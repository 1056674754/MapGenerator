(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// https://d3js.org/d3-quadtree/ v1.0.7 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function tree_add(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

exports.quadtree = quadtree;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],2:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.dat = {})));
}(this, (function (exports) { 'use strict';

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (!this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function ()        {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function ()        {
      dom.addClass(this, 'drag').bind(window, 'touchend', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller,                                   {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};

exports.color = color;
exports.controllers = controllers;
exports.dom = dom$1;
exports.gui = gui;
exports.GUI = GUI$1;
exports['default'] = index;

Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],3:[function(require,module,exports){
(function (global){
/* interact.js 1.9.8 | https://raw.github.com/taye/interact.js/master/LICENSE */
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).interact=t()}}(function(){function t(e){var n;return function(t){return n||e(n={exports:{},parent:t},n.exports),n.exports}}var k=t(function(t,e){"use strict";function a(t){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.Interactable=void 0;var u=r(S),l=n(C),s=n(V),c=n(ct),f=r(w),p=n(ft),i=n(bt),d=m({});function n(t){return t&&t.__esModule?t:{default:t}}function v(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return v=function(){return t},t}function r(t){if(t&&t.__esModule)return t;if(null===t||"object"!==a(t)&&"function"!=typeof t)return{default:t};var e=v();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function o(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function y(t,e,n){return e&&o(t.prototype,e),n&&o(t,n),t}function h(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var g=function(){function o(t,e,n,r){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),this._scopeEvents=r,h(this,"options",void 0),h(this,"_actions",void 0),h(this,"target",void 0),h(this,"events",new i.default),h(this,"_context",void 0),h(this,"_win",void 0),h(this,"_doc",void 0),this._actions=e.actions,this.target=t,this._context=e.context||n,this._win=(0,O.getWindow)((0,$.trySelector)(t)?this._context:t),this._doc=this._win.document,this.set(e)}return y(o,[{key:"_defaults",get:function(){return{base:{},perAction:{},actions:{}}}}]),y(o,[{key:"setOnEvents",value:function(t,e){return f.func(e.onstart)&&this.on("".concat(t,"start"),e.onstart),f.func(e.onmove)&&this.on("".concat(t,"move"),e.onmove),f.func(e.onend)&&this.on("".concat(t,"end"),e.onend),f.func(e.oninertiastart)&&this.on("".concat(t,"inertiastart"),e.oninertiastart),this}},{key:"updatePerActionListeners",value:function(t,e,n){(f.array(e)||f.object(e))&&this.off(t,e),(f.array(n)||f.object(n))&&this.on(t,n)}},{key:"setPerAction",value:function(t,e){var n=this._defaults;for(var r in e){var o=r,i=this.options[t],a=e[o];"listeners"===o&&this.updatePerActionListeners(t,i.listeners,a),f.array(a)?i[o]=u.from(a):f.plainObject(a)?(i[o]=(0,c.default)(i[o]||{},(0,s.default)(a)),f.object(n.perAction[o])&&"enabled"in n.perAction[o]&&(i[o].enabled=!1!==a.enabled)):f.bool(a)&&f.object(n.perAction[o])?i[o].enabled=a:i[o]=a}}},{key:"getRect",value:function(t){return t=t||(f.element(this.target)?this.target:null),f.string(this.target)&&(t=t||this._context.querySelector(this.target)),(0,$.getElementRect)(t)}},{key:"rectChecker",value:function(t){return f.func(t)?(this.getRect=t,this):null===t?(delete this.getRect,this):this.getRect}},{key:"_backCompatOption",value:function(t,e){if((0,$.trySelector)(e)||f.object(e)){for(var n in this.options[t]=e,this._actions.map)this.options[n][t]=e;return this}return this.options[t]}},{key:"origin",value:function(t){return this._backCompatOption("origin",t)}},{key:"deltaSource",value:function(t){return"page"===t||"client"===t?(this.options.deltaSource=t,this):this.options.deltaSource}},{key:"context",value:function(){return this._context}},{key:"inContext",value:function(t){return this._context===t.ownerDocument||(0,$.nodeContains)(this._context,t)}},{key:"testIgnoreAllow",value:function(t,e,n){return!this.testIgnore(t.ignoreFrom,e,n)&&this.testAllow(t.allowFrom,e,n)}},{key:"testAllow",value:function(t,e,n){return!t||!!f.element(n)&&(f.string(t)?(0,$.matchesUpTo)(n,t,e):!!f.element(t)&&(0,$.nodeContains)(t,n))}},{key:"testIgnore",value:function(t,e,n){return!(!t||!f.element(n))&&(f.string(t)?(0,$.matchesUpTo)(n,t,e):!!f.element(t)&&(0,$.nodeContains)(t,n))}},{key:"fire",value:function(t){return this.events.fire(t),this}},{key:"_onOff",value:function(t,e,n,r){f.object(e)&&!f.array(e)&&(r=n,n=null);var o="on"===t?"add":"remove",i=(0,p.default)(e,n);for(var a in i){"wheel"===a&&(a=l.default.wheelEvent);for(var u=0;u<i[a].length;u++){var s=i[a][u];(0,d.isNonNativeEvent)(a,this._actions)?this.events[t](a,s):f.string(this.target)?this._scopeEvents["".concat(o,"Delegate")](this.target,this._context,a,s,r):this._scopeEvents[o](this.target,a,s,r)}}return this}},{key:"on",value:function(t,e,n){return this._onOff("on",t,e,n)}},{key:"off",value:function(t,e,n){return this._onOff("off",t,e,n)}},{key:"set",value:function(t){var e=this._defaults;for(var n in f.object(t)||(t={}),this.options=(0,s.default)(e.base),this._actions.methodDict){var r=n,o=this._actions.methodDict[r];this.options[r]={},this.setPerAction(r,(0,c.default)((0,c.default)({},e.perAction),e.actions[r])),this[o](t[r])}for(var i in t)f.func(this[i])&&this[i](t[i]);return this}},{key:"unset",value:function(){if(f.string(this.target))for(var t in this._scopeEvents.delegatedEvents)for(var e=this._scopeEvents.delegatedEvents[t],n=e.length-1;0<=n;n--){var r=e[n],o=r.selector,i=r.context,a=r.listeners;o===this.target&&i===this._context&&e.splice(n,1);for(var u=a.length-1;0<=u;u--)this._scopeEvents.removeDelegate(this.target,this._context,t,a[u][0],a[u][1])}else this._scopeEvents.remove(this.target,"all")}}]),o}(),b=e.Interactable=g;e.default=b}),m=t(function(t,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNonNativeEvent=function(t,e){if(e.phaselessTypes[t])return!0;for(var n in e.map)if(0===t.indexOf(n)&&t.substr(n.length)in e.phases)return!0;return!1},e.initScope=M,e.Scope=e.default=void 0;var n=d(D),r=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==v(t)&&"function"!=typeof t)return{default:t};var e=p();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),o=d(bt),i=d(We),a=d(T({})),u=d(k({})),s=d(Ze),l=d(ze),c=d(cn),f=d(E({}));function p(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return p=function(){return t},t}function d(t){return t&&t.__esModule?t:{default:t}}function v(t){return(v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function y(t,e){return!e||"object"!==v(e)&&"function"!=typeof e?function(t){if(void 0!==t)return t;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(t):e}function h(t,e,n){return(h="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=g(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function g(t){return(g=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function b(t,e){return(b=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function m(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function O(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function w(t,e,n){return e&&O(t.prototype,e),n&&O(t,n),t}function _(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var P=r.win,x=r.browser,S=r.raf,j=function(){function t(){var e=this;m(this,t),_(this,"id","__interact_scope_".concat(Math.floor(100*Math.random()))),_(this,"isInitialized",!1),_(this,"listenerMaps",[]),_(this,"browser",x),_(this,"utils",r),_(this,"defaults",r.clone(l.default)),_(this,"Eventable",o.default),_(this,"actions",{map:{},phases:{start:!0,move:!0,end:!0},methodDict:{},phaselessTypes:{}}),_(this,"interactStatic",new a.default(this)),_(this,"InteractEvent",i.default),_(this,"Interactable",void 0),_(this,"interactables",new s.default(this)),_(this,"_win",void 0),_(this,"document",void 0),_(this,"window",void 0),_(this,"documents",[]),_(this,"_plugins",{list:[],map:{}}),_(this,"onWindowUnload",function(t){return e.removeDocument(t.target)});var n=this;this.Interactable=function(){function e(){return m(this,e),y(this,g(e).apply(this,arguments))}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&b(t,e)}(e,u["default"]),w(e,[{key:"set",value:function(t){return h(g(e.prototype),"set",this).call(this,t),n.fire("interactable:set",{options:t,interactable:this}),this}},{key:"unset",value:function(){h(g(e.prototype),"unset",this).call(this),n.interactables.list.splice(n.interactables.list.indexOf(this),1),n.fire("interactable:unset",{interactable:this})}},{key:"_defaults",get:function(){return n.defaults}}]),e}()}return w(t,[{key:"addListeners",value:function(t,e){this.listenerMaps.push({id:e,map:t})}},{key:"fire",value:function(t,e){for(var n=0;n<this.listenerMaps.length;n++){var r=this.listenerMaps[n].map[t];if(r&&!1===r(e,this,t))return!1}}},{key:"init",value:function(t){return this.isInitialized?this:M(this,t)}},{key:"pluginIsInstalled",value:function(t){return this._plugins.map[t.id]||-1!==this._plugins.list.indexOf(t)}},{key:"usePlugin",value:function(t,e){if(this.pluginIsInstalled(t))return this;if(t.id&&(this._plugins.map[t.id]=t),this._plugins.list.push(t),t.install&&t.install(this,e),t.listeners&&t.before){for(var n=0,r=this.listenerMaps.length,o=t.before.reduce(function(t,e){return t[e]=!0,t},{});n<r;n++){if(o[this.listenerMaps[n].id])break}this.listenerMaps.splice(n,0,{id:t.id,map:t.listeners})}else t.listeners&&this.listenerMaps.push({id:t.id,map:t.listeners});return this}},{key:"addDocument",value:function(t,e){if(-1!==this.getDocIndex(t))return!1;var n=P.getWindow(t);e=e?r.extend({},e):{},this.documents.push({doc:t,options:e}),this.events.documents.push(t),t!==this.document&&this.events.add(n,"unload",this.onWindowUnload),this.fire("scope:add-document",{doc:t,window:n,scope:this,options:e})}},{key:"removeDocument",value:function(t){var e=this.getDocIndex(t),n=P.getWindow(t),r=this.documents[e].options;this.events.remove(n,"unload",this.onWindowUnload),this.documents.splice(e,1),this.events.documents.splice(e,1),this.fire("scope:remove-document",{doc:t,window:n,scope:this,options:r})}},{key:"getDocIndex",value:function(t){for(var e=0;e<this.documents.length;e++)if(this.documents[e].doc===t)return e;return-1}},{key:"getDocOptions",value:function(t){var e=this.getDocIndex(t);return-1===e?null:this.documents[e].options}},{key:"now",value:function(){return(this.window.Date||Date).now()}}]),t}();function M(t,e){return t.isInitialized=!0,P.init(e),n.default.init(e),x.init(e),S.init(e),t.window=e,t.document=e.document,t.usePlugin(f.default),t.usePlugin(c.default),t}e.Scope=e.default=j}),E=t(function(t,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var _=n(C),u=n(D),P=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==c(t)&&"function"!=typeof t)return{default:t};var e=a();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(zt),s=n(En),l=n(Un),o=n(tr);n(m({}));function a(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return a=function(){return t},t}function n(t){return t&&t.__esModule?t:{default:t}}function c(t){return(c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function x(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function f(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function p(t,e){return!e||"object"!==c(e)&&"function"!=typeof e?function(t){if(void 0!==t)return t;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(t):e}function d(t){return(d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function v(t,e){return(v=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var y=["pointerDown","pointerMove","pointerUp","updatePointer","removePointer","windowBlur"];function h(O,w){return function(t){var e=w.interactions.list,n=P.getPointerType(t),r=x(P.getEventTargets(t),2),o=r[0],i=r[1],a=[];if(/^touch/.test(t.type)){w.prevTouchTime=w.now();for(var u=0;u<t.changedTouches.length;u++){s=t.changedTouches[u];var s,l={pointer:s,pointerId:P.getPointerId(s),pointerType:n,eventType:t.type,eventTarget:o,curEventTarget:i,scope:w},c=S(l);a.push([l.pointer,l.eventTarget,l.curEventTarget,c])}}else{var f=!1;if(!_.default.supportsPointerEvent&&/mouse/.test(t.type)){for(var p=0;p<e.length&&!f;p++)f="mouse"!==e[p].pointerType&&e[p].pointerIsDown;f=f||w.now()-w.prevTouchTime<500||0===t.timeStamp}if(!f){var d={pointer:t,pointerId:P.getPointerId(t),pointerType:n,eventType:t.type,curEventTarget:i,eventTarget:o,scope:w},v=S(d);a.push([d.pointer,d.eventTarget,d.curEventTarget,v])}}for(var y=0;y<a.length;y++){var h=x(a[y],4),g=h[0],b=h[1],m=h[2];h[3][O](g,t,b,m)}}}function S(t){var e=t.pointerType,n=t.scope,r={interaction:o.default.search(t),searchDetails:t};return n.fire("interactions:find",r),r.interaction||n.interactions.new({pointerType:e})}function r(t,e){var n=t.doc,r=t.scope,o=t.options,i=r.interactions.docEvents,a=r.events,u=a[e];for(var s in r.browser.isIOS&&!o.events&&(o.events={passive:!1}),a.delegatedEvents)u(n,s,a.delegateListener),u(n,s,a.delegateUseCapture,!0);for(var l=o&&o.events,c=0;c<i.length;c++){var f;f=i[c];u(n,f.type,f.listener,l)}}var i={id:"core/interactions",install:function(o){for(var t={},e=0;e<y.length;e++){var n;n=y[e];t[n]=h(n,o)}var r,i=_.default.pEventTypes;function a(){for(var t=0;t<o.interactions.list.length;t++){var e=o.interactions.list[t];if(e.pointerIsDown&&"touch"===e.pointerType&&!e._interacting)for(var n=function(){var n=e.pointers[r];o.documents.some(function(t){var e=t.doc;return(0,$.nodeContains)(e,n.downTarget)})||e.removePointer(n.pointer,n.event)},r=0;r<e.pointers.length;r++){n()}}}(r=u.default.PointerEvent?[{type:i.down,listener:a},{type:i.down,listener:t.pointerDown},{type:i.move,listener:t.pointerMove},{type:i.up,listener:t.pointerUp},{type:i.cancel,listener:t.pointerUp}]:[{type:"mousedown",listener:t.pointerDown},{type:"mousemove",listener:t.pointerMove},{type:"mouseup",listener:t.pointerUp},{type:"touchstart",listener:a},{type:"touchstart",listener:t.pointerDown},{type:"touchmove",listener:t.pointerMove},{type:"touchend",listener:t.pointerUp},{type:"touchcancel",listener:t.pointerUp}]).push({type:"blur",listener:function(t){for(var e=0;e<o.interactions.list.length;e++){o.interactions.list[e].documentBlur(t)}}}),o.prevTouchTime=0,o.Interaction=function(){function t(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),p(this,d(t).apply(this,arguments))}var e,n,r;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&v(t,e)}(t,s["default"]),e=t,(n=[{key:"_now",value:function(){return o.now()}},{key:"pointerMoveTolerance",get:function(){return o.interactions.pointerMoveTolerance},set:function(t){o.interactions.pointerMoveTolerance=t}}])&&f(e.prototype,n),r&&f(e,r),t}(),o.interactions={list:[],new:function(t){t.scopeFire=function(t,e){return o.fire(t,e)};var e=new o.Interaction(t);return o.interactions.list.push(e),e},listeners:t,docEvents:r,pointerMoveTolerance:1},o.usePlugin(l.default)},listeners:{"scope:add-document":function(t){return r(t,"add")},"scope:remove-document":function(t){return r(t,"remove")},"interactable:unset":function(t,e){for(var n=t.interactable,r=e.interactions.list.length-1;0<=r;r--){var o=e.interactions.list[r];o.interactable===n&&(o.stop(),e.fire("interactions:destroy",{interaction:o}),o.destroy(),2<e.interactions.list.length&&e.interactions.list.splice(r,1))}}},onDocSignal:r,doOnInteractions:h,methodNames:y};e.default=i}),T=t(function(t,e){"use strict";function a(t){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.InteractStatic=void 0;var n,r=(n=C)&&n.__esModule?n:{default:n},u=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==a(t)&&"function"!=typeof t)return{default:t};var e=l();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),s=m({});function l(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return l=function(){return t},t}function o(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function c(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var i=function(){function a(r){var o=this;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,a),this.scope=r,c(this,"getPointerAverage",u.pointer.pointerAverage),c(this,"getTouchBBox",u.pointer.touchBBox),c(this,"getTouchDistance",u.pointer.touchDistance),c(this,"getTouchAngle",u.pointer.touchAngle),c(this,"getElementRect",u.dom.getElementRect),c(this,"getElementClientRect",u.dom.getElementClientRect),c(this,"matchesSelector",u.dom.matchesSelector),c(this,"closest",u.dom.closest),c(this,"globalEvents",{}),c(this,"dynamicDrop",void 0),c(this,"version","1.9.8"),c(this,"interact",void 0);for(var t=this.constructor.prototype,e=function(t,e){var n=r.interactables.get(t,e);return n||((n=r.interactables.new(t,e)).events.global=o.globalEvents),n},n=0;n<Object.getOwnPropertyNames(this.constructor.prototype).length;n++){var i;i=Object.getOwnPropertyNames(this.constructor.prototype)[n];e[i]=t[i]}return u.extend(e,this),e.constructor=this.constructor,this.interact=e}var t,e,n;return t=a,(e=[{key:"use",value:function(t,e){return this.scope.usePlugin(t,e),this}},{key:"isSet",value:function(t,e){return!!this.scope.interactables.get(t,e&&e.context)}},{key:"on",value:function(t,e,n){if(u.is.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),u.is.array(t)){for(var r=0;r<t.length;r++){var o=t[r];this.on(o,e,n)}return this}if(u.is.object(t)){for(var i in t)this.on(i,t[i],e);return this}return(0,s.isNonNativeEvent)(t,this.scope.actions)?this.globalEvents[t]?this.globalEvents[t].push(e):this.globalEvents[t]=[e]:this.scope.events.add(this.scope.document,t,e,{options:n}),this}},{key:"off",value:function(t,e,n){if(u.is.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),u.is.array(t)){for(var r=0;r<t.length;r++){var o=t[r];this.off(o,e,n)}return this}if(u.is.object(t)){for(var i in t)this.off(i,t[i],e);return this}var a;(0,s.isNonNativeEvent)(t,this.scope.actions)?t in this.globalEvents&&-1!==(a=this.globalEvents[t].indexOf(e))&&this.globalEvents[t].splice(a,1):this.scope.events.remove(this.scope.document,t,e,n);return this}},{key:"debug",value:function(){return this.scope}},{key:"supportsTouch",value:function(){return r.default.supportsTouch}},{key:"supportsPointerEvent",value:function(){return r.default.supportsPointerEvent}},{key:"stop",value:function(){for(var t=0;t<this.scope.interactions.list.length;t++){this.scope.interactions.list[t].stop()}return this}},{key:"pointerMoveTolerance",value:function(t){return u.is.number(t)?(this.scope.interactions.pointerMoveTolerance=t,this):this.scope.interactions.pointerMoveTolerance}},{key:"addDocument",value:function(t,e){this.scope.addDocument(t,e)}},{key:"removeDocument",value:function(t){this.scope.removeDocument(t)}}])&&o(t.prototype,e),n&&o(t,n),a}(),f=e.InteractStatic=i;e.default=f}),e={};Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;e.default=function(t){return!(!t||!t.Window)&&t instanceof t.Window};var O={};Object.defineProperty(O,"__esModule",{value:!0}),O.init=i,O.getWindow=a,O.default=void 0;var n,r=(n=e)&&n.__esModule?n:{default:n};var o={realWindow:void 0,window:void 0,getWindow:a,init:i};function i(t){var e=(o.realWindow=t).document.createTextNode("");e.ownerDocument!==t.document&&"function"==typeof t.wrap&&t.wrap(e)===e&&(t=t.wrap(t)),o.window=t}function a(t){return(0,r.default)(t)?t:(t.ownerDocument||t).defaultView||o.window}"undefined"==typeof window?(o.window=void 0,o.realWindow=void 0):i(window),o.init=i;var u=o;O.default=u;var w={};Object.defineProperty(w,"__esModule",{value:!0}),w.array=w.plainObject=w.element=w.string=w.bool=w.number=w.func=w.object=w.docFrag=w.window=void 0;var s=c(e),l=c(O);function c(t){return t&&t.__esModule?t:{default:t}}function f(t){return(f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}w.window=function(t){return t===l.default.window||(0,s.default)(t)};w.docFrag=function(t){return p(t)&&11===t.nodeType};var p=function(t){return!!t&&"object"===f(t)};w.object=p;function d(t){return"function"==typeof t}w.func=d;w.number=function(t){return"number"==typeof t};w.bool=function(t){return"boolean"==typeof t};w.string=function(t){return"string"==typeof t};w.element=function(t){if(!t||"object"!==f(t))return!1;var e=l.default.getWindow(t)||l.default.window;return/object|function/.test(f(e.Element))?t instanceof e.Element:1===t.nodeType&&"string"==typeof t.nodeName};w.plainObject=function(t){return p(t)&&!!t.constructor&&/function Object\b/.test(t.constructor.toString())};w.array=function(t){return p(t)&&void 0!==t.length&&d(t.splice)};var v={};function y(t){return(y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(v,"__esModule",{value:!0}),v.default=void 0;var h=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==y(t)&&"function"!=typeof t)return{default:t};var e=g();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function g(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return g=function(){return t},t}function b(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.prepared.axis;"x"===n?(e.coords.cur.page.y=e.coords.start.page.y,e.coords.cur.client.y=e.coords.start.client.y,e.coords.velocity.client.y=0,e.coords.velocity.page.y=0):"y"===n&&(e.coords.cur.page.x=e.coords.start.page.x,e.coords.cur.client.x=e.coords.start.client.x,e.coords.velocity.client.x=0,e.coords.velocity.page.x=0)}}function _(t){var e=t.iEvent,n=t.interaction;if("drag"===n.prepared.name){var r=n.prepared.axis;if("x"===r||"y"===r){var o="x"===r?"y":"x";e.page[o]=n.coords.start.page[o],e.client[o]=n.coords.start.client[o],e.delta[o]=0}}}var P={id:"actions/drag",install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.draggable=P.draggable,e.map.drag=P,e.methodDict.drag="draggable",r.actions.drag=P.defaults},listeners:{"interactions:before-action-move":b,"interactions:action-resume":b,"interactions:action-move":_,"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.buttons,o=n.options.drag;if(o&&o.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(r&n.options.drag.mouseButtons)))return!(t.action={name:"drag",axis:"start"===o.lockAxis?o.startAxis:o.lockAxis})}},draggable:function(t){return h.object(t)?(this.options.drag.enabled=!1!==t.enabled,this.setPerAction("drag",t),this.setOnEvents("drag",t),/^(xy|x|y|start)$/.test(t.lockAxis)&&(this.options.drag.lockAxis=t.lockAxis),/^(xy|x|y)$/.test(t.startAxis)&&(this.options.drag.startAxis=t.startAxis),this):h.bool(t)?(this.options.drag.enabled=t,this):this.options.drag},beforeMove:b,move:_,defaults:{startAxis:"xy",lockAxis:"xy"},getCursor:function(){return"move"}},x=P;v.default=x;var S={};Object.defineProperty(S,"__esModule",{value:!0}),S.find=S.findIndex=S.from=S.merge=S.remove=S.contains=void 0;S.contains=function(t,e){return-1!==t.indexOf(e)};S.remove=function(t,e){return t.splice(t.indexOf(e),1)};function j(t,e){for(var n=0;n<e.length;n++){var r=e[n];t.push(r)}return t}S.merge=j;S.from=function(t){return j([],t)};function M(t,e){for(var n=0;n<t.length;n++)if(e(t[n],n,t))return n;return-1}S.findIndex=M;S.find=function(t,e){return t[M(t,e)]};var D={};Object.defineProperty(D,"__esModule",{value:!0}),D.default=void 0;var I={init:function(t){var e=t;I.document=e.document,I.DocumentFragment=e.DocumentFragment||z,I.SVGElement=e.SVGElement||z,I.SVGSVGElement=e.SVGSVGElement||z,I.SVGElementInstance=e.SVGElementInstance||z,I.Element=e.Element||z,I.HTMLElement=e.HTMLElement||I.Element,I.Event=e.Event,I.Touch=e.Touch||z,I.PointerEvent=e.PointerEvent||e.MSPointerEvent},document:null,DocumentFragment:null,SVGElement:null,SVGSVGElement:null,SVGElementInstance:null,Element:null,HTMLElement:null,Event:null,Touch:null,PointerEvent:null};function z(){}var A=I;D.default=A;var C={};function W(t){return(W="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(C,"__esModule",{value:!0}),C.default=void 0;var R=N(D),F=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==W(t)&&"function"!=typeof t)return{default:t};var e=Y();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w),X=N(O);function Y(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Y=function(){return t},t}function N(t){return t&&t.__esModule?t:{default:t}}var L={init:function(t){var e=R.default.Element,n=X.default.window.navigator;L.supportsTouch="ontouchstart"in t||F.func(t.DocumentTouch)&&R.default.document instanceof t.DocumentTouch,L.supportsPointerEvent=!1!==n.pointerEnabled&&!!R.default.PointerEvent,L.isIOS=/iP(hone|od|ad)/.test(n.platform),L.isIOS7=/iP(hone|od|ad)/.test(n.platform)&&/OS 7[^\d]/.test(n.appVersion),L.isIe9=/MSIE 9/.test(n.userAgent),L.isOperaMobile="Opera"===n.appName&&L.supportsTouch&&/Presto/.test(n.userAgent),L.prefixedMatchesSelector="matches"in e.prototype?"matches":"webkitMatchesSelector"in e.prototype?"webkitMatchesSelector":"mozMatchesSelector"in e.prototype?"mozMatchesSelector":"oMatchesSelector"in e.prototype?"oMatchesSelector":"msMatchesSelector",L.pEventTypes=L.supportsPointerEvent?R.default.PointerEvent===t.MSPointerEvent?{up:"MSPointerUp",down:"MSPointerDown",over:"mouseover",out:"mouseout",move:"MSPointerMove",cancel:"MSPointerCancel"}:{up:"pointerup",down:"pointerdown",over:"pointerover",out:"pointerout",move:"pointermove",cancel:"pointercancel"}:null,L.wheelEvent="onmousewheel"in R.default.document?"mousewheel":"wheel"},supportsTouch:null,supportsPointerEvent:null,isIOS7:null,isIOS:null,isIe9:null,isOperaMobile:null,prefixedMatchesSelector:null,pEventTypes:null,wheelEvent:null};var B=L;C.default=B;var V={};function q(t){return(q="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(V,"__esModule",{value:!0}),V.default=function t(e){var n={};for(var r in e){var o=e[r];G.plainObject(o)?n[r]=t(o):G.array(o)?n[r]=U.from(o):n[r]=o}return n};var U=K(S),G=K(w);function H(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return H=function(){return t},t}function K(t){if(t&&t.__esModule)return t;if(null===t||"object"!==q(t)&&"function"!=typeof t)return{default:t};var e=H();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}var $={};function Z(t){return(Z="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty($,"__esModule",{value:!0}),$.nodeContains=function(t,e){for(;e;){if(e===t)return!0;e=e.parentNode}return!1},$.closest=function(t,e){for(;tt.element(t);){if(at(t,e))return t;t=it(t)}return null},$.parentNode=it,$.matchesSelector=at,$.indexOfDeepestElement=function(t){var e,n,r=[],o=t[0],i=o?0:-1;for(e=1;e<t.length;e++){var a=t[e];if(a&&a!==o)if(o){if(a.parentNode!==a.ownerDocument)if(o.parentNode!==a.ownerDocument)if(a.parentNode!==o.parentNode){if(!r.length)for(var u=o,s=void 0;(s=ut(u))&&s!==u.ownerDocument;)r.unshift(u),u=s;var l=void 0;if(o instanceof Q.default.HTMLElement&&a instanceof Q.default.SVGElement&&!(a instanceof Q.default.SVGSVGElement)){if(a===o.parentNode)continue;l=a.ownerSVGElement}else l=a;for(var c=[];l.parentNode!==l.ownerDocument;)c.unshift(l),l=ut(l);for(n=0;c[n]&&c[n]===r[n];)n++;for(var f=[c[n-1],c[n],r[n]],p=f[0].lastChild;p;){if(p===f[1]){o=a,i=e,r=c;break}if(p===f[2])break;p=p.previousSibling}}else{var d=parseInt((0,et.getWindow)(o).getComputedStyle(o).zIndex,10)||0,v=parseInt((0,et.getWindow)(a).getComputedStyle(a).zIndex,10)||0;d<=v&&(o=a,i=e)}else o=a,i=e}else o=a,i=e}return i},$.matchesUpTo=function(t,e,n){for(;tt.element(t);){if(at(t,e))return!0;if((t=it(t))===n)return at(t,e)}return!1},$.getActualElement=function(t){return t instanceof Q.default.SVGElementInstance?t.correspondingUseElement:t},$.getScrollXY=st,$.getElementClientRect=lt,$.getElementRect=function(t){var e=lt(t);if(!J.default.isIOS7&&e){var n=st(et.default.getWindow(t));e.left+=n.x,e.right+=n.x,e.top+=n.y,e.bottom+=n.y}return e},$.getPath=function(t){var e=[];for(;t;)e.push(t),t=it(t);return e},$.trySelector=function(t){return!!tt.string(t)&&(Q.default.document.querySelector(t),!0)};var J=ot(C),Q=ot(D),tt=rt(w),et=rt(O);function nt(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return nt=function(){return t},t}function rt(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Z(t)&&"function"!=typeof t)return{default:t};var e=nt();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function ot(t){return t&&t.__esModule?t:{default:t}}function it(t){var e=t.parentNode;if(tt.docFrag(e)){for(;(e=e.host)&&tt.docFrag(e););return e}return e}function at(t,e){return et.default.window!==et.default.realWindow&&(e=e.replace(/\/deep\//g," ")),t[J.default.prefixedMatchesSelector](e)}var ut=function(t){return t.parentNode?t.parentNode:t.host};function st(t){return{x:(t=t||et.default.window).scrollX||t.document.documentElement.scrollLeft,y:t.scrollY||t.document.documentElement.scrollTop}}function lt(t){var e=t instanceof Q.default.SVGElement?t.getBoundingClientRect():t.getClientRects()[0];return e&&{left:e.left,right:e.right,top:e.top,bottom:e.bottom,width:e.width||e.right-e.left,height:e.height||e.bottom-e.top}}var ct={};Object.defineProperty(ct,"__esModule",{value:!0}),ct.default=function(t,e){for(var n in e)t[n]=e[n];return t};var ft={};function pt(t){return(pt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(ft,"__esModule",{value:!0}),ft.default=function n(e,r,o){o=o||{};yt.string(e)&&-1!==e.search(" ")&&(e=gt(e));if(yt.array(e))return e.reduce(function(t,e){return(0,vt.default)(t,n(e,r,o))},o);yt.object(e)&&(r=e,e="");if(yt.func(r))o[e]=o[e]||[],o[e].push(r);else if(yt.array(r))for(var t=0;t<r.length;t++){var i=r[t];n(e,i,o)}else if(yt.object(r))for(var a in r){var u=gt(a).map(function(t){return"".concat(e).concat(t)});n(u,r[a],o)}return o};var dt,vt=(dt=ct)&&dt.__esModule?dt:{default:dt},yt=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==pt(t)&&"function"!=typeof t)return{default:t};var e=ht();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function ht(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ht=function(){return t},t}function gt(t){return t.trim().split(/ +/)}var bt={};function mt(t){return(mt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(bt,"__esModule",{value:!0}),bt.default=void 0;var Ot=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==mt(t)&&"function"!=typeof t)return{default:t};var e=xt();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(S),wt=Pt(ct),_t=Pt(ft);function Pt(t){return t&&t.__esModule?t:{default:t}}function xt(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return xt=function(){return t},t}function St(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function jt(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function Mt(t,e){for(var n=0;n<e.length;n++){var r=e[n];if(t.immediatePropagationStopped)break;r(t)}}var kt=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),jt(this,"options",void 0),jt(this,"types",{}),jt(this,"propagationStopped",!1),jt(this,"immediatePropagationStopped",!1),jt(this,"global",void 0),this.options=(0,wt.default)({},t||{})}var t,n,r;return t=e,(n=[{key:"fire",value:function(t){var e,n=this.global;(e=this.types[t.type])&&Mt(t,e),!t.propagationStopped&&n&&(e=n[t.type])&&Mt(t,e)}},{key:"on",value:function(t,e){var n=(0,_t.default)(t,e);for(t in n)this.types[t]=Ot.merge(this.types[t]||[],n[t])}},{key:"off",value:function(t,e){var n=(0,_t.default)(t,e);for(t in n){var r=this.types[t];if(r&&r.length)for(var o=0;o<n[t].length;o++){var i=n[t][o],a=r.indexOf(i);-1!==a&&r.splice(a,1)}}}},{key:"getRect",value:function(){return null}}])&&St(t.prototype,n),r&&St(t,r),e}();bt.default=kt;var Et={};Object.defineProperty(Et,"__esModule",{value:!0}),Et.default=void 0;Et.default=function(t,e){return Math.sqrt(t*t+e*e)};var Tt={};function Dt(t,e){for(var n in e){var r=Dt.prefixedPropREs,o=!1;for(var i in r)if(0===n.indexOf(i)&&r[i].test(n)){o=!0;break}o||"function"==typeof e[n]||(t[n]=e[n])}return t}Object.defineProperty(Tt,"__esModule",{value:!0}),Tt.default=void 0,Dt.prefixedPropREs={webkit:/(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,moz:/(Pressure)$/};var It=Dt;Tt.default=It;var zt={};function At(t){return(At="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(zt,"__esModule",{value:!0}),zt.copyCoords=function(t,e){t.page=t.page||{},t.page.x=e.page.x,t.page.y=e.page.y,t.client=t.client||{},t.client.x=e.client.x,t.client.y=e.client.y,t.timeStamp=e.timeStamp},zt.setCoordDeltas=function(t,e,n){t.page.x=n.page.x-e.page.x,t.page.y=n.page.y-e.page.y,t.client.x=n.client.x-e.client.x,t.client.y=n.client.y-e.client.y,t.timeStamp=n.timeStamp-e.timeStamp},zt.setCoordVelocity=function(t,e){var n=Math.max(e.timeStamp/1e3,.001);t.page.x=e.page.x/n,t.page.y=e.page.y/n,t.client.x=e.client.x/n,t.client.y=e.client.y/n,t.timeStamp=n},zt.setZeroCoords=function(t){t.page.x=0,t.page.y=0,t.client.x=0,t.client.y=0},zt.isNativePointer=Vt,zt.getXY=qt,zt.getPageXY=Ut,zt.getClientXY=Gt,zt.getPointerId=function(t){return Xt.number(t.pointerId)?t.pointerId:t.identifier},zt.setCoords=function(t,e,n){var r=1<e.length?Kt(e):e[0],o={};Ut(r,o),t.page.x=o.x,t.page.y=o.y,Gt(r,o),t.client.x=o.x,t.client.y=o.y,t.timeStamp=n},zt.getTouchPair=Ht,zt.pointerAverage=Kt,zt.touchBBox=function(t){if(!(t.length||t.touches&&1<t.touches.length))return null;var e=Ht(t),n=Math.min(e[0].pageX,e[1].pageX),r=Math.min(e[0].pageY,e[1].pageY),o=Math.max(e[0].pageX,e[1].pageX),i=Math.max(e[0].pageY,e[1].pageY);return{x:n,y:r,left:n,top:r,right:o,bottom:i,width:o-n,height:i-r}},zt.touchDistance=function(t,e){var n=e+"X",r=e+"Y",o=Ht(t),i=o[0][n]-o[1][n],a=o[0][r]-o[1][r];return(0,Ft.default)(i,a)},zt.touchAngle=function(t,e){var n=e+"X",r=e+"Y",o=Ht(t),i=o[1][n]-o[0][n],a=o[1][r]-o[0][r];return 180*Math.atan2(a,i)/Math.PI},zt.getPointerType=function(t){return Xt.string(t.pointerType)?t.pointerType:Xt.number(t.pointerType)?[void 0,void 0,"touch","pen","mouse"][t.pointerType]:/touch/.test(t.type)||t instanceof Wt.default.Touch?"touch":"mouse"},zt.getEventTargets=function(t){var e=Xt.func(t.composedPath)?t.composedPath():t.path;return[Rt.getActualElement(e?e[0]:t.target),Rt.getActualElement(t.currentTarget)]},zt.newCoords=function(){return{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0}},zt.coordsToEvent=function(t){return{coords:t,get page(){return this.coords.page},get client(){return this.coords.client},get timeStamp(){return this.coords.timeStamp},get pageX(){return this.coords.page.x},get pageY(){return this.coords.page.y},get clientX(){return this.coords.client.x},get clientY(){return this.coords.client.y},get pointerId(){return this.coords.pointerId},get target(){return this.coords.target},get type(){return this.coords.type},get pointerType(){return this.coords.pointerType},get buttons(){return this.coords.buttons},preventDefault:function(){}}},Object.defineProperty(zt,"pointerExtend",{enumerable:!0,get:function(){return Yt.default}});var Ct=Bt(C),Wt=Bt(D),Rt=Lt($),Ft=Bt(Et),Xt=Lt(w),Yt=Bt(Tt);function Nt(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Nt=function(){return t},t}function Lt(t){if(t&&t.__esModule)return t;if(null===t||"object"!==At(t)&&"function"!=typeof t)return{default:t};var e=Nt();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function Bt(t){return t&&t.__esModule?t:{default:t}}function Vt(t){return t instanceof Wt.default.Event||t instanceof Wt.default.Touch}function qt(t,e,n){return(n=n||{}).x=e[(t=t||"page")+"X"],n.y=e[t+"Y"],n}function Ut(t,e){return e=e||{x:0,y:0},Ct.default.isOperaMobile&&Vt(t)?(qt("screen",t,e),e.x+=window.scrollX,e.y+=window.scrollY):qt("page",t,e),e}function Gt(t,e){return e=e||{},Ct.default.isOperaMobile&&Vt(t)?qt("screen",t,e):qt("client",t,e),e}function Ht(t){var e=[];return Xt.array(t)?(e[0]=t[0],e[1]=t[1]):"touchend"===t.type?1===t.touches.length?(e[0]=t.touches[0],e[1]=t.changedTouches[0]):0===t.touches.length&&(e[0]=t.changedTouches[0],e[1]=t.changedTouches[1]):(e[0]=t.touches[0],e[1]=t.touches[1]),e}function Kt(t){for(var e={pageX:0,pageY:0,clientX:0,clientY:0,screenX:0,screenY:0},n=0;n<t.length;n++){var r=t[n];for(var o in e)e[o]+=r[o]}for(var i in e)e[i]/=t.length;return e}var $t={};function Zt(t){return(Zt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty($t,"__esModule",{value:!0}),$t.getStringOptionResult=ne,$t.resolveRectLike=function(t,e,n,r){var o=t;te.string(o)?o=ne(o,e,n):te.func(o)&&(o=o.apply(void 0,function(t){return function(t){if(Array.isArray(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}}(t)||function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}(r)));te.element(o)&&(o=(0,$.getElementRect)(o));return o},$t.rectToXY=function(t){return t&&{x:"x"in t?t.x:t.left,y:"y"in t?t.y:t.top}},$t.xywhToTlbr=function(t){!t||"left"in t&&"top"in t||((t=(0,Qt.default)({},t)).left=t.x||0,t.top=t.y||0,t.right=t.right||t.left+t.width,t.bottom=t.bottom||t.top+t.height);return t},$t.tlbrToXywh=function(t){!t||"x"in t&&"y"in t||((t=(0,Qt.default)({},t)).x=t.left||0,t.y=t.top||0,t.width=t.width||t.right||0-t.x,t.height=t.height||t.bottom||0-t.y);return t},$t.addEdges=function(t,e,n){t.left&&(e.left+=n.x);t.right&&(e.right+=n.x);t.top&&(e.top+=n.y);t.bottom&&(e.bottom+=n.y);e.width=e.right-e.left,e.height=e.bottom-e.top};var Jt,Qt=(Jt=ct)&&Jt.__esModule?Jt:{default:Jt},te=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Zt(t)&&"function"!=typeof t)return{default:t};var e=ee();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function ee(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ee=function(){return t},t}function ne(t,e,n){return"parent"===t?(0,$.parentNode)(n):"self"===t?e.getRect(n):(0,$.closest)(n,t)}var re={};Object.defineProperty(re,"__esModule",{value:!0}),re.default=function(t,e,n){var r=t.options[n],o=r&&r.origin||t.options.origin,i=(0,$t.resolveRectLike)(o,t,e,[t&&e]);return(0,$t.rectToXY)(i)||{x:0,y:0}};var oe={};Object.defineProperty(oe,"__esModule",{value:!0}),oe.default=void 0;var ie,ae,ue=0;var se={request:function(t){return ie(t)},cancel:function(t){return ae(t)},init:function(t){if(ie=t.requestAnimationFrame,ae=t.cancelAnimationFrame,!ie)for(var e=["ms","moz","webkit","o"],n=0;n<e.length;n++){var r=e[n];ie=t["".concat(r,"RequestAnimationFrame")],ae=t["".concat(r,"CancelAnimationFrame")]||t["".concat(r,"CancelRequestAnimationFrame")]}ie||(ie=function(t){var e=Date.now(),n=Math.max(0,16-(e-ue)),r=setTimeout(function(){t(e+n)},n);return ue=e+n,r},ae=function(t){return clearTimeout(t)})}};oe.default=se;var le={};function ce(t){return(ce="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(le,"__esModule",{value:!0}),le.warnOnce=function(t,e){var n=!1;return function(){return n||(he.default.window.console.warn(e),n=!0),t.apply(this,arguments)}},le.copyAction=function(t,e){return t.name=e.name,t.axis=e.axis,t.edges=e.edges,t},Object.defineProperty(le,"win",{enumerable:!0,get:function(){return he.default}}),Object.defineProperty(le,"browser",{enumerable:!0,get:function(){return ge.default}}),Object.defineProperty(le,"clone",{enumerable:!0,get:function(){return be.default}}),Object.defineProperty(le,"extend",{enumerable:!0,get:function(){return me.default}}),Object.defineProperty(le,"getOriginXY",{enumerable:!0,get:function(){return Oe.default}}),Object.defineProperty(le,"hypot",{enumerable:!0,get:function(){return we.default}}),Object.defineProperty(le,"normalizeListeners",{enumerable:!0,get:function(){return _e.default}}),Object.defineProperty(le,"raf",{enumerable:!0,get:function(){return Pe.default}}),le.rect=le.pointer=le.is=le.dom=le.arr=void 0;var fe=je(S);le.arr=fe;var pe=je($);le.dom=pe;var de=je(w);le.is=de;var ve=je(zt);le.pointer=ve;var ye=je($t);le.rect=ye;var he=xe(O),ge=xe(C),be=xe(V),me=xe(ct),Oe=xe(re),we=xe(Et),_e=xe(ft),Pe=xe(oe);function xe(t){return t&&t.__esModule?t:{default:t}}function Se(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Se=function(){return t},t}function je(t){if(t&&t.__esModule)return t;if(null===t||"object"!==ce(t)&&"function"!=typeof t)return{default:t};var e=Se();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}var Me={};function ke(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Ee(t,e,n){return e&&ke(t.prototype,e),n&&ke(t,n),t}function Te(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}Object.defineProperty(Me,"__esModule",{value:!0}),Me.default=Me.BaseEvent=void 0;var De=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Te(this,"type",void 0),Te(this,"target",void 0),Te(this,"currentTarget",void 0),Te(this,"interactable",void 0),Te(this,"_interaction",void 0),Te(this,"timeStamp",void 0),Te(this,"immediatePropagationStopped",!1),Te(this,"propagationStopped",!1),this._interaction=t}return Ee(e,[{key:"interaction",get:function(){return this._interaction._proxy}}]),Ee(e,[{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}]),e}(),Ie=Me.BaseEvent=De;Me.default=Ie;var ze={};Object.defineProperty(ze,"__esModule",{value:!0}),ze.default=ze.defaults=void 0;var Ae={base:{preventDefault:"auto",deltaSource:"page"},perAction:{enabled:!1,origin:{x:0,y:0}},actions:{}},Ce=ze.defaults=Ae;ze.default=Ce;var We={};Object.defineProperty(We,"__esModule",{value:!0}),We.default=We.InteractEvent=void 0;var Re=Le(ct),Fe=Le(re),Xe=Le(Et),Ye=Le(Me),Ne=Le(ze);function Le(t){return t&&t.__esModule?t:{default:t}}function Be(t){return(Be="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Ve(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function qe(t){return(qe=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ue(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ge(t,e){return(Ge=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function He(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Ke=function(){function g(t,e,n,r,o,i,a){var u,s,l;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,g),s=this,u=!(l=qe(g).call(this,t))||"object"!==Be(l)&&"function"!=typeof l?Ue(s):l,He(Ue(u),"target",void 0),He(Ue(u),"currentTarget",void 0),He(Ue(u),"relatedTarget",null),He(Ue(u),"screenX",void 0),He(Ue(u),"screenY",void 0),He(Ue(u),"button",void 0),He(Ue(u),"buttons",void 0),He(Ue(u),"ctrlKey",void 0),He(Ue(u),"shiftKey",void 0),He(Ue(u),"altKey",void 0),He(Ue(u),"metaKey",void 0),He(Ue(u),"page",void 0),He(Ue(u),"client",void 0),He(Ue(u),"delta",void 0),He(Ue(u),"rect",void 0),He(Ue(u),"x0",void 0),He(Ue(u),"y0",void 0),He(Ue(u),"t0",void 0),He(Ue(u),"dt",void 0),He(Ue(u),"duration",void 0),He(Ue(u),"clientX0",void 0),He(Ue(u),"clientY0",void 0),He(Ue(u),"velocity",void 0),He(Ue(u),"speed",void 0),He(Ue(u),"swipe",void 0),He(Ue(u),"timeStamp",void 0),He(Ue(u),"dragEnter",void 0),He(Ue(u),"dragLeave",void 0),He(Ue(u),"axes",void 0),He(Ue(u),"preEnd",void 0),o=o||t.element;var c=t.interactable,f=(c&&c.options||Ne.default).deltaSource,p=(0,Fe.default)(c,o,n),d="start"===r,v="end"===r,y=d?Ue(u):t.prevEvent,h=d?t.coords.start:v?{page:y.page,client:y.client,timeStamp:t.coords.cur.timeStamp}:t.coords.cur;return u.page=(0,Re.default)({},h.page),u.client=(0,Re.default)({},h.client),u.rect=(0,Re.default)({},t.rect),u.timeStamp=h.timeStamp,v||(u.page.x-=p.x,u.page.y-=p.y,u.client.x-=p.x,u.client.y-=p.y),u.ctrlKey=e.ctrlKey,u.altKey=e.altKey,u.shiftKey=e.shiftKey,u.metaKey=e.metaKey,u.button=e.button,u.buttons=e.buttons,u.target=o,u.currentTarget=o,u.preEnd=i,u.type=a||n+(r||""),u.interactable=c,u.t0=d?t.pointers[t.pointers.length-1].downTime:y.t0,u.x0=t.coords.start.page.x-p.x,u.y0=t.coords.start.page.y-p.y,u.clientX0=t.coords.start.client.x-p.x,u.clientY0=t.coords.start.client.y-p.y,u.delta=d||v?{x:0,y:0}:{x:u[f].x-y[f].x,y:u[f].y-y[f].y},u.dt=t.coords.delta.timeStamp,u.duration=u.timeStamp-u.t0,u.velocity=(0,Re.default)({},t.coords.velocity[f]),u.speed=(0,Xe.default)(u.velocity.x,u.velocity.y),u.swipe=v||"inertiastart"===r?u.getSwipe():null,u}var t,e,n;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ge(t,e)}(g,Ye["default"]),t=g,(e=[{key:"getSwipe",value:function(){var t=this._interaction;if(t.prevEvent.speed<600||150<this.timeStamp-t.prevEvent.timeStamp)return null;var e=180*Math.atan2(t.prevEvent.velocityY,t.prevEvent.velocityX)/Math.PI;e<0&&(e+=360);var n=112.5<=e&&e<247.5,r=202.5<=e&&e<337.5;return{up:r,down:!r&&22.5<=e&&e<157.5,left:n,right:!n&&(292.5<=e||e<67.5),angle:e,speed:t.prevEvent.speed,velocity:{x:t.prevEvent.velocityX,y:t.prevEvent.velocityY}}}},{key:"preventDefault",value:function(){}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"pageX",get:function(){return this.page.x},set:function(t){this.page.x=t}},{key:"pageY",get:function(){return this.page.y},set:function(t){this.page.y=t}},{key:"clientX",get:function(){return this.client.x},set:function(t){this.client.x=t}},{key:"clientY",get:function(){return this.client.y},set:function(t){this.client.y=t}},{key:"dx",get:function(){return this.delta.x},set:function(t){this.delta.x=t}},{key:"dy",get:function(){return this.delta.y},set:function(t){this.delta.y=t}},{key:"velocityX",get:function(){return this.velocity.x},set:function(t){this.velocity.x=t}},{key:"velocityY",get:function(){return this.velocity.y},set:function(t){this.velocity.y=t}}])&&Ve(t.prototype,e),n&&Ve(t,n),g}(),$e=We.InteractEvent=Ke;We.default=$e;var Ze={};function Je(t){return(Je="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ze,"__esModule",{value:!0}),Ze.default=void 0;var Qe,tn=an(S),en=an($),nn=(Qe=ct)&&Qe.__esModule?Qe:{default:Qe},rn=an(w);function on(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return on=function(){return t},t}function an(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Je(t)&&"function"!=typeof t)return{default:t};var e=on();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function un(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function sn(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var ln=function(){function e(t){var a=this;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.scope=t,sn(this,"list",[]),sn(this,"selectorMap",{}),t.addListeners({"interactable:unset":function(t){var e=t.interactable,n=e.target,r=e._context,o=rn.string(n)?a.selectorMap[n]:n[a.scope.id],i=o.findIndex(function(t){return t.context===r});o[i]&&(o[i].context=null,o[i].interactable=null),o.splice(i,1)}})}var t,n,r;return t=e,(n=[{key:"new",value:function(t,e){e=(0,nn.default)(e||{},{actions:this.scope.actions});var n=new this.scope.Interactable(t,e,this.scope.document,this.scope.events),r={context:n._context,interactable:n};return this.scope.addDocument(n._doc),this.list.push(n),rn.string(t)?(this.selectorMap[t]||(this.selectorMap[t]=[]),this.selectorMap[t].push(r)):(n.target[this.scope.id]||Object.defineProperty(t,this.scope.id,{value:[],configurable:!0}),t[this.scope.id].push(r)),this.scope.fire("interactable:new",{target:t,options:e,interactable:n,win:this.scope._win}),n}},{key:"get",value:function(e,t){var n=t&&t.context||this.scope.document,r=rn.string(e),o=r?this.selectorMap[e]:e[this.scope.id];if(!o)return null;var i=tn.find(o,function(t){return t.context===n&&(r||t.interactable.inContext(e))});return i&&i.interactable}},{key:"forEachMatch",value:function(t,e){for(var n=0;n<this.list.length;n++){var r=this.list[n],o=void 0;if((rn.string(r.target)?rn.element(t)&&en.matchesSelector(t,r.target):t===r.target)&&r.inContext(t)&&(o=e(r)),void 0!==o)return o}}}])&&un(t.prototype,n),r&&un(t,r),e}();Ze.default=ln;var cn={};function fn(t){return(fn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(cn,"__esModule",{value:!0}),cn.default=cn.FakeEvent=void 0;var pn=On(S),dn=On($),vn=bn(ct),yn=On(w),hn=bn(Tt),gn=On(zt);function bn(t){return t&&t.__esModule?t:{default:t}}function mn(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return mn=function(){return t},t}function On(t){if(t&&t.__esModule)return t;if(null===t||"object"!==fn(t)&&"function"!=typeof t)return{default:t};var e=mn();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function wn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function _n(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var Pn=function(){function o(t){var e,n,r;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),this.originalEvent=t,r=void 0,(n="currentTarget")in(e=this)?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,(0,hn.default)(this,t)}var t,e,n;return t=o,(e=[{key:"preventOriginalDefault",value:function(){this.originalEvent.preventDefault()}},{key:"stopPropagation",value:function(){this.originalEvent.stopPropagation()}},{key:"stopImmediatePropagation",value:function(){this.originalEvent.stopImmediatePropagation()}}])&&wn(t.prototype,e),n&&wn(t,n),o}();function xn(t){if(!yn.object(t))return{capture:!!t,passive:!1};var e=(0,vn.default)({},t);return e.capture=!!t.capture,e.passive=!!t.passive,e}cn.FakeEvent=Pn;var Sn={id:"events",install:function(t){var f=[],b={},c=[],p={add:d,remove:g,addDelegate:function(e,n,t,r,o){var i=xn(o);if(!b[t]){b[t]=[];for(var a=0;a<c.length;a++){var u=c[a];d(u,t,m),d(u,t,O,!0)}}var s=b[t],l=pn.find(s,function(t){return t.selector===e&&t.context===n});l||(l={selector:e,context:n,listeners:[]},s.push(l));l.listeners.push([r,i])},removeDelegate:function(t,e,n,r,o){var i,a=xn(o),u=b[n],s=!1;if(!u)return;for(i=u.length-1;0<=i;i--){var l=u[i];if(l.selector===t&&l.context===e){for(var c=l.listeners,f=c.length-1;0<=f;f--){var p=_n(c[f],2),d=p[0],v=p[1],y=v.capture,h=v.passive;if(d===r&&y===a.capture&&h===a.passive){c.splice(f,1),c.length||(u.splice(i,1),g(e,n,m),g(e,n,O,!0)),s=!0;break}}if(s)break}}},delegateListener:m,delegateUseCapture:O,delegatedEvents:b,documents:c,targets:f,supportsOptions:!1,supportsPassive:!1};function d(e,t,n,r){var o=xn(r),i=pn.find(f,function(t){return t.eventTarget===e});i||(i={eventTarget:e,events:{}},f.push(i)),i.events[t]||(i.events[t]=[]),e.addEventListener&&!pn.contains(i.events[t],n)&&(e.addEventListener(t,n,p.supportsOptions?o:o.capture),i.events[t].push(n))}function g(e,t,n,r){var o=xn(r),i=pn.findIndex(f,function(t){return t.eventTarget===e}),a=f[i];if(a&&a.events)if("all"!==t){var u=!1,s=a.events[t];if(s){if("all"===n){for(var l=s.length-1;0<=l;l--)g(e,t,s[l],o);return}for(var c=0;c<s.length;c++)if(s[c]===n){e.removeEventListener(t,n,p.supportsOptions?o:o.capture),s.splice(c,1),0===s.length&&(delete a.events[t],u=!0);break}}u&&!Object.keys(a.events).length&&f.splice(i,1)}else for(t in a.events)a.events.hasOwnProperty(t)&&g(e,t,"all")}function m(t,e){for(var n=xn(e),r=new Pn(t),o=b[t.type],i=_n(gn.getEventTargets(t),1)[0],a=i;yn.element(a);){for(var u=0;u<o.length;u++){var s=o[u],l=s.selector,c=s.context;if(dn.matchesSelector(a,l)&&dn.nodeContains(c,i)&&dn.nodeContains(c,a)){var f=s.listeners;r.currentTarget=a;for(var p=0;p<f.length;p++){var d=_n(f[p],2),v=d[0],y=d[1],h=y.capture,g=y.passive;h===n.capture&&g===n.passive&&v(r)}}}a=dn.parentNode(a)}}function O(t){return m.call(this,t,!0)}return t.document.createElement("div").addEventListener("test",null,{get capture(){return p.supportsOptions=!0},get passive(){return p.supportsPassive=!0}}),t.events=p}};cn.default=Sn;var jn={};Object.defineProperty(jn,"__esModule",{value:!0}),jn.default=jn.PointerInfo=void 0;function Mn(t,e,n,r,o){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,Mn),this.id=t,this.pointer=e,this.event=n,this.downTime=r,this.downTarget=o}var kn=jn.PointerInfo=Mn;jn.default=kn;var En={};function Tn(t){return(Tn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(En,"__esModule",{value:!0}),Object.defineProperty(En,"PointerInfo",{enumerable:!0,get:function(){return Rn.default}}),En.default=En.Interaction=En._ProxyMethods=En._ProxyValues=void 0;var Dn,In,zn,An,Cn=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Tn(t)&&"function"!=typeof t)return{default:t};var e=Xn();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),Wn=Fn(We),Rn=Fn(jn);function Fn(t){return t&&t.__esModule?t:{default:t}}function Xn(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Xn=function(){return t},t}function Yn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Nn(t,e,n){return e&&Yn(t.prototype,e),n&&Yn(t,n),t}function Ln(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}En._ProxyValues=Dn,(In=Dn||(En._ProxyValues=Dn={})).interactable="",In.element="",In.prepared="",In.pointerIsDown="",In.pointerWasMoved="",In._proxy="",En._ProxyMethods=zn,(An=zn||(En._ProxyMethods=zn={})).start="",An.move="",An.end="",An.stop="",An.interacting="";var Bn=0,Vn=function(){function l(t){var e=this,n=t.pointerType,r=t.scopeFire;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,l),Ln(this,"interactable",null),Ln(this,"element",null),Ln(this,"rect",void 0),Ln(this,"_rects",void 0),Ln(this,"edges",void 0),Ln(this,"_scopeFire",void 0),Ln(this,"prepared",{name:null,axis:null,edges:null}),Ln(this,"pointerType",void 0),Ln(this,"pointers",[]),Ln(this,"downEvent",null),Ln(this,"downPointer",{}),Ln(this,"_latestPointer",{pointer:null,event:null,eventTarget:null}),Ln(this,"prevEvent",null),Ln(this,"pointerIsDown",!1),Ln(this,"pointerWasMoved",!1),Ln(this,"_interacting",!1),Ln(this,"_ending",!1),Ln(this,"_stopped",!0),Ln(this,"_proxy",null),Ln(this,"simulation",null),Ln(this,"doMove",Cn.warnOnce(function(t){this.move(t)},"The interaction.doMove() method has been renamed to interaction.move()")),Ln(this,"coords",{start:Cn.pointer.newCoords(),prev:Cn.pointer.newCoords(),cur:Cn.pointer.newCoords(),delta:Cn.pointer.newCoords(),velocity:Cn.pointer.newCoords()}),Ln(this,"_id",Bn++),this._scopeFire=r,this.pointerType=n;var o=this;this._proxy={};function i(t){Object.defineProperty(e._proxy,t,{get:function(){return o[t]}})}for(var a in Dn)i(a);function u(t){Object.defineProperty(e._proxy,t,{value:function(){return o[t].apply(o,arguments)}})}for(var s in zn)u(s);this._scopeFire("interactions:new",{interaction:this})}return Nn(l,[{key:"pointerMoveTolerance",get:function(){return 1}}]),Nn(l,[{key:"pointerDown",value:function(t,e,n){var r=this.updatePointer(t,e,n,!0),o=this.pointers[r];this._scopeFire("interactions:down",{pointer:t,event:e,eventTarget:n,pointerIndex:r,pointerInfo:o,type:"down",interaction:this})}},{key:"start",value:function(t,e,n){return!(this.interacting()||!this.pointerIsDown||this.pointers.length<("gesture"===t.name?2:1)||!e.options[t.name].enabled)&&(Cn.copyAction(this.prepared,t),this.interactable=e,this.element=n,this.rect=e.getRect(n),this.edges=this.prepared.edges?Cn.extend({},this.prepared.edges):{left:!0,right:!0,top:!0,bottom:!0},this._stopped=!1,this._interacting=this._doPhase({interaction:this,event:this.downEvent,phase:"start"})&&!this._stopped,this._interacting)}},{key:"pointerMove",value:function(t,e,n){this.simulation||this.modification&&this.modification.endResult||this.updatePointer(t,e,n,!1);var r,o,i=this.coords.cur.page.x===this.coords.prev.page.x&&this.coords.cur.page.y===this.coords.prev.page.y&&this.coords.cur.client.x===this.coords.prev.client.x&&this.coords.cur.client.y===this.coords.prev.client.y;this.pointerIsDown&&!this.pointerWasMoved&&(r=this.coords.cur.client.x-this.coords.start.client.x,o=this.coords.cur.client.y-this.coords.start.client.y,this.pointerWasMoved=Cn.hypot(r,o)>this.pointerMoveTolerance);var a=this.getPointerIndex(t),u={pointer:t,pointerIndex:a,pointerInfo:this.pointers[a],event:e,type:"move",eventTarget:n,dx:r,dy:o,duplicate:i,interaction:this};i||Cn.pointer.setCoordVelocity(this.coords.velocity,this.coords.delta),this._scopeFire("interactions:move",u),i||this.simulation||(this.interacting()&&(u.type=null,this.move(u)),this.pointerWasMoved&&Cn.pointer.copyCoords(this.coords.prev,this.coords.cur))}},{key:"move",value:function(t){t&&t.event||Cn.pointer.setZeroCoords(this.coords.delta),(t=Cn.extend({pointer:this._latestPointer.pointer,event:this._latestPointer.event,eventTarget:this._latestPointer.eventTarget,interaction:this},t||{})).phase="move",this._doPhase(t)}},{key:"pointerUp",value:function(t,e,n,r){var o=this.getPointerIndex(t);-1===o&&(o=this.updatePointer(t,e,n,!1));var i=/cancel$/i.test(e.type)?"cancel":"up";this._scopeFire("interactions:".concat(i),{pointer:t,pointerIndex:o,pointerInfo:this.pointers[o],event:e,eventTarget:n,type:i,curEventTarget:r,interaction:this}),this.simulation||this.end(e),this.pointerIsDown=!1,this.removePointer(t,e)}},{key:"documentBlur",value:function(t){this.end(t),this._scopeFire("interactions:blur",{event:t,type:"blur",interaction:this})}},{key:"end",value:function(t){var e;this._ending=!0,t=t||this._latestPointer.event,this.interacting()&&(e=this._doPhase({event:t,interaction:this,phase:"end"})),!(this._ending=!1)===e&&this.stop()}},{key:"currentAction",value:function(){return this._interacting?this.prepared.name:null}},{key:"interacting",value:function(){return this._interacting}},{key:"stop",value:function(){this._scopeFire("interactions:stop",{interaction:this}),this.interactable=this.element=null,this._interacting=!1,this._stopped=!0,this.prepared.name=this.prevEvent=null}},{key:"getPointerIndex",value:function(t){var e=Cn.pointer.getPointerId(t);return"mouse"===this.pointerType||"pen"===this.pointerType?this.pointers.length-1:Cn.arr.findIndex(this.pointers,function(t){return t.id===e})}},{key:"getPointerInfo",value:function(t){return this.pointers[this.getPointerIndex(t)]}},{key:"updatePointer",value:function(t,e,n,r){var o=Cn.pointer.getPointerId(t),i=this.getPointerIndex(t),a=this.pointers[i];return r=!1!==r&&(r||/(down|start)$/i.test(e.type)),a?a.pointer=t:(a=new Rn.default(o,t,e,null,null),i=this.pointers.length,this.pointers.push(a)),Cn.pointer.setCoords(this.coords.cur,this.pointers.map(function(t){return t.pointer}),this._now()),Cn.pointer.setCoordDeltas(this.coords.delta,this.coords.prev,this.coords.cur),r&&(this.pointerIsDown=!0,a.downTime=this.coords.cur.timeStamp,a.downTarget=n,Cn.pointer.pointerExtend(this.downPointer,t),this.interacting()||(Cn.pointer.copyCoords(this.coords.start,this.coords.cur),Cn.pointer.copyCoords(this.coords.prev,this.coords.cur),this.downEvent=e,this.pointerWasMoved=!1)),this._updateLatestPointer(t,e,n),this._scopeFire("interactions:update-pointer",{pointer:t,event:e,eventTarget:n,down:r,pointerInfo:a,pointerIndex:i,interaction:this}),i}},{key:"removePointer",value:function(t,e){var n=this.getPointerIndex(t);if(-1!==n){var r=this.pointers[n];this._scopeFire("interactions:remove-pointer",{pointer:t,event:e,eventTarget:null,pointerIndex:n,pointerInfo:r,interaction:this}),this.pointers.splice(n,1)}}},{key:"_updateLatestPointer",value:function(t,e,n){this._latestPointer.pointer=t,this._latestPointer.event=e,this._latestPointer.eventTarget=n}},{key:"destroy",value:function(){this._latestPointer.pointer=null,this._latestPointer.event=null,this._latestPointer.eventTarget=null}},{key:"_createPreparedEvent",value:function(t,e,n,r){return new Wn.default(this,t,this.prepared.name,e,this.element,n,r)}},{key:"_fireEvent",value:function(t){this.interactable.fire(t),(!this.prevEvent||t.timeStamp>=this.prevEvent.timeStamp)&&(this.prevEvent=t)}},{key:"_doPhase",value:function(t){var e=t.event,n=t.phase,r=t.preEnd,o=t.type,i=this.rect;if(i&&"move"===n&&(Cn.rect.addEdges(this.edges,i,this.coords.delta[this.interactable.options.deltaSource]),i.width=i.right-i.left,i.height=i.bottom-i.top),!1===this._scopeFire("interactions:before-action-".concat(n),t))return!1;var a=t.iEvent=this._createPreparedEvent(e,n,r,o);return this._scopeFire("interactions:action-".concat(n),t),"start"===n&&(this.prevEvent=a),this._fireEvent(a),this._scopeFire("interactions:after-action-".concat(n),t),!0}},{key:"_now",value:function(){return Date.now()}}]),l}(),qn=En.Interaction=Vn;En.default=qn;var Un={};function Gn(t){return(Gn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Un,"__esModule",{value:!0}),Un.install=Jn,Un.default=void 0;var Hn=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Gn(t)&&"function"!=typeof t)return{default:t};var e=Kn();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function Kn(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Kn=function(){return t},t}function $n(t){return/^(always|never|auto)$/.test(t)?(this.options.preventDefault=t,this):Hn.bool(t)?(this.options.preventDefault=t?"always":"never",this):this.options.preventDefault}function Zn(t){var e=t.interaction,n=t.event;e.interactable&&e.interactable.checkAndPreventDefault(n)}function Jn(r){var t=r.Interactable;t.prototype.preventDefault=$n,t.prototype.checkAndPreventDefault=function(t){return function(t,e,n){var r=t.options.preventDefault;if("never"!==r)if("always"!==r){if(e.events.supportsPassive&&/^touch(start|move)$/.test(n.type)){var o=(0,O.getWindow)(n.target).document,i=e.getDocOptions(o);if(!i||!i.events||!1!==i.events.passive)return}/^(mouse|pointer|touch)*(down|start)/i.test(n.type)||Hn.element(n.target)&&(0,$.matchesSelector)(n.target,"input,select,textarea,[contenteditable=true],[contenteditable=true] *")||n.preventDefault()}else n.preventDefault()}(this,r,t)},r.interactions.docEvents.push({type:"dragstart",listener:function(t){for(var e=0;e<r.interactions.list.length;e++){var n=r.interactions.list[e];if(n.element&&(n.element===t.target||(0,$.nodeContains)(n.element,t.target)))return void n.interactable.checkAndPreventDefault(t)}}})}var Qn={id:"core/interactablePreventDefault",install:Jn,listeners:["down","move","up","cancel"].reduce(function(t,e){return t["interactions:".concat(e)]=Zn,t},{})};Un.default=Qn;var tr={};function er(t){return(er="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(tr,"__esModule",{value:!0}),tr.default=void 0;var nr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==er(t)&&"function"!=typeof t)return{default:t};var e=rr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($);function rr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return rr=function(){return t},t}var or={methodOrder:["simulationResume","mouseOrPen","hasPointer","idle"],search:function(t){for(var e=0;e<or.methodOrder.length;e++){var n;n=or.methodOrder[e];var r=or[n](t);if(r)return r}return null},simulationResume:function(t){var e=t.pointerType,n=t.eventType,r=t.eventTarget,o=t.scope;if(!/down|start/i.test(n))return null;for(var i=0;i<o.interactions.list.length;i++){var a=o.interactions.list[i],u=r;if(a.simulation&&a.simulation.allowResume&&a.pointerType===e)for(;u;){if(u===a.element)return a;u=nr.parentNode(u)}}return null},mouseOrPen:function(t){var e,n=t.pointerId,r=t.pointerType,o=t.eventType,i=t.scope;if("mouse"!==r&&"pen"!==r)return null;for(var a=0;a<i.interactions.list.length;a++){var u=i.interactions.list[a];if(u.pointerType===r){if(u.simulation&&!ir(u,n))continue;if(u.interacting())return u;e=e||u}}if(e)return e;for(var s=0;s<i.interactions.list.length;s++){var l=i.interactions.list[s];if(!(l.pointerType!==r||/down/i.test(o)&&l.simulation))return l}return null},hasPointer:function(t){for(var e=t.pointerId,n=t.scope,r=0;r<n.interactions.list.length;r++){var o=n.interactions.list[r];if(ir(o,e))return o}return null},idle:function(t){for(var e=t.pointerType,n=t.scope,r=0;r<n.interactions.list.length;r++){var o=n.interactions.list[r];if(1===o.pointers.length){var i=o.interactable;if(i&&(!i.options.gesture||!i.options.gesture.enabled))continue}else if(2<=o.pointers.length)continue;if(!o.interacting()&&e===o.pointerType)return o}return null}};function ir(t,e){return t.pointers.some(function(t){return t.id===e})}var ar=or;tr.default=ar;var ur={};Object.defineProperty(ur,"__esModule",{value:!0}),ur.default=void 0;var sr,lr=(sr=Me)&&sr.__esModule?sr:{default:sr},cr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==pr(t)&&"function"!=typeof t)return{default:t};var e=fr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(S);function fr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return fr=function(){return t},t}function pr(t){return(pr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function dr(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function vr(t){return(vr=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function yr(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function hr(t,e){return(hr=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function gr(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var br=function(){function l(t,e,n){var r,o,i;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,l),o=this,r=!(i=vr(l).call(this,e._interaction))||"object"!==pr(i)&&"function"!=typeof i?yr(o):i,gr(yr(r),"target",void 0),gr(yr(r),"dropzone",void 0),gr(yr(r),"dragEvent",void 0),gr(yr(r),"relatedTarget",void 0),gr(yr(r),"draggable",void 0),gr(yr(r),"timeStamp",void 0),gr(yr(r),"propagationStopped",!1),gr(yr(r),"immediatePropagationStopped",!1);var a="dragleave"===n?t.prev:t.cur,u=a.element,s=a.dropzone;return r.type=n,r.target=u,r.currentTarget=u,r.dropzone=s,r.dragEvent=e,r.relatedTarget=e.target,r.draggable=e.interactable,r.timeStamp=e.timeStamp,r}var t,e,n;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&hr(t,e)}(l,lr["default"]),t=l,(e=[{key:"reject",value:function(){var r=this,t=this._interaction.dropState;if("dropactivate"===this.type||this.dropzone&&t.cur.dropzone===this.dropzone&&t.cur.element===this.target)if(t.prev.dropzone=this.dropzone,t.prev.element=this.target,t.rejected=!0,t.events.enter=null,this.stopImmediatePropagation(),"dropactivate"===this.type){var e=t.activeDrops,n=cr.findIndex(e,function(t){var e=t.dropzone,n=t.element;return e===r.dropzone&&n===r.target});t.activeDrops.splice(n,1);var o=new l(t,this.dragEvent,"dropdeactivate");o.dropzone=this.dropzone,o.target=this.target,this.dropzone.fire(o)}else this.dropzone.fire(new l(t,this.dragEvent,"dragleave"))}},{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}])&&dr(t.prototype,e),n&&dr(t,n),l}();ur.default=br;var mr={};function Or(t){return(Or="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(mr,"__esModule",{value:!0}),mr.default=void 0;Sr(k({})),Sr(m({}));var wr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Or(t)&&"function"!=typeof t)return{default:t};var e=xr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),_r=Sr(v),Pr=Sr(ur);function xr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return xr=function(){return t},t}function Sr(t){return t&&t.__esModule?t:{default:t}}function jr(t,e){for(var n=0;n<t.slice().length;n++){r=t.slice()[n];var r,o=r.dropzone,i=r.element;e.dropzone=o,e.target=i,o.fire(e),e.propagationStopped=e.immediatePropagationStopped=!1}}function Mr(t,e){for(var n=function(t,e){for(var n=t.interactables,r=[],o=0;o<n.list.length;o++){var i=n.list[o];if(i.options.drop.enabled){var a=i.options.drop.accept;if(!(wr.is.element(a)&&a!==e||wr.is.string(a)&&!wr.dom.matchesSelector(e,a)||wr.is.func(a)&&!a({dropzone:i,draggableElement:e})))for(var u=wr.is.string(i.target)?i._context.querySelectorAll(i.target):wr.is.array(i.target)?i.target:[i.target],s=0;s<u.length;s++){var l;l=u[s];l!==e&&r.push({dropzone:i,element:l})}}}return r}(t,e),r=0;r<n.length;r++){var o;o=n[r];o.rect=o.dropzone.getRect(o.element)}return n}function kr(t,e,n){for(var r=t.dropState,o=t.interactable,i=t.element,a=[],u=0;u<r.activeDrops.length;u++){s=r.activeDrops[u];var s,l=s.dropzone,c=s.element,f=s.rect;a.push(l.dropCheck(e,n,o,i,c,f)?c:null)}var p=wr.dom.indexOfDeepestElement(a);return r.activeDrops[p]||null}function Er(t,e,n){var r=t.dropState,o={enter:null,leave:null,activate:null,deactivate:null,move:null,drop:null};return"dragstart"===n.type&&(o.activate=new Pr.default(r,n,"dropactivate"),o.activate.target=null,o.activate.dropzone=null),"dragend"===n.type&&(o.deactivate=new Pr.default(r,n,"dropdeactivate"),o.deactivate.target=null,o.deactivate.dropzone=null),r.rejected||(r.cur.element!==r.prev.element&&(r.prev.dropzone&&(o.leave=new Pr.default(r,n,"dragleave"),n.dragLeave=o.leave.target=r.prev.element,n.prevDropzone=o.leave.dropzone=r.prev.dropzone),r.cur.dropzone&&(o.enter=new Pr.default(r,n,"dragenter"),n.dragEnter=r.cur.element,n.dropzone=r.cur.dropzone)),"dragend"===n.type&&r.cur.dropzone&&(o.drop=new Pr.default(r,n,"drop"),n.dropzone=r.cur.dropzone,n.relatedTarget=r.cur.element),"dragmove"===n.type&&r.cur.dropzone&&(o.move=new Pr.default(r,n,"dropmove"),(o.move.dragmove=n).dropzone=r.cur.dropzone)),o}function Tr(t,e){var n=t.dropState,r=n.activeDrops,o=n.cur,i=n.prev;e.leave&&i.dropzone.fire(e.leave),e.move&&o.dropzone.fire(e.move),e.enter&&o.dropzone.fire(e.enter),e.drop&&o.dropzone.fire(e.drop),e.deactivate&&jr(r,e.deactivate),n.prev.dropzone=o.dropzone,n.prev.element=o.element}function Dr(t,e){var n=t.interaction,r=t.iEvent,o=t.event;if("dragmove"===r.type||"dragend"===r.type){var i=n.dropState;e.dynamicDrop&&(i.activeDrops=Mr(e,n.element));var a=r,u=kr(n,a,o);i.rejected=i.rejected&&!!u&&u.dropzone===i.cur.dropzone&&u.element===i.cur.element,i.cur.dropzone=u&&u.dropzone,i.cur.element=u&&u.element,i.events=Er(n,0,a)}}var Ir={id:"actions/drop",install:function(e){var t=e.actions,n=e.interactStatic,r=e.Interactable,o=e.defaults;e.usePlugin(_r.default),r.prototype.dropzone=function(t){return function(t,e){if(wr.is.object(e)){if(t.options.drop.enabled=!1!==e.enabled,e.listeners){var n=wr.normalizeListeners(e.listeners),r=Object.keys(n).reduce(function(t,e){return t[/^(enter|leave)/.test(e)?"drag".concat(e):/^(activate|deactivate|move)/.test(e)?"drop".concat(e):e]=n[e],t},{});t.off(t.options.drop.listeners),t.on(r),t.options.drop.listeners=r}return wr.is.func(e.ondrop)&&t.on("drop",e.ondrop),wr.is.func(e.ondropactivate)&&t.on("dropactivate",e.ondropactivate),wr.is.func(e.ondropdeactivate)&&t.on("dropdeactivate",e.ondropdeactivate),wr.is.func(e.ondragenter)&&t.on("dragenter",e.ondragenter),wr.is.func(e.ondragleave)&&t.on("dragleave",e.ondragleave),wr.is.func(e.ondropmove)&&t.on("dropmove",e.ondropmove),/^(pointer|center)$/.test(e.overlap)?t.options.drop.overlap=e.overlap:wr.is.number(e.overlap)&&(t.options.drop.overlap=Math.max(Math.min(1,e.overlap),0)),"accept"in e&&(t.options.drop.accept=e.accept),"checker"in e&&(t.options.drop.checker=e.checker),t}if(wr.is.bool(e))return t.options.drop.enabled=e,t;return t.options.drop}(this,t)},r.prototype.dropCheck=function(t,e,n,r,o,i){return function(t,e,n,r,o,i,a){var u=!1;if(!(a=a||t.getRect(i)))return!!t.options.drop.checker&&t.options.drop.checker(e,n,u,t,i,r,o);var s=t.options.drop.overlap;if("pointer"===s){var l=wr.getOriginXY(r,o,"drag"),c=wr.pointer.getPageXY(e);c.x+=l.x,c.y+=l.y;var f=c.x>a.left&&c.x<a.right,p=c.y>a.top&&c.y<a.bottom;u=f&&p}var d=r.getRect(o);if(d&&"center"===s){var v=d.left+d.width/2,y=d.top+d.height/2;u=v>=a.left&&v<=a.right&&y>=a.top&&y<=a.bottom}if(d&&wr.is.number(s)){var h=Math.max(0,Math.min(a.right,d.right)-Math.max(a.left,d.left))*Math.max(0,Math.min(a.bottom,d.bottom)-Math.max(a.top,d.top))/(d.width*d.height);u=s<=h}t.options.drop.checker&&(u=t.options.drop.checker(e,n,u,t,i,r,o));return u}(this,t,e,n,r,o,i)},n.dynamicDrop=function(t){return wr.is.bool(t)?(e.dynamicDrop=t,n):e.dynamicDrop},wr.extend(t.phaselessTypes,{dragenter:!0,dragleave:!0,dropactivate:!0,dropdeactivate:!0,dropmove:!0,drop:!0}),t.methodDict.drop="dropzone",e.dynamicDrop=!1,o.actions.drop=Ir.defaults},listeners:{"interactions:before-action-start":function(t){var e=t.interaction;"drag"===e.prepared.name&&(e.dropState={cur:{dropzone:null,element:null},prev:{dropzone:null,element:null},rejected:null,events:null,activeDrops:[]})},"interactions:after-action-start":function(t,e){var n=t.interaction,r=(t.event,t.iEvent);if("drag"===n.prepared.name){var o=n.dropState;o.activeDrops=null,o.events=null,o.activeDrops=Mr(e,n.element),o.events=Er(n,0,r),o.events.activate&&(jr(o.activeDrops,o.events.activate),e.fire("actions/drop:start",{interaction:n,dragEvent:r}))}},"interactions:action-move":Dr,"interactions:action-end":Dr,"interactions:after-action-move":function(t,e){var n=t.interaction,r=t.iEvent;"drag"===n.prepared.name&&(Tr(n,n.dropState.events),e.fire("actions/drop:move",{interaction:n,dragEvent:r}),n.dropState.events={})},"interactions:after-action-end":function(t,e){var n=t.interaction,r=t.iEvent;"drag"===n.prepared.name&&(Tr(n,n.dropState.events),e.fire("actions/drop:end",{interaction:n,dragEvent:r}))},"interactions:stop":function(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.dropState;n&&(n.activeDrops=null,n.events=null,n.cur.dropzone=null,n.cur.element=null,n.prev.dropzone=null,n.prev.element=null,n.rejected=!1)}}},getActiveDrops:Mr,getDrop:kr,getDropEvents:Er,fireDropEvents:Tr,defaults:{enabled:!1,accept:null,overlap:"pointer"}},zr=Ir;mr.default=zr;var Ar={};function Cr(t){return(Cr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ar,"__esModule",{value:!0}),Ar.default=void 0;var Wr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Cr(t)&&"function"!=typeof t)return{default:t};var e=Rr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le);function Rr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Rr=function(){return t},t}function Fr(t){var e=t.interaction,n=t.iEvent,r=t.phase;if("gesture"===e.prepared.name){var o=e.pointers.map(function(t){return t.pointer}),i="start"===r,a="end"===r,u=e.interactable.options.deltaSource;if(n.touches=[o[0],o[1]],i)n.distance=Wr.pointer.touchDistance(o,u),n.box=Wr.pointer.touchBBox(o),n.scale=1,n.ds=0,n.angle=Wr.pointer.touchAngle(o,u),n.da=0,e.gesture.startDistance=n.distance,e.gesture.startAngle=n.angle;else if(a){var s=e.prevEvent;n.distance=s.distance,n.box=s.box,n.scale=s.scale,n.ds=0,n.angle=s.angle,n.da=0}else n.distance=Wr.pointer.touchDistance(o,u),n.box=Wr.pointer.touchBBox(o),n.scale=n.distance/e.gesture.startDistance,n.angle=Wr.pointer.touchAngle(o,u),n.ds=n.scale-e.gesture.scale,n.da=n.angle-e.gesture.angle;e.gesture.distance=n.distance,e.gesture.angle=n.angle,Wr.is.number(n.scale)&&n.scale!==1/0&&!isNaN(n.scale)&&(e.gesture.scale=n.scale)}}var Xr={id:"actions/gesture",before:["actions/drag","actions/resize"],install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.gesturable=function(t){return Wr.is.object(t)?(this.options.gesture.enabled=!1!==t.enabled,this.setPerAction("gesture",t),this.setOnEvents("gesture",t),this):Wr.is.bool(t)?(this.options.gesture.enabled=t,this):this.options.gesture},e.map.gesture=Xr,e.methodDict.gesture="gesturable",r.actions.gesture=Xr.defaults},listeners:{"interactions:action-start":Fr,"interactions:action-move":Fr,"interactions:action-end":Fr,"interactions:new":function(t){t.interaction.gesture={angle:0,distance:0,scale:1,startAngle:0,startDistance:0}},"auto-start:check":function(t){if(!(t.interaction.pointers.length<2)){var e=t.interactable.options.gesture;if(e&&e.enabled)return!(t.action={name:"gesture"})}}},defaults:{},getCursor:function(){return""}},Yr=Xr;Ar.default=Yr;var Nr={};function Lr(t){return(Lr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Nr,"__esModule",{value:!0}),Nr.default=void 0;var Br,Vr=Hr($),qr=(Br=ct)&&Br.__esModule?Br:{default:Br},Ur=Hr(w);function Gr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Gr=function(){return t},t}function Hr(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Lr(t)&&"function"!=typeof t)return{default:t};var e=Gr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function Kr(t,e,n,r,o,i,a){if(!e)return!1;if(!0===e){var u=Ur.number(i.width)?i.width:i.right-i.left,s=Ur.number(i.height)?i.height:i.bottom-i.top;if(a=Math.min(a,("left"===t||"right"===t?u:s)/2),u<0&&("left"===t?t="right":"right"===t&&(t="left")),s<0&&("top"===t?t="bottom":"bottom"===t&&(t="top")),"left"===t)return n.x<(0<=u?i.left:i.right)+a;if("top"===t)return n.y<(0<=s?i.top:i.bottom)+a;if("right"===t)return n.x>(0<=u?i.right:i.left)-a;if("bottom"===t)return n.y>(0<=s?i.bottom:i.top)-a}return!!Ur.element(r)&&(Ur.element(e)?e===r:Vr.matchesUpTo(r,e,o))}function $r(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.resizeAxes){var r=e;n.interactable.options.resize.square?("y"===n.resizeAxes?r.delta.x=r.delta.y:r.delta.y=r.delta.x,r.axes="xy"):(r.axes=n.resizeAxes,"x"===n.resizeAxes?r.delta.y=0:"y"===n.resizeAxes&&(r.delta.x=0))}}var Zr={id:"actions/resize",before:["actions/drag"],install:function(e){var t=e.actions,n=e.browser,r=e.Interactable,o=e.defaults;Zr.cursors=n.isIe9?{x:"e-resize",y:"s-resize",xy:"se-resize",top:"n-resize",left:"w-resize",bottom:"s-resize",right:"e-resize",topleft:"se-resize",bottomright:"se-resize",topright:"ne-resize",bottomleft:"ne-resize"}:{x:"ew-resize",y:"ns-resize",xy:"nwse-resize",top:"ns-resize",left:"ew-resize",bottom:"ns-resize",right:"ew-resize",topleft:"nwse-resize",bottomright:"nwse-resize",topright:"nesw-resize",bottomleft:"nesw-resize"},Zr.defaultMargin=n.supportsTouch||n.supportsPointerEvent?20:10,r.prototype.resizable=function(t){return function(t,e,n){if(Ur.object(e))return t.options.resize.enabled=!1!==e.enabled,t.setPerAction("resize",e),t.setOnEvents("resize",e),Ur.string(e.axis)&&/^x$|^y$|^xy$/.test(e.axis)?t.options.resize.axis=e.axis:null===e.axis&&(t.options.resize.axis=n.defaults.actions.resize.axis),Ur.bool(e.preserveAspectRatio)?t.options.resize.preserveAspectRatio=e.preserveAspectRatio:Ur.bool(e.square)&&(t.options.resize.square=e.square),t;if(Ur.bool(e))return t.options.resize.enabled=e,t;return t.options.resize}(this,t,e)},t.map.resize=Zr,t.methodDict.resize="resizable",o.actions.resize=Zr.defaults},listeners:{"interactions:new":function(t){t.interaction.resizeAxes="xy"},"interactions:action-start":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,o=n.rect;n._rects={start:(0,qr.default)({},o),corrected:(0,qr.default)({},o),previous:(0,qr.default)({},o),delta:{left:0,right:0,width:0,top:0,bottom:0,height:0}},r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}}(t),$r(t)},"interactions:action-move":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,o=n.interactable.options.resize.invert,i="reposition"===o||"negate"===o,a=n.rect,u=n._rects,s=u.start,l=u.corrected,c=u.delta,f=u.previous;if((0,qr.default)(f,l),i){if((0,qr.default)(l,a),"reposition"===o){if(l.top>l.bottom){var p=l.top;l.top=l.bottom,l.bottom=p}if(l.left>l.right){var d=l.left;l.left=l.right,l.right=d}}}else l.top=Math.min(a.top,s.bottom),l.bottom=Math.max(a.bottom,s.top),l.left=Math.min(a.left,s.right),l.right=Math.max(a.right,s.left);for(var v in l.width=l.right-l.left,l.height=l.bottom-l.top,l)c[v]=l[v]-f[v];r.edges=n.prepared.edges,r.rect=l,r.deltaRect=c}}(t),$r(t)},"interactions:action-end":function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e;r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}},"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.element,o=t.rect,i=t.buttons;if(o){var a=(0,qr.default)({},e.coords.cur.page),u=n.options.resize;if(u&&u.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(i&u.mouseButtons))){if(Ur.object(u.edges)){var s={left:!1,right:!1,top:!1,bottom:!1};for(var l in s)s[l]=Kr(l,u.edges[l],a,e._latestPointer.eventTarget,r,o,u.margin||Zr.defaultMargin);s.left=s.left&&!s.right,s.top=s.top&&!s.bottom,(s.left||s.right||s.top||s.bottom)&&(t.action={name:"resize",edges:s})}else{var c="y"!==u.axis&&a.x>o.right-Zr.defaultMargin,f="x"!==u.axis&&a.y>o.bottom-Zr.defaultMargin;(c||f)&&(t.action={name:"resize",axes:(c?"x":"")+(f?"y":"")})}return!t.action&&void 0}}}},defaults:{square:!1,preserveAspectRatio:!1,axis:"xy",margin:NaN,edges:null,invert:"none"},cursors:null,getCursor:function(t){var e=t.edges,n=t.axis,r=t.name,o=Zr.cursors,i=null;if(n)i=o[r+n];else if(e){for(var a="",u=["top","bottom","left","right"],s=0;s<u.length;s++){var l=u[s];e[l]&&(a+=l)}i=o[a]}return i},defaultMargin:null},Jr=Zr;Nr.default=Jr;var Qr={};Object.defineProperty(Qr,"__esModule",{value:!0}),Object.defineProperty(Qr,"drag",{enumerable:!0,get:function(){return to.default}}),Object.defineProperty(Qr,"drop",{enumerable:!0,get:function(){return eo.default}}),Object.defineProperty(Qr,"gesture",{enumerable:!0,get:function(){return no.default}}),Object.defineProperty(Qr,"resize",{enumerable:!0,get:function(){return ro.default}}),Qr.default=void 0;var to=oo(v),eo=oo(mr),no=oo(Ar),ro=oo(Nr);function oo(t){return t&&t.__esModule?t:{default:t}}var io={id:"actions",install:function(t){t.usePlugin(no.default),t.usePlugin(ro.default),t.usePlugin(to.default),t.usePlugin(eo.default)}};Qr.default=io;var ao={};Object.defineProperty(ao,"__esModule",{value:!0}),ao.default=void 0;ao.default={};var uo={};function so(t){return(so="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(uo,"__esModule",{value:!0}),uo.getContainer=go,uo.getScroll=bo,uo.getScrollSize=function(t){fo.window(t)&&(t=window.document.body);return{x:t.scrollWidth,y:t.scrollHeight}},uo.getScrollSizeDelta=function(t,e){var n=t.interaction,r=t.element,o=n&&n.interactable.options[n.prepared.name].autoScroll;if(!o||!o.enabled)return e(),{x:0,y:0};var i=go(o.container,n.interactable,r),a=bo(i);e();var u=bo(i);return{x:u.x-a.x,y:u.y-a.y}},uo.default=void 0;var lo,co=yo($),fo=yo(w),po=(lo=oe)&&lo.__esModule?lo:{default:lo};function vo(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return vo=function(){return t},t}function yo(t){if(t&&t.__esModule)return t;if(null===t||"object"!==so(t)&&"function"!=typeof t)return{default:t};var e=vo();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}var ho={defaults:{enabled:!1,margin:60,container:null,speed:300},now:Date.now,interaction:null,i:0,x:0,y:0,isScrolling:!1,prevTime:0,margin:0,speed:0,start:function(t){ho.isScrolling=!0,po.default.cancel(ho.i),(t.autoScroll=ho).interaction=t,ho.prevTime=ho.now(),ho.i=po.default.request(ho.scroll)},stop:function(){ho.isScrolling=!1,ho.interaction&&(ho.interaction.autoScroll=null),po.default.cancel(ho.i)},scroll:function(){var t=ho.interaction,e=t.interactable,n=t.element,r=t.prepared.name,o=e.options[r].autoScroll,i=go(o.container,e,n),a=ho.now(),u=(a-ho.prevTime)/1e3,s=o.speed*u;if(1<=s){var l={x:ho.x*s,y:ho.y*s};if(l.x||l.y){var c=bo(i);fo.window(i)?i.scrollBy(l.x,l.y):i&&(i.scrollLeft+=l.x,i.scrollTop+=l.y);var f=bo(i),p={x:f.x-c.x,y:f.y-c.y};(p.x||p.y)&&e.fire({type:"autoscroll",target:n,interactable:e,delta:p,interaction:t,container:i})}ho.prevTime=a}ho.isScrolling&&(po.default.cancel(ho.i),ho.i=po.default.request(ho.scroll))},check:function(t,e){var n=t.options;return n[e].autoScroll&&n[e].autoScroll.enabled},onInteractionMove:function(t){var e=t.interaction,n=t.pointer;if(e.interacting()&&ho.check(e.interactable,e.prepared.name))if(e.simulation)ho.x=ho.y=0;else{var r,o,i,a,u=e.interactable,s=e.element,l=e.prepared.name,c=u.options[l].autoScroll,f=go(c.container,u,s);if(fo.window(f))a=n.clientX<ho.margin,r=n.clientY<ho.margin,o=n.clientX>f.innerWidth-ho.margin,i=n.clientY>f.innerHeight-ho.margin;else{var p=co.getElementClientRect(f);a=n.clientX<p.left+ho.margin,r=n.clientY<p.top+ho.margin,o=n.clientX>p.right-ho.margin,i=n.clientY>p.bottom-ho.margin}ho.x=o?1:a?-1:0,ho.y=i?1:r?-1:0,ho.isScrolling||(ho.margin=c.margin,ho.speed=c.speed,ho.start(e))}}};function go(t,e,n){return(fo.string(t)?(0,$t.getStringOptionResult)(t,e,n):t)||(0,O.getWindow)(n)}function bo(t){return fo.window(t)&&(t=window.document.body),{x:t.scrollLeft,y:t.scrollTop}}var mo={id:"auto-scroll",install:function(t){var e=t.defaults,n=t.actions;(t.autoScroll=ho).now=function(){return t.now()},n.phaselessTypes.autoscroll=!0,e.perAction.autoScroll=ho.defaults},listeners:{"interactions:new":function(t){t.interaction.autoScroll=null},"interactions:destroy":function(t){t.interaction.autoScroll=null,ho.stop(),ho.interaction&&(ho.interaction=null)},"interactions:stop":ho.stop,"interactions:action-move":function(t){return ho.onInteractionMove(t)}}};uo.default=mo;var Oo={};function wo(t){return(wo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Oo,"__esModule",{value:!0}),Oo.default=void 0;var _o=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==wo(t)&&"function"!=typeof t)return{default:t};var e=Po();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function Po(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Po=function(){return t},t}function xo(t){return _o.bool(t)?(this.options.styleCursor=t,this):null===t?(delete this.options.styleCursor,this):this.options.styleCursor}function So(t){return _o.func(t)?(this.options.actionChecker=t,this):null===t?(delete this.options.actionChecker,this):this.options.actionChecker}var jo={id:"auto-start/interactableMethods",install:function(d){var t=d.Interactable;t.prototype.getAction=function(t,e,n,r){var o,i,a,u,s,l,c,f,p=(i=e,a=n,u=r,s=d,l=(o=this).getRect(u),c=i.buttons||{0:1,1:4,3:8,4:16}[i.button],f={action:null,interactable:o,interaction:a,element:u,rect:l,buttons:c},s.fire("auto-start:check",f),f.action);return this.options.actionChecker?this.options.actionChecker(t,e,p,this,r,n):p},t.prototype.ignoreFrom=(0,le.warnOnce)(function(t){return this._backCompatOption("ignoreFrom",t)},"Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."),t.prototype.allowFrom=(0,le.warnOnce)(function(t){return this._backCompatOption("allowFrom",t)},"Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."),t.prototype.actionChecker=So,t.prototype.styleCursor=xo}};Oo.default=jo;var Mo={};function ko(t){return(ko="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Mo,"__esModule",{value:!0}),Mo.default=void 0;var Eo,To=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==ko(t)&&"function"!=typeof t)return{default:t};var e=Io();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),Do=(Eo=Oo)&&Eo.__esModule?Eo:{default:Eo};function Io(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Io=function(){return t},t}function zo(t,e,n,r,o){return e.testIgnoreAllow(e.options[t.name],n,r)&&e.options[t.name].enabled&&Ro(e,n,t,o)?t:null}function Ao(t,e,n,r,o,i,a){for(var u=0,s=r.length;u<s;u++){var l=r[u],c=o[u],f=l.getAction(e,n,t,c);if(f){var p=zo(f,l,c,i,a);if(p)return{action:p,interactable:l,element:c}}}return{action:null,interactable:null,element:null}}function Co(t,e,n,r,o){var i=[],a=[],u=r;function s(t){i.push(t),a.push(u)}for(;To.is.element(u);){i=[],a=[],o.interactables.forEachMatch(u,s);var l=Ao(t,e,n,i,a,r,o);if(l.action&&!l.interactable.options[l.action.name].manualStart)return l;u=To.dom.parentNode(u)}return{action:null,interactable:null,element:null}}function Wo(t,e,n){var r=e.action,o=e.interactable,i=e.element;r=r||{name:null},t.interactable=o,t.element=i,To.copyAction(t.prepared,r),t.rect=o&&r.name?o.getRect(i):null,Yo(t,n),n.fire("autoStart:prepared",{interaction:t})}function Ro(t,e,n,r){var o=t.options,i=o[n.name].max,a=o[n.name].maxPerElement,u=r.autoStart.maxInteractions,s=0,l=0,c=0;if(!(i&&a&&u))return!1;for(var f=0;f<r.interactions.list.length;f++){var p=r.interactions.list[f],d=p.prepared.name;if(p.interacting()){if(u<=++s)return!1;if(p.interactable===t){if(i<=(l+=d===n.name?1:0))return!1;if(p.element===e&&(c++,d===n.name&&a<=c))return!1}}}return 0<u}function Fo(t,e){return To.is.number(t)?(e.autoStart.maxInteractions=t,this):e.autoStart.maxInteractions}function Xo(t,e,n){var r=n.autoStart.cursorElement;r&&r!==t&&(r.style.cursor=""),t.ownerDocument.documentElement.style.cursor=e,t.style.cursor=e,n.autoStart.cursorElement=e?t:null}function Yo(t,e){var n=t.interactable,r=t.element,o=t.prepared;if("mouse"===t.pointerType&&n&&n.options.styleCursor){var i="";if(o.name){var a=n.options[o.name].cursorChecker;i=To.is.func(a)?a(o,n,r,t._interacting):e.actions.map[o.name].getCursor(o)}Xo(t.element,i||"",e)}else e.autoStart.cursorElement&&Xo(e.autoStart.cursorElement,"",e)}var No={id:"auto-start/base",before:["actions","actions/drag","actions/resize","actions/gesture"],install:function(e){var t=e.interactStatic,n=e.defaults;e.usePlugin(Do.default),n.base.actionChecker=null,n.base.styleCursor=!0,To.extend(n.perAction,{manualStart:!1,max:1/0,maxPerElement:1,allowFrom:null,ignoreFrom:null,mouseButtons:1}),t.maxInteractions=function(t){return Fo(t,e)},e.autoStart={maxInteractions:1/0,withinInteractionLimit:Ro,cursorElement:null}},listeners:{"interactions:down":function(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget;n.interacting()||Wo(n,Co(n,r,o,i,e),e)},"interactions:move":function(t,e){var n,r,o,i,a,u;r=e,o=(n=t).interaction,i=n.pointer,a=n.event,u=n.eventTarget,"mouse"!==o.pointerType||o.pointerIsDown||o.interacting()||Wo(o,Co(o,i,a,u,r),r),function(t,e){var n=t.interaction;if(n.pointerIsDown&&!n.interacting()&&n.pointerWasMoved&&n.prepared.name){e.fire("autoStart:before-start",t);var r=n.interactable,o=n.prepared.name;o&&r&&(r.options[o].manualStart||!Ro(r,n.element,n.prepared,e)?n.stop():(n.start(n.prepared,r,n.element),Yo(n,e)))}}(t,e)},"interactions:stop":function(t,e){var n=t.interaction,r=n.interactable;r&&r.options.styleCursor&&Xo(n.element,"",e)}},maxInteractions:Fo,withinInteractionLimit:Ro,validateAction:zo};Mo.default=No;var Lo={};function Bo(t){return(Bo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Lo,"__esModule",{value:!0}),Lo.default=void 0;var Vo,qo=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Bo(t)&&"function"!=typeof t)return{default:t};var e=Go();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w),Uo=(Vo=Mo)&&Vo.__esModule?Vo:{default:Vo};function Go(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Go=function(){return t},t}var Ho={id:"auto-start/dragAxis",listeners:{"autoStart:before-start":function(t,r){var o=t.interaction,i=t.eventTarget,e=t.dx,n=t.dy;if("drag"===o.prepared.name){var a=Math.abs(e),u=Math.abs(n),s=o.interactable.options.drag,l=s.startAxis,c=u<a?"x":a<u?"y":"xy";if(o.prepared.axis="start"===s.lockAxis?c[0]:s.lockAxis,"xy"!=c&&"xy"!==l&&l!==c){o.prepared.name=null;function f(t){if(t!==o.interactable){var e=o.interactable.options.drag;if(!e.manualStart&&t.testIgnoreAllow(e,p,i)){var n=t.getAction(o.downPointer,o.downEvent,o,p);if(n&&"drag"===n.name&&function(t,e){if(!e)return;var n=e.options.drag.startAxis;return"xy"===t||"xy"===n||n===t}(c,t)&&Uo.default.validateAction(n,t,p,i,r))return t}}}for(var p=i;qo.element(p);){var d=r.interactables.forEachMatch(p,f);if(d){o.prepared.name="drag",o.interactable=d,o.element=p;break}p=(0,$.parentNode)(p)}}}}}};Lo.default=Ho;var Ko={};Object.defineProperty(Ko,"__esModule",{value:!0}),Ko.default=void 0;var $o,Zo=($o=Mo)&&$o.__esModule?$o:{default:$o};function Jo(t){var e=t.prepared&&t.prepared.name;if(!e)return null;var n=t.interactable.options;return n[e].hold||n[e].delay}var Qo={id:"auto-start/hold",install:function(t){var e=t.defaults;t.usePlugin(Zo.default),e.perAction.hold=0,e.perAction.delay=0},listeners:{"interactions:new":function(t){t.interaction.autoStartHoldTimer=null},"autoStart:prepared":function(t){var e=t.interaction,n=Jo(e);0<n&&(e.autoStartHoldTimer=setTimeout(function(){e.start(e.prepared,e.interactable,e.element)},n))},"interactions:move":function(t){var e=t.interaction,n=t.duplicate;e.pointerWasMoved&&!n&&clearTimeout(e.autoStartHoldTimer)},"autoStart:before-start":function(t){var e=t.interaction;0<Jo(e)&&(e.prepared.name=null)}},getHoldDuration:Jo};Ko.default=Qo;var ti={};Object.defineProperty(ti,"__esModule",{value:!0}),Object.defineProperty(ti,"autoStart",{enumerable:!0,get:function(){return ei.default}}),Object.defineProperty(ti,"dragAxis",{enumerable:!0,get:function(){return ni.default}}),Object.defineProperty(ti,"hold",{enumerable:!0,get:function(){return ri.default}}),ti.default=void 0;var ei=oi(Mo),ni=oi(Lo),ri=oi(Ko);function oi(t){return t&&t.__esModule?t:{default:t}}var ii={id:"auto-start",install:function(t){t.usePlugin(ei.default),t.usePlugin(ri.default),t.usePlugin(ni.default)}};ti.default=ii;var ai={};Object.defineProperty(ai,"__esModule",{value:!0}),ai.default=void 0;ai.default={};var ui={};Object.defineProperty(ui,"__esModule",{value:!0}),ui.default=void 0;ui.default={};var si={};function li(t){return(li="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(si,"__esModule",{value:!0}),si.default=void 0;var ci,fi,pi=hi(D),di=(hi(ct),function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==li(t)&&"function"!=typeof t)return{default:t};var e=yi();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w)),vi=hi(O);function yi(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return yi=function(){return t},t}function hi(t){return t&&t.__esModule?t:{default:t}}(fi=ci=ci||{}).touchAction="touchAction",fi.boxSizing="boxSizing",fi.noListeners="noListeners";var gi={touchAction:"https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action",boxSizing:"https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing"};ci.touchAction,ci.boxSizing,ci.noListeners;function bi(t,e,n){return n.test(t.style[e]||vi.default.window.getComputedStyle(t)[e])}var mi="dev-tools",Oi={id:mi,install:function(){}};si.default=Oi;var wi={};Object.defineProperty(wi,"__esModule",{value:!0}),wi.default=void 0;wi.default={};var _i={};function Pi(t){return(Pi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(_i,"__esModule",{value:!0}),_i.getRectOffset=Ai,_i.default=void 0;var xi=ki(V),Si=ki(ct),ji=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Pi(t)&&"function"!=typeof t)return{default:t};var e=Mi();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function Mi(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Mi=function(){return t},t}function ki(t){return t&&t.__esModule?t:{default:t}}function Ei(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function Ti(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Di(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Ii=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.interaction=t,Di(this,"states",[]),Di(this,"startOffset",{left:0,right:0,top:0,bottom:0}),Di(this,"startDelta",null),Di(this,"result",null),Di(this,"endResult",null),Di(this,"edges",void 0),this.result=zi()}var t,n,r;return t=e,(n=[{key:"start",value:function(t,e){var n=t.phase,r=this.interaction,o=function(t){var n=t.interactable.options[t.prepared.name],e=n.modifiers;if(e&&e.length)return e.filter(function(t){return!t.options||!1!==t.options.enabled});return["snap","snapSize","snapEdges","restrict","restrictEdges","restrictSize"].map(function(t){var e=n[t];return e&&e.enabled&&{options:e,methods:e._methods}}).filter(function(t){return!!t})}(r);this.prepareStates(o),this.edges=(0,Si.default)({},r.edges),this.startOffset=Ai(r.rect,e);var i={phase:n,pageCoords:e,preEnd:!(this.startDelta={x:0,y:0})};return this.result=zi(),this.startAll(i),this.result=this.setAll(i)}},{key:"fillArg",value:function(t){var e=this.interaction;t.interaction=e,t.interactable=e.interactable,t.element=e.element,t.rect=t.rect||e.rect,t.edges=this.edges,t.startOffset=this.startOffset}},{key:"startAll",value:function(t){this.fillArg(t);for(var e=0;e<this.states.length;e++){var n=this.states[e];n.methods.start&&(t.state=n).methods.start(t)}}},{key:"setAll",value:function(t){this.fillArg(t);var e=t.phase,n=t.preEnd,r=t.skipModifiers,o=t.rect;t.coords=(0,Si.default)({},t.pageCoords),t.rect=(0,Si.default)({},o);for(var i=r?this.states.slice(r):this.states,a=zi(t.coords,t.rect),u=0;u<i.length;u++){var s=i[u],l=s.options,c=(0,Si.default)({},t.coords),f=null;s.methods.set&&this.shouldDo(l,n,e)&&(f=(t.state=s).methods.set(t),ji.addEdges(this.interaction.edges,t.rect,{x:t.coords.x-c.x,y:t.coords.y-c.y})),a.eventProps.push(f)}a.delta.x=t.coords.x-t.pageCoords.x,a.delta.y=t.coords.y-t.pageCoords.y,a.rectDelta.left=t.rect.left-o.left,a.rectDelta.right=t.rect.right-o.right,a.rectDelta.top=t.rect.top-o.top,a.rectDelta.bottom=t.rect.bottom-o.bottom;var p=this.result.coords,d=this.result.rect;if(p&&d){var v=a.rect.left!==d.left||a.rect.right!==d.right||a.rect.top!==d.top||a.rect.bottom!==d.bottom;a.changed=v||p.x!==a.coords.x||p.y!==a.coords.y}return a}},{key:"applyToInteraction",value:function(t){var e=this.interaction,n=t.phase,r=e.coords.cur,o=e.coords.start,i=this.result,a=this.startDelta,u=i.delta;"start"===n&&(0,Si.default)(this.startDelta,i.delta);for(var s=0;s<[[o,a],[r,u]].length;s++){var l=Ei([[o,a],[r,u]][s],2),c=l[0],f=l[1];c.page.x+=f.x,c.page.y+=f.y,c.client.x+=f.x,c.client.y+=f.y}var p=this.result.rectDelta,d=t.rect||e.rect;d.left+=p.left,d.right+=p.right,d.top+=p.top,d.bottom+=p.bottom,d.width=d.right-d.left,d.height=d.bottom-d.top}},{key:"setAndApply",value:function(t){var e=this.interaction,n=t.phase,r=t.preEnd,o=t.skipModifiers,i=this.setAll({preEnd:r,phase:n,pageCoords:t.modifiedCoords||e.coords.cur.page});if(!(this.result=i).changed&&(!o||o<this.states.length)&&e.interacting())return!1;if(t.modifiedCoords){var a=e.coords.cur.page,u=t.modifiedCoords.x-a.x,s=t.modifiedCoords.y-a.y;i.coords.x+=u,i.coords.y+=s,i.delta.x+=u,i.delta.y+=s}this.applyToInteraction(t)}},{key:"beforeEnd",value:function(t){var e=t.interaction,n=t.event,r=this.states;if(r&&r.length){for(var o=!1,i=0;i<r.length;i++){var a=r[i],u=(t.state=a).options,s=a.methods,l=s.beforeEnd&&s.beforeEnd(t);if(l)return this.endResult=l,!1;o=o||!o&&this.shouldDo(u,!0,t.phase,!0)}o&&e.move({event:n,preEnd:!0})}}},{key:"stop",value:function(t){var e=t.interaction;if(this.states&&this.states.length){var n=(0,Si.default)({states:this.states,interactable:e.interactable,element:e.element,rect:null},t);this.fillArg(n);for(var r=0;r<this.states.length;r++){var o=this.states[r];(n.state=o).methods.stop&&o.methods.stop(n)}this.states=null,this.endResult=null}}},{key:"prepareStates",value:function(t){this.states=[];for(var e=0;e<t.length;e++){var n=t[e],r=n.options,o=n.methods,i=n.name;r&&!1===r.enabled||this.states.push({options:r,methods:o,index:e,name:i})}return this.states}},{key:"restoreInteractionCoords",value:function(t){var e=t.interaction,n=e.coords,r=e.rect,o=e.modification;if(o.result){for(var i=o.startDelta,a=o.result,u=a.delta,s=a.rectDelta,l=[[n.start,i],[n.cur,u]],c=0;c<l.length;c++){var f=Ei(l[c],2),p=f[0],d=f[1];p.page.x-=d.x,p.page.y-=d.y,p.client.x-=d.x,p.client.y-=d.y}r.left-=s.left,r.right-=s.right,r.top-=s.top,r.bottom-=s.bottom}}},{key:"shouldDo",value:function(t,e,n,r){return!(!t||!1===t.enabled||r&&!t.endOnly||t.endOnly&&!e||"start"===n&&!t.setStart)}},{key:"copyFrom",value:function(t){this.startOffset=t.startOffset,this.startDelta=t.startDelta,this.edges=t.edges,this.states=t.states.map(function(t){return(0,xi.default)(t)}),this.result=zi((0,Si.default)({},t.result.coords),(0,Si.default)({},t.result.rect))}},{key:"destroy",value:function(){for(var t in this)this[t]=null}}])&&Ti(t.prototype,n),r&&Ti(t,r),e}();function zi(t,e){return{rect:e,coords:t,delta:{x:0,y:0},rectDelta:{left:0,right:0,top:0,bottom:0},eventProps:[],changed:!0}}function Ai(t,e){return t?{left:e.x-t.left,top:e.y-t.top,right:t.right-e.x,bottom:t.bottom-e.y}:{left:0,top:0,right:0,bottom:0}}_i.default=Ii;var Ci={};Object.defineProperty(Ci,"__esModule",{value:!0}),Ci.makeModifier=function(t,r){function e(t){var e=t||{};for(var n in e.enabled=!1!==e.enabled,o)n in e||(e[n]=o[n]);return{options:e,methods:i,name:r}}var o=t.defaults,i={start:t.start,set:t.set,beforeEnd:t.beforeEnd,stop:t.stop};r&&"string"==typeof r&&(e._defaults=o,e._methods=i);return e},Ci.addEventModifiers=Fi,Ci.default=void 0;var Wi,Ri=(Wi=_i)&&Wi.__esModule?Wi:{default:Wi};function Fi(t){var e=t.iEvent,n=t.interaction.modification.result;n&&(e.modifiers=n.eventProps)}var Xi={id:"modifiers/base",install:function(t){t.defaults.perAction.modifiers=[]},listeners:{"interactions:new":function(t){var e=t.interaction;e.modification=new Ri.default(e)},"interactions:before-action-start":function(t){var e=t.interaction.modification;e.start(t,t.interaction.coords.start.page),t.interaction.edges=e.edges,e.applyToInteraction(t)},"interactions:before-action-move":function(t){return t.interaction.modification.setAndApply(t)},"interactions:before-action-end":function(t){return t.interaction.modification.beforeEnd(t)},"interactions:action-start":Fi,"interactions:action-move":Fi,"interactions:action-end":Fi,"interactions:after-action-start":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-move":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:stop":function(t){return t.interaction.modification.stop(t)}},before:["actions","action/drag","actions/resize","actions/gesture"]};Ci.default=Xi;var Yi={};function Ni(t){return(Ni="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Yi,"__esModule",{value:!0}),Yi.addTotal=Vi,Yi.applyPending=Ui,Yi.default=void 0;var Li=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Ni(t)&&"function"!=typeof t)return{default:t};var e=Bi();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function Bi(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Bi=function(){return t},t}function Vi(t){t.pointerIsDown&&(Hi(t.coords.cur,t.offset.total),t.offset.pending.x=0,t.offset.pending.y=0)}function qi(t){Ui(t.interaction)}function Ui(t){if(!(e=t).offset.pending.x&&!e.offset.pending.y)return!1;var e,n=t.offset.pending;return Hi(t.coords.cur,n),Hi(t.coords.delta,n),Li.addEdges(t.edges,t.rect,n),n.x=0,!(n.y=0)}function Gi(t){var e=t.x,n=t.y;this.offset.pending.x+=e,this.offset.pending.y+=n,this.offset.total.x+=e,this.offset.total.y+=n}function Hi(t,e){var n=t.page,r=t.client,o=e.x,i=e.y;n.x+=o,n.y+=i,r.x+=o,r.y+=i}En._ProxyMethods.offsetBy="";var Ki={id:"offset",install:function(t){t.Interaction.prototype.offsetBy=Gi},listeners:{"interactions:new":function(t){t.interaction.offset={total:{x:0,y:0},pending:{x:0,y:0}}},"interactions:update-pointer":function(t){return Vi(t.interaction)},"interactions:before-action-start":qi,"interactions:before-action-move":qi,"interactions:before-action-end":function(t){var e=t.interaction;if(Ui(e))return e.move({offset:!0}),e.end(),!1},"interactions:stop":function(t){var e=t.interaction;e.offset.total.x=0,e.offset.total.y=0,e.offset.pending.x=0,e.offset.pending.y=0}}};Yi.default=Ki;var $i={};function Zi(t){return(Zi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty($i,"__esModule",{value:!0}),$i.default=$i.InertiaState=void 0;var Ji=ua(_i),Qi=aa(Ci),ta=ua(Yi),ea=aa($),na=ua(Et),ra=aa(w),oa=ua(oe);function ia(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ia=function(){return t},t}function aa(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Zi(t)&&"function"!=typeof t)return{default:t};var e=ia();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function ua(t){return t&&t.__esModule?t:{default:t}}function sa(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function la(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var ca=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.interaction=t,la(this,"active",!1),la(this,"isModified",!1),la(this,"smoothEnd",!1),la(this,"allowResume",!1),la(this,"modification",null),la(this,"modifierCount",0),la(this,"modifierArg",null),la(this,"startCoords",null),la(this,"t0",0),la(this,"v0",0),la(this,"te",0),la(this,"targetOffset",null),la(this,"modifiedOffset",null),la(this,"currentOffset",null),la(this,"lambda_v0",0),la(this,"one_ve_v0",0),la(this,"timeout",null)}var t,n,r;return t=e,(n=[{key:"start",value:function(t){var e=this.interaction,n=fa(e);if(!n||!n.enabled)return!1;var r=e.coords.velocity.client,o=(0,na.default)(r.x,r.y),i=this.modification||(this.modification=new Ji.default(e));if(i.copyFrom(e.modification),this.t0=e._now(),this.allowResume=n.allowResume,this.v0=o,this.currentOffset={x:0,y:0},this.startCoords=e.coords.cur.page,this.modifierArg={interaction:e,interactable:e.interactable,element:e.element,rect:e.rect,edges:e.edges,pageCoords:this.startCoords,preEnd:!0,phase:"inertiastart"},this.t0-e.coords.cur.timeStamp<50&&o>n.minSpeed&&o>n.endSpeed)this.startInertia();else{if(i.result=i.setAll(this.modifierArg),!i.result.changed)return!1;this.startSmoothEnd()}return e.modification.result.rect=null,e.offsetBy(this.targetOffset),e._doPhase({interaction:e,event:t,phase:"inertiastart"}),e.offsetBy({x:-this.targetOffset.x,y:-this.targetOffset.y}),e.modification.result.rect=null,this.active=!0,e.simulation=this,!0}},{key:"startInertia",value:function(){var t=this,e=this.interaction.coords.velocity.client,n=fa(this.interaction),r=n.resistance,o=-Math.log(n.endSpeed/this.v0)/r;this.targetOffset={x:(e.x-o)/r,y:(e.y-o)/r},this.te=o,this.lambda_v0=r/this.v0,this.one_ve_v0=1-n.endSpeed/this.v0;var i=this.modification,a=this.modifierArg;a.pageCoords={x:this.startCoords.x+this.targetOffset.x,y:this.startCoords.y+this.targetOffset.y},i.result=i.setAll(a),i.result.changed&&(this.isModified=!0,this.modifiedOffset={x:this.targetOffset.x+i.result.delta.x,y:this.targetOffset.y+i.result.delta.y}),this.timeout=oa.default.request(function(){return t.inertiaTick()})}},{key:"startSmoothEnd",value:function(){var t=this;this.smoothEnd=!0,this.isModified=!0,this.targetOffset={x:this.modification.result.delta.x,y:this.modification.result.delta.y},this.timeout=oa.default.request(function(){return t.smoothEndTick()})}},{key:"inertiaTick",value:function(){var t,e,n,r,o,i,a,u=this,s=this.interaction,l=fa(s).resistance,c=(s._now()-this.t0)/1e3;if(c<this.te){var f,p=1-(Math.exp(-l*c)-this.lambda_v0)/this.one_ve_v0,d={x:(f=this.isModified?(e=t=0,n=this.targetOffset.x,r=this.targetOffset.y,o=this.modifiedOffset.x,i=this.modifiedOffset.y,{x:pa(a=p,t,n,o),y:pa(a,e,r,i)}):{x:this.targetOffset.x*p,y:this.targetOffset.y*p}).x-this.currentOffset.x,y:f.y-this.currentOffset.y};this.currentOffset.x+=d.x,this.currentOffset.y+=d.y,s.offsetBy(d),s.move(),this.timeout=oa.default.request(function(){return u.inertiaTick()})}else s.offsetBy({x:this.modifiedOffset.x-this.currentOffset.x,y:this.modifiedOffset.y-this.currentOffset.y}),this.end()}},{key:"smoothEndTick",value:function(){var t=this,e=this.interaction,n=e._now()-this.t0,r=fa(e).smoothEndDuration;if(n<r){var o=da(n,0,this.targetOffset.x,r),i=da(n,0,this.targetOffset.y,r),a={x:o-this.currentOffset.x,y:i-this.currentOffset.y};this.currentOffset.x+=a.x,this.currentOffset.y+=a.y,e.offsetBy(a),e.move({skipModifiers:this.modifierCount}),this.timeout=oa.default.request(function(){return t.smoothEndTick()})}else e.offsetBy({x:this.targetOffset.x-this.currentOffset.x,y:this.targetOffset.y-this.currentOffset.y}),this.end()}},{key:"resume",value:function(t){var e=t.pointer,n=t.event,r=t.eventTarget,o=this.interaction;o.offsetBy({x:-this.currentOffset.x,y:-this.currentOffset.y}),o.updatePointer(e,n,r,!0),o._doPhase({interaction:o,event:n,phase:"resume"}),(0,zt.copyCoords)(o.coords.prev,o.coords.cur),this.stop()}},{key:"end",value:function(){this.interaction.move(),this.interaction.end(),this.stop()}},{key:"stop",value:function(){this.active=this.smoothEnd=!1,this.interaction.simulation=null,oa.default.cancel(this.timeout)}}])&&sa(t.prototype,n),r&&sa(t,r),e}();function fa(t){var e=t.interactable,n=t.prepared;return e&&e.options&&n.name&&e.options[n.name].inertia}function pa(t,e,n,r){var o=1-t;return o*o*e+2*o*t*n+t*t*r}function da(t,e,n,r){return-n*(t/=r)*(t-2)+e}$i.InertiaState=ca;var va={id:"inertia",before:["modifiers/base"],install:function(t){var e=t.defaults;t.usePlugin(ta.default),t.usePlugin(Qi.default),t.actions.phases.inertiastart=!0,t.actions.phases.resume=!0,e.perAction.inertia={enabled:!1,resistance:10,minSpeed:100,endSpeed:10,allowResume:!0,smoothEndDuration:300}},listeners:{"interactions:new":function(t){var e=t.interaction;e.inertia=new ca(e)},"interactions:before-action-end":function(t){var e=t.interaction,n=t.event;return(!e._interacting||e.simulation||!e.inertia.start(n))&&null},"interactions:down":function(t){var e=t.interaction,n=t.eventTarget,r=e.inertia;if(r.active)for(var o=n;ra.element(o);){if(o===e.element){r.resume(t);break}o=ea.parentNode(o)}},"interactions:stop":function(t){var e=t.interaction.inertia;e.active&&e.stop()},"interactions:before-action-resume":function(t){var e=t.interaction.modification;e.stop(t),e.start(t,t.interaction.coords.cur.page),e.applyToInteraction(t)},"interactions:before-action-inertiastart":function(t){return t.interaction.modification.setAndApply(t)},"interactions:action-resume":Qi.addEventModifiers,"interactions:action-inertiastart":Qi.addEventModifiers,"interactions:after-action-inertiastart":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-resume":function(t){return t.interaction.modification.restoreInteractionCoords(t)}}};$i.default=va;var ya,ha={};function ga(t){return(ga="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(ha,"__esModule",{value:!0}),ha.init=ha.default=void 0;var ba=new(((ya=m({}))&&ya.__esModule?ya:{default:ya}).default),ma=ba.interactStatic;ha.default=ma;function Oa(t){return ba.init(t)}ha.init=Oa,"object"===("undefined"==typeof window?"undefined":ga(window))&&window&&Oa(window);var wa={};Object.defineProperty(wa,"__esModule",{value:!0}),wa.default=void 0;wa.default={};var _a={};Object.defineProperty(_a,"__esModule",{value:!0}),_a.default=void 0;_a.default={};var Pa={};function xa(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}Object.defineProperty(Pa,"__esModule",{value:!0}),Pa.default=void 0;Pa.default=function(v){function t(t,e){for(var n=v.range,r=v.limits,o=void 0===r?{left:-1/0,right:1/0,top:-1/0,bottom:1/0}:r,i=v.offset,a=void 0===i?{x:0,y:0}:i,u={range:n,grid:v,x:null,y:null},s=0;s<y.length;s++){var l=xa(y[s],2),c=l[0],f=l[1],p=Math.round((t-a.x)/v[c]),d=Math.round((e-a.y)/v[f]);u[c]=Math.max(o.left,Math.min(o.right,p*v[c]+a.x)),u[f]=Math.max(o.top,Math.min(o.bottom,d*v[f]+a.y))}return u}var y=[["x","y"],["left","top"],["right","bottom"],["width","height"]].filter(function(t){var e=xa(t,2),n=e[0],r=e[1];return n in v||r in v});return t.grid=v,t.coordFields=y,t};var Sa={};Object.defineProperty(Sa,"__esModule",{value:!0}),Object.defineProperty(Sa,"edgeTarget",{enumerable:!0,get:function(){return ja.default}}),Object.defineProperty(Sa,"elements",{enumerable:!0,get:function(){return Ma.default}}),Object.defineProperty(Sa,"grid",{enumerable:!0,get:function(){return ka.default}});var ja=Ea(wa),Ma=Ea(_a),ka=Ea(Pa);function Ea(t){return t&&t.__esModule?t:{default:t}}var Ta={};function Da(t){return(Da="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ta,"__esModule",{value:!0}),Ta.default=void 0;var Ia,za=(Ia=ct)&&Ia.__esModule?Ia:{default:Ia},Aa=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Da(t)&&"function"!=typeof t)return{default:t};var e=Ca();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(Sa);function Ca(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Ca=function(){return t},t}var Wa={id:"snappers",install:function(t){var e=t.interactStatic;e.snappers=(0,za.default)(e.snappers||{},Aa),e.createSnapGrid=e.snappers.grid}};Ta.default=Wa;var Ra={};Object.defineProperty(Ra,"__esModule",{value:!0}),Ra.aspectRatio=Ra.default=void 0;var Fa=Ya(ct),Xa=Ya(_i);function Ya(t){return t&&t.__esModule?t:{default:t}}function Na(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function La(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Na(Object(n),!0).forEach(function(t){Ba(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Na(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function Ba(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Va={start:function(t){var e=t.state,n=t.rect,r=t.edges,o=t.pageCoords,i=e.options.ratio,a=e.options,u=a.equalDelta,s=a.modifiers;"preserve"===i&&(i=n.width/n.height),e.startCoords=(0,Fa.default)({},o),e.startRect=(0,Fa.default)({},n),e.ratio=i,e.equalDelta=u;var l=e.linkedEdges={top:r.top||r.left&&!r.bottom,left:r.left||r.top&&!r.right,bottom:r.bottom||r.right&&!r.top,right:r.right||r.bottom&&!r.left};if(e.xIsPrimaryAxis=!(!r.left&&!r.right),e.equalDelta)e.edgeSign=(l.left?1:-1)*(l.top?1:-1);else{var c=e.xIsPrimaryAxis?l.top:l.left;e.edgeSign=c?-1:1}if((0,Fa.default)(t.edges,l),s&&s.length){var f=new Xa.default(t.interaction);f.copyFrom(t.interaction.modification),f.prepareStates(s),(e.subModification=f).startAll(La({},t))}},set:function(t){var e=t.state,n=t.rect,r=t.coords,o=(0,Fa.default)({},r),i=e.equalDelta?qa:Ua;if(i(e,e.xIsPrimaryAxis,r,n),!e.subModification)return null;var a=(0,Fa.default)({},n);(0,$t.addEdges)(e.linkedEdges,a,{x:r.x-o.x,y:r.y-o.y});var u=e.subModification.setAll(La({},t,{rect:a,edges:e.linkedEdges,pageCoords:r,prevCoords:r,prevRect:a})),s=u.delta;u.changed&&(i(e,Math.abs(s.x)>Math.abs(s.y),u.coords,u.rect),(0,Fa.default)(r,u.coords));return u.eventProps},defaults:{ratio:"preserve",equalDelta:!1,modifiers:[],enabled:!1}};function qa(t,e,n){var r=t.startCoords,o=t.edgeSign;e?n.y=r.y+(n.x-r.x)*o:n.x=r.x+(n.y-r.y)*o}function Ua(t,e,n,r){var o=t.startRect,i=t.startCoords,a=t.ratio,u=t.edgeSign;if(e){var s=r.width/a;n.y=i.y+(s-o.height)*u}else{var l=r.height*a;n.x=i.x+(l-o.width)*u}}Ra.aspectRatio=Va;var Ga=(0,Ci.makeModifier)(Va,"aspectRatio");Ra.default=Ga;var Ha={};Object.defineProperty(Ha,"__esModule",{value:!0}),Ha.default=void 0;function Ka(){}Ka._defaults={};var $a=Ka;Ha.default=$a;var Za={};function Ja(t){return(Ja="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Za,"__esModule",{value:!0}),Za.getRestrictionRect=iu,Za.restrict=Za.default=void 0;var Qa,tu=(Qa=ct)&&Qa.__esModule?Qa:{default:Qa},eu=ou(w),nu=ou($t);function ru(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ru=function(){return t},t}function ou(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Ja(t)&&"function"!=typeof t)return{default:t};var e=ru();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function iu(t,e,n){return eu.func(t)?nu.resolveRectLike(t,e.interactable,e.element,[n.x,n.y,e]):nu.resolveRectLike(t,e.interactable,e.element)}var au={start:function(t){var e=t.rect,n=t.startOffset,r=t.state,o=t.interaction,i=t.pageCoords,a=r.options,u=a.elementRect,s=(0,tu.default)({left:0,top:0,right:0,bottom:0},a.offset||{});if(e&&u){var l=iu(a.restriction,o,i);if(l){var c=l.right-l.left-e.width,f=l.bottom-l.top-e.height;c<0&&(s.left+=c,s.right+=c),f<0&&(s.top+=f,s.bottom+=f)}s.left+=n.left-e.width*u.left,s.top+=n.top-e.height*u.top,s.right+=n.right-e.width*(1-u.right),s.bottom+=n.bottom-e.height*(1-u.bottom)}r.offset=s},set:function(t){var e=t.coords,n=t.interaction,r=t.state,o=r.options,i=r.offset,a=iu(o.restriction,n,e);if(a){var u=nu.xywhToTlbr(a);e.x=Math.max(Math.min(u.right-i.right,e.x),u.left+i.left),e.y=Math.max(Math.min(u.bottom-i.bottom,e.y),u.top+i.top)}},defaults:{restriction:null,elementRect:null,offset:null,endOnly:!1,enabled:!1}};Za.restrict=au;var uu=(0,Ci.makeModifier)(au,"restrict");Za.default=uu;var su={};function lu(t){return(lu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(su,"__esModule",{value:!0}),su.restrictEdges=su.default=void 0;var cu,fu=(cu=ct)&&cu.__esModule?cu:{default:cu},pu=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==lu(t)&&"function"!=typeof t)return{default:t};var e=du();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function du(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return du=function(){return t},t}var vu={top:1/0,left:1/0,bottom:-1/0,right:-1/0},yu={top:-1/0,left:-1/0,bottom:1/0,right:1/0};function hu(t,e){for(var n=["top","left","bottom","right"],r=0;r<n.length;r++){var o=n[r];o in t||(t[o]=e[o])}return t}var gu={noInner:vu,noOuter:yu,start:function(t){var e,n=t.interaction,r=t.startOffset,o=t.state,i=o.options;if(i){var a=(0,Za.getRestrictionRect)(i.offset,n,n.coords.start.page);e=pu.rectToXY(a)}e=e||{x:0,y:0},o.offset={top:e.y+r.top,left:e.x+r.left,bottom:e.y-r.bottom,right:e.x-r.right}},set:function(t){var e=t.coords,n=t.edges,r=t.interaction,o=t.state,i=o.offset,a=o.options;if(n){var u=(0,fu.default)({},e),s=(0,Za.getRestrictionRect)(a.inner,r,u)||{},l=(0,Za.getRestrictionRect)(a.outer,r,u)||{};hu(s,vu),hu(l,yu),n.top?e.y=Math.min(Math.max(l.top+i.top,u.y),s.top+i.top):n.bottom&&(e.y=Math.max(Math.min(l.bottom+i.bottom,u.y),s.bottom+i.bottom)),n.left?e.x=Math.min(Math.max(l.left+i.left,u.x),s.left+i.left):n.right&&(e.x=Math.max(Math.min(l.right+i.right,u.x),s.right+i.right))}},defaults:{inner:null,outer:null,offset:null,endOnly:!1,enabled:!1}};su.restrictEdges=gu;var bu=(0,Ci.makeModifier)(gu,"restrictEdges");su.default=bu;var mu,Ou={};Object.defineProperty(Ou,"__esModule",{value:!0}),Ou.restrictRect=Ou.default=void 0;var wu=(0,((mu=ct)&&mu.__esModule?mu:{default:mu}).default)({get elementRect(){return{top:0,left:0,bottom:1,right:1}},set elementRect(t){}},Za.restrict.defaults),_u={start:Za.restrict.start,set:Za.restrict.set,defaults:wu};Ou.restrictRect=_u;var Pu=(0,Ci.makeModifier)(_u,"restrictRect");Ou.default=Pu;var xu={};function Su(t){return(Su="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(xu,"__esModule",{value:!0}),xu.restrictSize=xu.default=void 0;var ju,Mu=(ju=ct)&&ju.__esModule?ju:{default:ju},ku=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Su(t)&&"function"!=typeof t)return{default:t};var e=Eu();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function Eu(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Eu=function(){return t},t}var Tu={width:-1/0,height:-1/0},Du={width:1/0,height:1/0};var Iu={start:function(t){return su.restrictEdges.start(t)},set:function(t){var e=t.interaction,n=t.state,r=t.rect,o=t.edges,i=n.options;if(o){var a=ku.tlbrToXywh((0,Za.getRestrictionRect)(i.min,e,t.coords))||Tu,u=ku.tlbrToXywh((0,Za.getRestrictionRect)(i.max,e,t.coords))||Du;n.options={endOnly:i.endOnly,inner:(0,Mu.default)({},su.restrictEdges.noInner),outer:(0,Mu.default)({},su.restrictEdges.noOuter)},o.top?(n.options.inner.top=r.bottom-a.height,n.options.outer.top=r.bottom-u.height):o.bottom&&(n.options.inner.bottom=r.top+a.height,n.options.outer.bottom=r.top+u.height),o.left?(n.options.inner.left=r.right-a.width,n.options.outer.left=r.right-u.width):o.right&&(n.options.inner.right=r.left+a.width,n.options.outer.right=r.left+u.width),su.restrictEdges.set(t),n.options=i}},defaults:{min:null,max:null,endOnly:!1,enabled:!1}};xu.restrictSize=Iu;var zu=(0,Ci.makeModifier)(Iu,"restrictSize");xu.default=zu;var Au={};Object.defineProperty(Au,"__esModule",{value:!0}),Au.default=void 0;function Cu(){}Cu._defaults={};var Wu=Cu;Au.default=Wu;var Ru={};function Fu(t){return(Fu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ru,"__esModule",{value:!0}),Ru.snap=Ru.default=void 0;var Xu=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Fu(t)&&"function"!=typeof t)return{default:t};var e=Yu();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le);function Yu(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Yu=function(){return t},t}var Nu={start:function(t){var e,n,r,o=t.interaction,i=t.interactable,a=t.element,u=t.rect,s=t.state,l=t.startOffset,c=s.options,f=c.offsetWithOrigin?(n=(e=t).interaction.element,Xu.rect.rectToXY(Xu.rect.resolveRectLike(e.state.options.origin,null,null,[n]))||Xu.getOriginXY(e.interactable,n,e.interaction.prepared.name)):{x:0,y:0};if("startCoords"===c.offset)r={x:o.coords.start.page.x,y:o.coords.start.page.y};else{var p=Xu.rect.resolveRectLike(c.offset,i,a,[o]);(r=Xu.rect.rectToXY(p)||{x:0,y:0}).x+=f.x,r.y+=f.y}var d=c.relativePoints;s.offsets=u&&d&&d.length?d.map(function(t,e){return{index:e,relativePoint:t,x:l.left-u.width*t.x+r.x,y:l.top-u.height*t.y+r.y}}):[Xu.extend({index:0,relativePoint:null},r)]},set:function(t){var e=t.interaction,n=t.coords,r=t.state,o=r.options,i=r.offsets,a=Xu.getOriginXY(e.interactable,e.element,e.prepared.name),u=Xu.extend({},n),s=[];o.offsetWithOrigin||(u.x-=a.x,u.y-=a.y);for(var l=0;l<i.length;l++)for(var c=i[l],f=u.x-c.x,p=u.y-c.y,d=0,v=o.targets.length;d<v;d++){var y=o.targets[d],h=void 0;(h=Xu.is.func(y)?y(f,p,e,c,d):y)&&s.push({x:(Xu.is.number(h.x)?h.x:f)+c.x,y:(Xu.is.number(h.y)?h.y:p)+c.y,range:Xu.is.number(h.range)?h.range:o.range,source:y,index:d,offset:c})}for(var g={target:null,inRange:!1,distance:0,range:0,delta:{x:0,y:0}},b=0;b<s.length;b++){var m=s[b],O=m.range,w=m.x-u.x,_=m.y-u.y,P=Xu.hypot(w,_),x=P<=O;O===1/0&&g.inRange&&g.range!==1/0&&(x=!1),g.target&&!(x?g.inRange&&O!==1/0?P/O<g.distance/g.range:O===1/0&&g.range!==1/0||P<g.distance:!g.inRange&&P<g.distance)||(g.target=m,g.distance=P,g.range=O,g.inRange=x,g.delta.x=w,g.delta.y=_)}return g.inRange&&(n.x=g.target.x,n.y=g.target.y),r.closest=g},defaults:{range:1/0,targets:null,offset:null,offsetWithOrigin:!0,origin:null,relativePoints:null,endOnly:!1,enabled:!1}};Ru.snap=Nu;var Lu=(0,Ci.makeModifier)(Nu,"snap");Ru.default=Lu;var Bu={};function Vu(t){return(Vu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Bu,"__esModule",{value:!0}),Bu.snapSize=Bu.default=void 0;var qu,Uu=(qu=ct)&&qu.__esModule?qu:{default:qu},Gu=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Vu(t)&&"function"!=typeof t)return{default:t};var e=Hu();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function Hu(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Hu=function(){return t},t}function Ku(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var $u={start:function(t){var e=t.state,n=t.edges,r=e.options;if(!n)return null;t.state={options:{targets:null,relativePoints:[{x:n.left?0:1,y:n.top?0:1}],offset:r.offset||"self",origin:{x:0,y:0},range:r.range}},e.targetFields=e.targetFields||[["width","height"],["x","y"]],Ru.snap.start(t),e.offsets=t.state.offsets,t.state=e},set:function(t){var e=t.interaction,n=t.state,r=t.coords,o=n.options,i=n.offsets,a={x:r.x-i[0].x,y:r.y-i[0].y};n.options=(0,Uu.default)({},o),n.options.targets=[];for(var u=0;u<(o.targets||[]).length;u++){var s=(o.targets||[])[u],l=void 0;if(l=Gu.func(s)?s(a.x,a.y,e):s){for(var c=0;c<n.targetFields.length;c++){var f=Ku(n.targetFields[c],2),p=f[0],d=f[1];if(p in l||d in l){l.x=l[p],l.y=l[d];break}}n.options.targets.push(l)}}var v=Ru.snap.set(t);return n.options=o,v},defaults:{range:1/0,targets:null,offset:null,endOnly:!1,enabled:!1}};Bu.snapSize=$u;var Zu=(0,Ci.makeModifier)($u,"snapSize");Bu.default=Zu;var Ju={};Object.defineProperty(Ju,"__esModule",{value:!0}),Ju.snapEdges=Ju.default=void 0;var Qu=es(V),ts=es(ct);function es(t){return t&&t.__esModule?t:{default:t}}var ns={start:function(t){var e=t.edges;return e?(t.state.targetFields=t.state.targetFields||[[e.left?"left":"right",e.top?"top":"bottom"]],Bu.snapSize.start(t)):null},set:Bu.snapSize.set,defaults:(0,ts.default)((0,Qu.default)(Bu.snapSize.defaults),{targets:null,range:null,offset:{x:0,y:0}})};Ju.snapEdges=ns;var rs=(0,Ci.makeModifier)(ns,"snapEdges");Ju.default=rs;var os={};Object.defineProperty(os,"__esModule",{value:!0}),os.default=void 0;function is(){}is._defaults={};var as=is;os.default=as;var us={};Object.defineProperty(us,"__esModule",{value:!0}),us.default=void 0;function ss(){}ss._defaults={};var ls=ss;us.default=ls;var cs={};Object.defineProperty(cs,"__esModule",{value:!0}),cs.default=void 0;var fs=Ps(Ra),ps=Ps(Ha),ds=Ps(su),vs=Ps(Za),ys=Ps(Ou),hs=Ps(xu),gs=Ps(Au),bs=Ps(Ju),ms=Ps(Ru),Os=Ps(Bu),ws=Ps(os),_s=Ps(us);function Ps(t){return t&&t.__esModule?t:{default:t}}var xs={aspectRatio:fs.default,restrictEdges:ds.default,restrict:vs.default,restrictRect:ys.default,restrictSize:hs.default,snapEdges:bs.default,snap:ms.default,snapSize:Os.default,spring:ws.default,avoid:ps.default,transform:_s.default,rubberband:gs.default};cs.default=xs;var Ss={};Object.defineProperty(Ss,"__esModule",{value:!0}),Ss.default=void 0;var js=Es(Ta),Ms=Es(cs),ks=Es(Ci);function Es(t){return t&&t.__esModule?t:{default:t}}var Ts={id:"modifiers",install:function(t){var e=t.interactStatic;for(var n in t.usePlugin(ks.default),t.usePlugin(js.default),e.modifiers=Ms.default,Ms.default){var r=Ms.default[n],o=r._defaults,i=r._methods;o._methods=i,t.defaults.perAction[n]=o}}};Ss.default=Ts;var Ds={};Object.defineProperty(Ds,"__esModule",{value:!0}),Ds.default=void 0;Ds.default={};var Is={};Object.defineProperty(Is,"__esModule",{value:!0}),Is.PointerEvent=Is.default=void 0;var zs,As=(zs=Me)&&zs.__esModule?zs:{default:zs},Cs=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Rs(t)&&"function"!=typeof t)return{default:t};var e=Ws();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(zt);function Ws(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Ws=function(){return t},t}function Rs(t){return(Rs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Fs(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Xs(t){return(Xs=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ys(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ns(t,e){return(Ns=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Ls(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Bs=function(){function f(t,e,n,r,o,i){var a,u,s;if(!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,f),u=this,a=!(s=Xs(f).call(this,o))||"object"!==Rs(s)&&"function"!=typeof s?Ys(u):s,Ls(Ys(a),"type",void 0),Ls(Ys(a),"originalEvent",void 0),Ls(Ys(a),"pointerId",void 0),Ls(Ys(a),"pointerType",void 0),Ls(Ys(a),"double",void 0),Ls(Ys(a),"pageX",void 0),Ls(Ys(a),"pageY",void 0),Ls(Ys(a),"clientX",void 0),Ls(Ys(a),"clientY",void 0),Ls(Ys(a),"dt",void 0),Ls(Ys(a),"eventable",void 0),Cs.pointerExtend(Ys(a),n),n!==e&&Cs.pointerExtend(Ys(a),e),a.timeStamp=i,a.originalEvent=n,a.type=t,a.pointerId=Cs.getPointerId(e),a.pointerType=Cs.getPointerType(e),a.target=r,a.currentTarget=null,"tap"===t){var l=o.getPointerIndex(e);a.dt=a.timeStamp-o.pointers[l].downTime;var c=a.timeStamp-o.tapTime;a.double=!!(o.prevTap&&"doubletap"!==o.prevTap.type&&o.prevTap.target===a.target&&c<500)}else"doubletap"===t&&(a.dt=e.timeStamp-o.tapTime);return a}var t,e,n;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ns(t,e)}(f,As["default"]),t=f,(e=[{key:"_subtractOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX-=e,this.pageY-=n,this.clientX-=e,this.clientY-=n,this}},{key:"_addOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX+=e,this.pageY+=n,this.clientX+=e,this.clientY+=n,this}},{key:"preventDefault",value:function(){this.originalEvent.preventDefault()}}])&&Fs(t.prototype,e),n&&Fs(t,n),f}();Is.PointerEvent=Is.default=Bs;var Vs={};function qs(t){return(qs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Vs,"__esModule",{value:!0}),Vs.default=void 0;Ks(En),Ks(m({}));var Us=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==qs(t)&&"function"!=typeof t)return{default:t};var e=Hs();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),Gs=Ks(Is);function Hs(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Hs=function(){return t},t}function Ks(t){return t&&t.__esModule?t:{default:t}}var $s={id:"pointer-events/base",install:function(t){t.pointerEvents=$s,t.defaults.actions.pointerEvents=$s.defaults,Us.extend(t.actions.phaselessTypes,$s.types)},listeners:{"interactions:new":function(t){var e=t.interaction;e.prevTap=null,e.tapTime=0},"interactions:update-pointer":function(t){var e=t.down,n=t.pointerInfo;if(!e&&n.hold)return;n.hold={duration:1/0,timeout:null}},"interactions:move":function(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.duplicate,u=n.getPointerIndex(r);a||n.pointerIsDown&&!n.pointerWasMoved||(n.pointerIsDown&&clearTimeout(n.pointers[u].hold.timeout),Zs({interaction:n,pointer:r,event:o,eventTarget:i,type:"move"},e))},"interactions:down":function(t,e){!function(t,e){for(var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.pointerIndex,u=n.pointers[a].hold,s=Us.dom.getPath(i),l={interaction:n,pointer:r,event:o,eventTarget:i,type:"hold",targets:[],path:s,node:null},c=0;c<s.length;c++){var f=s[c];l.node=f,e.fire("pointerEvents:collect-targets",l)}if(!l.targets.length)return;for(var p=1/0,d=0;d<l.targets.length;d++){var v=l.targets[d].eventable.options.holdDuration;v<p&&(p=v)}u.duration=p,u.timeout=setTimeout(function(){Zs({interaction:n,eventTarget:i,pointer:r,event:o,type:"hold"},e)},p)}(t,e),Zs(t,e)},"interactions:up":function(t,e){var n,r,o,i,a,u;Qs(t),Zs(t,e),r=e,o=(n=t).interaction,i=n.pointer,a=n.event,u=n.eventTarget,o.pointerWasMoved||Zs({interaction:o,eventTarget:u,pointer:i,event:a,type:"tap"},r)},"interactions:cancel":function(t,e){Qs(t),Zs(t,e)}},PointerEvent:Gs.default,fire:Zs,collectEventTargets:Js,defaults:{holdDuration:600,ignoreFrom:null,allowFrom:null,origin:{x:0,y:0}},types:{down:!0,move:!0,up:!0,cancel:!0,tap:!0,doubletap:!0,hold:!0}};function Zs(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.type,u=t.targets,s=void 0===u?Js(t,e):u,l=new Gs.default(a,r,o,i,n,e.now());e.fire("pointerEvents:new",{pointerEvent:l});for(var c={interaction:n,pointer:r,event:o,eventTarget:i,targets:s,type:a,pointerEvent:l},f=0;f<s.length;f++){var p=s[f];for(var d in p.props||{})l[d]=p.props[d];var v=Us.getOriginXY(p.eventable,p.node);if(l._subtractOrigin(v),l.eventable=p.eventable,l.currentTarget=p.node,p.eventable.fire(l),l._addOrigin(v),l.immediatePropagationStopped||l.propagationStopped&&f+1<s.length&&s[f+1].node!==l.currentTarget)break}if(e.fire("pointerEvents:fired",c),"tap"===a){var y=l.double?Zs({interaction:n,pointer:r,event:o,eventTarget:i,type:"doubletap"},e):l;n.prevTap=y,n.tapTime=y.timeStamp}return l}function Js(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.type,u=n.getPointerIndex(r),s=n.pointers[u];if("tap"===a&&(n.pointerWasMoved||!s||s.downTarget!==i))return[];for(var l=Us.dom.getPath(i),c={interaction:n,pointer:r,event:o,eventTarget:i,type:a,path:l,targets:[],node:null},f=0;f<l.length;f++){var p=l[f];c.node=p,e.fire("pointerEvents:collect-targets",c)}return"hold"===a&&(c.targets=c.targets.filter(function(t){return t.eventable.options.holdDuration===n.pointers[u].hold.duration})),c.targets}function Qs(t){var e=t.interaction,n=t.pointerIndex;e.pointers[n].hold&&clearTimeout(e.pointers[n].hold.timeout)}var tl=$s;Vs.default=tl;var el={};Object.defineProperty(el,"__esModule",{value:!0}),el.default=void 0;rl(Is);var nl=rl(Vs);function rl(t){return t&&t.__esModule?t:{default:t}}function ol(t){var e=t.interaction;e.holdIntervalHandle&&(clearInterval(e.holdIntervalHandle),e.holdIntervalHandle=null)}var il={id:"pointer-events/holdRepeat",install:function(t){t.usePlugin(nl.default);var e=t.pointerEvents;e.defaults.holdRepeatInterval=0,e.types.holdrepeat=t.actions.phaselessTypes.holdrepeat=!0},listeners:["move","up","cancel","endall"].reduce(function(t,e){return t["pointerEvents:".concat(e)]=ol,t},{"pointerEvents:new":function(t){var e=t.pointerEvent;"hold"===e.type&&(e.count=(e.count||0)+1)},"pointerEvents:fired":function(t,e){var n=t.interaction,r=t.pointerEvent,o=t.eventTarget,i=t.targets;if("hold"===r.type&&i.length){var a=i[0].eventable.options.holdRepeatInterval;a<=0||(n.holdIntervalHandle=setTimeout(function(){e.pointerEvents.fire({interaction:n,eventTarget:o,type:"hold",pointer:r,event:r},e)},a))}}})};el.default=il;var al={};Object.defineProperty(al,"__esModule",{value:!0}),al.default=void 0;var ul,sl=(ul=ct)&&ul.__esModule?ul:{default:ul};function ll(t){return(0,sl.default)(this.events.options,t),this}var cl={id:"pointer-events/interactableTargets",install:function(t){var e=t.Interactable;e.prototype.pointerEvents=ll;var r=e.prototype._backCompatOption;e.prototype._backCompatOption=function(t,e){var n=r.call(this,t,e);return n===this&&(this.events.options[t]=e),n}},listeners:{"pointerEvents:collect-targets":function(t,e){var r=t.targets,o=t.node,i=t.type,a=t.eventTarget;e.interactables.forEachMatch(o,function(t){var e=t.events,n=e.options;e.types[i]&&e.types[i].length&&t.testIgnoreAllow(n,o,a)&&r.push({node:o,eventable:e,props:{interactable:t}})})},"interactable:new":function(t){var e=t.interactable;e.events.getRect=function(t){return e.getRect(t)}},"interactable:set":function(t,e){var n=t.interactable,r=t.options;(0,sl.default)(n.events.options,e.pointerEvents.defaults),(0,sl.default)(n.events.options,r.pointerEvents||{})}}};al.default=cl;var fl={};function pl(t){return(pl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(fl,"__esModule",{value:!0}),Object.defineProperty(fl,"holdRepeat",{enumerable:!0,get:function(){return vl.default}}),Object.defineProperty(fl,"interactableTargets",{enumerable:!0,get:function(){return yl.default}}),fl.pointerEvents=fl.default=void 0;var dl=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==pl(t)&&"function"!=typeof t)return{default:t};var e=gl();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(Vs);fl.pointerEvents=dl;var vl=hl(el),yl=hl(al);function hl(t){return t&&t.__esModule?t:{default:t}}function gl(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return gl=function(){return t},t}var bl={id:"pointer-events",install:function(t){t.usePlugin(dl),t.usePlugin(vl.default),t.usePlugin(yl.default)}};fl.default=bl;var ml={};Object.defineProperty(ml,"__esModule",{value:!0}),ml.install=wl,ml.default=void 0;var Ol;(Ol=k({}))&&Ol.__esModule;function wl(e){var t=e.Interactable;e.actions.phases.reflow=!0,t.prototype.reflow=function(t){return function(u,s,l){function t(){var e=c[d],t=u.getRect(e);if(!t)return"break";var n=le.arr.find(l.interactions.list,function(t){return t.interacting()&&t.interactable===u&&t.element===e&&t.prepared.name===s.name}),r=void 0;if(n)n.move(),p&&(r=n._reflowPromise||new f(function(t){n._reflowResolve=t}));else{var o=le.rect.tlbrToXywh(t),i={page:{x:o.x,y:o.y},client:{x:o.x,y:o.y},timeStamp:l.now()},a=le.pointer.coordsToEvent(i);r=function(t,e,n,r,o){var i=t.interactions.new({pointerType:"reflow"}),a={interaction:i,event:o,pointer:o,eventTarget:n,phase:"reflow"};i.interactable=e,i.element=n,i.prepared=(0,le.extend)({},r),i.prevEvent=o,i.updatePointer(o,o,n,!0),i._doPhase(a);var u=le.win.window.Promise?new le.win.window.Promise(function(t){i._reflowResolve=t}):null;i._reflowPromise=u,i.start(r,e,n),i._interacting?(i.move(a),i.end(o)):i.stop();return i.removePointer(o,o),i.pointerIsDown=!1,u}(l,u,e,s,a)}p&&p.push(r)}for(var c=le.is.string(u.target)?le.arr.from(u._context.querySelectorAll(u.target)):[u.target],f=le.win.window.Promise,p=f?[]:null,d=0;d<c.length;d++){if("break"===t())break}return p&&f.all(p).then(function(){return u})}(this,t,e)}}var _l={id:"reflow",install:wl,listeners:{"interactions:stop":function(t,e){var n=t.interaction;"reflow"===n.pointerType&&(n._reflowResolve&&n._reflowResolve(),le.arr.remove(e.interactions.list,n))}}};ml.default=_l;var Pl={};Object.defineProperty(Pl,"__esModule",{value:!0}),Pl.default=void 0;Pl.default={};var xl={};Object.defineProperty(xl,"__esModule",{value:!0}),xl.exchange=void 0;xl.exchange={};var Sl={};Object.defineProperty(Sl,"__esModule",{value:!0}),Sl.default=void 0;Sl.default={};var jl={};function Ml(t){return(Ml="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(jl,"__esModule",{value:!0}),jl.default=void 0;var kl=Hl(Qr),El=Hl(ao),Tl=Hl(uo),Dl=Hl(ti),Il=Hl(ai),zl=Hl(ui),Al=Hl(Un),Cl=(Hl(si),Gl(wi)),Wl=Hl($i),Rl=Hl(ha),Fl=Hl(Ss),Xl=Hl(Ds),Yl=Hl(Yi),Nl=Hl(fl),Ll=Hl(ml),Bl=Gl(Pl),Vl=Gl(zt),ql=Gl(Sl);function Ul(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Ul=function(){return t},t}function Gl(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Ml(t)&&"function"!=typeof t)return{default:t};var e=Ul();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function Hl(t){return t&&t.__esModule?t:{default:t}}Rl.default.use(Xl.default),Rl.default.use(Al.default),Rl.default.use(Yl.default),Rl.default.use(Il.default),Rl.default.use(El.default),Rl.default.use(Nl.default),Rl.default.use(Wl.default),Rl.default.use(Fl.default),Rl.default.use(Dl.default),Rl.default.use(kl.default),Rl.default.use(Tl.default),Rl.default.use(Ll.default),Rl.default.feedback=Cl,Rl.default.use(zl.default),Rl.default.vue={components:ql},Rl.default.__utils={exchange:xl.exchange,displace:Bl,pointer:Vl};var Kl=Rl.default;jl.default=Kl;var $l={exports:{}};Object.defineProperty($l.exports,"__esModule",{value:!0}),$l.exports.default=void 0;var Zl,Jl=(Zl=jl)&&Zl.__esModule?Zl:{default:Zl};function Ql(t){return(Ql="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}if("object"===Ql($l)&&$l)try{$l.exports=Jl.default}catch(t){}Jl.default.default=Jl.default;var tc=Jl.default;return $l.exports.default=tc,$l=$l.exports});



}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],4:[function(require,module,exports){
/*!
 * isect v3.0.0
 * (c) 2018 Andrei Kashcha.
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.isect = {})));
}(this, (function (exports) { 'use strict';

  /* follows "An implementation of top-down splaying"
   * by D. Sleator <sleator@cs.cmu.edu> March 1992
   */

  /**
   * @typedef {*} Key
   */


  /**
   * @typedef {*} Value
   */


  /**
   * @typedef {function(node:Node):void} Visitor
   */


  /**
   * @typedef {function(a:Key, b:Key):number} Comparator
   */


  /**
   * @param {function(node:Node):string} NodePrinter
   */


  /**
   * @typedef {Object}  Node
   * @property {Key}    Key
   * @property {Value=} data
   * @property {Node}   left
   * @property {Node}   right
   */

  var Node = function Node (key, data) {
    this.key  = key;
    this.data = data;
    this.left = null;
    this.right= null;
  };

  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }


  /**
   * Simple top down splay, not requiring i to be in the tree t.
   * @param {Key} i
   * @param {Node?} t
   * @param {Comparator} comparator
   */
  function splay (i, t, comparator) {
    if (t === null) { return t; }
    var l, r, y;
    var N = new Node();
    l = r = N;

    while (true) {
      var cmp = comparator(i, t.key);
      //if (i < t.key) {
      if (cmp < 0) {
        if (t.left === null) { break; }
        //if (i < t.left.key) {
        if (comparator(i, t.left.key) < 0) {
          y = t.left;                           /* rotate right */
          t.left = y.right;
          y.right = t;
          t = y;
          if (t.left === null) { break; }
        }
        r.left = t;                               /* link right */
        r = t;
        t = t.left;
      //} else if (i > t.key) {
      } else if (cmp > 0) {
        if (t.right === null) { break; }
        //if (i > t.right.key) {
        if (comparator(i, t.right.key) > 0) {
          y = t.right;                          /* rotate left */
          t.right = y.left;
          y.left = t;
          t = y;
          if (t.right === null) { break; }
        }
        l.right = t;                              /* link left */
        l = t;
        t = t.right;
      } else {
        break;
      }
    }
    /* assemble */
    l.right = t.left;
    r.left = t.right;
    t.left = N.right;
    t.right = N.left;
    return t;
  }


  /**
   * @param  {Key}        i
   * @param  {Value}      data
   * @param  {Comparator} comparator
   * @param  {Tree}       tree
   * @return {Node}      root
   */
  function insert (i, data, t, comparator, tree) {
    var node = new Node(i, data);

    tree._size++;

    if (t === null) {
      node.left = node.right = null;
      return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp < 0) {
      node.left = t.left;
      node.right = t;
      t.left = null;
    } else if (cmp >= 0) {
      node.right = t.right;
      node.left = t;
      t.right = null;
    }
    return node;
  }


  /**
   * Insert i into the tree t, unless it's already there.
   * @param  {Key}        i
   * @param  {Value}      data
   * @param  {Comparator} comparator
   * @param  {Tree}       tree
   * @return {Node}       root
   */
  function add (i, data, t, comparator, tree) {
    var node = new Node(i, data);

    if (t === null) {
      node.left = node.right = null;
      tree._size++;
      return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp === 0) { return t; }
    else {
      if (cmp < 0) {
        node.left = t.left;
        node.right = t;
        t.left = null;
      } else if (cmp > 0) {
        node.right = t.right;
        node.left = t;
        t.right = null;
      }
      tree._size++;
      return node;
    }
  }


  /**
   * Deletes i from the tree if it's there
   * @param {Key}        i
   * @param {Tree}       tree
   * @param {Comparator} comparator
   * @param {Tree}       tree
   * @return {Node}      new root
   */
  function remove (i, t, comparator, tree) {
    var x;
    if (t === null) { return null; }
    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp === 0) {               /* found it */
      if (t.left === null) {
        x = t.right;
      } else {
        x = splay(i, t.left, comparator);
        x.right = t.right;
      }
      tree._size--;
      return x;
    }
    return t;                         /* It wasn't there */
  }


  function split (key, v, comparator) {
    var left, right;
    if (v === null) {
      left = right = null;
    } else {
      v = splay(key, v, comparator);

      var cmp = comparator(v.key, key);
      if (cmp === 0) {
        left  = v.left;
        right = v.right;
      } else if (cmp < 0) {
        right   = v.right;
        v.right = null;
        left    = v;
      } else {
        left   = v.left;
        v.left = null;
        right  = v;
      }
    }
    return { left: left, right: right };
  }


  function merge (left, right, comparator) {
    if (right === null) { return left; }
    if (left  === null) { return right; }

    right = splay(left.key, right, comparator);
    right.left = left;
    return right;
  }


  /**
   * Prints level of the tree
   * @param  {Node}                        root
   * @param  {String}                      prefix
   * @param  {Boolean}                     isTail
   * @param  {Array<string>}               out
   * @param  {Function(node:Node):String}  printNode
   */
  function printRow (root, prefix, isTail, out, printNode) {
    if (root) {
      out(("" + prefix + (isTail ? '└── ' : '├── ') + (printNode(root)) + "\n"));
      var indent = prefix + (isTail ? '    ' : '│   ');
      if (root.left)  { printRow(root.left,  indent, false, out, printNode); }
      if (root.right) { printRow(root.right, indent, true,  out, printNode); }
    }
  }


  var Tree = function Tree (comparator) {
    if ( comparator === void 0 ) comparator = DEFAULT_COMPARE;

    this._comparator = comparator;
    this._root = null;
    this._size = 0;
  };

  var prototypeAccessors = { size: { configurable: true } };


  /**
   * Inserts a key, allows duplicates
   * @param{Key}  key
   * @param{Value=} data
   * @return {Node|null}
   */
  Tree.prototype.insert = function insert$1 (key, data) {
    return this._root = insert(key, data, this._root, this._comparator, this);
  };


  /**
   * Adds a key, if it is not present in the tree
   * @param{Key}  key
   * @param{Value=} data
   * @return {Node|null}
   */
  Tree.prototype.add = function add$1 (key, data) {
    return this._root = add(key, data, this._root, this._comparator, this);
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.remove = function remove$1 (key) {
    this._root = remove(key, this._root, this._comparator, this);
  };


  /**
   * Removes and returns the node with smallest key
   * @return {?Node}
   */
  Tree.prototype.pop = function pop () {
    var node = this._root;
    if (node) {
      while (node.left) { node = node.left; }
      this._root = splay(node.key,this._root, this._comparator);
      this._root = remove(node.key, this._root, this._comparator, this);
      return { key: node.key, data: node.data };
    }
    return null;
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.findStatic = function findStatic (key) {
    var current = this._root;
    var compare = this._comparator;
    while (current) {
      var cmp = compare(key, current.key);
      if (cmp === 0)  { return current; }
      else if (cmp < 0) { current = current.left; }
      else            { current = current.right; }
    }
    return null;
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.find = function find (key) {
    if (this._root) {
      this._root = splay(key, this._root, this._comparator);
      if (this._comparator(key, this._root.key) !== 0) { return null; }
    }
    return this._root;
  };


  /**
   * @param{Key} key
   * @return {Boolean}
   */
  Tree.prototype.contains = function contains (key) {
    var current = this._root;
    var compare = this._comparator;
    while (current) {
      var cmp = compare(key, current.key);
      if (cmp === 0)  { return true; }
      else if (cmp < 0) { current = current.left; }
      else            { current = current.right; }
    }
    return false;
  };


  /**
   * @param{Visitor} visitor
   * @param{*=}    ctx
   * @return {SplayTree}
   */
  Tree.prototype.forEach = function forEach (visitor, ctx) {
    var current = this._root;
    var Q = [];/* Initialize stack s */
    var done = false;

    while (!done) {
      if (current !==null) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length !== 0) {
          current = Q.pop();
          visitor.call(ctx, current);

          current = current.right;
        } else { done = true; }
      }
    }
    return this;
  };


  /**
   * Walk key range from `low` to `high`. Stops if `fn` returns a value.
   * @param{Key}    low
   * @param{Key}    high
   * @param{Function} fn
   * @param{*?}     ctx
   * @return {SplayTree}
   */
  Tree.prototype.range = function range (low, high, fn, ctx) {
      var this$1 = this;

    var Q = [];
    var compare = this._comparator;
    var node = this._root, cmp;

    while (Q.length !== 0 || node) {
      if (node) {
        Q.push(node);
        node = node.left;
      } else {
        node = Q.pop();
        cmp = compare(node.key, high);
        if (cmp > 0) {
          break;
        } else if (compare(node.key, low) >= 0) {
          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned
        }
        node = node.right;
      }
    }
    return this;
  };


  /**
   * Returns array of keys
   * @return {Array<Key>}
   */
  Tree.prototype.keys = function keys () {
    var keys = [];
    this.forEach(function (ref) {
        var key = ref.key;

        return keys.push(key);
      });
    return keys;
  };


  /**
   * Returns array of all the data in the nodes
   * @return {Array<Value>}
   */
  Tree.prototype.values = function values () {
    var values = [];
    this.forEach(function (ref) {
        var data = ref.data;

        return values.push(data);
      });
    return values;
  };


  /**
   * @return {Key|null}
   */
  Tree.prototype.min = function min () {
    if (this._root) { return this.minNode(this._root).key; }
    return null;
  };


  /**
   * @return {Key|null}
   */
  Tree.prototype.max = function max () {
    if (this._root) { return this.maxNode(this._root).key; }
    return null;
  };


  /**
   * @return {Node|null}
   */
  Tree.prototype.minNode = function minNode (t) {
      if ( t === void 0 ) t = this._root;

    if (t) { while (t.left) { t = t.left; } }
    return t;
  };


  /**
   * @return {Node|null}
   */
  Tree.prototype.maxNode = function maxNode (t) {
      if ( t === void 0 ) t = this._root;

    if (t) { while (t.right) { t = t.right; } }
    return t;
  };


  /**
   * Returns node at given index
   * @param{number} index
   * @return {?Node}
   */
  Tree.prototype.at = function at (index) {
    var current = this._root, done = false, i = 0;
    var Q = [];

    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = Q.pop();
          if (i === index) { return current; }
          i++;
          current = current.right;
        } else { done = true; }
      }
    }
    return null;
  };


  /**
   * @param{Node} d
   * @return {Node|null}
   */
  Tree.prototype.next = function next (d) {
    var root = this._root;
    var successor = null;

    if (d.right) {
      successor = d.right;
      while (successor.left) { successor = successor.left; }
      return successor;
    }

    var comparator = this._comparator;
    while (root) {
      var cmp = comparator(d.key, root.key);
      if (cmp === 0) { break; }
      else if (cmp < 0) {
        successor = root;
        root = root.left;
      } else { root = root.right; }
    }

    return successor;
  };


  /**
   * @param{Node} d
   * @return {Node|null}
   */
  Tree.prototype.prev = function prev (d) {
    var root = this._root;
    var predecessor = null;

    if (d.left !== null) {
      predecessor = d.left;
      while (predecessor.right) { predecessor = predecessor.right; }
      return predecessor;
    }

    var comparator = this._comparator;
    while (root) {
      var cmp = comparator(d.key, root.key);
      if (cmp === 0) { break; }
      else if (cmp < 0) { root = root.left; }
      else {
        predecessor = root;
        root = root.right;
      }
    }
    return predecessor;
  };


  /**
   * @return {SplayTree}
   */
  Tree.prototype.clear = function clear () {
    this._root = null;
    this._size = 0;
    return this;
  };


  /**
   * @return {NodeList}
   */
  Tree.prototype.toList = function toList$1 () {
    return toList(this._root);
  };


  /**
   * Bulk-load items. Both array have to be same size
   * @param{Array<Key>}  keys
   * @param{Array<Value>}[values]
   * @param{Boolean}     [presort=false] Pre-sort keys and values, using
   *                                       tree's comparator. Sorting is done
   *                                       in-place
   * @return {AVLTree}
   */
  Tree.prototype.load = function load (keys, values, presort) {
      if ( keys === void 0 ) keys = [];
      if ( values === void 0 ) values = [];
      if ( presort === void 0 ) presort = false;

    var size = keys.length;
    var comparator = this._comparator;

    // sort if needed
    if (presort) { sort(keys, values, 0, size - 1, comparator); }

    if (this._root === null) { // empty tree
      this._root = loadRecursive(this._root, keys, values, 0, size);
      this._size = size;
    } else { // that re-builds the whole tree from two in-order traversals
      var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
      size = this._size + size;
      this._root = sortedListToBST({ head: mergedList }, 0, size);
    }
    return this;
  };


  /**
   * @return {Boolean}
   */
  Tree.prototype.isEmpty = function isEmpty () { return this._root === null; };

  prototypeAccessors.size.get = function () { return this._size; };


  /**
   * @param{NodePrinter=} printNode
   * @return {String}
   */
  Tree.prototype.toString = function toString (printNode) {
      if ( printNode === void 0 ) printNode = function (n) { return n.key; };

    var out = [];
    printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);
    return out.join('');
  };


  Tree.prototype.update = function update (key, newKey, newData) {
    var comparator = this._comparator;
    var ref = split(key, this._root, comparator);
      var left = ref.left;
      var right = ref.right;
    this._size--;
    if (comparator(key, newKey) < 0) {
      right = insert(newKey, newData, right, comparator, this);
    } else {
      left = insert(newKey, newData, left, comparator, this);
    }
    this._root = merge(left, right, comparator);
  };


  Tree.prototype.split = function split$1 (key) {
    return split(key, this._root, this._comparator);
  };

  Object.defineProperties( Tree.prototype, prototypeAccessors );


  function loadRecursive (parent, keys, values, start, end) {
    var size = end - start;
    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var key    = keys[middle];
      var data   = values[middle];
      var node   = { key: key, data: data, parent: parent };
      node.left    = loadRecursive(node, keys, values, start, middle);
      node.right   = loadRecursive(node, keys, values, middle + 1, end);
      return node;
    }
    return null;
  }


  function createList(keys, values) {
    var head = { next: null };
    var p = head;
    for (var i = 0; i < keys.length; i++) {
      p = p.next = { key: keys[i], data: values[i] };
    }
    p.next = null;
    return head.next;
  }


  function toList (root) {
    var current = root;
    var Q = [], done = false;

    var head = { next: null };
    var p = head;

    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = p = p.next = Q.pop();
          current = current.right;
        } else { done = true; }
      }
    }
    p.next = null; // that'll work even if the tree was empty
    return head.next;
  }


  function sortedListToBST(list, start, end) {
    var size = end - start;
    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var left = sortedListToBST(list, start, middle);

      var root = list.head;
      root.left = left;

      list.head = list.head.next;

      root.right = sortedListToBST(list, middle + 1, end);
      return root;
    }
    return null;
  }


  function mergeLists (l1, l2, compare) {
    if ( compare === void 0 ) compare = function (a, b) { return a - b; };

    var head = {}; // dummy
    var p = head;

    var p1 = l1;
    var p2 = l2;

    while (p1 !== null && p2 !== null) {
      if (compare(p1.key, p2.key) < 0) {
        p.next = p1;
        p1 = p1.next;
      } else {
        p.next = p2;
        p2 = p2.next;
      }
      p = p.next;
    }

    if (p1 !== null)      { p.next = p1; }
    else if (p2 !== null) { p.next = p2; }

    return head.next;
  }


  function sort(keys, values, left, right, compare) {
    if (left >= right) { return; }

    var pivot = keys[(left + right) >> 1];
    var i = left - 1;
    var j = right + 1;

    while (true) {
      do { i++; } while (compare(keys[i], pivot) < 0);
      do { j--; } while (compare(keys[j], pivot) > 0);
      if (i >= j) { break; }

      var tmp = keys[i];
      keys[i] = keys[j];
      keys[j] = tmp;

      tmp = values[i];
      values[i] = values[j];
      values[j] = tmp;
    }

    sort(keys, values,  left,     j, compare);
    sort(keys, values, j + 1, right, compare);
  }

  function createEventQueue(byY) {
    var q = new Tree(byY);

    return {
      isEmpty: isEmpty,
      size: size,
      pop: pop,
      find: find,
      insert: insert
    }

    function find(p) {
      return q.find(p);
    }

    function size() {
      return q.size;
    }

    function isEmpty() {
      return q.isEmpty();
    }

    function insert(event) {
      // debugger;
      q.add(event.point, event);
    }

    function pop() {
      var node = q.pop();
      return node && node.data;
    }
  }

  /**
   * Just a collection of geometry related utilities
   */

  // This is used for precision checking (e.g. two numbers are equal
  // if their difference is smaller than this number). The value is 
  // chosen empirically. We still may run into precision related issues.
  // TODO: we should allow consumers to configure this.
  var EPS = 1e-9;//10;

  function getIntersectionXPoint(segment, xPos, yPos) {
    var dy1 = segment.from.y - yPos;
    var dy2 = yPos - segment.to.y;
    var dy = segment.to.y - segment.from.y;
    if (Math.abs(dy1) < EPS) {
      // The segment starts on the sweep line
      if (Math.abs(dy) < EPS) {
        // the segment is horizontal. Intersection is at the point
        if (xPos <= segment.from.x) { return segment.from.x; }
        if (xPos > segment.to.x) { return segment.to.x; }
        return xPos;
      }
      return segment.from.x;
    }
    
    var dx = (segment.to.x - segment.from.x); 
    var xOffset; 
    if (dy1 >= dy2) {
      xOffset = dy1 * (dx / dy); 
      return (segment.from.x - xOffset);
    } 
    xOffset = dy2 * (dx / dy);
    return (segment.to.x + xOffset);
  }

  function angle(dx, dy) {
    // https://stackoverflow.com/questions/16542042/fastest-way-to-sort-vectors-by-angle-without-actually-computing-that-angle
    var p = dx/(Math.abs(dx) + Math.abs(dy)); // -1 .. 1 increasing with x

    if (dy < 0) { return p - 1; }  // -2 .. 0 increasing with x
    return 1 - p               //  0 .. 2 decreasing with x
  }

  function intersectSegments(a, b) {
    //  https://stackoverflow.com/a/1968345/125351
    var aStart = a.from, bStart = b.from;
    var p0_x = aStart.x, p0_y = aStart.y,
        p2_x = bStart.x, p2_y = bStart.y;

    var s1_x = a.dx, s1_y = a.dy, s2_x = b.dx, s2_y = b.dy;
    var div = s1_x * s2_y - s2_x * s1_y;

    var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
    if (s < 0 || s > 1) { return; }

    var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

    if (t >= 0 && t <= 1) {
      return {
        x: p0_x - (t * s1_x),
        y: p0_y - (t * s1_y)
      }
    }
  }

  function samePoint(a, b) {
    return Math.abs(a.x - b.x) < EPS && Math.abs(a.y - b.y) < EPS;
  }

  /**
   * Creates a new sweep status data structure.
   */
  function createSweepStatus(onError, EPS$$1) {
    var lastPointY, prevY;
    var lastPointX, prevX;
    var useBelow = false;
    var status = new Tree(compareSegments);

    // To save on GC we return mutable object.
    var currentBoundary = {
      beforeLeft: null,
      left: null,
      right: null,
      afterRight: null,
    };

    var currentLeftRight = {left: null, right: null};

    return {
      /**
       * Add new segments into the status tree.
       */
      insertSegments: insertSegments,

      /**
       * Remove segments from the status tree.
       */
      deleteSegments: deleteSegments,

      /**
       * Returns segments that are to the left and right from a given point.
       */
      getLeftRightPoint: getLeftRightPoint,

      /**
       * For a given collections of segments finds the most left and the most right
       * segments. Also returns segments immediately before left, and after right segments.
       */
      getBoundarySegments: getBoundarySegments,

      findSegmentsWithPoint: findSegmentsWithPoint,

      /**
       * Current binary search tree with segments
       */
      status: status,

      /**
       * Introspection method that verifies if there are duplicates in the segment tree.
       * If there are - `onError()` is called.
       */
      checkDuplicate: checkDuplicate,

      /**
       * Prints current segments in order of their intersection with sweep line. Introspection method.
       */
      printStatus: printStatus,

      /**
       * Returns current position of the sweep line.
       */
      getLastPoint: function getLastPoint() {
        return {x: lastPointX, y: lastPointY};
      }
    }

    function compareSegments(a, b) {
      if (a === b) { return 0; }

      var ak = getIntersectionXPoint(a, lastPointX, lastPointY);
      var bk = getIntersectionXPoint(b, lastPointX, lastPointY);

      var res = ak - bk;
      if (Math.abs(res) >= EPS$$1) {
        // We are okay fine. Intersection distance between two segments
        // is good to give conclusive answer
        return res;
      }

      var aIsHorizontal = Math.abs(a.dy) < EPS$$1;
      var bIsHorizontal = Math.abs(b.dy) < EPS$$1;
      if (aIsHorizontal && bIsHorizontal) {
        return b.to.x - a.to.x;
      }
      // TODO: What if both a and b is horizontal?
      // move horizontal to end
      if (aIsHorizontal) { 
        return useBelow ? -1 : 1;
      }

      if (bIsHorizontal) {
        if (useBelow) {
          return (b.from.x >= lastPointX) ? -1 : 1
        }
        return -1;
        // return useBelow ? 1 : -1;
      }
      var pa = a.angle;
      var pb = b.angle;
      if (Math.abs(pa - pb) >= EPS$$1) {
        return useBelow ? pa - pb : pb - pa;
      }

      var segDist = a.from.y - b.from.y;
      if (Math.abs(segDist) >= EPS$$1) {
        return -segDist;
      }
      segDist = a.to.y - b.to.y;
      if (Math.abs(segDist) >= EPS$$1) {
        // TODO: Is this accurate?
        return -segDist;
      }

      return 0;
      // Could also use:
      // var aAngle = Math.atan2(a.from.y - a.to.y, a.from.x - a.to.x);
      // var bAngle = Math.atan2(b.from.y - b.to.y, b.from.x - b.to.x);
      // return useBelow ? bAngle - aAngle : aAngle - bAngle;
    }

    function getBoundarySegments(upper, interior) {
      var leftMost, rightMost, i;
      var uLength = upper.length;

      if (uLength > 0) {
        leftMost = rightMost = upper[0];
      } else {
        leftMost = rightMost = interior[0];
      }

      for (i = 1; i < uLength; ++i) {
        var s = upper[i];
        var cmp = compareSegments(leftMost, s);
        if (cmp > 0) { leftMost = s; }

        cmp = compareSegments(rightMost, s);
        if (cmp < 0) { rightMost = s; }
      }

      var startFrom = uLength > 0 ? 0 : 1;
      for (i = startFrom; i < interior.length; ++i) {
        s = interior[i];
        cmp = compareSegments(leftMost, s);
        if (cmp > 0) { leftMost = s; }

        cmp = compareSegments(rightMost, s);
        if (cmp < 0) { rightMost = s; }
      }

      // at this point we have our left/right segments in the status.
      // Let's find their prev/next elements and report them back:
      var left = status.find(leftMost);
      if (!left) {
        onError('Left is missing. Precision error?');
      }

      var right = status.find(rightMost);
      if (!right) {
        onError('Right is missing. Precision error?');
      }

      var beforeLeft = left && status.prev(left);
      var afterRight = right && status.next(right);

      while (afterRight && right.key.dy === 0 && afterRight.key.dy === 0) {
        // horizontal segments are special :(
        afterRight = status.next(afterRight);
      }

      currentBoundary.beforeLeft = beforeLeft && beforeLeft.key;
      currentBoundary.left = left && left.key;
      currentBoundary.right = right && right.key;
      currentBoundary.afterRight = afterRight && afterRight.key;

      return currentBoundary;
    }

    function getLeftRightPoint(p) {
      // We are trying to find left and right segments that are nearest to the
      // point p. For this we traverse the binary search tree, and remember
      // node with the shortest distance to p.
      var lastLeft;
      var current = status._root;
      var minX = Number.POSITIVE_INFINITY;
      while (current) {
        var x = getIntersectionXPoint(current.key, p.x, p.y);
        var dx = p.x - x;
        if (dx >= 0) {
          if (dx < minX) {
            minX = dx;
            lastLeft = current;
            current = current.left;
          } else {
            break;
          }
        } else {
          if (-dx < minX) {
            minX = -dx;
            lastLeft = current;
            current = current.right;
          } else {
            break;
          }
        }
      }

      currentLeftRight.left = lastLeft && lastLeft.key;
      var next = lastLeft && status.next(lastLeft);
      currentLeftRight.right = next && next.key;
      return currentLeftRight;

      // Conceptually, the code above should be equivalent to the code below;
      // The code below is easier to understand, but intuitively, the code above
      // should have better performance (as we do not traverse the entire status
      // tree)

      // var right, left,  x;
      // var all = status.keys()
      // for (var i = 0; i < all.length; ++i) {
      //   var segment = all[i];
      //   x = getIntersectionXPoint(segment, p.x, p.y);
      //   if (x > p.x && !right) {
      //     right = segment;
      //     break;
      //   } else if (x < p.x) {
      //     left = segment;
      //   }
      // }

      // currentLeftRight.left = left;
      // currentLeftRight.right = right;

      // return currentLeftRight;
    }

    function findSegmentsWithPoint(p, onFound) {
      // Option 1.
      // var arrResults = [];
      // status.forEach(current => {
      //   var x = getIntersectionXPoint(current.key, p.x, p.y);
      //   var dx = p.x - x;
      //   if (Math.abs(dx) < EPS) {
      //     onFound(current.key);
      //    // arrResults.push(current.key)
      //   }
      // });
      // return arrResults;

      // Option 2.

      // let current = status._root;
      // const Q = [];  /* Initialize stack s */
      // let done = false;
      // var res = [];
      // var breakEarly = false;

      // while (!done) {
      //   if (current !==  null) {
      //     Q.push(current);
      //     current = current.left;
      //   } else {
      //     if (Q.length !== 0) {
      //       current = Q.pop();

      //       var x = getIntersectionXPoint(current.key, p.x, p.y);
      //       var dx = p.x - x;
      //       if (Math.abs(dx) < EPS) {
      //         res.push(current.key)
      //         breakEarly = true;
      //       } else if (breakEarly) {
      //         done = true;
      //       }

      //       current = current.right;
      //     } else done = true;
      //   }
      // }

      // return res;

      // option 3.
      var current = status._root;

      while (current) {
        var x = getIntersectionXPoint(current.key, p.x, p.y);
        var dx = p.x - x;
        if (Math.abs(dx) < EPS$$1) {
          collectAdjacentNodes(current, p, onFound);
          break;
        } else if (dx < 0) {
          current = current.left;
        } else {
          current = current.right;
        }
      }
    }

    function collectAdjacentNodes(root, p, onFound) {
      onFound(root.key);
      goOverPredecessors(root.left, p, onFound);
      goOverSuccessors(root.right, p, onFound);
    }

    function goOverPredecessors(root, p, res) {
      if (!root) { return; }
      var x = getIntersectionXPoint(root.key, p.x, p.y);
      var dx = p.x - x;
      if (Math.abs(dx) < EPS$$1) {
        collectAdjacentNodes(root, p, res);
      } else {
        goOverPredecessors(root.right, p, res);
      }
    }

    function goOverSuccessors(root, p, res) {
      if (!root) { return; }
      var x = getIntersectionXPoint(root.key, p.x, p.y);
      var dx = p.x - x;
      if (Math.abs(dx) < EPS$$1) {
        collectAdjacentNodes(root, p, res);
      } else {
        goOverSuccessors(root.left, p, res);
      }
    }

    function checkDuplicate() {
      var prev;
      status.forEach(function (node) {
        var current = node.key;

        if (prev) {
          if (samePoint(prev.from, current.from) && samePoint(prev.to, current.to)) {
            // Likely you have received error before during segment removal.
            onError('Duplicate key in the status! This may be caused by Floating Point rounding error');
          }
        }
        prev = current;
      });
    }

    function printStatus(prefix) {
      if ( prefix === void 0 ) prefix = '';

      // eslint-disable-next-line
      console.log(prefix, 'status line: ', lastPointX, lastPointY);
      status.forEach(function (node) {
        var x = getIntersectionXPoint(node.key, lastPointX, lastPointY);
        // eslint-disable-next-line
        console.log(x + ' ' + node.key.name);
      });
    }

    function insertSegments(interior, upper, sweepLinePos) {
      lastPointY = sweepLinePos.y;
      lastPointX = sweepLinePos.x;
      var key;

      for (var i = 0; i < interior.length; ++i) {
        key = interior[i];
        status.add(key);
      }
      for (i = 0; i < upper.length; ++i) {
        key = upper[i];
        status.add(key);
      }
    }

    function deleteSegments(lower, interior, sweepLinePos) {
      // I spent most of the time debugging this method. Depending on the
      // algorithm state we can run into situation when dynamic keys of the
      // `status` tree predict wrong branch, and thus we are not able to find
      // the segment that needs to be deleted. If that happens I'm trying to
      // use previous point and repeat the process. This may result in 
      // incorrect state. In that case I report an error. 
      var i;
      var prevCount = status._size;
      prevX = lastPointX;
      prevY = lastPointY;
      lastPointY = sweepLinePos.y;
      lastPointX = sweepLinePos.x;

      useBelow = true;
      for(i = 0; i < lower.length; ++i) {
        removeSegment(lower[i], sweepLinePos);
      }
      for(i = 0; i < interior.length; ++i) {
        removeSegment(interior[i], sweepLinePos);
      }
      useBelow = false;

      if (status._size !== prevCount - interior.length - lower.length) {
        // This can happen when rounding error occurs. You can try scaling your input
        onError('Segments were not removed from a tree properly. Precision error?');
      }
    }

    function removeSegment(key, sweepLinePos) {
      if (status.find(key)) {
        status.remove(key);
      } else {
        lastPointX = prevX;
        lastPointY = prevY;
        if (status.find(key)) {
          status.remove(key);
        }
        lastPointY = sweepLinePos.y;
        lastPointX = sweepLinePos.x;
      }
    }
  }

  /**
   * Represents a single event in the sweep-line algorithm
   */
  var SweepEvent = function SweepEvent(point, segment) {
    this.point = point;
    if (segment) { this.from = [segment]; }
  };

  /**
   * A point on a line
   * 
   * @typedef {Object} Point
   * @property {number} x coordinate
   * @property {number} y coordinate
   */


  /**
   * @typedef {Object} Segment 
   * @property {Point} from start of the segment
   * @property {Point} to end of the segment
   */

  /**
   * @typedef {function(point : Point, interior : Segment[], lower : Segment[], upper : Segment[])} ReportIntersectionCallback
   */

  /**
   * @typedef {Object} ISectOptions 
   * @property {ReportIntersectionCallback} onFound 
   */

   /**
    * @typedef {Object} ISectResult
    */

  // We use EMPTY array to avoid pressure on garbage collector. Need to be
  // very cautious to not mutate this array.
  var EMPTY = [];

  /**
   * Finds all intersections among given segments.
   * 
   * The algorithm follows "Computation Geometry, Algorithms and Applications" book
   * by Mark de Berg, Otfried Cheong, Marc van Kreveld, and Mark Overmars.
   * 
   * Line is swept top-down
   * 
   * @param {Segment[]} segments
   * @param {ISectOptions=} options
   * @returns {ISectResult}
   */
  function isect(segments, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || defaultIntersectionReporter;

    var onError = (options && options.onError) || defaultErrorReporter;

    var eventQueue = createEventQueue(byY);
    var sweepStatus = createSweepStatus(onError, EPS);
    var lower, interior, lastPoint;

    segments.forEach(addSegment);

    return {
      /**
       * Find all intersections synchronously.
       * 
       * @returns array of found intersections.
       */
      run: run,

      /**
       * Performs a single step in the sweep line algorithm
       * 
       * @returns true if there was something to process; False if no more work to do
       */
      step: step,

      // Methods below are low level API for fine-grained control.
      // Don't use it unless you understand this code thoroughly

      /**
       * Add segment into the 
       */
      addSegment: addSegment,

      /**
       * Direct access to event queue. Queue contains segment endpoints and
       * pending detected intersections.
       */
      eventQueue: eventQueue, 

      /**
       * Direct access to sweep line status. "Status" holds information about
       * all intersected segments.
       */
      sweepStatus: sweepStatus,

      /**
       * Access to results array. Works only when you use default onFound() handler
       */
      results: results
    }

    function run() {
      while (!eventQueue.isEmpty()) {
        var eventPoint = eventQueue.pop();
        if (handleEventPoint(eventPoint)) {
          // they decided to stop.
          return;
        }    }

      return results;
    }

    function step() {
      if (!eventQueue.isEmpty()) {
        var eventPoint = eventQueue.pop();
        handleEventPoint(eventPoint);
        // Note: we don't check results of `handleEventPoint()`
        // assumption is that client controls `step()` and thus they 
        // know better if they want to stop.
        return true;
      }
      return false;
    }

    function handleEventPoint(p) {
      lastPoint = p.point;
      var upper = p.from || EMPTY;

      lower = interior = undefined;
      // TODO: move lower/interior into sweep status method?

      sweepStatus.findSegmentsWithPoint(lastPoint, addLowerOrInterior);
      // if (segmentsWithPoint) {
      //   segmentsWithPoint.forEach()
      // } 

      if (!lower) { lower = EMPTY; }
      if (!interior) { interior = EMPTY; }

      var uLength = upper.length;
      var iLength = interior.length;
      var lLength = lower.length;
      var hasIntersection = uLength + iLength + lLength > 1;
      var hasPointIntersection = !hasIntersection && (uLength === 0 && lLength === 0 && iLength > 0);

      if (hasIntersection || hasPointIntersection) {
        p.isReported = true;
        if (reportIntersection(lastPoint, union(interior, union(lower, upper)))) {
          return true;
        }
      }

      sweepStatus.deleteSegments(lower, interior, lastPoint);
      sweepStatus.insertSegments(interior, upper, lastPoint);

      var sLeft, sRight;

      var hasNoCrossing = (uLength + iLength === 0);

      if (hasNoCrossing) {
        var leftRight = sweepStatus.getLeftRightPoint(lastPoint);
        sLeft = leftRight.left;
        if (!sLeft) { return; }

        sRight = leftRight.right;
        if (!sRight) { return; }

        findNewEvent(sLeft, sRight, p);
      } else {
        var boundarySegments = sweepStatus.getBoundarySegments(upper, interior);

        findNewEvent(boundarySegments.beforeLeft, boundarySegments.left, p);
        findNewEvent(boundarySegments.right, boundarySegments.afterRight, p);
      }

      return false;
    }

    function addLowerOrInterior(s) {
      if (samePoint(s.to, lastPoint)) {
        if (!lower) { lower = [s]; }
        else { lower.push(s); }
      } else if (!samePoint(s.from, lastPoint)) {
        if (!interior) { interior = [s]; }
        else { interior.push(s); }
      }
    }

    function findNewEvent(left, right, p) {
      if (!left || !right) { return; }

      var intersection = intersectSegments(left, right);
      if (!intersection) {
          return;
      }

      var dy = p.point.y - intersection.y;
      // TODO: should I add dy to intersection.y?
      if (dy < -EPS) {
        // this means intersection happened after the sweep line. 
        // We already processed it.
        return;
      }
      if (Math.abs(dy) < EPS && intersection.x <= p.point.x) {
        return;
      }

      // Need to adjust floating point for this special case,
      // since otherwise it gives rounding errors:
      roundNearZero(intersection);

      var current = eventQueue.find(intersection);

      if (current && current.isReported) {
        // We already reported this event. No need to add it one more time
        // TODO: Is this case even possible?
        onError('We already reported this event.');
        return;
      }

      if (!current) {
        var event = new SweepEvent(intersection);
        eventQueue.insert(event);
      }
    }

    function defaultIntersectionReporter(p, segments) {
      results.push({
        point: p, 
        segments: segments
      });
    }

    function addSegment(segment) {
      var from = segment.from;
      var to = segment.to;

      // Small numbers give more precision errors. Rounding them to 0.
      roundNearZero(from);
      roundNearZero(to);

      var dy = from.y - to.y;

      // Note: dy is much smaller then EPS on purpose. I found that higher
      // precision here does less good - getting way more rounding errors.
      if (Math.abs(dy) < 1e-5) {
        from.y = to.y;
        segment.dy = 0;
      }
      if ((from.y < to.y) || (
          (from.y === to.y) && (from.x > to.x))
        ) {
        var temp = from;
        from = segment.from = to; 
        to = segment.to = temp;
      }

      // We pre-compute some immutable properties of the segment
      // They are used quite often in the tree traversal, and pre-computation
      // gives significant boost:
      segment.dy = from.y - to.y;
      segment.dx = from.x - to.x;
      segment.angle = angle(segment.dy, segment.dx);

      var isPoint = segment.dy === segment.dx && segment.dy === 0;
      var prev = eventQueue.find(from);
      if (prev && !isPoint) {
        // this detects identical segments early. Without this check
        // the algorithm would break since sweep line has no means to
        // detect identical segments.
        var prevFrom = prev.data.from;
        if (prevFrom) {
          for (var i = 0; i < prevFrom.length; ++i) {
            var s = prevFrom[i];
            if (samePoint(s.to, to)) {
              reportIntersection(s.from, [s.from, s.to]);
              reportIntersection(s.to, [s.from, s.to]);
              return;
            }
          }
        }
      }

      if (!isPoint) {
        if (prev) {
          if (prev.data.from) { prev.data.from.push(segment); }
          else { prev.data.from = [segment]; }
        } else {
          var e = new SweepEvent(from, segment);
          eventQueue.insert(e);
        }
        var event = new SweepEvent(to);
        eventQueue.insert(event);
      } else {
        var event = new SweepEvent(to);
        eventQueue.insert(event);
      }
    } 
  }

  function roundNearZero(point) {
    if (Math.abs(point.x) < EPS) { point.x = 0; }
    if (Math.abs(point.y) < EPS) { point.y = 0; }
  }

  function defaultErrorReporter(errorMessage) {
    throw new Error(errorMessage);
  }

  function union(a, b) {
    if (!a) { return b; }
    if (!b) { return a; }

    return a.concat(b);
  }

  function byY(a, b) {
    // decreasing Y 
    var res = b.y - a.y;
    // TODO: This might mess up the status tree.
    if (Math.abs(res) < EPS) {
      // increasing x.
      res = a.x - b.x;
      if (Math.abs(res) < EPS) { res = 0; }
    }

    return res;
  }

  function intersectSegments$1(a, b) {
    // Note: this is almost the same as geom.intersectSegments()
    // The main difference is that we don't have a pre-computed
    // value for dx/dy on the segments.
    //  https://stackoverflow.com/a/1968345/125351
    var aStart = a.from, bStart = b.from;
    var p0_x = aStart.x, p0_y = aStart.y,
        p2_x = bStart.x, p2_y = bStart.y;

    var s1_x = a.from.x - a.to.x, s1_y = a.from.y - a.to.y, s2_x = b.from.x - b.to.x, s2_y = b.from.y - b.to.y;
    var div = s1_x * s2_y - s2_x * s1_y;

    var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
    if (s < 0 || s > 1) { return; }

    var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

    if (t >= 0 && t <= 1) {
      return {
        x: p0_x - (t * s1_x),
        y: p0_y - (t * s1_y)
      }
    }
  }

  /**
   * This is a brute force solution with O(n^2) performance.
   * (`n` is number of segments).
   * 
   * Use this when number of lines is low, and number of intersections
   * is high.
   */
  function brute(lines, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || 
                              defaultIntersectionReporter;
    var asyncState;

    return {
      /**
       * Execute brute force of the segment intersection search
       */
      run: run,
      /**
       * Access to results array. Works only when you use default onFound() handler
       */
      results: results,

      /**
       * Performs a single step in the brute force algorithm ()
       */
      step: step
    }

    function step() {
      if (!asyncState) {
        asyncState = {
          i: 0
        };
      }
      var test = lines[asyncState.i];
      for (var j = asyncState.i + 1; j < lines.length; ++j) {
        var other = lines[j];
        var pt = intersectSegments$1(test, other);
        if (pt) {
          if (reportIntersection(pt, [test, other])) {
            return;
          }
        }
      }
      asyncState.i += 1;
      return asyncState.i < lines.length;
    }

    function run() {
      for(var i = 0; i < lines.length; ++i) {
        var test = lines[i];
        for (var j = i + 1; j < lines.length; ++j) {
          var other = lines[j];
          var pt = intersectSegments$1(test, other);
          if (pt) {
            if (reportIntersection(pt, [test, other])) {
              return;
            }
          }
        }
      }
      return results;
    }

    function defaultIntersectionReporter(p, interior) {
      results.push({
        point: p, 
        segments: interior
      });
    }
  }

  var ARRAY_TYPES = [
      Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
      Int32Array, Uint32Array, Float32Array, Float64Array
  ];

  var VERSION = 3; // serialized format version

  var Flatbush = function Flatbush(numItems, nodeSize, ArrayType, data) {
      var this$1 = this;

      if (numItems === undefined) { throw new Error('Missing required argument: numItems.'); }
      if (isNaN(numItems) || numItems <= 0) { throw new Error(("Unpexpected numItems value: " + numItems + ".")); }

      this.numItems = +numItems;
      this.nodeSize = Math.min(Math.max(+nodeSize || 16, 2), 65535);

      // calculate the total number of nodes in the R-tree to allocate space for
      // and the index of each tree level (used in search later)
      var n = numItems;
      var numNodes = n;
      this._levelBounds = [n * 4];
      do {
          n = Math.ceil(n / this$1.nodeSize);
          numNodes += n;
          this$1._levelBounds.push(numNodes * 4);
      } while (n !== 1);

      this.ArrayType = ArrayType || Float64Array;
      this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;

      var arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
      var nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;

      if (arrayTypeIndex < 0) {
          throw new Error(("Unexpected typed array class: " + ArrayType + "."));
      }

      if (data && (data instanceof ArrayBuffer)) {
          this.data = data;
          this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
          this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);

          this._pos = numNodes * 4;
          this.minX = this._boxes[this._pos - 4];
          this.minY = this._boxes[this._pos - 3];
          this.maxX = this._boxes[this._pos - 2];
          this.maxY = this._boxes[this._pos - 1];

      } else {
          this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
          this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
          this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
          this._pos = 0;
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;

          new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);
          new Uint16Array(this.data, 2, 1)[0] = nodeSize;
          new Uint32Array(this.data, 4, 1)[0] = numItems;
      }
  };

  Flatbush.from = function from (data) {
      if (!(data instanceof ArrayBuffer)) {
          throw new Error('Data must be an instance of ArrayBuffer.');
      }
      var ref = new Uint8Array(data, 0, 2);
          var magic = ref[0];
          var versionAndType = ref[1];
      if (magic !== 0xfb) {
          throw new Error('Data does not appear to be in a Flatbush format.');
      }
      if (versionAndType >> 4 !== VERSION) {
          throw new Error(("Got v" + (versionAndType >> 4) + " data when expected v" + VERSION + "."));
      }
      var ref$1 = new Uint16Array(data, 2, 1);
          var nodeSize = ref$1[0];
      var ref$2 = new Uint32Array(data, 4, 1);
          var numItems = ref$2[0];

      return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);
  };

  Flatbush.prototype.add = function add (minX, minY, maxX, maxY) {
      var index = this._pos >> 2;
      this._indices[index] = index;
      this._boxes[this._pos++] = minX;
      this._boxes[this._pos++] = minY;
      this._boxes[this._pos++] = maxX;
      this._boxes[this._pos++] = maxY;

      if (minX < this.minX) { this.minX = minX; }
      if (minY < this.minY) { this.minY = minY; }
      if (maxX > this.maxX) { this.maxX = maxX; }
      if (maxY > this.maxY) { this.maxY = maxY; }
  };

  Flatbush.prototype.finish = function finish () {
          var this$1 = this;

      if (this._pos >> 2 !== this.numItems) {
          throw new Error(("Added " + (this._pos >> 2) + " items when expected " + (this.numItems) + "."));
      }

      var width = this.maxX - this.minX;
      var height = this.maxY - this.minY;
      var hilbertValues = new Uint32Array(this.numItems);
      var hilbertMax = (1 << 16) - 1;

      // map item centers into Hilbert coordinate space and calculate Hilbert values
      for (var i = 0; i < this.numItems; i++) {
          var pos = 4 * i;
          var minX = this$1._boxes[pos++];
          var minY = this$1._boxes[pos++];
          var maxX = this$1._boxes[pos++];
          var maxY = this$1._boxes[pos++];
          var x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this$1.minX) / width);
          var y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this$1.minY) / height);
          hilbertValues[i] = hilbert(x, y);
      }

      // sort items by their Hilbert value (for packing later)
      sort$1(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1);

      // generate nodes at each tree level, bottom-up
      for (var i$1 = 0, pos$1 = 0; i$1 < this._levelBounds.length - 1; i$1++) {
          var end = this$1._levelBounds[i$1];

          // generate a parent node for each block of consecutive <nodeSize> nodes
          while (pos$1 < end) {
              var nodeMinX = Infinity;
              var nodeMinY = Infinity;
              var nodeMaxX = -Infinity;
              var nodeMaxY = -Infinity;
              var nodeIndex = pos$1;

              // calculate bbox for the new node
              for (var i$2 = 0; i$2 < this.nodeSize && pos$1 < end; i$2++) {
                  var minX$1 = this$1._boxes[pos$1++];
                  var minY$1 = this$1._boxes[pos$1++];
                  var maxX$1 = this$1._boxes[pos$1++];
                  var maxY$1 = this$1._boxes[pos$1++];
                  if (minX$1 < nodeMinX) { nodeMinX = minX$1; }
                  if (minY$1 < nodeMinY) { nodeMinY = minY$1; }
                  if (maxX$1 > nodeMaxX) { nodeMaxX = maxX$1; }
                  if (maxY$1 > nodeMaxY) { nodeMaxY = maxY$1; }
              }

              // add the new node to the tree data
              this$1._indices[this$1._pos >> 2] = nodeIndex;
              this$1._boxes[this$1._pos++] = nodeMinX;
              this$1._boxes[this$1._pos++] = nodeMinY;
              this$1._boxes[this$1._pos++] = nodeMaxX;
              this$1._boxes[this$1._pos++] = nodeMaxY;
          }
      }
  };

  Flatbush.prototype.search = function search (minX, minY, maxX, maxY, filterFn) {
          var this$1 = this;

      if (this._pos !== this._boxes.length) {
          throw new Error('Data not yet indexed - call index.finish().');
      }

      var nodeIndex = this._boxes.length - 4;
      var level = this._levelBounds.length - 1;
      var queue = [];
      var results = [];

      while (nodeIndex !== undefined) {
          // find the end index of the node
          var end = Math.min(nodeIndex + this$1.nodeSize * 4, this$1._levelBounds[level]);

          // search through child nodes
          for (var pos = nodeIndex; pos < end; pos += 4) {
              var index = this$1._indices[pos >> 2];

              // check if node bbox intersects with query bbox
              if (maxX < this$1._boxes[pos]) { continue; } // maxX < nodeMinX
              if (maxY < this$1._boxes[pos + 1]) { continue; } // maxY < nodeMinY
              if (minX > this$1._boxes[pos + 2]) { continue; } // minX > nodeMaxX
              if (minY > this$1._boxes[pos + 3]) { continue; } // minY > nodeMaxY

              if (nodeIndex < this$1.numItems * 4) {
                  if (filterFn === undefined || filterFn(index)) {
                      results.push(index); // leaf item
                  }

              } else {
                  queue.push(index); // node; add it to the search queue
                  queue.push(level - 1);
              }
          }

          level = queue.pop();
          nodeIndex = queue.pop();
      }

      return results;
  };

  // custom quicksort that sorts bbox data alongside the hilbert values
  function sort$1(values, boxes, indices, left, right) {
      if (left >= right) { return; }

      var pivot = values[(left + right) >> 1];
      var i = left - 1;
      var j = right + 1;

      while (true) {
          do { i++; } while (values[i] < pivot);
          do { j--; } while (values[j] > pivot);
          if (i >= j) { break; }
          swap(values, boxes, indices, i, j);
      }

      sort$1(values, boxes, indices, left, j);
      sort$1(values, boxes, indices, j + 1, right);
  }

  // swap two values and two corresponding boxes
  function swap(values, boxes, indices, i, j) {
      var temp = values[i];
      values[i] = values[j];
      values[j] = temp;

      var k = 4 * i;
      var m = 4 * j;

      var a = boxes[k];
      var b = boxes[k + 1];
      var c = boxes[k + 2];
      var d = boxes[k + 3];
      boxes[k] = boxes[m];
      boxes[k + 1] = boxes[m + 1];
      boxes[k + 2] = boxes[m + 2];
      boxes[k + 3] = boxes[m + 3];
      boxes[m] = a;
      boxes[m + 1] = b;
      boxes[m + 2] = c;
      boxes[m + 3] = d;

      var e = indices[i];
      indices[i] = indices[j];
      indices[j] = e;
  }

  // Fast Hilbert curve algorithm by http://threadlocalmutex.com/
  // Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)
  function hilbert(x, y) {
      var a = x ^ y;
      var b = 0xFFFF ^ a;
      var c = 0xFFFF ^ (x | y);
      var d = x & (y ^ 0xFFFF);

      var A = a | (b >> 1);
      var B = (a >> 1) ^ a;
      var C = ((c >> 1) ^ (b & (d >> 1))) ^ c;
      var D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;

      a = A; b = B; c = C; d = D;
      A = ((a & (a >> 2)) ^ (b & (b >> 2)));
      B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));
      C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));
      D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));

      a = A; b = B; c = C; d = D;
      A = ((a & (a >> 4)) ^ (b & (b >> 4)));
      B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));
      C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));
      D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));

      a = A; b = B; c = C; d = D;
      C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));
      D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));

      a = C ^ (C >> 1);
      b = D ^ (D >> 1);

      var i0 = x ^ y;
      var i1 = b | (0xFFFF ^ (i0 | a));

      i0 = (i0 | (i0 << 8)) & 0x00FF00FF;
      i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;
      i0 = (i0 | (i0 << 2)) & 0x33333333;
      i0 = (i0 | (i0 << 1)) & 0x55555555;

      i1 = (i1 | (i1 << 8)) & 0x00FF00FF;
      i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;
      i1 = (i1 | (i1 << 2)) & 0x33333333;
      i1 = (i1 | (i1 << 1)) & 0x55555555;

      return ((i1 << 1) | i0) >>> 0;
  }

  /**
   * This implementation is inspired by discussion here 
   * https://twitter.com/mourner/status/1049325199617921024 and 
   * here https://github.com/anvaka/isect/issues/1
   * 
   * It builds an index of all segments using static spatial index
   * and then for each segment it queries overlapping rectangles.
   */
  function bush(lines, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || 
                              defaultIntersectionReporter;
    var asyncState;

    var index = new Flatbush(lines.length);
    lines.forEach(addToIndex);
    index.finish();

    return {
      run: run,
      step: step,
      results: results,

      // undocumented, don't use unless you know what you are doing:
      checkIntersection: checkIntersection
    }

    function run() {
      for (var i = 0; i < lines.length; ++i) {
        if (checkIntersection(lines[i], i)) {
          return; // stop early
        }
      }
      return results;
    }

    function checkIntersection(currentSegment, currentId) {
      // sorry about code duplication.
      var minX = currentSegment.from.x; var maxX = currentSegment.to.x;
      var minY = currentSegment.from.y; var maxY = currentSegment.to.y;
      var t;
      if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
      if (minY > maxY) { t = minY; minY = maxY; maxY = t; }

      var ids = index.search(minX, minY, maxX, maxY);

      for (var i = 0; i < ids.length; ++i) {
        var segmentIndex = ids[i];
        if (segmentIndex <= currentId) { continue; } // we have either reported it, or it is current.

        var otherSegment = lines[segmentIndex];
        var point = intersectSegments$1(otherSegment, currentSegment);

        if (point) {
          if (reportIntersection(point, [currentSegment, otherSegment])) {
            // stop early
            return true;
          }
        }
      }
    }

    function step() {
      if (!asyncState) {
        asyncState = {i: 0};
      }
      var test = lines[asyncState.i];
      checkIntersection(test, asyncState.i);
      asyncState.i += 1;
      return asyncState.i < lines.length;
    }


    function addToIndex(line) {
      var minX = line.from.x; var maxX = line.to.x;
      var minY = line.from.y; var maxY = line.to.y;
      var t;
      if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
      if (minY > maxY) { t = minY; minY = maxY; maxY = t; }
      index.add(minX, minY, maxX, maxY);
    }

    function defaultIntersectionReporter(p, interior) {
      results.push({
        point: p, 
        segments: interior
      });
    }
  }

  exports.sweep = isect;
  exports.brute = brute;
  exports.bush = bush;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],5:[function(require,module,exports){
/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
 * @license
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).jsts={})}(this,(function(t){"use strict";class e{constructor(){e.constructor_.apply(this,arguments)}static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}getClass(){return e}get interfaces_(){return[]}}function n(t){this.message=t}function s(t,e){this.low=0|e,this.high=0|t}function i(){}function r(){}function o(){}function l(){}function a(){}function c(t){this.name="RuntimeException",this.message=t,this.stack=(new Error).stack,Error.call(this,t)}e.constructor_=function(){},s.toBinaryString=function(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n},i.isNaN=t=>Number.isNaN(t),i.isInfinite=t=>!Number.isFinite(t),i.MAX_VALUE=Number.MAX_VALUE,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=new Float64Array(1),e=new Int32Array(t.buffer);i.doubleToLongBits=function(n){t[0]=n;let i=0|e[0],r=0|e[1];return 2146435072==(2146435072&r)&&0!=(1048575&r)&&0!==i&&(i=0,r=2146959360),new s(r,i)},i.longBitsToDouble=function(n){return e[0]=n.low,e[1]=n.high,t[0]}}():function(){const t=Math.log2,e=Math.floor,n=Math.pow,r=function(){for(let s=53;s>0;s--){const i=n(2,s)-1;if(e(t(i))+1===s)return i}return 0}();i.doubleToLongBits=function(i){let o,l,a,c,h,u,g,d,_;if(i<0||1/i===Number.NEGATIVE_INFINITY?(u=1<<31,i=-i):u=0,0===i)return _=0,d=u,new s(d,_);if(i===1/0)return _=0,d=2146435072|u,new s(d,_);if(i!=i)return _=0,d=2146959360,new s(d,_);if(c=0,_=0,o=e(i),o>1)if(o<=r)c=e(t(o)),c<=20?(_=0,d=o<<20-c&1048575):(a=c-20,l=n(2,a),_=o%l<<32-a,d=o/l&1048575);else for(a=o,_=0;l=a/2,a=e(l),0!==a;)c++,_>>>=1,_|=(1&d)<<31,d>>>=1,l!==a&&(d|=524288);if(g=c+1023,h=0===o,o=i-o,c<52&&0!==o)for(a=0;;){if(l=2*o,l>=1?(o=l-1,h?(g--,h=!1):(a<<=1,a|=1,c++)):(o=l,h?0==--g&&(c++,h=!1):(a<<=1,c++)),20===c)d|=a,a=0;else if(52===c){_|=a;break}if(1===l){c<20?d|=a<<20-c:c<52&&(_|=a<<52-c);break}}return d|=g<<20,d|=u,new s(d,_)},i.longBitsToDouble=function(t){let e,s,i,r,o;const l=t.high,a=t.low;for(i=l&1<<31?-1:1,r=((2146435072&l)>>20)-1023,o=0,s=1<<19,e=1;e<=20;e++)l&s&&(o+=n(2,-e)),s>>>=1;for(s=1<<31,e=21;e<=52;e++)a&s&&(o+=n(2,-e)),s>>>=1;if(-1023===r){if(0===o)return 0*i;r=-1022}else{if(1024===r)return 0===o?i/0:NaN;o+=1}return i*o*n(2,r)}}(),c.prototype=Object.create(Error.prototype),c.prototype.constructor=Error;class h extends c{constructor(){super(),h.constructor_.apply(this,arguments)}getClass(){return h}get interfaces_(){return[]}}h.constructor_=function(){if(0===arguments.length)c.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];c.constructor_.call(this,t)}};class u{constructor(){u.constructor_.apply(this,arguments)}static shouldNeverReachHere(){if(0===arguments.length)u.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new h("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];u.isTrue(t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(!t)throw null===e?new h:new h(e)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];u.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new h("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}getClass(){return u}get interfaces_(){return[]}}u.constructor_=function(){};class g{constructor(){g.constructor_.apply(this,arguments)}static hashCode(){if(1===arguments.length&&"number"==typeof arguments[0]){const t=arguments[0],e=i.doubleToLongBits(t);return Math.trunc(e^e>>>32)}}setOrdinate(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new n("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}getOrdinate(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new n("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||i.isNaN(this.z)&&i.isNaN(t.z))}equals(t){return t instanceof g&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.z,t.z,n)}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return u.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new g(this)}toString(){return"("+this.x+", "+this.y+", "+this.z+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,s=this.z-t.z;return Math.sqrt(e*e+n*n+s*s)}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.z}getClass(){return g}get interfaces_(){return[r,o,a]}}class d{constructor(){d.constructor_.apply(this,arguments)}static compare(t,e){return t<e?-1:t>e?1:i.isNaN(t)?i.isNaN(e)?0:-1:i.isNaN(e)?1:0}compare(t,e){const n=t,s=e,i=d.compare(n.x,s.x);if(0!==i)return i;const r=d.compare(n.y,s.y);return 0!==r?r:this._dimensionsToTest<=2?0:d.compare(n.z,s.z)}getClass(){return d}get interfaces_(){return[l]}}function _(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}function f(){}function p(t){this.message=t||""}function m(){}function y(t){this.message=t||""}function x(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}d.constructor_=function(){if(this._dimensionsToTest=2,0===arguments.length)d.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new n("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}},g.DimensionalComparator=d,g.constructor_=function(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];g.constructor_.call(this,t.x,t.y,t.z)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];g.constructor_.call(this,t,e,g.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}},g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=i.NaN,g.X=0,g.Y=1,g.Z=2,f.prototype.add=function(){},f.prototype.addAll=function(){},f.prototype.isEmpty=function(){},f.prototype.iterator=function(){},f.prototype.size=function(){},f.prototype.toArray=function(){},f.prototype.remove=function(){},p.prototype=new Error,p.prototype.name="IndexOutOfBoundsException",m.prototype=Object.create(f.prototype),m.prototype.constructor=m,m.prototype.get=function(){},m.prototype.set=function(){},m.prototype.isEmpty=function(){},y.prototype=new Error,y.prototype.name="NoSuchElementException",x.prototype=Object.create(m.prototype),x.prototype.constructor=x,x.prototype.ensureCapacity=function(){},x.prototype.interfaces_=[m,f],x.prototype.add=function(t){return 1===arguments.length?this.array_.push(t):this.array_.splice(arguments[0],0,arguments[1]),!0},x.prototype.clear=function(){this.array_=[]},x.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},x.prototype.set=function(t,e){const n=this.array_[t];return this.array_[t]=e,n},x.prototype.iterator=function(){return new E(this)},x.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},x.prototype.isEmpty=function(){return 0===this.array_.length},x.prototype.size=function(){return this.array_.length},x.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},x.prototype.remove=function(t){let e=!1;for(let n=0,s=this.array_.length;n<s;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e},x.prototype.removeAll=function(t){for(let e=t.iterator();e.hasNext();)this.remove(e.next());return!0};const E=function(t){this.arrayList_=t,this.position_=0};E.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new y;return this.arrayList_.get(this.position_++)},E.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},E.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},E.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))};class I extends x{constructor(){super(),I.constructor_.apply(this,arguments)}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&_(arguments[0],f)){const t=arguments[0],e=arguments[1];let n=!1;for(let s=t.iterator();s.hasNext();)this.add(s.next(),e),n=!0;return n}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){return this.toArray(I.coordArrayType)}add(){if(1===arguments.length){const t=arguments[0];super.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=1;n>s&&(i=-1);for(let r=n;r!==s;r+=i)this.add(t[r],e);return!0}}closeRing(){this.size()>0&&this.add(new g(this.get(0)),!1)}getClass(){return I}get interfaces_(){return[]}}I.constructor_=function(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}},I.coordArrayType=new Array(0).fill(null);class N{constructor(){N.constructor_.apply(this,arguments)}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<i)&&(i=Math.min(n.y,s.y),r=Math.max(n.y,s.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<i)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof N))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new N;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,s=this._maxx<t._maxx?this._maxx:t._maxx,i=this._maxy<t._maxy?this._maxy:t._maxy;return new N(e,s,n,i)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof N){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof N){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof g){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];return!this.isNull()&&(!((t.x<e.x?t.x:e.x)>this._maxx)&&(!((t.x>e.x?t.x:e.x)<this._minx)&&(!((t.y<e.y?t.y:e.y)>this._maxy)&&!((t.y>e.y?t.y:e.y)<this._miny))))}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof N){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<s?(this._miny=n,this._maxy=s):(this._miny=s,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+g.hashCode(this._minx),t=37*t+g.hashCode(this._maxx),t=37*t+g.hashCode(this._miny),t=37*t+g.hashCode(this._maxy),t}getClass(){return N}get interfaces_(){return[r,a]}}function C(){}N.constructor_=function(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.init(t,e,n,s)}},N.serialVersionUID=0x51845cd552189800;class S extends C{constructor(){super(),S.constructor_.apply(this,arguments)}getClass(){return S}get interfaces_(){return[]}}function w(t){this.str=t}function L(t){this.value=t}function T(){}S.constructor_=function(){C.constructor_.call(this,"Projective point not representable on the Cartesian plane.")},w.prototype.append=function(t){this.str+=t},w.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},w.prototype.toString=function(t){return this.str},L.prototype.intValue=function(){return this.value},L.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},L.isNaN=t=>Number.isNaN(t),T.isWhitespace=t=>t<=32&&t>=0||127===t,T.toUpperCase=t=>t.toUpperCase();class R{constructor(){R.constructor_.apply(this,arguments)}static sqr(t){return R.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return R.parse(t)}if("number"==typeof arguments[0]){const t=arguments[0];return new R(t)}}static sqrt(t){return R.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;T.isWhitespace(t.charAt(e));)e++;let s=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(s=!0))}const i=new R;let r=0,o=0,l=0;for(;!(e>=n);){const n=t.charAt(e);if(e++,T.isDigit(n)){const t=n-"0";i.selfMultiply(R.TEN),i.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=L.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r}}let a=i;const c=r-o-l;if(0===c)a=i;else if(c>0){const t=R.TEN.pow(c);a=i.divide(t)}else if(c<0){const t=R.TEN.pow(-c);a=i.multiply(t)}return s?a.negate():a}static createNaN(){return new R(i.NaN,i.NaN)}static copy(t){return new R(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let s=Math.trunc(Math.floor(n));return 10*Math.pow(10,s)<=e&&(s+=1),s}static stringOfChar(t,e){const n=new w;for(let s=0;s<e;s++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),s=R.magnitude(n._hi);const i=R.TEN.pow(s);n=n.divide(i),n.gt(R.TEN)?(n=n.divide(R.TEN),s+=1):n.lt(R.ONE)&&(n=n.multiply(R.TEN),s-=1);const r=s+1,o=new w,l=R.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const s=Math.trunc(n._hi);if(s<0)break;let i=!1,a=0;s>9?(i=!0,a="9"):a="0"+s,o.append(a),n=n.subtract(R.valueOf(s)).multiply(R.TEN),i&&n.selfAdd(R.TEN);let c=!0;const h=R.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=s,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof R){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof R){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof R){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=R.SPLIT*o,n=l-o,c=R.SPLIT*t,n=l-n,s=o-n,i=c-t,a=o*t,i=c-i,r=t-i,c=n*i-a+n*r+s*i+s*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof R){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null,l=null,a=null;return r=this._hi/t._hi,o=R.SPLIT*r,e=o-r,a=R.SPLIT*t._hi,e=o-e,n=r-e,s=a-t._hi,l=r*t._hi,s=a-s,i=t._hi-s,a=e*s-l+e*i+n*s+n*i,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o,new R(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return R.valueOf(1);let e=new R(this),n=R.valueOf(1),s=Math.abs(t);if(s>1)for(;s>0;)s%2==1&&n.selfMultiply(e),s/=2,s>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return R.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new R(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof R){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return R.valueOf(0);if(this.isNegative())return R.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=R.valueOf(e),s=this.subtract(n.sqr())._hi*(.5*t);return n.add(s)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null;return s=this._hi+t,r=s-this._hi,i=s-r,i=t-r+(this._hi-i),o=i+this._lo,e=s+o,n=o+(s-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,i=this._lo+e,a=o-this._hi,c=i-this._lo,l=o-a,r=i-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+i,n=o+a,s=a+(o-n),a=r+s;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null;o=R.SPLIT*this._hi,n=o-this._hi,l=R.SPLIT*t,n=o-n,s=this._hi-n,i=l-t,o=this._hi*t,i=l-i,r=t-i,l=n*i-o+n*r+s*i+s*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return R.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new R(t,e)}negate(){return this.isNaN()?this:new R(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof R){const t=arguments[0];return t.isNaN()?R.createNaN():R.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfMultiply(t,0)}}isNaN(){return i.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=R.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),s=e[0]+1;let i=n;if("."===n.charAt(0))i="0"+n;else if(s<0)i="0."+R.stringOfChar("0",-s)+n;else if(-1===n.indexOf(".")){const t=s-n.length;i=n+R.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+i:i}reciprocal(){let t=null,e=null,n=null,s=null,i=null,r=null,o=null,l=null;i=1/this._hi,r=R.SPLIT*i,t=r-i,l=R.SPLIT*this._hi,t=r-t,e=i-t,n=l-this._hi,o=i*this._hi,n=l-n,s=this._hi-n,l=t*n-o+t*s+e*n+e*s,r=(1-o-l-i*this._lo)/this._hi;const a=i+r;return new R(a,i-a+r)}toSciNotation(){if(this.isZero())return R.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),s=R.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);let i="";n.length>1&&(i=n.substring(1));const r=n.charAt(0)+"."+i;return this.isNegative()?"-"+r+s:r+s}abs(){return this.isNaN()?R.NaN:this.isNegative()?this.negate():new R(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof R){const t=arguments[0];return R.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return R.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof R){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?R.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}getClass(){return R}get interfaces_(){return[a,r,o]}}R.constructor_=function(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof R){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];R.constructor_.call(this,R.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}},R.PI=new R(3.141592653589793,12246467991473532e-32),R.TWO_PI=new R(6.283185307179586,24492935982947064e-32),R.PI_2=new R(1.5707963267948966,6123233995736766e-32),R.E=new R(2.718281828459045,14456468917292502e-32),R.NaN=new R(i.NaN,i.NaN),R.EPS=123259516440783e-46,R.SPLIT=134217729,R.MAX_PRINT_DIGITS=32,R.TEN=R.valueOf(10),R.ONE=R.valueOf(1),R.SCI_NOT_EXPONENT_CHAR="E",R.SCI_NOT_ZERO="0.0E0";class P{constructor(){P.constructor_.apply(this,arguments)}static orientationIndex(t,e,n){const s=P.orientationIndexFilter(t,e,n);if(s<=1)return s;const i=R.valueOf(e.x).selfAdd(-t.x),r=R.valueOf(e.y).selfAdd(-t.y),o=R.valueOf(n.x).selfAdd(-e.x),l=R.valueOf(n.y).selfAdd(-e.y);return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof R&&arguments[2]instanceof R&&arguments[0]instanceof R&&arguments[1]instanceof R){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return t.multiply(s).selfSubtract(e.multiply(n)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=R.valueOf(t),r=R.valueOf(e),o=R.valueOf(n),l=R.valueOf(s);return i.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,s){const i=R.valueOf(s.y).selfSubtract(n.y).selfMultiply(R.valueOf(e.x).selfSubtract(t.x)),r=R.valueOf(s.x).selfSubtract(n.x).selfMultiply(R.valueOf(e.y).selfSubtract(t.y)),o=i.subtract(r),l=R.valueOf(s.x).selfSubtract(n.x).selfMultiply(R.valueOf(t.y).selfSubtract(n.y)),a=R.valueOf(s.y).selfSubtract(n.y).selfMultiply(R.valueOf(t.x).selfSubtract(n.x)),c=l.subtract(a).selfDivide(o).doubleValue(),h=R.valueOf(t.x).selfAdd(R.valueOf(e.x).selfSubtract(t.x).selfMultiply(c)).doubleValue(),u=R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(t.y).selfSubtract(n.y)),d=R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(t.x).selfSubtract(n.x)),_=u.subtract(d).selfDivide(o).doubleValue(),f=R.valueOf(n.y).selfAdd(R.valueOf(s.y).selfSubtract(n.y).selfMultiply(_)).doubleValue();return new g(h,f)}static orientationIndexFilter(t,e,n){let s=null;const i=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=i-r;if(i>0){if(r<=0)return P.signum(o);s=i+r}else{if(!(i<0))return P.signum(o);if(r>=0)return P.signum(o);s=-i-r}const l=P.DP_SAFE_EPSILON*s;return o>=l||-o>=l?P.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}getClass(){return P}get interfaces_(){return[]}}P.constructor_=function(){},P.DP_SAFE_EPSILON=1e-15;class v{constructor(){v.constructor_.apply(this,arguments)}static index(t,e,n){return P.orientationIndex(t,e,n)}static isCCW(t){const e=t.length-1;if(e<3)throw new n("Ring has fewer than 4 points, so orientation cannot be determined");let s=t[0],i=0;for(let n=1;n<=e;n++){const e=t[n];e.y>s.y&&(s=e,i=n)}let r=i;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(s)&&r!==i);let o=i;do{o=(o+1)%e}while(t[o].equals2D(s)&&o!==i);const l=t[r],a=t[o];if(l.equals2D(s)||a.equals2D(s)||l.equals2D(a))return!1;const c=v.index(l,s,a);let h=null;return h=0===c?l.x>a.x:c>0,h}getClass(){return v}get interfaces_(){return[]}}function O(){}v.constructor_=function(){},v.CLOCKWISE=-1,v.RIGHT=v.CLOCKWISE,v.COUNTERCLOCKWISE=1,v.LEFT=v.COUNTERCLOCKWISE,v.COLLINEAR=0,v.STRAIGHT=v.COLLINEAR,O.arraycopy=(t,e,n,s,i)=>{let r=0;for(let o=e;o<e+i;o++)n[s+r]=t[o],r++},O.getProperty=t=>({"line.separator":"\n"}[t]);class b{constructor(){b.constructor_.apply(this,arguments)}static intersection(t,e,n,s){const r=t.y-e.y,o=e.x-t.x,l=t.x*e.y-e.x*t.y,a=n.y-s.y,c=s.x-n.x,h=n.x*s.y-s.x*n.y,u=r*c-a*o,d=(o*h-c*l)/u,_=(a*l-r*h)/u;if(i.isNaN(d)||i.isInfinite(d)||i.isNaN(_)||i.isInfinite(_))throw new S;return new g(d,_)}getY(){const t=this.y/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getX(){const t=this.x/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getCoordinate(){const t=new g;return t.x=this.getX(),t.y=this.getY(),t}getClass(){return b}get interfaces_(){return[]}}b.constructor_=function(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){const t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this.x=t,this.y=e,this.w=1}else if(arguments[0]instanceof b&&arguments[1]instanceof b){const t=arguments[0],e=arguments[1];this.x=t.y*e.w-e.y*t.w,this.y=e.x*t.w-t.x*e.w,this.w=t.x*e.y-e.x*t.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];this.x=t.y-e.y,this.y=e.x-t.x,this.w=t.x*e.y-e.x*t.y}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.w=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.y-e.y,r=e.x-t.x,o=t.x*e.y-e.x*t.y,l=n.y-s.y,a=s.x-n.x,c=n.x*s.y-s.x*n.y;this.x=r*c-a*o,this.y=l*o-i*c,this.w=i*a-l*r}};class M{constructor(){M.constructor_.apply(this,arguments)}static log10(t){const e=Math.log(t);return i.isInfinite(e)||i.isNaN(e)?e:e/M.LOG_10}static min(t,e,n,s){let i=t;return e<i&&(i=e),n<i&&(i=n),s<i&&(i=s),i}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=t;return e>s&&(s=e),n>s&&(s=n),s}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=t;return e>i&&(i=e),n>i&&(i=n),s>i&&(i=s),i}}static average(t,e){return(t+e)/2}getClass(){return M}get interfaces_(){return[]}}M.constructor_=function(){},M.LOG_10=Math.log(10);class D{constructor(){D.constructor_.apply(this,arguments)}static segmentToSegment(t,e,n,s){if(t.equals(e))return D.pointToSegment(t,n,s);if(n.equals(s))return D.pointToSegment(s,t,e);let i=!1;if(N.intersects(t,e,n,s)){const r=(e.x-t.x)*(s.y-n.y)-(e.y-t.y)*(s.x-n.x);if(0===r)i=!0;else{const o=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(i=!0)}}else i=!0;return i?M.min(D.pointToSegment(t,n,s),D.pointToSegment(e,n,s),D.pointToSegment(n,t,e),D.pointToSegment(s,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/s;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(r)*Math.sqrt(s)}static pointToLinePerpendicular(t,e,n){const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(i)*Math.sqrt(s)}static pointToSegmentString(t,e){if(0===e.length)throw new n("Line array must contain at least one vertex");let s=t.distance(e[0]);for(let n=0;n<e.length-1;n++){const i=D.pointToSegment(t,e[n],e[n+1]);i<s&&(s=i)}return s}getClass(){return D}get interfaces_(){return[]}}D.constructor_=function(){};class A{constructor(){A.constructor_.apply(this,arguments)}setOrdinate(t,e,n){}size(){}getOrdinate(t,e){}getCoordinate(){}getCoordinateCopy(t){}getDimension(){}getX(t){}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}getClass(){return A}get interfaces_(){return[o]}}A.constructor_=function(){},A.X=0,A.Y=1,A.Z=2,A.M=3;class F{constructor(){F.constructor_.apply(this,arguments)}create(){1===arguments.length&&(arguments[0]instanceof Array||_(arguments[0],A))}getClass(){return F}get interfaces_(){return[]}}F.constructor_=function(){};class G{constructor(){G.constructor_.apply(this,arguments)}filter(t){}getClass(){return G}get interfaces_(){return[]}}G.constructor_=function(){};class q{constructor(){q.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equals(){if(arguments[0]instanceof q){const t=arguments[0];return null!==t&&this.equalsTopo(t)}if(arguments[0]instanceof Object){const t=arguments[0];if(!(t instanceof q))return!1;const e=t;return this.equalsExact(e)}}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(q.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}checkNotGeometryCollection(t){if(t.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION)throw new n("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new N(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),s=e.iterator();for(;n.hasNext()&&s.hasNext();){const t=n.next(),e=s.next(),i=t.compareTo(e);if(0!==i)return i}return n.hasNext()?1:s.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isGeometryCollectionOrDerived(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION||this.getTypeCode()===q.TYPECODE_MULTIPOINT||this.getTypeCode()===q.TYPECODE_MULTILINESTRING||this.getTypeCode()===q.TYPECODE_MULTIPOLYGON}get interfaces_(){return[o,r,a]}getClass(){return q}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}q.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},q.serialVersionUID=0x799ea46522854c00,q.TYPECODE_POINT=0,q.TYPECODE_MULTIPOINT=1,q.TYPECODE_LINESTRING=2,q.TYPECODE_LINEARRING=3,q.TYPECODE_MULTILINESTRING=4,q.TYPECODE_POLYGON=5,q.TYPECODE_MULTIPOLYGON=6,q.TYPECODE_GEOMETRYCOLLECTION=7,q.TYPENAME_POINT="Point",q.TYPENAME_MULTIPOINT="MultiPoint",q.TYPENAME_LINESTRING="LineString",q.TYPENAME_LINEARRING="LinearRing",q.TYPENAME_MULTILINESTRING="MultiLineString",q.TYPENAME_POLYGON="Polygon",q.TYPENAME_MULTIPOLYGON="MultiPolygon",q.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",q.geometryChangedFilter={get interfaces_(){return[G]},filter(t){t.geometryChangedAction()}};class B{constructor(){B.constructor_.apply(this,arguments)}filter(t){}getClass(){return B}get interfaces_(){return[]}}B.constructor_=function(){};class V{constructor(){V.constructor_.apply(this,arguments)}isInBoundary(t){}getClass(){return V}get interfaces_(){return[]}}class z{constructor(){z.constructor_.apply(this,arguments)}isInBoundary(t){return t%2==1}getClass(){return z}get interfaces_(){return[V]}}z.constructor_=function(){};class Y{constructor(){Y.constructor_.apply(this,arguments)}isInBoundary(t){return t>0}getClass(){return Y}get interfaces_(){return[V]}}Y.constructor_=function(){};class U{constructor(){U.constructor_.apply(this,arguments)}isInBoundary(t){return t>1}getClass(){return U}get interfaces_(){return[V]}}U.constructor_=function(){};class k{constructor(){k.constructor_.apply(this,arguments)}isInBoundary(t){return 1===t}getClass(){return k}get interfaces_(){return[V]}}k.constructor_=function(){},V.Mod2BoundaryNodeRule=z,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=k,V.constructor_=function(){},V.MOD2_BOUNDARY_RULE=new z,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new k,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE;class X{constructor(){X.constructor_.apply(this,arguments)}static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(X.indexOf(s,e)<0)return s}return null}static scroll(t,e){const n=X.indexOf(e,t);if(n<0)return null;const s=new Array(t.length).fill(null);O.arraycopy(t,n,s,0,t.length-n),O.arraycopy(t,0,s,t.length-n,n),O.arraycopy(s,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(0!==n.compare(t[s],e[s]))return!1;return!0}}static intersection(t,e){const n=new I;for(let s=0;s<t.length;s++)e.intersects(t[s])&&n.add(t[s],!0);return n.toCoordinateArray()}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!X.hasRepeatedPoints(t))return t;return new I(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++){const n=t[s];t[s]=t[e-s],t[e-s]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let s=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[s++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4];for(let r=0;r<i;r++)n[s+r]=new g(t[e+r])}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const s=t[n],i=e[t.length-n-1];if(0!==s.compareTo(i))return!1}return!0}static envelope(t){const e=new N;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(X.coordArrayType)}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,s=t[e].compareTo(t[n]);if(0!==s)return s}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=t[n].compareTo(e[n]);if(0!==s)return s;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=M.clamp(e,0,t.length);let s=(n=M.clamp(n,-1,t.length))-e+1;n<0&&(s=0),e>=t.length&&(s=0),n<e&&(s=0);const i=new Array(s).fill(null);if(0===s)return i;let r=0;for(let s=e;s<=n;s++)i[r++]=t[s];return i}getClass(){return X}get interfaces_(){return[]}}class H{constructor(){H.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e;return X.compare(n,s)}getClass(){return H}get interfaces_(){return[l]}}H.constructor_=function(){};class W{constructor(){W.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=X.compare(n,s);return X.isEqualReversed(n,s)?0:i}OLDcompare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=X.increasingDirection(n),r=X.increasingDirection(s);let o=i>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(s[l]);if(0!==t)return t;o+=i,l+=r}return 0}getClass(){return W}get interfaces_(){return[l]}}function j(){}function K(){}function Z(t){this.message=t||""}function Q(){}function J(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}W.constructor_=function(){},X.ForwardComparator=H,X.BidirectionalComparator=W,X.constructor_=function(){},X.coordArrayType=new Array(0).fill(null),j.prototype.get=function(){},j.prototype.put=function(){},j.prototype.size=function(){},j.prototype.values=function(){},j.prototype.entrySet=function(){},K.prototype=new j,Z.prototype=new Error,Z.prototype.name="OperationNotSupported",Q.prototype=new f,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(let e=0,n=this.array_.length;e<n;e++){if(this.array_[e]===t)return!0}return!1},J.prototype.add=function(t){return!this.contains(t)&&(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new Z},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new $(this)};const $=function(t){this.hashSet_=t,this.position_=0};$.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new y;return this.hashSet_.array_[this.position_++]},$.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},$.prototype.remove=function(){throw new Z};function tt(t){return null==t?0:t.color}function et(t){return null==t?null:t.parent}function nt(t,e){null!==t&&(t.color=e)}function st(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}rt.prototype=new K,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;var n,s,i=this.root_;do{if(n=i,(s=t.compareTo(i.key))<0)i=i.left;else{if(!(s>0)){var r=i.value;return i.value=e,r}i=i.right}}while(null!==i);var o={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return s<0?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)et(t)===st(et(et(t)))?(e=it(et(et(t))),1===tt(e)?(nt(et(t),0),nt(e,0),nt(et(et(t)),1),t=et(et(t))):(t===it(et(t))&&(t=et(t),this.rotateLeft(t)),nt(et(t),0),nt(et(et(t)),1),this.rotateRight(et(et(t))))):(e=st(et(et(t))),1===tt(e)?(nt(et(t),0),nt(e,0),nt(et(et(t)),1),t=et(et(t))):(t===st(et(t))&&(t=et(t),this.rotateRight(t)),nt(et(t),0),nt(et(et(t)),1),this.rotateLeft(et(et(t)))));this.root_.color=0},rt.prototype.values=function(){var t=new x,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}e=t.parent;for(var n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},rt.prototype.containsKey=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1};class ot{constructor(){ot.constructor_.apply(this,arguments)}getClass(){return ot}get interfaces_(){return[]}}function lt(){}function at(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}ot.constructor_=function(){},lt.prototype=new Q,at.prototype=new lt,at.prototype.contains=function(t){for(let e=0,n=this.array_.length;e<n;e++){if(0===this.array_[e].compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(let e=0,n=this.array_.length;e<n;e++){if(1===this.array_[e].compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new Z},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new ct(this)};const ct=function(t){this.treeSet_=t,this.position_=0};function ht(){}ct.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new y;return this.treeSet_.array_[this.position_++]},ct.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},ct.prototype.remove=function(){throw new Z},ht.sort=function(){const t=arguments[0];let e,n,s,i;if(1===arguments.length)i=function(t,e){return t.compareTo(e)},t.sort(i);else if(2===arguments.length)s=arguments[1],i=function(t,e){return s.compare(t,e)},t.sort(i);else if(3===arguments.length){n=t.slice(arguments[1],arguments[2]),n.sort();const s=t.slice(0,arguments[1]).concat(n,t.slice(arguments[2],t.length));for(t.splice(0,t.length),e=0;e<s.length;e++)t.push(s[e])}else if(4===arguments.length){n=t.slice(arguments[1],arguments[2]),s=arguments[3],i=function(t,e){return s.compare(t,e)},n.sort(i);const r=t.slice(0,arguments[1]).concat(n,t.slice(arguments[2],t.length));for(t.splice(0,t.length),e=0;e<r.length;e++)t.push(r[e])}},ht.asList=function(t){const e=new x;for(let n=0,s=t.length;n<s;n++)e.add(t[n]);return e};class ut{constructor(){ut.constructor_.apply(this,arguments)}static toDimensionSymbol(t){switch(t){case ut.FALSE:return ut.SYM_FALSE;case ut.TRUE:return ut.SYM_TRUE;case ut.DONTCARE:return ut.SYM_DONTCARE;case ut.P:return ut.SYM_P;case ut.L:return ut.SYM_L;case ut.A:return ut.SYM_A}throw new n("Unknown dimension value: "+t)}static toDimensionValue(t){switch(T.toUpperCase(t)){case ut.SYM_FALSE:return ut.FALSE;case ut.SYM_TRUE:return ut.TRUE;case ut.SYM_DONTCARE:return ut.DONTCARE;case ut.SYM_P:return ut.P;case ut.SYM_L:return ut.L;case ut.SYM_A:return ut.A}throw new n("Unknown dimension symbol: "+t)}getClass(){return ut}get interfaces_(){return[]}}ut.constructor_=function(){},ut.P=0,ut.L=1,ut.A=2,ut.FALSE=-1,ut.TRUE=-2,ut.DONTCARE=-3,ut.SYM_FALSE="F",ut.SYM_TRUE="T",ut.SYM_DONTCARE="*",ut.SYM_P="0",ut.SYM_L="1",ut.SYM_A="2";class gt{constructor(){gt.constructor_.apply(this,arguments)}filter(t){}getClass(){return gt}get interfaces_(){return[]}}gt.constructor_=function(){};class dt{constructor(){dt.constructor_.apply(this,arguments)}filter(t,e){}isDone(){}isGeometryChanged(){}getClass(){return dt}get interfaces_(){return[]}}dt.constructor_=function(){};class _t extends q{constructor(){super(),_t.constructor_.apply(this,arguments)}computeEnvelopeInternal(){const t=new N;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const s=this._geometries[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();ht.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=ut.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}getTypeCode(){return q.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=ut.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)e[t]=this._geometries[t].reverse();return this.getFactory().createGeometryCollection(e)}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new at(ht.asList(this._geometries)),n=new at(ht.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t,s=this.getNumGeometries(),i=n.getNumGeometries();let r=0;for(;r<s&&r<i;){const t=this.getGeometryN(r),s=n.getGeometryN(r),i=t.compareToSameClass(s,e);if(0!==i)return i;r++}return r<s?1:r<i?-1:0}}apply(){if(_(arguments[0],B)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(_(arguments[0],dt)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(_(arguments[0],G)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return this.checkNotGeometryCollection(this),u.shouldNeverReachHere(),null}getGeometryType(){return q.TYPENAME_GEOMETRYCOLLECTION}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new _t(t,this._factory)}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}getClass(){return _t}get interfaces_(){return[]}}_t.constructor_=function(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0];const e=arguments[1];if(q.constructor_.call(this,e),null===t&&(t=[]),q.hasNullElements(t))throw new n("geometries must not contain null elements");this._geometries=t}},_t.serialVersionUID=-0x4f07bcb1f857d800;class ft extends _t{constructor(){super(),ft.constructor_.apply(this,arguments)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?ut.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return q.TYPECODE_MULTILINESTRING}getDimension(){return 1}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let n=0;n<this._geometries.length;n++)e[t-1-n]=this._geometries[n].reverse();return this.getFactory().createMultiLineString(e)}getBoundary(){return new pt(this).getBoundary()}getGeometryType(){return q.TYPENAME_MULTILINESTRING}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ft(t,this._factory)}getClass(){return ft}get interfaces_(){return[ot]}}ft.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},ft.serialVersionUID=0x7155d2ab4afa8000;class pt{constructor(){pt.constructor_.apply(this,arguments)}static getBoundary(){if(1===arguments.length){const t=arguments[0];return new pt(t).getBoundary()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new pt(t,e).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();const e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)}getBoundary(){return this._geom instanceof Tt?this.boundaryLineString(this._geom):this._geom instanceof ft?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){const e=new x;this._endpointMap=new rt;for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);0!==n.getNumPoints()&&(this.addEndpoint(n.getCoordinateN(0)),this.addEndpoint(n.getCoordinateN(n.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){const n=t.next(),s=n.getValue().count;this._bnRule.isInBoundary(s)&&e.add(n.getKey())}return X.toCoordinateArray(e)}addEndpoint(t){let e=this._endpointMap.get(t);null===e&&(e=new mt,this._endpointMap.put(t,e)),e.count++}getClass(){return pt}get interfaces_(){return[]}}pt.constructor_=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){const t=arguments[0];pt.constructor_.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}};class mt{constructor(){mt.constructor_.apply(this,arguments)}getClass(){return mt}get interfaces_(){return[]}}mt.constructor_=function(){this.count=null};class yt{constructor(){yt.constructor_.apply(this,arguments)}static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const s=new g;t.getCoordinate(0,s);let i=s.x,r=s.y;for(let o=1;o<e;o++){t.getCoordinate(o,s);const e=s.x,l=s.y,a=e-i,c=l-r;n+=Math.sqrt(a*a+c*c),i=e,r=l}return n}getClass(){return yt}get interfaces_(){return[]}}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}yt.constructor_=function(){};class St{constructor(){St.constructor_.apply(this,arguments)}static chars(t,e){const n=new Array(e).fill(null);for(let s=0;s<e;s++)n[s]=t;return new String(n)}static getStackTrace(){if(1===arguments.length){const t=arguments[0],e=new It,n=new xt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n="";const s=new Ct(new Et(St.getStackTrace(t)));for(let t=0;t<e;t++)try{n+=s.readLine()+St.NEWLINE}catch(t){if(!(t instanceof Nt))throw t;u.shouldNeverReachHere()}return n}}static split(t,e){const n=e.length,s=new x;let i=""+t,r=i.indexOf(e);for(;r>=0;){const t=i.substring(0,r);s.add(t),i=i.substring(r+n),r=i.indexOf(e)}i.length>0&&s.add(i);const o=new Array(s.size()).fill(null);for(let t=0;t<o.length;t++)o[t]=s.get(t);return o}static toString(){if(1===arguments.length&&"number"==typeof arguments[0]){const t=arguments[0];return St.SIMPLE_ORDINATE_FORMAT.format(t)}}static spaces(t){return St.chars(" ",t)}getClass(){return St}get interfaces_(){return[]}}function wt(t){this.str=t}St.constructor_=function(){},St.NEWLINE=O.getProperty("line.separator"),St.SIMPLE_ORDINATE_FORMAT=new function(){}("0.#"),wt.prototype.append=function(t){this.str+=t},wt.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},wt.prototype.toString=function(t){return this.str};class Lt{constructor(){Lt.constructor_.apply(this,arguments)}static copyCoord(t,e,n,s){const i=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<i;r++)n.setOrdinate(s,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,A.X)===t.getOrdinate(e-1,A.X)&&t.getOrdinate(0,A.Y)===t.getOrdinate(e-1,A.Y))}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const s=Math.min(t.getDimension(),e.getDimension());for(let r=0;r<n;r++)for(let n=0;n<s;n++){const s=t.getOrdinate(r,n),o=e.getOrdinate(r,n);if(t.getOrdinate(r,n)!==e.getOrdinate(r,n)&&(!i.isNaN(s)||!i.isNaN(o)))return!1}return!0}static extend(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();if(Lt.copy(e,0,s,0,i),i>0)for(let t=i;t<n;t++)Lt.copy(e,i-1,s,t,1);return s}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++)Lt.swap(t,s,e-s)}static swap(t,e,n){if(e===n)return null;for(let s=0;s<t.getDimension();s++){const i=t.getOrdinate(e,s);t.setOrdinate(e,s,t.getOrdinate(n,s)),t.setOrdinate(n,s,i)}}static copy(t,e,n,s,i){for(let r=0;r<i;r++)Lt.copyCoord(t,e+r,n,s+r)}static toString(){if(1===arguments.length&&_(arguments[0],A)){const t=arguments[0],e=t.size();if(0===e)return"()";const n=t.getDimension(),s=new wt;s.append("(");for(let i=0;i<e;i++){i>0&&s.append(" ");for(let e=0;e<n;e++)e>0&&s.append(","),s.append(St.toString(t.getOrdinate(i,e)))}return s.append(")"),s.toString()}}static ensureValidRing(t,e){const n=e.size();return 0===n?e:n<=3?Lt.createClosedRing(t,e,4):e.getOrdinate(0,A.X)===e.getOrdinate(n-1,A.X)&&e.getOrdinate(0,A.Y)===e.getOrdinate(n-1,A.Y)?e:Lt.createClosedRing(t,e,n+1)}static createClosedRing(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();Lt.copy(e,0,s,0,i);for(let t=i;t<n;t++)Lt.copy(e,0,s,t,1);return s}getClass(){return Lt}get interfaces_(){return[]}}Lt.constructor_=function(){};class Tt extends q{constructor(){super(),Tt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this.isEmpty()?new N:this._points.expandEnvelope(new N)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();Lt.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?ut.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return q.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return yt.ofLine(this._points)}getNumPoints(){return this._points.size()}reverse(){const t=this._points.copy();return Lt.reverse(t),this.getFactory().createLineString(t)}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const s=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==s)return s;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(_(arguments[0],B)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(_(arguments[0],dt)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){arguments[0].filter(this)}}getBoundary(){return new pt(this).getBoundary()}isEquivalentClass(t){return t instanceof Tt}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return q.TYPENAME_LINESTRING}copy(){return new Tt(this._points.copy(),this._factory)}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new n("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}getClass(){return Tt}get interfaces_(){return[ot]}}Tt.constructor_=function(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];q.constructor_.call(this,e),this.init(t)}},Tt.serialVersionUID=0x2b2b51ba435c8e00;class Rt{constructor(){Rt.constructor_.apply(this,arguments)}getClass(){return Rt}get interfaces_(){return[]}}Rt.constructor_=function(){};class Pt extends q{constructor(){super(),Pt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){if(this.isEmpty())return new N;const t=new N;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return ut.FALSE}getTypeCode(){return q.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}reverse(){return this.copy()}getX(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(_(arguments[0],B)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(_(arguments[0],dt)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_POINT}copy(){return new Pt(this._coordinates.copy(),this._factory)}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),u.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}getClass(){return Pt}get interfaces_(){return[Rt]}}Pt.constructor_=function(){this._coordinates=null;const t=arguments[0],e=arguments[1];q.constructor_.call(this,e),this.init(t)},Pt.serialVersionUID=0x44077bad161cbc00;class vt{constructor(){vt.constructor_.apply(this,arguments)}static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(vt.ofRingSigned(t))}if(_(arguments[0],A)){const t=arguments[0];return Math.abs(vt.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let s=1;s<t.length-1;s++){const i=t[s].x-n,r=t[s+1].y;e+=i*(t[s-1].y-r)}return e/2}if(_(arguments[0],A)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new g,s=new g,i=new g;t.getCoordinate(0,s),t.getCoordinate(1,i);const r=s.x;i.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=s.y,s.x=i.x,s.y=i.y,t.getCoordinate(l+1,i),i.x-=r,o+=s.x*(n.y-i.y);return o/2}}getClass(){return vt}get interfaces_(){return[]}}vt.constructor_=function(){};class Ot{constructor(){Ot.constructor_.apply(this,arguments)}getClass(){return Ot}get interfaces_(){return[]}}Ot.constructor_=function(){};class bt extends q{constructor(){super(),bt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let s=0;s<n.length;s++)e++,t[e]=n[s];for(let n=0;n<this._holes.length;n++){const s=this._holes[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;t+=vt.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=vt.ofRing(this._holes[e].getCoordinateSequence());return t}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const s=t.getX(n);if(s!==e.getMinX()&&s!==e.getMaxX())return!1;const i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}let n=t.getX(0),s=t.getY(0);for(let e=1;e<=4;e++){const i=t.getX(e),r=t.getY(e);if(i!==n===(r!==s))return!1;n=i,s=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,s=this._shell,i=n._shell;if(!s.equalsExact(i,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this.normalize(this._shell,!0);for(let t=0;t<this._holes.length;t++)this.normalize(this._holes[t],!1);ht.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=new Array(t.getCoordinates().length-1).fill(null);O.arraycopy(t.getCoordinates(),0,n,0,n.length);const s=X.minCoordinate(t.getCoordinates());X.scroll(n,s),O.arraycopy(n,0,t.getCoordinates(),0,n.length),t.getCoordinates()[n.length]=n[0],v.isCCW(t.getCoordinates())===e&&X.reverse(t.getCoordinates())}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}reverse(){const t=this.copy();t._shell=this._shell.copy().reverse(),t._holes=new Array(this._holes.length).fill(null);for(let e=0;e<this._holes.length;e++)t._holes[e]=this._holes[e].copy().reverse();return t}convexHull(){return this.getExteriorRing().convexHull()}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t,s=this._shell,i=n._shell,r=s.compareToSameClass(i,e);if(0!==r)return r;const o=this.getNumInteriorRing(),l=n.getNumInteriorRing();let a=0;for(;a<o&&a<l;){const t=this.getInteriorRingN(a),s=n.getInteriorRingN(a),i=t.compareToSameClass(s,e);if(0!==i)return i;a++}return a<o?1:a<l?-1:0}}apply(){if(_(arguments[0],B)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(_(arguments[0],dt)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return q.TYPENAME_POLYGON}copy(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new bt(t,e,this._factory)}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}getClass(){return bt}get interfaces_(){return[Ot]}}bt.constructor_=function(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1];const s=arguments[2];if(q.constructor_.call(this,s),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),q.hasNullElements(e))throw new n("holes must not contain null elements");if(t.isEmpty()&&q.hasNonEmptyElements(e))throw new n("shell is empty but holes are not");this._shell=t,this._holes=e},bt.serialVersionUID=-0x307ffefd8dc97200;class Mt extends _t{constructor(){super(),Mt.constructor_.apply(this,arguments)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return ut.FALSE}getTypeCode(){return q.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_MULTIPOINT}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Mt(t,this._factory)}getClass(){return Mt}get interfaces_(){return[Rt]}}Mt.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},Mt.serialVersionUID=-0x6fb1ed4162e0fc00;class Dt extends Tt{constructor(){super(),Dt.constructor_.apply(this,arguments)}getBoundaryDimension(){return ut.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}getTypeCode(){return q.TYPECODE_LINEARRING}reverse(){const t=this._points.copy();return Lt.reverse(t),this.getFactory().createLinearRing(t)}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new n("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<Dt.MINIMUM_VALID_SIZE)throw new n("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return q.TYPENAME_LINEARRING}copy(){return new Dt(this._points.copy(),this._factory)}getClass(){return Dt}get interfaces_(){return[]}}Dt.constructor_=function(){if(arguments[0]instanceof Array&&arguments[1]instanceof Ht){const t=arguments[0],e=arguments[1];Dt.constructor_.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(_(arguments[0],A)&&arguments[1]instanceof Ht){const t=arguments[0],e=arguments[1];Tt.constructor_.call(this,t,e),this.validateConstruction()}},Dt.MINIMUM_VALID_SIZE=4,Dt.serialVersionUID=-0x3b229e262367a600;class At extends _t{constructor(){super(),At.constructor_.apply(this,arguments)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_MULTIPOLYGON}getDimension(){return 2}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)e[t]=this._geometries[t].reverse();return this.getFactory().createMultiPolygon(e)}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new x;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return q.TYPENAME_MULTIPOLYGON}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new At(t,this._factory)}getClass(){return At}get interfaces_(){return[Ot]}}At.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},At.serialVersionUID=-0x7a5aa1369171980;class Ft{constructor(){Ft.constructor_.apply(this,arguments)}setCopyUserData(t){this._isUserDataCopied=t}edit(t,e){if(null===t)return null;const n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n}editInternal(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof _t?this.editGeometryCollection(t,e):t instanceof bt?this.editPolygon(t,e):t instanceof Pt||t instanceof Tt?e.edit(t,this._factory):(u.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)}editGeometryCollection(t,e){const n=e.edit(t,this._factory),s=new x;for(let t=0;t<n.getNumGeometries();t++){const i=this.edit(n.getGeometryN(t),e);null===i||i.isEmpty()||s.add(i)}return n.getClass()===Mt?this._factory.createMultiPoint(s.toArray([])):n.getClass()===ft?this._factory.createMultiLineString(s.toArray([])):n.getClass()===At?this._factory.createMultiPolygon(s.toArray([])):this._factory.createGeometryCollection(s.toArray([]))}editPolygon(t,e){let n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon()),n.isEmpty())return n;const s=this.edit(n.getExteriorRing(),e);if(null===s||s.isEmpty())return this._factory.createPolygon();const i=new x;for(let t=0;t<n.getNumInteriorRing();t++){const s=this.edit(n.getInteriorRingN(t),e);null===s||s.isEmpty()||i.add(s)}return this._factory.createPolygon(s,i.toArray([]))}getClass(){return Ft}get interfaces_(){return[]}}function Gt(){}Ft.GeometryEditorOperation=Gt;class qt{constructor(){qt.constructor_.apply(this,arguments)}edit(t,e){return t}getClass(){return qt}get interfaces_(){return[Gt]}}qt.constructor_=function(){};class Bt{constructor(){Bt.constructor_.apply(this,arguments)}edit(t,e){const n=this.edit(t.getCoordinates(),t);return t instanceof Dt?null===n?e.createLinearRing():e.createLinearRing(n):t instanceof Tt?null===n?e.createLineString():e.createLineString(n):t instanceof Pt?null===n||0===n.length?e.createPoint():e.createPoint(n[0]):t}getClass(){return Bt}get interfaces_(){return[Gt]}}Bt.constructor_=function(){};class Vt{constructor(){Vt.constructor_.apply(this,arguments)}edit(t,e){return t instanceof Dt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof Tt?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Pt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t}getClass(){return Vt}get interfaces_(){return[Gt]}}Vt.constructor_=function(){},Ft.NoOpGeometryOperation=qt,Ft.CoordinateOperation=Bt,Ft.CoordinateSequenceOperation=Vt,Ft.constructor_=function(){if(this._factory=null,this._isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._factory=t}};class zt{constructor(){zt.constructor_.apply(this,arguments)}setOrdinate(t,e,s){switch(e){case A.X:this._coordinates[t].x=s;break;case A.Y:this._coordinates[t].y=s;break;case A.Z:this._coordinates[t].z=s;break;default:throw new n("invalid ordinateIndex")}}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case A.X:return this._coordinates[t].x;case A.Y:return this._coordinates[t].y;case A.Z:return this._coordinates[t].z}return i.NaN}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0],e=arguments[1];e.x=this._coordinates[t].x,e.y=this._coordinates[t].y,e.z=this._coordinates[t].z}}getCoordinateCopy(t){return new g(this._coordinates[t])}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)t[e]=this._coordinates[e].copy();return new zt(t,this._dimension)}toString(){if(this._coordinates.length>0){const t=new wt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}getClass(){return zt}get interfaces_(){return[A,a]}}zt.constructor_=function(){if(this._dimension=3,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];zt.constructor_.call(this,t,3)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new g}else if(_(arguments[0],A)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=t,this._dimension=e,null===t&&(this._coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let e=0;e<t;e++)this._coordinates[e]=new g}},zt.serialVersionUID=-0xcb44a778db18e00;class Yt{constructor(){Yt.constructor_.apply(this,arguments)}static instance(){return Yt.instanceObject}readResolve(){return Yt.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return new zt(t)}if(_(arguments[0],A)){const t=arguments[0];return new zt(t)}}else if(2===arguments.length){const t=arguments[0];let e=arguments[1];return e>3&&(e=3),e<2?new zt(t):new zt(t,e)}}getClass(){return Yt}get interfaces_(){return[F,a]}}function Ut(){this.map_=new Map}Yt.constructor_=function(){},Yt.serialVersionUID=-0x38e49fa6cf6f2e00,Yt.instanceObject=new Yt,Ut.prototype=new j,Ut.prototype.get=function(t){return this.map_.get(t)||null},Ut.prototype.put=function(t,e){return this.map_.set(t,e),e},Ut.prototype.values=function(){const t=new x,e=this.map_.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t},Ut.prototype.entrySet=function(){const t=new J;return this.map_.entries().forEach(e=>t.add(e)),t},Ut.prototype.size=function(){return this.map_.size()};class kt{constructor(){kt.constructor_.apply(this,arguments)}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof kt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),s=e.getMaximumSignificantDigits();return new L(n).compareTo(new L(s))}getScale(){return this._scale}isFloating(){return this._modelType===kt.FLOATING||this._modelType===kt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===kt.FLOATING?t="Floating":this._modelType===kt.FLOATING_SINGLE?t="Floating-Single":this._modelType===kt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(i.isNaN(t))return t;if(this._modelType===kt.FLOATING_SINGLE){return t}return this._modelType===kt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof g){const t=arguments[0];if(this._modelType===kt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===kt.FLOATING?t=16:this._modelType===kt.FLOATING_SINGLE?t=6:this._modelType===kt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}getClass(){return kt}get interfaces_(){return[a,r]}}class Xt{constructor(){Xt.constructor_.apply(this,arguments)}readResolve(){return Xt.nameToTypeMap.get(this._name)}toString(){return this._name}getClass(){return Xt}get interfaces_(){return[a]}}Xt.constructor_=function(){this._name=null;const t=arguments[0];this._name=t,Xt.nameToTypeMap.put(t,this)},Xt.serialVersionUID=-552860263173159e4,Xt.nameToTypeMap=new Ut,kt.Type=Xt,kt.constructor_=function(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=kt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof Xt){const t=arguments[0];this._modelType=t,t===kt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=kt.FIXED,this.setScale(t)}else if(arguments[0]instanceof kt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}},kt.serialVersionUID=0x6bee6404e9a25c00,kt.FIXED=new Xt("FIXED"),kt.FLOATING=new Xt("FLOATING"),kt.FLOATING_SINGLE=new Xt("FLOATING SINGLE"),kt.maximumPreciseValue=9007199254740992;class Ht{constructor(){Ht.constructor_.apply(this,arguments)}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return Yt.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){const t=arguments[0];return new Tt(t,this)}}}createMultiLineString(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){const t=arguments[0];return new ft(t,this)}}buildGeometry(t){let e=null,n=!1,s=!1;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=t.getClass();null===e&&(e=r),r!==e&&(n=!0),t instanceof _t&&(s=!0)}if(null===e)return this.createGeometryCollection();if(n||s)return this.createGeometryCollection(Ht.toGeometryArray(t));const i=t.iterator().next();if(t.size()>1){if(i instanceof bt)return this.createMultiPolygon(Ht.toPolygonArray(t));if(i instanceof Tt)return this.createMultiLineString(Ht.toLineStringArray(t));if(i instanceof Pt)return this.createMultiPoint(Ht.toPointArray(t));u.shouldNeverReachHere("Unhandled class: "+i.getClass().getName())}return i}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(_(arguments[0],A)){const t=arguments[0];return new Pt(t,this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(_(arguments[0],A)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Dt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return new bt(t,e,this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new _t(null,this);if(1===arguments.length){const t=arguments[0];return new _t(t,this)}}createGeometry(t){return new Ft(this).edit(t,new Wt(this._coordinateSequenceFactory))}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){const t=arguments[0];return new Dt(t,this)}}}createMultiPolygon(){if(0===arguments.length)return new At(null,this);if(1===arguments.length){const t=arguments[0];return new At(t,this)}}createMultiPoint(){if(0===arguments.length)return new Mt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return new Mt(t,this)}if(_(arguments[0],A)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=this.getCoordinateSequenceFactory().create(1,t.getDimension());Lt.copy(t,n,s,0,1),e[n]=this.createPoint(s)}return this.createMultiPoint(e)}}}getClass(){return Ht}get interfaces_(){return[a]}}class Wt extends Ft.CoordinateSequenceOperation{constructor(){super(),Wt.constructor_.apply(this,arguments)}edit(){if(2===arguments.length&&arguments[1]instanceof q&&_(arguments[0],A)){const t=arguments[0];return this.coordinateSequenceFactory.create(t)}return super.edit.apply(this,arguments)}getClass(){return Wt}get interfaces_(){return[]}}Wt.constructor_=function(){this.coordinateSequenceFactory=null;const t=arguments[0];this.coordinateSequenceFactory=t},Ht.CloneOp=Wt,Ht.constructor_=function(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Ht.constructor_.call(this,new kt,0);else if(1===arguments.length){if(_(arguments[0],F)){const t=arguments[0];Ht.constructor_.call(this,new kt,0,t)}else if(arguments[0]instanceof kt){const t=arguments[0];Ht.constructor_.call(this,t,0,Ht.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Ht.constructor_.call(this,t,e,Ht.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}},Ht.serialVersionUID=-0x5ea75f2051eeb400;const jt={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};class Kt{constructor(t){this.geometryFactory=t||new Ht,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){var e,n,s;t=t.replace(/[\n\r]/g," ");var i=jt.typeStr.exec(t);if(-1!==t.search("EMPTY")&&((i=jt.emptyTypeStr.exec(t))[2]=void 0),i&&(n=i[1].toLowerCase(),s=i[2],Qt[n]&&(e=Qt[n].call(this,s))),void 0===e)throw new Error("Could not parse WKT "+t);return e}write(t){return this.extractGeometry(t)}extractGeometry(t){var e=t.getGeometryType().toLowerCase();if(!Zt[e])return null;var n=e.toUpperCase();return t.isEmpty()?n+" EMPTY":n+"("+Zt[e].call(this,t)+")"}}const Zt={coordinate(t){return this.precisionModel.makePrecise(t),t.x+" "+t.y},point(t){return Zt.coordinate.call(this,t._coordinates._coordinates[0])},multipoint(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.point.call(this,t._geometries[n])+")");return e.join(",")},linestring(t){var e=[];for(let n=0,s=t._points._coordinates.length;n<s;++n)e.push(Zt.coordinate.call(this,t._points._coordinates[n]));return e.join(",")},linearring(t){var e=[];for(let n=0,s=t._points._coordinates.length;n<s;++n)e.push(Zt.coordinate.call(this,t._points._coordinates[n]));return e.join(",")},multilinestring(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.linestring.call(this,t._geometries[n])+")");return e.join(",")},polygon(t){var e=[];e.push("("+Zt.linestring.call(this,t._shell)+")");for(let n=0,s=t._holes.length;n<s;++n)e.push("("+Zt.linestring.call(this,t._holes[n])+")");return e.join(",")},multipolygon(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.polygon.call(this,t._geometries[n])+")");return e.join(",")},geometrycollection(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push(this.extractGeometry(t._geometries[n]));return e.join(",")}},Qt={coord(t){var e=t.trim().split(jt.spaces),n=new g(Number.parseFloat(e[0]),Number.parseFloat(e[1]));return this.precisionModel.makePrecise(n),n},point(t){return void 0===t?this.geometryFactory.createPoint():this.geometryFactory.createPoint(Qt.coord.call(this,t))},multipoint(t){if(void 0===t)return this.geometryFactory.createMultiPoint();var e,n=t.trim().split(","),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.point.call(this,e));return this.geometryFactory.createMultiPoint(s)},linestring(t){if(void 0===t)return this.geometryFactory.createLineString();var e=t.trim().split(","),n=[];for(let t=0,s=e.length;t<s;++t)n.push(Qt.coord.call(this,e[t]));return this.geometryFactory.createLineString(n)},linearring(t){if(void 0===t)return this.geometryFactory.createLinearRing();var e=t.trim().split(","),n=[];for(let t=0,s=e.length;t<s;++t)n.push(Qt.coord.call(this,e[t]));return this.geometryFactory.createLinearRing(n)},multilinestring(t){if(void 0===t)return this.geometryFactory.createMultiLineString();var e,n=t.trim().split(jt.parenComma),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.linestring.call(this,e));return this.geometryFactory.createMultiLineString(s)},polygon(t){if(void 0===t)return this.geometryFactory.createPolygon();var e,n,s,i,r=t.trim().split(jt.parenComma),o=[];for(let t=0,l=r.length;t<l;++t)e=r[t].replace(jt.trimParens,"$1"),n=Qt.linestring.call(this,e),s=this.geometryFactory.createLinearRing(n._points),0===t?i=s:o.push(s);return this.geometryFactory.createPolygon(i,o)},multipolygon(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();var e,n=t.trim().split(jt.doubleParenComma),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.polygon.call(this,e));return this.geometryFactory.createMultiPolygon(s)},geometrycollection(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();var e=(t=t.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),n=[];for(let t=0,s=e.length;t<s;++t)n.push(this.read(e[t]));return this.geometryFactory.createGeometryCollection(n)}};class Jt{constructor(t){this.parser=new Kt(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class $t{constructor(){$t.constructor_.apply(this,arguments)}static computeEdgeDistance(t,e,n){const s=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=s>i?s:i;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=s>i?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return u.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const s=t.x-e.x,i=t.y-e.y,r=Math.sqrt(s*s+i*i);return u.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new wt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,s){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=s,this._result=this.computeIntersect(t,e,n,s)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(()=>Array(2)),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==$t.NO_INTERSECTION}getEdgeDistance(t,e){return $t.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===$t.COLLINEAR_INTERSECTION}toString(){return Jt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Jt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}getClass(){return $t}get interfaces_(){return[]}}$t.constructor_=function(){this._result=null,this._inputLines=Array(2).fill().map(()=>Array(2)),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new g,this._intPt[1]=new g,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0},$t.DONT_INTERSECT=0,$t.DO_INTERSECT=1,$t.COLLINEAR=2,$t.NO_INTERSECTION=0,$t.POINT_INTERSECTION=1,$t.COLLINEAR_INTERSECTION=2;class te extends $t{constructor(){super(),te.constructor_.apply(this,arguments)}static nearestEndpoint(t,e,n,s){let i=t,r=D.pointToSegment(t,n,s),o=D.pointToSegment(e,n,s);return o<r&&(r=o,i=e),o=D.pointToSegment(n,t,e),o<r&&(r=o,i=n),o=D.pointToSegment(s,t,e),o<r&&(r=o,i=s),i}isInSegmentEnvelopes(t){const e=new N(this._inputLines[0][0],this._inputLines[0][1]),n=new N(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,N.intersects(e,n,t)&&0===v.index(e,n,t)&&0===v.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=$t.POINT_INTERSECTION,null;this._result=$t.NO_INTERSECTION}}normalizeToMinimum(t,e,n,s,i){i.x=this.smallestInAbsValue(t.x,e.x,n.x,s.x),i.y=this.smallestInAbsValue(t.y,e.y,n.y,s.y),t.x-=i.x,t.y-=i.y,e.x-=i.x,e.y-=i.y,n.x-=i.x,n.y-=i.y,s.x-=i.x,s.y-=i.y}safeHCoordinateIntersection(t,e,n,s){let i=null;try{i=b.intersection(t,e,n,s)}catch(r){if(!(r instanceof S))throw r;i=te.nearestEndpoint(t,e,n,s)}return i}intersection(t,e,n,s){let i=this.intersectionWithNormalization(t,e,n,s);return this.isInSegmentEnvelopes(i)||(i=new g(te.nearestEndpoint(t,e,n,s))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}smallestInAbsValue(t,e,n,s){let i=t,r=Math.abs(i);return Math.abs(e)<r&&(i=e,r=Math.abs(e)),Math.abs(n)<r&&(i=n,r=Math.abs(n)),Math.abs(s)<r&&(i=s),i}checkDD(t,e,n,s,i){const r=P.intersection(t,e,n,s),o=this.isInSegmentEnvelopes(r);O.out.println("DD in env = "+o+"  --------------------- "+r),i.distance(r)>1e-4&&O.out.println("Distance = "+i.distance(r))}intersectionWithNormalization(t,e,n,s){const i=new g(t),r=new g(e),o=new g(n),l=new g(s),a=new g;this.normalizeToEnvCentre(i,r,o,l,a);const c=this.safeHCoordinateIntersection(i,r,o,l);return c.x+=a.x,c.y+=a.y,c}computeCollinearIntersection(t,e,n,s){const i=N.intersects(t,e,n),r=N.intersects(t,e,s),o=N.intersects(n,s,t),l=N.intersects(n,s,e);return i&&r?(this._intPt[0]=n,this._intPt[1]=s,$t.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,$t.COLLINEAR_INTERSECTION):i&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):i&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):r&&o?(this._intPt[0]=s,this._intPt[1]=t,!s.equals(t)||i||l?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):r&&l?(this._intPt[0]=s,this._intPt[1]=e,!s.equals(e)||i||o?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):$t.NO_INTERSECTION}normalizeToEnvCentre(t,e,n,s,i){const r=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,l=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,c=n.x<s.x?n.x:s.x,h=n.y<s.y?n.y:s.y,u=n.x>s.x?n.x:s.x,g=n.y>s.y?n.y:s.y,d=((r>c?r:c)+(l<u?l:u))/2,_=((o>h?o:h)+(a<g?a:g))/2;i.x=d,i.y=_,t.x-=i.x,t.y-=i.y,e.x-=i.x,e.y-=i.y,n.x-=i.x,n.y-=i.y,s.x-=i.x,s.y-=i.y}computeIntersect(t,e,n,s){if(this._isProper=!1,!N.intersects(t,e,n,s))return $t.NO_INTERSECTION;const i=v.index(t,e,n),r=v.index(t,e,s);if(i>0&&r>0||i<0&&r<0)return $t.NO_INTERSECTION;const o=v.index(n,s,t),l=v.index(n,s,e);return o>0&&l>0||o<0&&l<0?$t.NO_INTERSECTION:0===i&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,s):(0===i||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(s)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(s)?this._intPt[0]=e:0===i?this._intPt[0]=new g(n):0===r?this._intPt[0]=new g(s):0===o?this._intPt[0]=new g(t):0===l&&(this._intPt[0]=new g(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,s)),$t.POINT_INTERSECTION)}getClass(){return te}get interfaces_(){return[]}}te.constructor_=function(){};class ee{constructor(){ee.constructor_.apply(this,arguments)}static midPoint(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof ee){const t=arguments[0],e=v.index(this.p0,this.p1,t.p0),n=v.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof g){const t=arguments[0];return v.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof ee))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new te;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof g){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);const e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ee){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let s=this.project(t.p0);e<0&&(s=this.p0),e>1&&(s=this.p1);let i=this.project(t.p1);return n<0&&(i=this.p0),n>1&&(i=this.p1),new ee(s,i)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return D.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return ee.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,s=e*e+n*n;return s<=0?i.NaN:((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/s}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let s=i.MAX_VALUE,r=null;const o=this.closestPoint(t.p0);s=o.distance(t.p0),n[0]=o,n[1]=t.p0;const l=this.closestPoint(t.p1);r=l.distance(t.p1),r<s&&(s=r,n[0]=l,n[1]=t.p1);const a=t.closestPoint(this.p0);r=a.distance(this.p0),r<s&&(s=r,n[0]=this.p0,n[1]=a);const c=t.closestPoint(this.p1);return r=c.distance(this.p1),r<s&&(s=r,n[0]=this.p1,n[1]=c),n}closestPoint(t){const e=this.projectionFactor(t);return e>0&&e<1?this.project(t):this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){try{return b.intersection(this.p0,this.p1,t.p0,t.p1)}catch(t){if(!(t instanceof S))throw t}return null}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),s=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(i*i+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new IllegalStateException("Cannot compute offset from zero-length line segment");l=e*i/o,a=e*r/o}return new g(n-a,s+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||i.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}distance(){if(arguments[0]instanceof ee){const t=arguments[0];return D.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){const t=arguments[0];return D.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=java.lang.Double.doubleToLongBits(this.p1.x);return n^=31*java.lang.Double.doubleToLongBits(this.p1.y),e^(Math.trunc(n)^Math.trunc(n>>32))}getClass(){return ee}get interfaces_(){return[r,a]}}ee.constructor_=function(){if(this.p0=null,this.p1=null,0===arguments.length)ee.constructor_.call(this,new g,new g);else if(1===arguments.length){const t=arguments[0];ee.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ee.constructor_.call(this,new g(t,e),new g(n,s))}},ee.serialVersionUID=0x2d2172135f411c00;class ne{constructor(){ne.constructor_.apply(this,arguments)}static toLocationSymbol(t){switch(t){case ne.EXTERIOR:return"e";case ne.BOUNDARY:return"b";case ne.INTERIOR:return"i";case ne.NONE:return"-"}throw new n("Unknown location value: "+t)}getClass(){return ne}get interfaces_(){return[]}}ne.constructor_=function(){},ne.INTERIOR=0,ne.BOUNDARY=1,ne.EXTERIOR=2,ne.NONE=-1;class se{constructor(){se.constructor_.apply(this,arguments)}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===ut.SYM_DONTCARE||(e===ut.SYM_TRUE&&(t>=0||t===ut.TRUE)||(e===ut.SYM_FALSE&&t===ut.FALSE||(e===ut.SYM_P&&t===ut.P||(e===ut.SYM_L&&t===ut.L||e===ut.SYM_A&&t===ut.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return new se(t).matches(e)}}static isTrue(t){return t>=0||t===ut.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])||se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY]))&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE}isCoveredBy(){return(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])||se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY]))&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this._matrix[n][s]=ut.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this.setAtLeast(n,s,ut.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===ut.A&&e===ut.A||t===ut.L&&e===ut.L||t===ut.L&&e===ut.A||t===ut.P&&e===ut.A||t===ut.P&&e===ut.L)&&(this._matrix[ne.INTERIOR][ne.INTERIOR]===ut.FALSE&&(se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY])))}isOverlaps(t,e){return t===ut.P&&e===ut.P||t===ut.A&&e===ut.A?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]):t===ut.L&&e===ut.L&&(1===this._matrix[ne.INTERIOR][ne.INTERIOR]&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]))}isEquals(t,e){return t===e&&(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE)}toString(){const t=new wt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,ut.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new n("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!se.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[ne.INTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.INTERIOR][ne.BOUNDARY]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.BOUNDARY]===ut.FALSE}isCrosses(t,e){return t===ut.P&&e===ut.L||t===ut.P&&e===ut.A||t===ut.L&&e===ut.A?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR]):t===ut.L&&e===ut.P||t===ut.A&&e===ut.P||t===ut.A&&e===ut.L?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]):t===ut.L&&e===ut.L&&0===this._matrix[ne.INTERIOR][ne.INTERIOR]}getClass(){return se}get interfaces_(){return[o]}}se.constructor_=function(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map(()=>Array(3)),this.setAll(ut.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];se.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof se){const t=arguments[0];se.constructor_.call(this),this._matrix[ne.INTERIOR][ne.INTERIOR]=t._matrix[ne.INTERIOR][ne.INTERIOR],this._matrix[ne.INTERIOR][ne.BOUNDARY]=t._matrix[ne.INTERIOR][ne.BOUNDARY],this._matrix[ne.INTERIOR][ne.EXTERIOR]=t._matrix[ne.INTERIOR][ne.EXTERIOR],this._matrix[ne.BOUNDARY][ne.INTERIOR]=t._matrix[ne.BOUNDARY][ne.INTERIOR],this._matrix[ne.BOUNDARY][ne.BOUNDARY]=t._matrix[ne.BOUNDARY][ne.BOUNDARY],this._matrix[ne.BOUNDARY][ne.EXTERIOR]=t._matrix[ne.BOUNDARY][ne.EXTERIOR],this._matrix[ne.EXTERIOR][ne.INTERIOR]=t._matrix[ne.EXTERIOR][ne.INTERIOR],this._matrix[ne.EXTERIOR][ne.BOUNDARY]=t._matrix[ne.EXTERIOR][ne.BOUNDARY],this._matrix[ne.EXTERIOR][ne.EXTERIOR]=t._matrix[ne.EXTERIOR][ne.EXTERIOR]}};class ie{constructor(){ie.constructor_.apply(this,arguments)}static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=ie.PI_TIMES_2;for(;t<=-Math.PI;)t+=ie.PI_TIMES_2;return t}static angle(){if(1===arguments.length){const t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return Math.atan2(s,n)}}static isAcute(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)>0}static isObtuse(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)<0}static interiorAngle(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n);return Math.abs(i-s)}static normalizePositive(t){if(t<0){for(;t<0;)t+=ie.PI_TIMES_2;t>=ie.PI_TIMES_2&&(t=0)}else{for(;t>=ie.PI_TIMES_2;)t-=ie.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n);return ie.diff(s,i)}static diff(t,e){let n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n}static toRadians(t){return t*Math.PI/180}static getTurn(t,e){const n=Math.sin(e-t);return n>0?ie.COUNTERCLOCKWISE:n<0?ie.CLOCKWISE:ie.NONE}static angleBetweenOriented(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n)-s;return i<=-Math.PI?i+ie.PI_TIMES_2:i>Math.PI?i-ie.PI_TIMES_2:i}getClass(){return ie}get interfaces_(){return[]}}ie.constructor_=function(){},ie.PI_TIMES_2=2*Math.PI,ie.PI_OVER_2=Math.PI/2,ie.PI_OVER_4=Math.PI/4,ie.COUNTERCLOCKWISE=v.COUNTERCLOCKWISE,ie.CLOCKWISE=v.CLOCKWISE,ie.NONE=v.COLLINEAR;class re{constructor(){re.constructor_.apply(this,arguments)}static area(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}static signedArea(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}static det(t,e,n,s){return t*s-e*n}static interpolateZ(t,e,n,s){const i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.z+d*(n.z-e.z)+_*(s.z-e.z)}static longestSideLength(t,e,n){const s=t.distance(e),i=e.distance(n),r=n.distance(t);let o=s;return i>o&&(o=i),r>o&&(o=r),o}static isAcute(t,e,n){return!!ie.isAcute(t,e,n)&&(!!ie.isAcute(e,n,t)&&!!ie.isAcute(n,t,e))}static circumcentre(t,e,n){const s=n.x,i=n.y,r=t.x-s,o=t.y-i,l=e.x-s,a=e.y-i,c=2*re.det(r,o,l,a),h=re.det(o,r*r+o*o,a,l*l+a*a),u=re.det(r,r*r+o*o,l,l*l+a*a);return new g(s-h/c,i+u/c)}static perpendicularBisector(t,e){const n=e.x-t.x,s=e.y-t.y,i=new b(t.x+n/2,t.y+s/2,1),r=new b(t.x-s+n/2,t.y+n+s/2,1);return new b(i,r)}static angleBisector(t,e,n){const s=e.distance(t),i=s/(s+e.distance(n)),r=n.x-t.x,o=n.y-t.y;return new g(t.x+i*r,t.y+i*o)}static area3D(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=e.z-t.z,o=n.x-t.x,l=n.y-t.y,a=n.z-t.z,c=i*a-r*l,h=r*o-s*a,u=s*l-i*o,g=c*c+h*h+u*u;return Math.sqrt(g)/2}static centroid(t,e,n){const s=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new g(s,i)}static inCentre(t,e,n){const s=e.distance(n),i=t.distance(n),r=t.distance(e),o=s+i+r,l=(s*t.x+i*e.x+r*n.x)/o,a=(s*t.y+i*e.y+r*n.y)/o;return new g(l,a)}area(){return re.area(this.p0,this.p1,this.p2)}signedArea(){return re.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new n("Supplied point is null.");return re.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return re.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return re.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return re.circumcentre(this.p0,this.p1,this.p2)}area3D(){return re.area3D(this.p0,this.p1,this.p2)}centroid(){return re.centroid(this.p0,this.p1,this.p2)}inCentre(){return re.inCentre(this.p0,this.p1,this.p2)}getClass(){return re}get interfaces_(){return[]}}re.constructor_=function(){this.p0=null,this.p1=null,this.p2=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n};class oe extends C{constructor(){super(),oe.constructor_.apply(this,arguments)}getClass(){return oe}get interfaces_(){return[]}}oe.constructor_=function(){if(0===arguments.length)C.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];C.constructor_.call(this,t)}};class le{constructor(){le.constructor_.apply(this,arguments)}static translationInstance(t,e){const n=new le;return n.setToTranslation(t,e),n}static shearInstance(t,e){const n=new le;return n.setToShear(t,e),n}static reflectionInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToReflection(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.setToReflection(t,e,n,s),i}}static rotationInstance(){if(1===arguments.length){const t=arguments[0];return le.rotationInstance(Math.sin(t),Math.cos(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToRotation(t,e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return le.rotationInstance(Math.sin(t),Math.cos(t),e,n)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.setToRotation(t,e,n,s),i}}static scaleInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToScale(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.translate(-n,-s),i.scale(t,e),i.translate(n,s),i}}setToReflectionBasic(t,e,s,i){if(t===s&&e===i)throw new n("Reflection line points must be distinct");const r=s-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l,h=2*a*c,u=c*c-a*a;return this._m00=u,this._m01=h,this._m02=0,this._m10=h,this._m11=-u,this._m12=0,this}getInverse(){const t=this.getDeterminant();if(0===t)throw new oe("Transformation is non-invertible");const e=this._m11/t,n=-this._m10/t,s=-this._m01/t,i=this._m00/t,r=(this._m01*this._m12-this._m02*this._m11)/t,o=(-this._m00*this._m12+this._m10*this._m02)/t;return new le(e,s,r,n,i,o)}compose(t){const e=t._m00*this._m00+t._m01*this._m10,n=t._m00*this._m01+t._m01*this._m11,s=t._m00*this._m02+t._m01*this._m12+t._m02,i=t._m10*this._m00+t._m11*this._m10,r=t._m10*this._m01+t._m11*this._m11,o=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}equals(t){if(null===t)return!1;if(!(t instanceof le))return!1;const e=t;return this._m00===e._m00&&this._m01===e._m01&&this._m02===e._m02&&this._m10===e._m10&&this._m11===e._m11&&this._m12===e._m12}setToScale(t,e){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=e,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,e){return this.compose(le.scaleInstance(t,e)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1===arguments.length){const t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return this._m00=t,this._m01=e,this._m02=n,this._m10=s,this._m11=i,this._m12=r,this}}setToRotation(){if(1===arguments.length){const t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._m00=e,this._m01=-t,this._m02=0,this._m10=t,this._m11=e,this._m12=0,this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),e,n),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this._m00=e,this._m01=-t,this._m02=n-n*e+s*t,this._m10=t,this._m11=e,this._m12=s-n*t-s*e,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,e){this.transform(t,e)}rotate(){if(1===arguments.length){const t=arguments[0];return this.compose(le.rotationInstance(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.rotationInstance(t,e)),this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.compose(le.rotationInstance(t,e,n)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.rotationInstance(t,e)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){const e=this._m00*t._m00+this._m01*t._m10,n=this._m00*t._m01+this._m01*t._m11,s=this._m00*t._m02+this._m01*t._m12+this._m02,i=this._m10*t._m00+this._m11*t._m10,r=this._m10*t._m01+this._m11*t._m11,o=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}setToShear(t,e){return this._m00=1,this._m01=t,this._m02=0,this._m10=e,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){try{return null}catch(t){if(!(t instanceof C))throw t;u.shouldNeverReachHere()}return null}translate(t,e){return this.compose(le.translationInstance(t,e)),this}setToReflection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Reflection vector must be non-zero");if(t===e)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;const s=Math.sqrt(t*t+e*e),i=e/s,r=t/s;return this.rotate(-i,r),this.scale(1,-1),this.rotate(i,r),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],s=arguments[2],i=arguments[3];if(t===s&&e===i)throw new n("Reflection line points must be distinct");this.setToTranslation(-t,-e);const r=s-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l;return this.rotate(-a,c),this.scale(1,-1),this.rotate(a,c),this.translate(t,e),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,e){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=e,this}shear(t,e){return this.compose(le.shearInstance(t,e)),this}transform(){if(1===arguments.length){const t=arguments[0].copy();return t.apply(this),t}if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=this._m00*t.x+this._m01*t.y+this._m02,s=this._m10*t.x+this._m11*t.y+this._m12;return e.x=n,e.y=s,e}if(_(arguments[0],A)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=this._m00*t.getOrdinate(e,0)+this._m01*t.getOrdinate(e,1)+this._m02,s=this._m10*t.getOrdinate(e,0)+this._m11*t.getOrdinate(e,1)+this._m12;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}}}reflect(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.reflectionInstance(t,e)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(le.reflectionInstance(t,e,n,s)),this}}getClass(){return le}get interfaces_(){return[o,dt]}}le.constructor_=function(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0===arguments.length)this.setToIdentity();else if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof le){const t=arguments[0];this.setTransformation(t)}}else if(6===arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this.setTransformation(t,e,n,s,i,r)}};class ae{constructor(){ae.constructor_.apply(this,arguments)}static solve(t,e){const s=e.length;if(t.length!==s||t[0].length!==s)throw new n("Matrix A is incorrectly sized");for(let n=0;n<s;n++){let i=n;for(let e=n+1;e<s;e++)Math.abs(t[e][n])>Math.abs(t[i][n])&&(i=e);if(0===t[i][n])return null;ae.swapRows(t,n,i),ae.swapRows(e,n,i);for(let i=n+1;i<s;i++){const r=t[i][n]/t[n][n];for(let e=s-1;e>=n;e--)t[i][e]-=t[n][e]*r;e[i]-=e[n]*r}}const i=new Array(s).fill(null);for(let n=s-1;n>=0;n--){let r=0;for(let e=n+1;e<s;e++)r+=t[n][e]*i[e];i[n]=(e[n]-r)/t[n][n]}return i}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;for(let s=0;s<t[0].length;s++){const i=t[e][s];t[e][s]=t[n][s],t[n][s]=i}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;const s=t[e];t[e]=t[n],t[n]=s}}getClass(){return ae}get interfaces_(){return[]}}ae.constructor_=function(){};class ce{constructor(){ce.constructor_.apply(this,arguments)}solve(t){const e=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return ae.solve(e,t)}compute(){const t=[this._dest0.x,this._dest1.x,this._dest2.x],e=this.solve(t);if(null===e)return!1;this._m00=e[0],this._m01=e[1],this._m02=e[2];const n=[this._dest0.y,this._dest1.y,this._dest2.y],s=this.solve(n);return null!==s&&(this._m10=s[0],this._m11=s[1],this._m12=s[2],!0)}getTransformation(){return this.compute()?new le(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}getClass(){return ce}get interfaces_(){return[]}}ce.constructor_=function(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this._src0=t,this._src1=e,this._src2=n,this._dest0=s,this._dest1=i,this._dest2=r};class he{constructor(){he.constructor_.apply(this,arguments)}static createFromBaseLines(t,e,n,s){const i=new g(t.x+s.x-n.x,t.y+s.y-n.y),r=ie.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return new le;const a=l/o,c=le.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}static createFromControlVectors(){if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return le.translationInstance(n,s)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1];if(t.length!==e.length)throw new n("Src and Dest arrays are not the same length");if(t.length<=0)throw new n("Too few control points");if(t.length>3)throw new n("Too many control points");return 1===t.length?he.createFromControlVectors(t[0],e[0]):2===t.length?he.createFromControlVectors(t[0],t[1],e[0],e[1]):he.createFromControlVectors(t[0],t[1],t[2],e[0],e[1],e[2])}}else{if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new g(s.x-n.x,s.y-n.y),r=ie.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return null;const a=l/o,c=le.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return new ce(t,e,n,s,i,r).getTransformation()}}}getClass(){return he}get interfaces_(){return[]}}he.constructor_=function(){};class ue{constructor(){ue.constructor_.apply(this,arguments)}static getCoordinates(t){const e=new x;return t.apply(new ue(e)),e}filter(t){(t instanceof Tt||t instanceof Pt)&&this._coords.add(t.getCoordinate())}getClass(){return ue}get interfaces_(){return[G]}}ue.constructor_=function(){this._coords=null;const t=arguments[0];this._coords=t};class ge{constructor(){ge.constructor_.apply(this,arguments)}static map(t,e){return new ge(e).map(t)}map(t){const e=new x;for(let n=0;n<t.getNumGeometries();n++){const s=this._mapOp.map(t.getGeometryN(n));s.isEmpty()||e.add(s)}return t.getFactory().createGeometryCollection(Ht.toGeometryArray(e))}getClass(){return ge}get interfaces_(){return[]}}ge.constructor_=function(){this._mapOp=null;const t=arguments[0];this._mapOp=t};class de{constructor(){de.constructor_.apply(this,arguments)}static combine(){if(1===arguments.length){const t=arguments[0];return new de(t).combine()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new de(de.createList(t,e)).combine()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new de(de.createList(t,e,n)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new x;return n.add(t),n.add(e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new x;return s.add(t),s.add(e),s.add(n),s}}extractElements(t,e){if(null===t)return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);this._skipEmpty&&s.isEmpty()||e.add(s)}}combine(){const t=new x;for(let e=this._inputGeoms.iterator();e.hasNext();){const n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}getClass(){return de}get interfaces_(){return[]}}de.constructor_=function(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;const t=arguments[0];this._geomFactory=de.extractFactory(t),this._inputGeoms=t};class _e{constructor(){_e.constructor_.apply(this,arguments)}static isOfType(t,e){return t.getGeometryType()===e||e===q.TYPENAME_LINESTRING&&t.getGeometryType()===q.TYPENAME_LINEARRING}static extract(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return _e.extract(t,e,new x)}if(3===arguments.length){if(_(arguments[2],m)&&arguments[0]instanceof q&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t.getGeometryType()===e?n.add(t):t instanceof _t&&t.apply(new _e(e,n)),n}if(_(arguments[2],m)&&arguments[0]instanceof q&&arguments[1]instanceof Class){const t=arguments[0],e=arguments[1],n=arguments[2];return _e.extract(t,_e.toGeometryType(e),n)}}}filter(t){(null===this._geometryType||_e.isOfType(t,this._geometryType))&&this._comps.add(t)}getClass(){return _e}get interfaces_(){return[gt]}}_e.constructor_=function(){this._geometryType=null,this._comps=null;const t=arguments[0],e=arguments[1];this._geometryType=t,this._comps=e};class fe{constructor(){fe.constructor_.apply(this,arguments)}map(t){}getClass(){return fe}get interfaces_(){return[]}}fe.constructor_=function(){};class pe{constructor(){pe.constructor_.apply(this,arguments)}static map(){if(arguments[0]instanceof q&&_(arguments[1],fe)){const t=arguments[0],e=arguments[1],n=new x;for(let s=0;s<t.getNumGeometries();s++){const i=e.map(t.getGeometryN(s));null!==i&&n.add(i)}return t.getFactory().buildGeometry(n)}if(_(arguments[0],f)&&_(arguments[1],fe)){const t=arguments[0],e=arguments[1],n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e.map(t);null!==i&&n.add(i)}return n}}getClass(){return pe}get interfaces_(){return[]}}pe.constructor_=function(){};class me{constructor(){me.constructor_.apply(this,arguments)}transformPoint(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,e){let n=!0;const s=this.transformLinearRing(t.getExteriorRing(),t);null!==s&&s instanceof Dt&&!s.isEmpty()||(n=!1);const i=new x;for(let e=0;e<t.getNumInteriorRing();e++){const s=this.transformLinearRing(t.getInteriorRingN(e),t);null===s||s.isEmpty()||(s instanceof Dt||(n=!1),i.add(s))}if(n)return this._factory.createPolygon(s,i.toArray([]));{const t=new x;return null!==s&&t.add(s),t.addAll(i),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformLineString(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformCoordinates(t,e){return this.copy(t)}transformLineString(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPoint(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformMultiPolygon(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPolygon(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}copy(t){return t.copy()}transformGeometryCollection(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transform(t.getGeometryN(e));null!==s&&(this._pruneEmptyGeometry&&s.isEmpty()||n.add(s))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Ht.toGeometryArray(n)):this._factory.buildGeometry(n)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof Pt)return this.transformPoint(t,null);if(t instanceof Mt)return this.transformMultiPoint(t,null);if(t instanceof Dt)return this.transformLinearRing(t,null);if(t instanceof Tt)return this.transformLineString(t,null);if(t instanceof ft)return this.transformMultiLineString(t,null);if(t instanceof bt)return this.transformPolygon(t,null);if(t instanceof At)return this.transformMultiPolygon(t,null);if(t instanceof _t)return this.transformGeometryCollection(t,null);throw new n("Unknown Geometry subtype: "+t.getClass().getName())}transformLinearRing(t,e){const n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);const s=n.size();return s>0&&s<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)}getClass(){return me}get interfaces_(){return[]}}me.constructor_=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1};class ye{constructor(){ye.constructor_.apply(this,arguments)}static getGeometry(t){return t.getFactory().buildGeometry(ye.getLines(t))}static getLines(){if(1===arguments.length){const t=arguments[0];return ye.getLines(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof Tt?e.add(t):t instanceof _t&&t.apply(new ye(e)),e}}filter(t){t instanceof Tt&&this._comps.add(t)}getClass(){return ye}get interfaces_(){return[gt]}}ye.constructor_=function(){this._comps=null;const t=arguments[0];this._comps=t};class xe{constructor(){xe.constructor_.apply(this,arguments)}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(xe.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(xe.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return xe.getLines(t,!1)}if(2===arguments.length){if(_(arguments[0],f)&&_(arguments[1],f)){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){const t=n.next();xe.getLines(t,e)}return e}if(arguments[0]instanceof q&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new x;return t.apply(new xe(n,e)),n}if(arguments[0]instanceof q&&_(arguments[1],f)){const t=arguments[0],e=arguments[1];return t instanceof Tt?e.add(t):t.apply(new xe(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&_(arguments[0],f)&&_(arguments[1],f)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=t.iterator();s.hasNext();){const t=s.next();xe.getLines(t,e,n)}return e}if("boolean"==typeof arguments[2]&&arguments[0]instanceof q&&_(arguments[1],f)){const t=arguments[0],e=arguments[1],n=arguments[2];return t.apply(new xe(e,n)),e}}}filter(t){if(this._isForcedToLineString&&t instanceof Dt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof Tt&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}getClass(){return xe}get interfaces_(){return[G]}}xe.constructor_=function(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}};const Ee={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return Ee.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?ht.sort(n,e):ht.sort(n);const s=t.iterator();for(let t=0,e=n.length;t<e;t++)s.next(),s.set(n[t])},singletonList:function(t){const e=new x;return e.add(t),e}};class Ie{constructor(){Ie.constructor_.apply(this,arguments)}static getPoints(){if(1===arguments.length){const t=arguments[0];return t instanceof Pt?Ee.singletonList(t):Ie.getPoints(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof Pt?e.add(t):t instanceof _t&&t.apply(new Ie(e)),e}}filter(t){t instanceof Pt&&this._pts.add(t)}getClass(){return Ie}get interfaces_(){return[gt]}}Ie.constructor_=function(){this._pts=null;const t=arguments[0];this._pts=t};class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static getPolygons(){if(1===arguments.length){const t=arguments[0];return Ne.getPolygons(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof bt?e.add(t):t instanceof _t&&t.apply(new Ne(e)),e}}filter(t){t instanceof bt&&this._comps.add(t)}getClass(){return Ne}get interfaces_(){return[gt]}}Ne.constructor_=function(){this._comps=null;const t=arguments[0];this._comps=t};class Ce{constructor(){Ce.constructor_.apply(this,arguments)}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof _t)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}getClass(){return Ce}get interfaces_(){return[]}}Ce.constructor_=function(){this._isDone=!1};class Se{constructor(){Se.constructor_.apply(this,arguments)}createSupercircle(t){const e=1/t,n=this._dim.getMinSize()/2,s=this._dim.getCentre(),i=Math.pow(n,t),r=n,o=Math.pow(i/2,e),l=Math.trunc(this._nPts/8),a=new Array(8*l+1).fill(null),c=o/l;for(let n=0;n<=l;n++){let o=0,h=r;if(0!==n){o=c*n;const s=Math.pow(o,t);h=Math.pow(i-s,e)}a[n]=this.coordTrans(o,h,s),a[2*l-n]=this.coordTrans(h,o,s),a[2*l+n]=this.coordTrans(h,-o,s),a[4*l-n]=this.coordTrans(o,-h,s),a[4*l+n]=this.coordTrans(-o,-h,s),a[6*l-n]=this.coordTrans(-h,-o,s),a[6*l+n]=this.coordTrans(-h,o,s),a[8*l-n]=this.coordTrans(-o,h,s)}a[a.length-1]=new g(a[0]);const h=this._geomFact.createLinearRing(a),u=this._geomFact.createPolygon(h);return this.rotate(u)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){const t=this._dim.getEnvelope(),e=t.getWidth()/2,n=t.getHeight()/2,s=t.getMinX()+e,i=t.getMinY()+n,r=new Array(this._nPts+1).fill(null);let o=0;for(let t=0;t<this._nPts;t++){const l=t*(2*Math.PI/this._nPts),a=e*Math.cos(l)+s,c=n*Math.sin(l)+i;r[o++]=this.coord(a,c)}r[o]=new g(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}coordTrans(t,e,n){return this.coord(t+n.x,e+n.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts).fill(null);let h=0;for(let e=0;e<this._nPts;e++){const n=t+e*a,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}const u=this._geomFact.createLineString(c);return this.rotate(u)}rotate(t){if(0!==this._rotationAngle){const e=le.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(e)}return t}coord(t,e){const n=new g(t,e);return this._precModel.makePrecise(n),n}createArcPolygon(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts+2).fill(null);let h=0;c[h++]=this.coord(r,o);for(let e=0;e<this._nPts;e++){const n=t+a*e,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}c[h++]=this.coord(r,o);const u=this._geomFact.createLinearRing(c),g=this._geomFact.createPolygon(u);return this.rotate(g)}createRectangle(){let t=null,e=0,n=Math.trunc(this._nPts/4);n<1&&(n=1);const s=this._dim.getEnvelope().getWidth()/n,i=this._dim.getEnvelope().getHeight()/n,r=new Array(4*n+1).fill(null),o=this._dim.getEnvelope();for(t=0;t<n;t++){const n=o.getMinX()+t*s,i=o.getMinY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMaxX(),s=o.getMinY()+t*i;r[e++]=this.coord(n,s)}for(t=0;t<n;t++){const n=o.getMaxX()-t*s,i=o.getMaxY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMinX(),s=o.getMaxY()-t*i;r[e++]=this.coord(n,s)}r[e++]=new g(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}getClass(){return Se}get interfaces_(){return[]}}class we{constructor(){we.constructor_.apply(this,arguments)}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new g(t.getMinX(),t.getMinY()),this.centre=new g(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new N(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new N(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new N(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new g(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}getClass(){return we}get interfaces_(){return[]}}we.constructor_=function(){this.base=null,this.centre=null,this.width=null,this.height=null},Se.Dimensions=we,Se.constructor_=function(){if(this._geomFact=null,this._precModel=null,this._dim=new we,this._nPts=100,this._rotationAngle=0,0===arguments.length)Se.constructor_.call(this,new Ht);else if(1===arguments.length){const t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}};class Le extends Se{constructor(){super(),Le.constructor_.apply(this,arguments)}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){const t=this._dim.getEnvelope(),e=t.getWidth()/2;let n=this._armLengthRatio;n<0&&(n=0),n>1&&(n=1);const s=n*e,i=(1-n)*e,r=t.getMinX()+e,o=t.getMinY()+e,l=new Array(this._nPts+1).fill(null);let a=0;for(let t=0;t<this._nPts;t++){const e=t/this._nPts*this._numArms,n=e-Math.floor(e),c=2*Math.PI*n,h=i+s*((Math.cos(c)+1)/2),u=t*(2*Math.PI/this._nPts),g=h*Math.cos(u)+r,d=h*Math.sin(u)+o;l[a++]=this.coord(g,d)}l[a]=new g(l[0]);const c=this._geomFact.createLinearRing(l);return this._geomFact.createPolygon(c)}getClass(){return Le}get interfaces_(){return[]}}Le.constructor_=function(){if(this._numArms=8,this._armLengthRatio=.5,0===arguments.length)Se.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];Se.constructor_.call(this,t)}};var Te=Object.freeze({__proto__:null,AffineTransformation:le,AffineTransformationBuilder:ce,AffineTransformationFactory:he,ComponentCoordinateExtracter:ue,GeometryCollectionMapper:ge,GeometryCombiner:de,GeometryEditor:Ft,GeometryExtracter:_e,GeometryMapper:pe,GeometryTransformer:me,LineStringExtracter:ye,LinearComponentExtracter:xe,MapOp:fe,PointExtracter:Ie,PolygonExtracter:Ne,ShortCircuitedGeometryVisitor:Ce,SineStarFactory:Le}),Re=Object.freeze({__proto__:null,Coordinate:g,CoordinateList:I,Envelope:N,LineSegment:ee,GeometryFactory:Ht,Geometry:q,Point:Pt,LineString:Tt,LinearRing:Dt,Polygon:bt,GeometryCollection:_t,MultiPoint:Mt,MultiLineString:ft,MultiPolygon:At,Dimension:ut,IntersectionMatrix:se,PrecisionModel:kt,Location:ne,Triangle:re,util:Te});class Pe{constructor(){Pe.constructor_.apply(this,arguments)}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1===arguments.length){const t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n<this._distance&&this.initialize(t,e,n)}}initialize(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=n,this._isNull=!1}}toString(){return Jt.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1===arguments.length){const t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n>this._distance&&this.initialize(t,e,n)}}getClass(){return Pe}get interfaces_(){return[]}}Pe.constructor_=function(){this._pt=[new g,new g],this._distance=i.NaN,this._isNull=!0};class ve{constructor(){ve.constructor_.apply(this,arguments)}static computeDistance(){if(arguments[2]instanceof Pe&&arguments[0]instanceof Tt&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2],s=new ee,i=t.getCoordinates();for(let t=0;t<i.length-1;t++){s.setCoordinates(i[t],i[t+1]);const r=s.closestPoint(e);n.setMinimum(r,e)}}else if(arguments[2]instanceof Pe&&arguments[0]instanceof bt&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2];ve.computeDistance(t.getExteriorRing(),e,n);for(let s=0;s<t.getNumInteriorRing();s++)ve.computeDistance(t.getInteriorRingN(s),e,n)}else if(arguments[2]instanceof Pe&&arguments[0]instanceof q&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2];if(t instanceof Tt)ve.computeDistance(t,e,n);else if(t instanceof bt)ve.computeDistance(t,e,n);else if(t instanceof _t){const s=t;for(let t=0;t<s.getNumGeometries();t++){const i=s.getGeometryN(t);ve.computeDistance(i,e,n)}}else n.setMinimum(t.getCoordinate(),e)}else if(arguments[2]instanceof Pe&&arguments[0]instanceof ee&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.closestPoint(e);n.setMinimum(s,e)}}getClass(){return ve}get interfaces_(){return[]}}ve.constructor_=function(){};class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static distance(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Oe(t,e).distance()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Oe(t,e);return s.setDensifyFraction(n),s.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new n("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,e,n){const s=new be(e);if(t.apply(s),n.setMaximum(s.getMaxPointDistance()),this._densifyFrac>0){const s=new Me(e,this._densifyFrac);t.apply(s),n.setMaximum(s.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}getClass(){return Oe}get interfaces_(){return[]}}class be{constructor(){be.constructor_.apply(this,arguments)}filter(t){this._minPtDist.initialize(),ve.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}getClass(){return be}get interfaces_(){return[B]}}be.constructor_=function(){this._maxPtDist=new Pe,this._minPtDist=new Pe,this._euclideanDist=new ve,this._geom=null;const t=arguments[0];this._geom=t};class Me{constructor(){Me.constructor_.apply(this,arguments)}filter(t,e){if(0===e)return null;const n=t.getCoordinate(e-1),s=t.getCoordinate(e),i=(s.x-n.x)/this._numSubSegs,r=(s.y-n.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){const e=n.x+t*i,s=n.y+t*r,o=new g(e,s);this._minPtDist.initialize(),ve.computeDistance(this._geom,o,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}getClass(){return Me}get interfaces_(){return[dt]}}Me.constructor_=function(){this._maxPtDist=new Pe,this._minPtDist=new Pe,this._geom=null,this._numSubSegs=0;const t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))},Oe.MaxPointDistanceFilter=be,Oe.MaxDensifiedByFractionDistanceFilter=Me,Oe.constructor_=function(){this._g0=null,this._g1=null,this._ptDist=new Pe,this._densifyFrac=0;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e};var De=Object.freeze({__proto__:null,DiscreteHausdorffDistance:Oe,DistanceToPoint:ve,PointPairDistance:Pe});class Ae{constructor(){Ae.constructor_.apply(this,arguments)}visitItem(t){}getClass(){return Ae}get interfaces_(){return[]}}Ae.constructor_=function(){};class Fe{constructor(){Fe.constructor_.apply(this,arguments)}locate(t){}getClass(){return Fe}get interfaces_(){return[]}}Fe.constructor_=function(){};class Ge{constructor(){Ge.constructor_.apply(this,arguments)}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Jt.toLineString(new g(this._min,0),new g(this._max,0))}getClass(){return Ge}get interfaces_(){return[]}}class qe{constructor(){qe.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e,i=(n._min+n._max)/2,r=(s._min+s._max)/2;return i<r?-1:i>r?1:0}getClass(){return qe}get interfaces_(){return[l]}}qe.constructor_=function(){},Ge.NodeComparator=qe,Ge.constructor_=function(){this._min=i.POSITIVE_INFINITY,this._max=i.NEGATIVE_INFINITY};class Be extends Ge{constructor(){super(),Be.constructor_.apply(this,arguments)}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}getClass(){return Be}get interfaces_(){return[]}}Be.constructor_=function(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n};class Ve extends Ge{constructor(){super(),Ve.constructor_.apply(this,arguments)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}getClass(){return Ve}get interfaces_(){return[]}}Ve.constructor_=function(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)};class ze{constructor(){ze.constructor_.apply(this,arguments)}buildTree(){Ee.sort(this._leaves,new Ge.NodeComparator);let t=this._leaves,e=null,n=new x;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new IllegalStateException("Index cannot be added to once it has been queried");this._leaves.add(new Be(t,e,n))}query(t,e,n){this.init(),this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){O.out.println(Jt.toLineString(new g(t._min,this._level),new g(t._max,this._level)))}init(){if(null!==this._root)return null;this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const s=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(s);else{const s=new Ve(t.get(n),t.get(n+1));e.add(s)}}}getClass(){return ze}get interfaces_(){return[]}}ze.constructor_=function(){this._leaves=new x,this._root=null,this._level=0};class Ye{constructor(){Ye.constructor_.apply(this,arguments)}visitItem(t){this._items.add(t)}getItems(){return this._items}getClass(){return Ye}get interfaces_(){return[Ae]}}Ye.constructor_=function(){this._items=new x};class Ue{constructor(){Ue.constructor_.apply(this,arguments)}static locatePointInRing(){if(arguments[0]instanceof g&&_(arguments[1],A)){const t=arguments[0],e=arguments[1],n=new Ue(t),s=new g,i=new g;for(let t=1;t<e.size();t++)if(e.getCoordinate(t,s),e.getCoordinate(t-1,i),n.countSegment(s,i),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new Ue(t);for(let t=1;t<e.length;t++){const s=e[t],i=e[t-1];if(n.countSegment(s,i),n.isOnSegment())return n.getLocation()}return n.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,s=e.x;return n>s&&(n=e.x,s=t.x),this._p.x>=n&&this._p.x<=s&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=v.index(t,e,this._p);if(n===v.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===v.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==ne.EXTERIOR}getLocation(){return this._isPointOnSegment?ne.BOUNDARY:this._crossingCount%2==1?ne.INTERIOR:ne.EXTERIOR}isOnSegment(){return this._isPointOnSegment}getClass(){return Ue}get interfaces_(){return[]}}Ue.constructor_=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t};class ke{constructor(){ke.constructor_.apply(this,arguments)}locate(t){const e=new Ue(t),n=new Xe(e);return this._index.query(t.y,t.y,n),e.getLocation()}getClass(){return ke}get interfaces_(){return[Fe]}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}getClass(){return Xe}get interfaces_(){return[Ae]}}Xe.constructor_=function(){this._counter=null;const t=arguments[0];this._counter=t};class He{constructor(){He.constructor_.apply(this,arguments)}init(t){for(let e=xe.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new ee(t[e-1],t[e]),s=Math.min(n.p0.y,n.p1.y),i=Math.max(n.p0.y,n.p1.y);this._index.insert(s,i,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new Ye;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._index.query(t,e,n)}}getClass(){return He}get interfaces_(){return[]}}He.constructor_=function(){this._index=new ze;const t=arguments[0];this.init(t)},ke.SegmentVisitor=Xe,ke.IntervalIndexedGeometry=He,ke.constructor_=function(){this._index=null;const t=arguments[0];if(!(_(t,Ot)||t instanceof Dt))throw new n("Argument must be Polygonal or LinearRing");this._index=new He(t)};class We{constructor(){We.constructor_.apply(this,arguments)}static isOnLine(){if(arguments[0]instanceof g&&_(arguments[1],A)){const t=arguments[0],e=arguments[1],n=new te,s=new g,i=new g,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,s),e.getCoordinate(o,i),n.computeIntersection(t,s,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof g&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new te;for(let s=1;s<e.length;s++){const i=e[s-1],r=e[s];if(n.computeIntersection(t,i,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Ue.locatePointInRing(t,e)}static isInRing(t,e){return We.locateInRing(t,e)!==ne.EXTERIOR}getClass(){return We}get interfaces_(){return[]}}function je(){}We.constructor_=function(){},je.prototype.hasNext=function(){},je.prototype.next=function(){},je.prototype.remove=function(){};class Ke{constructor(){Ke.constructor_.apply(this,arguments)}static isAtomic(t){return!(t instanceof _t)}next(){if(this._atStart)return this._atStart=!1,Ke.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new y;const t=this._parent.getGeometryN(this._index++);return t instanceof _t?(this._subcollectionIterator=new Ke(t),this._subcollectionIterator.next()):t}remove(){throw new Z(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}getClass(){return Ke}get interfaces_(){return[je]}}Ke.constructor_=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()};class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static locatePointInPolygon(t,e){if(e.isEmpty())return ne.EXTERIOR;const n=e.getExteriorRing(),s=Ze.locatePointInRing(t,n);if(s!==ne.INTERIOR)return s;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=Ze.locatePointInRing(t,s);if(i===ne.BOUNDARY)return ne.BOUNDARY;if(i===ne.INTERIOR)return ne.EXTERIOR}return ne.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?We.locateInRing(t,e.getCoordinates()):ne.EXTERIOR}static containsPointInPolygon(t,e){return ne.EXTERIOR!==Ze.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof bt)return Ze.locatePointInPolygon(t,e);if(e instanceof _t){const n=new Ke(e);for(;n.hasNext();){const s=n.next();if(s!==e){const e=Ze.locateInGeometry(t,s);if(e!==ne.EXTERIOR)return e}}}return ne.EXTERIOR}static locate(t,e){return e.isEmpty()?ne.EXTERIOR:Ze.locateInGeometry(t,e)}locate(t){return Ze.locate(t,this._geom)}getClass(){return Ze}get interfaces_(){return[Fe]}}Ze.constructor_=function(){this._geom=null;const t=arguments[0];this._geom=t};var Qe=Object.freeze({__proto__:null,IndexedPointInAreaLocator:ke,PointOnGeometryLocator:Fe,SimplePointInAreaLocator:Ze});class Je{constructor(){Je.constructor_.apply(this,arguments)}measure(t,e){}getClass(){return Je}get interfaces_(){return[]}}Je.constructor_=function(){};class $e{constructor(){$e.constructor_.apply(this,arguments)}measure(t,e){return t.intersection(e).getArea()/t.union(e).getArea()}getClass(){return $e}get interfaces_(){return[Je]}}$e.constructor_=function(){};class tn{constructor(){tn.constructor_.apply(this,arguments)}static diagonalSize(t){if(t.isNull())return 0;const e=t.getWidth(),n=t.getHeight();return Math.sqrt(e*e+n*n)}measure(t,e){const n=Oe.distance(t,e,tn.DENSIFY_FRACTION),s=new N(t.getEnvelopeInternal());return s.expandToInclude(e.getEnvelopeInternal()),1-n/tn.diagonalSize(s)}getClass(){return tn}get interfaces_(){return[Je]}}tn.constructor_=function(){},tn.DENSIFY_FRACTION=.25;class en{constructor(){en.constructor_.apply(this,arguments)}static combine(t,e){return Math.min(t,e)}getClass(){return en}get interfaces_(){return[]}}en.constructor_=function(){};var nn=Object.freeze({__proto__:null,AreaSimilarityMeasure:$e,HausdorffSimilarityMeasure:tn,SimilarityMeasure:Je,SimilarityMeasureCombiner:en});class sn{constructor(){sn.constructor_.apply(this,arguments)}static area2(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}static centroid3(t,e,n,s){return s.x=t.x+e.x+n.x,s.y=t.y+e.y+n.y,null}static getCentroid(t){return new sn(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let e=0;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);if(0===s)continue;e+=s;const i=(t[n].x+t[n+1].x)/2;this._lineCentSum.x+=s*i;const r=(t[n].y+t[n+1].y)/2;this._lineCentSum.y+=s*r}this._totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])}addHole(t){const e=v.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}getCentroid(){const t=new g;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);const e=!v.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}addTriangle(t,e,n,s){const i=s?1:-1;sn.centroid3(t,e,n,this._triangleCent3);const r=sn.area2(t,e,n);this._cg3.x+=i*r*this._triangleCent3.x,this._cg3.y+=i*r*this._triangleCent3.y,this._areasum2+=i*r}add(){if(arguments[0]instanceof bt){const t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof q){const t=arguments[0];if(t.isEmpty())return null;if(t instanceof Pt)this.addPoint(t.getCoordinate());else if(t instanceof Tt)this.addLineSegments(t.getCoordinates());else if(t instanceof bt){const e=t;this.add(e)}else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}}getClass(){return sn}get interfaces_(){return[]}}function rn(t){this.message=t||""}function on(){this.array_=[]}sn.constructor_=function(){this._areaBasePt=null,this._triangleCent3=new g,this._areasum2=0,this._cg3=new g,this._lineCentSum=new g,this._totalLength=0,this._ptCount=0,this._ptCentSum=new g;const t=arguments[0];this._areaBasePt=null,this.add(t)},rn.prototype=new Error,rn.prototype.name="EmptyStackException",on.prototype=new m,on.prototype.add=function(t){return this.array_.push(t),!0},on.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},on.prototype.push=function(t){return this.array_.push(t),t},on.prototype.pop=function(t){if(0===this.array_.length)throw new rn;return this.array_.pop()},on.prototype.peek=function(){if(0===this.array_.length)throw new rn;return this.array_[this.array_.length-1]},on.prototype.empty=function(){return 0===this.array_.length},on.prototype.isEmpty=function(){return this.empty()},on.prototype.search=function(t){return this.array_.indexOf(t)},on.prototype.size=function(){return this.array_.length},on.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t};class ln{constructor(){ln.constructor_.apply(this,arguments)}static filterCoordinates(t){const e=new ln;for(let n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()}filter(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))}getCoordinates(){const t=new Array(this.list.size()).fill(null);return this.list.toArray(t)}getClass(){return ln}get interfaces_(){return[B]}}ln.constructor_=function(){this.treeSet=new at,this.list=new x};class an{constructor(){an.constructor_.apply(this,arguments)}static extractCoordinates(t){const e=new ln;return t.apply(e),e.getCoordinates()}preSort(t){let e=null;for(let n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ht.sort(t,1,t.length,new cn(t[0])),t}computeOctRing(t){const e=this.computeOctPts(t),n=new I;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);const e=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(e)}cleanRing(t){u.equals(t[0],t[t.length-1]);const e=new x;let n=null;for(let s=0;s<=t.length-2;s++){const i=t[s],r=t[s+1];i.equals(r)||(null!==n&&this.isBetween(n,i,r)||(e.add(i),n=i))}e.add(t[t.length-1]);const s=new Array(e.size()).fill(null);return e.toArray(s)}isBetween(t,e,n){if(0!==v.index(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1}reduce(t){const e=this.computeOctRing(t);if(null===e)return t;const n=new at;for(let t=0;t<e.length;t++)n.add(e[t]);for(let s=0;s<t.length;s++)We.isInRing(t[s],e)||n.add(t[s]);const s=X.toCoordinateArray(n);return s.length<3?this.padArray3(s):s}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));const e=this.preSort(t),n=this.grahamScan(e),s=this.toCoordinateArray(n);return this.lineOrPolygon(s)}padArray3(t){const e=new Array(3).fill(null);for(let n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e}computeOctPts(t){const e=new Array(8).fill(null);for(let n=0;n<e.length;n++)e[n]=t[0];for(let n=1;n<t.length;n++)t[n].x<e[0].x&&(e[0]=t[n]),t[n].x-t[n].y<e[1].x-e[1].y&&(e[1]=t[n]),t[n].y>e[2].y&&(e[2]=t[n]),t[n].x+t[n].y>e[3].x+e[3].y&&(e[3]=t[n]),t[n].x>e[4].x&&(e[4]=t[n]),t[n].x-t[n].y>e[5].x-e[5].y&&(e[5]=t[n]),t[n].y<e[6].y&&(e[6]=t[n]),t[n].x+t[n].y<e[7].x+e[7].y&&(e[7]=t[n]);return e}toCoordinateArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=t.get(n);e[n]=s}return e}grahamScan(t){let e=null;const n=new on;n.push(t[0]),n.push(t[1]),n.push(t[2]);for(let s=3;s<t.length;s++){for(e=n.pop();!n.empty()&&v.index(n.peek(),e,t[s])>0;)e=n.pop();n.push(e),n.push(t[s])}return n.push(t[0]),n}getClass(){return an}get interfaces_(){return[]}}class cn{constructor(){cn.constructor_.apply(this,arguments)}static polarCompare(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=n.x-t.x,o=n.y-t.y,l=v.index(t,e,n);if(l===v.COUNTERCLOCKWISE)return 1;if(l===v.CLOCKWISE)return-1;const a=s*s+i*i,c=r*r+o*o;return a<c?-1:a>c?1:0}compare(t,e){const n=t,s=e;return cn.polarCompare(this._origin,n,s)}getClass(){return cn}get interfaces_(){return[l]}}cn.constructor_=function(){this._origin=null;const t=arguments[0];this._origin=t},an.RadialComparator=cn,an.constructor_=function(){if(this._geomFactory=null,this._inputPts=null,1===arguments.length){const t=arguments[0];an.constructor_.call(this,an.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputPts=ln.filterCoordinates(t),this._geomFactory=e}};class hn{constructor(){hn.constructor_.apply(this,arguments)}static centre(t){return new g(hn.avg(t.getMinX(),t.getMaxX()),hn.avg(t.getMinY(),t.getMaxY()))}static avg(t,e){return(t+e)/2}addPolygon(t){if(t.isEmpty())return null;let e=null,n=null;const s=this.horizontalBisector(t);if(0===s.getLength())n=0,e=s.getCoordinate();else{const i=s.intersection(t),r=this.widestGeometry(i);n=r.getEnvelopeInternal().getWidth(),e=hn.centre(r.getEnvelopeInternal())}(null===this._interiorPoint||n>this._maxWidth)&&(this._interiorPoint=e,this._maxWidth=n)}getInteriorPoint(){return this._interiorPoint}widestGeometry(){if(arguments[0]instanceof _t){const t=arguments[0];if(t.isEmpty())return t;let e=t.getGeometryN(0);for(let n=1;n<t.getNumGeometries();n++)t.getGeometryN(n).getEnvelopeInternal().getWidth()>e.getEnvelopeInternal().getWidth()&&(e=t.getGeometryN(n));return e}if(arguments[0]instanceof q){const t=arguments[0];return t instanceof _t?this.widestGeometry(t):t}}horizontalBisector(t){const e=t.getEnvelopeInternal(),n=un.getBisectorY(t);return this._factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])}add(t){if(t instanceof bt)this.addPolygon(t);else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}getClass(){return hn}get interfaces_(){return[]}}class un{constructor(){un.constructor_.apply(this,arguments)}static getBisectorY(t){return new un(t).getBisectorY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getBisectorY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return hn.avg(this._hiY,this._loY)}process(t){const e=t.getCoordinateSequence();for(let t=0;t<e.size();t++){const n=e.getY(t);this.updateInterval(n)}}getClass(){return un}get interfaces_(){return[]}}un.constructor_=function(){this._poly=null,this._centreY=null,this._hiY=i.MAX_VALUE,this._loY=-i.MAX_VALUE;const t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=hn.avg(this._loY,this._hiY)},hn.SafeBisectorFinder=un,hn.constructor_=function(){this._factory=null,this._interiorPoint=null,this._maxWidth=0;const t=arguments[0];this._factory=t.getFactory(),this.add(t)};class gn{constructor(){gn.constructor_.apply(this,arguments)}addEndpoints(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Tt)this.addEndpoints(t.getCoordinates());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addEndpoints(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Tt)this.addInterior(t.getCoordinates());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addInterior(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=1;e<t.length-1;e++)this.add(t[e])}}add(t){const e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=e)}getClass(){return gn}get interfaces_(){return[]}}gn.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];t.isEmpty()?this._centroid=new g:this._centroid=sn.getCentroid(t),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)};class dn{constructor(){dn.constructor_.apply(this,arguments)}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Pt)this.add(t.getCoordinate());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}else if(arguments[0]instanceof g){const t=arguments[0],e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=e)}}getClass(){return dn}get interfaces_(){return[]}}dn.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];this._centroid=t.getCentroid().getCoordinate(),this.add(t)};class _n{constructor(){_n.constructor_.apply(this,arguments)}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?We.locateInRing(t,e.getCoordinates()):ne.EXTERIOR}intersects(t,e){return this.locate(t,e)!==ne.EXTERIOR}updateLocationInfo(t){t===ne.INTERIOR&&(this._isIn=!0),t===ne.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof Pt&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof Tt)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof bt)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof ft){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,s))}}else if(e instanceof At){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,s))}}else if(e instanceof _t){const n=new Ke(e);for(;n.hasNext();){const s=n.next();s!==e&&this.computeLocation(t,s)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?ne.INTERIOR:ne.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return ne.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?We.isOnLine(t,n)?ne.INTERIOR:ne.EXTERIOR:ne.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return ne.EXTERIOR;const n=e.getExteriorRing(),s=this.locateInPolygonRing(t,n);if(s===ne.EXTERIOR)return ne.EXTERIOR;if(s===ne.BOUNDARY)return ne.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=this.locateInPolygonRing(t,s);if(i===ne.INTERIOR)return ne.EXTERIOR;if(i===ne.BOUNDARY)return ne.BOUNDARY}return ne.INTERIOR}locate(t,e){return e.isEmpty()?ne.EXTERIOR:e instanceof Tt?this.locateOnLineString(t,e):e instanceof bt?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?ne.BOUNDARY:this._numBoundaries>0||this._isIn?ne.INTERIOR:ne.EXTERIOR)}getClass(){return _n}get interfaces_(){return[]}}_n.constructor_=function(){if(this._boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new n("Rule must be non-null");this._boundaryRule=t}};class fn{constructor(){fn.constructor_.apply(this,arguments)}static pointWitMinAngleWithX(t,e){let n=i.MAX_VALUE,s=null;for(let i=0;i<t.length;i++){const r=t[i];if(r===e)continue;const o=r.x-e.x;let l=r.y-e.y;l<0&&(l=-l);const a=l/Math.sqrt(o*o+l*l);a<n&&(n=a,s=r)}return s}static lowestPoint(t){let e=t[0];for(let n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e}static pointWithMinAngleWithSegment(t,e,n){let s=i.MAX_VALUE,r=null;for(let i=0;i<t.length;i++){const o=t[i];if(o===e)continue;if(o===n)continue;const l=ie.angleBetween(e,o,n);l<s&&(s=l,r=o)}return r}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[1];return this._input.getFactory().createLineString([t,e])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=new Array(0).fill(null),null;if(1===this._input.getNumPoints()){const t=this._input.getCoordinates();return this._extremalPts=[new g(t[0])],null}const t=this._input.convexHull().getCoordinates();let e=t;if(t[0].equals2D(t[t.length-1])&&(e=new Array(t.length-1).fill(null),X.copyDeep(t,0,e,0,t.length-1)),e.length<=2)return this._extremalPts=X.copyDeep(e),null;let n=fn.lowestPoint(e),s=fn.pointWitMinAngleWithX(e,n);for(let t=0;t<e.length;t++){const t=fn.pointWithMinAngleWithSegment(e,n,s);if(ie.isObtuse(n,t,s))return this._extremalPts=[new g(n),new g(s)],null;if(ie.isObtuse(t,n,s))n=t;else{if(!ie.isObtuse(t,s,n))return this._extremalPts=[new g(n),new g(s),new g(t)],null;s=t}}u.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getFarthestPoints(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[this._extremalPts.length-1];return this._input.getFactory().createLineString([t,e])}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();const t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new g((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=re.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}getClass(){return fn}get interfaces_(){return[]}}fn.constructor_=function(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;const t=arguments[0];this._input=t};class pn{constructor(){pn.constructor_.apply(this,arguments)}static nextIndex(t,e){return++e>=t.length&&(e=0),e}static computeC(t,e,n){return t*n.y-e*n.x}static getMinimumDiameter(t){return new pn(t).getDiameter()}static getMinimumRectangle(t){return new pn(t).getMinimumRectangle()}static computeSegmentForLine(t,e,n){let s=null,i=null;return Math.abs(e)>Math.abs(t)?(s=new g(0,n/e),i=new g(1,n/e-t/e)):(s=new g(n/t,0),i=new g(n/t-e/t,1)),new ee(s,i)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();const t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof bt?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=i.MAX_VALUE;let e=1;const n=new ee;for(let s=0;s<t.length-1;s++)n.p0=t[s],n.p1=t[s+1],e=this.findMaxPerpDistance(t,n,e)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{const t=new an(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,e,n){let s=e.distancePerpendicular(t[n]),i=s,r=n,o=r;for(;i>=s;)s=i,r=o,o=pn.nextIndex(t,r),i=e.distancePerpendicular(t[o]);return s<this._minWidth&&(this._minPtIndex=r,this._minWidth=s,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new ee(e)),r}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());const t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,e=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y;let n=i.MAX_VALUE,s=-i.MAX_VALUE,r=i.MAX_VALUE,o=-i.MAX_VALUE;for(let i=0;i<this._convexHullPts.length;i++){const l=pn.computeC(t,e,this._convexHullPts[i]);l>s&&(s=l),l<n&&(n=l);const a=pn.computeC(-e,t,this._convexHullPts[i]);a>o&&(o=a),a<r&&(r=a)}const l=pn.computeSegmentForLine(-t,-e,o),a=pn.computeSegmentForLine(-t,-e,r),c=pn.computeSegmentForLine(-e,t,s),h=pn.computeSegmentForLine(-e,t,n),u=c.lineIntersection(l),g=h.lineIntersection(l),d=h.lineIntersection(a),_=c.lineIntersection(a),f=this._inputGeom.getFactory().createLinearRing([u,g,d,_,u]);return this._inputGeom.getFactory().createPolygon(f)}getClass(){return pn}get interfaces_(){return[]}}pn.constructor_=function(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new ee,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1===arguments.length){const t=arguments[0];pn.constructor_.call(this,t,!1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isConvex=e}};var mn=Object.freeze({__proto__:null,distance:De,locate:Qe,match:nn,Angle:ie,Area:vt,Centroid:sn,ConvexHull:an,Distance:D,InteriorPointArea:hn,InteriorPointLine:gn,InteriorPointPoint:dn,Length:yt,Orientation:v,PointLocation:We,PointLocator:_n,RobustLineIntersector:te,MinimumBoundingCircle:fn,MinimumDiameter:pn});class yn{constructor(){yn.constructor_.apply(this,arguments)}static densifyPoints(t,e,n){const s=new ee,i=new I;for(let r=0;r<t.length-1;r++){s.p0=t[r],s.p1=t[r+1],i.add(s.p0,!1);const o=s.getLength(),l=Math.trunc(o/e)+1;if(l>1){const t=o/l;for(let e=1;e<l;e++){const r=e*t/o,l=s.pointAlong(r);n.makePrecise(l),i.add(l,!1)}}}return i.add(t[t.length-1],!1),i.toCoordinateArray()}static densify(t,e){const n=new yn(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){return new xn(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new n("Tolerance must be positive");this._distanceTolerance=t}getClass(){return yn}get interfaces_(){return[]}}class xn extends me{constructor(){super(),xn.constructor_.apply(this,arguments)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformPolygon(t,e){const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=yn.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof Tt&&1===s.length&&(s=new Array(0).fill(null)),this._factory.getCoordinateSequenceFactory().create(s)}createValidArea(t){return t.buffer(0)}getClass(){return xn}get interfaces_(){return[]}}xn.constructor_=function(){this.distanceTolerance=null;const t=arguments[0];this.distanceTolerance=t},yn.DensifyTransformer=xn,yn.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null;const t=arguments[0];this._inputGeom=t};var En=Object.freeze({__proto__:null,Densifier:yn});class In{constructor(){In.constructor_.apply(this,arguments)}static isNorthern(t){return t===In.NE||t===In.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===In.SE?t===In.SE||t===In.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?In.NE:In.SE:e>=0?In.NW:In.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new n("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?In.NE:In.SE:e.y>=t.y?In.NW:In.SW}}getClass(){return In}get interfaces_(){return[]}}In.constructor_=function(){},In.NE=0,In.NW=1,In.SW=2,In.SE=3;class Nn{constructor(){Nn.constructor_.apply(this,arguments)}static init(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t}static create(t,e){const n=new Nn(t),s=new Nn(e);return n.init(s),n}find(t){let e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null}dest(){return this._sym._orig}oNext(){return this._sym._next}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;const e=this.compareTo(t);let n=this;do{const s=n.oNext();if(s.compareTo(t)!==e||s===this)return n.insertAfter(t),null;n=s}while(n!==this);u.shouldNeverReachHere()}insertAfter(t){u.equals(this._orig,t.orig());const e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)}degree(){let t=0,e=this;do{t++,e=e.oNext()}while(e!==this);return t}equals(){if(2===arguments.length&&arguments[1]instanceof g&&arguments[0]instanceof g){const t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}}deltaY(){return this._sym._orig.y-this._orig.y}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){const e=this.deltaX(),n=this.deltaY(),s=t.deltaX(),i=t.deltaY();if(e===s&&n===i)return 0;const r=In.quadrant(e,n),o=In.quadrant(s,i);return r>o?1:r<o?-1:v.index(t._orig,t.dest(),this.dest())}prevNode(){let t=this;for(;2===t.degree();)if(t=t.prev(),t===this)return null;return t}compareTo(t){const e=t;return this.compareAngularDirection(e)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}setNext(t){this._next=t}init(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}deltaX(){return this._sym._orig.x-this._orig.x}getClass(){return Nn}get interfaces_(){return[]}}Nn.constructor_=function(){this._orig=null,this._sym=null,this._next=null;const t=arguments[0];this._orig=t};class Cn extends Nn{constructor(){super(),Cn.constructor_.apply(this,arguments)}static setMarkBoth(t,e){t.setMark(e),t.sym().setMark(e)}static isMarked(t){return t.isMarked()}static setMark(t,e){t.setMark(e)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}getClass(){return Cn}get interfaces_(){return[]}}Cn.constructor_=function(){this._isMarked=!1;const t=arguments[0];Nn.constructor_.call(this,t)};class Sn{constructor(){Sn.constructor_.apply(this,arguments)}static isValidEdge(t,e){return 0!==e.compareTo(t)}insert(t,e,n){const s=this.create(t,e);null!==n?n.insert(s):this._vertexMap.put(t,s);const i=this._vertexMap.get(e);return null!==i?i.insert(s.sym()):this._vertexMap.put(e,s.sym()),s}create(t,e){const n=this.createEdge(t),s=this.createEdge(e);return Nn.init(n,s),n}createEdge(t){return new Nn(t)}addEdge(t,e){if(!Sn.isValidEdge(t,e))return null;const n=this._vertexMap.get(t);let s=null;if(null!==n&&(s=n.find(e)),null!==s)return s;return this.insert(t,e,n)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,e){const n=this._vertexMap.get(t);return null===n?null:n.find(e)}getClass(){return Sn}get interfaces_(){return[]}}Sn.constructor_=function(){this._vertexMap=new Ut};class wn extends Cn{constructor(){super(),wn.constructor_.apply(this,arguments)}setStart(){this._isStart=!0}isStart(){return this._isStart}getClass(){return wn}get interfaces_(){return[]}}wn.constructor_=function(){this._isStart=!1;const t=arguments[0];Cn.constructor_.call(this,t)};class Ln extends Sn{constructor(){super(),Ln.constructor_.apply(this,arguments)}createEdge(t){return new wn(t)}getClass(){return Ln}get interfaces_(){return[]}}Ln.constructor_=function(){};class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static dissolve(t){const e=new Tn;return e.add(t),e.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(t.orig().compareTo(this._ringStartEdge.orig())<0&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()}buildRing(t){const e=new I;let n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){const s=n.next();if(s===t)break;e.add(s.orig().copy(),!1),n=s}e.add(n.dest().copy(),!1),this.addLine(e)}buildLine(t){const e=new I;let n=t;for(this._ringStartEdge=null,Cn.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);const s=n.next();if(s===t)return this.buildRing(this._ringStartEdge),null;e.add(s.orig().copy(),!1),n=s,Cn.markBoth(n)}e.add(n.dest().clone(),!1),this.stackEdges(n.sym()),this.addLine(e)}stackEdges(t){let e=t;do{Cn.isMarked(e)||this._nodeEdgeStack.add(e),e=e.oNext()}while(e!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){const e=t.next();Cn.isMarked(e)||this.process(e)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){const t=this._nodeEdgeStack.pop();Cn.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof q){arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Tt&&this.add(t)}})}else if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof Tt){const t=arguments[0];null===this._factory&&(this._factory=t.getFactory());const e=t.getCoordinateSequence();let n=!1;for(let t=1;t<e.size();t++){const s=this._graph.addEdge(e.getCoordinate(t-1),e.getCoordinate(t));null!==s&&(n||(s.setStart(),n=!0))}}}getClass(){return Tn}get interfaces_(){return[]}}Tn.constructor_=function(){this._result=null,this._factory=null,this._graph=null,this._lines=new x,this._nodeEdgeStack=new on,this._ringStartEdge=null,this._graph=new Ln};var Rn=Object.freeze({__proto__:null,LineDissolver:Tn});class Pn{constructor(){Pn.constructor_.apply(this,arguments)}static opposite(t){return t===Pn.LEFT?Pn.RIGHT:t===Pn.RIGHT?Pn.LEFT:t}getClass(){return Pn}get interfaces_(){return[]}}Pn.constructor_=function(){},Pn.ON=0,Pn.LEFT=1,Pn.RIGHT=2;class vn{constructor(){vn.constructor_.apply(this,arguments)}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}getClass(){return vn}get interfaces_(){return[]}}vn.constructor_=function(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e};class On{constructor(){On.constructor_.apply(this,arguments)}isDelete(){return this._eventType===On.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===On.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}getClass(){return On}get interfaces_(){return[r]}}On.constructor_=function(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=On.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=On.INSERT,this._label=t,this._xValue=e,this._obj=n}},On.INSERT=1,On.DELETE=2;class bn{constructor(){bn.constructor_.apply(this,arguments)}getClass(){return bn}get interfaces_(){return[]}}bn.constructor_=function(){};class Mn{constructor(){Mn.constructor_.apply(this,arguments)}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Mn.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}getClass(){return Mn}get interfaces_(){return[]}}Mn.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n};class Dn extends bn{constructor(){super(),Dn.constructor_.apply(this,arguments)}prepareEvents(){Ee.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof Mn&&_(arguments[0],m)&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&_(arguments[0],m)&&arguments[1]instanceof Mn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),s=n.getStartIndexes();for(let t=0;t<s.length-1;t++){const s=new vn(n,t),i=new On(e,n.getMinX(t),s);this.events.add(i),this.events.add(new On(n.getMaxX(t),i))}}processOverlaps(t,e,n,s){const i=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(i.computeIntersections(e,s),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){const t=n.next();this.addEdge(t,e)}}}getClass(){return Dn}get interfaces_(){return[]}}Dn.constructor_=function(){this.events=new x,this.nOverlaps=null};class An{constructor(){An.constructor_.apply(this,arguments)}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==ne.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===ne.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[Pn.ON]=this.location[Pn.ON],t[Pn.LEFT]=ne.NONE,t[Pn.RIGHT]=ne.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===ne.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[Pn.LEFT];this.location[Pn.LEFT]=this.location[Pn.RIGHT],this.location[Pn.RIGHT]=t}toString(){const t=new w;return this.location.length>1&&t.append(ne.toLocationSymbol(this.location[Pn.LEFT])),t.append(ne.toLocationSymbol(this.location[Pn.ON])),this.location.length>1&&t.append(ne.toLocationSymbol(this.location[Pn.RIGHT])),t.toString()}setLocations(t,e,n){this.location[Pn.ON]=t,this.location[Pn.LEFT]=e,this.location[Pn.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:ne.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===ne.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(Pn.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(ne.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}getClass(){return An}get interfaces_(){return[]}}An.constructor_=function(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[Pn.ON]=t}else if(arguments[0]instanceof An){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[Pn.ON]=t,this.location[Pn.LEFT]=e,this.location[Pn.RIGHT]=n}};class Fn{constructor(){Fn.constructor_.apply(this,arguments)}static toLineLabel(t){const e=new Fn(ne.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new An(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(Pn.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new w;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(Pn.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new An(this.elt[t].location[0]))}getClass(){return Fn}get interfaces_(){return[]}}Fn.constructor_=function(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new An(t),this.elt[1]=new An(t)}else if(arguments[0]instanceof Fn){const t=arguments[0];this.elt[0]=new An(t.elt[0]),this.elt[1]=new An(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new An(ne.NONE),this.elt[1]=new An(ne.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new An(t,e,n),this.elt[1]=new An(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.elt[0]=new An(ne.NONE,ne.NONE,ne.NONE),this.elt[1]=new An(ne.NONE,ne.NONE,ne.NONE),this.elt[t].setLocations(e,n,s)}};class Gn{constructor(){Gn.constructor_.apply(this,arguments)}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}getClass(){return Gn}get interfaces_(){return[r]}}Gn.constructor_=function(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n};class qn{constructor(){qn.constructor_.apply(this,arguments)}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new g(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return i&&(r[o]=e.coord),new Un(r,new Fn(this.edge._label))}add(t,e,n){const s=new Gn(t,e,n),i=this._nodeMap.get(s);return null!==i?i:(this._nodeMap.put(s,s),s)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}getClass(){return qn}get interfaces_(){return[]}}qn.constructor_=function(){this._nodeMap=new rt,this.edge=null;const t=arguments[0];this.edge=t};class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new x;n.add(new L(e));do{const s=this.findChainEnd(t,e);n.add(new L(s)),e=s}while(e<t.length-1);return Bn.toIntArray(n)}findChainEnd(t,e){const n=In.quadrant(t[e],t[e+1]);let s=e+1;for(;s<t.length;){if(In.quadrant(t[s-1],t[s])!==n)break;s++}return s-1}getClass(){return Bn}get interfaces_(){return[]}}Bn.constructor_=function(){};class Vn{constructor(){Vn.constructor_.apply(this,arguments)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],s)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.addIntersections(this.e,t,n.e,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeIntersectsForChain(t,o,n,s,l,r),l<i&&this.computeIntersectsForChain(t,o,n,l,i,r)),o<e&&(s<l&&this.computeIntersectsForChain(o,e,n,s,l,r),l<i&&this.computeIntersectsForChain(o,e,n,l,i,r))}}overlaps(t,e,n,s,i){return N.intersects(this.pts[t],this.pts[e],n.pts[s],n.pts[i])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let s=0;s<t.startIndex.length-1;s++)this.computeIntersectsForChain(n,t,s,e)}getClass(){return Vn}get interfaces_(){return[]}}Vn.constructor_=function(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new Bn;this.startIndex=e.getChainStartIndices(this.pts)};class zn{constructor(){zn.constructor_.apply(this,arguments)}static depthAtLocation(t){return t===ne.EXTERIOR?0:t===ne.INTERIOR?1:zn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==zn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===zn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===zn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let s=0;this._depth[t][n]>e&&(s=1),this._depth[t][n]=s}}}getDelta(t){return this._depth[t][Pn.RIGHT]-this._depth[t][Pn.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?ne.EXTERIOR:ne.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const s=t.getLocation(e,n);s!==ne.EXTERIOR&&s!==ne.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=zn.depthAtLocation(s):this._depth[e][n]+=zn.depthAtLocation(s))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===ne.INTERIOR&&this._depth[t][e]++}}getClass(){return zn}get interfaces_(){return[]}}zn.constructor_=function(){this._depth=Array(2).fill().map(()=>Array(3));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=zn.NULL_VALUE},zn.NULL_VALUE=-1;class Yn{constructor(){Yn.constructor_.apply(this,arguments)}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){u.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}getClass(){return Yn}get interfaces_(){return[]}}Yn.constructor_=function(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}};class Un extends Yn{constructor(){super(),Un.constructor_.apply(this,arguments)}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof se&&arguments[0]instanceof Fn))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,Pn.ON),t.getLocation(1,Pn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,Pn.LEFT),t.getLocation(1,Pn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,Pn.RIGHT),t.getLocation(1,Pn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);return t[0]=this.pts[0],t[1]=this.pts[1],new Un(t,Fn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof Un))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,s=!0,i=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--i])||(s=!1),!n&&!s)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){Un.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Vn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new N;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,s){const i=new g(t.getIntersection(s));let r=e,o=t.getEdgeDistance(n,s);const l=r+1;if(l<this.pts.length){const t=this.pts[l];i.equals2D(t)&&(r=l,o=0)}this.eiList.add(i,r,o)}toString(){const t=new wt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}getClass(){return Un}get interfaces_(){return[]}}Un.constructor_=function(){if(this.pts=null,this._env=null,this.eiList=new qn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new zn,this._depthDelta=0,1===arguments.length){const t=arguments[0];Un.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}};class kn extends Yn{constructor(){super(),kn.constructor_.apply(this,arguments)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=ne.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const s=t.getLocation(e);n!==ne.BOUNDARY&&(n=s)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Fn(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof kn){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Fn){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===ne.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=ne.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case ne.BOUNDARY:n=ne.INTERIOR;break;case ne.INTERIOR:default:n=ne.BOUNDARY}this._label.setLocation(t,n)}getClass(){return kn}get interfaces_(){return[]}}kn.constructor_=function(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Fn(0,ne.NONE)};class Xn{constructor(){Xn.constructor_.apply(this,arguments)}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof g){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof kn){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new x;for(let n=this.iterator();n.hasNext();){const s=n.next();s.getLabel().getLocation(t)===ne.BOUNDARY&&e.add(s)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}getClass(){return Xn}get interfaces_(){return[]}}Xn.constructor_=function(){this.nodeMap=new rt,this.nodeFact=null;const t=arguments[0];this.nodeFact=t};class Hn{constructor(){Hn.constructor_.apply(this,arguments)}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),s=n.lastIndexOf("."),i=n.substring(s+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=In.quadrant(this._dx,this._dy),u.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}getClass(){return Hn}get interfaces_(){return[r]}}Hn.constructor_=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Hn.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hn.constructor_.call(this,t),this.init(e,n),this._label=s}};class Wn extends c{constructor(){if(1===arguments.length){const t=arguments[0];super(t),c.call(this,t)}else{if(2!==arguments.length)throw Error();{const t=arguments[0],e=arguments[1];super(Wn.msgWithCoord(t,e)),this.name="TopologyException",this.pt=new g(e)}}}getCoordinate(){return this.pt}get interfaces_(){return[]}getClass(){return Wn}static msgWithCoord(t,e){return null!==e?t+" [ "+e+" ]":t}}class jn extends Hn{constructor(){super(),jn.constructor_.apply(this,arguments)}static depthFactor(t,e){return t===ne.EXTERIOR&&e===ne.INTERIOR?1:t===ne.INTERIOR&&e===ne.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new Fn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new Wn("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,Pn.LEFT)===ne.INTERIOR&&this._label.getLocation(e,Pn.RIGHT)===ne.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[Pn.LEFT]+"/"+this._depth[Pn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,ne.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,ne.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let s=1;t===Pn.LEFT&&(s=-1);const i=Pn.opposite(t),r=e+n*s;this.setDepth(t,e),this.setDepth(i,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}getClass(){return jn}get interfaces_(){return[]}}jn.constructor_=function(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(Hn.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()};class Kn{constructor(){Kn.constructor_.apply(this,arguments)}createNode(t){return new kn(t,null)}getClass(){return Kn}get interfaces_(){return[]}}Kn.constructor_=function(){};class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof kn){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof g){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){O.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const s=n.getLabel();return null!==s&&s.getLocation(t)===ne.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,s){return!!t.equals(n)&&(v.index(t,e,s)===v.COLLINEAR&&In.quadrant(t,e)===In.quadrant(n,s))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){O.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return s;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return s}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new jn(t,!0),s=new jn(t,!1);n.setSym(s),s.setSym(n),this.add(n),this.add(s)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return s}return null}getClass(){return Zn}get interfaces_(){return[]}}Zn.constructor_=function(){if(this._edges=new x,this._nodes=null,this._edgeEndList=new x,0===arguments.length)this._nodes=new Xn(new Kn);else if(1===arguments.length){const t=arguments[0];this._nodes=new Xn(t)}};class Qn extends Zn{constructor(){super(),Qn.constructor_.apply(this,arguments)}static determineBoundary(t,e){return t.isInBoundary(e)?ne.BOUNDARY:ne.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let s=1,i=ne.NONE;i=n.getLocation(t,Pn.ON),i===ne.BOUNDARY&&s++;const r=Qn.determineBoundary(this._boundaryNodeRule,s);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Mn(t,!0,!1);s.setIsDoneIfProperInt(n);const i=this.createEdgeSetIntersector(),r=this._parentGeom instanceof Dt||this._parentGeom instanceof bt||this._parentGeom instanceof At,o=e||!r;return i.computeIntersections(this._edges,s,o),this.addSelfIntersectionNodes(this._argIndex),s}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const s=new Mn(e,n,!0);return s.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,s),s}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof Pt){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,ne.INTERIOR)}else if(arguments[0]instanceof g){const t=arguments[0];this.insertPoint(this._argIndex,t,ne.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),ne.EXTERIOR,ne.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,ne.INTERIOR,ne.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],ne.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],ne.BOUNDARY)}addLineString(t){const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new Un(e,new Fn(this._argIndex,ne.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),u.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let s=t.iterator();s.hasNext();){const t=s.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===ne.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const s=X.removeRepeatedPoints(t.getCoordinates());if(s.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=s[0],null;let i=e,r=n;v.isCCW(s)&&(i=n,r=e);const o=new Un(s,new Fn(this._argIndex,ne.BOUNDARY,i,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,s[0],ne.BOUNDARY)}insertPoint(t,e,n){const s=this._nodes.addNode(e),i=s.getLabel();null===i?s._label=new Fn(t,n):i.setLocation(t,n)}createEdgeSetIntersector(){return new Dn}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,s)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof q))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof At&&(this._useBoundaryDeterminationRule=!1),t instanceof bt)this.addPolygon(t);else if(t instanceof Tt)this.addLineString(t);else if(t instanceof Pt)this.addPoint(t);else if(t instanceof Mt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else if(t instanceof At)this.addCollection(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return _(this._parentGeom,Ot)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new ke(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof Tt){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}getClass(){return Qn}get interfaces_(){return[]}}Qn.constructor_=function(){if(this._parentGeom=null,this._lineEdgeMap=new Ut,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new _n,2===arguments.length){const t=arguments[0],e=arguments[1];Qn.constructor_.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}};var Jn=Object.freeze({__proto__:null,GeometryGraph:Qn});class $n{constructor(){$n.constructor_.apply(this,arguments)}visit(t){}getClass(){return $n}get interfaces_(){return[]}}$n.constructor_=function(){};class ts{constructor(){ts.constructor_.apply(this,arguments)}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}getClass(){return ts}get interfaces_(){return[]}}ts.constructor_=function(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new g(t),this._left=null,this._right=null,this._count=1,this._data=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new g(t,e),this._left=null,this._right=null,this._count=1,this._data=n}};class es{constructor(){es.constructor_.apply(this,arguments)}static toCoordinates(){if(1===arguments.length){const t=arguments[0];return es.toCoordinates(t,!1)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new I;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e?t.getCount():1;for(let e=0;e<i;e++)n.add(t.getCoordinate(),!0)}return n.toCoordinateArray()}}insert(){if(1===arguments.length){const t=arguments[0];return this.insert(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(null===this._root)return this._root=new ts(t,e),this._root;if(this._tolerance>0){const e=this.findBestMatchNode(t);if(null!==e)return e.increment(),e}return this.insertExact(t,e)}}query(){if(1===arguments.length){const t=arguments[0],e=new x;return this.query(t,e),e}if(2===arguments.length)if(arguments[0]instanceof N&&_(arguments[1],m)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[$n]}visit(t){e.add(t)}})}else if(arguments[0]instanceof N&&_(arguments[1],$n)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,e)}}queryNode(t,e,n,s){if(null===t)return null;let i=null,r=null,o=null;n?(i=e.getMinX(),r=e.getMaxX(),o=t.getX()):(i=e.getMinY(),r=e.getMaxY(),o=t.getY());const l=o<=r;i<o&&this.queryNode(t.getLeft(),e,!n,s),e.contains(t.getCoordinate())&&s.visit(t),l&&this.queryNode(t.getRight(),e,!n,s)}findBestMatchNode(t){const e=new ns(t,this._tolerance);return this.query(e.queryEnvelope(),e),e.getNode()}isEmpty(){return null===this._root}insertExact(t,e){let n=this._root,s=this._root,i=!0,r=!0;for(;null!==n;){if(null!==n){if(t.distance(n.getCoordinate())<=this._tolerance)return n.increment(),n}r=i?t.x<n.getX():t.y<n.getY(),s=n,n=r?n.getLeft():n.getRight(),i=!i}this._numberOfNodes=this._numberOfNodes+1;const o=new ts(t,e);return r?s.setLeft(o):s.setRight(o),o}getClass(){return es}get interfaces_(){return[]}}class ns{constructor(){ns.constructor_.apply(this,arguments)}visit(t){const e=this._p.distance(t.getCoordinate());if(!(e<=this._tolerance))return null;let n=!1;(null===this._matchNode||e<this._matchDist||null!==this._matchNode&&e===this._matchDist&&t.getCoordinate().compareTo(this._matchNode.getCoordinate())<1)&&(n=!0),n&&(this._matchNode=t,this._matchDist=e)}queryEnvelope(){const t=new N(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}getClass(){return ns}get interfaces_(){return[$n]}}ns.constructor_=function(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;const t=arguments[0],e=arguments[1];this._p=t,this._tolerance=e},es.BestMatchVisitor=ns,es.constructor_=function(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0===arguments.length)es.constructor_.call(this,0);else if(1===arguments.length){const t=arguments[0];this._tolerance=t}};var ss=Object.freeze({__proto__:null,KdTree:es});class is{constructor(){is.constructor_.apply(this,arguments)}static getSubnodeIndex(t,e,n){let s=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(s=3),t.getMaxY()<=n&&(s=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(s=2),t.getMaxY()<=n&&(s=0)),s}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let e=0;e<4;e++)null!==this._subnode[e]&&this._subnode[e].addAllItems(t);return t}getNodeCount(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+1}size(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+this._items.size()}addAllItemsFromOverlapping(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this._items);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].addAllItemsFromOverlapping(t,e)}visitItems(t,e){for(let t=this._items.iterator();t.hasNext();)e.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,e){if(!this.isSearchMatch(t))return!1;let n=!1;for(let s=0;s<4;s++)if(null!==this._subnode[s]&&(n=this._subnode[s].remove(t,e),n)){this._subnode[s].isPrunable()&&(this._subnode[s]=null);break}return n||(n=this._items.remove(e),n)}visit(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].visit(t,e)}getItems(){return this._items}depth(){let t=0;for(let e=0;e<4;e++)if(null!==this._subnode[e]){const n=this._subnode[e].depth();n>t&&(t=n)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let e=0;e<4;e++)if(null!==this._subnode[e]&&!this._subnode[e].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}getClass(){return is}get interfaces_(){return[a]}}function rs(){}is.constructor_=function(){this._items=new x,this._subnode=new Array(4).fill(null)},rs.exponent=function(t){return function(t,e){let n,s,i,r;const o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},l={32:8,64:11}[t];r||(n=e<0||1/e<0,isFinite(e)||(r=o[t],n&&(r.d+=1<<t/4-1),s=Math.pow(2,l)-1,i=0));if(!r){for(s={32:127,64:1023}[t],i=Math.abs(e);i>=2;)s++,i/=2;for(;i<1&&s>0;)s--,i*=2;s<=0&&(i/=2),32===t&&s>254&&(r={d:n?255:127,c:128,b:0,a:0},s=Math.pow(2,l)-1,i=0)}return s}(64,t)-1023},rs.powerOf2=function(t){return Math.pow(2,t)};class os{constructor(){os.constructor_.apply(this,arguments)}static computeQuadLevel(t){const e=t.getWidth(),n=t.getHeight(),s=e>n?e:n;return rs.exponent(s)+1}getLevel(){return this._level}computeKey(){if(1===arguments.length){const t=arguments[0];for(this._level=os.computeQuadLevel(t),this._env=new N,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=rs.powerOf2(t);this._pt.x=Math.floor(e.getMinX()/n)*n,this._pt.y=Math.floor(e.getMinY()/n)*n,this._env.init(this._pt.x,this._pt.x+n,this._pt.y,this._pt.y+n)}}getEnvelope(){return this._env}getCentre(){return new g((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}getClass(){return os}get interfaces_(){return[]}}os.constructor_=function(){this._pt=new g,this._level=0,this._env=null;const t=arguments[0];this.computeKey(t)};class ls extends is{constructor(){super(),ls.constructor_.apply(this,arguments)}static createNode(t){const e=new os(t);return new ls(e.getEnvelope(),e.getLevel())}static createExpanded(t,e){const n=new N(e);null!==t&&n.expandToInclude(t._env);const s=ls.createNode(n);return null!==t&&s.insertNode(t),s}find(t){const e=is.getSubnodeIndex(t,this._centrex,this._centrey);if(-1===e)return this;if(null!==this._subnode[e]){return this._subnode[e].find(t)}return this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){const e=is.getSubnodeIndex(t,this._centrex,this._centrey);if(-1!==e){return this.getSubnode(e).getNode(t)}return this}createSubnode(t){let e=0,n=0,s=0,i=0;switch(t){case 0:e=this._env.getMinX(),n=this._centrex,s=this._env.getMinY(),i=this._centrey;break;case 1:e=this._centrex,n=this._env.getMaxX(),s=this._env.getMinY(),i=this._centrey;break;case 2:e=this._env.getMinX(),n=this._centrex,s=this._centrey,i=this._env.getMaxY();break;case 3:e=this._centrex,n=this._env.getMaxX(),s=this._centrey,i=this._env.getMaxY()}const r=new N(e,n,s,i);return new ls(r,this._level-1)}insertNode(t){u.isTrue(null===this._env||this._env.contains(t._env));const e=is.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[e]=t;else{const n=this.createSubnode(e);n.insertNode(t),this._subnode[e]=n}}getClass(){return ls}get interfaces_(){return[]}}ls.constructor_=function(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;const t=arguments[0],e=arguments[1];this._env=t,this._level=e,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2};class as{constructor(){as.constructor_.apply(this,arguments)}static isZeroWidth(t,e){const n=e-t;if(0===n)return!0;const s=n/Math.max(Math.abs(t),Math.abs(e));return rs.exponent(s)<=as.MIN_BINARY_EXPONENT}getClass(){return as}get interfaces_(){return[]}}as.constructor_=function(){},as.MIN_BINARY_EXPONENT=-50;class cs extends is{constructor(){super(),cs.constructor_.apply(this,arguments)}insert(t,e){const n=is.getSubnodeIndex(t,cs.origin.x,cs.origin.y);if(-1===n)return this.add(e),null;const s=this._subnode[n];if(null===s||!s.getEnvelope().contains(t)){const e=ls.createExpanded(s,t);this._subnode[n]=e}this.insertContained(this._subnode[n],t,e)}isSearchMatch(t){return!0}insertContained(t,e,n){u.isTrue(t.getEnvelope().contains(e));const s=as.isZeroWidth(e.getMinX(),e.getMaxX()),i=as.isZeroWidth(e.getMinY(),e.getMaxY());let r=null;r=s||i?t.find(e):t.getNode(e),r.add(n)}getClass(){return cs}get interfaces_(){return[]}}cs.constructor_=function(){},cs.origin=new g(0,0);class hs{constructor(){hs.constructor_.apply(this,arguments)}insert(t,e){}remove(t,e){}query(){}getClass(){return hs}get interfaces_(){return[]}}hs.constructor_=function(){};class us{constructor(){us.constructor_.apply(this,arguments)}static ensureExtent(t,e){let n=t.getMinX(),s=t.getMaxX(),i=t.getMinY(),r=t.getMaxY();return n!==s&&i!==r?t:(n===s&&(n-=e/2,s=n+e/2),i===r&&(i-=e/2,r=i+e/2),new N(n,s,i,r))}size(){return null!==this._root?this._root.size():0}insert(t,e){this.collectStats(t);const n=us.ensureExtent(t,this._minExtent);this._root.insert(n,e)}query(){if(1===arguments.length){const t=arguments[0],e=new Ye;return this.query(t,e),e.getItems()}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._root.visit(t,e)}}queryAll(){const t=new x;return this._root.addAllItems(t),t}remove(t,e){const n=us.ensureExtent(t,this._minExtent);return this._root.remove(n,e)}collectStats(t){const e=t.getWidth();e<this._minExtent&&e>0&&(this._minExtent=e);const n=t.getHeight();n<this._minExtent&&n>0&&(this._minExtent=n)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}getClass(){return us}get interfaces_(){return[hs,a]}}us.constructor_=function(){this._root=null,this._minExtent=1,this._root=new cs},us.serialVersionUID=-0x678b60c967a25400;var gs=Object.freeze({__proto__:null,Quadtree:us});class ds{constructor(){ds.constructor_.apply(this,arguments)}getBounds(){}getClass(){return ds}get interfaces_(){return[]}}ds.constructor_=function(){};class _s{constructor(){_s.constructor_.apply(this,arguments)}getItem(){return this._item}getBounds(){return this._bounds}getClass(){return _s}get interfaces_(){return[ds,a]}}_s.constructor_=function(){this._bounds=null,this._item=null;const t=arguments[0],e=arguments[1];this._bounds=t,this._item=e};class fs{constructor(){fs.constructor_.apply(this,arguments)}poll(){if(this.isEmpty())return null;const t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let e=null;const n=this._items.get(t);for(;2*t<=this._size&&(e=2*t,e!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}clear(){this._size=0,this._items.clear()}peek(){if(this.isEmpty())return null;return this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}getClass(){return fs}get interfaces_(){return[]}}fs.constructor_=function(){this._size=null,this._items=null,this._size=0,this._items=new x,this._items.add(null)};class ps{constructor(){ps.constructor_.apply(this,arguments)}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){u.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}getClass(){return ps}get interfaces_(){return[ds,a]}}ps.constructor_=function(){if(this._childBoundables=new x,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._level=t}},ps.serialVersionUID=0x5a1e55ec41369800;class ms{constructor(){ms.constructor_.apply(this,arguments)}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof ps}expandToQueue(t,e){const s=ms.isComposite(this._boundable1),i=ms.isComposite(this._boundable2);if(s&&i)return ms.area(this._boundable1)>ms.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,t,e),null):(this.expand(this._boundable2,this._boundable1,t,e),null);if(s)return this.expand(this._boundable1,this._boundable2,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,t,e),null;throw new n("neither boundable is composite")}isLeaves(){return!(ms.isComposite(this._boundable1)||ms.isComposite(this._boundable2))}compareTo(t){const e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}expand(t,e,n,s){for(let i=t.getChildBoundables().iterator();i.hasNext();){const t=i.next(),r=new ms(t,e,this._itemDistance);r.getDistance()<s&&n.add(r)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}getClass(){return ms}get interfaces_(){return[r]}}ms.constructor_=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()};class ys{constructor(){ys.constructor_.apply(this,arguments)}static compareDoubles(t,e){return t>e?1:t<e?-1:0}queryInternal(){if(_(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof ps){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getChildBoundables();for(let e=0;e<s.size();e++){const i=s.get(e);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof ps?this.queryInternal(t,i,n):i instanceof _s?n.visitItem(i.getItem()):u.shouldNeverReachHere())}}else if(_(arguments[2],m)&&arguments[0]instanceof Object&&arguments[1]instanceof ps){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getChildBoundables();for(let e=0;e<s.size();e++){const i=s.get(e);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof ps?this.queryInternal(t,i,n):i instanceof _s?n.add(i.getItem()):u.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();n instanceof ps?t+=this.size(n):n instanceof _s&&(t+=1)}return t}}removeItem(t,e){let n=null;for(let s=t.getChildBoundables().iterator();s.hasNext();){const t=s.next();t instanceof _s&&t.getItem()===e&&(n=t)}return null!==n&&(t.getChildBoundables().remove(n),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this._root);return null===t?new x:t}if(1===arguments.length){const t=arguments[0],e=new x;for(let n=t.getChildBoundables().iterator();n.hasNext();){const t=n.next();if(t instanceof ps){const n=this.itemsTree(t);null!==n&&e.add(n)}else t instanceof _s?e.add(t.getItem()):u.shouldNeverReachHere()}return e.size()<=0?null:e}}insert(t,e){u.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new _s(t,e))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],e=new x;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(u.isTrue(t>-2),e.getLevel()===t)return n.add(e),null;for(let s=e.getChildBoundables().iterator();s.hasNext();){const e=s.next();e instanceof ps?this.boundablesAtLevel(t,e,n):(u.isTrue(e instanceof _s),-1===t&&n.add(e))}return null}}query(){if(1===arguments.length){const t=arguments[0];this.build();const e=new x;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=this.removeItem(e,n);if(s)return!0;let i=null;for(let r=e.getChildBoundables().iterator();r.hasNext();){const e=r.next();if(this.getIntersectsOp().intersects(e.getBounds(),t)&&(e instanceof ps&&(s=this.remove(t,e,n),s))){i=e;break}}return null!==i&&i.getChildBoundables().isEmpty()&&e.getChildBoundables().remove(i),s}}createHigherLevels(t,e){u.isTrue(!t.isEmpty());const n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();if(n instanceof ps){const e=this.depth(n);e>t&&(t=e)}}return t+1}}createParentBoundables(t,e){u.isTrue(!t.isEmpty());const n=new x;n.add(this.createNode(e));const s=new x(t);Ee.sort(s,this.getComparator());for(let t=s.iterator();t.hasNext();){const s=t.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}getClass(){return ys}get interfaces_(){return[a]}}ys.IntersectsOp=function(){},ys.constructor_=function(){if(this._root=null,this._built=!1,this._itemBoundables=new x,this._nodeCapacity=null,0===arguments.length)ys.constructor_.call(this,ys.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];u.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}},ys.serialVersionUID=-0x35ef64c82d4c5400,ys.DEFAULT_NODE_CAPACITY=10;class xs{constructor(){xs.constructor_.apply(this,arguments)}distance(t,e){}getClass(){return xs}get interfaces_(){return[]}}xs.constructor_=function(){};class Es extends ys{constructor(){super(),Es.constructor_.apply(this,arguments)}static centreX(t){return Es.avg(t.getMinX(),t.getMaxX())}static avg(t,e){return(t+e)/2}static getItems(t){const e=new Array(t.size()).fill(null);let n=0;for(;!t.isEmpty();){const s=t.poll();e[n]=s.getBoundable(0).getItem(),n++}return e}static centreY(t){return Es.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,e){u.isTrue(t.length>0);const n=new x;for(let s=0;s<t.length;s++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[s],e));return n}createNode(t){return new Is(t)}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N))return super.insert.apply(this,arguments);{const t=arguments[0],e=arguments[1];if(t.isNull())return null;super.insert.call(this,t,e)}}getIntersectsOp(){return Es.intersectsOp}verticalSlices(t,e){const n=Math.trunc(Math.ceil(t.size()/e)),s=new Array(e).fill(null),i=t.iterator();for(let t=0;t<e;t++){s[t]=new x;let e=0;for(;i.hasNext()&&e<n;){const n=i.next();s[t].add(n),e++}}return s}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];super.query.call(this,t,e)}}getComparator(){return Es.yComparator}createParentBoundablesFromVerticalSlice(t,e){return super.createParentBoundables.call(this,t,e)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N){const t=arguments[0],e=arguments[1];return super.remove.call(this,t,e)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,e){u.isTrue(!t.isEmpty());const n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),s=new x(t);Ee.sort(s,Es.xComparator);const i=this.verticalSlices(s,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}nearestNeighbour(){if(1===arguments.length){if(_(arguments[0],xs)){const t=arguments[0],e=new ms(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof ms){const t=arguments[0];return this.nearestNeighbour(t,i.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof Es&&_(arguments[1],xs)){const t=arguments[0],e=arguments[1],n=new ms(this.getRoot(),t.getRoot(),e);return this.nearestNeighbour(n)}if(arguments[0]instanceof ms&&"number"==typeof arguments[1]){const t=arguments[0];let e=arguments[1],n=null;const s=new fs;for(s.add(t);!s.isEmpty()&&e>0;){const t=s.poll(),i=t.getDistance();if(i>=e)break;t.isLeaves()?(e=i,n=t):t.expandToQueue(s,e)}return[n.getBoundable(0).getItem(),n.getBoundable(1).getItem()]}if(arguments[0]instanceof ms&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];return this.nearestNeighbour(t,i.POSITIVE_INFINITY,e)}}else if(3===arguments.length){if(_(arguments[2],xs)&&arguments[0]instanceof N&&arguments[1]instanceof Object){const t=arguments[0],e=arguments[1],n=arguments[2],s=new _s(t,e),i=new ms(this.getRoot(),s,n);return this.nearestNeighbour(i)[0]}if(Number.isInteger(arguments[2])&&arguments[0]instanceof ms&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];let s=e;const i=new fs;i.add(t);const r=new fs;for(;!i.isEmpty()&&s>=0;){const t=i.poll(),e=t.getDistance();if(e>=s)break;if(t.isLeaves())if(r.size()<n)r.add(t);else{r.peek().getDistance()>e&&(r.poll(),r.add(t)),s=r.peek().getDistance()}else t.expandToQueue(i,s)}return Es.getItems(r)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new _s(t,e),r=new ms(this.getRoot(),i,n);return this.nearestNeighbour(r,s)}}getClass(){return Es}get interfaces_(){return[hs,a]}}class Is extends ps{constructor(){super(),Is.constructor_.apply(this,arguments)}computeBounds(){let t=null;for(let e=this.getChildBoundables().iterator();e.hasNext();){const n=e.next();null===t?t=new N(n.getBounds()):t.expandToInclude(n.getBounds())}return t}getClass(){return Is}get interfaces_(){return[]}}Is.constructor_=function(){const t=arguments[0];ps.constructor_.call(this,t)},Es.STRtreeNode=Is,Es.constructor_=function(){if(0===arguments.length)Es.constructor_.call(this,Es.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];ys.constructor_.call(this,t)}},Es.serialVersionUID=0x39920f7d5f261e0,Es.xComparator=new class{get interfaces_(){return[l]}compare(t,e){return ys.compareDoubles(Es.centreX(t.getBounds()),Es.centreX(e.getBounds()))}},Es.yComparator=new class{get interfaces_(){return[l]}compare(t,e){return ys.compareDoubles(Es.centreY(t.getBounds()),Es.centreY(e.getBounds()))}},Es.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,e){return t.intersects(e)}},Es.DEFAULT_NODE_CAPACITY=10;var Ns=Object.freeze({__proto__:null,STRtree:Es}),Cs=Object.freeze({__proto__:null,kdtree:ss,quadtree:gs,strtree:Ns});const Ss=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class ws{constructor(t){this.geometryFactory=t||new Ht}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!Ls[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==Ss.indexOf(n)?Ls[n].call(this,e.coordinates):"GeometryCollection"===n?Ls[n].call(this,e.geometries):Ls[n].call(this,e)}write(t){const e=t.getGeometryType();if(!Ts[e])throw new Error("Geometry is not supported");return Ts[e].call(this,t)}}const Ls={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!Ls[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Ls.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(new g(s[0],s[1]))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){const e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Ls.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=Ls.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Ls.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=Ls.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),s=[];for(let e=1;e<t.length;++e){const n=t[e],i=Ls.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(i);s.push(r)}return this.geometryFactory.createPolygon(n,s)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(Ls.Polygon.call(this,s))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(this.read(s))}return this.geometryFactory.createGeometryCollection(e)}},Ts={coordinate:function(t){return[t.x,t.y]},Point:function(t){return{type:"Point",coordinates:Ts.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.Point.call(this,s);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const s=n[t];e.push(Ts.coordinate.call(this,s))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.LineString.call(this,s);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=Ts.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const s=t._holes[n],i=Ts.LineString.call(this,s);e.push(i.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.Polygon.call(this,s);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=s.getGeometryType();e.push(Ts[i].call(this,s))}return{type:"GeometryCollection",geometries:e}}};function Rs(t){return[t.x,t.y]}var Ps=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new ws(t||new Ht)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new ws(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,e){this.geometryFactory=t||new Ht,this.ol=e||"undefined"!=typeof ol&&ol}inject(t,e,n,s,i,r,o,l){this.ol={geom:{Point:t,LineString:e,LinearRing:n,Polygon:s,MultiPoint:i,MultiLineString:r,MultiPolygon:o,GeometryCollection:l}}}read(t){const e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){const e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map((function(t){return new g(t[0],t[1])})))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t){return new g(t[0],t[1])})))}convertFromPolygon(t){const e=t.getLinearRings();let n=null;const s=[];for(let t=0;t<e.length;t++){const i=this.convertFromLinearRing(e[t]);0===t?n=i:s.push(i)}return this.geometryFactory.createPolygon(n,s)}convertFromMultiPoint(t){const e=t.getPoints().map((function(t){return this.convertFromPoint(t)}),this);return this.geometryFactory.createMultiPoint(e)}convertFromMultiLineString(t){const e=t.getLineStrings().map((function(t){return this.convertFromLineString(t)}),this);return this.geometryFactory.createMultiLineString(e)}convertFromMultiPolygon(t){const e=t.getPolygons().map((function(t){return this.convertFromPolygon(t)}),this);return this.geometryFactory.createMultiPolygon(e)}convertFromCollection(t){const e=t.getGeometries().map((function(t){return this.read(t)}),this);return this.geometryFactory.createGeometryCollection(e)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){const e=t._points._coordinates.map(Rs);return new this.ol.geom.LineString(e)}convertToLinearRing(t){const e=t._points._coordinates.map(Rs);return new this.ol.geom.LinearRing(e)}convertToPolygon(t){const e=[t._shell._points._coordinates.map(Rs)];for(let n=0;n<t._holes.length;n++)e.push(t._holes[n]._points._coordinates.map(Rs));return new this.ol.geom.Polygon(e)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Rs))}convertToMultiLineString(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)}convertToMultiPolygon(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)}convertToCollection(t){const e=[];for(let n=0;n<t._geometries.length;n++){const s=t._geometries[n];e.push(this.write(s))}return new this.ol.geom.GeometryCollection(e)}},WKTReader:class{constructor(t){this.parser=new Kt(t||new Ht)}read(t){return this.parser.read(t)}},WKTWriter:Jt});class vs{constructor(){vs.constructor_.apply(this,arguments)}static relativeSign(t,e){return t<e?-1:t>e?1:0}static compare(t,e,n){if(e.equals2D(n))return 0;const s=vs.relativeSign(e.x,n.x),i=vs.relativeSign(e.y,n.y);switch(t){case 0:return vs.compareValue(s,i);case 1:return vs.compareValue(i,s);case 2:return vs.compareValue(i,-s);case 3:return vs.compareValue(-s,i);case 4:return vs.compareValue(-s,-i);case 5:return vs.compareValue(-i,-s);case 6:return vs.compareValue(-i,s);case 7:return vs.compareValue(s,-i)}return u.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}getClass(){return vs}get interfaces_(){return[]}}vs.constructor_=function(){};class Os{constructor(){Os.constructor_.apply(this,arguments)}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){const e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:vs.compare(this._segmentOctant,this.coord,e.coord)}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}isInterior(){return this._isInterior}getClass(){return Os}get interfaces_(){return[r]}}Os.constructor_=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._segString=t,this.coord=new g(e),this.segmentIndex=n,this._segmentOctant=s,this._isInterior=!e.equals2D(t.getCoordinate(n))};class bs{constructor(){bs.constructor_.apply(this,arguments)}getSplitCoordinates(){const t=new I;this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next();this.addEdgeCoordinates(n,s,t),n=s}return t.toCoordinateArray()}addCollapsedNodes(){const t=new x;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let e=t.iterator();e.hasNext();){const t=e.next().intValue();this.add(this._edge.getCoordinate(t),t)}}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}findCollapsesFromExistingVertices(t){for(let e=0;e<this._edge.size()-2;e++){const n=this._edge.getCoordinate(e),s=(this._edge.getCoordinate(e+1),this._edge.getCoordinate(e+2));n.equals2D(s)&&t.add(new L(e+1))}}addEdgeCoordinates(t,e,n){e.segmentIndex,t.segmentIndex;const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);n.add(new g(t.coord),!1);for(let s=t.segmentIndex+1;s<=e.segmentIndex;s++)n.add(this._edge.getCoordinate(s));i&&n.add(new g(e.coord))}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}findCollapseIndex(t,e,n){if(!t.coord.equals2D(e.coord))return!1;let s=e.segmentIndex-t.segmentIndex;return e.isInterior()||s--,1===s&&(n[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){const e=new Array(1).fill(null),n=this.iterator();let s=n.next();for(;n.hasNext();){const i=n.next();this.findCollapseIndex(s,i,e)&&t.add(new L(e[0])),s=i}}getEdge(){return this._edge}addEndpoints(){const t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new g(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this._edge.getCoordinate(n);return i&&(r[o]=new g(e.coord)),new Fs(r,this._edge.getData())}add(t,e){const n=new Os(this._edge,t,e,this._edge.getSegmentOctant(e)),s=this._nodeMap.get(n);return null!==s?(u.isTrue(s.coord.equals2D(t),"Found equal nodes with different coordinates"),s):(this._nodeMap.put(n,n),n)}checkSplitEdgesCorrectness(t){const e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new c("bad split edge start point at "+n);const s=t.get(t.size()-1).getCoordinates(),i=s[s.length-1];if(!i.equals2D(e[e.length-1]))throw new c("bad split edge end point at "+i)}getClass(){return bs}get interfaces_(){return[]}}bs.constructor_=function(){this._nodeMap=new rt,this._edge=null;const t=arguments[0];this._edge=t};class Ms{constructor(){Ms.constructor_.apply(this,arguments)}static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Cannot compute the octant for point ( "+t+", "+e+" )");const s=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?s>=i?0:1:s>=i?7:6:e>=0?s>=i?3:2:s>=i?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],s=e.x-t.x,i=e.y-t.y;if(0===s&&0===i)throw new n("Cannot compute the octant for two identical points "+t);return Ms.octant(s,i)}}getClass(){return Ms}get interfaces_(){return[]}}Ms.constructor_=function(){};class Ds{constructor(){Ds.constructor_.apply(this,arguments)}getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}getClass(){return Ds}get interfaces_(){return[]}}Ds.constructor_=function(){};class As{constructor(){As.constructor_.apply(this,arguments)}addIntersection(t,e){}getClass(){return As}get interfaces_(){return[Ds]}}As.constructor_=function(){};class Fs{constructor(){Fs.constructor_.apply(this,arguments)}static getNodedSubstrings(){if(1===arguments.length){const t=arguments[0],e=new x;return Fs.getNodedSubstrings(t,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){n.next().getNodeList().addSplitEdges(e)}}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,e){return t.equals2D(e)?0:Ms.octant(t,e)}getData(){return this._data}addIntersection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[3],s=new g(t.getIntersection(n));this.addIntersection(s,e)}}toString(){return Jt.toLineString(new zt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,e){let n=e;const s=n+1;if(s<this._pts.length){const e=this._pts[s];t.equals2D(e)&&(n=s)}return this._nodeList.add(t,n)}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}getClass(){return Fs}get interfaces_(){return[As]}}Fs.constructor_=function(){this._nodeList=new bs(this),this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e};class Gs{constructor(){Gs.constructor_.apply(this,arguments)}overlap(){if(2===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t.getLineSegment(e,this._overlapSeg1),n.getLineSegment(s,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}getClass(){return Gs}get interfaces_(){return[]}}Gs.constructor_=function(){this._overlapSeg1=new ee,this._overlapSeg2=new ee};class qs{constructor(){qs.constructor_.apply(this,arguments)}getLineSegment(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}computeSelect(t,e,n,s){const i=this._pts[e],r=this._pts[n];if(n-e==1)return s.select(this,e),null;if(!t.intersects(i,r))return null;const o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,s),o<n&&this.computeSelect(t,o,n,s)}getCoordinates(){const t=new Array(this._end-this._start+1).fill(null);let e=0;for(let n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}computeOverlaps(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.overlap(this,t,n,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeOverlaps(t,o,n,s,l,r),l<i&&this.computeOverlaps(t,o,n,l,i,r)),o<e&&(s<l&&this.computeOverlaps(o,e,n,s,l,r),l<i&&this.computeOverlaps(o,e,n,l,i,r))}}setId(t){this._id=t}select(t,e){this.computeSelect(t,this._start,this._end,e)}getEnvelope(){if(null===this._env){const t=this._pts[this._start],e=this._pts[this._end];this._env=new N(t,e)}return this._env}overlaps(t,e,n,s,i){return N.intersects(this._pts[t],this._pts[e],n._pts[s],n._pts[i])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}getClass(){return qs}get interfaces_(){return[]}}qs.constructor_=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=s};class Bs{constructor(){Bs.constructor_.apply(this,arguments)}static getChainStartIndices(t){let e=0;const n=new x;n.add(new L(e));do{const s=Bs.findChainEnd(t,e);n.add(new L(s)),e=s}while(e<t.length-1);return Bs.toIntArray(n)}static findChainEnd(t,e){let n=e;for(;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;const s=In.quadrant(t[n],t[n+1]);let i=e+1;for(;i<t.length;){if(!t[i-1].equals2D(t[i])){if(In.quadrant(t[i-1],t[i])!==s)break}i++}return i-1}static getChains(){if(1===arguments.length){const t=arguments[0];return Bs.getChains(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new x,s=Bs.getChainStartIndices(t);for(let i=0;i<s.length-1;i++){const r=new qs(t,s[i],s[i+1],e);n.add(r)}return n}}static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getClass(){return Bs}get interfaces_(){return[]}}Bs.constructor_=function(){};class Vs{constructor(){Vs.constructor_.apply(this,arguments)}computeNodes(t){}getNodedSubstrings(){}getClass(){return Vs}get interfaces_(){return[]}}Vs.constructor_=function(){};class zs{constructor(){zs.constructor_.apply(this,arguments)}setSegmentIntersector(t){this._segInt=t}getClass(){return zs}get interfaces_(){return[Vs]}}zs.constructor_=function(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setSegmentIntersector(t)}};class Ys extends zs{constructor(){super(),Ys.constructor_.apply(this,arguments)}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Fs.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let e=Bs.getChains(t.getCoordinates(),t).iterator();e.hasNext();){const t=e.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}intersectChains(){const t=new Us(this._segInt);for(let e=this._monoChains.iterator();e.hasNext();){const n=e.next();for(let e=this._index.query(n.getEnvelope()).iterator();e.hasNext();){const s=e.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this._nOverlaps++),this._segInt.isDone())return null}}}getClass(){return Ys}get interfaces_(){return[]}}class Us extends Gs{constructor(){super(),Us.constructor_.apply(this,arguments)}overlap(){if(4!==arguments.length)return super.overlap.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.getContext(),r=n.getContext();this._si.processIntersections(i,e,r,s)}}getClass(){return Us}get interfaces_(){return[]}}Us.constructor_=function(){this._si=null;const t=arguments[0];this._si=t},Ys.SegmentOverlapAction=Us,Ys.constructor_=function(){if(this._monoChains=new x,this._index=new Es,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];zs.constructor_.call(this,t)}};class ks{constructor(){ks.constructor_.apply(this,arguments)}rescale(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.rescale(e.getCoordinates())}}else if(arguments[0]instanceof Array){const t=arguments[0];let e=null,n=null;2===t.length&&(e=new g(t[0]),n=new g(t[1]));for(let e=0;e<t.length;e++)t[e].x=t[e].x/this._scaleFactor+this._offsetX,t[e].y=t[e].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&O.out.println(t)}}scale(){if(_(arguments[0],f)){const t=arguments[0],e=new x(t.size());for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Fs(this.scale(t.getCoordinates()),t.getData()))}return e}if(arguments[0]instanceof Array){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new g(Math.round((t[n].x-this._offsetX)*this._scaleFactor),Math.round((t[n].y-this._offsetY)*this._scaleFactor),t[n].z);return X.removeRepeatedPoints(e)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){const t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}getClass(){return ks}get interfaces_(){return[Vs]}}ks.constructor_=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){const t=arguments[0],e=arguments[1];ks.constructor_.call(this,t,e,0,0)}else if(4===arguments.length){const t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._isScaled=!this.isIntegerPrecision()}};var Xs=Object.freeze({__proto__:null,MCIndexNoder:Ys,ScaledNoder:ks,SegmentString:Ds});class Hs{constructor(){Hs.constructor_.apply(this,arguments)}static isSimple(){if(1===arguments.length){const t=arguments[0];return new Hs(t).isSimple()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Hs(t,e).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;const e=new at;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getCoordinate();if(e.contains(s))return this._nonSimpleLocation=s,!1;e.add(s)}return!0}isSimplePolygonal(t){for(let e=xe.getLines(t).iterator();e.hasNext();){const t=e.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){const e=new rt;for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=(t.getMaximumSegmentIndex(),t.isClosed()),i=t.getCoordinate(0);this.addEndpoint(e,i,s);const r=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(e,r,s)}for(let t=e.values().iterator();t.hasNext();){const e=t.next();if(e.isClosed&&2!==e.degree)return this._nonSimpleLocation=e.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;const e=new Qn(0,t),n=new te,s=e.computeSelfNodes(n,!0);return!s.hasIntersection()||(s.hasProperIntersection()?(this._nonSimpleLocation=s.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))}hasNonEndpointIntersection(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next(),n=t.getMaximumSegmentIndex();for(let e=t.getEdgeIntersectionList().iterator();e.hasNext();){const t=e.next();if(!t.isEndPoint(n))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,e,n){let s=t.get(e);null===s&&(s=new Ws(e),t.put(e,s)),s.addEndpoint(n)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof Tt||t instanceof ft?this.isSimpleLinearGeometry(t):t instanceof Mt?this.isSimpleMultiPoint(t):_(t,Ot)?this.isSimplePolygonal(t):!(t instanceof _t)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0}getClass(){return Hs}get interfaces_(){return[]}}class Ws{constructor(){Ws.constructor_.apply(this,arguments)}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}getClass(){return Ws}get interfaces_(){return[]}}Ws.constructor_=function(){this.pt=null,this.isClosed=null,this.degree=null;const t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0},Hs.EndpointInfo=Ws,Hs.constructor_=function(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1===arguments.length){const t=arguments[0];this._inputGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!e.isInBoundary(2)}};class js{constructor(){js.constructor_.apply(this,arguments)}static bufferDistanceError(t){const e=Math.PI/2/t;return 1-Math.cos(e/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=js.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=js.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==js.JOIN_ROUND&&(this._quadrantSegments=js.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}getClass(){return js}get interfaces_(){return[]}}js.constructor_=function(){if(this._quadrantSegments=js.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=js.CAP_ROUND,this._joinStyle=js.JOIN_ROUND,this._mitreLimit=js.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=js.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(e),this.setJoinStyle(n),this.setMitreLimit(s)}},js.CAP_ROUND=1,js.CAP_FLAT=2,js.CAP_SQUARE=3,js.JOIN_ROUND=1,js.JOIN_MITRE=2,js.JOIN_BEVEL=3,js.DEFAULT_QUADRANT_SEGMENTS=8,js.DEFAULT_MITRE_LIMIT=5,js.DEFAULT_SIMPLIFY_FACTOR=.01;class Ks{constructor(){Ks.constructor_.apply(this,arguments)}getCoordinate(){return this._minCoord}getRightmostSide(t,e){let n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}findRightmostEdgeAtVertex(){const t=this._minDe.getEdge().getCoordinates();u.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");const e=t[this._minIndex-1],n=t[this._minIndex+1],s=v.index(this._minCoord,n,e);let i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&s===v.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&s===v.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,e){const n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;let s=Pn.LEFT;return n[e].y<n[e+1].y&&(s=Pn.RIGHT),s}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){const e=t.getEdge().getCoordinates();for(let n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}findRightmostEdgeAtNode(){const t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let e=t.iterator();e.hasNext();){const t=e.next();t.isForward()&&this.checkForRightmostCoordinate(t)}u.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe,this.getRightmostSide(this._minDe,this._minIndex)===Pn.LEFT&&(this._orientedDe=this._minDe.getSym())}getClass(){return Ks}get interfaces_(){return[]}}function Zs(){this.array_=[]}Ks.constructor_=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null},Zs.prototype.addLast=function(t){this.array_.push(t)},Zs.prototype.removeFirst=function(){return this.array_.shift()},Zs.prototype.isEmpty=function(){return 0===this.array_.length};class Qs{constructor(){Qs.constructor_.apply(this,arguments)}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let e=null;for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();if(t.isVisited()||t.getSym().isVisited()){e=t;break}}if(null===e)throw new Wn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(let e=t.getEdges().iterator();e.hasNext();){const t=e.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();const e=this._finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(Pn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){const e=t.next();e.getDepth(Pn.RIGHT)>=1&&e.getDepth(Pn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}computeDepths(t){const e=new J,n=new Zs,s=t.getNode();for(n.addLast(s),e.add(s),t.setVisited(!0);!n.isEmpty();){const t=n.removeFirst();e.add(t),this.computeNodeDepth(t);for(let s=t.getEdges().iterator();s.hasNext();){const t=s.next().getSym();if(t.isVisited())continue;const i=t.getNode();e.contains(i)||(n.addLast(i),e.add(i))}}}compareTo(t){const e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){const t=new N;for(let e=this._dirEdgeList.iterator();e.hasNext();){const n=e.next().getEdge().getCoordinates();for(let e=0;e<n.length-1;e++)t.expandToInclude(n[e])}this._env=t}return this._env}addReachable(t){const e=new on;for(e.add(t);!e.empty();){const t=e.pop();this.add(t,e)}}copySymDepths(t){const e=t.getSym();e.setDepth(Pn.LEFT,t.getDepth(Pn.RIGHT)),e.setDepth(Pn.RIGHT,t.getDepth(Pn.LEFT))}add(t,e){t.setVisited(!0),this._nodes.add(t);for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();this._dirEdgeList.add(t);const s=t.getSym().getNode();s.isVisited()||e.push(s)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}getClass(){return Qs}get interfaces_(){return[r]}}Qs.constructor_=function(){this._finder=null,this._dirEdgeList=new x,this._nodes=new x,this._rightMostCoord=null,this._env=null,this._finder=new Ks};class Js{constructor(){Js.constructor_.apply(this,arguments)}computeRing(){if(null!==this._ring)return null;const t=new Array(this._pts.size()).fill(null);for(let e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=v.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let e=t,n=!0;do{if(null===e)throw new Wn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new Wn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);const t=e.getLabel();u.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{const e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,e,n){const s=t.getCoordinates();if(e){let t=1;n&&(t=0);for(let e=t;e<s.length;e++)this._pts.add(s[e])}else{let t=s.length-2;n&&(t=s.length-1);for(let e=t;e>=0;e--)this._pts.add(s[e])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}containsPoint(t){const e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!We.isInRing(t,e.getCoordinates()))return!1;for(let e=this._holes.iterator();e.hasNext();){if(e.next().containsPoint(t))return!1}return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(e,Pn.RIGHT);if(n===ne.NONE)return null;if(this._label.getLocation(e)===ne.NONE)return this._label.setLocation(e,n),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){const e=new Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)e[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}getClass(){return Js}get interfaces_(){return[]}}Js.constructor_=function(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new x,this._pts=new x,this._label=new Fn(ne.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new x,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}};class $s extends Js{constructor(){super(),$s.constructor_.apply(this,arguments)}setEdgeRing(t,e){t.setMinEdgeRing(e)}getNext(t){return t.getNextMin()}getClass(){return $s}get interfaces_(){return[]}}$s.constructor_=function(){const t=arguments[0],e=arguments[1];Js.constructor_.call(this,t,e)};class ti extends Js{constructor(){super(),ti.constructor_.apply(this,arguments)}buildMinimalRings(){const t=new x;let e=this._startDe;do{if(null===e.getMinEdgeRing()){const n=new $s(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}setEdgeRing(t,e){t.setEdgeRing(e)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}getNext(t){return t.getNext()}getClass(){return ti}get interfaces_(){return[]}}ti.constructor_=function(){const t=arguments[0],e=arguments[1];Js.constructor_.call(this,t,e)};class ei{constructor(){ei.constructor_.apply(this,arguments)}sortShellsAndHoles(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()?n.add(t):e.add(t)}}computePolygons(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next().toPolygon(this._geometryFactory);e.add(t)}return e}placeFreeHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(null===e.getShell()){const n=this.findEdgeRingContaining(e,t);if(null===n)throw new Wn("unable to assign hole to a shell",e.getCoordinate(0));e.setShell(n)}}}buildMinimalEdgeRings(t,e,n){const s=new x;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();const s=t.buildMinimalRings(),i=this.findShell(s);null!==i?(this.placePolygonHoles(i,s),e.add(i)):n.addAll(s)}else s.add(t)}return s}containsPoint(t){for(let e=this._shellList.iterator();e.hasNext();){if(e.next().containsPoint(t))return!0}return!1}buildMaximalEdgeRings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){const n=new ti(t,this._geometryFactory);e.add(n),n.setInResult()}}return e}placePolygonHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();e.isHole()&&e.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findEdgeRingContaining(t,e){const n=t.getLinearRing(),s=n.getEnvelopeInternal(),i=n.getCoordinateN(0);let r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),n=e.getLinearRing(),l=n.getEnvelopeInternal();null!==r&&(o=r.getLinearRing().getEnvelopeInternal());let a=!1;l.contains(s)&&We.isInRing(i,n.getCoordinates())&&(a=!0),a&&(null===r||o.contains(l))&&(r=e)}return r}findShell(t){let e=0,n=null;for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()||(n=t,e++)}return u.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}add(){if(1===arguments.length){const t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Zn.linkResultDirectedEdges(e);const n=this.buildMaximalEdgeRings(t),s=new x,i=this.buildMinimalEdgeRings(n,this._shellList,s);this.sortShellsAndHoles(i,this._shellList,s),this.placeFreeHoles(this._shellList,s)}}getClass(){return ei}get interfaces_(){return[]}}ei.constructor_=function(){this._geometryFactory=null,this._shellList=new x;const t=arguments[0];this._geometryFactory=t};class ni{constructor(){ni.constructor_.apply(this,arguments)}static simplify(t,e){return new ni(t).simplify(e)}isDeletable(t,e,n,s){const i=this._inputLine[t],r=this._inputLine[e],o=this._inputLine[n];return!!this.isConcave(i,r,o)&&(!!this.isShallow(i,r,o,s)&&this.isShallowSampled(i,r,t,n,s))}deleteShallowConcavities(){let t=1;this._inputLine.length;let e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),s=!1;for(;n<this._inputLine.length;){let i=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=ni.DELETE,i=!0,s=!0),t=i?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return s}isShallowConcavity(t,e,n,s){return v.index(t,e,n)===this._angleOrientation&&D.pointToSegment(e,t,n)<s}isShallowSampled(t,e,n,s,i){let r=Math.trunc((s-n)/ni.NUM_PTS_TO_CHECK);r<=0&&(r=1);for(let o=n;o<s;o+=r)if(!this.isShallow(t,e,this._inputLine[o],i))return!1;return!0}isConcave(t,e,n){return v.index(t,e,n)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=v.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);let e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}findNextNonDeletedIndex(t){let e=t+1;for(;e<this._inputLine.length&&this._isDeleted[e]===ni.DELETE;)e++;return e}isShallow(t,e,n,s){return D.pointToSegment(e,t,n)<s}collapseLine(){const t=new I;for(let e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==ni.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()}getClass(){return ni}get interfaces_(){return[]}}ni.constructor_=function(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=v.COUNTERCLOCKWISE;const t=arguments[0];this._inputLine=t},ni.INIT=0,ni.DELETE=1,ni.KEEP=1,ni.NUM_PTS_TO_CHECK=10;class si{constructor(){si.constructor_.apply(this,arguments)}getCoordinates(){return this._ptList.toArray(si.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){const e=new g(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}reverse(){}addPts(t,e){if(e)for(let e=0;e<t.length;e++)this.addPt(t[e]);else for(let e=t.length-1;e>=0;e--)this.addPt(t[e])}isRedundant(t){if(this._ptList.size()<1)return!1;const e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}toString(){return(new Ht).createLineString(this.getCoordinates()).toString()}closeRing(){if(this._ptList.size()<1)return null;const t=new g(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);let n=null;if(this._ptList.size()>=2&&this._ptList.get(this._ptList.size()-2),t.equals(e))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}getClass(){return si}get interfaces_(){return[]}}si.constructor_=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new x},si.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);class ii{constructor(){ii.constructor_.apply(this,arguments)}addNextSegment(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;const n=v.index(this._s0,this._s1,this._s2),s=n===v.CLOCKWISE&&this._side===Pn.LEFT||n===v.COUNTERCLOCKWISE&&this._side===Pn.RIGHT;0===n?this.addCollinear(e):s?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}addLineEndCap(t,e){const n=new ee(t,e),s=new ee;this.computeOffsetSegment(n,Pn.LEFT,this._distance,s);const i=new ee;this.computeOffsetSegment(n,Pn.RIGHT,this._distance,i);const r=e.x-t.x,o=e.y-t.y,l=Math.atan2(o,r);switch(this._bufParams.getEndCapStyle()){case js.CAP_ROUND:this._segList.addPt(s.p1),this.addDirectedFillet(e,l+Math.PI/2,l-Math.PI/2,v.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case js.CAP_FLAT:this._segList.addPt(s.p1),this._segList.addPt(i.p1);break;case js.CAP_SQUARE:const t=new g;t.x=Math.abs(this._distance)*Math.cos(l),t.y=Math.abs(this._distance)*Math.sin(l);const n=new g(s.p1.x+t.x,s.p1.y+t.y),r=new g(i.p1.x+t.x,i.p1.y+t.y);this._segList.addPt(n),this._segList.addPt(r)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,e,n,s){let i=!0,r=null;try{r=b.intersection(e.p0,e.p1,n.p0,n.p1),(s<=0?1:r.distance(t)/Math.abs(s))>this._bufParams.getMitreLimit()&&(i=!1)}catch(t){if(!(t instanceof S))throw t;r=new g(0,0),i=!1}i?this._segList.addPt(r):this.addLimitedMitreJoin(e,n,s,this._bufParams.getMitreLimit())}addOutsideTurn(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*ii.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===js.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===js.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new g(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new g(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,e){this._segList.addPts(t,e)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,e,n,s,i){const r=e.x-t.x,o=e.y-t.y;let l=Math.atan2(o,r);const a=n.x-t.x,c=n.y-t.y,h=Math.atan2(c,a);s===v.CLOCKWISE?l<=h&&(l+=2*Math.PI):l>=h&&(l-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,l,h,s,i),this._segList.addPt(n)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}addLimitedMitreJoin(t,e,n,s){const i=this._seg0.p1,r=ie.angle(i,this._seg0.p0),o=(ie.angle(i,this._seg1.p1),ie.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2),l=ie.normalize(r+o),a=ie.normalize(l+Math.PI),c=s*n,h=n-c*Math.abs(Math.sin(o)),u=i.x+c*Math.cos(a),d=i.y+c*Math.sin(a),_=new g(u,d),f=new ee(i,_),p=f.pointAlongOffset(1,h),m=f.pointAlongOffset(1,-h);this._side===Pn.LEFT?(this._segList.addPt(p),this._segList.addPt(m)):(this._segList.addPt(m),this._segList.addPt(p))}addDirectedFillet(t,e,n,s,i){const r=s===v.CLOCKWISE?-1:1,o=Math.abs(e-n),l=Math.trunc(o/this._filletAngleQuantum+.5);if(l<1)return null;let a=null,c=null;a=0,c=o/l;let h=0;const u=new g;for(;h<o;){const n=e+r*h;u.x=t.x+i*Math.cos(n),u.y=t.y+i*Math.sin(n),this._segList.addPt(u),h+=c}}computeOffsetSegment(t,e,n,s){const i=e===Pn.LEFT?1:-1,r=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,l=Math.sqrt(r*r+o*o),a=i*n*r/l,c=i*n*o/l;s.p0.x=t.p0.x-c,s.p0.y=t.p0.y+a,s.p1.x=t.p1.x-c,s.p1.y=t.p1.y+a}addInsideTurn(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*ii.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){const t=new g((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);const e=new g((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(e)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){const e=new g(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new si,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*ii.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2),this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===js.JOIN_BEVEL||this._bufParams.getJoinStyle()===js.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,v.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}getClass(){return ii}get interfaces_(){return[]}}ii.constructor_=function(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new ee,this._seg1=new ee,this._offset0=new ee,this._offset1=new ee,this._side=0,this._hasNarrowConcaveAngle=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._bufParams=e,this._li=new te,this._filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===js.JOIN_ROUND&&(this._closingSegLengthFactor=ii.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)},ii.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,ii.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,ii.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,ii.MAX_CLOSING_SEG_LEN_FACTOR=80;class ri{constructor(){ri.constructor_.apply(this,arguments)}static copyCoordinates(t){const e=new Array(t.length).fill(null);for(let n=0;n<e.length;n++)e[n]=new g(t[n]);return e}getOffsetCurve(t,e){if(this._distance=e,0===e)return null;const n=e<0,s=Math.abs(e),i=this.getSegGen(s);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);const r=i.getCoordinates();return n&&X.reverse(r),r}computeSingleSidedBufferCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);const e=ni.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Pn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{n.addSegments(t,!1);const e=ni.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Pn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment(),n.closeRing()}computeRingBufferCurve(t,e,n){let s=this.simplifyTolerance(this._distance);e===Pn.RIGHT&&(s=-s);const i=ni.simplify(t,s),r=i.length-1;n.initSideSegments(i[r-1],i[0],e);for(let t=1;t<=r;t++){const e=1!==t;n.addNextSegment(i[t],e)}n.closeRing()}computeLineBufferCurve(t,e){const n=this.simplifyTolerance(this._distance),s=ni.simplify(t,n),i=s.length-1;e.initSideSegments(s[0],s[1],Pn.LEFT);for(let t=2;t<=i;t++)e.addNextSegment(s[t],!0);e.addLastSegment(),e.addLineEndCap(s[i-1],s[i]);const r=ni.simplify(t,-n),o=r.length-1;e.initSideSegments(r[o],r[o-1],Pn.LEFT);for(let t=o-2;t>=0;t--)e.addNextSegment(r[t],!0);e.addLastSegment(),e.addLineEndCap(r[1],r[0]),e.closeRing()}computePointCurve(t,e){switch(this._bufParams.getEndCapStyle()){case js.CAP_ROUND:e.createCircle(t);break;case js.CAP_SQUARE:e.createSquare(t)}}getLineCurve(t,e){if(this._distance=e,e<0&&!this._bufParams.isSingleSided())return null;if(0===e)return null;const n=Math.abs(e),s=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],s);else if(this._bufParams.isSingleSided()){const n=e<0;this.computeSingleSidedBufferCurve(t,n,s)}else this.computeLineBufferCurve(t,s);return s.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return ri.copyCoordinates(t);const s=this.getSegGen(n);return this.computeRingBufferCurve(t,e,s),s.getCoordinates()}computeOffsetCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){const e=ni.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Pn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{const e=ni.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Pn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment()}getSegGen(t){return new ii(this._precisionModel,this._bufParams,t)}getClass(){return ri}get interfaces_(){return[]}}ri.constructor_=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;const t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e};class oi{constructor(){oi.constructor_.apply(this,arguments)}findStabbedSegments(){if(1===arguments.length){const t=arguments[0],e=new x;for(let n=this._subgraphs.iterator();n.hasNext();){const s=n.next(),i=s.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,s.getDirectedEdges(),e)}return e}if(3===arguments.length)if(_(arguments[2],m)&&arguments[0]instanceof g&&arguments[1]instanceof jn){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getEdge().getCoordinates();for(let i=0;i<s.length-1;i++){if(this._seg.p0=s[i],this._seg.p1=s[i+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse(),Math.max(this._seg.p0.x,this._seg.p1.x)<t.x)continue;if(this._seg.isHorizontal())continue;if(t.y<this._seg.p0.y||t.y>this._seg.p1.y)continue;if(v.index(this._seg.p0,this._seg.p1,t)===v.RIGHT)continue;let r=e.getDepth(Pn.LEFT);this._seg.p0.equals(s[i])||(r=e.getDepth(Pn.RIGHT));const o=new li(this._seg,r);n.add(o)}}else if(_(arguments[2],m)&&arguments[0]instanceof g&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=e.iterator();s.hasNext();){const e=s.next();e.isForward()&&this.findStabbedSegments(t,e,n)}}}getDepth(t){const e=this.findStabbedSegments(t);return 0===e.size()?0:Ee.min(e)._leftDepth}getClass(){return oi}get interfaces_(){return[]}}class li{constructor(){li.constructor_.apply(this,arguments)}compareTo(t){const e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;let n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg),0!==n?n:this._upwardSeg.compareTo(e._upwardSeg))}compareX(t,e){const n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}toString(){return this._upwardSeg.toString()}getClass(){return li}get interfaces_(){return[r]}}li.constructor_=function(){this._upwardSeg=null,this._leftDepth=null;const t=arguments[0],e=arguments[1];this._upwardSeg=new ee(t),this._leftDepth=e},oi.DepthSegment=li,oi.constructor_=function(){this._subgraphs=null,this._seg=new ee;const t=arguments[0];this._subgraphs=t};class ai{constructor(){ai.constructor_.apply(this,arguments)}addPoint(t){if(this._distance<=0)return null;const e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,ne.EXTERIOR,ne.INTERIOR)}addPolygon(t){let e=this._distance,n=Pn.LEFT;this._distance<0&&(e=-this._distance,n=Pn.RIGHT);const s=t.getExteriorRing(),i=X.removeRepeatedPoints(s.getCoordinates());if(this._distance<0&&this.isErodedCompletely(s,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addPolygonRing(i,e,n,ne.EXTERIOR,ne.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s),r=X.removeRepeatedPoints(i.getCoordinates());this._distance>0&&this.isErodedCompletely(i,-this._distance)||this.addPolygonRing(r,e,Pn.opposite(n),ne.INTERIOR,ne.EXTERIOR)}}isTriangleErodedCompletely(t,e){const n=new re(t[0],t[1],t[2]),s=n.inCentre();return D.pointToSegment(s,n.p0,n.p1)<Math.abs(e)}addLineString(t){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;const e=X.removeRepeatedPoints(t.getCoordinates()),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,ne.EXTERIOR,ne.INTERIOR)}addCurve(t,e,n){if(null===t||t.length<2)return null;const s=new Fs(t,new Fn(0,ne.BOUNDARY,e,n));this._curveList.add(s)}getCurves(){return this.add(this._inputGeom),this._curveList}addPolygonRing(t,e,n,s,i){if(0===e&&t.length<Dt.MINIMUM_VALID_SIZE)return null;let r=s,o=i;t.length>=Dt.MINIMUM_VALID_SIZE&&v.isCCW(t)&&(r=i,o=s,n=Pn.opposite(n));const l=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(l,r,o)}add(t){if(t.isEmpty())return null;if(t instanceof bt)this.addPolygon(t);else if(t instanceof Tt)this.addLineString(t);else if(t instanceof Pt)this.addPoint(t);else if(t instanceof Mt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else if(t instanceof At)this.addCollection(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.addCollection(t)}}isErodedCompletely(t,e){const n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);const s=t.getEnvelopeInternal(),i=Math.min(s.getHeight(),s.getWidth());return e<0&&2*Math.abs(e)>i}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}getClass(){return ai}get interfaces_(){return[]}}ai.constructor_=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new x;const t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n};class ci{constructor(){ci.constructor_.apply(this,arguments)}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=ne.NONE;for(let n=this.iterator();n.hasNext();){const s=n.next().getLabel();s.isArea(t)&&s.getLocation(t,Pn.LEFT)!==ne.NONE&&(e=s.getLocation(t,Pn.LEFT))}if(e===ne.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const s=e.next(),i=s.getLabel();if(i.getLocation(t,Pn.ON)===ne.NONE&&i.setLocation(t,Pn.ON,n),i.isArea(t)){const e=i.getLocation(t,Pn.LEFT),r=i.getLocation(t,Pn.RIGHT);if(r!==ne.NONE){if(r!==n)throw new Wn("side location conflict",s.getCoordinate());e===ne.NONE&&u.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),n=e}else u.isTrue(i.getLocation(t,Pn.LEFT)===ne.NONE,"found single null side"),i.setLocation(t,Pn.RIGHT,n),i.setLocation(t,Pn.LEFT,n)}}}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}print(t){O.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,s=e.get(n).getLabel().getLocation(t,Pn.LEFT);u.isTrue(s!==ne.NONE,"Found unlabelled area edge");let i=s;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();u.isTrue(n.isArea(t),"Found non-area edge");const s=n.getLocation(t,Pn.LEFT),r=n.getLocation(t,Pn.RIGHT);if(s===r)return!1;if(r!==i)return!1;i=s}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new x(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===ne.NONE&&(this._ptInAreaLocation[t]=Ze.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new w;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===ne.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const s=n.next(),i=s.getLabel();for(let n=0;n<2;n++)if(i.isAnyNull(n)){let r=ne.NONE;if(e[n])r=ne.EXTERIOR;else{const e=s.getCoordinate();r=this.getLocation(n,e,t)}i.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}getClass(){return ci}get interfaces_(){return[]}}ci.constructor_=function(){this._edgeMap=new rt,this._edgeList=null,this._ptInAreaLocation=[ne.NONE,ne.NONE]};class hi extends ci{constructor(){super(),hi.constructor_.apply(this,arguments)}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,e=null,n=this._SCANNING_FOR_INCOMING;for(let s=0;s<this._resultAreaEdgeList.size();s++){const i=this._resultAreaEdgeList.get(s),r=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!r.isInResult())continue;e=r,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new Wn("no outgoing dirEdge found",this.getCoordinate());u.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}insert(t){const e=t;this.insertEdgeEnd(e,e)}getRightmostEdge(){const t=this.getEdges(),e=t.size();if(e<1)return null;const n=t.get(0);if(1===e)return n;const s=t.get(e-1),i=n.getQuadrant(),r=s.getQuadrant();return In.isNorthern(i)&&In.isNorthern(r)?n:In.isNorthern(i)||In.isNorthern(r)?0!==n.getDy()?n:0!==s.getDy()?s:(u.shouldNeverReachHere("found two horizontal edges incident on node"),null):s}print(t){O.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){const n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new x;for(let t=this.iterator();t.hasNext();){const e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}updateLabelling(t){for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,e=null;for(let n=this._edgeList.size()-1;n>=0;n--){const s=this._edgeList.get(n),i=s.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=s}e.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],e=this.findIndex(t),n=t.getDepth(Pn.LEFT),s=t.getDepth(Pn.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==s)throw new Wn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[0],e=arguments[1];let n=arguments[2];for(let s=t;s<e;s++){const t=this._edgeList.get(s);t.setEdgeDepths(Pn.RIGHT,n),n=t.getDepth(Pn.LEFT)}return n}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const e=t.next();e.getLabel().merge(e.getSym().getLabel())}}linkMinimalDirectedEdges(t){let e=null,n=null,s=this._SCANNING_FOR_INCOMING;for(let i=this._resultAreaEdgeList.size()-1;i>=0;i--){const r=this._resultAreaEdgeList.get(i),o=r.getSym();switch(null===e&&r.getEdgeRing()===t&&(e=r),s){case this._SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,s=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(r.getEdgeRing()!==t)continue;n.setNextMin(r),s=this._SCANNING_FOR_INCOMING}}s===this._LINKING_TO_OUTGOING&&(u.isTrue(null!==e,"found null for first outgoing dirEdge"),u.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){const t=arguments[0];let e=0;for(let n=this.iterator();n.hasNext();){n.next().getEdgeRing()===t&&e++}return e}}getLabel(){return this._label}findCoveredLineEdges(){let t=ne.NONE;for(let e=this.iterator();e.hasNext();){const n=e.next(),s=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=ne.INTERIOR;break}if(s.isInResult()){t=ne.EXTERIOR;break}}}if(t===ne.NONE)return null;let e=t;for(let t=this.iterator();t.hasNext();){const n=t.next(),s=n.getSym();n.isLineEdge()?n.getEdge().setCovered(e===ne.INTERIOR):(n.isInResult()&&(e=ne.EXTERIOR),s.isInResult()&&(e=ne.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new Fn(ne.NONE);for(let t=this.iterator();t.hasNext();){const e=t.next().getEdge().getLabel();for(let t=0;t<2;t++){const n=e.getLocation(t);n!==ne.INTERIOR&&n!==ne.BOUNDARY||this._label.setLocation(t,ne.INTERIOR)}}}getClass(){return hi}get interfaces_(){return[]}}hi.constructor_=function(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2};class ui extends Kn{constructor(){super(),ui.constructor_.apply(this,arguments)}createNode(t){return new kn(t,new hi)}getClass(){return ui}get interfaces_(){return[]}}ui.constructor_=function(){};class gi{constructor(){gi.constructor_.apply(this,arguments)}static orientation(t){return 1===X.increasingDirection(t)}static compareOriented(t,e,n,s){const i=e?1:-1,r=s?1:-1,o=e?t.length:-1,l=s?n.length:-1;let a=e?0:t.length-1,c=s?0:n.length-1;for(;;){const e=t[a].compareTo(n[c]);if(0!==e)return e;a+=i,c+=r;const s=a===o,h=c===l;if(s&&!h)return-1;if(!s&&h)return 1;if(s&&h)return 0}}compareTo(t){const e=t;return gi.compareOriented(this._pts,this._orientation,e._pts,e._orientation)}getClass(){return gi}get interfaces_(){return[r]}}gi.constructor_=function(){this._pts=null,this._orientation=null;const t=arguments[0];this._pts=t,this._orientation=gi.orientation(t)};class di{constructor(){di.constructor_.apply(this,arguments)}print(t){t.print("MULTILINESTRING ( ");for(let e=0;e<this._edges.size();e++){const n=this._edges.get(e);e>0&&t.print(","),t.print("(");const s=n.getCoordinates();for(let e=0;e<s.length;e++)e>0&&t.print(","),t.print(s[e].x+" "+s[e].y);t.println(")")}t.print(")  ")}addAll(t){for(let e=t.iterator();e.hasNext();)this.add(e.next())}findEdgeIndex(t){for(let e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){const e=new gi(t.getCoordinates());return this._ocaMap.get(e)}add(t){this._edges.add(t);const e=new gi(t.getCoordinates());this._ocaMap.put(e,t)}getClass(){return di}get interfaces_(){return[]}}di.constructor_=function(){this._edges=new x,this._ocaMap=new rt};class _i{constructor(){_i.constructor_.apply(this,arguments)}processIntersections(t,e,n,s){}isDone(){}getClass(){return _i}get interfaces_(){return[]}}_i.constructor_=function(){};class fi{constructor(){fi.constructor_.apply(this,arguments)}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(fi.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.size()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}getClass(){return fi}get interfaces_(){return[_i]}}fi.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;const t=arguments[0];this._li=t};class pi{constructor(){pi.constructor_.apply(this,arguments)}static depthDelta(t){const e=t.getLocation(0,Pn.LEFT),n=t.getLocation(0,Pn.RIGHT);return e===ne.INTERIOR&&n===ne.EXTERIOR?1:e===ne.EXTERIOR&&n===ne.INTERIOR?-1:0}static convertSegStrings(t){const e=new Ht,n=new x;for(;t.hasNext();){const s=t.next(),i=e.createLineString(s.getCoordinates());n.add(i)}return e.buildGeometry(n)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Fn(t.getLabel()),s.flip()),n.merge(s);const i=pi.depthDelta(s),r=e.getDepthDelta()+i;e.setDepthDelta(r)}else this._edgeList.add(t),t.setDepthDelta(pi.depthDelta(t.getLabel()))}buildSubgraphs(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=t.getRightmostCoordinate(),r=new oi(n).getDepth(i);t.computeDepth(r),t.findResultEdges(),n.add(t),e.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){const e=new x;for(let n=t.getNodes().iterator();n.hasNext();){const t=n.next();if(!t.isVisited()){const n=new Qs;n.create(t),e.add(n)}}return Ee.sort(e,Ee.reverseOrder()),e}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;const e=new Ys,n=new te;return n.setPrecisionModel(t),e.setSegmentIntersector(new fi(n)),e}buffer(t,e){let n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();const s=new ri(n,this._bufParams),i=new ai(t,e,s).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new Zn(new ui),this._graph.addEdges(this._edgeList.getEdges());const r=this.createSubgraphs(this._graph),o=new ei(this._geomFact);this.buildSubgraphs(r,o);const l=o.getPolygons();return l.size()<=0?this.createEmptyResultGeometry():this._geomFact.buildGeometry(l)}computeNodedEdges(t,e){const n=this.getNoder(e);n.computeNodes(t);for(let t=n.getNodedSubstrings().iterator();t.hasNext();){const e=t.next(),n=e.getCoordinates();if(2===n.length&&n[0].equals2D(n[1]))continue;const s=e.getData(),i=new Un(e.getCoordinates(),new Fn(s));this.insertUniqueEdge(i)}}setNoder(t){this._workingNoder=t}getClass(){return pi}get interfaces_(){return[]}}pi.constructor_=function(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new di;const t=arguments[0];this._bufParams=t};class mi{constructor(){mi.constructor_.apply(this,arguments)}checkEndPtVertexIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length){const t=arguments[0];for(let e=arguments[1].iterator();e.hasNext();){const n=e.next().getCoordinates();for(let e=1;e<n.length-1;e++)if(n[e].equals(t))throw new c("found endpt/interior pt intersection at index "+e+" :pt "+t)}}}checkInteriorIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();for(let t=this._segStrings.iterator();t.hasNext();){const n=t.next();this.checkInteriorIntersections(e,n)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates(),s=e.getCoordinates();for(let i=0;i<n.length-1;i++)for(let n=0;n<s.length-1;n++)this.checkInteriorIntersections(t,i,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,i,r)||this.hasInteriorIntersection(this._li,o,l)))throw new c("found non-noded intersection at "+i+"-"+r+" and "+o+"-"+l)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();this.checkCollapses(e)}else if(1===arguments.length){const t=arguments[0].getCoordinates();for(let e=0;e<t.length-2;e++)this.checkCollapse(t[e],t[e+1],t[e+2])}}hasInteriorIntersection(t,e,n){for(let s=0;s<t.getIntersectionNum();s++){const i=t.getIntersection(s);if(!i.equals(e)&&!i.equals(n))return!0}return!1}checkCollapse(t,e,n){if(t.equals(n))throw new c("found non-noded collapse at "+mi.fact.createLineString([t,e,n]))}getClass(){return mi}get interfaces_(){return[]}}mi.constructor_=function(){this._li=new te,this._segStrings=null;const t=arguments[0];this._segStrings=t},mi.fact=new Ht;class yi{constructor(){yi.constructor_.apply(this,arguments)}intersectsScaled(t,e){const n=Math.min(t.x,e.x),s=Math.max(t.x,e.x),i=Math.min(t.y,e.y),r=Math.max(t.y,e.y),o=this._maxx<n||this._minx>s||this._maxy<i||this._miny>r;if(o)return!1;const l=this.intersectsToleranceSquare(t,e);return u.isTrue(!(o&&l),"Found bad envelope test"),l}initCorners(t){this._minx=t.x-.5,this._maxx=t.x+.5,this._miny=t.y-.5,this._maxy=t.y+.5,this._corner[0]=new g(this._maxx,this._maxy),this._corner[1]=new g(this._minx,this._maxy),this._corner[2]=new g(this._minx,this._miny),this._corner[3]=new g(this._maxx,this._miny)}intersects(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){const t=yi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new N(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,e){let n=!1,s=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(s=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!s)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))}addSnappedNode(t,e){const n=t.getCoordinate(e),s=t.getCoordinate(e+1);return!!this.intersects(n,s)&&(t.addIntersection(this.getCoordinate(),e),!0)}getClass(){return yi}get interfaces_(){return[]}}yi.constructor_=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;const t=arguments[0],e=arguments[1],s=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=s,e<=0)throw new n("Scale factor must be non-zero");1!==e&&(this._pt=new g(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new g,this._p1Scaled=new g),this.initCorners(this._pt)},yi.SAFE_ENV_EXPANSION_FACTOR=.75;class xi{constructor(){xi.constructor_.apply(this,arguments)}select(){if(1===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}}getClass(){return xi}get interfaces_(){return[]}}xi.constructor_=function(){this.selectedSegment=new ee};class Ei{constructor(){Ei.constructor_.apply(this,arguments)}snap(){if(1===arguments.length){const t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getSafeEnvelope(),i=new Ii(t,e,n);return this._index.query(s,new class{get interfaces_(){return[Ae]}visitItem(t){t.select(s,i)}}),i.isNodeAdded()}}getClass(){return Ei}get interfaces_(){return[]}}class Ii extends xi{constructor(){super(),Ii.constructor_.apply(this,arguments)}isNodeAdded(){return this._isNodeAdded}select(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof qs))return super.select.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=t.getContext();if(null!==this._parentEdge&&n===this._parentEdge&&e===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(n,e)}}getClass(){return Ii}get interfaces_(){return[]}}Ii.constructor_=function(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n},Ei.HotPixelSnapAction=Ii,Ei.constructor_=function(){this._index=null;const t=arguments[0];this._index=t};class Ni{constructor(){Ni.constructor_.apply(this,arguments)}processIntersections(t,e,n,s){if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}getClass(){return Ni}get interfaces_(){return[_i]}}Ni.constructor_=function(){this._li=null,this._interiorIntersections=null;const t=arguments[0];this._li=t,this._interiorIntersections=new x};class Ci{constructor(){Ci.constructor_.apply(this,arguments)}checkCorrectness(t){const e=Fs.getNodedSubstrings(t),n=new mi(e);try{n.checkValid()}catch(t){if(!(t instanceof C))throw t;t.printStackTrace()}}getNodedSubstrings(){return Fs.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,e){const n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}findInteriorIntersections(t,e){const n=new Ni(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}computeVertexSnaps(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.computeVertexSnaps(e)}}else if(arguments[0]instanceof Fs){const t=arguments[0],e=t.getCoordinates();for(let n=0;n<e.length;n++){const s=new yi(e[n],this._scaleFactor,this._li);this._pointSnapper.snap(s,t,n)&&t.addIntersection(e[n],n)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new Ys,this._pointSnapper=new Ei(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=new yi(t,this._scaleFactor,this._li);this._pointSnapper.snap(n)}}getClass(){return Ci}get interfaces_(){return[Vs]}}Ci.constructor_=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;const t=arguments[0];this._pm=t,this._li=new te,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()};class Si{constructor(){Si.constructor_.apply(this,arguments)}static bufferOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Si(t).getResultGeometry(e)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof q&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Si(t);return s.setQuadrantSegments(n),s.getResultGeometry(e)}if(arguments[2]instanceof js&&arguments[0]instanceof q&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return new Si(t,n).getResultGeometry(e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new Si(t);return i.setQuadrantSegments(n),i.setEndCapStyle(s),i.getResultGeometry(e)}}static precisionScaleFactor(t,e,n){const s=t.getEnvelopeInternal(),i=M.max(Math.abs(s.getMaxX()),Math.abs(s.getMaxY()),Math.abs(s.getMinX()),Math.abs(s.getMinY()))+2*(e>0?e:0),r=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,r)}bufferFixedPrecision(t){const e=new ks(new Ci(new kt(1)),t.getScale()),n=new pi(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0===arguments.length){for(let t=Si.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof Wn))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){const t=arguments[0],e=Si.precisionScaleFactor(this._argGeom,this._distance,t),n=new kt(e);this.bufferFixedPrecision(n)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;const t=this._argGeom.getFactory().getPrecisionModel();t.getType()===kt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{const t=new pi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof c))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}getClass(){return Si}get interfaces_(){return[]}}Si.constructor_=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new js,this._resultGeometry=null,this._saveException=null,1===arguments.length){const t=arguments[0];this._argGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._argGeom=t,this._bufParams=e}},Si.CAP_ROUND=js.CAP_ROUND,Si.CAP_BUTT=js.CAP_FLAT,Si.CAP_FLAT=js.CAP_FLAT,Si.CAP_SQUARE=js.CAP_SQUARE,Si.MAX_PRECISION_DIGITS=12;var wi=Object.freeze({__proto__:null,BufferOp:Si,BufferParameters:js});class Li{constructor(){Li.constructor_.apply(this,arguments)}isInsideArea(){return this._segIndex===Li.INSIDE_AREA}getCoordinate(){return this._pt}getGeometryComponent(){return this._component}getSegmentIndex(){return this._segIndex}getClass(){return Li}get interfaces_(){return[]}}Li.constructor_=function(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){const t=arguments[0],e=arguments[1];Li.constructor_.call(this,t,Li.INSIDE_AREA,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._component=t,this._segIndex=e,this._pt=n}},Li.INSIDE_AREA=-1;class Ti{constructor(){Ti.constructor_.apply(this,arguments)}static getLocations(t){const e=new x;return t.apply(new Ti(e)),e}filter(t){(t instanceof Pt||t instanceof Tt||t instanceof bt)&&this._locations.add(new Li(t,0,t.getCoordinate()))}getClass(){return Ti}get interfaces_(){return[gt]}}Ti.constructor_=function(){this._locations=null;const t=arguments[0];this._locations=t};class Ri{constructor(){Ri.constructor_.apply(this,arguments)}static distance(t,e){return new Ri(t,e).distance()}static isWithinDistance(t,e,n){return!(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>n)&&new Ri(t,e,n).distance()<=n}static nearestPoints(t,e){return new Ri(t,e).nearestPoints()}computeContainmentDistance(){if(0===arguments.length){const t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._geom[t];if(n.getDimension()<2)return null;const s=1-t,i=Ne.getPolygons(n);if(i.size()>0){const n=Ti.getLocations(this._geom[s]);if(this.computeContainmentDistance(n,i,e),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[s]=e[0],this._minDistanceLocation[t]=e[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&_(arguments[0],m)&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++)if(this.computeContainmentDistance(i,e.get(t),n),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Li&&arguments[1]instanceof bt){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getCoordinate();if(ne.EXTERIOR!==this._ptLocator.locate(s,e))return this._minDistance=0,n[0]=t,n[1]=new Li(e,s),null}}computeMinDistanceLinesPoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){const t=new Array(2).fill(null),e=xe.getLines(this._geom[0]),n=xe.getLines(this._geom[1]),s=Ie.getPoints(this._geom[0]),i=Ie.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,i,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,s,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(s,i,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){return this.computeMinDistance(),[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof Tt&&arguments[1]instanceof Pt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinate();for(let r=0;r<s.length-1;r++){const o=D.pointToSegment(i,s[r],s[r+1]);if(o<this._minDistance){this._minDistance=o;const l=new ee(s[r],s[r+1]).closestPoint(i);n[0]=new Li(t,r,l),n[1]=new Li(e,0,i)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Tt&&arguments[1]instanceof Tt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinates();for(let r=0;r<s.length-1;r++)for(let o=0;o<i.length-1;o++){const l=D.segmentToSegment(s[r],s[r+1],i[o],i[o+1]);if(l<this._minDistance){this._minDistance=l;const a=new ee(s[r],s[r+1]),c=new ee(i[o],i[o+1]),h=a.closestPoints(c);n[0]=new Li(t,r,h[0]),n[1]=new Li(e,o,h[1])}if(this._minDistance<=this._terminateDistance)return null}}}computeMinDistancePoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t),r=i.getCoordinate().distance(s.getCoordinate());if(r<this._minDistance&&(this._minDistance=r,n[0]=new Li(i,0,i.getCoordinate()),n[1]=new Li(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new n("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}getClass(){return Ri}get interfaces_(){return[]}}Ri.constructor_=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new _n,this._minDistanceLocation=null,this._minDistance=i.MAX_VALUE,2===arguments.length){const t=arguments[0],e=arguments[1];Ri.constructor_.call(this,t,e,0)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e,this._terminateDistance=n}};var Pi=Object.freeze({__proto__:null,DistanceOp:Ri});class vi{constructor(){vi.constructor_.apply(this,arguments)}getCoordinates(){if(null===this._coordinates){let t=0,e=0;const n=new I;for(let s=this._directedEdges.iterator();s.hasNext();){const i=s.next();i.getEdgeDirection()?t++:e++,n.add(i.getEdge().getLine().getCoordinates(),!1,i.getEdgeDirection())}this._coordinates=n.toCoordinateArray(),e>t&&X.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}getClass(){return vi}get interfaces_(){return[]}}vi.constructor_=function(){this._factory=null,this._directedEdges=new x,this._coordinates=null;const t=arguments[0];this._factory=t};class Oi{constructor(){Oi.constructor_.apply(this,arguments)}static getComponentWithVisitedState(t,e){for(;t.hasNext();){const n=t.next();if(n.isVisited()===e)return n}return null}static setVisited(t,e){for(;t.hasNext();){t.next().setVisited(e)}}static setMarked(t,e){for(;t.hasNext();){t.next().setMarked(e)}}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}getClass(){return Oi}get interfaces_(){return[]}}Oi.constructor_=function(){this._isMarked=!1,this._isVisited=!1,this._data=null};class bi extends Oi{constructor(){super(),bi.constructor_.apply(this,arguments)}static toEdges(t){const e=new x;for(let n=t.iterator();n.hasNext();)e.add(n.next()._parentEdge);return e}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){const e=this.getClass().getName(),n=e.lastIndexOf("."),s=e.substring(n+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){const e=t;return this.compareDirection(e)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}getClass(){return bi}get interfaces_(){return[r]}}bi.constructor_=function(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._from=t,this._to=e,this._edgeDirection=s,this._p0=t.getCoordinate(),this._p1=n;const i=this._p1.x-this._p0.x,r=this._p1.y-this._p0.y;this._quadrant=In.quadrant(i,r),this._angle=Math.atan2(r,i)}};class Mi extends bi{constructor(){super(),Mi.constructor_.apply(this,arguments)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(u.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}getClass(){return Mi}get interfaces_(){return[]}}Mi.constructor_=function(){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];bi.constructor_.call(this,t,e,n,s)};class Di extends Oi{constructor(){super(),Di.constructor_.apply(this,arguments)}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,e){this._dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)}getDirEdge(){if(Number.isInteger(arguments[0])){const t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof Fi){const t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}getClass(){return Di}get interfaces_(){return[]}}Di.constructor_=function(){if(this._dirEdge=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}};class Ai{constructor(){Ai.constructor_.apply(this,arguments)}getNextEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e+1))}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(Ee.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e-1))}getIndex(){if(arguments[0]instanceof Di){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e).getEdge()===t)return e}return-1}if(arguments[0]instanceof bi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e)===t)return e}return-1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}getClass(){return Ai}get interfaces_(){return[]}}Ai.constructor_=function(){this._outEdges=new x,this._sorted=!1};class Fi extends Oi{constructor(){super(),Fi.constructor_.apply(this,arguments)}static getEdgesBetween(t,e){const n=new J(bi.toEdges(t.getOutEdges().getEdges())),s=bi.toEdges(e.getOutEdges().getEdges());return n.retainAll(s),n}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0===arguments.length)this._pt=null;else if(1===arguments.length){const t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}getClass(){return Fi}get interfaces_(){return[]}}Fi.constructor_=function(){if(this._pt=null,this._deStar=null,1===arguments.length){const t=arguments[0];Fi.constructor_.call(this,t,new Ai)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt=t,this._deStar=e}};class Gi extends Di{constructor(){super(),Gi.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return Gi}get interfaces_(){return[]}}Gi.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class qi{constructor(){qi.constructor_.apply(this,arguments)}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}getClass(){return qi}get interfaces_(){return[]}}qi.constructor_=function(){this._nodeMap=new rt};class Bi{constructor(){Bi.constructor_.apply(this,arguments)}findNodesOfDegree(t){const e=new x;for(let n=this.nodeIterator();n.hasNext();){const s=n.next();s.getDegree()===t&&e.add(s)}return e}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Di){const t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof bi){const t=arguments[0],e=t.getSym();null!==e&&e.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof Fi){const t=arguments[0];for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next(),n=t.getSym();null!==n&&this.remove(n),this._dirEdges.remove(t);const s=t.getEdge();null!==s&&this._edges.remove(s)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Di){const t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof bi){const t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof Fi){const t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Di){const t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof bi){const t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}getClass(){return Bi}get interfaces_(){return[]}}Bi.constructor_=function(){this._edges=new J,this._dirEdges=new J,this._nodeMap=new qi};class Vi extends Bi{constructor(){super(),Vi.constructor_.apply(this,arguments)}addEdge(t){if(t.isEmpty())return null;const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Mi(i,r,e[1],!0),l=new Mi(r,i,e[e.length-2],!1),a=new Gi(t);a.setDirectedEdges(o,l),this.add(a)}getNode(t){let e=this.findNode(t);return null===e&&(e=new Fi(t),this.add(e)),e}getClass(){return Vi}get interfaces_(){return[]}}Vi.constructor_=function(){};class zi{constructor(){zi.constructor_.apply(this,arguments)}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();e.isMarked()||(u.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let e=t.getOutEdges().iterator();e.hasNext();){const t=e.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;Oi.setMarked(this._graph.nodeIterator(),!1),Oi.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new x,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new x;for(let t=this._edgeStrings.iterator();t.hasNext();){const e=t.next();this._mergedLineStrings.add(e.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){const e=new vi(this._factory);let n=t;do{e.add(n),n.getEdge().setMarked(!0),n=n.getNext()}while(null!==n&&n!==t);return e}add(){if(arguments[0]instanceof q){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);n instanceof Tt&&this.addLineString(n)}}else if(_(arguments[0],f)){const t=arguments[0];this._mergedLineStrings=null;for(let e=t.iterator();e.hasNext();){const t=e.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}getClass(){return zi}get interfaces_(){return[]}}zi.constructor_=function(){this._graph=new Vi,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null};class Yi{constructor(){Yi.constructor_.apply(this,arguments)}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}getClass(){return Yi}get interfaces_(){return[]}}Yi.constructor_=function(){this._parentGraph=null,this._edges=new J,this._dirEdges=new x,this._nodeMap=new qi;const t=arguments[0];this._parentGraph=t};class Ui{constructor(){Ui.constructor_.apply(this,arguments)}addReachable(t,e){const n=new on;for(n.add(t);!n.empty();){const t=n.pop();this.addEdges(t,n,e)}}findSubgraph(t){const e=new Yi(this._graph);return this.addReachable(t,e),e}getConnectedSubgraphs(){const t=new x;Oi.setVisited(this._graph.nodeIterator(),!1);for(let e=this._graph.edgeIterator();e.hasNext();){const n=e.next().getDirEdge(0).getFromNode();n.isVisited()||t.add(this.findSubgraph(n))}return t}addEdges(t,e,n){t.setVisited(!0);for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();n.add(t.getEdge());const i=t.getToNode();i.isVisited()||e.push(i)}}getClass(){return Ui}get interfaces_(){return[]}}Ui.constructor_=function(){this._graph=null;const t=arguments[0];this._graph=t};class ki{constructor(){ki.constructor_.apply(this,arguments)}static findUnvisitedBestOrientedDE(t){let e=null,n=null;for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();t.getEdge().isVisited()||(n=t,t.getEdgeDirection()&&(e=t))}return null!==e?e:n}static findLowestDegreeNode(t){let e=L.MAX_VALUE,n=null;for(let s=t.nodeIterator();s.hasNext();){const t=s.next();(null===n||t.getDegree()<e)&&(e=t.getDegree(),n=t)}return n}static isSequenced(t){if(!(t instanceof ft))return!0;const e=t,n=new at;let s=null;const i=new x;for(let t=0;t<e.getNumGeometries();t++){const r=e.getGeometryN(t),o=r.getCoordinateN(0),l=r.getCoordinateN(r.getNumPoints()-1);if(n.contains(o))return!1;if(n.contains(l))return!1;null!==s&&(o.equals(s)||(n.addAll(i),i.clear())),i.add(o),i.add(l),s=l}return!0}static reverse(t){const e=t.getCoordinates(),n=new Array(e.length).fill(null),s=e.length;for(let t=0;t<s;t++)n[s-1-t]=new g(e[t]);return t.getFactory().createLineString(n)}static sequence(t){const e=new ki;return e.add(t),e.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let e=0;for(let n=t.nodeIterator();n.hasNext();){n.next().getDegree()%2==1&&e++}return e<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;const t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;const e=this._sequencedGeometry.getNumGeometries();u.isTrue(this._lineCount===e,"Lines were missing from result"),u.isTrue(this._sequencedGeometry instanceof Tt||this._sequencedGeometry instanceof ft,"Result is not lineal")}findSequences(){const t=new x;for(let e=new Ui(this._graph).getConnectedSubgraphs().iterator();e.hasNext();){const n=e.next();if(!this.hasSequence(n))return null;{const e=this.findSequence(n);t.add(e)}}return t}addReverseSubpath(t,e,n){const s=t.getToNode();let i=null;for(;;){e.add(t.getSym()),t.getEdge().setVisited(!0),i=t.getFromNode();const n=ki.findUnvisitedBestOrientedDE(i);if(null===n)break;t=n.getSym()}n&&u.isTrue(i===s,"path not contiguous")}findSequence(t){Oi.setVisited(t.edgeIterator(),!1);const e=ki.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),n=new Zs,s=n.listIterator();for(this.addReverseSubpath(e,s,!1);s.hasPrevious();){const t=s.previous(),e=ki.findUnvisitedBestOrientedDE(t.getFromNode());null!==e&&this.addReverseSubpath(e.getSym(),s,!0)}return this.orient(n)}reverse(t){const e=new Zs;for(let n=t.iterator();n.hasNext();){const t=n.next();e.addFirst(t.getSym())}return e}orient(t){const e=t.get(0),n=t.get(t.size()-1),s=e.getFromNode(),i=n.getToNode();let r=!1;if(1===s.getDegree()||1===i.getDegree()){let t=!1;1===n.getToNode().getDegree()&&!1===n.getEdgeDirection()&&(t=!0,r=!0),1===e.getFromNode().getDegree()&&!0===e.getEdgeDirection()&&(t=!0,r=!1),t||1===e.getFromNode().getDegree()&&(r=!0)}return r?this.reverse(t):t}buildSequencedGeometry(t){const e=new x;for(let n=t.iterator();n.hasNext();){for(let t=n.next().iterator();t.hasNext();){const n=t.next(),s=n.getEdge().getLine();let i=s;n.getEdgeDirection()||s.isClosed()||(i=ki.reverse(s)),e.add(i)}}return 0===e.size()?this._factory.createMultiLineString(new Array(0).fill(null)):this._factory.buildGeometry(e)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof q){arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Tt&&this.addLine(t)}})}}getClass(){return ki}get interfaces_(){return[]}}ki.constructor_=function(){this._graph=new Vi,this._factory=new Ht,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1};var Xi=Object.freeze({__proto__:null,LineMerger:zi,LineSequencer:ki});class Hi{constructor(){Hi.constructor_.apply(this,arguments)}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,e){const n=this._isClosed?t.size()-1:t.size();for(let s=0;s<n;s++){const n=t.get(s),i=this.findSnapForVertex(n,e);null!==i&&(t.set(s,new g(i)),0===s&&this._isClosed&&t.set(t.size()-1,new g(i)))}}findSnapForVertex(t,e){for(let n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null}snapTo(t){const e=new I(this._srcPts);return this.snapVertices(e,t),this.snapSegments(e,t),e.toCoordinateArray()}snapSegments(t,e){if(0===e.length)return null;let n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(let s=0;s<n;s++){const n=e[s],i=this.findSegmentIndexToSnap(n,t);i>=0&&t.add(i+1,new g(n),!1)}}findSegmentIndexToSnap(t,e){let n=i.MAX_VALUE,s=-1;for(let i=0;i<e.size()-1;i++){if(this._seg.p0=e.get(i),this._seg.p1=e.get(i+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}const r=this._seg.distance(t);r<this._snapTolerance&&r<n&&(n=r,s=i)}return s}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}getClass(){return Hi}get interfaces_(){return[]}}Hi.constructor_=function(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new ee,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Tt&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];Hi.constructor_.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this._srcPts=t,this._isClosed=Hi.isClosed(t),this._snapTolerance=e}};class Wi{constructor(){Wi.constructor_.apply(this,arguments)}static snap(t,e,n){const s=new Array(2).fill(null),i=new Wi(t);s[0]=i.snapTo(e,n);const r=new Wi(e);return s[1]=r.snapTo(s[0],n),s}static computeOverlaySnapTolerance(){if(1===arguments.length){const t=arguments[0];let e=Wi.computeSizeBasedSnapTolerance(t);const n=t.getPrecisionModel();if(n.getType()===kt.FIXED){const t=1/n.getScale()*2/1.415;t>e&&(e=t)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Math.min(Wi.computeOverlaySnapTolerance(t),Wi.computeOverlaySnapTolerance(e))}}static computeSizeBasedSnapTolerance(t){const e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*Wi.SNAP_PRECISION_FACTOR}static snapToSelf(t,e,n){return new Wi(t).snapToSelf(e,n)}snapTo(t,e){const n=this.extractTargetCoordinates(t);return new ji(e,n).transform(this._srcGeom)}snapToSelf(t,e){const n=this.extractTargetCoordinates(this._srcGeom),s=new ji(t,n,!0).transform(this._srcGeom);let i=s;return e&&_(i,Ot)&&(i=s.buffer(0)),i}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){const e=new at,n=t.getCoordinates();for(let t=0;t<n.length;t++)e.add(n[t]);return e.toArray(new Array(0).fill(null))}computeMinimumSegmentLength(t){let e=i.MAX_VALUE;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);s<e&&(e=s)}return e}getClass(){return Wi}get interfaces_(){return[]}}Wi.constructor_=function(){this._srcGeom=null;const t=arguments[0];this._srcGeom=t},Wi.SNAP_PRECISION_FACTOR=1e-9;class ji extends me{constructor(){super(),ji.constructor_.apply(this,arguments)}snapLine(t,e){const n=new Hi(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)}transformCoordinates(t,e){const n=t.toCoordinateArray(),s=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(s)}getClass(){return ji}get interfaces_(){return[]}}ji.constructor_=function(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2===arguments.length){const t=arguments[0],e=arguments[1];this._snapTolerance=t,this._snapPts=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._snapTolerance=t,this._snapPts=e,this._isSelfSnap=n}};var Ki=Object.freeze({__proto__:null,GeometrySnapper:Wi,LineStringSnapper:Hi});class Zi{constructor(){Zi.constructor_.apply(this,arguments)}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Ms.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return Jt.toLineString(new zt(this._pts))}getClass(){return Zi}get interfaces_(){return[Ds]}}Zi.constructor_=function(){this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e};class Qi{constructor(){Qi.constructor_.apply(this,arguments)}static createAllIntersectionsFinder(t){const e=new Qi(t);return e.setFindAllIntersections(!0),e}static createAnyIntersectionFinder(t){return new Qi(t)}static createIntersectionCounter(t){const e=new Qi(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}getInteriorIntersection(){return this._interiorIntersection}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}processIntersections(t,e,n,s){if(!this._findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===s)return null;if(this._isCheckEndSegmentsOnly){if(!(this.isEndSegment(t,e)||this.isEndSegment(n,s)))return null}const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=i,this._intSegments[1]=r,this._intSegments[2]=o,this._intSegments[3]=l,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}isEndSegment(t,e){return 0===e||e>=t.size()-2}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}getClass(){return Qi}get interfaces_(){return[_i]}}Qi.constructor_=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new x,this._intersectionCount=0,this._keepIntersections=!0;const t=arguments[0];this._li=t,this._interiorIntersection=null};class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static computeIntersections(t){const e=new Ji(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new Qi(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);const t=new Ys;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new Wn(this.getErrorMessage(),this._segInt.getInteriorIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";const t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Jt.toLineString(t[0],t[1])+" and "+Jt.toLineString(t[2],t[3])}getClass(){return Ji}get interfaces_(){return[]}}Ji.constructor_=function(){this._li=new te,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;const t=arguments[0];this._segStrings=t};class $i{constructor(){$i.constructor_.apply(this,arguments)}static toSegmentStrings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Zi(t.getCoordinates(),t))}return e}static checkValid(t){new $i(t).checkValid()}checkValid(){this._nv.checkValid()}getClass(){return $i}get interfaces_(){return[]}}$i.constructor_=function(){this._nv=null;const t=arguments[0];this._nv=new Ji($i.toSegmentStrings(t))};class tr{constructor(){tr.constructor_.apply(this,arguments)}collectLines(t){for(let e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){const n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}}labelIsolatedLine(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,e,n){const s=t.getLabel(),i=t.getEdge();t.isLineEdge()&&(t.isVisited()||!cr.isResultOfOp(s,e)||i.isCovered()||(n.add(i),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getEdge();if(e.isLineEdge()&&!n.isCoveredSet()){const t=this._op.isCoveredByA(e.getCoordinate());n.setCovered(t)}}}labelIsolatedLines(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel();t.isIsolated()&&(n.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){const e=t.next(),n=(e.getLabel(),this._geometryFactory.createLineString(e.getCoordinates()));this._resultLineList.add(n),e.setInResult(!0)}}collectBoundaryTouchEdge(t,e,n){const s=t.getLabel();return t.isLineEdge()||t.isVisited()||t.isInteriorAreaEdge()||t.getEdge().isInResult()?null:(u.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(cr.isResultOfOp(s,e)&&e===cr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))}getClass(){return tr}get interfaces_(){return[]}}tr.constructor_=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new x,this._resultLineList=new x;const t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n};class er{constructor(){er.constructor_.apply(this,arguments)}filterCoveredNodeToPoint(t){const e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){const t=this._geometryFactory.createPoint(e);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let e=this._op.getGraph().getNodes().iterator();e.hasNext();){const n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===cr.INTERSECTION))){const e=n.getLabel();cr.isResultOfOp(e,t)&&this.filterCoveredNodeToPoint(n)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}getClass(){return er}get interfaces_(){return[]}}er.constructor_=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new x;const t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e};class nr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new s,this._commonSignExp=null}getCommon(){return i.longBitsToDouble(this._commonBits)}add(t){const e=i.doubleToLongBits(t);return this._isFirst?(this._commonBits=e,this._commonSignExp=nr.signExpBits(this._commonBits),this._isFirst=!1,null):nr.signExpBits(e)!==this._commonSignExp?(this._commonBits.high=0,this._commonBits.low=0,null):(this._commonMantissaBitsCount=nr.numCommonMostSigMantissaBits(this._commonBits,e),void(this._commonBits=nr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))))}toString(){if(1===arguments.length){const t=arguments[0],e=i.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+s.toBinaryString(t),r=n.substring(n.length-64);return r.substring(0,1)+"  "+r.substring(1,12)+"(exp) "+r.substring(12)+" [ "+e+" ]"}}getClass(){return nr}get interfaces_(){return[]}static getBit(t,e){const n=1<<e%32;return e<32?0!=(t.low&n)?1:0:0!=(t.high&n)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,e){let n="low";if(e>32&&(t.low=0,e%=32,n="high"),e>0){const s=e<32?~((1<<e)-1):0;t[n]&=s}return t}static numCommonMostSigMantissaBits(t,e){let n=0;for(let s=52;s>=0;s--){if(nr.getBit(t,s)!==nr.getBit(e,s))return n;n++}return 52}}class sr{constructor(){sr.constructor_.apply(this,arguments)}addCommonBits(t){const e=new rr(this._commonCoord);t.apply(e),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;const e=new g(this._commonCoord);e.x=-e.x,e.y=-e.y;const n=new rr(e);return t.apply(n),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}getClass(){return sr}get interfaces_(){return[]}}class ir{constructor(){ir.constructor_.apply(this,arguments)}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new g(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}getClass(){return ir}get interfaces_(){return[B]}}ir.constructor_=function(){this._commonBitsX=new nr,this._commonBitsY=new nr};class rr{constructor(){rr.constructor_.apply(this,arguments)}filter(t,e){const n=t.getOrdinate(e,0)+this.trans.x,s=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}isDone(){return!1}isGeometryChanged(){return!0}getClass(){return rr}get interfaces_(){return[dt]}}rr.constructor_=function(){this.trans=null;const t=arguments[0];this.trans=t},sr.CommonCoordinateFilter=ir,sr.Translater=rr,sr.constructor_=function(){this._commonCoord=null,this._ccFilter=new ir};class or{constructor(){or.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new or(t,e).getResultGeometry(n)}static union(t,e){return or.overlayOp(t,e,cr.UNION)}static intersection(t,e){return or.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){return or.overlayOp(t,e,cr.SYMDIFFERENCE)}static difference(t,e){return or.overlayOp(t,e,cr.DIFFERENCE)}selfSnap(t){return new Wi(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new sr,this._cbr.add(t[0]),this._cbr.add(t[1]);const e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){const e=this.snap(this._geom),n=cr.overlayOp(e[0],e[1],t);return this.prepareResult(n)}checkValid(t){t.isValid()||O.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=Wi.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){const e=this.removeCommonBits(t);return Wi.snap(e[0],e[1],this._snapTolerance)}getClass(){return or}get interfaces_(){return[]}}or.constructor_=function(){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null;const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()};class lr{constructor(){lr.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new lr(t,e).getResultGeometry(n)}static union(t,e){return lr.overlayOp(t,e,cr.UNION)}static intersection(t,e){return lr.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){return lr.overlayOp(t,e,cr.SYMDIFFERENCE)}static difference(t,e){return lr.overlayOp(t,e,cr.DIFFERENCE)}getResultGeometry(t){let e=null,n=!1,s=null;try{e=cr.overlayOp(this._geom[0],this._geom[1],t),!0&&(n=!0)}catch(t){if(!(t instanceof c))throw t;s=t}if(!n)try{e=or.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof c?s:t}return e}getClass(){return lr}get interfaces_(){return[]}}lr.constructor_=function(){this._geom=new Array(2).fill(null);const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e};class ar{constructor(){ar.constructor_.apply(this,arguments)}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}getClass(){return ar}get interfaces_(){return[]}}ar.constructor_=function(){if(this._li=new te,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Qn(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Qn(0,t,n),this._arg[1]=new Qn(1,e,n)}};class cr extends ar{constructor(){super(),cr.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new cr(t,e).getResultGeometry(n)}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.UNION)}static intersection(t,e){if(t.isEmpty()||e.isEmpty())return cr.createEmptyResult(cr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){const n=e;return ge.map(t,new class{get interfaces_(){return[fe]}map(t){return cr.intersection(t,n)}})}return lr.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.SYMDIFFERENCE)}static resultDimension(t,e,n){const s=e.getDimension(),i=n.getDimension();let r=-1;switch(t){case cr.INTERSECTION:r=Math.min(s,i);break;case cr.UNION:r=Math.max(s,i);break;case cr.DIFFERENCE:r=s;break;case cr.SYMDIFFERENCE:r=Math.max(s,i)}return r}static createEmptyResult(t,e,n,s){let i=null;switch(cr.resultDimension(t,e,n)){case-1:i=s.createGeometryCollection();break;case 0:i=s.createPoint();break;case 1:i=s.createLineString();break;case 2:i=s.createPolygon()}return i}static difference(t,e){if(t.isEmpty())return cr.createEmptyResult(cr.DIFFERENCE,t,e,t.getFactory());if(e.isEmpty())return t.copy();if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.DIFFERENCE)}static isResultOfOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(0),s=t.getLocation(1);return cr.isResultOfOp(n,s,e)}if(3===arguments.length){let t=arguments[0],e=arguments[1];const n=arguments[2];switch(t===ne.BOUNDARY&&(t=ne.INTERIOR),e===ne.BOUNDARY&&(e=ne.INTERIOR),n){case cr.INTERSECTION:return t===ne.INTERIOR&&e===ne.INTERIOR;case cr.UNION:return t===ne.INTERIOR||e===ne.INTERIOR;case cr.DIFFERENCE:return t===ne.INTERIOR&&e!==ne.INTERIOR;case cr.SYMDIFFERENCE:return t===ne.INTERIOR&&e!==ne.INTERIOR||t!==ne.INTERIOR&&e===ne.INTERIOR}return!1}}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Fn(t.getLabel()),s.flip());const i=e.getDepth();i.isNull()&&i.add(n),i.add(s),n.merge(s)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,e,n,s){const i=new x;return i.addAll(t),i.addAll(e),i.addAll(n),i.isEmpty()?cr.createEmptyResult(s,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(i)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}}isCovered(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(this._ptLocator.locate(t,e)!==ne.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){const t=new x;for(let e=this._edgeList.iterator();e.hasNext();){const n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);const e=new x;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),$i.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();const n=new ei(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();const s=new tr(this,this._geomFact,this._ptLocator);this._resultLineList=s.build(t);const i=new er(this,this._geomFact,this._ptLocator);this._resultPointList=i.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)}copyPoints(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let e=this._graph.getEdgeEnds().iterator();e.hasNext();){const n=e.next(),s=n.getLabel();s.isArea()&&!n.isInteriorAreaEdge()&&cr.isResultOfOp(s.getLocation(0,Pn.RIGHT),s.getLocation(1,Pn.RIGHT),t)&&n.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){const e=t.next(),n=e.getLabel(),s=e.getDepth();if(!s.isNull()){s.normalize();for(let t=0;t<2;t++)n.isNull(t)||!n.isArea()||s.isNull(t)||(0===s.getDelta(t)?n.toLine(t):(u.isTrue(!s.isNull(t,Pn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(t,Pn.LEFT,s.getLocation(t,Pn.LEFT)),u.isTrue(!s.isNull(t,Pn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(t,Pn.RIGHT,s.getLocation(t,Pn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}getClass(){return cr}get interfaces_(){return[]}}cr.constructor_=function(){this._ptLocator=new _n,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new di,this._resultPolyList=new x,this._resultLineList=new x,this._resultPointList=new x;const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e),this._graph=new Zn(new ui),this._geomFact=t.getFactory()},cr.INTERSECTION=1,cr.UNION=2,cr.DIFFERENCE=3,cr.SYMDIFFERENCE=4;var hr=Object.freeze({__proto__:null,snap:Ki,OverlayOp:cr});class ur extends bi{constructor(){super(),ur.constructor_.apply(this,arguments)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}getClass(){return ur}get interfaces_(){return[]}}ur.constructor_=function(){this._edgeRing=null,this._next=null,this._label=-1;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];bi.constructor_.call(this,t,e,n,s)};class gr extends Di{constructor(){super(),gr.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return gr}get interfaces_(){return[]}}gr.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class dr{constructor(){dr.constructor_.apply(this,arguments)}static findDifferentPoint(t,e){for(let n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null}visitInteriorRing(t,e){const n=t.getCoordinates(),s=n[0],i=dr.findDifferentPoint(n,s),r=e.findEdgeInSameDirection(s,i),o=e.findEdgeEnd(r);let l=null;o.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR?l=o:o.getSym().getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR&&(l=o.getSym()),u.isTrue(null!==l,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(l)}visitShellInteriors(t,e){if(t instanceof bt){const n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof At){const n=t;for(let t=0;t<n.getNumGeometries();t++){const s=n.getGeometryN(t);this.visitInteriorRing(s.getExteriorRing(),e)}}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let e=t.getEdgeEnds().iterator();e.hasNext();){const t=e.next();t.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const e=t;let n=t;do{u.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext()}while(n!==e)}buildEdgeRings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&null===t.getEdgeRing()){const n=new ti(t,this._geometryFactory);n.linkDirectedEdgesForMinimalEdgeRings();const s=n.buildMinimalRings();e.addAll(s)}}return e}hasUnvisitedShellEdge(t){for(let e=0;e<t.size();e++){const n=t.get(e);if(n.isHole())continue;const s=n.getEdges();let i=s.get(0);if(i.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR)for(let t=0;t<s.size();t++)if(i=s.get(t),!i.isVisited())return this._disconnectedRingcoord=i.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new x;this._geomGraph.computeSplitEdges(t);const e=new Zn(new ui);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();const n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)}getClass(){return dr}get interfaces_(){return[]}}dr.constructor_=function(){this._geometryFactory=new Ht,this._geomGraph=null,this._disconnectedRingcoord=null;const t=arguments[0];this._geomGraph=t};class _r{constructor(){_r.constructor_.apply(this,arguments)}createEdgeEndForNext(t,e,n,s){const i=n.segmentIndex+1;if(i>=t.getNumPoints()&&null===s)return null;let r=t.getCoordinate(i);null!==s&&s.segmentIndex===n.segmentIndex&&(r=s.coord);const o=new Hn(t,n.coord,r,new Fn(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,s){let i=n.segmentIndex;if(0===n.dist){if(0===i)return null;i--}let r=t.getCoordinate(i);null!==s&&s.segmentIndex>=i&&(r=s.coord);const o=new Fn(t.getLabel());o.flip();const l=new Hn(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new x;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const s=n.iterator();let i=null,r=null;if(!s.hasNext())return null;let o=s.next();do{i=r,r=o,o=null,s.hasNext()&&(o=s.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,i),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}getClass(){return _r}get interfaces_(){return[]}}_r.constructor_=function(){};class fr extends Hn{constructor(){super(),fr.constructor_.apply(this,arguments)}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,s=!1;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel().getLocation(t);i===ne.BOUNDARY&&n++,i===ne.INTERIOR&&(s=!0)}let i=ne.NONE;s&&(i=ne.INTERIOR),n>0&&(i=Qn.determineBoundary(e,n)),this._label.setLocation(t,i)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const s=n.next();if(s.getLabel().isArea()){const n=s.getLabel().getLocation(t,e);if(n===ne.INTERIOR)return this._label.setLocation(t,e,ne.INTERIOR),null;n===ne.EXTERIOR&&this._label.setLocation(t,e,ne.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,Pn.LEFT),this.computeLabelSide(t,Pn.RIGHT)}updateIM(t){Un.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new Fn(ne.NONE,ne.NONE,ne.NONE):new Fn(ne.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}getClass(){return fr}get interfaces_(){return[]}}fr.constructor_=function(){if(this._edgeEnds=new x,1===arguments.length){const t=arguments[0];fr.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];Hn.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Fn(t.getLabel())),this.insert(t)}};class pr extends ci{constructor(){super(),pr.constructor_.apply(this,arguments)}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new fr(t),this.insertEdgeEnd(t,e)):e.insert(t)}getClass(){return pr}get interfaces_(){return[]}}pr.constructor_=function(){};class mr extends kn{constructor(){super(),mr.constructor_.apply(this,arguments)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}getClass(){return mr}get interfaces_(){return[]}}mr.constructor_=function(){const t=arguments[0],e=arguments[1];kn.constructor_.call(this,t,e)};class yr extends Kn{constructor(){super(),yr.constructor_.apply(this,arguments)}createNode(t){return new mr(t,new pr)}getClass(){return yr}get interfaces_(){return[]}}yr.constructor_=function(){};class xr{constructor(){xr.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,e){for(let n=t.getNodeIterator();n.hasNext();){const t=n.next();this._nodes.addNode(t.getCoordinate()).setLabel(e,t.getLabel().getLocation(e))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const e=(new _r).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(e)}computeIntersectionNodes(t,e){for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.getLabel().getLocation(e);for(let n=t.getEdgeIntersectionList().iterator();n.hasNext();){const t=n.next(),i=this._nodes.addNode(t.coord);s===ne.BOUNDARY?i.setLabelBoundary(e):i.getLabel().isNull(e)&&i.setLabel(e,ne.INTERIOR)}}}getClass(){return xr}get interfaces_(){return[]}}xr.constructor_=function(){this._nodes=new Xn(new yr)};class Er{constructor(){Er.constructor_.apply(this,arguments)}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){const e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=e.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){for(let e=t.next().getEdges().iterator();e.hasNext();){const t=e.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}}return!1}isNodeConsistentArea(){const t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}getClass(){return Er}get interfaces_(){return[]}}Er.constructor_=function(){this._li=new te,this._geomGraph=null,this._nodeGraph=new xr,this._invalidPoint=null;const t=arguments[0];this._geomGraph=t};class Ir{constructor(){Ir.constructor_.apply(this,arguments)}buildIndex(){this._index=new Es;for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getEnvelopeInternal();this._index.insert(n,e)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getCoordinates(),s=this._index.query(e.getEnvelopeInternal());for(let t=0;t<s.size();t++){const i=s.get(t),r=i.getCoordinates();if(e===i)continue;if(!e.getEnvelopeInternal().intersects(i.getEnvelopeInternal()))continue;const o=Cr.findPtNotNode(n,i,this._graph);if(null!==o&&We.isInRing(o,r))return this._nestedPt=o,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}getClass(){return Ir}get interfaces_(){return[]}}Ir.constructor_=function(){this._graph=null,this._rings=new x,this._totalEnv=new N,this._index=null,this._nestedPt=null;const t=arguments[0];this._graph=t};class Nr{constructor(){Nr.constructor_.apply(this,arguments)}getErrorType(){return this._errorType}getMessage(){return Nr.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}getClass(){return Nr}get interfaces_(){return[]}}Nr.constructor_=function(){if(this._errorType=null,this._pt=null,1===arguments.length){const t=arguments[0];Nr.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._errorType=t,null!==e&&(this._pt=e.copy())}},Nr.ERROR=0,Nr.REPEATED_POINT=1,Nr.HOLE_OUTSIDE_SHELL=2,Nr.NESTED_HOLES=3,Nr.DISCONNECTED_INTERIOR=4,Nr.SELF_INTERSECTION=5,Nr.RING_SELF_INTERSECTION=6,Nr.NESTED_SHELLS=7,Nr.DUPLICATE_RINGS=8,Nr.TOO_FEW_POINTS=9,Nr.INVALID_COORDINATE=10,Nr.RING_NOT_CLOSED=11,Nr.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class Cr{constructor(){Cr.constructor_.apply(this,arguments)}static findPtNotNode(t,e,n){const s=n.findEdge(e).getEdgeIntersectionList();for(let e=0;e<t.length;e++){const n=t[e];if(!s.isIntersection(n))return n}return null}static isValid(){if(arguments[0]instanceof q){const t=arguments[0];return new Cr(t).isValid()}if(arguments[0]instanceof g){const t=arguments[0];return!i.isNaN(t.x)&&(!i.isInfinite(t.x)&&(!i.isNaN(t.y)&&!i.isInfinite(t.y)))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)if(!Cr.isValid(t[e]))return this._validErr=new Nr(Nr.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof bt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,e){const n=new Ir(e);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);n.add(s)}n.isNonNested()||(this._validErr=new Nr(Nr.NESTED_HOLES,n.getNestedPoint()))}checkConsistentArea(t){const e=new Er(t);if(!e.isNodeConsistentArea())return this._validErr=new Nr(Nr.SELF_INTERSECTION,e.getInvalidPoint()),null;e.hasDuplicateRings()&&(this._validErr=new Nr(Nr.DUPLICATE_RINGS,e.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,e,n){const s=t.getCoordinates(),i=e.getCoordinates(),r=Cr.findPtNotNode(s,e,n);if(null!==r){if(!We.isInRing(r,i))return r}const o=Cr.findPtNotNode(i,t,n);if(null!==o){return We.isInRing(o,s)?o:null}return u.shouldNeverReachHere("points in shell and hole appear to be equal"),null}checkNoSelfIntersectingRings(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){const e=new dr(t);e.isInteriorsConnected()||(this._validErr=new Nr(Nr.DISCONNECTED_INTERIOR,e.getCoordinate()))}checkNoSelfIntersectingRing(t){const e=new at;let n=!0;for(let s=t.iterator();s.hasNext();){const t=s.next();if(n)n=!1;else{if(e.contains(t.coord))return this._validErr=new Nr(Nr.RING_SELF_INTERSECTION,t.coord),null;e.add(t.coord)}}}checkHolesInShell(t,e){const n=t.getExteriorRing(),s=new ke(n);for(let i=0;i<t.getNumInteriorRing();i++){const r=t.getInteriorRingN(i),o=Cr.findPtNotNode(r.getCoordinates(),n,e);if(null===o)return null;if(ne.EXTERIOR===s.locate(o))return this._validErr=new Nr(Nr.HOLE_OUTSIDE_SHELL,o),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Nr(Nr.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof Pt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Mt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Dt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;if(this.checkClosedRing(t),null!==this._validErr)return null;const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;const n=new te;e.computeSelfNodes(n,!0,!0),this.checkNoSelfIntersectingRings(e)}else if(arguments[0]instanceof Tt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;const e=new Qn(0,t);this.checkTooFewPoints(e)}else if(arguments[0]instanceof bt){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr)return null;if(this.checkClosedRings(t),null!==this._validErr)return null;const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;if(this.checkHolesInShell(t,e),null!==this._validErr)return null;if(this.checkHolesNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof At){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkInvalidCoordinates(n),null!==this._validErr)return null;if(this.checkClosedRings(n),null!==this._validErr)return null}const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesInShell(s,e),null!==this._validErr)return null}for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesNotNested(s,e),null!==this._validErr)return null}if(this.checkShellsNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof _t){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkValid(n),null!==this._validErr)return null}}else if(arguments[0]instanceof q){const t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof Pt)this.checkValid(t);else if(t instanceof Mt)this.checkValid(t);else if(t instanceof Dt)this.checkValid(t);else if(t instanceof Tt)this.checkValid(t);else if(t instanceof bt)this.checkValid(t);else if(t instanceof At)this.checkValid(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,e,n){const s=t.getCoordinates(),i=e.getExteriorRing(),r=i.getCoordinates(),o=Cr.findPtNotNode(s,i,n);if(null===o)return null;if(!We.isInRing(o,r))return null;if(e.getNumInteriorRing()<=0)return this._validErr=new Nr(Nr.NESTED_SHELLS,o),null;let l=null;for(let s=0;s<e.getNumInteriorRing();s++){const i=e.getInteriorRingN(s);if(l=this.checkShellInsideHole(t,i,n),null===l)return null}this._validErr=new Nr(Nr.NESTED_SHELLS,l)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this._validErr)return null}checkClosedRing(t){if(!t.isClosed()){let e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this._validErr=new Nr(Nr.RING_NOT_CLOSED,e)}}checkShellsNotNested(t,e){for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getExteriorRing();for(let i=0;i<t.getNumGeometries();i++){if(n===i)continue;const r=t.getGeometryN(i);if(this.checkShellNotNested(s,r,e),null!==this._validErr)return null}}}getClass(){return Cr}get interfaces_(){return[]}}Cr.constructor_=function(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;const t=arguments[0];this._parentGeometry=t};class Sr{constructor(){Sr.constructor_.apply(this,arguments)}static findDirEdgesInRing(t){let e=t;const n=new x;do{n.add(e),e=e.getNext(),u.isTrue(null!==e,"found null DE in ring"),u.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t);return n}static addEdge(t,e,n){if(e)for(let e=0;e<t.length;e++)n.add(t[e],!1);else for(let e=t.length-1;e>=0;e--)n.add(t[e],!1)}static findEdgeRingContaining(t,e){const n=t.getRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getRing(),a=l.getEnvelopeInternal();if(a.equals(s))continue;if(!a.contains(s))continue;i=X.ptNotInList(n.getCoordinates(),l.getCoordinates());let c=!1;We.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===r||o.contains(a))&&(r=e,o=r.getRing().getEnvelopeInternal())}return r}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){const t=new I;for(let e=this._deList.iterator();e.hasNext();){const n=e.next(),s=n.getEdge();Sr.addEdge(s.getLine().getCoordinates(),n.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Cr.isValid(this._ring))}build(t){let e=t;do{this.add(e),e.setRing(this),e=e.getNext(),u.isTrue(null!==e,"found null DE in ring"),u.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=new Array(this._holes.size()).fill(null);for(let e=0;e<this._holes.size();e++)t[e]=this._holes.get(e)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof Dt){const t=arguments[0];null===this._holes&&(this._holes=new x),this._holes.add(t)}else if(arguments[0]instanceof Sr){const t=arguments[0];t.setShell(this);const e=t.getRing();null===this._holes&&(this._holes=new x),this._holes.add(e)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing();if(e.isOuterHole())return e}return null}computeHole(){const t=this.getRing();this._isHole=v.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return Jt.toLineString(new zt(this.getCoordinates()))}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&O.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof C))throw t;O.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing().getShell();if(null!==e&&e.isIncludedSet())return this.setIncluded(!e.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}getClass(){return Sr}get interfaces_(){return[]}}class wr{constructor(){wr.constructor_.apply(this,arguments)}compare(t,e){const n=e;return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())}getClass(){return wr}get interfaces_(){return[l]}}wr.constructor_=function(){},Sr.EnvelopeComparator=wr,Sr.constructor_=function(){this._factory=null,this._deList=new x,this._lowestEdge=null,this._ring=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;const t=arguments[0];this._factory=t};class Lr extends Bi{constructor(){super(),Lr.constructor_.apply(this,arguments)}static findLabeledEdgeRings(t){const e=new x;let n=1;for(let s=t.iterator();s.hasNext();){const t=s.next();if(t.isMarked())continue;if(t.getLabel()>=0)continue;e.add(t);const i=Sr.findDirEdgesInRing(t);Lr.label(i,n),n++}return e}static getDegreeNonDeleted(t){let e=0;for(let n=t.getOutEdges().getEdges().iterator();n.hasNext();){n.next().isMarked()||e++}return e}static deleteAllEdges(t){for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next();t.setMarked(!0);const n=t.getSym();null!==n&&n.setMarked(!0)}}static label(t,e){for(let n=t.iterator();n.hasNext();){n.next().setLabel(e)}}static computeNextCWEdges(t){let e=null,n=null;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();if(!t.isMarked()){if(null===e&&(e=t),null!==n){n.getSym().setNext(t)}n=t}}if(null!==n){n.getSym().setNext(e)}}static computeNextCCWEdges(t,e){let n=null,s=null;const i=t.getOutEdges().getEdges();for(let t=i.size()-1;t>=0;t--){const r=i.get(t),o=r.getSym();let l=null;r.getLabel()===e&&(l=r);let a=null;o.getLabel()===e&&(a=o),null===l&&null===a||(null!==a&&(s=a),null!==l&&(null!==s&&(s.setNext(l),s=null),null===n&&(n=l)))}null!==s&&(u.isTrue(null!==n),s.setNext(n))}static getDegree(t,e){let n=0;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){s.next().getLabel()===e&&n++}return n}static findIntersectionNodes(t,e){let n=t,s=null;do{const i=n.getFromNode();Lr.getDegree(i,e)>1&&(null===s&&(s=new x),s.add(i)),n=n.getNext(),u.isTrue(null!==n,"found null DE in ring"),u.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return s}findEdgeRing(t){const e=new Sr(this._factory);return e.build(t),e}computeDepthParity(){if(0===arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){const e=t.next();Lr.computeNextCWEdges(e)}}addEdge(t){if(t.isEmpty())return null;const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new ur(i,r,e[1],!0),l=new ur(r,i,e[e.length-2],!1),a=new gr(t);a.setDirectedEdges(o,l),this.add(a)}deleteCutEdges(){this.computeNextCWEdges(),Lr.findLabeledEdgeRings(this._dirEdges);const t=new x;for(let e=this._dirEdges.iterator();e.hasNext();){const n=e.next();if(n.isMarked())continue;const s=n.getSym();if(n.getLabel()===s.getLabel()){n.setMarked(!0),s.setMarked(!0);const e=n.getEdge();t.add(e.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),Lr.label(this._dirEdges,-1);const t=Lr.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);const e=new x;for(let t=this._dirEdges.iterator();t.hasNext();){const n=t.next();if(n.isMarked())continue;if(n.isInRing())continue;const s=this.findEdgeRing(n);e.add(s)}return e}getNode(t){let e=this.findNode(t);return null===e&&(e=new Fi(t),this.add(e)),e}convertMaximalToMinimalEdgeRings(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel(),s=Lr.findIntersectionNodes(t,n);if(null!==s)for(let t=s.iterator();t.hasNext();){const e=t.next();Lr.computeNextCCWEdges(e,n)}}}deleteDangles(){const t=this.findNodesOfDegree(1),e=new J,n=new on;for(let e=t.iterator();e.hasNext();)n.push(e.next());for(;!n.isEmpty();){const t=n.pop();Lr.deleteAllEdges(t);for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();t.setMarked(!0);const i=t.getSym();null!==i&&i.setMarked(!0);const r=t.getEdge();e.add(r.getLine());const o=t.getToNode();1===Lr.getDegreeNonDeleted(o)&&n.push(o)}}return e}getClass(){return Lr}get interfaces_(){return[]}}Lr.constructor_=function(){this._factory=null;const t=arguments[0];this._factory=t};class Tr{constructor(){Tr.constructor_.apply(this,arguments)}static findOuterShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getOuterHole();null===n||n.isProcessed()||(t.setIncluded(!0),n.setProcessed(!0))}}static extractPolygons(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next();(e||t.isIncluded())&&n.add(t.getPolygon())}return n}static assignHolesToShells(t,e){for(let n=t.iterator();n.hasNext();){const t=n.next();Tr.assignHoleToShell(t,e)}}static assignHoleToShell(t,e){const n=Sr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)}static findDisjointShells(t){Tr.findOuterShells(t);let e=null;do{e=!1;for(let n=t.iterator();n.hasNext();){const t=n.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(e=!0))}}while(e)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Ht),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Ht.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isValid()?e.add(t):n.add(t.getLineString())}}polygonize(){if(null!==this._polyList)return null;if(this._polyList=new x,null===this._graph)return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();const t=this._graph.getEdgeRings();let e=new x;this._invalidRingLines=new x,this._isCheckingRingsValid?this.findValidRings(t,e,this._invalidRingLines):e=t,this.findShellsAndHoles(e),Tr.assignHolesToShells(this._holeList,this._shellList),Ee.sort(this._shellList,new Sr.EnvelopeComparator);let n=!0;this._extractOnlyPolygonal&&(Tr.findDisjointShells(this._shellList),n=!1),this._polyList=Tr.extractPolygons(this._shellList,n)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof Tt){const t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new Lr(this._geomFactory)),this._graph.addEdge(t)}else if(arguments[0]instanceof q){arguments[0].apply(this._lineStringAdder)}}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new x,this._shellList=new x;for(let e=t.iterator();e.hasNext();){const t=e.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}getClass(){return Tr}get interfaces_(){return[]}}class Rr{constructor(){Rr.constructor_.apply(this,arguments)}filter(t){t instanceof Tt&&this.p.add(t)}getClass(){return Rr}get interfaces_(){return[G]}}Rr.constructor_=function(){this.p=null;const t=arguments[0];this.p=t},Tr.LineStringAdder=Rr,Tr.constructor_=function(){if(this._lineStringAdder=new Rr(this),this._graph=null,this._dangles=new x,this._cutEdges=new x,this._invalidRingLines=new x,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0===arguments.length)Tr.constructor_.call(this,!1);else if(1===arguments.length){const t=arguments[0];this._extractOnlyPolygonal=t}};var Pr=Object.freeze({__proto__:null,Polygonizer:Tr});class vr{constructor(){vr.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),s=this._arg[1].getGeometry().getDimension(),i=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===s?i&&e.setAtLeast("212101212"):2===n&&1===s?(i&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===s?(i&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===s&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const s=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,s)}else t.getLabel().setAllLocations(e,ne.EXTERIOR)}computeIM(){const t=new se;if(t.set(ne.EXTERIOR,ne.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new _r,s=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(s);const i=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(i),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.find(n.coord);i.getLabel().isNull(t)&&(s===ne.BOUNDARY?i.setLabelBoundary(t):i.setLabel(t,ne.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.addNode(n.coord);s===ne.BOUNDARY?i.setLabelBoundary(t):i.getLabel().isNull(t)&&i.setLabel(t,ne.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();u.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(ne.INTERIOR,ne.EXTERIOR,e.getDimension()),t.set(ne.BOUNDARY,ne.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(ne.EXTERIOR,ne.INTERIOR,n.getDimension()),t.set(ne.EXTERIOR,ne.BOUNDARY,n.getBoundaryDimension()))}getClass(){return vr}get interfaces_(){return[]}}vr.constructor_=function(){this._li=new te,this._ptLocator=new _n,this._arg=null,this._nodes=new Xn(new yr),this._im=null,this._isolatedEdges=new x,this._invalidPoint=null;const t=arguments[0];this._arg=t};class Or{constructor(){Or.constructor_.apply(this,arguments)}static contains(t,e){return new Or(t).contains(e)}isContainedInBoundary(t){if(t instanceof bt)return!1;if(t instanceof Pt)return this.isPointContainedInBoundary(t);if(t instanceof Tt)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new g,s=new g;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,s),!this.isLineSegmentContainedInBoundary(n,s))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof Pt){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}getClass(){return Or}get interfaces_(){return[]}}Or.constructor_=function(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()};class br{constructor(){br.constructor_.apply(this,arguments)}intersects(t,e){const n=new N(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let s=!1;return e.y>t.y&&(s=!0),s?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}getClass(){return br}get interfaces_(){return[]}}br.constructor_=function(){this._li=new te,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new g(t.getMinX(),t.getMinY()),this._diagUp1=new g(t.getMaxX(),t.getMaxY()),this._diagDown0=new g(t.getMinX(),t.getMaxY()),this._diagDown1=new g(t.getMaxX(),t.getMinY())};class Mr{constructor(){Mr.constructor_.apply(this,arguments)}static intersects(t,e){return new Mr(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Dr(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new Ar(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const s=new Fr(this._rectangle);return s.applyTo(t),!!s.intersects()}getClass(){return Mr}get interfaces_(){return[]}}Mr.constructor_=function(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()};class Dr extends Ce{constructor(){super(),Dr.constructor_.apply(this,arguments)}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}getClass(){return Dr}get interfaces_(){return[]}}Dr.constructor_=function(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t};class Ar extends Ce{constructor(){super(),Ar.constructor_.apply(this,arguments)}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof bt))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new g;for(let s=0;s<4;s++)if(this._rectSeq.getCoordinate(s,n),e.contains(n)&&Ze.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}getClass(){return Ar}get interfaces_(){return[]}}Ar.constructor_=function(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()};class Fr extends Ce{constructor(){super(),Fr.constructor_.apply(this,arguments)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=xe.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}getClass(){return Fr}get interfaces_(){return[]}}Fr.constructor_=function(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new g,this._p1=new g;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new br(this._rectEnv)};class Gr extends ar{constructor(){super(),Gr.constructor_.apply(this,arguments)}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Gr(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Mr.intersects(t,e);if(e.isRectangle())return Mr.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let s=0;s<e.getNumGeometries();s++)if(t.getGeometryN(n).intersects(e.getGeometryN(s)))return!0;return!1}return new Gr(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Gr.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Gr(t,e).getIntersectionMatrix()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new Gr(t,e,n).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Or.contains(t,e):new Gr(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}getClass(){return Gr}get interfaces_(){return[]}}Gr.constructor_=function(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e),this._relate=new vr(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];ar.constructor_.call(this,t,e,n),this._relate=new vr(this._arg)}};var qr=Object.freeze({__proto__:null,RelateOp:Gr});class Br{constructor(){Br.constructor_.apply(this,arguments)}static union(t,e){return new Br(t,e).union()}union(){const t=new _n,e=new at;for(let n=0;n<this._pointGeom.getNumGeometries();n++){const s=this._pointGeom.getGeometryN(n).getCoordinate();t.locate(s,this._otherGeom)===ne.EXTERIOR&&e.add(s)}if(0===e.size())return this._otherGeom;let n=null;const s=X.toCoordinateArray(e);return n=1===s.length?this._geomFact.createPoint(s[0]):this._geomFact.createMultiPointFromCoords(s),de.combine(n,this._otherGeom)}getClass(){return Br}get interfaces_(){return[]}}Br.constructor_=function(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;const t=arguments[0],e=arguments[1];this._pointGeom=t,this._otherGeom=e,this._geomFact=e.getFactory()};class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static restrictToPolygons(t){if(_(t,Ot))return t;const e=Ne.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(Ht.toPolygonArray(e))}static getGeometry(t,e){return e>=t.size()?null:t.get(e)}static union(t){return new Vr(t).union()}reduceToGeometries(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();let s=null;_(t,m)?s=this.unionTree(t):t instanceof q&&(s=t),e.add(s)}return e}extractByEnvelope(t,e,n){const s=new x;for(let i=0;i<e.getNumGeometries();i++){const r=e.getGeometryN(i);r.getEnvelopeInternal().intersects(t)?s.add(r):n.add(r)}return this._geomFactory.buildGeometry(s)}unionOptimized(t,e){const n=t.getEnvelopeInternal(),s=e.getEnvelopeInternal();if(!n.intersects(s)){return de.combine(t,e)}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);const i=n.intersection(s);return this.unionUsingEnvelopeIntersection(t,e,i)}union(){if(null===this._inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();const t=new Es(Vr.STRTREE_NODE_CAPACITY);for(let e=this._inputPolys.iterator();e.hasNext();){const n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;const e=t.itemsTree();return this.unionTree(e)}binaryUnion(){if(1===arguments.length){const t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(n-e<=1){const n=Vr.getGeometry(t,e);return this.unionSafe(n,null)}if(n-e==2)return this.unionSafe(Vr.getGeometry(t,e),Vr.getGeometry(t,e+1));{const s=Math.trunc((n+e)/2),i=this.binaryUnion(t,e,s),r=this.binaryUnion(t,s,n);return this.unionSafe(i,r)}}}repeatedUnion(t){let e=null;for(let n=t.iterator();n.hasNext();){const t=n.next();e=null===e?t.copy():e.union(t)}return e}unionSafe(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)}unionActual(t,e){return Vr.restrictToPolygons(t.union(e))}unionTree(t){const e=this.reduceToGeometries(t);return this.binaryUnion(e)}unionUsingEnvelopeIntersection(t,e,n){const s=new x,i=this.extractByEnvelope(n,t,s),r=this.extractByEnvelope(n,e,s),o=this.unionActual(i,r);return s.add(o),de.combine(s)}bufferUnion(){if(1===arguments.length){const t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().createGeometryCollection([t,e]).buffer(0)}}getClass(){return Vr}get interfaces_(){return[]}}Vr.constructor_=function(){this._inputPolys=null,this._geomFactory=null;const t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new x)},Vr.STRTREE_NODE_CAPACITY=4;class zr{constructor(){zr.constructor_.apply(this,arguments)}static union(){if(1===arguments.length){if(_(arguments[0],f)){const t=arguments[0];return new zr(t).union()}if(arguments[0]instanceof q){const t=arguments[0];return new zr(t).union()}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return new zr(t,e).union()}}unionNoOpt(t){const e=this._geomFact.createPoint();return lr.overlayOp(t,e,cr.UNION)}unionWithNull(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)}extract(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.extract(e)}}else if(arguments[0]instanceof q){const t=arguments[0];null===this._geomFact&&(this._geomFact=t.getFactory()),_e.extract(t,q.TYPENAME_POLYGON,this._polygons),_e.extract(t,q.TYPENAME_LINESTRING,this._lines),_e.extract(t,q.TYPENAME_POINT,this._points)}}union(){if(null===this._geomFact)return null;let t=null;if(this._points.size()>0){const e=this._geomFact.buildGeometry(this._points);t=this.unionNoOpt(e)}let e=null;if(this._lines.size()>0){const t=this._geomFact.buildGeometry(this._lines);e=this.unionNoOpt(t)}let n=null;this._polygons.size()>0&&(n=Vr.union(this._polygons));const s=this.unionWithNull(e,n);let i=null;return i=null===t?s:null===s?t:Br.union(t,s),null===i?this._geomFact.createGeometryCollection():i}getClass(){return zr}get interfaces_(){return[]}}zr.constructor_=function(){if(this._polygons=new x,this._lines=new x,this._points=new x,this._geomFact=null,1===arguments.length){if(_(arguments[0],f)){const t=arguments[0];this.extract(t)}else if(arguments[0]instanceof q){const t=arguments[0];this.extract(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geomFact=e,this.extract(t)}};var Yr=Object.freeze({__proto__:null,UnaryUnionOp:zr}),Ur=Object.freeze({__proto__:null,IsValidOp:Cr,ConsistentAreaTester:Er}),kr=Object.freeze({__proto__:null,BoundaryOp:pt,IsSimpleOp:Hs,buffer:wi,distance:Pi,linemerge:Xi,overlay:hr,polygonize:Pr,relate:qr,union:Yr,valid:Ur});class Xr extends Ft.CoordinateOperation{constructor(){super(),Xr.constructor_.apply(this,arguments)}edit(){if(2===arguments.length&&arguments[1]instanceof q&&arguments[0]instanceof Array){const t=arguments[0],e=arguments[1];if(0===t.length)return null;const n=new Array(t.length).fill(null);for(let e=0;e<t.length;e++){const s=new g(t[e]);this._targetPM.makePrecise(s),n[e]=s}const s=new I(n,!1).toCoordinateArray();let i=0;e instanceof Tt&&(i=2),e instanceof Dt&&(i=4);let r=n;return this._removeCollapsed&&(r=null),s.length<i?r:s}return super.edit.apply(this,arguments)}getClass(){return Xr}get interfaces_(){return[]}}Xr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0;const t=arguments[0],e=arguments[1];this._targetPM=t,this._removeCollapsed=e};class Hr{constructor(){Hr.constructor_.apply(this,arguments)}static reduce(t,e){return new Hr(e).reduce(t)}static reducePointwise(t,e){const n=new Hr(e);return n.setPointwise(!0),n.reduce(t)}fixPolygonalTopology(t){let e=t;this._changePrecisionModel||(e=this.changePM(t,this._targetPM));const n=Si.bufferOp(e,0);let s=n;return this._changePrecisionModel||(s=t.getFactory().createGeometry(n)),s}reducePointwise(t){let e=null;if(this._changePrecisionModel){const n=this.createFactory(t.getFactory(),this._targetPM);e=new Ft(n)}else e=new Ft;let n=this._removeCollapsed;return t.getDimension()>=2&&(n=!0),e.edit(t,new Xr(this._targetPM,n))}changePM(t,e){return this.createEditor(t.getFactory(),e).edit(t,new Ft.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,e){return new Ht(e,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){const e=this.reducePointwise(t);return this._isPointwise?e:_(e,Ot)?Cr.isValid(e)?e:this.fixPolygonalTopology(e):e}setPointwise(t){this._isPointwise=t}createEditor(t,e){if(t.getPrecisionModel()===e)return new Ft;const n=this.createFactory(t,e);return new Ft(n)}getClass(){return Hr}get interfaces_(){return[]}}Hr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;const t=arguments[0];this._targetPM=t};var Wr=Object.freeze({__proto__:null,GeometryPrecisionReducer:Hr});class jr{constructor(){jr.constructor_.apply(this,arguments)}static simplify(t,e){const n=new jr(t);return n.setDistanceTolerance(e),n.simplify()}simplifySection(t,e){if(t+1===e)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[e];let n=-1,s=t;for(let i=t+1;i<e;i++){const t=this._seg.distance(this._pts[i]);t>n&&(n=t,s=i)}if(n<=this._distanceTolerance)for(let n=t+1;n<e;n++)this._usePt[n]=!1;else this.simplifySection(t,s),this.simplifySection(s,e)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=new Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);const t=new I;for(let e=0;e<this._pts.length;e++)this._usePt[e]&&t.add(new g(this._pts[e]));return t.toCoordinateArray()}getClass(){return jr}get interfaces_(){return[]}}jr.constructor_=function(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new ee;const t=arguments[0];this._pts=t};class Kr{constructor(){Kr.constructor_.apply(this,arguments)}static simplify(t,e){const n=new Kr(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Zr(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return Kr}get interfaces_(){return[]}}class Zr extends me{constructor(){super(),Zr.constructor_.apply(this,arguments)}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):jr.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof bt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof Dt?s:null}getClass(){return Zr}get interfaces_(){return[]}}Zr.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e},Kr.DPTransformer=Zr,Kr.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t};class Qr extends ee{constructor(){super(),Qr.constructor_.apply(this,arguments)}getIndex(){return this._index}getParent(){return this._parent}getClass(){return Qr}get interfaces_(){return[]}}Qr.constructor_=function(){if(this._parent=null,this._index=null,2===arguments.length){const t=arguments[0],e=arguments[1];Qr.constructor_.call(this,t,e,null,-1)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ee.constructor_.call(this,t,e),this._parent=n,this._index=s}};class Jr{constructor(){Jr.constructor_.apply(this,arguments)}static extractCoordinates(t){const e=new Array(t.size()+1).fill(null);let n=null;for(let s=0;s<t.size();s++)n=t.get(s),e[s]=n.p0;return e[e.length-1]=n.p1,e}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString(Jr.extractCoordinates(this._resultSegs))}getResultSize(){const t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing(Jr.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){const t=this._parentLine.getCoordinates();this._segs=new Array(t.length-1).fill(null);for(let e=0;e<t.length-1;e++){const n=new Qr(t[e],t[e+1],this._parentLine,e);this._segs[e]=n}}getResultCoordinates(){return Jr.extractCoordinates(this._resultSegs)}getClass(){return Jr}get interfaces_(){return[]}}Jr.constructor_=function(){if(this._parentLine=null,this._segs=null,this._resultSegs=new x,this._minimumSize=null,1===arguments.length){const t=arguments[0];Jr.constructor_.call(this,t,2)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._parentLine=t,this._minimumSize=e,this.init()}};class $r{constructor(){$r.constructor_.apply(this,arguments)}remove(t){this._index.remove(new N(t.p0,t.p1),t)}add(){if(arguments[0]instanceof Jr){const t=arguments[0].getSegments();for(let e=0;e<t.length;e++){const n=t[e];this.add(n)}}else if(arguments[0]instanceof ee){const t=arguments[0];this._index.insert(new N(t.p0,t.p1),t)}}query(t){const e=new N(t.p0,t.p1),n=new to(t);return this._index.query(e,n),n.getItems()}getClass(){return $r}get interfaces_(){return[]}}$r.constructor_=function(){this._index=new us};class to{constructor(){to.constructor_.apply(this,arguments)}visitItem(t){const e=t;N.intersects(e.p0,e.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}getClass(){return to}get interfaces_(){return[Ae]}}to.constructor_=function(){this._querySeg=null,this._items=new x;const t=arguments[0];this._querySeg=t};class eo{constructor(){eo.constructor_.apply(this,arguments)}static isInLineSection(t,e,n){if(n.getParent()!==t.getParent())return!1;const s=n.getIndex();return s>=e[0]&&s<e[1]}flatten(t,e){const n=this._linePts[t],s=this._linePts[e],i=new ee(n,s);return this.remove(this._line,t,e),this._outputIndex.add(i),i}hasBadIntersection(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,e,n){n+=1;const s=new Array(2).fill(null);if(t+1===e){const e=this._line.getSegment(t);return this._line.addToResult(e),null}let i=!0;if(this._line.getResultSize()<this._line.getMinimumSize()){n+1<this._line.getMinimumSize()&&(i=!1)}const r=new Array(1).fill(null),o=this.findFurthestPoint(this._linePts,t,e,r);r[0]>this._distanceTolerance&&(i=!1);const l=new ee;if(l.p0=this._linePts[t],l.p1=this._linePts[e],s[0]=t,s[1]=e,this.hasBadIntersection(this._line,s,l)&&(i=!1),i){const n=this.flatten(t,e);return this._line.addToResult(n),null}this.simplifySection(t,o,n),this.simplifySection(o,e,n)}hasBadOutputIntersection(t){for(let e=this._outputIndex.query(t).iterator();e.hasNext();){const n=e.next();if(this.hasInteriorIntersection(n,t))return!0}return!1}findFurthestPoint(t,e,n,s){const i=new ee;i.p0=t[e],i.p1=t[n];let r=-1,o=e;for(let s=e+1;s<n;s++){const e=t[s],n=i.distance(e);n>r&&(r=n,o=s)}return s[0]=r,o}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,e,n){for(let s=e;s<n;s++){const e=t.getSegment(s);this._inputIndex.remove(e)}}hasInteriorIntersection(t,e){return this._li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,e,n){for(let s=this._inputIndex.query(n).iterator();s.hasNext();){const i=s.next();if(this.hasInteriorIntersection(i,n)){if(eo.isInLineSection(t,e,i))continue;return!0}}return!1}getClass(){return eo}get interfaces_(){return[]}}eo.constructor_=function(){this._li=new te,this._inputIndex=new $r,this._outputIndex=new $r,this._line=null,this._linePts=null,this._distanceTolerance=0;const t=arguments[0],e=arguments[1];this._inputIndex=t,this._outputIndex=e};class no{constructor(){no.constructor_.apply(this,arguments)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let e=t.iterator();e.hasNext();)this._inputIndex.add(e.next());for(let e=t.iterator();e.hasNext();){const t=new eo(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(e.next())}}getClass(){return no}get interfaces_(){return[]}}no.constructor_=function(){this._inputIndex=new $r,this._outputIndex=new $r,this._distanceTolerance=0};class so{constructor(){so.constructor_.apply(this,arguments)}static simplify(t,e){const n=new so(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){if(this._inputGeom.isEmpty())return this._inputGeom.copy();return this._linestringMap=new Ut,this._inputGeom.apply(new ro(this)),this._lineSimplifier.simplify(this._linestringMap.values()),new io(this._linestringMap).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}getClass(){return so}get interfaces_(){return[]}}class io extends me{constructor(){super(),io.constructor_.apply(this,arguments)}transformCoordinates(t,e){if(0===t.size())return null;if(e instanceof Tt){const t=this._linestringMap.get(e);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,e)}getClass(){return io}get interfaces_(){return[]}}io.constructor_=function(){this._linestringMap=null;const t=arguments[0];this._linestringMap=t};class ro{constructor(){ro.constructor_.apply(this,arguments)}filter(t){if(t instanceof Tt){const e=t;if(e.isEmpty())return null;const n=e.isClosed()?4:2,s=new Jr(e,n);this.tps._linestringMap.put(e,s)}}getClass(){return ro}get interfaces_(){return[G]}}ro.constructor_=function(){this.tps=null;const t=arguments[0];this.tps=t},so.LineStringTransformer=io,so.LineStringMapBuilderFilter=ro,so.constructor_=function(){this._inputGeom=null,this._lineSimplifier=new no,this._linestringMap=null;const t=arguments[0];this._inputGeom=t};class oo{constructor(){oo.constructor_.apply(this,arguments)}static simplify(t,e){return new oo(t,e).simplify()}simplifyVertex(t){let e=t,n=e.getArea(),s=null;for(;null!==e;){const t=e.getArea();t<n&&(n=t,s=e),e=e._next}return null!==s&&n<this._tolerance&&s.remove(),t.isLive()?n:-1}simplify(){const t=lo.buildLine(this._pts);let e=this._tolerance;do{e=this.simplifyVertex(t)}while(e<this._tolerance);const n=t.getCoordinates();return n.length<2?[n[0],new g(n[0])]:n}getClass(){return oo}get interfaces_(){return[]}}class lo{constructor(){lo.constructor_.apply(this,arguments)}static buildLine(t){let e=null,n=null;for(let s=0;s<t.length;s++){const i=new lo(t[s]);null===e&&(e=i),i.setPrev(n),null!==n&&(n.setNext(i),n.updateArea()),n=i}return e}getCoordinates(){const t=new I;let e=this;do{t.add(e._pt,!1),e=e._next}while(null!==e);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=lo.MAX_AREA,null;this._area=Math.abs(re.area(this._prev._pt,this._pt,this._next._pt))}remove(){const t=this._prev,e=this._next;let n=null;return null!==this._prev&&(this._prev.setNext(e),this._prev.updateArea(),n=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===n&&(n=this._next)),this._isLive=!1,n}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}getClass(){return lo}get interfaces_(){return[]}}lo.constructor_=function(){this._pt=null,this._prev=null,this._next=null,this._area=lo.MAX_AREA,this._isLive=!0;const t=arguments[0];this._pt=t},lo.MAX_AREA=i.MAX_VALUE,oo.VWVertex=lo,oo.constructor_=function(){this._pts=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._pts=t,this._tolerance=e*e};class ao{constructor(){ao.constructor_.apply(this,arguments)}static simplify(t,e){const n=new ao(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new co(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return ao}get interfaces_(){return[]}}class co extends me{constructor(){super(),co.constructor_.apply(this,arguments)}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):oo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof bt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof Dt?s:null}getClass(){return co}get interfaces_(){return[]}}co.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e},ao.VWTransformer=co,ao.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t};var ho=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:Kr,TopologyPreservingSimplifier:so,VWSimplifier:ao});class uo{constructor(){uo.constructor_.apply(this,arguments)}static pointAlongReverse(t,e){const n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n}splitAt(){if(1===arguments.length){const t=arguments[0],e=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(e),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=uo.pointAlongReverse(this._seg,e),null;this._splitPt=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this.getConstrainedLength(t)/this._segLen;e.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(n):this._splitPt=uo.pointAlongReverse(this._seg,n)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}getClass(){return uo}get interfaces_(){return[]}}uo.constructor_=function(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;const t=arguments[0];this._seg=t,this._segLen=t.getLength()};class go{constructor(){go.constructor_.apply(this,arguments)}findSplitPoint(t,e){}getClass(){return go}get interfaces_(){return[]}}go.constructor_=function(){};class _o{constructor(){_o.constructor_.apply(this,arguments)}static projectedSplitPoint(t,e){return t.getLineSegment().project(e)}findSplitPoint(t,e){const n=t.getLineSegment(),s=n.getLength()/2,i=new uo(n),r=_o.projectedSplitPoint(t,e);let o=2*r.distance(e)*.8;return o>s&&(o=s),i.setMinimumLength(o),i.splitAt(r),i.getSplitPoint()}getClass(){return _o}get interfaces_(){return[go]}}_o.constructor_=function(){};class fo{constructor(){fo.constructor_.apply(this,arguments)}static triArea(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static isInCircleDDNormalized(t,e,n,s){const i=R.valueOf(t.x).selfSubtract(s.x),r=R.valueOf(t.y).selfSubtract(s.y),o=R.valueOf(e.x).selfSubtract(s.x),l=R.valueOf(e.y).selfSubtract(s.y),a=R.valueOf(n.x).selfSubtract(s.x),c=R.valueOf(n.y).selfSubtract(s.y),h=i.multiply(l).selfSubtract(o.multiply(r)),u=o.multiply(c).selfSubtract(a.multiply(l)),g=a.multiply(r).selfSubtract(i.multiply(c)),d=i.multiply(i).selfAdd(r.multiply(r)),_=o.multiply(o).selfAdd(l.multiply(l)),f=a.multiply(a).selfAdd(c.multiply(c));return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(f.selfMultiply(h)).doubleValue()>0}static checkRobustInCircle(t,e,n,s){const i=fo.isInCircleNonRobust(t,e,n,s),r=fo.isInCircleDDSlow(t,e,n,s),o=fo.isInCircleCC(t,e,n,s),l=re.circumcentre(t,e,n);O.out.println("p radius diff a = "+Math.abs(s.distance(l)-t.distance(l))/t.distance(l)),i===r&&i===o||(O.out.println("inCircle robustness failure (double result = "+i+", DD result = "+r+", CC result = "+o+")"),O.out.println(Jt.toLineString(new zt([t,e,n,s]))),O.out.println("Circumcentre = "+Jt.toPoint(l)+" radius = "+t.distance(l)),O.out.println("p radius diff a = "+Math.abs(s.distance(l)/t.distance(l)-1)),O.out.println("p radius diff b = "+Math.abs(s.distance(l)/e.distance(l)-1)),O.out.println("p radius diff c = "+Math.abs(s.distance(l)/n.distance(l)-1)),O.out.println())}static isInCircleDDFast(t,e,n,s){const i=R.sqr(t.x).selfAdd(R.sqr(t.y)).selfMultiply(fo.triAreaDDFast(e,n,s)),r=R.sqr(e.x).selfAdd(R.sqr(e.y)).selfMultiply(fo.triAreaDDFast(t,n,s)),o=R.sqr(n.x).selfAdd(R.sqr(n.y)).selfMultiply(fo.triAreaDDFast(t,e,s)),l=R.sqr(s.x).selfAdd(R.sqr(s.y)).selfMultiply(fo.triAreaDDFast(t,e,n));return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue()>0}static isInCircleCC(t,e,n,s){const i=re.circumcentre(t,e,n),r=t.distance(i);return s.distance(i)-r<=0}static isInCircleNormalized(t,e,n,s){const i=t.x-s.x,r=t.y-s.y,o=e.x-s.x,l=e.y-s.y,a=n.x-s.x,c=n.y-s.y;return(i*i+r*r)*(o*c-a*l)+(o*o+l*l)*(a*r-i*c)+(a*a+c*c)*(i*l-o*r)>0}static isInCircleDDSlow(t,e,n,s){const i=R.valueOf(s.x),r=R.valueOf(s.y),o=R.valueOf(t.x),l=R.valueOf(t.y),a=R.valueOf(e.x),c=R.valueOf(e.y),h=R.valueOf(n.x),u=R.valueOf(n.y),g=o.multiply(o).add(l.multiply(l)).multiply(fo.triAreaDDSlow(a,c,h,u,i,r)),d=a.multiply(a).add(c.multiply(c)).multiply(fo.triAreaDDSlow(o,l,h,u,i,r)),_=h.multiply(h).add(u.multiply(u)).multiply(fo.triAreaDDSlow(o,l,a,c,i,r)),f=i.multiply(i).add(r.multiply(r)).multiply(fo.triAreaDDSlow(o,l,a,c,h,u));return g.subtract(d).add(_).subtract(f).doubleValue()>0}static isInCircleNonRobust(t,e,n,s){return(t.x*t.x+t.y*t.y)*fo.triArea(e,n,s)-(e.x*e.x+e.y*e.y)*fo.triArea(t,n,s)+(n.x*n.x+n.y*n.y)*fo.triArea(t,e,s)-(s.x*s.x+s.y*s.y)*fo.triArea(t,e,n)>0}static isInCircleRobust(t,e,n,s){return fo.isInCircleNormalized(t,e,n,s)}static triAreaDDSlow(t,e,n,s,i,r){return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)))}static triAreaDDFast(t,e,n){const s=R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(n.y).selfSubtract(t.y)),i=R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(n.x).selfSubtract(t.x));return s.selfSubtract(i)}getClass(){return fo}get interfaces_(){return[]}}fo.constructor_=function(){};class po{constructor(){po.constructor_.apply(this,arguments)}static interpolateZ(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.distance(n),i=t.distance(e),r=n.z-e.z;return e.z+r*(i/s)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.z+d*(n.z-e.z)+_*(s.z-e.z)}}circleCenter(t,e){const n=new po(this.getX(),this.getY()),s=this.bisector(n,t),i=this.bisector(t,e),r=new b(s,i);let o=null;try{o=new po(r.getX(),r.getY())}catch(s){if(!(s instanceof S))throw s;O.err.println("a: "+n+"  b: "+t+"  c: "+e),O.err.println(s)}return o}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.z}bisector(t,e){const n=e.getX()-t.getX(),s=e.getY()-t.getY(),i=new b(t.getX()+n/2,t.getY()+s/2,1),r=new b(t.getX()-s+n/2,t.getY()+n+s/2,1);return new b(i,r)}equals(){if(1===arguments.length){const t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._p.distance(t.getCoordinate())<e}}getCoordinate(){return this._p}isInCircle(t,e,n){return fo.isInCircleRobust(t._p,e._p,n._p,this._p)}interpolateZValue(t,e,n){const s=t.getX(),i=t.getY(),r=e.getX()-s,o=n.getX()-s,l=e.getY()-i,a=n.getY()-i,c=r*a-o*l,h=this.getX()-s,u=this.getY()-i,g=(a*h-o*u)/c,d=(-l*h+r*u)/c;return t.getZ()+g*(e.getZ()-t.getZ())+d*(n.getZ()-t.getZ())}midPoint(t){const e=(this._p.x+t.getX())/2,n=(this._p.y+t.getY())/2,s=(this._p.z+t.getZ())/2;return new po(e,n,s)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,e){return(t._p.x-this._p.x)*(e._p.y-this._p.y)-(t._p.y-this._p.y)*(e._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.z=t}times(t){return new po(t*this._p.x,t*this._p.y)}cross(){return new po(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new po(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,e){const n=e.sub(t),s=this.sub(t),i=n.crossProduct(s);return i>0?po.LEFT:i<0?po.RIGHT:n.getX()*s.getX()<0||n.getY()*s.getY()<0?po.BEHIND:n.magn()<s.magn()?po.BEYOND:t.equals(this)?po.ORIGIN:e.equals(this)?po.DESTINATION:po.BETWEEN}sum(t){return new po(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))}circumRadiusRatio(t,e){const n=this.circleCenter(t,e),s=this.distance(n,t);let i=this.distance(this,t),r=this.distance(t,e);return r<i&&(i=r),r=this.distance(e,this),r<i&&(i=r),s/i}getClass(){return po}get interfaces_(){return[]}}po.constructor_=function(){if(this._p=null,1===arguments.length){const t=arguments[0];this._p=new g(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new g(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new g(t,e,n)}},po.LEFT=0,po.RIGHT=1,po.BEYOND=2,po.BEHIND=3,po.BETWEEN=4,po.ORIGIN=5,po.DESTINATION=6;class mo extends po{constructor(){super(),mo.constructor_.apply(this,arguments)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}getClass(){return mo}get interfaces_(){return[]}}mo.constructor_=function(){this._isOnConstraint=null,this._constraint=null;const t=arguments[0];po.constructor_.call(this,t)};class yo{constructor(){yo.constructor_.apply(this,arguments)}static makeEdge(t,e){const n=new yo,s=new yo,i=new yo,r=new yo;n._rot=s,s._rot=i,i._rot=r,r._rot=n,n.setNext(n),s.setNext(r),i.setNext(i),r.setNext(s);const o=n;return o.setOrig(t),o.setDest(e),o}static swap(t){const e=t.oPrev(),n=t.sym().oPrev();yo.splice(t,e),yo.splice(t.sym(),n),yo.splice(t,e.lNext()),yo.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())}static splice(t,e){const n=t.oNext().rot(),s=e.oNext().rot(),i=e.oNext(),r=t.oNext(),o=s.oNext(),l=n.oNext();t.setNext(i),e.setNext(r),n.setNext(o),s.setNext(l)}static connect(t,e){const n=yo.makeEdge(t.dest(),e.orig());return yo.splice(n,t.lNext()),yo.splice(n.sym(),e),n}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new ee(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){const t=this._vertex.getCoordinate(),e=this.dest().getCoordinate();return Jt.toLineString(t,e)}isLive(){return null!==this._rot}getPrimary(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}getClass(){return yo}get interfaces_(){return[]}}yo.constructor_=function(){this._rot=null,this._vertex=null,this._next=null,this._data=null};class xo{constructor(){xo.constructor_.apply(this,arguments)}insertSite(t){let e=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(e,t))return e;this._subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this._subdiv.delete(e.oNext()));let n=this._subdiv.makeEdge(e.orig(),t);yo.splice(n,e);const s=n;do{n=this._subdiv.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);for(;;){const i=e.oPrev();if(i.dest().rightOf(e)&&t.isInCircle(e.orig(),i.dest(),e.dest()))yo.swap(e),e=e.oPrev();else{if(e.oNext()===s)return n;e=e.oNext().lPrev()}}}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getClass(){return xo}get interfaces_(){return[]}}xo.constructor_=function(){this._subdiv=null,this._isUsingTolerance=!1;const t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0};class Eo{constructor(){Eo.constructor_.apply(this,arguments)}locate(t){}getClass(){return Eo}get interfaces_(){return[]}}Eo.constructor_=function(){};class Io{constructor(){Io.constructor_.apply(this,arguments)}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();const e=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=e,e}findEdge(){return this._subdiv.getEdges().iterator().next()}getClass(){return Io}get interfaces_(){return[Eo]}}Io.constructor_=function(){this._subdiv=null,this._lastEdge=null;const t=arguments[0];this._subdiv=t,this.init()};class No extends c{constructor(){super(),No.constructor_.apply(this,arguments)}static msgWithSpatial(t,e){return null!==e?t+" [ "+e+" ]":t}getSegment(){return this._seg}getClass(){return No}get interfaces_(){return[]}}No.constructor_=function(){if(this._seg=null,1===arguments.length){if("string"==typeof arguments[0]){const t=arguments[0];c.constructor_.call(this,t)}else if(arguments[0]instanceof ee){const t=arguments[0];c.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new ee(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];c.constructor_.call(this,No.msgWithSpatial(t,e)),this._seg=new ee(e)}};class Co{constructor(){Co.constructor_.apply(this,arguments)}visit(t){}getClass(){return Co}get interfaces_(){return[]}}Co.constructor_=function(){};class So{constructor(){So.constructor_.apply(this,arguments)}static getTriangleEdges(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new n("Edges do not form a triangle")}getTriangleVertices(t){const e=new To;return this.visitTriangles(e,t),e.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||(!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2]))}isVertexOfEdge(t,e){return!(!e.equals(t.orig(),this._tolerance)&&!e.equals(t.dest(),this._tolerance))}connect(t,e){const n=yo.connect(t,e);return this._quadEdges.add(n),n}getVoronoiCellPolygon(t,e){const n=new x,s=t;do{const e=t.rot().orig().getCoordinate();n.add(e),t=t.oPrev()}while(t!==s);const i=new I;i.addAll(n,!1),i.closeRing(),i.size()<4&&(O.out.println(i),i.add(i.get(i.size()-1),!0));const r=i.toCoordinateArray(),o=e.createPolygon(e.createLinearRing(r)),l=s.orig();return o.setUserData(l.getCoordinate()),o}setLocator(t){this._locator=t}initSubdiv(){const t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),e=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);yo.splice(t.sym(),e);const n=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return yo.splice(e.sym(),n),yo.splice(n.sym(),t),t}isFrameBorderEdge(t){const e=new Array(3).fill(null);So.getTriangleEdges(t,e);const n=new Array(3).fill(null);So.getTriangleEdges(t.sym(),n);const s=t.lNext().dest();if(this.isFrameVertex(s))return!0;const i=t.sym().lNext().dest();return!!this.isFrameVertex(i)}makeEdge(t,e){const n=yo.makeEdge(t,e);return this._quadEdges.add(n),n}visitTriangles(t,e){this._visitedKey++;const n=new on;n.push(this._startingEdge);const s=new J;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=this.fetchTriangleToVisit(i,n,e,s);null!==r&&t.visit(r)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,e){return this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate()),this._seg.distance(e)<this._edgeCoincidenceTolerance}getEnvelope(){return new N(this._frameEnv)}createFrame(t){const e=t.getWidth(),n=t.getHeight();let s=0;s=e>n?10*e:10*n,this._frameVertex[0]=new po((t.getMaxX()+t.getMinX())/2,t.getMaxY()+s),this._frameVertex[1]=new po(t.getMinX()-s,t.getMinY()-s),this._frameVertex[2]=new po(t.getMaxX()+s,t.getMinY()-s),this._frameEnv=new N(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){const e=new Ro;return this.visitTriangles(e,t),e.getTriangles()}getVertices(t){const e=new J;for(let n=this._quadEdges.iterator();n.hasNext();){const s=n.next(),i=s.orig();!t&&this.isFrameVertex(i)||e.add(i);const r=s.dest();!t&&this.isFrameVertex(r)||e.add(r)}return e}fetchTriangleToVisit(t,e,n,s){let i=t,r=0,o=!1;do{this._triEdges[r]=i,this.isFrameEdge(i)&&(o=!0);const t=i.sym();s.contains(t)||e.push(t),s.add(i),r++,i=i.lNext()}while(i!==t);return o&&!n?null:this._triEdges}getEdges(){if(0===arguments.length)return this._quadEdges;if(1===arguments.length){const t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createLineString([e.orig().getCoordinate(),e.dest().getCoordinate()])}return t.createMultiLineString(n)}}getVertexUniqueEdges(t){const e=new x,n=new J;for(let s=this._quadEdges.iterator();s.hasNext();){const i=s.next(),r=i.orig();n.contains(r)||(n.add(r),!t&&this.isFrameVertex(r)||e.add(i));const o=i.sym(),l=o.orig();n.contains(l)||(n.add(l),!t&&this.isFrameVertex(l)||e.add(o))}return e}getTriangleEdges(t){const e=new Lo;return this.visitTriangles(e,t),e.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;const e=new x,n=new on;n.push(this._startingEdge);const s=new J;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=i.getPrimary();!t&&this.isFrameEdge(r)||e.add(r),n.push(i.oNext()),n.push(i.sym().oNext()),s.add(i),s.add(i.sym())}}return e}delete(t){yo.splice(t,t.oPrev()),yo.splice(t.sym(),t.sym().oPrev());const e=t.sym(),n=t.rot(),s=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(e),this._quadEdges.remove(n),this._quadEdges.remove(s),t.delete(),e.delete(),n.delete(),s.delete()}locateFromEdge(t,e){let n=0;const s=this._quadEdges.size();let i=e;for(;;){if(n++,n>s)throw new No(i.toLineSegment());if(t.equals(i.orig())||t.equals(i.dest()))break;if(t.rightOf(i))i=i.sym();else if(t.rightOf(i.oNext())){if(t.rightOf(i.dPrev()))break;i=i.dPrev()}else i=i.oNext()}return i}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new wo,!0);const e=new x;for(let n=this.getVertexUniqueEdges(!1).iterator();n.hasNext();){const s=n.next();e.add(this.getVoronoiCellPolygon(s,t))}return e}getVoronoiDiagram(t){const e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Ht.toGeometryArray(e))}getTriangles(t){const e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createPolygon(t.createLinearRing(e))}return t.createGeometryCollection(n)}insertSite(t){let e=this.locate(t);if(t.equals(e.orig(),this._tolerance)||t.equals(e.dest(),this._tolerance))return e;let n=this.makeEdge(e.orig(),t);yo.splice(n,e);const s=n;do{n=this.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);return s}locate(){if(1===arguments.length){if(arguments[0]instanceof po){const t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof g){const t=arguments[0];return this._locator.locate(new po(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._locator.locate(new po(t));if(null===n)return null;let s=n;n.dest().getCoordinate().equals2D(t)&&(s=n.sym());let i=s;do{if(i.dest().getCoordinate().equals2D(e))return i;i=i.oNext()}while(i!==s);return null}}getClass(){return So}get interfaces_(){return[]}}class wo{constructor(){wo.constructor_.apply(this,arguments)}visit(t){const e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),s=t[2].orig().getCoordinate(),i=re.circumcentre(e,n,s),r=new po(i);for(let e=0;e<3;e++)t[e].rot().setOrig(r)}getClass(){return wo}get interfaces_(){return[Co]}}wo.constructor_=function(){};class Lo{constructor(){Lo.constructor_.apply(this,arguments)}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}getClass(){return Lo}get interfaces_(){return[Co]}}Lo.constructor_=function(){this._triList=new x};class To{constructor(){To.constructor_.apply(this,arguments)}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}getClass(){return To}get interfaces_(){return[Co]}}To.constructor_=function(){this._triList=new x};class Ro{constructor(){Ro.constructor_.apply(this,arguments)}checkTriangleSize(t){let e="";t.length>=2?e=Jt.toLineString(t[0],t[1]):t.length>=1&&(e=Jt.toPoint(t[0]))}visit(t){this._coordList.clear();for(let e=0;e<3;e++){const n=t[e].orig();this._coordList.add(n.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();const t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}getClass(){return Ro}get interfaces_(){return[Co]}}Ro.constructor_=function(){this._coordList=new I,this._triCoords=new x},So.TriangleCircumcentreVisitor=wo,So.TriangleEdgesListVisitor=Lo,So.TriangleVertexListVisitor=To,So.TriangleCoordinatesVisitor=Ro,So.constructor_=function(){this._visitedKey=0,this._quadEdges=new x,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=new Array(3).fill(null),this._frameEnv=null,this._locator=null,this._seg=new ee,this._triEdges=new Array(3).fill(null);const t=arguments[0],e=arguments[1];this._tolerance=e,this._edgeCoincidenceTolerance=e/So.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new Io(this)},So.EDGE_COINCIDENCE_TOL_FACTOR=1e3;class Po{constructor(){Po.constructor_.apply(this,arguments)}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).z}getStartZ(){return this._ls.getCoordinate(0).z}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}getClass(){return Po}get interfaces_(){return[]}}Po.constructor_=function(){if(this._ls=null,this._data=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._ls=new ee(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._ls=new ee(t,e),this._data=n}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];Po.constructor_.call(this,new g(t,e,n),new g(s,i,r))}else if(7===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6];Po.constructor_.call(this,new g(t,e,n),new g(s,i,r),o)}};class vo{constructor(){vo.constructor_.apply(this,arguments)}static computeVertexEnvelope(t){const e=new N;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t.getCoordinate())}return e}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,e=0;do{e=this.enforceGabriel(this._segments),t++}while(e>0&&t<vo.MAX_SPLIT_ITER)}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){const t=new Array(this._initialVertices.size()+this._segVertices.size()).fill(null);let e=0;for(let n=this._initialVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}for(let n=this._segVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}return t}setConstraints(t,e){this._segments=t,this._segVertices=e}computeConvexHull(){const t=new Ht,e=this.getPointArray(),n=new an(e,t);this._convexHull=n.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){const e=t.getStart(),n=t.getEnd(),s=new g((e.x+n.x)/2,(e.y+n.y)/2),r=e.distance(s),o=new N(s);o.expandBy(r);const l=this._kdt.query(o);let a=null,c=i.MAX_VALUE;for(let t=l.iterator();t.hasNext();){const i=t.next().getCoordinate();if(i.equals2D(e)||i.equals2D(n))continue;const o=s.distance(i);if(o<r){const t=o;(null===a||t<c)&&(a=i,c=t)}}return a}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){const e=new x;let n=0;const s=new x;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=this.findNonGabrielPoint(t);if(null===r)continue;this._splitPt=this._splitFinder.findSplitPoint(t,r);const o=this.createVertex(this._splitPt,t);this.insertSite(o).getCoordinate().equals2D(this._splitPt);const l=new Po(t.getStartX(),t.getStartY(),t.getStartZ(),o.getX(),o.getY(),o.getZ(),t.getData()),a=new Po(o.getX(),o.getY(),o.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());e.add(l),e.add(a),s.add(t),n+=1}return t.removeAll(s),t.addAll(e),n}createVertex(){if(1===arguments.length){const t=arguments[0];let e=null;return e=null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new mo(t),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null;return n=null!==this._vertexFactory?this._vertexFactory.createVertex(t,e):new mo(t),n.setOnConstraint(!0),n}}getSubdivision(){return this._subdiv}computeBoundingBox(){const t=vo.computeVertexEnvelope(this._initialVertices),e=vo.computeVertexEnvelope(this._segVertices),n=new N(t);n.expandToInclude(e);const s=.2*n.getWidth(),i=.2*n.getHeight(),r=Math.max(s,i);this._computeAreaEnv=new N(n),this._computeAreaEnv.expandBy(r)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new So(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new Io(this._subdiv)),this._incDel=new xo(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof mo){const t=arguments[0],e=this._kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){const n=e.getData();return n.merge(t),n}return this._incDel.insertSite(t),t}if(arguments[0]instanceof g){const t=arguments[0];this.insertSite(this.createVertex(t))}}getClass(){return vo}get interfaces_(){return[]}}vo.constructor_=function(){this._initialVertices=null,this._segVertices=null,this._segments=new x,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new _o,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._initialVertices=new x(t),this._tolerance=e,this._kdt=new es(e)},vo.MAX_SPLIT_ITER=99;class Oo{constructor(){Oo.constructor_.apply(this,arguments)}static extractUniqueCoordinates(t){if(null===t)return new I;const e=t.getCoordinates();return Oo.unique(e)}static envelope(t){const e=new N;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t)}return e}static unique(t){const e=X.copyDeep(t);return ht.sort(e),new I(e,!1)}static toVertices(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new po(t))}return e}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords),e=Oo.toVertices(this._siteCoords);this._subdiv=new So(t,this._tolerance),new xo(this._subdiv).insertSites(e)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){const t=arguments[0];this._siteCoords=Oo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){const t=arguments[0];this._siteCoords=Oo.unique(X.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}getClass(){return Oo}get interfaces_(){return[]}}Oo.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null};class bo{constructor(){bo.constructor_.apply(this,arguments)}static createConstraintSegments(){if(1===arguments.length){const t=arguments[0],e=xe.getLines(t),n=new x;for(let t=e.iterator();t.hasNext();){const e=t.next();bo.createConstraintSegments(e,n)}return n}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates();for(let t=1;t<n.length;t++)e.add(new Po(n[t-1],n[t]))}}createSiteVertices(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();this._constraintVertexMap.containsKey(t)||e.add(new mo(t))}return e}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords);let e=new x;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),e=bo.createConstraintSegments(this._constraintLines));const n=this.createSiteVertices(this._siteCoords),s=new vo(n,this._tolerance);s.setConstraints(e,new x(this._constraintVertexMap.values())),s.formInitialDelaunay(),s.enforceConstraints(),this._subdiv=s.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=Oo.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){const e=t.getCoordinates();for(let t=0;t<e.length;t++){const n=new mo(e[t]);this._constraintVertexMap.put(e[t],n)}}getClass(){return bo}get interfaces_(){return[]}}bo.constructor_=function(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new rt};class Mo{constructor(){Mo.constructor_.apply(this,arguments)}static clipGeometryCollection(t,e){const n=t.getFactory().toGeometry(e),s=new x;for(let i=0;i<t.getNumGeometries();i++){const r=t.getGeometryN(i);let o=null;e.contains(r.getEnvelopeInternal())?o=r:e.intersects(r.getEnvelopeInternal())&&(o=n.intersection(r),o.setUserData(r.getUserData())),null===o||o.isEmpty()||s.add(o)}return t.getFactory().createGeometryCollection(Ht.toGeometryArray(s))}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords);this._diagramEnv=t;const e=Math.max(this._diagramEnv.getWidth(),this._diagramEnv.getHeight());this._diagramEnv.expandBy(e),null!==this._clipEnv&&this._diagramEnv.expandToInclude(this._clipEnv);const n=Oo.toVertices(this._siteCoords);this._subdiv=new So(t,this._tolerance),new xo(this._subdiv).insertSites(n)}getDiagram(t){this.create();const e=this._subdiv.getVoronoiDiagram(t);return Mo.clipGeometryCollection(e,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){const t=arguments[0];this._siteCoords=Oo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){const t=arguments[0];this._siteCoords=Oo.unique(X.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}getClass(){return Mo}get interfaces_(){return[]}}Mo.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null};var Do=Object.freeze({__proto__:null,Vertex:po}),Ao=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:bo,DelaunayTriangulationBuilder:Oo,VoronoiDiagramBuilder:Mo,quadedge:Do});class Fo{constructor(){Fo.constructor_.apply(this,arguments)}static getEndLocation(t){const e=new Fo;return e.setToEnd(t),e}static pointAlongSegmentByFraction(t,e,n){if(n<=0)return t;if(n>=1)return e;const s=(e.x-t.x)*n+t.x,i=(e.y-t.y)*n+t.y,r=(e.z-t.z)*n+t.z;return new g(s,i,r)}static compareLocationValues(t,e,n,s,i,r){return t<s?-1:t>s?1:e<i?-1:e>i?1:n<r?-1:n>r?1:0}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){const e=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex>=e||this._segmentIndex===e&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;const e=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>e.getNumPoints())&&((this._segmentIndex!==e.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1))}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){const e=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex<e?this:new Fo(this._componentIndex,e,1,!1)}getCoordinate(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=e.getNumPoints()-1)return n;const s=e.getCoordinateN(this._segmentIndex+1);return Fo.pointAlongSegmentByFraction(n,s,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=e.getNumPoints()-1){const t=e.getCoordinateN(e.getNumPoints()-2);return new ee(t,n)}const s=e.getCoordinateN(this._segmentIndex+1);return new ee(n,s)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){const e=t.getGeometryN(this._componentIndex);this._segmentIndex=e.getNumPoints()-1,this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;const e=t.getGeometryN(this._componentIndex);this._segmentIndex=e.getNumPoints()-1,this._segmentFraction=1}compareTo(t){const e=t;return this._componentIndex<e._componentIndex?-1:this._componentIndex>e._componentIndex?1:this._segmentIndex<e._segmentIndex?-1:this._segmentIndex>e._segmentIndex?1:this._segmentFraction<e._segmentFraction?-1:this._segmentFraction>e._segmentFraction?1:0}copy(){return new Fo(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||(t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction))}snapToVertex(t,e){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;const n=this.getSegmentLength(t),s=this._segmentFraction*n,i=n-s;s<=i&&s<e?this._segmentFraction=0:i<=s&&i<e&&(this._segmentFraction=1)}compareLocationValues(t,e,n){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<e?-1:this._segmentIndex>e?1:this._segmentFraction<n?-1:this._segmentFraction>n?1:0}getSegmentLength(t){const e=t.getGeometryN(this._componentIndex);let n=this._segmentIndex;this._segmentIndex>=e.getNumPoints()-1&&(n=e.getNumPoints()-2);const s=e.getCoordinateN(n),i=e.getCoordinateN(n+1);return s.distance(i)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}getClass(){return Fo}get interfaces_(){return[r]}}Fo.constructor_=function(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Fo.constructor_.call(this,0,t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,this.normalize()}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,s&&this.normalize()}};class Go{constructor(){Go.constructor_.apply(this,arguments)}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}getClass(){return Go}get interfaces_(){return[]}}Go.constructor_=function(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1===arguments.length){const t=arguments[0];Go.constructor_.call(this,t,0,0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Go.constructor_.call(this,t,e.getComponentIndex(),Go.segmentEndVertexIndex(e))}else if(3===arguments.length){const t=arguments[0],e=arguments[1],s=arguments[2];if(!_(t,ot))throw new n("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=e,this._vertexIndex=s,this.loadCurrentLine()}};class qo{constructor(){qo.constructor_.apply(this,arguments)}static indexOf(t,e){return new qo(t).indexOf(e)}static indexOfAfter(t,e,n){return new qo(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,e){let n=i.MAX_VALUE,s=0,r=0,o=-1;const l=new ee;for(let i=new Go(this._linearGeom);i.hasNext();i.next())if(!i.isEndOfLine()){l.p0=i.getSegmentStart(),l.p1=i.getSegmentEnd();const a=l.distance(t),c=l.segmentFraction(t),h=i.getComponentIndex(),u=i.getVertexIndex();a<n&&(null===e||e.compareLocationValues(h,u,c)<0)&&(s=h,r=u,o=c,n=a)}return n===i.MAX_VALUE?new Fo(e):new Fo(s,r,o)}indexOfAfter(t,e){if(null===e)return this.indexOf(t);const n=Fo.getEndLocation(this._linearGeom);if(n.compareTo(e)<=0)return n;const s=this.indexOfFromStart(t,e);return u.isTrue(s.compareTo(e)>=0,"computed location is before specified minimum location"),s}getClass(){return qo}get interfaces_(){return[]}}qo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Bo{constructor(){Bo.constructor_.apply(this,arguments)}static indicesOf(t,e){return new Bo(t).indicesOf(e)}indicesOf(t){const e=t.getGeometryN(0).getCoordinateN(0),n=t.getGeometryN(t.getNumGeometries()-1),s=n.getCoordinateN(n.getNumPoints()-1),i=new qo(this._linearGeom),r=new Array(2).fill(null);return r[0]=i.indexOf(e),0===t.getLength()?r[1]=r[0].copy():r[1]=i.indexOfAfter(s,r[0]),r}getClass(){return Bo}get interfaces_(){return[]}}Bo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Vo{constructor(){Vo.constructor_.apply(this,arguments)}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&this._coordList.size()<2)return this._coordList=null,null;const t=this._coordList.toCoordinateArray();let e=t;this._fixInvalidLines&&(e=this.validCoordinateSequence(t)),this._coordList=null;let s=null;try{s=this._geomFact.createLineString(e)}catch(t){if(!(t instanceof n))throw t;if(!this._ignoreInvalidLines)throw t}null!==s&&this._lines.add(s)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1===arguments.length){const t=arguments[0];this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];null===this._coordList&&(this._coordList=new I),this._coordList.add(t,e),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){if(t.length>=2)return t;return[t[0],t[0]]}getClass(){return Vo}get interfaces_(){return[]}}Vo.constructor_=function(){this._geomFact=null,this._lines=new x,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;const t=arguments[0];this._geomFact=t};class zo{constructor(){zo.constructor_.apply(this,arguments)}static extract(t,e,n){return new zo(t).extract(e,n)}computeLinear(t,e){const n=new Vo(this._line.getFactory());n.setFixInvalidLines(!0),t.isVertex()||n.add(t.getCoordinate(this._line));for(let s=new Go(this._line,t);s.hasNext()&&!(e.compareLocationValues(s.getComponentIndex(),s.getVertexIndex(),0)<0);s.next()){const t=s.getSegmentStart();n.add(t),s.isEndOfLine()&&n.endLine()}return e.isVertex()||n.add(e.getCoordinate(this._line)),n.getGeometry()}computeLine(t,e){const n=this._line.getCoordinates(),s=new I;let i=t.getSegmentIndex();t.getSegmentFraction()>0&&(i+=1);let r=e.getSegmentIndex();1===e.getSegmentFraction()&&(r+=1),r>=n.length&&(r=n.length-1),t.isVertex()||s.add(t.getCoordinate(this._line));for(let t=i;t<=r;t++)s.add(n[t]);e.isVertex()||s.add(e.getCoordinate(this._line)),s.size()<=0&&s.add(t.getCoordinate(this._line));let o=s.toCoordinateArray();return o.length<=1&&(o=[o[0],o[0]]),this._line.getFactory().createLineString(o)}extract(t,e){return e.compareTo(t)<0?this.reverse(this.computeLinear(e,t)):this.computeLinear(t,e)}reverse(t){return t instanceof Tt||t instanceof ft?t.reverse():(u.shouldNeverReachHere("non-linear geometry encountered"),null)}getClass(){return zo}get interfaces_(){return[]}}zo.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class Yo{constructor(){Yo.constructor_.apply(this,arguments)}clampIndex(t){const e=t.copy();return e.clamp(this._linearGeom),e}project(t){return qo.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof Tt||this._linearGeom instanceof ft))throw new n("Input geometry must be linear")}extractPoint(){if(1===arguments.length){return arguments[0].getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return Fo.getEndLocation(this._linearGeom)}getStartIndex(){return new Fo}indexOfAfter(t,e){return qo.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){return zo.extract(this._linearGeom,t,e)}indexOf(t){return qo.indexOf(this._linearGeom,t)}indicesOf(t){return Bo.indicesOf(this._linearGeom,t)}getClass(){return Yo}get interfaces_(){return[]}}Yo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t,this.checkGeometryType()};class Uo{constructor(){Uo.constructor_.apply(this,arguments)}static indexOf(t,e){return new Uo(t).indexOf(e)}static indexOfAfter(t,e,n){return new Uo(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,e){let n=i.MAX_VALUE,s=e,r=0;const o=new ee,l=new Go(this._linearGeom);for(;l.hasNext();){if(!l.isEndOfLine()){o.p0=l.getSegmentStart(),o.p1=l.getSegmentEnd();const i=o.distance(t),a=this.segmentNearestMeasure(o,t,r);i<n&&a>e&&(s=a,n=i),r+=o.getLength()}l.next()}return s}indexOfAfter(t,e){if(e<0)return this.indexOf(t);const n=this._linearGeom.getLength();if(n<e)return n;const s=this.indexOfFromStart(t,e);return u.isTrue(s>=e,"computed index is before specified minimum index"),s}segmentNearestMeasure(t,e,n){const s=t.projectionFactor(e);return s<=0?n:s<=1?n+s*t.getLength():n+t.getLength()}getClass(){return Uo}get interfaces_(){return[]}}Uo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class ko{constructor(){ko.constructor_.apply(this,arguments)}static getLength(t,e){return new ko(t).getLength(e)}static getLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new ko(t).getLocation(e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new ko(t).getLocation(e,n)}}getLength(t){let e=0;const n=new Go(this._linearGeom);for(;n.hasNext();){if(!n.isEndOfLine()){const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(t.getComponentIndex()===n.getComponentIndex()&&t.getSegmentIndex()===n.getVertexIndex())return e+i*t.getSegmentFraction();e+=i}n.next()}return e}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let e=t.getComponentIndex();if(e>=this._linearGeom.getNumGeometries()-1)return t;do{e++}while(e<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(e).getLength());return new Fo(e,0,0)}getLocation(){if(1===arguments.length){const t=arguments[0];return this.getLocation(t,!0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=t;if(t<0){n=this._linearGeom.getLength()+t}const s=this.getLocationForward(n);return e?s:this.resolveHigher(s)}}getLocationForward(t){if(t<=0)return new Fo;let e=0;const n=new Go(this._linearGeom);for(;n.hasNext();){if(n.isEndOfLine()){if(e===t){const t=n.getComponentIndex(),e=n.getVertexIndex();return new Fo(t,e,0)}}else{const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(e+i>t){const s=(t-e)/i,r=n.getComponentIndex(),o=n.getVertexIndex();return new Fo(r,o,s)}e+=i}n.next()}return Fo.getEndLocation(this._linearGeom)}getClass(){return ko}get interfaces_(){return[]}}ko.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Xo{constructor(){Xo.constructor_.apply(this,arguments)}clampIndex(t){const e=this.positiveIndex(t),n=this.getStartIndex();if(e<n)return n;const s=this.getEndIndex();return e>s?s:e}locationOf(){if(1===arguments.length){const t=arguments[0];return ko.getLocation(this._linearGeom,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return ko.getLocation(this._linearGeom,t,e)}}project(t){return Uo.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1===arguments.length){const t=arguments[0];return ko.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=ko.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,e){return Uo.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){new Yo(this._linearGeom);const n=this.clampIndex(t),s=this.clampIndex(e),i=n===s,r=this.locationOf(n,i),o=this.locationOf(s);return zo.extract(this._linearGeom,r,o)}indexOf(t){return Uo.indexOf(this._linearGeom,t)}indicesOf(t){const e=Bo.indicesOf(this._linearGeom,t);return[ko.getLength(this._linearGeom,e[0]),ko.getLength(this._linearGeom,e[1])]}getClass(){return Xo}get interfaces_(){return[]}}Xo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};var Ho=Object.freeze({__proto__:null,LengthIndexedLine:Xo,LengthLocationMap:ko,LinearGeometryBuilder:Vo,LinearIterator:Go,LinearLocation:Fo,LocationIndexedLine:Yo});class Wo{constructor(){Wo.constructor_.apply(this,arguments)}static transform(t,e){const n=new x;for(let s=t.iterator();s.hasNext();)n.add(e.execute(s.next()));return n}static select(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next();Boolean.TRUE.equals(e.execute(t))&&n.add(t)}return n}static apply(t,e){for(let n=t.iterator();n.hasNext();)e.execute(n.next())}getClass(){return Wo}get interfaces_(){return[]}}Wo.Function=function(){},Wo.constructor_=function(){};class jo{constructor(){jo.constructor_.apply(this,arguments)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}getClass(){return jo}get interfaces_(){return[B]}}jo.constructor_=function(){this.pts=null,this.n=0;const t=arguments[0];this.pts=new Array(t).fill(null)};class Ko{constructor(){Ko.constructor_.apply(this,arguments)}filter(t){this._n++}getCount(){return this._n}getClass(){return Ko}get interfaces_(){return[B]}}Ko.constructor_=function(){this._n=0};class Zo{constructor(){Zo.constructor_.apply(this,arguments)}count(t){const e=this._counts.get(t);return null===e?0:e.count()}add(t){const e=this._counts.get(t);null===e?this._counts.put(t,new Qo(1)):e.increment()}getClass(){return Zo}get interfaces_(){return[]}}class Qo{constructor(){Qo.constructor_.apply(this,arguments)}count(){return this.count}increment(){this.count++}getClass(){return Qo}get interfaces_(){return[]}}Qo.constructor_=function(){if(this.count=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.count=t}},Zo.Counter=Qo,Zo.constructor_=function(){this._counts=new Ut};var Jo=Object.freeze({__proto__:null,CollectionUtil:Wo,CoordinateArrayFilter:jo,CoordinateCountFilter:Ko,GeometricShapeFactory:Se,NumberUtil:e,ObjectCounter:Zo,PriorityQueue:fs,StringUtil:St,UniqueCoordinateArrayFilter:ln});class $o{get interfaces_(){return[]}getClass(){return $o}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),lr.overlayOp(t,e,cr.UNION)}}q.prototype.equalsTopo=function(t){return!!this.getEnvelopeInternal().equals(t.getEnvelopeInternal())&&Gr.relate(this,t).isEquals(this.getDimension(),t.getDimension())},q.prototype.union=function(){if(0===arguments.length)return zr.union(this);if(1===arguments.length){const t=arguments[0];return $o.union(this,t)}},q.prototype.isValid=function(){return Cr.isValid(this)},q.prototype.intersection=function(t){return cr.intersection(this,t)},q.prototype.covers=function(t){return Gr.covers(this,t)},q.prototype.coveredBy=function(t){return Gr.covers(t,this)},q.prototype.touches=function(t){return Gr.touches(this,t)},q.prototype.intersects=function(t){return Gr.intersects(this,t)},q.prototype.within=function(t){return Gr.contains(t,this)},q.prototype.overlaps=function(t){return Gr.overlaps(this,t)},q.prototype.disjoint=function(t){return Gr.disjoint(this,t)},q.prototype.crosses=function(t){return Gr.crosses(this,t)},q.prototype.buffer=function(){if(1===arguments.length){const t=arguments[0];return Si.bufferOp(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Si.bufferOp(this,t,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return Si.bufferOp(this,t,e,n)}},q.prototype.convexHull=function(){return new an(this).getConvexHull()},q.prototype.relate=function(...t){if(1===arguments.length){const t=arguments[0];return Gr.relate(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Gr.relate(this,t).matches(e)}},q.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();const t=sn.getCentroid(this);return this.createPointFromInternalCoord(t,this)},q.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=null;const e=this.getDimension();t=0===e?new dn(this):1===e?new gn(this):new hn(this);const n=t.getInteriorPoint();return this.createPointFromInternalCoord(n,this)},q.prototype.symDifference=function(t){return cr.symDifference(this,t)},q.prototype.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},q.prototype.toText=function(){return(new Jt).write(this)},q.prototype.toString=function(){this.toText()},q.prototype.contains=function(t){return Gr.contains(this,t)},q.prototype.difference=function(t){return cr.difference(this,t)},q.prototype.isSimple=function(){return new Hs(this).isSimple()},q.prototype.isWithinDistance=function(t,e){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>e)&&Ri.isWithinDistance(this,t,e)},q.prototype.distance=function(t){return Ri.distance(this,t)},q.prototype.isEquivalentClass=function(t){return this.getClass()===t.getClass()};t.algorithm=mn,t.densify=En,t.dissolve=Rn,t.geom=Re,t.geomgraph=Jn,t.index=Cs,t.io=Ps,t.linearref=Ho,t.noding=Xs,t.operation=kr,t.precision=Wr,t.simplify=ho,t.triangulate=Ao,t.util=Jo,t.version="2.1.2 (83b5aee)",Object.defineProperty(t,"__esModule",{value:!0})}));

},{}],6:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],7:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

/**
 * Checks, if polygon is simple. Polygon is simple, when its edges don't cross each other.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean} true if Polygon is simple
 */
function IsSimple (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 4) return true
  var a1 = Point();
  var a2 = Point();
  var b1 = Point();
  var b2 = Point();
  var c = Point();

  for (var i = 0; i < n; i++) {
    a1.x = p[2 * i];
    a1.y = p[2 * i + 1];
    if (i == n - 1) {
      a2.x = p[0];
      a2.y = p[1];
    } else {
      a2.x = p[2 * i + 2];
      a2.y = p[2 * i + 3];
    }

    for (var j = 0; j < n; j++) {
      if (Math.abs(i - j) < 2) continue
      if (j == n - 1 && i == 0) continue
      if (i == n - 1 && j == 0) continue

      b1.x = p[2 * j];
      b1.y = p[2 * j + 1];
      if (j == n - 1) {
        b2.x = p[0];
        b2.y = p[1];
      } else {
        b2.x = p[2 * j + 2];
        b2.y = p[2 * j + 3];
      }

      if (GetLineIntersection(a1, a2, b1, b2, c) != null) return false
    }
  }
  return true
}
module.exports.IsSimple = IsSimple;

/**
 * Checks, if polygon is convex. Polygon is convex, when each inner angle is <= 180°.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean}
 */
function IsConvex (polygon) {
  var p = polygon;
  if (p.length < 6) return true
  var l = p.length - 4;
  for (var i = 0; i < l; i += 2) {
    if (!convex(p[i], p[i + 1], p[i + 2], p[i + 3], p[i + 4], p[i + 5])) return false
  }
  if (!convex(p[l], p[l + 1], p[l + 2], p[l + 3], p[0], p[1])) return false
  if (!convex(p[l + 2], p[l + 3], p[0], p[1], p[2], p[3])) return false
  return true
}
module.exports.IsConvex = IsConvex;

/**
 * Returns the area of polygon.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number}
 */
function GetArea (polygon) {
  var p = polygon;
  if (p.length < 6) return 0
  var l = p.length - 2;
  var sum = 0;
  for (var i = 0; i < l; i += 2) {
    sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
  }
  sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
  return -sum * 0.5
}
module.exports.GetArea = GetArea;

/**
 * Returns the Axis-aligned Bounding Box of polygon
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {AABB}
 * @example
 * //={x:0, y:0, width:0, height:0}
 */
function GetAABB (polygon) {
  var p = polygon;
  var minx = Infinity;
  var miny = Infinity;
  var maxx = -minx;
  var maxy = -miny;
  for (var i = 0; i < p.length; i += 2) {
    minx = Math.min(minx, p[i]);
    maxx = Math.max(maxx, p[i]);
    miny = Math.min(miny, p[i + 1]);
    maxy = Math.max(maxy, p[i + 1]);
  }
  return {x: minx, y: miny, width: maxx - minx, height: maxy - miny}
}
module.exports.GetAABB = GetAABB;

/**
 * Computes the triangulation. Output array is array of triangles (triangle = 3 indices of polygon vertices).
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number[]} array of triangles (triangle = 3 indices of polygon vertices)
 * @example
 * var ids = PolyK.Triangulate([0, 0, 1, 0, 1, 1, 0, 1]);
 * //=[0, 1, 2, 0, 2, 3]
 */
function Triangulate (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 3) return []
  var tgs = [];
  var avl = [];
  for (var i = 0; i < n; i++) { avl.push(i); }

  var i = 0;
  var al = n;
  while (al > 3) {
    var i0 = avl[(i + 0) % al];
    var i1 = avl[(i + 1) % al];
    var i2 = avl[(i + 2) % al];

    var ax = p[2 * i0];
    var ay = p[2 * i0 + 1];
    var bx = p[2 * i1];
    var by = p[2 * i1 + 1];
    var cx = p[2 * i2];
    var cy = p[2 * i2 + 1];

    var earFound = false;
    if (convex(ax, ay, bx, by, cx, cy)) {
      earFound = true;
      for (var j = 0; j < al; j++) {
        var vi = avl[j];
        if (vi == i0 || vi == i1 || vi == i2) continue
        if (PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
          earFound = false;
          break
        }
      }
    }
    if (earFound) {
      tgs.push(i0, i1, i2);
      avl.splice((i + 1) % al, 1);
      al--;
      i = 0;
    } else if (i++ > 3 * al) break    // no convex angles :(
  }
  tgs.push(avl[0], avl[1], avl[2]);
  return tgs
}
module.exports.Triangulate = Triangulate;

/**
 * Slices the polygon with line segment A-B, defined by [ax,ay] and [bx,by]. A, B must not lay inside a polygon. Returns an array of polygons.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} startX Start Coordinate [x]
 * @param {number} startY Start Coordinate [y]
 * @param {number} endX End Coordinate [x]
 * @param {number} endY End Coordinate [y]
 * @returns {number[][]} Array of Polygon
 */
function Slice (polygon, startX, startY, endX, endY) {
  var p = polygon;
  var ax = startX;
  var ay = startY;
  var bx = endX;
  var by = endY;
  if (ContainsPoint(p, ax, ay) || ContainsPoint(p, bx, by)) {
    return [p.slice(0)]
  }

  var a = Point(ax, ay);
  var b = Point(bx, by);
  var iscs = [];  // intersections
  var ps = [];  // points
  for (var i = 0; i < p.length; i += 2) {
    ps.push(Point(p[i], p[i + 1]));
  }
  for (var i = 0; i < ps.length; i++) {
    var isc = Point(0, 0);
    isc = GetLineIntersection(a, b, ps[i], ps[(i + 1) % ps.length], isc);
    var fisc = iscs[0];
    var lisc = iscs[iscs.length - 1];
    // && (isc.x!=ps[i].x || isc.y!=ps[i].y) )
    if (isc && (fisc == null || distance(isc, fisc) > 1e-10) && (lisc == null || distance(isc, lisc) > 1e-10)) {
      isc.flag = true;
      iscs.push(isc);
      ps.splice(i + 1, 0, isc);
      i++;
    }
  }

  if (iscs.length < 2) return [p.slice(0)]
  var comp = function (u, v) { return distance(a, u) - distance(a, v) };
  iscs.sort(comp);

  var pgs = [];
  var dir = 0;
  while (iscs.length > 0) {
    // var n = ps.length // is assigned a value but never used. (no-unused-vars)
    var i0 = iscs[0];
    var i1 = iscs[1];
    // if(i0.x==i1.x && i0.y==i1.y) { iscs.splice(0,2); continue;}
    var index0 = ps.indexOf(i0);
    var index1 = ps.indexOf(i1);
    var solved = false;

    if (firstWithFlag(ps, index0) === index1) {
      solved = true;
    } else {
      i0 = iscs[1];
      i1 = iscs[0];
      index0 = ps.indexOf(i0);
      index1 = ps.indexOf(i1);
      if (firstWithFlag(ps, index0) === index1) solved = true;
    }
    if (solved) {
      dir--;
      var pgn = getPoints(ps, index0, index1);
      pgs.push(pgn);
      ps = getPoints(ps, index1, index0);
      i0.flag = i1.flag = false;
      iscs.splice(0, 2);
      if (iscs.length == 0) pgs.push(ps);
    } else {
      dir++;
      iscs.reverse();
    }
    if (dir > 1) break
  }
  var result = [];
  for (var i = 0; i < pgs.length; i++) {
    var pg = pgs[i];
    var npg = [];
    for (var j = 0; j < pg.length; j++) { npg.push(pg[j].x, pg[j].y); }
    result.push(npg);
  }
  return result
}
module.exports.Slice = Slice;

/**
 * Checks, if polygon contains [x, y].
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} pointX Coordinate [x]
 * @param {number} pointY Coordinate [y]
 * @returns {boolean} depth
 */
function ContainsPoint (polygon, pointX, pointY) {
  var p = polygon;
  var px = pointX;
  var py = pointY;
  var n = p.length >> 1;
  var ax;
  var ay = p[2 * n - 3] - py;
  var bx = p[2 * n - 2] - px;
  var by = p[2 * n - 1] - py;

  // var lup = by > ay;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay === by) continue
    var lup = by > ay;
  }

  var depth = 0;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay < 0 && by < 0) continue  // both "up" or both "down"
    if (ay > 0 && by > 0) continue  // both "up" or both "down"
    if (ax < 0 && bx < 0) continue   // both points on the left

    if (ay === by && Math.min(ax, bx) <= 0) return true
    if (ay === by) continue

    var lx = ax + (bx - ax) * (-ay) / (by - ay);
    if (lx === 0) return true      // point on edge
    if (lx > 0) depth++;
    if (ay === 0 && lup && by > ay) depth--;  // hit vertex, both up
    if (ay === 0 && !lup && by < ay) depth--; // hit vertex, both down
    lup = by > ay;
  }
  return (depth & 1) === 1
}
module.exports.ContainsPoint = ContainsPoint;

/**
 * Finds the closest point of polygon, which lays on ray defined by [x,y] (origin) and [dx,dy] (direction).
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the edge, on which intersection occurs, "norm" is the normal in that place, "refl" is reflected direction.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} originX Origin [x]
 * @param {number} originY Origin [y]
 * @param {number} directionX Direction [x]
 * @param {number} directionY Direction [y]
 * @returns {Raycast}
 * @example
 * //={dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}}
 */
function Raycast (polygon, originX, originY, directionX, directionY, isc) {
  var p = polygon;
  var x = originX;
  var y = originY;
  var dx = directionX;
  var dy = directionY;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var a2 = empty[1];
  var b1 = empty[2];
  var b2 = empty[3];
  var c = empty[4];
  a1.x = x;
  a1.y = y;
  a2.x = x + dx;
  a2.y = y + dy;

  if (isc === null || isc === undefined) {
    isc = {dist: 0, edge: 0, norm: {x: 0, y: 0}, refl: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  var nisc;
  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    nisc = RayLineIntersection(a1, a2, b1, b2, c);
    if (nisc) {
      isc = updateISC(dx, dy, a1, b1, b2, c, i / 2, isc);
    }
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  nisc = RayLineIntersection(a1, a2, b1, b2, c);
  if (nisc) {
    isc = updateISC(dx, dy, a1, b1, b2, c, (p.length / 2) - 1, isc);
  }

  return (isc.dist !== Infinity) ? isc : null
}
module.exports.Raycast = Raycast;

/**
 * Finds the point on polygon edges, which is closest to [x,y]. Returns an object in this format
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the closest edge, "point" is the closest point on that edge, "norm" is the normal from "point" to [x,y].
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} x Coordinate [x]
 * @param {number} y Coordinate [y]
 * @returns {ClosestEdge}
 * @example
 * //={dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}}
 */
function ClosestEdge (polygon, x, y, isc) {
  var p = polygon;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var b1 = empty[2];
  var b2 = empty[3];
  // var c = tp[4] // is assigned a value but never used.
  a1.x = x;
  a1.y = y;

  if (isc == null) {
    isc = {dist: 0, edge: 0, point: {x: 0, y: 0}, norm: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    isc = pointLineDist(a1, b1, b2, i >> 1, isc);
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  isc = pointLineDist(a1, b1, b2, l >> 1, isc);

  var idst = 1 / isc.dist;
  isc.norm.x = (x - isc.point.x) * idst;
  isc.norm.y = (y - isc.point.y) * idst;
  return isc
}
module.exports.ClosestEdge = ClosestEdge;

/**
 * Reverse
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 */
function Reverse (polygon) {
  var p = polygon;
  var np = [];
  for (var j = p.length - 2; j >= 0; j -= 2) { np.push(p[j], p[j + 1]); }
  return np
}
module.exports.Reverse = Reverse;

/**
 * Point Line Distance
 *
 * @private
 * @param {Point} p
 * @param {Point} a
 * @param {Point} b
 * @param {??} edge
 * @param {??} isc
 * @returns {??} ISC
 */
function pointLineDist (p, a, b, edge, isc) {
  var x = p.x;
  var y = p.y;
  var x1 = a.x;
  var y1 = a.y;
  var x2 = b.x;
  var y2 = b.y;

  var A = x - x1;
  var B = y - y1;
  var C = x2 - x1;
  var D = y2 - y1;

  var dot = A * C + B * D;
  var lenSq = C * C + D * D;
  var param = dot / lenSq;

  var xx;
  var yy;

  if (param < 0 || (x1 == x2 && y1 == y2)) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  var dx = x - xx;
  var dy = y - yy;
  var dst = Math.sqrt(dx * dx + dy * dy);
  if (dst < isc.dist) {
    isc.dist = dst;
    isc.edge = edge;
    isc.point.x = xx;
    isc.point.y = yy;
  }
  return isc
}

/**
 * Update ISC
 *
 * @private
 * @param {number} dx
 * @param {number} dy
 * @param {Point} a1
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @param {??} edge
 * @param {??} isc
 * @returns {??}
 */
function updateISC (dx, dy, a1, b1, b2, c, edge, isc) {
  var nrl = distance(a1, c);
  if (nrl < isc.dist) {
    var ibl = 1 / distance(b1, b2);
    var nx = -(b2.y - b1.y) * ibl;
    var ny = (b2.x - b1.x) * ibl;
    var ddot = 2 * (dx * nx + dy * ny);
    isc.dist = nrl;
    isc.norm.x = nx;
    isc.norm.y = ny;
    isc.refl.x = -ddot * nx + dx;
    isc.refl.y = -ddot * ny + dy;
    isc.edge = edge;
  }
  return isc
}

/**
 * Get Points
 *
 * @private
 * @param {number[]} points
 * @param {number} index0
 * @param {number} index1
 * @returns {number[]} points
 */
function getPoints (points, index0, index1) {
  var n = points.length;
  var result = [];
  if (index1 < index0) index1 += n;
  for (var i = index0; i <= index1; i++) { result.push(points[i % n]); }
  return result
}

/**
 * First With Flag
 *
 * @private
 * @param {Point[]} points
 * @param {number} index
 * @returns {number}
 */
function firstWithFlag (points, index) {
  var n = points.length;
  while (true) {
    index = (index + 1) % n;
    if (points[index].flag) {
      return index
    }
  }
}

/**
 * Point in Triangle
 *
 * @private
 * @param {number} px
 * @param {number} py
 * @param {number} ax
 * @param {number} ay
 * @param {number} bx
 * @param {number} by
 * @param {number} cx
 * @param {number} cy
 * @returns {boolean}
 */
function PointInTriangle (px, py, ax, ay, bx, by, cx, cy) {
  var v0x = cx - ax;
  var v0y = cy - ay;
  var v1x = bx - ax;
  var v1y = by - ay;
  var v2x = px - ax;
  var v2y = py - ay;

  var dot00 = v0x * v0x + v0y * v0y;
  var dot01 = v0x * v1x + v0y * v1y;
  var dot02 = v0x * v2x + v0y * v2y;
  var dot11 = v1x * v1x + v1y * v1y;
  var dot12 = v1x * v2x + v1y * v2y;

  var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
  var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

  // Check if point is in triangle
  return (u >= 0) && (v >= 0) && (u + v < 1)
}

/**
 * RayLine Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 */
function RayLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;
  if (Den == 0) return null  // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  var iDen = 1 / Den;
  I.x = (A * dbx - dax * B) * iDen;
  I.y = (A * dby - day * B) * iDen;

  if (!InRectangle(I, b1, b2)) return null
  if ((day > 0 && I.y > a1.y) || (day < 0 && I.y < a1.y)) return null
  if ((dax > 0 && I.x > a1.x) || (dax < 0 && I.x < a1.x)) return null
  return I
}

/**
 * Get Line Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @returns {Point}
 */
function GetLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;

  if (Den === 0) { return null } // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  I.x = (A * dbx - dax * B) / Den;
  I.y = (A * dby - day * B) / Den;

  if (InRectangle(I, a1, a2) && InRectangle(I, b1, b2)) {
    return I
  }
  return null
}

/**
 * In Rectangle
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @param {Point} c
 * @return {boolean}
 */
function InRectangle (a, b, c) {
  var minx = Math.min(b.x, c.x);
  var maxx = Math.max(b.x, c.x);
  var miny = Math.min(b.y, c.y);
  var maxy = Math.max(b.y, c.y);

  if (minx === maxx) { return (miny <= a.y && a.y <= maxy) }
  if (miny === maxy) { return (minx <= a.x && a.x <= maxx) }

  // return (minx <= a.x && a.x <= maxx && miny <= a.y && a.y <= maxy)
  return (minx <= a.x + 1e-10 && a.x - 1e-10 <= maxx && miny <= a.y + 1e-10 && a.y - 1e-10 <= maxy)
}

/**
 * Convex
 *
 * @private
 * @param {Point} ax
 * @param {Point} ay
 * @param {Point} bx
 * @param {Point} by
 * @param {Point} cx
 * @param {Point} cy
 * @returns {boolean}
 */
function convex (ax, ay, bx, by, cx, cy) {
  return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0
}

/**
 * Point
 *
 * @private
 * @param {number} x
 * @param {number} y
 * @returns {Point}
 */
function Point (x, y) {
  return {
    x: x,
    y: y,
    flag: false,
    toString: function () { return 'Point [' + x + ', ' + y + ']' }
  }
}

/**
 * Distance
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @returns {number}
 */
function distance (a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy)
}

/**
 * Creates an array of empty Points
 *
 * @private
 * @param {number} [num=10] Number of points
 * @returns {Point[]}
 */
function emptyPoints (num) {
  num = num || 10;
  var container = [];
  for (var i = 0; i < num; i++) { container.push(Point(0, 0)); }
  return container
}

})));


},{}],8:[function(require,module,exports){
var rough=function(){"use strict";function t(t,e,s){if(t&&t.length){const[n,a]=e,o=Math.PI/180*s,h=Math.cos(o),r=Math.sin(o);t.forEach(t=>{const[e,s]=t;t[0]=(e-n)*h-(s-a)*r+n,t[1]=(e-n)*r+(s-a)*h+a})}}function e(t){const e=t[0],s=t[1];return Math.sqrt(Math.pow(e[0]-s[0],2)+Math.pow(e[1]-s[1],2))}function s(e,s){const n=[0,0],a=Math.round(s.hachureAngle+90);a&&t(e,n,a);const o=function(t,e){const s=[...t];s[0].join(",")!==s[s.length-1].join(",")&&s.push([s[0][0],s[0][1]]);const n=[];if(s&&s.length>2){let t=e.hachureGap;t<0&&(t=4*e.strokeWidth),t=Math.max(t,.1);const a=[];for(let t=0;t<s.length-1;t++){const e=s[t],n=s[t+1];if(e[1]!==n[1]){const t=Math.min(e[1],n[1]);a.push({ymin:t,ymax:Math.max(e[1],n[1]),x:t===e[1]?e[0]:n[0],islope:(n[0]-e[0])/(n[1]-e[1])})}}if(a.sort((t,e)=>t.ymin<e.ymin?-1:t.ymin>e.ymin?1:t.x<e.x?-1:t.x>e.x?1:t.ymax===e.ymax?0:(t.ymax-e.ymax)/Math.abs(t.ymax-e.ymax)),!a.length)return n;let o=[],h=a[0].ymin;for(;o.length||a.length;){if(a.length){let t=-1;for(let e=0;e<a.length&&!(a[e].ymin>h);e++)t=e;a.splice(0,t+1).forEach(t=>{o.push({s:h,edge:t})})}if(o=o.filter(t=>!(t.edge.ymax<=h)),o.sort((t,e)=>t.edge.x===e.edge.x?0:(t.edge.x-e.edge.x)/Math.abs(t.edge.x-e.edge.x)),o.length>1)for(let t=0;t<o.length;t+=2){const e=t+1;if(e>=o.length)break;const s=o[t].edge,a=o[e].edge;n.push([[Math.round(s.x),h],[Math.round(a.x),h]])}h+=t,o.forEach(e=>{e.edge.x=e.edge.x+t*e.edge.islope})}}return n}(e,s);return a&&(t(e,n,-a),function(e,s,n){const a=[];e.forEach(t=>a.push(...t)),t(a,s,n)}(o,n,-a)),o}class n{constructor(t){this.helper=t}fillPolygon(t,e){return this._fillPolygon(t,e)}_fillPolygon(t,e,n=!1){const a=s(t,e);return{type:"fillSketch",ops:this.renderLines(a,e,n)}}renderLines(t,e,s){const n=[];let a=null;for(const o of t)n.push(...this.helper.doubleLineOps(o[0][0],o[0][1],o[1][0],o[1][1],e)),s&&a&&n.push(...this.helper.doubleLineOps(a[0],a[1],o[0][0],o[0][1],e)),a=o[1];return n}}class a extends n{fillPolygon(t,e){return this._fillPolygon(t,e,!0)}}class o extends n{fillPolygon(t,e){const s=this._fillPolygon(t,e),n=Object.assign({},e,{hachureAngle:e.hachureAngle+90}),a=this._fillPolygon(t,n);return s.ops=s.ops.concat(a.ops),s}}class h{constructor(t){this.helper=t}fillPolygon(t,e){const n=s(t,e=Object.assign({},e,{curveStepCount:4,hachureAngle:0,roughness:1}));return this.dotsOnLines(n,e)}dotsOnLines(t,s){const n=[];let a=s.hachureGap;a<0&&(a=4*s.strokeWidth),a=Math.max(a,.1);let o=s.fillWeight;o<0&&(o=s.strokeWidth/2);const h=a/4;for(const r of t){const t=e(r),i=t/a,c=Math.ceil(i)-1,l=t-c*a,u=(r[0][0]+r[1][0])/2-a/4,p=Math.min(r[0][1],r[1][1]);for(let t=0;t<c;t++){const e=p+l+t*a,r=this.helper.randOffsetWithRange(u-h,u+h,s),i=this.helper.randOffsetWithRange(e-h,e+h,s),c=this.helper.ellipse(r,i,o,o,s);n.push(...c.ops)}}return{type:"fillSketch",ops:n}}}class r{constructor(t){this.helper=t}fillPolygon(t,e){const n=s(t,e);return{type:"fillSketch",ops:this.dashedLine(n,e)}}dashedLine(t,s){const n=s.dashOffset<0?s.hachureGap<0?4*s.strokeWidth:s.hachureGap:s.dashOffset,a=s.dashGap<0?s.hachureGap<0?4*s.strokeWidth:s.hachureGap:s.dashGap,o=[];return t.forEach(t=>{const h=e(t),r=Math.floor(h/(n+a)),i=(h+a-r*(n+a))/2;let c=t[0],l=t[1];c[0]>l[0]&&(c=t[1],l=t[0]);const u=Math.atan((l[1]-c[1])/(l[0]-c[0]));for(let t=0;t<r;t++){const e=t*(n+a),h=e+n,r=[c[0]+e*Math.cos(u)+i*Math.cos(u),c[1]+e*Math.sin(u)+i*Math.sin(u)],l=[c[0]+h*Math.cos(u)+i*Math.cos(u),c[1]+h*Math.sin(u)+i*Math.sin(u)];o.push(...this.helper.doubleLineOps(r[0],r[1],l[0],l[1],s))}}),o}}class i{constructor(t){this.helper=t}fillPolygon(t,e){const n=e.hachureGap<0?4*e.strokeWidth:e.hachureGap,a=e.zigzagOffset<0?n:e.zigzagOffset,o=s(t,e=Object.assign({},e,{hachureGap:n+a}));return{type:"fillSketch",ops:this.zigzagLines(o,a,e)}}zigzagLines(t,s,n){const a=[];return t.forEach(t=>{const o=e(t),h=Math.round(o/(2*s));let r=t[0],i=t[1];r[0]>i[0]&&(r=t[1],i=t[0]);const c=Math.atan((i[1]-r[1])/(i[0]-r[0]));for(let t=0;t<h;t++){const e=2*t*s,o=2*(t+1)*s,h=Math.sqrt(2*Math.pow(s,2)),i=[r[0]+e*Math.cos(c),r[1]+e*Math.sin(c)],l=[r[0]+o*Math.cos(c),r[1]+o*Math.sin(c)],u=[i[0]+h*Math.cos(c+Math.PI/4),i[1]+h*Math.sin(c+Math.PI/4)];a.push(...this.helper.doubleLineOps(i[0],i[1],u[0],u[1],n),...this.helper.doubleLineOps(u[0],u[1],l[0],l[1],n))}}),a}}const c={};class l{constructor(t){this.seed=t}next(){return this.seed?(2**31-1&(this.seed=Math.imul(48271,this.seed)))/2**31:Math.random()}}const u={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function p(t,e){return t.type===e}function f(t){const e=[],s=function(t){const e=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:0,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];e[e.length]={type:1,text:""+parseFloat(RegExp.$1)},t=t.substr(RegExp.$1.length)}return e[e.length]={type:2,text:""},e}(t);let n="BOD",a=0,o=s[a];for(;!p(o,2);){let h=0;const r=[];if("BOD"===n){if("M"!==o.text&&"m"!==o.text)return f("M0,0"+t);a++,h=u[o.text],n=o.text}else p(o,1)?h=u[n]:(a++,h=u[o.text],n=o.text);if(!(a+h<s.length))throw new Error("Path data ended short");for(let t=a;t<a+h;t++){const e=s[t];if(!p(e,1))throw new Error("Param not a number: "+n+","+e.text);r[r.length]=+e.text}if("number"!=typeof u[n])throw new Error("Bad segment: "+n);{const t={key:n,data:r};e.push(t),a+=h,o=s[a],"M"===n&&(n="L"),"m"===n&&(n="l")}}return e}function d(t){let e=0,s=0,n=0,a=0;const o=[];for(const{key:h,data:r}of t)switch(h){case"M":o.push({key:"M",data:[...r]}),[e,s]=r,[n,a]=r;break;case"m":e+=r[0],s+=r[1],o.push({key:"M",data:[e,s]}),n=e,a=s;break;case"L":o.push({key:"L",data:[...r]}),[e,s]=r;break;case"l":e+=r[0],s+=r[1],o.push({key:"L",data:[e,s]});break;case"C":o.push({key:"C",data:[...r]}),e=r[4],s=r[5];break;case"c":{const t=r.map((t,n)=>n%2?t+s:t+e);o.push({key:"C",data:t}),e=t[4],s=t[5];break}case"Q":o.push({key:"Q",data:[...r]}),e=r[2],s=r[3];break;case"q":{const t=r.map((t,n)=>n%2?t+s:t+e);o.push({key:"Q",data:t}),e=t[2],s=t[3];break}case"A":o.push({key:"A",data:[...r]}),e=r[5],s=r[6];break;case"a":e+=r[5],s+=r[6],o.push({key:"A",data:[r[0],r[1],r[2],r[3],r[4],e,s]});break;case"H":o.push({key:"H",data:[...r]}),e=r[0];break;case"h":e+=r[0],o.push({key:"H",data:[e]});break;case"V":o.push({key:"V",data:[...r]}),s=r[0];break;case"v":s+=r[0],o.push({key:"V",data:[s]});break;case"S":o.push({key:"S",data:[...r]}),e=r[2],s=r[3];break;case"s":{const t=r.map((t,n)=>n%2?t+s:t+e);o.push({key:"S",data:t}),e=t[2],s=t[3];break}case"T":o.push({key:"T",data:[...r]}),e=r[0],s=r[1];break;case"t":e+=r[0],s+=r[1],o.push({key:"T",data:[e,s]});break;case"Z":case"z":o.push({key:"Z",data:[]}),e=n,s=a}return o}function g(t){const e=[];let s="",n=0,a=0,o=0,h=0,r=0,i=0;for(const{key:c,data:l}of t){switch(c){case"M":e.push({key:"M",data:[...l]}),[n,a]=l,[o,h]=l;break;case"C":e.push({key:"C",data:[...l]}),n=l[4],a=l[5],r=l[2],i=l[3];break;case"L":e.push({key:"L",data:[...l]}),[n,a]=l;break;case"H":n=l[0],e.push({key:"L",data:[n,a]});break;case"V":a=l[0],e.push({key:"L",data:[n,a]});break;case"S":{let t=0,o=0;"C"===s||"S"===s?(t=n+(n-r),o=a+(a-i)):(t=n,o=a),e.push({key:"C",data:[t,o,...l]}),r=l[0],i=l[1],n=l[2],a=l[3];break}case"T":{const[t,o]=l;let h=0,c=0;"Q"===s||"T"===s?(h=n+(n-r),c=a+(a-i)):(h=n,c=a);const u=n+2*(h-n)/3,p=a+2*(c-a)/3,f=t+2*(h-t)/3,d=o+2*(c-o)/3;e.push({key:"C",data:[u,p,f,d,t,o]}),r=h,i=c,n=t,a=o;break}case"Q":{const[t,s,o,h]=l,c=n+2*(t-n)/3,u=a+2*(s-a)/3,p=o+2*(t-o)/3,f=h+2*(s-h)/3;e.push({key:"C",data:[c,u,p,f,o,h]}),r=t,i=s,n=o,a=h;break}case"A":{const t=Math.abs(l[0]),s=Math.abs(l[1]),o=l[2],h=l[3],r=l[4],i=l[5],c=l[6];if(0===t||0===s)e.push({key:"C",data:[n,a,i,c,i,c]}),n=i,a=c;else if(n!==i||a!==c){k(n,a,i,c,t,s,o,h,r).forEach((function(t){e.push({key:"C",data:t})})),n=i,a=c}break}case"Z":e.push({key:"Z",data:[]}),n=o,a=h}s=c}return e}function M(t,e,s){return[t*Math.cos(s)-e*Math.sin(s),t*Math.sin(s)+e*Math.cos(s)]}function k(t,e,s,n,a,o,h,r,i,c){const l=(u=h,Math.PI*u/180);var u;let p=[],f=0,d=0,g=0,y=0;if(c)[f,d,g,y]=c;else{[t,e]=M(t,e,-l),[s,n]=M(s,n,-l);const h=(t-s)/2,c=(e-n)/2;let u=h*h/(a*a)+c*c/(o*o);u>1&&(u=Math.sqrt(u),a*=u,o*=u);const p=a*a,k=o*o,m=p*k-p*c*c-k*h*h,b=p*c*c+k*h*h,w=(r===i?-1:1)*Math.sqrt(Math.abs(m/b));g=w*a*c/o+(t+s)/2,y=w*-o*h/a+(e+n)/2,f=Math.asin(parseFloat(((e-y)/o).toFixed(9))),d=Math.asin(parseFloat(((n-y)/o).toFixed(9))),t<g&&(f=Math.PI-f),s<g&&(d=Math.PI-d),f<0&&(f=2*Math.PI+f),d<0&&(d=2*Math.PI+d),i&&f>d&&(f-=2*Math.PI),!i&&d>f&&(d-=2*Math.PI)}let m=d-f;if(Math.abs(m)>120*Math.PI/180){const t=d,e=s,r=n;d=i&&d>f?f+120*Math.PI/180*1:f+120*Math.PI/180*-1,p=k(s=g+a*Math.cos(d),n=y+o*Math.sin(d),e,r,a,o,h,0,i,[d,t,g,y])}m=d-f;const b=Math.cos(f),w=Math.sin(f),P=Math.cos(d),x=Math.sin(d),v=Math.tan(m/4),S=4/3*a*v,O=4/3*o*v,T=[t,e],C=[t+S*w,e-O*b],W=[s+S*x,n-O*P],_=[s,n];if(C[0]=2*T[0]-C[0],C[1]=2*T[1]-C[1],c)return[C,W,_].concat(p);{p=[C,W,_].concat(p);const t=[];for(let e=0;e<p.length;e+=3){const s=M(p[e][0],p[e][1],l),n=M(p[e+1][0],p[e+1][1],l),a=M(p[e+2][0],p[e+2][1],l);t.push([s[0],s[1],n[0],n[1],a[0],a[1]])}return t}}const y={randOffset:function(t,e){return W(t,e)},randOffsetWithRange:function(t,e,s){return C(t,e,s)},ellipse:function(t,e,s,n,a){const o=P(s,n,a);return x(t,e,a,o).opset},doubleLineOps:function(t,e,s,n,a){return _(t,e,s,n,a)}};function m(t,e,s,n,a){return{type:"path",ops:_(t,e,s,n,a)}}function b(t,e,s){const n=(t||[]).length;if(n>2){const a=[];for(let e=0;e<n-1;e++)a.push(..._(t[e][0],t[e][1],t[e+1][0],t[e+1][1],s));return e&&a.push(..._(t[n-1][0],t[n-1][1],t[0][0],t[0][1],s)),{type:"path",ops:a}}return 2===n?m(t[0][0],t[0][1],t[1][0],t[1][1],s):{type:"path",ops:[]}}function w(t,e,s,n,a){return function(t,e){return b(t,!0,e)}([[t,e],[t+s,e],[t+s,e+n],[t,e+n]],a)}function P(t,e,s){const n=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),a=Math.max(s.curveStepCount,s.curveStepCount/Math.sqrt(200)*n),o=2*Math.PI/a;let h=Math.abs(t/2),r=Math.abs(e/2);const i=1-s.curveFitting;return h+=W(h*i,s),r+=W(r*i,s),{increment:o,rx:h,ry:r}}function x(t,e,s,n){const[a,o]=z(n.increment,t,e,n.rx,n.ry,1,n.increment*C(.1,C(.4,1,s),s),s),[h]=z(n.increment,t,e,n.rx,n.ry,1.5,0,s),r=E(a,null,s),i=E(h,null,s);return{estimatedPoints:o,opset:{type:"path",ops:r.concat(i)}}}function v(t,e,s,n,a,o,h,r,i){const c=t,l=e;let u=Math.abs(s/2),p=Math.abs(n/2);u+=W(.01*u,i),p+=W(.01*p,i);let f=a,d=o;for(;f<0;)f+=2*Math.PI,d+=2*Math.PI;d-f>2*Math.PI&&(f=0,d=2*Math.PI);const g=2*Math.PI/i.curveStepCount,M=Math.min(g/2,(d-f)/2),k=R(M,c,l,u,p,f,d,1,i),y=R(M,c,l,u,p,f,d,1.5,i),m=k.concat(y);return h&&(r?m.push(..._(c,l,c+u*Math.cos(f),l+p*Math.sin(f),i),..._(c,l,c+u*Math.cos(d),l+p*Math.sin(d),i)):m.push({op:"lineTo",data:[c,l]},{op:"lineTo",data:[c+u*Math.cos(f),l+p*Math.sin(f)]})),{type:"path",ops:m}}function S(t,e){const s=[];if(t.length){const n=e.maxRandomnessOffset||0,a=t.length;if(a>2){s.push({op:"move",data:[t[0][0]+W(n,e),t[0][1]+W(n,e)]});for(let o=1;o<a;o++)s.push({op:"lineTo",data:[t[o][0]+W(n,e),t[o][1]+W(n,e)]})}}return{type:"fillPath",ops:s}}function O(t,e){return function(t,e){let s=t.fillStyle||"hachure";if(!c[s])switch(s){case"zigzag":c[s]||(c[s]=new a(e));break;case"cross-hatch":c[s]||(c[s]=new o(e));break;case"dots":c[s]||(c[s]=new h(e));break;case"dashed":c[s]||(c[s]=new r(e));break;case"zigzag-line":c[s]||(c[s]=new i(e));break;case"hachure":default:s="hachure",c[s]||(c[s]=new n(e))}return c[s]}(e,y).fillPolygon(t,e)}function T(t){return t.randomizer||(t.randomizer=new l(t.seed||0)),t.randomizer.next()}function C(t,e,s,n=1){return s.roughness*n*(T(s)*(e-t)+t)}function W(t,e,s=1){return C(-t,t,e,s)}function _(t,e,s,n,a){const o=I(t,e,s,n,a,!0,!1),h=I(t,e,s,n,a,!0,!0);return o.concat(h)}function I(t,e,s,n,a,o,h){const r=Math.pow(t-s,2)+Math.pow(e-n,2),i=Math.sqrt(r);let c=1;c=i<200?1:i>500?.4:-.0016668*i+1.233334;let l=a.maxRandomnessOffset||0;l*l*100>r&&(l=i/10);const u=l/2,p=.2+.2*T(a);let f=a.bowing*a.maxRandomnessOffset*(n-e)/200,d=a.bowing*a.maxRandomnessOffset*(t-s)/200;f=W(f,a,c),d=W(d,a,c);const g=[],M=()=>W(u,a,c),k=()=>W(l,a,c);return o&&(h?g.push({op:"move",data:[t+M(),e+M()]}):g.push({op:"move",data:[t+W(l,a,c),e+W(l,a,c)]})),h?g.push({op:"bcurveTo",data:[f+t+(s-t)*p+M(),d+e+(n-e)*p+M(),f+t+2*(s-t)*p+M(),d+e+2*(n-e)*p+M(),s+M(),n+M()]}):g.push({op:"bcurveTo",data:[f+t+(s-t)*p+k(),d+e+(n-e)*p+k(),f+t+2*(s-t)*p+k(),d+e+2*(n-e)*p+k(),s+k(),n+k()]}),g}function L(t,e,s){const n=[];n.push([t[0][0]+W(e,s),t[0][1]+W(e,s)]),n.push([t[0][0]+W(e,s),t[0][1]+W(e,s)]);for(let a=1;a<t.length;a++)n.push([t[a][0]+W(e,s),t[a][1]+W(e,s)]),a===t.length-1&&n.push([t[a][0]+W(e,s),t[a][1]+W(e,s)]);return E(n,null,s)}function E(t,e,s){const n=t.length,a=[];if(n>3){const o=[],h=1-s.curveTightness;a.push({op:"move",data:[t[1][0],t[1][1]]});for(let e=1;e+2<n;e++){const s=t[e];o[0]=[s[0],s[1]],o[1]=[s[0]+(h*t[e+1][0]-h*t[e-1][0])/6,s[1]+(h*t[e+1][1]-h*t[e-1][1])/6],o[2]=[t[e+1][0]+(h*t[e][0]-h*t[e+2][0])/6,t[e+1][1]+(h*t[e][1]-h*t[e+2][1])/6],o[3]=[t[e+1][0],t[e+1][1]],a.push({op:"bcurveTo",data:[o[1][0],o[1][1],o[2][0],o[2][1],o[3][0],o[3][1]]})}if(e&&2===e.length){const t=s.maxRandomnessOffset;a.push({op:"lineTo",data:[e[0]+W(t,s),e[1]+W(t,s)]})}}else 3===n?(a.push({op:"move",data:[t[1][0],t[1][1]]}),a.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===n&&a.push(..._(t[0][0],t[0][1],t[1][0],t[1][1],s));return a}function z(t,e,s,n,a,o,h,r){const i=[],c=[],l=W(.5,r)-Math.PI/2;c.push([W(o,r)+e+.9*n*Math.cos(l-t),W(o,r)+s+.9*a*Math.sin(l-t)]);for(let h=l;h<2*Math.PI+l-.01;h+=t){const t=[W(o,r)+e+n*Math.cos(h),W(o,r)+s+a*Math.sin(h)];i.push(t),c.push(t)}return c.push([W(o,r)+e+n*Math.cos(l+2*Math.PI+.5*h),W(o,r)+s+a*Math.sin(l+2*Math.PI+.5*h)]),c.push([W(o,r)+e+.98*n*Math.cos(l+h),W(o,r)+s+.98*a*Math.sin(l+h)]),c.push([W(o,r)+e+.9*n*Math.cos(l+.5*h),W(o,r)+s+.9*a*Math.sin(l+.5*h)]),[c,i]}function R(t,e,s,n,a,o,h,r,i){const c=o+W(.1,i),l=[];l.push([W(r,i)+e+.9*n*Math.cos(c-t),W(r,i)+s+.9*a*Math.sin(c-t)]);for(let o=c;o<=h;o+=t)l.push([W(r,i)+e+n*Math.cos(o),W(r,i)+s+a*Math.sin(o)]);return l.push([e+n*Math.cos(h),s+a*Math.sin(h)]),l.push([e+n*Math.cos(h),s+a*Math.sin(h)]),E(l,null,i)}function A(t,e,s,n,a,o,h,r){const i=[],c=[r.maxRandomnessOffset||1,(r.maxRandomnessOffset||1)+.3];let l=[0,0];for(let u=0;u<2;u++)0===u?i.push({op:"move",data:[h[0],h[1]]}):i.push({op:"move",data:[h[0]+W(c[0],r),h[1]+W(c[0],r)]}),l=[a+W(c[u],r),o+W(c[u],r)],i.push({op:"bcurveTo",data:[t+W(c[u],r),e+W(c[u],r),s+W(c[u],r),n+W(c[u],r),l[0],l[1]]});return i}function $(t){return[...t]}function q(t,e){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function G(t,e,s){const n=q(e,s);if(0===n)return q(t,e);let a=((t[0]-e[0])*(s[0]-e[0])+(t[1]-e[1])*(s[1]-e[1]))/n;return a=Math.max(0,Math.min(1,a)),q(t,Z(e,s,a))}function Z(t,e,s){return[t[0]+(e[0]-t[0])*s,t[1]+(e[1]-t[1])*s]}function D(t,e,s,n){const a=n||[];if(function(t,e){const s=t[e+0],n=t[e+1],a=t[e+2],o=t[e+3];let h=3*n[0]-2*s[0]-o[0];h*=h;let r=3*n[1]-2*s[1]-o[1];r*=r;let i=3*a[0]-2*o[0]-s[0];i*=i;let c=3*a[1]-2*o[1]-s[1];return c*=c,h<i&&(h=i),r<c&&(r=c),h+r}(t,e)<s){const s=t[e+0];if(a.length){(o=a[a.length-1],h=s,Math.sqrt(q(o,h)))>1&&a.push(s)}else a.push(s);a.push(t[e+3])}else{const n=.5,o=t[e+0],h=t[e+1],r=t[e+2],i=t[e+3],c=Z(o,h,n),l=Z(h,r,n),u=Z(r,i,n),p=Z(c,l,n),f=Z(l,u,n),d=Z(p,f,n);D([o,c,p,d],0,s,a),D([d,f,u,i],0,s,a)}var o,h;return a}function F(t,e){return Q(t,0,t.length,e)}function Q(t,e,s,n,a){const o=a||[],h=t[e],r=t[s-1];let i=0,c=1;for(let n=e+1;n<s-1;++n){const e=G(t[n],h,r);e>i&&(i=e,c=n)}return Math.sqrt(i)>n?(Q(t,e,c+1,n,o),Q(t,c,s,n,o)):(o.length||o.push(h),o.push(r)),o}function j(t,e=.15,s){const n=[],a=(t.length-1)/3;for(let s=0;s<a;s++){D(t,3*s,e,n)}return s&&s>0?Q(n,0,n.length,s):n}const H="none";class N{constructor(t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,combineNestedSvgPaths:!1},this.config=t||{},this.config.options&&(this.defaultOptions=this._o(this.config.options))}static newSeed(){return Math.floor(Math.random()*2**31)}_o(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions}_d(t,e,s){return{shape:t,sets:e||[],options:s||this.defaultOptions}}line(t,e,s,n,a){const o=this._o(a);return this._d("line",[m(t,e,s,n,o)],o)}rectangle(t,e,s,n,a){const o=this._o(a),h=[],r=w(t,e,s,n,o);if(o.fill){const a=[[t,e],[t+s,e],[t+s,e+n],[t,e+n]];"solid"===o.fillStyle?h.push(S(a,o)):h.push(O(a,o))}return o.stroke!==H&&h.push(r),this._d("rectangle",h,o)}ellipse(t,e,s,n,a){const o=this._o(a),h=[],r=P(s,n,o),i=x(t,e,o,r);if(o.fill)if("solid"===o.fillStyle){const s=x(t,e,o,r).opset;s.type="fillPath",h.push(s)}else h.push(O(i.estimatedPoints,o));return o.stroke!==H&&h.push(i.opset),this._d("ellipse",h,o)}circle(t,e,s,n){const a=this.ellipse(t,e,s,s,n);return a.shape="circle",a}linearPath(t,e){const s=this._o(e);return this._d("linearPath",[b(t,!1,s)],s)}arc(t,e,s,n,a,o,h=!1,r){const i=this._o(r),c=[],l=v(t,e,s,n,a,o,h,!0,i);if(h&&i.fill)if("solid"===i.fillStyle){const h=v(t,e,s,n,a,o,!0,!1,i);h.type="fillPath",c.push(h)}else c.push(function(t,e,s,n,a,o,h){const r=t,i=e;let c=Math.abs(s/2),l=Math.abs(n/2);c+=W(.01*c,h),l+=W(.01*l,h);let u=a,p=o;for(;u<0;)u+=2*Math.PI,p+=2*Math.PI;p-u>2*Math.PI&&(u=0,p=2*Math.PI);const f=(p-u)/h.curveStepCount,d=[];for(let t=u;t<=p;t+=f)d.push([r+c*Math.cos(t),i+l*Math.sin(t)]);return d.push([r+c*Math.cos(p),i+l*Math.sin(p)]),d.push([r,i]),O(d,h)}(t,e,s,n,a,o,i));return i.stroke!==H&&c.push(l),this._d("arc",c,i)}curve(t,e){const s=this._o(e),n=[],a=function(t,e){const s=L(t,1*(1+.2*e.roughness),e),n=L(t,1.5*(1+.22*e.roughness),e);return{type:"path",ops:s.concat(n)}}(t,s);if(s.fill&&s.fill!==H&&t.length>=3){const e=j(function(t,e=0){const s=t.length;if(s<3)throw new Error("A curve must have at least three points.");const n=[];if(3===s)n.push($(t[0]),$(t[1]),$(t[2]),$(t[2]));else{const s=[];s.push(t[0],t[0]);for(let e=1;e<t.length;e++)s.push(t[e]),e===t.length-1&&s.push(t[e]);const a=[],o=1-e;n.push($(s[0]));for(let t=1;t+2<s.length;t++){const e=s[t];a[0]=[e[0],e[1]],a[1]=[e[0]+(o*s[t+1][0]-o*s[t-1][0])/6,e[1]+(o*s[t+1][1]-o*s[t-1][1])/6],a[2]=[s[t+1][0]+(o*s[t][0]-o*s[t+2][0])/6,s[t+1][1]+(o*s[t][1]-o*s[t+2][1])/6],a[3]=[s[t+1][0],s[t+1][1]],n.push(a[1],a[2],a[3])}}return n}(t),10,(1+s.roughness)/2);"solid"===s.fillStyle?n.push(S(e,s)):n.push(O(e,s))}return s.stroke!==H&&n.push(a),this._d("curve",n,s)}polygon(t,e){const s=this._o(e),n=[],a=b(t,!0,s);return s.fill&&("solid"===s.fillStyle?n.push(S(t,s)):n.push(O(t,s))),s.stroke!==H&&n.push(a),this._d("polygon",n,s)}path(t,e){const s=this._o(e),n=[];if(!t)return this._d("path",n,s);t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");const a=s.fill&&"transparent"!==s.fill&&s.fill!==H,o=s.stroke!==H,h=!!(s.simplification&&s.simplification<1),r=function(t,e,s){const n=g(d(f(t))),a=[];let o=[],h=[0,0],r=[];const i=()=>{r.length>=4&&o.push(...j(r,e)),r=[]},c=()=>{i(),o.length&&(a.push(o),o=[])};for(const{key:t,data:e}of n)switch(t){case"M":c(),h=[e[0],e[1]],o.push(h);break;case"L":i(),o.push([e[0],e[1]]);break;case"C":if(!r.length){const t=o.length?o[o.length-1]:h;r.push([t[0],t[1]])}r.push([e[0],e[1]]),r.push([e[2],e[3]]),r.push([e[4],e[5]]);break;case"Z":i(),o.push([h[0],h[1]])}if(c(),!s)return a;const l=[];for(const t of a){const e=F(t,s);e.length&&l.push(e)}return l}(t,1,h?4-4*s.simplification:(1+s.roughness)/2);if(a)if(s.combineNestedSvgPaths){const t=[];r.forEach(e=>t.push(...e)),"solid"===s.fillStyle?n.push(S(t,s)):n.push(O(t,s))}else r.forEach(t=>{"solid"===s.fillStyle?n.push(S(t,s)):n.push(O(t,s))});return o&&(h?r.forEach(t=>{n.push(b(t,!1,s))}):n.push(function(t,e){const s=g(d(f(t))),n=[];let a=[0,0],o=[0,0];for(const{key:t,data:h}of s)switch(t){case"M":{const t=1*(e.maxRandomnessOffset||0);n.push({op:"move",data:h.map(s=>s+W(t,e))}),o=[h[0],h[1]],a=[h[0],h[1]];break}case"L":n.push(..._(o[0],o[1],h[0],h[1],e)),o=[h[0],h[1]];break;case"C":{const[t,s,a,r,i,c]=h;n.push(...A(t,s,a,r,i,c,o,e)),o=[i,c];break}case"Z":n.push(..._(o[0],o[1],a[0],a[1],e)),o=[a[0],a[1]]}return{type:"path",ops:n}}(t,s))),this._d("path",n,s)}opsToPath(t){let e="";for(const s of t.ops){const t=s.data;switch(s.op){case"move":e+=`M${t[0]} ${t[1]} `;break;case"bcurveTo":e+=`C${t[0]} ${t[1]}, ${t[2]} ${t[3]}, ${t[4]} ${t[5]} `;break;case"lineTo":e+=`L${t[0]} ${t[1]} `}}return e.trim()}toPaths(t){const e=t.sets||[],s=t.options||this.defaultOptions,n=[];for(const t of e){let e=null;switch(t.type){case"path":e={d:this.opsToPath(t),stroke:s.stroke,strokeWidth:s.strokeWidth,fill:H};break;case"fillPath":e={d:this.opsToPath(t),stroke:H,strokeWidth:0,fill:s.fill||H};break;case"fillSketch":e=this.fillSketch(t,s)}e&&n.push(e)}return n}fillSketch(t,e){let s=e.fillWeight;return s<0&&(s=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill||H,strokeWidth:s,fill:H}}}class V{constructor(t,e){this.canvas=t,this.ctx=this.canvas.getContext("2d"),this.gen=new N(e)}draw(t){const e=t.sets||[],s=t.options||this.getDefaultOptions(),n=this.ctx;for(const a of e)switch(a.type){case"path":n.save(),n.strokeStyle="none"===s.stroke?"transparent":s.stroke,n.lineWidth=s.strokeWidth,this._drawToContext(n,a),n.restore();break;case"fillPath":n.save(),n.fillStyle=s.fill||"";const e="curve"===t.shape||"polygon"===t.shape?"evenodd":"nonzero";this._drawToContext(n,a,e),n.restore();break;case"fillSketch":this.fillSketch(n,a,s)}}fillSketch(t,e,s){let n=s.fillWeight;n<0&&(n=s.strokeWidth/2),t.save(),t.strokeStyle=s.fill||"",t.lineWidth=n,this._drawToContext(t,e),t.restore()}_drawToContext(t,e,s="nonzero"){t.beginPath();for(const s of e.ops){const e=s.data;switch(s.op){case"move":t.moveTo(e[0],e[1]);break;case"bcurveTo":t.bezierCurveTo(e[0],e[1],e[2],e[3],e[4],e[5]);break;case"lineTo":t.lineTo(e[0],e[1])}}"fillPath"===e.type?t.fill(s):t.stroke()}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}line(t,e,s,n,a){const o=this.gen.line(t,e,s,n,a);return this.draw(o),o}rectangle(t,e,s,n,a){const o=this.gen.rectangle(t,e,s,n,a);return this.draw(o),o}ellipse(t,e,s,n,a){const o=this.gen.ellipse(t,e,s,n,a);return this.draw(o),o}circle(t,e,s,n){const a=this.gen.circle(t,e,s,n);return this.draw(a),a}linearPath(t,e){const s=this.gen.linearPath(t,e);return this.draw(s),s}polygon(t,e){const s=this.gen.polygon(t,e);return this.draw(s),s}arc(t,e,s,n,a,o,h=!1,r){const i=this.gen.arc(t,e,s,n,a,o,h,r);return this.draw(i),i}curve(t,e){const s=this.gen.curve(t,e);return this.draw(s),s}path(t,e){const s=this.gen.path(t,e);return this.draw(s),s}}const B="http://www.w3.org/2000/svg";class J{constructor(t,e){this.svg=t,this.gen=new N(e)}draw(t){const e=t.sets||[],s=t.options||this.getDefaultOptions(),n=this.svg.ownerDocument||window.document,a=n.createElementNS(B,"g");for(const t of e){let e=null;switch(t.type){case"path":e=n.createElementNS(B,"path"),e.setAttribute("d",this.opsToPath(t)),e.style.stroke=s.stroke,e.style.strokeWidth=s.strokeWidth+"",e.style.fill="none";break;case"fillPath":e=n.createElementNS(B,"path"),e.setAttribute("d",this.opsToPath(t)),e.style.stroke="none",e.style.strokeWidth="0",e.style.fill=s.fill||"";break;case"fillSketch":e=this.fillSketch(n,t,s)}e&&a.appendChild(e)}return a}fillSketch(t,e,s){let n=s.fillWeight;n<0&&(n=s.strokeWidth/2);const a=t.createElementNS(B,"path");return a.setAttribute("d",this.opsToPath(e)),a.style.stroke=s.fill||"",a.style.strokeWidth=n+"",a.style.fill="none",a}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}opsToPath(t){return this.gen.opsToPath(t)}line(t,e,s,n,a){const o=this.gen.line(t,e,s,n,a);return this.draw(o)}rectangle(t,e,s,n,a){const o=this.gen.rectangle(t,e,s,n,a);return this.draw(o)}ellipse(t,e,s,n,a){const o=this.gen.ellipse(t,e,s,n,a);return this.draw(o)}circle(t,e,s,n){const a=this.gen.circle(t,e,s,n);return this.draw(a)}linearPath(t,e){const s=this.gen.linearPath(t,e);return this.draw(s)}polygon(t,e){const s=this.gen.polygon(t,e);return this.draw(s)}arc(t,e,s,n,a,o,h=!1,r){const i=this.gen.arc(t,e,s,n,a,o,h,r);return this.draw(i)}curve(t,e){const s=this.gen.curve(t,e);return this.draw(s)}path(t,e){const s=this.gen.path(t,e);return this.draw(s)}}return{canvas:(t,e)=>new V(t,e),svg:(t,e)=>new J(t,e),generator:t=>new N(t),newSeed:()=>N.newSeed()}}();

},{}],9:[function(require,module,exports){
/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.


 Copyright (c) 2018 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
(function() {
  'use strict';

  var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
  var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
  var F3 = 1.0 / 3.0;
  var G3 = 1.0 / 6.0;
  var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
  var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;

  function SimplexNoise(randomOrSeed) {
    var random;
    if (typeof randomOrSeed == 'function') {
      random = randomOrSeed;
    }
    else if (randomOrSeed) {
      random = alea(randomOrSeed);
    } else {
      random = Math.random;
    }
    this.p = buildPermutationTable(random);
    this.perm = new Uint8Array(512);
    this.permMod12 = new Uint8Array(512);
    for (var i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }

  }
  SimplexNoise.prototype = {
    grad3: new Float32Array([1, 1, 0,
      -1, 1, 0,
      1, -1, 0,

      -1, -1, 0,
      1, 0, 1,
      -1, 0, 1,

      1, 0, -1,
      -1, 0, -1,
      0, 1, 1,

      0, -1, 1,
      0, 1, -1,
      0, -1, -1]),
    grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,
      0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,
      1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,
      -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,
      1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,
      -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,
      1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,
      -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
    noise2D: function(xin, yin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0 = 0; // Noise contributions from the three corners
      var n1 = 0;
      var n2 = 0;
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin) * F2; // Hairy factor for 2D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var t = (i + j) * G2;
      var X0 = i - t; // Unskew the cell origin back to (x,y) space
      var Y0 = j - t;
      var x0 = xin - X0; // The x,y distances from the cell origin
      var y0 = yin - Y0;
      // For the 2D case, the simplex shape is an equilateral triangle.
      // Determine which simplex we are in.
      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      else {
        i1 = 0;
        j1 = 1;
      } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
      // c = (3-sqrt(3))/6
      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
      var y1 = y0 - j1 + G2;
      var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
      var y2 = y0 - 1.0 + 2.0 * G2;
      // Work out the hashed gradient indices of the three simplex corners
      var ii = i & 255;
      var jj = j & 255;
      // Calculate the contribution from the three corners
      var t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 >= 0) {
        var gi0 = permMod12[ii + perm[jj]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 >= 0) {
        var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
      }
      var t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 >= 0) {
        var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 70.0 * (n0 + n1 + n2);
    },
    // 3D simplex noise
    noise3D: function(xin, yin, zin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0, n1, n2, n3; // Noise contributions from the four corners
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var k = Math.floor(zin + s);
      var t = (i + j + k) * G3;
      var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
      var Y0 = j - t;
      var Z0 = k - t;
      var x0 = xin - X0; // The x,y,z distances from the cell origin
      var y0 = yin - Y0;
      var z0 = zin - Z0;
      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
      // Determine which simplex we are in.
      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // X Y Z order
        else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // X Z Y order
        else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // Z X Y order
      }
      else { // x0<y0
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Z Y X order
        else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Y Z X order
        else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // Y X Z order
      }
      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
      // c = 1/6.
      var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;
      var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
      var y2 = y0 - j2 + 2.0 * G3;
      var z2 = z0 - k2 + 2.0 * G3;
      var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
      var y3 = y0 - 1.0 + 3.0 * G3;
      var z3 = z0 - 1.0 + 3.0 * G3;
      // Work out the hashed gradient indices of the four simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      // Calculate the contribution from the four corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
        t3 *= t3;
        n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to stay just inside [-1,1]
      return 32.0 * (n0 + n1 + n2 + n3);
    },
    // 4D simplex noise, better simplex rank ordering method 2012-03-09
    noise4D: function(x, y, z, w) {
      var perm = this.perm;
      var grad4 = this.grad4;

      var n0, n1, n2, n3, n4; // Noise contributions from the five corners
      // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
      var s = (x + y + z + w) * F4; // Factor for 4D skewing
      var i = Math.floor(x + s);
      var j = Math.floor(y + s);
      var k = Math.floor(z + s);
      var l = Math.floor(w + s);
      var t = (i + j + k + l) * G4; // Factor for 4D unskewing
      var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
      var Y0 = j - t;
      var Z0 = k - t;
      var W0 = l - t;
      var x0 = x - X0; // The x,y,z,w distances from the cell origin
      var y0 = y - Y0;
      var z0 = z - Z0;
      var w0 = w - W0;
      // For the 4D case, the simplex is a 4D shape I won't even try to describe.
      // To find out which of the 24 possible simplices we're in, we need to
      // determine the magnitude ordering of x0, y0, z0 and w0.
      // Six pair-wise comparisons are performed between each possible pair
      // of the four coordinates, and the results are used to rank the numbers.
      var rankx = 0;
      var ranky = 0;
      var rankz = 0;
      var rankw = 0;
      if (x0 > y0) rankx++;
      else ranky++;
      if (x0 > z0) rankx++;
      else rankz++;
      if (x0 > w0) rankx++;
      else rankw++;
      if (y0 > z0) ranky++;
      else rankz++;
      if (y0 > w0) ranky++;
      else rankw++;
      if (z0 > w0) rankz++;
      else rankw++;
      var i1, j1, k1, l1; // The integer offsets for the second simplex corner
      var i2, j2, k2, l2; // The integer offsets for the third simplex corner
      var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
      // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
      // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
      // impossible. Only the 24 indices which have non-zero entries make any sense.
      // We use a thresholding to set the coordinates in turn from the largest magnitude.
      // Rank 3 denotes the largest coordinate.
      i1 = rankx >= 3 ? 1 : 0;
      j1 = ranky >= 3 ? 1 : 0;
      k1 = rankz >= 3 ? 1 : 0;
      l1 = rankw >= 3 ? 1 : 0;
      // Rank 2 denotes the second largest coordinate.
      i2 = rankx >= 2 ? 1 : 0;
      j2 = ranky >= 2 ? 1 : 0;
      k2 = rankz >= 2 ? 1 : 0;
      l2 = rankw >= 2 ? 1 : 0;
      // Rank 1 denotes the second smallest coordinate.
      i3 = rankx >= 1 ? 1 : 0;
      j3 = ranky >= 1 ? 1 : 0;
      k3 = rankz >= 1 ? 1 : 0;
      l3 = rankw >= 1 ? 1 : 0;
      // The fifth corner has all coordinate offsets = 1, so no need to compute that.
      var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
      var y1 = y0 - j1 + G4;
      var z1 = z0 - k1 + G4;
      var w1 = w0 - l1 + G4;
      var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
      var y2 = y0 - j2 + 2.0 * G4;
      var z2 = z0 - k2 + 2.0 * G4;
      var w2 = w0 - l2 + 2.0 * G4;
      var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
      var y3 = y0 - j3 + 3.0 * G4;
      var z3 = z0 - k3 + 3.0 * G4;
      var w3 = w0 - l3 + 3.0 * G4;
      var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
      var y4 = y0 - 1.0 + 4.0 * G4;
      var z4 = z0 - 1.0 + 4.0 * G4;
      var w4 = w0 - 1.0 + 4.0 * G4;
      // Work out the hashed gradient indices of the five simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      var ll = l & 255;
      // Calculate the contribution from the five corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;
        t0 *= t0;
        n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;
        t1 *= t1;
        n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;
        t2 *= t2;
        n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;
        t3 *= t3;
        n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
      }
      var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0) n4 = 0.0;
      else {
        var gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;
        t4 *= t4;
        n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
      }
      // Sum up and scale the result to cover the range [-1,1]
      return 27.0 * (n0 + n1 + n2 + n3 + n4);
    }
  };

  function buildPermutationTable(random) {
    var i;
    var p = new Uint8Array(256);
    for (i = 0; i < 256; i++) {
      p[i] = i;
    }
    for (i = 0; i < 255; i++) {
      var r = i + ~~(random() * (256 - i));
      var aux = p[i];
      p[i] = p[r];
      p[r] = aux;
    }
    return p;
  }
  SimplexNoise._buildPermutationTable = buildPermutationTable;

  function alea() {
    // Johannes Baagøe <baagoe@baagoe.com>, 2010
    var s0 = 0;
    var s1 = 0;
    var s2 = 0;
    var c = 1;

    var mash = masher();
    s0 = mash(' ');
    s1 = mash(' ');
    s2 = mash(' ');

    for (var i = 0; i < arguments.length; i++) {
      s0 -= mash(arguments[i]);
      if (s0 < 0) {
        s0 += 1;
      }
      s1 -= mash(arguments[i]);
      if (s1 < 0) {
        s1 += 1;
      }
      s2 -= mash(arguments[i]);
      if (s2 < 0) {
        s2 += 1;
      }
    }
    mash = null;
    return function() {
      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
      s0 = s1;
      s1 = s2;
      return s2 = t - (c = t | 0);
    };
  }
  function masher() {
    var n = 0xefc8249d;
    return function(data) {
      data = data.toString();
      for (var i = 0; i < data.length; i++) {
        n += data.charCodeAt(i);
        var h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000; // 2^32
      }
      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    };
  }

  // amd
  if (typeof define !== 'undefined' && define.amd) define(function() {return SimplexNoise;});
  // common js
  if (typeof exports !== 'undefined') exports.SimplexNoise = SimplexNoise;
  // browser
  else if (typeof window !== 'undefined') window.SimplexNoise = SimplexNoise;
  // nodejs
  if (typeof module !== 'undefined') {
    module.exports = SimplexNoise;
  }

})();

},{}],10:[function(require,module,exports){
/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') {
    module.exports = simplify;
    module.exports.default = simplify;
} else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dat = require("dat.gui");
var tensor_field_gui_1 = require("./ts/ui/tensor_field_gui");
var roads_gui_1 = require("./ts/ui/roads_gui");
var canvas_wrapper_1 = require("./ts/ui/canvas_wrapper");
var util_1 = require("./ts/util");
var drag_controller_1 = require("./ts/ui/drag_controller");
var domain_controller_1 = require("./ts/ui/domain_controller");
var Main = /** @class */ (function () {
    function Main() {
        var _this = this;
        this.domainController = domain_controller_1.default.getInstance();
        this.gui = new dat.GUI({ width: 300 });
        this.dragController = new drag_controller_1.default(this.gui);
        // Options
        this.imageScale = 3;
        // To force draw if needed
        this.previousFrameDrawTensor = true;
        var c = document.getElementById(util_1.default.CANVAS_ID);
        this.canvas = new canvas_wrapper_1.default(c);
        var zoomController = this.gui.add(this.domainController, 'zoom');
        this.domainController.setZoomUpdate(function () { return zoomController.updateDisplay(); });
        var noiseParams = {
            globalNoise: false,
            noiseSizePark: 20,
            noiseAnglePark: 90,
            noiseSizeGlobal: 30,
            noiseAngleGlobal: 20
        };
        this.tensorFolder = this.gui.addFolder('Tensor Field');
        this.tensorField = new tensor_field_gui_1.default(this.tensorFolder, this.dragController, true, noiseParams);
        this.tensorFolder.open();
        this.roadsFolder = this.gui.addFolder('Roads');
        this.roadsFolder.open();
        this.roadsGUI = new roads_gui_1.default(this.roadsFolder, this.tensorField, function () { return _this.tensorFolder.close(); });
        var optionsFolder = this.gui.addFolder('Options');
        optionsFolder.add(this.tensorField, 'drawCentre');
        optionsFolder.add(this.canvas, 'canvasScale');
        optionsFolder.add(this, 'imageScale', 1, 5);
        optionsFolder.add(this, 'download');
        this.tensorField.setRecommended();
        requestAnimationFrame(this.update.bind(this));
    }
    /**
     * Downloads image of map
     * Draws onto hidden canvas at requested resolution
     */
    Main.prototype.download = function () {
        var c = document.getElementById(util_1.default.IMG_CANVAS_ID);
        var imgCanvas = new canvas_wrapper_1.default(c, this.imageScale, false);
        this.draw(imgCanvas, true);
        var link = document.createElement('a');
        link.download = 'map.png';
        link.href = document.getElementById(util_1.default.IMG_CANVAS_ID).toDataURL();
        link.click();
    };
    Main.prototype.drawTensorField = function () {
        return !this.tensorFolder.closed || this.roadsGUI.roadsEmpty();
    };
    Main.prototype.draw = function (canvas, forceDraw) {
        if (forceDraw === void 0) { forceDraw = false; }
        if (this.drawTensorField()) {
            this.previousFrameDrawTensor = true;
            canvas.setFillStyle('black');
            canvas.clearCanvas();
            this.dragController.setDragDisabled(false);
            this.tensorField.draw(canvas, forceDraw);
        }
        else {
            this.dragController.setDragDisabled(true);
            if (this.previousFrameDrawTensor === true) {
                // Force redraw
                this.roadsGUI.draw(canvas, true);
                this.previousFrameDrawTensor = false;
            }
            else {
                this.roadsGUI.draw(canvas, forceDraw);
            }
        }
    };
    Main.prototype.update = function () {
        this.draw(this.canvas);
        requestAnimationFrame(this.update.bind(this));
    };
    return Main;
}());
window.addEventListener('load', function () {
    new Main();
});

},{"./ts/ui/canvas_wrapper":21,"./ts/ui/domain_controller":23,"./ts/ui/drag_controller":24,"./ts/ui/roads_gui":26,"./ts/ui/tensor_field_gui":28,"./ts/util":29,"dat.gui":2}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var Vector = /** @class */ (function () {
    function Vector(x, y) {
        this.x = x;
        this.y = y;
    }
    Vector.zeroVector = function () {
        return new Vector(0, 0);
    };
    Vector.fromScalar = function (s) {
        return new Vector(s, s);
    };
    /**
     * -pi to pi
     */
    Vector.angleBetween = function (v1, v2) {
        // -2pi to 2pi
        var angleBetween = v1.angle() - v2.angle();
        if (angleBetween > Math.PI) {
            angleBetween -= 2 * Math.PI;
        }
        else if (angleBetween <= -Math.PI) {
            angleBetween += 2 * Math.PI;
        }
        return angleBetween;
    };
    /**
     * Tests whether a point lies to the left of a line
     * @param  {Vector} linePoint     Point on the line
     * @param  {Vector} lineDirection
     * @param  {Vector} point
     * @return {Vector}               true if left, false otherwise
     */
    Vector.isLeft = function (linePoint, lineDirection, point) {
        var perpendicularVector = new Vector(lineDirection.y, -lineDirection.x);
        return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
    };
    Vector.prototype.add = function (v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    };
    /**
     * Angle in radians to positive x-axis between -pi and pi
     */
    Vector.prototype.angle = function () {
        return Math.atan2(this.y, this.x);
    };
    Vector.prototype.clone = function () {
        return new Vector(this.x, this.y);
    };
    Vector.prototype.copy = function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    };
    Vector.prototype.cross = function (v) {
        return this.x * v.y - this.y * v.x;
    };
    Vector.prototype.distanceTo = function (v) {
        return Math.sqrt(this.distanceToSquared(v));
    };
    Vector.prototype.distanceToSquared = function (v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        return dx * dx + dy * dy;
    };
    Vector.prototype.divide = function (v) {
        if (v.x === 0 || v.y === 0) {
            log.warn("Division by zero");
            return this;
        }
        this.x /= v.x;
        this.y /= v.y;
        return this;
    };
    Vector.prototype.divideScalar = function (s) {
        if (s === 0) {
            log.warn("Division by zero");
            return this;
        }
        return this.multiplyScalar(1 / s);
    };
    Vector.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y;
    };
    Vector.prototype.equals = function (v) {
        return ((v.x === this.x) && (v.y === this.y));
    };
    Vector.prototype.length = function () {
        return Math.sqrt(this.lengthSq());
    };
    Vector.prototype.lengthSq = function () {
        return this.x * this.x + this.y * this.y;
    };
    Vector.prototype.multiply = function (v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    };
    Vector.prototype.multiplyScalar = function (s) {
        this.x *= s;
        this.y *= s;
        return this;
    };
    Vector.prototype.negate = function () {
        return this.multiplyScalar(-1);
    };
    Vector.prototype.normalize = function () {
        var l = this.length();
        if (l === 0) {
            log.warn("Zero Vector");
            return this;
        }
        return this.divideScalar(this.length());
    };
    /**
     * Angle in radians
     */
    Vector.prototype.rotateAround = function (center, angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * cos - y * sin + center.x;
        this.y = x * sin + y * cos + center.y;
        return this;
    };
    Vector.prototype.set = function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    };
    Vector.prototype.setX = function (x) {
        this.x = x;
        return this;
    };
    Vector.prototype.setY = function (y) {
        this.y = y;
        return this;
    };
    Vector.prototype.setLength = function (length) {
        return this.normalize().multiplyScalar(length);
    };
    Vector.prototype.sub = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    };
    return Vector;
}());
exports.default = Vector;

},{"loglevel":6}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("./tensor");
var BasisField = /** @class */ (function () {
    function BasisField(centre, _size, _decay) {
        this._size = _size;
        this._decay = _decay;
        this._centre = centre.clone();
    }
    Object.defineProperty(BasisField.prototype, "centre", {
        get: function () {
            return this._centre.clone();
        },
        set: function (centre) {
            this._centre.copy(centre);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BasisField.prototype, "decay", {
        set: function (decay) {
            this._decay = decay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BasisField.prototype, "size", {
        set: function (size) {
            this._size = size;
        },
        enumerable: true,
        configurable: true
    });
    BasisField.prototype.dragMoveListener = function (delta) {
        // Delta assumed to be in world space (only relevant when zoomed)
        this._centre.add(delta);
    };
    BasisField.prototype.getWeightedTensor = function (point) {
        return this.getTensor(point).scale(this.getTensorWeight(point));
    };
    /**
     * Creates a folder and adds it to the GUI to control params
     */
    BasisField.prototype.setGui = function (gui) {
        gui.add(this._centre, 'x');
        gui.add(this._centre, 'y');
        gui.add(this, '_size');
        gui.add(this, '_decay', 0, 50);
    };
    /**
     * Interpolates between (0 and 1)^decay
     */
    BasisField.prototype.getTensorWeight = function (point) {
        var normDistanceToCentre = point.clone().sub(this._centre).length() / this._size;
        // Stop (** 0) turning weight into 1, filling screen even when outside 'size'
        if (this._decay === 0 && normDistanceToCentre >= 1) {
            return 0;
        }
        return Math.pow(Math.max(0, (1 - normDistanceToCentre)), this._decay);
    };
    BasisField.folderNameIndex = 0;
    return BasisField;
}());
exports.BasisField = BasisField;
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid(centre, size, decay, _theta) {
        var _this = _super.call(this, centre, size, decay) || this;
        _this._theta = _theta;
        _this.FOLDER_NAME = "Grid " + Grid.folderNameIndex++;
        return _this;
    }
    Object.defineProperty(Grid.prototype, "theta", {
        set: function (theta) {
            this._theta = theta;
        },
        enumerable: true,
        configurable: true
    });
    Grid.prototype.setGui = function (gui) {
        var _this = this;
        _super.prototype.setGui.call(this, gui);
        // GUI in degrees, convert to rads
        var thetaProp = { theta: this._theta * 180 / Math.PI };
        var thetaController = gui.add(thetaProp, 'theta', -90, 90);
        thetaController.onChange(function (theta) { return _this._theta = theta * (Math.PI / 180); });
    };
    Grid.prototype.getTensor = function (point) {
        var cos = Math.cos(2 * this._theta);
        var sin = Math.sin(2 * this._theta);
        return new tensor_1.default(1, [cos, sin]);
    };
    return Grid;
}(BasisField));
exports.Grid = Grid;
var Radial = /** @class */ (function (_super) {
    __extends(Radial, _super);
    function Radial(centre, size, decay) {
        var _this = _super.call(this, centre, size, decay) || this;
        _this.FOLDER_NAME = "Radial " + Radial.folderNameIndex++;
        return _this;
    }
    Radial.prototype.getTensor = function (point) {
        var t = point.clone().sub(this._centre);
        var t1 = Math.pow(t.y, 2) - Math.pow(t.x, 2);
        var t2 = -2 * t.x * t.y;
        return new tensor_1.default(1, [t1, t2]);
    };
    return Radial;
}(BasisField));
exports.Radial = Radial;

},{"./tensor":19}],14:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var isect = require("isect");
var d3 = require("d3-quadtree");
var vector_1 = require("../vector");
var Node = /** @class */ (function () {
    function Node(value, neighbors) {
        if (neighbors === void 0) { neighbors = new Set(); }
        this.value = value;
        this.neighbors = neighbors;
        this.segments = new Set();
    }
    Node.prototype.addSegment = function (segment) {
        this.segments.add(segment);
    };
    Node.prototype.addNeighbor = function (node) {
        if (node !== this) {
            this.neighbors.add(node);
            node.neighbors.add(this);
        }
    };
    return Node;
}());
exports.Node = Node;
var Graph = /** @class */ (function () {
    function Graph(streamlines, dstep) {
        var _this = this;
        var intersections = isect.bush(this.streamlinesToSegment(streamlines)).run();
        var quadtree = d3.quadtree().x(function (n) { return n.value.x; }).y(function (n) { return n.value.y; });
        var nodeAddRadius = 0.001;
        // Add all segment start and endpoints
        streamlines.forEach(function (streamline) {
            for (var i = 0; i < streamline.length; i++) {
                var node = new Node(streamline[i]);
                if (i > 0) {
                    node.addSegment(_this.vectorsToSegment(streamline[i - 1], streamline[i]));
                }
                if (i < streamline.length - 1) {
                    node.addSegment(_this.vectorsToSegment(streamline[i], streamline[i + 1]));
                }
                _this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
            }
        });
        // Add all intersections
        intersections.forEach(function (intersection) {
            var node = new Node(new vector_1.default(intersection.point.x, intersection.point.y));
            intersection.segments.forEach(function (s) { return node.addSegment(s); });
            _this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
        });
        // For each simplified streamline, build list of nodes in order along streamline
        streamlines.forEach(function (streamline) {
            for (var i = 0; i < streamline.length - 1; i++) {
                var nodesAlongSegment = _this.getNodesAlongSegment(_this.vectorsToSegment(streamline[i], streamline[i + 1]), quadtree, nodeAddRadius, dstep);
                if (nodesAlongSegment.length > 1) {
                    for (var j = 0; j < nodesAlongSegment.length - 1; j++) {
                        nodesAlongSegment[j].addNeighbor(nodesAlongSegment[j + 1]);
                    }
                }
                else {
                    log.error("Error Graph.js: segment with less than 2 nodes");
                }
            }
        });
        this.nodes = quadtree.data();
        this.nodes.forEach(function (n) { return n.adj = Array.from(n.neighbors); });
        this.intersections = intersections.map(function (i) { return new vector_1.default(i.point.x, i.point.y); });
    }
    Graph.prototype.getNodesAlongSegment = function (segment, quadtree, radius, step) {
        // Walk dstep along each streamline, adding nodes within dstep/2
        // and connected to this streamline (fuzzy - nodeAddRadius) to list, removing from
        // quadtree and adding them all back at the end
        var e_1, _a;
        var _this = this;
        var foundNodes = [];
        var nodesAlongSegment = [];
        var start = new vector_1.default(segment.from.x, segment.from.y);
        var end = new vector_1.default(segment.to.x, segment.to.y);
        var differenceVector = end.clone().sub(start);
        step = Math.min(step, differenceVector.length() / 2); // Min of 2 step along vector
        var steps = Math.ceil(differenceVector.length() / step);
        var differenceVectorLength = differenceVector.length();
        for (var i = 0; i <= steps; i++) {
            var currentPoint = start.clone().add(differenceVector.clone().multiplyScalar(i / steps));
            // Order nodes, not by 'closeness', but by dot product
            var nodesToAdd = [];
            var closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);
            while (closestNode !== undefined) {
                quadtree.remove(closestNode);
                foundNodes.push(closestNode);
                var nodeOnSegment = false;
                try {
                    for (var _b = (e_1 = void 0, __values(closestNode.segments)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var s = _c.value;
                        if (this.fuzzySegmentsEqual(s, segment)) {
                            nodeOnSegment = true;
                            break;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (nodeOnSegment) {
                    nodesToAdd.push(closestNode);
                }
                closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);
            }
            nodesToAdd.sort(function (first, second) {
                return _this.dotProductToSegment(first, start, differenceVector) - _this.dotProductToSegment(second, start, differenceVector);
            });
            nodesToAdd.forEach(function (n) { return nodesAlongSegment.push(n); });
        }
        quadtree.addAll(foundNodes);
        return nodesAlongSegment;
    };
    Graph.prototype.fuzzySegmentsEqual = function (s1, s2, tolerance) {
        if (tolerance === void 0) { tolerance = 0.0001; }
        // From
        if (s1.from.x - s2.from.x > tolerance) {
            return false;
        }
        if (s1.from.y - s2.from.y > tolerance) {
            return false;
        }
        // To
        if (s1.to.x - s2.to.x > tolerance) {
            return false;
        }
        if (s1.to.y - s2.to.y > tolerance) {
            return false;
        }
        return true;
    };
    Graph.prototype.dotProductToSegment = function (node, start, differenceVector) {
        var dotVector = node.value.clone().sub(start);
        return differenceVector.dot(dotVector);
    };
    Graph.prototype.fuzzyAddToQuadtree = function (quadtree, node, radius) {
        // Only add if there isn't a node within radius
        // Remember to check for double radius when querying tree, or point might be missed
        var existingNode = quadtree.find(node.value.x, node.value.y, radius);
        if (existingNode === undefined) {
            quadtree.add(node);
        }
        else {
            node.neighbors.forEach(function (neighbor) { return existingNode.addNeighbor(neighbor); });
            node.segments.forEach(function (segment) { return existingNode.addSegment(segment); });
        }
    };
    Graph.prototype.streamlinesToSegment = function (streamlines) {
        var e_2, _a;
        var out = [];
        try {
            for (var streamlines_1 = __values(streamlines), streamlines_1_1 = streamlines_1.next(); !streamlines_1_1.done; streamlines_1_1 = streamlines_1.next()) {
                var s = streamlines_1_1.value;
                for (var i = 0; i < s.length - 1; i++) {
                    out.push(this.vectorsToSegment(s[i], s[i + 1]));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (streamlines_1_1 && !streamlines_1_1.done && (_a = streamlines_1.return)) _a.call(streamlines_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return out;
    };
    Graph.prototype.vectorsToSegment = function (v1, v2) {
        return {
            from: v1,
            to: v2
        };
    };
    return Graph;
}());
exports.default = Graph;

},{"../vector":30,"d3-quadtree":1,"isect":4,"loglevel":6}],15:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = require("../vector");
var GridStorage = /** @class */ (function () {
    /**
     * worldDimensions assumes origin of 0,0
     * @param {number} dsep Separation distance between samples
     */
    function GridStorage(worldDimensions, origin, dsep) {
        this.worldDimensions = worldDimensions;
        this.origin = origin;
        this.dsep = dsep;
        this.dsepSq = this.dsep * this.dsep;
        this.gridDimensions = worldDimensions.clone().divideScalar(this.dsep);
        this.grid = [];
        for (var x = 0; x < this.gridDimensions.x; x++) {
            this.grid.push([]);
            for (var y = 0; y < this.gridDimensions.y; y++) {
                this.grid[x].push([]);
            }
        }
    }
    /**
     * Add all samples from another grid to this one
     */
    GridStorage.prototype.addAll = function (gridStorage) {
        var _this = this;
        gridStorage.grid.forEach(function (row) { return row.forEach(function (cell) { return cell.forEach(function (sample) {
            _this.addSample(sample);
        }); }); });
    };
    GridStorage.prototype.addPolyline = function (line) {
        var _this = this;
        line.forEach(function (v) { return _this.addSample(v); });
    };
    /**
     * Does not enforce separation
     * Does not clone
     */
    GridStorage.prototype.addSample = function (v, coords) {
        if (!coords) {
            coords = this.getSampleCoords(v);
        }
        this.grid[coords.x][coords.y].push(v);
    };
    /**
     * Tests whether v is at least d away from samples
     * Performance very important - this is called at every integration step
     * @param dSq=this.dsepSq squared test distance
     * Could be dtest if we are integrating a streamline
     */
    GridStorage.prototype.isValidSample = function (v, dSq) {
        // Code duplication with this.getNearbyPoints but much slower when calling
        // this.getNearbyPoints due to array creation in that method
        if (dSq === void 0) { dSq = this.dsepSq; }
        var coords = this.getSampleCoords(v);
        // Check samples in 9 cells in 3x3 grid
        for (var x = -1; x <= 1; x++) {
            for (var y = -1; y <= 1; y++) {
                var cell = coords.clone().add(new vector_1.default(x, y));
                if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
                    if (!this.vectorFarFromVectors(v, this.grid[cell.x][cell.y], dSq)) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    /**
     * Test whether v is at least d away from vectors
     * Performance very important - this is called at every integration step
     * @param {number}   dSq     squared test distance
     */
    GridStorage.prototype.vectorFarFromVectors = function (v, vectors, dSq) {
        var e_1, _a;
        try {
            for (var vectors_1 = __values(vectors), vectors_1_1 = vectors_1.next(); !vectors_1_1.done; vectors_1_1 = vectors_1.next()) {
                var sample = vectors_1_1.value;
                if (sample !== v) {
                    var distanceSq = sample.distanceToSquared(v);
                    if (distanceSq < dSq) {
                        return false;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vectors_1_1 && !vectors_1_1.done && (_a = vectors_1.return)) _a.call(vectors_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    /**
     * Returns points in cells surrounding v
     * Results include v, if it exists in the grid
     * @param {number} returns samples (kind of) closer than distance - returns all samples in
     * cells so approximation (square to approximate circle)
     */
    GridStorage.prototype.getNearbyPoints = function (v, distance) {
        var radius = Math.ceil((distance / this.dsep) - 0.5);
        var coords = this.getSampleCoords(v);
        var out = [];
        for (var x = -1 * radius; x <= 1 * radius; x++) {
            for (var y = -1 * radius; y <= 1 * radius; y++) {
                var cell = coords.clone().add(new vector_1.default(x, y));
                if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
                    this.grid[cell.x][cell.y].forEach(function (v2) {
                        out.push(v2);
                    });
                }
            }
        }
        return out;
    };
    GridStorage.prototype.worldToGrid = function (v) {
        return v.clone().sub(this.origin);
    };
    GridStorage.prototype.gridToWorld = function (v) {
        return v.clone().add(this.origin);
    };
    GridStorage.prototype.vectorOutOfBounds = function (gridV, bounds) {
        return (gridV.x < 0 || gridV.y < 0 ||
            gridV.x >= bounds.x || gridV.y >= bounds.y);
    };
    /**
     * @return {Vector}   Cell coords corresponding to vector
     * Performance important - called at every integration step
     */
    GridStorage.prototype.getSampleCoords = function (worldV) {
        var v = this.worldToGrid(worldV);
        if (this.vectorOutOfBounds(v, this.worldDimensions)) {
            // log.error("Tried to access out-of-bounds sample in grid");
            return vector_1.default.zeroVector();
        }
        return new vector_1.default(Math.floor(v.x / this.dsep), Math.floor(v.y / this.dsep));
    };
    return GridStorage;
}());
exports.default = GridStorage;

},{"../vector":30}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = require("../vector");
var FieldIntegrator = /** @class */ (function () {
    function FieldIntegrator(field) {
        this.field = field;
    }
    FieldIntegrator.prototype.sampleFieldVector = function (point, major) {
        var tensor = this.field.samplePoint(point);
        if (major)
            return tensor.getMajor();
        return tensor.getMinor();
    };
    FieldIntegrator.prototype.onLand = function (point) {
        return this.field.onLand(point);
    };
    return FieldIntegrator;
}());
exports.default = FieldIntegrator;
var EulerIntegrator = /** @class */ (function (_super) {
    __extends(EulerIntegrator, _super);
    function EulerIntegrator(field, params) {
        var _this = _super.call(this, field) || this;
        _this.params = params;
        return _this;
    }
    EulerIntegrator.prototype.integrate = function (point, major) {
        return this.sampleFieldVector(point, major).multiplyScalar(this.params.dstep);
    };
    return EulerIntegrator;
}(FieldIntegrator));
exports.EulerIntegrator = EulerIntegrator;
var RK4Integrator = /** @class */ (function (_super) {
    __extends(RK4Integrator, _super);
    function RK4Integrator(field, params) {
        var _this = _super.call(this, field) || this;
        _this.params = params;
        return _this;
    }
    RK4Integrator.prototype.integrate = function (point, major) {
        var k1 = this.sampleFieldVector(point, major);
        var k23 = this.sampleFieldVector(point.clone().add(vector_1.default.fromScalar(this.params.dstep / 2)), major);
        var k4 = this.sampleFieldVector(point.clone().add(vector_1.default.fromScalar(this.params.dstep)), major);
        return k1.add(k23.multiplyScalar(4)).add(k4).multiplyScalar(this.params.dstep / 6);
    };
    return RK4Integrator;
}(FieldIntegrator));
exports.RK4Integrator = RK4Integrator;

},{"../vector":30}],17:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var PolyK = require("polyk");
var vector_1 = require("../vector");
var jsts = require("jsts");
var PolygonFinder = /** @class */ (function () {
    function PolygonFinder(nodes, maxLength) {
        if (maxLength === void 0) { maxLength = 20; }
        this.nodes = nodes;
        this.maxLength = maxLength;
        this._polygons = [];
        this._shrunkPolygons = [];
        this._dividedPolygons = [];
        this.jstsPolygons = [];
        this.geometryFactory = new jsts.geom.GeometryFactory();
    }
    Object.defineProperty(PolygonFinder.prototype, "polygons", {
        get: function () {
            if (this._dividedPolygons.length > 0) {
                return this._dividedPolygons;
            }
            if (this._shrunkPolygons.length > 0) {
                return this._shrunkPolygons;
            }
            return this._polygons;
        },
        enumerable: true,
        configurable: true
    });
    PolygonFinder.prototype.shrink = function (spacing) {
        var _this = this;
        if (spacing === void 0) { spacing = 2; }
        // this.polygons = this.polygons.map(p => this.shrinkPolygon(p, this.shrinkAmount))
        if (this._polygons.length === 0) {
            this.findPolygons();
        }
        this._shrunkPolygons = this.jstsPolygons.map(function (p) { return _this.resizePolygon(p, -spacing); })
            .filter(function (p) { return p.length > 0; });
    };
    PolygonFinder.prototype.divide = function (minArea) {
        var _this = this;
        if (minArea === void 0) { minArea = 20; }
        if (this._polygons.length === 0) {
            this.findPolygons();
        }
        var polygons = this._polygons;
        if (this._shrunkPolygons.length > 0) {
            polygons = this._shrunkPolygons;
        }
        var divided = [];
        polygons.forEach(function (p) {
            divided = divided.concat(_this.subdividePolygon(p, minArea));
        });
        this._dividedPolygons = divided.filter(function (p) { return PolygonFinder.calcPolygonArea(p) > minArea * 0.4; });
    };
    PolygonFinder.prototype.findPolygons = function () {
        // Node
        // x, y, value (Vector2), adj (list of node refs)
        // Gonna edit adj for now
        var e_1, _a, e_2, _b;
        var _this = this;
        // Walk a clockwise path until polygon found or limit reached
        // When we find a polygon, mark all edges as traversed (in particular direction)
        // Each edge separates two polygons
        // If edge already traversed in this direction, this polygon has already been found
        this._shrunkPolygons = [];
        this._dividedPolygons = [];
        var polygons = [];
        try {
            for (var _c = __values(this.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                var node = _d.value;
                if (node.adj.length === 0)
                    continue;
                try {
                    for (var _e = (e_2 = void 0, __values(node.adj)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var nextNode = _f.value;
                        var polygon = this.recursiveWalk([node, nextNode]);
                        if (polygon !== null) {
                            this.removePolygonAdjacencies(polygon);
                            polygons.push(polygon.map(function (n) { return n.value.clone(); }));
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this._polygons = polygons;
        this.jstsPolygons = polygons.map(function (p) { return _this.polygonToJts(p); });
    };
    PolygonFinder.prototype.removePolygonAdjacencies = function (polygon) {
        for (var i = 0; i < polygon.length; i++) {
            var current = polygon[i];
            var next = polygon[(i + 1) % polygon.length];
            var index = current.adj.indexOf(next);
            if (index >= 0) {
                current.adj.splice(index, 1);
            }
            else {
                log.error("PolygonFinder - node not in adj");
            }
        }
    };
    PolygonFinder.prototype.recursiveWalk = function (visited, count) {
        if (count === void 0) { count = 0; }
        if (count >= this.maxLength)
            return null;
        // TODO backtracking to find polygons with dead end roads inside them
        var nextNode = this.getRightmostNode(visited[visited.length - 2], visited[visited.length - 1]);
        if (nextNode === null) {
            return null; // Currently ignores polygons with dead end inside
        }
        var visitedIndex = visited.indexOf(nextNode);
        if (visitedIndex >= 0) {
            return visited.slice(visitedIndex);
        }
        else {
            visited.push(nextNode);
            return this.recursiveWalk(visited, count++);
        }
    };
    PolygonFinder.prototype.getRightmostNode = function (nodeFrom, nodeTo) {
        var e_3, _a;
        // We want to turn right at every junction
        if (nodeTo.adj.length === 0)
            return null;
        var backwardsDifferenceVector = nodeFrom.value.clone().sub(nodeTo.value);
        var transformAngle = Math.atan2(backwardsDifferenceVector.y, backwardsDifferenceVector.x);
        var rightmostNode = null;
        var smallestTheta = Math.PI * 2;
        try {
            for (var _b = __values(nodeTo.adj), _c = _b.next(); !_c.done; _c = _b.next()) {
                var nextNode = _c.value;
                if (nextNode !== nodeFrom) {
                    var nextVector = nextNode.value.clone().sub(nodeTo.value);
                    var nextAngle = Math.atan2(nextVector.y, nextVector.x) - transformAngle;
                    if (nextAngle < 0) {
                        nextAngle += Math.PI * 2;
                    }
                    if (nextAngle < smallestTheta) {
                        smallestTheta = nextAngle;
                        rightmostNode = nextNode;
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return rightmostNode;
    };
    PolygonFinder.prototype.shrinkPolygon = function (polygon, amount) {
        // Returns clone
        if (polygon.length < 3) {
            return;
        }
        var averagePoint = polygon[0].clone();
        for (var i = 1; i < polygon.length; i++) {
            averagePoint.add(polygon[i]);
        }
        averagePoint.multiplyScalar(1 / polygon.length);
        return polygon.map(function (v) { return v.clone().sub(averagePoint).multiplyScalar(amount).add(averagePoint); });
    };
    PolygonFinder.prototype.polygonToJts = function (polygon) {
        var geoInput = polygon.map(function (v) { return new jsts.geom.Coordinate(v.x, v.y); });
        geoInput.push(geoInput[0]);
        return this.geometryFactory.createPolygon(this.geometryFactory.createLinearRing(geoInput), []);
    };
    PolygonFinder.prototype.resizePolygon = function (polygon, spacing) {
        try {
            var resized = polygon.buffer(spacing, undefined, undefined);
            if (!resized.isSimple()) {
                return [];
            }
            return resized.getCoordinates().map(function (c) { return new vector_1.default(c.x, c.y); });
        }
        catch (error) {
            log.error(error);
            return [];
        }
    };
    PolygonFinder.prototype.subdividePolygon = function (p, minArea) {
        var _this = this;
        if (PolygonFinder.calcPolygonArea(p) < minArea) {
            return [p];
        }
        var divided = []; // Array of polygons
        var longestSideLength = 0;
        var longestSide = [p[0], p[1]];
        for (var i = 0; i < p.length; i++) {
            var sideLength = p[i].clone().sub(p[(i + 1) % p.length]).length();
            if (sideLength > longestSideLength) {
                longestSideLength = sideLength;
                longestSide = [p[i], p[(i + 1) % p.length]];
            }
        }
        // Between 0.4 and 0.6
        var deviation = (Math.random() * 0.2) + 0.4;
        var averagePoint = longestSide[0].clone().add(longestSide[1]).multiplyScalar(deviation);
        var differenceVector = longestSide[0].clone().sub(longestSide[1]);
        var perpVector = (new vector_1.default(differenceVector.y, -1 * differenceVector.x))
            .normalize()
            .multiplyScalar(100);
        var bisect = [averagePoint.clone().add(perpVector), averagePoint.clone().sub(perpVector)];
        // Array of polygons
        try {
            var sliced = PolyK.Slice(PolygonFinder.polygonToPolygonArray(p), bisect[0].x, bisect[0].y, bisect[1].x, bisect[1].y);
            // Recursive call
            sliced.forEach(function (s) {
                divided = divided.concat(_this.subdividePolygon(PolygonFinder.polygonArrayToPolygon(s), minArea));
            });
            return divided;
        }
        catch (error) {
            log.error(error);
            return [];
        }
    };
    /**
     * Used to create sea polygon
     * Returns largest polygon
     */
    PolygonFinder.sliceRectangle = function (origin, worldDimensions, p1, p2) {
        var _this = this;
        var rectangle = [
            origin.x, origin.y,
            origin.x + worldDimensions.x, origin.y,
            origin.x + worldDimensions.x, origin.y + worldDimensions.y,
            origin.x, origin.y + worldDimensions.y,
        ];
        var sliced = PolyK.Slice(rectangle, p1.x, p1.y, p2.x, p2.y).map(function (p) { return _this.polygonArrayToPolygon(p); });
        var minArea = PolygonFinder.calcPolygonArea(sliced[0]);
        if (sliced.length > 1 && PolygonFinder.calcPolygonArea(sliced[1]) < minArea) {
            return sliced[1];
        }
        return sliced[0];
    };
    PolygonFinder.polygonToPolygonArray = function (p) {
        var outP = [];
        p.forEach(function (v) {
            outP.push(v.x);
            outP.push(v.y);
        });
        return outP;
    };
    PolygonFinder.polygonArrayToPolygon = function (p) {
        var outP = [];
        for (var i = 0; i < p.length / 2; i++) {
            outP.push(new vector_1.default(p[2 * i], p[2 * i + 1]));
        }
        return outP;
    };
    // private isValidPolygon(p: Vector[]): boolean {
    //     if (p.length > this.maxLength) return false;
    //     const area = PolygonFinder.calcPolygonArea(p);
    //     if (area < this.minArea || area > 10000) return false;
    //     return true;
    // }
    PolygonFinder.calcPolygonArea = function (vertices) {
        var total = 0;
        for (var i = 0; i < vertices.length; i++) {
            var addX = vertices[i].x;
            var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;
            var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;
            var subY = vertices[i].y;
            total += (addX * addY * 0.5);
            total -= (subX * subY * 0.5);
        }
        return Math.abs(total);
    };
    return PolygonFinder;
}());
exports.default = PolygonFinder;

},{"../vector":30,"jsts":5,"loglevel":6,"polyk":7}],18:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var simplify = require("simplify-js");
var vector_1 = require("../vector");
var grid_storage_1 = require("./grid_storage");
var StreamlineGenerator = /** @class */ (function () {
    /**
     * Uses world-space coordinates
     */
    function StreamlineGenerator(integrator, origin, worldDimensions, params) {
        this.integrator = integrator;
        this.origin = origin;
        this.worldDimensions = worldDimensions;
        this.params = params;
        this.SEED_AT_ENDPOINTS = false;
        this.NEAR_EDGE = 3; // Sample near edge
        this.candidateSeedsMajor = [];
        this.candidateSeedsMinor = [];
        this.streamlinesDone = true;
        this.lastStreamlineMajor = true;
        this.streamlinesMajor = [];
        this.streamlinesMinor = [];
        this.allStreamlinesSimple = []; // Reduced vertex count
        if (params.dstep > params.dsep) {
            log.error("STREAMLINE SAMPLE DISTANCE BIGGER THAN DSEP");
        }
        // Enforce test < sep
        params.dtest = Math.min(params.dtest, params.dsep);
        // Needs to be less than circlejoin
        this.dcollideselfSq = Math.pow((params.dcirclejoin / 2), 2);
        this.nStreamlineStep = Math.floor(params.dcirclejoin / params.dstep);
        this.nStreamlineLookBack = 2 * this.nStreamlineStep;
        this.majorGrid = new grid_storage_1.default(this.worldDimensions, this.origin, params.dsep);
        this.minorGrid = new grid_storage_1.default(this.worldDimensions, this.origin, params.dsep);
        this.setParamsSq();
    }
    StreamlineGenerator.prototype.clearStreamlines = function () {
        this.allStreamlinesSimple = [];
        this.streamlinesMajor = [];
        this.streamlinesMinor = [];
    };
    /**
     * Edits streamlines
     */
    StreamlineGenerator.prototype.joinDanglingStreamlines = function () {
        var e_1, _a;
        var _this = this;
        var _loop_1 = function (major) {
            var e_2, _a;
            var _loop_2 = function (streamline) {
                // Ignore circles
                if (streamline[0].equals(streamline[streamline.length - 1])) {
                    return "continue";
                }
                var newStart = this_1.getBestNextPoint(streamline[0], streamline[4], streamline);
                if (newStart !== null) {
                    this_1.pointsBetween(streamline[0], newStart, this_1.params.dstep).forEach(function (p) {
                        streamline.unshift(p);
                        _this.grid(major).addSample(p);
                    });
                }
                var newEnd = this_1.getBestNextPoint(streamline[streamline.length - 1], streamline[streamline.length - 4], streamline);
                if (newEnd !== null) {
                    this_1.pointsBetween(streamline[streamline.length - 1], newEnd, this_1.params.dstep).forEach(function (p) {
                        streamline.push(p);
                        _this.grid(major).addSample(p);
                    });
                }
            };
            try {
                for (var _b = (e_2 = void 0, __values(this_1.streamlines(major))), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var streamline = _c.value;
                    _loop_2(streamline);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        var this_1 = this;
        try {
            // TODO do in update method
            for (var _b = __values([true, false]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var major = _c.value;
                _loop_1(major);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Reset simplified streamlines
        this.allStreamlinesSimple = this.allStreamlines.map(function (s) { return _this.simplifyStreamline(s); });
    };
    /**
     * Returns array of points from v1 to v2 such that they are separated by at most dsep
     * not including v1
     */
    StreamlineGenerator.prototype.pointsBetween = function (v1, v2, dstep) {
        var d = v1.distanceTo(v2);
        var nPoints = Math.floor(d / dstep);
        if (nPoints === 0)
            return [];
        var stepVector = v2.clone().sub(v1);
        var out = [];
        var i = 1;
        var next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));
        for (i = 1; i <= nPoints; i++) {
            if (this.integrator.integrate(next, true).lengthSq() > 0.001) { // Test for degenerate point
                out.push(next);
            }
            else {
                return out;
            }
            next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));
        }
        return out;
    };
    /**
     * Gets next best point to join streamline
     * returns null if there are no good candidates
     */
    StreamlineGenerator.prototype.getBestNextPoint = function (point, previousPoint, streamline) {
        var e_3, _a;
        // Only consider points not on the edge
        if (point.x < this.NEAR_EDGE || point.x > this.worldDimensions.x - this.NEAR_EDGE) {
            return null;
        }
        if (point.y < this.NEAR_EDGE || point.y > this.worldDimensions.y - this.NEAR_EDGE) {
            return null;
        }
        var nearbyPoints = this.majorGrid.getNearbyPoints(point, this.params.dlookahead)
            .concat(this.minorGrid.getNearbyPoints(point, this.params.dlookahead));
        var direction = point.clone().sub(previousPoint);
        var closestSample = null;
        var closestDistance = Infinity;
        try {
            for (var nearbyPoints_1 = __values(nearbyPoints), nearbyPoints_1_1 = nearbyPoints_1.next(); !nearbyPoints_1_1.done; nearbyPoints_1_1 = nearbyPoints_1.next()) {
                var sample = nearbyPoints_1_1.value;
                if (!sample.equals(point) && !sample.equals(previousPoint) && !streamline.includes(sample)) {
                    var differenceVector = sample.clone().sub(point);
                    // Acute angle between vectors (agnostic of CW, ACW)
                    var distanceToSample = point.distanceToSquared(sample);
                    if (distanceToSample < 2 * this.paramsSq.dstep) {
                        closestSample = sample;
                        break;
                    }
                    var angleBetween = Math.abs(vector_1.default.angleBetween(direction, differenceVector));
                    // Filter by angle
                    if (angleBetween < this.params.joinangle && distanceToSample < closestDistance) {
                        closestDistance = distanceToSample;
                        closestSample = sample;
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (nearbyPoints_1_1 && !nearbyPoints_1_1.done && (_a = nearbyPoints_1.return)) _a.call(nearbyPoints_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        // TODO is reimplement simplify-js to preserve intersection points
        //  - this is the primary reason polygons aren't found
        // If trying to find intersections in the simplified graph
        // prevent ends getting pulled away from simplified lines
        if (closestSample !== null) {
            closestSample = closestSample.clone().add(direction.setLength(this.params.simplifyTolerance * 3));
        }
        return closestSample;
    };
    /**
     * Assumes s has already generated
     */
    StreamlineGenerator.prototype.addExistingStreamlines = function (s) {
        this.majorGrid.addAll(s.majorGrid);
        this.minorGrid.addAll(s.minorGrid);
    };
    Object.defineProperty(StreamlineGenerator.prototype, "allStreamlines", {
        get: function () {
            // Combine
            return this.streamlinesMajor.concat(this.streamlinesMinor);
        },
        enumerable: true,
        configurable: true
    });
    StreamlineGenerator.prototype.update = function () {
        if (!this.streamlinesDone) {
            this.lastStreamlineMajor = !this.lastStreamlineMajor;
            if (!this.createStreamline(this.lastStreamlineMajor)) {
                this.streamlinesDone = true;
            }
        }
    };
    /**
     * Streamlines created each frame (animated)
     */
    StreamlineGenerator.prototype.createAllStreamlinesDynamic = function () {
        this.streamlinesDone = false;
        // this.joinDanglingStreamlines();
    };
    /**
     * All at once - will freeze if dsep small
     */
    StreamlineGenerator.prototype.createAllStreamlines = function () {
        var major = true;
        while (this.createStreamline(major)) {
            major = !major;
        }
    };
    StreamlineGenerator.prototype.createCoastStreamline = function () {
        var streamline;
        var seed;
        var major;
        for (var i = 0; i < 500; i++) {
            major = Math.random() < 0.5;
            seed = this.getSeed(major);
            streamline = this.integrateStreamline(seed, major);
            streamline.unshift(streamline[0].clone().add(streamline[0].clone().sub(streamline[1]).setLength(this.params.dlookahead)));
            streamline.push(streamline[streamline.length - 1].clone().add(streamline[streamline.length - 1].clone().sub(streamline[streamline.length - 2]).setLength(this.params.dstep * 5)));
            if (this.vectorOffScreen(streamline[0]) && this.vectorOffScreen(streamline[streamline.length - 1])) {
                break;
            }
        }
        // Streamline is coastal = noisy
        var road = this.simplifyStreamline(streamline);
        this.allStreamlinesSimple.push(road);
        // Create intermediate samples
        var complex = this.complexifyStreamline(road);
        this.grid(major).addPolyline(complex);
        this.streamlines(major).push(complex);
        return streamline;
    };
    /**
     * Insert samples in streamline until separated by dstep
     */
    StreamlineGenerator.prototype.complexifyStreamline = function (s) {
        var out = [];
        for (var i = 0; i < s.length - 1; i++) {
            out = out.concat(this.complexifyStreamlineRecursive(s[i], s[i + 1]));
        }
        return out;
    };
    StreamlineGenerator.prototype.complexifyStreamlineRecursive = function (v1, v2) {
        if (v1.distanceToSquared(v2) <= this.paramsSq.dstep) {
            return [v1, v2];
        }
        var d = v2.clone().sub(v1);
        var halfway = v1.clone().add(d.multiplyScalar(0.5));
        return this.complexifyStreamlineRecursive(v1, halfway).concat(this.complexifyStreamlineRecursive(halfway, v2));
    };
    StreamlineGenerator.prototype.vectorOffScreen = function (v) {
        var toOrigin = v.clone().sub(this.origin);
        return toOrigin.x <= 0 || toOrigin.y <= 0 ||
            toOrigin.x >= this.worldDimensions.x || toOrigin.y >= this.worldDimensions.y;
    };
    StreamlineGenerator.prototype.simplifyStreamline = function (streamline) {
        return simplify(streamline, this.params.simplifyTolerance).map(function (point) { return new vector_1.default(point.x, point.y); });
    };
    /**
     * Finds seed and creates a streamline from that point
     * Pushes new candidate seeds to queue
     * @return {Vector[]} returns false if seed isn't found within params.seedTries
     */
    StreamlineGenerator.prototype.createStreamline = function (major) {
        var seed = this.getSeed(major);
        if (seed === null) {
            return false;
        }
        var streamline = this.integrateStreamline(seed, major);
        if (this.validStreamline(streamline)) {
            this.grid(major).addPolyline(streamline);
            this.streamlines(major).push(streamline);
            this.allStreamlinesSimple.push(this.simplifyStreamline(streamline));
            // Add candidate seeds
            if (!streamline[0].equals(streamline[streamline.length - 1])) {
                this.candidateSeeds(!major).push(streamline[0]);
                this.candidateSeeds(!major).push(streamline[streamline.length - 1]);
            }
        }
        return true;
    };
    StreamlineGenerator.prototype.validStreamline = function (s) {
        return s.length > 5;
    };
    StreamlineGenerator.prototype.setParamsSq = function () {
        this.paramsSq = Object.assign({}, this.params);
        for (var p in this.paramsSq) {
            this.paramsSq[p] *= this.paramsSq[p];
        }
    };
    StreamlineGenerator.prototype.samplePoint = function () {
        // TODO better seeding scheme
        return new vector_1.default(Math.random() * this.worldDimensions.x, Math.random() * this.worldDimensions.y)
            .add(this.origin);
    };
    /**
     * Tries this.candidateSeeds first, then samples using this.samplePoint
     */
    StreamlineGenerator.prototype.getSeed = function (major) {
        // Candidate seeds first
        if (this.SEED_AT_ENDPOINTS && this.candidateSeeds(major).length > 0) {
            while (this.candidateSeeds(major).length > 0) {
                var seed_1 = this.candidateSeeds(major).pop();
                if (this.isValidSample(major, seed_1, this.paramsSq.dsep)) {
                    return seed_1;
                }
            }
        }
        var seed = this.samplePoint();
        var i = 0;
        while (!this.isValidSample(major, seed, this.paramsSq.dsep)) {
            if (i >= this.params.seedTries) {
                return null;
            }
            seed = this.samplePoint();
            i++;
        }
        return seed;
    };
    StreamlineGenerator.prototype.isValidSample = function (major, point, dSq) {
        return this.integrator.onLand(point) && this.grid(major).isValidSample(point, dSq);
    };
    // TODO enum to remove these functions
    StreamlineGenerator.prototype.candidateSeeds = function (major) {
        return major ? this.candidateSeedsMajor : this.candidateSeedsMinor;
    };
    StreamlineGenerator.prototype.streamlines = function (major) {
        return major ? this.streamlinesMajor : this.streamlinesMinor;
    };
    StreamlineGenerator.prototype.grid = function (major) {
        return major ? this.majorGrid : this.minorGrid;
    };
    StreamlineGenerator.prototype.pointInBounds = function (v) {
        return (v.x >= this.origin.x
            && v.y >= this.origin.y
            && v.x < this.worldDimensions.x + this.origin.x
            && v.y < this.worldDimensions.y + this.origin.y);
    };
    /**
     * Didn't end up using - bit expensive, used streamlineTurned instead
     * Stops spirals from forming
     * uses 0.5 dcirclejoin so that circles are still joined up
     * testSample is candidate to pushed on end of streamlineForwards
     * returns true if streamline collides with itself
     */
    StreamlineGenerator.prototype.doesStreamlineCollideSelf = function (testSample, streamlineForwards, streamlineBackwards) {
        // Streamline long enough
        if (streamlineForwards.length > this.nStreamlineLookBack) {
            // Forwards check
            for (var i = 0; i < streamlineForwards.length - this.nStreamlineLookBack; i += this.nStreamlineStep) {
                if (testSample.distanceToSquared(streamlineForwards[i]) < this.dcollideselfSq) {
                    return true;
                }
            }
            // Backwards check
            for (var i = 0; i < streamlineBackwards.length; i += this.nStreamlineStep) {
                if (testSample.distanceToSquared(streamlineBackwards[i]) < this.dcollideselfSq) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Tests whether streamline has turned through greater than 180 degrees
     */
    StreamlineGenerator.prototype.streamlineTurned = function (seed, originalDir, point, direction) {
        if (originalDir.dot(direction) < 0) {
            // TODO optimise
            var perpendicularVector = new vector_1.default(originalDir.y, -originalDir.x);
            var isLeft = point.clone().sub(seed).dot(perpendicularVector) < 0;
            var directionUp = direction.dot(perpendicularVector) > 0;
            return isLeft === directionUp;
        }
        return false;
    };
    /**
     * // TODO this doesn't work well - consider something disallowing one direction (F/B) to turn more than 180 deg
     * One step of the streamline integration process
     */
    StreamlineGenerator.prototype.streamlineIntegrationStep = function (params, major) {
        if (params.valid) {
            params.streamline.push(params.previousPoint);
            var nextDirection = this.integrator.integrate(params.previousPoint, major);
            // Stop at degenerate point
            if (nextDirection.lengthSq() < 0.01) {
                params.valid = false;
                return;
            }
            // Make sure we travel in the same direction
            if (nextDirection.dot(params.previousDirection) < 0) {
                nextDirection.negate();
            }
            var nextPoint = params.previousPoint.clone().add(nextDirection);
            // Visualise stopping points
            // if (this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
            //     params.valid = false;
            //     params.streamline.push(Vector.zeroVector());
            // }
            if (this.pointInBounds(nextPoint)
                && this.isValidSample(major, nextPoint, this.paramsSq.dtest)
                && !this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
                params.previousPoint = nextPoint;
                params.previousDirection = nextDirection;
            }
            else {
                // One more step
                params.streamline.push(nextPoint);
                params.valid = false;
            }
        }
    };
    /**
     * By simultaneously integrating in both directions we reduce the impact of circles not joining
     * up as the error matches at the join
     */
    StreamlineGenerator.prototype.integrateStreamline = function (seed, major) {
        var count = 0;
        var pointsEscaped = false; // True once two integration fronts have moved dlookahead away
        var d = this.integrator.integrate(seed, major);
        var forwardParams = {
            seed: seed,
            originalDir: d,
            streamline: [seed],
            previousDirection: d,
            previousPoint: seed.clone().add(d),
            valid: true,
        };
        forwardParams.valid = this.pointInBounds(forwardParams.previousPoint);
        var negD = d.clone().negate();
        var backwardParams = {
            seed: seed,
            originalDir: negD,
            streamline: [],
            previousDirection: negD,
            previousPoint: seed.clone().add(negD),
            valid: true,
        };
        backwardParams.valid = this.pointInBounds(backwardParams.previousPoint);
        while (count < this.params.pathIterations && (forwardParams.valid || backwardParams.valid)) {
            this.streamlineIntegrationStep(forwardParams, major);
            this.streamlineIntegrationStep(backwardParams, major);
            // Join up circles
            var sqDistanceBetweenPoints = forwardParams.previousPoint.distanceToSquared(backwardParams.previousPoint);
            if (!pointsEscaped && sqDistanceBetweenPoints > this.paramsSq.dcirclejoin) {
                pointsEscaped = true;
            }
            if (pointsEscaped && sqDistanceBetweenPoints <= this.paramsSq.dcirclejoin) {
                forwardParams.streamline.push(forwardParams.previousPoint);
                forwardParams.streamline.push(backwardParams.previousPoint);
                backwardParams.streamline.push(backwardParams.previousPoint);
                break;
            }
            count++;
        }
        return backwardParams.streamline.reverse().concat(forwardParams.streamline);
    };
    return StreamlineGenerator;
}());
exports.default = StreamlineGenerator;

},{"../vector":30,"./grid_storage":15,"loglevel":6,"simplify-js":10}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = require("../vector");
var Tensor = /** @class */ (function () {
    function Tensor(r, matrix) {
        this.r = r;
        this.matrix = matrix;
        // Matrix is 2 element list
        // [ 0, 1
        //   1, -0 ]
        this.oldTheta = false;
        this._theta = this.calculateTheta();
    }
    Object.defineProperty(Tensor.prototype, "theta", {
        get: function () {
            if (this.oldTheta) {
                this._theta = this.calculateTheta();
                this.oldTheta = false;
            }
            return this._theta;
        },
        enumerable: true,
        configurable: true
    });
    Tensor.prototype.add = function (tensor) {
        var _this = this;
        this.matrix = this.matrix.map(function (v, i) { return v * _this.r + tensor.matrix[i] * tensor.r; });
        this.r = 2;
        this.oldTheta = true;
        return this;
    };
    Tensor.prototype.scale = function (s) {
        this.r *= s;
        this.oldTheta = true;
        return this;
    };
    // Radians
    Tensor.prototype.rotate = function (theta) {
        if (theta === 0) {
            return this;
        }
        var newTheta = this.theta + theta;
        if (newTheta < Math.PI) {
            newTheta += Math.PI;
        }
        if (newTheta >= Math.PI) {
            newTheta -= Math.PI;
        }
        this.matrix[0] = Math.cos(2 * newTheta) * this.r;
        this.matrix[1] = Math.sin(2 * newTheta) * this.r;
        this._theta = newTheta;
        return this;
    };
    Tensor.prototype.getMajor = function () {
        // Degenerate case
        if (this.r === 0) {
            return vector_1.default.zeroVector();
        }
        return new vector_1.default(Math.cos(this.theta), Math.sin(this.theta));
    };
    Tensor.prototype.getMinor = function () {
        // Degenerate case
        if (this.r === 0) {
            return vector_1.default.zeroVector();
        }
        var angle = this.theta + Math.PI / 2;
        return new vector_1.default(Math.cos(angle), Math.sin(angle));
    };
    Tensor.prototype.calculateTheta = function () {
        if (this.r === 0) {
            return 0;
        }
        return Math.atan2(this.matrix[1] / this.r, this.matrix[0] / this.r) / 2;
    };
    return Tensor;
}());
exports.default = Tensor;

},{"../vector":30}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// import * as noise from 'noisejs';
var SimplexNoise = require("simplex-noise");
var tensor_1 = require("./tensor");
var basis_field_1 = require("./basis_field");
var TensorField = /** @class */ (function () {
    function TensorField(noiseParams) {
        this.noiseParams = noiseParams;
        this.basisFields = [];
        this.parks = [];
        this.sea = [];
        this.noise = new SimplexNoise();
    }
    TensorField.prototype.addGrid = function (centre, size, decay, theta) {
        var grid = new basis_field_1.Grid(centre, size, decay, theta);
        this.addField(grid);
    };
    TensorField.prototype.addRadial = function (centre, size, decay) {
        var radial = new basis_field_1.Radial(centre, size, decay);
        this.addField(radial);
    };
    TensorField.prototype.addField = function (field) {
        this.basisFields.push(field);
    };
    TensorField.prototype.removeField = function (field) {
        var index = this.basisFields.indexOf(field);
        if (index > -1) {
            this.basisFields.splice(index, 1);
        }
    };
    TensorField.prototype.reset = function () {
        this.basisFields = [];
        this.parks = [];
        this.sea = [];
    };
    TensorField.prototype.getCentrePoints = function () {
        return this.basisFields.map(function (field) { return field.centre; });
    };
    TensorField.prototype.setParks = function (p) {
        this.parks = p;
    };
    TensorField.prototype.setSea = function (p) {
        this.sea = p;
    };
    TensorField.prototype.samplePoint = function (point) {
        var _this = this;
        if (!this.onLand(point)) {
            // Degenerate point
            return new tensor_1.default(0, [0, 0]);
        }
        // Default field is a grid
        if (this.basisFields.length === 0) {
            return new tensor_1.default(1, [0, 0]);
        }
        var tensorAcc = new tensor_1.default(0, [0, 0]);
        this.basisFields.forEach(function (field) { return tensorAcc.add(field.getWeightedTensor(point)); });
        // Add rotational noise for parks - range -pi/2 to pi/2
        if (this.parks.some(function (p) { return _this.insidePolygon(point, p); })) {
            // TODO optimise insidePolygon e.g. distance
            tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizePark, this.noiseParams.noiseAnglePark));
        }
        if (this.noiseParams.globalNoise) {
            tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizeGlobal, this.noiseParams.noiseAngleGlobal));
        }
        return tensorAcc;
    };
    /**
     * Noise Angle is in degrees
     */
    TensorField.prototype.getRotationalNoise = function (point, noiseSize, noiseAngle) {
        return this.noise.noise2D(point.x / noiseSize, point.y / noiseSize) * noiseAngle * Math.PI / 180;
    };
    TensorField.prototype.onLand = function (point) {
        return !this.insidePolygon(point, this.sea);
    };
    TensorField.prototype.insidePolygon = function (point, polygon) {
        // ray-casting algorithm based on
        // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
        if (polygon.length === 0) {
            return false;
        }
        var inside = false;
        for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            var xi = polygon[i].x, yi = polygon[i].y;
            var xj = polygon[j].x, yj = polygon[j].y;
            var intersect = ((yi > point.y) != (yj > point.y))
                && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
            if (intersect)
                inside = !inside;
        }
        return inside;
    };
    ;
    return TensorField;
}());
exports.default = TensorField;

},{"./basis_field":13,"./tensor":19,"simplex-noise":9}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CanvasWrapper = /** @class */ (function () {
    function CanvasWrapper(canvas, _scale, resizeToWindow) {
        var _this = this;
        if (_scale === void 0) { _scale = 1; }
        if (resizeToWindow === void 0) { resizeToWindow = true; }
        this._scale = _scale;
        this.ctx = canvas.getContext("2d");
        this.setDimensions();
        this.resizeCanvas();
        if (resizeToWindow) {
            window.addEventListener('resize', function () {
                _this.setDimensions();
                _this.resizeCanvas();
            });
        }
        this.setFillStyle('black');
        this.clearCanvas();
    }
    CanvasWrapper.prototype.setDimensions = function () {
        this._width = window.innerWidth * this._scale;
        this._height = window.innerHeight * this._scale;
    };
    Object.defineProperty(CanvasWrapper.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasWrapper.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasWrapper.prototype, "canvasScale", {
        get: function () {
            return this._scale;
        },
        set: function (s) {
            this._scale = s;
            this.setDimensions();
            this.resizeCanvas();
        },
        enumerable: true,
        configurable: true
    });
    CanvasWrapper.prototype.setFillStyle = function (colour) {
        this.ctx.fillStyle = colour;
    };
    CanvasWrapper.prototype.clearCanvas = function () {
        this.drawRectangle(0, 0, window.innerWidth, window.innerHeight);
    };
    CanvasWrapper.prototype.drawRectangle = function (x, y, width, height) {
        if (this._scale !== 1) {
            x *= this._scale;
            y *= this._scale;
            width *= this._scale;
            height *= this._scale;
        }
        this.ctx.fillRect(x, y, width, height);
    };
    CanvasWrapper.prototype.drawPolygon = function (polygon) {
        var _this = this;
        if (polygon.length === 0) {
            return;
        }
        if (this._scale !== 1) {
            polygon = polygon.map(function (v) { return v.clone().multiplyScalar(_this._scale); });
        }
        this.ctx.beginPath();
        this.ctx.moveTo(polygon[0].x, polygon[0].y);
        for (var i = 1; i < polygon.length; i++) {
            this.ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        this.ctx.lineTo(polygon[0].x, polygon[0].y);
        this.ctx.fill();
        this.ctx.stroke();
    };
    CanvasWrapper.prototype.drawSquare = function (centre, radius) {
        this.drawRectangle(centre.x - radius, centre.y - radius, 2 * radius, 2 * radius);
    };
    CanvasWrapper.prototype.setLineWidth = function (width) {
        if (this._scale !== 1) {
            width *= this._scale;
        }
        this.ctx.lineWidth = width;
    };
    CanvasWrapper.prototype.setStrokeStyle = function (colour) {
        this.ctx.strokeStyle = colour;
    };
    CanvasWrapper.prototype.drawPolyline = function (line) {
        var _this = this;
        if (line.length < 2) {
            return;
        }
        if (this._scale !== 1) {
            line = line.map(function (v) { return v.clone().multiplyScalar(_this._scale); });
        }
        this.ctx.beginPath();
        this.ctx.moveTo(line[0].x, line[0].y);
        for (var i = 1; i < line.length; i++) {
            this.ctx.lineTo(line[i].x, line[i].y);
        }
        this.ctx.stroke();
    };
    CanvasWrapper.prototype.resizeCanvas = function () {
        this.ctx.canvas.width = this._width;
        this.ctx.canvas.height = this._height;
    };
    return CanvasWrapper;
}());
exports.default = CanvasWrapper;

},{}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var streamlines_1 = require("../impl/streamlines");
var polygon_finder_1 = require("../impl/polygon_finder");
var road_gui_1 = require("./road_gui");
var CoastlineGUI = /** @class */ (function (_super) {
    __extends(CoastlineGUI, _super);
    function CoastlineGUI(params, integrator, guiFolder, closeTensorFolder, folderName, redraw, noiseParams) {
        var _this = _super.call(this, params, integrator, guiFolder, closeTensorFolder, folderName, redraw) || this;
        _this.noiseParams = noiseParams;
        _this._seaPolygon = [];
        _this._noisyRoad = [];
        _this.noise = true;
        return _this;
    }
    CoastlineGUI.prototype.initFolder = function () {
        var roadGUI = {
            Generate: this.generateRoads.bind(this),
        };
        var folder = this.guiFolder.addFolder(this.folderName);
        folder.open();
        folder.add(roadGUI, 'Generate');
        var paramsFolder = folder.addFolder('Params');
        paramsFolder.add(this, 'noise');
        paramsFolder.add(this.noiseParams, 'noiseSizeGlobal');
        paramsFolder.add(this.noiseParams, 'noiseAngleGlobal');
        paramsFolder.add(this.params, 'simplifyTolerance');
        var devParamsFolder = paramsFolder.addFolder('Dev');
        this.addDevParamsToFolder(this.params, devParamsFolder);
        return this;
    };
    Object.defineProperty(CoastlineGUI.prototype, "seaPolygon", {
        get: function () {
            return this._seaPolygon;
        },
        enumerable: true,
        configurable: true
    });
    CoastlineGUI.prototype.generateRoads = function () {
        this.preGenerateCallback();
        this.domainController.zoom = this.domainController.zoom / 1.1;
        this.streamlines = new streamlines_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params));
        this.domainController.zoom = this.domainController.zoom * 1.1;
        if (this.noise) {
            this.noiseParams.globalNoise = true;
        }
        this._noisyRoad = this.streamlines.createCoastStreamline();
        this._seaPolygon = this.getSeaPolygon(this.allStreamlines[0]);
        this.noiseParams.globalNoise = false;
        this.closeTensorFolder();
        this.redraw();
        this.postGenerateCallback();
    };
    CoastlineGUI.prototype.drawCoastline = function (canvas) {
        var _this = this;
        canvas.drawPolyline(this._noisyRoad.map(function (v) { return _this.domainController.worldToScreen(v.clone()); }));
    };
    CoastlineGUI.prototype.drawSea = function (canvas) {
        var _this = this;
        canvas.drawPolygon(this._seaPolygon.map(function (v) { return _this.domainController.worldToScreen(v.clone()); }));
    };
    /**
     * Might reverse input array
     */
    CoastlineGUI.prototype.getSeaPolygon = function (polyline) {
        this.domainController.zoom = this.domainController.zoom / 1.1;
        var seaPolygon = polygon_finder_1.default.sliceRectangle(this.domainController.origin, this.domainController.worldDimensions, polyline[0], polyline[polyline.length - 1]);
        this.domainController.zoom = this.domainController.zoom * 1.1;
        // Replace the longest side with coastline
        var longestIndex = 0;
        var longestLength = 0;
        for (var i = 0; i < seaPolygon.length; i++) {
            var next = (i + 1) % seaPolygon.length;
            var d = seaPolygon[i].distanceToSquared(seaPolygon[next]);
            if (d > longestLength) {
                longestLength = d;
                longestIndex = i;
            }
        }
        var insertBackwards = seaPolygon[longestIndex].distanceToSquared(polyline[0]) > seaPolygon[longestIndex].distanceToSquared(polyline[polyline.length - 1]);
        if (insertBackwards) {
            polyline.reverse();
        }
        seaPolygon.splice.apply(seaPolygon, __spread([longestIndex, 0], polyline));
        return seaPolygon;
    };
    CoastlineGUI.prototype.addDevParamsToFolder = function (params, folder) {
        folder.add(params, 'dsep');
        folder.add(params, 'dtest');
        folder.add(params, 'pathIterations');
        folder.add(params, 'seedTries');
        folder.add(params, 'dstep');
        folder.add(params, 'dlookahead');
        folder.add(params, 'dcirclejoin');
        folder.add(params, 'joinangle');
    };
    return CoastlineGUI;
}(road_gui_1.default));
exports.default = CoastlineGUI;

},{"../impl/polygon_finder":17,"../impl/streamlines":18,"./road_gui":25}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = require("../vector");
/**
 * Singleton
 * Controls panning and zooming
 */
var DomainController = /** @class */ (function () {
    function DomainController() {
        var _this = this;
        this.ZOOM_SPEED = 0.96;
        // Location of screen origin in world space
        this._origin = vector_1.default.zeroVector();
        // Screen-space width and height
        this._screenDimensions = vector_1.default.zeroVector();
        // Ratio of screen pixels to world pixels
        this._zoom = 1;
        this.zoomCallback = function () { };
        // Set after pan or zoom
        this.moved = false;
        this.setScreenDimensions();
        window.addEventListener('resize', function () { return _this.setScreenDimensions(); });
        window.addEventListener('wheel', function (e) {
            var delta = e.deltaY;
            // TODO scale by value of delta
            if (delta > 0) {
                _this.zoom = _this._zoom * _this.ZOOM_SPEED;
            }
            else {
                _this.zoom = _this._zoom / _this.ZOOM_SPEED;
            }
        });
    }
    DomainController.prototype.setScreenDimensions = function () {
        this.moved = true;
        this._screenDimensions.setX(window.innerWidth);
        this._screenDimensions.setY(window.innerHeight);
    };
    DomainController.getInstance = function () {
        if (!DomainController.instance) {
            DomainController.instance = new DomainController();
        }
        return DomainController.instance;
    };
    /**
     * @param {Vector} delta in world space
     */
    DomainController.prototype.pan = function (delta) {
        this.moved = true;
        this._origin.sub(delta);
    };
    Object.defineProperty(DomainController.prototype, "origin", {
        get: function () {
            return this._origin.clone();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomainController.prototype, "zoom", {
        get: function () {
            return this._zoom;
        },
        set: function (z) {
            if (z > 0) {
                this.moved = true;
                var oldWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
                this._zoom = z;
                var newWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
                this.pan(newWorldSpaceMidpoint.sub(oldWorldSpaceMidpoint));
                this.zoomCallback();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomainController.prototype, "screenDimensions", {
        get: function () {
            return this._screenDimensions.clone();
        },
        set: function (v) {
            this.moved = true;
            this._screenDimensions.copy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomainController.prototype, "worldDimensions", {
        /**
         * @return {Vector} world-space w/h visible on screen
         */
        get: function () {
            return this.screenDimensions.divideScalar(this._zoom);
        },
        enumerable: true,
        configurable: true
    });
    DomainController.prototype.setZoomUpdate = function (callback) {
        this.zoomCallback = callback;
    };
    /**
     * Edits vector
     */
    DomainController.prototype.zoomToWorld = function (v) {
        return v.divideScalar(this._zoom);
    };
    /**
     * Edits vector
     */
    DomainController.prototype.zoomToScreen = function (v) {
        return v.multiplyScalar(this._zoom);
    };
    /**
     * Edits vector
     */
    DomainController.prototype.screenToWorld = function (v) {
        return this.zoomToWorld(v).add(this._origin);
    };
    /**
     * Edits vector
     */
    DomainController.prototype.worldToScreen = function (v) {
        return this.zoomToScreen(v.sub(this._origin));
    };
    return DomainController;
}());
exports.default = DomainController;

},{"../vector":30}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var interactjs_1 = require("interactjs");
var util_1 = require("../util");
var Vector_1 = require("../Vector");
var domain_controller_1 = require("./domain_controller");
/**
* Register multiple centre points
* Closest one to mouse click will be selected to drag
* Up to caller to actually move their centre point via callback
*/
var DragController = /** @class */ (function () {
    function DragController(gui) {
        this.gui = gui;
        // How close to drag handle pointer needs to be
        this.MIN_DRAG_DISTANCE = 50;
        this.draggables = [];
        this.currentlyDragging = null;
        this.disabled = false;
        this.domainController = domain_controller_1.default.getInstance();
        interactjs_1.default("#" + util_1.default.CANVAS_ID).draggable({
            onstart: this.dragStart.bind(this),
            onmove: this.dragMove.bind(this),
            onend: this.dragEnd.bind(this),
            cursorChecker: this.getCursor.bind(this),
        });
    }
    DragController.prototype.setDragDisabled = function (disable) {
        this.disabled = disable;
    };
    DragController.prototype.getCursor = function (action, interactable, element, interacting) {
        if (interacting)
            return 'grabbing';
        return 'grab';
    };
    DragController.prototype.dragStart = function (event) {
        var _this = this;
        // Transform screen space to world space
        var origin = this.domainController.screenToWorld(new Vector_1.default(event.x0, event.y0));
        var closestDistance = Infinity;
        this.draggables.forEach(function (draggable) {
            var d = draggable.getCentre().distanceTo(origin);
            if (d < closestDistance) {
                closestDistance = d;
                _this.currentlyDragging = draggable;
            }
        });
        // Zoom screen size to world size for consistent drag distance while zoomed in
        var scaledDragDistance = this.MIN_DRAG_DISTANCE / this.domainController.zoom;
        if (closestDistance > scaledDragDistance) {
            this.currentlyDragging = null;
        }
    };
    DragController.prototype.dragMove = function (event) {
        var delta = new Vector_1.default(event.delta.x, event.delta.y);
        this.domainController.zoomToWorld(delta);
        if (!this.disabled && this.currentlyDragging !== null) {
            // Drag field
            this.currentlyDragging.callbackFn(delta);
        }
        else {
            // Move map
            this.domainController.pan(delta);
        }
    };
    DragController.prototype.dragEnd = function () {
        this.currentlyDragging = null;
        util_1.default.updateGui(this.gui);
    };
    /**
     * @param {(() => Vector)} Gets centre point
     * @param {((v: Vector) => void)} Called on move with delta vector
     * @returns {(() => void)} Function to deregister callback
     */
    DragController.prototype.register = function (getCentre, onMove) {
        var _this = this;
        var draggable = {
            getCentre: getCentre,
            callbackFn: onMove,
        };
        this.draggables.push(draggable);
        return (function () {
            var index = _this.draggables.indexOf(draggable);
            if (index >= 0) {
                _this.draggables.splice(index, 1);
            }
        }).bind(this);
    };
    return DragController;
}());
exports.default = DragController;

},{"../Vector":12,"../util":29,"./domain_controller":23,"interactjs":3}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var domain_controller_1 = require("./domain_controller");
var util_1 = require("../util");
var streamlines_1 = require("../impl/streamlines");
var RoadGUI = /** @class */ (function () {
    function RoadGUI(params, integrator, guiFolder, closeTensorFolder, folderName, redraw) {
        var _this = this;
        this.params = params;
        this.integrator = integrator;
        this.guiFolder = guiFolder;
        this.closeTensorFolder = closeTensorFolder;
        this.folderName = folderName;
        this.redraw = redraw;
        this.existingStreamlines = [];
        this.domainController = domain_controller_1.default.getInstance();
        this.preGenerateCallback = function () { };
        this.postGenerateCallback = function () { };
        this.streamlines = new streamlines_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, this.params);
        // Update path iterations based on window size
        this.setPathIterations();
        window.addEventListener('resize', function () { return _this.setPathIterations(); });
    }
    RoadGUI.prototype.initFolder = function () {
        var _this = this;
        var roadGUI = {
            Generate: this.generateRoads.bind(this),
            JoinDangling: function () {
                _this.streamlines.joinDanglingStreamlines();
                _this.redraw();
            },
        };
        var folder = this.guiFolder.addFolder(this.folderName);
        folder.add(roadGUI, 'Generate');
        folder.add(roadGUI, 'JoinDangling');
        var paramsFolder = folder.addFolder('Params');
        paramsFolder.add(this.params, 'dsep');
        paramsFolder.add(this.params, 'dtest');
        var devParamsFolder = paramsFolder.addFolder('Dev');
        this.addDevParamsToFolder(this.params, devParamsFolder);
        return this;
    };
    Object.defineProperty(RoadGUI.prototype, "allStreamlines", {
        get: function () {
            return this.streamlines.allStreamlinesSimple;
        },
        enumerable: true,
        configurable: true
    });
    RoadGUI.prototype.draw = function (canvas) {
        var _this = this;
        this.streamlines.allStreamlinesSimple.forEach(function (s) {
            canvas.drawPolyline(s.map(function (v) { return _this.domainController.worldToScreen(v.clone()); }));
        });
    };
    RoadGUI.prototype.roadsEmpty = function () {
        return this.streamlines.allStreamlinesSimple.length === 0;
    };
    RoadGUI.prototype.setExistingStreamlines = function (existingStreamlines) {
        this.existingStreamlines = existingStreamlines;
    };
    RoadGUI.prototype.setPreGenerateCallback = function (callback) {
        this.preGenerateCallback = callback;
    };
    RoadGUI.prototype.setPostGenerateCallback = function (callback) {
        this.postGenerateCallback = callback;
    };
    RoadGUI.prototype.clearStreamlines = function () {
        this.streamlines.clearStreamlines();
    };
    RoadGUI.prototype.generateRoads = function () {
        var _this = this;
        this.preGenerateCallback();
        this.domainController.zoom = this.domainController.zoom / 1.1;
        this.streamlines = new streamlines_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params));
        this.domainController.zoom = this.domainController.zoom * 1.1;
        this.existingStreamlines.forEach(function (s) { return _this.streamlines.addExistingStreamlines(s.streamlines); });
        this.streamlines.createAllStreamlines();
        this.streamlines.joinDanglingStreamlines();
        this.closeTensorFolder();
        this.redraw();
        this.postGenerateCallback();
    };
    RoadGUI.prototype.addDevParamsToFolder = function (params, folder) {
        folder.add(params, 'pathIterations');
        folder.add(params, 'seedTries');
        folder.add(params, 'dstep');
        folder.add(params, 'dlookahead');
        folder.add(params, 'dcirclejoin');
        folder.add(params, 'joinangle');
        folder.add(params, 'simplifyTolerance');
    };
    /**
     * Sets path iterations so that a road can cover the screen
     */
    RoadGUI.prototype.setPathIterations = function () {
        var max = 1.5 * Math.max(window.innerWidth, window.innerHeight);
        this.params.pathIterations = max / this.params.dstep;
        util_1.default.updateGui(this.guiFolder);
    };
    return RoadGUI;
}());
exports.default = RoadGUI;

},{"../impl/streamlines":18,"../util":29,"./domain_controller":23}],26:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var domain_controller_1 = require("./domain_controller");
var integrator_1 = require("../impl/integrator");
var graph_1 = require("../impl/graph");
var road_gui_1 = require("./road_gui");
var coastline_gui_1 = require("./coastline_gui");
var polygon_finder_1 = require("../impl/polygon_finder");
var RoadsGUI = /** @class */ (function () {
    function RoadsGUI(guiFolder, tensorField, closeTensorFolder) {
        var _this = this;
        this.guiFolder = guiFolder;
        this.closeTensorFolder = closeTensorFolder;
        this.domainController = domain_controller_1.default.getInstance();
        this.intersections = [];
        this.numParks = 2;
        this.parks = [];
        this.lots = [];
        this.buildingSize = 80;
        this.buildingMargin = 4;
        this.minorParams = {
            dsep: 20,
            dtest: 10,
            dstep: 1,
            dlookahead: 100,
            dcirclejoin: 5,
            joinangle: 0.1,
            pathIterations: 1000,
            seedTries: 300,
            simplifyTolerance: 0.5,
        };
        this.redraw = true;
        var roadsParams = guiFolder.addFolder('Params');
        roadsParams.add(this, 'numParks');
        this.coastlineParams = Object.assign({}, this.minorParams);
        this.coastlineParams.pathIterations = 10000;
        this.coastlineParams.simplifyTolerance = 10;
        this.majorParams = Object.assign({}, this.minorParams);
        this.majorParams.dsep = 100;
        this.majorParams.dtest = 30;
        this.majorParams.dlookahead = 200;
        this.mainParams = Object.assign({}, this.minorParams);
        this.mainParams.dsep = 400;
        this.mainParams.dtest = 200;
        this.mainParams.dlookahead = 300;
        var integrator = new integrator_1.RK4Integrator(tensorField, this.minorParams);
        var redraw = function () { return _this.redraw = true; };
        this.coastline = new coastline_gui_1.default(this.coastlineParams, integrator, this.guiFolder, closeTensorFolder, 'Coastline', redraw, tensorField.noiseParams).initFolder();
        this.mainRoads = new road_gui_1.default(this.mainParams, integrator, this.guiFolder, closeTensorFolder, 'Main', redraw).initFolder();
        this.majorRoads = new road_gui_1.default(this.majorParams, integrator, this.guiFolder, closeTensorFolder, 'Major', redraw).initFolder();
        this.minorRoads = new road_gui_1.default(this.minorParams, integrator, this.guiFolder, closeTensorFolder, 'Minor', redraw).initFolder();
        this.minorRoads.setExistingStreamlines([this.coastline, this.mainRoads, this.majorRoads]);
        this.majorRoads.setExistingStreamlines([this.coastline, this.mainRoads]);
        this.mainRoads.setExistingStreamlines([this.coastline]);
        this.coastline.setPreGenerateCallback(function () {
            _this.mainRoads.clearStreamlines();
            _this.majorRoads.clearStreamlines();
            _this.minorRoads.clearStreamlines();
            _this.parks = [];
            _this.lots = [];
            tensorField.setParks([]);
            tensorField.setSea([]);
        });
        this.coastline.setPostGenerateCallback(function () {
            tensorField.setSea(_this.coastline.seaPolygon);
        });
        this.mainRoads.setPreGenerateCallback(function () {
            _this.majorRoads.clearStreamlines();
            _this.minorRoads.clearStreamlines();
            _this.parks = [];
            _this.lots = [];
            tensorField.setParks([]);
        });
        this.majorRoads.setPreGenerateCallback(function () {
            _this.minorRoads.clearStreamlines();
            _this.parks = [];
            _this.lots = [];
            tensorField.setParks(_this.parks);
        });
        this.majorRoads.setPostGenerateCallback(function () {
            var e_1, _a;
            var g = new graph_1.default(_this.majorRoads.allStreamlines.concat(_this.mainRoads.allStreamlines), _this.minorParams.dstep);
            _this.intersections = g.intersections;
            var p = new polygon_finder_1.default(g.nodes);
            p.findPolygons();
            var polygons = p.polygons;
            if (polygons.length > _this.numParks) {
                var parkIndex = Math.floor(Math.random() * (polygons.length - _this.numParks));
                for (var i = parkIndex; i < parkIndex + _this.numParks; i++) {
                    _this.parks.push(polygons[i]);
                }
            }
            else {
                try {
                    for (var polygons_1 = __values(polygons), polygons_1_1 = polygons_1.next(); !polygons_1_1.done; polygons_1_1 = polygons_1.next()) {
                        var p_1 = polygons_1_1.value;
                        _this.parks.push(p_1);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (polygons_1_1 && !polygons_1_1.done && (_a = polygons_1.return)) _a.call(polygons_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
        this.minorRoads.setPreGenerateCallback(function () {
            _this.lots = [];
        });
        var buildingsFolder = guiFolder.addFolder('Buildings');
        buildingsFolder.add(this, 'addBuildings');
        buildingsFolder.add(this, 'buildingSize');
        buildingsFolder.add(this, 'buildingMargin');
    }
    RoadsGUI.prototype.addBuildings = function () {
        var g = new graph_1.default(this.majorRoads.allStreamlines
            .concat(this.mainRoads.allStreamlines)
            .concat(this.minorRoads.allStreamlines)
            .concat(this.coastline.allStreamlines), this.minorParams.dstep);
        var p = new polygon_finder_1.default(g.nodes);
        p.shrink(this.buildingMargin);
        p.divide(this.buildingSize);
        this.lots = p.polygons;
        this.redraw = true;
    };
    RoadsGUI.prototype.draw = function (canvas, forceDraw) {
        var _this = this;
        if (forceDraw === void 0) { forceDraw = false; }
        if (!forceDraw && !this.redraw && !this.domainController.moved) {
            return;
        }
        this.domainController.moved = false;
        this.redraw = false;
        canvas.setFillStyle('#ECE5DB');
        canvas.clearCanvas();
        // Sea
        canvas.setFillStyle('#a9d9fe');
        canvas.setStrokeStyle('#a9d9fe');
        canvas.setLineWidth(0.1);
        canvas.drawPolygon(this.coastline.seaPolygon.map(function (v) { return _this.domainController.worldToScreen(v.clone()); }));
        canvas.setStrokeStyle('#ECE5DB');
        canvas.setLineWidth(30 * this.domainController.zoom);
        this.coastline.drawCoastline(canvas);
        // Buildings
        canvas.setFillStyle('#ECE5DB');
        // canvas.setFillStyle('#ebae34');
        canvas.setStrokeStyle('#282828');
        canvas.setLineWidth(0.5);
        this.lots.forEach(function (p) {
            canvas.drawPolygon(p.map(function (v) { return _this.domainController.worldToScreen(v.clone()); }));
        });
        // Parks
        canvas.setFillStyle('#c5e8c5');
        this.parks.forEach(function (p) {
            canvas.drawPolygon(p.map(function (v) { return _this.domainController.worldToScreen(v.clone()); }));
        });
        // Road outline
        canvas.setStrokeStyle('#020202');
        canvas.setLineWidth(3 * this.domainController.zoom);
        this.minorRoads.draw(canvas);
        canvas.setStrokeStyle('#020202');
        canvas.setLineWidth(5 * this.domainController.zoom);
        this.majorRoads.draw(canvas);
        canvas.setStrokeStyle('#282828');
        canvas.setLineWidth(6 * this.domainController.zoom);
        this.mainRoads.draw(canvas);
        this.coastline.draw(canvas);
        // Road inline
        canvas.setStrokeStyle('#F8F8F8');
        canvas.setLineWidth(2 * this.domainController.zoom);
        this.minorRoads.draw(canvas);
        canvas.setStrokeStyle('#F8F8F8');
        canvas.setLineWidth(4 * this.domainController.zoom);
        this.majorRoads.draw(canvas);
        canvas.setStrokeStyle('#FAFA7A');
        canvas.setLineWidth(5 * this.domainController.zoom);
        this.mainRoads.draw(canvas);
        this.coastline.draw(canvas);
        // Coast
        // canvas.setStrokeStyle('#020202');
        // canvas.setLineWidth(1);
        // canvas.drawPolyline(this.coast.map(v => this.domainController.worldToScreen(v.clone())));
        // canvas.setFillStyle('red');
        // this.intersections.forEach(v =>
        //     canvas.drawSquare(this.domainController.worldToScreen(v.clone()), 2));
    };
    RoadsGUI.prototype.roadsEmpty = function () {
        return this.majorRoads.roadsEmpty()
            && this.minorRoads.roadsEmpty()
            && this.mainRoads.roadsEmpty()
            && this.coastline.roadsEmpty();
    };
    return RoadsGUI;
}());
exports.default = RoadsGUI;

},{"../impl/graph":14,"../impl/integrator":16,"../impl/polygon_finder":17,"./coastline_gui":22,"./domain_controller":23,"./road_gui":25}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var roughjs_1 = require("roughjs");
var canvas_wrapper_1 = require("./canvas_wrapper");
var RoughCanvas = /** @class */ (function (_super) {
    __extends(RoughCanvas, _super);
    function RoughCanvas(canvas, scale, resizeToWindow) {
        if (scale === void 0) { scale = 1; }
        if (resizeToWindow === void 0) { resizeToWindow = true; }
        var _this = _super.call(this, canvas, scale, resizeToWindow) || this;
        var rc = roughjs_1.default.canvas(canvas);
        return _this;
        // this.rc = rc;
    }
    return RoughCanvas;
}(canvas_wrapper_1.default));
exports.default = RoughCanvas;

},{"./canvas_wrapper":21,"roughjs":8}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var domain_controller_1 = require("./domain_controller");
var tensor_field_1 = require("../impl/tensor_field");
var util_1 = require("../util");
var vector_1 = require("../vector");
var TensorFieldGUI = /** @class */ (function (_super) {
    __extends(TensorFieldGUI, _super);
    function TensorFieldGUI(guiFolder, dragController, drawCentre, noiseParams) {
        var _this = _super.call(this, noiseParams) || this;
        _this.guiFolder = guiFolder;
        _this.dragController = dragController;
        _this.drawCentre = drawCentre;
        _this.TENSOR_LINE_DIAMETER = 20;
        _this.TENSOR_SPAWN_SCALE = 0.7; // How much to shrink worldDimensions to find spawn point
        _this.domainController = domain_controller_1.default.getInstance();
        // For custom naming of gui buttons
        var tensorFieldGuiObj = {
            reset: function () { return _this.reset(); },
            setRecommended: function () { return _this.setRecommended(); },
            addRadial: function () { return _this.addRadialRandom(); },
            addGrid: function () { return _this.addGridRandom(); },
        };
        _this.guiFolder.add(tensorFieldGuiObj, 'reset');
        _this.guiFolder.add(tensorFieldGuiObj, 'setRecommended');
        _this.guiFolder.add(tensorFieldGuiObj, 'addRadial');
        _this.guiFolder.add(tensorFieldGuiObj, 'addGrid');
        return _this;
    }
    /**
     * 4 Grids, one radial
     */
    TensorFieldGUI.prototype.setRecommended = function () {
        this.reset();
        var size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
        var newOrigin = this.domainController.worldDimensions
            .multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2)
            .add(this.domainController.origin);
        this.addGridAtLocation(newOrigin);
        this.addGridAtLocation(newOrigin.clone().add(size));
        this.addGridAtLocation(newOrigin.clone().add(new vector_1.default(size.x, 0)));
        this.addGridAtLocation(newOrigin.clone().add(new vector_1.default(0, size.y)));
        this.addRadialRandom();
    };
    TensorFieldGUI.prototype.addRadialRandom = function () {
        var width = this.domainController.worldDimensions.x;
        this.addRadial(this.randomLocation(), util_1.default.randomRange(width / 10, width / 5), // Size
        util_1.default.randomRange(50)); // Decay
    };
    TensorFieldGUI.prototype.addGridRandom = function () {
        this.addGridAtLocation(this.randomLocation());
    };
    TensorFieldGUI.prototype.addGridAtLocation = function (location) {
        var width = this.domainController.worldDimensions.x;
        this.addGrid(location, util_1.default.randomRange(width / 4, width), // Size
        util_1.default.randomRange(50), // Decay
        util_1.default.randomRange(Math.PI / 2));
    };
    /**
     * World-space random location for tensor field spawn
     * Sampled from middle of screen (shrunk rectangle)
     */
    TensorFieldGUI.prototype.randomLocation = function () {
        var size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
        var location = new vector_1.default(Math.random(), Math.random()).multiply(size);
        var newOrigin = this.domainController.worldDimensions.multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2);
        return location.add(this.domainController.origin).add(newOrigin);
    };
    TensorFieldGUI.prototype.getCrossLocations = function () {
        // Gets grid of points for vector field vis in world space
        var diameter = this.TENSOR_LINE_DIAMETER / this.domainController.zoom;
        var worldDimensions = this.domainController.worldDimensions;
        var nHor = Math.ceil(worldDimensions.x / diameter) + 1; // Prevent pop-in
        var nVer = Math.ceil(worldDimensions.y / diameter) + 1;
        var originX = diameter * Math.floor(this.domainController.origin.x / diameter);
        var originY = diameter * Math.floor(this.domainController.origin.y / diameter);
        var out = [];
        for (var x = 0; x <= nHor; x++) {
            for (var y = 0; y <= nVer; y++) {
                out.push(new vector_1.default(originX + (x * diameter), originY + (y * diameter)));
            }
        }
        return out;
    };
    TensorFieldGUI.prototype.getTensorLine = function (point, tensorV) {
        var transformedPoint = this.domainController.worldToScreen(point.clone());
        var diff = tensorV.multiplyScalar(this.TENSOR_LINE_DIAMETER / 2); // Assumes normalised
        var start = transformedPoint.clone().sub(diff);
        var end = transformedPoint.clone().add(diff);
        return [start, end];
    };
    TensorFieldGUI.prototype.draw = function (canvas, forceDraw) {
        var _this = this;
        if (forceDraw === void 0) { forceDraw = false; }
        // Draw tensor field
        canvas.setStrokeStyle('white');
        canvas.setLineWidth(1);
        var tensorPoints = this.getCrossLocations();
        tensorPoints.forEach(function (p) {
            var t = _this.samplePoint(p);
            canvas.drawPolyline(_this.getTensorLine(p, t.getMajor()));
            canvas.drawPolyline(_this.getTensorLine(p, t.getMinor()));
        });
        // Draw centre points of fields
        if (this.drawCentre) {
            canvas.setFillStyle('red');
            this.getCentrePoints().forEach(function (v) {
                return canvas.drawSquare(_this.domainController.worldToScreen(v), 7);
            });
        }
    };
    TensorFieldGUI.prototype.addField = function (field) {
        var _this = this;
        _super.prototype.addField.call(this, field);
        var folder = this.guiFolder.addFolder("" + field.FOLDER_NAME);
        // Function to deregister from drag controller
        var deregisterDrag = this.dragController.register(function () { return field.centre; }, field.dragMoveListener.bind(field));
        var removeFieldObj = { remove: function () { return _this.removeFieldGUI.bind(_this)(field, folder, deregisterDrag); } };
        // Give dat gui removeField button
        folder.add(removeFieldObj, 'remove');
        field.setGui(folder);
    };
    TensorFieldGUI.prototype.removeFieldGUI = function (field, folder, deregisterDrag) {
        _super.prototype.removeField.call(this, field);
        this.guiFolder.removeFolder(folder);
        // Deregister from drag controller
        deregisterDrag();
    };
    TensorFieldGUI.prototype.reset = function () {
        // TODO kind of hacky - calling remove callbacks from gui object, should store callbacks
        // in addfield and call them (requires making sure they're idempotent)
        for (var fieldFolderName in this.guiFolder.__folders) {
            var fieldFolder = this.guiFolder.__folders[fieldFolderName];
            fieldFolder.__controllers[0].initialValue();
        }
        _super.prototype.reset.call(this);
    };
    return TensorFieldGUI;
}(tensor_field_1.default));
exports.default = TensorFieldGUI;

},{"../impl/tensor_field":20,"../util":29,"../vector":30,"./domain_controller":23}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Util = /** @class */ (function () {
    function Util() {
    }
    Util.updateGui = function (gui) {
        if (gui.__controllers) {
            gui.__controllers.forEach(function (c) { return c.updateDisplay(); });
        }
        if (gui.__folders) {
            for (var folderName in gui.__folders) {
                this.updateGui(gui.__folders[folderName]);
            }
        }
    };
    Util.removeAllFolders = function (gui) {
        if (gui.__folders) {
            for (var folderName in gui.__folders) {
                gui.removeFolder(gui.__folders[folderName]);
            }
        }
    };
    Util.randomRange = function (max, min) {
        if (min === void 0) { min = 0; }
        return (Math.random() * (max - min)) + min;
    };
    // Must match style.css
    Util.CANVAS_ID = 'map-canvas';
    Util.IMG_CANVAS_ID = 'img-canvas';
    return Util;
}());
exports.default = Util;

},{}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var Vector = /** @class */ (function () {
    function Vector(x, y) {
        this.x = x;
        this.y = y;
    }
    Vector.zeroVector = function () {
        return new Vector(0, 0);
    };
    Vector.fromScalar = function (s) {
        return new Vector(s, s);
    };
    /**
     * -pi to pi
     */
    Vector.angleBetween = function (v1, v2) {
        // -2pi to 2pi
        var angleBetween = v1.angle() - v2.angle();
        if (angleBetween > Math.PI) {
            angleBetween -= 2 * Math.PI;
        }
        else if (angleBetween <= -Math.PI) {
            angleBetween += 2 * Math.PI;
        }
        return angleBetween;
    };
    /**
     * Tests whether a point lies to the left of a line
     * @param  {Vector} linePoint     Point on the line
     * @param  {Vector} lineDirection
     * @param  {Vector} point
     * @return {Vector}               true if left, false otherwise
     */
    Vector.isLeft = function (linePoint, lineDirection, point) {
        var perpendicularVector = new Vector(lineDirection.y, -lineDirection.x);
        return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
    };
    Vector.prototype.add = function (v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    };
    /**
     * Angle in radians to positive x-axis between -pi and pi
     */
    Vector.prototype.angle = function () {
        return Math.atan2(this.y, this.x);
    };
    Vector.prototype.clone = function () {
        return new Vector(this.x, this.y);
    };
    Vector.prototype.copy = function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    };
    Vector.prototype.cross = function (v) {
        return this.x * v.y - this.y * v.x;
    };
    Vector.prototype.distanceTo = function (v) {
        return Math.sqrt(this.distanceToSquared(v));
    };
    Vector.prototype.distanceToSquared = function (v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        return dx * dx + dy * dy;
    };
    Vector.prototype.divide = function (v) {
        if (v.x === 0 || v.y === 0) {
            log.warn("Division by zero");
            return this;
        }
        this.x /= v.x;
        this.y /= v.y;
        return this;
    };
    Vector.prototype.divideScalar = function (s) {
        if (s === 0) {
            log.warn("Division by zero");
            return this;
        }
        return this.multiplyScalar(1 / s);
    };
    Vector.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y;
    };
    Vector.prototype.equals = function (v) {
        return ((v.x === this.x) && (v.y === this.y));
    };
    Vector.prototype.length = function () {
        return Math.sqrt(this.lengthSq());
    };
    Vector.prototype.lengthSq = function () {
        return this.x * this.x + this.y * this.y;
    };
    Vector.prototype.multiply = function (v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    };
    Vector.prototype.multiplyScalar = function (s) {
        this.x *= s;
        this.y *= s;
        return this;
    };
    Vector.prototype.negate = function () {
        return this.multiplyScalar(-1);
    };
    Vector.prototype.normalize = function () {
        var l = this.length();
        if (l === 0) {
            log.warn("Zero Vector");
            return this;
        }
        return this.divideScalar(this.length());
    };
    /**
     * Angle in radians
     */
    Vector.prototype.rotateAround = function (center, angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * cos - y * sin + center.x;
        this.y = x * sin + y * cos + center.y;
        return this;
    };
    Vector.prototype.set = function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    };
    Vector.prototype.setX = function (x) {
        this.x = x;
        return this;
    };
    Vector.prototype.setY = function (y) {
        this.y = y;
        return this;
    };
    Vector.prototype.setLength = function (length) {
        return this.normalize().multiplyScalar(length);
    };
    Vector.prototype.sub = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    };
    return Vector;
}());
exports.default = Vector;

},{"loglevel":6}]},{},[11,13,14,15,16,17,18,20,19,21,22,23,24,25,26,27,28,29,30])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvZGlzdC9kMy1xdWFkdHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXQuZ3VpL2J1aWxkL2RhdC5ndWkuanMiLCJub2RlX21vZHVsZXMvaW50ZXJhY3Rqcy9kaXN0L2ludGVyYWN0Lm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9pc2VjdC9idWlsZC9pc2VjdC5qcyIsIm5vZGVfbW9kdWxlcy9qc3RzL2Rpc3QvanN0cy5taW4uanMiLCJub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzL3BvbHlrL2Rpc3QvcG9seWsuanMiLCJub2RlX21vZHVsZXMvcm91Z2hqcy9idW5kbGVkL3JvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZXgtbm9pc2Uvc2ltcGxleC1ub2lzZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGlmeS1qcy9zaW1wbGlmeS5qcyIsInNyYy9tYWluLnRzIiwic3JjL3RzL1ZlY3Rvci50cyIsInNyYy90cy9pbXBsL2Jhc2lzX2ZpZWxkLnRzIiwic3JjL3RzL2ltcGwvZ3JhcGgudHMiLCJzcmMvdHMvaW1wbC9ncmlkX3N0b3JhZ2UudHMiLCJzcmMvdHMvaW1wbC9pbnRlZ3JhdG9yLnRzIiwic3JjL3RzL2ltcGwvcG9seWdvbl9maW5kZXIudHMiLCJzcmMvdHMvaW1wbC9zdHJlYW1saW5lcy50cyIsInNyYy90cy9pbXBsL3RlbnNvci50cyIsInNyYy90cy9pbXBsL3RlbnNvcl9maWVsZC50cyIsInNyYy90cy91aS9jYW52YXNfd3JhcHBlci50cyIsInNyYy90cy91aS9jb2FzdGxpbmVfZ3VpLnRzIiwic3JjL3RzL3VpL2RvbWFpbl9jb250cm9sbGVyLnRzIiwic3JjL3RzL3VpL2RyYWdfY29udHJvbGxlci50cyIsInNyYy90cy91aS9yb2FkX2d1aS50cyIsInNyYy90cy91aS9yb2Fkc19ndWkudHMiLCJzcmMvdHMvdWkvcm91Z2hfY2FudmFzLnRzIiwic3JjL3RzL3VpL3RlbnNvcl9maWVsZF9ndWkudHMiLCJzcmMvdHMvdXRpbC50cyIsInNyYy90cy92ZWN0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeitFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmxFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h2QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUhBLDZCQUErQjtBQUMvQiw2REFBc0Q7QUFFdEQsK0NBQXlDO0FBQ3pDLHlEQUFtRDtBQUNuRCxrQ0FBNkI7QUFDN0IsMkRBQXFEO0FBQ3JELCtEQUF5RDtBQU16RDtJQWtCSTtRQUFBLGlCQWdDQztRQWpETyxxQkFBZ0IsR0FBRywyQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUVsRCxRQUFHLEdBQVksSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBQyxDQUFDLENBQUM7UUFHekMsbUJBQWMsR0FBRyxJQUFJLHlCQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXRELFVBQVU7UUFDRixlQUFVLEdBQUcsQ0FBQyxDQUFDO1FBTXZCLDBCQUEwQjtRQUNsQiw0QkFBdUIsR0FBRyxJQUFJLENBQUM7UUFHbkMsSUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxjQUFJLENBQUMsU0FBUyxDQUFzQixDQUFDO1FBQ3ZFLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSx3QkFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNuRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLGNBQU0sT0FBQSxjQUFjLENBQUMsYUFBYSxFQUFFLEVBQTlCLENBQThCLENBQUMsQ0FBQztRQUUxRSxJQUFNLFdBQVcsR0FBZ0I7WUFDN0IsV0FBVyxFQUFFLEtBQUs7WUFDbEIsYUFBYSxFQUFFLEVBQUU7WUFDakIsY0FBYyxFQUFFLEVBQUU7WUFDbEIsZUFBZSxFQUFFLEVBQUU7WUFDbkIsZ0JBQWdCLEVBQUUsRUFBRTtTQUN2QixDQUFDO1FBRUYsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN2RCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksMEJBQWMsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ2pHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXhCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxtQkFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxjQUFNLE9BQUEsS0FBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsRUFBekIsQ0FBeUIsQ0FBQyxDQUFDO1FBRWxHLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3BELGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNsRCxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDOUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM1QyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztRQUVwQyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBRWxDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVEOzs7T0FHRztJQUNILHVCQUFRLEdBQVI7UUFDSSxJQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGNBQUksQ0FBQyxhQUFhLENBQXNCLENBQUM7UUFDM0UsSUFBTSxTQUFTLEdBQUcsSUFBSSx3QkFBYSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQy9ELElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzNCLElBQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7UUFDMUIsSUFBSSxDQUFDLElBQUksR0FBSSxRQUFRLENBQUMsY0FBYyxDQUFDLGNBQUksQ0FBQyxhQUFhLENBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUM3RSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUVPLDhCQUFlLEdBQXZCO1FBQ0ksT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDbkUsQ0FBQztJQUVELG1CQUFJLEdBQUosVUFBSyxNQUFxQixFQUFFLFNBQWU7UUFBZiwwQkFBQSxFQUFBLGlCQUFlO1FBQ3ZDLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFO1lBQ3hCLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxJQUFJLENBQUM7WUFDcEMsTUFBTSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM3QixNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDckIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQzVDO2FBQU07WUFDSCxJQUFJLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMxQyxJQUFJLElBQUksQ0FBQyx1QkFBdUIsS0FBSyxJQUFJLEVBQUU7Z0JBQ3ZDLGVBQWU7Z0JBQ2YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNqQyxJQUFJLENBQUMsdUJBQXVCLEdBQUcsS0FBSyxDQUFDO2FBQ3hDO2lCQUFNO2dCQUNILElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQzthQUN6QztTQUNKO0lBQ0wsQ0FBQztJQUVELHFCQUFNLEdBQU47UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN2QixxQkFBcUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFDTCxXQUFDO0FBQUQsQ0E3RkEsQUE2RkMsSUFBQTtBQUVELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUU7SUFDNUIsSUFBSSxJQUFJLEVBQUUsQ0FBQztBQUNmLENBQUMsQ0FBQyxDQUFDOzs7OztBQy9HSCw4QkFBZ0M7QUFFaEM7SUFDSSxnQkFBbUIsQ0FBUyxFQUFTLENBQVM7UUFBM0IsTUFBQyxHQUFELENBQUMsQ0FBUTtRQUFTLE1BQUMsR0FBRCxDQUFDLENBQVE7SUFBRyxDQUFDO0lBRTNDLGlCQUFVLEdBQWpCO1FBQ0ksT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVNLGlCQUFVLEdBQWpCLFVBQWtCLENBQVM7UUFDdkIsT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksbUJBQVksR0FBbkIsVUFBb0IsRUFBVSxFQUFFLEVBQVU7UUFDdEMsY0FBYztRQUNkLElBQUksWUFBWSxHQUFHLEVBQUUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDM0MsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUN4QixZQUFZLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDL0I7YUFBTSxJQUFJLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDakMsWUFBWSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO1NBQy9CO1FBQ0QsT0FBTyxZQUFZLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLGFBQU0sR0FBYixVQUFjLFNBQWlCLEVBQUUsYUFBcUIsRUFBRSxLQUFhO1FBQ2pFLElBQU0sbUJBQW1CLEdBQUcsSUFBSSxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxRSxPQUFPLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRCxvQkFBRyxHQUFILFVBQUksQ0FBUztRQUNULElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNkLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNkLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7T0FFRztJQUNILHNCQUFLLEdBQUw7UUFDSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELHNCQUFLLEdBQUw7UUFDSSxPQUFPLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxxQkFBSSxHQUFKLFVBQUssQ0FBUztRQUNWLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNiLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNiLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxzQkFBSyxHQUFMLFVBQU0sQ0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsMkJBQVUsR0FBVixVQUFXLENBQVM7UUFDaEIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRCxrQ0FBaUIsR0FBakIsVUFBbUIsQ0FBUztRQUN4QixJQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDdkIsSUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRCx1QkFBTSxHQUFOLFVBQU8sQ0FBUztRQUNaLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDeEIsR0FBRyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBQzdCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDZCxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDZCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsNkJBQVksR0FBWixVQUFhLENBQVM7UUFDbEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ1QsR0FBRyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBQzdCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxvQkFBRyxHQUFILFVBQUksQ0FBUztRQUNULE9BQU8sSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsdUJBQU0sR0FBTixVQUFPLENBQVM7UUFDWixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVELHVCQUFNLEdBQU47UUFDSSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELHlCQUFRLEdBQVI7UUFDSSxPQUFPLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELHlCQUFRLEdBQVIsVUFBUyxDQUFTO1FBQ2QsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELCtCQUFjLEdBQWQsVUFBZSxDQUFTO1FBQ3BCLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDWixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsdUJBQU0sR0FBTjtRQUNJLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRCwwQkFBUyxHQUFUO1FBQ0ksSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNULEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDeEIsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCw2QkFBWSxHQUFaLFVBQWEsTUFBYyxFQUFFLEtBQWE7UUFDdEMsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUMzQixJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTVCLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUM1QixJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFFNUIsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxvQkFBRyxHQUFILFVBQUksQ0FBUztRQUNULElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNiLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNiLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxxQkFBSSxHQUFKLFVBQUssQ0FBUztRQUNWLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELHFCQUFJLEdBQUosVUFBSyxDQUFTO1FBQ1YsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsMEJBQVMsR0FBVCxVQUFXLE1BQWM7UUFDckIsT0FBTyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRCxvQkFBRyxHQUFILFVBQUksQ0FBUztRQUNULElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNkLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNkLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFDTCxhQUFDO0FBQUQsQ0EvS0EsQUErS0MsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pMRCxtQ0FBOEI7QUFHOUI7SUFLSSxvQkFBWSxNQUFjLEVBQVksS0FBYSxFQUFZLE1BQWM7UUFBdkMsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUFZLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDekUsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVELHNCQUFJLDhCQUFNO2FBSVY7WUFDSSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDaEMsQ0FBQzthQU5ELFVBQVcsTUFBYztZQUNyQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QixDQUFDOzs7T0FBQTtJQU1ELHNCQUFJLDZCQUFLO2FBQVQsVUFBVSxLQUFhO1lBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksNEJBQUk7YUFBUixVQUFTLElBQVk7WUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDdEIsQ0FBQzs7O09BQUE7SUFFRCxxQ0FBZ0IsR0FBaEIsVUFBaUIsS0FBYTtRQUMxQixpRUFBaUU7UUFDakUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUlELHNDQUFpQixHQUFqQixVQUFrQixLQUFhO1FBQzNCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7T0FFRztJQUNILDJCQUFNLEdBQU4sVUFBTyxHQUFZO1FBQ2YsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMzQixHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN2QixHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7T0FFRztJQUNPLG9DQUFlLEdBQXpCLFVBQTBCLEtBQWE7UUFDbkMsSUFBTSxvQkFBb0IsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBRW5GLDZFQUE2RTtRQUM3RSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLG9CQUFvQixJQUFJLENBQUMsRUFBRTtZQUNoRCxPQUFPLENBQUMsQ0FBQztTQUNaO1FBQ0QsT0FBTyxTQUFBLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLG9CQUFvQixDQUFDLENBQUMsRUFBSSxJQUFJLENBQUMsTUFBTSxDQUFBLENBQUM7SUFDbEUsQ0FBQztJQXZEZ0IsMEJBQWUsR0FBVyxDQUFDLENBQUM7SUF3RGpELGlCQUFDO0NBMURELEFBMERDLElBQUE7QUExRHFCLGdDQUFVO0FBNERoQztJQUEwQix3QkFBVTtJQUdoQyxjQUFZLE1BQWMsRUFBRSxJQUFZLEVBQUUsS0FBYSxFQUFVLE1BQWM7UUFBL0UsWUFDSSxrQkFBTSxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxTQUM3QjtRQUZnRSxZQUFNLEdBQU4sTUFBTSxDQUFRO1FBRnRFLGlCQUFXLEdBQUcsVUFBUSxJQUFJLENBQUMsZUFBZSxFQUFJLENBQUM7O0lBSXhELENBQUM7SUFFRCxzQkFBSSx1QkFBSzthQUFULFVBQVUsS0FBYTtZQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUN4QixDQUFDOzs7T0FBQTtJQUVELHFCQUFNLEdBQU4sVUFBTyxHQUFZO1FBQW5CLGlCQU9DO1FBTkcsaUJBQU0sTUFBTSxZQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxCLGtDQUFrQztRQUNsQyxJQUFNLFNBQVMsR0FBRyxFQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFDLENBQUM7UUFDdkQsSUFBTSxlQUFlLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzdELGVBQWUsQ0FBQyxRQUFRLENBQUMsVUFBQSxLQUFLLElBQUksT0FBQSxLQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQXJDLENBQXFDLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRUQsd0JBQVMsR0FBVCxVQUFVLEtBQWE7UUFDbkIsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RDLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0QyxPQUFPLElBQUksZ0JBQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBQ0wsV0FBQztBQUFELENBekJBLEFBeUJDLENBekJ5QixVQUFVLEdBeUJuQztBQXpCWSxvQkFBSTtBQTJCakI7SUFBNEIsMEJBQVU7SUFFbEMsZ0JBQVksTUFBYyxFQUFFLElBQVksRUFBRSxLQUFhO1FBQXZELFlBQ0ksa0JBQU0sTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsU0FDN0I7UUFIUSxpQkFBVyxHQUFHLFlBQVUsTUFBTSxDQUFDLGVBQWUsRUFBSSxDQUFDOztJQUc1RCxDQUFDO0lBRUQsMEJBQVMsR0FBVCxVQUFVLEtBQWE7UUFDbkIsSUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDMUMsSUFBTSxFQUFFLEdBQUcsU0FBQSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQSxHQUFHLFNBQUEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUEsQ0FBQztRQUMzQixJQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsT0FBTyxJQUFJLGdCQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUNMLGFBQUM7QUFBRCxDQVpBLEFBWUMsQ0FaMkIsVUFBVSxHQVlyQztBQVpZLHdCQUFNOzs7Ozs7Ozs7Ozs7Ozs7O0FDMUZuQiw4QkFBZ0M7QUFDaEMsNkJBQStCO0FBQy9CLGdDQUFrQztBQUNsQyxvQ0FBK0I7QUFvQi9CO0lBSUksY0FBbUIsS0FBYSxFQUFTLFNBQXlCO1FBQXpCLDBCQUFBLEVBQUEsZ0JBQWMsR0FBRyxFQUFRO1FBQS9DLFVBQUssR0FBTCxLQUFLLENBQVE7UUFBUyxjQUFTLEdBQVQsU0FBUyxDQUFnQjtRQUgzRCxhQUFRLEdBQUcsSUFBSSxHQUFHLEVBQVcsQ0FBQztJQUdnQyxDQUFDO0lBRXRFLHlCQUFVLEdBQVYsVUFBVyxPQUFnQjtRQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQsMEJBQVcsR0FBWCxVQUFZLElBQVU7UUFDbEIsSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFO1lBQ2YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUI7SUFDTCxDQUFDO0lBQ0wsV0FBQztBQUFELENBaEJBLEFBZ0JDLElBQUE7QUFoQlksb0JBQUk7QUFrQmpCO0lBSUksZUFBWSxXQUF1QixFQUFFLEtBQWE7UUFBbEQsaUJBK0NDO1FBOUNHLElBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDL0UsSUFBTSxRQUFRLEdBQUksRUFBRSxDQUFDLFFBQVEsRUFBd0IsQ0FBQyxDQUFDLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBVCxDQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBVCxDQUFTLENBQUMsQ0FBQztRQUMxRixJQUFNLGFBQWEsR0FBRyxLQUFLLENBQUM7UUFFNUIsc0NBQXNDO1FBQ3RDLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBQSxVQUFVO1lBQzFCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN4QyxJQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUNQLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDNUU7Z0JBRUQsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7b0JBQzNCLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDNUU7Z0JBRUQsS0FBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7YUFDMUQ7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILHdCQUF3QjtRQUN4QixhQUFhLENBQUMsT0FBTyxDQUFDLFVBQUEsWUFBWTtZQUM5QixJQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLGdCQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlFLFlBQVksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBbEIsQ0FBa0IsQ0FBQyxDQUFDO1lBQ3ZELEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQzNELENBQUMsQ0FBQyxDQUFDO1FBRUgsZ0ZBQWdGO1FBQ2hGLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBQSxVQUFVO1lBQzFCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDNUMsSUFBTSxpQkFBaUIsR0FDbkIsS0FBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBRXZILElBQUksaUJBQWlCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDOUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7d0JBQ25ELGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDNUQ7aUJBQ0o7cUJBQU07b0JBQ0gsR0FBRyxDQUFDLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO2lCQUMvRDthQUNKO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUM3QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQS9CLENBQStCLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxJQUFJLGdCQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBaEMsQ0FBZ0MsQ0FBQyxDQUFDO0lBQ2xGLENBQUM7SUFFTyxvQ0FBb0IsR0FBNUIsVUFBNkIsT0FBZ0IsRUFBRSxRQUEyQixFQUFFLE1BQWMsRUFBRSxJQUFZO1FBQ3BHLGdFQUFnRTtRQUNoRSxrRkFBa0Y7UUFDbEYsK0NBQStDOztRQUhuRCxpQkFpREM7UUE1Q0csSUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDO1FBQ3RCLElBQU0saUJBQWlCLEdBQVcsRUFBRSxDQUFDO1FBRXJDLElBQU0sS0FBSyxHQUFHLElBQUksZ0JBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pELElBQU0sR0FBRyxHQUFHLElBQUksZ0JBQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRW5ELElBQU0sZ0JBQWdCLEdBQUcsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoRCxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBRSw2QkFBNkI7UUFDcEYsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUMxRCxJQUFNLHNCQUFzQixHQUFHLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRXpELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDN0IsSUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFFekYsc0RBQXNEO1lBQ3RELElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztZQUNwQixJQUFJLFdBQVcsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsRUFBRSxNQUFNLEdBQUcsSUFBSSxHQUFDLENBQUMsQ0FBQyxDQUFDO1lBRWpGLE9BQU8sV0FBVyxLQUFLLFNBQVMsRUFBRTtnQkFDOUIsUUFBUSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDN0IsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFFN0IsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDOztvQkFDMUIsS0FBYyxJQUFBLG9CQUFBLFNBQUEsV0FBVyxDQUFDLFFBQVEsQ0FBQSxDQUFBLGdCQUFBLDRCQUFFO3dCQUEvQixJQUFJLENBQUMsV0FBQTt3QkFDTixJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLEVBQUU7NEJBQ3JDLGFBQWEsR0FBRyxJQUFJLENBQUM7NEJBQ3JCLE1BQU07eUJBQ1Q7cUJBQ0o7Ozs7Ozs7OztnQkFFRCxJQUFJLGFBQWEsRUFBRTtvQkFDZixVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUNoQztnQkFFRCxXQUFXLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLEVBQUUsTUFBTSxHQUFHLElBQUksR0FBQyxDQUFDLENBQUMsQ0FBQzthQUNoRjtZQUVELFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBQyxLQUFXLEVBQUUsTUFBWTtnQkFDdEMsT0FBQSxLQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxnQkFBZ0IsQ0FBQyxHQUFHLEtBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixDQUFDO1lBQXBILENBQW9ILENBQUMsQ0FBQztZQUMxSCxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUF6QixDQUF5QixDQUFDLENBQUM7U0FDdEQ7UUFFRCxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzVCLE9BQU8saUJBQWlCLENBQUM7SUFDN0IsQ0FBQztJQUVPLGtDQUFrQixHQUExQixVQUEyQixFQUFXLEVBQUUsRUFBVyxFQUFFLFNBQWdCO1FBQWhCLDBCQUFBLEVBQUEsa0JBQWdCO1FBQ2pFLE9BQU87UUFDUCxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLFNBQVMsRUFBRTtZQUNuQyxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUVELElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsU0FBUyxFQUFFO1lBQ25DLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsS0FBSztRQUVMLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsU0FBUyxFQUFFO1lBQy9CLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxTQUFTLEVBQUU7WUFDL0IsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRU8sbUNBQW1CLEdBQTNCLFVBQTRCLElBQVUsRUFBRSxLQUFhLEVBQUUsZ0JBQXdCO1FBQzNFLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hELE9BQU8sZ0JBQWdCLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFTyxrQ0FBa0IsR0FBMUIsVUFBMkIsUUFBMkIsRUFBRSxJQUFVLEVBQUUsTUFBYztRQUM5RSwrQ0FBK0M7UUFDL0MsbUZBQW1GO1FBQ25GLElBQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDdkUsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFO1lBQzVCLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEI7YUFBTTtZQUNILElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQUEsUUFBUSxJQUFJLE9BQUEsWUFBWSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsRUFBbEMsQ0FBa0MsQ0FBQyxDQUFDO1lBQ3ZFLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQUEsT0FBTyxJQUFJLE9BQUEsWUFBWSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBaEMsQ0FBZ0MsQ0FBQyxDQUFDO1NBQ3RFO0lBQ0wsQ0FBQztJQUVPLG9DQUFvQixHQUE1QixVQUE2QixXQUF1Qjs7UUFDaEQsSUFBTSxHQUFHLEdBQWMsRUFBRSxDQUFDOztZQUMxQixLQUFnQixJQUFBLGdCQUFBLFNBQUEsV0FBVyxDQUFBLHdDQUFBLGlFQUFFO2dCQUF4QixJQUFNLENBQUMsd0JBQUE7Z0JBQ1IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNuQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ25EO2FBQ0o7Ozs7Ozs7OztRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVPLGdDQUFnQixHQUF4QixVQUF5QixFQUFVLEVBQUUsRUFBVTtRQUMzQyxPQUFPO1lBQ0gsSUFBSSxFQUFFLEVBQUU7WUFDUixFQUFFLEVBQUksRUFBRTtTQUNYLENBQUM7SUFDTixDQUFDO0lBQ0wsWUFBQztBQUFELENBaktBLEFBaUtDLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDek1ELG9DQUErQjtBQUUvQjtJQU1JOzs7T0FHRztJQUNILHFCQUFxQixlQUF1QixFQUFVLE1BQWMsRUFBVSxJQUFZO1FBQXJFLG9CQUFlLEdBQWYsZUFBZSxDQUFRO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUFVLFNBQUksR0FBSixJQUFJLENBQVE7UUFDdEYsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDcEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxlQUFlLENBQUMsS0FBSyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0RSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNuQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzVDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ3pCO1NBQ0o7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSCw0QkFBTSxHQUFOLFVBQU8sV0FBd0I7UUFBL0IsaUJBSUM7UUFIRyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEdBQUcsSUFBSSxPQUFBLEdBQUcsQ0FBQyxPQUFPLENBQUMsVUFBQSxJQUFJLElBQUksT0FBQSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQUEsTUFBTTtZQUNuRSxLQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzNCLENBQUMsQ0FBQyxFQUZrRCxDQUVsRCxDQUFDLEVBRjZCLENBRTdCLENBQUMsQ0FBQztJQUNULENBQUM7SUFFRCxpQ0FBVyxHQUFYLFVBQVksSUFBYztRQUExQixpQkFFQztRQURHLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFqQixDQUFpQixDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7T0FHRztJQUNILCtCQUFTLEdBQVQsVUFBVSxDQUFTLEVBQUUsTUFBZTtRQUNoQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDcEM7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILG1DQUFhLEdBQWIsVUFBYyxDQUFTLEVBQUUsR0FBZTtRQUNwQywwRUFBMEU7UUFDMUUsNERBQTREO1FBRnZDLG9CQUFBLEVBQUEsTUFBSSxJQUFJLENBQUMsTUFBTTtRQUlwQyxJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXZDLHVDQUF1QztRQUN2QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDMUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUMxQixJQUFNLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksZ0JBQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbEQsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFO29CQUNwRCxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUU7d0JBQy9ELE9BQU8sS0FBSyxDQUFDO3FCQUNoQjtpQkFDSjthQUNKO1NBQ0o7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDBDQUFvQixHQUFwQixVQUFxQixDQUFTLEVBQUUsT0FBaUIsRUFBRSxHQUFXOzs7WUFDMUQsS0FBcUIsSUFBQSxZQUFBLFNBQUEsT0FBTyxDQUFBLGdDQUFBLHFEQUFFO2dCQUF6QixJQUFNLE1BQU0sb0JBQUE7Z0JBQ2IsSUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFO29CQUNkLElBQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDL0MsSUFBSSxVQUFVLEdBQUcsR0FBRyxFQUFFO3dCQUNsQixPQUFPLEtBQUssQ0FBQztxQkFDaEI7aUJBQ0o7YUFDSjs7Ozs7Ozs7O1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gscUNBQWUsR0FBZixVQUFnQixDQUFTLEVBQUUsUUFBZ0I7UUFDdkMsSUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsR0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDckQsSUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QyxJQUFNLEdBQUcsR0FBYSxFQUFFLENBQUM7UUFDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDNUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzVDLElBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxnQkFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsRCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7b0JBQ3BELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxFQUFFO3dCQUNoQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUNqQixDQUFDLENBQUMsQ0FBQztpQkFDTjthQUNKO1NBQ0o7UUFFRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFTyxpQ0FBVyxHQUFuQixVQUFvQixDQUFTO1FBQ3pCLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVPLGlDQUFXLEdBQW5CLFVBQW9CLENBQVM7UUFDekIsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRU8sdUNBQWlCLEdBQXpCLFVBQTBCLEtBQWEsRUFBRSxNQUFjO1FBQ25ELE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFDOUIsS0FBSyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7O09BR0c7SUFDSyxxQ0FBZSxHQUF2QixVQUF3QixNQUFjO1FBQ2xDLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRTtZQUNqRCw2REFBNkQ7WUFDN0QsT0FBTyxnQkFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDO1NBQzlCO1FBRUQsT0FBTyxJQUFJLGdCQUFNLENBQ2IsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFDM0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDOUIsQ0FBQztJQUNOLENBQUM7SUFDTCxrQkFBQztBQUFELENBaEpBLEFBZ0pDLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsSkQsb0NBQStCO0FBRy9CO0lBQ0kseUJBQXNCLEtBQWtCO1FBQWxCLFVBQUssR0FBTCxLQUFLLENBQWE7SUFBRyxDQUFDO0lBSWxDLDJDQUFpQixHQUEzQixVQUE0QixLQUFhLEVBQUUsS0FBYztRQUNyRCxJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QyxJQUFJLEtBQUs7WUFBRSxPQUFPLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNwQyxPQUFPLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQsZ0NBQU0sR0FBTixVQUFPLEtBQWE7UUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBQ0wsc0JBQUM7QUFBRCxDQWRBLEFBY0MsSUFBQTs7QUFFRDtJQUFxQyxtQ0FBZTtJQUNoRCx5QkFBWSxLQUFrQixFQUFVLE1BQXdCO1FBQWhFLFlBQ0ksa0JBQU0sS0FBSyxDQUFDLFNBQ2Y7UUFGdUMsWUFBTSxHQUFOLE1BQU0sQ0FBa0I7O0lBRWhFLENBQUM7SUFFRCxtQ0FBUyxHQUFULFVBQVUsS0FBYSxFQUFFLEtBQWM7UUFDbkMsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2xGLENBQUM7SUFDTCxzQkFBQztBQUFELENBUkEsQUFRQyxDQVJvQyxlQUFlLEdBUW5EO0FBUlksMENBQWU7QUFVNUI7SUFBbUMsaUNBQWU7SUFDOUMsdUJBQVksS0FBa0IsRUFBVSxNQUF3QjtRQUFoRSxZQUNJLGtCQUFNLEtBQUssQ0FBQyxTQUNmO1FBRnVDLFlBQU0sR0FBTixNQUFNLENBQWtCOztJQUVoRSxDQUFDO0lBRUQsaUNBQVMsR0FBVCxVQUFVLEtBQWEsRUFBRSxLQUFjO1FBQ25DLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDaEQsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsZ0JBQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2RyxJQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxnQkFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFbEcsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3ZGLENBQUM7SUFDTCxvQkFBQztBQUFELENBWkEsQUFZQyxDQVprQyxlQUFlLEdBWWpEO0FBWlksc0NBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5QjFCLDhCQUFnQztBQUNoQyw2QkFBK0I7QUFDL0Isb0NBQStCO0FBRS9CLDJCQUE2QjtBQUU3QjtJQVFJLHVCQUFvQixLQUFhLEVBQVUsU0FBWTtRQUFaLDBCQUFBLEVBQUEsY0FBWTtRQUFuQyxVQUFLLEdBQUwsS0FBSyxDQUFRO1FBQVUsY0FBUyxHQUFULFNBQVMsQ0FBRztRQVAvQyxjQUFTLEdBQWUsRUFBRSxDQUFDO1FBQzNCLG9CQUFlLEdBQWUsRUFBRSxDQUFDO1FBQ2pDLHFCQUFnQixHQUFlLEVBQUUsQ0FBQztRQUVsQyxpQkFBWSxHQUF3QixFQUFFLENBQUM7UUFDdkMsb0JBQWUsR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFFQSxDQUFDO0lBRTNELHNCQUFJLG1DQUFRO2FBQVo7WUFDSSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNsQyxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQzthQUNoQztZQUVELElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNqQyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7YUFDL0I7WUFFRCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDMUIsQ0FBQzs7O09BQUE7SUFFRCw4QkFBTSxHQUFOLFVBQU8sT0FBVztRQUFsQixpQkFRQztRQVJNLHdCQUFBLEVBQUEsV0FBVztRQUNkLG1GQUFtRjtRQUNuRixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM3QixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDdkI7UUFFRCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsS0FBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBL0IsQ0FBK0IsQ0FBQzthQUM3RSxNQUFNLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBWixDQUFZLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQsOEJBQU0sR0FBTixVQUFPLE9BQVk7UUFBbkIsaUJBZUM7UUFmTSx3QkFBQSxFQUFBLFlBQVk7UUFDZixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM3QixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDdkI7UUFFRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQzlCLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2pDLFFBQVEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1NBQ25DO1FBRUQsSUFBSSxPQUFPLEdBQWUsRUFBRSxDQUFDO1FBQzdCLFFBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDO1lBQ2QsT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ2hFLENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxhQUFhLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sR0FBRyxHQUFHLEVBQWhELENBQWdELENBQUMsQ0FBQztJQUNsRyxDQUFDO0lBRUQsb0NBQVksR0FBWjtRQUNJLE9BQU87UUFDUCxpREFBaUQ7UUFDakQseUJBQXlCOztRQUg3QixpQkEwQkM7UUFyQkcsNkRBQTZEO1FBQzdELGdGQUFnRjtRQUNoRixtQ0FBbUM7UUFDbkMsbUZBQW1GO1FBQ25GLElBQUksQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7UUFDM0IsSUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDOztZQUVwQixLQUFpQixJQUFBLEtBQUEsU0FBQSxJQUFJLENBQUMsS0FBSyxDQUFBLGdCQUFBLDRCQUFFO2dCQUF4QixJQUFJLElBQUksV0FBQTtnQkFDVCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUM7b0JBQUUsU0FBUzs7b0JBQ3BDLEtBQXFCLElBQUEsb0JBQUEsU0FBQSxJQUFJLENBQUMsR0FBRyxDQUFBLENBQUEsZ0JBQUEsNEJBQUU7d0JBQTFCLElBQUksUUFBUSxXQUFBO3dCQUNiLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQzt3QkFDckQsSUFBSSxPQUFPLEtBQUssSUFBSSxFQUFFOzRCQUNsQixJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxDQUFDLENBQUM7NEJBQ3ZDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQWYsQ0FBZSxDQUFDLENBQUMsQ0FBQzt5QkFDcEQ7cUJBQ0o7Ozs7Ozs7OzthQUNKOzs7Ozs7Ozs7UUFFRCxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztRQUMxQixJQUFJLENBQUMsWUFBWSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFwQixDQUFvQixDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVPLGdEQUF3QixHQUFoQyxVQUFpQyxPQUFlO1FBQzVDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3JDLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQixJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRS9DLElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3hDLElBQUksS0FBSyxJQUFJLENBQUMsRUFBRTtnQkFDWixPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDaEM7aUJBQU07Z0JBQ0gsR0FBRyxDQUFDLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO2FBQ2hEO1NBQ0o7SUFDTCxDQUFDO0lBRU8scUNBQWEsR0FBckIsVUFBc0IsT0FBZSxFQUFFLEtBQU87UUFBUCxzQkFBQSxFQUFBLFNBQU87UUFDMUMsSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLFNBQVM7WUFBRSxPQUFPLElBQUksQ0FBQztRQUN6QyxxRUFBcUU7UUFDckUsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakcsSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFO1lBQ25CLE9BQU8sSUFBSSxDQUFDLENBQUUsa0RBQWtEO1NBQ25FO1FBRUQsSUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMvQyxJQUFJLFlBQVksSUFBSSxDQUFDLEVBQUU7WUFDbkIsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ3RDO2FBQU07WUFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUMvQztJQUNMLENBQUM7SUFFTyx3Q0FBZ0IsR0FBeEIsVUFBeUIsUUFBYyxFQUFFLE1BQVk7O1FBQ2pELDBDQUEwQztRQUMxQyxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUM7WUFBRSxPQUFPLElBQUksQ0FBQztRQUV6QyxJQUFNLHlCQUF5QixHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzRSxJQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUMsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU1RixJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUM7UUFDekIsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7O1lBRWhDLEtBQXFCLElBQUEsS0FBQSxTQUFBLE1BQU0sQ0FBQyxHQUFHLENBQUEsZ0JBQUEsNEJBQUU7Z0JBQTVCLElBQUksUUFBUSxXQUFBO2dCQUNiLElBQUksUUFBUSxLQUFLLFFBQVEsRUFBRTtvQkFDdkIsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUM1RCxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLGNBQWMsQ0FBQztvQkFDeEUsSUFBSSxTQUFTLEdBQUcsQ0FBQyxFQUFFO3dCQUNmLFNBQVMsSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztxQkFDNUI7b0JBRUQsSUFBSSxTQUFTLEdBQUcsYUFBYSxFQUFFO3dCQUMzQixhQUFhLEdBQUcsU0FBUyxDQUFDO3dCQUMxQixhQUFhLEdBQUcsUUFBUSxDQUFDO3FCQUM1QjtpQkFDSjthQUNKOzs7Ozs7Ozs7UUFFRCxPQUFPLGFBQWEsQ0FBQztJQUN6QixDQUFDO0lBRU8scUNBQWEsR0FBckIsVUFBc0IsT0FBaUIsRUFBRSxNQUFjO1FBQ25ELGdCQUFnQjtRQUNoQixJQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3BCLE9BQU87U0FDVjtRQUVELElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN4QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNyQyxZQUFZLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2hDO1FBRUQsWUFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWhELE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBcEUsQ0FBb0UsQ0FBQyxDQUFDO0lBQ2xHLENBQUM7SUFFTyxvQ0FBWSxHQUFwQixVQUFxQixPQUFpQjtRQUNsQyxJQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBbEMsQ0FBa0MsQ0FBQyxDQUFDO1FBQ3RFLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0IsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ25HLENBQUM7SUFFTyxxQ0FBYSxHQUFyQixVQUFzQixPQUEwQixFQUFFLE9BQWU7UUFDN0QsSUFBSTtZQUNBLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUM5RCxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFO2dCQUNyQixPQUFPLEVBQUUsQ0FBQzthQUNiO1lBQ0QsT0FBTyxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsSUFBSSxnQkFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFwQixDQUFvQixDQUFDLENBQUM7U0FDbEU7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNaLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDakIsT0FBTyxFQUFFLENBQUM7U0FDYjtJQUNMLENBQUM7SUFFTyx3Q0FBZ0IsR0FBeEIsVUFBeUIsQ0FBVyxFQUFFLE9BQWU7UUFBckQsaUJBMENDO1FBekNHLElBQUksYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEVBQUU7WUFDNUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2Q7UUFFRCxJQUFJLE9BQU8sR0FBZSxFQUFFLENBQUMsQ0FBRSxvQkFBb0I7UUFFbkQsSUFBSSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7UUFDMUIsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFL0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDL0IsSUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDbEUsSUFBSSxVQUFVLEdBQUcsaUJBQWlCLEVBQUU7Z0JBQ2hDLGlCQUFpQixHQUFHLFVBQVUsQ0FBQztnQkFDL0IsV0FBVyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzthQUM3QztTQUNKO1FBRUQsc0JBQXNCO1FBQ3RCLElBQU0sU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUU5QyxJQUFNLFlBQVksR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMxRixJQUFNLGdCQUFnQixHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEUsSUFBTSxVQUFVLEdBQUcsQ0FBQyxJQUFJLGdCQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3ZFLFNBQVMsRUFBRTthQUNYLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV6QixJQUFNLE1BQU0sR0FBRyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUUsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBRTVGLG9CQUFvQjtRQUNwQixJQUFJO1lBQ0EsSUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZILGlCQUFpQjtZQUNqQixNQUFNLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQztnQkFDWixPQUFPLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDckcsQ0FBQyxDQUFDLENBQUM7WUFFSCxPQUFPLE9BQU8sQ0FBQztTQUNsQjtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ1osR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNqQixPQUFPLEVBQUUsQ0FBQTtTQUNaO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNXLDRCQUFjLEdBQTVCLFVBQTZCLE1BQWMsRUFBRSxlQUF1QixFQUFFLEVBQVUsRUFBRSxFQUFVO1FBQTVGLGlCQWFDO1FBWkcsSUFBTSxTQUFTLEdBQUc7WUFDZCxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ2xCLE1BQU0sQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUN0QyxNQUFNLENBQUMsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxlQUFlLENBQUMsQ0FBQztZQUMxRCxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUM7U0FDekMsQ0FBQztRQUNGLElBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEVBQTdCLENBQTZCLENBQUMsQ0FBQztRQUN0RyxJQUFNLE9BQU8sR0FBRyxhQUFhLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pELElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksYUFBYSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEVBQUU7WUFDekUsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDcEI7UUFDRCxPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRWMsbUNBQXFCLEdBQXBDLFVBQXFDLENBQVc7UUFDNUMsSUFBTSxJQUFJLEdBQWEsRUFBRSxDQUFDO1FBQzFCLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDO1lBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFYyxtQ0FBcUIsR0FBcEMsVUFBcUMsQ0FBVztRQUM1QyxJQUFNLElBQUksR0FBRyxFQUFFLENBQUM7UUFDaEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxnQkFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzdDO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELGlEQUFpRDtJQUNqRCxtREFBbUQ7SUFDbkQscURBQXFEO0lBQ3JELDZEQUE2RDtJQUM3RCxtQkFBbUI7SUFDbkIsSUFBSTtJQUVXLDZCQUFlLEdBQTlCLFVBQStCLFFBQWtCO1FBQzdDLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztRQUVkLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hDLElBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekIsSUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVELElBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1RCxJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXpCLEtBQUssSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDN0IsS0FBSyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztTQUM5QjtRQUVELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBQ0wsb0JBQUM7QUFBRCxDQWpSQSxBQWlSQyxJQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZSRCw4QkFBZ0M7QUFDaEMsc0NBQXdDO0FBQ3hDLG9DQUErQjtBQUMvQiwrQ0FBeUM7QUF5QnpDO0lBd0JJOztPQUVHO0lBQ0gsNkJBQW9CLFVBQTJCLEVBQzNCLE1BQWMsRUFDZCxlQUF1QixFQUN2QixNQUF3QjtRQUh4QixlQUFVLEdBQVYsVUFBVSxDQUFpQjtRQUMzQixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2Qsb0JBQWUsR0FBZixlQUFlLENBQVE7UUFDdkIsV0FBTSxHQUFOLE1BQU0sQ0FBa0I7UUE3QjNCLHNCQUFpQixHQUFHLEtBQUssQ0FBQztRQUMxQixjQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUUsbUJBQW1CO1FBWTVDLHdCQUFtQixHQUFhLEVBQUUsQ0FBQztRQUNuQyx3QkFBbUIsR0FBYSxFQUFFLENBQUM7UUFFbkMsb0JBQWUsR0FBWSxJQUFJLENBQUM7UUFDaEMsd0JBQW1CLEdBQVksSUFBSSxDQUFDO1FBRXJDLHFCQUFnQixHQUFlLEVBQUUsQ0FBQztRQUNsQyxxQkFBZ0IsR0FBZSxFQUFFLENBQUM7UUFDbEMseUJBQW9CLEdBQWUsRUFBRSxDQUFDLENBQUUsdUJBQXVCO1FBU2xFLElBQUksTUFBTSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFO1lBQzVCLEdBQUcsQ0FBQyxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQztTQUM1RDtRQUVELHFCQUFxQjtRQUNyQixNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFbkQsbUNBQW1DO1FBQ25DLElBQUksQ0FBQyxjQUFjLEdBQUcsU0FBQSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEVBQUksQ0FBQyxDQUFBLENBQUM7UUFDcEQsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JFLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUVwRCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksc0JBQVcsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pGLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxzQkFBVyxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFakYsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCw4Q0FBZ0IsR0FBaEI7UUFDSSxJQUFJLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxDQUFDO1FBQy9CLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7UUFDM0IsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxxREFBdUIsR0FBdkI7O1FBQUEsaUJBNkJDO2dDQTNCWSxLQUFLOztvQ0FDRCxVQUFVO2dCQUNmLGlCQUFpQjtnQkFDakIsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7O2lCQUU1RDtnQkFFRCxJQUFNLFFBQVEsR0FBRyxPQUFLLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUE7Z0JBQ2hGLElBQUksUUFBUSxLQUFLLElBQUksRUFBRTtvQkFDbkIsT0FBSyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxPQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDO3dCQUNwRSxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN0QixLQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDbEMsQ0FBQyxDQUFDLENBQUM7aUJBQ047Z0JBRUQsSUFBTSxNQUFNLEdBQUcsT0FBSyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDdkgsSUFBSSxNQUFNLEtBQUssSUFBSSxFQUFFO29CQUNqQixPQUFLLGFBQWEsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsT0FBSyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQzt3QkFDdEYsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDbkIsS0FBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ2xDLENBQUMsQ0FBQyxDQUFDO2lCQUNOOzs7Z0JBcEJMLEtBQXVCLElBQUEsb0JBQUEsU0FBQSxPQUFLLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQSxDQUFBLGdCQUFBO29CQUF6QyxJQUFJLFVBQVUsV0FBQTs0QkFBVixVQUFVO2lCQXFCbEI7Ozs7Ozs7Ozs7OztZQXZCTCwyQkFBMkI7WUFDM0IsS0FBa0IsSUFBQSxLQUFBLFNBQUEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUEsZ0JBQUE7Z0JBQTFCLElBQUksS0FBSyxXQUFBO3dCQUFMLEtBQUs7YUF1QmI7Ozs7Ozs7OztRQUVELCtCQUErQjtRQUMvQixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLEVBQTFCLENBQTBCLENBQUMsQ0FBQztJQUN6RixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsMkNBQWEsR0FBYixVQUFjLEVBQVUsRUFBRSxFQUFVLEVBQUUsS0FBYTtRQUMvQyxJQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzVCLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBQ3RDLElBQUksT0FBTyxLQUFLLENBQUM7WUFBRSxPQUFPLEVBQUUsQ0FBQztRQUU3QixJQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXRDLElBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUNmLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNWLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUMxRSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLE9BQU8sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMzQixJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxLQUFLLEVBQUUsRUFBRyw0QkFBNEI7Z0JBQ3pGLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDbEI7aUJBQU07Z0JBQ0gsT0FBTyxHQUFHLENBQUM7YUFDZDtZQUNELElBQUksR0FBRyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDekU7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFHRDs7O09BR0c7SUFDSCw4Q0FBZ0IsR0FBaEIsVUFBaUIsS0FBYSxFQUFFLGFBQXFCLEVBQUUsVUFBb0I7O1FBQ3ZFLHVDQUF1QztRQUN2QyxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDL0UsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUMvRSxPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDO2FBQzdFLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQzNFLElBQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFbkQsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLElBQUksZUFBZSxHQUFHLFFBQVEsQ0FBQzs7WUFFL0IsS0FBbUIsSUFBQSxpQkFBQSxTQUFBLFlBQVksQ0FBQSwwQ0FBQSxvRUFBRTtnQkFBNUIsSUFBSSxNQUFNLHlCQUFBO2dCQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7b0JBQ3hGLElBQU0sZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFFbkQsb0RBQW9EO29CQUNwRCxJQUFNLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDekQsSUFBSSxnQkFBZ0IsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUU7d0JBQzVDLGFBQWEsR0FBRyxNQUFNLENBQUM7d0JBQ3ZCLE1BQU07cUJBQ1Q7b0JBQ0QsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO29CQUVoRixrQkFBa0I7b0JBQ2xCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxJQUFJLGdCQUFnQixHQUFHLGVBQWUsRUFBRTt3QkFDNUUsZUFBZSxHQUFHLGdCQUFnQixDQUFDO3dCQUNuQyxhQUFhLEdBQUcsTUFBTSxDQUFDO3FCQUMxQjtpQkFDSjthQUNKOzs7Ozs7Ozs7UUFFRCxrRUFBa0U7UUFDbEUsc0RBQXNEO1FBQ3RELDBEQUEwRDtRQUMxRCx5REFBeUQ7UUFDekQsSUFBSSxhQUFhLEtBQUssSUFBSSxFQUFFO1lBQ3hCLGFBQWEsR0FBRyxhQUFhLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3JHO1FBRUQsT0FBTyxhQUFhLENBQUM7SUFDekIsQ0FBQztJQUdEOztPQUVHO0lBQ0gsb0RBQXNCLEdBQXRCLFVBQXVCLENBQXNCO1FBQ3pDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVELHNCQUFJLCtDQUFjO2FBQWxCO1lBQ0ksVUFBVTtZQUNWLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUMvRCxDQUFDOzs7T0FBQTtJQUVELG9DQUFNLEdBQU47UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN2QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUM7WUFDckQsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsRUFBRTtnQkFDbEQsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7YUFDL0I7U0FDSjtJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILHlEQUEyQixHQUEzQjtRQUNJLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDO1FBQzdCLGtDQUFrQztJQUN0QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxrREFBb0IsR0FBcEI7UUFDSSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDakIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDakMsS0FBSyxHQUFHLENBQUMsS0FBSyxDQUFDO1NBQ2xCO0lBQ0wsQ0FBQztJQUVELG1EQUFxQixHQUFyQjtRQUNJLElBQUksVUFBVSxDQUFDO1FBQ2YsSUFBSSxJQUFJLENBQUM7UUFDVCxJQUFJLEtBQUssQ0FBQztRQUNWLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDMUIsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUM7WUFDNUIsSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDM0IsVUFBVSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDbkQsVUFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUN4QyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqRixVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FDekQsVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUV4SCxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNoRyxNQUFNO2FBQ1Q7U0FDSjtRQUVELGdDQUFnQztRQUNoQyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVyQyw4QkFBOEI7UUFDOUIsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXRDLE9BQU8sVUFBVSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7T0FFRztJQUNLLGtEQUFvQixHQUE1QixVQUE2QixDQUFXO1FBQ3BDLElBQUksR0FBRyxHQUFhLEVBQUUsQ0FBQztRQUN2QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbkMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDZCQUE2QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0RTtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVPLDJEQUE2QixHQUFyQyxVQUFzQyxFQUFVLEVBQUUsRUFBVTtRQUN4RCxJQUFJLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRTtZQUNqRCxPQUFPLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ25CO1FBQ0QsSUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM3QixJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN0RCxPQUFPLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNuSCxDQUFDO0lBRUQsNkNBQWUsR0FBZixVQUFnQixDQUFTO1FBQ3JCLElBQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzVDLE9BQU8sUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3JDLFFBQVEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztJQUNyRixDQUFDO0lBRU8sZ0RBQWtCLEdBQTFCLFVBQTJCLFVBQW9CO1FBQzNDLE9BQU8sUUFBUSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsR0FBRyxDQUFDLFVBQUEsS0FBSyxJQUFJLE9BQUEsSUFBSSxnQkFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUE1QixDQUE0QixDQUFDLENBQUM7SUFDMUcsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyw4Q0FBZ0IsR0FBeEIsVUFBeUIsS0FBYztRQUNuQyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pDLElBQUksSUFBSSxLQUFLLElBQUksRUFBRTtZQUNmLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBQ0QsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN6RCxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFFekMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUVwRSxzQkFBc0I7WUFDdEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDMUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDaEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3ZFO1NBQ0o7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRU8sNkNBQWUsR0FBdkIsVUFBd0IsQ0FBVztRQUMvQixPQUFPLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFTyx5Q0FBVyxHQUFuQjtRQUNJLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQy9DLEtBQUssSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDeEM7SUFDTCxDQUFDO0lBRU8seUNBQVcsR0FBbkI7UUFDSSw2QkFBNkI7UUFDN0IsT0FBTyxJQUFJLGdCQUFNLENBQ2IsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUN0QyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7YUFDdEMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQ7O09BRUc7SUFDSyxxQ0FBTyxHQUFmLFVBQWdCLEtBQWM7UUFDMUIsd0JBQXdCO1FBQ3hCLElBQUksSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNqRSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDMUMsSUFBTSxNQUFJLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDOUMsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxNQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDckQsT0FBTyxNQUFJLENBQUM7aUJBQ2Y7YUFDSjtTQUNKO1FBRUQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNWLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN6RCxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRTtnQkFDNUIsT0FBTyxJQUFJLENBQUM7YUFDZjtZQUNELElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDMUIsQ0FBQyxFQUFFLENBQUM7U0FDUDtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTywyQ0FBYSxHQUFyQixVQUFzQixLQUFjLEVBQUUsS0FBYSxFQUFFLEdBQVc7UUFDNUQsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDdkYsQ0FBQztJQUVELHNDQUFzQztJQUM5Qiw0Q0FBYyxHQUF0QixVQUF1QixLQUFjO1FBQ2pDLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztJQUN2RSxDQUFDO0lBRU8seUNBQVcsR0FBbkIsVUFBb0IsS0FBYztRQUM5QixPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7SUFDakUsQ0FBQztJQUVPLGtDQUFJLEdBQVosVUFBYSxLQUFjO1FBQ3ZCLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ25ELENBQUM7SUFFTywyQ0FBYSxHQUFyQixVQUFzQixDQUFTO1FBQzNCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztlQUNyQixDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztlQUNwQixDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztlQUM1QyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUNsRCxDQUFDO0lBQ04sQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLHVEQUF5QixHQUFqQyxVQUFrQyxVQUFrQixFQUFFLGtCQUE0QixFQUFFLG1CQUE2QjtRQUM3Ryx5QkFBeUI7UUFDekIsSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFO1lBQ3RELGlCQUFpQjtZQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsa0JBQWtCLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtnQkFDakcsSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFO29CQUMzRSxPQUFPLElBQUksQ0FBQztpQkFDZjthQUNKO1lBRUQsa0JBQWtCO1lBQ2xCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0JBQ3ZFLElBQUksVUFBVSxDQUFDLGlCQUFpQixDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRTtvQkFDNUUsT0FBTyxJQUFJLENBQUM7aUJBQ2Y7YUFDSjtTQUNKO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVEOztPQUVHO0lBQ0ssOENBQWdCLEdBQXhCLFVBQXlCLElBQVksRUFBRSxXQUFtQixFQUFFLEtBQWEsRUFBRSxTQUFpQjtRQUN4RixJQUFJLFdBQVcsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2hDLGdCQUFnQjtZQUNoQixJQUFNLG1CQUFtQixHQUFHLElBQUksZ0JBQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RFLElBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3BFLElBQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0QsT0FBTyxNQUFNLEtBQUssV0FBVyxDQUFDO1NBQ2pDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7T0FHRztJQUNLLHVEQUF5QixHQUFqQyxVQUFrQyxNQUE2QixFQUFFLEtBQWM7UUFDM0UsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2QsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzdDLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFFN0UsMkJBQTJCO1lBQzNCLElBQUksYUFBYSxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksRUFBRTtnQkFDakMsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Z0JBQ3JCLE9BQU87YUFDVjtZQUVELDRDQUE0QztZQUM1QyxJQUFJLGFBQWEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNqRCxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7YUFDMUI7WUFFRCxJQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUVsRSw0QkFBNEI7WUFDNUIsMEZBQTBGO1lBQzFGLDRCQUE0QjtZQUM1QixtREFBbUQ7WUFDbkQsSUFBSTtZQUVKLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUM7bUJBQzFCLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQzttQkFDekQsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsV0FBVyxFQUFFLFNBQVMsRUFBRSxhQUFhLENBQUMsRUFBRTtnQkFDdEYsTUFBTSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7Z0JBQ2pDLE1BQU0sQ0FBQyxpQkFBaUIsR0FBRyxhQUFhLENBQUM7YUFDNUM7aUJBQU07Z0JBQ0gsZ0JBQWdCO2dCQUNoQixNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDbEMsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7YUFDeEI7U0FDSjtJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSyxpREFBbUIsR0FBM0IsVUFBNEIsSUFBWSxFQUFFLEtBQWM7UUFDcEQsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLENBQUUsOERBQThEO1FBRTFGLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUVqRCxJQUFNLGFBQWEsR0FBMEI7WUFDekMsSUFBSSxFQUFFLElBQUk7WUFDVixXQUFXLEVBQUUsQ0FBQztZQUNkLFVBQVUsRUFBRSxDQUFDLElBQUksQ0FBQztZQUNsQixpQkFBaUIsRUFBRSxDQUFDO1lBQ3BCLGFBQWEsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNsQyxLQUFLLEVBQUUsSUFBSTtTQUNkLENBQUE7UUFFRCxhQUFhLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRXRFLElBQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNoQyxJQUFNLGNBQWMsR0FBMEI7WUFDMUMsSUFBSSxFQUFFLElBQUk7WUFDVixXQUFXLEVBQUUsSUFBSTtZQUNqQixVQUFVLEVBQUUsRUFBRTtZQUNkLGlCQUFpQixFQUFFLElBQUk7WUFDdkIsYUFBYSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1lBQ3JDLEtBQUssRUFBRSxJQUFJO1NBQ2QsQ0FBQTtRQUVELGNBQWMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFeEUsT0FBTyxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN4RixJQUFJLENBQUMseUJBQXlCLENBQUMsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3JELElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxjQUFjLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFFdEQsa0JBQWtCO1lBQ2xCLElBQU0sdUJBQXVCLEdBQUcsYUFBYSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFNUcsSUFBSSxDQUFDLGFBQWEsSUFBSSx1QkFBdUIsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRTtnQkFDdkUsYUFBYSxHQUFHLElBQUksQ0FBQzthQUN4QjtZQUVELElBQUksYUFBYSxJQUFJLHVCQUF1QixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFO2dCQUN2RSxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQzNELGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQztnQkFDNUQsY0FBYyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUM3RCxNQUFNO2FBQ1Q7WUFFRCxLQUFLLEVBQUUsQ0FBQztTQUNYO1FBRUQsT0FBTyxjQUFjLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDaEYsQ0FBQztJQUNMLDBCQUFDO0FBQUQsQ0ExZkEsQUEwZkMsSUFBQTs7Ozs7O0FDdGhCRCxvQ0FBK0I7QUFFL0I7SUFJSSxnQkFBb0IsQ0FBUyxFQUFVLE1BQWdCO1FBQW5DLE1BQUMsR0FBRCxDQUFDLENBQVE7UUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFVO1FBQ25ELDJCQUEyQjtRQUMzQixTQUFTO1FBQ1QsWUFBWTtRQUNaLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ3hDLENBQUM7SUFFRCxzQkFBSSx5QkFBSzthQUFUO1lBQ0ksSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNmLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO2dCQUNwQyxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQzthQUN6QjtZQUVELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN2QixDQUFDOzs7T0FBQTtJQUVELG9CQUFHLEdBQUgsVUFBSSxNQUFjO1FBQWxCLGlCQUtDO1FBSkcsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDLElBQUssT0FBQSxDQUFDLEdBQUcsS0FBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQXhDLENBQXdDLENBQUMsQ0FBQztRQUNsRixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3JCLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxzQkFBSyxHQUFMLFVBQU0sQ0FBUztRQUNYLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDckIsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELFVBQVU7SUFDVix1QkFBTSxHQUFOLFVBQU8sS0FBYTtRQUNoQixJQUFJLEtBQUssS0FBSyxDQUFDLEVBQUU7WUFDYixPQUFPLElBQUksQ0FBQztTQUNmO1FBQ0QsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNwQixRQUFRLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQztTQUN2QjtRQUVELElBQUksUUFBUSxJQUFJLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDckIsUUFBUSxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDdkI7UUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCx5QkFBUSxHQUFSO1FBQ0ksa0JBQWtCO1FBQ2xCLElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDZCxPQUFPLGdCQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7U0FDOUI7UUFDRCxPQUFPLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRCx5QkFBUSxHQUFSO1FBQ0ksa0JBQWtCO1FBQ2xCLElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDZCxPQUFPLGdCQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7U0FDOUI7UUFDRCxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sSUFBSSxnQkFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFTywrQkFBYyxHQUF0QjtRQUNJLElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDZCxPQUFPLENBQUMsQ0FBQztTQUNaO1FBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUNMLGFBQUM7QUFBRCxDQTdFQSxBQTZFQyxJQUFBOzs7Ozs7QUM5RUQsb0NBQW9DO0FBQ3BDLDRDQUE4QztBQUM5QyxtQ0FBOEI7QUFFOUIsNkNBQXVEO0FBVXZEO0lBTUkscUJBQW1CLFdBQXdCO1FBQXhCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBTG5DLGdCQUFXLEdBQWlCLEVBQUUsQ0FBQztRQUMvQixVQUFLLEdBQWUsRUFBRSxDQUFDO1FBQ3ZCLFFBQUcsR0FBYSxFQUFFLENBQUM7UUFJdkIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUFFRCw2QkFBTyxHQUFQLFVBQVEsTUFBYyxFQUFFLElBQVksRUFBRSxLQUFhLEVBQUUsS0FBYTtRQUM5RCxJQUFNLElBQUksR0FBRyxJQUFJLGtCQUFJLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQsK0JBQVMsR0FBVCxVQUFVLE1BQWMsRUFBRSxJQUFZLEVBQUUsS0FBYTtRQUNqRCxJQUFNLE1BQU0sR0FBRyxJQUFJLG9CQUFNLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFUyw4QkFBUSxHQUFsQixVQUFtQixLQUFpQjtRQUNoQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRVMsaUNBQVcsR0FBckIsVUFBc0IsS0FBaUI7UUFDbkMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDWixJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDckM7SUFDTCxDQUFDO0lBRUQsMkJBQUssR0FBTDtRQUNJLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ2xCLENBQUM7SUFFRCxxQ0FBZSxHQUFmO1FBQ0ksT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLEtBQUssQ0FBQyxNQUFNLEVBQVosQ0FBWSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELDhCQUFRLEdBQVIsVUFBUyxDQUFhO1FBQ2xCLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRCw0QkFBTSxHQUFOLFVBQU8sQ0FBVztRQUNkLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxpQ0FBVyxHQUFYLFVBQVksS0FBYTtRQUF6QixpQkF5QkM7UUF4QkcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckIsbUJBQW1CO1lBQ25CLE9BQU8sSUFBSSxnQkFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQy9CO1FBRUQsMEJBQTBCO1FBQzFCLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQy9CLE9BQU8sSUFBSSxnQkFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2hDO1FBRUQsSUFBTSxTQUFTLEdBQUcsSUFBSSxnQkFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLFVBQUEsS0FBSyxJQUFJLE9BQUEsU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBN0MsQ0FBNkMsQ0FBQyxDQUFDO1FBRWpGLHVEQUF1RDtRQUN2RCxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsS0FBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQTVCLENBQTRCLENBQUMsRUFBRTtZQUNwRCw0Q0FBNEM7WUFDNUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztTQUNySDtRQUVELElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUU7WUFDOUIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1NBQ3pIO1FBRUQsT0FBTyxTQUFTLENBQUM7SUFDckIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsd0NBQWtCLEdBQWxCLFVBQW1CLEtBQWEsRUFBRSxTQUFpQixFQUFFLFVBQWtCO1FBQ25FLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsR0FBRyxVQUFVLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUM7SUFDckcsQ0FBQztJQUVELDRCQUFNLEdBQU4sVUFBTyxLQUFhO1FBQ2hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELG1DQUFhLEdBQWIsVUFBYyxLQUFhLEVBQUUsT0FBaUI7UUFDMUMsaUNBQWlDO1FBQ2pDLHlFQUF5RTtRQUV6RSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3RCLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ25CLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUU7WUFDakUsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6QyxJQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXpDLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzttQkFDM0MsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUMvRCxJQUFJLFNBQVM7Z0JBQUUsTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDO1NBQ25DO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUFBLENBQUM7SUFDTixrQkFBQztBQUFELENBM0dBLEFBMkdDLElBQUE7Ozs7OztBQ3ZIRDtJQUtJLHVCQUFZLE1BQXlCLEVBQVUsTUFBUSxFQUFFLGNBQW1CO1FBQTVFLGlCQWNDO1FBZDhDLHVCQUFBLEVBQUEsVUFBUTtRQUFFLCtCQUFBLEVBQUEscUJBQW1CO1FBQTdCLFdBQU0sR0FBTixNQUFNLENBQUU7UUFDbkQsSUFBSSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFFcEIsSUFBSSxjQUFjLEVBQUU7WUFDaEIsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRTtnQkFDOUIsS0FBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO2dCQUNyQixLQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDeEIsQ0FBQyxDQUFDLENBQUM7U0FDTjtRQUVELElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxxQ0FBYSxHQUFiO1FBQ0ksSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDOUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDcEQsQ0FBQztJQUVELHNCQUFJLGdDQUFLO2FBQVQ7WUFDSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDdkIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxpQ0FBTTthQUFWO1lBQ0ksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3hCLENBQUM7OztPQUFBO0lBRUQsc0JBQUksc0NBQVc7YUFBZjtZQUNJLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN2QixDQUFDO2FBRUQsVUFBZ0IsQ0FBUztZQUNyQixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztZQUNoQixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDckIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3hCLENBQUM7OztPQU5BO0lBUUQsb0NBQVksR0FBWixVQUFhLE1BQWM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDO0lBQ2hDLENBQUM7SUFFRCxtQ0FBVyxHQUFYO1FBQ0ksSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRCxxQ0FBYSxHQUFiLFVBQWMsQ0FBUyxFQUFFLENBQVMsRUFBRSxLQUFhLEVBQUUsTUFBYztRQUM3RCxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ25CLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ2pCLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ2pCLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ3JCLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ3pCO1FBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELG1DQUFXLEdBQVgsVUFBWSxPQUFpQjtRQUE3QixpQkFtQkM7UUFsQkcsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN0QixPQUFPO1NBQ1Y7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ25CLE9BQU8sR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLGNBQWMsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLEVBQXJDLENBQXFDLENBQUMsQ0FBQztTQUNyRTtRQUVELElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFNUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDckMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDL0M7UUFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU1QyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2hCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVELGtDQUFVLEdBQVYsVUFBVyxNQUFjLEVBQUUsTUFBYztRQUNyQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFFRCxvQ0FBWSxHQUFaLFVBQWEsS0FBYTtRQUN0QixJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ25CLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ3hCO1FBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0lBQy9CLENBQUM7SUFFRCxzQ0FBYyxHQUFkLFVBQWUsTUFBYztRQUN6QixJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQUVELG9DQUFZLEdBQVosVUFBYSxJQUFjO1FBQTNCLGlCQWlCQztRQWhCRyxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2pCLE9BQU87U0FDVjtRQUVELElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbkIsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsRUFBckMsQ0FBcUMsQ0FBQyxDQUFDO1NBQy9EO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV0QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNsQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN6QztRQUVELElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVTLG9DQUFZLEdBQXRCO1FBQ0ksSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDcEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDMUMsQ0FBQztJQUNMLG9CQUFDO0FBQUQsQ0F6SEEsQUF5SEMsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEhELG1EQUFzRDtBQUV0RCx5REFBbUQ7QUFDbkQsdUNBQWlDO0FBR2pDO0lBQTBDLGdDQUFPO0lBSzdDLHNCQUFZLE1BQXdCLEVBQ3hCLFVBQTJCLEVBQzNCLFNBQWtCLEVBQ2xCLGlCQUE2QixFQUM3QixVQUFrQixFQUNsQixNQUFrQixFQUNWLFdBQXdCO1FBTjVDLFlBT0ksa0JBQU0sTUFBTSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxTQUU5RTtRQUhtQixpQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQVZwQyxpQkFBVyxHQUFhLEVBQUUsQ0FBQztRQUMzQixnQkFBVSxHQUFhLEVBQUUsQ0FBQztRQUMzQixXQUFLLEdBQVksSUFBSSxDQUFDOztJQVc3QixDQUFDO0lBRUQsaUNBQVUsR0FBVjtRQUNJLElBQU0sT0FBTyxHQUFHO1lBQ1osUUFBUSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztTQUMxQyxDQUFDO1FBRUYsSUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNkLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRWhDLElBQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEQsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDaEMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDdEQsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLGtCQUFrQixDQUFDLENBQUM7UUFDdkQsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFFbkQsSUFBTSxlQUFlLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxlQUFlLENBQUMsQ0FBQztRQUN4RCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsc0JBQUksb0NBQVU7YUFBZDtZQUNJLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUM1QixDQUFDOzs7T0FBQTtJQUVELG9DQUFhLEdBQWI7UUFDSSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUUzQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBQzlELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxxQkFBbUIsQ0FDdEMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUM3QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7UUFFOUQsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1osSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1NBQ3ZDO1FBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFDM0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFFckMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2QsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFDaEMsQ0FBQztJQUVELG9DQUFhLEdBQWIsVUFBYyxNQUFxQjtRQUFuQyxpQkFFQztRQURHLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUE5QyxDQUE4QyxDQUFDLENBQUMsQ0FBQztJQUNsRyxDQUFDO0lBRUQsOEJBQU8sR0FBUCxVQUFRLE1BQXFCO1FBQTdCLGlCQUVDO1FBREcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLEtBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQTlDLENBQThDLENBQUMsQ0FBQyxDQUFDO0lBQ2xHLENBQUM7SUFFRDs7T0FFRztJQUNLLG9DQUFhLEdBQXJCLFVBQXNCLFFBQWtCO1FBQ3BDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7UUFDOUQsSUFBTSxVQUFVLEdBQUcsd0JBQWEsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxFQUMvRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBRTlELDBDQUEwQztRQUMxQyxJQUFJLFlBQVksR0FBRyxDQUFDLENBQUM7UUFDckIsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hDLElBQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUM7WUFDekMsSUFBTSxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzVELElBQUksQ0FBQyxHQUFHLGFBQWEsRUFBRTtnQkFDbkIsYUFBYSxHQUFHLENBQUMsQ0FBQztnQkFDbEIsWUFBWSxHQUFHLENBQUMsQ0FBQzthQUNwQjtTQUNKO1FBRUQsSUFBTSxlQUFlLEdBQUcsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVKLElBQUksZUFBZSxFQUFFO1lBQ2pCLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUN0QjtRQUVELFVBQVUsQ0FBQyxNQUFNLE9BQWpCLFVBQVUsWUFBUSxZQUFZLEVBQUUsQ0FBQyxHQUFLLFFBQVEsR0FBRTtRQUNoRCxPQUFPLFVBQVUsQ0FBQztJQUN0QixDQUFDO0lBRVMsMkNBQW9CLEdBQTlCLFVBQStCLE1BQXdCLEVBQUUsTUFBZTtRQUNwRSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMzQixNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUM1QixNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3JDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ2hDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQzVCLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ2xDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFTCxtQkFBQztBQUFELENBOUdBLEFBOEdDLENBOUd5QyxrQkFBTyxHQThHaEQ7Ozs7OztBQ3pIRCxvQ0FBK0I7QUFHL0I7OztHQUdHO0FBQ0g7SUFrQkk7UUFBQSxpQkFlQztRQTlCZ0IsZUFBVSxHQUFHLElBQUksQ0FBQztRQUVuQywyQ0FBMkM7UUFDbkMsWUFBTyxHQUFXLGdCQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFOUMsZ0NBQWdDO1FBQ3hCLHNCQUFpQixHQUFHLGdCQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFaEQseUNBQXlDO1FBQ2pDLFVBQUssR0FBVyxDQUFDLENBQUM7UUFDbEIsaUJBQVksR0FBYyxjQUFPLENBQUMsQ0FBQztRQUUzQyx3QkFBd0I7UUFDakIsVUFBSyxHQUFHLEtBQUssQ0FBQztRQUdqQixJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUUzQixNQUFNLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLGNBQVksT0FBQSxLQUFJLENBQUMsbUJBQW1CLEVBQUUsRUFBMUIsQ0FBMEIsQ0FBQyxDQUFDO1FBRTFFLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxDQUFNO1lBQ3BDLElBQU0sS0FBSyxHQUFXLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFDL0IsK0JBQStCO1lBQy9CLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtnQkFDWCxLQUFJLENBQUMsSUFBSSxHQUFHLEtBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSSxDQUFDLFVBQVUsQ0FBQzthQUM1QztpQkFBTTtnQkFDSCxLQUFJLENBQUMsSUFBSSxHQUFHLEtBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSSxDQUFDLFVBQVUsQ0FBQzthQUM1QztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBRVAsQ0FBQztJQUVPLDhDQUFtQixHQUEzQjtRQUNJLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFYSw0QkFBVyxHQUF6QjtRQUNJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUU7WUFDNUIsZ0JBQWdCLENBQUMsUUFBUSxHQUFHLElBQUksZ0JBQWdCLEVBQUUsQ0FBQztTQUN0RDtRQUNELE9BQU8sZ0JBQWdCLENBQUMsUUFBUSxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7T0FFRztJQUNILDhCQUFHLEdBQUgsVUFBSSxLQUFhO1FBQ2IsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVELHNCQUFJLG9DQUFNO2FBQVY7WUFDSSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDaEMsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxrQ0FBSTthQUFSO1lBQ0ksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3RCLENBQUM7YUFrQkQsVUFBUyxDQUFTO1lBQ2QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNQLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO2dCQUNsQixJQUFNLHFCQUFxQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3BGLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO2dCQUNmLElBQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDcEYsSUFBSSxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDO2dCQUMzRCxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDdkI7UUFDTCxDQUFDOzs7T0EzQkE7SUFFRCxzQkFBSSw4Q0FBZ0I7YUFBcEI7WUFDSSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUMxQyxDQUFDO2FBU0QsVUFBcUIsQ0FBUztZQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztZQUNsQixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLENBQUM7OztPQVpBO0lBS0Qsc0JBQUksNkNBQWU7UUFIbkI7O1dBRUc7YUFDSDtZQUNJLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUQsQ0FBQzs7O09BQUE7SUFrQkQsd0NBQWEsR0FBYixVQUFjLFFBQW1CO1FBQzdCLElBQUksQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7T0FFRztJQUNILHNDQUFXLEdBQVgsVUFBWSxDQUFTO1FBQ2pCLE9BQU8sQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsdUNBQVksR0FBWixVQUFhLENBQVM7UUFDbEIsT0FBTyxDQUFDLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCx3Q0FBYSxHQUFiLFVBQWMsQ0FBUztRQUNuQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7O09BRUc7SUFDSCx3Q0FBYSxHQUFiLFVBQWMsQ0FBUztRQUNuQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBQ0wsdUJBQUM7QUFBRCxDQTFIQSxBQTBIQyxJQUFBOzs7Ozs7QUNqSUQseUNBQWtDO0FBQ2xDLGdDQUEyQjtBQUMzQixvQ0FBK0I7QUFDL0IseURBQW1EO0FBT25EOzs7O0VBSUU7QUFDRjtJQVNJLHdCQUFvQixHQUFZO1FBQVosUUFBRyxHQUFILEdBQUcsQ0FBUztRQVJoQywrQ0FBK0M7UUFDOUIsc0JBQWlCLEdBQUcsRUFBRSxDQUFDO1FBRWhDLGVBQVUsR0FBZ0IsRUFBRSxDQUFDO1FBQzdCLHNCQUFpQixHQUFjLElBQUksQ0FBQztRQUNwQyxhQUFRLEdBQVksS0FBSyxDQUFDO1FBQzFCLHFCQUFnQixHQUFHLDJCQUFnQixDQUFDLFdBQVcsRUFBRSxDQUFDO1FBR3RELG9CQUFRLENBQUMsTUFBSSxjQUFJLENBQUMsU0FBVyxDQUFDLENBQUMsU0FBUyxDQUFDO1lBQ3JDLE9BQU8sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDbEMsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNoQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQzlCLGFBQWEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7U0FDM0MsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELHdDQUFlLEdBQWYsVUFBZ0IsT0FBZ0I7UUFDNUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7SUFDNUIsQ0FBQztJQUVELGtDQUFTLEdBQVQsVUFBVSxNQUFXLEVBQUUsWUFBaUIsRUFBRSxPQUFZLEVBQUUsV0FBb0I7UUFDeEUsSUFBSSxXQUFXO1lBQUUsT0FBTyxVQUFVLENBQUM7UUFDbkMsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUVELGtDQUFTLEdBQVQsVUFBVSxLQUFVO1FBQXBCLGlCQW1CQztRQWxCRyx3Q0FBd0M7UUFDeEMsSUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxJQUFJLGdCQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVuRixJQUFJLGVBQWUsR0FBRyxRQUFRLENBQUM7UUFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBQSxTQUFTO1lBQzdCLElBQU0sQ0FBQyxHQUFHLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDbkQsSUFBSSxDQUFDLEdBQUcsZUFBZSxFQUFFO2dCQUNyQixlQUFlLEdBQUcsQ0FBQyxDQUFDO2dCQUNwQixLQUFJLENBQUMsaUJBQWlCLEdBQUcsU0FBUyxDQUFDO2FBQ3RDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCw4RUFBOEU7UUFDOUUsSUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQztRQUUvRSxJQUFJLGVBQWUsR0FBRyxrQkFBa0IsRUFBRTtZQUN0QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO1NBQ2pDO0lBQ0wsQ0FBQztJQUVELGlDQUFRLEdBQVIsVUFBUyxLQUFVO1FBQ2YsSUFBTSxLQUFLLEdBQUcsSUFBSSxnQkFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUV6QyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEtBQUssSUFBSSxFQUFFO1lBQ25ELGFBQWE7WUFDYixJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzVDO2FBQU07WUFDSCxXQUFXO1lBQ1gsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNwQztJQUNMLENBQUM7SUFFRCxnQ0FBTyxHQUFQO1FBQ0ksSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQztRQUM5QixjQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGlDQUFRLEdBQVIsVUFBUyxTQUF5QixFQUN6QixNQUE2QjtRQUR0QyxpQkFjQztRQVpHLElBQU0sU0FBUyxHQUFjO1lBQ3pCLFNBQVMsRUFBRSxTQUFTO1lBQ3BCLFVBQVUsRUFBRSxNQUFNO1NBQ3JCLENBQUM7UUFFRixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNoQyxPQUFPLENBQUM7WUFDSixJQUFNLEtBQUssR0FBRyxLQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNqRCxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7Z0JBQ1osS0FBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ3BDO1FBQ0wsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFDTCxxQkFBQztBQUFELENBdEZBLEFBc0ZDLElBQUE7Ozs7OztBQ3BHRCx5REFBbUQ7QUFDbkQsZ0NBQTJCO0FBRzNCLG1EQUFzRDtBQUd0RDtJQU9JLGlCQUFzQixNQUF3QixFQUN4QixVQUEyQixFQUMzQixTQUFrQixFQUNsQixpQkFBNkIsRUFDN0IsVUFBa0IsRUFDbEIsTUFBa0I7UUFMeEMsaUJBYUM7UUFicUIsV0FBTSxHQUFOLE1BQU0sQ0FBa0I7UUFDeEIsZUFBVSxHQUFWLFVBQVUsQ0FBaUI7UUFDM0IsY0FBUyxHQUFULFNBQVMsQ0FBUztRQUNsQixzQkFBaUIsR0FBakIsaUJBQWlCLENBQVk7UUFDN0IsZUFBVSxHQUFWLFVBQVUsQ0FBUTtRQUNsQixXQUFNLEdBQU4sTUFBTSxDQUFZO1FBVmhDLHdCQUFtQixHQUFjLEVBQUUsQ0FBQztRQUNsQyxxQkFBZ0IsR0FBRywyQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNsRCx3QkFBbUIsR0FBYyxjQUFPLENBQUMsQ0FBQztRQUMxQyx5QkFBb0IsR0FBYyxjQUFPLENBQUMsQ0FBQztRQVFqRCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUkscUJBQW1CLENBQ3RDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFDN0MsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFeEQsOENBQThDO1FBQzlDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pCLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsY0FBWSxPQUFBLEtBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUF4QixDQUF3QixDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVELDRCQUFVLEdBQVY7UUFBQSxpQkFvQkM7UUFuQkcsSUFBTSxPQUFPLEdBQUc7WUFDWixRQUFRLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3ZDLFlBQVksRUFBRTtnQkFDVixLQUFJLENBQUMsV0FBVyxDQUFDLHVCQUF1QixFQUFFLENBQUM7Z0JBQzNDLEtBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNsQixDQUFDO1NBQ0osQ0FBQztRQUVGLElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN6RCxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNoQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQztRQUVwQyxJQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hELFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN0QyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFdkMsSUFBTSxlQUFlLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxlQUFlLENBQUMsQ0FBQztRQUN4RCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsc0JBQUksbUNBQWM7YUFBbEI7WUFDSSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsb0JBQW9CLENBQUM7UUFDakQsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxHQUFKLFVBQUssTUFBcUI7UUFBMUIsaUJBSUM7UUFIRyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUM7WUFDM0MsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsS0FBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBOUMsQ0FBOEMsQ0FBQyxDQUFDLENBQUM7UUFDcEYsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsNEJBQVUsR0FBVjtRQUNJLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRCx3Q0FBc0IsR0FBdEIsVUFBdUIsbUJBQThCO1FBQ2pELElBQUksQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztJQUNuRCxDQUFDO0lBRUQsd0NBQXNCLEdBQXRCLFVBQXVCLFFBQW1CO1FBQ3RDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxRQUFRLENBQUM7SUFDeEMsQ0FBQztJQUVELHlDQUF1QixHQUF2QixVQUF3QixRQUFtQjtRQUN2QyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsUUFBUSxDQUFDO0lBQ3pDLENBQUM7SUFFRCxrQ0FBZ0IsR0FBaEI7UUFDSSxJQUFJLENBQUMsV0FBVyxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDeEMsQ0FBQztJQUVELCtCQUFhLEdBQWI7UUFBQSxpQkFlQztRQWRHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBRTNCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7UUFDOUQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLHFCQUFtQixDQUN0QyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQzdDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDMUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztRQUU5RCxJQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsS0FBSSxDQUFDLFdBQVcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEVBQXRELENBQXNELENBQUMsQ0FBQztRQUM5RixJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFvQixFQUFFLENBQUM7UUFDeEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1FBQzNDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNkLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFFUyxzQ0FBb0IsR0FBOUIsVUFBK0IsTUFBd0IsRUFBRSxNQUFlO1FBQ3BFLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFDckMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDaEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDNUIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDakMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDbEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDaEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxtQ0FBaUIsR0FBekI7UUFDSSxJQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNsRSxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsR0FBRyxHQUFHLEdBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDbkQsY0FBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUNMLGNBQUM7QUFBRCxDQTdHQSxBQTZHQyxJQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BIRCx5REFBbUQ7QUFFbkQsaURBQWlEO0FBR2pELHVDQUFrQztBQUNsQyx1Q0FBaUM7QUFDakMsaURBQTJDO0FBRTNDLHlEQUFtRDtBQUduRDtJQWlDSSxrQkFBb0IsU0FBa0IsRUFBRSxXQUF3QixFQUFVLGlCQUE2QjtRQUF2RyxpQkFzRkM7UUF0Rm1CLGNBQVMsR0FBVCxTQUFTLENBQVM7UUFBb0Msc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFZO1FBaEMvRixxQkFBZ0IsR0FBRywyQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNsRCxrQkFBYSxHQUFhLEVBQUUsQ0FBQztRQUM5QixhQUFRLEdBQVcsQ0FBQyxDQUFDO1FBQ3BCLFVBQUssR0FBZSxFQUFFLENBQUM7UUFDdkIsU0FBSSxHQUFlLEVBQUUsQ0FBQztRQUV0QixpQkFBWSxHQUFHLEVBQUUsQ0FBQztRQUNsQixtQkFBYyxHQUFHLENBQUMsQ0FBQztRQVduQixnQkFBVyxHQUFxQjtZQUNwQyxJQUFJLEVBQUUsRUFBRTtZQUNSLEtBQUssRUFBRSxFQUFFO1lBQ1QsS0FBSyxFQUFFLENBQUM7WUFDUixVQUFVLEVBQUUsR0FBRztZQUNmLFdBQVcsRUFBRSxDQUFDO1lBQ2QsU0FBUyxFQUFFLEdBQUc7WUFDZCxjQUFjLEVBQUUsSUFBSTtZQUNwQixTQUFTLEVBQUUsR0FBRztZQUNkLGlCQUFpQixFQUFFLEdBQUc7U0FDekIsQ0FBQztRQUVNLFdBQU0sR0FBWSxJQUFJLENBQUM7UUFHM0IsSUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNsRCxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztRQUVsQyxJQUFJLENBQUMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzRCxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7UUFDNUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLENBQUM7UUFFNUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBQzVCLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUM1QixJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUM7UUFFbEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBQzNCLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztRQUM1QixJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUM7UUFFakMsSUFBTSxVQUFVLEdBQUcsSUFBSSwwQkFBYSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDcEUsSUFBTSxNQUFNLEdBQUcsY0FBTSxPQUFBLEtBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxFQUFsQixDQUFrQixDQUFDO1FBQ3hDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSx1QkFBWSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsVUFBVSxFQUM5RCxJQUFJLENBQUMsU0FBUyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2xHLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxrQkFBTyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzFILElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxrQkFBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzdILElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxrQkFBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRTdILElBQUksQ0FBQyxVQUFVLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDMUYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDekUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBRXhELElBQUksQ0FBQyxTQUFTLENBQUMsc0JBQXNCLENBQUM7WUFDbEMsS0FBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ2xDLEtBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUNuQyxLQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDbkMsS0FBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7WUFDaEIsS0FBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7WUFDZixXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3pCLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDM0IsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsU0FBUyxDQUFDLHVCQUF1QixDQUFDO1lBQ25DLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsRCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxTQUFTLENBQUMsc0JBQXNCLENBQUM7WUFDbEMsS0FBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ25DLEtBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUNuQyxLQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztZQUNoQixLQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUNmLFdBQVcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsVUFBVSxDQUFDLHNCQUFzQixDQUFDO1lBQ25DLEtBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUNuQyxLQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztZQUNoQixLQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUNmLFdBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JDLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQzs7WUFDcEMsSUFBTSxDQUFDLEdBQUcsSUFBSSxlQUFLLENBQUMsS0FBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEtBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLEVBQUUsS0FBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNsSCxLQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxhQUFhLENBQUM7WUFDckMsSUFBTSxDQUFDLEdBQUcsSUFBSSx3QkFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNyQyxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDakIsSUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQztZQUU1QixJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsS0FBSSxDQUFDLFFBQVEsRUFBRTtnQkFDakMsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUNoRixLQUFLLElBQUksQ0FBQyxHQUFHLFNBQVMsRUFBRSxDQUFDLEdBQUcsU0FBUyxHQUFHLEtBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ3hELEtBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNoQzthQUNKO2lCQUFNOztvQkFDSCxLQUFjLElBQUEsYUFBQSxTQUFBLFFBQVEsQ0FBQSxrQ0FBQSx3REFBRTt3QkFBbkIsSUFBSSxHQUFDLHFCQUFBO3dCQUNOLEtBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUMsQ0FBQyxDQUFDO3FCQUN0Qjs7Ozs7Ozs7O2FBQ0o7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxVQUFVLENBQUMsc0JBQXNCLENBQUM7WUFDbkMsS0FBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7UUFDbkIsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFNLGVBQWUsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3pELGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQzFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQzFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELCtCQUFZLEdBQVo7UUFDSSxJQUFNLENBQUMsR0FBRyxJQUFJLGVBQUssQ0FDZixJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWM7YUFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDO2FBQ3JDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQzthQUN0QyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BFLElBQU0sQ0FBQyxHQUFHLElBQUksd0JBQWEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDOUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCx1QkFBSSxHQUFKLFVBQUssTUFBcUIsRUFBRSxTQUFlO1FBQTNDLGlCQXdFQztRQXhFMkIsMEJBQUEsRUFBQSxpQkFBZTtRQUN2QyxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUU7WUFDNUQsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDcEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFFcEIsTUFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvQixNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFckIsTUFBTTtRQUNOLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqQyxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pCLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsS0FBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBOUMsQ0FBOEMsQ0FBQyxDQUFDLENBQUM7UUFFdkcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckMsWUFBWTtRQUNaLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0Isa0NBQWtDO1FBQ2xDLE1BQU0sQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDakMsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUM7WUFDZixNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUE5QyxDQUE4QyxDQUFDLENBQUMsQ0FBQztRQUNuRixDQUFDLENBQUMsQ0FBQztRQUVILFFBQVE7UUFDUixNQUFNLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQztZQUNoQixNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUE5QyxDQUE4QyxDQUFDLENBQUMsQ0FBQztRQUNuRixDQUFDLENBQUMsQ0FBQztRQUVILGVBQWU7UUFDZixNQUFNLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUU3QixNQUFNLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUU3QixNQUFNLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUU1QixjQUFjO1FBQ2QsTUFBTSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFN0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFN0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFNUIsUUFBUTtRQUNSLG9DQUFvQztRQUNwQywwQkFBMEI7UUFDMUIsNEZBQTRGO1FBRTVGLDhCQUE4QjtRQUM5QixrQ0FBa0M7UUFDbEMsNkVBQTZFO0lBQ2pGLENBQUM7SUFFRCw2QkFBVSxHQUFWO1FBQ0ksT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRTtlQUM1QixJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRTtlQUM1QixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRTtlQUMzQixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3ZDLENBQUM7SUFDTCxlQUFDO0FBQUQsQ0F0TkEsQUFzTkMsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25PRCxtQ0FBNEI7QUFFNUIsbURBQTZDO0FBRTdDO0lBQXlDLCtCQUFhO0lBR2xELHFCQUFZLE1BQXlCLEVBQUUsS0FBTyxFQUFFLGNBQW1CO1FBQTVCLHNCQUFBLEVBQUEsU0FBTztRQUFFLCtCQUFBLEVBQUEscUJBQW1CO1FBQW5FLFlBQ0ksa0JBQU0sTUFBTSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsU0FHdkM7UUFGRyxJQUFNLEVBQUUsR0FBRyxpQkFBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7UUFDaEMsZ0JBQWdCO0lBQ3BCLENBQUM7SUFHTCxrQkFBQztBQUFELENBVkEsQUFVQyxDQVZ3Qyx3QkFBYSxHQVVyRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2JELHlEQUFtRDtBQUVuRCxxREFBK0M7QUFHL0MsZ0NBQTJCO0FBQzNCLG9DQUErQjtBQUUvQjtJQUE0QyxrQ0FBVztJQUtuRCx3QkFBb0IsU0FBa0IsRUFBVSxjQUE4QixFQUNuRSxVQUFtQixFQUFFLFdBQXdCO1FBRHhELFlBRUksa0JBQU0sV0FBVyxDQUFDLFNBYXJCO1FBZm1CLGVBQVMsR0FBVCxTQUFTLENBQVM7UUFBVSxvQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDbkUsZ0JBQVUsR0FBVixVQUFVLENBQVM7UUFMdEIsMEJBQW9CLEdBQUcsRUFBRSxDQUFDO1FBQzFCLHdCQUFrQixHQUFHLEdBQUcsQ0FBQyxDQUFFLHlEQUF5RDtRQUNwRixzQkFBZ0IsR0FBRywyQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUt0RCxtQ0FBbUM7UUFDbkMsSUFBTSxpQkFBaUIsR0FBRztZQUN0QixLQUFLLEVBQUUsY0FBWSxPQUFBLEtBQUksQ0FBQyxLQUFLLEVBQUUsRUFBWixDQUFZO1lBQy9CLGNBQWMsRUFBRSxjQUFZLE9BQUEsS0FBSSxDQUFDLGNBQWMsRUFBRSxFQUFyQixDQUFxQjtZQUNqRCxTQUFTLEVBQUUsY0FBWSxPQUFBLEtBQUksQ0FBQyxlQUFlLEVBQUUsRUFBdEIsQ0FBc0I7WUFDN0MsT0FBTyxFQUFFLGNBQVksT0FBQSxLQUFJLENBQUMsYUFBYSxFQUFFLEVBQXBCLENBQW9CO1NBQzVDLENBQUM7UUFFRixLQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMvQyxLQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3hELEtBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLGlCQUFpQixFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ25ELEtBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLGlCQUFpQixFQUFFLFNBQVMsQ0FBQyxDQUFDOztJQUNyRCxDQUFDO0lBRUQ7O09BRUc7SUFDSCx1Q0FBYyxHQUFkO1FBQ0ksSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2IsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDM0YsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWU7YUFDbEQsY0FBYyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNqRCxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3BELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLGdCQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckUsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRCx3Q0FBZSxHQUFmO1FBQ0ksSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLEVBQ2hDLGNBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxHQUFDLEVBQUUsRUFBRSxLQUFLLEdBQUMsQ0FBQyxDQUFDLEVBQUcsT0FBTztRQUM3QyxjQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBRSxRQUFRO0lBQ3hDLENBQUM7SUFFRCxzQ0FBYSxHQUFiO1FBQ0ksSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFTywwQ0FBaUIsR0FBekIsVUFBMEIsUUFBZ0I7UUFDdEMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQ2pCLGNBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxHQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRyxPQUFPO1FBQzFDLGNBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUcsUUFBUTtRQUMvQixjQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssdUNBQWMsR0FBdEI7UUFDSSxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUMzRixJQUFNLFFBQVEsR0FBRyxJQUFJLGdCQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6RSxJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMxRyxPQUFPLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRU8sMENBQWlCLEdBQXpCO1FBQ0ksMERBQTBEO1FBQzFELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDO1FBQ3hFLElBQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUM7UUFDOUQsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGlCQUFpQjtRQUMzRSxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pELElBQU0sT0FBTyxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO1FBQ2pGLElBQU0sT0FBTyxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO1FBRWpGLElBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDNUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDNUIsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLGdCQUFNLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxFQUFFLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDNUU7U0FDSjtRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVPLHNDQUFhLEdBQXJCLFVBQXNCLEtBQWEsRUFBRSxPQUFlO1FBQ2hELElBQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUU1RSxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFFLHFCQUFxQjtRQUMxRixJQUFNLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakQsSUFBTSxHQUFHLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9DLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVELDZCQUFJLEdBQUosVUFBSyxNQUFxQixFQUFFLFNBQWU7UUFBM0MsaUJBaUJDO1FBakIyQiwwQkFBQSxFQUFBLGlCQUFlO1FBQ3ZDLG9CQUFvQjtRQUNoQixNQUFNLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9CLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkIsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDOUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUM7WUFDbEIsSUFBTSxDQUFDLEdBQUcsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QixNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekQsTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzdELENBQUMsQ0FBQyxDQUFDO1FBRUgsK0JBQStCO1FBQy9CLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNqQixNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzNCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDO2dCQUM1QixPQUFBLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFBNUQsQ0FBNEQsQ0FBQyxDQUFDO1NBQ3JFO0lBQ1QsQ0FBQztJQUVTLGlDQUFRLEdBQWxCLFVBQW1CLEtBQWlCO1FBQXBDLGlCQVlDO1FBWEcsaUJBQU0sUUFBUSxZQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3RCLElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEtBQUcsS0FBSyxDQUFDLFdBQWEsQ0FBQyxDQUFDO1FBRWhFLDhDQUE4QztRQUM5QyxJQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FDL0MsY0FBTSxPQUFBLEtBQUssQ0FBQyxNQUFNLEVBQVosQ0FBWSxFQUFFLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUM1RCxJQUFNLGNBQWMsR0FBRyxFQUFDLE1BQU0sRUFBRSxjQUFZLE9BQUEsS0FBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxjQUFjLENBQUMsRUFBN0QsQ0FBNkQsRUFBQyxDQUFDO1FBRTNHLGtDQUFrQztRQUNsQyxNQUFNLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNyQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFTyx1Q0FBYyxHQUF0QixVQUF1QixLQUFpQixFQUFFLE1BQWUsRUFBRSxjQUE0QjtRQUNuRixpQkFBTSxXQUFXLFlBQUMsS0FBSyxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDcEMsa0NBQWtDO1FBQ2xDLGNBQWMsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFRCw4QkFBSyxHQUFMO1FBQ0ksd0ZBQXdGO1FBQ3hGLHNFQUFzRTtRQUN0RSxLQUFLLElBQU0sZUFBZSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFO1lBQ3BELElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQzdELFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFTLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDeEQ7UUFFRCxpQkFBTSxLQUFLLFdBQUUsQ0FBQztJQUNsQixDQUFDO0lBQ0wscUJBQUM7QUFBRCxDQWxKQSxBQWtKQyxDQWxKMkMsc0JBQVcsR0FrSnREOzs7Ozs7QUN2SkQ7SUFBQTtJQTJCQSxDQUFDO0lBdEJVLGNBQVMsR0FBaEIsVUFBaUIsR0FBWTtRQUN6QixJQUFJLEdBQUcsQ0FBQyxhQUFhLEVBQUU7WUFDbkIsR0FBRyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsYUFBYSxFQUFFLEVBQWpCLENBQWlCLENBQUMsQ0FBQztTQUNyRDtRQUNELElBQUksR0FBRyxDQUFDLFNBQVMsRUFBRTtZQUNmLEtBQUssSUFBSSxVQUFVLElBQUksR0FBRyxDQUFDLFNBQVMsRUFBRTtnQkFDbEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7YUFDN0M7U0FDSjtJQUNMLENBQUM7SUFFTSxxQkFBZ0IsR0FBdkIsVUFBd0IsR0FBWTtRQUNoQyxJQUFJLEdBQUcsQ0FBQyxTQUFTLEVBQUU7WUFDZixLQUFLLElBQUksVUFBVSxJQUFJLEdBQUcsQ0FBQyxTQUFTLEVBQUU7Z0JBQ2xDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO2FBQy9DO1NBQ0o7SUFDTCxDQUFDO0lBRU0sZ0JBQVcsR0FBbEIsVUFBbUIsR0FBVyxFQUFFLEdBQUs7UUFBTCxvQkFBQSxFQUFBLE9BQUs7UUFDakMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUMvQyxDQUFDO0lBekJELHVCQUF1QjtJQUNQLGNBQVMsR0FBRyxZQUFZLENBQUM7SUFDekIsa0JBQWEsR0FBRyxZQUFZLENBQUM7SUF3QmpELFdBQUM7Q0EzQkQsQUEyQkMsSUFBQTtrQkEzQm9CLElBQUk7Ozs7O0FDTHpCLDhCQUFnQztBQUVoQztJQUNJLGdCQUFtQixDQUFTLEVBQVMsQ0FBUztRQUEzQixNQUFDLEdBQUQsQ0FBQyxDQUFRO1FBQVMsTUFBQyxHQUFELENBQUMsQ0FBUTtJQUFHLENBQUM7SUFFM0MsaUJBQVUsR0FBakI7UUFDSSxPQUFPLElBQUksTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRU0saUJBQVUsR0FBakIsVUFBa0IsQ0FBUztRQUN2QixPQUFPLElBQUksTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQ7O09BRUc7SUFDSSxtQkFBWSxHQUFuQixVQUFvQixFQUFVLEVBQUUsRUFBVTtRQUN0QyxjQUFjO1FBQ2QsSUFBSSxZQUFZLEdBQUcsRUFBRSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUMzQyxJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3hCLFlBQVksSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztTQUMvQjthQUFNLElBQUksWUFBWSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNqQyxZQUFZLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDL0I7UUFDRCxPQUFPLFlBQVksQ0FBQztJQUN4QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksYUFBTSxHQUFiLFVBQWMsU0FBaUIsRUFBRSxhQUFxQixFQUFFLEtBQWE7UUFDakUsSUFBTSxtQkFBbUIsR0FBRyxJQUFJLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFFLE9BQU8sS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVELG9CQUFHLEdBQUgsVUFBSSxDQUFTO1FBQ1QsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsc0JBQUssR0FBTDtRQUNJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsc0JBQUssR0FBTDtRQUNJLE9BQU8sSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELHFCQUFJLEdBQUosVUFBSyxDQUFTO1FBQ1YsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2IsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELHNCQUFLLEdBQUwsVUFBTSxDQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCwyQkFBVSxHQUFWLFVBQVcsQ0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELGtDQUFpQixHQUFqQixVQUFtQixDQUFTO1FBQ3hCLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUN2QixJQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEIsT0FBTyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVELHVCQUFNLEdBQU4sVUFBTyxDQUFTO1FBQ1osSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN4QixHQUFHLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7WUFDN0IsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNkLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNkLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCw2QkFBWSxHQUFaLFVBQWEsQ0FBUztRQUNsQixJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDVCxHQUFHLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7WUFDN0IsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUNELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELG9CQUFHLEdBQUgsVUFBSSxDQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCx1QkFBTSxHQUFOLFVBQU8sQ0FBUztRQUNaLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQsdUJBQU0sR0FBTjtRQUNJLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQseUJBQVEsR0FBUjtRQUNJLE9BQU8sSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQseUJBQVEsR0FBUixVQUFTLENBQVM7UUFDZCxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDZCxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDZCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsK0JBQWMsR0FBZCxVQUFlLENBQVM7UUFDcEIsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDWixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNaLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCx1QkFBTSxHQUFOO1FBQ0ksT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVELDBCQUFTLEdBQVQ7UUFDSSxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ1QsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUN4QixPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRDs7T0FFRztJQUNILDZCQUFZLEdBQVosVUFBYSxNQUFjLEVBQUUsS0FBYTtRQUN0QyxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFBO1FBQzNCLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFNUIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzVCLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUU1QixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDdEMsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELG9CQUFHLEdBQUgsVUFBSSxDQUFTO1FBQ1QsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2IsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELHFCQUFJLEdBQUosVUFBSyxDQUFTO1FBQ1YsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQscUJBQUksR0FBSixVQUFLLENBQVM7UUFDVixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCwwQkFBUyxHQUFULFVBQVcsTUFBYztRQUNyQixPQUFPLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVELG9CQUFHLEdBQUgsVUFBSSxDQUFTO1FBQ1QsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUNMLGFBQUM7QUFBRCxDQS9LQSxBQStLQyxJQUFBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1xdWFkdHJlZS8gdjEuMC43IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gdHJlZV9hZGQoZCkge1xuICB2YXIgeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCksXG4gICAgICB5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKTtcbiAgcmV0dXJuIGFkZCh0aGlzLmNvdmVyKHgsIHkpLCB4LCB5LCBkKTtcbn1cblxuZnVuY3Rpb24gYWRkKHRyZWUsIHgsIHksIGQpIHtcbiAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gdHJlZTsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0cmVlLl9yb290LFxuICAgICAgbGVhZiA9IHtkYXRhOiBkfSxcbiAgICAgIHgwID0gdHJlZS5feDAsXG4gICAgICB5MCA9IHRyZWUuX3kwLFxuICAgICAgeDEgPSB0cmVlLl94MSxcbiAgICAgIHkxID0gdHJlZS5feTEsXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgeHAsXG4gICAgICB5cCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBGaW5kIHRoZSBleGlzdGluZyBsZWFmIGZvciB0aGUgbmV3IHBvaW50LCBvciBhZGQgaXQuXG4gIHdoaWxlIChub2RlLmxlbmd0aCkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmIChwYXJlbnQgPSBub2RlLCAhKG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xuICB9XG5cbiAgLy8gSXMgdGhlIG5ldyBwb2ludCBpcyBleGFjdGx5IGNvaW5jaWRlbnQgd2l0aCB0aGUgZXhpc3RpbmcgcG9pbnQ/XG4gIHhwID0gK3RyZWUuX3guY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICB5cCA9ICt0cmVlLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgaWYgKHggPT09IHhwICYmIHkgPT09IHlwKSByZXR1cm4gbGVhZi5uZXh0ID0gbm9kZSwgcGFyZW50ID8gcGFyZW50W2ldID0gbGVhZiA6IHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIE90aGVyd2lzZSwgc3BsaXQgdGhlIGxlYWYgbm9kZSB1bnRpbCB0aGUgb2xkIGFuZCBuZXcgcG9pbnQgYXJlIHNlcGFyYXRlZC5cbiAgZG8ge1xuICAgIHBhcmVudCA9IHBhcmVudCA/IHBhcmVudFtpXSA9IG5ldyBBcnJheSg0KSA6IHRyZWUuX3Jvb3QgPSBuZXcgQXJyYXkoNCk7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gIH0gd2hpbGUgKChpID0gYm90dG9tIDw8IDEgfCByaWdodCkgPT09IChqID0gKHlwID49IHltKSA8PCAxIHwgKHhwID49IHhtKSkpO1xuICByZXR1cm4gcGFyZW50W2pdID0gbm9kZSwgcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbn1cblxuZnVuY3Rpb24gYWRkQWxsKGRhdGEpIHtcbiAgdmFyIGQsIGksIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeHogPSBuZXcgQXJyYXkobiksXG4gICAgICB5eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHgwID0gSW5maW5pdHksXG4gICAgICB5MCA9IEluZmluaXR5LFxuICAgICAgeDEgPSAtSW5maW5pdHksXG4gICAgICB5MSA9IC1JbmZpbml0eTtcblxuICAvLyBDb21wdXRlIHRoZSBwb2ludHMgYW5kIHRoZWlyIGV4dGVudC5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkID0gZGF0YVtpXSkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgY29udGludWU7XG4gICAgeHpbaV0gPSB4O1xuICAgIHl6W2ldID0geTtcbiAgICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gICAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICAgIGlmICh5IDwgeTApIHkwID0geTtcbiAgICBpZiAoeSA+IHkxKSB5MSA9IHk7XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlIG5vICh2YWxpZCkgcG9pbnRzLCBhYm9ydC5cbiAgaWYgKHgwID4geDEgfHwgeTAgPiB5MSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRXhwYW5kIHRoZSB0cmVlIHRvIGNvdmVyIHRoZSBuZXcgcG9pbnRzLlxuICB0aGlzLmNvdmVyKHgwLCB5MCkuY292ZXIoeDEsIHkxKTtcblxuICAvLyBBZGQgdGhlIG5ldyBwb2ludHMuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBhZGQodGhpcywgeHpbaV0sIHl6W2ldLCBkYXRhW2ldKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0cmVlX2NvdmVyKHgsIHkpIHtcbiAgaWYgKGlzTmFOKHggPSAreCkgfHwgaXNOYU4oeSA9ICt5KSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxO1xuXG4gIC8vIElmIHRoZSBxdWFkdHJlZSBoYXMgbm8gZXh0ZW50LCBpbml0aWFsaXplIHRoZW0uXG4gIC8vIEludGVnZXIgZXh0ZW50IGFyZSBuZWNlc3Nhcnkgc28gdGhhdCBpZiB3ZSBsYXRlciBkb3VibGUgdGhlIGV4dGVudCxcbiAgLy8gdGhlIGV4aXN0aW5nIHF1YWRyYW50IGJvdW5kYXJpZXMgZG9u4oCZdCBjaGFuZ2UgZHVlIHRvIGZsb2F0aW5nIHBvaW50IGVycm9yIVxuICBpZiAoaXNOYU4oeDApKSB7XG4gICAgeDEgPSAoeDAgPSBNYXRoLmZsb29yKHgpKSArIDE7XG4gICAgeTEgPSAoeTAgPSBNYXRoLmZsb29yKHkpKSArIDE7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGRvdWJsZSByZXBlYXRlZGx5IHRvIGNvdmVyLlxuICBlbHNlIHtcbiAgICB2YXIgeiA9IHgxIC0geDAsXG4gICAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGk7XG5cbiAgICB3aGlsZSAoeDAgPiB4IHx8IHggPj0geDEgfHwgeTAgPiB5IHx8IHkgPj0geTEpIHtcbiAgICAgIGkgPSAoeSA8IHkwKSA8PCAxIHwgKHggPCB4MCk7XG4gICAgICBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQsIHogKj0gMjtcbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6IHgxID0geDAgKyB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogeDAgPSB4MSAtIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAyOiB4MSA9IHgwICsgeiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IHgwID0geDEgLSB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jvb3QgJiYgdGhpcy5fcm9vdC5sZW5ndGgpIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRyZWVfZGF0YSgpIHtcbiAgdmFyIGRhdGEgPSBbXTtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gZGF0YS5wdXNoKG5vZGUuZGF0YSk7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHRyZWVfZXh0ZW50KF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5jb3ZlcigrX1swXVswXSwgK19bMF1bMV0pLmNvdmVyKCtfWzFdWzBdLCArX1sxXVsxXSlcbiAgICAgIDogaXNOYU4odGhpcy5feDApID8gdW5kZWZpbmVkIDogW1t0aGlzLl94MCwgdGhpcy5feTBdLCBbdGhpcy5feDEsIHRoaXMuX3kxXV07XG59XG5cbmZ1bmN0aW9uIFF1YWQobm9kZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy54MCA9IHgwO1xuICB0aGlzLnkwID0geTA7XG4gIHRoaXMueDEgPSB4MTtcbiAgdGhpcy55MSA9IHkxO1xufVxuXG5mdW5jdGlvbiB0cmVlX2ZpbmQoeCwgeSwgcmFkaXVzKSB7XG4gIHZhciBkYXRhLFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MixcbiAgICAgIHgzID0gdGhpcy5feDEsXG4gICAgICB5MyA9IHRoaXMuX3kxLFxuICAgICAgcXVhZHMgPSBbXSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcSxcbiAgICAgIGk7XG5cbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgeDAsIHkwLCB4MywgeTMpKTtcbiAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgZWxzZSB7XG4gICAgeDAgPSB4IC0gcmFkaXVzLCB5MCA9IHkgLSByYWRpdXM7XG4gICAgeDMgPSB4ICsgcmFkaXVzLCB5MyA9IHkgKyByYWRpdXM7XG4gICAgcmFkaXVzICo9IHJhZGl1cztcbiAgfVxuXG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcblxuICAgIC8vIFN0b3Agc2VhcmNoaW5nIGlmIHRoaXMgcXVhZHJhbnQgY2Fu4oCZdCBjb250YWluIGEgY2xvc2VyIG5vZGUuXG4gICAgaWYgKCEobm9kZSA9IHEubm9kZSlcbiAgICAgICAgfHwgKHgxID0gcS54MCkgPiB4M1xuICAgICAgICB8fCAoeTEgPSBxLnkwKSA+IHkzXG4gICAgICAgIHx8ICh4MiA9IHEueDEpIDwgeDBcbiAgICAgICAgfHwgKHkyID0gcS55MSkgPCB5MCkgY29udGludWU7XG5cbiAgICAvLyBCaXNlY3QgdGhlIGN1cnJlbnQgcXVhZHJhbnQuXG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgIHltID0gKHkxICsgeTIpIC8gMjtcblxuICAgICAgcXVhZHMucHVzaChcbiAgICAgICAgbmV3IFF1YWQobm9kZVszXSwgeG0sIHltLCB4MiwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzJdLCB4MSwgeW0sIHhtLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMV0sIHhtLCB5MSwgeDIsIHltKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVswXSwgeDEsIHkxLCB4bSwgeW0pXG4gICAgICApO1xuXG4gICAgICAvLyBWaXNpdCB0aGUgY2xvc2VzdCBxdWFkcmFudCBmaXJzdC5cbiAgICAgIGlmIChpID0gKHkgPj0geW0pIDw8IDEgfCAoeCA+PSB4bSkpIHtcbiAgICAgICAgcSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxXSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldID0gcTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWaXNpdCB0aGlzIHBvaW50LiAoVmlzaXRpbmcgY29pbmNpZGVudCBwb2ludHMgaXNu4oCZdCBuZWNlc3NhcnkhKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGR4ID0geCAtICt0aGlzLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkeSA9IHkgLSArdGhpcy5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkMiA8IHJhZGl1cykge1xuICAgICAgICB2YXIgZCA9IE1hdGguc3FydChyYWRpdXMgPSBkMik7XG4gICAgICAgIHgwID0geCAtIGQsIHkwID0geSAtIGQ7XG4gICAgICAgIHgzID0geCArIGQsIHkzID0geSArIGQ7XG4gICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHRyZWVfcmVtb3ZlKGQpIHtcbiAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICByZXRhaW5lcixcbiAgICAgIHByZXZpb3VzLFxuICAgICAgbmV4dCxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdGhpcztcblxuICAvLyBGaW5kIHRoZSBsZWFmIG5vZGUgZm9yIHRoZSBwb2ludC5cbiAgLy8gV2hpbGUgZGVzY2VuZGluZywgYWxzbyByZXRhaW4gdGhlIGRlZXBlc3QgcGFyZW50IHdpdGggYSBub24tcmVtb3ZlZCBzaWJsaW5nLlxuICBpZiAobm9kZS5sZW5ndGgpIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKCEocGFyZW50ID0gbm9kZSwgbm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgYnJlYWs7XG4gICAgaWYgKHBhcmVudFsoaSArIDEpICYgM10gfHwgcGFyZW50WyhpICsgMikgJiAzXSB8fCBwYXJlbnRbKGkgKyAzKSAmIDNdKSByZXRhaW5lciA9IHBhcmVudCwgaiA9IGk7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBwb2ludCB0byByZW1vdmUuXG4gIHdoaWxlIChub2RlLmRhdGEgIT09IGQpIGlmICghKHByZXZpb3VzID0gbm9kZSwgbm9kZSA9IG5vZGUubmV4dCkpIHJldHVybiB0aGlzO1xuICBpZiAobmV4dCA9IG5vZGUubmV4dCkgZGVsZXRlIG5vZGUubmV4dDtcblxuICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29pbmNpZGVudCBwb2ludHMsIHJlbW92ZSBqdXN0IHRoZSBwb2ludC5cbiAgaWYgKHByZXZpb3VzKSByZXR1cm4gKG5leHQgPyBwcmV2aW91cy5uZXh0ID0gbmV4dCA6IGRlbGV0ZSBwcmV2aW91cy5uZXh0KSwgdGhpcztcblxuICAvLyBJZiB0aGlzIGlzIHRoZSByb290IHBvaW50LCByZW1vdmUgaXQuXG4gIGlmICghcGFyZW50KSByZXR1cm4gdGhpcy5fcm9vdCA9IG5leHQsIHRoaXM7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVhZi5cbiAgbmV4dCA/IHBhcmVudFtpXSA9IG5leHQgOiBkZWxldGUgcGFyZW50W2ldO1xuXG4gIC8vIElmIHRoZSBwYXJlbnQgbm93IGNvbnRhaW5zIGV4YWN0bHkgb25lIGxlYWYsIGNvbGxhcHNlIHN1cGVyZmx1b3VzIHBhcmVudHMuXG4gIGlmICgobm9kZSA9IHBhcmVudFswXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzJdIHx8IHBhcmVudFszXSlcbiAgICAgICYmIG5vZGUgPT09IChwYXJlbnRbM10gfHwgcGFyZW50WzJdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMF0pXG4gICAgICAmJiAhbm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUFsbChkYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHRoaXMucmVtb3ZlKGRhdGFbaV0pO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdHJlZV9yb290KCkge1xuICByZXR1cm4gdGhpcy5fcm9vdDtcbn1cblxuZnVuY3Rpb24gdHJlZV9zaXplKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvICsrc2l6ZTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gdHJlZV92aXNpdChjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgcSwgbm9kZSA9IHRoaXMuX3Jvb3QsIGNoaWxkLCB4MCwgeTAsIHgxLCB5MTtcbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIGlmICghY2FsbGJhY2sobm9kZSA9IHEubm9kZSwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxKSAmJiBub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRyZWVfdmlzaXRBZnRlcihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgbmV4dCA9IFtdLCBxO1xuICBpZiAodGhpcy5fcm9vdCkgcXVhZHMucHVzaChuZXcgUXVhZCh0aGlzLl9yb290LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgdmFyIG5vZGUgPSBxLm5vZGU7XG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSwgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgIH1cbiAgICBuZXh0LnB1c2gocSk7XG4gIH1cbiAgd2hpbGUgKHEgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2socS5ub2RlLCBxLngwLCBxLnkwLCBxLngxLCBxLnkxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFgoZCkge1xuICByZXR1cm4gZFswXTtcbn1cblxuZnVuY3Rpb24gdHJlZV94KF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feCA9IF8sIHRoaXMpIDogdGhpcy5feDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFkoZCkge1xuICByZXR1cm4gZFsxXTtcbn1cblxuZnVuY3Rpb24gdHJlZV95KF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feSA9IF8sIHRoaXMpIDogdGhpcy5feTtcbn1cblxuZnVuY3Rpb24gcXVhZHRyZWUobm9kZXMsIHgsIHkpIHtcbiAgdmFyIHRyZWUgPSBuZXcgUXVhZHRyZWUoeCA9PSBudWxsID8gZGVmYXVsdFggOiB4LCB5ID09IG51bGwgPyBkZWZhdWx0WSA6IHksIE5hTiwgTmFOLCBOYU4sIE5hTik7XG4gIHJldHVybiBub2RlcyA9PSBudWxsID8gdHJlZSA6IHRyZWUuYWRkQWxsKG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gUXVhZHRyZWUoeCwgeSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5feCA9IHg7XG4gIHRoaXMuX3kgPSB5O1xuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICB0aGlzLl9yb290ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBsZWFmX2NvcHkobGVhZikge1xuICB2YXIgY29weSA9IHtkYXRhOiBsZWFmLmRhdGF9LCBuZXh0ID0gY29weTtcbiAgd2hpbGUgKGxlYWYgPSBsZWFmLm5leHQpIG5leHQgPSBuZXh0Lm5leHQgPSB7ZGF0YTogbGVhZi5kYXRhfTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbnZhciB0cmVlUHJvdG8gPSBxdWFkdHJlZS5wcm90b3R5cGUgPSBRdWFkdHJlZS5wcm90b3R5cGU7XG5cbnRyZWVQcm90by5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb3B5ID0gbmV3IFF1YWR0cmVlKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgbm9kZXMsXG4gICAgICBjaGlsZDtcblxuICBpZiAoIW5vZGUpIHJldHVybiBjb3B5O1xuXG4gIGlmICghbm9kZS5sZW5ndGgpIHJldHVybiBjb3B5Ll9yb290ID0gbGVhZl9jb3B5KG5vZGUpLCBjb3B5O1xuXG4gIG5vZGVzID0gW3tzb3VyY2U6IG5vZGUsIHRhcmdldDogY29weS5fcm9vdCA9IG5ldyBBcnJheSg0KX1dO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGUuc291cmNlW2ldKSB7XG4gICAgICAgIGlmIChjaGlsZC5sZW5ndGgpIG5vZGVzLnB1c2goe3NvdXJjZTogY2hpbGQsIHRhcmdldDogbm9kZS50YXJnZXRbaV0gPSBuZXcgQXJyYXkoNCl9KTtcbiAgICAgICAgZWxzZSBub2RlLnRhcmdldFtpXSA9IGxlYWZfY29weShjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG50cmVlUHJvdG8uYWRkID0gdHJlZV9hZGQ7XG50cmVlUHJvdG8uYWRkQWxsID0gYWRkQWxsO1xudHJlZVByb3RvLmNvdmVyID0gdHJlZV9jb3ZlcjtcbnRyZWVQcm90by5kYXRhID0gdHJlZV9kYXRhO1xudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xudHJlZVByb3RvLmZpbmQgPSB0cmVlX2ZpbmQ7XG50cmVlUHJvdG8ucmVtb3ZlID0gdHJlZV9yZW1vdmU7XG50cmVlUHJvdG8ucmVtb3ZlQWxsID0gcmVtb3ZlQWxsO1xudHJlZVByb3RvLnJvb3QgPSB0cmVlX3Jvb3Q7XG50cmVlUHJvdG8uc2l6ZSA9IHRyZWVfc2l6ZTtcbnRyZWVQcm90by52aXNpdCA9IHRyZWVfdmlzaXQ7XG50cmVlUHJvdG8udmlzaXRBZnRlciA9IHRyZWVfdmlzaXRBZnRlcjtcbnRyZWVQcm90by54ID0gdHJlZV94O1xudHJlZVByb3RvLnkgPSB0cmVlX3k7XG5cbmV4cG9ydHMucXVhZHRyZWUgPSBxdWFkdHJlZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kYXQgPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX19fJGluc2VydFN0eWxlKGNzcykge1xuICBpZiAoIWNzcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICBzdHlsZS5pbm5lckhUTUwgPSBjc3M7XG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXG4gIHJldHVybiBjc3M7XG59XG5cbmZ1bmN0aW9uIGNvbG9yVG9TdHJpbmcgKGNvbG9yLCBmb3JjZUNTU0hleCkge1xuICB2YXIgY29sb3JGb3JtYXQgPSBjb2xvci5fX3N0YXRlLmNvbnZlcnNpb25OYW1lLnRvU3RyaW5nKCk7XG4gIHZhciByID0gTWF0aC5yb3VuZChjb2xvci5yKTtcbiAgdmFyIGcgPSBNYXRoLnJvdW5kKGNvbG9yLmcpO1xuICB2YXIgYiA9IE1hdGgucm91bmQoY29sb3IuYik7XG4gIHZhciBhID0gY29sb3IuYTtcbiAgdmFyIGggPSBNYXRoLnJvdW5kKGNvbG9yLmgpO1xuICB2YXIgcyA9IGNvbG9yLnMudG9GaXhlZCgxKTtcbiAgdmFyIHYgPSBjb2xvci52LnRvRml4ZWQoMSk7XG4gIGlmIChmb3JjZUNTU0hleCB8fCBjb2xvckZvcm1hdCA9PT0gJ1RIUkVFX0NIQVJfSEVYJyB8fCBjb2xvckZvcm1hdCA9PT0gJ1NJWF9DSEFSX0hFWCcpIHtcbiAgICB2YXIgc3RyID0gY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDYpIHtcbiAgICAgIHN0ciA9ICcwJyArIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuICcjJyArIHN0cjtcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0NTU19SR0InKSB7XG4gICAgcmV0dXJuICdyZ2IoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcpJztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0NTU19SR0JBJykge1xuICAgIHJldHVybiAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hFWCcpIHtcbiAgICByZXR1cm4gJzB4JyArIGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdSR0JfQVJSQVknKSB7XG4gICAgcmV0dXJuICdbJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICddJztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQkFfQVJSQVknKSB7XG4gICAgcmV0dXJuICdbJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnXSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdSR0JfT0JKJykge1xuICAgIHJldHVybiAne3I6JyArIHIgKyAnLGc6JyArIGcgKyAnLGI6JyArIGIgKyAnfSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdSR0JBX09CSicpIHtcbiAgICByZXR1cm4gJ3tyOicgKyByICsgJyxnOicgKyBnICsgJyxiOicgKyBiICsgJyxhOicgKyBhICsgJ30nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnSFNWX09CSicpIHtcbiAgICByZXR1cm4gJ3toOicgKyBoICsgJyxzOicgKyBzICsgJyx2OicgKyB2ICsgJ30nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnSFNWQV9PQkonKSB7XG4gICAgcmV0dXJuICd7aDonICsgaCArICcsczonICsgcyArICcsdjonICsgdiArICcsYTonICsgYSArICd9JztcbiAgfVxuICByZXR1cm4gJ3Vua25vd24gZm9ybWF0Jztcbn1cblxudmFyIEFSUl9FQUNIID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG52YXIgQVJSX1NMSUNFID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIENvbW1vbiA9IHtcbiAgQlJFQUs6IHt9LFxuICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQpIHtcbiAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIGtleXMgPSB0aGlzLmlzT2JqZWN0KG9iaikgPyBPYmplY3Qua2V5cyhvYmopIDogW107XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNVbmRlZmluZWQob2JqW2tleV0pKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0KSB7XG4gICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5pc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuICBjb21wb3NlOiBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgIHZhciB0b0NhbGwgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBmb3IgKHZhciBpID0gdG9DYWxsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3MgPSBbdG9DYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH07XG4gIH0sXG4gIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqLCBpdHIsIHNjb3BlKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFSUl9FQUNIICYmIG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBBUlJfRUFDSCkge1xuICAgICAgb2JqLmZvckVhY2goaXRyLCBzY29wZSk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSBvYmoubGVuZ3RoICsgMCkge1xuICAgICAgdmFyIGtleSA9IHZvaWQgMDtcbiAgICAgIHZhciBsID0gdm9pZCAwO1xuICAgICAgZm9yIChrZXkgPSAwLCBsID0gb2JqLmxlbmd0aDsga2V5IDwgbDsga2V5KyspIHtcbiAgICAgICAgaWYgKGtleSBpbiBvYmogJiYgaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIF9rZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChpdHIuY2FsbChzY29wZSwgb2JqW19rZXldLCBfa2V5KSA9PT0gdGhpcy5CUkVBSykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVmZXI6IGZ1bmN0aW9uIGRlZmVyKGZuYykge1xuICAgIHNldFRpbWVvdXQoZm5jLCAwKTtcbiAgfSxcbiAgZGVib3VuY2U6IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHRocmVzaG9sZCwgY2FsbEltbWVkaWF0ZWx5KSB7XG4gICAgdmFyIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBmdW5jdGlvbiBkZWxheWVkKCkge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFjYWxsSW1tZWRpYXRlbHkpIGZ1bmMuYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWxsTm93ID0gY2FsbEltbWVkaWF0ZWx5IHx8ICF0aW1lb3V0O1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZGVsYXllZCwgdGhyZXNob2xkKTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIGZ1bmMuYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIGlmIChvYmoudG9BcnJheSkgcmV0dXJuIG9iai50b0FycmF5KCk7XG4gICAgcmV0dXJuIEFSUl9TTElDRS5jYWxsKG9iaik7XG4gIH0sXG4gIGlzVW5kZWZpbmVkOiBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24gaXNOdWxsKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH0sXG4gIGlzTmFOOiBmdW5jdGlvbiAoX2lzTmFOKSB7XG4gICAgZnVuY3Rpb24gaXNOYU4oX3gpIHtcbiAgICAgIHJldHVybiBfaXNOYU4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaXNOYU4udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2lzTmFOLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gaXNOYU47XG4gIH0oZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBpc05hTihvYmopO1xuICB9KSxcbiAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfSxcbiAgaXNOdW1iZXI6IGZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG9iaiArIDA7XG4gIH0sXG4gIGlzU3RyaW5nOiBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBvYmogKyAnJztcbiAgfSxcbiAgaXNCb29sZWFuOiBmdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSB0cnVlO1xuICB9LFxuICBpc0Z1bmN0aW9uOiBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfVxufTtcblxudmFyIElOVEVSUFJFVEFUSU9OUyA9IFtcbntcbiAgbGl0bXVzOiBDb21tb24uaXNTdHJpbmcsXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgVEhSRUVfQ0hBUl9IRVg6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV0pKFtBLUYwLTldKShbQS1GMC05XSkkL2kpO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCkgKyB0ZXN0WzFdLnRvU3RyaW5nKCkgKyB0ZXN0WzJdLnRvU3RyaW5nKCkgKyB0ZXN0WzJdLnRvU3RyaW5nKCkgKyB0ZXN0WzNdLnRvU3RyaW5nKCkgKyB0ZXN0WzNdLnRvU3RyaW5nKCksIDApXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGNvbG9yVG9TdHJpbmdcbiAgICB9LFxuICAgIFNJWF9DSEFSX0hFWDoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XXs2fSkkL2kpO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCksIDApXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGNvbG9yVG9TdHJpbmdcbiAgICB9LFxuICAgIENTU19SR0I6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGNvbG9yVG9TdHJpbmdcbiAgICB9LFxuICAgIENTU19SR0JBOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JhXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNOdW1iZXIsXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc0FycmF5LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQl9BUlJBWToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICB9XG4gICAgfSxcbiAgICBSR0JBX0FSUkFZOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT09IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzT2JqZWN0LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQkFfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFJHQl9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZBX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufV07XG52YXIgcmVzdWx0ID0gdm9pZCAwO1xudmFyIHRvUmV0dXJuID0gdm9pZCAwO1xudmFyIGludGVycHJldCA9IGZ1bmN0aW9uIGludGVycHJldCgpIHtcbiAgdG9SZXR1cm4gPSBmYWxzZTtcbiAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBDb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuICBDb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcbiAgICAgIENvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24gKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG4gICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICByZXR1cm4gQ29tbW9uLkJSRUFLO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21tb24uQlJFQUs7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufTtcblxudmFyIHRtcENvbXBvbmVudCA9IHZvaWQgMDtcbnZhciBDb2xvck1hdGggPSB7XG4gIGhzdl90b19yZ2I6IGZ1bmN0aW9uIGhzdl90b19yZ2IoaCwgcywgdikge1xuICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG4gICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgIHZhciBxID0gdiAqICgxLjAgLSBmICogcyk7XG4gICAgdmFyIHQgPSB2ICogKDEuMCAtICgxLjAgLSBmKSAqIHMpO1xuICAgIHZhciBjID0gW1t2LCB0LCBwXSwgW3EsIHYsIHBdLCBbcCwgdiwgdF0sIFtwLCBxLCB2XSwgW3QsIHAsIHZdLCBbdiwgcCwgcV1dW2hpXTtcbiAgICByZXR1cm4ge1xuICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICBiOiBjWzJdICogMjU1XG4gICAgfTtcbiAgfSxcbiAgcmdiX3RvX2hzdjogZnVuY3Rpb24gcmdiX3RvX2hzdihyLCBnLCBiKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgdmFyIGggPSB2b2lkIDA7XG4gICAgdmFyIHMgPSB2b2lkIDA7XG4gICAgaWYgKG1heCAhPT0gMCkge1xuICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBOYU4sXG4gICAgICAgIHM6IDAsXG4gICAgICAgIHY6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChyID09PSBtYXgpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICB9XG4gICAgaCAvPSA2O1xuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaDogaCAqIDM2MCxcbiAgICAgIHM6IHMsXG4gICAgICB2OiBtYXggLyAyNTVcbiAgICB9O1xuICB9LFxuICByZ2JfdG9faGV4OiBmdW5jdGlvbiByZ2JfdG9faGV4KHIsIGcsIGIpIHtcbiAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgIHJldHVybiBoZXg7XG4gIH0sXG4gIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24gY29tcG9uZW50X2Zyb21faGV4KGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICByZXR1cm4gaGV4ID4+IGNvbXBvbmVudEluZGV4ICogOCAmIDB4RkY7XG4gIH0sXG4gIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24gaGV4X3dpdGhfY29tcG9uZW50KGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgaGV4ICYgfigweEZGIDw8IHRtcENvbXBvbmVudCk7XG4gIH1cbn07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbG9yKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yKTtcbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29sb3IsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBjb2xvclRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSGV4U3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXhTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gY29sb3JUb1N0cmluZyh0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b09yaWdpbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PcmlnaW5hbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbG9yO1xufSgpO1xuZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgIH1cbiAgICAgIENvbG9yLnJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICB9XG4gICAgICBDb2xvci5yZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgIENvbG9yLnJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcbiAgICB9XG4gIH0pO1xufVxuQ29sb3IucmVjYWxjdWxhdGVSR0IgPSBmdW5jdGlvbiAoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcbiAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG4gICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gQ29sb3JNYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG4gICAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBDb2xvck1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3JydXB0ZWQgY29sb3Igc3RhdGUnKTtcbiAgfVxufTtcbkNvbG9yLnJlY2FsY3VsYXRlSFNWID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHZhciByZXN1bHQgPSBDb2xvck1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCB7XG4gICAgczogcmVzdWx0LnMsXG4gICAgdjogcmVzdWx0LnZcbiAgfSk7XG4gIGlmICghQ29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICB9IGVsc2UgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgfVxufTtcbkNvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCAnZycsICdiJywgJ2gnLCAncycsICd2JywgJ2hleCcsICdhJ107XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgIGlmICghdGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IENvbG9yTWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmhleDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIRVgnO1xuICAgIHRoaXMuX19zdGF0ZS5oZXggPSB2O1xuICB9XG59KTtcblxudmFyIENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyb2xsZXIpO1xuICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgdGhpcy5fX29uQ2hhbmdlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ29uQ2hhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2UoZm5jKSB7XG4gICAgICB0aGlzLl9fb25DaGFuZ2UgPSBmbmM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZpbmlzaENoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRmluaXNoQ2hhbmdlKGZuYykge1xuICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gZm5jO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcywgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNNb2RpZmllZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTW9kaWZpZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWUgIT09IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbnRyb2xsZXI7XG59KCk7XG5cbnZhciBFVkVOVF9NQVAgPSB7XG4gIEhUTUxFdmVudHM6IFsnY2hhbmdlJ10sXG4gIE1vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ21vdXNlbW92ZScsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZW92ZXInXSxcbiAgS2V5Ym9hcmRFdmVudHM6IFsna2V5ZG93biddXG59O1xudmFyIEVWRU5UX01BUF9JTlYgPSB7fTtcbkNvbW1vbi5lYWNoKEVWRU5UX01BUCwgZnVuY3Rpb24gKHYsIGspIHtcbiAgQ29tbW9uLmVhY2godiwgZnVuY3Rpb24gKGUpIHtcbiAgICBFVkVOVF9NQVBfSU5WW2VdID0gaztcbiAgfSk7XG59KTtcbnZhciBDU1NfVkFMVUVfUElYRUxTID0gLyhcXGQrKFxcLlxcZCspPylweC87XG5mdW5jdGlvbiBjc3NWYWx1ZVRvUGl4ZWxzKHZhbCkge1xuICBpZiAodmFsID09PSAnMCcgfHwgQ29tbW9uLmlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goQ1NTX1ZBTFVFX1BJWEVMUyk7XG4gIGlmICghQ29tbW9uLmlzTnVsbChtYXRjaCkpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgZG9tID0ge1xuICBtYWtlU2VsZWN0YWJsZTogZnVuY3Rpb24gbWFrZVNlbGVjdGFibGUoZWxlbSwgc2VsZWN0YWJsZSkge1xuICAgIGlmIChlbGVtID09PSB1bmRlZmluZWQgfHwgZWxlbS5zdHlsZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgZWxlbS5vbnNlbGVjdHN0YXJ0ID0gc2VsZWN0YWJsZSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IDogZnVuY3Rpb24gKCkge307XG4gICAgZWxlbS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICBlbGVtLnN0eWxlLktodG1sVXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgZWxlbS51bnNlbGVjdGFibGUgPSBzZWxlY3RhYmxlID8gJ29uJyA6ICdvZmYnO1xuICB9LFxuICBtYWtlRnVsbHNjcmVlbjogZnVuY3Rpb24gbWFrZUZ1bGxzY3JlZW4oZWxlbSwgaG9yLCB2ZXJ0KSB7XG4gICAgdmFyIHZlcnRpY2FsID0gdmVydDtcbiAgICB2YXIgaG9yaXpvbnRhbCA9IGhvcjtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKGhvcml6b250YWwpKSB7XG4gICAgICBob3Jpem9udGFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZCh2ZXJ0aWNhbCkpIHtcbiAgICAgIHZlcnRpY2FsID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgIGVsZW0uc3R5bGUubGVmdCA9IDA7XG4gICAgICBlbGVtLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBlbGVtLnN0eWxlLnRvcCA9IDA7XG4gICAgICBlbGVtLnN0eWxlLmJvdHRvbSA9IDA7XG4gICAgfVxuICB9LFxuICBmYWtlRXZlbnQ6IGZ1bmN0aW9uIGZha2VFdmVudChlbGVtLCBldmVudFR5cGUsIHBhcnMsIGF1eCkge1xuICAgIHZhciBwYXJhbXMgPSBwYXJzIHx8IHt9O1xuICAgIHZhciBjbGFzc05hbWUgPSBFVkVOVF9NQVBfSU5WW2V2ZW50VHlwZV07XG4gICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgdHlwZSAnICsgZXZlbnRUeXBlICsgJyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoY2xhc3NOYW1lKTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgY2FzZSAnTW91c2VFdmVudHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNsaWVudFggPSBwYXJhbXMueCB8fCBwYXJhbXMuY2xpZW50WCB8fCAwO1xuICAgICAgICAgIHZhciBjbGllbnRZID0gcGFyYW1zLnkgfHwgcGFyYW1zLmNsaWVudFkgfHwgMDtcbiAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSwgd2luZG93LCBwYXJhbXMuY2xpY2tDb3VudCB8fCAxLCAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZLFxuICAgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnS2V5Ym9hcmRFdmVudHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluaXQgPSBldnQuaW5pdEtleWJvYXJkRXZlbnQgfHwgZXZ0LmluaXRLZXlFdmVudDtcbiAgICAgICAgICBDb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICBrZXlDb2RlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFyQ29kZTogdW5kZWZpbmVkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5pdChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSwgd2luZG93LCBwYXJhbXMuY3RybEtleSwgcGFyYW1zLmFsdEtleSwgcGFyYW1zLnNoaWZ0S2V5LCBwYXJhbXMubWV0YUtleSwgcGFyYW1zLmtleUNvZGUsIHBhcmFtcy5jaGFyQ29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbW1vbi5kZWZhdWx0cyhldnQsIGF1eCk7XG4gICAgZWxlbS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH0sXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoZWxlbSwgZXZlbnQsIGZ1bmMsIG5ld0Jvb2wpIHtcbiAgICB2YXIgYm9vbCA9IG5ld0Jvb2wgfHwgZmFsc2U7XG4gICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWxlbSwgZXZlbnQsIGZ1bmMsIG5ld0Jvb2wpIHtcbiAgICB2YXIgYm9vbCA9IG5ld0Jvb2wgfHwgZmFsc2U7XG4gICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uY2xhc3NOYW1lICE9PSBjbGFzc05hbWUpIHtcbiAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT09IC0xKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSBjbGFzc05hbWUpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uY2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJyg/Ol58XFxcXHMrKScgKyBjbGFzc05hbWUgKyAnKD86XFxcXHMrfCQpJykudGVzdChlbGVtLmNsYXNzTmFtZSkgfHwgZmFsc2U7XG4gIH0sXG4gIGdldFdpZHRoOiBmdW5jdGlvbiBnZXRXaWR0aChlbGVtKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWxlZnQtd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItcmlnaHQtd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWxlZnQnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXJpZ2h0J10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZS53aWR0aCk7XG4gIH0sXG4gIGdldEhlaWdodDogZnVuY3Rpb24gZ2V0SGVpZ2h0KGVsZW0pIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItdG9wLXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWJvdHRvbS13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctdG9wJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1ib3R0b20nXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlLmhlaWdodCk7XG4gIH0sXG4gIGdldE9mZnNldDogZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gICAgdmFyIGVsZW0gPSBlbDtcbiAgICB2YXIgb2Zmc2V0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcbiAgICBpZiAoZWxlbS5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgb2Zmc2V0LmxlZnQgKz0gZWxlbS5vZmZzZXRMZWZ0O1xuICAgICAgICBvZmZzZXQudG9wICs9IGVsZW0ub2Zmc2V0VG9wO1xuICAgICAgICBlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQ7XG4gICAgICB9IHdoaWxlIChlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfSxcbiAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoZWxlbS50eXBlIHx8IGVsZW0uaHJlZik7XG4gIH1cbn07XG5cbnZhciBCb29sZWFuQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhCb29sZWFuQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQm9vbGVhbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCb29sZWFuQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX3ByZXYgPSBfdGhpczIuZ2V0VmFsdWUoKTtcbiAgICBfdGhpczIuX19jaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZSghX3RoaXMuX19wcmV2KTtcbiAgICB9XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fY2hlY2tib3gsICdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2NoZWNrYm94KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQm9vbGVhbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgdG9SZXR1cm4gPSBnZXQoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3NldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCB2KTtcbiAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19wcmV2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9fcHJldiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fcHJldiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldChCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb29sZWFuQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbnZhciBPcHRpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKE9wdGlvbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gT3B0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBvcHRzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgT3B0aW9uQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE9wdGlvbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBpZiAoQ29tbW9uLmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgIENvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIG1hcFtlbGVtZW50XSA9IGVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnMgPSBtYXA7XG4gICAgfVxuICAgIENvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICBvcHQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgICBfdGhpcy5fX3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICAgIH0pO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRlc2lyZWRWYWx1ZSA9IHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoZGVzaXJlZFZhbHVlKTtcbiAgICB9KTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19zZWxlY3QpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoT3B0aW9uQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHYpIHtcbiAgICAgIHZhciB0b1JldHVybiA9IGdldChPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3NldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCB2KTtcbiAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIGlmIChkb20uaXNBY3RpdmUodGhpcy5fX3NlbGVjdCkpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy5fX3NlbGVjdC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiBnZXQoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9wdGlvbkNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG52YXIgU3RyaW5nQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhTdHJpbmdDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmluZ0NvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTdHJpbmdDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RyaW5nQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleXVwJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoU3RyaW5nQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIGlmICghZG9tLmlzQWN0aXZlKHRoaXMuX19pbnB1dCkpIHtcbiAgICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldChTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ0NvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RyaW5nQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbmZ1bmN0aW9uIG51bURlY2ltYWxzKHgpIHtcbiAgdmFyIF94ID0geC50b1N0cmluZygpO1xuICBpZiAoX3guaW5kZXhPZignLicpID4gLTEpIHtcbiAgICByZXR1cm4gX3gubGVuZ3RoIC0gX3guaW5kZXhPZignLicpIC0gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBOdW1iZXJDb250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKE51bWJlckNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gTnVtYmVyQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOdW1iZXJDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIF90aGlzLl9fbWluID0gX3BhcmFtcy5taW47XG4gICAgX3RoaXMuX19tYXggPSBfcGFyYW1zLm1heDtcbiAgICBfdGhpcy5fX3N0ZXAgPSBfcGFyYW1zLnN0ZXA7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChfdGhpcy5fX3N0ZXApKSB7XG4gICAgICBpZiAoX3RoaXMuaW5pdGlhbFZhbHVlID09PSAwKSB7XG4gICAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKF90aGlzLmluaXRpYWxWYWx1ZSkpIC8gTWF0aC5MTjEwKSkgLyAxMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IF90aGlzLl9fc3RlcDtcbiAgICB9XG4gICAgX3RoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyhfdGhpcy5fX2ltcGxpZWRTdGVwKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoTnVtYmVyQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHYpIHtcbiAgICAgIHZhciBfdiA9IHY7XG4gICAgICBpZiAodGhpcy5fX21pbiAhPT0gdW5kZWZpbmVkICYmIF92IDwgdGhpcy5fX21pbikge1xuICAgICAgICBfdiA9IHRoaXMuX19taW47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX19tYXggIT09IHVuZGVmaW5lZCAmJiBfdiA+IHRoaXMuX19tYXgpIHtcbiAgICAgICAgX3YgPSB0aGlzLl9fbWF4O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19zdGVwICE9PSB1bmRlZmluZWQgJiYgX3YgJSB0aGlzLl9fc3RlcCAhPT0gMCkge1xuICAgICAgICBfdiA9IE1hdGgucm91bmQoX3YgLyB0aGlzLl9fc3RlcCkgKiB0aGlzLl9fc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgX3YpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21pbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbihtaW5WYWx1ZSkge1xuICAgICAgdGhpcy5fX21pbiA9IG1pblZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWF4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4KG1heFZhbHVlKSB7XG4gICAgICB0aGlzLl9fbWF4ID0gbWF4VmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcChzdGVwVmFsdWUpIHtcbiAgICAgIHRoaXMuX19zdGVwID0gc3RlcFZhbHVlO1xuICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gc3RlcFZhbHVlO1xuICAgICAgdGhpcy5fX3ByZWNpc2lvbiA9IG51bURlY2ltYWxzKHN0ZXBWYWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiByb3VuZFRvRGVjaW1hbCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgdmFyIHRlblRvID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiB0ZW5UbykgLyB0ZW5Ubztcbn1cbnZhciBOdW1iZXJDb250cm9sbGVyQm94ID0gZnVuY3Rpb24gKF9OdW1iZXJDb250cm9sbGVyKSB7XG4gIGluaGVyaXRzKE51bWJlckNvbnRyb2xsZXJCb3gsIF9OdW1iZXJDb250cm9sbGVyKTtcbiAgZnVuY3Rpb24gTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyQm94KTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlckJveC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJCb3gpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykpO1xuICAgIF90aGlzMi5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgdmFyIHByZXZZID0gdm9pZCAwO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgdmFyIGF0dGVtcHRlZCA9IHBhcnNlRmxvYXQoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgICBpZiAoIUNvbW1vbi5pc05hTihhdHRlbXB0ZWQpKSB7XG4gICAgICAgIF90aGlzLnNldFZhbHVlKGF0dGVtcHRlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRmluaXNoKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuICAgICAgdmFyIGRpZmYgPSBwcmV2WSAtIGUuY2xpZW50WTtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLmdldFZhbHVlKCkgKyBkaWZmICogX3RoaXMuX19pbXBsaWVkU3RlcCk7XG4gICAgICBwcmV2WSA9IGUuY2xpZW50WTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBwcmV2WSA9IGUuY2xpZW50WTtcbiAgICB9XG4gICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuICAgICAgICBvbkZpbmlzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoTnVtYmVyQ29udHJvbGxlckJveCwgW3tcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID8gdGhpcy5nZXRWYWx1ZSgpIDogcm91bmRUb0RlY2ltYWwodGhpcy5nZXRWYWx1ZSgpLCB0aGlzLl9fcHJlY2lzaW9uKTtcbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyQm94LnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJCb3g7XG59KE51bWJlckNvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiBtYXAodiwgaTEsIGkyLCBvMSwgbzIpIHtcbiAgcmV0dXJuIG8xICsgKG8yIC0gbzEpICogKCh2IC0gaTEpIC8gKGkyIC0gaTEpKTtcbn1cbnZhciBOdW1iZXJDb250cm9sbGVyU2xpZGVyID0gZnVuY3Rpb24gKF9OdW1iZXJDb250cm9sbGVyKSB7XG4gIGluaGVyaXRzKE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIF9OdW1iZXJDb250cm9sbGVyKTtcbiAgZnVuY3Rpb24gTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBtaW4sIG1heCwgc3RlcCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOdW1iZXJDb250cm9sbGVyU2xpZGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlclNsaWRlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IHN0ZXAgfSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2JhY2tncm91bmQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19iYWNrZ3JvdW5kLCAnc2xpZGVyJyk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2ZvcmVncm91bmQsICdzbGlkZXItZmcnKTtcbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgb25Nb3VzZURyYWcoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBiZ1JlY3QgPSBfdGhpcy5fX2JhY2tncm91bmQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShtYXAoZS5jbGllbnRYLCBiZ1JlY3QubGVmdCwgYmdSZWN0LnJpZ2h0LCBfdGhpcy5fX21pbiwgX3RoaXMuX19tYXgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgICBvblRvdWNoTW92ZShlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xuICAgICAgdmFyIGNsaWVudFggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgIHZhciBiZ1JlY3QgPSBfdGhpcy5fX2JhY2tncm91bmQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShtYXAoY2xpZW50WCwgYmdSZWN0LmxlZnQsIGJnUmVjdC5yaWdodCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgX3RoaXMyLl9fYmFja2dyb3VuZC5hcHBlbmRDaGlsZChfdGhpczIuX19mb3JlZ3JvdW5kKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19iYWNrZ3JvdW5kKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB2YXIgcGN0ID0gKHRoaXMuZ2V0VmFsdWUoKSAtIHRoaXMuX19taW4pIC8gKHRoaXMuX19tYXggLSB0aGlzLl9fbWluKTtcbiAgICAgIHRoaXMuX19mb3JlZ3JvdW5kLnN0eWxlLndpZHRoID0gcGN0ICogMTAwICsgJyUnO1xuICAgICAgcmV0dXJuIGdldChOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJTbGlkZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlclNsaWRlcjtcbn0oTnVtYmVyQ29udHJvbGxlcik7XG5cbnZhciBGdW5jdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoRnVuY3Rpb25Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIEZ1bmN0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCB0ZXh0KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVuY3Rpb25Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRnVuY3Rpb25Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnVuY3Rpb25Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX2J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2J1dHRvbi5pbm5lckhUTUwgPSB0ZXh0ID09PSB1bmRlZmluZWQgPyAnRmlyZScgOiB0ZXh0O1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2J1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmZpcmUoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fYnV0dG9uLCAnYnV0dG9uJyk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fYnV0dG9uKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKEZ1bmN0aW9uQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdmaXJlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmdldFZhbHVlKCkuY2FsbCh0aGlzLm9iamVjdCk7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGdW5jdGlvbkNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG52YXIgQ29sb3JDb250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKENvbG9yQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBDb2xvckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbG9yQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIF90aGlzMi5fX2NvbG9yID0gbmV3IENvbG9yKF90aGlzMi5nZXRWYWx1ZSgpKTtcbiAgICBfdGhpczIuX190ZW1wID0gbmV3IENvbG9yKDApO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5tYWtlU2VsZWN0YWJsZShfdGhpczIuZG9tRWxlbWVudCwgZmFsc2UpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuY2xhc3NOYW1lID0gJ3NlbGVjdG9yJztcbiAgICBfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5jbGFzc05hbWUgPSAnc2F0dXJhdGlvbi1maWVsZCc7XG4gICAgX3RoaXMyLl9fZmllbGRfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2ZpZWxkX2tub2IuY2xhc3NOYW1lID0gJ2ZpZWxkLWtub2InO1xuICAgIF90aGlzMi5fX2ZpZWxkX2tub2JfYm9yZGVyID0gJzJweCBzb2xpZCAnO1xuICAgIF90aGlzMi5fX2h1ZV9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9faHVlX2tub2IuY2xhc3NOYW1lID0gJ2h1ZS1rbm9iJztcbiAgICBfdGhpczIuX19odWVfZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19odWVfZmllbGQuY2xhc3NOYW1lID0gJ2h1ZS1maWVsZCc7XG4gICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2lucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgX3RoaXMyLl9faW5wdXRfdGV4dFNoYWRvdyA9ICcwIDFweCAxcHggJztcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgb25CbHVyLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zZWxlY3RvciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpICAgICAgICB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiAoKSAgICAgICAge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX19zZWxlY3RvciwgJ2RyYWcnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdG9yLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpICAgICAgICB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZnVuY3Rpb24gKCkgICAgICAgIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgdmFsdWVGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2VsZWN0b3Iuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTIycHgnLFxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxuICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMnB4JyxcbiAgICAgIGhlaWdodDogJzEycHgnLFxuICAgICAgYm9yZGVyOiBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciArIChfdGhpczIuX19jb2xvci52IDwgMC41ID8gJyNmZmYnIDogJyMwMDAnKSxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBtYXJnaW5SaWdodDogJzNweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZCh2YWx1ZUZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICB9KTtcbiAgICBsaW5lYXJHcmFkaWVudCh2YWx1ZUZpZWxkLCAndG9wJywgJ3JnYmEoMCwwLDAsMCknLCAnIzAwMCcpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnM3B4JyxcbiAgICAgIHJpZ2h0OiAnM3B4J1xuICAgIH0pO1xuICAgIGh1ZUdyYWRpZW50KF90aGlzMi5fX2h1ZV9maWVsZCk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19pbnB1dC5zdHlsZSwge1xuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICB0ZXh0U2hhZG93OiBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bkgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd25IKTtcbiAgICBmdW5jdGlvbiBmaWVsZERvd24oZSkge1xuICAgICAgc2V0U1YoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGREb3duSChlKSB7XG4gICAgICBzZXRIKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBIKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGRVcFNWKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkVXBIKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcEgpO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy52YWx1ZSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5hcHBlbmRDaGlsZCh2YWx1ZUZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19maWVsZF9rbm9iKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfZmllbGQpO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfa25vYik7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdG9yKTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGZ1bmN0aW9uIHNldFNWKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBfcmVmID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgICAgIHZhciBzID0gKGNsaWVudFggLSBmaWVsZFJlY3QubGVmdCkgLyAoZmllbGRSZWN0LnJpZ2h0IC0gZmllbGRSZWN0LmxlZnQpO1xuICAgICAgdmFyIHYgPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAodiA+IDEpIHtcbiAgICAgICAgdiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHMgPiAxKSB7XG4gICAgICAgIHMgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzIDwgMCkge1xuICAgICAgICBzID0gMDtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XG4gICAgICBfdGhpcy5fX2NvbG9yLnMgPSBzO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRIKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9faHVlX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIF9yZWYyID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmMi5jbGllbnRZO1xuICAgICAgdmFyIGggPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgaCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGggPCAwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfVxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb2xvckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuICAgICAgICBDb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQoaVtjb21wb25lbnRdKSAmJiAhQ29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pICYmIGlbY29tcG9uZW50XSAhPT0gdGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX190ZW1wLl9fc3RhdGUsIHRoaXMuX19jb2xvci5fX3N0YXRlKTtcbiAgICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuICAgICAgdmFyIGZsaXAgPSB0aGlzLl9fY29sb3IudiA8IDAuNSB8fCB0aGlzLl9fY29sb3IucyA+IDAuNSA/IDI1NSA6IDA7XG4gICAgICB2YXIgX2ZsaXAgPSAyNTUgLSBmbGlwO1xuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuICAgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcCA9ICgxIC0gdGhpcy5fX2NvbG9yLmggLyAzNjApICogMTAwICsgJ3B4JztcbiAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xuICAgICAgdGhpcy5fX3RlbXAudiA9IDE7XG4gICAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCkpO1xuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19jb2xvci50b0hleFN0cmluZygpLFxuICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknLFxuICAgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLC43KSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3JDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcbnZhciB2ZW5kb3JzID0gWyctbW96LScsICctby0nLCAnLXdlYmtpdC0nLCAnLW1zLScsICcnXTtcbmZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KGVsZW0sIHgsIGEsIGIpIHtcbiAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gIENvbW1vbi5lYWNoKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3IpIHtcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcgKyB4ICsgJywgJyArIGEgKyAnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG4gIH0pO1xufVxuZnVuY3Rpb24gaHVlR3JhZGllbnQoZWxlbSkge1xuICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCAjZmYwMGZmIDE3JSwgIzAwMDBmZiAzNCUsICMwMGZmZmYgNTAlLCAjMDBmZjAwIDY3JSwgI2ZmZmYwMCA4NCUsICNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG59XG5cbnZhciBjc3MgPSB7XG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQodXJsLCBpbmRvYykge1xuICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcbiAgICB2YXIgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcbiAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gIH0sXG4gIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KGNzc0NvbnRlbnQsIGluZG9jKSB7XG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xuICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaW5qZWN0ZWQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzQ29udGVudDtcbiAgICB2YXIgaGVhZCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHRyeSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKGluamVjdGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2F2ZURpYWxvZ0NvbnRlbnRzID0gXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuXFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCI7XG5cbnZhciBDb250cm9sbGVyRmFjdG9yeSA9IGZ1bmN0aW9uIENvbnRyb2xsZXJGYWN0b3J5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gIGlmIChDb21tb24uaXNBcnJheShhcmd1bWVudHNbMl0pIHx8IENvbW1vbi5pc09iamVjdChhcmd1bWVudHNbMl0pKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbM10pKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICB9XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbNF0pKSB7XG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10sIHN0ZXA6IGFyZ3VtZW50c1s0XSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdIH0pO1xuICB9XG4gIGlmIChDb21tb24uaXNTdHJpbmcoaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzRnVuY3Rpb24oaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksICcnKTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzQm9vbGVhbihpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xufVxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxudmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZW50ZXJlZERpdigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50ZXJlZERpdik7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcicsXG4gICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcbiAgICBkb20ubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInLFxuICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZG9tLmJpbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENlbnRlcmVkRGl2LCBbe1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgICAgdGhpcy5sYXlvdXQoKTtcbiAgICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaWRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICB9O1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xheW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGggLyAyIC0gZG9tLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDZW50ZXJlZERpdjtcbn0oKTtcblxudmFyIHN0eWxlU2hlZXQgPSBfX18kaW5zZXJ0U3R5bGUoXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7Ym9yZGVyOjA7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS1ib3R0b217cG9zaXRpb246YWJzb2x1dGV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteTp2aXNpYmxlfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLXRvcHttYXJnaW4tdG9wOjB9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtYm90dG9te21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3t0b3A6MDt6LWluZGV4OjEwMDJ9LmRnLmEgLnNhdmUtcm93LmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtYm90dG9te3Bvc2l0aW9uOmZpeGVkfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy13ZWJraXQtdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXJ9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGk+KntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVufS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3tmbG9hdDpsZWZ0O3dpZHRoOjYwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtib3JkZXI6MDttYXJnaW4tdG9wOjRweDtwYWRkaW5nOjNweDt3aWR0aDoxMDAlO2Zsb2F0OnJpZ2h0fS5kZyAuaGFzLXNsaWRlciBpbnB1dFt0eXBlPXRleHRde3dpZHRoOjMwJTttYXJnaW4tbGVmdDowfS5kZyAuc2xpZGVye2Zsb2F0OmxlZnQ7d2lkdGg6NjYlO21hcmdpbi1sZWZ0Oi01cHg7bWFyZ2luLXJpZ2h0OjA7aGVpZ2h0OjE5cHg7bWFyZ2luLXRvcDo0cHh9LmRnIC5zbGlkZXItZmd7aGVpZ2h0OjEwMCV9LmRnIC5jIGlucHV0W3R5cGU9Y2hlY2tib3hde21hcmdpbi10b3A6N3B4fS5kZyAuYyBzZWxlY3R7bWFyZ2luLXRvcDo1cHh9LmRnIC5jci5mdW5jdGlvbiwuZGcgLmNyLmZ1bmN0aW9uIC5wcm9wZXJ0eS1uYW1lLC5kZyAuY3IuZnVuY3Rpb24gKiwuZGcgLmNyLmJvb2xlYW4sLmRnIC5jci5ib29sZWFuICp7Y3Vyc29yOnBvaW50ZXJ9LmRnIC5jci5jb2xvcntvdmVyZmxvdzp2aXNpYmxlfS5kZyAuc2VsZWN0b3J7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbi1sZWZ0Oi05cHg7bWFyZ2luLXRvcDoyM3B4O3otaW5kZXg6MTB9LmRnIC5jOmhvdmVyIC5zZWxlY3RvciwuZGcgLnNlbGVjdG9yLmRyYWd7ZGlzcGxheTpibG9ja30uZGcgbGkuc2F2ZS1yb3d7cGFkZGluZzowfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MHB4IDZweH0uZGcuZGlhbG9ndWV7YmFja2dyb3VuZC1jb2xvcjojMjIyO3dpZHRoOjQ2MHB4O3BhZGRpbmc6MTVweDtmb250LXNpemU6MTNweDtsaW5lLWhlaWdodDoxNXB4fSNkZy1uZXctY29uc3RydWN0b3J7cGFkZGluZzoxMHB4O2NvbG9yOiMyMjI7Zm9udC1mYW1pbHk6TW9uYWNvLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHg7Ym9yZGVyOjA7cmVzaXplOm5vbmU7Ym94LXNoYWRvdzppbnNldCAxcHggMXB4IDFweCAjODg4O3dvcmQtd3JhcDpicmVhay13b3JkO21hcmdpbjoxMnB4IDA7ZGlzcGxheTpibG9jazt3aWR0aDo0NDBweDtvdmVyZmxvdy15OnNjcm9sbDtoZWlnaHQ6MTAwcHg7cG9zaXRpb246cmVsYXRpdmV9I2RnLWxvY2FsLWV4cGxhaW57ZGlzcGxheTpub25lO2ZvbnQtc2l6ZToxMXB4O2xpbmUtaGVpZ2h0OjE3cHg7Ym9yZGVyLXJhZGl1czozcHg7YmFja2dyb3VuZC1jb2xvcjojMzMzO3BhZGRpbmc6OHB4O21hcmdpbi10b3A6MTBweH0jZGctbG9jYWwtZXhwbGFpbiBjb2Rle2ZvbnQtc2l6ZToxMHB4fSNkYXQtZ3VpLXNhdmUtbG9jYWxseXtkaXNwbGF5Om5vbmV9LmRne2NvbG9yOiNlZWU7Zm9udDoxMXB4ICdMdWNpZGEgR3JhbmRlJywgc2Fucy1zZXJpZjt0ZXh0LXNoYWRvdzowIC0xcHggMCAjMTExfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDo1cHg7YmFja2dyb3VuZDojMWExYTFhfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXJ7aGVpZ2h0OjA7ZGlzcGxheTpub25lfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci10aHVtYntib3JkZXItcmFkaXVzOjVweDtiYWNrZ3JvdW5kOiM2NzY3Njd9LmRnIGxpOm5vdCguZm9sZGVyKXtiYWNrZ3JvdW5kOiMxYTFhMWE7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgIzJjMmMyY30uZGcgbGkuc2F2ZS1yb3d7bGluZS1oZWlnaHQ6MjVweDtiYWNrZ3JvdW5kOiNkYWQ1Y2I7Ym9yZGVyOjB9LmRnIGxpLnNhdmUtcm93IHNlbGVjdHttYXJnaW4tbGVmdDo1cHg7d2lkdGg6MTA4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b257bWFyZ2luLWxlZnQ6NXB4O21hcmdpbi10b3A6MXB4O2JvcmRlci1yYWRpdXM6MnB4O2ZvbnQtc2l6ZTo5cHg7bGluZS1oZWlnaHQ6N3B4O3BhZGRpbmc6NHB4IDRweCA1cHggNHB4O2JhY2tncm91bmQ6I2M1YmRhZDtjb2xvcjojZmZmO3RleHQtc2hhZG93OjAgMXB4IDAgI2IwYTU4Zjtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGY7Y3Vyc29yOnBvaW50ZXJ9LmRnIGxpLnNhdmUtcm93IC5idXR0b24uZ2VhcnN7YmFja2dyb3VuZDojYzViZGFkIHVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFzQUFBQU5DQVlBQUFCLzlaUTdBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQVFKSlJFRlVlTnBpWUtBVS9QLy9Qd0dJQy9BcENBQmlCU0FXK0k4QUNsQWNnS3hRNFQ5aG9NQUVVcnh4MlFTR042K2VnRFgrL3ZXVDRlN044MkFNWW9QQXgvZXZ3V29Zb1NZYkFDWDJzN0t4Q3h6Y3NlekRoM2V2Rm9ERUJZVEVFcXljZ2dXQXpBOUF1VVNRUWdlWVBhOWZQdjYvWVdtL0FjeDVJUGI3dHkvZncrUVpibHc2N3ZEczhSMFlIeVFoZ09ieCt5QUprQnFtRzVkUFBEaDFhUE9HUi9ldWdXMEc0dmxJb1RJZnlGY0ErUWVraGhISmhQZFF4YmlBSWd1TUJUUVpyUEQ3MTA4TTZyb1dZREZRaUlBQXY2QW93LzFiRndYZ2lzK2YyTFVBeW53b0lhTmN6OFhOeDNEbDdNRUpVREdRcHg5Z3RROFlDdWVCK0QyNk9FQ0FBUURhZHQ3ZTQ2RDQyUUFBQUFCSlJVNUVya0pnZ2c9PSkgMnB4IDFweCBuby1yZXBlYXQ7aGVpZ2h0OjdweDt3aWR0aDo4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojYmFiMTllO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4Zn0uZGcgbGkuZm9sZGVye2JvcmRlci1ib3R0b206MH0uZGcgbGkudGl0bGV7cGFkZGluZy1sZWZ0OjE2cHg7YmFja2dyb3VuZDojMDAwIHVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEkraEtnRnhvQ2dBT3c9PSkgNnB4IDEwcHggbm8tcmVwZWF0O2N1cnNvcjpwb2ludGVyO2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKX0uZGcgLmNsb3NlZCBsaS50aXRsZXtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEdJV3FNQ2JXQUVBT3c9PSl9LmRnIC5jci5ib29sZWFue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjODA2Nzg3fS5kZyAuY3IuY29sb3J7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkfS5kZyAuY3IuZnVuY3Rpb257Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICNlNjFkNWZ9LmRnIC5jci5udW1iZXJ7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMyRkExRDZ9LmRnIC5jci5udW1iZXIgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMkZBMUQ2fS5kZyAuY3Iuc3RyaW5ne2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMWVkMzZmfS5kZyAuY3Iuc3RyaW5nIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzFlZDM2Zn0uZGcgLmNyLmZ1bmN0aW9uOmhvdmVyLC5kZyAuY3IuYm9vbGVhbjpob3ZlcntiYWNrZ3JvdW5kOiMxMTF9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17YmFja2dyb3VuZDojMzAzMDMwO291dGxpbmU6bm9uZX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06Zm9jdXN7YmFja2dyb3VuZDojNDk0OTQ5O2NvbG9yOiNmZmZ9LmRnIC5jIC5zbGlkZXJ7YmFja2dyb3VuZDojMzAzMDMwO2N1cnNvcjpldy1yZXNpemV9LmRnIC5jIC5zbGlkZXItZmd7YmFja2dyb3VuZDojMkZBMUQ2O21heC13aWR0aDoxMDAlfS5kZyAuYyAuc2xpZGVyOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgLnNsaWRlcjpob3ZlciAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzQ0YWJkYX1cXG5cIik7XG5cbmNzcy5pbmplY3Qoc3R5bGVTaGVldCk7XG52YXIgQ1NTX05BTUVTUEFDRSA9ICdkZyc7XG52YXIgSElERV9LRVlfQ09ERSA9IDcyO1xudmFyIENMT1NFX0JVVFRPTl9IRUlHSFQgPSAyMDtcbnZhciBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgPSAnRGVmYXVsdCc7XG52YXIgU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISF3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KCk7XG52YXIgU0FWRV9ESUFMT0dVRSA9IHZvaWQgMDtcbnZhciBhdXRvUGxhY2VWaXJnaW4gPSB0cnVlO1xudmFyIGF1dG9QbGFjZUNvbnRhaW5lciA9IHZvaWQgMDtcbnZhciBoaWRlID0gZmFsc2U7XG52YXIgaGlkZWFibGVHdWlzID0gW107XG52YXIgR1VJID0gZnVuY3Rpb24gR1VJKHBhcnMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIHBhcmFtcyA9IHBhcnMgfHwge307XG4gIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLl9fdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3VsKTtcbiAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgQ1NTX05BTUVTUEFDRSk7XG4gIHRoaXMuX19mb2xkZXJzID0ge307XG4gIHRoaXMuX19jb250cm9sbGVycyA9IFtdO1xuICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMgPSBbXTtcbiAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVycyA9IFtdO1xuICB0aGlzLl9fbGlzdGVuaW5nID0gW107XG4gIHBhcmFtcyA9IENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICBjbG9zZU9uVG9wOiBmYWxzZSxcbiAgICBhdXRvUGxhY2U6IHRydWUsXG4gICAgd2lkdGg6IEdVSS5ERUZBVUxUX1dJRFRIXG4gIH0pO1xuICBwYXJhbXMgPSBDb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgcmVzaXphYmxlOiBwYXJhbXMuYXV0b1BsYWNlLFxuICAgIGhpZGVhYmxlOiBwYXJhbXMuYXV0b1BsYWNlXG4gIH0pO1xuICBpZiAoIUNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMubG9hZCkpIHtcbiAgICBpZiAocGFyYW1zLnByZXNldCkge1xuICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gcGFyYW1zLnByZXNldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zLmxvYWQgPSB7IHByZXNldDogREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FIH07XG4gIH1cbiAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMuaGlkZWFibGUpIHtcbiAgICBoaWRlYWJsZUd1aXMucHVzaCh0aGlzKTtcbiAgfVxuICBwYXJhbXMucmVzaXphYmxlID0gQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5yZXNpemFibGU7XG4gIGlmIChwYXJhbXMuYXV0b1BsYWNlICYmIENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMuc2Nyb2xsYWJsZSkpIHtcbiAgICBwYXJhbXMuc2Nyb2xsYWJsZSA9IHRydWU7XG4gIH1cbiAgdmFyIHVzZUxvY2FsU3RvcmFnZSA9IFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnO1xuICB2YXIgc2F2ZVRvTG9jYWxTdG9yYWdlID0gdm9pZCAwO1xuICB2YXIgdGl0bGVSb3cgPSB2b2lkIDA7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsXG4gIHtcbiAgICBwYXJlbnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLnBhcmVudDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNjcm9sbGFibGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLnNjcm9sbGFibGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBhdXRvUGxhY2U6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmF1dG9QbGFjZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb3NlT25Ub3A6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlT25Ub3A7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcmVzZXQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmdldFJvb3QoKS5wcmVzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkLnByZXNldDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICBfdGhpcy5nZXRSb290KCkucHJlc2V0ID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXMubG9hZC5wcmVzZXQgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHNldFByZXNldFNlbGVjdEluZGV4KHRoaXMpO1xuICAgICAgICBfdGhpcy5yZXZlcnQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpZHRoOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy53aWR0aDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICAgIHBhcmFtcy53aWR0aCA9IHY7XG4gICAgICAgIHNldFdpZHRoKF90aGlzLCB2KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLm5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMubmFtZSA9IHY7XG4gICAgICAgIGlmICh0aXRsZVJvdykge1xuICAgICAgICAgIHRpdGxlUm93LmlubmVySFRNTCA9IHBhcmFtcy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICAgIHBhcmFtcy5jbG9zZWQgPSB2O1xuICAgICAgICBpZiAocGFyYW1zLmNsb3NlZCkge1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICBpZiAoX3RoaXMuX19jbG9zZUJ1dHRvbikge1xuICAgICAgICAgIF90aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gdiA/IEdVSS5URVhUX09QRU4gOiBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxvYWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VMb2NhbFN0b3JhZ2U6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdXNlTG9jYWxTdG9yYWdlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKGJvb2wpIHtcbiAgICAgICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICAgICAgICB1c2VMb2NhbFN0b3JhZ2UgPSBib29sO1xuICAgICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICBkb20uYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdpc0xvY2FsJyksIGJvb2wpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuICAgIHRoaXMuY2xvc2VkID0gcGFyYW1zLmNsb3NlZCB8fCBmYWxzZTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfTUFJTik7XG4gICAgZG9tLm1ha2VTZWxlY3RhYmxlKHRoaXMuZG9tRWxlbWVudCwgZmFsc2UpO1xuICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICBpZiAodXNlTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIF90aGlzLnVzZUxvY2FsU3RvcmFnZSA9IHRydWU7XG4gICAgICAgIHZhciBzYXZlZEd1aSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2d1aScpKTtcbiAgICAgICAgaWYgKHNhdmVkR3VpKSB7XG4gICAgICAgICAgcGFyYW1zLmxvYWQgPSBKU09OLnBhcnNlKHNhdmVkR3VpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9fY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gR1VJLlRFWFRfQ0xPU0VEO1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9CVVRUT04pO1xuICAgIGlmIChwYXJhbXMuY2xvc2VPblRvcCkge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX1RPUCk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuX19jbG9zZUJ1dHRvbiwgdGhpcy5kb21FbGVtZW50LmNoaWxkTm9kZXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQk9UVE9NKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fY2xvc2VCdXR0b24pO1xuICAgIH1cbiAgICBkb20uYmluZCh0aGlzLl9fY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtcy5jbG9zZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW1zLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIHZhciB0aXRsZVJvd05hbWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXJhbXMubmFtZSk7XG4gICAgZG9tLmFkZENsYXNzKHRpdGxlUm93TmFtZSwgJ2NvbnRyb2xsZXItbmFtZScpO1xuICAgIHRpdGxlUm93ID0gYWRkUm93KF90aGlzLCB0aXRsZVJvd05hbWUpO1xuICAgIHZhciBvbkNsaWNrVGl0bGUgPSBmdW5jdGlvbiBvbkNsaWNrVGl0bGUoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgIGRvbS5hZGRDbGFzcyh0aXRsZVJvdywgJ3RpdGxlJyk7XG4gICAgZG9tLmJpbmQodGl0bGVSb3csICdjbGljaycsIG9uQ2xpY2tUaXRsZSk7XG4gICAgaWYgKCFwYXJhbXMuY2xvc2VkKSB7XG4gICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAocGFyYW1zLmF1dG9QbGFjZSkge1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcbiAgICAgIGlmIChhdXRvUGxhY2VWaXJnaW4pIHtcbiAgICAgICAgYXV0b1BsYWNlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvUGxhY2VDb250YWluZXIsIENTU19OQU1FU1BBQ0UpO1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBHVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1dG9QbGFjZUNvbnRhaW5lcik7XG4gICAgICAgIGF1dG9QbGFjZVZpcmdpbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgYXV0b1BsYWNlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfQVVUT19QTEFDRSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHNldFdpZHRoKF90aGlzLCBwYXJhbXMud2lkdGgpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9fcmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5vblJlc2l6ZURlYm91bmNlZCgpO1xuICB9O1xuICBkb20uYmluZCh3aW5kb3csICdyZXNpemUnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gIGRvbS5iaW5kKHRoaXMuX191bCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gIGRvbS5iaW5kKHRoaXMuX191bCwgJ3RyYW5zaXRpb25lbmQnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gIGRvbS5iaW5kKHRoaXMuX191bCwgJ29UcmFuc2l0aW9uRW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICB0aGlzLm9uUmVzaXplKCk7XG4gIGlmIChwYXJhbXMucmVzaXphYmxlKSB7XG4gICAgYWRkUmVzaXplSGFuZGxlKHRoaXMpO1xuICB9XG4gIHNhdmVUb0xvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uIHNhdmVUb0xvY2FsU3RvcmFnZSgpIHtcbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnZ3VpJyksIEpTT04uc3RyaW5naWZ5KF90aGlzLmdldFNhdmVPYmplY3QoKSkpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlID0gc2F2ZVRvTG9jYWxTdG9yYWdlO1xuICBmdW5jdGlvbiByZXNldFdpZHRoKCkge1xuICAgIHZhciByb290ID0gX3RoaXMuZ2V0Um9vdCgpO1xuICAgIHJvb3Qud2lkdGggKz0gMTtcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcm9vdC53aWR0aCAtPSAxO1xuICAgIH0pO1xuICB9XG4gIGlmICghcGFyYW1zLnBhcmVudCkge1xuICAgIHJlc2V0V2lkdGgoKTtcbiAgfVxufTtcbkdVSS50b2dnbGVIaWRlID0gZnVuY3Rpb24gKCkge1xuICBoaWRlID0gIWhpZGU7XG4gIENvbW1vbi5lYWNoKGhpZGVhYmxlR3VpcywgZnVuY3Rpb24gKGd1aSkge1xuICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBoaWRlID8gJ25vbmUnIDogJyc7XG4gIH0pO1xufTtcbkdVSS5DTEFTU19BVVRPX1BMQUNFID0gJ2EnO1xuR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSID0gJ2FjJztcbkdVSS5DTEFTU19NQUlOID0gJ21haW4nO1xuR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XID0gJ2NyJztcbkdVSS5DTEFTU19UT09fVEFMTCA9ICd0YWxsZXItdGhhbi13aW5kb3cnO1xuR1VJLkNMQVNTX0NMT1NFRCA9ICdjbG9zZWQnO1xuR1VJLkNMQVNTX0NMT1NFX0JVVFRPTiA9ICdjbG9zZS1idXR0b24nO1xuR1VJLkNMQVNTX0NMT1NFX1RPUCA9ICdjbG9zZS10b3AnO1xuR1VJLkNMQVNTX0NMT1NFX0JPVFRPTSA9ICdjbG9zZS1ib3R0b20nO1xuR1VJLkNMQVNTX0RSQUcgPSAnZHJhZyc7XG5HVUkuREVGQVVMVF9XSURUSCA9IDI0NTtcbkdVSS5URVhUX0NMT1NFRCA9ICdDbG9zZSBDb250cm9scyc7XG5HVUkuVEVYVF9PUEVOID0gJ09wZW4gQ29udHJvbHMnO1xuR1VJLl9rZXlkb3duSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50LnR5cGUgIT09ICd0ZXh0JyAmJiAoZS53aGljaCA9PT0gSElERV9LRVlfQ09ERSB8fCBlLmtleUNvZGUgPT09IEhJREVfS0VZX0NPREUpKSB7XG4gICAgR1VJLnRvZ2dsZUhpZGUoKTtcbiAgfVxufTtcbmRvbS5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBHVUkuX2tleWRvd25IYW5kbGVyLCBmYWxzZSk7XG5Db21tb24uZXh0ZW5kKEdVSS5wcm90b3R5cGUsXG57XG4gIGFkZDogZnVuY3Rpb24gYWRkKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gX2FkZCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICBmYWN0b3J5QXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxuICAgIH0pO1xuICB9LFxuICBhZGRDb2xvcjogZnVuY3Rpb24gYWRkQ29sb3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBfYWRkKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgIGNvbG9yOiB0cnVlXG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLl9fdWwucmVtb3ZlQ2hpbGQoY29udHJvbGxlci5fX2xpKTtcbiAgICB0aGlzLl9fY29udHJvbGxlcnMuc3BsaWNlKHRoaXMuX19jb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpLCAxKTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5vblJlc2l6ZSgpO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHRoZSByb290IEdVSSBzaG91bGQgYmUgcmVtb3ZlZCB3aXRoIC5kZXN0cm95KCkuICcgKyAnRm9yIHN1YmZvbGRlcnMsIHVzZSBndWkucmVtb3ZlRm9sZGVyKGZvbGRlcikgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICBhdXRvUGxhY2VDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICB9XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKHN1YmZvbGRlcikge1xuICAgICAgX3RoaXMucmVtb3ZlRm9sZGVyKHN1YmZvbGRlcik7XG4gICAgfSk7XG4gICAgZG9tLnVuYmluZCh3aW5kb3csICdrZXlkb3duJywgR1VJLl9rZXlkb3duSGFuZGxlciwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVycyh0aGlzKTtcbiAgfSxcbiAgYWRkRm9sZGVyOiBmdW5jdGlvbiBhZGRGb2xkZXIobmFtZSkge1xuICAgIGlmICh0aGlzLl9fZm9sZGVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhbHJlYWR5IGhhdmUgYSBmb2xkZXIgaW4gdGhpcyBHVUkgYnkgdGhlJyArICcgbmFtZSBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgfVxuICAgIHZhciBuZXdHdWlQYXJhbXMgPSB7IG5hbWU6IG5hbWUsIHBhcmVudDogdGhpcyB9O1xuICAgIG5ld0d1aVBhcmFtcy5hdXRvUGxhY2UgPSB0aGlzLmF1dG9QbGFjZTtcbiAgICBpZiAodGhpcy5sb2FkICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnMgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXSkge1xuICAgICAgbmV3R3VpUGFyYW1zLmNsb3NlZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdLmNsb3NlZDtcbiAgICAgIG5ld0d1aVBhcmFtcy5sb2FkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV07XG4gICAgfVxuICAgIHZhciBndWkgPSBuZXcgR1VJKG5ld0d1aVBhcmFtcyk7XG4gICAgdGhpcy5fX2ZvbGRlcnNbbmFtZV0gPSBndWk7XG4gICAgdmFyIGxpID0gYWRkUm93KHRoaXMsIGd1aS5kb21FbGVtZW50KTtcbiAgICBkb20uYWRkQ2xhc3MobGksICdmb2xkZXInKTtcbiAgICByZXR1cm4gZ3VpO1xuICB9LFxuICByZW1vdmVGb2xkZXI6IGZ1bmN0aW9uIHJlbW92ZUZvbGRlcihmb2xkZXIpIHtcbiAgICB0aGlzLl9fdWwucmVtb3ZlQ2hpbGQoZm9sZGVyLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gICAgZGVsZXRlIHRoaXMuX19mb2xkZXJzW2ZvbGRlci5uYW1lXTtcbiAgICBpZiAodGhpcy5sb2FkICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnMgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVyc1tmb2xkZXIubmFtZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWQuZm9sZGVyc1tmb2xkZXIubmFtZV07XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVycyhmb2xkZXIpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2goZm9sZGVyLl9fZm9sZGVycywgZnVuY3Rpb24gKHN1YmZvbGRlcikge1xuICAgICAgZm9sZGVyLnJlbW92ZUZvbGRlcihzdWJmb2xkZXIpO1xuICAgIH0pO1xuICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5vblJlc2l6ZSgpO1xuICAgIH0pO1xuICB9LFxuICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gIH0sXG4gIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH0sXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgfSxcbiAgb25SZXNpemU6IGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgIHZhciByb290ID0gdGhpcy5nZXRSb290KCk7XG4gICAgaWYgKHJvb3Quc2Nyb2xsYWJsZSkge1xuICAgICAgdmFyIHRvcCA9IGRvbS5nZXRPZmZzZXQocm9vdC5fX3VsKS50b3A7XG4gICAgICB2YXIgaCA9IDA7XG4gICAgICBDb21tb24uZWFjaChyb290Ll9fdWwuY2hpbGROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCEocm9vdC5hdXRvUGxhY2UgJiYgbm9kZSA9PT0gcm9vdC5fX3NhdmVfcm93KSkge1xuICAgICAgICAgIGggKz0gZG9tLmdldEhlaWdodChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAod2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCA8IGgpIHtcbiAgICAgICAgZG9tLmFkZENsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvb3QuX19yZXNpemVfaGFuZGxlKSB7XG4gICAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICByb290Ll9fcmVzaXplX2hhbmRsZS5zdHlsZS5oZWlnaHQgPSByb290Ll9fdWwub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocm9vdC5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICByb290Ll9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSByb290LndpZHRoICsgJ3B4JztcbiAgICB9XG4gIH0sXG4gIG9uUmVzaXplRGVib3VuY2VkOiBDb21tb24uZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgfSwgNTApLFxuICByZW1lbWJlcjogZnVuY3Rpb24gcmVtZW1iZXIoKSB7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChTQVZFX0RJQUxPR1VFKSkge1xuICAgICAgU0FWRV9ESUFMT0dVRSA9IG5ldyBDZW50ZXJlZERpdigpO1xuICAgICAgU0FWRV9ESUFMT0dVRS5kb21FbGVtZW50LmlubmVySFRNTCA9IHNhdmVEaWFsb2dDb250ZW50cztcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW4gb25seSBjYWxsIHJlbWVtYmVyIG9uIGEgdG9wIGxldmVsIEdVSS4nKTtcbiAgICB9XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZWFjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYWRkU2F2ZU1lbnUoX3RoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSkge1xuICAgICAgICBfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgIHNldFdpZHRoKHRoaXMsIHRoaXMud2lkdGgpO1xuICAgIH1cbiAgfSxcbiAgZ2V0Um9vdDogZnVuY3Rpb24gZ2V0Um9vdCgpIHtcbiAgICB2YXIgZ3VpID0gdGhpcztcbiAgICB3aGlsZSAoZ3VpLnBhcmVudCkge1xuICAgICAgZ3VpID0gZ3VpLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGd1aTtcbiAgfSxcbiAgZ2V0U2F2ZU9iamVjdDogZnVuY3Rpb24gZ2V0U2F2ZU9iamVjdCgpIHtcbiAgICB2YXIgdG9SZXR1cm4gPSB0aGlzLmxvYWQ7XG4gICAgdG9SZXR1cm4uY2xvc2VkID0gdGhpcy5jbG9zZWQ7XG4gICAgaWYgKHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICB0b1JldHVybi5wcmVzZXQgPSB0aGlzLnByZXNldDtcbiAgICAgIGlmICghdG9SZXR1cm4ucmVtZW1iZXJlZCkge1xuICAgICAgICB0b1JldHVybi5yZW1lbWJlcmVkID0ge307XG4gICAgICB9XG4gICAgICB0b1JldHVybi5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgfVxuICAgIHRvUmV0dXJuLmZvbGRlcnMgPSB7fTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuICAgICAgdG9SZXR1cm4uZm9sZGVyc1trZXldID0gZWxlbWVudC5nZXRTYXZlT2JqZWN0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuICB9LFxuICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xuICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgfVxuICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUoKTtcbiAgfSxcbiAgc2F2ZUFzOiBmdW5jdGlvbiBzYXZlQXMocHJlc2V0TmFtZSkge1xuICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbcHJlc2V0TmFtZV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIHRoaXMucHJlc2V0ID0gcHJlc2V0TmFtZTtcbiAgICBhZGRQcmVzZXRPcHRpb24odGhpcywgcHJlc2V0TmFtZSwgdHJ1ZSk7XG4gICAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKCk7XG4gIH0sXG4gIHJldmVydDogZnVuY3Rpb24gcmV2ZXJ0KGd1aSkge1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmICghdGhpcy5nZXRSb290KCkubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUoY29udHJvbGxlci5pbml0aWFsVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjYWxsU2F2ZWRWYWx1ZShndWkgfHwgdGhpcy5nZXRSb290KCksIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRyb2xsZXIuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBjb250cm9sbGVyLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChjb250cm9sbGVyLCBjb250cm9sbGVyLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZm9sZGVyKSB7XG4gICAgICBmb2xkZXIucmV2ZXJ0KGZvbGRlcik7XG4gICAgfSk7XG4gICAgaWYgKCFndWkpIHtcbiAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLmdldFJvb3QoKSwgZmFsc2UpO1xuICAgIH1cbiAgfSxcbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4oY29udHJvbGxlcikge1xuICAgIHZhciBpbml0ID0gdGhpcy5fX2xpc3RlbmluZy5sZW5ndGggPT09IDA7XG4gICAgdGhpcy5fX2xpc3RlbmluZy5wdXNoKGNvbnRyb2xsZXIpO1xuICAgIGlmIChpbml0KSB7XG4gICAgICB1cGRhdGVEaXNwbGF5cyh0aGlzLl9fbGlzdGVuaW5nKTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLCBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSk7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChmb2xkZXIpIHtcbiAgICAgIGZvbGRlci51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gYWRkUm93KGd1aSwgbmV3RG9tLCBsaUJlZm9yZSkge1xuICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBpZiAobmV3RG9tKSB7XG4gICAgbGkuYXBwZW5kQ2hpbGQobmV3RG9tKTtcbiAgfVxuICBpZiAobGlCZWZvcmUpIHtcbiAgICBndWkuX191bC5pbnNlcnRCZWZvcmUobGksIGxpQmVmb3JlKTtcbiAgfSBlbHNlIHtcbiAgICBndWkuX191bC5hcHBlbmRDaGlsZChsaSk7XG4gIH1cbiAgZ3VpLm9uUmVzaXplKCk7XG4gIHJldHVybiBsaTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyhndWkpIHtcbiAgZG9tLnVuYmluZCh3aW5kb3csICdyZXNpemUnLCBndWkuX19yZXNpemVIYW5kbGVyKTtcbiAgaWYgKGd1aS5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKSB7XG4gICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBndWkuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQcmVzZXRNb2RpZmllZChndWksIG1vZGlmaWVkKSB7XG4gIHZhciBvcHQgPSBndWkuX19wcmVzZXRfc2VsZWN0W2d1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleF07XG4gIGlmIChtb2RpZmllZCkge1xuICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWUgKyAnKic7XG4gIH0gZWxzZSB7XG4gICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcikge1xuICBjb250cm9sbGVyLl9fbGkgPSBsaTtcbiAgY29udHJvbGxlci5fX2d1aSA9IGd1aTtcbiAgQ29tbW9uLmV4dGVuZChjb250cm9sbGVyLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoX29wdGlvbnMpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBuZXh0U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW0NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKENvbW1vbi5pc0FycmF5KF9vcHRpb25zKSB8fCBDb21tb24uaXNPYmplY3QoX29wdGlvbnMpKSB7XG4gICAgICAgIHZhciBfbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBfbmV4dFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtfb3B0aW9uc11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKF9uYW1lKSB7XG4gICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gX25hbWU7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5saXN0ZW4oY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpIHtcbiAgICB2YXIgYm94ID0gbmV3IE51bWJlckNvbnRyb2xsZXJCb3goY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHsgbWluOiBjb250cm9sbGVyLl9fbWluLCBtYXg6IGNvbnRyb2xsZXIuX19tYXgsIHN0ZXA6IGNvbnRyb2xsZXIuX19zdGVwIH0pO1xuICAgIENvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZScsICdzdGVwJywgJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuICAgICAgdmFyIHBiID0gYm94W21ldGhvZF07XG4gICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBwYi5hcHBseShib3gsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcbiAgICBjb250cm9sbGVyLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJveC5kb21FbGVtZW50LCBjb250cm9sbGVyLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyQm94KSB7XG4gICAgdmFyIHIgPSBmdW5jdGlvbiByKHJldHVybmVkKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19taW4pICYmIENvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuICAgICAgICB2YXIgb2xkTmFtZSA9IGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUw7XG4gICAgICAgIHZhciB3YXNMaXN0ZW5pbmcgPSBjb250cm9sbGVyLl9fZ3VpLl9fbGlzdGVuaW5nLmluZGV4T2YoY29udHJvbGxlcikgPiAtMTtcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXIgPSBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb250cm9sbGVyLl9fbWluLCBjb250cm9sbGVyLl9fbWF4LCBjb250cm9sbGVyLl9fc3RlcF1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXIubmFtZShvbGROYW1lKTtcbiAgICAgICAgaWYgKHdhc0xpc3RlbmluZykgbmV3Q29udHJvbGxlci5saXN0ZW4oKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuZWQ7XG4gICAgfTtcbiAgICBjb250cm9sbGVyLm1pbiA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcbiAgICBjb250cm9sbGVyLm1heCA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWF4KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQm9vbGVhbkNvbnRyb2xsZXIpIHtcbiAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xuICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19idXR0b24sICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gQ29tbW9uLmNvbXBvc2UoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG4gIH1cbiAgY29udHJvbGxlci5zZXRWYWx1ZSA9IENvbW1vbi5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcbiAgICAgIG1hcmtQcmVzZXRNb2RpZmllZChndWkuZ2V0Um9vdCgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG59XG5mdW5jdGlvbiByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcikge1xuICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG4gIHZhciBtYXRjaGVkSW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XG4gIGlmIChtYXRjaGVkSW5kZXggIT09IC0xKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJNYXAgPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRJbmRleF07XG4gICAgaWYgKGNvbnRyb2xsZXJNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udHJvbGxlck1hcCA9IHt9O1xuICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkSW5kZXhdID0gY29udHJvbGxlck1hcDtcbiAgICB9XG4gICAgY29udHJvbGxlck1hcFtjb250cm9sbGVyLnByb3BlcnR5XSA9IGNvbnRyb2xsZXI7XG4gICAgaWYgKHJvb3QubG9hZCAmJiByb290LmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdmFyIHByZXNldE1hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuICAgICAgdmFyIHByZXNldCA9IHZvaWQgMDtcbiAgICAgIGlmIChwcmVzZXRNYXBbZ3VpLnByZXNldF0pIHtcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW2d1aS5wcmVzZXRdO1xuICAgICAgfSBlbHNlIGlmIChwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSkge1xuICAgICAgICBwcmVzZXQgPSBwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZEluZGV4XSAmJiBwcmVzZXRbbWF0Y2hlZEluZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkSW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuICAgICAgICBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGQoZ3VpLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IFwiJyArIG9iamVjdCArICdcIiBoYXMgbm8gcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCInKTtcbiAgfVxuICB2YXIgY29udHJvbGxlciA9IHZvaWQgMDtcbiAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgIGNvbnRyb2xsZXIgPSBuZXcgQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QsIHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcbiAgICBjb250cm9sbGVyID0gQ29udHJvbGxlckZhY3RvcnkuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5iZWZvcmUgaW5zdGFuY2VvZiBDb250cm9sbGVyKSB7XG4gICAgcGFyYW1zLmJlZm9yZSA9IHBhcmFtcy5iZWZvcmUuX19saTtcbiAgfVxuICByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcik7XG4gIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLmRvbUVsZW1lbnQsICdjJyk7XG4gIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBkb20uYWRkQ2xhc3MobmFtZSwgJ3Byb3BlcnR5LW5hbWUnKTtcbiAgbmFtZS5pbm5lckhUTUwgPSBjb250cm9sbGVyLnByb3BlcnR5O1xuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xsZXIuZG9tRWxlbWVudCk7XG4gIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XG4gIGRvbS5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcbiAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICB9IGVsc2Uge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgX3R5cGVvZihjb250cm9sbGVyLmdldFZhbHVlKCkpKTtcbiAgfVxuICBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKTtcbiAgZ3VpLl9fY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xufVxuZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICBvcHQuaW5uZXJIVE1MID0gbmFtZTtcbiAgb3B0LnZhbHVlID0gbmFtZTtcbiAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICBpZiAoc2V0U2VsZWN0ZWQpIHtcbiAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pIHtcbiAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG59XG5mdW5jdGlvbiBhZGRTYXZlTWVudShndWkpIHtcbiAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgZG9tLmFkZENsYXNzKGd1aS5kb21FbGVtZW50LCAnaGFzLXNhdmUnKTtcbiAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGRpdiwgZ3VpLl9fdWwuZmlyc3RDaGlsZCk7XG4gIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGdlYXJzLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcbiAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uLmlubmVySFRNTCA9ICdTYXZlJztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnc2F2ZScpO1xuICB2YXIgYnV0dG9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG4gIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24zLmlubmVySFRNTCA9ICdSZXZlcnQnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xuICB2YXIgc2VsZWN0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICBpZiAoZ3VpLmxvYWQgJiYgZ3VpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgIENvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBrZXksIGtleSA9PT0gZ3VpLnByZXNldCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FLCBmYWxzZSk7XG4gIH1cbiAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0uaW5uZXJIVE1MID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIGd1aS5wcmVzZXQgPSB0aGlzLnZhbHVlO1xuICB9KTtcbiAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG4gIGRpdi5hcHBlbmRDaGlsZChnZWFycyk7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24zKTtcbiAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XG4gICAgdmFyIGxvY2FsU3RvcmFnZUNoZWNrQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLXN0b3JhZ2UnKTtcbiAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG4gICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2VDaGVja0JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgIH1cbiAgICBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKTtcbiAgICBkb20uYmluZChsb2NhbFN0b3JhZ2VDaGVja0JveCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuICAgIH0pO1xuICB9XG4gIHZhciBuZXdDb25zdHJ1Y3RvclRleHRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLW5ldy1jb25zdHJ1Y3RvcicpO1xuICBkb20uYmluZChuZXdDb25zdHJ1Y3RvclRleHRBcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09PSA2NykpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuICAgIH1cbiAgfSk7XG4gIGRvbS5iaW5kKGdlYXJzLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShndWkuZ2V0U2F2ZU9iamVjdCgpLCB1bmRlZmluZWQsIDIpO1xuICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuZm9jdXMoKTtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLnNlbGVjdCgpO1xuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgZ3VpLnNhdmUoKTtcbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJlc2V0TmFtZSA9IHByb21wdCgnRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuJyk7XG4gICAgaWYgKHByZXNldE5hbWUpIHtcbiAgICAgIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG4gICAgfVxuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uMywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGd1aS5yZXZlcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRSZXNpemVIYW5kbGUoZ3VpKSB7XG4gIHZhciBwbW91c2VYID0gdm9pZCAwO1xuICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIENvbW1vbi5leHRlbmQoZ3VpLl9fcmVzaXplX2hhbmRsZS5zdHlsZSwge1xuICAgIHdpZHRoOiAnNnB4JyxcbiAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG4gICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgfSk7XG4gIGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBndWkud2lkdGggKz0gcG1vdXNlWCAtIGUuY2xpZW50WDtcbiAgICBndWkub25SZXNpemUoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RvcCgpIHtcbiAgICBkb20ucmVtb3ZlQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRvbS5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcbiAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgaWYgKGd1aS5fX3NhdmVfcm93ICYmIGd1aS5hdXRvUGxhY2UpIHtcbiAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICB9XG4gIGlmIChndWkuX19jbG9zZUJ1dHRvbikge1xuICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XG4gIHZhciB0b1JldHVybiA9IHt9O1xuICBDb21tb24uZWFjaChndWkuX19yZW1lbWJlcmVkT2JqZWN0cywgZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICB2YXIgc2F2ZWRWYWx1ZXMgPSB7fTtcbiAgICB2YXIgY29udHJvbGxlck1hcCA9IGd1aS5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tpbmRleF07XG4gICAgQ29tbW9uLmVhY2goY29udHJvbGxlck1hcCwgZnVuY3Rpb24gKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG4gICAgICBzYXZlZFZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XG4gICAgfSk7XG4gICAgdG9SZXR1cm5baW5kZXhdID0gc2F2ZWRWYWx1ZXM7XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59XG5mdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09PSBndWkucHJlc2V0KSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSkge1xuICBpZiAoY29udHJvbGxlckFycmF5Lmxlbmd0aCAhPT0gMCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpO1xuICAgIH0pO1xuICB9XG4gIENvbW1vbi5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24gKGMpIHtcbiAgICBjLnVwZGF0ZURpc3BsYXkoKTtcbiAgfSk7XG59XG5cbnZhciBjb2xvciA9IHtcbiAgQ29sb3I6IENvbG9yLFxuICBtYXRoOiBDb2xvck1hdGgsXG4gIGludGVycHJldDogaW50ZXJwcmV0XG59O1xudmFyIGNvbnRyb2xsZXJzID0ge1xuICBDb250cm9sbGVyOiBDb250cm9sbGVyLFxuICBCb29sZWFuQ29udHJvbGxlcjogQm9vbGVhbkNvbnRyb2xsZXIsXG4gIE9wdGlvbkNvbnRyb2xsZXI6IE9wdGlvbkNvbnRyb2xsZXIsXG4gIFN0cmluZ0NvbnRyb2xsZXI6IFN0cmluZ0NvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXI6IE51bWJlckNvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXJCb3g6IE51bWJlckNvbnRyb2xsZXJCb3gsXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXI6IE51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG4gIEZ1bmN0aW9uQ29udHJvbGxlcjogRnVuY3Rpb25Db250cm9sbGVyLFxuICBDb2xvckNvbnRyb2xsZXI6IENvbG9yQ29udHJvbGxlclxufTtcbnZhciBkb20kMSA9IHsgZG9tOiBkb20gfTtcbnZhciBndWkgPSB7IEdVSTogR1VJIH07XG52YXIgR1VJJDEgPSBHVUk7XG52YXIgaW5kZXggPSB7XG4gIGNvbG9yOiBjb2xvcixcbiAgY29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxuICBkb206IGRvbSQxLFxuICBndWk6IGd1aSxcbiAgR1VJOiBHVUkkMVxufTtcblxuZXhwb3J0cy5jb2xvciA9IGNvbG9yO1xuZXhwb3J0cy5jb250cm9sbGVycyA9IGNvbnRyb2xsZXJzO1xuZXhwb3J0cy5kb20gPSBkb20kMTtcbmV4cG9ydHMuZ3VpID0gZ3VpO1xuZXhwb3J0cy5HVUkgPSBHVUkkMTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGluZGV4O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0Lmd1aS5qcy5tYXBcbiIsIi8qIGludGVyYWN0LmpzIDEuOS44IHwgaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS90YXllL2ludGVyYWN0LmpzL21hc3Rlci9MSUNFTlNFICovXG4hZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9dCgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSx0KTtlbHNleyhcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMpLmludGVyYWN0PXQoKX19KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt2YXIgbjtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIG58fGUobj17ZXhwb3J0czp7fSxwYXJlbnQ6dH0sbi5leHBvcnRzKSxuLmV4cG9ydHN9fXZhciBrPXQoZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBhKHQpe3JldHVybihhPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9ZS5JbnRlcmFjdGFibGU9dm9pZCAwO3ZhciB1PXIoUyksbD1uKEMpLHM9bihWKSxjPW4oY3QpLGY9cih3KSxwPW4oZnQpLGk9bihidCksZD1tKHt9KTtmdW5jdGlvbiBuKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiB2KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gdj1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIHIodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09YSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT12KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59ZnVuY3Rpb24gbyh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24geSh0LGUsbil7cmV0dXJuIGUmJm8odC5wcm90b3R5cGUsZSksbiYmbyh0LG4pLHR9ZnVuY3Rpb24gaCh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIGc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBvKHQsZSxuLHIpeyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbyksdGhpcy5fc2NvcGVFdmVudHM9cixoKHRoaXMsXCJvcHRpb25zXCIsdm9pZCAwKSxoKHRoaXMsXCJfYWN0aW9uc1wiLHZvaWQgMCksaCh0aGlzLFwidGFyZ2V0XCIsdm9pZCAwKSxoKHRoaXMsXCJldmVudHNcIixuZXcgaS5kZWZhdWx0KSxoKHRoaXMsXCJfY29udGV4dFwiLHZvaWQgMCksaCh0aGlzLFwiX3dpblwiLHZvaWQgMCksaCh0aGlzLFwiX2RvY1wiLHZvaWQgMCksdGhpcy5fYWN0aW9ucz1lLmFjdGlvbnMsdGhpcy50YXJnZXQ9dCx0aGlzLl9jb250ZXh0PWUuY29udGV4dHx8bix0aGlzLl93aW49KDAsTy5nZXRXaW5kb3cpKCgwLCQudHJ5U2VsZWN0b3IpKHQpP3RoaXMuX2NvbnRleHQ6dCksdGhpcy5fZG9jPXRoaXMuX3dpbi5kb2N1bWVudCx0aGlzLnNldChlKX1yZXR1cm4geShvLFt7a2V5OlwiX2RlZmF1bHRzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue2Jhc2U6e30scGVyQWN0aW9uOnt9LGFjdGlvbnM6e319fX1dKSx5KG8sW3trZXk6XCJzZXRPbkV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGYuZnVuYyhlLm9uc3RhcnQpJiZ0aGlzLm9uKFwiXCIuY29uY2F0KHQsXCJzdGFydFwiKSxlLm9uc3RhcnQpLGYuZnVuYyhlLm9ubW92ZSkmJnRoaXMub24oXCJcIi5jb25jYXQodCxcIm1vdmVcIiksZS5vbm1vdmUpLGYuZnVuYyhlLm9uZW5kKSYmdGhpcy5vbihcIlwiLmNvbmNhdCh0LFwiZW5kXCIpLGUub25lbmQpLGYuZnVuYyhlLm9uaW5lcnRpYXN0YXJ0KSYmdGhpcy5vbihcIlwiLmNvbmNhdCh0LFwiaW5lcnRpYXN0YXJ0XCIpLGUub25pbmVydGlhc3RhcnQpLHRoaXN9fSx7a2V5OlwidXBkYXRlUGVyQWN0aW9uTGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4peyhmLmFycmF5KGUpfHxmLm9iamVjdChlKSkmJnRoaXMub2ZmKHQsZSksKGYuYXJyYXkobil8fGYub2JqZWN0KG4pKSYmdGhpcy5vbih0LG4pfX0se2tleTpcInNldFBlckFjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fZGVmYXVsdHM7Zm9yKHZhciByIGluIGUpe3ZhciBvPXIsaT10aGlzLm9wdGlvbnNbdF0sYT1lW29dO1wibGlzdGVuZXJzXCI9PT1vJiZ0aGlzLnVwZGF0ZVBlckFjdGlvbkxpc3RlbmVycyh0LGkubGlzdGVuZXJzLGEpLGYuYXJyYXkoYSk/aVtvXT11LmZyb20oYSk6Zi5wbGFpbk9iamVjdChhKT8oaVtvXT0oMCxjLmRlZmF1bHQpKGlbb118fHt9LCgwLHMuZGVmYXVsdCkoYSkpLGYub2JqZWN0KG4ucGVyQWN0aW9uW29dKSYmXCJlbmFibGVkXCJpbiBuLnBlckFjdGlvbltvXSYmKGlbb10uZW5hYmxlZD0hMSE9PWEuZW5hYmxlZCkpOmYuYm9vbChhKSYmZi5vYmplY3Qobi5wZXJBY3Rpb25bb10pP2lbb10uZW5hYmxlZD1hOmlbb109YX19fSx7a2V5OlwiZ2V0UmVjdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0PXR8fChmLmVsZW1lbnQodGhpcy50YXJnZXQpP3RoaXMudGFyZ2V0Om51bGwpLGYuc3RyaW5nKHRoaXMudGFyZ2V0KSYmKHQ9dHx8dGhpcy5fY29udGV4dC5xdWVyeVNlbGVjdG9yKHRoaXMudGFyZ2V0KSksKDAsJC5nZXRFbGVtZW50UmVjdCkodCl9fSx7a2V5OlwicmVjdENoZWNrZXJcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gZi5mdW5jKHQpPyh0aGlzLmdldFJlY3Q9dCx0aGlzKTpudWxsPT09dD8oZGVsZXRlIHRoaXMuZ2V0UmVjdCx0aGlzKTp0aGlzLmdldFJlY3R9fSx7a2V5OlwiX2JhY2tDb21wYXRPcHRpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKCgwLCQudHJ5U2VsZWN0b3IpKGUpfHxmLm9iamVjdChlKSl7Zm9yKHZhciBuIGluIHRoaXMub3B0aW9uc1t0XT1lLHRoaXMuX2FjdGlvbnMubWFwKXRoaXMub3B0aW9uc1tuXVt0XT1lO3JldHVybiB0aGlzfXJldHVybiB0aGlzLm9wdGlvbnNbdF19fSx7a2V5Olwib3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2JhY2tDb21wYXRPcHRpb24oXCJvcmlnaW5cIix0KX19LHtrZXk6XCJkZWx0YVNvdXJjZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVyblwicGFnZVwiPT09dHx8XCJjbGllbnRcIj09PXQ/KHRoaXMub3B0aW9ucy5kZWx0YVNvdXJjZT10LHRoaXMpOnRoaXMub3B0aW9ucy5kZWx0YVNvdXJjZX19LHtrZXk6XCJjb250ZXh0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGV4dH19LHtrZXk6XCJpbkNvbnRleHRcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fY29udGV4dD09PXQub3duZXJEb2N1bWVudHx8KDAsJC5ub2RlQ29udGFpbnMpKHRoaXMuX2NvbnRleHQsdCl9fSx7a2V5OlwidGVzdElnbm9yZUFsbG93XCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiF0aGlzLnRlc3RJZ25vcmUodC5pZ25vcmVGcm9tLGUsbikmJnRoaXMudGVzdEFsbG93KHQuYWxsb3dGcm9tLGUsbil9fSx7a2V5OlwidGVzdEFsbG93XCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiF0fHwhIWYuZWxlbWVudChuKSYmKGYuc3RyaW5nKHQpPygwLCQubWF0Y2hlc1VwVG8pKG4sdCxlKTohIWYuZWxlbWVudCh0KSYmKDAsJC5ub2RlQ29udGFpbnMpKHQsbikpfX0se2tleTpcInRlc3RJZ25vcmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuISghdHx8IWYuZWxlbWVudChuKSkmJihmLnN0cmluZyh0KT8oMCwkLm1hdGNoZXNVcFRvKShuLHQsZSk6ISFmLmVsZW1lbnQodCkmJigwLCQubm9kZUNvbnRhaW5zKSh0LG4pKX19LHtrZXk6XCJmaXJlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZXZlbnRzLmZpcmUodCksdGhpc319LHtrZXk6XCJfb25PZmZcIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyKXtmLm9iamVjdChlKSYmIWYuYXJyYXkoZSkmJihyPW4sbj1udWxsKTt2YXIgbz1cIm9uXCI9PT10P1wiYWRkXCI6XCJyZW1vdmVcIixpPSgwLHAuZGVmYXVsdCkoZSxuKTtmb3IodmFyIGEgaW4gaSl7XCJ3aGVlbFwiPT09YSYmKGE9bC5kZWZhdWx0LndoZWVsRXZlbnQpO2Zvcih2YXIgdT0wO3U8aVthXS5sZW5ndGg7dSsrKXt2YXIgcz1pW2FdW3VdOygwLGQuaXNOb25OYXRpdmVFdmVudCkoYSx0aGlzLl9hY3Rpb25zKT90aGlzLmV2ZW50c1t0XShhLHMpOmYuc3RyaW5nKHRoaXMudGFyZ2V0KT90aGlzLl9zY29wZUV2ZW50c1tcIlwiLmNvbmNhdChvLFwiRGVsZWdhdGVcIildKHRoaXMudGFyZ2V0LHRoaXMuX2NvbnRleHQsYSxzLHIpOnRoaXMuX3Njb3BlRXZlbnRzW29dKHRoaXMudGFyZ2V0LGEscyxyKX19cmV0dXJuIHRoaXN9fSx7a2V5Olwib25cIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuX29uT2ZmKFwib25cIix0LGUsbil9fSx7a2V5Olwib2ZmXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLl9vbk9mZihcIm9mZlwiLHQsZSxuKX19LHtrZXk6XCJzZXRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9kZWZhdWx0cztmb3IodmFyIG4gaW4gZi5vYmplY3QodCl8fCh0PXt9KSx0aGlzLm9wdGlvbnM9KDAscy5kZWZhdWx0KShlLmJhc2UpLHRoaXMuX2FjdGlvbnMubWV0aG9kRGljdCl7dmFyIHI9bixvPXRoaXMuX2FjdGlvbnMubWV0aG9kRGljdFtyXTt0aGlzLm9wdGlvbnNbcl09e30sdGhpcy5zZXRQZXJBY3Rpb24ociwoMCxjLmRlZmF1bHQpKCgwLGMuZGVmYXVsdCkoe30sZS5wZXJBY3Rpb24pLGUuYWN0aW9uc1tyXSkpLHRoaXNbb10odFtyXSl9Zm9yKHZhciBpIGluIHQpZi5mdW5jKHRoaXNbaV0pJiZ0aGlzW2ldKHRbaV0pO3JldHVybiB0aGlzfX0se2tleTpcInVuc2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZihmLnN0cmluZyh0aGlzLnRhcmdldCkpZm9yKHZhciB0IGluIHRoaXMuX3Njb3BlRXZlbnRzLmRlbGVnYXRlZEV2ZW50cylmb3IodmFyIGU9dGhpcy5fc2NvcGVFdmVudHMuZGVsZWdhdGVkRXZlbnRzW3RdLG49ZS5sZW5ndGgtMTswPD1uO24tLSl7dmFyIHI9ZVtuXSxvPXIuc2VsZWN0b3IsaT1yLmNvbnRleHQsYT1yLmxpc3RlbmVycztvPT09dGhpcy50YXJnZXQmJmk9PT10aGlzLl9jb250ZXh0JiZlLnNwbGljZShuLDEpO2Zvcih2YXIgdT1hLmxlbmd0aC0xOzA8PXU7dS0tKXRoaXMuX3Njb3BlRXZlbnRzLnJlbW92ZURlbGVnYXRlKHRoaXMudGFyZ2V0LHRoaXMuX2NvbnRleHQsdCxhW3VdWzBdLGFbdV1bMV0pfWVsc2UgdGhpcy5fc2NvcGVFdmVudHMucmVtb3ZlKHRoaXMudGFyZ2V0LFwiYWxsXCIpfX1dKSxvfSgpLGI9ZS5JbnRlcmFjdGFibGU9ZztlLmRlZmF1bHQ9Yn0pLG09dChmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuaXNOb25OYXRpdmVFdmVudD1mdW5jdGlvbih0LGUpe2lmKGUucGhhc2VsZXNzVHlwZXNbdF0pcmV0dXJuITA7Zm9yKHZhciBuIGluIGUubWFwKWlmKDA9PT10LmluZGV4T2YobikmJnQuc3Vic3RyKG4ubGVuZ3RoKWluIGUucGhhc2VzKXJldHVybiEwO3JldHVybiExfSxlLmluaXRTY29wZT1NLGUuU2NvcGU9ZS5kZWZhdWx0PXZvaWQgMDt2YXIgbj1kKEQpLHI9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09dih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1wKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KGxlKSxvPWQoYnQpLGk9ZChXZSksYT1kKFQoe30pKSx1PWQoayh7fSkpLHM9ZChaZSksbD1kKHplKSxjPWQoY24pLGY9ZChFKHt9KSk7ZnVuY3Rpb24gcCgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIHA9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBkKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiB2KHQpe3JldHVybih2PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiB5KHQsZSl7cmV0dXJuIWV8fFwib2JqZWN0XCIhPT12KGUpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP2Z1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXQpcmV0dXJuIHQ7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpfSh0KTplfWZ1bmN0aW9uIGgodCxlLG4pe3JldHVybihoPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmdldD9SZWZsZWN0LmdldDpmdW5jdGlvbih0LGUsbil7dmFyIHI9ZnVuY3Rpb24odCxlKXtmb3IoOyFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSYmbnVsbCE9PSh0PWcodCkpOyk7cmV0dXJuIHR9KHQsZSk7aWYocil7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpO3JldHVybiBvLmdldD9vLmdldC5jYWxsKG4pOm8udmFsdWV9fSkodCxlLG58fHQpfWZ1bmN0aW9uIGcodCl7cmV0dXJuKGc9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KX0pKHQpfWZ1bmN0aW9uIGIodCxlKXtyZXR1cm4oYj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9ZnVuY3Rpb24gbSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gTyh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gdyh0LGUsbil7cmV0dXJuIGUmJk8odC5wcm90b3R5cGUsZSksbiYmTyh0LG4pLHR9ZnVuY3Rpb24gXyh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIFA9ci53aW4seD1yLmJyb3dzZXIsUz1yLnJhZixqPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3ZhciBlPXRoaXM7bSh0aGlzLHQpLF8odGhpcyxcImlkXCIsXCJfX2ludGVyYWN0X3Njb3BlX1wiLmNvbmNhdChNYXRoLmZsb29yKDEwMCpNYXRoLnJhbmRvbSgpKSkpLF8odGhpcyxcImlzSW5pdGlhbGl6ZWRcIiwhMSksXyh0aGlzLFwibGlzdGVuZXJNYXBzXCIsW10pLF8odGhpcyxcImJyb3dzZXJcIix4KSxfKHRoaXMsXCJ1dGlsc1wiLHIpLF8odGhpcyxcImRlZmF1bHRzXCIsci5jbG9uZShsLmRlZmF1bHQpKSxfKHRoaXMsXCJFdmVudGFibGVcIixvLmRlZmF1bHQpLF8odGhpcyxcImFjdGlvbnNcIix7bWFwOnt9LHBoYXNlczp7c3RhcnQ6ITAsbW92ZTohMCxlbmQ6ITB9LG1ldGhvZERpY3Q6e30scGhhc2VsZXNzVHlwZXM6e319KSxfKHRoaXMsXCJpbnRlcmFjdFN0YXRpY1wiLG5ldyBhLmRlZmF1bHQodGhpcykpLF8odGhpcyxcIkludGVyYWN0RXZlbnRcIixpLmRlZmF1bHQpLF8odGhpcyxcIkludGVyYWN0YWJsZVwiLHZvaWQgMCksXyh0aGlzLFwiaW50ZXJhY3RhYmxlc1wiLG5ldyBzLmRlZmF1bHQodGhpcykpLF8odGhpcyxcIl93aW5cIix2b2lkIDApLF8odGhpcyxcImRvY3VtZW50XCIsdm9pZCAwKSxfKHRoaXMsXCJ3aW5kb3dcIix2b2lkIDApLF8odGhpcyxcImRvY3VtZW50c1wiLFtdKSxfKHRoaXMsXCJfcGx1Z2luc1wiLHtsaXN0OltdLG1hcDp7fX0pLF8odGhpcyxcIm9uV2luZG93VW5sb2FkXCIsZnVuY3Rpb24odCl7cmV0dXJuIGUucmVtb3ZlRG9jdW1lbnQodC50YXJnZXQpfSk7dmFyIG49dGhpczt0aGlzLkludGVyYWN0YWJsZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbSh0aGlzLGUpLHkodGhpcyxnKGUpLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiZiKHQsZSl9KGUsdVtcImRlZmF1bHRcIl0pLHcoZSxbe2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBoKGcoZS5wcm90b3R5cGUpLFwic2V0XCIsdGhpcykuY2FsbCh0aGlzLHQpLG4uZmlyZShcImludGVyYWN0YWJsZTpzZXRcIix7b3B0aW9uczp0LGludGVyYWN0YWJsZTp0aGlzfSksdGhpc319LHtrZXk6XCJ1bnNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7aChnKGUucHJvdG90eXBlKSxcInVuc2V0XCIsdGhpcykuY2FsbCh0aGlzKSxuLmludGVyYWN0YWJsZXMubGlzdC5zcGxpY2Uobi5pbnRlcmFjdGFibGVzLmxpc3QuaW5kZXhPZih0aGlzKSwxKSxuLmZpcmUoXCJpbnRlcmFjdGFibGU6dW5zZXRcIix7aW50ZXJhY3RhYmxlOnRoaXN9KX19LHtrZXk6XCJfZGVmYXVsdHNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5kZWZhdWx0c319XSksZX0oKX1yZXR1cm4gdyh0LFt7a2V5OlwiYWRkTGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLmxpc3RlbmVyTWFwcy5wdXNoKHtpZDplLG1hcDp0fSl9fSx7a2V5OlwiZmlyZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0aGlzLmxpc3RlbmVyTWFwcy5sZW5ndGg7bisrKXt2YXIgcj10aGlzLmxpc3RlbmVyTWFwc1tuXS5tYXBbdF07aWYociYmITE9PT1yKGUsdGhpcyx0KSlyZXR1cm4hMX19fSx7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzSW5pdGlhbGl6ZWQ/dGhpczpNKHRoaXMsdCl9fSx7a2V5OlwicGx1Z2luSXNJbnN0YWxsZWRcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcGx1Z2lucy5tYXBbdC5pZF18fC0xIT09dGhpcy5fcGx1Z2lucy5saXN0LmluZGV4T2YodCl9fSx7a2V5OlwidXNlUGx1Z2luXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih0aGlzLnBsdWdpbklzSW5zdGFsbGVkKHQpKXJldHVybiB0aGlzO2lmKHQuaWQmJih0aGlzLl9wbHVnaW5zLm1hcFt0LmlkXT10KSx0aGlzLl9wbHVnaW5zLmxpc3QucHVzaCh0KSx0Lmluc3RhbGwmJnQuaW5zdGFsbCh0aGlzLGUpLHQubGlzdGVuZXJzJiZ0LmJlZm9yZSl7Zm9yKHZhciBuPTAscj10aGlzLmxpc3RlbmVyTWFwcy5sZW5ndGgsbz10LmJlZm9yZS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtlXT0hMCx0fSx7fSk7bjxyO24rKyl7aWYob1t0aGlzLmxpc3RlbmVyTWFwc1tuXS5pZF0pYnJlYWt9dGhpcy5saXN0ZW5lck1hcHMuc3BsaWNlKG4sMCx7aWQ6dC5pZCxtYXA6dC5saXN0ZW5lcnN9KX1lbHNlIHQubGlzdGVuZXJzJiZ0aGlzLmxpc3RlbmVyTWFwcy5wdXNoKHtpZDp0LmlkLG1hcDp0Lmxpc3RlbmVyc30pO3JldHVybiB0aGlzfX0se2tleTpcImFkZERvY3VtZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZigtMSE9PXRoaXMuZ2V0RG9jSW5kZXgodCkpcmV0dXJuITE7dmFyIG49UC5nZXRXaW5kb3codCk7ZT1lP3IuZXh0ZW5kKHt9LGUpOnt9LHRoaXMuZG9jdW1lbnRzLnB1c2goe2RvYzp0LG9wdGlvbnM6ZX0pLHRoaXMuZXZlbnRzLmRvY3VtZW50cy5wdXNoKHQpLHQhPT10aGlzLmRvY3VtZW50JiZ0aGlzLmV2ZW50cy5hZGQobixcInVubG9hZFwiLHRoaXMub25XaW5kb3dVbmxvYWQpLHRoaXMuZmlyZShcInNjb3BlOmFkZC1kb2N1bWVudFwiLHtkb2M6dCx3aW5kb3c6bixzY29wZTp0aGlzLG9wdGlvbnM6ZX0pfX0se2tleTpcInJlbW92ZURvY3VtZW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXREb2NJbmRleCh0KSxuPVAuZ2V0V2luZG93KHQpLHI9dGhpcy5kb2N1bWVudHNbZV0ub3B0aW9uczt0aGlzLmV2ZW50cy5yZW1vdmUobixcInVubG9hZFwiLHRoaXMub25XaW5kb3dVbmxvYWQpLHRoaXMuZG9jdW1lbnRzLnNwbGljZShlLDEpLHRoaXMuZXZlbnRzLmRvY3VtZW50cy5zcGxpY2UoZSwxKSx0aGlzLmZpcmUoXCJzY29wZTpyZW1vdmUtZG9jdW1lbnRcIix7ZG9jOnQsd2luZG93Om4sc2NvcGU6dGhpcyxvcHRpb25zOnJ9KX19LHtrZXk6XCJnZXREb2NJbmRleFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5kb2N1bWVudHMubGVuZ3RoO2UrKylpZih0aGlzLmRvY3VtZW50c1tlXS5kb2M9PT10KXJldHVybiBlO3JldHVybi0xfX0se2tleTpcImdldERvY09wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldERvY0luZGV4KHQpO3JldHVybi0xPT09ZT9udWxsOnRoaXMuZG9jdW1lbnRzW2VdLm9wdGlvbnN9fSx7a2V5Olwibm93XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy53aW5kb3cuRGF0ZXx8RGF0ZSkubm93KCl9fV0pLHR9KCk7ZnVuY3Rpb24gTSh0LGUpe3JldHVybiB0LmlzSW5pdGlhbGl6ZWQ9ITAsUC5pbml0KGUpLG4uZGVmYXVsdC5pbml0KGUpLHguaW5pdChlKSxTLmluaXQoZSksdC53aW5kb3c9ZSx0LmRvY3VtZW50PWUuZG9jdW1lbnQsdC51c2VQbHVnaW4oZi5kZWZhdWx0KSx0LnVzZVBsdWdpbihjLmRlZmF1bHQpLHR9ZS5TY29wZT1lLmRlZmF1bHQ9an0pLEU9dChmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD12b2lkIDA7dmFyIF89bihDKSx1PW4oRCksUD1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1jKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPWEoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oenQpLHM9bihFbiksbD1uKFVuKSxvPW4odHIpO24obSh7fSkpO2Z1bmN0aW9uIGEoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBhPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gYyh0KXtyZXR1cm4oYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9ZnVuY3Rpb24geCh0LGUpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0fSh0KXx8ZnVuY3Rpb24odCxlKXtpZighKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpKXJldHVybjt2YXIgbj1bXSxyPSEwLG89ITEsaT12b2lkIDA7dHJ5e2Zvcih2YXIgYSx1PXRbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0oYT11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goYS52YWx1ZSksIWV8fG4ubGVuZ3RoIT09ZSk7cj0hMCk7fWNhdGNoKHQpe289ITAsaT10fWZpbmFsbHl7dHJ5e3J8fG51bGw9PXUucmV0dXJufHx1LnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn0odCxlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX1mdW5jdGlvbiBmKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBwKHQsZSl7cmV0dXJuIWV8fFwib2JqZWN0XCIhPT1jKGUpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP2Z1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXQpcmV0dXJuIHQ7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpfSh0KTplfWZ1bmN0aW9uIGQodCl7cmV0dXJuKGQ9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KX0pKHQpfWZ1bmN0aW9uIHYodCxlKXtyZXR1cm4odj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9dmFyIHk9W1wicG9pbnRlckRvd25cIixcInBvaW50ZXJNb3ZlXCIsXCJwb2ludGVyVXBcIixcInVwZGF0ZVBvaW50ZXJcIixcInJlbW92ZVBvaW50ZXJcIixcIndpbmRvd0JsdXJcIl07ZnVuY3Rpb24gaChPLHcpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgZT13LmludGVyYWN0aW9ucy5saXN0LG49UC5nZXRQb2ludGVyVHlwZSh0KSxyPXgoUC5nZXRFdmVudFRhcmdldHModCksMiksbz1yWzBdLGk9clsxXSxhPVtdO2lmKC9edG91Y2gvLnRlc3QodC50eXBlKSl7dy5wcmV2VG91Y2hUaW1lPXcubm93KCk7Zm9yKHZhciB1PTA7dTx0LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDt1Kyspe3M9dC5jaGFuZ2VkVG91Y2hlc1t1XTt2YXIgcyxsPXtwb2ludGVyOnMscG9pbnRlcklkOlAuZ2V0UG9pbnRlcklkKHMpLHBvaW50ZXJUeXBlOm4sZXZlbnRUeXBlOnQudHlwZSxldmVudFRhcmdldDpvLGN1ckV2ZW50VGFyZ2V0Omksc2NvcGU6d30sYz1TKGwpO2EucHVzaChbbC5wb2ludGVyLGwuZXZlbnRUYXJnZXQsbC5jdXJFdmVudFRhcmdldCxjXSl9fWVsc2V7dmFyIGY9ITE7aWYoIV8uZGVmYXVsdC5zdXBwb3J0c1BvaW50ZXJFdmVudCYmL21vdXNlLy50ZXN0KHQudHlwZSkpe2Zvcih2YXIgcD0wO3A8ZS5sZW5ndGgmJiFmO3ArKylmPVwibW91c2VcIiE9PWVbcF0ucG9pbnRlclR5cGUmJmVbcF0ucG9pbnRlcklzRG93bjtmPWZ8fHcubm93KCktdy5wcmV2VG91Y2hUaW1lPDUwMHx8MD09PXQudGltZVN0YW1wfWlmKCFmKXt2YXIgZD17cG9pbnRlcjp0LHBvaW50ZXJJZDpQLmdldFBvaW50ZXJJZCh0KSxwb2ludGVyVHlwZTpuLGV2ZW50VHlwZTp0LnR5cGUsY3VyRXZlbnRUYXJnZXQ6aSxldmVudFRhcmdldDpvLHNjb3BlOnd9LHY9UyhkKTthLnB1c2goW2QucG9pbnRlcixkLmV2ZW50VGFyZ2V0LGQuY3VyRXZlbnRUYXJnZXQsdl0pfX1mb3IodmFyIHk9MDt5PGEubGVuZ3RoO3krKyl7dmFyIGg9eChhW3ldLDQpLGc9aFswXSxiPWhbMV0sbT1oWzJdO2hbM11bT10oZyx0LGIsbSl9fX1mdW5jdGlvbiBTKHQpe3ZhciBlPXQucG9pbnRlclR5cGUsbj10LnNjb3BlLHI9e2ludGVyYWN0aW9uOm8uZGVmYXVsdC5zZWFyY2godCksc2VhcmNoRGV0YWlsczp0fTtyZXR1cm4gbi5maXJlKFwiaW50ZXJhY3Rpb25zOmZpbmRcIixyKSxyLmludGVyYWN0aW9ufHxuLmludGVyYWN0aW9ucy5uZXcoe3BvaW50ZXJUeXBlOmV9KX1mdW5jdGlvbiByKHQsZSl7dmFyIG49dC5kb2Mscj10LnNjb3BlLG89dC5vcHRpb25zLGk9ci5pbnRlcmFjdGlvbnMuZG9jRXZlbnRzLGE9ci5ldmVudHMsdT1hW2VdO2Zvcih2YXIgcyBpbiByLmJyb3dzZXIuaXNJT1MmJiFvLmV2ZW50cyYmKG8uZXZlbnRzPXtwYXNzaXZlOiExfSksYS5kZWxlZ2F0ZWRFdmVudHMpdShuLHMsYS5kZWxlZ2F0ZUxpc3RlbmVyKSx1KG4scyxhLmRlbGVnYXRlVXNlQ2FwdHVyZSwhMCk7Zm9yKHZhciBsPW8mJm8uZXZlbnRzLGM9MDtjPGkubGVuZ3RoO2MrKyl7dmFyIGY7Zj1pW2NdO3UobixmLnR5cGUsZi5saXN0ZW5lcixsKX19dmFyIGk9e2lkOlwiY29yZS9pbnRlcmFjdGlvbnNcIixpbnN0YWxsOmZ1bmN0aW9uKG8pe2Zvcih2YXIgdD17fSxlPTA7ZTx5Lmxlbmd0aDtlKyspe3ZhciBuO249eVtlXTt0W25dPWgobixvKX12YXIgcixpPV8uZGVmYXVsdC5wRXZlbnRUeXBlcztmdW5jdGlvbiBhKCl7Zm9yKHZhciB0PTA7dDxvLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDt0Kyspe3ZhciBlPW8uaW50ZXJhY3Rpb25zLmxpc3RbdF07aWYoZS5wb2ludGVySXNEb3duJiZcInRvdWNoXCI9PT1lLnBvaW50ZXJUeXBlJiYhZS5faW50ZXJhY3RpbmcpZm9yKHZhciBuPWZ1bmN0aW9uKCl7dmFyIG49ZS5wb2ludGVyc1tyXTtvLmRvY3VtZW50cy5zb21lKGZ1bmN0aW9uKHQpe3ZhciBlPXQuZG9jO3JldHVybigwLCQubm9kZUNvbnRhaW5zKShlLG4uZG93blRhcmdldCl9KXx8ZS5yZW1vdmVQb2ludGVyKG4ucG9pbnRlcixuLmV2ZW50KX0scj0wO3I8ZS5wb2ludGVycy5sZW5ndGg7cisrKXtuKCl9fX0ocj11LmRlZmF1bHQuUG9pbnRlckV2ZW50P1t7dHlwZTppLmRvd24sbGlzdGVuZXI6YX0se3R5cGU6aS5kb3duLGxpc3RlbmVyOnQucG9pbnRlckRvd259LHt0eXBlOmkubW92ZSxsaXN0ZW5lcjp0LnBvaW50ZXJNb3ZlfSx7dHlwZTppLnVwLGxpc3RlbmVyOnQucG9pbnRlclVwfSx7dHlwZTppLmNhbmNlbCxsaXN0ZW5lcjp0LnBvaW50ZXJVcH1dOlt7dHlwZTpcIm1vdXNlZG93blwiLGxpc3RlbmVyOnQucG9pbnRlckRvd259LHt0eXBlOlwibW91c2Vtb3ZlXCIsbGlzdGVuZXI6dC5wb2ludGVyTW92ZX0se3R5cGU6XCJtb3VzZXVwXCIsbGlzdGVuZXI6dC5wb2ludGVyVXB9LHt0eXBlOlwidG91Y2hzdGFydFwiLGxpc3RlbmVyOmF9LHt0eXBlOlwidG91Y2hzdGFydFwiLGxpc3RlbmVyOnQucG9pbnRlckRvd259LHt0eXBlOlwidG91Y2htb3ZlXCIsbGlzdGVuZXI6dC5wb2ludGVyTW92ZX0se3R5cGU6XCJ0b3VjaGVuZFwiLGxpc3RlbmVyOnQucG9pbnRlclVwfSx7dHlwZTpcInRvdWNoY2FuY2VsXCIsbGlzdGVuZXI6dC5wb2ludGVyVXB9XSkucHVzaCh7dHlwZTpcImJsdXJcIixsaXN0ZW5lcjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPG8uaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO2UrKyl7by5pbnRlcmFjdGlvbnMubGlzdFtlXS5kb2N1bWVudEJsdXIodCl9fX0pLG8ucHJldlRvdWNoVGltZT0wLG8uSW50ZXJhY3Rpb249ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyx0KSxwKHRoaXMsZCh0KS5hcHBseSh0aGlzLGFyZ3VtZW50cykpfXZhciBlLG4scjtyZXR1cm4gZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJnYodCxlKX0odCxzW1wiZGVmYXVsdFwiXSksZT10LChuPVt7a2V5OlwiX25vd1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIG8ubm93KCl9fSx7a2V5OlwicG9pbnRlck1vdmVUb2xlcmFuY2VcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5pbnRlcmFjdGlvbnMucG9pbnRlck1vdmVUb2xlcmFuY2V9LHNldDpmdW5jdGlvbih0KXtvLmludGVyYWN0aW9ucy5wb2ludGVyTW92ZVRvbGVyYW5jZT10fX1dKSYmZihlLnByb3RvdHlwZSxuKSxyJiZmKGUsciksdH0oKSxvLmludGVyYWN0aW9ucz17bGlzdDpbXSxuZXc6ZnVuY3Rpb24odCl7dC5zY29wZUZpcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gby5maXJlKHQsZSl9O3ZhciBlPW5ldyBvLkludGVyYWN0aW9uKHQpO3JldHVybiBvLmludGVyYWN0aW9ucy5saXN0LnB1c2goZSksZX0sbGlzdGVuZXJzOnQsZG9jRXZlbnRzOnIscG9pbnRlck1vdmVUb2xlcmFuY2U6MX0sby51c2VQbHVnaW4obC5kZWZhdWx0KX0sbGlzdGVuZXJzOntcInNjb3BlOmFkZC1kb2N1bWVudFwiOmZ1bmN0aW9uKHQpe3JldHVybiByKHQsXCJhZGRcIil9LFwic2NvcGU6cmVtb3ZlLWRvY3VtZW50XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHIodCxcInJlbW92ZVwiKX0sXCJpbnRlcmFjdGFibGU6dW5zZXRcIjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmludGVyYWN0YWJsZSxyPWUuaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoLTE7MDw9cjtyLS0pe3ZhciBvPWUuaW50ZXJhY3Rpb25zLmxpc3Rbcl07by5pbnRlcmFjdGFibGU9PT1uJiYoby5zdG9wKCksZS5maXJlKFwiaW50ZXJhY3Rpb25zOmRlc3Ryb3lcIix7aW50ZXJhY3Rpb246b30pLG8uZGVzdHJveSgpLDI8ZS5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGgmJmUuaW50ZXJhY3Rpb25zLmxpc3Quc3BsaWNlKHIsMSkpfX19LG9uRG9jU2lnbmFsOnIsZG9PbkludGVyYWN0aW9uczpoLG1ldGhvZE5hbWVzOnl9O2UuZGVmYXVsdD1pfSksVD10KGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYSh0KXtyZXR1cm4oYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PWUuSW50ZXJhY3RTdGF0aWM9dm9pZCAwO3ZhciBuLHI9KG49QykmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59LHU9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09YSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1sKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KGxlKSxzPW0oe30pO2Z1bmN0aW9uIGwoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBsPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gbyh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gYyh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKHIpe3ZhciBvPXRoaXM7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxhKSx0aGlzLnNjb3BlPXIsYyh0aGlzLFwiZ2V0UG9pbnRlckF2ZXJhZ2VcIix1LnBvaW50ZXIucG9pbnRlckF2ZXJhZ2UpLGModGhpcyxcImdldFRvdWNoQkJveFwiLHUucG9pbnRlci50b3VjaEJCb3gpLGModGhpcyxcImdldFRvdWNoRGlzdGFuY2VcIix1LnBvaW50ZXIudG91Y2hEaXN0YW5jZSksYyh0aGlzLFwiZ2V0VG91Y2hBbmdsZVwiLHUucG9pbnRlci50b3VjaEFuZ2xlKSxjKHRoaXMsXCJnZXRFbGVtZW50UmVjdFwiLHUuZG9tLmdldEVsZW1lbnRSZWN0KSxjKHRoaXMsXCJnZXRFbGVtZW50Q2xpZW50UmVjdFwiLHUuZG9tLmdldEVsZW1lbnRDbGllbnRSZWN0KSxjKHRoaXMsXCJtYXRjaGVzU2VsZWN0b3JcIix1LmRvbS5tYXRjaGVzU2VsZWN0b3IpLGModGhpcyxcImNsb3Nlc3RcIix1LmRvbS5jbG9zZXN0KSxjKHRoaXMsXCJnbG9iYWxFdmVudHNcIix7fSksYyh0aGlzLFwiZHluYW1pY0Ryb3BcIix2b2lkIDApLGModGhpcyxcInZlcnNpb25cIixcIjEuOS44XCIpLGModGhpcyxcImludGVyYWN0XCIsdm9pZCAwKTtmb3IodmFyIHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsZT1mdW5jdGlvbih0LGUpe3ZhciBuPXIuaW50ZXJhY3RhYmxlcy5nZXQodCxlKTtyZXR1cm4gbnx8KChuPXIuaW50ZXJhY3RhYmxlcy5uZXcodCxlKSkuZXZlbnRzLmdsb2JhbD1vLmdsb2JhbEV2ZW50cyksbn0sbj0wO248T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpLmxlbmd0aDtuKyspe3ZhciBpO2k9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpW25dO2VbaV09dFtpXX1yZXR1cm4gdS5leHRlbmQoZSx0aGlzKSxlLmNvbnN0cnVjdG9yPXRoaXMuY29uc3RydWN0b3IsdGhpcy5pbnRlcmFjdD1lfXZhciB0LGUsbjtyZXR1cm4gdD1hLChlPVt7a2V5OlwidXNlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zY29wZS51c2VQbHVnaW4odCxlKSx0aGlzfX0se2tleTpcImlzU2V0XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4hIXRoaXMuc2NvcGUuaW50ZXJhY3RhYmxlcy5nZXQodCxlJiZlLmNvbnRleHQpfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe2lmKHUuaXMuc3RyaW5nKHQpJiYtMSE9PXQuc2VhcmNoKFwiIFwiKSYmKHQ9dC50cmltKCkuc3BsaXQoLyArLykpLHUuaXMuYXJyYXkodCkpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbz10W3JdO3RoaXMub24obyxlLG4pfXJldHVybiB0aGlzfWlmKHUuaXMub2JqZWN0KHQpKXtmb3IodmFyIGkgaW4gdCl0aGlzLm9uKGksdFtpXSxlKTtyZXR1cm4gdGhpc31yZXR1cm4oMCxzLmlzTm9uTmF0aXZlRXZlbnQpKHQsdGhpcy5zY29wZS5hY3Rpb25zKT90aGlzLmdsb2JhbEV2ZW50c1t0XT90aGlzLmdsb2JhbEV2ZW50c1t0XS5wdXNoKGUpOnRoaXMuZ2xvYmFsRXZlbnRzW3RdPVtlXTp0aGlzLnNjb3BlLmV2ZW50cy5hZGQodGhpcy5zY29wZS5kb2N1bWVudCx0LGUse29wdGlvbnM6bn0pLHRoaXN9fSx7a2V5Olwib2ZmXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe2lmKHUuaXMuc3RyaW5nKHQpJiYtMSE9PXQuc2VhcmNoKFwiIFwiKSYmKHQ9dC50cmltKCkuc3BsaXQoLyArLykpLHUuaXMuYXJyYXkodCkpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbz10W3JdO3RoaXMub2ZmKG8sZSxuKX1yZXR1cm4gdGhpc31pZih1LmlzLm9iamVjdCh0KSl7Zm9yKHZhciBpIGluIHQpdGhpcy5vZmYoaSx0W2ldLGUpO3JldHVybiB0aGlzfXZhciBhOygwLHMuaXNOb25OYXRpdmVFdmVudCkodCx0aGlzLnNjb3BlLmFjdGlvbnMpP3QgaW4gdGhpcy5nbG9iYWxFdmVudHMmJi0xIT09KGE9dGhpcy5nbG9iYWxFdmVudHNbdF0uaW5kZXhPZihlKSkmJnRoaXMuZ2xvYmFsRXZlbnRzW3RdLnNwbGljZShhLDEpOnRoaXMuc2NvcGUuZXZlbnRzLnJlbW92ZSh0aGlzLnNjb3BlLmRvY3VtZW50LHQsZSxuKTtyZXR1cm4gdGhpc319LHtrZXk6XCJkZWJ1Z1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2NvcGV9fSx7a2V5Olwic3VwcG9ydHNUb3VjaFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5zdXBwb3J0c1RvdWNofX0se2tleTpcInN1cHBvcnRzUG9pbnRlckV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0LnN1cHBvcnRzUG9pbnRlckV2ZW50fX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5zY29wZS5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7dCsrKXt0aGlzLnNjb3BlLmludGVyYWN0aW9ucy5saXN0W3RdLnN0b3AoKX1yZXR1cm4gdGhpc319LHtrZXk6XCJwb2ludGVyTW92ZVRvbGVyYW5jZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB1LmlzLm51bWJlcih0KT8odGhpcy5zY29wZS5pbnRlcmFjdGlvbnMucG9pbnRlck1vdmVUb2xlcmFuY2U9dCx0aGlzKTp0aGlzLnNjb3BlLmludGVyYWN0aW9ucy5wb2ludGVyTW92ZVRvbGVyYW5jZX19LHtrZXk6XCJhZGREb2N1bWVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5zY29wZS5hZGREb2N1bWVudCh0LGUpfX0se2tleTpcInJlbW92ZURvY3VtZW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5zY29wZS5yZW1vdmVEb2N1bWVudCh0KX19XSkmJm8odC5wcm90b3R5cGUsZSksbiYmbyh0LG4pLGF9KCksZj1lLkludGVyYWN0U3RhdGljPWk7ZS5kZWZhdWx0PWZ9KSxlPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD12b2lkIDA7ZS5kZWZhdWx0PWZ1bmN0aW9uKHQpe3JldHVybiEoIXR8fCF0LldpbmRvdykmJnQgaW5zdGFuY2VvZiB0LldpbmRvd307dmFyIE89e307T2JqZWN0LmRlZmluZVByb3BlcnR5KE8sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksTy5pbml0PWksTy5nZXRXaW5kb3c9YSxPLmRlZmF1bHQ9dm9pZCAwO3ZhciBuLHI9KG49ZSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3ZhciBvPXtyZWFsV2luZG93OnZvaWQgMCx3aW5kb3c6dm9pZCAwLGdldFdpbmRvdzphLGluaXQ6aX07ZnVuY3Rpb24gaSh0KXt2YXIgZT0oby5yZWFsV2luZG93PXQpLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO2Uub3duZXJEb2N1bWVudCE9PXQuZG9jdW1lbnQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQud3JhcCYmdC53cmFwKGUpPT09ZSYmKHQ9dC53cmFwKHQpKSxvLndpbmRvdz10fWZ1bmN0aW9uIGEodCl7cmV0dXJuKDAsci5kZWZhdWx0KSh0KT90Oih0Lm93bmVyRG9jdW1lbnR8fHQpLmRlZmF1bHRWaWV3fHxvLndpbmRvd31cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93PyhvLndpbmRvdz12b2lkIDAsby5yZWFsV2luZG93PXZvaWQgMCk6aSh3aW5kb3cpLG8uaW5pdD1pO3ZhciB1PW87Ty5kZWZhdWx0PXU7dmFyIHc9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHcsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdy5hcnJheT13LnBsYWluT2JqZWN0PXcuZWxlbWVudD13LnN0cmluZz13LmJvb2w9dy5udW1iZXI9dy5mdW5jPXcub2JqZWN0PXcuZG9jRnJhZz13LndpbmRvdz12b2lkIDA7dmFyIHM9YyhlKSxsPWMoTyk7ZnVuY3Rpb24gYyh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gZih0KXtyZXR1cm4oZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9dy53aW5kb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1sLmRlZmF1bHQud2luZG93fHwoMCxzLmRlZmF1bHQpKHQpfTt3LmRvY0ZyYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHAodCkmJjExPT09dC5ub2RlVHlwZX07dmFyIHA9ZnVuY3Rpb24odCl7cmV0dXJuISF0JiZcIm9iamVjdFwiPT09Zih0KX07dy5vYmplY3Q9cDtmdW5jdGlvbiBkKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHR9dy5mdW5jPWQ7dy5udW1iZXI9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHR9O3cuYm9vbD1mdW5jdGlvbih0KXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIHR9O3cuc3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fTt3LmVsZW1lbnQ9ZnVuY3Rpb24odCl7aWYoIXR8fFwib2JqZWN0XCIhPT1mKHQpKXJldHVybiExO3ZhciBlPWwuZGVmYXVsdC5nZXRXaW5kb3codCl8fGwuZGVmYXVsdC53aW5kb3c7cmV0dXJuL29iamVjdHxmdW5jdGlvbi8udGVzdChmKGUuRWxlbWVudCkpP3QgaW5zdGFuY2VvZiBlLkVsZW1lbnQ6MT09PXQubm9kZVR5cGUmJlwic3RyaW5nXCI9PXR5cGVvZiB0Lm5vZGVOYW1lfTt3LnBsYWluT2JqZWN0PWZ1bmN0aW9uKHQpe3JldHVybiBwKHQpJiYhIXQuY29uc3RydWN0b3ImJi9mdW5jdGlvbiBPYmplY3RcXGIvLnRlc3QodC5jb25zdHJ1Y3Rvci50b1N0cmluZygpKX07dy5hcnJheT1mdW5jdGlvbih0KXtyZXR1cm4gcCh0KSYmdm9pZCAwIT09dC5sZW5ndGgmJmQodC5zcGxpY2UpfTt2YXIgdj17fTtmdW5jdGlvbiB5KHQpe3JldHVybih5PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx2LmRlZmF1bHQ9dm9pZCAwO3ZhciBoPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PXkodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9ZygpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh3KTtmdW5jdGlvbiBnKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gZz1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIGIodCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtpZihcImRyYWdcIj09PWUucHJlcGFyZWQubmFtZSl7dmFyIG49ZS5wcmVwYXJlZC5heGlzO1wieFwiPT09bj8oZS5jb29yZHMuY3VyLnBhZ2UueT1lLmNvb3Jkcy5zdGFydC5wYWdlLnksZS5jb29yZHMuY3VyLmNsaWVudC55PWUuY29vcmRzLnN0YXJ0LmNsaWVudC55LGUuY29vcmRzLnZlbG9jaXR5LmNsaWVudC55PTAsZS5jb29yZHMudmVsb2NpdHkucGFnZS55PTApOlwieVwiPT09biYmKGUuY29vcmRzLmN1ci5wYWdlLng9ZS5jb29yZHMuc3RhcnQucGFnZS54LGUuY29vcmRzLmN1ci5jbGllbnQueD1lLmNvb3Jkcy5zdGFydC5jbGllbnQueCxlLmNvb3Jkcy52ZWxvY2l0eS5jbGllbnQueD0wLGUuY29vcmRzLnZlbG9jaXR5LnBhZ2UueD0wKX19ZnVuY3Rpb24gXyh0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb247aWYoXCJkcmFnXCI9PT1uLnByZXBhcmVkLm5hbWUpe3ZhciByPW4ucHJlcGFyZWQuYXhpcztpZihcInhcIj09PXJ8fFwieVwiPT09cil7dmFyIG89XCJ4XCI9PT1yP1wieVwiOlwieFwiO2UucGFnZVtvXT1uLmNvb3Jkcy5zdGFydC5wYWdlW29dLGUuY2xpZW50W29dPW4uY29vcmRzLnN0YXJ0LmNsaWVudFtvXSxlLmRlbHRhW29dPTB9fX12YXIgUD17aWQ6XCJhY3Rpb25zL2RyYWdcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuYWN0aW9ucyxuPXQuSW50ZXJhY3RhYmxlLHI9dC5kZWZhdWx0cztuLnByb3RvdHlwZS5kcmFnZ2FibGU9UC5kcmFnZ2FibGUsZS5tYXAuZHJhZz1QLGUubWV0aG9kRGljdC5kcmFnPVwiZHJhZ2dhYmxlXCIsci5hY3Rpb25zLmRyYWc9UC5kZWZhdWx0c30sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLW1vdmVcIjpiLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1yZXN1bWVcIjpiLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlXCI6XyxcImF1dG8tc3RhcnQ6Y2hlY2tcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5pbnRlcmFjdGFibGUscj10LmJ1dHRvbnMsbz1uLm9wdGlvbnMuZHJhZztpZihvJiZvLmVuYWJsZWQmJighZS5wb2ludGVySXNEb3dufHwhL21vdXNlfHBvaW50ZXIvLnRlc3QoZS5wb2ludGVyVHlwZSl8fDAhPShyJm4ub3B0aW9ucy5kcmFnLm1vdXNlQnV0dG9ucykpKXJldHVybiEodC5hY3Rpb249e25hbWU6XCJkcmFnXCIsYXhpczpcInN0YXJ0XCI9PT1vLmxvY2tBeGlzP28uc3RhcnRBeGlzOm8ubG9ja0F4aXN9KX19LGRyYWdnYWJsZTpmdW5jdGlvbih0KXtyZXR1cm4gaC5vYmplY3QodCk/KHRoaXMub3B0aW9ucy5kcmFnLmVuYWJsZWQ9ITEhPT10LmVuYWJsZWQsdGhpcy5zZXRQZXJBY3Rpb24oXCJkcmFnXCIsdCksdGhpcy5zZXRPbkV2ZW50cyhcImRyYWdcIix0KSwvXih4eXx4fHl8c3RhcnQpJC8udGVzdCh0LmxvY2tBeGlzKSYmKHRoaXMub3B0aW9ucy5kcmFnLmxvY2tBeGlzPXQubG9ja0F4aXMpLC9eKHh5fHh8eSkkLy50ZXN0KHQuc3RhcnRBeGlzKSYmKHRoaXMub3B0aW9ucy5kcmFnLnN0YXJ0QXhpcz10LnN0YXJ0QXhpcyksdGhpcyk6aC5ib29sKHQpPyh0aGlzLm9wdGlvbnMuZHJhZy5lbmFibGVkPXQsdGhpcyk6dGhpcy5vcHRpb25zLmRyYWd9LGJlZm9yZU1vdmU6Yixtb3ZlOl8sZGVmYXVsdHM6e3N0YXJ0QXhpczpcInh5XCIsbG9ja0F4aXM6XCJ4eVwifSxnZXRDdXJzb3I6ZnVuY3Rpb24oKXtyZXR1cm5cIm1vdmVcIn19LHg9UDt2LmRlZmF1bHQ9eDt2YXIgUz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoUyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxTLmZpbmQ9Uy5maW5kSW5kZXg9Uy5mcm9tPVMubWVyZ2U9Uy5yZW1vdmU9Uy5jb250YWlucz12b2lkIDA7Uy5jb250YWlucz1mdW5jdGlvbih0LGUpe3JldHVybi0xIT09dC5pbmRleE9mKGUpfTtTLnJlbW92ZT1mdW5jdGlvbih0LGUpe3JldHVybiB0LnNwbGljZSh0LmluZGV4T2YoZSksMSl9O2Z1bmN0aW9uIGoodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTt0LnB1c2gocil9cmV0dXJuIHR9Uy5tZXJnZT1qO1MuZnJvbT1mdW5jdGlvbih0KXtyZXR1cm4gaihbXSx0KX07ZnVuY3Rpb24gTSh0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKGUodFtuXSxuLHQpKXJldHVybiBuO3JldHVybi0xfVMuZmluZEluZGV4PU07Uy5maW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbTSh0LGUpXX07dmFyIEQ9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KEQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksRC5kZWZhdWx0PXZvaWQgMDt2YXIgST17aW5pdDpmdW5jdGlvbih0KXt2YXIgZT10O0kuZG9jdW1lbnQ9ZS5kb2N1bWVudCxJLkRvY3VtZW50RnJhZ21lbnQ9ZS5Eb2N1bWVudEZyYWdtZW50fHx6LEkuU1ZHRWxlbWVudD1lLlNWR0VsZW1lbnR8fHosSS5TVkdTVkdFbGVtZW50PWUuU1ZHU1ZHRWxlbWVudHx8eixJLlNWR0VsZW1lbnRJbnN0YW5jZT1lLlNWR0VsZW1lbnRJbnN0YW5jZXx8eixJLkVsZW1lbnQ9ZS5FbGVtZW50fHx6LEkuSFRNTEVsZW1lbnQ9ZS5IVE1MRWxlbWVudHx8SS5FbGVtZW50LEkuRXZlbnQ9ZS5FdmVudCxJLlRvdWNoPWUuVG91Y2h8fHosSS5Qb2ludGVyRXZlbnQ9ZS5Qb2ludGVyRXZlbnR8fGUuTVNQb2ludGVyRXZlbnR9LGRvY3VtZW50Om51bGwsRG9jdW1lbnRGcmFnbWVudDpudWxsLFNWR0VsZW1lbnQ6bnVsbCxTVkdTVkdFbGVtZW50Om51bGwsU1ZHRWxlbWVudEluc3RhbmNlOm51bGwsRWxlbWVudDpudWxsLEhUTUxFbGVtZW50Om51bGwsRXZlbnQ6bnVsbCxUb3VjaDpudWxsLFBvaW50ZXJFdmVudDpudWxsfTtmdW5jdGlvbiB6KCl7fXZhciBBPUk7RC5kZWZhdWx0PUE7dmFyIEM9e307ZnVuY3Rpb24gVyh0KXtyZXR1cm4oVz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KEMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksQy5kZWZhdWx0PXZvaWQgMDt2YXIgUj1OKEQpLEY9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09Vyh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1ZKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHcpLFg9TihPKTtmdW5jdGlvbiBZKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gWT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIE4odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fXZhciBMPXtpbml0OmZ1bmN0aW9uKHQpe3ZhciBlPVIuZGVmYXVsdC5FbGVtZW50LG49WC5kZWZhdWx0LndpbmRvdy5uYXZpZ2F0b3I7TC5zdXBwb3J0c1RvdWNoPVwib250b3VjaHN0YXJ0XCJpbiB0fHxGLmZ1bmModC5Eb2N1bWVudFRvdWNoKSYmUi5kZWZhdWx0LmRvY3VtZW50IGluc3RhbmNlb2YgdC5Eb2N1bWVudFRvdWNoLEwuc3VwcG9ydHNQb2ludGVyRXZlbnQ9ITEhPT1uLnBvaW50ZXJFbmFibGVkJiYhIVIuZGVmYXVsdC5Qb2ludGVyRXZlbnQsTC5pc0lPUz0vaVAoaG9uZXxvZHxhZCkvLnRlc3Qobi5wbGF0Zm9ybSksTC5pc0lPUzc9L2lQKGhvbmV8b2R8YWQpLy50ZXN0KG4ucGxhdGZvcm0pJiYvT1MgN1teXFxkXS8udGVzdChuLmFwcFZlcnNpb24pLEwuaXNJZTk9L01TSUUgOS8udGVzdChuLnVzZXJBZ2VudCksTC5pc09wZXJhTW9iaWxlPVwiT3BlcmFcIj09PW4uYXBwTmFtZSYmTC5zdXBwb3J0c1RvdWNoJiYvUHJlc3RvLy50ZXN0KG4udXNlckFnZW50KSxMLnByZWZpeGVkTWF0Y2hlc1NlbGVjdG9yPVwibWF0Y2hlc1wiaW4gZS5wcm90b3R5cGU/XCJtYXRjaGVzXCI6XCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3JcImluIGUucHJvdG90eXBlP1wid2Via2l0TWF0Y2hlc1NlbGVjdG9yXCI6XCJtb3pNYXRjaGVzU2VsZWN0b3JcImluIGUucHJvdG90eXBlP1wibW96TWF0Y2hlc1NlbGVjdG9yXCI6XCJvTWF0Y2hlc1NlbGVjdG9yXCJpbiBlLnByb3RvdHlwZT9cIm9NYXRjaGVzU2VsZWN0b3JcIjpcIm1zTWF0Y2hlc1NlbGVjdG9yXCIsTC5wRXZlbnRUeXBlcz1MLnN1cHBvcnRzUG9pbnRlckV2ZW50P1IuZGVmYXVsdC5Qb2ludGVyRXZlbnQ9PT10Lk1TUG9pbnRlckV2ZW50P3t1cDpcIk1TUG9pbnRlclVwXCIsZG93bjpcIk1TUG9pbnRlckRvd25cIixvdmVyOlwibW91c2VvdmVyXCIsb3V0OlwibW91c2VvdXRcIixtb3ZlOlwiTVNQb2ludGVyTW92ZVwiLGNhbmNlbDpcIk1TUG9pbnRlckNhbmNlbFwifTp7dXA6XCJwb2ludGVydXBcIixkb3duOlwicG9pbnRlcmRvd25cIixvdmVyOlwicG9pbnRlcm92ZXJcIixvdXQ6XCJwb2ludGVyb3V0XCIsbW92ZTpcInBvaW50ZXJtb3ZlXCIsY2FuY2VsOlwicG9pbnRlcmNhbmNlbFwifTpudWxsLEwud2hlZWxFdmVudD1cIm9ubW91c2V3aGVlbFwiaW4gUi5kZWZhdWx0LmRvY3VtZW50P1wibW91c2V3aGVlbFwiOlwid2hlZWxcIn0sc3VwcG9ydHNUb3VjaDpudWxsLHN1cHBvcnRzUG9pbnRlckV2ZW50Om51bGwsaXNJT1M3Om51bGwsaXNJT1M6bnVsbCxpc0llOTpudWxsLGlzT3BlcmFNb2JpbGU6bnVsbCxwcmVmaXhlZE1hdGNoZXNTZWxlY3RvcjpudWxsLHBFdmVudFR5cGVzOm51bGwsd2hlZWxFdmVudDpudWxsfTt2YXIgQj1MO0MuZGVmYXVsdD1CO3ZhciBWPXt9O2Z1bmN0aW9uIHEodCl7cmV0dXJuKHE9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShWLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFYuZGVmYXVsdD1mdW5jdGlvbiB0KGUpe3ZhciBuPXt9O2Zvcih2YXIgciBpbiBlKXt2YXIgbz1lW3JdO0cucGxhaW5PYmplY3Qobyk/bltyXT10KG8pOkcuYXJyYXkobyk/bltyXT1VLmZyb20obyk6bltyXT1vfXJldHVybiBufTt2YXIgVT1LKFMpLEc9Syh3KTtmdW5jdGlvbiBIKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gSD1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIEsodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09cSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1IKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59dmFyICQ9e307ZnVuY3Rpb24gWih0KXtyZXR1cm4oWj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KCQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksJC5ub2RlQ29udGFpbnM9ZnVuY3Rpb24odCxlKXtmb3IoO2U7KXtpZihlPT09dClyZXR1cm4hMDtlPWUucGFyZW50Tm9kZX1yZXR1cm4hMX0sJC5jbG9zZXN0PWZ1bmN0aW9uKHQsZSl7Zm9yKDt0dC5lbGVtZW50KHQpOyl7aWYoYXQodCxlKSlyZXR1cm4gdDt0PWl0KHQpfXJldHVybiBudWxsfSwkLnBhcmVudE5vZGU9aXQsJC5tYXRjaGVzU2VsZWN0b3I9YXQsJC5pbmRleE9mRGVlcGVzdEVsZW1lbnQ9ZnVuY3Rpb24odCl7dmFyIGUsbixyPVtdLG89dFswXSxpPW8/MDotMTtmb3IoZT0xO2U8dC5sZW5ndGg7ZSsrKXt2YXIgYT10W2VdO2lmKGEmJmEhPT1vKWlmKG8pe2lmKGEucGFyZW50Tm9kZSE9PWEub3duZXJEb2N1bWVudClpZihvLnBhcmVudE5vZGUhPT1hLm93bmVyRG9jdW1lbnQpaWYoYS5wYXJlbnROb2RlIT09by5wYXJlbnROb2RlKXtpZighci5sZW5ndGgpZm9yKHZhciB1PW8scz12b2lkIDA7KHM9dXQodSkpJiZzIT09dS5vd25lckRvY3VtZW50OylyLnVuc2hpZnQodSksdT1zO3ZhciBsPXZvaWQgMDtpZihvIGluc3RhbmNlb2YgUS5kZWZhdWx0LkhUTUxFbGVtZW50JiZhIGluc3RhbmNlb2YgUS5kZWZhdWx0LlNWR0VsZW1lbnQmJiEoYSBpbnN0YW5jZW9mIFEuZGVmYXVsdC5TVkdTVkdFbGVtZW50KSl7aWYoYT09PW8ucGFyZW50Tm9kZSljb250aW51ZTtsPWEub3duZXJTVkdFbGVtZW50fWVsc2UgbD1hO2Zvcih2YXIgYz1bXTtsLnBhcmVudE5vZGUhPT1sLm93bmVyRG9jdW1lbnQ7KWMudW5zaGlmdChsKSxsPXV0KGwpO2ZvcihuPTA7Y1tuXSYmY1tuXT09PXJbbl07KW4rKztmb3IodmFyIGY9W2Nbbi0xXSxjW25dLHJbbl1dLHA9ZlswXS5sYXN0Q2hpbGQ7cDspe2lmKHA9PT1mWzFdKXtvPWEsaT1lLHI9YzticmVha31pZihwPT09ZlsyXSlicmVhaztwPXAucHJldmlvdXNTaWJsaW5nfX1lbHNle3ZhciBkPXBhcnNlSW50KCgwLGV0LmdldFdpbmRvdykobykuZ2V0Q29tcHV0ZWRTdHlsZShvKS56SW5kZXgsMTApfHwwLHY9cGFyc2VJbnQoKDAsZXQuZ2V0V2luZG93KShhKS5nZXRDb21wdXRlZFN0eWxlKGEpLnpJbmRleCwxMCl8fDA7ZDw9diYmKG89YSxpPWUpfWVsc2Ugbz1hLGk9ZX1lbHNlIG89YSxpPWV9cmV0dXJuIGl9LCQubWF0Y2hlc1VwVG89ZnVuY3Rpb24odCxlLG4pe2Zvcig7dHQuZWxlbWVudCh0KTspe2lmKGF0KHQsZSkpcmV0dXJuITA7aWYoKHQ9aXQodCkpPT09bilyZXR1cm4gYXQodCxlKX1yZXR1cm4hMX0sJC5nZXRBY3R1YWxFbGVtZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgUS5kZWZhdWx0LlNWR0VsZW1lbnRJbnN0YW5jZT90LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50OnR9LCQuZ2V0U2Nyb2xsWFk9c3QsJC5nZXRFbGVtZW50Q2xpZW50UmVjdD1sdCwkLmdldEVsZW1lbnRSZWN0PWZ1bmN0aW9uKHQpe3ZhciBlPWx0KHQpO2lmKCFKLmRlZmF1bHQuaXNJT1M3JiZlKXt2YXIgbj1zdChldC5kZWZhdWx0LmdldFdpbmRvdyh0KSk7ZS5sZWZ0Kz1uLngsZS5yaWdodCs9bi54LGUudG9wKz1uLnksZS5ib3R0b20rPW4ueX1yZXR1cm4gZX0sJC5nZXRQYXRoPWZ1bmN0aW9uKHQpe3ZhciBlPVtdO2Zvcig7dDspZS5wdXNoKHQpLHQ9aXQodCk7cmV0dXJuIGV9LCQudHJ5U2VsZWN0b3I9ZnVuY3Rpb24odCl7cmV0dXJuISF0dC5zdHJpbmcodCkmJihRLmRlZmF1bHQuZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSwhMCl9O3ZhciBKPW90KEMpLFE9b3QoRCksdHQ9cnQodyksZXQ9cnQoTyk7ZnVuY3Rpb24gbnQoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBudD1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIHJ0KHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PVoodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9bnQoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn1mdW5jdGlvbiBvdCh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gaXQodCl7dmFyIGU9dC5wYXJlbnROb2RlO2lmKHR0LmRvY0ZyYWcoZSkpe2Zvcig7KGU9ZS5ob3N0KSYmdHQuZG9jRnJhZyhlKTspO3JldHVybiBlfXJldHVybiBlfWZ1bmN0aW9uIGF0KHQsZSl7cmV0dXJuIGV0LmRlZmF1bHQud2luZG93IT09ZXQuZGVmYXVsdC5yZWFsV2luZG93JiYoZT1lLnJlcGxhY2UoL1xcL2RlZXBcXC8vZyxcIiBcIikpLHRbSi5kZWZhdWx0LnByZWZpeGVkTWF0Y2hlc1NlbGVjdG9yXShlKX12YXIgdXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQucGFyZW50Tm9kZT90LnBhcmVudE5vZGU6dC5ob3N0fTtmdW5jdGlvbiBzdCh0KXtyZXR1cm57eDoodD10fHxldC5kZWZhdWx0LndpbmRvdykuc2Nyb2xsWHx8dC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCx5OnQuc2Nyb2xsWXx8dC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wfX1mdW5jdGlvbiBsdCh0KXt2YXIgZT10IGluc3RhbmNlb2YgUS5kZWZhdWx0LlNWR0VsZW1lbnQ/dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTp0LmdldENsaWVudFJlY3RzKClbMF07cmV0dXJuIGUmJntsZWZ0OmUubGVmdCxyaWdodDplLnJpZ2h0LHRvcDplLnRvcCxib3R0b206ZS5ib3R0b20sd2lkdGg6ZS53aWR0aHx8ZS5yaWdodC1lLmxlZnQsaGVpZ2h0OmUuaGVpZ2h0fHxlLmJvdHRvbS1lLnRvcH19dmFyIGN0PXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShjdCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxjdC5kZWZhdWx0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpdFtuXT1lW25dO3JldHVybiB0fTt2YXIgZnQ9e307ZnVuY3Rpb24gcHQodCl7cmV0dXJuKHB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZnQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZnQuZGVmYXVsdD1mdW5jdGlvbiBuKGUscixvKXtvPW98fHt9O3l0LnN0cmluZyhlKSYmLTEhPT1lLnNlYXJjaChcIiBcIikmJihlPWd0KGUpKTtpZih5dC5hcnJheShlKSlyZXR1cm4gZS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4oMCx2dC5kZWZhdWx0KSh0LG4oZSxyLG8pKX0sbyk7eXQub2JqZWN0KGUpJiYocj1lLGU9XCJcIik7aWYoeXQuZnVuYyhyKSlvW2VdPW9bZV18fFtdLG9bZV0ucHVzaChyKTtlbHNlIGlmKHl0LmFycmF5KHIpKWZvcih2YXIgdD0wO3Q8ci5sZW5ndGg7dCsrKXt2YXIgaT1yW3RdO24oZSxpLG8pfWVsc2UgaWYoeXQub2JqZWN0KHIpKWZvcih2YXIgYSBpbiByKXt2YXIgdT1ndChhKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJcIi5jb25jYXQoZSkuY29uY2F0KHQpfSk7bih1LHJbYV0sbyl9cmV0dXJuIG99O3ZhciBkdCx2dD0oZHQ9Y3QpJiZkdC5fX2VzTW9kdWxlP2R0OntkZWZhdWx0OmR0fSx5dD1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1wdCh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1odCgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh3KTtmdW5jdGlvbiBodCgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIGh0PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gZ3QodCl7cmV0dXJuIHQudHJpbSgpLnNwbGl0KC8gKy8pfXZhciBidD17fTtmdW5jdGlvbiBtdCh0KXtyZXR1cm4obXQ9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShidCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxidC5kZWZhdWx0PXZvaWQgMDt2YXIgT3Q9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09bXQodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9eHQoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oUyksd3Q9UHQoY3QpLF90PVB0KGZ0KTtmdW5jdGlvbiBQdCh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24geHQoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiB4dD1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIFN0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBqdCh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9ZnVuY3Rpb24gTXQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtpZih0LmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZClicmVhaztyKHQpfX12YXIga3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpeyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksanQodGhpcyxcIm9wdGlvbnNcIix2b2lkIDApLGp0KHRoaXMsXCJ0eXBlc1wiLHt9KSxqdCh0aGlzLFwicHJvcGFnYXRpb25TdG9wcGVkXCIsITEpLGp0KHRoaXMsXCJpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcIiwhMSksanQodGhpcyxcImdsb2JhbFwiLHZvaWQgMCksdGhpcy5vcHRpb25zPSgwLHd0LmRlZmF1bHQpKHt9LHR8fHt9KX12YXIgdCxuLHI7cmV0dXJuIHQ9ZSwobj1be2tleTpcImZpcmVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMuZ2xvYmFsOyhlPXRoaXMudHlwZXNbdC50eXBlXSkmJk10KHQsZSksIXQucHJvcGFnYXRpb25TdG9wcGVkJiZuJiYoZT1uW3QudHlwZV0pJiZNdCh0LGUpfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgbj0oMCxfdC5kZWZhdWx0KSh0LGUpO2Zvcih0IGluIG4pdGhpcy50eXBlc1t0XT1PdC5tZXJnZSh0aGlzLnR5cGVzW3RdfHxbXSxuW3RdKX19LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPSgwLF90LmRlZmF1bHQpKHQsZSk7Zm9yKHQgaW4gbil7dmFyIHI9dGhpcy50eXBlc1t0XTtpZihyJiZyLmxlbmd0aClmb3IodmFyIG89MDtvPG5bdF0ubGVuZ3RoO28rKyl7dmFyIGk9blt0XVtvXSxhPXIuaW5kZXhPZihpKTstMSE9PWEmJnIuc3BsaWNlKGEsMSl9fX19LHtrZXk6XCJnZXRSZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH19XSkmJlN0KHQucHJvdG90eXBlLG4pLHImJlN0KHQsciksZX0oKTtidC5kZWZhdWx0PWt0O3ZhciBFdD17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRXQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksRXQuZGVmYXVsdD12b2lkIDA7RXQuZGVmYXVsdD1mdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLnNxcnQodCp0K2UqZSl9O3ZhciBUdD17fTtmdW5jdGlvbiBEdCh0LGUpe2Zvcih2YXIgbiBpbiBlKXt2YXIgcj1EdC5wcmVmaXhlZFByb3BSRXMsbz0hMTtmb3IodmFyIGkgaW4gcilpZigwPT09bi5pbmRleE9mKGkpJiZyW2ldLnRlc3Qobikpe289ITA7YnJlYWt9b3x8XCJmdW5jdGlvblwiPT10eXBlb2YgZVtuXXx8KHRbbl09ZVtuXSl9cmV0dXJuIHR9T2JqZWN0LmRlZmluZVByb3BlcnR5KFR0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFR0LmRlZmF1bHQ9dm9pZCAwLER0LnByZWZpeGVkUHJvcFJFcz17d2Via2l0Oi8oTW92ZW1lbnRbWFldfFJhZGl1c1tYWV18Um90YXRpb25BbmdsZXxGb3JjZSkkLyxtb3o6LyhQcmVzc3VyZSkkL307dmFyIEl0PUR0O1R0LmRlZmF1bHQ9SXQ7dmFyIHp0PXt9O2Z1bmN0aW9uIEF0KHQpe3JldHVybihBdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHp0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHp0LmNvcHlDb29yZHM9ZnVuY3Rpb24odCxlKXt0LnBhZ2U9dC5wYWdlfHx7fSx0LnBhZ2UueD1lLnBhZ2UueCx0LnBhZ2UueT1lLnBhZ2UueSx0LmNsaWVudD10LmNsaWVudHx8e30sdC5jbGllbnQueD1lLmNsaWVudC54LHQuY2xpZW50Lnk9ZS5jbGllbnQueSx0LnRpbWVTdGFtcD1lLnRpbWVTdGFtcH0senQuc2V0Q29vcmREZWx0YXM9ZnVuY3Rpb24odCxlLG4pe3QucGFnZS54PW4ucGFnZS54LWUucGFnZS54LHQucGFnZS55PW4ucGFnZS55LWUucGFnZS55LHQuY2xpZW50Lng9bi5jbGllbnQueC1lLmNsaWVudC54LHQuY2xpZW50Lnk9bi5jbGllbnQueS1lLmNsaWVudC55LHQudGltZVN0YW1wPW4udGltZVN0YW1wLWUudGltZVN0YW1wfSx6dC5zZXRDb29yZFZlbG9jaXR5PWZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5tYXgoZS50aW1lU3RhbXAvMWUzLC4wMDEpO3QucGFnZS54PWUucGFnZS54L24sdC5wYWdlLnk9ZS5wYWdlLnkvbix0LmNsaWVudC54PWUuY2xpZW50Lngvbix0LmNsaWVudC55PWUuY2xpZW50Lnkvbix0LnRpbWVTdGFtcD1ufSx6dC5zZXRaZXJvQ29vcmRzPWZ1bmN0aW9uKHQpe3QucGFnZS54PTAsdC5wYWdlLnk9MCx0LmNsaWVudC54PTAsdC5jbGllbnQueT0wfSx6dC5pc05hdGl2ZVBvaW50ZXI9VnQsenQuZ2V0WFk9cXQsenQuZ2V0UGFnZVhZPVV0LHp0LmdldENsaWVudFhZPUd0LHp0LmdldFBvaW50ZXJJZD1mdW5jdGlvbih0KXtyZXR1cm4gWHQubnVtYmVyKHQucG9pbnRlcklkKT90LnBvaW50ZXJJZDp0LmlkZW50aWZpZXJ9LHp0LnNldENvb3Jkcz1mdW5jdGlvbih0LGUsbil7dmFyIHI9MTxlLmxlbmd0aD9LdChlKTplWzBdLG89e307VXQocixvKSx0LnBhZ2UueD1vLngsdC5wYWdlLnk9by55LEd0KHIsbyksdC5jbGllbnQueD1vLngsdC5jbGllbnQueT1vLnksdC50aW1lU3RhbXA9bn0senQuZ2V0VG91Y2hQYWlyPUh0LHp0LnBvaW50ZXJBdmVyYWdlPUt0LHp0LnRvdWNoQkJveD1mdW5jdGlvbih0KXtpZighKHQubGVuZ3RofHx0LnRvdWNoZXMmJjE8dC50b3VjaGVzLmxlbmd0aCkpcmV0dXJuIG51bGw7dmFyIGU9SHQodCksbj1NYXRoLm1pbihlWzBdLnBhZ2VYLGVbMV0ucGFnZVgpLHI9TWF0aC5taW4oZVswXS5wYWdlWSxlWzFdLnBhZ2VZKSxvPU1hdGgubWF4KGVbMF0ucGFnZVgsZVsxXS5wYWdlWCksaT1NYXRoLm1heChlWzBdLnBhZ2VZLGVbMV0ucGFnZVkpO3JldHVybnt4Om4seTpyLGxlZnQ6bix0b3A6cixyaWdodDpvLGJvdHRvbTppLHdpZHRoOm8tbixoZWlnaHQ6aS1yfX0senQudG91Y2hEaXN0YW5jZT1mdW5jdGlvbih0LGUpe3ZhciBuPWUrXCJYXCIscj1lK1wiWVwiLG89SHQodCksaT1vWzBdW25dLW9bMV1bbl0sYT1vWzBdW3JdLW9bMV1bcl07cmV0dXJuKDAsRnQuZGVmYXVsdCkoaSxhKX0senQudG91Y2hBbmdsZT1mdW5jdGlvbih0LGUpe3ZhciBuPWUrXCJYXCIscj1lK1wiWVwiLG89SHQodCksaT1vWzFdW25dLW9bMF1bbl0sYT1vWzFdW3JdLW9bMF1bcl07cmV0dXJuIDE4MCpNYXRoLmF0YW4yKGEsaSkvTWF0aC5QSX0senQuZ2V0UG9pbnRlclR5cGU9ZnVuY3Rpb24odCl7cmV0dXJuIFh0LnN0cmluZyh0LnBvaW50ZXJUeXBlKT90LnBvaW50ZXJUeXBlOlh0Lm51bWJlcih0LnBvaW50ZXJUeXBlKT9bdm9pZCAwLHZvaWQgMCxcInRvdWNoXCIsXCJwZW5cIixcIm1vdXNlXCJdW3QucG9pbnRlclR5cGVdOi90b3VjaC8udGVzdCh0LnR5cGUpfHx0IGluc3RhbmNlb2YgV3QuZGVmYXVsdC5Ub3VjaD9cInRvdWNoXCI6XCJtb3VzZVwifSx6dC5nZXRFdmVudFRhcmdldHM9ZnVuY3Rpb24odCl7dmFyIGU9WHQuZnVuYyh0LmNvbXBvc2VkUGF0aCk/dC5jb21wb3NlZFBhdGgoKTp0LnBhdGg7cmV0dXJuW1J0LmdldEFjdHVhbEVsZW1lbnQoZT9lWzBdOnQudGFyZ2V0KSxSdC5nZXRBY3R1YWxFbGVtZW50KHQuY3VycmVudFRhcmdldCldfSx6dC5uZXdDb29yZHM9ZnVuY3Rpb24oKXtyZXR1cm57cGFnZTp7eDowLHk6MH0sY2xpZW50Ont4OjAseTowfSx0aW1lU3RhbXA6MH19LHp0LmNvb3Jkc1RvRXZlbnQ9ZnVuY3Rpb24odCl7cmV0dXJue2Nvb3Jkczp0LGdldCBwYWdlKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBhZ2V9LGdldCBjbGllbnQoKXtyZXR1cm4gdGhpcy5jb29yZHMuY2xpZW50fSxnZXQgdGltZVN0YW1wKCl7cmV0dXJuIHRoaXMuY29vcmRzLnRpbWVTdGFtcH0sZ2V0IHBhZ2VYKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBhZ2UueH0sZ2V0IHBhZ2VZKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBhZ2UueX0sZ2V0IGNsaWVudFgoKXtyZXR1cm4gdGhpcy5jb29yZHMuY2xpZW50Lnh9LGdldCBjbGllbnRZKCl7cmV0dXJuIHRoaXMuY29vcmRzLmNsaWVudC55fSxnZXQgcG9pbnRlcklkKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBvaW50ZXJJZH0sZ2V0IHRhcmdldCgpe3JldHVybiB0aGlzLmNvb3Jkcy50YXJnZXR9LGdldCB0eXBlKCl7cmV0dXJuIHRoaXMuY29vcmRzLnR5cGV9LGdldCBwb2ludGVyVHlwZSgpe3JldHVybiB0aGlzLmNvb3Jkcy5wb2ludGVyVHlwZX0sZ2V0IGJ1dHRvbnMoKXtyZXR1cm4gdGhpcy5jb29yZHMuYnV0dG9uc30scHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt9fX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHp0LFwicG9pbnRlckV4dGVuZFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBZdC5kZWZhdWx0fX0pO3ZhciBDdD1CdChDKSxXdD1CdChEKSxSdD1MdCgkKSxGdD1CdChFdCksWHQ9THQodyksWXQ9QnQoVHQpO2Z1bmN0aW9uIE50KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gTnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBMdCh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1BdCh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1OdCgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufWZ1bmN0aW9uIEJ0KHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBWdCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFd0LmRlZmF1bHQuRXZlbnR8fHQgaW5zdGFuY2VvZiBXdC5kZWZhdWx0LlRvdWNofWZ1bmN0aW9uIHF0KHQsZSxuKXtyZXR1cm4obj1ufHx7fSkueD1lWyh0PXR8fFwicGFnZVwiKStcIlhcIl0sbi55PWVbdCtcIllcIl0sbn1mdW5jdGlvbiBVdCh0LGUpe3JldHVybiBlPWV8fHt4OjAseTowfSxDdC5kZWZhdWx0LmlzT3BlcmFNb2JpbGUmJlZ0KHQpPyhxdChcInNjcmVlblwiLHQsZSksZS54Kz13aW5kb3cuc2Nyb2xsWCxlLnkrPXdpbmRvdy5zY3JvbGxZKTpxdChcInBhZ2VcIix0LGUpLGV9ZnVuY3Rpb24gR3QodCxlKXtyZXR1cm4gZT1lfHx7fSxDdC5kZWZhdWx0LmlzT3BlcmFNb2JpbGUmJlZ0KHQpP3F0KFwic2NyZWVuXCIsdCxlKTpxdChcImNsaWVudFwiLHQsZSksZX1mdW5jdGlvbiBIdCh0KXt2YXIgZT1bXTtyZXR1cm4gWHQuYXJyYXkodCk/KGVbMF09dFswXSxlWzFdPXRbMV0pOlwidG91Y2hlbmRcIj09PXQudHlwZT8xPT09dC50b3VjaGVzLmxlbmd0aD8oZVswXT10LnRvdWNoZXNbMF0sZVsxXT10LmNoYW5nZWRUb3VjaGVzWzBdKTowPT09dC50b3VjaGVzLmxlbmd0aCYmKGVbMF09dC5jaGFuZ2VkVG91Y2hlc1swXSxlWzFdPXQuY2hhbmdlZFRvdWNoZXNbMV0pOihlWzBdPXQudG91Y2hlc1swXSxlWzFdPXQudG91Y2hlc1sxXSksZX1mdW5jdGlvbiBLdCh0KXtmb3IodmFyIGU9e3BhZ2VYOjAscGFnZVk6MCxjbGllbnRYOjAsY2xpZW50WTowLHNjcmVlblg6MCxzY3JlZW5ZOjB9LG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtmb3IodmFyIG8gaW4gZSllW29dKz1yW29dfWZvcih2YXIgaSBpbiBlKWVbaV0vPXQubGVuZ3RoO3JldHVybiBlfXZhciAkdD17fTtmdW5jdGlvbiBadCh0KXtyZXR1cm4oWnQ9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkdCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSwkdC5nZXRTdHJpbmdPcHRpb25SZXN1bHQ9bmUsJHQucmVzb2x2ZVJlY3RMaWtlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXQ7dGUuc3RyaW5nKG8pP289bmUobyxlLG4pOnRlLmZ1bmMobykmJihvPW8uYXBwbHkodm9pZCAwLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXtmb3IodmFyIGU9MCxuPW5ldyBBcnJheSh0Lmxlbmd0aCk7ZTx0Lmxlbmd0aDtlKyspbltlXT10W2VdO3JldHVybiBufX0odCl8fGZ1bmN0aW9uKHQpe2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpcmV0dXJuIEFycmF5LmZyb20odCl9KHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX0ocikpKTt0ZS5lbGVtZW50KG8pJiYobz0oMCwkLmdldEVsZW1lbnRSZWN0KShvKSk7cmV0dXJuIG99LCR0LnJlY3RUb1hZPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ7eDpcInhcImluIHQ/dC54OnQubGVmdCx5OlwieVwiaW4gdD90Lnk6dC50b3B9fSwkdC54eXdoVG9UbGJyPWZ1bmN0aW9uKHQpeyF0fHxcImxlZnRcImluIHQmJlwidG9wXCJpbiB0fHwoKHQ9KDAsUXQuZGVmYXVsdCkoe30sdCkpLmxlZnQ9dC54fHwwLHQudG9wPXQueXx8MCx0LnJpZ2h0PXQucmlnaHR8fHQubGVmdCt0LndpZHRoLHQuYm90dG9tPXQuYm90dG9tfHx0LnRvcCt0LmhlaWdodCk7cmV0dXJuIHR9LCR0LnRsYnJUb1h5d2g9ZnVuY3Rpb24odCl7IXR8fFwieFwiaW4gdCYmXCJ5XCJpbiB0fHwoKHQ9KDAsUXQuZGVmYXVsdCkoe30sdCkpLng9dC5sZWZ0fHwwLHQueT10LnRvcHx8MCx0LndpZHRoPXQud2lkdGh8fHQucmlnaHR8fDAtdC54LHQuaGVpZ2h0PXQuaGVpZ2h0fHx0LmJvdHRvbXx8MC10LnkpO3JldHVybiB0fSwkdC5hZGRFZGdlcz1mdW5jdGlvbih0LGUsbil7dC5sZWZ0JiYoZS5sZWZ0Kz1uLngpO3QucmlnaHQmJihlLnJpZ2h0Kz1uLngpO3QudG9wJiYoZS50b3ArPW4ueSk7dC5ib3R0b20mJihlLmJvdHRvbSs9bi55KTtlLndpZHRoPWUucmlnaHQtZS5sZWZ0LGUuaGVpZ2h0PWUuYm90dG9tLWUudG9wfTt2YXIgSnQsUXQ9KEp0PWN0KSYmSnQuX19lc01vZHVsZT9KdDp7ZGVmYXVsdDpKdH0sdGU9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09WnQodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9ZWUoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0odyk7ZnVuY3Rpb24gZWUoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBlZT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIG5lKHQsZSxuKXtyZXR1cm5cInBhcmVudFwiPT09dD8oMCwkLnBhcmVudE5vZGUpKG4pOlwic2VsZlwiPT09dD9lLmdldFJlY3Qobik6KDAsJC5jbG9zZXN0KShuLHQpfXZhciByZT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocmUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscmUuZGVmYXVsdD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dC5vcHRpb25zW25dLG89ciYmci5vcmlnaW58fHQub3B0aW9ucy5vcmlnaW4saT0oMCwkdC5yZXNvbHZlUmVjdExpa2UpKG8sdCxlLFt0JiZlXSk7cmV0dXJuKDAsJHQucmVjdFRvWFkpKGkpfHx7eDowLHk6MH19O3ZhciBvZT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkob2UsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksb2UuZGVmYXVsdD12b2lkIDA7dmFyIGllLGFlLHVlPTA7dmFyIHNlPXtyZXF1ZXN0OmZ1bmN0aW9uKHQpe3JldHVybiBpZSh0KX0sY2FuY2VsOmZ1bmN0aW9uKHQpe3JldHVybiBhZSh0KX0saW5pdDpmdW5jdGlvbih0KXtpZihpZT10LnJlcXVlc3RBbmltYXRpb25GcmFtZSxhZT10LmNhbmNlbEFuaW1hdGlvbkZyYW1lLCFpZSlmb3IodmFyIGU9W1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtpZT10W1wiXCIuY29uY2F0KHIsXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIildLGFlPXRbXCJcIi5jb25jYXQocixcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCIpXXx8dFtcIlwiLmNvbmNhdChyLFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpXX1pZXx8KGllPWZ1bmN0aW9uKHQpe3ZhciBlPURhdGUubm93KCksbj1NYXRoLm1heCgwLDE2LShlLXVlKSkscj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dChlK24pfSxuKTtyZXR1cm4gdWU9ZStuLHJ9LGFlPWZ1bmN0aW9uKHQpe3JldHVybiBjbGVhclRpbWVvdXQodCl9KX19O29lLmRlZmF1bHQ9c2U7dmFyIGxlPXt9O2Z1bmN0aW9uIGNlKHQpe3JldHVybihjZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGxlLndhcm5PbmNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49ITE7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG58fChoZS5kZWZhdWx0LndpbmRvdy5jb25zb2xlLndhcm4oZSksbj0hMCksdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSxsZS5jb3B5QWN0aW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQubmFtZT1lLm5hbWUsdC5heGlzPWUuYXhpcyx0LmVkZ2VzPWUuZWRnZXMsdH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwid2luXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGhlLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwiYnJvd3NlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBnZS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsZSxcImNsb25lXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGJlLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwiZXh0ZW5kXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG1lLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwiZ2V0T3JpZ2luWFlcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gT2UuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJoeXBvdFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB3ZS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsZSxcIm5vcm1hbGl6ZUxpc3RlbmVyc1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBfZS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsZSxcInJhZlwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBQZS5kZWZhdWx0fX0pLGxlLnJlY3Q9bGUucG9pbnRlcj1sZS5pcz1sZS5kb209bGUuYXJyPXZvaWQgMDt2YXIgZmU9amUoUyk7bGUuYXJyPWZlO3ZhciBwZT1qZSgkKTtsZS5kb209cGU7dmFyIGRlPWplKHcpO2xlLmlzPWRlO3ZhciB2ZT1qZSh6dCk7bGUucG9pbnRlcj12ZTt2YXIgeWU9amUoJHQpO2xlLnJlY3Q9eWU7dmFyIGhlPXhlKE8pLGdlPXhlKEMpLGJlPXhlKFYpLG1lPXhlKGN0KSxPZT14ZShyZSksd2U9eGUoRXQpLF9lPXhlKGZ0KSxQZT14ZShvZSk7ZnVuY3Rpb24geGUodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIFNlKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gU2U9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBqZSh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1jZSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1TZSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufXZhciBNZT17fTtmdW5jdGlvbiBrZSh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gRWUodCxlLG4pe3JldHVybiBlJiZrZSh0LnByb3RvdHlwZSxlKSxuJiZrZSh0LG4pLHR9ZnVuY3Rpb24gVGUodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxNZS5kZWZhdWx0PU1lLkJhc2VFdmVudD12b2lkIDA7dmFyIERlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLFRlKHRoaXMsXCJ0eXBlXCIsdm9pZCAwKSxUZSh0aGlzLFwidGFyZ2V0XCIsdm9pZCAwKSxUZSh0aGlzLFwiY3VycmVudFRhcmdldFwiLHZvaWQgMCksVGUodGhpcyxcImludGVyYWN0YWJsZVwiLHZvaWQgMCksVGUodGhpcyxcIl9pbnRlcmFjdGlvblwiLHZvaWQgMCksVGUodGhpcyxcInRpbWVTdGFtcFwiLHZvaWQgMCksVGUodGhpcyxcImltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwiLCExKSxUZSh0aGlzLFwicHJvcGFnYXRpb25TdG9wcGVkXCIsITEpLHRoaXMuX2ludGVyYWN0aW9uPXR9cmV0dXJuIEVlKGUsW3trZXk6XCJpbnRlcmFjdGlvblwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcmFjdGlvbi5fcHJveHl9fV0pLEVlKGUsW3trZXk6XCJwcmV2ZW50RGVmYXVsdFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcInN0b3BQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fSx7a2V5Olwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD10aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19XSksZX0oKSxJZT1NZS5CYXNlRXZlbnQ9RGU7TWUuZGVmYXVsdD1JZTt2YXIgemU9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHplLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHplLmRlZmF1bHQ9emUuZGVmYXVsdHM9dm9pZCAwO3ZhciBBZT17YmFzZTp7cHJldmVudERlZmF1bHQ6XCJhdXRvXCIsZGVsdGFTb3VyY2U6XCJwYWdlXCJ9LHBlckFjdGlvbjp7ZW5hYmxlZDohMSxvcmlnaW46e3g6MCx5OjB9fSxhY3Rpb25zOnt9fSxDZT16ZS5kZWZhdWx0cz1BZTt6ZS5kZWZhdWx0PUNlO3ZhciBXZT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoV2UsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksV2UuZGVmYXVsdD1XZS5JbnRlcmFjdEV2ZW50PXZvaWQgMDt2YXIgUmU9TGUoY3QpLEZlPUxlKHJlKSxYZT1MZShFdCksWWU9TGUoTWUpLE5lPUxlKHplKTtmdW5jdGlvbiBMZSh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gQmUodCl7cmV0dXJuKEJlPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiBWZSh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gcWUodCl7cmV0dXJuKHFlPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX1mdW5jdGlvbiBVZSh0KXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gdH1mdW5jdGlvbiBHZSh0LGUpe3JldHVybihHZT1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9ZnVuY3Rpb24gSGUodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBLZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGcodCxlLG4scixvLGksYSl7dmFyIHUscyxsOyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZykscz10aGlzLHU9IShsPXFlKGcpLmNhbGwodGhpcyx0KSl8fFwib2JqZWN0XCIhPT1CZShsKSYmXCJmdW5jdGlvblwiIT10eXBlb2YgbD9VZShzKTpsLEhlKFVlKHUpLFwidGFyZ2V0XCIsdm9pZCAwKSxIZShVZSh1KSxcImN1cnJlbnRUYXJnZXRcIix2b2lkIDApLEhlKFVlKHUpLFwicmVsYXRlZFRhcmdldFwiLG51bGwpLEhlKFVlKHUpLFwic2NyZWVuWFwiLHZvaWQgMCksSGUoVWUodSksXCJzY3JlZW5ZXCIsdm9pZCAwKSxIZShVZSh1KSxcImJ1dHRvblwiLHZvaWQgMCksSGUoVWUodSksXCJidXR0b25zXCIsdm9pZCAwKSxIZShVZSh1KSxcImN0cmxLZXlcIix2b2lkIDApLEhlKFVlKHUpLFwic2hpZnRLZXlcIix2b2lkIDApLEhlKFVlKHUpLFwiYWx0S2V5XCIsdm9pZCAwKSxIZShVZSh1KSxcIm1ldGFLZXlcIix2b2lkIDApLEhlKFVlKHUpLFwicGFnZVwiLHZvaWQgMCksSGUoVWUodSksXCJjbGllbnRcIix2b2lkIDApLEhlKFVlKHUpLFwiZGVsdGFcIix2b2lkIDApLEhlKFVlKHUpLFwicmVjdFwiLHZvaWQgMCksSGUoVWUodSksXCJ4MFwiLHZvaWQgMCksSGUoVWUodSksXCJ5MFwiLHZvaWQgMCksSGUoVWUodSksXCJ0MFwiLHZvaWQgMCksSGUoVWUodSksXCJkdFwiLHZvaWQgMCksSGUoVWUodSksXCJkdXJhdGlvblwiLHZvaWQgMCksSGUoVWUodSksXCJjbGllbnRYMFwiLHZvaWQgMCksSGUoVWUodSksXCJjbGllbnRZMFwiLHZvaWQgMCksSGUoVWUodSksXCJ2ZWxvY2l0eVwiLHZvaWQgMCksSGUoVWUodSksXCJzcGVlZFwiLHZvaWQgMCksSGUoVWUodSksXCJzd2lwZVwiLHZvaWQgMCksSGUoVWUodSksXCJ0aW1lU3RhbXBcIix2b2lkIDApLEhlKFVlKHUpLFwiZHJhZ0VudGVyXCIsdm9pZCAwKSxIZShVZSh1KSxcImRyYWdMZWF2ZVwiLHZvaWQgMCksSGUoVWUodSksXCJheGVzXCIsdm9pZCAwKSxIZShVZSh1KSxcInByZUVuZFwiLHZvaWQgMCksbz1vfHx0LmVsZW1lbnQ7dmFyIGM9dC5pbnRlcmFjdGFibGUsZj0oYyYmYy5vcHRpb25zfHxOZS5kZWZhdWx0KS5kZWx0YVNvdXJjZSxwPSgwLEZlLmRlZmF1bHQpKGMsbyxuKSxkPVwic3RhcnRcIj09PXIsdj1cImVuZFwiPT09cix5PWQ/VWUodSk6dC5wcmV2RXZlbnQsaD1kP3QuY29vcmRzLnN0YXJ0OnY/e3BhZ2U6eS5wYWdlLGNsaWVudDp5LmNsaWVudCx0aW1lU3RhbXA6dC5jb29yZHMuY3VyLnRpbWVTdGFtcH06dC5jb29yZHMuY3VyO3JldHVybiB1LnBhZ2U9KDAsUmUuZGVmYXVsdCkoe30saC5wYWdlKSx1LmNsaWVudD0oMCxSZS5kZWZhdWx0KSh7fSxoLmNsaWVudCksdS5yZWN0PSgwLFJlLmRlZmF1bHQpKHt9LHQucmVjdCksdS50aW1lU3RhbXA9aC50aW1lU3RhbXAsdnx8KHUucGFnZS54LT1wLngsdS5wYWdlLnktPXAueSx1LmNsaWVudC54LT1wLngsdS5jbGllbnQueS09cC55KSx1LmN0cmxLZXk9ZS5jdHJsS2V5LHUuYWx0S2V5PWUuYWx0S2V5LHUuc2hpZnRLZXk9ZS5zaGlmdEtleSx1Lm1ldGFLZXk9ZS5tZXRhS2V5LHUuYnV0dG9uPWUuYnV0dG9uLHUuYnV0dG9ucz1lLmJ1dHRvbnMsdS50YXJnZXQ9byx1LmN1cnJlbnRUYXJnZXQ9byx1LnByZUVuZD1pLHUudHlwZT1hfHxuKyhyfHxcIlwiKSx1LmludGVyYWN0YWJsZT1jLHUudDA9ZD90LnBvaW50ZXJzW3QucG9pbnRlcnMubGVuZ3RoLTFdLmRvd25UaW1lOnkudDAsdS54MD10LmNvb3Jkcy5zdGFydC5wYWdlLngtcC54LHUueTA9dC5jb29yZHMuc3RhcnQucGFnZS55LXAueSx1LmNsaWVudFgwPXQuY29vcmRzLnN0YXJ0LmNsaWVudC54LXAueCx1LmNsaWVudFkwPXQuY29vcmRzLnN0YXJ0LmNsaWVudC55LXAueSx1LmRlbHRhPWR8fHY/e3g6MCx5OjB9Ont4OnVbZl0ueC15W2ZdLngseTp1W2ZdLnkteVtmXS55fSx1LmR0PXQuY29vcmRzLmRlbHRhLnRpbWVTdGFtcCx1LmR1cmF0aW9uPXUudGltZVN0YW1wLXUudDAsdS52ZWxvY2l0eT0oMCxSZS5kZWZhdWx0KSh7fSx0LmNvb3Jkcy52ZWxvY2l0eVtmXSksdS5zcGVlZD0oMCxYZS5kZWZhdWx0KSh1LnZlbG9jaXR5LngsdS52ZWxvY2l0eS55KSx1LnN3aXBlPXZ8fFwiaW5lcnRpYXN0YXJ0XCI9PT1yP3UuZ2V0U3dpcGUoKTpudWxsLHV9dmFyIHQsZSxuO3JldHVybiBmdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmR2UodCxlKX0oZyxZZVtcImRlZmF1bHRcIl0pLHQ9ZywoZT1be2tleTpcImdldFN3aXBlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9pbnRlcmFjdGlvbjtpZih0LnByZXZFdmVudC5zcGVlZDw2MDB8fDE1MDx0aGlzLnRpbWVTdGFtcC10LnByZXZFdmVudC50aW1lU3RhbXApcmV0dXJuIG51bGw7dmFyIGU9MTgwKk1hdGguYXRhbjIodC5wcmV2RXZlbnQudmVsb2NpdHlZLHQucHJldkV2ZW50LnZlbG9jaXR5WCkvTWF0aC5QSTtlPDAmJihlKz0zNjApO3ZhciBuPTExMi41PD1lJiZlPDI0Ny41LHI9MjAyLjU8PWUmJmU8MzM3LjU7cmV0dXJue3VwOnIsZG93bjohciYmMjIuNTw9ZSYmZTwxNTcuNSxsZWZ0Om4scmlnaHQ6IW4mJigyOTIuNTw9ZXx8ZTw2Ny41KSxhbmdsZTplLHNwZWVkOnQucHJldkV2ZW50LnNwZWVkLHZlbG9jaXR5Ont4OnQucHJldkV2ZW50LnZlbG9jaXR5WCx5OnQucHJldkV2ZW50LnZlbG9jaXR5WX19fX0se2tleTpcInByZXZlbnREZWZhdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD10aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19LHtrZXk6XCJzdG9wUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX0se2tleTpcInBhZ2VYXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFnZS54fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5wYWdlLng9dH19LHtrZXk6XCJwYWdlWVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhZ2UueX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMucGFnZS55PXR9fSx7a2V5OlwiY2xpZW50WFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsaWVudC54fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5jbGllbnQueD10fX0se2tleTpcImNsaWVudFlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGllbnQueX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuY2xpZW50Lnk9dH19LHtrZXk6XCJkeFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbHRhLnh9LHNldDpmdW5jdGlvbih0KXt0aGlzLmRlbHRhLng9dH19LHtrZXk6XCJkeVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbHRhLnl9LHNldDpmdW5jdGlvbih0KXt0aGlzLmRlbHRhLnk9dH19LHtrZXk6XCJ2ZWxvY2l0eVhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZWxvY2l0eS54fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy52ZWxvY2l0eS54PXR9fSx7a2V5OlwidmVsb2NpdHlZXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmVsb2NpdHkueX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMudmVsb2NpdHkueT10fX1dKSYmVmUodC5wcm90b3R5cGUsZSksbiYmVmUodCxuKSxnfSgpLCRlPVdlLkludGVyYWN0RXZlbnQ9S2U7V2UuZGVmYXVsdD0kZTt2YXIgWmU9e307ZnVuY3Rpb24gSmUodCl7cmV0dXJuKEplPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoWmUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksWmUuZGVmYXVsdD12b2lkIDA7dmFyIFFlLHRuPWFuKFMpLGVuPWFuKCQpLG5uPShRZT1jdCkmJlFlLl9fZXNNb2R1bGU/UWU6e2RlZmF1bHQ6UWV9LHJuPWFuKHcpO2Z1bmN0aW9uIG9uKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gb249ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBhbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1KZSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1vbigpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufWZ1bmN0aW9uIHVuKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBzbih0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIGxuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXt2YXIgYT10aGlzOyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5zY29wZT10LHNuKHRoaXMsXCJsaXN0XCIsW10pLHNuKHRoaXMsXCJzZWxlY3Rvck1hcFwiLHt9KSx0LmFkZExpc3RlbmVycyh7XCJpbnRlcmFjdGFibGU6dW5zZXRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0YWJsZSxuPWUudGFyZ2V0LHI9ZS5fY29udGV4dCxvPXJuLnN0cmluZyhuKT9hLnNlbGVjdG9yTWFwW25dOm5bYS5zY29wZS5pZF0saT1vLmZpbmRJbmRleChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb250ZXh0PT09cn0pO29baV0mJihvW2ldLmNvbnRleHQ9bnVsbCxvW2ldLmludGVyYWN0YWJsZT1udWxsKSxvLnNwbGljZShpLDEpfX0pfXZhciB0LG4scjtyZXR1cm4gdD1lLChuPVt7a2V5OlwibmV3XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtlPSgwLG5uLmRlZmF1bHQpKGV8fHt9LHthY3Rpb25zOnRoaXMuc2NvcGUuYWN0aW9uc30pO3ZhciBuPW5ldyB0aGlzLnNjb3BlLkludGVyYWN0YWJsZSh0LGUsdGhpcy5zY29wZS5kb2N1bWVudCx0aGlzLnNjb3BlLmV2ZW50cykscj17Y29udGV4dDpuLl9jb250ZXh0LGludGVyYWN0YWJsZTpufTtyZXR1cm4gdGhpcy5zY29wZS5hZGREb2N1bWVudChuLl9kb2MpLHRoaXMubGlzdC5wdXNoKG4pLHJuLnN0cmluZyh0KT8odGhpcy5zZWxlY3Rvck1hcFt0XXx8KHRoaXMuc2VsZWN0b3JNYXBbdF09W10pLHRoaXMuc2VsZWN0b3JNYXBbdF0ucHVzaChyKSk6KG4udGFyZ2V0W3RoaXMuc2NvcGUuaWRdfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCx0aGlzLnNjb3BlLmlkLHt2YWx1ZTpbXSxjb25maWd1cmFibGU6ITB9KSx0W3RoaXMuc2NvcGUuaWRdLnB1c2gocikpLHRoaXMuc2NvcGUuZmlyZShcImludGVyYWN0YWJsZTpuZXdcIix7dGFyZ2V0OnQsb3B0aW9uczplLGludGVyYWN0YWJsZTpuLHdpbjp0aGlzLnNjb3BlLl93aW59KSxufX0se2tleTpcImdldFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dCYmdC5jb250ZXh0fHx0aGlzLnNjb3BlLmRvY3VtZW50LHI9cm4uc3RyaW5nKGUpLG89cj90aGlzLnNlbGVjdG9yTWFwW2VdOmVbdGhpcy5zY29wZS5pZF07aWYoIW8pcmV0dXJuIG51bGw7dmFyIGk9dG4uZmluZChvLGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnRleHQ9PT1uJiYocnx8dC5pbnRlcmFjdGFibGUuaW5Db250ZXh0KGUpKX0pO3JldHVybiBpJiZpLmludGVyYWN0YWJsZX19LHtrZXk6XCJmb3JFYWNoTWF0Y2hcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dGhpcy5saXN0Lmxlbmd0aDtuKyspe3ZhciByPXRoaXMubGlzdFtuXSxvPXZvaWQgMDtpZigocm4uc3RyaW5nKHIudGFyZ2V0KT9ybi5lbGVtZW50KHQpJiZlbi5tYXRjaGVzU2VsZWN0b3IodCxyLnRhcmdldCk6dD09PXIudGFyZ2V0KSYmci5pbkNvbnRleHQodCkmJihvPWUocikpLHZvaWQgMCE9PW8pcmV0dXJuIG99fX1dKSYmdW4odC5wcm90b3R5cGUsbiksciYmdW4odCxyKSxlfSgpO1plLmRlZmF1bHQ9bG47dmFyIGNuPXt9O2Z1bmN0aW9uIGZuKHQpe3JldHVybihmbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGNuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGNuLmRlZmF1bHQ9Y24uRmFrZUV2ZW50PXZvaWQgMDt2YXIgcG49T24oUyksZG49T24oJCksdm49Ym4oY3QpLHluPU9uKHcpLGhuPWJuKFR0KSxnbj1Pbih6dCk7ZnVuY3Rpb24gYm4odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG1uKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gbW49ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBPbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1mbih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1tbigpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufWZ1bmN0aW9uIHduKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBfbih0LGUpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0fSh0KXx8ZnVuY3Rpb24odCxlKXtpZighKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpKXJldHVybjt2YXIgbj1bXSxyPSEwLG89ITEsaT12b2lkIDA7dHJ5e2Zvcih2YXIgYSx1PXRbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0oYT11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goYS52YWx1ZSksIWV8fG4ubGVuZ3RoIT09ZSk7cj0hMCk7fWNhdGNoKHQpe289ITAsaT10fWZpbmFsbHl7dHJ5e3J8fG51bGw9PXUucmV0dXJufHx1LnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn0odCxlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX12YXIgUG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBvKHQpe3ZhciBlLG4scjshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLG8pLHRoaXMub3JpZ2luYWxFdmVudD10LHI9dm9pZCAwLChuPVwiY3VycmVudFRhcmdldFwiKWluKGU9dGhpcyk/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbbl09ciwoMCxobi5kZWZhdWx0KSh0aGlzLHQpfXZhciB0LGUsbjtyZXR1cm4gdD1vLChlPVt7a2V5OlwicHJldmVudE9yaWdpbmFsRGVmYXVsdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCl9fSx7a2V5Olwic3RvcFByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9fSx7a2V5Olwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCl9fV0pJiZ3bih0LnByb3RvdHlwZSxlKSxuJiZ3bih0LG4pLG99KCk7ZnVuY3Rpb24geG4odCl7aWYoIXluLm9iamVjdCh0KSlyZXR1cm57Y2FwdHVyZTohIXQscGFzc2l2ZTohMX07dmFyIGU9KDAsdm4uZGVmYXVsdCkoe30sdCk7cmV0dXJuIGUuY2FwdHVyZT0hIXQuY2FwdHVyZSxlLnBhc3NpdmU9ISF0LnBhc3NpdmUsZX1jbi5GYWtlRXZlbnQ9UG47dmFyIFNuPXtpZDpcImV2ZW50c1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGY9W10sYj17fSxjPVtdLHA9e2FkZDpkLHJlbW92ZTpnLGFkZERlbGVnYXRlOmZ1bmN0aW9uKGUsbix0LHIsbyl7dmFyIGk9eG4obyk7aWYoIWJbdF0pe2JbdF09W107Zm9yKHZhciBhPTA7YTxjLmxlbmd0aDthKyspe3ZhciB1PWNbYV07ZCh1LHQsbSksZCh1LHQsTywhMCl9fXZhciBzPWJbdF0sbD1wbi5maW5kKHMsZnVuY3Rpb24odCl7cmV0dXJuIHQuc2VsZWN0b3I9PT1lJiZ0LmNvbnRleHQ9PT1ufSk7bHx8KGw9e3NlbGVjdG9yOmUsY29udGV4dDpuLGxpc3RlbmVyczpbXX0scy5wdXNoKGwpKTtsLmxpc3RlbmVycy5wdXNoKFtyLGldKX0scmVtb3ZlRGVsZWdhdGU6ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgaSxhPXhuKG8pLHU9YltuXSxzPSExO2lmKCF1KXJldHVybjtmb3IoaT11Lmxlbmd0aC0xOzA8PWk7aS0tKXt2YXIgbD11W2ldO2lmKGwuc2VsZWN0b3I9PT10JiZsLmNvbnRleHQ9PT1lKXtmb3IodmFyIGM9bC5saXN0ZW5lcnMsZj1jLmxlbmd0aC0xOzA8PWY7Zi0tKXt2YXIgcD1fbihjW2ZdLDIpLGQ9cFswXSx2PXBbMV0seT12LmNhcHR1cmUsaD12LnBhc3NpdmU7aWYoZD09PXImJnk9PT1hLmNhcHR1cmUmJmg9PT1hLnBhc3NpdmUpe2Muc3BsaWNlKGYsMSksYy5sZW5ndGh8fCh1LnNwbGljZShpLDEpLGcoZSxuLG0pLGcoZSxuLE8sITApKSxzPSEwO2JyZWFrfX1pZihzKWJyZWFrfX19LGRlbGVnYXRlTGlzdGVuZXI6bSxkZWxlZ2F0ZVVzZUNhcHR1cmU6TyxkZWxlZ2F0ZWRFdmVudHM6Yixkb2N1bWVudHM6Yyx0YXJnZXRzOmYsc3VwcG9ydHNPcHRpb25zOiExLHN1cHBvcnRzUGFzc2l2ZTohMX07ZnVuY3Rpb24gZChlLHQsbixyKXt2YXIgbz14bihyKSxpPXBuLmZpbmQoZixmdW5jdGlvbih0KXtyZXR1cm4gdC5ldmVudFRhcmdldD09PWV9KTtpfHwoaT17ZXZlbnRUYXJnZXQ6ZSxldmVudHM6e319LGYucHVzaChpKSksaS5ldmVudHNbdF18fChpLmV2ZW50c1t0XT1bXSksZS5hZGRFdmVudExpc3RlbmVyJiYhcG4uY29udGFpbnMoaS5ldmVudHNbdF0sbikmJihlLmFkZEV2ZW50TGlzdGVuZXIodCxuLHAuc3VwcG9ydHNPcHRpb25zP286by5jYXB0dXJlKSxpLmV2ZW50c1t0XS5wdXNoKG4pKX1mdW5jdGlvbiBnKGUsdCxuLHIpe3ZhciBvPXhuKHIpLGk9cG4uZmluZEluZGV4KGYsZnVuY3Rpb24odCl7cmV0dXJuIHQuZXZlbnRUYXJnZXQ9PT1lfSksYT1mW2ldO2lmKGEmJmEuZXZlbnRzKWlmKFwiYWxsXCIhPT10KXt2YXIgdT0hMSxzPWEuZXZlbnRzW3RdO2lmKHMpe2lmKFwiYWxsXCI9PT1uKXtmb3IodmFyIGw9cy5sZW5ndGgtMTswPD1sO2wtLSlnKGUsdCxzW2xdLG8pO3JldHVybn1mb3IodmFyIGM9MDtjPHMubGVuZ3RoO2MrKylpZihzW2NdPT09bil7ZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsbixwLnN1cHBvcnRzT3B0aW9ucz9vOm8uY2FwdHVyZSkscy5zcGxpY2UoYywxKSwwPT09cy5sZW5ndGgmJihkZWxldGUgYS5ldmVudHNbdF0sdT0hMCk7YnJlYWt9fXUmJiFPYmplY3Qua2V5cyhhLmV2ZW50cykubGVuZ3RoJiZmLnNwbGljZShpLDEpfWVsc2UgZm9yKHQgaW4gYS5ldmVudHMpYS5ldmVudHMuaGFzT3duUHJvcGVydHkodCkmJmcoZSx0LFwiYWxsXCIpfWZ1bmN0aW9uIG0odCxlKXtmb3IodmFyIG49eG4oZSkscj1uZXcgUG4odCksbz1iW3QudHlwZV0saT1fbihnbi5nZXRFdmVudFRhcmdldHModCksMSlbMF0sYT1pO3luLmVsZW1lbnQoYSk7KXtmb3IodmFyIHU9MDt1PG8ubGVuZ3RoO3UrKyl7dmFyIHM9b1t1XSxsPXMuc2VsZWN0b3IsYz1zLmNvbnRleHQ7aWYoZG4ubWF0Y2hlc1NlbGVjdG9yKGEsbCkmJmRuLm5vZGVDb250YWlucyhjLGkpJiZkbi5ub2RlQ29udGFpbnMoYyxhKSl7dmFyIGY9cy5saXN0ZW5lcnM7ci5jdXJyZW50VGFyZ2V0PWE7Zm9yKHZhciBwPTA7cDxmLmxlbmd0aDtwKyspe3ZhciBkPV9uKGZbcF0sMiksdj1kWzBdLHk9ZFsxXSxoPXkuY2FwdHVyZSxnPXkucGFzc2l2ZTtoPT09bi5jYXB0dXJlJiZnPT09bi5wYXNzaXZlJiZ2KHIpfX19YT1kbi5wYXJlbnROb2RlKGEpfX1mdW5jdGlvbiBPKHQpe3JldHVybiBtLmNhbGwodGhpcyx0LCEwKX1yZXR1cm4gdC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsbnVsbCx7Z2V0IGNhcHR1cmUoKXtyZXR1cm4gcC5zdXBwb3J0c09wdGlvbnM9ITB9LGdldCBwYXNzaXZlKCl7cmV0dXJuIHAuc3VwcG9ydHNQYXNzaXZlPSEwfX0pLHQuZXZlbnRzPXB9fTtjbi5kZWZhdWx0PVNuO3ZhciBqbj17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoam4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksam4uZGVmYXVsdD1qbi5Qb2ludGVySW5mbz12b2lkIDA7ZnVuY3Rpb24gTW4odCxlLG4scixvKXshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLE1uKSx0aGlzLmlkPXQsdGhpcy5wb2ludGVyPWUsdGhpcy5ldmVudD1uLHRoaXMuZG93blRpbWU9cix0aGlzLmRvd25UYXJnZXQ9b312YXIga249am4uUG9pbnRlckluZm89TW47am4uZGVmYXVsdD1rbjt2YXIgRW49e307ZnVuY3Rpb24gVG4odCl7cmV0dXJuKFRuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoRW4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuLFwiUG9pbnRlckluZm9cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUm4uZGVmYXVsdH19KSxFbi5kZWZhdWx0PUVuLkludGVyYWN0aW9uPUVuLl9Qcm94eU1ldGhvZHM9RW4uX1Byb3h5VmFsdWVzPXZvaWQgMDt2YXIgRG4sSW4sem4sQW4sQ249ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09VG4odCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9WG4oKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0obGUpLFduPUZuKFdlKSxSbj1Gbihqbik7ZnVuY3Rpb24gRm4odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIFhuKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gWG49ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBZbih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gTm4odCxlLG4pe3JldHVybiBlJiZZbih0LnByb3RvdHlwZSxlKSxuJiZZbih0LG4pLHR9ZnVuY3Rpb24gTG4odCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fUVuLl9Qcm94eVZhbHVlcz1EbiwoSW49RG58fChFbi5fUHJveHlWYWx1ZXM9RG49e30pKS5pbnRlcmFjdGFibGU9XCJcIixJbi5lbGVtZW50PVwiXCIsSW4ucHJlcGFyZWQ9XCJcIixJbi5wb2ludGVySXNEb3duPVwiXCIsSW4ucG9pbnRlcldhc01vdmVkPVwiXCIsSW4uX3Byb3h5PVwiXCIsRW4uX1Byb3h5TWV0aG9kcz16biwoQW49em58fChFbi5fUHJveHlNZXRob2RzPXpuPXt9KSkuc3RhcnQ9XCJcIixBbi5tb3ZlPVwiXCIsQW4uZW5kPVwiXCIsQW4uc3RvcD1cIlwiLEFuLmludGVyYWN0aW5nPVwiXCI7dmFyIEJuPTAsVm49ZnVuY3Rpb24oKXtmdW5jdGlvbiBsKHQpe3ZhciBlPXRoaXMsbj10LnBvaW50ZXJUeXBlLHI9dC5zY29wZUZpcmU7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxsKSxMbih0aGlzLFwiaW50ZXJhY3RhYmxlXCIsbnVsbCksTG4odGhpcyxcImVsZW1lbnRcIixudWxsKSxMbih0aGlzLFwicmVjdFwiLHZvaWQgMCksTG4odGhpcyxcIl9yZWN0c1wiLHZvaWQgMCksTG4odGhpcyxcImVkZ2VzXCIsdm9pZCAwKSxMbih0aGlzLFwiX3Njb3BlRmlyZVwiLHZvaWQgMCksTG4odGhpcyxcInByZXBhcmVkXCIse25hbWU6bnVsbCxheGlzOm51bGwsZWRnZXM6bnVsbH0pLExuKHRoaXMsXCJwb2ludGVyVHlwZVwiLHZvaWQgMCksTG4odGhpcyxcInBvaW50ZXJzXCIsW10pLExuKHRoaXMsXCJkb3duRXZlbnRcIixudWxsKSxMbih0aGlzLFwiZG93blBvaW50ZXJcIix7fSksTG4odGhpcyxcIl9sYXRlc3RQb2ludGVyXCIse3BvaW50ZXI6bnVsbCxldmVudDpudWxsLGV2ZW50VGFyZ2V0Om51bGx9KSxMbih0aGlzLFwicHJldkV2ZW50XCIsbnVsbCksTG4odGhpcyxcInBvaW50ZXJJc0Rvd25cIiwhMSksTG4odGhpcyxcInBvaW50ZXJXYXNNb3ZlZFwiLCExKSxMbih0aGlzLFwiX2ludGVyYWN0aW5nXCIsITEpLExuKHRoaXMsXCJfZW5kaW5nXCIsITEpLExuKHRoaXMsXCJfc3RvcHBlZFwiLCEwKSxMbih0aGlzLFwiX3Byb3h5XCIsbnVsbCksTG4odGhpcyxcInNpbXVsYXRpb25cIixudWxsKSxMbih0aGlzLFwiZG9Nb3ZlXCIsQ24ud2Fybk9uY2UoZnVuY3Rpb24odCl7dGhpcy5tb3ZlKHQpfSxcIlRoZSBpbnRlcmFjdGlvbi5kb01vdmUoKSBtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBpbnRlcmFjdGlvbi5tb3ZlKClcIikpLExuKHRoaXMsXCJjb29yZHNcIix7c3RhcnQ6Q24ucG9pbnRlci5uZXdDb29yZHMoKSxwcmV2OkNuLnBvaW50ZXIubmV3Q29vcmRzKCksY3VyOkNuLnBvaW50ZXIubmV3Q29vcmRzKCksZGVsdGE6Q24ucG9pbnRlci5uZXdDb29yZHMoKSx2ZWxvY2l0eTpDbi5wb2ludGVyLm5ld0Nvb3JkcygpfSksTG4odGhpcyxcIl9pZFwiLEJuKyspLHRoaXMuX3Njb3BlRmlyZT1yLHRoaXMucG9pbnRlclR5cGU9bjt2YXIgbz10aGlzO3RoaXMuX3Byb3h5PXt9O2Z1bmN0aW9uIGkodCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUuX3Byb3h5LHQse2dldDpmdW5jdGlvbigpe3JldHVybiBvW3RdfX0pfWZvcih2YXIgYSBpbiBEbilpKGEpO2Z1bmN0aW9uIHUodCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUuX3Byb3h5LHQse3ZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIG9bdF0uYXBwbHkobyxhcmd1bWVudHMpfX0pfWZvcih2YXIgcyBpbiB6bil1KHMpO3RoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpuZXdcIix7aW50ZXJhY3Rpb246dGhpc30pfXJldHVybiBObihsLFt7a2V5OlwicG9pbnRlck1vdmVUb2xlcmFuY2VcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMX19XSksTm4obCxbe2tleTpcInBvaW50ZXJEb3duXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMudXBkYXRlUG9pbnRlcih0LGUsbiwhMCksbz10aGlzLnBvaW50ZXJzW3JdO3RoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpkb3duXCIse3BvaW50ZXI6dCxldmVudDplLGV2ZW50VGFyZ2V0Om4scG9pbnRlckluZGV4OnIscG9pbnRlckluZm86byx0eXBlOlwiZG93blwiLGludGVyYWN0aW9uOnRoaXN9KX19LHtrZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4hKHRoaXMuaW50ZXJhY3RpbmcoKXx8IXRoaXMucG9pbnRlcklzRG93bnx8dGhpcy5wb2ludGVycy5sZW5ndGg8KFwiZ2VzdHVyZVwiPT09dC5uYW1lPzI6MSl8fCFlLm9wdGlvbnNbdC5uYW1lXS5lbmFibGVkKSYmKENuLmNvcHlBY3Rpb24odGhpcy5wcmVwYXJlZCx0KSx0aGlzLmludGVyYWN0YWJsZT1lLHRoaXMuZWxlbWVudD1uLHRoaXMucmVjdD1lLmdldFJlY3QobiksdGhpcy5lZGdlcz10aGlzLnByZXBhcmVkLmVkZ2VzP0NuLmV4dGVuZCh7fSx0aGlzLnByZXBhcmVkLmVkZ2VzKTp7bGVmdDohMCxyaWdodDohMCx0b3A6ITAsYm90dG9tOiEwfSx0aGlzLl9zdG9wcGVkPSExLHRoaXMuX2ludGVyYWN0aW5nPXRoaXMuX2RvUGhhc2Uoe2ludGVyYWN0aW9uOnRoaXMsZXZlbnQ6dGhpcy5kb3duRXZlbnQscGhhc2U6XCJzdGFydFwifSkmJiF0aGlzLl9zdG9wcGVkLHRoaXMuX2ludGVyYWN0aW5nKX19LHtrZXk6XCJwb2ludGVyTW92ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLnNpbXVsYXRpb258fHRoaXMubW9kaWZpY2F0aW9uJiZ0aGlzLm1vZGlmaWNhdGlvbi5lbmRSZXN1bHR8fHRoaXMudXBkYXRlUG9pbnRlcih0LGUsbiwhMSk7dmFyIHIsbyxpPXRoaXMuY29vcmRzLmN1ci5wYWdlLng9PT10aGlzLmNvb3Jkcy5wcmV2LnBhZ2UueCYmdGhpcy5jb29yZHMuY3VyLnBhZ2UueT09PXRoaXMuY29vcmRzLnByZXYucGFnZS55JiZ0aGlzLmNvb3Jkcy5jdXIuY2xpZW50Lng9PT10aGlzLmNvb3Jkcy5wcmV2LmNsaWVudC54JiZ0aGlzLmNvb3Jkcy5jdXIuY2xpZW50Lnk9PT10aGlzLmNvb3Jkcy5wcmV2LmNsaWVudC55O3RoaXMucG9pbnRlcklzRG93biYmIXRoaXMucG9pbnRlcldhc01vdmVkJiYocj10aGlzLmNvb3Jkcy5jdXIuY2xpZW50LngtdGhpcy5jb29yZHMuc3RhcnQuY2xpZW50Lngsbz10aGlzLmNvb3Jkcy5jdXIuY2xpZW50LnktdGhpcy5jb29yZHMuc3RhcnQuY2xpZW50LnksdGhpcy5wb2ludGVyV2FzTW92ZWQ9Q24uaHlwb3QocixvKT50aGlzLnBvaW50ZXJNb3ZlVG9sZXJhbmNlKTt2YXIgYT10aGlzLmdldFBvaW50ZXJJbmRleCh0KSx1PXtwb2ludGVyOnQscG9pbnRlckluZGV4OmEscG9pbnRlckluZm86dGhpcy5wb2ludGVyc1thXSxldmVudDplLHR5cGU6XCJtb3ZlXCIsZXZlbnRUYXJnZXQ6bixkeDpyLGR5Om8sZHVwbGljYXRlOmksaW50ZXJhY3Rpb246dGhpc307aXx8Q24ucG9pbnRlci5zZXRDb29yZFZlbG9jaXR5KHRoaXMuY29vcmRzLnZlbG9jaXR5LHRoaXMuY29vcmRzLmRlbHRhKSx0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6bW92ZVwiLHUpLGl8fHRoaXMuc2ltdWxhdGlvbnx8KHRoaXMuaW50ZXJhY3RpbmcoKSYmKHUudHlwZT1udWxsLHRoaXMubW92ZSh1KSksdGhpcy5wb2ludGVyV2FzTW92ZWQmJkNuLnBvaW50ZXIuY29weUNvb3Jkcyh0aGlzLmNvb3Jkcy5wcmV2LHRoaXMuY29vcmRzLmN1cikpfX0se2tleTpcIm1vdmVcIix2YWx1ZTpmdW5jdGlvbih0KXt0JiZ0LmV2ZW50fHxDbi5wb2ludGVyLnNldFplcm9Db29yZHModGhpcy5jb29yZHMuZGVsdGEpLCh0PUNuLmV4dGVuZCh7cG9pbnRlcjp0aGlzLl9sYXRlc3RQb2ludGVyLnBvaW50ZXIsZXZlbnQ6dGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudCxldmVudFRhcmdldDp0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50VGFyZ2V0LGludGVyYWN0aW9uOnRoaXN9LHR8fHt9KSkucGhhc2U9XCJtb3ZlXCIsdGhpcy5fZG9QaGFzZSh0KX19LHtrZXk6XCJwb2ludGVyVXBcIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyKXt2YXIgbz10aGlzLmdldFBvaW50ZXJJbmRleCh0KTstMT09PW8mJihvPXRoaXMudXBkYXRlUG9pbnRlcih0LGUsbiwhMSkpO3ZhciBpPS9jYW5jZWwkL2kudGVzdChlLnR5cGUpP1wiY2FuY2VsXCI6XCJ1cFwiO3RoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpcIi5jb25jYXQoaSkse3BvaW50ZXI6dCxwb2ludGVySW5kZXg6byxwb2ludGVySW5mbzp0aGlzLnBvaW50ZXJzW29dLGV2ZW50OmUsZXZlbnRUYXJnZXQ6bix0eXBlOmksY3VyRXZlbnRUYXJnZXQ6cixpbnRlcmFjdGlvbjp0aGlzfSksdGhpcy5zaW11bGF0aW9ufHx0aGlzLmVuZChlKSx0aGlzLnBvaW50ZXJJc0Rvd249ITEsdGhpcy5yZW1vdmVQb2ludGVyKHQsZSl9fSx7a2V5OlwiZG9jdW1lbnRCbHVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5lbmQodCksdGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOmJsdXJcIix7ZXZlbnQ6dCx0eXBlOlwiYmx1clwiLGludGVyYWN0aW9uOnRoaXN9KX19LHtrZXk6XCJlbmRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZTt0aGlzLl9lbmRpbmc9ITAsdD10fHx0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50LHRoaXMuaW50ZXJhY3RpbmcoKSYmKGU9dGhpcy5fZG9QaGFzZSh7ZXZlbnQ6dCxpbnRlcmFjdGlvbjp0aGlzLHBoYXNlOlwiZW5kXCJ9KSksISh0aGlzLl9lbmRpbmc9ITEpPT09ZSYmdGhpcy5zdG9wKCl9fSx7a2V5OlwiY3VycmVudEFjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyYWN0aW5nP3RoaXMucHJlcGFyZWQubmFtZTpudWxsfX0se2tleTpcImludGVyYWN0aW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJhY3Rpbmd9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOnN0b3BcIix7aW50ZXJhY3Rpb246dGhpc30pLHRoaXMuaW50ZXJhY3RhYmxlPXRoaXMuZWxlbWVudD1udWxsLHRoaXMuX2ludGVyYWN0aW5nPSExLHRoaXMuX3N0b3BwZWQ9ITAsdGhpcy5wcmVwYXJlZC5uYW1lPXRoaXMucHJldkV2ZW50PW51bGx9fSx7a2V5OlwiZ2V0UG9pbnRlckluZGV4XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9Q24ucG9pbnRlci5nZXRQb2ludGVySWQodCk7cmV0dXJuXCJtb3VzZVwiPT09dGhpcy5wb2ludGVyVHlwZXx8XCJwZW5cIj09PXRoaXMucG9pbnRlclR5cGU/dGhpcy5wb2ludGVycy5sZW5ndGgtMTpDbi5hcnIuZmluZEluZGV4KHRoaXMucG9pbnRlcnMsZnVuY3Rpb24odCl7cmV0dXJuIHQuaWQ9PT1lfSl9fSx7a2V5OlwiZ2V0UG9pbnRlckluZm9cIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wb2ludGVyc1t0aGlzLmdldFBvaW50ZXJJbmRleCh0KV19fSx7a2V5OlwidXBkYXRlUG9pbnRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPUNuLnBvaW50ZXIuZ2V0UG9pbnRlcklkKHQpLGk9dGhpcy5nZXRQb2ludGVySW5kZXgodCksYT10aGlzLnBvaW50ZXJzW2ldO3JldHVybiByPSExIT09ciYmKHJ8fC8oZG93bnxzdGFydCkkL2kudGVzdChlLnR5cGUpKSxhP2EucG9pbnRlcj10OihhPW5ldyBSbi5kZWZhdWx0KG8sdCxlLG51bGwsbnVsbCksaT10aGlzLnBvaW50ZXJzLmxlbmd0aCx0aGlzLnBvaW50ZXJzLnB1c2goYSkpLENuLnBvaW50ZXIuc2V0Q29vcmRzKHRoaXMuY29vcmRzLmN1cix0aGlzLnBvaW50ZXJzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5wb2ludGVyfSksdGhpcy5fbm93KCkpLENuLnBvaW50ZXIuc2V0Q29vcmREZWx0YXModGhpcy5jb29yZHMuZGVsdGEsdGhpcy5jb29yZHMucHJldix0aGlzLmNvb3Jkcy5jdXIpLHImJih0aGlzLnBvaW50ZXJJc0Rvd249ITAsYS5kb3duVGltZT10aGlzLmNvb3Jkcy5jdXIudGltZVN0YW1wLGEuZG93blRhcmdldD1uLENuLnBvaW50ZXIucG9pbnRlckV4dGVuZCh0aGlzLmRvd25Qb2ludGVyLHQpLHRoaXMuaW50ZXJhY3RpbmcoKXx8KENuLnBvaW50ZXIuY29weUNvb3Jkcyh0aGlzLmNvb3Jkcy5zdGFydCx0aGlzLmNvb3Jkcy5jdXIpLENuLnBvaW50ZXIuY29weUNvb3Jkcyh0aGlzLmNvb3Jkcy5wcmV2LHRoaXMuY29vcmRzLmN1ciksdGhpcy5kb3duRXZlbnQ9ZSx0aGlzLnBvaW50ZXJXYXNNb3ZlZD0hMSkpLHRoaXMuX3VwZGF0ZUxhdGVzdFBvaW50ZXIodCxlLG4pLHRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczp1cGRhdGUtcG9pbnRlclwiLHtwb2ludGVyOnQsZXZlbnQ6ZSxldmVudFRhcmdldDpuLGRvd246cixwb2ludGVySW5mbzphLHBvaW50ZXJJbmRleDppLGludGVyYWN0aW9uOnRoaXN9KSxpfX0se2tleTpcInJlbW92ZVBvaW50ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0UG9pbnRlckluZGV4KHQpO2lmKC0xIT09bil7dmFyIHI9dGhpcy5wb2ludGVyc1tuXTt0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6cmVtb3ZlLXBvaW50ZXJcIix7cG9pbnRlcjp0LGV2ZW50OmUsZXZlbnRUYXJnZXQ6bnVsbCxwb2ludGVySW5kZXg6bixwb2ludGVySW5mbzpyLGludGVyYWN0aW9uOnRoaXN9KSx0aGlzLnBvaW50ZXJzLnNwbGljZShuLDEpfX19LHtrZXk6XCJfdXBkYXRlTGF0ZXN0UG9pbnRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLl9sYXRlc3RQb2ludGVyLnBvaW50ZXI9dCx0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50PWUsdGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudFRhcmdldD1ufX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2xhdGVzdFBvaW50ZXIucG9pbnRlcj1udWxsLHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnQ9bnVsbCx0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50VGFyZ2V0PW51bGx9fSx7a2V5OlwiX2NyZWF0ZVByZXBhcmVkRXZlbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gbmV3IFduLmRlZmF1bHQodGhpcyx0LHRoaXMucHJlcGFyZWQubmFtZSxlLHRoaXMuZWxlbWVudCxuLHIpfX0se2tleTpcIl9maXJlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmludGVyYWN0YWJsZS5maXJlKHQpLCghdGhpcy5wcmV2RXZlbnR8fHQudGltZVN0YW1wPj10aGlzLnByZXZFdmVudC50aW1lU3RhbXApJiYodGhpcy5wcmV2RXZlbnQ9dCl9fSx7a2V5OlwiX2RvUGhhc2VcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmV2ZW50LG49dC5waGFzZSxyPXQucHJlRW5kLG89dC50eXBlLGk9dGhpcy5yZWN0O2lmKGkmJlwibW92ZVwiPT09biYmKENuLnJlY3QuYWRkRWRnZXModGhpcy5lZGdlcyxpLHRoaXMuY29vcmRzLmRlbHRhW3RoaXMuaW50ZXJhY3RhYmxlLm9wdGlvbnMuZGVsdGFTb3VyY2VdKSxpLndpZHRoPWkucmlnaHQtaS5sZWZ0LGkuaGVpZ2h0PWkuYm90dG9tLWkudG9wKSwhMT09PXRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLVwiLmNvbmNhdChuKSx0KSlyZXR1cm4hMTt2YXIgYT10LmlFdmVudD10aGlzLl9jcmVhdGVQcmVwYXJlZEV2ZW50KGUsbixyLG8pO3JldHVybiB0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6YWN0aW9uLVwiLmNvbmNhdChuKSx0KSxcInN0YXJ0XCI9PT1uJiYodGhpcy5wcmV2RXZlbnQ9YSksdGhpcy5fZmlyZUV2ZW50KGEpLHRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tXCIuY29uY2F0KG4pLHQpLCEwfX0se2tleTpcIl9ub3dcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfX1dKSxsfSgpLHFuPUVuLkludGVyYWN0aW9uPVZuO0VuLmRlZmF1bHQ9cW47dmFyIFVuPXt9O2Z1bmN0aW9uIEduKHQpe3JldHVybihHbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KFVuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFVuLmluc3RhbGw9Sm4sVW4uZGVmYXVsdD12b2lkIDA7dmFyIEhuPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PUduKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUtuKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHcpO2Z1bmN0aW9uIEtuKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gS249ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiAkbih0KXtyZXR1cm4vXihhbHdheXN8bmV2ZXJ8YXV0bykkLy50ZXN0KHQpPyh0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ9dCx0aGlzKTpIbi5ib29sKHQpPyh0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ9dD9cImFsd2F5c1wiOlwibmV2ZXJcIix0aGlzKTp0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHR9ZnVuY3Rpb24gWm4odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuZXZlbnQ7ZS5pbnRlcmFjdGFibGUmJmUuaW50ZXJhY3RhYmxlLmNoZWNrQW5kUHJldmVudERlZmF1bHQobil9ZnVuY3Rpb24gSm4ocil7dmFyIHQ9ci5JbnRlcmFjdGFibGU7dC5wcm90b3R5cGUucHJldmVudERlZmF1bHQ9JG4sdC5wcm90b3R5cGUuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdD1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3ZhciByPXQub3B0aW9ucy5wcmV2ZW50RGVmYXVsdDtpZihcIm5ldmVyXCIhPT1yKWlmKFwiYWx3YXlzXCIhPT1yKXtpZihlLmV2ZW50cy5zdXBwb3J0c1Bhc3NpdmUmJi9edG91Y2goc3RhcnR8bW92ZSkkLy50ZXN0KG4udHlwZSkpe3ZhciBvPSgwLE8uZ2V0V2luZG93KShuLnRhcmdldCkuZG9jdW1lbnQsaT1lLmdldERvY09wdGlvbnMobyk7aWYoIWl8fCFpLmV2ZW50c3x8ITEhPT1pLmV2ZW50cy5wYXNzaXZlKXJldHVybn0vXihtb3VzZXxwb2ludGVyfHRvdWNoKSooZG93bnxzdGFydCkvaS50ZXN0KG4udHlwZSl8fEhuLmVsZW1lbnQobi50YXJnZXQpJiYoMCwkLm1hdGNoZXNTZWxlY3Rvcikobi50YXJnZXQsXCJpbnB1dCxzZWxlY3QsdGV4dGFyZWEsW2NvbnRlbnRlZGl0YWJsZT10cnVlXSxbY29udGVudGVkaXRhYmxlPXRydWVdICpcIil8fG4ucHJldmVudERlZmF1bHQoKX1lbHNlIG4ucHJldmVudERlZmF1bHQoKX0odGhpcyxyLHQpfSxyLmludGVyYWN0aW9ucy5kb2NFdmVudHMucHVzaCh7dHlwZTpcImRyYWdzdGFydFwiLGxpc3RlbmVyOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8ci5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7ZSsrKXt2YXIgbj1yLmludGVyYWN0aW9ucy5saXN0W2VdO2lmKG4uZWxlbWVudCYmKG4uZWxlbWVudD09PXQudGFyZ2V0fHwoMCwkLm5vZGVDb250YWlucykobi5lbGVtZW50LHQudGFyZ2V0KSkpcmV0dXJuIHZvaWQgbi5pbnRlcmFjdGFibGUuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdCh0KX19fSl9dmFyIFFuPXtpZDpcImNvcmUvaW50ZXJhY3RhYmxlUHJldmVudERlZmF1bHRcIixpbnN0YWxsOkpuLGxpc3RlbmVyczpbXCJkb3duXCIsXCJtb3ZlXCIsXCJ1cFwiLFwiY2FuY2VsXCJdLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0W1wiaW50ZXJhY3Rpb25zOlwiLmNvbmNhdChlKV09Wm4sdH0se30pfTtVbi5kZWZhdWx0PVFuO3ZhciB0cj17fTtmdW5jdGlvbiBlcih0KXtyZXR1cm4oZXI9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0ci5kZWZhdWx0PXZvaWQgMDt2YXIgbnI9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09ZXIodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9cnIoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oJCk7ZnVuY3Rpb24gcnIoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBycj1mdW5jdGlvbigpe3JldHVybiB0fSx0fXZhciBvcj17bWV0aG9kT3JkZXI6W1wic2ltdWxhdGlvblJlc3VtZVwiLFwibW91c2VPclBlblwiLFwiaGFzUG9pbnRlclwiLFwiaWRsZVwiXSxzZWFyY2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTxvci5tZXRob2RPcmRlci5sZW5ndGg7ZSsrKXt2YXIgbjtuPW9yLm1ldGhvZE9yZGVyW2VdO3ZhciByPW9yW25dKHQpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIG51bGx9LHNpbXVsYXRpb25SZXN1bWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5wb2ludGVyVHlwZSxuPXQuZXZlbnRUeXBlLHI9dC5ldmVudFRhcmdldCxvPXQuc2NvcGU7aWYoIS9kb3dufHN0YXJ0L2kudGVzdChuKSlyZXR1cm4gbnVsbDtmb3IodmFyIGk9MDtpPG8uaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO2krKyl7dmFyIGE9by5pbnRlcmFjdGlvbnMubGlzdFtpXSx1PXI7aWYoYS5zaW11bGF0aW9uJiZhLnNpbXVsYXRpb24uYWxsb3dSZXN1bWUmJmEucG9pbnRlclR5cGU9PT1lKWZvcig7dTspe2lmKHU9PT1hLmVsZW1lbnQpcmV0dXJuIGE7dT1uci5wYXJlbnROb2RlKHUpfX1yZXR1cm4gbnVsbH0sbW91c2VPclBlbjpmdW5jdGlvbih0KXt2YXIgZSxuPXQucG9pbnRlcklkLHI9dC5wb2ludGVyVHlwZSxvPXQuZXZlbnRUeXBlLGk9dC5zY29wZTtpZihcIm1vdXNlXCIhPT1yJiZcInBlblwiIT09cilyZXR1cm4gbnVsbDtmb3IodmFyIGE9MDthPGkuaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO2ErKyl7dmFyIHU9aS5pbnRlcmFjdGlvbnMubGlzdFthXTtpZih1LnBvaW50ZXJUeXBlPT09cil7aWYodS5zaW11bGF0aW9uJiYhaXIodSxuKSljb250aW51ZTtpZih1LmludGVyYWN0aW5nKCkpcmV0dXJuIHU7ZT1lfHx1fX1pZihlKXJldHVybiBlO2Zvcih2YXIgcz0wO3M8aS5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7cysrKXt2YXIgbD1pLmludGVyYWN0aW9ucy5saXN0W3NdO2lmKCEobC5wb2ludGVyVHlwZSE9PXJ8fC9kb3duL2kudGVzdChvKSYmbC5zaW11bGF0aW9uKSlyZXR1cm4gbH1yZXR1cm4gbnVsbH0saGFzUG9pbnRlcjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5wb2ludGVySWQsbj10LnNjb3BlLHI9MDtyPG4uaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO3IrKyl7dmFyIG89bi5pbnRlcmFjdGlvbnMubGlzdFtyXTtpZihpcihvLGUpKXJldHVybiBvfXJldHVybiBudWxsfSxpZGxlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnBvaW50ZXJUeXBlLG49dC5zY29wZSxyPTA7cjxuLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDtyKyspe3ZhciBvPW4uaW50ZXJhY3Rpb25zLmxpc3Rbcl07aWYoMT09PW8ucG9pbnRlcnMubGVuZ3RoKXt2YXIgaT1vLmludGVyYWN0YWJsZTtpZihpJiYoIWkub3B0aW9ucy5nZXN0dXJlfHwhaS5vcHRpb25zLmdlc3R1cmUuZW5hYmxlZCkpY29udGludWV9ZWxzZSBpZigyPD1vLnBvaW50ZXJzLmxlbmd0aCljb250aW51ZTtpZighby5pbnRlcmFjdGluZygpJiZlPT09by5wb2ludGVyVHlwZSlyZXR1cm4gb31yZXR1cm4gbnVsbH19O2Z1bmN0aW9uIGlyKHQsZSl7cmV0dXJuIHQucG9pbnRlcnMuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdC5pZD09PWV9KX12YXIgYXI9b3I7dHIuZGVmYXVsdD1hcjt2YXIgdXI9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHVyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHVyLmRlZmF1bHQ9dm9pZCAwO3ZhciBzcixscj0oc3I9TWUpJiZzci5fX2VzTW9kdWxlP3NyOntkZWZhdWx0OnNyfSxjcj1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1wcih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1mcigpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShTKTtmdW5jdGlvbiBmcigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIGZyPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gcHIodCl7cmV0dXJuKHByPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiBkcih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gdnIodCl7cmV0dXJuKHZyPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX1mdW5jdGlvbiB5cih0KXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gdH1mdW5jdGlvbiBocih0LGUpe3JldHVybihocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9ZnVuY3Rpb24gZ3IodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBicj1mdW5jdGlvbigpe2Z1bmN0aW9uIGwodCxlLG4pe3ZhciByLG8saTshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGwpLG89dGhpcyxyPSEoaT12cihsKS5jYWxsKHRoaXMsZS5faW50ZXJhY3Rpb24pKXx8XCJvYmplY3RcIiE9PXByKGkpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBpP3lyKG8pOmksZ3IoeXIociksXCJ0YXJnZXRcIix2b2lkIDApLGdyKHlyKHIpLFwiZHJvcHpvbmVcIix2b2lkIDApLGdyKHlyKHIpLFwiZHJhZ0V2ZW50XCIsdm9pZCAwKSxncih5cihyKSxcInJlbGF0ZWRUYXJnZXRcIix2b2lkIDApLGdyKHlyKHIpLFwiZHJhZ2dhYmxlXCIsdm9pZCAwKSxncih5cihyKSxcInRpbWVTdGFtcFwiLHZvaWQgMCksZ3IoeXIociksXCJwcm9wYWdhdGlvblN0b3BwZWRcIiwhMSksZ3IoeXIociksXCJpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcIiwhMSk7dmFyIGE9XCJkcmFnbGVhdmVcIj09PW4/dC5wcmV2OnQuY3VyLHU9YS5lbGVtZW50LHM9YS5kcm9wem9uZTtyZXR1cm4gci50eXBlPW4sci50YXJnZXQ9dSxyLmN1cnJlbnRUYXJnZXQ9dSxyLmRyb3B6b25lPXMsci5kcmFnRXZlbnQ9ZSxyLnJlbGF0ZWRUYXJnZXQ9ZS50YXJnZXQsci5kcmFnZ2FibGU9ZS5pbnRlcmFjdGFibGUsci50aW1lU3RhbXA9ZS50aW1lU3RhbXAscn12YXIgdCxlLG47cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiZocih0LGUpfShsLGxyW1wiZGVmYXVsdFwiXSksdD1sLChlPVt7a2V5OlwicmVqZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgcj10aGlzLHQ9dGhpcy5faW50ZXJhY3Rpb24uZHJvcFN0YXRlO2lmKFwiZHJvcGFjdGl2YXRlXCI9PT10aGlzLnR5cGV8fHRoaXMuZHJvcHpvbmUmJnQuY3VyLmRyb3B6b25lPT09dGhpcy5kcm9wem9uZSYmdC5jdXIuZWxlbWVudD09PXRoaXMudGFyZ2V0KWlmKHQucHJldi5kcm9wem9uZT10aGlzLmRyb3B6b25lLHQucHJldi5lbGVtZW50PXRoaXMudGFyZ2V0LHQucmVqZWN0ZWQ9ITAsdC5ldmVudHMuZW50ZXI9bnVsbCx0aGlzLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLFwiZHJvcGFjdGl2YXRlXCI9PT10aGlzLnR5cGUpe3ZhciBlPXQuYWN0aXZlRHJvcHMsbj1jci5maW5kSW5kZXgoZSxmdW5jdGlvbih0KXt2YXIgZT10LmRyb3B6b25lLG49dC5lbGVtZW50O3JldHVybiBlPT09ci5kcm9wem9uZSYmbj09PXIudGFyZ2V0fSk7dC5hY3RpdmVEcm9wcy5zcGxpY2UobiwxKTt2YXIgbz1uZXcgbCh0LHRoaXMuZHJhZ0V2ZW50LFwiZHJvcGRlYWN0aXZhdGVcIik7by5kcm9wem9uZT10aGlzLmRyb3B6b25lLG8udGFyZ2V0PXRoaXMudGFyZ2V0LHRoaXMuZHJvcHpvbmUuZmlyZShvKX1lbHNlIHRoaXMuZHJvcHpvbmUuZmlyZShuZXcgbCh0LHRoaXMuZHJhZ0V2ZW50LFwiZHJhZ2xlYXZlXCIpKX19LHtrZXk6XCJwcmV2ZW50RGVmYXVsdFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcInN0b3BQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fSx7a2V5Olwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD10aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19XSkmJmRyKHQucHJvdG90eXBlLGUpLG4mJmRyKHQsbiksbH0oKTt1ci5kZWZhdWx0PWJyO3ZhciBtcj17fTtmdW5jdGlvbiBPcih0KXtyZXR1cm4oT3I9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShtcixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxtci5kZWZhdWx0PXZvaWQgMDtTcihrKHt9KSksU3IobSh7fSkpO3ZhciB3cj1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1Pcih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT14cigpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShsZSksX3I9U3IodiksUHI9U3IodXIpO2Z1bmN0aW9uIHhyKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4geHI9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBTcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24ganIodCxlKXtmb3IodmFyIG49MDtuPHQuc2xpY2UoKS5sZW5ndGg7bisrKXtyPXQuc2xpY2UoKVtuXTt2YXIgcixvPXIuZHJvcHpvbmUsaT1yLmVsZW1lbnQ7ZS5kcm9wem9uZT1vLGUudGFyZ2V0PWksby5maXJlKGUpLGUucHJvcGFnYXRpb25TdG9wcGVkPWUuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPSExfX1mdW5jdGlvbiBNcih0LGUpe2Zvcih2YXIgbj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmludGVyYWN0YWJsZXMscj1bXSxvPTA7bzxuLmxpc3QubGVuZ3RoO28rKyl7dmFyIGk9bi5saXN0W29dO2lmKGkub3B0aW9ucy5kcm9wLmVuYWJsZWQpe3ZhciBhPWkub3B0aW9ucy5kcm9wLmFjY2VwdDtpZighKHdyLmlzLmVsZW1lbnQoYSkmJmEhPT1lfHx3ci5pcy5zdHJpbmcoYSkmJiF3ci5kb20ubWF0Y2hlc1NlbGVjdG9yKGUsYSl8fHdyLmlzLmZ1bmMoYSkmJiFhKHtkcm9wem9uZTppLGRyYWdnYWJsZUVsZW1lbnQ6ZX0pKSlmb3IodmFyIHU9d3IuaXMuc3RyaW5nKGkudGFyZ2V0KT9pLl9jb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoaS50YXJnZXQpOndyLmlzLmFycmF5KGkudGFyZ2V0KT9pLnRhcmdldDpbaS50YXJnZXRdLHM9MDtzPHUubGVuZ3RoO3MrKyl7dmFyIGw7bD11W3NdO2whPT1lJiZyLnB1c2goe2Ryb3B6b25lOmksZWxlbWVudDpsfSl9fX1yZXR1cm4gcn0odCxlKSxyPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBvO289bltyXTtvLnJlY3Q9by5kcm9wem9uZS5nZXRSZWN0KG8uZWxlbWVudCl9cmV0dXJuIG59ZnVuY3Rpb24ga3IodCxlLG4pe2Zvcih2YXIgcj10LmRyb3BTdGF0ZSxvPXQuaW50ZXJhY3RhYmxlLGk9dC5lbGVtZW50LGE9W10sdT0wO3U8ci5hY3RpdmVEcm9wcy5sZW5ndGg7dSsrKXtzPXIuYWN0aXZlRHJvcHNbdV07dmFyIHMsbD1zLmRyb3B6b25lLGM9cy5lbGVtZW50LGY9cy5yZWN0O2EucHVzaChsLmRyb3BDaGVjayhlLG4sbyxpLGMsZik/YzpudWxsKX12YXIgcD13ci5kb20uaW5kZXhPZkRlZXBlc3RFbGVtZW50KGEpO3JldHVybiByLmFjdGl2ZURyb3BzW3BdfHxudWxsfWZ1bmN0aW9uIEVyKHQsZSxuKXt2YXIgcj10LmRyb3BTdGF0ZSxvPXtlbnRlcjpudWxsLGxlYXZlOm51bGwsYWN0aXZhdGU6bnVsbCxkZWFjdGl2YXRlOm51bGwsbW92ZTpudWxsLGRyb3A6bnVsbH07cmV0dXJuXCJkcmFnc3RhcnRcIj09PW4udHlwZSYmKG8uYWN0aXZhdGU9bmV3IFByLmRlZmF1bHQocixuLFwiZHJvcGFjdGl2YXRlXCIpLG8uYWN0aXZhdGUudGFyZ2V0PW51bGwsby5hY3RpdmF0ZS5kcm9wem9uZT1udWxsKSxcImRyYWdlbmRcIj09PW4udHlwZSYmKG8uZGVhY3RpdmF0ZT1uZXcgUHIuZGVmYXVsdChyLG4sXCJkcm9wZGVhY3RpdmF0ZVwiKSxvLmRlYWN0aXZhdGUudGFyZ2V0PW51bGwsby5kZWFjdGl2YXRlLmRyb3B6b25lPW51bGwpLHIucmVqZWN0ZWR8fChyLmN1ci5lbGVtZW50IT09ci5wcmV2LmVsZW1lbnQmJihyLnByZXYuZHJvcHpvbmUmJihvLmxlYXZlPW5ldyBQci5kZWZhdWx0KHIsbixcImRyYWdsZWF2ZVwiKSxuLmRyYWdMZWF2ZT1vLmxlYXZlLnRhcmdldD1yLnByZXYuZWxlbWVudCxuLnByZXZEcm9wem9uZT1vLmxlYXZlLmRyb3B6b25lPXIucHJldi5kcm9wem9uZSksci5jdXIuZHJvcHpvbmUmJihvLmVudGVyPW5ldyBQci5kZWZhdWx0KHIsbixcImRyYWdlbnRlclwiKSxuLmRyYWdFbnRlcj1yLmN1ci5lbGVtZW50LG4uZHJvcHpvbmU9ci5jdXIuZHJvcHpvbmUpKSxcImRyYWdlbmRcIj09PW4udHlwZSYmci5jdXIuZHJvcHpvbmUmJihvLmRyb3A9bmV3IFByLmRlZmF1bHQocixuLFwiZHJvcFwiKSxuLmRyb3B6b25lPXIuY3VyLmRyb3B6b25lLG4ucmVsYXRlZFRhcmdldD1yLmN1ci5lbGVtZW50KSxcImRyYWdtb3ZlXCI9PT1uLnR5cGUmJnIuY3VyLmRyb3B6b25lJiYoby5tb3ZlPW5ldyBQci5kZWZhdWx0KHIsbixcImRyb3Btb3ZlXCIpLChvLm1vdmUuZHJhZ21vdmU9bikuZHJvcHpvbmU9ci5jdXIuZHJvcHpvbmUpKSxvfWZ1bmN0aW9uIFRyKHQsZSl7dmFyIG49dC5kcm9wU3RhdGUscj1uLmFjdGl2ZURyb3BzLG89bi5jdXIsaT1uLnByZXY7ZS5sZWF2ZSYmaS5kcm9wem9uZS5maXJlKGUubGVhdmUpLGUubW92ZSYmby5kcm9wem9uZS5maXJlKGUubW92ZSksZS5lbnRlciYmby5kcm9wem9uZS5maXJlKGUuZW50ZXIpLGUuZHJvcCYmby5kcm9wem9uZS5maXJlKGUuZHJvcCksZS5kZWFjdGl2YXRlJiZqcihyLGUuZGVhY3RpdmF0ZSksbi5wcmV2LmRyb3B6b25lPW8uZHJvcHpvbmUsbi5wcmV2LmVsZW1lbnQ9by5lbGVtZW50fWZ1bmN0aW9uIERyKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQuaUV2ZW50LG89dC5ldmVudDtpZihcImRyYWdtb3ZlXCI9PT1yLnR5cGV8fFwiZHJhZ2VuZFwiPT09ci50eXBlKXt2YXIgaT1uLmRyb3BTdGF0ZTtlLmR5bmFtaWNEcm9wJiYoaS5hY3RpdmVEcm9wcz1NcihlLG4uZWxlbWVudCkpO3ZhciBhPXIsdT1rcihuLGEsbyk7aS5yZWplY3RlZD1pLnJlamVjdGVkJiYhIXUmJnUuZHJvcHpvbmU9PT1pLmN1ci5kcm9wem9uZSYmdS5lbGVtZW50PT09aS5jdXIuZWxlbWVudCxpLmN1ci5kcm9wem9uZT11JiZ1LmRyb3B6b25lLGkuY3VyLmVsZW1lbnQ9dSYmdS5lbGVtZW50LGkuZXZlbnRzPUVyKG4sMCxhKX19dmFyIElyPXtpZDpcImFjdGlvbnMvZHJvcFwiLGluc3RhbGw6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hY3Rpb25zLG49ZS5pbnRlcmFjdFN0YXRpYyxyPWUuSW50ZXJhY3RhYmxlLG89ZS5kZWZhdWx0cztlLnVzZVBsdWdpbihfci5kZWZhdWx0KSxyLnByb3RvdHlwZS5kcm9wem9uZT1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlKXtpZih3ci5pcy5vYmplY3QoZSkpe2lmKHQub3B0aW9ucy5kcm9wLmVuYWJsZWQ9ITEhPT1lLmVuYWJsZWQsZS5saXN0ZW5lcnMpe3ZhciBuPXdyLm5vcm1hbGl6ZUxpc3RlbmVycyhlLmxpc3RlbmVycykscj1PYmplY3Qua2V5cyhuKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFsvXihlbnRlcnxsZWF2ZSkvLnRlc3QoZSk/XCJkcmFnXCIuY29uY2F0KGUpOi9eKGFjdGl2YXRlfGRlYWN0aXZhdGV8bW92ZSkvLnRlc3QoZSk/XCJkcm9wXCIuY29uY2F0KGUpOmVdPW5bZV0sdH0se30pO3Qub2ZmKHQub3B0aW9ucy5kcm9wLmxpc3RlbmVycyksdC5vbihyKSx0Lm9wdGlvbnMuZHJvcC5saXN0ZW5lcnM9cn1yZXR1cm4gd3IuaXMuZnVuYyhlLm9uZHJvcCkmJnQub24oXCJkcm9wXCIsZS5vbmRyb3ApLHdyLmlzLmZ1bmMoZS5vbmRyb3BhY3RpdmF0ZSkmJnQub24oXCJkcm9wYWN0aXZhdGVcIixlLm9uZHJvcGFjdGl2YXRlKSx3ci5pcy5mdW5jKGUub25kcm9wZGVhY3RpdmF0ZSkmJnQub24oXCJkcm9wZGVhY3RpdmF0ZVwiLGUub25kcm9wZGVhY3RpdmF0ZSksd3IuaXMuZnVuYyhlLm9uZHJhZ2VudGVyKSYmdC5vbihcImRyYWdlbnRlclwiLGUub25kcmFnZW50ZXIpLHdyLmlzLmZ1bmMoZS5vbmRyYWdsZWF2ZSkmJnQub24oXCJkcmFnbGVhdmVcIixlLm9uZHJhZ2xlYXZlKSx3ci5pcy5mdW5jKGUub25kcm9wbW92ZSkmJnQub24oXCJkcm9wbW92ZVwiLGUub25kcm9wbW92ZSksL14ocG9pbnRlcnxjZW50ZXIpJC8udGVzdChlLm92ZXJsYXApP3Qub3B0aW9ucy5kcm9wLm92ZXJsYXA9ZS5vdmVybGFwOndyLmlzLm51bWJlcihlLm92ZXJsYXApJiYodC5vcHRpb25zLmRyb3Aub3ZlcmxhcD1NYXRoLm1heChNYXRoLm1pbigxLGUub3ZlcmxhcCksMCkpLFwiYWNjZXB0XCJpbiBlJiYodC5vcHRpb25zLmRyb3AuYWNjZXB0PWUuYWNjZXB0KSxcImNoZWNrZXJcImluIGUmJih0Lm9wdGlvbnMuZHJvcC5jaGVja2VyPWUuY2hlY2tlciksdH1pZih3ci5pcy5ib29sKGUpKXJldHVybiB0Lm9wdGlvbnMuZHJvcC5lbmFibGVkPWUsdDtyZXR1cm4gdC5vcHRpb25zLmRyb3B9KHRoaXMsdCl9LHIucHJvdG90eXBlLmRyb3BDaGVjaz1mdW5jdGlvbih0LGUsbixyLG8saSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxpLGEpe3ZhciB1PSExO2lmKCEoYT1hfHx0LmdldFJlY3QoaSkpKXJldHVybiEhdC5vcHRpb25zLmRyb3AuY2hlY2tlciYmdC5vcHRpb25zLmRyb3AuY2hlY2tlcihlLG4sdSx0LGkscixvKTt2YXIgcz10Lm9wdGlvbnMuZHJvcC5vdmVybGFwO2lmKFwicG9pbnRlclwiPT09cyl7dmFyIGw9d3IuZ2V0T3JpZ2luWFkocixvLFwiZHJhZ1wiKSxjPXdyLnBvaW50ZXIuZ2V0UGFnZVhZKGUpO2MueCs9bC54LGMueSs9bC55O3ZhciBmPWMueD5hLmxlZnQmJmMueDxhLnJpZ2h0LHA9Yy55PmEudG9wJiZjLnk8YS5ib3R0b207dT1mJiZwfXZhciBkPXIuZ2V0UmVjdChvKTtpZihkJiZcImNlbnRlclwiPT09cyl7dmFyIHY9ZC5sZWZ0K2Qud2lkdGgvMix5PWQudG9wK2QuaGVpZ2h0LzI7dT12Pj1hLmxlZnQmJnY8PWEucmlnaHQmJnk+PWEudG9wJiZ5PD1hLmJvdHRvbX1pZihkJiZ3ci5pcy5udW1iZXIocykpe3ZhciBoPU1hdGgubWF4KDAsTWF0aC5taW4oYS5yaWdodCxkLnJpZ2h0KS1NYXRoLm1heChhLmxlZnQsZC5sZWZ0KSkqTWF0aC5tYXgoMCxNYXRoLm1pbihhLmJvdHRvbSxkLmJvdHRvbSktTWF0aC5tYXgoYS50b3AsZC50b3ApKS8oZC53aWR0aCpkLmhlaWdodCk7dT1zPD1ofXQub3B0aW9ucy5kcm9wLmNoZWNrZXImJih1PXQub3B0aW9ucy5kcm9wLmNoZWNrZXIoZSxuLHUsdCxpLHIsbykpO3JldHVybiB1fSh0aGlzLHQsZSxuLHIsbyxpKX0sbi5keW5hbWljRHJvcD1mdW5jdGlvbih0KXtyZXR1cm4gd3IuaXMuYm9vbCh0KT8oZS5keW5hbWljRHJvcD10LG4pOmUuZHluYW1pY0Ryb3B9LHdyLmV4dGVuZCh0LnBoYXNlbGVzc1R5cGVzLHtkcmFnZW50ZXI6ITAsZHJhZ2xlYXZlOiEwLGRyb3BhY3RpdmF0ZTohMCxkcm9wZGVhY3RpdmF0ZTohMCxkcm9wbW92ZTohMCxkcm9wOiEwfSksdC5tZXRob2REaWN0LmRyb3A9XCJkcm9wem9uZVwiLGUuZHluYW1pY0Ryb3A9ITEsby5hY3Rpb25zLmRyb3A9SXIuZGVmYXVsdHN9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1zdGFydFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247XCJkcmFnXCI9PT1lLnByZXBhcmVkLm5hbWUmJihlLmRyb3BTdGF0ZT17Y3VyOntkcm9wem9uZTpudWxsLGVsZW1lbnQ6bnVsbH0scHJldjp7ZHJvcHpvbmU6bnVsbCxlbGVtZW50Om51bGx9LHJlamVjdGVkOm51bGwsZXZlbnRzOm51bGwsYWN0aXZlRHJvcHM6W119KX0sXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLXN0YXJ0XCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9KHQuZXZlbnQsdC5pRXZlbnQpO2lmKFwiZHJhZ1wiPT09bi5wcmVwYXJlZC5uYW1lKXt2YXIgbz1uLmRyb3BTdGF0ZTtvLmFjdGl2ZURyb3BzPW51bGwsby5ldmVudHM9bnVsbCxvLmFjdGl2ZURyb3BzPU1yKGUsbi5lbGVtZW50KSxvLmV2ZW50cz1FcihuLDAsciksby5ldmVudHMuYWN0aXZhdGUmJihqcihvLmFjdGl2ZURyb3BzLG8uZXZlbnRzLmFjdGl2YXRlKSxlLmZpcmUoXCJhY3Rpb25zL2Ryb3A6c3RhcnRcIix7aW50ZXJhY3Rpb246bixkcmFnRXZlbnQ6cn0pKX19LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlXCI6RHIsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLWVuZFwiOkRyLFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1tb3ZlXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5pRXZlbnQ7XCJkcmFnXCI9PT1uLnByZXBhcmVkLm5hbWUmJihUcihuLG4uZHJvcFN0YXRlLmV2ZW50cyksZS5maXJlKFwiYWN0aW9ucy9kcm9wOm1vdmVcIix7aW50ZXJhY3Rpb246bixkcmFnRXZlbnQ6cn0pLG4uZHJvcFN0YXRlLmV2ZW50cz17fSl9LFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1lbmRcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LmlFdmVudDtcImRyYWdcIj09PW4ucHJlcGFyZWQubmFtZSYmKFRyKG4sbi5kcm9wU3RhdGUuZXZlbnRzKSxlLmZpcmUoXCJhY3Rpb25zL2Ryb3A6ZW5kXCIse2ludGVyYWN0aW9uOm4sZHJhZ0V2ZW50OnJ9KSl9LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2lmKFwiZHJhZ1wiPT09ZS5wcmVwYXJlZC5uYW1lKXt2YXIgbj1lLmRyb3BTdGF0ZTtuJiYobi5hY3RpdmVEcm9wcz1udWxsLG4uZXZlbnRzPW51bGwsbi5jdXIuZHJvcHpvbmU9bnVsbCxuLmN1ci5lbGVtZW50PW51bGwsbi5wcmV2LmRyb3B6b25lPW51bGwsbi5wcmV2LmVsZW1lbnQ9bnVsbCxuLnJlamVjdGVkPSExKX19fSxnZXRBY3RpdmVEcm9wczpNcixnZXREcm9wOmtyLGdldERyb3BFdmVudHM6RXIsZmlyZURyb3BFdmVudHM6VHIsZGVmYXVsdHM6e2VuYWJsZWQ6ITEsYWNjZXB0Om51bGwsb3ZlcmxhcDpcInBvaW50ZXJcIn19LHpyPUlyO21yLmRlZmF1bHQ9enI7dmFyIEFyPXt9O2Z1bmN0aW9uIENyKHQpe3JldHVybihDcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KEFyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEFyLmRlZmF1bHQ9dm9pZCAwO3ZhciBXcj1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1Dcih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1ScigpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShsZSk7ZnVuY3Rpb24gUnIoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBScj1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIEZyKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmlFdmVudCxyPXQucGhhc2U7aWYoXCJnZXN0dXJlXCI9PT1lLnByZXBhcmVkLm5hbWUpe3ZhciBvPWUucG9pbnRlcnMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnBvaW50ZXJ9KSxpPVwic3RhcnRcIj09PXIsYT1cImVuZFwiPT09cix1PWUuaW50ZXJhY3RhYmxlLm9wdGlvbnMuZGVsdGFTb3VyY2U7aWYobi50b3VjaGVzPVtvWzBdLG9bMV1dLGkpbi5kaXN0YW5jZT1Xci5wb2ludGVyLnRvdWNoRGlzdGFuY2Uobyx1KSxuLmJveD1Xci5wb2ludGVyLnRvdWNoQkJveChvKSxuLnNjYWxlPTEsbi5kcz0wLG4uYW5nbGU9V3IucG9pbnRlci50b3VjaEFuZ2xlKG8sdSksbi5kYT0wLGUuZ2VzdHVyZS5zdGFydERpc3RhbmNlPW4uZGlzdGFuY2UsZS5nZXN0dXJlLnN0YXJ0QW5nbGU9bi5hbmdsZTtlbHNlIGlmKGEpe3ZhciBzPWUucHJldkV2ZW50O24uZGlzdGFuY2U9cy5kaXN0YW5jZSxuLmJveD1zLmJveCxuLnNjYWxlPXMuc2NhbGUsbi5kcz0wLG4uYW5nbGU9cy5hbmdsZSxuLmRhPTB9ZWxzZSBuLmRpc3RhbmNlPVdyLnBvaW50ZXIudG91Y2hEaXN0YW5jZShvLHUpLG4uYm94PVdyLnBvaW50ZXIudG91Y2hCQm94KG8pLG4uc2NhbGU9bi5kaXN0YW5jZS9lLmdlc3R1cmUuc3RhcnREaXN0YW5jZSxuLmFuZ2xlPVdyLnBvaW50ZXIudG91Y2hBbmdsZShvLHUpLG4uZHM9bi5zY2FsZS1lLmdlc3R1cmUuc2NhbGUsbi5kYT1uLmFuZ2xlLWUuZ2VzdHVyZS5hbmdsZTtlLmdlc3R1cmUuZGlzdGFuY2U9bi5kaXN0YW5jZSxlLmdlc3R1cmUuYW5nbGU9bi5hbmdsZSxXci5pcy5udW1iZXIobi5zY2FsZSkmJm4uc2NhbGUhPT0xLzAmJiFpc05hTihuLnNjYWxlKSYmKGUuZ2VzdHVyZS5zY2FsZT1uLnNjYWxlKX19dmFyIFhyPXtpZDpcImFjdGlvbnMvZ2VzdHVyZVwiLGJlZm9yZTpbXCJhY3Rpb25zL2RyYWdcIixcImFjdGlvbnMvcmVzaXplXCJdLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5hY3Rpb25zLG49dC5JbnRlcmFjdGFibGUscj10LmRlZmF1bHRzO24ucHJvdG90eXBlLmdlc3R1cmFibGU9ZnVuY3Rpb24odCl7cmV0dXJuIFdyLmlzLm9iamVjdCh0KT8odGhpcy5vcHRpb25zLmdlc3R1cmUuZW5hYmxlZD0hMSE9PXQuZW5hYmxlZCx0aGlzLnNldFBlckFjdGlvbihcImdlc3R1cmVcIix0KSx0aGlzLnNldE9uRXZlbnRzKFwiZ2VzdHVyZVwiLHQpLHRoaXMpOldyLmlzLmJvb2wodCk/KHRoaXMub3B0aW9ucy5nZXN0dXJlLmVuYWJsZWQ9dCx0aGlzKTp0aGlzLm9wdGlvbnMuZ2VzdHVyZX0sZS5tYXAuZ2VzdHVyZT1YcixlLm1ldGhvZERpY3QuZ2VzdHVyZT1cImdlc3R1cmFibGVcIixyLmFjdGlvbnMuZ2VzdHVyZT1Yci5kZWZhdWx0c30sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczphY3Rpb24tc3RhcnRcIjpGcixcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOkZyLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1lbmRcIjpGcixcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLmdlc3R1cmU9e2FuZ2xlOjAsZGlzdGFuY2U6MCxzY2FsZToxLHN0YXJ0QW5nbGU6MCxzdGFydERpc3RhbmNlOjB9fSxcImF1dG8tc3RhcnQ6Y2hlY2tcIjpmdW5jdGlvbih0KXtpZighKHQuaW50ZXJhY3Rpb24ucG9pbnRlcnMubGVuZ3RoPDIpKXt2YXIgZT10LmludGVyYWN0YWJsZS5vcHRpb25zLmdlc3R1cmU7aWYoZSYmZS5lbmFibGVkKXJldHVybiEodC5hY3Rpb249e25hbWU6XCJnZXN0dXJlXCJ9KX19fSxkZWZhdWx0czp7fSxnZXRDdXJzb3I6ZnVuY3Rpb24oKXtyZXR1cm5cIlwifX0sWXI9WHI7QXIuZGVmYXVsdD1Zcjt2YXIgTnI9e307ZnVuY3Rpb24gTHIodCl7cmV0dXJuKExyPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoTnIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksTnIuZGVmYXVsdD12b2lkIDA7dmFyIEJyLFZyPUhyKCQpLHFyPShCcj1jdCkmJkJyLl9fZXNNb2R1bGU/QnI6e2RlZmF1bHQ6QnJ9LFVyPUhyKHcpO2Z1bmN0aW9uIEdyKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gR3I9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBIcih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1Mcih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1HcigpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufWZ1bmN0aW9uIEtyKHQsZSxuLHIsbyxpLGEpe2lmKCFlKXJldHVybiExO2lmKCEwPT09ZSl7dmFyIHU9VXIubnVtYmVyKGkud2lkdGgpP2kud2lkdGg6aS5yaWdodC1pLmxlZnQscz1Vci5udW1iZXIoaS5oZWlnaHQpP2kuaGVpZ2h0OmkuYm90dG9tLWkudG9wO2lmKGE9TWF0aC5taW4oYSwoXCJsZWZ0XCI9PT10fHxcInJpZ2h0XCI9PT10P3U6cykvMiksdTwwJiYoXCJsZWZ0XCI9PT10P3Q9XCJyaWdodFwiOlwicmlnaHRcIj09PXQmJih0PVwibGVmdFwiKSksczwwJiYoXCJ0b3BcIj09PXQ/dD1cImJvdHRvbVwiOlwiYm90dG9tXCI9PT10JiYodD1cInRvcFwiKSksXCJsZWZ0XCI9PT10KXJldHVybiBuLng8KDA8PXU/aS5sZWZ0OmkucmlnaHQpK2E7aWYoXCJ0b3BcIj09PXQpcmV0dXJuIG4ueTwoMDw9cz9pLnRvcDppLmJvdHRvbSkrYTtpZihcInJpZ2h0XCI9PT10KXJldHVybiBuLng+KDA8PXU/aS5yaWdodDppLmxlZnQpLWE7aWYoXCJib3R0b21cIj09PXQpcmV0dXJuIG4ueT4oMDw9cz9pLmJvdHRvbTppLnRvcCktYX1yZXR1cm4hIVVyLmVsZW1lbnQocikmJihVci5lbGVtZW50KGUpP2U9PT1yOlZyLm1hdGNoZXNVcFRvKHIsZSxvKSl9ZnVuY3Rpb24gJHIodCl7dmFyIGU9dC5pRXZlbnQsbj10LmludGVyYWN0aW9uO2lmKFwicmVzaXplXCI9PT1uLnByZXBhcmVkLm5hbWUmJm4ucmVzaXplQXhlcyl7dmFyIHI9ZTtuLmludGVyYWN0YWJsZS5vcHRpb25zLnJlc2l6ZS5zcXVhcmU/KFwieVwiPT09bi5yZXNpemVBeGVzP3IuZGVsdGEueD1yLmRlbHRhLnk6ci5kZWx0YS55PXIuZGVsdGEueCxyLmF4ZXM9XCJ4eVwiKTooci5heGVzPW4ucmVzaXplQXhlcyxcInhcIj09PW4ucmVzaXplQXhlcz9yLmRlbHRhLnk9MDpcInlcIj09PW4ucmVzaXplQXhlcyYmKHIuZGVsdGEueD0wKSl9fXZhciBacj17aWQ6XCJhY3Rpb25zL3Jlc2l6ZVwiLGJlZm9yZTpbXCJhY3Rpb25zL2RyYWdcIl0saW5zdGFsbDpmdW5jdGlvbihlKXt2YXIgdD1lLmFjdGlvbnMsbj1lLmJyb3dzZXIscj1lLkludGVyYWN0YWJsZSxvPWUuZGVmYXVsdHM7WnIuY3Vyc29ycz1uLmlzSWU5P3t4OlwiZS1yZXNpemVcIix5Olwicy1yZXNpemVcIix4eTpcInNlLXJlc2l6ZVwiLHRvcDpcIm4tcmVzaXplXCIsbGVmdDpcInctcmVzaXplXCIsYm90dG9tOlwicy1yZXNpemVcIixyaWdodDpcImUtcmVzaXplXCIsdG9wbGVmdDpcInNlLXJlc2l6ZVwiLGJvdHRvbXJpZ2h0Olwic2UtcmVzaXplXCIsdG9wcmlnaHQ6XCJuZS1yZXNpemVcIixib3R0b21sZWZ0OlwibmUtcmVzaXplXCJ9Ont4OlwiZXctcmVzaXplXCIseTpcIm5zLXJlc2l6ZVwiLHh5OlwibndzZS1yZXNpemVcIix0b3A6XCJucy1yZXNpemVcIixsZWZ0OlwiZXctcmVzaXplXCIsYm90dG9tOlwibnMtcmVzaXplXCIscmlnaHQ6XCJldy1yZXNpemVcIix0b3BsZWZ0OlwibndzZS1yZXNpemVcIixib3R0b21yaWdodDpcIm53c2UtcmVzaXplXCIsdG9wcmlnaHQ6XCJuZXN3LXJlc2l6ZVwiLGJvdHRvbWxlZnQ6XCJuZXN3LXJlc2l6ZVwifSxaci5kZWZhdWx0TWFyZ2luPW4uc3VwcG9ydHNUb3VjaHx8bi5zdXBwb3J0c1BvaW50ZXJFdmVudD8yMDoxMCxyLnByb3RvdHlwZS5yZXNpemFibGU9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtpZihVci5vYmplY3QoZSkpcmV0dXJuIHQub3B0aW9ucy5yZXNpemUuZW5hYmxlZD0hMSE9PWUuZW5hYmxlZCx0LnNldFBlckFjdGlvbihcInJlc2l6ZVwiLGUpLHQuc2V0T25FdmVudHMoXCJyZXNpemVcIixlKSxVci5zdHJpbmcoZS5heGlzKSYmL154JHxeeSR8Xnh5JC8udGVzdChlLmF4aXMpP3Qub3B0aW9ucy5yZXNpemUuYXhpcz1lLmF4aXM6bnVsbD09PWUuYXhpcyYmKHQub3B0aW9ucy5yZXNpemUuYXhpcz1uLmRlZmF1bHRzLmFjdGlvbnMucmVzaXplLmF4aXMpLFVyLmJvb2woZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvKT90Lm9wdGlvbnMucmVzaXplLnByZXNlcnZlQXNwZWN0UmF0aW89ZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvOlVyLmJvb2woZS5zcXVhcmUpJiYodC5vcHRpb25zLnJlc2l6ZS5zcXVhcmU9ZS5zcXVhcmUpLHQ7aWYoVXIuYm9vbChlKSlyZXR1cm4gdC5vcHRpb25zLnJlc2l6ZS5lbmFibGVkPWUsdDtyZXR1cm4gdC5vcHRpb25zLnJlc2l6ZX0odGhpcyx0LGUpfSx0Lm1hcC5yZXNpemU9WnIsdC5tZXRob2REaWN0LnJlc2l6ZT1cInJlc2l6YWJsZVwiLG8uYWN0aW9ucy5yZXNpemU9WnIuZGVmYXVsdHN9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5yZXNpemVBeGVzPVwieHlcIn0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLXN0YXJ0XCI6ZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbjtpZihcInJlc2l6ZVwiPT09bi5wcmVwYXJlZC5uYW1lJiZuLnByZXBhcmVkLmVkZ2VzKXt2YXIgcj1lLG89bi5yZWN0O24uX3JlY3RzPXtzdGFydDooMCxxci5kZWZhdWx0KSh7fSxvKSxjb3JyZWN0ZWQ6KDAscXIuZGVmYXVsdCkoe30sbykscHJldmlvdXM6KDAscXIuZGVmYXVsdCkoe30sbyksZGVsdGE6e2xlZnQ6MCxyaWdodDowLHdpZHRoOjAsdG9wOjAsYm90dG9tOjAsaGVpZ2h0OjB9fSxyLmVkZ2VzPW4ucHJlcGFyZWQuZWRnZXMsci5yZWN0PW4uX3JlY3RzLmNvcnJlY3RlZCxyLmRlbHRhUmVjdD1uLl9yZWN0cy5kZWx0YX19KHQpLCRyKHQpfSxcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOmZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb247aWYoXCJyZXNpemVcIj09PW4ucHJlcGFyZWQubmFtZSYmbi5wcmVwYXJlZC5lZGdlcyl7dmFyIHI9ZSxvPW4uaW50ZXJhY3RhYmxlLm9wdGlvbnMucmVzaXplLmludmVydCxpPVwicmVwb3NpdGlvblwiPT09b3x8XCJuZWdhdGVcIj09PW8sYT1uLnJlY3QsdT1uLl9yZWN0cyxzPXUuc3RhcnQsbD11LmNvcnJlY3RlZCxjPXUuZGVsdGEsZj11LnByZXZpb3VzO2lmKCgwLHFyLmRlZmF1bHQpKGYsbCksaSl7aWYoKDAscXIuZGVmYXVsdCkobCxhKSxcInJlcG9zaXRpb25cIj09PW8pe2lmKGwudG9wPmwuYm90dG9tKXt2YXIgcD1sLnRvcDtsLnRvcD1sLmJvdHRvbSxsLmJvdHRvbT1wfWlmKGwubGVmdD5sLnJpZ2h0KXt2YXIgZD1sLmxlZnQ7bC5sZWZ0PWwucmlnaHQsbC5yaWdodD1kfX19ZWxzZSBsLnRvcD1NYXRoLm1pbihhLnRvcCxzLmJvdHRvbSksbC5ib3R0b209TWF0aC5tYXgoYS5ib3R0b20scy50b3ApLGwubGVmdD1NYXRoLm1pbihhLmxlZnQscy5yaWdodCksbC5yaWdodD1NYXRoLm1heChhLnJpZ2h0LHMubGVmdCk7Zm9yKHZhciB2IGluIGwud2lkdGg9bC5yaWdodC1sLmxlZnQsbC5oZWlnaHQ9bC5ib3R0b20tbC50b3AsbCljW3ZdPWxbdl0tZlt2XTtyLmVkZ2VzPW4ucHJlcGFyZWQuZWRnZXMsci5yZWN0PWwsci5kZWx0YVJlY3Q9Y319KHQpLCRyKHQpfSxcImludGVyYWN0aW9uczphY3Rpb24tZW5kXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pRXZlbnQsbj10LmludGVyYWN0aW9uO2lmKFwicmVzaXplXCI9PT1uLnByZXBhcmVkLm5hbWUmJm4ucHJlcGFyZWQuZWRnZXMpe3ZhciByPWU7ci5lZGdlcz1uLnByZXBhcmVkLmVkZ2VzLHIucmVjdD1uLl9yZWN0cy5jb3JyZWN0ZWQsci5kZWx0YVJlY3Q9bi5fcmVjdHMuZGVsdGF9fSxcImF1dG8tc3RhcnQ6Y2hlY2tcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5pbnRlcmFjdGFibGUscj10LmVsZW1lbnQsbz10LnJlY3QsaT10LmJ1dHRvbnM7aWYobyl7dmFyIGE9KDAscXIuZGVmYXVsdCkoe30sZS5jb29yZHMuY3VyLnBhZ2UpLHU9bi5vcHRpb25zLnJlc2l6ZTtpZih1JiZ1LmVuYWJsZWQmJighZS5wb2ludGVySXNEb3dufHwhL21vdXNlfHBvaW50ZXIvLnRlc3QoZS5wb2ludGVyVHlwZSl8fDAhPShpJnUubW91c2VCdXR0b25zKSkpe2lmKFVyLm9iamVjdCh1LmVkZ2VzKSl7dmFyIHM9e2xlZnQ6ITEscmlnaHQ6ITEsdG9wOiExLGJvdHRvbTohMX07Zm9yKHZhciBsIGluIHMpc1tsXT1LcihsLHUuZWRnZXNbbF0sYSxlLl9sYXRlc3RQb2ludGVyLmV2ZW50VGFyZ2V0LHIsbyx1Lm1hcmdpbnx8WnIuZGVmYXVsdE1hcmdpbik7cy5sZWZ0PXMubGVmdCYmIXMucmlnaHQscy50b3A9cy50b3AmJiFzLmJvdHRvbSwocy5sZWZ0fHxzLnJpZ2h0fHxzLnRvcHx8cy5ib3R0b20pJiYodC5hY3Rpb249e25hbWU6XCJyZXNpemVcIixlZGdlczpzfSl9ZWxzZXt2YXIgYz1cInlcIiE9PXUuYXhpcyYmYS54Pm8ucmlnaHQtWnIuZGVmYXVsdE1hcmdpbixmPVwieFwiIT09dS5heGlzJiZhLnk+by5ib3R0b20tWnIuZGVmYXVsdE1hcmdpbjsoY3x8ZikmJih0LmFjdGlvbj17bmFtZTpcInJlc2l6ZVwiLGF4ZXM6KGM/XCJ4XCI6XCJcIikrKGY/XCJ5XCI6XCJcIil9KX1yZXR1cm4hdC5hY3Rpb24mJnZvaWQgMH19fX0sZGVmYXVsdHM6e3NxdWFyZTohMSxwcmVzZXJ2ZUFzcGVjdFJhdGlvOiExLGF4aXM6XCJ4eVwiLG1hcmdpbjpOYU4sZWRnZXM6bnVsbCxpbnZlcnQ6XCJub25lXCJ9LGN1cnNvcnM6bnVsbCxnZXRDdXJzb3I6ZnVuY3Rpb24odCl7dmFyIGU9dC5lZGdlcyxuPXQuYXhpcyxyPXQubmFtZSxvPVpyLmN1cnNvcnMsaT1udWxsO2lmKG4paT1vW3Irbl07ZWxzZSBpZihlKXtmb3IodmFyIGE9XCJcIix1PVtcInRvcFwiLFwiYm90dG9tXCIsXCJsZWZ0XCIsXCJyaWdodFwiXSxzPTA7czx1Lmxlbmd0aDtzKyspe3ZhciBsPXVbc107ZVtsXSYmKGErPWwpfWk9b1thXX1yZXR1cm4gaX0sZGVmYXVsdE1hcmdpbjpudWxsfSxKcj1acjtOci5kZWZhdWx0PUpyO3ZhciBRcj17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoUXIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFFyLFwiZHJhZ1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0by5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRcixcImRyb3BcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZW8uZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoUXIsXCJnZXN0dXJlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5vLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFFyLFwicmVzaXplXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJvLmRlZmF1bHR9fSksUXIuZGVmYXVsdD12b2lkIDA7dmFyIHRvPW9vKHYpLGVvPW9vKG1yKSxubz1vbyhBcikscm89b28oTnIpO2Z1bmN0aW9uIG9vKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX12YXIgaW89e2lkOlwiYWN0aW9uc1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC51c2VQbHVnaW4obm8uZGVmYXVsdCksdC51c2VQbHVnaW4ocm8uZGVmYXVsdCksdC51c2VQbHVnaW4odG8uZGVmYXVsdCksdC51c2VQbHVnaW4oZW8uZGVmYXVsdCl9fTtRci5kZWZhdWx0PWlvO3ZhciBhbz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYW8sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksYW8uZGVmYXVsdD12b2lkIDA7YW8uZGVmYXVsdD17fTt2YXIgdW89e307ZnVuY3Rpb24gc28odCl7cmV0dXJuKHNvPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodW8sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdW8uZ2V0Q29udGFpbmVyPWdvLHVvLmdldFNjcm9sbD1ibyx1by5nZXRTY3JvbGxTaXplPWZ1bmN0aW9uKHQpe2ZvLndpbmRvdyh0KSYmKHQ9d2luZG93LmRvY3VtZW50LmJvZHkpO3JldHVybnt4OnQuc2Nyb2xsV2lkdGgseTp0LnNjcm9sbEhlaWdodH19LHVvLmdldFNjcm9sbFNpemVEZWx0YT1mdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LmVsZW1lbnQsbz1uJiZuLmludGVyYWN0YWJsZS5vcHRpb25zW24ucHJlcGFyZWQubmFtZV0uYXV0b1Njcm9sbDtpZighb3x8IW8uZW5hYmxlZClyZXR1cm4gZSgpLHt4OjAseTowfTt2YXIgaT1nbyhvLmNvbnRhaW5lcixuLmludGVyYWN0YWJsZSxyKSxhPWJvKGkpO2UoKTt2YXIgdT1ibyhpKTtyZXR1cm57eDp1LngtYS54LHk6dS55LWEueX19LHVvLmRlZmF1bHQ9dm9pZCAwO3ZhciBsbyxjbz15bygkKSxmbz15byh3KSxwbz0obG89b2UpJiZsby5fX2VzTW9kdWxlP2xvOntkZWZhdWx0OmxvfTtmdW5jdGlvbiB2bygpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIHZvPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24geW8odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09c28odCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9dm8oKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn12YXIgaG89e2RlZmF1bHRzOntlbmFibGVkOiExLG1hcmdpbjo2MCxjb250YWluZXI6bnVsbCxzcGVlZDozMDB9LG5vdzpEYXRlLm5vdyxpbnRlcmFjdGlvbjpudWxsLGk6MCx4OjAseTowLGlzU2Nyb2xsaW5nOiExLHByZXZUaW1lOjAsbWFyZ2luOjAsc3BlZWQ6MCxzdGFydDpmdW5jdGlvbih0KXtoby5pc1Njcm9sbGluZz0hMCxwby5kZWZhdWx0LmNhbmNlbChoby5pKSwodC5hdXRvU2Nyb2xsPWhvKS5pbnRlcmFjdGlvbj10LGhvLnByZXZUaW1lPWhvLm5vdygpLGhvLmk9cG8uZGVmYXVsdC5yZXF1ZXN0KGhvLnNjcm9sbCl9LHN0b3A6ZnVuY3Rpb24oKXtoby5pc1Njcm9sbGluZz0hMSxoby5pbnRlcmFjdGlvbiYmKGhvLmludGVyYWN0aW9uLmF1dG9TY3JvbGw9bnVsbCkscG8uZGVmYXVsdC5jYW5jZWwoaG8uaSl9LHNjcm9sbDpmdW5jdGlvbigpe3ZhciB0PWhvLmludGVyYWN0aW9uLGU9dC5pbnRlcmFjdGFibGUsbj10LmVsZW1lbnQscj10LnByZXBhcmVkLm5hbWUsbz1lLm9wdGlvbnNbcl0uYXV0b1Njcm9sbCxpPWdvKG8uY29udGFpbmVyLGUsbiksYT1oby5ub3coKSx1PShhLWhvLnByZXZUaW1lKS8xZTMscz1vLnNwZWVkKnU7aWYoMTw9cyl7dmFyIGw9e3g6aG8ueCpzLHk6aG8ueSpzfTtpZihsLnh8fGwueSl7dmFyIGM9Ym8oaSk7Zm8ud2luZG93KGkpP2kuc2Nyb2xsQnkobC54LGwueSk6aSYmKGkuc2Nyb2xsTGVmdCs9bC54LGkuc2Nyb2xsVG9wKz1sLnkpO3ZhciBmPWJvKGkpLHA9e3g6Zi54LWMueCx5OmYueS1jLnl9OyhwLnh8fHAueSkmJmUuZmlyZSh7dHlwZTpcImF1dG9zY3JvbGxcIix0YXJnZXQ6bixpbnRlcmFjdGFibGU6ZSxkZWx0YTpwLGludGVyYWN0aW9uOnQsY29udGFpbmVyOml9KX1oby5wcmV2VGltZT1hfWhvLmlzU2Nyb2xsaW5nJiYocG8uZGVmYXVsdC5jYW5jZWwoaG8uaSksaG8uaT1wby5kZWZhdWx0LnJlcXVlc3QoaG8uc2Nyb2xsKSl9LGNoZWNrOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5vcHRpb25zO3JldHVybiBuW2VdLmF1dG9TY3JvbGwmJm5bZV0uYXV0b1Njcm9sbC5lbmFibGVkfSxvbkludGVyYWN0aW9uTW92ZTpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5wb2ludGVyO2lmKGUuaW50ZXJhY3RpbmcoKSYmaG8uY2hlY2soZS5pbnRlcmFjdGFibGUsZS5wcmVwYXJlZC5uYW1lKSlpZihlLnNpbXVsYXRpb24paG8ueD1oby55PTA7ZWxzZXt2YXIgcixvLGksYSx1PWUuaW50ZXJhY3RhYmxlLHM9ZS5lbGVtZW50LGw9ZS5wcmVwYXJlZC5uYW1lLGM9dS5vcHRpb25zW2xdLmF1dG9TY3JvbGwsZj1nbyhjLmNvbnRhaW5lcix1LHMpO2lmKGZvLndpbmRvdyhmKSlhPW4uY2xpZW50WDxoby5tYXJnaW4scj1uLmNsaWVudFk8aG8ubWFyZ2luLG89bi5jbGllbnRYPmYuaW5uZXJXaWR0aC1oby5tYXJnaW4saT1uLmNsaWVudFk+Zi5pbm5lckhlaWdodC1oby5tYXJnaW47ZWxzZXt2YXIgcD1jby5nZXRFbGVtZW50Q2xpZW50UmVjdChmKTthPW4uY2xpZW50WDxwLmxlZnQraG8ubWFyZ2luLHI9bi5jbGllbnRZPHAudG9wK2hvLm1hcmdpbixvPW4uY2xpZW50WD5wLnJpZ2h0LWhvLm1hcmdpbixpPW4uY2xpZW50WT5wLmJvdHRvbS1oby5tYXJnaW59aG8ueD1vPzE6YT8tMTowLGhvLnk9aT8xOnI/LTE6MCxoby5pc1Njcm9sbGluZ3x8KGhvLm1hcmdpbj1jLm1hcmdpbixoby5zcGVlZD1jLnNwZWVkLGhvLnN0YXJ0KGUpKX19fTtmdW5jdGlvbiBnbyh0LGUsbil7cmV0dXJuKGZvLnN0cmluZyh0KT8oMCwkdC5nZXRTdHJpbmdPcHRpb25SZXN1bHQpKHQsZSxuKTp0KXx8KDAsTy5nZXRXaW5kb3cpKG4pfWZ1bmN0aW9uIGJvKHQpe3JldHVybiBmby53aW5kb3codCkmJih0PXdpbmRvdy5kb2N1bWVudC5ib2R5KSx7eDp0LnNjcm9sbExlZnQseTp0LnNjcm9sbFRvcH19dmFyIG1vPXtpZDpcImF1dG8tc2Nyb2xsXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmRlZmF1bHRzLG49dC5hY3Rpb25zOyh0LmF1dG9TY3JvbGw9aG8pLm5vdz1mdW5jdGlvbigpe3JldHVybiB0Lm5vdygpfSxuLnBoYXNlbGVzc1R5cGVzLmF1dG9zY3JvbGw9ITAsZS5wZXJBY3Rpb24uYXV0b1Njcm9sbD1oby5kZWZhdWx0c30sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLmF1dG9TY3JvbGw9bnVsbH0sXCJpbnRlcmFjdGlvbnM6ZGVzdHJveVwiOmZ1bmN0aW9uKHQpe3QuaW50ZXJhY3Rpb24uYXV0b1Njcm9sbD1udWxsLGhvLnN0b3AoKSxoby5pbnRlcmFjdGlvbiYmKGhvLmludGVyYWN0aW9uPW51bGwpfSxcImludGVyYWN0aW9uczpzdG9wXCI6aG8uc3RvcCxcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOmZ1bmN0aW9uKHQpe3JldHVybiBoby5vbkludGVyYWN0aW9uTW92ZSh0KX19fTt1by5kZWZhdWx0PW1vO3ZhciBPbz17fTtmdW5jdGlvbiB3byh0KXtyZXR1cm4od289XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShPbyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPby5kZWZhdWx0PXZvaWQgMDt2YXIgX289ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09d28odCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9UG8oKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0odyk7ZnVuY3Rpb24gUG8oKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBQbz1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIHhvKHQpe3JldHVybiBfby5ib29sKHQpPyh0aGlzLm9wdGlvbnMuc3R5bGVDdXJzb3I9dCx0aGlzKTpudWxsPT09dD8oZGVsZXRlIHRoaXMub3B0aW9ucy5zdHlsZUN1cnNvcix0aGlzKTp0aGlzLm9wdGlvbnMuc3R5bGVDdXJzb3J9ZnVuY3Rpb24gU28odCl7cmV0dXJuIF9vLmZ1bmModCk/KHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyPXQsdGhpcyk6bnVsbD09PXQ/KGRlbGV0ZSB0aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlcix0aGlzKTp0aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlcn12YXIgam89e2lkOlwiYXV0by1zdGFydC9pbnRlcmFjdGFibGVNZXRob2RzXCIsaW5zdGFsbDpmdW5jdGlvbihkKXt2YXIgdD1kLkludGVyYWN0YWJsZTt0LnByb3RvdHlwZS5nZXRBY3Rpb249ZnVuY3Rpb24odCxlLG4scil7dmFyIG8saSxhLHUscyxsLGMsZixwPShpPWUsYT1uLHU9cixzPWQsbD0obz10aGlzKS5nZXRSZWN0KHUpLGM9aS5idXR0b25zfHx7MDoxLDE6NCwzOjgsNDoxNn1baS5idXR0b25dLGY9e2FjdGlvbjpudWxsLGludGVyYWN0YWJsZTpvLGludGVyYWN0aW9uOmEsZWxlbWVudDp1LHJlY3Q6bCxidXR0b25zOmN9LHMuZmlyZShcImF1dG8tc3RhcnQ6Y2hlY2tcIixmKSxmLmFjdGlvbik7cmV0dXJuIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyP3RoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyKHQsZSxwLHRoaXMscixuKTpwfSx0LnByb3RvdHlwZS5pZ25vcmVGcm9tPSgwLGxlLndhcm5PbmNlKShmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYmFja0NvbXBhdE9wdGlvbihcImlnbm9yZUZyb21cIix0KX0sXCJJbnRlcmFjdGFibGUuaWdub3JlRnJvbSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBJbnRlcmFjdGJsZS5kcmFnZ2FibGUoe2lnbm9yZUZyb206IG5ld1ZhbHVlfSkuXCIpLHQucHJvdG90eXBlLmFsbG93RnJvbT0oMCxsZS53YXJuT25jZSkoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2JhY2tDb21wYXRPcHRpb24oXCJhbGxvd0Zyb21cIix0KX0sXCJJbnRlcmFjdGFibGUuYWxsb3dGcm9tKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIEludGVyYWN0YmxlLmRyYWdnYWJsZSh7YWxsb3dGcm9tOiBuZXdWYWx1ZX0pLlwiKSx0LnByb3RvdHlwZS5hY3Rpb25DaGVja2VyPVNvLHQucHJvdG90eXBlLnN0eWxlQ3Vyc29yPXhvfX07T28uZGVmYXVsdD1qbzt2YXIgTW89e307ZnVuY3Rpb24ga28odCl7cmV0dXJuKGtvPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoTW8sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksTW8uZGVmYXVsdD12b2lkIDA7dmFyIEVvLFRvPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWtvKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUlvKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KGxlKSxEbz0oRW89T28pJiZFby5fX2VzTW9kdWxlP0VvOntkZWZhdWx0OkVvfTtmdW5jdGlvbiBJbygpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIElvPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gem8odCxlLG4scixvKXtyZXR1cm4gZS50ZXN0SWdub3JlQWxsb3coZS5vcHRpb25zW3QubmFtZV0sbixyKSYmZS5vcHRpb25zW3QubmFtZV0uZW5hYmxlZCYmUm8oZSxuLHQsbyk/dDpudWxsfWZ1bmN0aW9uIEFvKHQsZSxuLHIsbyxpLGEpe2Zvcih2YXIgdT0wLHM9ci5sZW5ndGg7dTxzO3UrKyl7dmFyIGw9clt1XSxjPW9bdV0sZj1sLmdldEFjdGlvbihlLG4sdCxjKTtpZihmKXt2YXIgcD16byhmLGwsYyxpLGEpO2lmKHApcmV0dXJue2FjdGlvbjpwLGludGVyYWN0YWJsZTpsLGVsZW1lbnQ6Y319fXJldHVybnthY3Rpb246bnVsbCxpbnRlcmFjdGFibGU6bnVsbCxlbGVtZW50Om51bGx9fWZ1bmN0aW9uIENvKHQsZSxuLHIsbyl7dmFyIGk9W10sYT1bXSx1PXI7ZnVuY3Rpb24gcyh0KXtpLnB1c2godCksYS5wdXNoKHUpfWZvcig7VG8uaXMuZWxlbWVudCh1KTspe2k9W10sYT1bXSxvLmludGVyYWN0YWJsZXMuZm9yRWFjaE1hdGNoKHUscyk7dmFyIGw9QW8odCxlLG4saSxhLHIsbyk7aWYobC5hY3Rpb24mJiFsLmludGVyYWN0YWJsZS5vcHRpb25zW2wuYWN0aW9uLm5hbWVdLm1hbnVhbFN0YXJ0KXJldHVybiBsO3U9VG8uZG9tLnBhcmVudE5vZGUodSl9cmV0dXJue2FjdGlvbjpudWxsLGludGVyYWN0YWJsZTpudWxsLGVsZW1lbnQ6bnVsbH19ZnVuY3Rpb24gV28odCxlLG4pe3ZhciByPWUuYWN0aW9uLG89ZS5pbnRlcmFjdGFibGUsaT1lLmVsZW1lbnQ7cj1yfHx7bmFtZTpudWxsfSx0LmludGVyYWN0YWJsZT1vLHQuZWxlbWVudD1pLFRvLmNvcHlBY3Rpb24odC5wcmVwYXJlZCxyKSx0LnJlY3Q9byYmci5uYW1lP28uZ2V0UmVjdChpKTpudWxsLFlvKHQsbiksbi5maXJlKFwiYXV0b1N0YXJ0OnByZXBhcmVkXCIse2ludGVyYWN0aW9uOnR9KX1mdW5jdGlvbiBSbyh0LGUsbixyKXt2YXIgbz10Lm9wdGlvbnMsaT1vW24ubmFtZV0ubWF4LGE9b1tuLm5hbWVdLm1heFBlckVsZW1lbnQsdT1yLmF1dG9TdGFydC5tYXhJbnRlcmFjdGlvbnMscz0wLGw9MCxjPTA7aWYoIShpJiZhJiZ1KSlyZXR1cm4hMTtmb3IodmFyIGY9MDtmPHIuaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO2YrKyl7dmFyIHA9ci5pbnRlcmFjdGlvbnMubGlzdFtmXSxkPXAucHJlcGFyZWQubmFtZTtpZihwLmludGVyYWN0aW5nKCkpe2lmKHU8PSsrcylyZXR1cm4hMTtpZihwLmludGVyYWN0YWJsZT09PXQpe2lmKGk8PShsKz1kPT09bi5uYW1lPzE6MCkpcmV0dXJuITE7aWYocC5lbGVtZW50PT09ZSYmKGMrKyxkPT09bi5uYW1lJiZhPD1jKSlyZXR1cm4hMX19fXJldHVybiAwPHV9ZnVuY3Rpb24gRm8odCxlKXtyZXR1cm4gVG8uaXMubnVtYmVyKHQpPyhlLmF1dG9TdGFydC5tYXhJbnRlcmFjdGlvbnM9dCx0aGlzKTplLmF1dG9TdGFydC5tYXhJbnRlcmFjdGlvbnN9ZnVuY3Rpb24gWG8odCxlLG4pe3ZhciByPW4uYXV0b1N0YXJ0LmN1cnNvckVsZW1lbnQ7ciYmciE9PXQmJihyLnN0eWxlLmN1cnNvcj1cIlwiKSx0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvcj1lLHQuc3R5bGUuY3Vyc29yPWUsbi5hdXRvU3RhcnQuY3Vyc29yRWxlbWVudD1lP3Q6bnVsbH1mdW5jdGlvbiBZbyh0LGUpe3ZhciBuPXQuaW50ZXJhY3RhYmxlLHI9dC5lbGVtZW50LG89dC5wcmVwYXJlZDtpZihcIm1vdXNlXCI9PT10LnBvaW50ZXJUeXBlJiZuJiZuLm9wdGlvbnMuc3R5bGVDdXJzb3Ipe3ZhciBpPVwiXCI7aWYoby5uYW1lKXt2YXIgYT1uLm9wdGlvbnNbby5uYW1lXS5jdXJzb3JDaGVja2VyO2k9VG8uaXMuZnVuYyhhKT9hKG8sbixyLHQuX2ludGVyYWN0aW5nKTplLmFjdGlvbnMubWFwW28ubmFtZV0uZ2V0Q3Vyc29yKG8pfVhvKHQuZWxlbWVudCxpfHxcIlwiLGUpfWVsc2UgZS5hdXRvU3RhcnQuY3Vyc29yRWxlbWVudCYmWG8oZS5hdXRvU3RhcnQuY3Vyc29yRWxlbWVudCxcIlwiLGUpfXZhciBObz17aWQ6XCJhdXRvLXN0YXJ0L2Jhc2VcIixiZWZvcmU6W1wiYWN0aW9uc1wiLFwiYWN0aW9ucy9kcmFnXCIsXCJhY3Rpb25zL3Jlc2l6ZVwiLFwiYWN0aW9ucy9nZXN0dXJlXCJdLGluc3RhbGw6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5pbnRlcmFjdFN0YXRpYyxuPWUuZGVmYXVsdHM7ZS51c2VQbHVnaW4oRG8uZGVmYXVsdCksbi5iYXNlLmFjdGlvbkNoZWNrZXI9bnVsbCxuLmJhc2Uuc3R5bGVDdXJzb3I9ITAsVG8uZXh0ZW5kKG4ucGVyQWN0aW9uLHttYW51YWxTdGFydDohMSxtYXg6MS8wLG1heFBlckVsZW1lbnQ6MSxhbGxvd0Zyb206bnVsbCxpZ25vcmVGcm9tOm51bGwsbW91c2VCdXR0b25zOjF9KSx0Lm1heEludGVyYWN0aW9ucz1mdW5jdGlvbih0KXtyZXR1cm4gRm8odCxlKX0sZS5hdXRvU3RhcnQ9e21heEludGVyYWN0aW9uczoxLzAsd2l0aGluSW50ZXJhY3Rpb25MaW1pdDpSbyxjdXJzb3JFbGVtZW50Om51bGx9fSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOmRvd25cIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsbz10LmV2ZW50LGk9dC5ldmVudFRhcmdldDtuLmludGVyYWN0aW5nKCl8fFdvKG4sQ28obixyLG8saSxlKSxlKX0sXCJpbnRlcmFjdGlvbnM6bW92ZVwiOmZ1bmN0aW9uKHQsZSl7dmFyIG4scixvLGksYSx1O3I9ZSxvPShuPXQpLmludGVyYWN0aW9uLGk9bi5wb2ludGVyLGE9bi5ldmVudCx1PW4uZXZlbnRUYXJnZXQsXCJtb3VzZVwiIT09by5wb2ludGVyVHlwZXx8by5wb2ludGVySXNEb3dufHxvLmludGVyYWN0aW5nKCl8fFdvKG8sQ28obyxpLGEsdSxyKSxyKSxmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb247aWYobi5wb2ludGVySXNEb3duJiYhbi5pbnRlcmFjdGluZygpJiZuLnBvaW50ZXJXYXNNb3ZlZCYmbi5wcmVwYXJlZC5uYW1lKXtlLmZpcmUoXCJhdXRvU3RhcnQ6YmVmb3JlLXN0YXJ0XCIsdCk7dmFyIHI9bi5pbnRlcmFjdGFibGUsbz1uLnByZXBhcmVkLm5hbWU7byYmciYmKHIub3B0aW9uc1tvXS5tYW51YWxTdGFydHx8IVJvKHIsbi5lbGVtZW50LG4ucHJlcGFyZWQsZSk/bi5zdG9wKCk6KG4uc3RhcnQobi5wcmVwYXJlZCxyLG4uZWxlbWVudCksWW8obixlKSkpfX0odCxlKX0sXCJpbnRlcmFjdGlvbnM6c3RvcFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPW4uaW50ZXJhY3RhYmxlO3ImJnIub3B0aW9ucy5zdHlsZUN1cnNvciYmWG8obi5lbGVtZW50LFwiXCIsZSl9fSxtYXhJbnRlcmFjdGlvbnM6Rm8sd2l0aGluSW50ZXJhY3Rpb25MaW1pdDpSbyx2YWxpZGF0ZUFjdGlvbjp6b307TW8uZGVmYXVsdD1Obzt2YXIgTG89e307ZnVuY3Rpb24gQm8odCl7cmV0dXJuKEJvPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoTG8sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksTG8uZGVmYXVsdD12b2lkIDA7dmFyIFZvLHFvPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PUJvKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUdvKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHcpLFVvPShWbz1NbykmJlZvLl9fZXNNb2R1bGU/Vm86e2RlZmF1bHQ6Vm99O2Z1bmN0aW9uIEdvKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gR289ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH12YXIgSG89e2lkOlwiYXV0by1zdGFydC9kcmFnQXhpc1wiLGxpc3RlbmVyczp7XCJhdXRvU3RhcnQ6YmVmb3JlLXN0YXJ0XCI6ZnVuY3Rpb24odCxyKXt2YXIgbz10LmludGVyYWN0aW9uLGk9dC5ldmVudFRhcmdldCxlPXQuZHgsbj10LmR5O2lmKFwiZHJhZ1wiPT09by5wcmVwYXJlZC5uYW1lKXt2YXIgYT1NYXRoLmFicyhlKSx1PU1hdGguYWJzKG4pLHM9by5pbnRlcmFjdGFibGUub3B0aW9ucy5kcmFnLGw9cy5zdGFydEF4aXMsYz11PGE/XCJ4XCI6YTx1P1wieVwiOlwieHlcIjtpZihvLnByZXBhcmVkLmF4aXM9XCJzdGFydFwiPT09cy5sb2NrQXhpcz9jWzBdOnMubG9ja0F4aXMsXCJ4eVwiIT1jJiZcInh5XCIhPT1sJiZsIT09Yyl7by5wcmVwYXJlZC5uYW1lPW51bGw7ZnVuY3Rpb24gZih0KXtpZih0IT09by5pbnRlcmFjdGFibGUpe3ZhciBlPW8uaW50ZXJhY3RhYmxlLm9wdGlvbnMuZHJhZztpZighZS5tYW51YWxTdGFydCYmdC50ZXN0SWdub3JlQWxsb3coZSxwLGkpKXt2YXIgbj10LmdldEFjdGlvbihvLmRvd25Qb2ludGVyLG8uZG93bkV2ZW50LG8scCk7aWYobiYmXCJkcmFnXCI9PT1uLm5hbWUmJmZ1bmN0aW9uKHQsZSl7aWYoIWUpcmV0dXJuO3ZhciBuPWUub3B0aW9ucy5kcmFnLnN0YXJ0QXhpcztyZXR1cm5cInh5XCI9PT10fHxcInh5XCI9PT1ufHxuPT09dH0oYyx0KSYmVW8uZGVmYXVsdC52YWxpZGF0ZUFjdGlvbihuLHQscCxpLHIpKXJldHVybiB0fX19Zm9yKHZhciBwPWk7cW8uZWxlbWVudChwKTspe3ZhciBkPXIuaW50ZXJhY3RhYmxlcy5mb3JFYWNoTWF0Y2gocCxmKTtpZihkKXtvLnByZXBhcmVkLm5hbWU9XCJkcmFnXCIsby5pbnRlcmFjdGFibGU9ZCxvLmVsZW1lbnQ9cDticmVha31wPSgwLCQucGFyZW50Tm9kZSkocCl9fX19fX07TG8uZGVmYXVsdD1Ibzt2YXIgS289e307T2JqZWN0LmRlZmluZVByb3BlcnR5KEtvLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEtvLmRlZmF1bHQ9dm9pZCAwO3ZhciAkbyxabz0oJG89TW8pJiYkby5fX2VzTW9kdWxlPyRvOntkZWZhdWx0OiRvfTtmdW5jdGlvbiBKbyh0KXt2YXIgZT10LnByZXBhcmVkJiZ0LnByZXBhcmVkLm5hbWU7aWYoIWUpcmV0dXJuIG51bGw7dmFyIG49dC5pbnRlcmFjdGFibGUub3B0aW9ucztyZXR1cm4gbltlXS5ob2xkfHxuW2VdLmRlbGF5fXZhciBRbz17aWQ6XCJhdXRvLXN0YXJ0L2hvbGRcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZGVmYXVsdHM7dC51c2VQbHVnaW4oWm8uZGVmYXVsdCksZS5wZXJBY3Rpb24uaG9sZD0wLGUucGVyQWN0aW9uLmRlbGF5PTB9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5hdXRvU3RhcnRIb2xkVGltZXI9bnVsbH0sXCJhdXRvU3RhcnQ6cHJlcGFyZWRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49Sm8oZSk7MDxuJiYoZS5hdXRvU3RhcnRIb2xkVGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe2Uuc3RhcnQoZS5wcmVwYXJlZCxlLmludGVyYWN0YWJsZSxlLmVsZW1lbnQpfSxuKSl9LFwiaW50ZXJhY3Rpb25zOm1vdmVcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5kdXBsaWNhdGU7ZS5wb2ludGVyV2FzTW92ZWQmJiFuJiZjbGVhclRpbWVvdXQoZS5hdXRvU3RhcnRIb2xkVGltZXIpfSxcImF1dG9TdGFydDpiZWZvcmUtc3RhcnRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uOzA8Sm8oZSkmJihlLnByZXBhcmVkLm5hbWU9bnVsbCl9fSxnZXRIb2xkRHVyYXRpb246Sm99O0tvLmRlZmF1bHQ9UW87dmFyIHRpPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGksXCJhdXRvU3RhcnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZWkuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGksXCJkcmFnQXhpc1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuaS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aSxcImhvbGRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcmkuZGVmYXVsdH19KSx0aS5kZWZhdWx0PXZvaWQgMDt2YXIgZWk9b2koTW8pLG5pPW9pKExvKSxyaT1vaShLbyk7ZnVuY3Rpb24gb2kodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fXZhciBpaT17aWQ6XCJhdXRvLXN0YXJ0XCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LnVzZVBsdWdpbihlaS5kZWZhdWx0KSx0LnVzZVBsdWdpbihyaS5kZWZhdWx0KSx0LnVzZVBsdWdpbihuaS5kZWZhdWx0KX19O3RpLmRlZmF1bHQ9aWk7dmFyIGFpPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShhaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxhaS5kZWZhdWx0PXZvaWQgMDthaS5kZWZhdWx0PXt9O3ZhciB1aT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodWksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdWkuZGVmYXVsdD12b2lkIDA7dWkuZGVmYXVsdD17fTt2YXIgc2k9e307ZnVuY3Rpb24gbGkodCl7cmV0dXJuKGxpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoc2ksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksc2kuZGVmYXVsdD12b2lkIDA7dmFyIGNpLGZpLHBpPWhpKEQpLGRpPShoaShjdCksZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09bGkodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9eWkoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0odykpLHZpPWhpKE8pO2Z1bmN0aW9uIHlpKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4geWk9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBoaSh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19KGZpPWNpPWNpfHx7fSkudG91Y2hBY3Rpb249XCJ0b3VjaEFjdGlvblwiLGZpLmJveFNpemluZz1cImJveFNpemluZ1wiLGZpLm5vTGlzdGVuZXJzPVwibm9MaXN0ZW5lcnNcIjt2YXIgZ2k9e3RvdWNoQWN0aW9uOlwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RvdWNoLWFjdGlvblwiLGJveFNpemluZzpcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9ib3gtc2l6aW5nXCJ9O2NpLnRvdWNoQWN0aW9uLGNpLmJveFNpemluZyxjaS5ub0xpc3RlbmVycztmdW5jdGlvbiBiaSh0LGUsbil7cmV0dXJuIG4udGVzdCh0LnN0eWxlW2VdfHx2aS5kZWZhdWx0LndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpW2VdKX12YXIgbWk9XCJkZXYtdG9vbHNcIixPaT17aWQ6bWksaW5zdGFsbDpmdW5jdGlvbigpe319O3NpLmRlZmF1bHQ9T2k7dmFyIHdpPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx3aS5kZWZhdWx0PXZvaWQgMDt3aS5kZWZhdWx0PXt9O3ZhciBfaT17fTtmdW5jdGlvbiBQaSh0KXtyZXR1cm4oUGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShfaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxfaS5nZXRSZWN0T2Zmc2V0PUFpLF9pLmRlZmF1bHQ9dm9pZCAwO3ZhciB4aT1raShWKSxTaT1raShjdCksamk9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09UGkodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9TWkoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oJHQpO2Z1bmN0aW9uIE1pKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gTWk9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBraSh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gRWkodCxlKXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKSlyZXR1cm47dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEsdT10W1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO3I9ITApO31jYXRjaCh0KXtvPSEwLGk9dH1maW5hbGx5e3RyeXtyfHxudWxsPT11LnJldHVybnx8dS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgaX19cmV0dXJuIG59KHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9ZnVuY3Rpb24gVGkodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIERpKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgSWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpeyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5pbnRlcmFjdGlvbj10LERpKHRoaXMsXCJzdGF0ZXNcIixbXSksRGkodGhpcyxcInN0YXJ0T2Zmc2V0XCIse2xlZnQ6MCxyaWdodDowLHRvcDowLGJvdHRvbTowfSksRGkodGhpcyxcInN0YXJ0RGVsdGFcIixudWxsKSxEaSh0aGlzLFwicmVzdWx0XCIsbnVsbCksRGkodGhpcyxcImVuZFJlc3VsdFwiLG51bGwpLERpKHRoaXMsXCJlZGdlc1wiLHZvaWQgMCksdGhpcy5yZXN1bHQ9emkoKX12YXIgdCxuLHI7cmV0dXJuIHQ9ZSwobj1be2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnBoYXNlLHI9dGhpcy5pbnRlcmFjdGlvbixvPWZ1bmN0aW9uKHQpe3ZhciBuPXQuaW50ZXJhY3RhYmxlLm9wdGlvbnNbdC5wcmVwYXJlZC5uYW1lXSxlPW4ubW9kaWZpZXJzO2lmKGUmJmUubGVuZ3RoKXJldHVybiBlLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hdC5vcHRpb25zfHwhMSE9PXQub3B0aW9ucy5lbmFibGVkfSk7cmV0dXJuW1wic25hcFwiLFwic25hcFNpemVcIixcInNuYXBFZGdlc1wiLFwicmVzdHJpY3RcIixcInJlc3RyaWN0RWRnZXNcIixcInJlc3RyaWN0U2l6ZVwiXS5tYXAoZnVuY3Rpb24odCl7dmFyIGU9blt0XTtyZXR1cm4gZSYmZS5lbmFibGVkJiZ7b3B0aW9uczplLG1ldGhvZHM6ZS5fbWV0aG9kc319KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuISF0fSl9KHIpO3RoaXMucHJlcGFyZVN0YXRlcyhvKSx0aGlzLmVkZ2VzPSgwLFNpLmRlZmF1bHQpKHt9LHIuZWRnZXMpLHRoaXMuc3RhcnRPZmZzZXQ9QWkoci5yZWN0LGUpO3ZhciBpPXtwaGFzZTpuLHBhZ2VDb29yZHM6ZSxwcmVFbmQ6ISh0aGlzLnN0YXJ0RGVsdGE9e3g6MCx5OjB9KX07cmV0dXJuIHRoaXMucmVzdWx0PXppKCksdGhpcy5zdGFydEFsbChpKSx0aGlzLnJlc3VsdD10aGlzLnNldEFsbChpKX19LHtrZXk6XCJmaWxsQXJnXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pbnRlcmFjdGlvbjt0LmludGVyYWN0aW9uPWUsdC5pbnRlcmFjdGFibGU9ZS5pbnRlcmFjdGFibGUsdC5lbGVtZW50PWUuZWxlbWVudCx0LnJlY3Q9dC5yZWN0fHxlLnJlY3QsdC5lZGdlcz10aGlzLmVkZ2VzLHQuc3RhcnRPZmZzZXQ9dGhpcy5zdGFydE9mZnNldH19LHtrZXk6XCJzdGFydEFsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuZmlsbEFyZyh0KTtmb3IodmFyIGU9MDtlPHRoaXMuc3RhdGVzLmxlbmd0aDtlKyspe3ZhciBuPXRoaXMuc3RhdGVzW2VdO24ubWV0aG9kcy5zdGFydCYmKHQuc3RhdGU9bikubWV0aG9kcy5zdGFydCh0KX19fSx7a2V5Olwic2V0QWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5maWxsQXJnKHQpO3ZhciBlPXQucGhhc2Usbj10LnByZUVuZCxyPXQuc2tpcE1vZGlmaWVycyxvPXQucmVjdDt0LmNvb3Jkcz0oMCxTaS5kZWZhdWx0KSh7fSx0LnBhZ2VDb29yZHMpLHQucmVjdD0oMCxTaS5kZWZhdWx0KSh7fSxvKTtmb3IodmFyIGk9cj90aGlzLnN0YXRlcy5zbGljZShyKTp0aGlzLnN0YXRlcyxhPXppKHQuY29vcmRzLHQucmVjdCksdT0wO3U8aS5sZW5ndGg7dSsrKXt2YXIgcz1pW3VdLGw9cy5vcHRpb25zLGM9KDAsU2kuZGVmYXVsdCkoe30sdC5jb29yZHMpLGY9bnVsbDtzLm1ldGhvZHMuc2V0JiZ0aGlzLnNob3VsZERvKGwsbixlKSYmKGY9KHQuc3RhdGU9cykubWV0aG9kcy5zZXQodCksamkuYWRkRWRnZXModGhpcy5pbnRlcmFjdGlvbi5lZGdlcyx0LnJlY3Qse3g6dC5jb29yZHMueC1jLngseTp0LmNvb3Jkcy55LWMueX0pKSxhLmV2ZW50UHJvcHMucHVzaChmKX1hLmRlbHRhLng9dC5jb29yZHMueC10LnBhZ2VDb29yZHMueCxhLmRlbHRhLnk9dC5jb29yZHMueS10LnBhZ2VDb29yZHMueSxhLnJlY3REZWx0YS5sZWZ0PXQucmVjdC5sZWZ0LW8ubGVmdCxhLnJlY3REZWx0YS5yaWdodD10LnJlY3QucmlnaHQtby5yaWdodCxhLnJlY3REZWx0YS50b3A9dC5yZWN0LnRvcC1vLnRvcCxhLnJlY3REZWx0YS5ib3R0b209dC5yZWN0LmJvdHRvbS1vLmJvdHRvbTt2YXIgcD10aGlzLnJlc3VsdC5jb29yZHMsZD10aGlzLnJlc3VsdC5yZWN0O2lmKHAmJmQpe3ZhciB2PWEucmVjdC5sZWZ0IT09ZC5sZWZ0fHxhLnJlY3QucmlnaHQhPT1kLnJpZ2h0fHxhLnJlY3QudG9wIT09ZC50b3B8fGEucmVjdC5ib3R0b20hPT1kLmJvdHRvbTthLmNoYW5nZWQ9dnx8cC54IT09YS5jb29yZHMueHx8cC55IT09YS5jb29yZHMueX1yZXR1cm4gYX19LHtrZXk6XCJhcHBseVRvSW50ZXJhY3Rpb25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyYWN0aW9uLG49dC5waGFzZSxyPWUuY29vcmRzLmN1cixvPWUuY29vcmRzLnN0YXJ0LGk9dGhpcy5yZXN1bHQsYT10aGlzLnN0YXJ0RGVsdGEsdT1pLmRlbHRhO1wic3RhcnRcIj09PW4mJigwLFNpLmRlZmF1bHQpKHRoaXMuc3RhcnREZWx0YSxpLmRlbHRhKTtmb3IodmFyIHM9MDtzPFtbbyxhXSxbcix1XV0ubGVuZ3RoO3MrKyl7dmFyIGw9RWkoW1tvLGFdLFtyLHVdXVtzXSwyKSxjPWxbMF0sZj1sWzFdO2MucGFnZS54Kz1mLngsYy5wYWdlLnkrPWYueSxjLmNsaWVudC54Kz1mLngsYy5jbGllbnQueSs9Zi55fXZhciBwPXRoaXMucmVzdWx0LnJlY3REZWx0YSxkPXQucmVjdHx8ZS5yZWN0O2QubGVmdCs9cC5sZWZ0LGQucmlnaHQrPXAucmlnaHQsZC50b3ArPXAudG9wLGQuYm90dG9tKz1wLmJvdHRvbSxkLndpZHRoPWQucmlnaHQtZC5sZWZ0LGQuaGVpZ2h0PWQuYm90dG9tLWQudG9wfX0se2tleTpcInNldEFuZEFwcGx5XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pbnRlcmFjdGlvbixuPXQucGhhc2Uscj10LnByZUVuZCxvPXQuc2tpcE1vZGlmaWVycyxpPXRoaXMuc2V0QWxsKHtwcmVFbmQ6cixwaGFzZTpuLHBhZ2VDb29yZHM6dC5tb2RpZmllZENvb3Jkc3x8ZS5jb29yZHMuY3VyLnBhZ2V9KTtpZighKHRoaXMucmVzdWx0PWkpLmNoYW5nZWQmJighb3x8bzx0aGlzLnN0YXRlcy5sZW5ndGgpJiZlLmludGVyYWN0aW5nKCkpcmV0dXJuITE7aWYodC5tb2RpZmllZENvb3Jkcyl7dmFyIGE9ZS5jb29yZHMuY3VyLnBhZ2UsdT10Lm1vZGlmaWVkQ29vcmRzLngtYS54LHM9dC5tb2RpZmllZENvb3Jkcy55LWEueTtpLmNvb3Jkcy54Kz11LGkuY29vcmRzLnkrPXMsaS5kZWx0YS54Kz11LGkuZGVsdGEueSs9c310aGlzLmFwcGx5VG9JbnRlcmFjdGlvbih0KX19LHtrZXk6XCJiZWZvcmVFbmRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5ldmVudCxyPXRoaXMuc3RhdGVzO2lmKHImJnIubGVuZ3RoKXtmb3IodmFyIG89ITEsaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgYT1yW2ldLHU9KHQuc3RhdGU9YSkub3B0aW9ucyxzPWEubWV0aG9kcyxsPXMuYmVmb3JlRW5kJiZzLmJlZm9yZUVuZCh0KTtpZihsKXJldHVybiB0aGlzLmVuZFJlc3VsdD1sLCExO289b3x8IW8mJnRoaXMuc2hvdWxkRG8odSwhMCx0LnBoYXNlLCEwKX1vJiZlLm1vdmUoe2V2ZW50Om4scHJlRW5kOiEwfSl9fX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2lmKHRoaXMuc3RhdGVzJiZ0aGlzLnN0YXRlcy5sZW5ndGgpe3ZhciBuPSgwLFNpLmRlZmF1bHQpKHtzdGF0ZXM6dGhpcy5zdGF0ZXMsaW50ZXJhY3RhYmxlOmUuaW50ZXJhY3RhYmxlLGVsZW1lbnQ6ZS5lbGVtZW50LHJlY3Q6bnVsbH0sdCk7dGhpcy5maWxsQXJnKG4pO2Zvcih2YXIgcj0wO3I8dGhpcy5zdGF0ZXMubGVuZ3RoO3IrKyl7dmFyIG89dGhpcy5zdGF0ZXNbcl07KG4uc3RhdGU9bykubWV0aG9kcy5zdG9wJiZvLm1ldGhvZHMuc3RvcChuKX10aGlzLnN0YXRlcz1udWxsLHRoaXMuZW5kUmVzdWx0PW51bGx9fX0se2tleTpcInByZXBhcmVTdGF0ZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnN0YXRlcz1bXTtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIG49dFtlXSxyPW4ub3B0aW9ucyxvPW4ubWV0aG9kcyxpPW4ubmFtZTtyJiYhMT09PXIuZW5hYmxlZHx8dGhpcy5zdGF0ZXMucHVzaCh7b3B0aW9uczpyLG1ldGhvZHM6byxpbmRleDplLG5hbWU6aX0pfXJldHVybiB0aGlzLnN0YXRlc319LHtrZXk6XCJyZXN0b3JlSW50ZXJhY3Rpb25Db29yZHNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49ZS5jb29yZHMscj1lLnJlY3Qsbz1lLm1vZGlmaWNhdGlvbjtpZihvLnJlc3VsdCl7Zm9yKHZhciBpPW8uc3RhcnREZWx0YSxhPW8ucmVzdWx0LHU9YS5kZWx0YSxzPWEucmVjdERlbHRhLGw9W1tuLnN0YXJ0LGldLFtuLmN1cix1XV0sYz0wO2M8bC5sZW5ndGg7YysrKXt2YXIgZj1FaShsW2NdLDIpLHA9ZlswXSxkPWZbMV07cC5wYWdlLngtPWQueCxwLnBhZ2UueS09ZC55LHAuY2xpZW50LngtPWQueCxwLmNsaWVudC55LT1kLnl9ci5sZWZ0LT1zLmxlZnQsci5yaWdodC09cy5yaWdodCxyLnRvcC09cy50b3Asci5ib3R0b20tPXMuYm90dG9tfX19LHtrZXk6XCJzaG91bGREb1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiEoIXR8fCExPT09dC5lbmFibGVkfHxyJiYhdC5lbmRPbmx5fHx0LmVuZE9ubHkmJiFlfHxcInN0YXJ0XCI9PT1uJiYhdC5zZXRTdGFydCl9fSx7a2V5OlwiY29weUZyb21cIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnN0YXJ0T2Zmc2V0PXQuc3RhcnRPZmZzZXQsdGhpcy5zdGFydERlbHRhPXQuc3RhcnREZWx0YSx0aGlzLmVkZ2VzPXQuZWRnZXMsdGhpcy5zdGF0ZXM9dC5zdGF0ZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybigwLHhpLmRlZmF1bHQpKHQpfSksdGhpcy5yZXN1bHQ9emkoKDAsU2kuZGVmYXVsdCkoe30sdC5yZXN1bHQuY29vcmRzKSwoMCxTaS5kZWZhdWx0KSh7fSx0LnJlc3VsdC5yZWN0KSl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMpdGhpc1t0XT1udWxsfX1dKSYmVGkodC5wcm90b3R5cGUsbiksciYmVGkodCxyKSxlfSgpO2Z1bmN0aW9uIHppKHQsZSl7cmV0dXJue3JlY3Q6ZSxjb29yZHM6dCxkZWx0YTp7eDowLHk6MH0scmVjdERlbHRhOntsZWZ0OjAscmlnaHQ6MCx0b3A6MCxib3R0b206MH0sZXZlbnRQcm9wczpbXSxjaGFuZ2VkOiEwfX1mdW5jdGlvbiBBaSh0LGUpe3JldHVybiB0P3tsZWZ0OmUueC10LmxlZnQsdG9wOmUueS10LnRvcCxyaWdodDp0LnJpZ2h0LWUueCxib3R0b206dC5ib3R0b20tZS55fTp7bGVmdDowLHRvcDowLHJpZ2h0OjAsYm90dG9tOjB9fV9pLmRlZmF1bHQ9SWk7dmFyIENpPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShDaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxDaS5tYWtlTW9kaWZpZXI9ZnVuY3Rpb24odCxyKXtmdW5jdGlvbiBlKHQpe3ZhciBlPXR8fHt9O2Zvcih2YXIgbiBpbiBlLmVuYWJsZWQ9ITEhPT1lLmVuYWJsZWQsbyluIGluIGV8fChlW25dPW9bbl0pO3JldHVybntvcHRpb25zOmUsbWV0aG9kczppLG5hbWU6cn19dmFyIG89dC5kZWZhdWx0cyxpPXtzdGFydDp0LnN0YXJ0LHNldDp0LnNldCxiZWZvcmVFbmQ6dC5iZWZvcmVFbmQsc3RvcDp0LnN0b3B9O3ImJlwic3RyaW5nXCI9PXR5cGVvZiByJiYoZS5fZGVmYXVsdHM9byxlLl9tZXRob2RzPWkpO3JldHVybiBlfSxDaS5hZGRFdmVudE1vZGlmaWVycz1GaSxDaS5kZWZhdWx0PXZvaWQgMDt2YXIgV2ksUmk9KFdpPV9pKSYmV2kuX19lc01vZHVsZT9XaTp7ZGVmYXVsdDpXaX07ZnVuY3Rpb24gRmkodCl7dmFyIGU9dC5pRXZlbnQsbj10LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5yZXN1bHQ7biYmKGUubW9kaWZpZXJzPW4uZXZlbnRQcm9wcyl9dmFyIFhpPXtpZDpcIm1vZGlmaWVycy9iYXNlXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LmRlZmF1bHRzLnBlckFjdGlvbi5tb2RpZmllcnM9W119LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtlLm1vZGlmaWNhdGlvbj1uZXcgUmkuZGVmYXVsdChlKX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1zdGFydFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uO2Uuc3RhcnQodCx0LmludGVyYWN0aW9uLmNvb3Jkcy5zdGFydC5wYWdlKSx0LmludGVyYWN0aW9uLmVkZ2VzPWUuZWRnZXMsZS5hcHBseVRvSW50ZXJhY3Rpb24odCl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tbW92ZVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5zZXRBbmRBcHBseSh0KX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1lbmRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24uYmVmb3JlRW5kKHQpfSxcImludGVyYWN0aW9uczphY3Rpb24tc3RhcnRcIjpGaSxcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOkZpLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1lbmRcIjpGaSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tc3RhcnRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdG9yZUludGVyYWN0aW9uQ29vcmRzKHQpfSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tbW92ZVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5yZXN0b3JlSW50ZXJhY3Rpb25Db29yZHModCl9LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24uc3RvcCh0KX19LGJlZm9yZTpbXCJhY3Rpb25zXCIsXCJhY3Rpb24vZHJhZ1wiLFwiYWN0aW9ucy9yZXNpemVcIixcImFjdGlvbnMvZ2VzdHVyZVwiXX07Q2kuZGVmYXVsdD1YaTt2YXIgWWk9e307ZnVuY3Rpb24gTmkodCl7cmV0dXJuKE5pPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoWWksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksWWkuYWRkVG90YWw9VmksWWkuYXBwbHlQZW5kaW5nPVVpLFlpLmRlZmF1bHQ9dm9pZCAwO3ZhciBMaT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1OaSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1CaSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSgkdCk7ZnVuY3Rpb24gQmkoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBCaT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIFZpKHQpe3QucG9pbnRlcklzRG93biYmKEhpKHQuY29vcmRzLmN1cix0Lm9mZnNldC50b3RhbCksdC5vZmZzZXQucGVuZGluZy54PTAsdC5vZmZzZXQucGVuZGluZy55PTApfWZ1bmN0aW9uIHFpKHQpe1VpKHQuaW50ZXJhY3Rpb24pfWZ1bmN0aW9uIFVpKHQpe2lmKCEoZT10KS5vZmZzZXQucGVuZGluZy54JiYhZS5vZmZzZXQucGVuZGluZy55KXJldHVybiExO3ZhciBlLG49dC5vZmZzZXQucGVuZGluZztyZXR1cm4gSGkodC5jb29yZHMuY3VyLG4pLEhpKHQuY29vcmRzLmRlbHRhLG4pLExpLmFkZEVkZ2VzKHQuZWRnZXMsdC5yZWN0LG4pLG4ueD0wLCEobi55PTApfWZ1bmN0aW9uIEdpKHQpe3ZhciBlPXQueCxuPXQueTt0aGlzLm9mZnNldC5wZW5kaW5nLngrPWUsdGhpcy5vZmZzZXQucGVuZGluZy55Kz1uLHRoaXMub2Zmc2V0LnRvdGFsLngrPWUsdGhpcy5vZmZzZXQudG90YWwueSs9bn1mdW5jdGlvbiBIaSh0LGUpe3ZhciBuPXQucGFnZSxyPXQuY2xpZW50LG89ZS54LGk9ZS55O24ueCs9byxuLnkrPWksci54Kz1vLHIueSs9aX1Fbi5fUHJveHlNZXRob2RzLm9mZnNldEJ5PVwiXCI7dmFyIEtpPXtpZDpcIm9mZnNldFwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC5JbnRlcmFjdGlvbi5wcm90b3R5cGUub2Zmc2V0Qnk9R2l9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5vZmZzZXQ9e3RvdGFsOnt4OjAseTowfSxwZW5kaW5nOnt4OjAseTowfX19LFwiaW50ZXJhY3Rpb25zOnVwZGF0ZS1wb2ludGVyXCI6ZnVuY3Rpb24odCl7cmV0dXJuIFZpKHQuaW50ZXJhY3Rpb24pfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLXN0YXJ0XCI6cWksXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1tb3ZlXCI6cWksXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1lbmRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2lmKFVpKGUpKXJldHVybiBlLm1vdmUoe29mZnNldDohMH0pLGUuZW5kKCksITF9LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2Uub2Zmc2V0LnRvdGFsLng9MCxlLm9mZnNldC50b3RhbC55PTAsZS5vZmZzZXQucGVuZGluZy54PTAsZS5vZmZzZXQucGVuZGluZy55PTB9fX07WWkuZGVmYXVsdD1LaTt2YXIgJGk9e307ZnVuY3Rpb24gWmkodCl7cmV0dXJuKFppPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoJGksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksJGkuZGVmYXVsdD0kaS5JbmVydGlhU3RhdGU9dm9pZCAwO3ZhciBKaT11YShfaSksUWk9YWEoQ2kpLHRhPXVhKFlpKSxlYT1hYSgkKSxuYT11YShFdCkscmE9YWEodyksb2E9dWEob2UpO2Z1bmN0aW9uIGlhKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gaWE9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBhYSh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1aaSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1pYSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufWZ1bmN0aW9uIHVhKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBzYSh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gbGEodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBjYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0aGlzLmludGVyYWN0aW9uPXQsbGEodGhpcyxcImFjdGl2ZVwiLCExKSxsYSh0aGlzLFwiaXNNb2RpZmllZFwiLCExKSxsYSh0aGlzLFwic21vb3RoRW5kXCIsITEpLGxhKHRoaXMsXCJhbGxvd1Jlc3VtZVwiLCExKSxsYSh0aGlzLFwibW9kaWZpY2F0aW9uXCIsbnVsbCksbGEodGhpcyxcIm1vZGlmaWVyQ291bnRcIiwwKSxsYSh0aGlzLFwibW9kaWZpZXJBcmdcIixudWxsKSxsYSh0aGlzLFwic3RhcnRDb29yZHNcIixudWxsKSxsYSh0aGlzLFwidDBcIiwwKSxsYSh0aGlzLFwidjBcIiwwKSxsYSh0aGlzLFwidGVcIiwwKSxsYSh0aGlzLFwidGFyZ2V0T2Zmc2V0XCIsbnVsbCksbGEodGhpcyxcIm1vZGlmaWVkT2Zmc2V0XCIsbnVsbCksbGEodGhpcyxcImN1cnJlbnRPZmZzZXRcIixudWxsKSxsYSh0aGlzLFwibGFtYmRhX3YwXCIsMCksbGEodGhpcyxcIm9uZV92ZV92MFwiLDApLGxhKHRoaXMsXCJ0aW1lb3V0XCIsbnVsbCl9dmFyIHQsbixyO3JldHVybiB0PWUsKG49W3trZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaW50ZXJhY3Rpb24sbj1mYShlKTtpZighbnx8IW4uZW5hYmxlZClyZXR1cm4hMTt2YXIgcj1lLmNvb3Jkcy52ZWxvY2l0eS5jbGllbnQsbz0oMCxuYS5kZWZhdWx0KShyLngsci55KSxpPXRoaXMubW9kaWZpY2F0aW9ufHwodGhpcy5tb2RpZmljYXRpb249bmV3IEppLmRlZmF1bHQoZSkpO2lmKGkuY29weUZyb20oZS5tb2RpZmljYXRpb24pLHRoaXMudDA9ZS5fbm93KCksdGhpcy5hbGxvd1Jlc3VtZT1uLmFsbG93UmVzdW1lLHRoaXMudjA9byx0aGlzLmN1cnJlbnRPZmZzZXQ9e3g6MCx5OjB9LHRoaXMuc3RhcnRDb29yZHM9ZS5jb29yZHMuY3VyLnBhZ2UsdGhpcy5tb2RpZmllckFyZz17aW50ZXJhY3Rpb246ZSxpbnRlcmFjdGFibGU6ZS5pbnRlcmFjdGFibGUsZWxlbWVudDplLmVsZW1lbnQscmVjdDplLnJlY3QsZWRnZXM6ZS5lZGdlcyxwYWdlQ29vcmRzOnRoaXMuc3RhcnRDb29yZHMscHJlRW5kOiEwLHBoYXNlOlwiaW5lcnRpYXN0YXJ0XCJ9LHRoaXMudDAtZS5jb29yZHMuY3VyLnRpbWVTdGFtcDw1MCYmbz5uLm1pblNwZWVkJiZvPm4uZW5kU3BlZWQpdGhpcy5zdGFydEluZXJ0aWEoKTtlbHNle2lmKGkucmVzdWx0PWkuc2V0QWxsKHRoaXMubW9kaWZpZXJBcmcpLCFpLnJlc3VsdC5jaGFuZ2VkKXJldHVybiExO3RoaXMuc3RhcnRTbW9vdGhFbmQoKX1yZXR1cm4gZS5tb2RpZmljYXRpb24ucmVzdWx0LnJlY3Q9bnVsbCxlLm9mZnNldEJ5KHRoaXMudGFyZ2V0T2Zmc2V0KSxlLl9kb1BoYXNlKHtpbnRlcmFjdGlvbjplLGV2ZW50OnQscGhhc2U6XCJpbmVydGlhc3RhcnRcIn0pLGUub2Zmc2V0Qnkoe3g6LXRoaXMudGFyZ2V0T2Zmc2V0LngseTotdGhpcy50YXJnZXRPZmZzZXQueX0pLGUubW9kaWZpY2F0aW9uLnJlc3VsdC5yZWN0PW51bGwsdGhpcy5hY3RpdmU9ITAsZS5zaW11bGF0aW9uPXRoaXMsITB9fSx7a2V5Olwic3RhcnRJbmVydGlhXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5pbnRlcmFjdGlvbi5jb29yZHMudmVsb2NpdHkuY2xpZW50LG49ZmEodGhpcy5pbnRlcmFjdGlvbikscj1uLnJlc2lzdGFuY2Usbz0tTWF0aC5sb2cobi5lbmRTcGVlZC90aGlzLnYwKS9yO3RoaXMudGFyZ2V0T2Zmc2V0PXt4OihlLngtbykvcix5OihlLnktbykvcn0sdGhpcy50ZT1vLHRoaXMubGFtYmRhX3YwPXIvdGhpcy52MCx0aGlzLm9uZV92ZV92MD0xLW4uZW5kU3BlZWQvdGhpcy52MDt2YXIgaT10aGlzLm1vZGlmaWNhdGlvbixhPXRoaXMubW9kaWZpZXJBcmc7YS5wYWdlQ29vcmRzPXt4OnRoaXMuc3RhcnRDb29yZHMueCt0aGlzLnRhcmdldE9mZnNldC54LHk6dGhpcy5zdGFydENvb3Jkcy55K3RoaXMudGFyZ2V0T2Zmc2V0Lnl9LGkucmVzdWx0PWkuc2V0QWxsKGEpLGkucmVzdWx0LmNoYW5nZWQmJih0aGlzLmlzTW9kaWZpZWQ9ITAsdGhpcy5tb2RpZmllZE9mZnNldD17eDp0aGlzLnRhcmdldE9mZnNldC54K2kucmVzdWx0LmRlbHRhLngseTp0aGlzLnRhcmdldE9mZnNldC55K2kucmVzdWx0LmRlbHRhLnl9KSx0aGlzLnRpbWVvdXQ9b2EuZGVmYXVsdC5yZXF1ZXN0KGZ1bmN0aW9uKCl7cmV0dXJuIHQuaW5lcnRpYVRpY2soKX0pfX0se2tleTpcInN0YXJ0U21vb3RoRW5kXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuc21vb3RoRW5kPSEwLHRoaXMuaXNNb2RpZmllZD0hMCx0aGlzLnRhcmdldE9mZnNldD17eDp0aGlzLm1vZGlmaWNhdGlvbi5yZXN1bHQuZGVsdGEueCx5OnRoaXMubW9kaWZpY2F0aW9uLnJlc3VsdC5kZWx0YS55fSx0aGlzLnRpbWVvdXQ9b2EuZGVmYXVsdC5yZXF1ZXN0KGZ1bmN0aW9uKCl7cmV0dXJuIHQuc21vb3RoRW5kVGljaygpfSl9fSx7a2V5OlwiaW5lcnRpYVRpY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGUsbixyLG8saSxhLHU9dGhpcyxzPXRoaXMuaW50ZXJhY3Rpb24sbD1mYShzKS5yZXNpc3RhbmNlLGM9KHMuX25vdygpLXRoaXMudDApLzFlMztpZihjPHRoaXMudGUpe3ZhciBmLHA9MS0oTWF0aC5leHAoLWwqYyktdGhpcy5sYW1iZGFfdjApL3RoaXMub25lX3ZlX3YwLGQ9e3g6KGY9dGhpcy5pc01vZGlmaWVkPyhlPXQ9MCxuPXRoaXMudGFyZ2V0T2Zmc2V0Lngscj10aGlzLnRhcmdldE9mZnNldC55LG89dGhpcy5tb2RpZmllZE9mZnNldC54LGk9dGhpcy5tb2RpZmllZE9mZnNldC55LHt4OnBhKGE9cCx0LG4sbykseTpwYShhLGUscixpKX0pOnt4OnRoaXMudGFyZ2V0T2Zmc2V0LngqcCx5OnRoaXMudGFyZ2V0T2Zmc2V0LnkqcH0pLngtdGhpcy5jdXJyZW50T2Zmc2V0LngseTpmLnktdGhpcy5jdXJyZW50T2Zmc2V0Lnl9O3RoaXMuY3VycmVudE9mZnNldC54Kz1kLngsdGhpcy5jdXJyZW50T2Zmc2V0LnkrPWQueSxzLm9mZnNldEJ5KGQpLHMubW92ZSgpLHRoaXMudGltZW91dD1vYS5kZWZhdWx0LnJlcXVlc3QoZnVuY3Rpb24oKXtyZXR1cm4gdS5pbmVydGlhVGljaygpfSl9ZWxzZSBzLm9mZnNldEJ5KHt4OnRoaXMubW9kaWZpZWRPZmZzZXQueC10aGlzLmN1cnJlbnRPZmZzZXQueCx5OnRoaXMubW9kaWZpZWRPZmZzZXQueS10aGlzLmN1cnJlbnRPZmZzZXQueX0pLHRoaXMuZW5kKCl9fSx7a2V5Olwic21vb3RoRW5kVGlja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMuaW50ZXJhY3Rpb24sbj1lLl9ub3coKS10aGlzLnQwLHI9ZmEoZSkuc21vb3RoRW5kRHVyYXRpb247aWYobjxyKXt2YXIgbz1kYShuLDAsdGhpcy50YXJnZXRPZmZzZXQueCxyKSxpPWRhKG4sMCx0aGlzLnRhcmdldE9mZnNldC55LHIpLGE9e3g6by10aGlzLmN1cnJlbnRPZmZzZXQueCx5OmktdGhpcy5jdXJyZW50T2Zmc2V0Lnl9O3RoaXMuY3VycmVudE9mZnNldC54Kz1hLngsdGhpcy5jdXJyZW50T2Zmc2V0LnkrPWEueSxlLm9mZnNldEJ5KGEpLGUubW92ZSh7c2tpcE1vZGlmaWVyczp0aGlzLm1vZGlmaWVyQ291bnR9KSx0aGlzLnRpbWVvdXQ9b2EuZGVmYXVsdC5yZXF1ZXN0KGZ1bmN0aW9uKCl7cmV0dXJuIHQuc21vb3RoRW5kVGljaygpfSl9ZWxzZSBlLm9mZnNldEJ5KHt4OnRoaXMudGFyZ2V0T2Zmc2V0LngtdGhpcy5jdXJyZW50T2Zmc2V0LngseTp0aGlzLnRhcmdldE9mZnNldC55LXRoaXMuY3VycmVudE9mZnNldC55fSksdGhpcy5lbmQoKX19LHtrZXk6XCJyZXN1bWVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50ZXIsbj10LmV2ZW50LHI9dC5ldmVudFRhcmdldCxvPXRoaXMuaW50ZXJhY3Rpb247by5vZmZzZXRCeSh7eDotdGhpcy5jdXJyZW50T2Zmc2V0LngseTotdGhpcy5jdXJyZW50T2Zmc2V0Lnl9KSxvLnVwZGF0ZVBvaW50ZXIoZSxuLHIsITApLG8uX2RvUGhhc2Uoe2ludGVyYWN0aW9uOm8sZXZlbnQ6bixwaGFzZTpcInJlc3VtZVwifSksKDAsenQuY29weUNvb3Jkcykoby5jb29yZHMucHJldixvLmNvb3Jkcy5jdXIpLHRoaXMuc3RvcCgpfX0se2tleTpcImVuZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pbnRlcmFjdGlvbi5tb3ZlKCksdGhpcy5pbnRlcmFjdGlvbi5lbmQoKSx0aGlzLnN0b3AoKX19LHtrZXk6XCJzdG9wXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmFjdGl2ZT10aGlzLnNtb290aEVuZD0hMSx0aGlzLmludGVyYWN0aW9uLnNpbXVsYXRpb249bnVsbCxvYS5kZWZhdWx0LmNhbmNlbCh0aGlzLnRpbWVvdXQpfX1dKSYmc2EodC5wcm90b3R5cGUsbiksciYmc2EodCxyKSxlfSgpO2Z1bmN0aW9uIGZhKHQpe3ZhciBlPXQuaW50ZXJhY3RhYmxlLG49dC5wcmVwYXJlZDtyZXR1cm4gZSYmZS5vcHRpb25zJiZuLm5hbWUmJmUub3B0aW9uc1tuLm5hbWVdLmluZXJ0aWF9ZnVuY3Rpb24gcGEodCxlLG4scil7dmFyIG89MS10O3JldHVybiBvKm8qZSsyKm8qdCpuK3QqdCpyfWZ1bmN0aW9uIGRhKHQsZSxuLHIpe3JldHVybi1uKih0Lz1yKSoodC0yKStlfSRpLkluZXJ0aWFTdGF0ZT1jYTt2YXIgdmE9e2lkOlwiaW5lcnRpYVwiLGJlZm9yZTpbXCJtb2RpZmllcnMvYmFzZVwiXSxpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZGVmYXVsdHM7dC51c2VQbHVnaW4odGEuZGVmYXVsdCksdC51c2VQbHVnaW4oUWkuZGVmYXVsdCksdC5hY3Rpb25zLnBoYXNlcy5pbmVydGlhc3RhcnQ9ITAsdC5hY3Rpb25zLnBoYXNlcy5yZXN1bWU9ITAsZS5wZXJBY3Rpb24uaW5lcnRpYT17ZW5hYmxlZDohMSxyZXNpc3RhbmNlOjEwLG1pblNwZWVkOjEwMCxlbmRTcGVlZDoxMCxhbGxvd1Jlc3VtZTohMCxzbW9vdGhFbmREdXJhdGlvbjozMDB9fSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247ZS5pbmVydGlhPW5ldyBjYShlKX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1lbmRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5ldmVudDtyZXR1cm4oIWUuX2ludGVyYWN0aW5nfHxlLnNpbXVsYXRpb258fCFlLmluZXJ0aWEuc3RhcnQobikpJiZudWxsfSxcImludGVyYWN0aW9uczpkb3duXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuZXZlbnRUYXJnZXQscj1lLmluZXJ0aWE7aWYoci5hY3RpdmUpZm9yKHZhciBvPW47cmEuZWxlbWVudChvKTspe2lmKG89PT1lLmVsZW1lbnQpe3IucmVzdW1lKHQpO2JyZWFrfW89ZWEucGFyZW50Tm9kZShvKX19LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLmluZXJ0aWE7ZS5hY3RpdmUmJmUuc3RvcCgpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLXJlc3VtZVwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uO2Uuc3RvcCh0KSxlLnN0YXJ0KHQsdC5pbnRlcmFjdGlvbi5jb29yZHMuY3VyLnBhZ2UpLGUuYXBwbHlUb0ludGVyYWN0aW9uKHQpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLWluZXJ0aWFzdGFydFwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5zZXRBbmRBcHBseSh0KX0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLXJlc3VtZVwiOlFpLmFkZEV2ZW50TW9kaWZpZXJzLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1pbmVydGlhc3RhcnRcIjpRaS5hZGRFdmVudE1vZGlmaWVycyxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24taW5lcnRpYXN0YXJ0XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkcyh0KX0sXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLXJlc3VtZVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5yZXN0b3JlSW50ZXJhY3Rpb25Db29yZHModCl9fX07JGkuZGVmYXVsdD12YTt2YXIgeWEsaGE9e307ZnVuY3Rpb24gZ2EodCl7cmV0dXJuKGdhPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoaGEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksaGEuaW5pdD1oYS5kZWZhdWx0PXZvaWQgMDt2YXIgYmE9bmV3KCgoeWE9bSh7fSkpJiZ5YS5fX2VzTW9kdWxlP3lhOntkZWZhdWx0OnlhfSkuZGVmYXVsdCksbWE9YmEuaW50ZXJhY3RTdGF0aWM7aGEuZGVmYXVsdD1tYTtmdW5jdGlvbiBPYSh0KXtyZXR1cm4gYmEuaW5pdCh0KX1oYS5pbml0PU9hLFwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9cInVuZGVmaW5lZFwiOmdhKHdpbmRvdykpJiZ3aW5kb3cmJk9hKHdpbmRvdyk7dmFyIHdhPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3YSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx3YS5kZWZhdWx0PXZvaWQgMDt3YS5kZWZhdWx0PXt9O3ZhciBfYT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoX2EsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksX2EuZGVmYXVsdD12b2lkIDA7X2EuZGVmYXVsdD17fTt2YXIgUGE9e307ZnVuY3Rpb24geGEodCxlKXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKSlyZXR1cm47dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEsdT10W1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO3I9ITApO31jYXRjaCh0KXtvPSEwLGk9dH1maW5hbGx5e3RyeXtyfHxudWxsPT11LnJldHVybnx8dS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgaX19cmV0dXJuIG59KHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KFBhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFBhLmRlZmF1bHQ9dm9pZCAwO1BhLmRlZmF1bHQ9ZnVuY3Rpb24odil7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj12LnJhbmdlLHI9di5saW1pdHMsbz12b2lkIDA9PT1yP3tsZWZ0Oi0xLzAscmlnaHQ6MS8wLHRvcDotMS8wLGJvdHRvbToxLzB9OnIsaT12Lm9mZnNldCxhPXZvaWQgMD09PWk/e3g6MCx5OjB9OmksdT17cmFuZ2U6bixncmlkOnYseDpudWxsLHk6bnVsbH0scz0wO3M8eS5sZW5ndGg7cysrKXt2YXIgbD14YSh5W3NdLDIpLGM9bFswXSxmPWxbMV0scD1NYXRoLnJvdW5kKCh0LWEueCkvdltjXSksZD1NYXRoLnJvdW5kKChlLWEueSkvdltmXSk7dVtjXT1NYXRoLm1heChvLmxlZnQsTWF0aC5taW4oby5yaWdodCxwKnZbY10rYS54KSksdVtmXT1NYXRoLm1heChvLnRvcCxNYXRoLm1pbihvLmJvdHRvbSxkKnZbZl0rYS55KSl9cmV0dXJuIHV9dmFyIHk9W1tcInhcIixcInlcIl0sW1wibGVmdFwiLFwidG9wXCJdLFtcInJpZ2h0XCIsXCJib3R0b21cIl0sW1wid2lkdGhcIixcImhlaWdodFwiXV0uZmlsdGVyKGZ1bmN0aW9uKHQpe3ZhciBlPXhhKHQsMiksbj1lWzBdLHI9ZVsxXTtyZXR1cm4gbiBpbiB2fHxyIGluIHZ9KTtyZXR1cm4gdC5ncmlkPXYsdC5jb29yZEZpZWxkcz15LHR9O3ZhciBTYT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoU2EsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFNhLFwiZWRnZVRhcmdldFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBqYS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTYSxcImVsZW1lbnRzXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE1hLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFNhLFwiZ3JpZFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBrYS5kZWZhdWx0fX0pO3ZhciBqYT1FYSh3YSksTWE9RWEoX2EpLGthPUVhKFBhKTtmdW5jdGlvbiBFYSh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19dmFyIFRhPXt9O2Z1bmN0aW9uIERhKHQpe3JldHVybihEYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KFRhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFRhLmRlZmF1bHQ9dm9pZCAwO3ZhciBJYSx6YT0oSWE9Y3QpJiZJYS5fX2VzTW9kdWxlP0lhOntkZWZhdWx0OklhfSxBYT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1EYSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1DYSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShTYSk7ZnVuY3Rpb24gQ2EoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBDYT1mdW5jdGlvbigpe3JldHVybiB0fSx0fXZhciBXYT17aWQ6XCJzbmFwcGVyc1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdFN0YXRpYztlLnNuYXBwZXJzPSgwLHphLmRlZmF1bHQpKGUuc25hcHBlcnN8fHt9LEFhKSxlLmNyZWF0ZVNuYXBHcmlkPWUuc25hcHBlcnMuZ3JpZH19O1RhLmRlZmF1bHQ9V2E7dmFyIFJhPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShSYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxSYS5hc3BlY3RSYXRpbz1SYS5kZWZhdWx0PXZvaWQgMDt2YXIgRmE9WWEoY3QpLFhhPVlhKF9pKTtmdW5jdGlvbiBZYSh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gTmEoZSx0KXt2YXIgbj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihyPXIuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSxuLnB1c2guYXBwbHkobixyKX1yZXR1cm4gbn1mdW5jdGlvbiBMYShlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgbj1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9OYShPYmplY3QobiksITApLmZvckVhY2goZnVuY3Rpb24odCl7QmEoZSx0LG5bdF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSk6TmEoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpKX0pfXJldHVybiBlfWZ1bmN0aW9uIEJhKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgVmE9e3N0YXJ0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGUsbj10LnJlY3Qscj10LmVkZ2VzLG89dC5wYWdlQ29vcmRzLGk9ZS5vcHRpb25zLnJhdGlvLGE9ZS5vcHRpb25zLHU9YS5lcXVhbERlbHRhLHM9YS5tb2RpZmllcnM7XCJwcmVzZXJ2ZVwiPT09aSYmKGk9bi53aWR0aC9uLmhlaWdodCksZS5zdGFydENvb3Jkcz0oMCxGYS5kZWZhdWx0KSh7fSxvKSxlLnN0YXJ0UmVjdD0oMCxGYS5kZWZhdWx0KSh7fSxuKSxlLnJhdGlvPWksZS5lcXVhbERlbHRhPXU7dmFyIGw9ZS5saW5rZWRFZGdlcz17dG9wOnIudG9wfHxyLmxlZnQmJiFyLmJvdHRvbSxsZWZ0OnIubGVmdHx8ci50b3AmJiFyLnJpZ2h0LGJvdHRvbTpyLmJvdHRvbXx8ci5yaWdodCYmIXIudG9wLHJpZ2h0OnIucmlnaHR8fHIuYm90dG9tJiYhci5sZWZ0fTtpZihlLnhJc1ByaW1hcnlBeGlzPSEoIXIubGVmdCYmIXIucmlnaHQpLGUuZXF1YWxEZWx0YSllLmVkZ2VTaWduPShsLmxlZnQ/MTotMSkqKGwudG9wPzE6LTEpO2Vsc2V7dmFyIGM9ZS54SXNQcmltYXJ5QXhpcz9sLnRvcDpsLmxlZnQ7ZS5lZGdlU2lnbj1jPy0xOjF9aWYoKDAsRmEuZGVmYXVsdCkodC5lZGdlcyxsKSxzJiZzLmxlbmd0aCl7dmFyIGY9bmV3IFhhLmRlZmF1bHQodC5pbnRlcmFjdGlvbik7Zi5jb3B5RnJvbSh0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbiksZi5wcmVwYXJlU3RhdGVzKHMpLChlLnN1Yk1vZGlmaWNhdGlvbj1mKS5zdGFydEFsbChMYSh7fSx0KSl9fSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0ZSxuPXQucmVjdCxyPXQuY29vcmRzLG89KDAsRmEuZGVmYXVsdCkoe30sciksaT1lLmVxdWFsRGVsdGE/cWE6VWE7aWYoaShlLGUueElzUHJpbWFyeUF4aXMscixuKSwhZS5zdWJNb2RpZmljYXRpb24pcmV0dXJuIG51bGw7dmFyIGE9KDAsRmEuZGVmYXVsdCkoe30sbik7KDAsJHQuYWRkRWRnZXMpKGUubGlua2VkRWRnZXMsYSx7eDpyLngtby54LHk6ci55LW8ueX0pO3ZhciB1PWUuc3ViTW9kaWZpY2F0aW9uLnNldEFsbChMYSh7fSx0LHtyZWN0OmEsZWRnZXM6ZS5saW5rZWRFZGdlcyxwYWdlQ29vcmRzOnIscHJldkNvb3JkczpyLHByZXZSZWN0OmF9KSkscz11LmRlbHRhO3UuY2hhbmdlZCYmKGkoZSxNYXRoLmFicyhzLngpPk1hdGguYWJzKHMueSksdS5jb29yZHMsdS5yZWN0KSwoMCxGYS5kZWZhdWx0KShyLHUuY29vcmRzKSk7cmV0dXJuIHUuZXZlbnRQcm9wc30sZGVmYXVsdHM6e3JhdGlvOlwicHJlc2VydmVcIixlcXVhbERlbHRhOiExLG1vZGlmaWVyczpbXSxlbmFibGVkOiExfX07ZnVuY3Rpb24gcWEodCxlLG4pe3ZhciByPXQuc3RhcnRDb29yZHMsbz10LmVkZ2VTaWduO2U/bi55PXIueSsobi54LXIueCkqbzpuLng9ci54KyhuLnktci55KSpvfWZ1bmN0aW9uIFVhKHQsZSxuLHIpe3ZhciBvPXQuc3RhcnRSZWN0LGk9dC5zdGFydENvb3JkcyxhPXQucmF0aW8sdT10LmVkZ2VTaWduO2lmKGUpe3ZhciBzPXIud2lkdGgvYTtuLnk9aS55KyhzLW8uaGVpZ2h0KSp1fWVsc2V7dmFyIGw9ci5oZWlnaHQqYTtuLng9aS54KyhsLW8ud2lkdGgpKnV9fVJhLmFzcGVjdFJhdGlvPVZhO3ZhciBHYT0oMCxDaS5tYWtlTW9kaWZpZXIpKFZhLFwiYXNwZWN0UmF0aW9cIik7UmEuZGVmYXVsdD1HYTt2YXIgSGE9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KEhhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEhhLmRlZmF1bHQ9dm9pZCAwO2Z1bmN0aW9uIEthKCl7fUthLl9kZWZhdWx0cz17fTt2YXIgJGE9S2E7SGEuZGVmYXVsdD0kYTt2YXIgWmE9e307ZnVuY3Rpb24gSmEodCl7cmV0dXJuKEphPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoWmEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksWmEuZ2V0UmVzdHJpY3Rpb25SZWN0PWl1LFphLnJlc3RyaWN0PVphLmRlZmF1bHQ9dm9pZCAwO3ZhciBRYSx0dT0oUWE9Y3QpJiZRYS5fX2VzTW9kdWxlP1FhOntkZWZhdWx0OlFhfSxldT1vdSh3KSxudT1vdSgkdCk7ZnVuY3Rpb24gcnUoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBydT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIG91KHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PUphKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPXJ1KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59ZnVuY3Rpb24gaXUodCxlLG4pe3JldHVybiBldS5mdW5jKHQpP251LnJlc29sdmVSZWN0TGlrZSh0LGUuaW50ZXJhY3RhYmxlLGUuZWxlbWVudCxbbi54LG4ueSxlXSk6bnUucmVzb2x2ZVJlY3RMaWtlKHQsZS5pbnRlcmFjdGFibGUsZS5lbGVtZW50KX12YXIgYXU9e3N0YXJ0OmZ1bmN0aW9uKHQpe3ZhciBlPXQucmVjdCxuPXQuc3RhcnRPZmZzZXQscj10LnN0YXRlLG89dC5pbnRlcmFjdGlvbixpPXQucGFnZUNvb3JkcyxhPXIub3B0aW9ucyx1PWEuZWxlbWVudFJlY3Qscz0oMCx0dS5kZWZhdWx0KSh7bGVmdDowLHRvcDowLHJpZ2h0OjAsYm90dG9tOjB9LGEub2Zmc2V0fHx7fSk7aWYoZSYmdSl7dmFyIGw9aXUoYS5yZXN0cmljdGlvbixvLGkpO2lmKGwpe3ZhciBjPWwucmlnaHQtbC5sZWZ0LWUud2lkdGgsZj1sLmJvdHRvbS1sLnRvcC1lLmhlaWdodDtjPDAmJihzLmxlZnQrPWMscy5yaWdodCs9YyksZjwwJiYocy50b3ArPWYscy5ib3R0b20rPWYpfXMubGVmdCs9bi5sZWZ0LWUud2lkdGgqdS5sZWZ0LHMudG9wKz1uLnRvcC1lLmhlaWdodCp1LnRvcCxzLnJpZ2h0Kz1uLnJpZ2h0LWUud2lkdGgqKDEtdS5yaWdodCkscy5ib3R0b20rPW4uYm90dG9tLWUuaGVpZ2h0KigxLXUuYm90dG9tKX1yLm9mZnNldD1zfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5jb29yZHMsbj10LmludGVyYWN0aW9uLHI9dC5zdGF0ZSxvPXIub3B0aW9ucyxpPXIub2Zmc2V0LGE9aXUoby5yZXN0cmljdGlvbixuLGUpO2lmKGEpe3ZhciB1PW51Lnh5d2hUb1RsYnIoYSk7ZS54PU1hdGgubWF4KE1hdGgubWluKHUucmlnaHQtaS5yaWdodCxlLngpLHUubGVmdCtpLmxlZnQpLGUueT1NYXRoLm1heChNYXRoLm1pbih1LmJvdHRvbS1pLmJvdHRvbSxlLnkpLHUudG9wK2kudG9wKX19LGRlZmF1bHRzOntyZXN0cmljdGlvbjpudWxsLGVsZW1lbnRSZWN0Om51bGwsb2Zmc2V0Om51bGwsZW5kT25seTohMSxlbmFibGVkOiExfX07WmEucmVzdHJpY3Q9YXU7dmFyIHV1PSgwLENpLm1ha2VNb2RpZmllcikoYXUsXCJyZXN0cmljdFwiKTtaYS5kZWZhdWx0PXV1O3ZhciBzdT17fTtmdW5jdGlvbiBsdSh0KXtyZXR1cm4obHU9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxzdS5yZXN0cmljdEVkZ2VzPXN1LmRlZmF1bHQ9dm9pZCAwO3ZhciBjdSxmdT0oY3U9Y3QpJiZjdS5fX2VzTW9kdWxlP2N1OntkZWZhdWx0OmN1fSxwdT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1sdSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1kdSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSgkdCk7ZnVuY3Rpb24gZHUoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBkdT1mdW5jdGlvbigpe3JldHVybiB0fSx0fXZhciB2dT17dG9wOjEvMCxsZWZ0OjEvMCxib3R0b206LTEvMCxyaWdodDotMS8wfSx5dT17dG9wOi0xLzAsbGVmdDotMS8wLGJvdHRvbToxLzAscmlnaHQ6MS8wfTtmdW5jdGlvbiBodSh0LGUpe2Zvcih2YXIgbj1bXCJ0b3BcIixcImxlZnRcIixcImJvdHRvbVwiLFwicmlnaHRcIl0scj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbz1uW3JdO28gaW4gdHx8KHRbb109ZVtvXSl9cmV0dXJuIHR9dmFyIGd1PXtub0lubmVyOnZ1LG5vT3V0ZXI6eXUsc3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGUsbj10LmludGVyYWN0aW9uLHI9dC5zdGFydE9mZnNldCxvPXQuc3RhdGUsaT1vLm9wdGlvbnM7aWYoaSl7dmFyIGE9KDAsWmEuZ2V0UmVzdHJpY3Rpb25SZWN0KShpLm9mZnNldCxuLG4uY29vcmRzLnN0YXJ0LnBhZ2UpO2U9cHUucmVjdFRvWFkoYSl9ZT1lfHx7eDowLHk6MH0sby5vZmZzZXQ9e3RvcDplLnkrci50b3AsbGVmdDplLngrci5sZWZ0LGJvdHRvbTplLnktci5ib3R0b20scmlnaHQ6ZS54LXIucmlnaHR9fSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5jb29yZHMsbj10LmVkZ2VzLHI9dC5pbnRlcmFjdGlvbixvPXQuc3RhdGUsaT1vLm9mZnNldCxhPW8ub3B0aW9ucztpZihuKXt2YXIgdT0oMCxmdS5kZWZhdWx0KSh7fSxlKSxzPSgwLFphLmdldFJlc3RyaWN0aW9uUmVjdCkoYS5pbm5lcixyLHUpfHx7fSxsPSgwLFphLmdldFJlc3RyaWN0aW9uUmVjdCkoYS5vdXRlcixyLHUpfHx7fTtodShzLHZ1KSxodShsLHl1KSxuLnRvcD9lLnk9TWF0aC5taW4oTWF0aC5tYXgobC50b3AraS50b3AsdS55KSxzLnRvcCtpLnRvcCk6bi5ib3R0b20mJihlLnk9TWF0aC5tYXgoTWF0aC5taW4obC5ib3R0b20raS5ib3R0b20sdS55KSxzLmJvdHRvbStpLmJvdHRvbSkpLG4ubGVmdD9lLng9TWF0aC5taW4oTWF0aC5tYXgobC5sZWZ0K2kubGVmdCx1LngpLHMubGVmdCtpLmxlZnQpOm4ucmlnaHQmJihlLng9TWF0aC5tYXgoTWF0aC5taW4obC5yaWdodCtpLnJpZ2h0LHUueCkscy5yaWdodCtpLnJpZ2h0KSl9fSxkZWZhdWx0czp7aW5uZXI6bnVsbCxvdXRlcjpudWxsLG9mZnNldDpudWxsLGVuZE9ubHk6ITEsZW5hYmxlZDohMX19O3N1LnJlc3RyaWN0RWRnZXM9Z3U7dmFyIGJ1PSgwLENpLm1ha2VNb2RpZmllcikoZ3UsXCJyZXN0cmljdEVkZ2VzXCIpO3N1LmRlZmF1bHQ9YnU7dmFyIG11LE91PXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShPdSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPdS5yZXN0cmljdFJlY3Q9T3UuZGVmYXVsdD12b2lkIDA7dmFyIHd1PSgwLCgobXU9Y3QpJiZtdS5fX2VzTW9kdWxlP211OntkZWZhdWx0Om11fSkuZGVmYXVsdCkoe2dldCBlbGVtZW50UmVjdCgpe3JldHVybnt0b3A6MCxsZWZ0OjAsYm90dG9tOjEscmlnaHQ6MX19LHNldCBlbGVtZW50UmVjdCh0KXt9fSxaYS5yZXN0cmljdC5kZWZhdWx0cyksX3U9e3N0YXJ0OlphLnJlc3RyaWN0LnN0YXJ0LHNldDpaYS5yZXN0cmljdC5zZXQsZGVmYXVsdHM6d3V9O091LnJlc3RyaWN0UmVjdD1fdTt2YXIgUHU9KDAsQ2kubWFrZU1vZGlmaWVyKShfdSxcInJlc3RyaWN0UmVjdFwiKTtPdS5kZWZhdWx0PVB1O3ZhciB4dT17fTtmdW5jdGlvbiBTdSh0KXtyZXR1cm4oU3U9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4dSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx4dS5yZXN0cmljdFNpemU9eHUuZGVmYXVsdD12b2lkIDA7dmFyIGp1LE11PShqdT1jdCkmJmp1Ll9fZXNNb2R1bGU/anU6e2RlZmF1bHQ6anV9LGt1PWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PVN1KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUV1KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KCR0KTtmdW5jdGlvbiBFdSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIEV1PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9dmFyIFR1PXt3aWR0aDotMS8wLGhlaWdodDotMS8wfSxEdT17d2lkdGg6MS8wLGhlaWdodDoxLzB9O3ZhciBJdT17c3RhcnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHN1LnJlc3RyaWN0RWRnZXMuc3RhcnQodCl9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5zdGF0ZSxyPXQucmVjdCxvPXQuZWRnZXMsaT1uLm9wdGlvbnM7aWYobyl7dmFyIGE9a3UudGxiclRvWHl3aCgoMCxaYS5nZXRSZXN0cmljdGlvblJlY3QpKGkubWluLGUsdC5jb29yZHMpKXx8VHUsdT1rdS50bGJyVG9YeXdoKCgwLFphLmdldFJlc3RyaWN0aW9uUmVjdCkoaS5tYXgsZSx0LmNvb3JkcykpfHxEdTtuLm9wdGlvbnM9e2VuZE9ubHk6aS5lbmRPbmx5LGlubmVyOigwLE11LmRlZmF1bHQpKHt9LHN1LnJlc3RyaWN0RWRnZXMubm9Jbm5lciksb3V0ZXI6KDAsTXUuZGVmYXVsdCkoe30sc3UucmVzdHJpY3RFZGdlcy5ub091dGVyKX0sby50b3A/KG4ub3B0aW9ucy5pbm5lci50b3A9ci5ib3R0b20tYS5oZWlnaHQsbi5vcHRpb25zLm91dGVyLnRvcD1yLmJvdHRvbS11LmhlaWdodCk6by5ib3R0b20mJihuLm9wdGlvbnMuaW5uZXIuYm90dG9tPXIudG9wK2EuaGVpZ2h0LG4ub3B0aW9ucy5vdXRlci5ib3R0b209ci50b3ArdS5oZWlnaHQpLG8ubGVmdD8obi5vcHRpb25zLmlubmVyLmxlZnQ9ci5yaWdodC1hLndpZHRoLG4ub3B0aW9ucy5vdXRlci5sZWZ0PXIucmlnaHQtdS53aWR0aCk6by5yaWdodCYmKG4ub3B0aW9ucy5pbm5lci5yaWdodD1yLmxlZnQrYS53aWR0aCxuLm9wdGlvbnMub3V0ZXIucmlnaHQ9ci5sZWZ0K3Uud2lkdGgpLHN1LnJlc3RyaWN0RWRnZXMuc2V0KHQpLG4ub3B0aW9ucz1pfX0sZGVmYXVsdHM6e21pbjpudWxsLG1heDpudWxsLGVuZE9ubHk6ITEsZW5hYmxlZDohMX19O3h1LnJlc3RyaWN0U2l6ZT1JdTt2YXIgenU9KDAsQ2kubWFrZU1vZGlmaWVyKShJdSxcInJlc3RyaWN0U2l6ZVwiKTt4dS5kZWZhdWx0PXp1O3ZhciBBdT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQXUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksQXUuZGVmYXVsdD12b2lkIDA7ZnVuY3Rpb24gQ3UoKXt9Q3UuX2RlZmF1bHRzPXt9O3ZhciBXdT1DdTtBdS5kZWZhdWx0PVd1O3ZhciBSdT17fTtmdW5jdGlvbiBGdSh0KXtyZXR1cm4oRnU9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxSdS5zbmFwPVJ1LmRlZmF1bHQ9dm9pZCAwO3ZhciBYdT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1GdSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1ZdSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShsZSk7ZnVuY3Rpb24gWXUoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBZdT1mdW5jdGlvbigpe3JldHVybiB0fSx0fXZhciBOdT17c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGUsbixyLG89dC5pbnRlcmFjdGlvbixpPXQuaW50ZXJhY3RhYmxlLGE9dC5lbGVtZW50LHU9dC5yZWN0LHM9dC5zdGF0ZSxsPXQuc3RhcnRPZmZzZXQsYz1zLm9wdGlvbnMsZj1jLm9mZnNldFdpdGhPcmlnaW4/KG49KGU9dCkuaW50ZXJhY3Rpb24uZWxlbWVudCxYdS5yZWN0LnJlY3RUb1hZKFh1LnJlY3QucmVzb2x2ZVJlY3RMaWtlKGUuc3RhdGUub3B0aW9ucy5vcmlnaW4sbnVsbCxudWxsLFtuXSkpfHxYdS5nZXRPcmlnaW5YWShlLmludGVyYWN0YWJsZSxuLGUuaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSkpOnt4OjAseTowfTtpZihcInN0YXJ0Q29vcmRzXCI9PT1jLm9mZnNldClyPXt4Om8uY29vcmRzLnN0YXJ0LnBhZ2UueCx5Om8uY29vcmRzLnN0YXJ0LnBhZ2UueX07ZWxzZXt2YXIgcD1YdS5yZWN0LnJlc29sdmVSZWN0TGlrZShjLm9mZnNldCxpLGEsW29dKTsocj1YdS5yZWN0LnJlY3RUb1hZKHApfHx7eDowLHk6MH0pLngrPWYueCxyLnkrPWYueX12YXIgZD1jLnJlbGF0aXZlUG9pbnRzO3Mub2Zmc2V0cz11JiZkJiZkLmxlbmd0aD9kLm1hcChmdW5jdGlvbih0LGUpe3JldHVybntpbmRleDplLHJlbGF0aXZlUG9pbnQ6dCx4OmwubGVmdC11LndpZHRoKnQueCtyLngseTpsLnRvcC11LmhlaWdodCp0Lnkrci55fX0pOltYdS5leHRlbmQoe2luZGV4OjAscmVsYXRpdmVQb2ludDpudWxsfSxyKV19LHNldDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5jb29yZHMscj10LnN0YXRlLG89ci5vcHRpb25zLGk9ci5vZmZzZXRzLGE9WHUuZ2V0T3JpZ2luWFkoZS5pbnRlcmFjdGFibGUsZS5lbGVtZW50LGUucHJlcGFyZWQubmFtZSksdT1YdS5leHRlbmQoe30sbikscz1bXTtvLm9mZnNldFdpdGhPcmlnaW58fCh1LngtPWEueCx1LnktPWEueSk7Zm9yKHZhciBsPTA7bDxpLmxlbmd0aDtsKyspZm9yKHZhciBjPWlbbF0sZj11LngtYy54LHA9dS55LWMueSxkPTAsdj1vLnRhcmdldHMubGVuZ3RoO2Q8djtkKyspe3ZhciB5PW8udGFyZ2V0c1tkXSxoPXZvaWQgMDsoaD1YdS5pcy5mdW5jKHkpP3koZixwLGUsYyxkKTp5KSYmcy5wdXNoKHt4OihYdS5pcy5udW1iZXIoaC54KT9oLng6ZikrYy54LHk6KFh1LmlzLm51bWJlcihoLnkpP2gueTpwKStjLnkscmFuZ2U6WHUuaXMubnVtYmVyKGgucmFuZ2UpP2gucmFuZ2U6by5yYW5nZSxzb3VyY2U6eSxpbmRleDpkLG9mZnNldDpjfSl9Zm9yKHZhciBnPXt0YXJnZXQ6bnVsbCxpblJhbmdlOiExLGRpc3RhbmNlOjAscmFuZ2U6MCxkZWx0YTp7eDowLHk6MH19LGI9MDtiPHMubGVuZ3RoO2IrKyl7dmFyIG09c1tiXSxPPW0ucmFuZ2Usdz1tLngtdS54LF89bS55LXUueSxQPVh1Lmh5cG90KHcsXykseD1QPD1PO089PT0xLzAmJmcuaW5SYW5nZSYmZy5yYW5nZSE9PTEvMCYmKHg9ITEpLGcudGFyZ2V0JiYhKHg/Zy5pblJhbmdlJiZPIT09MS8wP1AvTzxnLmRpc3RhbmNlL2cucmFuZ2U6Tz09PTEvMCYmZy5yYW5nZSE9PTEvMHx8UDxnLmRpc3RhbmNlOiFnLmluUmFuZ2UmJlA8Zy5kaXN0YW5jZSl8fChnLnRhcmdldD1tLGcuZGlzdGFuY2U9UCxnLnJhbmdlPU8sZy5pblJhbmdlPXgsZy5kZWx0YS54PXcsZy5kZWx0YS55PV8pfXJldHVybiBnLmluUmFuZ2UmJihuLng9Zy50YXJnZXQueCxuLnk9Zy50YXJnZXQueSksci5jbG9zZXN0PWd9LGRlZmF1bHRzOntyYW5nZToxLzAsdGFyZ2V0czpudWxsLG9mZnNldDpudWxsLG9mZnNldFdpdGhPcmlnaW46ITAsb3JpZ2luOm51bGwscmVsYXRpdmVQb2ludHM6bnVsbCxlbmRPbmx5OiExLGVuYWJsZWQ6ITF9fTtSdS5zbmFwPU51O3ZhciBMdT0oMCxDaS5tYWtlTW9kaWZpZXIpKE51LFwic25hcFwiKTtSdS5kZWZhdWx0PUx1O3ZhciBCdT17fTtmdW5jdGlvbiBWdSh0KXtyZXR1cm4oVnU9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxCdS5zbmFwU2l6ZT1CdS5kZWZhdWx0PXZvaWQgMDt2YXIgcXUsVXU9KHF1PWN0KSYmcXUuX19lc01vZHVsZT9xdTp7ZGVmYXVsdDpxdX0sR3U9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09VnUodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9SHUoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0odyk7ZnVuY3Rpb24gSHUoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBIdT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIEt1KHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHR9KHQpfHxmdW5jdGlvbih0LGUpe2lmKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkpcmV0dXJuO3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHU9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7cnx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufSh0LGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfXZhciAkdT17c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0ZSxuPXQuZWRnZXMscj1lLm9wdGlvbnM7aWYoIW4pcmV0dXJuIG51bGw7dC5zdGF0ZT17b3B0aW9uczp7dGFyZ2V0czpudWxsLHJlbGF0aXZlUG9pbnRzOlt7eDpuLmxlZnQ/MDoxLHk6bi50b3A/MDoxfV0sb2Zmc2V0OnIub2Zmc2V0fHxcInNlbGZcIixvcmlnaW46e3g6MCx5OjB9LHJhbmdlOnIucmFuZ2V9fSxlLnRhcmdldEZpZWxkcz1lLnRhcmdldEZpZWxkc3x8W1tcIndpZHRoXCIsXCJoZWlnaHRcIl0sW1wieFwiLFwieVwiXV0sUnUuc25hcC5zdGFydCh0KSxlLm9mZnNldHM9dC5zdGF0ZS5vZmZzZXRzLHQuc3RhdGU9ZX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LnN0YXRlLHI9dC5jb29yZHMsbz1uLm9wdGlvbnMsaT1uLm9mZnNldHMsYT17eDpyLngtaVswXS54LHk6ci55LWlbMF0ueX07bi5vcHRpb25zPSgwLFV1LmRlZmF1bHQpKHt9LG8pLG4ub3B0aW9ucy50YXJnZXRzPVtdO2Zvcih2YXIgdT0wO3U8KG8udGFyZ2V0c3x8W10pLmxlbmd0aDt1Kyspe3ZhciBzPShvLnRhcmdldHN8fFtdKVt1XSxsPXZvaWQgMDtpZihsPUd1LmZ1bmMocyk/cyhhLngsYS55LGUpOnMpe2Zvcih2YXIgYz0wO2M8bi50YXJnZXRGaWVsZHMubGVuZ3RoO2MrKyl7dmFyIGY9S3Uobi50YXJnZXRGaWVsZHNbY10sMikscD1mWzBdLGQ9ZlsxXTtpZihwIGluIGx8fGQgaW4gbCl7bC54PWxbcF0sbC55PWxbZF07YnJlYWt9fW4ub3B0aW9ucy50YXJnZXRzLnB1c2gobCl9fXZhciB2PVJ1LnNuYXAuc2V0KHQpO3JldHVybiBuLm9wdGlvbnM9byx2fSxkZWZhdWx0czp7cmFuZ2U6MS8wLHRhcmdldHM6bnVsbCxvZmZzZXQ6bnVsbCxlbmRPbmx5OiExLGVuYWJsZWQ6ITF9fTtCdS5zbmFwU2l6ZT0kdTt2YXIgWnU9KDAsQ2kubWFrZU1vZGlmaWVyKSgkdSxcInNuYXBTaXplXCIpO0J1LmRlZmF1bHQ9WnU7dmFyIEp1PXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShKdSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxKdS5zbmFwRWRnZXM9SnUuZGVmYXVsdD12b2lkIDA7dmFyIFF1PWVzKFYpLHRzPWVzKGN0KTtmdW5jdGlvbiBlcyh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19dmFyIG5zPXtzdGFydDpmdW5jdGlvbih0KXt2YXIgZT10LmVkZ2VzO3JldHVybiBlPyh0LnN0YXRlLnRhcmdldEZpZWxkcz10LnN0YXRlLnRhcmdldEZpZWxkc3x8W1tlLmxlZnQ/XCJsZWZ0XCI6XCJyaWdodFwiLGUudG9wP1widG9wXCI6XCJib3R0b21cIl1dLEJ1LnNuYXBTaXplLnN0YXJ0KHQpKTpudWxsfSxzZXQ6QnUuc25hcFNpemUuc2V0LGRlZmF1bHRzOigwLHRzLmRlZmF1bHQpKCgwLFF1LmRlZmF1bHQpKEJ1LnNuYXBTaXplLmRlZmF1bHRzKSx7dGFyZ2V0czpudWxsLHJhbmdlOm51bGwsb2Zmc2V0Ont4OjAseTowfX0pfTtKdS5zbmFwRWRnZXM9bnM7dmFyIHJzPSgwLENpLm1ha2VNb2RpZmllcikobnMsXCJzbmFwRWRnZXNcIik7SnUuZGVmYXVsdD1yczt2YXIgb3M9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KG9zLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG9zLmRlZmF1bHQ9dm9pZCAwO2Z1bmN0aW9uIGlzKCl7fWlzLl9kZWZhdWx0cz17fTt2YXIgYXM9aXM7b3MuZGVmYXVsdD1hczt2YXIgdXM9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHVzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHVzLmRlZmF1bHQ9dm9pZCAwO2Z1bmN0aW9uIHNzKCl7fXNzLl9kZWZhdWx0cz17fTt2YXIgbHM9c3M7dXMuZGVmYXVsdD1sczt2YXIgY3M9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KGNzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGNzLmRlZmF1bHQ9dm9pZCAwO3ZhciBmcz1QcyhSYSkscHM9UHMoSGEpLGRzPVBzKHN1KSx2cz1QcyhaYSkseXM9UHMoT3UpLGhzPVBzKHh1KSxncz1QcyhBdSksYnM9UHMoSnUpLG1zPVBzKFJ1KSxPcz1QcyhCdSksd3M9UHMob3MpLF9zPVBzKHVzKTtmdW5jdGlvbiBQcyh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19dmFyIHhzPXthc3BlY3RSYXRpbzpmcy5kZWZhdWx0LHJlc3RyaWN0RWRnZXM6ZHMuZGVmYXVsdCxyZXN0cmljdDp2cy5kZWZhdWx0LHJlc3RyaWN0UmVjdDp5cy5kZWZhdWx0LHJlc3RyaWN0U2l6ZTpocy5kZWZhdWx0LHNuYXBFZGdlczpicy5kZWZhdWx0LHNuYXA6bXMuZGVmYXVsdCxzbmFwU2l6ZTpPcy5kZWZhdWx0LHNwcmluZzp3cy5kZWZhdWx0LGF2b2lkOnBzLmRlZmF1bHQsdHJhbnNmb3JtOl9zLmRlZmF1bHQscnViYmVyYmFuZDpncy5kZWZhdWx0fTtjcy5kZWZhdWx0PXhzO3ZhciBTcz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoU3MsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksU3MuZGVmYXVsdD12b2lkIDA7dmFyIGpzPUVzKFRhKSxNcz1Fcyhjcyksa3M9RXMoQ2kpO2Z1bmN0aW9uIEVzKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX12YXIgVHM9e2lkOlwibW9kaWZpZXJzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0U3RhdGljO2Zvcih2YXIgbiBpbiB0LnVzZVBsdWdpbihrcy5kZWZhdWx0KSx0LnVzZVBsdWdpbihqcy5kZWZhdWx0KSxlLm1vZGlmaWVycz1Ncy5kZWZhdWx0LE1zLmRlZmF1bHQpe3ZhciByPU1zLmRlZmF1bHRbbl0sbz1yLl9kZWZhdWx0cyxpPXIuX21ldGhvZHM7by5fbWV0aG9kcz1pLHQuZGVmYXVsdHMucGVyQWN0aW9uW25dPW99fX07U3MuZGVmYXVsdD1Uczt2YXIgRHM9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KERzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLERzLmRlZmF1bHQ9dm9pZCAwO0RzLmRlZmF1bHQ9e307dmFyIElzPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJcyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJcy5Qb2ludGVyRXZlbnQ9SXMuZGVmYXVsdD12b2lkIDA7dmFyIHpzLEFzPSh6cz1NZSkmJnpzLl9fZXNNb2R1bGU/enM6e2RlZmF1bHQ6enN9LENzPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PVJzKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPVdzKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHp0KTtmdW5jdGlvbiBXcygpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIFdzPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gUnModCl7cmV0dXJuKFJzPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiBGcyh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gWHModCl7cmV0dXJuKFhzPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX1mdW5jdGlvbiBZcyh0KXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gdH1mdW5jdGlvbiBOcyh0LGUpe3JldHVybihOcz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9ZnVuY3Rpb24gTHModCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBCcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGYodCxlLG4scixvLGkpe3ZhciBhLHUscztpZighZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGYpLHU9dGhpcyxhPSEocz1YcyhmKS5jYWxsKHRoaXMsbykpfHxcIm9iamVjdFwiIT09UnMocykmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHM/WXModSk6cyxMcyhZcyhhKSxcInR5cGVcIix2b2lkIDApLExzKFlzKGEpLFwib3JpZ2luYWxFdmVudFwiLHZvaWQgMCksTHMoWXMoYSksXCJwb2ludGVySWRcIix2b2lkIDApLExzKFlzKGEpLFwicG9pbnRlclR5cGVcIix2b2lkIDApLExzKFlzKGEpLFwiZG91YmxlXCIsdm9pZCAwKSxMcyhZcyhhKSxcInBhZ2VYXCIsdm9pZCAwKSxMcyhZcyhhKSxcInBhZ2VZXCIsdm9pZCAwKSxMcyhZcyhhKSxcImNsaWVudFhcIix2b2lkIDApLExzKFlzKGEpLFwiY2xpZW50WVwiLHZvaWQgMCksTHMoWXMoYSksXCJkdFwiLHZvaWQgMCksTHMoWXMoYSksXCJldmVudGFibGVcIix2b2lkIDApLENzLnBvaW50ZXJFeHRlbmQoWXMoYSksbiksbiE9PWUmJkNzLnBvaW50ZXJFeHRlbmQoWXMoYSksZSksYS50aW1lU3RhbXA9aSxhLm9yaWdpbmFsRXZlbnQ9bixhLnR5cGU9dCxhLnBvaW50ZXJJZD1Dcy5nZXRQb2ludGVySWQoZSksYS5wb2ludGVyVHlwZT1Dcy5nZXRQb2ludGVyVHlwZShlKSxhLnRhcmdldD1yLGEuY3VycmVudFRhcmdldD1udWxsLFwidGFwXCI9PT10KXt2YXIgbD1vLmdldFBvaW50ZXJJbmRleChlKTthLmR0PWEudGltZVN0YW1wLW8ucG9pbnRlcnNbbF0uZG93blRpbWU7dmFyIGM9YS50aW1lU3RhbXAtby50YXBUaW1lO2EuZG91YmxlPSEhKG8ucHJldlRhcCYmXCJkb3VibGV0YXBcIiE9PW8ucHJldlRhcC50eXBlJiZvLnByZXZUYXAudGFyZ2V0PT09YS50YXJnZXQmJmM8NTAwKX1lbHNlXCJkb3VibGV0YXBcIj09PXQmJihhLmR0PWUudGltZVN0YW1wLW8udGFwVGltZSk7cmV0dXJuIGF9dmFyIHQsZSxuO3JldHVybiBmdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmTnModCxlKX0oZixBc1tcImRlZmF1bHRcIl0pLHQ9ZiwoZT1be2tleTpcIl9zdWJ0cmFjdE9yaWdpblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQueCxuPXQueTtyZXR1cm4gdGhpcy5wYWdlWC09ZSx0aGlzLnBhZ2VZLT1uLHRoaXMuY2xpZW50WC09ZSx0aGlzLmNsaWVudFktPW4sdGhpc319LHtrZXk6XCJfYWRkT3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC54LG49dC55O3JldHVybiB0aGlzLnBhZ2VYKz1lLHRoaXMucGFnZVkrPW4sdGhpcy5jbGllbnRYKz1lLHRoaXMuY2xpZW50WSs9bix0aGlzfX0se2tleTpcInByZXZlbnREZWZhdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKX19XSkmJkZzKHQucHJvdG90eXBlLGUpLG4mJkZzKHQsbiksZn0oKTtJcy5Qb2ludGVyRXZlbnQ9SXMuZGVmYXVsdD1Cczt2YXIgVnM9e307ZnVuY3Rpb24gcXModCl7cmV0dXJuKHFzPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoVnMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksVnMuZGVmYXVsdD12b2lkIDA7S3MoRW4pLEtzKG0oe30pKTt2YXIgVXM9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09cXModCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9SHMoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0obGUpLEdzPUtzKElzKTtmdW5jdGlvbiBIcygpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIEhzPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gS3ModCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fXZhciAkcz17aWQ6XCJwb2ludGVyLWV2ZW50cy9iYXNlXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LnBvaW50ZXJFdmVudHM9JHMsdC5kZWZhdWx0cy5hY3Rpb25zLnBvaW50ZXJFdmVudHM9JHMuZGVmYXVsdHMsVXMuZXh0ZW5kKHQuYWN0aW9ucy5waGFzZWxlc3NUeXBlcywkcy50eXBlcyl9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtlLnByZXZUYXA9bnVsbCxlLnRhcFRpbWU9MH0sXCJpbnRlcmFjdGlvbnM6dXBkYXRlLXBvaW50ZXJcIjpmdW5jdGlvbih0KXt2YXIgZT10LmRvd24sbj10LnBvaW50ZXJJbmZvO2lmKCFlJiZuLmhvbGQpcmV0dXJuO24uaG9sZD17ZHVyYXRpb246MS8wLHRpbWVvdXQ6bnVsbH19LFwiaW50ZXJhY3Rpb25zOm1vdmVcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsbz10LmV2ZW50LGk9dC5ldmVudFRhcmdldCxhPXQuZHVwbGljYXRlLHU9bi5nZXRQb2ludGVySW5kZXgocik7YXx8bi5wb2ludGVySXNEb3duJiYhbi5wb2ludGVyV2FzTW92ZWR8fChuLnBvaW50ZXJJc0Rvd24mJmNsZWFyVGltZW91dChuLnBvaW50ZXJzW3VdLmhvbGQudGltZW91dCksWnMoe2ludGVyYWN0aW9uOm4scG9pbnRlcjpyLGV2ZW50Om8sZXZlbnRUYXJnZXQ6aSx0eXBlOlwibW92ZVwifSxlKSl9LFwiaW50ZXJhY3Rpb25zOmRvd25cIjpmdW5jdGlvbih0LGUpeyFmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyLG89dC5ldmVudCxpPXQuZXZlbnRUYXJnZXQsYT10LnBvaW50ZXJJbmRleCx1PW4ucG9pbnRlcnNbYV0uaG9sZCxzPVVzLmRvbS5nZXRQYXRoKGkpLGw9e2ludGVyYWN0aW9uOm4scG9pbnRlcjpyLGV2ZW50Om8sZXZlbnRUYXJnZXQ6aSx0eXBlOlwiaG9sZFwiLHRhcmdldHM6W10scGF0aDpzLG5vZGU6bnVsbH0sYz0wO2M8cy5sZW5ndGg7YysrKXt2YXIgZj1zW2NdO2wubm9kZT1mLGUuZmlyZShcInBvaW50ZXJFdmVudHM6Y29sbGVjdC10YXJnZXRzXCIsbCl9aWYoIWwudGFyZ2V0cy5sZW5ndGgpcmV0dXJuO2Zvcih2YXIgcD0xLzAsZD0wO2Q8bC50YXJnZXRzLmxlbmd0aDtkKyspe3ZhciB2PWwudGFyZ2V0c1tkXS5ldmVudGFibGUub3B0aW9ucy5ob2xkRHVyYXRpb247djxwJiYocD12KX11LmR1cmF0aW9uPXAsdS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtacyh7aW50ZXJhY3Rpb246bixldmVudFRhcmdldDppLHBvaW50ZXI6cixldmVudDpvLHR5cGU6XCJob2xkXCJ9LGUpfSxwKX0odCxlKSxacyh0LGUpfSxcImludGVyYWN0aW9uczp1cFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG4scixvLGksYSx1O1FzKHQpLFpzKHQsZSkscj1lLG89KG49dCkuaW50ZXJhY3Rpb24saT1uLnBvaW50ZXIsYT1uLmV2ZW50LHU9bi5ldmVudFRhcmdldCxvLnBvaW50ZXJXYXNNb3ZlZHx8WnMoe2ludGVyYWN0aW9uOm8sZXZlbnRUYXJnZXQ6dSxwb2ludGVyOmksZXZlbnQ6YSx0eXBlOlwidGFwXCJ9LHIpfSxcImludGVyYWN0aW9uczpjYW5jZWxcIjpmdW5jdGlvbih0LGUpe1FzKHQpLFpzKHQsZSl9fSxQb2ludGVyRXZlbnQ6R3MuZGVmYXVsdCxmaXJlOlpzLGNvbGxlY3RFdmVudFRhcmdldHM6SnMsZGVmYXVsdHM6e2hvbGREdXJhdGlvbjo2MDAsaWdub3JlRnJvbTpudWxsLGFsbG93RnJvbTpudWxsLG9yaWdpbjp7eDowLHk6MH19LHR5cGVzOntkb3duOiEwLG1vdmU6ITAsdXA6ITAsY2FuY2VsOiEwLHRhcDohMCxkb3VibGV0YXA6ITAsaG9sZDohMH19O2Z1bmN0aW9uIFpzKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixvPXQuZXZlbnQsaT10LmV2ZW50VGFyZ2V0LGE9dC50eXBlLHU9dC50YXJnZXRzLHM9dm9pZCAwPT09dT9Kcyh0LGUpOnUsbD1uZXcgR3MuZGVmYXVsdChhLHIsbyxpLG4sZS5ub3coKSk7ZS5maXJlKFwicG9pbnRlckV2ZW50czpuZXdcIix7cG9pbnRlckV2ZW50Omx9KTtmb3IodmFyIGM9e2ludGVyYWN0aW9uOm4scG9pbnRlcjpyLGV2ZW50Om8sZXZlbnRUYXJnZXQ6aSx0YXJnZXRzOnMsdHlwZTphLHBvaW50ZXJFdmVudDpsfSxmPTA7ZjxzLmxlbmd0aDtmKyspe3ZhciBwPXNbZl07Zm9yKHZhciBkIGluIHAucHJvcHN8fHt9KWxbZF09cC5wcm9wc1tkXTt2YXIgdj1Vcy5nZXRPcmlnaW5YWShwLmV2ZW50YWJsZSxwLm5vZGUpO2lmKGwuX3N1YnRyYWN0T3JpZ2luKHYpLGwuZXZlbnRhYmxlPXAuZXZlbnRhYmxlLGwuY3VycmVudFRhcmdldD1wLm5vZGUscC5ldmVudGFibGUuZmlyZShsKSxsLl9hZGRPcmlnaW4odiksbC5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWR8fGwucHJvcGFnYXRpb25TdG9wcGVkJiZmKzE8cy5sZW5ndGgmJnNbZisxXS5ub2RlIT09bC5jdXJyZW50VGFyZ2V0KWJyZWFrfWlmKGUuZmlyZShcInBvaW50ZXJFdmVudHM6ZmlyZWRcIixjKSxcInRhcFwiPT09YSl7dmFyIHk9bC5kb3VibGU/WnMoe2ludGVyYWN0aW9uOm4scG9pbnRlcjpyLGV2ZW50Om8sZXZlbnRUYXJnZXQ6aSx0eXBlOlwiZG91YmxldGFwXCJ9LGUpOmw7bi5wcmV2VGFwPXksbi50YXBUaW1lPXkudGltZVN0YW1wfXJldHVybiBsfWZ1bmN0aW9uIEpzKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixvPXQuZXZlbnQsaT10LmV2ZW50VGFyZ2V0LGE9dC50eXBlLHU9bi5nZXRQb2ludGVySW5kZXgocikscz1uLnBvaW50ZXJzW3VdO2lmKFwidGFwXCI9PT1hJiYobi5wb2ludGVyV2FzTW92ZWR8fCFzfHxzLmRvd25UYXJnZXQhPT1pKSlyZXR1cm5bXTtmb3IodmFyIGw9VXMuZG9tLmdldFBhdGgoaSksYz17aW50ZXJhY3Rpb246bixwb2ludGVyOnIsZXZlbnQ6byxldmVudFRhcmdldDppLHR5cGU6YSxwYXRoOmwsdGFyZ2V0czpbXSxub2RlOm51bGx9LGY9MDtmPGwubGVuZ3RoO2YrKyl7dmFyIHA9bFtmXTtjLm5vZGU9cCxlLmZpcmUoXCJwb2ludGVyRXZlbnRzOmNvbGxlY3QtdGFyZ2V0c1wiLGMpfXJldHVyblwiaG9sZFwiPT09YSYmKGMudGFyZ2V0cz1jLnRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0LmV2ZW50YWJsZS5vcHRpb25zLmhvbGREdXJhdGlvbj09PW4ucG9pbnRlcnNbdV0uaG9sZC5kdXJhdGlvbn0pKSxjLnRhcmdldHN9ZnVuY3Rpb24gUXModCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQucG9pbnRlckluZGV4O2UucG9pbnRlcnNbbl0uaG9sZCYmY2xlYXJUaW1lb3V0KGUucG9pbnRlcnNbbl0uaG9sZC50aW1lb3V0KX12YXIgdGw9JHM7VnMuZGVmYXVsdD10bDt2YXIgZWw9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGVsLmRlZmF1bHQ9dm9pZCAwO3JsKElzKTt2YXIgbmw9cmwoVnMpO2Z1bmN0aW9uIHJsKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvbCh0KXt2YXIgZT10LmludGVyYWN0aW9uO2UuaG9sZEludGVydmFsSGFuZGxlJiYoY2xlYXJJbnRlcnZhbChlLmhvbGRJbnRlcnZhbEhhbmRsZSksZS5ob2xkSW50ZXJ2YWxIYW5kbGU9bnVsbCl9dmFyIGlsPXtpZDpcInBvaW50ZXItZXZlbnRzL2hvbGRSZXBlYXRcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3QudXNlUGx1Z2luKG5sLmRlZmF1bHQpO3ZhciBlPXQucG9pbnRlckV2ZW50cztlLmRlZmF1bHRzLmhvbGRSZXBlYXRJbnRlcnZhbD0wLGUudHlwZXMuaG9sZHJlcGVhdD10LmFjdGlvbnMucGhhc2VsZXNzVHlwZXMuaG9sZHJlcGVhdD0hMH0sbGlzdGVuZXJzOltcIm1vdmVcIixcInVwXCIsXCJjYW5jZWxcIixcImVuZGFsbFwiXS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtcInBvaW50ZXJFdmVudHM6XCIuY29uY2F0KGUpXT1vbCx0fSx7XCJwb2ludGVyRXZlbnRzOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQucG9pbnRlckV2ZW50O1wiaG9sZFwiPT09ZS50eXBlJiYoZS5jb3VudD0oZS5jb3VudHx8MCkrMSl9LFwicG9pbnRlckV2ZW50czpmaXJlZFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlckV2ZW50LG89dC5ldmVudFRhcmdldCxpPXQudGFyZ2V0cztpZihcImhvbGRcIj09PXIudHlwZSYmaS5sZW5ndGgpe3ZhciBhPWlbMF0uZXZlbnRhYmxlLm9wdGlvbnMuaG9sZFJlcGVhdEludGVydmFsO2E8PTB8fChuLmhvbGRJbnRlcnZhbEhhbmRsZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5wb2ludGVyRXZlbnRzLmZpcmUoe2ludGVyYWN0aW9uOm4sZXZlbnRUYXJnZXQ6byx0eXBlOlwiaG9sZFwiLHBvaW50ZXI6cixldmVudDpyfSxlKX0sYSkpfX19KX07ZWwuZGVmYXVsdD1pbDt2YXIgYWw9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KGFsLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGFsLmRlZmF1bHQ9dm9pZCAwO3ZhciB1bCxzbD0odWw9Y3QpJiZ1bC5fX2VzTW9kdWxlP3VsOntkZWZhdWx0OnVsfTtmdW5jdGlvbiBsbCh0KXtyZXR1cm4oMCxzbC5kZWZhdWx0KSh0aGlzLmV2ZW50cy5vcHRpb25zLHQpLHRoaXN9dmFyIGNsPXtpZDpcInBvaW50ZXItZXZlbnRzL2ludGVyYWN0YWJsZVRhcmdldHNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuSW50ZXJhY3RhYmxlO2UucHJvdG90eXBlLnBvaW50ZXJFdmVudHM9bGw7dmFyIHI9ZS5wcm90b3R5cGUuX2JhY2tDb21wYXRPcHRpb247ZS5wcm90b3R5cGUuX2JhY2tDb21wYXRPcHRpb249ZnVuY3Rpb24odCxlKXt2YXIgbj1yLmNhbGwodGhpcyx0LGUpO3JldHVybiBuPT09dGhpcyYmKHRoaXMuZXZlbnRzLm9wdGlvbnNbdF09ZSksbn19LGxpc3RlbmVyczp7XCJwb2ludGVyRXZlbnRzOmNvbGxlY3QtdGFyZ2V0c1wiOmZ1bmN0aW9uKHQsZSl7dmFyIHI9dC50YXJnZXRzLG89dC5ub2RlLGk9dC50eXBlLGE9dC5ldmVudFRhcmdldDtlLmludGVyYWN0YWJsZXMuZm9yRWFjaE1hdGNoKG8sZnVuY3Rpb24odCl7dmFyIGU9dC5ldmVudHMsbj1lLm9wdGlvbnM7ZS50eXBlc1tpXSYmZS50eXBlc1tpXS5sZW5ndGgmJnQudGVzdElnbm9yZUFsbG93KG4sbyxhKSYmci5wdXNoKHtub2RlOm8sZXZlbnRhYmxlOmUscHJvcHM6e2ludGVyYWN0YWJsZTp0fX0pfSl9LFwiaW50ZXJhY3RhYmxlOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3RhYmxlO2UuZXZlbnRzLmdldFJlY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIGUuZ2V0UmVjdCh0KX19LFwiaW50ZXJhY3RhYmxlOnNldFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGFibGUscj10Lm9wdGlvbnM7KDAsc2wuZGVmYXVsdCkobi5ldmVudHMub3B0aW9ucyxlLnBvaW50ZXJFdmVudHMuZGVmYXVsdHMpLCgwLHNsLmRlZmF1bHQpKG4uZXZlbnRzLm9wdGlvbnMsci5wb2ludGVyRXZlbnRzfHx7fSl9fX07YWwuZGVmYXVsdD1jbDt2YXIgZmw9e307ZnVuY3Rpb24gcGwodCl7cmV0dXJuKHBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZmwsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGZsLFwiaG9sZFJlcGVhdFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB2bC5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbCxcImludGVyYWN0YWJsZVRhcmdldHNcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4geWwuZGVmYXVsdH19KSxmbC5wb2ludGVyRXZlbnRzPWZsLmRlZmF1bHQ9dm9pZCAwO3ZhciBkbD1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1wbCh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1nbCgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShWcyk7ZmwucG9pbnRlckV2ZW50cz1kbDt2YXIgdmw9aGwoZWwpLHlsPWhsKGFsKTtmdW5jdGlvbiBobCh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gZ2woKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBnbD1mdW5jdGlvbigpe3JldHVybiB0fSx0fXZhciBibD17aWQ6XCJwb2ludGVyLWV2ZW50c1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC51c2VQbHVnaW4oZGwpLHQudXNlUGx1Z2luKHZsLmRlZmF1bHQpLHQudXNlUGx1Z2luKHlsLmRlZmF1bHQpfX07ZmwuZGVmYXVsdD1ibDt2YXIgbWw9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KG1sLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG1sLmluc3RhbGw9d2wsbWwuZGVmYXVsdD12b2lkIDA7dmFyIE9sOyhPbD1rKHt9KSkmJk9sLl9fZXNNb2R1bGU7ZnVuY3Rpb24gd2woZSl7dmFyIHQ9ZS5JbnRlcmFjdGFibGU7ZS5hY3Rpb25zLnBoYXNlcy5yZWZsb3c9ITAsdC5wcm90b3R5cGUucmVmbG93PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih1LHMsbCl7ZnVuY3Rpb24gdCgpe3ZhciBlPWNbZF0sdD11LmdldFJlY3QoZSk7aWYoIXQpcmV0dXJuXCJicmVha1wiO3ZhciBuPWxlLmFyci5maW5kKGwuaW50ZXJhY3Rpb25zLmxpc3QsZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3RpbmcoKSYmdC5pbnRlcmFjdGFibGU9PT11JiZ0LmVsZW1lbnQ9PT1lJiZ0LnByZXBhcmVkLm5hbWU9PT1zLm5hbWV9KSxyPXZvaWQgMDtpZihuKW4ubW92ZSgpLHAmJihyPW4uX3JlZmxvd1Byb21pc2V8fG5ldyBmKGZ1bmN0aW9uKHQpe24uX3JlZmxvd1Jlc29sdmU9dH0pKTtlbHNle3ZhciBvPWxlLnJlY3QudGxiclRvWHl3aCh0KSxpPXtwYWdlOnt4Om8ueCx5Om8ueX0sY2xpZW50Ont4Om8ueCx5Om8ueX0sdGltZVN0YW1wOmwubm93KCl9LGE9bGUucG9pbnRlci5jb29yZHNUb0V2ZW50KGkpO3I9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgaT10LmludGVyYWN0aW9ucy5uZXcoe3BvaW50ZXJUeXBlOlwicmVmbG93XCJ9KSxhPXtpbnRlcmFjdGlvbjppLGV2ZW50Om8scG9pbnRlcjpvLGV2ZW50VGFyZ2V0Om4scGhhc2U6XCJyZWZsb3dcIn07aS5pbnRlcmFjdGFibGU9ZSxpLmVsZW1lbnQ9bixpLnByZXBhcmVkPSgwLGxlLmV4dGVuZCkoe30sciksaS5wcmV2RXZlbnQ9byxpLnVwZGF0ZVBvaW50ZXIobyxvLG4sITApLGkuX2RvUGhhc2UoYSk7dmFyIHU9bGUud2luLndpbmRvdy5Qcm9taXNlP25ldyBsZS53aW4ud2luZG93LlByb21pc2UoZnVuY3Rpb24odCl7aS5fcmVmbG93UmVzb2x2ZT10fSk6bnVsbDtpLl9yZWZsb3dQcm9taXNlPXUsaS5zdGFydChyLGUsbiksaS5faW50ZXJhY3Rpbmc/KGkubW92ZShhKSxpLmVuZChvKSk6aS5zdG9wKCk7cmV0dXJuIGkucmVtb3ZlUG9pbnRlcihvLG8pLGkucG9pbnRlcklzRG93bj0hMSx1fShsLHUsZSxzLGEpfXAmJnAucHVzaChyKX1mb3IodmFyIGM9bGUuaXMuc3RyaW5nKHUudGFyZ2V0KT9sZS5hcnIuZnJvbSh1Ll9jb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwodS50YXJnZXQpKTpbdS50YXJnZXRdLGY9bGUud2luLndpbmRvdy5Qcm9taXNlLHA9Zj9bXTpudWxsLGQ9MDtkPGMubGVuZ3RoO2QrKyl7aWYoXCJicmVha1wiPT09dCgpKWJyZWFrfXJldHVybiBwJiZmLmFsbChwKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHV9KX0odGhpcyx0LGUpfX12YXIgX2w9e2lkOlwicmVmbG93XCIsaW5zdGFsbDp3bCxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb247XCJyZWZsb3dcIj09PW4ucG9pbnRlclR5cGUmJihuLl9yZWZsb3dSZXNvbHZlJiZuLl9yZWZsb3dSZXNvbHZlKCksbGUuYXJyLnJlbW92ZShlLmludGVyYWN0aW9ucy5saXN0LG4pKX19fTttbC5kZWZhdWx0PV9sO3ZhciBQbD17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoUGwsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksUGwuZGVmYXVsdD12b2lkIDA7UGwuZGVmYXVsdD17fTt2YXIgeGw9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHhsLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHhsLmV4Y2hhbmdlPXZvaWQgMDt4bC5leGNoYW5nZT17fTt2YXIgU2w9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KFNsLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFNsLmRlZmF1bHQ9dm9pZCAwO1NsLmRlZmF1bHQ9e307dmFyIGpsPXt9O2Z1bmN0aW9uIE1sKHQpe3JldHVybihNbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGpsLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGpsLmRlZmF1bHQ9dm9pZCAwO3ZhciBrbD1IbChRciksRWw9SGwoYW8pLFRsPUhsKHVvKSxEbD1IbCh0aSksSWw9SGwoYWkpLHpsPUhsKHVpKSxBbD1IbChVbiksQ2w9KEhsKHNpKSxHbCh3aSkpLFdsPUhsKCRpKSxSbD1IbChoYSksRmw9SGwoU3MpLFhsPUhsKERzKSxZbD1IbChZaSksTmw9SGwoZmwpLExsPUhsKG1sKSxCbD1HbChQbCksVmw9R2woenQpLHFsPUdsKFNsKTtmdW5jdGlvbiBVbCgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIFVsPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gR2wodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09TWwodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9VWwoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn1mdW5jdGlvbiBIbCh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19UmwuZGVmYXVsdC51c2UoWGwuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoQWwuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoWWwuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoSWwuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoRWwuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoTmwuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoV2wuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoRmwuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoRGwuZGVmYXVsdCksUmwuZGVmYXVsdC51c2Uoa2wuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoVGwuZGVmYXVsdCksUmwuZGVmYXVsdC51c2UoTGwuZGVmYXVsdCksUmwuZGVmYXVsdC5mZWVkYmFjaz1DbCxSbC5kZWZhdWx0LnVzZSh6bC5kZWZhdWx0KSxSbC5kZWZhdWx0LnZ1ZT17Y29tcG9uZW50czpxbH0sUmwuZGVmYXVsdC5fX3V0aWxzPXtleGNoYW5nZTp4bC5leGNoYW5nZSxkaXNwbGFjZTpCbCxwb2ludGVyOlZsfTt2YXIgS2w9UmwuZGVmYXVsdDtqbC5kZWZhdWx0PUtsO3ZhciAkbD17ZXhwb3J0czp7fX07T2JqZWN0LmRlZmluZVByb3BlcnR5KCRsLmV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksJGwuZXhwb3J0cy5kZWZhdWx0PXZvaWQgMDt2YXIgWmwsSmw9KFpsPWpsKSYmWmwuX19lc01vZHVsZT9abDp7ZGVmYXVsdDpabH07ZnVuY3Rpb24gUWwodCl7cmV0dXJuKFFsPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1pZihcIm9iamVjdFwiPT09UWwoJGwpJiYkbCl0cnl7JGwuZXhwb3J0cz1KbC5kZWZhdWx0fWNhdGNoKHQpe31KbC5kZWZhdWx0LmRlZmF1bHQ9SmwuZGVmYXVsdDt2YXIgdGM9SmwuZGVmYXVsdDtyZXR1cm4gJGwuZXhwb3J0cy5kZWZhdWx0PXRjLCRsPSRsLmV4cG9ydHN9KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJhY3QubWluLmpzLm1hcFxuIiwiLyohXG4gKiBpc2VjdCB2My4wLjBcbiAqIChjKSAyMDE4IEFuZHJlaSBLYXNoY2hhLlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwuaXNlY3QgPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKiBmb2xsb3dzIFwiQW4gaW1wbGVtZW50YXRpb24gb2YgdG9wLWRvd24gc3BsYXlpbmdcIlxuICAgKiBieSBELiBTbGVhdG9yIDxzbGVhdG9yQGNzLmNtdS5lZHU+IE1hcmNoIDE5OTJcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsqfSBLZXlcbiAgICovXG5cblxuICAvKipcbiAgICogQHR5cGVkZWYgeyp9IFZhbHVlXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtmdW5jdGlvbihub2RlOk5vZGUpOnZvaWR9IFZpc2l0b3JcbiAgICovXG5cblxuICAvKipcbiAgICogQHR5cGVkZWYge2Z1bmN0aW9uKGE6S2V5LCBiOktleSk6bnVtYmVyfSBDb21wYXJhdG9yXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obm9kZTpOb2RlKTpzdHJpbmd9IE5vZGVQcmludGVyXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9ICBOb2RlXG4gICAqIEBwcm9wZXJ0eSB7S2V5fSAgICBLZXlcbiAgICogQHByb3BlcnR5IHtWYWx1ZT19IGRhdGFcbiAgICogQHByb3BlcnR5IHtOb2RlfSAgIGxlZnRcbiAgICogQHByb3BlcnR5IHtOb2RlfSAgIHJpZ2h0XG4gICAqL1xuXG4gIHZhciBOb2RlID0gZnVuY3Rpb24gTm9kZSAoa2V5LCBkYXRhKSB7XG4gICAgdGhpcy5rZXkgID0ga2V5O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICB0aGlzLnJpZ2h0PSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIERFRkFVTFRfQ09NUEFSRSAoYSwgYikgeyByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7IH1cblxuXG4gIC8qKlxuICAgKiBTaW1wbGUgdG9wIGRvd24gc3BsYXksIG5vdCByZXF1aXJpbmcgaSB0byBiZSBpbiB0aGUgdHJlZSB0LlxuICAgKiBAcGFyYW0ge0tleX0gaVxuICAgKiBAcGFyYW0ge05vZGU/fSB0XG4gICAqIEBwYXJhbSB7Q29tcGFyYXRvcn0gY29tcGFyYXRvclxuICAgKi9cbiAgZnVuY3Rpb24gc3BsYXkgKGksIHQsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodCA9PT0gbnVsbCkgeyByZXR1cm4gdDsgfVxuICAgIHZhciBsLCByLCB5O1xuICAgIHZhciBOID0gbmV3IE5vZGUoKTtcbiAgICBsID0gciA9IE47XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xuICAgICAgLy9pZiAoaSA8IHQua2V5KSB7XG4gICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICBpZiAodC5sZWZ0ID09PSBudWxsKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vaWYgKGkgPCB0LmxlZnQua2V5KSB7XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGksIHQubGVmdC5rZXkpIDwgMCkge1xuICAgICAgICAgIHkgPSB0LmxlZnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogcm90YXRlIHJpZ2h0ICovXG4gICAgICAgICAgdC5sZWZ0ID0geS5yaWdodDtcbiAgICAgICAgICB5LnJpZ2h0ID0gdDtcbiAgICAgICAgICB0ID0geTtcbiAgICAgICAgICBpZiAodC5sZWZ0ID09PSBudWxsKSB7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgci5sZWZ0ID0gdDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGluayByaWdodCAqL1xuICAgICAgICByID0gdDtcbiAgICAgICAgdCA9IHQubGVmdDtcbiAgICAgIC8vfSBlbHNlIGlmIChpID4gdC5rZXkpIHtcbiAgICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICBpZiAodC5yaWdodCA9PT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgICAvL2lmIChpID4gdC5yaWdodC5rZXkpIHtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaSwgdC5yaWdodC5rZXkpID4gMCkge1xuICAgICAgICAgIHkgPSB0LnJpZ2h0OyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogcm90YXRlIGxlZnQgKi9cbiAgICAgICAgICB0LnJpZ2h0ID0geS5sZWZ0O1xuICAgICAgICAgIHkubGVmdCA9IHQ7XG4gICAgICAgICAgdCA9IHk7XG4gICAgICAgICAgaWYgKHQucmlnaHQgPT09IG51bGwpIHsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBsLnJpZ2h0ID0gdDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaW5rIGxlZnQgKi9cbiAgICAgICAgbCA9IHQ7XG4gICAgICAgIHQgPSB0LnJpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGFzc2VtYmxlICovXG4gICAgbC5yaWdodCA9IHQubGVmdDtcbiAgICByLmxlZnQgPSB0LnJpZ2h0O1xuICAgIHQubGVmdCA9IE4ucmlnaHQ7XG4gICAgdC5yaWdodCA9IE4ubGVmdDtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0tleX0gICAgICAgIGlcbiAgICogQHBhcmFtICB7VmFsdWV9ICAgICAgZGF0YVxuICAgKiBAcGFyYW0gIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yXG4gICAqIEBwYXJhbSAge1RyZWV9ICAgICAgIHRyZWVcbiAgICogQHJldHVybiB7Tm9kZX0gICAgICByb290XG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnQgKGksIGRhdGEsIHQsIGNvbXBhcmF0b3IsIHRyZWUpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKGksIGRhdGEpO1xuXG4gICAgdHJlZS5fc2l6ZSsrO1xuXG4gICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgIG5vZGUubGVmdCA9IG5vZGUucmlnaHQgPSBudWxsO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgdCA9IHNwbGF5KGksIHQsIGNvbXBhcmF0b3IpO1xuICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGksIHQua2V5KTtcbiAgICBpZiAoY21wIDwgMCkge1xuICAgICAgbm9kZS5sZWZ0ID0gdC5sZWZ0O1xuICAgICAgbm9kZS5yaWdodCA9IHQ7XG4gICAgICB0LmxlZnQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoY21wID49IDApIHtcbiAgICAgIG5vZGUucmlnaHQgPSB0LnJpZ2h0O1xuICAgICAgbm9kZS5sZWZ0ID0gdDtcbiAgICAgIHQucmlnaHQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEluc2VydCBpIGludG8gdGhlIHRyZWUgdCwgdW5sZXNzIGl0J3MgYWxyZWFkeSB0aGVyZS5cbiAgICogQHBhcmFtICB7S2V5fSAgICAgICAgaVxuICAgKiBAcGFyYW0gIHtWYWx1ZX0gICAgICBkYXRhXG4gICAqIEBwYXJhbSAge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3JcbiAgICogQHBhcmFtICB7VHJlZX0gICAgICAgdHJlZVxuICAgKiBAcmV0dXJuIHtOb2RlfSAgICAgICByb290XG4gICAqL1xuICBmdW5jdGlvbiBhZGQgKGksIGRhdGEsIHQsIGNvbXBhcmF0b3IsIHRyZWUpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKGksIGRhdGEpO1xuXG4gICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgIG5vZGUubGVmdCA9IG5vZGUucmlnaHQgPSBudWxsO1xuICAgICAgdHJlZS5fc2l6ZSsrO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgdCA9IHNwbGF5KGksIHQsIGNvbXBhcmF0b3IpO1xuICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGksIHQua2V5KTtcbiAgICBpZiAoY21wID09PSAwKSB7IHJldHVybiB0OyB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICBub2RlLmxlZnQgPSB0LmxlZnQ7XG4gICAgICAgIG5vZGUucmlnaHQgPSB0O1xuICAgICAgICB0LmxlZnQgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgIG5vZGUucmlnaHQgPSB0LnJpZ2h0O1xuICAgICAgICBub2RlLmxlZnQgPSB0O1xuICAgICAgICB0LnJpZ2h0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRyZWUuX3NpemUrKztcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgaSBmcm9tIHRoZSB0cmVlIGlmIGl0J3MgdGhlcmVcbiAgICogQHBhcmFtIHtLZXl9ICAgICAgICBpXG4gICAqIEBwYXJhbSB7VHJlZX0gICAgICAgdHJlZVxuICAgKiBAcGFyYW0ge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3JcbiAgICogQHBhcmFtIHtUcmVlfSAgICAgICB0cmVlXG4gICAqIEByZXR1cm4ge05vZGV9ICAgICAgbmV3IHJvb3RcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZSAoaSwgdCwgY29tcGFyYXRvciwgdHJlZSkge1xuICAgIHZhciB4O1xuICAgIGlmICh0ID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgdCA9IHNwbGF5KGksIHQsIGNvbXBhcmF0b3IpO1xuICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGksIHQua2V5KTtcbiAgICBpZiAoY21wID09PSAwKSB7ICAgICAgICAgICAgICAgLyogZm91bmQgaXQgKi9cbiAgICAgIGlmICh0LmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgeCA9IHQucmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gc3BsYXkoaSwgdC5sZWZ0LCBjb21wYXJhdG9yKTtcbiAgICAgICAgeC5yaWdodCA9IHQucmlnaHQ7XG4gICAgICB9XG4gICAgICB0cmVlLl9zaXplLS07XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgcmV0dXJuIHQ7ICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEl0IHdhc24ndCB0aGVyZSAqL1xuICB9XG5cblxuICBmdW5jdGlvbiBzcGxpdCAoa2V5LCB2LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGxlZnQsIHJpZ2h0O1xuICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICBsZWZ0ID0gcmlnaHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ID0gc3BsYXkoa2V5LCB2LCBjb21wYXJhdG9yKTtcblxuICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3Iodi5rZXksIGtleSk7XG4gICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgIGxlZnQgID0gdi5sZWZ0O1xuICAgICAgICByaWdodCA9IHYucmlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgcmlnaHQgICA9IHYucmlnaHQ7XG4gICAgICAgIHYucmlnaHQgPSBudWxsO1xuICAgICAgICBsZWZ0ICAgID0gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgICA9IHYubGVmdDtcbiAgICAgICAgdi5sZWZ0ID0gbnVsbDtcbiAgICAgICAgcmlnaHQgID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCwgcmlnaHQ6IHJpZ2h0IH07XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG1lcmdlIChsZWZ0LCByaWdodCwgY29tcGFyYXRvcikge1xuICAgIGlmIChyaWdodCA9PT0gbnVsbCkgeyByZXR1cm4gbGVmdDsgfVxuICAgIGlmIChsZWZ0ICA9PT0gbnVsbCkgeyByZXR1cm4gcmlnaHQ7IH1cblxuICAgIHJpZ2h0ID0gc3BsYXkobGVmdC5rZXksIHJpZ2h0LCBjb21wYXJhdG9yKTtcbiAgICByaWdodC5sZWZ0ID0gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBQcmludHMgbGV2ZWwgb2YgdGhlIHRyZWVcbiAgICogQHBhcmFtICB7Tm9kZX0gICAgICAgICAgICAgICAgICAgICAgICByb290XG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgcHJlZml4XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgaXNUYWlsXG4gICAqIEBwYXJhbSAge0FycmF5PHN0cmluZz59ICAgICAgICAgICAgICAgb3V0XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9uKG5vZGU6Tm9kZSk6U3RyaW5nfSAgcHJpbnROb2RlXG4gICAqL1xuICBmdW5jdGlvbiBwcmludFJvdyAocm9vdCwgcHJlZml4LCBpc1RhaWwsIG91dCwgcHJpbnROb2RlKSB7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIG91dCgoXCJcIiArIHByZWZpeCArIChpc1RhaWwgPyAn4pSU4pSA4pSAICcgOiAn4pSc4pSA4pSAICcpICsgKHByaW50Tm9kZShyb290KSkgKyBcIlxcblwiKSk7XG4gICAgICB2YXIgaW5kZW50ID0gcHJlZml4ICsgKGlzVGFpbCA/ICcgICAgJyA6ICfilIIgICAnKTtcbiAgICAgIGlmIChyb290LmxlZnQpICB7IHByaW50Um93KHJvb3QubGVmdCwgIGluZGVudCwgZmFsc2UsIG91dCwgcHJpbnROb2RlKTsgfVxuICAgICAgaWYgKHJvb3QucmlnaHQpIHsgcHJpbnRSb3cocm9vdC5yaWdodCwgaW5kZW50LCB0cnVlLCAgb3V0LCBwcmludE5vZGUpOyB9XG4gICAgfVxuICB9XG5cblxuICB2YXIgVHJlZSA9IGZ1bmN0aW9uIFRyZWUgKGNvbXBhcmF0b3IpIHtcbiAgICBpZiAoIGNvbXBhcmF0b3IgPT09IHZvaWQgMCApIGNvbXBhcmF0b3IgPSBERUZBVUxUX0NPTVBBUkU7XG5cbiAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9zaXplID0gMDtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBzaXplOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblxuICAvKipcbiAgICogSW5zZXJ0cyBhIGtleSwgYWxsb3dzIGR1cGxpY2F0ZXNcbiAgICogQHBhcmFte0tleX0gIGtleVxuICAgKiBAcGFyYW17VmFsdWU9fSBkYXRhXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCQxIChrZXksIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdCA9IGluc2VydChrZXksIGRhdGEsIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IsIHRoaXMpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBrZXksIGlmIGl0IGlzIG5vdCBwcmVzZW50IGluIHRoZSB0cmVlXG4gICAqIEBwYXJhbXtLZXl9ICBrZXlcbiAgICogQHBhcmFte1ZhbHVlPX0gZGF0YVxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQkMSAoa2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBhZGQoa2V5LCBkYXRhLCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yLCB0aGlzKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17S2V5fSBrZXlcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlJDEgKGtleSkge1xuICAgIHRoaXMuX3Jvb3QgPSByZW1vdmUoa2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yLCB0aGlzKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBub2RlIHdpdGggc21hbGxlc3Qga2V5XG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gcG9wICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHdoaWxlIChub2RlLmxlZnQpIHsgbm9kZSA9IG5vZGUubGVmdDsgfVxuICAgICAgdGhpcy5fcm9vdCA9IHNwbGF5KG5vZGUua2V5LHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xuICAgICAgdGhpcy5fcm9vdCA9IHJlbW92ZShub2RlLmtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvciwgdGhpcyk7XG4gICAgICByZXR1cm4geyBrZXk6IG5vZGUua2V5LCBkYXRhOiBub2RlLmRhdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte0tleX0ga2V5XG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmZpbmRTdGF0aWMgPSBmdW5jdGlvbiBmaW5kU3RhdGljIChrZXkpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICB2YXIgY21wID0gY29tcGFyZShrZXksIGN1cnJlbnQua2V5KTtcbiAgICAgIGlmIChjbXAgPT09IDApICB7IHJldHVybiBjdXJyZW50OyB9XG4gICAgICBlbHNlIGlmIChjbXAgPCAwKSB7IGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7IH1cbiAgICAgIGVsc2UgICAgICAgICAgICB7IGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0OyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtLZXl9IGtleVxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gZmluZCAoa2V5KSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QpIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSBzcGxheShrZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xuICAgICAgaWYgKHRoaXMuX2NvbXBhcmF0b3Ioa2V5LCB0aGlzLl9yb290LmtleSkgIT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte0tleX0ga2V5XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zIChrZXkpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICB2YXIgY21wID0gY29tcGFyZShrZXksIGN1cnJlbnQua2V5KTtcbiAgICAgIGlmIChjbXAgPT09IDApICB7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIGlmIChjbXAgPCAwKSB7IGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7IH1cbiAgICAgIGVsc2UgICAgICAgICAgICB7IGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0OyB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17VmlzaXRvcn0gdmlzaXRvclxuICAgKiBAcGFyYW17Kj19ICAgIGN0eFxuICAgKiBAcmV0dXJuIHtTcGxheVRyZWV9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAodmlzaXRvciwgY3R4KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290O1xuICAgIHZhciBRID0gW107LyogSW5pdGlhbGl6ZSBzdGFjayBzICovXG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcblxuICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgaWYgKGN1cnJlbnQgIT09bnVsbCkge1xuICAgICAgICBRLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoUS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gUS5wb3AoKTtcbiAgICAgICAgICB2aXNpdG9yLmNhbGwoY3R4LCBjdXJyZW50KTtcblxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgeyBkb25lID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBXYWxrIGtleSByYW5nZSBmcm9tIGBsb3dgIHRvIGBoaWdoYC4gU3RvcHMgaWYgYGZuYCByZXR1cm5zIGEgdmFsdWUuXG4gICAqIEBwYXJhbXtLZXl9ICAgIGxvd1xuICAgKiBAcGFyYW17S2V5fSAgICBoaWdoXG4gICAqIEBwYXJhbXtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFteyo/fSAgICAgY3R4XG4gICAqIEByZXR1cm4ge1NwbGF5VHJlZX1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UgKGxvdywgaGlnaCwgZm4sIGN0eCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBjb21wYXJlID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3QsIGNtcDtcblxuICAgIHdoaWxlIChRLmxlbmd0aCAhPT0gMCB8fCBub2RlKSB7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBRLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gUS5wb3AoKTtcbiAgICAgICAgY21wID0gY29tcGFyZShub2RlLmtleSwgaGlnaCk7XG4gICAgICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcGFyZShub2RlLmtleSwgbG93KSA+PSAwKSB7XG4gICAgICAgICAgaWYgKGZuLmNhbGwoY3R4LCBub2RlKSkgeyByZXR1cm4gdGhpcyQxOyB9IC8vIHN0b3AgaWYgc210aCBpcyByZXR1cm5lZFxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IG9mIGtleXNcbiAgICogQHJldHVybiB7QXJyYXk8S2V5Pn1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiBrZXlzICgpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBrZXkgPSByZWYua2V5O1xuXG4gICAgICAgIHJldHVybiBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0pO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgb2YgYWxsIHRoZSBkYXRhIGluIHRoZSBub2Rlc1xuICAgKiBAcmV0dXJuIHtBcnJheTxWYWx1ZT59XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMgKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZXMucHVzaChkYXRhKTtcbiAgICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7S2V5fG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiBtaW4gKCkge1xuICAgIGlmICh0aGlzLl9yb290KSB7IHJldHVybiB0aGlzLm1pbk5vZGUodGhpcy5fcm9vdCkua2V5OyB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7S2V5fG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiBtYXggKCkge1xuICAgIGlmICh0aGlzLl9yb290KSB7IHJldHVybiB0aGlzLm1heE5vZGUodGhpcy5fcm9vdCkua2V5OyB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUubWluTm9kZSA9IGZ1bmN0aW9uIG1pbk5vZGUgKHQpIHtcbiAgICAgIGlmICggdCA9PT0gdm9pZCAwICkgdCA9IHRoaXMuX3Jvb3Q7XG5cbiAgICBpZiAodCkgeyB3aGlsZSAodC5sZWZ0KSB7IHQgPSB0LmxlZnQ7IH0gfVxuICAgIHJldHVybiB0O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLm1heE5vZGUgPSBmdW5jdGlvbiBtYXhOb2RlICh0KSB7XG4gICAgICBpZiAoIHQgPT09IHZvaWQgMCApIHQgPSB0aGlzLl9yb290O1xuXG4gICAgaWYgKHQpIHsgd2hpbGUgKHQucmlnaHQpIHsgdCA9IHQucmlnaHQ7IH0gfVxuICAgIHJldHVybiB0O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgbm9kZSBhdCBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW17bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQgKGluZGV4KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290LCBkb25lID0gZmFsc2UsIGkgPSAwO1xuICAgIHZhciBRID0gW107XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIFEucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChRLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gUS5wb3AoKTtcbiAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHsgcmV0dXJuIGN1cnJlbnQ7IH1cbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7IGRvbmUgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtOb2RlfSBkXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0IChkKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xuICAgIHZhciBzdWNjZXNzb3IgPSBudWxsO1xuXG4gICAgaWYgKGQucmlnaHQpIHtcbiAgICAgIHN1Y2Nlc3NvciA9IGQucmlnaHQ7XG4gICAgICB3aGlsZSAoc3VjY2Vzc29yLmxlZnQpIHsgc3VjY2Vzc29yID0gc3VjY2Vzc29yLmxlZnQ7IH1cbiAgICAgIHJldHVybiBzdWNjZXNzb3I7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgIHdoaWxlIChyb290KSB7XG4gICAgICB2YXIgY21wID0gY29tcGFyYXRvcihkLmtleSwgcm9vdC5rZXkpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkgeyBicmVhazsgfVxuICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICBzdWNjZXNzb3IgPSByb290O1xuICAgICAgICByb290ID0gcm9vdC5sZWZ0O1xuICAgICAgfSBlbHNlIHsgcm9vdCA9IHJvb3QucmlnaHQ7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VjY2Vzc29yO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtOb2RlfSBkXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiBwcmV2IChkKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xuICAgIHZhciBwcmVkZWNlc3NvciA9IG51bGw7XG5cbiAgICBpZiAoZC5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICBwcmVkZWNlc3NvciA9IGQubGVmdDtcbiAgICAgIHdoaWxlIChwcmVkZWNlc3Nvci5yaWdodCkgeyBwcmVkZWNlc3NvciA9IHByZWRlY2Vzc29yLnJpZ2h0OyB9XG4gICAgICByZXR1cm4gcHJlZGVjZXNzb3I7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgIHdoaWxlIChyb290KSB7XG4gICAgICB2YXIgY21wID0gY29tcGFyYXRvcihkLmtleSwgcm9vdC5rZXkpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkgeyBicmVhazsgfVxuICAgICAgZWxzZSBpZiAoY21wIDwgMCkgeyByb290ID0gcm9vdC5sZWZ0OyB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHJlZGVjZXNzb3IgPSByb290O1xuICAgICAgICByb290ID0gcm9vdC5yaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZWRlY2Vzc29yO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1NwbGF5VHJlZX1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge05vZGVMaXN0fVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUudG9MaXN0ID0gZnVuY3Rpb24gdG9MaXN0JDEgKCkge1xuICAgIHJldHVybiB0b0xpc3QodGhpcy5fcm9vdCk7XG4gIH07XG5cblxuICAvKipcbiAgICogQnVsay1sb2FkIGl0ZW1zLiBCb3RoIGFycmF5IGhhdmUgdG8gYmUgc2FtZSBzaXplXG4gICAqIEBwYXJhbXtBcnJheTxLZXk+fSAga2V5c1xuICAgKiBAcGFyYW17QXJyYXk8VmFsdWU+fVt2YWx1ZXNdXG4gICAqIEBwYXJhbXtCb29sZWFufSAgICAgW3ByZXNvcnQ9ZmFsc2VdIFByZS1zb3J0IGtleXMgYW5kIHZhbHVlcywgdXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlJ3MgY29tcGFyYXRvci4gU29ydGluZyBpcyBkb25lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4tcGxhY2VcbiAgICogQHJldHVybiB7QVZMVHJlZX1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkIChrZXlzLCB2YWx1ZXMsIHByZXNvcnQpIHtcbiAgICAgIGlmICgga2V5cyA9PT0gdm9pZCAwICkga2V5cyA9IFtdO1xuICAgICAgaWYgKCB2YWx1ZXMgPT09IHZvaWQgMCApIHZhbHVlcyA9IFtdO1xuICAgICAgaWYgKCBwcmVzb3J0ID09PSB2b2lkIDAgKSBwcmVzb3J0ID0gZmFsc2U7XG5cbiAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcblxuICAgIC8vIHNvcnQgaWYgbmVlZGVkXG4gICAgaWYgKHByZXNvcnQpIHsgc29ydChrZXlzLCB2YWx1ZXMsIDAsIHNpemUgLSAxLCBjb21wYXJhdG9yKTsgfVxuXG4gICAgaWYgKHRoaXMuX3Jvb3QgPT09IG51bGwpIHsgLy8gZW1wdHkgdHJlZVxuICAgICAgdGhpcy5fcm9vdCA9IGxvYWRSZWN1cnNpdmUodGhpcy5fcm9vdCwga2V5cywgdmFsdWVzLCAwLCBzaXplKTtcbiAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIH0gZWxzZSB7IC8vIHRoYXQgcmUtYnVpbGRzIHRoZSB3aG9sZSB0cmVlIGZyb20gdHdvIGluLW9yZGVyIHRyYXZlcnNhbHNcbiAgICAgIHZhciBtZXJnZWRMaXN0ID0gbWVyZ2VMaXN0cyh0aGlzLnRvTGlzdCgpLCBjcmVhdGVMaXN0KGtleXMsIHZhbHVlcyksIGNvbXBhcmF0b3IpO1xuICAgICAgc2l6ZSA9IHRoaXMuX3NpemUgKyBzaXplO1xuICAgICAgdGhpcy5fcm9vdCA9IHNvcnRlZExpc3RUb0JTVCh7IGhlYWQ6IG1lcmdlZExpc3QgfSwgMCwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7IHJldHVybiB0aGlzLl9yb290ID09PSBudWxsOyB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5zaXplLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NpemU7IH07XG5cblxuICAvKipcbiAgICogQHBhcmFte05vZGVQcmludGVyPX0gcHJpbnROb2RlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKHByaW50Tm9kZSkge1xuICAgICAgaWYgKCBwcmludE5vZGUgPT09IHZvaWQgMCApIHByaW50Tm9kZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLmtleTsgfTtcblxuICAgIHZhciBvdXQgPSBbXTtcbiAgICBwcmludFJvdyh0aGlzLl9yb290LCAnJywgdHJ1ZSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG91dC5wdXNoKHYpOyB9LCBwcmludE5vZGUpO1xuICAgIHJldHVybiBvdXQuam9pbignJyk7XG4gIH07XG5cblxuICBUcmVlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGtleSwgbmV3S2V5LCBuZXdEYXRhKSB7XG4gICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgIHZhciByZWYgPSBzcGxpdChrZXksIHRoaXMuX3Jvb3QsIGNvbXBhcmF0b3IpO1xuICAgICAgdmFyIGxlZnQgPSByZWYubGVmdDtcbiAgICAgIHZhciByaWdodCA9IHJlZi5yaWdodDtcbiAgICB0aGlzLl9zaXplLS07XG4gICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuZXdLZXkpIDwgMCkge1xuICAgICAgcmlnaHQgPSBpbnNlcnQobmV3S2V5LCBuZXdEYXRhLCByaWdodCwgY29tcGFyYXRvciwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBpbnNlcnQobmV3S2V5LCBuZXdEYXRhLCBsZWZ0LCBjb21wYXJhdG9yLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcm9vdCA9IG1lcmdlKGxlZnQsIHJpZ2h0LCBjb21wYXJhdG9yKTtcbiAgfTtcblxuXG4gIFRyZWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQkMSAoa2V5KSB7XG4gICAgcmV0dXJuIHNwbGl0KGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRyZWUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuXG4gIGZ1bmN0aW9uIGxvYWRSZWN1cnNpdmUgKHBhcmVudCwga2V5cywgdmFsdWVzLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHNpemUgPSBlbmQgLSBzdGFydDtcbiAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgIHZhciBtaWRkbGUgPSBzdGFydCArIE1hdGguZmxvb3Ioc2l6ZSAvIDIpO1xuICAgICAgdmFyIGtleSAgICA9IGtleXNbbWlkZGxlXTtcbiAgICAgIHZhciBkYXRhICAgPSB2YWx1ZXNbbWlkZGxlXTtcbiAgICAgIHZhciBub2RlICAgPSB7IGtleToga2V5LCBkYXRhOiBkYXRhLCBwYXJlbnQ6IHBhcmVudCB9O1xuICAgICAgbm9kZS5sZWZ0ICAgID0gbG9hZFJlY3Vyc2l2ZShub2RlLCBrZXlzLCB2YWx1ZXMsIHN0YXJ0LCBtaWRkbGUpO1xuICAgICAgbm9kZS5yaWdodCAgID0gbG9hZFJlY3Vyc2l2ZShub2RlLCBrZXlzLCB2YWx1ZXMsIG1pZGRsZSArIDEsIGVuZCk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxpc3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgdmFyIGhlYWQgPSB7IG5leHQ6IG51bGwgfTtcbiAgICB2YXIgcCA9IGhlYWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwID0gcC5uZXh0ID0geyBrZXk6IGtleXNbaV0sIGRhdGE6IHZhbHVlc1tpXSB9O1xuICAgIH1cbiAgICBwLm5leHQgPSBudWxsO1xuICAgIHJldHVybiBoZWFkLm5leHQ7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHRvTGlzdCAocm9vdCkge1xuICAgIHZhciBjdXJyZW50ID0gcm9vdDtcbiAgICB2YXIgUSA9IFtdLCBkb25lID0gZmFsc2U7XG5cbiAgICB2YXIgaGVhZCA9IHsgbmV4dDogbnVsbCB9O1xuICAgIHZhciBwID0gaGVhZDtcblxuICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBwID0gcC5uZXh0ID0gUS5wb3AoKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfSBlbHNlIHsgZG9uZSA9IHRydWU7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcC5uZXh0ID0gbnVsbDsgLy8gdGhhdCdsbCB3b3JrIGV2ZW4gaWYgdGhlIHRyZWUgd2FzIGVtcHR5XG4gICAgcmV0dXJuIGhlYWQubmV4dDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gc29ydGVkTGlzdFRvQlNUKGxpc3QsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xuICAgIGlmIChzaXplID4gMCkge1xuICAgICAgdmFyIG1pZGRsZSA9IHN0YXJ0ICsgTWF0aC5mbG9vcihzaXplIC8gMik7XG4gICAgICB2YXIgbGVmdCA9IHNvcnRlZExpc3RUb0JTVChsaXN0LCBzdGFydCwgbWlkZGxlKTtcblxuICAgICAgdmFyIHJvb3QgPSBsaXN0LmhlYWQ7XG4gICAgICByb290LmxlZnQgPSBsZWZ0O1xuXG4gICAgICBsaXN0LmhlYWQgPSBsaXN0LmhlYWQubmV4dDtcblxuICAgICAgcm9vdC5yaWdodCA9IHNvcnRlZExpc3RUb0JTVChsaXN0LCBtaWRkbGUgKyAxLCBlbmQpO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cblxuICBmdW5jdGlvbiBtZXJnZUxpc3RzIChsMSwgbDIsIGNvbXBhcmUpIHtcbiAgICBpZiAoIGNvbXBhcmUgPT09IHZvaWQgMCApIGNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH07XG5cbiAgICB2YXIgaGVhZCA9IHt9OyAvLyBkdW1teVxuICAgIHZhciBwID0gaGVhZDtcblxuICAgIHZhciBwMSA9IGwxO1xuICAgIHZhciBwMiA9IGwyO1xuXG4gICAgd2hpbGUgKHAxICE9PSBudWxsICYmIHAyICE9PSBudWxsKSB7XG4gICAgICBpZiAoY29tcGFyZShwMS5rZXksIHAyLmtleSkgPCAwKSB7XG4gICAgICAgIHAubmV4dCA9IHAxO1xuICAgICAgICBwMSA9IHAxLm5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBwMjtcbiAgICAgICAgcDIgPSBwMi5uZXh0O1xuICAgICAgfVxuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICBpZiAocDEgIT09IG51bGwpICAgICAgeyBwLm5leHQgPSBwMTsgfVxuICAgIGVsc2UgaWYgKHAyICE9PSBudWxsKSB7IHAubmV4dCA9IHAyOyB9XG5cbiAgICByZXR1cm4gaGVhZC5uZXh0O1xuICB9XG5cblxuICBmdW5jdGlvbiBzb3J0KGtleXMsIHZhbHVlcywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcbiAgICBpZiAobGVmdCA+PSByaWdodCkgeyByZXR1cm47IH1cblxuICAgIHZhciBwaXZvdCA9IGtleXNbKGxlZnQgKyByaWdodCkgPj4gMV07XG4gICAgdmFyIGkgPSBsZWZ0IC0gMTtcbiAgICB2YXIgaiA9IHJpZ2h0ICsgMTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBkbyB7IGkrKzsgfSB3aGlsZSAoY29tcGFyZShrZXlzW2ldLCBwaXZvdCkgPCAwKTtcbiAgICAgIGRvIHsgai0tOyB9IHdoaWxlIChjb21wYXJlKGtleXNbal0sIHBpdm90KSA+IDApO1xuICAgICAgaWYgKGkgPj0gaikgeyBicmVhazsgfVxuXG4gICAgICB2YXIgdG1wID0ga2V5c1tpXTtcbiAgICAgIGtleXNbaV0gPSBrZXlzW2pdO1xuICAgICAga2V5c1tqXSA9IHRtcDtcblxuICAgICAgdG1wID0gdmFsdWVzW2ldO1xuICAgICAgdmFsdWVzW2ldID0gdmFsdWVzW2pdO1xuICAgICAgdmFsdWVzW2pdID0gdG1wO1xuICAgIH1cblxuICAgIHNvcnQoa2V5cywgdmFsdWVzLCAgbGVmdCwgICAgIGosIGNvbXBhcmUpO1xuICAgIHNvcnQoa2V5cywgdmFsdWVzLCBqICsgMSwgcmlnaHQsIGNvbXBhcmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRRdWV1ZShieVkpIHtcbiAgICB2YXIgcSA9IG5ldyBUcmVlKGJ5WSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNFbXB0eTogaXNFbXB0eSxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBwb3A6IHBvcCxcbiAgICAgIGZpbmQ6IGZpbmQsXG4gICAgICBpbnNlcnQ6IGluc2VydFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmQocCkge1xuICAgICAgcmV0dXJuIHEuZmluZChwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaXplKCkge1xuICAgICAgcmV0dXJuIHEuc2l6ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHEuaXNFbXB0eSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydChldmVudCkge1xuICAgICAgLy8gZGVidWdnZXI7XG4gICAgICBxLmFkZChldmVudC5wb2ludCwgZXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAgIHZhciBub2RlID0gcS5wb3AoKTtcbiAgICAgIHJldHVybiBub2RlICYmIG5vZGUuZGF0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSnVzdCBhIGNvbGxlY3Rpb24gb2YgZ2VvbWV0cnkgcmVsYXRlZCB1dGlsaXRpZXNcbiAgICovXG5cbiAgLy8gVGhpcyBpcyB1c2VkIGZvciBwcmVjaXNpb24gY2hlY2tpbmcgKGUuZy4gdHdvIG51bWJlcnMgYXJlIGVxdWFsXG4gIC8vIGlmIHRoZWlyIGRpZmZlcmVuY2UgaXMgc21hbGxlciB0aGFuIHRoaXMgbnVtYmVyKS4gVGhlIHZhbHVlIGlzIFxuICAvLyBjaG9zZW4gZW1waXJpY2FsbHkuIFdlIHN0aWxsIG1heSBydW4gaW50byBwcmVjaXNpb24gcmVsYXRlZCBpc3N1ZXMuXG4gIC8vIFRPRE86IHdlIHNob3VsZCBhbGxvdyBjb25zdW1lcnMgdG8gY29uZmlndXJlIHRoaXMuXG4gIHZhciBFUFMgPSAxZS05Oy8vMTA7XG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KHNlZ21lbnQsIHhQb3MsIHlQb3MpIHtcbiAgICB2YXIgZHkxID0gc2VnbWVudC5mcm9tLnkgLSB5UG9zO1xuICAgIHZhciBkeTIgPSB5UG9zIC0gc2VnbWVudC50by55O1xuICAgIHZhciBkeSA9IHNlZ21lbnQudG8ueSAtIHNlZ21lbnQuZnJvbS55O1xuICAgIGlmIChNYXRoLmFicyhkeTEpIDwgRVBTKSB7XG4gICAgICAvLyBUaGUgc2VnbWVudCBzdGFydHMgb24gdGhlIHN3ZWVwIGxpbmVcbiAgICAgIGlmIChNYXRoLmFicyhkeSkgPCBFUFMpIHtcbiAgICAgICAgLy8gdGhlIHNlZ21lbnQgaXMgaG9yaXpvbnRhbC4gSW50ZXJzZWN0aW9uIGlzIGF0IHRoZSBwb2ludFxuICAgICAgICBpZiAoeFBvcyA8PSBzZWdtZW50LmZyb20ueCkgeyByZXR1cm4gc2VnbWVudC5mcm9tLng7IH1cbiAgICAgICAgaWYgKHhQb3MgPiBzZWdtZW50LnRvLngpIHsgcmV0dXJuIHNlZ21lbnQudG8ueDsgfVxuICAgICAgICByZXR1cm4geFBvcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWdtZW50LmZyb20ueDtcbiAgICB9XG4gICAgXG4gICAgdmFyIGR4ID0gKHNlZ21lbnQudG8ueCAtIHNlZ21lbnQuZnJvbS54KTsgXG4gICAgdmFyIHhPZmZzZXQ7IFxuICAgIGlmIChkeTEgPj0gZHkyKSB7XG4gICAgICB4T2Zmc2V0ID0gZHkxICogKGR4IC8gZHkpOyBcbiAgICAgIHJldHVybiAoc2VnbWVudC5mcm9tLnggLSB4T2Zmc2V0KTtcbiAgICB9IFxuICAgIHhPZmZzZXQgPSBkeTIgKiAoZHggLyBkeSk7XG4gICAgcmV0dXJuIChzZWdtZW50LnRvLnggKyB4T2Zmc2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuZ2xlKGR4LCBkeSkge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NTQyMDQyL2Zhc3Rlc3Qtd2F5LXRvLXNvcnQtdmVjdG9ycy1ieS1hbmdsZS13aXRob3V0LWFjdHVhbGx5LWNvbXB1dGluZy10aGF0LWFuZ2xlXG4gICAgdmFyIHAgPSBkeC8oTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKTsgLy8gLTEgLi4gMSBpbmNyZWFzaW5nIHdpdGggeFxuXG4gICAgaWYgKGR5IDwgMCkgeyByZXR1cm4gcCAtIDE7IH0gIC8vIC0yIC4uIDAgaW5jcmVhc2luZyB3aXRoIHhcbiAgICByZXR1cm4gMSAtIHAgICAgICAgICAgICAgICAvLyAgMCAuLiAyIGRlY3JlYXNpbmcgd2l0aCB4XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnNlY3RTZWdtZW50cyhhLCBiKSB7XG4gICAgLy8gIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTY4MzQ1LzEyNTM1MVxuICAgIHZhciBhU3RhcnQgPSBhLmZyb20sIGJTdGFydCA9IGIuZnJvbTtcbiAgICB2YXIgcDBfeCA9IGFTdGFydC54LCBwMF95ID0gYVN0YXJ0LnksXG4gICAgICAgIHAyX3ggPSBiU3RhcnQueCwgcDJfeSA9IGJTdGFydC55O1xuXG4gICAgdmFyIHMxX3ggPSBhLmR4LCBzMV95ID0gYS5keSwgczJfeCA9IGIuZHgsIHMyX3kgPSBiLmR5O1xuICAgIHZhciBkaXYgPSBzMV94ICogczJfeSAtIHMyX3ggKiBzMV95O1xuXG4gICAgdmFyIHMgPSAoczFfeSAqIChwMF94IC0gcDJfeCkgLSBzMV94ICogKHAwX3kgLSBwMl95KSkgLyBkaXY7XG4gICAgaWYgKHMgPCAwIHx8IHMgPiAxKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIHQgPSAoczJfeCAqIChwMl95IC0gcDBfeSkgKyBzMl95ICogKHAwX3ggLSBwMl94KSkgLyBkaXY7XG5cbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcDBfeCAtICh0ICogczFfeCksXG4gICAgICAgIHk6IHAwX3kgLSAodCAqIHMxX3kpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FtZVBvaW50KGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS54IC0gYi54KSA8IEVQUyAmJiBNYXRoLmFicyhhLnkgLSBiLnkpIDwgRVBTO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3dlZXAgc3RhdHVzIGRhdGEgc3RydWN0dXJlLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlU3dlZXBTdGF0dXMob25FcnJvciwgRVBTJCQxKSB7XG4gICAgdmFyIGxhc3RQb2ludFksIHByZXZZO1xuICAgIHZhciBsYXN0UG9pbnRYLCBwcmV2WDtcbiAgICB2YXIgdXNlQmVsb3cgPSBmYWxzZTtcbiAgICB2YXIgc3RhdHVzID0gbmV3IFRyZWUoY29tcGFyZVNlZ21lbnRzKTtcblxuICAgIC8vIFRvIHNhdmUgb24gR0Mgd2UgcmV0dXJuIG11dGFibGUgb2JqZWN0LlxuICAgIHZhciBjdXJyZW50Qm91bmRhcnkgPSB7XG4gICAgICBiZWZvcmVMZWZ0OiBudWxsLFxuICAgICAgbGVmdDogbnVsbCxcbiAgICAgIHJpZ2h0OiBudWxsLFxuICAgICAgYWZ0ZXJSaWdodDogbnVsbCxcbiAgICB9O1xuXG4gICAgdmFyIGN1cnJlbnRMZWZ0UmlnaHQgPSB7bGVmdDogbnVsbCwgcmlnaHQ6IG51bGx9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIG5ldyBzZWdtZW50cyBpbnRvIHRoZSBzdGF0dXMgdHJlZS5cbiAgICAgICAqL1xuICAgICAgaW5zZXJ0U2VnbWVudHM6IGluc2VydFNlZ21lbnRzLFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBzZWdtZW50cyBmcm9tIHRoZSBzdGF0dXMgdHJlZS5cbiAgICAgICAqL1xuICAgICAgZGVsZXRlU2VnbWVudHM6IGRlbGV0ZVNlZ21lbnRzLFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgc2VnbWVudHMgdGhhdCBhcmUgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IGZyb20gYSBnaXZlbiBwb2ludC5cbiAgICAgICAqL1xuICAgICAgZ2V0TGVmdFJpZ2h0UG9pbnQ6IGdldExlZnRSaWdodFBvaW50LFxuXG4gICAgICAvKipcbiAgICAgICAqIEZvciBhIGdpdmVuIGNvbGxlY3Rpb25zIG9mIHNlZ21lbnRzIGZpbmRzIHRoZSBtb3N0IGxlZnQgYW5kIHRoZSBtb3N0IHJpZ2h0XG4gICAgICAgKiBzZWdtZW50cy4gQWxzbyByZXR1cm5zIHNlZ21lbnRzIGltbWVkaWF0ZWx5IGJlZm9yZSBsZWZ0LCBhbmQgYWZ0ZXIgcmlnaHQgc2VnbWVudHMuXG4gICAgICAgKi9cbiAgICAgIGdldEJvdW5kYXJ5U2VnbWVudHM6IGdldEJvdW5kYXJ5U2VnbWVudHMsXG5cbiAgICAgIGZpbmRTZWdtZW50c1dpdGhQb2ludDogZmluZFNlZ21lbnRzV2l0aFBvaW50LFxuXG4gICAgICAvKipcbiAgICAgICAqIEN1cnJlbnQgYmluYXJ5IHNlYXJjaCB0cmVlIHdpdGggc2VnbWVudHNcbiAgICAgICAqL1xuICAgICAgc3RhdHVzOiBzdGF0dXMsXG5cbiAgICAgIC8qKlxuICAgICAgICogSW50cm9zcGVjdGlvbiBtZXRob2QgdGhhdCB2ZXJpZmllcyBpZiB0aGVyZSBhcmUgZHVwbGljYXRlcyBpbiB0aGUgc2VnbWVudCB0cmVlLlxuICAgICAgICogSWYgdGhlcmUgYXJlIC0gYG9uRXJyb3IoKWAgaXMgY2FsbGVkLlxuICAgICAgICovXG4gICAgICBjaGVja0R1cGxpY2F0ZTogY2hlY2tEdXBsaWNhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJpbnRzIGN1cnJlbnQgc2VnbWVudHMgaW4gb3JkZXIgb2YgdGhlaXIgaW50ZXJzZWN0aW9uIHdpdGggc3dlZXAgbGluZS4gSW50cm9zcGVjdGlvbiBtZXRob2QuXG4gICAgICAgKi9cbiAgICAgIHByaW50U3RhdHVzOiBwcmludFN0YXR1cyxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHN3ZWVwIGxpbmUuXG4gICAgICAgKi9cbiAgICAgIGdldExhc3RQb2ludDogZnVuY3Rpb24gZ2V0TGFzdFBvaW50KCkge1xuICAgICAgICByZXR1cm4ge3g6IGxhc3RQb2ludFgsIHk6IGxhc3RQb2ludFl9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVTZWdtZW50cyhhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gYikgeyByZXR1cm4gMDsgfVxuXG4gICAgICB2YXIgYWsgPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoYSwgbGFzdFBvaW50WCwgbGFzdFBvaW50WSk7XG4gICAgICB2YXIgYmsgPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoYiwgbGFzdFBvaW50WCwgbGFzdFBvaW50WSk7XG5cbiAgICAgIHZhciByZXMgPSBhayAtIGJrO1xuICAgICAgaWYgKE1hdGguYWJzKHJlcykgPj0gRVBTJCQxKSB7XG4gICAgICAgIC8vIFdlIGFyZSBva2F5IGZpbmUuIEludGVyc2VjdGlvbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzZWdtZW50c1xuICAgICAgICAvLyBpcyBnb29kIHRvIGdpdmUgY29uY2x1c2l2ZSBhbnN3ZXJcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgdmFyIGFJc0hvcml6b250YWwgPSBNYXRoLmFicyhhLmR5KSA8IEVQUyQkMTtcbiAgICAgIHZhciBiSXNIb3Jpem9udGFsID0gTWF0aC5hYnMoYi5keSkgPCBFUFMkJDE7XG4gICAgICBpZiAoYUlzSG9yaXpvbnRhbCAmJiBiSXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiBiLnRvLnggLSBhLnRvLng7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBXaGF0IGlmIGJvdGggYSBhbmQgYiBpcyBob3Jpem9udGFsP1xuICAgICAgLy8gbW92ZSBob3Jpem9udGFsIHRvIGVuZFxuICAgICAgaWYgKGFJc0hvcml6b250YWwpIHsgXG4gICAgICAgIHJldHVybiB1c2VCZWxvdyA/IC0xIDogMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJJc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKHVzZUJlbG93KSB7XG4gICAgICAgICAgcmV0dXJuIChiLmZyb20ueCA+PSBsYXN0UG9pbnRYKSA/IC0xIDogMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgLy8gcmV0dXJuIHVzZUJlbG93ID8gMSA6IC0xO1xuICAgICAgfVxuICAgICAgdmFyIHBhID0gYS5hbmdsZTtcbiAgICAgIHZhciBwYiA9IGIuYW5nbGU7XG4gICAgICBpZiAoTWF0aC5hYnMocGEgLSBwYikgPj0gRVBTJCQxKSB7XG4gICAgICAgIHJldHVybiB1c2VCZWxvdyA/IHBhIC0gcGIgOiBwYiAtIHBhO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VnRGlzdCA9IGEuZnJvbS55IC0gYi5mcm9tLnk7XG4gICAgICBpZiAoTWF0aC5hYnMoc2VnRGlzdCkgPj0gRVBTJCQxKSB7XG4gICAgICAgIHJldHVybiAtc2VnRGlzdDtcbiAgICAgIH1cbiAgICAgIHNlZ0Rpc3QgPSBhLnRvLnkgLSBiLnRvLnk7XG4gICAgICBpZiAoTWF0aC5hYnMoc2VnRGlzdCkgPj0gRVBTJCQxKSB7XG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgYWNjdXJhdGU/XG4gICAgICAgIHJldHVybiAtc2VnRGlzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgICAvLyBDb3VsZCBhbHNvIHVzZTpcbiAgICAgIC8vIHZhciBhQW5nbGUgPSBNYXRoLmF0YW4yKGEuZnJvbS55IC0gYS50by55LCBhLmZyb20ueCAtIGEudG8ueCk7XG4gICAgICAvLyB2YXIgYkFuZ2xlID0gTWF0aC5hdGFuMihiLmZyb20ueSAtIGIudG8ueSwgYi5mcm9tLnggLSBiLnRvLngpO1xuICAgICAgLy8gcmV0dXJuIHVzZUJlbG93ID8gYkFuZ2xlIC0gYUFuZ2xlIDogYUFuZ2xlIC0gYkFuZ2xlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvdW5kYXJ5U2VnbWVudHModXBwZXIsIGludGVyaW9yKSB7XG4gICAgICB2YXIgbGVmdE1vc3QsIHJpZ2h0TW9zdCwgaTtcbiAgICAgIHZhciB1TGVuZ3RoID0gdXBwZXIubGVuZ3RoO1xuXG4gICAgICBpZiAodUxlbmd0aCA+IDApIHtcbiAgICAgICAgbGVmdE1vc3QgPSByaWdodE1vc3QgPSB1cHBlclswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnRNb3N0ID0gcmlnaHRNb3N0ID0gaW50ZXJpb3JbMF07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCB1TGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSB1cHBlcltpXTtcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVTZWdtZW50cyhsZWZ0TW9zdCwgcyk7XG4gICAgICAgIGlmIChjbXAgPiAwKSB7IGxlZnRNb3N0ID0gczsgfVxuXG4gICAgICAgIGNtcCA9IGNvbXBhcmVTZWdtZW50cyhyaWdodE1vc3QsIHMpO1xuICAgICAgICBpZiAoY21wIDwgMCkgeyByaWdodE1vc3QgPSBzOyB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEZyb20gPSB1TGVuZ3RoID4gMCA/IDAgOiAxO1xuICAgICAgZm9yIChpID0gc3RhcnRGcm9tOyBpIDwgaW50ZXJpb3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcyA9IGludGVyaW9yW2ldO1xuICAgICAgICBjbXAgPSBjb21wYXJlU2VnbWVudHMobGVmdE1vc3QsIHMpO1xuICAgICAgICBpZiAoY21wID4gMCkgeyBsZWZ0TW9zdCA9IHM7IH1cblxuICAgICAgICBjbXAgPSBjb21wYXJlU2VnbWVudHMocmlnaHRNb3N0LCBzKTtcbiAgICAgICAgaWYgKGNtcCA8IDApIHsgcmlnaHRNb3N0ID0gczsgfVxuICAgICAgfVxuXG4gICAgICAvLyBhdCB0aGlzIHBvaW50IHdlIGhhdmUgb3VyIGxlZnQvcmlnaHQgc2VnbWVudHMgaW4gdGhlIHN0YXR1cy5cbiAgICAgIC8vIExldCdzIGZpbmQgdGhlaXIgcHJldi9uZXh0IGVsZW1lbnRzIGFuZCByZXBvcnQgdGhlbSBiYWNrOlxuICAgICAgdmFyIGxlZnQgPSBzdGF0dXMuZmluZChsZWZ0TW9zdCk7XG4gICAgICBpZiAoIWxlZnQpIHtcbiAgICAgICAgb25FcnJvcignTGVmdCBpcyBtaXNzaW5nLiBQcmVjaXNpb24gZXJyb3I/Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByaWdodCA9IHN0YXR1cy5maW5kKHJpZ2h0TW9zdCk7XG4gICAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgIG9uRXJyb3IoJ1JpZ2h0IGlzIG1pc3NpbmcuIFByZWNpc2lvbiBlcnJvcj8nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJlZm9yZUxlZnQgPSBsZWZ0ICYmIHN0YXR1cy5wcmV2KGxlZnQpO1xuICAgICAgdmFyIGFmdGVyUmlnaHQgPSByaWdodCAmJiBzdGF0dXMubmV4dChyaWdodCk7XG5cbiAgICAgIHdoaWxlIChhZnRlclJpZ2h0ICYmIHJpZ2h0LmtleS5keSA9PT0gMCAmJiBhZnRlclJpZ2h0LmtleS5keSA9PT0gMCkge1xuICAgICAgICAvLyBob3Jpem9udGFsIHNlZ21lbnRzIGFyZSBzcGVjaWFsIDooXG4gICAgICAgIGFmdGVyUmlnaHQgPSBzdGF0dXMubmV4dChhZnRlclJpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudEJvdW5kYXJ5LmJlZm9yZUxlZnQgPSBiZWZvcmVMZWZ0ICYmIGJlZm9yZUxlZnQua2V5O1xuICAgICAgY3VycmVudEJvdW5kYXJ5LmxlZnQgPSBsZWZ0ICYmIGxlZnQua2V5O1xuICAgICAgY3VycmVudEJvdW5kYXJ5LnJpZ2h0ID0gcmlnaHQgJiYgcmlnaHQua2V5O1xuICAgICAgY3VycmVudEJvdW5kYXJ5LmFmdGVyUmlnaHQgPSBhZnRlclJpZ2h0ICYmIGFmdGVyUmlnaHQua2V5O1xuXG4gICAgICByZXR1cm4gY3VycmVudEJvdW5kYXJ5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldExlZnRSaWdodFBvaW50KHApIHtcbiAgICAgIC8vIFdlIGFyZSB0cnlpbmcgdG8gZmluZCBsZWZ0IGFuZCByaWdodCBzZWdtZW50cyB0aGF0IGFyZSBuZWFyZXN0IHRvIHRoZVxuICAgICAgLy8gcG9pbnQgcC4gRm9yIHRoaXMgd2UgdHJhdmVyc2UgdGhlIGJpbmFyeSBzZWFyY2ggdHJlZSwgYW5kIHJlbWVtYmVyXG4gICAgICAvLyBub2RlIHdpdGggdGhlIHNob3J0ZXN0IGRpc3RhbmNlIHRvIHAuXG4gICAgICB2YXIgbGFzdExlZnQ7XG4gICAgICB2YXIgY3VycmVudCA9IHN0YXR1cy5fcm9vdDtcbiAgICAgIHZhciBtaW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoY3VycmVudC5rZXksIHAueCwgcC55KTtcbiAgICAgICAgdmFyIGR4ID0gcC54IC0geDtcbiAgICAgICAgaWYgKGR4ID49IDApIHtcbiAgICAgICAgICBpZiAoZHggPCBtaW5YKSB7XG4gICAgICAgICAgICBtaW5YID0gZHg7XG4gICAgICAgICAgICBsYXN0TGVmdCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKC1keCA8IG1pblgpIHtcbiAgICAgICAgICAgIG1pblggPSAtZHg7XG4gICAgICAgICAgICBsYXN0TGVmdCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRMZWZ0UmlnaHQubGVmdCA9IGxhc3RMZWZ0ICYmIGxhc3RMZWZ0LmtleTtcbiAgICAgIHZhciBuZXh0ID0gbGFzdExlZnQgJiYgc3RhdHVzLm5leHQobGFzdExlZnQpO1xuICAgICAgY3VycmVudExlZnRSaWdodC5yaWdodCA9IG5leHQgJiYgbmV4dC5rZXk7XG4gICAgICByZXR1cm4gY3VycmVudExlZnRSaWdodDtcblxuICAgICAgLy8gQ29uY2VwdHVhbGx5LCB0aGUgY29kZSBhYm92ZSBzaG91bGQgYmUgZXF1aXZhbGVudCB0byB0aGUgY29kZSBiZWxvdztcbiAgICAgIC8vIFRoZSBjb2RlIGJlbG93IGlzIGVhc2llciB0byB1bmRlcnN0YW5kLCBidXQgaW50dWl0aXZlbHksIHRoZSBjb2RlIGFib3ZlXG4gICAgICAvLyBzaG91bGQgaGF2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UgKGFzIHdlIGRvIG5vdCB0cmF2ZXJzZSB0aGUgZW50aXJlIHN0YXR1c1xuICAgICAgLy8gdHJlZSlcblxuICAgICAgLy8gdmFyIHJpZ2h0LCBsZWZ0LCAgeDtcbiAgICAgIC8vIHZhciBhbGwgPSBzdGF0dXMua2V5cygpXG4gICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gICB2YXIgc2VnbWVudCA9IGFsbFtpXTtcbiAgICAgIC8vICAgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChzZWdtZW50LCBwLngsIHAueSk7XG4gICAgICAvLyAgIGlmICh4ID4gcC54ICYmICFyaWdodCkge1xuICAgICAgLy8gICAgIHJpZ2h0ID0gc2VnbWVudDtcbiAgICAgIC8vICAgICBicmVhaztcbiAgICAgIC8vICAgfSBlbHNlIGlmICh4IDwgcC54KSB7XG4gICAgICAvLyAgICAgbGVmdCA9IHNlZ21lbnQ7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgLy8gY3VycmVudExlZnRSaWdodC5sZWZ0ID0gbGVmdDtcbiAgICAgIC8vIGN1cnJlbnRMZWZ0UmlnaHQucmlnaHQgPSByaWdodDtcblxuICAgICAgLy8gcmV0dXJuIGN1cnJlbnRMZWZ0UmlnaHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZFNlZ21lbnRzV2l0aFBvaW50KHAsIG9uRm91bmQpIHtcbiAgICAgIC8vIE9wdGlvbiAxLlxuICAgICAgLy8gdmFyIGFyclJlc3VsdHMgPSBbXTtcbiAgICAgIC8vIHN0YXR1cy5mb3JFYWNoKGN1cnJlbnQgPT4ge1xuICAgICAgLy8gICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChjdXJyZW50LmtleSwgcC54LCBwLnkpO1xuICAgICAgLy8gICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgLy8gICBpZiAoTWF0aC5hYnMoZHgpIDwgRVBTKSB7XG4gICAgICAvLyAgICAgb25Gb3VuZChjdXJyZW50LmtleSk7XG4gICAgICAvLyAgICAvLyBhcnJSZXN1bHRzLnB1c2goY3VycmVudC5rZXkpXG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH0pO1xuICAgICAgLy8gcmV0dXJuIGFyclJlc3VsdHM7XG5cbiAgICAgIC8vIE9wdGlvbiAyLlxuXG4gICAgICAvLyBsZXQgY3VycmVudCA9IHN0YXR1cy5fcm9vdDtcbiAgICAgIC8vIGNvbnN0IFEgPSBbXTsgIC8qIEluaXRpYWxpemUgc3RhY2sgcyAqL1xuICAgICAgLy8gbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgIC8vIHZhciByZXMgPSBbXTtcbiAgICAgIC8vIHZhciBicmVha0Vhcmx5ID0gZmFsc2U7XG5cbiAgICAgIC8vIHdoaWxlICghZG9uZSkge1xuICAgICAgLy8gICBpZiAoY3VycmVudCAhPT0gIG51bGwpIHtcbiAgICAgIC8vICAgICBRLnB1c2goY3VycmVudCk7XG4gICAgICAvLyAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgIC8vICAgICBpZiAoUS5sZW5ndGggIT09IDApIHtcbiAgICAgIC8vICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xuXG4gICAgICAvLyAgICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChjdXJyZW50LmtleSwgcC54LCBwLnkpO1xuICAgICAgLy8gICAgICAgdmFyIGR4ID0gcC54IC0geDtcbiAgICAgIC8vICAgICAgIGlmIChNYXRoLmFicyhkeCkgPCBFUFMpIHtcbiAgICAgIC8vICAgICAgICAgcmVzLnB1c2goY3VycmVudC5rZXkpXG4gICAgICAvLyAgICAgICAgIGJyZWFrRWFybHkgPSB0cnVlO1xuICAgICAgLy8gICAgICAgfSBlbHNlIGlmIChicmVha0Vhcmx5KSB7XG4gICAgICAvLyAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgLy8gICAgICAgfVxuXG4gICAgICAvLyAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgIC8vICAgICB9IGVsc2UgZG9uZSA9IHRydWU7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgLy8gcmV0dXJuIHJlcztcblxuICAgICAgLy8gb3B0aW9uIDMuXG4gICAgICB2YXIgY3VycmVudCA9IHN0YXR1cy5fcm9vdDtcblxuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoY3VycmVudC5rZXksIHAueCwgcC55KTtcbiAgICAgICAgdmFyIGR4ID0gcC54IC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQUyQkMSkge1xuICAgICAgICAgIGNvbGxlY3RBZGphY2VudE5vZGVzKGN1cnJlbnQsIHAsIG9uRm91bmQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGR4IDwgMCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0QWRqYWNlbnROb2Rlcyhyb290LCBwLCBvbkZvdW5kKSB7XG4gICAgICBvbkZvdW5kKHJvb3Qua2V5KTtcbiAgICAgIGdvT3ZlclByZWRlY2Vzc29ycyhyb290LmxlZnQsIHAsIG9uRm91bmQpO1xuICAgICAgZ29PdmVyU3VjY2Vzc29ycyhyb290LnJpZ2h0LCBwLCBvbkZvdW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb092ZXJQcmVkZWNlc3NvcnMocm9vdCwgcCwgcmVzKSB7XG4gICAgICBpZiAoIXJvb3QpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChyb290LmtleSwgcC54LCBwLnkpO1xuICAgICAgdmFyIGR4ID0gcC54IC0geDtcbiAgICAgIGlmIChNYXRoLmFicyhkeCkgPCBFUFMkJDEpIHtcbiAgICAgICAgY29sbGVjdEFkamFjZW50Tm9kZXMocm9vdCwgcCwgcmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvT3ZlclByZWRlY2Vzc29ycyhyb290LnJpZ2h0LCBwLCByZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvT3ZlclN1Y2Nlc3NvcnMocm9vdCwgcCwgcmVzKSB7XG4gICAgICBpZiAoIXJvb3QpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChyb290LmtleSwgcC54LCBwLnkpO1xuICAgICAgdmFyIGR4ID0gcC54IC0geDtcbiAgICAgIGlmIChNYXRoLmFicyhkeCkgPCBFUFMkJDEpIHtcbiAgICAgICAgY29sbGVjdEFkamFjZW50Tm9kZXMocm9vdCwgcCwgcmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvT3ZlclN1Y2Nlc3NvcnMocm9vdC5sZWZ0LCBwLCByZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlKCkge1xuICAgICAgdmFyIHByZXY7XG4gICAgICBzdGF0dXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IG5vZGUua2V5O1xuXG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgaWYgKHNhbWVQb2ludChwcmV2LmZyb20sIGN1cnJlbnQuZnJvbSkgJiYgc2FtZVBvaW50KHByZXYudG8sIGN1cnJlbnQudG8pKSB7XG4gICAgICAgICAgICAvLyBMaWtlbHkgeW91IGhhdmUgcmVjZWl2ZWQgZXJyb3IgYmVmb3JlIGR1cmluZyBzZWdtZW50IHJlbW92YWwuXG4gICAgICAgICAgICBvbkVycm9yKCdEdXBsaWNhdGUga2V5IGluIHRoZSBzdGF0dXMhIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBGbG9hdGluZyBQb2ludCByb3VuZGluZyBlcnJvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50U3RhdHVzKHByZWZpeCkge1xuICAgICAgaWYgKCBwcmVmaXggPT09IHZvaWQgMCApIHByZWZpeCA9ICcnO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGNvbnNvbGUubG9nKHByZWZpeCwgJ3N0YXR1cyBsaW5lOiAnLCBsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcbiAgICAgIHN0YXR1cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KG5vZGUua2V5LCBsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnNvbGUubG9nKHggKyAnICcgKyBub2RlLmtleS5uYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydFNlZ21lbnRzKGludGVyaW9yLCB1cHBlciwgc3dlZXBMaW5lUG9zKSB7XG4gICAgICBsYXN0UG9pbnRZID0gc3dlZXBMaW5lUG9zLnk7XG4gICAgICBsYXN0UG9pbnRYID0gc3dlZXBMaW5lUG9zLng7XG4gICAgICB2YXIga2V5O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVyaW9yLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGtleSA9IGludGVyaW9yW2ldO1xuICAgICAgICBzdGF0dXMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdXBwZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAga2V5ID0gdXBwZXJbaV07XG4gICAgICAgIHN0YXR1cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxldGVTZWdtZW50cyhsb3dlciwgaW50ZXJpb3IsIHN3ZWVwTGluZVBvcykge1xuICAgICAgLy8gSSBzcGVudCBtb3N0IG9mIHRoZSB0aW1lIGRlYnVnZ2luZyB0aGlzIG1ldGhvZC4gRGVwZW5kaW5nIG9uIHRoZVxuICAgICAgLy8gYWxnb3JpdGhtIHN0YXRlIHdlIGNhbiBydW4gaW50byBzaXR1YXRpb24gd2hlbiBkeW5hbWljIGtleXMgb2YgdGhlXG4gICAgICAvLyBgc3RhdHVzYCB0cmVlIHByZWRpY3Qgd3JvbmcgYnJhbmNoLCBhbmQgdGh1cyB3ZSBhcmUgbm90IGFibGUgdG8gZmluZFxuICAgICAgLy8gdGhlIHNlZ21lbnQgdGhhdCBuZWVkcyB0byBiZSBkZWxldGVkLiBJZiB0aGF0IGhhcHBlbnMgSSdtIHRyeWluZyB0b1xuICAgICAgLy8gdXNlIHByZXZpb3VzIHBvaW50IGFuZCByZXBlYXQgdGhlIHByb2Nlc3MuIFRoaXMgbWF5IHJlc3VsdCBpbiBcbiAgICAgIC8vIGluY29ycmVjdCBzdGF0ZS4gSW4gdGhhdCBjYXNlIEkgcmVwb3J0IGFuIGVycm9yLiBcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHByZXZDb3VudCA9IHN0YXR1cy5fc2l6ZTtcbiAgICAgIHByZXZYID0gbGFzdFBvaW50WDtcbiAgICAgIHByZXZZID0gbGFzdFBvaW50WTtcbiAgICAgIGxhc3RQb2ludFkgPSBzd2VlcExpbmVQb3MueTtcbiAgICAgIGxhc3RQb2ludFggPSBzd2VlcExpbmVQb3MueDtcblxuICAgICAgdXNlQmVsb3cgPSB0cnVlO1xuICAgICAgZm9yKGkgPSAwOyBpIDwgbG93ZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVtb3ZlU2VnbWVudChsb3dlcltpXSwgc3dlZXBMaW5lUG9zKTtcbiAgICAgIH1cbiAgICAgIGZvcihpID0gMDsgaSA8IGludGVyaW9yLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlbW92ZVNlZ21lbnQoaW50ZXJpb3JbaV0sIHN3ZWVwTGluZVBvcyk7XG4gICAgICB9XG4gICAgICB1c2VCZWxvdyA9IGZhbHNlO1xuXG4gICAgICBpZiAoc3RhdHVzLl9zaXplICE9PSBwcmV2Q291bnQgLSBpbnRlcmlvci5sZW5ndGggLSBsb3dlci5sZW5ndGgpIHtcbiAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gcm91bmRpbmcgZXJyb3Igb2NjdXJzLiBZb3UgY2FuIHRyeSBzY2FsaW5nIHlvdXIgaW5wdXRcbiAgICAgICAgb25FcnJvcignU2VnbWVudHMgd2VyZSBub3QgcmVtb3ZlZCBmcm9tIGEgdHJlZSBwcm9wZXJseS4gUHJlY2lzaW9uIGVycm9yPycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVNlZ21lbnQoa2V5LCBzd2VlcExpbmVQb3MpIHtcbiAgICAgIGlmIChzdGF0dXMuZmluZChrZXkpKSB7XG4gICAgICAgIHN0YXR1cy5yZW1vdmUoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RQb2ludFggPSBwcmV2WDtcbiAgICAgICAgbGFzdFBvaW50WSA9IHByZXZZO1xuICAgICAgICBpZiAoc3RhdHVzLmZpbmQoa2V5KSkge1xuICAgICAgICAgIHN0YXR1cy5yZW1vdmUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UG9pbnRZID0gc3dlZXBMaW5lUG9zLnk7XG4gICAgICAgIGxhc3RQb2ludFggPSBzd2VlcExpbmVQb3MueDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNpbmdsZSBldmVudCBpbiB0aGUgc3dlZXAtbGluZSBhbGdvcml0aG1cbiAgICovXG4gIHZhciBTd2VlcEV2ZW50ID0gZnVuY3Rpb24gU3dlZXBFdmVudChwb2ludCwgc2VnbWVudCkge1xuICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICBpZiAoc2VnbWVudCkgeyB0aGlzLmZyb20gPSBbc2VnbWVudF07IH1cbiAgfTtcblxuICAvKipcbiAgICogQSBwb2ludCBvbiBhIGxpbmVcbiAgICogXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFBvaW50XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IGNvb3JkaW5hdGVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHkgY29vcmRpbmF0ZVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTZWdtZW50IFxuICAgKiBAcHJvcGVydHkge1BvaW50fSBmcm9tIHN0YXJ0IG9mIHRoZSBzZWdtZW50XG4gICAqIEBwcm9wZXJ0eSB7UG9pbnR9IHRvIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge2Z1bmN0aW9uKHBvaW50IDogUG9pbnQsIGludGVyaW9yIDogU2VnbWVudFtdLCBsb3dlciA6IFNlZ21lbnRbXSwgdXBwZXIgOiBTZWdtZW50W10pfSBSZXBvcnRJbnRlcnNlY3Rpb25DYWxsYmFja1xuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gSVNlY3RPcHRpb25zIFxuICAgKiBAcHJvcGVydHkge1JlcG9ydEludGVyc2VjdGlvbkNhbGxiYWNrfSBvbkZvdW5kIFxuICAgKi9cblxuICAgLyoqXG4gICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJU2VjdFJlc3VsdFxuICAgICovXG5cbiAgLy8gV2UgdXNlIEVNUFRZIGFycmF5IHRvIGF2b2lkIHByZXNzdXJlIG9uIGdhcmJhZ2UgY29sbGVjdG9yLiBOZWVkIHRvIGJlXG4gIC8vIHZlcnkgY2F1dGlvdXMgdG8gbm90IG11dGF0ZSB0aGlzIGFycmF5LlxuICB2YXIgRU1QVFkgPSBbXTtcblxuICAvKipcbiAgICogRmluZHMgYWxsIGludGVyc2VjdGlvbnMgYW1vbmcgZ2l2ZW4gc2VnbWVudHMuXG4gICAqIFxuICAgKiBUaGUgYWxnb3JpdGhtIGZvbGxvd3MgXCJDb21wdXRhdGlvbiBHZW9tZXRyeSwgQWxnb3JpdGhtcyBhbmQgQXBwbGljYXRpb25zXCIgYm9va1xuICAgKiBieSBNYXJrIGRlIEJlcmcsIE90ZnJpZWQgQ2hlb25nLCBNYXJjIHZhbiBLcmV2ZWxkLCBhbmQgTWFyayBPdmVybWFycy5cbiAgICogXG4gICAqIExpbmUgaXMgc3dlcHQgdG9wLWRvd25cbiAgICogXG4gICAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICAgKiBAcGFyYW0ge0lTZWN0T3B0aW9ucz19IG9wdGlvbnNcbiAgICogQHJldHVybnMge0lTZWN0UmVzdWx0fVxuICAgKi9cbiAgZnVuY3Rpb24gaXNlY3Qoc2VnbWVudHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciByZXBvcnRJbnRlcnNlY3Rpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLm9uRm91bmQpIHx8IGRlZmF1bHRJbnRlcnNlY3Rpb25SZXBvcnRlcjtcblxuICAgIHZhciBvbkVycm9yID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5vbkVycm9yKSB8fCBkZWZhdWx0RXJyb3JSZXBvcnRlcjtcblxuICAgIHZhciBldmVudFF1ZXVlID0gY3JlYXRlRXZlbnRRdWV1ZShieVkpO1xuICAgIHZhciBzd2VlcFN0YXR1cyA9IGNyZWF0ZVN3ZWVwU3RhdHVzKG9uRXJyb3IsIEVQUyk7XG4gICAgdmFyIGxvd2VyLCBpbnRlcmlvciwgbGFzdFBvaW50O1xuXG4gICAgc2VnbWVudHMuZm9yRWFjaChhZGRTZWdtZW50KTtcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgYWxsIGludGVyc2VjdGlvbnMgc3luY2hyb25vdXNseS5cbiAgICAgICAqIFxuICAgICAgICogQHJldHVybnMgYXJyYXkgb2YgZm91bmQgaW50ZXJzZWN0aW9ucy5cbiAgICAgICAqL1xuICAgICAgcnVuOiBydW4sXG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybXMgYSBzaW5nbGUgc3RlcCBpbiB0aGUgc3dlZXAgbGluZSBhbGdvcml0aG1cbiAgICAgICAqIFxuICAgICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIHRvIHByb2Nlc3M7IEZhbHNlIGlmIG5vIG1vcmUgd29yayB0byBkb1xuICAgICAgICovXG4gICAgICBzdGVwOiBzdGVwLFxuXG4gICAgICAvLyBNZXRob2RzIGJlbG93IGFyZSBsb3cgbGV2ZWwgQVBJIGZvciBmaW5lLWdyYWluZWQgY29udHJvbC5cbiAgICAgIC8vIERvbid0IHVzZSBpdCB1bmxlc3MgeW91IHVuZGVyc3RhbmQgdGhpcyBjb2RlIHRob3JvdWdobHlcblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgc2VnbWVudCBpbnRvIHRoZSBcbiAgICAgICAqL1xuICAgICAgYWRkU2VnbWVudDogYWRkU2VnbWVudCxcblxuICAgICAgLyoqXG4gICAgICAgKiBEaXJlY3QgYWNjZXNzIHRvIGV2ZW50IHF1ZXVlLiBRdWV1ZSBjb250YWlucyBzZWdtZW50IGVuZHBvaW50cyBhbmRcbiAgICAgICAqIHBlbmRpbmcgZGV0ZWN0ZWQgaW50ZXJzZWN0aW9ucy5cbiAgICAgICAqL1xuICAgICAgZXZlbnRRdWV1ZTogZXZlbnRRdWV1ZSwgXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlyZWN0IGFjY2VzcyB0byBzd2VlcCBsaW5lIHN0YXR1cy4gXCJTdGF0dXNcIiBob2xkcyBpbmZvcm1hdGlvbiBhYm91dFxuICAgICAgICogYWxsIGludGVyc2VjdGVkIHNlZ21lbnRzLlxuICAgICAgICovXG4gICAgICBzd2VlcFN0YXR1czogc3dlZXBTdGF0dXMsXG5cbiAgICAgIC8qKlxuICAgICAgICogQWNjZXNzIHRvIHJlc3VsdHMgYXJyYXkuIFdvcmtzIG9ubHkgd2hlbiB5b3UgdXNlIGRlZmF1bHQgb25Gb3VuZCgpIGhhbmRsZXJcbiAgICAgICAqL1xuICAgICAgcmVzdWx0czogcmVzdWx0c1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHdoaWxlICghZXZlbnRRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgdmFyIGV2ZW50UG9pbnQgPSBldmVudFF1ZXVlLnBvcCgpO1xuICAgICAgICBpZiAoaGFuZGxlRXZlbnRQb2ludChldmVudFBvaW50KSkge1xuICAgICAgICAgIC8vIHRoZXkgZGVjaWRlZCB0byBzdG9wLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICBpZiAoIWV2ZW50UXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgIHZhciBldmVudFBvaW50ID0gZXZlbnRRdWV1ZS5wb3AoKTtcbiAgICAgICAgaGFuZGxlRXZlbnRQb2ludChldmVudFBvaW50KTtcbiAgICAgICAgLy8gTm90ZTogd2UgZG9uJ3QgY2hlY2sgcmVzdWx0cyBvZiBgaGFuZGxlRXZlbnRQb2ludCgpYFxuICAgICAgICAvLyBhc3N1bXB0aW9uIGlzIHRoYXQgY2xpZW50IGNvbnRyb2xzIGBzdGVwKClgIGFuZCB0aHVzIHRoZXkgXG4gICAgICAgIC8vIGtub3cgYmV0dGVyIGlmIHRoZXkgd2FudCB0byBzdG9wLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFdmVudFBvaW50KHApIHtcbiAgICAgIGxhc3RQb2ludCA9IHAucG9pbnQ7XG4gICAgICB2YXIgdXBwZXIgPSBwLmZyb20gfHwgRU1QVFk7XG5cbiAgICAgIGxvd2VyID0gaW50ZXJpb3IgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBUT0RPOiBtb3ZlIGxvd2VyL2ludGVyaW9yIGludG8gc3dlZXAgc3RhdHVzIG1ldGhvZD9cblxuICAgICAgc3dlZXBTdGF0dXMuZmluZFNlZ21lbnRzV2l0aFBvaW50KGxhc3RQb2ludCwgYWRkTG93ZXJPckludGVyaW9yKTtcbiAgICAgIC8vIGlmIChzZWdtZW50c1dpdGhQb2ludCkge1xuICAgICAgLy8gICBzZWdtZW50c1dpdGhQb2ludC5mb3JFYWNoKClcbiAgICAgIC8vIH0gXG5cbiAgICAgIGlmICghbG93ZXIpIHsgbG93ZXIgPSBFTVBUWTsgfVxuICAgICAgaWYgKCFpbnRlcmlvcikgeyBpbnRlcmlvciA9IEVNUFRZOyB9XG5cbiAgICAgIHZhciB1TGVuZ3RoID0gdXBwZXIubGVuZ3RoO1xuICAgICAgdmFyIGlMZW5ndGggPSBpbnRlcmlvci5sZW5ndGg7XG4gICAgICB2YXIgbExlbmd0aCA9IGxvd2VyLmxlbmd0aDtcbiAgICAgIHZhciBoYXNJbnRlcnNlY3Rpb24gPSB1TGVuZ3RoICsgaUxlbmd0aCArIGxMZW5ndGggPiAxO1xuICAgICAgdmFyIGhhc1BvaW50SW50ZXJzZWN0aW9uID0gIWhhc0ludGVyc2VjdGlvbiAmJiAodUxlbmd0aCA9PT0gMCAmJiBsTGVuZ3RoID09PSAwICYmIGlMZW5ndGggPiAwKTtcblxuICAgICAgaWYgKGhhc0ludGVyc2VjdGlvbiB8fCBoYXNQb2ludEludGVyc2VjdGlvbikge1xuICAgICAgICBwLmlzUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAocmVwb3J0SW50ZXJzZWN0aW9uKGxhc3RQb2ludCwgdW5pb24oaW50ZXJpb3IsIHVuaW9uKGxvd2VyLCB1cHBlcikpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3ZWVwU3RhdHVzLmRlbGV0ZVNlZ21lbnRzKGxvd2VyLCBpbnRlcmlvciwgbGFzdFBvaW50KTtcbiAgICAgIHN3ZWVwU3RhdHVzLmluc2VydFNlZ21lbnRzKGludGVyaW9yLCB1cHBlciwgbGFzdFBvaW50KTtcblxuICAgICAgdmFyIHNMZWZ0LCBzUmlnaHQ7XG5cbiAgICAgIHZhciBoYXNOb0Nyb3NzaW5nID0gKHVMZW5ndGggKyBpTGVuZ3RoID09PSAwKTtcblxuICAgICAgaWYgKGhhc05vQ3Jvc3NpbmcpIHtcbiAgICAgICAgdmFyIGxlZnRSaWdodCA9IHN3ZWVwU3RhdHVzLmdldExlZnRSaWdodFBvaW50KGxhc3RQb2ludCk7XG4gICAgICAgIHNMZWZ0ID0gbGVmdFJpZ2h0LmxlZnQ7XG4gICAgICAgIGlmICghc0xlZnQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgc1JpZ2h0ID0gbGVmdFJpZ2h0LnJpZ2h0O1xuICAgICAgICBpZiAoIXNSaWdodCkgeyByZXR1cm47IH1cblxuICAgICAgICBmaW5kTmV3RXZlbnQoc0xlZnQsIHNSaWdodCwgcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYm91bmRhcnlTZWdtZW50cyA9IHN3ZWVwU3RhdHVzLmdldEJvdW5kYXJ5U2VnbWVudHModXBwZXIsIGludGVyaW9yKTtcblxuICAgICAgICBmaW5kTmV3RXZlbnQoYm91bmRhcnlTZWdtZW50cy5iZWZvcmVMZWZ0LCBib3VuZGFyeVNlZ21lbnRzLmxlZnQsIHApO1xuICAgICAgICBmaW5kTmV3RXZlbnQoYm91bmRhcnlTZWdtZW50cy5yaWdodCwgYm91bmRhcnlTZWdtZW50cy5hZnRlclJpZ2h0LCBwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExvd2VyT3JJbnRlcmlvcihzKSB7XG4gICAgICBpZiAoc2FtZVBvaW50KHMudG8sIGxhc3RQb2ludCkpIHtcbiAgICAgICAgaWYgKCFsb3dlcikgeyBsb3dlciA9IFtzXTsgfVxuICAgICAgICBlbHNlIHsgbG93ZXIucHVzaChzKTsgfVxuICAgICAgfSBlbHNlIGlmICghc2FtZVBvaW50KHMuZnJvbSwgbGFzdFBvaW50KSkge1xuICAgICAgICBpZiAoIWludGVyaW9yKSB7IGludGVyaW9yID0gW3NdOyB9XG4gICAgICAgIGVsc2UgeyBpbnRlcmlvci5wdXNoKHMpOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZE5ld0V2ZW50KGxlZnQsIHJpZ2h0LCBwKSB7XG4gICAgICBpZiAoIWxlZnQgfHwgIXJpZ2h0KSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0U2VnbWVudHMobGVmdCwgcmlnaHQpO1xuICAgICAgaWYgKCFpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkeSA9IHAucG9pbnQueSAtIGludGVyc2VjdGlvbi55O1xuICAgICAgLy8gVE9ETzogc2hvdWxkIEkgYWRkIGR5IHRvIGludGVyc2VjdGlvbi55P1xuICAgICAgaWYgKGR5IDwgLUVQUykge1xuICAgICAgICAvLyB0aGlzIG1lYW5zIGludGVyc2VjdGlvbiBoYXBwZW5lZCBhZnRlciB0aGUgc3dlZXAgbGluZS4gXG4gICAgICAgIC8vIFdlIGFscmVhZHkgcHJvY2Vzc2VkIGl0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoZHkpIDwgRVBTICYmIGludGVyc2VjdGlvbi54IDw9IHAucG9pbnQueCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZWQgdG8gYWRqdXN0IGZsb2F0aW5nIHBvaW50IGZvciB0aGlzIHNwZWNpYWwgY2FzZSxcbiAgICAgIC8vIHNpbmNlIG90aGVyd2lzZSBpdCBnaXZlcyByb3VuZGluZyBlcnJvcnM6XG4gICAgICByb3VuZE5lYXJaZXJvKGludGVyc2VjdGlvbik7XG5cbiAgICAgIHZhciBjdXJyZW50ID0gZXZlbnRRdWV1ZS5maW5kKGludGVyc2VjdGlvbik7XG5cbiAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuaXNSZXBvcnRlZCkge1xuICAgICAgICAvLyBXZSBhbHJlYWR5IHJlcG9ydGVkIHRoaXMgZXZlbnQuIE5vIG5lZWQgdG8gYWRkIGl0IG9uZSBtb3JlIHRpbWVcbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBjYXNlIGV2ZW4gcG9zc2libGU/XG4gICAgICAgIG9uRXJyb3IoJ1dlIGFscmVhZHkgcmVwb3J0ZWQgdGhpcyBldmVudC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IFN3ZWVwRXZlbnQoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgZXZlbnRRdWV1ZS5pbnNlcnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRJbnRlcnNlY3Rpb25SZXBvcnRlcihwLCBzZWdtZW50cykge1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgcG9pbnQ6IHAsIFxuICAgICAgICBzZWdtZW50czogc2VnbWVudHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFNlZ21lbnQoc2VnbWVudCkge1xuICAgICAgdmFyIGZyb20gPSBzZWdtZW50LmZyb207XG4gICAgICB2YXIgdG8gPSBzZWdtZW50LnRvO1xuXG4gICAgICAvLyBTbWFsbCBudW1iZXJzIGdpdmUgbW9yZSBwcmVjaXNpb24gZXJyb3JzLiBSb3VuZGluZyB0aGVtIHRvIDAuXG4gICAgICByb3VuZE5lYXJaZXJvKGZyb20pO1xuICAgICAgcm91bmROZWFyWmVybyh0byk7XG5cbiAgICAgIHZhciBkeSA9IGZyb20ueSAtIHRvLnk7XG5cbiAgICAgIC8vIE5vdGU6IGR5IGlzIG11Y2ggc21hbGxlciB0aGVuIEVQUyBvbiBwdXJwb3NlLiBJIGZvdW5kIHRoYXQgaGlnaGVyXG4gICAgICAvLyBwcmVjaXNpb24gaGVyZSBkb2VzIGxlc3MgZ29vZCAtIGdldHRpbmcgd2F5IG1vcmUgcm91bmRpbmcgZXJyb3JzLlxuICAgICAgaWYgKE1hdGguYWJzKGR5KSA8IDFlLTUpIHtcbiAgICAgICAgZnJvbS55ID0gdG8ueTtcbiAgICAgICAgc2VnbWVudC5keSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoKGZyb20ueSA8IHRvLnkpIHx8IChcbiAgICAgICAgICAoZnJvbS55ID09PSB0by55KSAmJiAoZnJvbS54ID4gdG8ueCkpXG4gICAgICAgICkge1xuICAgICAgICB2YXIgdGVtcCA9IGZyb207XG4gICAgICAgIGZyb20gPSBzZWdtZW50LmZyb20gPSB0bzsgXG4gICAgICAgIHRvID0gc2VnbWVudC50byA9IHRlbXA7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHByZS1jb21wdXRlIHNvbWUgaW1tdXRhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNlZ21lbnRcbiAgICAgIC8vIFRoZXkgYXJlIHVzZWQgcXVpdGUgb2Z0ZW4gaW4gdGhlIHRyZWUgdHJhdmVyc2FsLCBhbmQgcHJlLWNvbXB1dGF0aW9uXG4gICAgICAvLyBnaXZlcyBzaWduaWZpY2FudCBib29zdDpcbiAgICAgIHNlZ21lbnQuZHkgPSBmcm9tLnkgLSB0by55O1xuICAgICAgc2VnbWVudC5keCA9IGZyb20ueCAtIHRvLng7XG4gICAgICBzZWdtZW50LmFuZ2xlID0gYW5nbGUoc2VnbWVudC5keSwgc2VnbWVudC5keCk7XG5cbiAgICAgIHZhciBpc1BvaW50ID0gc2VnbWVudC5keSA9PT0gc2VnbWVudC5keCAmJiBzZWdtZW50LmR5ID09PSAwO1xuICAgICAgdmFyIHByZXYgPSBldmVudFF1ZXVlLmZpbmQoZnJvbSk7XG4gICAgICBpZiAocHJldiAmJiAhaXNQb2ludCkge1xuICAgICAgICAvLyB0aGlzIGRldGVjdHMgaWRlbnRpY2FsIHNlZ21lbnRzIGVhcmx5LiBXaXRob3V0IHRoaXMgY2hlY2tcbiAgICAgICAgLy8gdGhlIGFsZ29yaXRobSB3b3VsZCBicmVhayBzaW5jZSBzd2VlcCBsaW5lIGhhcyBubyBtZWFucyB0b1xuICAgICAgICAvLyBkZXRlY3QgaWRlbnRpY2FsIHNlZ21lbnRzLlxuICAgICAgICB2YXIgcHJldkZyb20gPSBwcmV2LmRhdGEuZnJvbTtcbiAgICAgICAgaWYgKHByZXZGcm9tKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RnJvbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHMgPSBwcmV2RnJvbVtpXTtcbiAgICAgICAgICAgIGlmIChzYW1lUG9pbnQocy50bywgdG8pKSB7XG4gICAgICAgICAgICAgIHJlcG9ydEludGVyc2VjdGlvbihzLmZyb20sIFtzLmZyb20sIHMudG9dKTtcbiAgICAgICAgICAgICAgcmVwb3J0SW50ZXJzZWN0aW9uKHMudG8sIFtzLmZyb20sIHMudG9dKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUG9pbnQpIHtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBpZiAocHJldi5kYXRhLmZyb20pIHsgcHJldi5kYXRhLmZyb20ucHVzaChzZWdtZW50KTsgfVxuICAgICAgICAgIGVsc2UgeyBwcmV2LmRhdGEuZnJvbSA9IFtzZWdtZW50XTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlID0gbmV3IFN3ZWVwRXZlbnQoZnJvbSwgc2VnbWVudCk7XG4gICAgICAgICAgZXZlbnRRdWV1ZS5pbnNlcnQoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IFN3ZWVwRXZlbnQodG8pO1xuICAgICAgICBldmVudFF1ZXVlLmluc2VydChldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgU3dlZXBFdmVudCh0byk7XG4gICAgICAgIGV2ZW50UXVldWUuaW5zZXJ0KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9IFxuICB9XG5cbiAgZnVuY3Rpb24gcm91bmROZWFyWmVybyhwb2ludCkge1xuICAgIGlmIChNYXRoLmFicyhwb2ludC54KSA8IEVQUykgeyBwb2ludC54ID0gMDsgfVxuICAgIGlmIChNYXRoLmFicyhwb2ludC55KSA8IEVQUykgeyBwb2ludC55ID0gMDsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEVycm9yUmVwb3J0ZXIoZXJyb3JNZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBmdW5jdGlvbiB1bmlvbihhLCBiKSB7XG4gICAgaWYgKCFhKSB7IHJldHVybiBiOyB9XG4gICAgaWYgKCFiKSB7IHJldHVybiBhOyB9XG5cbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH1cblxuICBmdW5jdGlvbiBieVkoYSwgYikge1xuICAgIC8vIGRlY3JlYXNpbmcgWSBcbiAgICB2YXIgcmVzID0gYi55IC0gYS55O1xuICAgIC8vIFRPRE86IFRoaXMgbWlnaHQgbWVzcyB1cCB0aGUgc3RhdHVzIHRyZWUuXG4gICAgaWYgKE1hdGguYWJzKHJlcykgPCBFUFMpIHtcbiAgICAgIC8vIGluY3JlYXNpbmcgeC5cbiAgICAgIHJlcyA9IGEueCAtIGIueDtcbiAgICAgIGlmIChNYXRoLmFicyhyZXMpIDwgRVBTKSB7IHJlcyA9IDA7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0U2VnbWVudHMkMShhLCBiKSB7XG4gICAgLy8gTm90ZTogdGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgZ2VvbS5pbnRlcnNlY3RTZWdtZW50cygpXG4gICAgLy8gVGhlIG1haW4gZGlmZmVyZW5jZSBpcyB0aGF0IHdlIGRvbid0IGhhdmUgYSBwcmUtY29tcHV0ZWRcbiAgICAvLyB2YWx1ZSBmb3IgZHgvZHkgb24gdGhlIHNlZ21lbnRzLlxuICAgIC8vICBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTk2ODM0NS8xMjUzNTFcbiAgICB2YXIgYVN0YXJ0ID0gYS5mcm9tLCBiU3RhcnQgPSBiLmZyb207XG4gICAgdmFyIHAwX3ggPSBhU3RhcnQueCwgcDBfeSA9IGFTdGFydC55LFxuICAgICAgICBwMl94ID0gYlN0YXJ0LngsIHAyX3kgPSBiU3RhcnQueTtcblxuICAgIHZhciBzMV94ID0gYS5mcm9tLnggLSBhLnRvLngsIHMxX3kgPSBhLmZyb20ueSAtIGEudG8ueSwgczJfeCA9IGIuZnJvbS54IC0gYi50by54LCBzMl95ID0gYi5mcm9tLnkgLSBiLnRvLnk7XG4gICAgdmFyIGRpdiA9IHMxX3ggKiBzMl95IC0gczJfeCAqIHMxX3k7XG5cbiAgICB2YXIgcyA9IChzMV95ICogKHAwX3ggLSBwMl94KSAtIHMxX3ggKiAocDBfeSAtIHAyX3kpKSAvIGRpdjtcbiAgICBpZiAocyA8IDAgfHwgcyA+IDEpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdCA9IChzMl94ICogKHAyX3kgLSBwMF95KSArIHMyX3kgKiAocDBfeCAtIHAyX3gpKSAvIGRpdjtcblxuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwMF94IC0gKHQgKiBzMV94KSxcbiAgICAgICAgeTogcDBfeSAtICh0ICogczFfeSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIGJydXRlIGZvcmNlIHNvbHV0aW9uIHdpdGggTyhuXjIpIHBlcmZvcm1hbmNlLlxuICAgKiAoYG5gIGlzIG51bWJlciBvZiBzZWdtZW50cykuXG4gICAqIFxuICAgKiBVc2UgdGhpcyB3aGVuIG51bWJlciBvZiBsaW5lcyBpcyBsb3csIGFuZCBudW1iZXIgb2YgaW50ZXJzZWN0aW9uc1xuICAgKiBpcyBoaWdoLlxuICAgKi9cbiAgZnVuY3Rpb24gYnJ1dGUobGluZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciByZXBvcnRJbnRlcnNlY3Rpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLm9uRm91bmQpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyO1xuICAgIHZhciBhc3luY1N0YXRlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogRXhlY3V0ZSBicnV0ZSBmb3JjZSBvZiB0aGUgc2VnbWVudCBpbnRlcnNlY3Rpb24gc2VhcmNoXG4gICAgICAgKi9cbiAgICAgIHJ1bjogcnVuLFxuICAgICAgLyoqXG4gICAgICAgKiBBY2Nlc3MgdG8gcmVzdWx0cyBhcnJheS4gV29ya3Mgb25seSB3aGVuIHlvdSB1c2UgZGVmYXVsdCBvbkZvdW5kKCkgaGFuZGxlclxuICAgICAgICovXG4gICAgICByZXN1bHRzOiByZXN1bHRzLFxuXG4gICAgICAvKipcbiAgICAgICAqIFBlcmZvcm1zIGEgc2luZ2xlIHN0ZXAgaW4gdGhlIGJydXRlIGZvcmNlIGFsZ29yaXRobSAoKVxuICAgICAgICovXG4gICAgICBzdGVwOiBzdGVwXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmICghYXN5bmNTdGF0ZSkge1xuICAgICAgICBhc3luY1N0YXRlID0ge1xuICAgICAgICAgIGk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXN0ID0gbGluZXNbYXN5bmNTdGF0ZS5pXTtcbiAgICAgIGZvciAodmFyIGogPSBhc3luY1N0YXRlLmkgKyAxOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIG90aGVyID0gbGluZXNbal07XG4gICAgICAgIHZhciBwdCA9IGludGVyc2VjdFNlZ21lbnRzJDEodGVzdCwgb3RoZXIpO1xuICAgICAgICBpZiAocHQpIHtcbiAgICAgICAgICBpZiAocmVwb3J0SW50ZXJzZWN0aW9uKHB0LCBbdGVzdCwgb3RoZXJdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXN5bmNTdGF0ZS5pICs9IDE7XG4gICAgICByZXR1cm4gYXN5bmNTdGF0ZS5pIDwgbGluZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdGVzdCA9IGxpbmVzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsaW5lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBvdGhlciA9IGxpbmVzW2pdO1xuICAgICAgICAgIHZhciBwdCA9IGludGVyc2VjdFNlZ21lbnRzJDEodGVzdCwgb3RoZXIpO1xuICAgICAgICAgIGlmIChwdCkge1xuICAgICAgICAgICAgaWYgKHJlcG9ydEludGVyc2VjdGlvbihwdCwgW3Rlc3QsIG90aGVyXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyKHAsIGludGVyaW9yKSB7XG4gICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICBwb2ludDogcCwgXG4gICAgICAgIHNlZ21lbnRzOiBpbnRlcmlvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIEFSUkFZX1RZUEVTID0gW1xuICAgICAgSW50OEFycmF5LCBVaW50OEFycmF5LCBVaW50OENsYW1wZWRBcnJheSwgSW50MTZBcnJheSwgVWludDE2QXJyYXksXG4gICAgICBJbnQzMkFycmF5LCBVaW50MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDY0QXJyYXlcbiAgXTtcblxuICB2YXIgVkVSU0lPTiA9IDM7IC8vIHNlcmlhbGl6ZWQgZm9ybWF0IHZlcnNpb25cblxuICB2YXIgRmxhdGJ1c2ggPSBmdW5jdGlvbiBGbGF0YnVzaChudW1JdGVtcywgbm9kZVNpemUsIEFycmF5VHlwZSwgZGF0YSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChudW1JdGVtcyA9PT0gdW5kZWZpbmVkKSB7IHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudDogbnVtSXRlbXMuJyk7IH1cbiAgICAgIGlmIChpc05hTihudW1JdGVtcykgfHwgbnVtSXRlbXMgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoKFwiVW5wZXhwZWN0ZWQgbnVtSXRlbXMgdmFsdWU6IFwiICsgbnVtSXRlbXMgKyBcIi5cIikpOyB9XG5cbiAgICAgIHRoaXMubnVtSXRlbXMgPSArbnVtSXRlbXM7XG4gICAgICB0aGlzLm5vZGVTaXplID0gTWF0aC5taW4oTWF0aC5tYXgoK25vZGVTaXplIHx8IDE2LCAyKSwgNjU1MzUpO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgUi10cmVlIHRvIGFsbG9jYXRlIHNwYWNlIGZvclxuICAgICAgLy8gYW5kIHRoZSBpbmRleCBvZiBlYWNoIHRyZWUgbGV2ZWwgKHVzZWQgaW4gc2VhcmNoIGxhdGVyKVxuICAgICAgdmFyIG4gPSBudW1JdGVtcztcbiAgICAgIHZhciBudW1Ob2RlcyA9IG47XG4gICAgICB0aGlzLl9sZXZlbEJvdW5kcyA9IFtuICogNF07XG4gICAgICBkbyB7XG4gICAgICAgICAgbiA9IE1hdGguY2VpbChuIC8gdGhpcyQxLm5vZGVTaXplKTtcbiAgICAgICAgICBudW1Ob2RlcyArPSBuO1xuICAgICAgICAgIHRoaXMkMS5fbGV2ZWxCb3VuZHMucHVzaChudW1Ob2RlcyAqIDQpO1xuICAgICAgfSB3aGlsZSAobiAhPT0gMSk7XG5cbiAgICAgIHRoaXMuQXJyYXlUeXBlID0gQXJyYXlUeXBlIHx8IEZsb2F0NjRBcnJheTtcbiAgICAgIHRoaXMuSW5kZXhBcnJheVR5cGUgPSBudW1Ob2RlcyA8IDE2Mzg0ID8gVWludDE2QXJyYXkgOiBVaW50MzJBcnJheTtcblxuICAgICAgdmFyIGFycmF5VHlwZUluZGV4ID0gQVJSQVlfVFlQRVMuaW5kZXhPZih0aGlzLkFycmF5VHlwZSk7XG4gICAgICB2YXIgbm9kZXNCeXRlU2l6ZSA9IG51bU5vZGVzICogNCAqIHRoaXMuQXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG4gICAgICBpZiAoYXJyYXlUeXBlSW5kZXggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlVuZXhwZWN0ZWQgdHlwZWQgYXJyYXkgY2xhc3M6IFwiICsgQXJyYXlUeXBlICsgXCIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgJiYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAgIHRoaXMuX2JveGVzID0gbmV3IHRoaXMuQXJyYXlUeXBlKHRoaXMuZGF0YSwgOCwgbnVtTm9kZXMgKiA0KTtcbiAgICAgICAgICB0aGlzLl9pbmRpY2VzID0gbmV3IHRoaXMuSW5kZXhBcnJheVR5cGUodGhpcy5kYXRhLCA4ICsgbm9kZXNCeXRlU2l6ZSwgbnVtTm9kZXMpO1xuXG4gICAgICAgICAgdGhpcy5fcG9zID0gbnVtTm9kZXMgKiA0O1xuICAgICAgICAgIHRoaXMubWluWCA9IHRoaXMuX2JveGVzW3RoaXMuX3BvcyAtIDRdO1xuICAgICAgICAgIHRoaXMubWluWSA9IHRoaXMuX2JveGVzW3RoaXMuX3BvcyAtIDNdO1xuICAgICAgICAgIHRoaXMubWF4WCA9IHRoaXMuX2JveGVzW3RoaXMuX3BvcyAtIDJdO1xuICAgICAgICAgIHRoaXMubWF4WSA9IHRoaXMuX2JveGVzW3RoaXMuX3BvcyAtIDFdO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBBcnJheUJ1ZmZlcig4ICsgbm9kZXNCeXRlU2l6ZSArIG51bU5vZGVzICogdGhpcy5JbmRleEFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgICAgICAgdGhpcy5fYm94ZXMgPSBuZXcgdGhpcy5BcnJheVR5cGUodGhpcy5kYXRhLCA4LCBudW1Ob2RlcyAqIDQpO1xuICAgICAgICAgIHRoaXMuX2luZGljZXMgPSBuZXcgdGhpcy5JbmRleEFycmF5VHlwZSh0aGlzLmRhdGEsIDggKyBub2Rlc0J5dGVTaXplLCBudW1Ob2Rlcyk7XG4gICAgICAgICAgdGhpcy5fcG9zID0gMDtcbiAgICAgICAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcbiAgICAgICAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgICAgICAgdGhpcy5tYXhZID0gLUluZmluaXR5O1xuXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLCAwLCAyKS5zZXQoWzB4ZmIsIChWRVJTSU9OIDw8IDQpICsgYXJyYXlUeXBlSW5kZXhdKTtcbiAgICAgICAgICBuZXcgVWludDE2QXJyYXkodGhpcy5kYXRhLCAyLCAxKVswXSA9IG5vZGVTaXplO1xuICAgICAgICAgIG5ldyBVaW50MzJBcnJheSh0aGlzLmRhdGEsIDQsIDEpWzBdID0gbnVtSXRlbXM7XG4gICAgICB9XG4gIH07XG5cbiAgRmxhdGJ1c2guZnJvbSA9IGZ1bmN0aW9uIGZyb20gKGRhdGEpIHtcbiAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBBcnJheUJ1ZmZlci4nKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWYgPSBuZXcgVWludDhBcnJheShkYXRhLCAwLCAyKTtcbiAgICAgICAgICB2YXIgbWFnaWMgPSByZWZbMF07XG4gICAgICAgICAgdmFyIHZlcnNpb25BbmRUeXBlID0gcmVmWzFdO1xuICAgICAgaWYgKG1hZ2ljICE9PSAweGZiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGRvZXMgbm90IGFwcGVhciB0byBiZSBpbiBhIEZsYXRidXNoIGZvcm1hdC4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJzaW9uQW5kVHlwZSA+PiA0ICE9PSBWRVJTSU9OKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkdvdCB2XCIgKyAodmVyc2lvbkFuZFR5cGUgPj4gNCkgKyBcIiBkYXRhIHdoZW4gZXhwZWN0ZWQgdlwiICsgVkVSU0lPTiArIFwiLlwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVmJDEgPSBuZXcgVWludDE2QXJyYXkoZGF0YSwgMiwgMSk7XG4gICAgICAgICAgdmFyIG5vZGVTaXplID0gcmVmJDFbMF07XG4gICAgICB2YXIgcmVmJDIgPSBuZXcgVWludDMyQXJyYXkoZGF0YSwgNCwgMSk7XG4gICAgICAgICAgdmFyIG51bUl0ZW1zID0gcmVmJDJbMF07XG5cbiAgICAgIHJldHVybiBuZXcgRmxhdGJ1c2gobnVtSXRlbXMsIG5vZGVTaXplLCBBUlJBWV9UWVBFU1t2ZXJzaW9uQW5kVHlwZSAmIDB4MGZdLCBkYXRhKTtcbiAgfTtcblxuICBGbGF0YnVzaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9wb3MgPj4gMjtcbiAgICAgIHRoaXMuX2luZGljZXNbaW5kZXhdID0gaW5kZXg7XG4gICAgICB0aGlzLl9ib3hlc1t0aGlzLl9wb3MrK10gPSBtaW5YO1xuICAgICAgdGhpcy5fYm94ZXNbdGhpcy5fcG9zKytdID0gbWluWTtcbiAgICAgIHRoaXMuX2JveGVzW3RoaXMuX3BvcysrXSA9IG1heFg7XG4gICAgICB0aGlzLl9ib3hlc1t0aGlzLl9wb3MrK10gPSBtYXhZO1xuXG4gICAgICBpZiAobWluWCA8IHRoaXMubWluWCkgeyB0aGlzLm1pblggPSBtaW5YOyB9XG4gICAgICBpZiAobWluWSA8IHRoaXMubWluWSkgeyB0aGlzLm1pblkgPSBtaW5ZOyB9XG4gICAgICBpZiAobWF4WCA+IHRoaXMubWF4WCkgeyB0aGlzLm1heFggPSBtYXhYOyB9XG4gICAgICBpZiAobWF4WSA+IHRoaXMubWF4WSkgeyB0aGlzLm1heFkgPSBtYXhZOyB9XG4gIH07XG5cbiAgRmxhdGJ1c2gucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCAoKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9wb3MgPj4gMiAhPT0gdGhpcy5udW1JdGVtcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJBZGRlZCBcIiArICh0aGlzLl9wb3MgPj4gMikgKyBcIiBpdGVtcyB3aGVuIGV4cGVjdGVkIFwiICsgKHRoaXMubnVtSXRlbXMpICsgXCIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoID0gdGhpcy5tYXhYIC0gdGhpcy5taW5YO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMubWF4WSAtIHRoaXMubWluWTtcbiAgICAgIHZhciBoaWxiZXJ0VmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KHRoaXMubnVtSXRlbXMpO1xuICAgICAgdmFyIGhpbGJlcnRNYXggPSAoMSA8PCAxNikgLSAxO1xuXG4gICAgICAvLyBtYXAgaXRlbSBjZW50ZXJzIGludG8gSGlsYmVydCBjb29yZGluYXRlIHNwYWNlIGFuZCBjYWxjdWxhdGUgSGlsYmVydCB2YWx1ZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1JdGVtczsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IDQgKiBpO1xuICAgICAgICAgIHZhciBtaW5YID0gdGhpcyQxLl9ib3hlc1twb3MrK107XG4gICAgICAgICAgdmFyIG1pblkgPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgICB2YXIgbWF4WCA9IHRoaXMkMS5fYm94ZXNbcG9zKytdO1xuICAgICAgICAgIHZhciBtYXhZID0gdGhpcyQxLl9ib3hlc1twb3MrK107XG4gICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKGhpbGJlcnRNYXggKiAoKG1pblggKyBtYXhYKSAvIDIgLSB0aGlzJDEubWluWCkgLyB3aWR0aCk7XG4gICAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKGhpbGJlcnRNYXggKiAoKG1pblkgKyBtYXhZKSAvIDIgLSB0aGlzJDEubWluWSkgLyBoZWlnaHQpO1xuICAgICAgICAgIGhpbGJlcnRWYWx1ZXNbaV0gPSBoaWxiZXJ0KHgsIHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBzb3J0IGl0ZW1zIGJ5IHRoZWlyIEhpbGJlcnQgdmFsdWUgKGZvciBwYWNraW5nIGxhdGVyKVxuICAgICAgc29ydCQxKGhpbGJlcnRWYWx1ZXMsIHRoaXMuX2JveGVzLCB0aGlzLl9pbmRpY2VzLCAwLCB0aGlzLm51bUl0ZW1zIC0gMSk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIG5vZGVzIGF0IGVhY2ggdHJlZSBsZXZlbCwgYm90dG9tLXVwXG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBwb3MkMSA9IDA7IGkkMSA8IHRoaXMuX2xldmVsQm91bmRzLmxlbmd0aCAtIDE7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGVuZCA9IHRoaXMkMS5fbGV2ZWxCb3VuZHNbaSQxXTtcblxuICAgICAgICAgIC8vIGdlbmVyYXRlIGEgcGFyZW50IG5vZGUgZm9yIGVhY2ggYmxvY2sgb2YgY29uc2VjdXRpdmUgPG5vZGVTaXplPiBub2Rlc1xuICAgICAgICAgIHdoaWxlIChwb3MkMSA8IGVuZCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZU1pblggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVNaW5ZID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgIHZhciBub2RlTWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVNYXhZID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gcG9zJDE7XG5cbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGJib3ggZm9yIHRoZSBuZXcgbm9kZVxuICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCB0aGlzLm5vZGVTaXplICYmIHBvcyQxIDwgZW5kOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIG1pblgkMSA9IHRoaXMkMS5fYm94ZXNbcG9zJDErK107XG4gICAgICAgICAgICAgICAgICB2YXIgbWluWSQxID0gdGhpcyQxLl9ib3hlc1twb3MkMSsrXTtcbiAgICAgICAgICAgICAgICAgIHZhciBtYXhYJDEgPSB0aGlzJDEuX2JveGVzW3BvcyQxKytdO1xuICAgICAgICAgICAgICAgICAgdmFyIG1heFkkMSA9IHRoaXMkMS5fYm94ZXNbcG9zJDErK107XG4gICAgICAgICAgICAgICAgICBpZiAobWluWCQxIDwgbm9kZU1pblgpIHsgbm9kZU1pblggPSBtaW5YJDE7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChtaW5ZJDEgPCBub2RlTWluWSkgeyBub2RlTWluWSA9IG1pblkkMTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG1heFgkMSA+IG5vZGVNYXhYKSB7IG5vZGVNYXhYID0gbWF4WCQxOyB9XG4gICAgICAgICAgICAgICAgICBpZiAobWF4WSQxID4gbm9kZU1heFkpIHsgbm9kZU1heFkgPSBtYXhZJDE7IH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGFkZCB0aGUgbmV3IG5vZGUgdG8gdGhlIHRyZWUgZGF0YVxuICAgICAgICAgICAgICB0aGlzJDEuX2luZGljZXNbdGhpcyQxLl9wb3MgPj4gMl0gPSBub2RlSW5kZXg7XG4gICAgICAgICAgICAgIHRoaXMkMS5fYm94ZXNbdGhpcyQxLl9wb3MrK10gPSBub2RlTWluWDtcbiAgICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNaW5ZO1xuICAgICAgICAgICAgICB0aGlzJDEuX2JveGVzW3RoaXMkMS5fcG9zKytdID0gbm9kZU1heFg7XG4gICAgICAgICAgICAgIHRoaXMkMS5fYm94ZXNbdGhpcyQxLl9wb3MrK10gPSBub2RlTWF4WTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgRmxhdGJ1c2gucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaCAobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgZmlsdGVyRm4pIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX3BvcyAhPT0gdGhpcy5fYm94ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG5vdCB5ZXQgaW5kZXhlZCAtIGNhbGwgaW5kZXguZmluaXNoKCkuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLl9ib3hlcy5sZW5ndGggLSA0O1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxCb3VuZHMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgd2hpbGUgKG5vZGVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmluZCB0aGUgZW5kIGluZGV4IG9mIHRoZSBub2RlXG4gICAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKG5vZGVJbmRleCArIHRoaXMkMS5ub2RlU2l6ZSAqIDQsIHRoaXMkMS5fbGV2ZWxCb3VuZHNbbGV2ZWxdKTtcblxuICAgICAgICAgIC8vIHNlYXJjaCB0aHJvdWdoIGNoaWxkIG5vZGVzXG4gICAgICAgICAgZm9yICh2YXIgcG9zID0gbm9kZUluZGV4OyBwb3MgPCBlbmQ7IHBvcyArPSA0KSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMkMS5faW5kaWNlc1twb3MgPj4gMl07XG5cbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbm9kZSBiYm94IGludGVyc2VjdHMgd2l0aCBxdWVyeSBiYm94XG4gICAgICAgICAgICAgIGlmIChtYXhYIDwgdGhpcyQxLl9ib3hlc1twb3NdKSB7IGNvbnRpbnVlOyB9IC8vIG1heFggPCBub2RlTWluWFxuICAgICAgICAgICAgICBpZiAobWF4WSA8IHRoaXMkMS5fYm94ZXNbcG9zICsgMV0pIHsgY29udGludWU7IH0gLy8gbWF4WSA8IG5vZGVNaW5ZXG4gICAgICAgICAgICAgIGlmIChtaW5YID4gdGhpcyQxLl9ib3hlc1twb3MgKyAyXSkgeyBjb250aW51ZTsgfSAvLyBtaW5YID4gbm9kZU1heFhcbiAgICAgICAgICAgICAgaWYgKG1pblkgPiB0aGlzJDEuX2JveGVzW3BvcyArIDNdKSB7IGNvbnRpbnVlOyB9IC8vIG1pblkgPiBub2RlTWF4WVxuXG4gICAgICAgICAgICAgIGlmIChub2RlSW5kZXggPCB0aGlzJDEubnVtSXRlbXMgKiA0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRm4gPT09IHVuZGVmaW5lZCB8fCBmaWx0ZXJGbihpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaW5kZXgpOyAvLyBsZWFmIGl0ZW1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChpbmRleCk7IC8vIG5vZGU7IGFkZCBpdCB0byB0aGUgc2VhcmNoIHF1ZXVlXG4gICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGxldmVsIC0gMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXZlbCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICAgIG5vZGVJbmRleCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBjdXN0b20gcXVpY2tzb3J0IHRoYXQgc29ydHMgYmJveCBkYXRhIGFsb25nc2lkZSB0aGUgaGlsYmVydCB2YWx1ZXNcbiAgZnVuY3Rpb24gc29ydCQxKHZhbHVlcywgYm94ZXMsIGluZGljZXMsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAobGVmdCA+PSByaWdodCkgeyByZXR1cm47IH1cblxuICAgICAgdmFyIHBpdm90ID0gdmFsdWVzWyhsZWZ0ICsgcmlnaHQpID4+IDFdO1xuICAgICAgdmFyIGkgPSBsZWZ0IC0gMTtcbiAgICAgIHZhciBqID0gcmlnaHQgKyAxO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGRvIHsgaSsrOyB9IHdoaWxlICh2YWx1ZXNbaV0gPCBwaXZvdCk7XG4gICAgICAgICAgZG8geyBqLS07IH0gd2hpbGUgKHZhbHVlc1tqXSA+IHBpdm90KTtcbiAgICAgICAgICBpZiAoaSA+PSBqKSB7IGJyZWFrOyB9XG4gICAgICAgICAgc3dhcCh2YWx1ZXMsIGJveGVzLCBpbmRpY2VzLCBpLCBqKTtcbiAgICAgIH1cblxuICAgICAgc29ydCQxKHZhbHVlcywgYm94ZXMsIGluZGljZXMsIGxlZnQsIGopO1xuICAgICAgc29ydCQxKHZhbHVlcywgYm94ZXMsIGluZGljZXMsIGogKyAxLCByaWdodCk7XG4gIH1cblxuICAvLyBzd2FwIHR3byB2YWx1ZXMgYW5kIHR3byBjb3JyZXNwb25kaW5nIGJveGVzXG4gIGZ1bmN0aW9uIHN3YXAodmFsdWVzLCBib3hlcywgaW5kaWNlcywgaSwgaikge1xuICAgICAgdmFyIHRlbXAgPSB2YWx1ZXNbaV07XG4gICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbal07XG4gICAgICB2YWx1ZXNbal0gPSB0ZW1wO1xuXG4gICAgICB2YXIgayA9IDQgKiBpO1xuICAgICAgdmFyIG0gPSA0ICogajtcblxuICAgICAgdmFyIGEgPSBib3hlc1trXTtcbiAgICAgIHZhciBiID0gYm94ZXNbayArIDFdO1xuICAgICAgdmFyIGMgPSBib3hlc1trICsgMl07XG4gICAgICB2YXIgZCA9IGJveGVzW2sgKyAzXTtcbiAgICAgIGJveGVzW2tdID0gYm94ZXNbbV07XG4gICAgICBib3hlc1trICsgMV0gPSBib3hlc1ttICsgMV07XG4gICAgICBib3hlc1trICsgMl0gPSBib3hlc1ttICsgMl07XG4gICAgICBib3hlc1trICsgM10gPSBib3hlc1ttICsgM107XG4gICAgICBib3hlc1ttXSA9IGE7XG4gICAgICBib3hlc1ttICsgMV0gPSBiO1xuICAgICAgYm94ZXNbbSArIDJdID0gYztcbiAgICAgIGJveGVzW20gKyAzXSA9IGQ7XG5cbiAgICAgIHZhciBlID0gaW5kaWNlc1tpXTtcbiAgICAgIGluZGljZXNbaV0gPSBpbmRpY2VzW2pdO1xuICAgICAgaW5kaWNlc1tqXSA9IGU7XG4gIH1cblxuICAvLyBGYXN0IEhpbGJlcnQgY3VydmUgYWxnb3JpdGhtIGJ5IGh0dHA6Ly90aHJlYWRsb2NhbG11dGV4LmNvbS9cbiAgLy8gUG9ydGVkIGZyb20gQysrIGh0dHBzOi8vZ2l0aHViLmNvbS9yYXdydW5wcm90ZWN0ZWQvaGlsYmVydF9jdXJ2ZXMgKHB1YmxpYyBkb21haW4pXG4gIGZ1bmN0aW9uIGhpbGJlcnQoeCwgeSkge1xuICAgICAgdmFyIGEgPSB4IF4geTtcbiAgICAgIHZhciBiID0gMHhGRkZGIF4gYTtcbiAgICAgIHZhciBjID0gMHhGRkZGIF4gKHggfCB5KTtcbiAgICAgIHZhciBkID0geCAmICh5IF4gMHhGRkZGKTtcblxuICAgICAgdmFyIEEgPSBhIHwgKGIgPj4gMSk7XG4gICAgICB2YXIgQiA9IChhID4+IDEpIF4gYTtcbiAgICAgIHZhciBDID0gKChjID4+IDEpIF4gKGIgJiAoZCA+PiAxKSkpIF4gYztcbiAgICAgIHZhciBEID0gKChhICYgKGMgPj4gMSkpIF4gKGQgPj4gMSkpIF4gZDtcblxuICAgICAgYSA9IEE7IGIgPSBCOyBjID0gQzsgZCA9IEQ7XG4gICAgICBBID0gKChhICYgKGEgPj4gMikpIF4gKGIgJiAoYiA+PiAyKSkpO1xuICAgICAgQiA9ICgoYSAmIChiID4+IDIpKSBeIChiICYgKChhIF4gYikgPj4gMikpKTtcbiAgICAgIEMgXj0gKChhICYgKGMgPj4gMikpIF4gKGIgJiAoZCA+PiAyKSkpO1xuICAgICAgRCBePSAoKGIgJiAoYyA+PiAyKSkgXiAoKGEgXiBiKSAmIChkID4+IDIpKSk7XG5cbiAgICAgIGEgPSBBOyBiID0gQjsgYyA9IEM7IGQgPSBEO1xuICAgICAgQSA9ICgoYSAmIChhID4+IDQpKSBeIChiICYgKGIgPj4gNCkpKTtcbiAgICAgIEIgPSAoKGEgJiAoYiA+PiA0KSkgXiAoYiAmICgoYSBeIGIpID4+IDQpKSk7XG4gICAgICBDIF49ICgoYSAmIChjID4+IDQpKSBeIChiICYgKGQgPj4gNCkpKTtcbiAgICAgIEQgXj0gKChiICYgKGMgPj4gNCkpIF4gKChhIF4gYikgJiAoZCA+PiA0KSkpO1xuXG4gICAgICBhID0gQTsgYiA9IEI7IGMgPSBDOyBkID0gRDtcbiAgICAgIEMgXj0gKChhICYgKGMgPj4gOCkpIF4gKGIgJiAoZCA+PiA4KSkpO1xuICAgICAgRCBePSAoKGIgJiAoYyA+PiA4KSkgXiAoKGEgXiBiKSAmIChkID4+IDgpKSk7XG5cbiAgICAgIGEgPSBDIF4gKEMgPj4gMSk7XG4gICAgICBiID0gRCBeIChEID4+IDEpO1xuXG4gICAgICB2YXIgaTAgPSB4IF4geTtcbiAgICAgIHZhciBpMSA9IGIgfCAoMHhGRkZGIF4gKGkwIHwgYSkpO1xuXG4gICAgICBpMCA9IChpMCB8IChpMCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgICAgaTAgPSAoaTAgfCAoaTAgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICAgIGkwID0gKGkwIHwgKGkwIDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgICBpMCA9IChpMCB8IChpMCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgICBpMSA9IChpMSB8IChpMSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgICAgaTEgPSAoaTEgfCAoaTEgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICAgIGkxID0gKGkxIHwgKGkxIDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgICBpMSA9IChpMSB8IChpMSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgICByZXR1cm4gKChpMSA8PCAxKSB8IGkwKSA+Pj4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluc3BpcmVkIGJ5IGRpc2N1c3Npb24gaGVyZSBcbiAgICogaHR0cHM6Ly90d2l0dGVyLmNvbS9tb3VybmVyL3N0YXR1cy8xMDQ5MzI1MTk5NjE3OTIxMDI0IGFuZCBcbiAgICogaGVyZSBodHRwczovL2dpdGh1Yi5jb20vYW52YWthL2lzZWN0L2lzc3Vlcy8xXG4gICAqIFxuICAgKiBJdCBidWlsZHMgYW4gaW5kZXggb2YgYWxsIHNlZ21lbnRzIHVzaW5nIHN0YXRpYyBzcGF0aWFsIGluZGV4XG4gICAqIGFuZCB0aGVuIGZvciBlYWNoIHNlZ21lbnQgaXQgcXVlcmllcyBvdmVybGFwcGluZyByZWN0YW5nbGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYnVzaChsaW5lcywgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHJlcG9ydEludGVyc2VjdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMub25Gb3VuZCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXI7XG4gICAgdmFyIGFzeW5jU3RhdGU7XG5cbiAgICB2YXIgaW5kZXggPSBuZXcgRmxhdGJ1c2gobGluZXMubGVuZ3RoKTtcbiAgICBsaW5lcy5mb3JFYWNoKGFkZFRvSW5kZXgpO1xuICAgIGluZGV4LmZpbmlzaCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bjogcnVuLFxuICAgICAgc3RlcDogc3RlcCxcbiAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG5cbiAgICAgIC8vIHVuZG9jdW1lbnRlZCwgZG9uJ3QgdXNlIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmc6XG4gICAgICBjaGVja0ludGVyc2VjdGlvbjogY2hlY2tJbnRlcnNlY3Rpb25cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChjaGVja0ludGVyc2VjdGlvbihsaW5lc1tpXSwgaSkpIHtcbiAgICAgICAgICByZXR1cm47IC8vIHN0b3AgZWFybHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oY3VycmVudFNlZ21lbnQsIGN1cnJlbnRJZCkge1xuICAgICAgLy8gc29ycnkgYWJvdXQgY29kZSBkdXBsaWNhdGlvbi5cbiAgICAgIHZhciBtaW5YID0gY3VycmVudFNlZ21lbnQuZnJvbS54OyB2YXIgbWF4WCA9IGN1cnJlbnRTZWdtZW50LnRvLng7XG4gICAgICB2YXIgbWluWSA9IGN1cnJlbnRTZWdtZW50LmZyb20ueTsgdmFyIG1heFkgPSBjdXJyZW50U2VnbWVudC50by55O1xuICAgICAgdmFyIHQ7XG4gICAgICBpZiAobWluWCA+IG1heFgpIHsgdCA9IG1pblg7IG1pblggPSBtYXhYOyBtYXhYID0gdDsgfVxuICAgICAgaWYgKG1pblkgPiBtYXhZKSB7IHQgPSBtaW5ZOyBtaW5ZID0gbWF4WTsgbWF4WSA9IHQ7IH1cblxuICAgICAgdmFyIGlkcyA9IGluZGV4LnNlYXJjaChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRJbmRleCA9IGlkc1tpXTtcbiAgICAgICAgaWYgKHNlZ21lbnRJbmRleCA8PSBjdXJyZW50SWQpIHsgY29udGludWU7IH0gLy8gd2UgaGF2ZSBlaXRoZXIgcmVwb3J0ZWQgaXQsIG9yIGl0IGlzIGN1cnJlbnQuXG5cbiAgICAgICAgdmFyIG90aGVyU2VnbWVudCA9IGxpbmVzW3NlZ21lbnRJbmRleF07XG4gICAgICAgIHZhciBwb2ludCA9IGludGVyc2VjdFNlZ21lbnRzJDEob3RoZXJTZWdtZW50LCBjdXJyZW50U2VnbWVudCk7XG5cbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgaWYgKHJlcG9ydEludGVyc2VjdGlvbihwb2ludCwgW2N1cnJlbnRTZWdtZW50LCBvdGhlclNlZ21lbnRdKSkge1xuICAgICAgICAgICAgLy8gc3RvcCBlYXJseVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmICghYXN5bmNTdGF0ZSkge1xuICAgICAgICBhc3luY1N0YXRlID0ge2k6IDB9O1xuICAgICAgfVxuICAgICAgdmFyIHRlc3QgPSBsaW5lc1thc3luY1N0YXRlLmldO1xuICAgICAgY2hlY2tJbnRlcnNlY3Rpb24odGVzdCwgYXN5bmNTdGF0ZS5pKTtcbiAgICAgIGFzeW5jU3RhdGUuaSArPSAxO1xuICAgICAgcmV0dXJuIGFzeW5jU3RhdGUuaSA8IGxpbmVzLmxlbmd0aDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZFRvSW5kZXgobGluZSkge1xuICAgICAgdmFyIG1pblggPSBsaW5lLmZyb20ueDsgdmFyIG1heFggPSBsaW5lLnRvLng7XG4gICAgICB2YXIgbWluWSA9IGxpbmUuZnJvbS55OyB2YXIgbWF4WSA9IGxpbmUudG8ueTtcbiAgICAgIHZhciB0O1xuICAgICAgaWYgKG1pblggPiBtYXhYKSB7IHQgPSBtaW5YOyBtaW5YID0gbWF4WDsgbWF4WCA9IHQ7IH1cbiAgICAgIGlmIChtaW5ZID4gbWF4WSkgeyB0ID0gbWluWTsgbWluWSA9IG1heFk7IG1heFkgPSB0OyB9XG4gICAgICBpbmRleC5hZGQobWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyKHAsIGludGVyaW9yKSB7XG4gICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICBwb2ludDogcCwgXG4gICAgICAgIHNlZ21lbnRzOiBpbnRlcmlvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5zd2VlcCA9IGlzZWN0O1xuICBleHBvcnRzLmJydXRlID0gYnJ1dGU7XG4gIGV4cG9ydHMuYnVzaCA9IGJ1c2g7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzZWN0LmpzLm1hcFxuIiwiLyoqXG4gKiBKU1RTLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0c1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VETHYxLnR4dFxuICogaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VQTHYxLnR4dFxuICogaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0xJQ0VOU0VfRVM2X0NPTExFQ1RJT05TLnR4dFxuICogQGxpY2Vuc2VcbiAqL1xuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/ZShleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sZSk6ZSgodD10fHxzZWxmKS5qc3RzPXt9KX0odGhpcywoZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7Y2xhc3MgZXtjb25zdHJ1Y3Rvcigpe2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZXF1YWxzV2l0aFRvbGVyYW5jZSh0LGUsbil7cmV0dXJuIE1hdGguYWJzKHQtZSk8PW59Z2V0Q2xhc3MoKXtyZXR1cm4gZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gbih0KXt0aGlzLm1lc3NhZ2U9dH1mdW5jdGlvbiBzKHQsZSl7dGhpcy5sb3c9MHxlLHRoaXMuaGlnaD0wfHR9ZnVuY3Rpb24gaSgpe31mdW5jdGlvbiByKCl7fWZ1bmN0aW9uIG8oKXt9ZnVuY3Rpb24gbCgpe31mdW5jdGlvbiBhKCl7fWZ1bmN0aW9uIGModCl7dGhpcy5uYW1lPVwiUnVudGltZUV4Y2VwdGlvblwiLHRoaXMubWVzc2FnZT10LHRoaXMuc3RhY2s9KG5ldyBFcnJvcikuc3RhY2ssRXJyb3IuY2FsbCh0aGlzLHQpfWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxzLnRvQmluYXJ5U3RyaW5nPWZ1bmN0aW9uKHQpe2xldCBlLG49XCJcIjtmb3IoZT0yMTQ3NDgzNjQ4O2U+MDtlPj4+PTEpbis9KHQuaGlnaCZlKT09PWU/XCIxXCI6XCIwXCI7Zm9yKGU9MjE0NzQ4MzY0ODtlPjA7ZT4+Pj0xKW4rPSh0LmxvdyZlKT09PWU/XCIxXCI6XCIwXCI7cmV0dXJuIG59LGkuaXNOYU49dD0+TnVtYmVyLmlzTmFOKHQpLGkuaXNJbmZpbml0ZT10PT4hTnVtYmVyLmlzRmluaXRlKHQpLGkuTUFYX1ZBTFVFPU51bWJlci5NQVhfVkFMVUUsXCJmdW5jdGlvblwiPT10eXBlb2YgRmxvYXQ2NEFycmF5JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBJbnQzMkFycmF5P2Z1bmN0aW9uKCl7Y29uc3QgdD1uZXcgRmxvYXQ2NEFycmF5KDEpLGU9bmV3IEludDMyQXJyYXkodC5idWZmZXIpO2kuZG91YmxlVG9Mb25nQml0cz1mdW5jdGlvbihuKXt0WzBdPW47bGV0IGk9MHxlWzBdLHI9MHxlWzFdO3JldHVybiAyMTQ2NDM1MDcyPT0oMjE0NjQzNTA3MiZyKSYmMCE9KDEwNDg1NzUmcikmJjAhPT1pJiYoaT0wLHI9MjE0Njk1OTM2MCksbmV3IHMocixpKX0saS5sb25nQml0c1RvRG91YmxlPWZ1bmN0aW9uKG4pe3JldHVybiBlWzBdPW4ubG93LGVbMV09bi5oaWdoLHRbMF19fSgpOmZ1bmN0aW9uKCl7Y29uc3QgdD1NYXRoLmxvZzIsZT1NYXRoLmZsb29yLG49TWF0aC5wb3cscj1mdW5jdGlvbigpe2ZvcihsZXQgcz01MztzPjA7cy0tKXtjb25zdCBpPW4oMixzKS0xO2lmKGUodChpKSkrMT09PXMpcmV0dXJuIGl9cmV0dXJuIDB9KCk7aS5kb3VibGVUb0xvbmdCaXRzPWZ1bmN0aW9uKGkpe2xldCBvLGwsYSxjLGgsdSxnLGQsXztpZihpPDB8fDEvaT09PU51bWJlci5ORUdBVElWRV9JTkZJTklUWT8odT0xPDwzMSxpPS1pKTp1PTAsMD09PWkpcmV0dXJuIF89MCxkPXUsbmV3IHMoZCxfKTtpZihpPT09MS8wKXJldHVybiBfPTAsZD0yMTQ2NDM1MDcyfHUsbmV3IHMoZCxfKTtpZihpIT1pKXJldHVybiBfPTAsZD0yMTQ2OTU5MzYwLG5ldyBzKGQsXyk7aWYoYz0wLF89MCxvPWUoaSksbz4xKWlmKG88PXIpYz1lKHQobykpLGM8PTIwPyhfPTAsZD1vPDwyMC1jJjEwNDg1NzUpOihhPWMtMjAsbD1uKDIsYSksXz1vJWw8PDMyLWEsZD1vL2wmMTA0ODU3NSk7ZWxzZSBmb3IoYT1vLF89MDtsPWEvMixhPWUobCksMCE9PWE7KWMrKyxfPj4+PTEsX3w9KDEmZCk8PDMxLGQ+Pj49MSxsIT09YSYmKGR8PTUyNDI4OCk7aWYoZz1jKzEwMjMsaD0wPT09byxvPWktbyxjPDUyJiYwIT09bylmb3IoYT0wOzspe2lmKGw9MipvLGw+PTE/KG89bC0xLGg/KGctLSxoPSExKTooYTw8PTEsYXw9MSxjKyspKToobz1sLGg/MD09LS1nJiYoYysrLGg9ITEpOihhPDw9MSxjKyspKSwyMD09PWMpZHw9YSxhPTA7ZWxzZSBpZig1Mj09PWMpe198PWE7YnJlYWt9aWYoMT09PWwpe2M8MjA/ZHw9YTw8MjAtYzpjPDUyJiYoX3w9YTw8NTItYyk7YnJlYWt9fXJldHVybiBkfD1nPDwyMCxkfD11LG5ldyBzKGQsXyl9LGkubG9uZ0JpdHNUb0RvdWJsZT1mdW5jdGlvbih0KXtsZXQgZSxzLGkscixvO2NvbnN0IGw9dC5oaWdoLGE9dC5sb3c7Zm9yKGk9bCYxPDwzMT8tMToxLHI9KCgyMTQ2NDM1MDcyJmwpPj4yMCktMTAyMyxvPTAscz0xPDwxOSxlPTE7ZTw9MjA7ZSsrKWwmcyYmKG8rPW4oMiwtZSkpLHM+Pj49MTtmb3Iocz0xPDwzMSxlPTIxO2U8PTUyO2UrKylhJnMmJihvKz1uKDIsLWUpKSxzPj4+PTE7aWYoLTEwMjM9PT1yKXtpZigwPT09bylyZXR1cm4gMCppO3I9LTEwMjJ9ZWxzZXtpZigxMDI0PT09cilyZXR1cm4gMD09PW8/aS8wOk5hTjtvKz0xfXJldHVybiBpKm8qbigyLHIpfX0oKSxjLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSksYy5wcm90b3R5cGUuY29uc3RydWN0b3I9RXJyb3I7Y2xhc3MgaCBleHRlbmRzIGN7Y29uc3RydWN0b3IoKXtzdXBlcigpLGguY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBofWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1oLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWMuY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Yy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX07Y2xhc3MgdXtjb25zdHJ1Y3Rvcigpe3UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl1LnNob3VsZE5ldmVyUmVhY2hIZXJlKG51bGwpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3Rocm93IG5ldyBoKFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIisobnVsbCE9PXQ/XCI6IFwiK3Q6XCJcIikpfX1zdGF0aWMgaXNUcnVlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3UuaXNUcnVlKHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXQpdGhyb3cgbnVsbD09PWU/bmV3IGg6bmV3IGgoZSl9fXN0YXRpYyBlcXVhbHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dS5lcXVhbHModCxlLG51bGwpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKCFlLmVxdWFscyh0KSl0aHJvdyBuZXcgaChcIkV4cGVjdGVkIFwiK3QrXCIgYnV0IGVuY291bnRlcmVkIFwiK2UrKG51bGwhPT1uP1wiOiBcIituOlwiXCIpKX19Z2V0Q2xhc3MoKXtyZXR1cm4gdX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGd7Y29uc3RydWN0b3IoKXtnLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGhhc2hDb2RlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9aS5kb3VibGVUb0xvbmdCaXRzKHQpO3JldHVybiBNYXRoLnRydW5jKGVeZT4+PjMyKX19c2V0T3JkaW5hdGUodCxlKXtzd2l0Y2godCl7Y2FzZSBnLlg6dGhpcy54PWU7YnJlYWs7Y2FzZSBnLlk6dGhpcy55PWU7YnJlYWs7Y2FzZSBnLlo6dGhpcy56PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgbihcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfX1lcXVhbHMyRCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy54PT09dC54JiZ0aGlzLnk9PT10Lnl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiEhZS5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueCx0LngsbikmJiEhZS5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueSx0Lnksbil9fWdldE9yZGluYXRlKHQpe3N3aXRjaCh0KXtjYXNlIGcuWDpyZXR1cm4gdGhpcy54O2Nhc2UgZy5ZOnJldHVybiB0aGlzLnk7Y2FzZSBnLlo6cmV0dXJuIHRoaXMuen10aHJvdyBuZXcgbihcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfWVxdWFsczNEKHQpe3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueSYmKHRoaXMuej09PXQuenx8aS5pc05hTih0aGlzLnopJiZpLmlzTmFOKHQueikpfWVxdWFscyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGcmJnRoaXMuZXF1YWxzMkQodCl9ZXF1YWxJbloodCxuKXtyZXR1cm4gZS5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueix0Lnosbil9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy54PGUueD8tMTp0aGlzLng+ZS54PzE6dGhpcy55PGUueT8tMTp0aGlzLnk+ZS55PzE6MH1jbG9uZSgpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJ0aGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGlzIGNsYXNzIGlzIENsb25lYWJsZVwiKSxudWxsO3Rocm93IHR9fWNvcHkoKXtyZXR1cm4gbmV3IGcodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm5cIihcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIiwgXCIrdGhpcy56K1wiKVwifWRpc3RhbmNlM0QodCl7Y29uc3QgZT10aGlzLngtdC54LG49dGhpcy55LXQueSxzPXRoaXMuei10Lno7cmV0dXJuIE1hdGguc3FydChlKmUrbipuK3Mqcyl9ZGlzdGFuY2UodCl7Y29uc3QgZT10aGlzLngtdC54LG49dGhpcy55LXQueTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4pfWhhc2hDb2RlKCl7bGV0IHQ9MTc7cmV0dXJuIHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMueCksdD0zNyp0K2cuaGFzaENvZGUodGhpcy55KSx0fXNldENvb3JkaW5hdGUodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10Lnp9Z2V0Q2xhc3MoKXtyZXR1cm4gZ31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcixvLGFdfX1jbGFzcyBke2NvbnN0cnVjdG9yKCl7ZC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21wYXJlKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTppLmlzTmFOKHQpP2kuaXNOYU4oZSk/MDotMTppLmlzTmFOKGUpPzE6MH1jb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZSxpPWQuY29tcGFyZShuLngscy54KTtpZigwIT09aSlyZXR1cm4gaTtjb25zdCByPWQuY29tcGFyZShuLnkscy55KTtyZXR1cm4gMCE9PXI/cjp0aGlzLl9kaW1lbnNpb25zVG9UZXN0PD0yPzA6ZC5jb21wYXJlKG4ueixzLnopfWdldENsYXNzKCl7cmV0dXJuIGR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1mdW5jdGlvbiBfKHQsZSl7cmV0dXJuIHQuaW50ZXJmYWNlc18mJnQuaW50ZXJmYWNlc18uaW5kZXhPZihlKT4tMX1mdW5jdGlvbiBmKCl7fWZ1bmN0aW9uIHAodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gbSgpe31mdW5jdGlvbiB5KHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIHgoKXt0aGlzLmFycmF5Xz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGYmJnRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSl9ZC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9kaW1lbnNpb25zVG9UZXN0PTIsMD09PWFyZ3VtZW50cy5sZW5ndGgpZC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDIpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDIhPT10JiYzIT09dCl0aHJvdyBuZXcgbihcIm9ubHkgMiBvciAzIGRpbWVuc2lvbnMgbWF5IGJlIHNwZWNpZmllZFwiKTt0aGlzLl9kaW1lbnNpb25zVG9UZXN0PXR9fSxnLkRpbWVuc2lvbmFsQ29tcGFyYXRvcj1kLGcuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy56PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpZy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDAsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQueCx0LnksdC56KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtnLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLGcuTlVMTF9PUkRJTkFURSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy54PXQsdGhpcy55PWUsdGhpcy56PW59fSxnLnNlcmlhbFZlcnNpb25VSUQ9MHg1Y2JmMmMyMzVjN2U1ODAwLGcuTlVMTF9PUkRJTkFURT1pLk5hTixnLlg9MCxnLlk9MSxnLlo9MixmLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oKXt9LGYucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXt9LGYucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXt9LGYucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXt9LGYucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe30scC5wcm90b3R5cGU9bmV3IEVycm9yLHAucHJvdG90eXBlLm5hbWU9XCJJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXCIsbS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShmLnByb3RvdHlwZSksbS5wcm90b3R5cGUuY29uc3RydWN0b3I9bSxtLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt9LG0ucHJvdG90eXBlLnNldD1mdW5jdGlvbigpe30sbS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe30seS5wcm90b3R5cGU9bmV3IEVycm9yLHkucHJvdG90eXBlLm5hbWU9XCJOb1N1Y2hFbGVtZW50RXhjZXB0aW9uXCIseC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShtLnByb3RvdHlwZSkseC5wcm90b3R5cGUuY29uc3RydWN0b3I9eCx4LnByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eT1mdW5jdGlvbigpe30seC5wcm90b3R5cGUuaW50ZXJmYWNlc189W20sZl0seC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aD90aGlzLmFycmF5Xy5wdXNoKHQpOnRoaXMuYXJyYXlfLnNwbGljZShhcmd1bWVudHNbMF0sMCxhcmd1bWVudHNbMV0pLCEwfSx4LnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuYXJyYXlfPVtdfSx4LnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24odCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3JldHVybiEwfSx4LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXtjb25zdCBuPXRoaXMuYXJyYXlfW3RdO3JldHVybiB0aGlzLmFycmF5X1t0XT1lLG59LHgucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBFKHRoaXMpfSx4LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7aWYodDwwfHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgcDtyZXR1cm4gdGhpcy5hcnJheV9bdF19LHgucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0seC5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LHgucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtjb25zdCB0PVtdO2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO2U8bjtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0seC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe2xldCBlPSExO2ZvcihsZXQgbj0wLHM9dGhpcy5hcnJheV8ubGVuZ3RoO248cztuKyspaWYodGhpcy5hcnJheV9bbl09PT10KXt0aGlzLmFycmF5Xy5zcGxpY2UobiwxKSxlPSEwO2JyZWFrfXJldHVybiBlfSx4LnByb3RvdHlwZS5yZW1vdmVBbGw9ZnVuY3Rpb24odCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5yZW1vdmUoZS5uZXh0KCkpO3JldHVybiEwfTtjb25zdCBFPWZ1bmN0aW9uKHQpe3RoaXMuYXJyYXlMaXN0Xz10LHRoaXMucG9zaXRpb25fPTB9O0UucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvc2l0aW9uXz09PXRoaXMuYXJyYXlMaXN0Xy5zaXplKCkpdGhyb3cgbmV3IHk7cmV0dXJuIHRoaXMuYXJyYXlMaXN0Xy5nZXQodGhpcy5wb3NpdGlvbl8rKyl9LEUucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy5hcnJheUxpc3RfLnNpemUoKX0sRS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5TGlzdF8uc2V0KHRoaXMucG9zaXRpb25fLTEsdCl9LEUucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3RoaXMuYXJyYXlMaXN0Xy5yZW1vdmUodGhpcy5hcnJheUxpc3RfLmdldCh0aGlzLnBvc2l0aW9uXykpfTtjbGFzcyBJIGV4dGVuZHMgeHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksSS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuZ2V0KHQpfWFkZEFsbCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmXyhhcmd1bWVudHNbMF0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPSExO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXRoaXMuYWRkKHMubmV4dCgpLGUpLG49ITA7cmV0dXJuIG59cmV0dXJuIHN1cGVyLmFkZEFsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2xvbmUoKXtjb25zdCB0PXN1cGVyLmNsb25lLmNhbGwodGhpcyk7Zm9yKGxldCBlPTA7ZTx0aGlzLnNpemUoKTtlKyspdC5hZGQoZSx0aGlzLmdldChlKS5jbG9uZSgpKTtyZXR1cm4gdH10b0Nvb3JkaW5hdGVBcnJheSgpe3JldHVybiB0aGlzLnRvQXJyYXkoSS5jb29yZEFycmF5VHlwZSl9YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3N1cGVyLmFkZC5jYWxsKHRoaXMsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZCh0LGUsITApLCEwfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKCFhcmd1bWVudHNbMV0mJnRoaXMuc2l6ZSgpPj0xKXtpZih0aGlzLmdldCh0aGlzLnNpemUoKS0xKS5lcXVhbHMyRCh0KSlyZXR1cm4gbnVsbH1zdXBlci5hZGQuY2FsbCh0aGlzLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQodCxlKSwhMH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHNbMl0pZm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpcy5hZGQodFtuXSxlKTtlbHNlIGZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKXRoaXMuYWRkKHRbbl0sZSk7cmV0dXJuITB9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighYXJndW1lbnRzWzJdKXtjb25zdCBuPXRoaXMuc2l6ZSgpO2lmKG4+MCl7aWYodD4wKXtpZih0aGlzLmdldCh0LTEpLmVxdWFsczJEKGUpKXJldHVybiBudWxsfWlmKHQ8bil7aWYodGhpcy5nZXQodCkuZXF1YWxzMkQoZSkpcmV0dXJuIG51bGx9fX1zdXBlci5hZGQuY2FsbCh0aGlzLHQsZSl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2xldCBpPTE7bj5zJiYoaT0tMSk7Zm9yKGxldCByPW47ciE9PXM7cis9aSl0aGlzLmFkZCh0W3JdLGUpO3JldHVybiEwfX1jbG9zZVJpbmcoKXt0aGlzLnNpemUoKT4wJiZ0aGlzLmFkZChuZXcgZyh0aGlzLmdldCgwKSksITEpfWdldENsYXNzKCl7cmV0dXJuIEl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZW5zdXJlQ2FwYWNpdHkodC5sZW5ndGgpLHRoaXMuYWRkKHQsITApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZW5zdXJlQ2FwYWNpdHkodC5sZW5ndGgpLHRoaXMuYWRkKHQsZSl9fSxJLmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpO2NsYXNzIE57Y29uc3RydWN0b3IoKXtOLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGludGVyc2VjdHMoKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG4ueD49KHQueDxlLng/dC54OmUueCkmJm4ueDw9KHQueD5lLng/dC54OmUueCkmJm4ueT49KHQueTxlLnk/dC55OmUueSkmJm4ueTw9KHQueT5lLnk/dC55OmUueSl9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2xldCBpPU1hdGgubWluKG4ueCxzLngpLHI9TWF0aC5tYXgobi54LHMueCksbz1NYXRoLm1pbih0LngsZS54KSxsPU1hdGgubWF4KHQueCxlLngpO3JldHVybiEobz5yKSYmKCEobDxpKSYmKGk9TWF0aC5taW4obi55LHMueSkscj1NYXRoLm1heChuLnkscy55KSxvPU1hdGgubWluKHQueSxlLnkpLGw9TWF0aC5tYXgodC55LGUueSksIShvPnIpJiYhKGw8aSkpKX19Z2V0QXJlYSgpe3JldHVybiB0aGlzLmdldFdpZHRoKCkqdGhpcy5nZXRIZWlnaHQoKX1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2YgTikpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk6dGhpcy5fbWF4eD09PWUuZ2V0TWF4WCgpJiZ0aGlzLl9tYXh5PT09ZS5nZXRNYXhZKCkmJnRoaXMuX21pbng9PT1lLmdldE1pblgoKSYmdGhpcy5fbWlueT09PWUuZ2V0TWluWSgpfWludGVyc2VjdGlvbih0KXtpZih0aGlzLmlzTnVsbCgpfHx0LmlzTnVsbCgpfHwhdGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiBuZXcgTjtjb25zdCBlPXRoaXMuX21pbng+dC5fbWlueD90aGlzLl9taW54OnQuX21pbngsbj10aGlzLl9taW55PnQuX21pbnk/dGhpcy5fbWlueTp0Ll9taW55LHM9dGhpcy5fbWF4eDx0Ll9tYXh4P3RoaXMuX21heHg6dC5fbWF4eCxpPXRoaXMuX21heHk8dC5fbWF4eT90aGlzLl9tYXh5OnQuX21heHk7cmV0dXJuIG5ldyBOKGUscyxuLGkpfWlzTnVsbCgpe3JldHVybiB0aGlzLl9tYXh4PHRoaXMuX21pbnh9Z2V0TWF4WCgpe3JldHVybiB0aGlzLl9tYXh4fWNvdmVycygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0LngsdC55KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYhdC5pc051bGwoKSYmKHQuZ2V0TWluWCgpPj10aGlzLl9taW54JiZ0LmdldE1heFgoKTw9dGhpcy5fbWF4eCYmdC5nZXRNaW5ZKCk+PXRoaXMuX21pbnkmJnQuZ2V0TWF4WSgpPD10aGlzLl9tYXh5KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJih0Pj10aGlzLl9taW54JiZ0PD10aGlzLl9tYXh4JiZlPj10aGlzLl9taW55JiZlPD10aGlzLl9tYXh5KX19aW50ZXJzZWN0cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYhdC5pc051bGwoKSYmISh0Ll9taW54PnRoaXMuX21heHh8fHQuX21heHg8dGhpcy5fbWlueHx8dC5fbWlueT50aGlzLl9tYXh5fHx0Ll9tYXh5PHRoaXMuX21pbnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW50ZXJzZWN0cyh0LngsdC55KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYoISgodC54PGUueD90Lng6ZS54KT50aGlzLl9tYXh4KSYmKCEoKHQueD5lLng/dC54OmUueCk8dGhpcy5fbWlueCkmJighKCh0Lnk8ZS55P3QueTplLnkpPnRoaXMuX21heHkpJiYhKCh0Lnk+ZS55P3QueTplLnkpPHRoaXMuX21pbnkpKSkpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYhKHQ+dGhpcy5fbWF4eHx8dDx0aGlzLl9taW54fHxlPnRoaXMuX21heHl8fGU8dGhpcy5fbWlueSl9fX1nZXRNaW5ZKCl7cmV0dXJuIHRoaXMuX21pbnl9Z2V0TWluWCgpe3JldHVybiB0aGlzLl9taW54fWV4cGFuZFRvSW5jbHVkZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXhwYW5kVG9JbmNsdWRlKHQueCx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuaXNOdWxsKCk/KHRoaXMuX21pbng9dC5nZXRNaW5YKCksdGhpcy5fbWF4eD10LmdldE1heFgoKSx0aGlzLl9taW55PXQuZ2V0TWluWSgpLHRoaXMuX21heHk9dC5nZXRNYXhZKCkpOih0Ll9taW54PHRoaXMuX21pbngmJih0aGlzLl9taW54PXQuX21pbngpLHQuX21heHg+dGhpcy5fbWF4eCYmKHRoaXMuX21heHg9dC5fbWF4eCksdC5fbWlueTx0aGlzLl9taW55JiYodGhpcy5fbWlueT10Ll9taW55KSx0Ll9tYXh5PnRoaXMuX21heHkmJih0aGlzLl9tYXh5PXQuX21heHkpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pc051bGwoKT8odGhpcy5fbWlueD10LHRoaXMuX21heHg9dCx0aGlzLl9taW55PWUsdGhpcy5fbWF4eT1lKToodDx0aGlzLl9taW54JiYodGhpcy5fbWlueD10KSx0PnRoaXMuX21heHgmJih0aGlzLl9tYXh4PXQpLGU8dGhpcy5fbWlueSYmKHRoaXMuX21pbnk9ZSksZT50aGlzLl9tYXh5JiYodGhpcy5fbWF4eT1lKSl9fW1pbkV4dGVudCgpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiB0PGU/dDplfWdldFdpZHRoKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLl9tYXh4LXRoaXMuX21pbnh9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpPzA6LTE6ZS5pc051bGwoKT8xOnRoaXMuX21pbng8ZS5fbWlueD8tMTp0aGlzLl9taW54PmUuX21pbng/MTp0aGlzLl9taW55PGUuX21pbnk/LTE6dGhpcy5fbWlueT5lLl9taW55PzE6dGhpcy5fbWF4eDxlLl9tYXh4Py0xOnRoaXMuX21heHg+ZS5fbWF4eD8xOnRoaXMuX21heHk8ZS5fbWF4eT8tMTp0aGlzLl9tYXh5PmUuX21heHk/MTowfXRyYW5zbGF0ZSh0LGUpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5pbml0KHRoaXMuZ2V0TWluWCgpK3QsdGhpcy5nZXRNYXhYKCkrdCx0aGlzLmdldE1pblkoKStlLHRoaXMuZ2V0TWF4WSgpK2UpfXRvU3RyaW5nKCl7cmV0dXJuXCJFbnZbXCIrdGhpcy5fbWlueCtcIiA6IFwiK3RoaXMuX21heHgrXCIsIFwiK3RoaXMuX21pbnkrXCIgOiBcIit0aGlzLl9tYXh5K1wiXVwifXNldFRvTnVsbCgpe3RoaXMuX21pbng9MCx0aGlzLl9tYXh4PS0xLHRoaXMuX21pbnk9MCx0aGlzLl9tYXh5PS0xfWdldEhlaWdodCgpe3JldHVybiB0aGlzLmlzTnVsbCgpPzA6dGhpcy5fbWF4eS10aGlzLl9taW55fW1heEV4dGVudCgpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiB0PmU/dDplfWV4cGFuZEJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXhwYW5kQnkodCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuX21pbngtPXQsdGhpcy5fbWF4eCs9dCx0aGlzLl9taW55LT1lLHRoaXMuX21heHkrPWUsKHRoaXMuX21pbng+dGhpcy5fbWF4eHx8dGhpcy5fbWlueT50aGlzLl9tYXh5KSYmdGhpcy5zZXRUb051bGwoKX19Y29udGFpbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvdmVycyh0LGUpfX1jZW50cmUoKXtyZXR1cm4gdGhpcy5pc051bGwoKT9udWxsOm5ldyBnKCh0aGlzLmdldE1pblgoKSt0aGlzLmdldE1heFgoKSkvMiwodGhpcy5nZXRNaW5ZKCkrdGhpcy5nZXRNYXhZKCkpLzIpfWluaXQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnNldFRvTnVsbCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQueCx0LngsdC55LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21pbng9dC5fbWlueCx0aGlzLl9tYXh4PXQuX21heHgsdGhpcy5fbWlueT10Ll9taW55LHRoaXMuX21heHk9dC5fbWF4eX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0KHQueCxlLngsdC55LGUueSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dDxlPyh0aGlzLl9taW54PXQsdGhpcy5fbWF4eD1lKToodGhpcy5fbWlueD1lLHRoaXMuX21heHg9dCksbjxzPyh0aGlzLl9taW55PW4sdGhpcy5fbWF4eT1zKToodGhpcy5fbWlueT1zLHRoaXMuX21heHk9bil9fWdldE1heFkoKXtyZXR1cm4gdGhpcy5fbWF4eX1kaXN0YW5jZSh0KXtpZih0aGlzLmludGVyc2VjdHModCkpcmV0dXJuIDA7bGV0IGU9MDt0aGlzLl9tYXh4PHQuX21pbng/ZT10Ll9taW54LXRoaXMuX21heHg6dGhpcy5fbWlueD50Ll9tYXh4JiYoZT10aGlzLl9taW54LXQuX21heHgpO2xldCBuPTA7cmV0dXJuIHRoaXMuX21heHk8dC5fbWlueT9uPXQuX21pbnktdGhpcy5fbWF4eTp0aGlzLl9taW55PnQuX21heHkmJihuPXRoaXMuX21pbnktdC5fbWF4eSksMD09PWU/bjowPT09bj9lOk1hdGguc3FydChlKmUrbipuKX1oYXNoQ29kZSgpe2xldCB0PTE3O3JldHVybiB0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLl9taW54KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLl9tYXh4KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLl9taW55KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLl9tYXh5KSx0fWdldENsYXNzKCl7cmV0dXJuIE59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3IsYV19fWZ1bmN0aW9uIEMoKXt9Ti5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9taW54PW51bGwsdGhpcy5fbWF4eD1udWxsLHRoaXMuX21pbnk9bnVsbCx0aGlzLl9tYXh5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodC54LGUueCx0LnksZS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLmluaXQodCxlLG4scyl9fSxOLnNlcmlhbFZlcnNpb25VSUQ9MHg1MTg0NWNkNTUyMTg5ODAwO2NsYXNzIFMgZXh0ZW5kcyBDe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxTLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gU31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gdyh0KXt0aGlzLnN0cj10fWZ1bmN0aW9uIEwodCl7dGhpcy52YWx1ZT10fWZ1bmN0aW9uIFQoKXt9Uy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtDLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsXCJQcm9qZWN0aXZlIHBvaW50IG5vdCByZXByZXNlbnRhYmxlIG9uIHRoZSBDYXJ0ZXNpYW4gcGxhbmUuXCIpfSx3LnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24odCl7dGhpcy5zdHIrPXR9LHcucHJvdG90eXBlLnNldENoYXJBdD1mdW5jdGlvbih0LGUpe3RoaXMuc3RyPXRoaXMuc3RyLnN1YnN0cigwLHQpK2UrdGhpcy5zdHIuc3Vic3RyKHQrMSl9LHcucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0cn0sTC5wcm90b3R5cGUuaW50VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sTC5wcm90b3R5cGUuY29tcGFyZVRvPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnZhbHVlPHQ/LTE6dGhpcy52YWx1ZT50PzE6MH0sTC5pc05hTj10PT5OdW1iZXIuaXNOYU4odCksVC5pc1doaXRlc3BhY2U9dD0+dDw9MzImJnQ+PTB8fDEyNz09PXQsVC50b1VwcGVyQ2FzZT10PT50LnRvVXBwZXJDYXNlKCk7Y2xhc3MgUntjb25zdHJ1Y3Rvcigpe1IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc3FyKHQpe3JldHVybiBSLnZhbHVlT2YodCkuc2VsZk11bHRpcGx5KHQpfXN0YXRpYyB2YWx1ZU9mKCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIFIucGFyc2UodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBSKHQpfX1zdGF0aWMgc3FydCh0KXtyZXR1cm4gUi52YWx1ZU9mKHQpLnNxcnQoKX1zdGF0aWMgcGFyc2UodCl7bGV0IGU9MDtjb25zdCBuPXQubGVuZ3RoO2Zvcig7VC5pc1doaXRlc3BhY2UodC5jaGFyQXQoZSkpOyllKys7bGV0IHM9ITE7aWYoZTxuKXtjb25zdCBuPXQuY2hhckF0KGUpO1wiLVwiIT09biYmXCIrXCIhPT1ufHwoZSsrLFwiLVwiPT09biYmKHM9ITApKX1jb25zdCBpPW5ldyBSO2xldCByPTAsbz0wLGw9MDtmb3IoOyEoZT49bik7KXtjb25zdCBuPXQuY2hhckF0KGUpO2lmKGUrKyxULmlzRGlnaXQobikpe2NvbnN0IHQ9bi1cIjBcIjtpLnNlbGZNdWx0aXBseShSLlRFTiksaS5zZWxmQWRkKHQpLHIrK31lbHNle2lmKFwiLlwiIT09bil7aWYoXCJlXCI9PT1ufHxcIkVcIj09PW4pe2NvbnN0IG49dC5zdWJzdHJpbmcoZSk7dHJ5e2w9TC5wYXJzZUludChuKX1jYXRjaChlKXt0aHJvdyBlIGluc3RhbmNlb2YgTnVtYmVyRm9ybWF0RXhjZXB0aW9uP25ldyBOdW1iZXJGb3JtYXRFeGNlcHRpb24oXCJJbnZhbGlkIGV4cG9uZW50IFwiK24rXCIgaW4gc3RyaW5nIFwiK3QpOmV9YnJlYWt9dGhyb3cgbmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIituK1wiJyBhdCBwb3NpdGlvbiBcIitlK1wiIGluIHN0cmluZyBcIit0KX1vPXJ9fWxldCBhPWk7Y29uc3QgYz1yLW8tbDtpZigwPT09YylhPWk7ZWxzZSBpZihjPjApe2NvbnN0IHQ9Ui5URU4ucG93KGMpO2E9aS5kaXZpZGUodCl9ZWxzZSBpZihjPDApe2NvbnN0IHQ9Ui5URU4ucG93KC1jKTthPWkubXVsdGlwbHkodCl9cmV0dXJuIHM/YS5uZWdhdGUoKTphfXN0YXRpYyBjcmVhdGVOYU4oKXtyZXR1cm4gbmV3IFIoaS5OYU4saS5OYU4pfXN0YXRpYyBjb3B5KHQpe3JldHVybiBuZXcgUih0KX1zdGF0aWMgbWFnbml0dWRlKHQpe2NvbnN0IGU9TWF0aC5hYnModCksbj1NYXRoLmxvZyhlKS9NYXRoLmxvZygxMCk7bGV0IHM9TWF0aC50cnVuYyhNYXRoLmZsb29yKG4pKTtyZXR1cm4gMTAqTWF0aC5wb3coMTAscyk8PWUmJihzKz0xKSxzfXN0YXRpYyBzdHJpbmdPZkNoYXIodCxlKXtjb25zdCBuPW5ldyB3O2ZvcihsZXQgcz0wO3M8ZTtzKyspbi5hcHBlbmQodCk7cmV0dXJuIG4udG9TdHJpbmcoKX1sZSh0KXtyZXR1cm4gdGhpcy5faGk8dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPD10Ll9sb31leHRyYWN0U2lnbmlmaWNhbnREaWdpdHModCxlKXtsZXQgbj10aGlzLmFicygpLHM9Ui5tYWduaXR1ZGUobi5faGkpO2NvbnN0IGk9Ui5URU4ucG93KHMpO249bi5kaXZpZGUoaSksbi5ndChSLlRFTik/KG49bi5kaXZpZGUoUi5URU4pLHMrPTEpOm4ubHQoUi5PTkUpJiYobj1uLm11bHRpcGx5KFIuVEVOKSxzLT0xKTtjb25zdCByPXMrMSxvPW5ldyB3LGw9Ui5NQVhfUFJJTlRfRElHSVRTLTE7Zm9yKGxldCBlPTA7ZTw9bDtlKyspe3QmJmU9PT1yJiZvLmFwcGVuZChcIi5cIik7Y29uc3Qgcz1NYXRoLnRydW5jKG4uX2hpKTtpZihzPDApYnJlYWs7bGV0IGk9ITEsYT0wO3M+OT8oaT0hMCxhPVwiOVwiKTphPVwiMFwiK3Msby5hcHBlbmQoYSksbj1uLnN1YnRyYWN0KFIudmFsdWVPZihzKSkubXVsdGlwbHkoUi5URU4pLGkmJm4uc2VsZkFkZChSLlRFTik7bGV0IGM9ITA7Y29uc3QgaD1SLm1hZ25pdHVkZShuLl9oaSk7aWYoaDwwJiZNYXRoLmFicyhoKT49bC1lJiYoYz0hMSksIWMpYnJlYWt9cmV0dXJuIGVbMF09cyxvLnRvU3RyaW5nKCl9c3FyKCl7cmV0dXJuIHRoaXMubXVsdGlwbHkodGhpcyl9ZG91YmxlVmFsdWUoKXtyZXR1cm4gdGhpcy5faGkrdGhpcy5fbG99c3VidHJhY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCh0Lm5lZ2F0ZSgpKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5hZGQoLXQpfX1lcXVhbHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG89PT10Ll9sb319aXNaZXJvKCl7cmV0dXJuIDA9PT10aGlzLl9oaSYmMD09PXRoaXMuX2xvfXNlbGZTdWJ0cmFjdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOnRoaXMuc2VsZkFkZCgtdC5faGksLXQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC10LDApfX1nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCl7cmV0dXJuIHRoaXMuaXNaZXJvKCk/XCIwLjBcIjp0aGlzLmlzTmFOKCk/XCJOYU4gXCI6bnVsbH1taW4odCl7cmV0dXJuIHRoaXMubGUodCk/dGhpczp0fXNlbGZEaXZpZGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKHQuX2hpLHQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKHQsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbCxhPW51bGwsYz1udWxsO3JldHVybiBvPXRoaXMuX2hpL3QsbD1SLlNQTElUKm8sbj1sLW8sYz1SLlNQTElUKnQsbj1sLW4scz1vLW4saT1jLXQsYT1vKnQsaT1jLWkscj10LWksYz1uKmktYStuKnIrcyppK3MqcixsPSh0aGlzLl9oaS1hLWMrdGhpcy5fbG8tbyplKS90LGM9bytsLHRoaXMuX2hpPWMsdGhpcy5fbG89by1jK2wsdGhpc319ZHVtcCgpe3JldHVyblwiREQ8XCIrdGhpcy5faGkrXCIsIFwiK3RoaXMuX2xvK1wiPlwifWRpdmlkZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbCxuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbCxhPW51bGw7cmV0dXJuIHI9dGhpcy5faGkvdC5faGksbz1SLlNQTElUKnIsZT1vLXIsYT1SLlNQTElUKnQuX2hpLGU9by1lLG49ci1lLHM9YS10Ll9oaSxsPXIqdC5faGkscz1hLXMsaT10Ll9oaS1zLGE9ZSpzLWwrZSppK24qcytuKmksbz0odGhpcy5faGktbC1hK3RoaXMuX2xvLXIqdC5fbG8pL3QuX2hpLGE9citvLG5ldyBSKGEsci1hK28pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBpLmlzTmFOKHQpP1IuY3JlYXRlTmFOKCk6Ui5jb3B5KHRoaXMpLnNlbGZEaXZpZGUodCwwKX19Z2UodCl7cmV0dXJuIHRoaXMuX2hpPnQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbz49dC5fbG99cG93KHQpe2lmKDA9PT10KXJldHVybiBSLnZhbHVlT2YoMSk7bGV0IGU9bmV3IFIodGhpcyksbj1SLnZhbHVlT2YoMSkscz1NYXRoLmFicyh0KTtpZihzPjEpZm9yKDtzPjA7KXMlMj09MSYmbi5zZWxmTXVsdGlwbHkoZSkscy89MixzPjAmJihlPWUuc3FyKCkpO2Vsc2Ugbj1lO3JldHVybiB0PDA/bi5yZWNpcHJvY2FsKCk6bn1jZWlsKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBSLk5hTjtjb25zdCB0PU1hdGguY2VpbCh0aGlzLl9oaSk7bGV0IGU9MDtyZXR1cm4gdD09PXRoaXMuX2hpJiYoZT1NYXRoLmNlaWwodGhpcy5fbG8pKSxuZXcgUih0LGUpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX2hpPGUuX2hpPy0xOnRoaXMuX2hpPmUuX2hpPzE6dGhpcy5fbG88ZS5fbG8/LTE6dGhpcy5fbG8+ZS5fbG8/MTowfXJpbnQoKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIHRoaXM7cmV0dXJuIHRoaXMuYWRkKC41KS5mbG9vcigpfXNldFZhbHVlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KHQpLHRoaXN9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdCh0KSx0aGlzfX1tYXgodCl7cmV0dXJuIHRoaXMuZ2UodCk/dGhpczp0fXNxcnQoKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBSLnZhbHVlT2YoMCk7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIFIuTmFOO2NvbnN0IHQ9MS9NYXRoLnNxcnQodGhpcy5faGkpLGU9dGhpcy5faGkqdCxuPVIudmFsdWVPZihlKSxzPXRoaXMuc3VidHJhY3Qobi5zcXIoKSkuX2hpKiguNSp0KTtyZXR1cm4gbi5hZGQocyl9c2VsZkFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZBZGQodC5faGksdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW51bGwsbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbDtyZXR1cm4gcz10aGlzLl9oaSt0LHI9cy10aGlzLl9oaSxpPXMtcixpPXQtcisodGhpcy5faGktaSksbz1pK3RoaXMuX2xvLGU9cytvLG49bysocy1lKSx0aGlzLl9oaT1lK24sdGhpcy5fbG89bisoZS10aGlzLl9oaSksdGhpc319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsLGE9bnVsbCxjPW51bGw7bz10aGlzLl9oaSt0LGk9dGhpcy5fbG8rZSxhPW8tdGhpcy5faGksYz1pLXRoaXMuX2xvLGw9by1hLHI9aS1jLGw9dC1hKyh0aGlzLl9oaS1sKSxyPWUtYysodGhpcy5fbG8tciksYT1sK2ksbj1vK2Escz1hKyhvLW4pLGE9citzO2NvbnN0IGg9bithLHU9YSsobi1oKTtyZXR1cm4gdGhpcy5faGk9aCx0aGlzLl9sbz11LHRoaXN9fXNlbGZNdWx0aXBseSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0Ll9oaSx0Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHQsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbDtvPVIuU1BMSVQqdGhpcy5faGksbj1vLXRoaXMuX2hpLGw9Ui5TUExJVCp0LG49by1uLHM9dGhpcy5faGktbixpPWwtdCxvPXRoaXMuX2hpKnQsaT1sLWkscj10LWksbD1uKmktbytuKnIrcyppK3MqcisodGhpcy5faGkqZSt0aGlzLl9sbyp0KTtjb25zdCBhPW8rbDtuPW8tYTtjb25zdCBjPWwrbjtyZXR1cm4gdGhpcy5faGk9YSx0aGlzLl9sbz1jLHRoaXN9fXNlbGZTcXIoKXtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodGhpcyl9Zmxvb3IoKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIFIuTmFOO2NvbnN0IHQ9TWF0aC5mbG9vcih0aGlzLl9oaSk7bGV0IGU9MDtyZXR1cm4gdD09PXRoaXMuX2hpJiYoZT1NYXRoLmZsb29yKHRoaXMuX2xvKSksbmV3IFIodCxlKX1uZWdhdGUoKXtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6bmV3IFIoLXRoaXMuX2hpLC10aGlzLl9sbyl9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKXJldHVybiBudWxsO3Rocm93IHR9fW11bHRpcGx5KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5pc05hTigpP1IuY3JlYXRlTmFOKCk6Ui5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gaS5pc05hTih0KT9SLmNyZWF0ZU5hTigpOlIuY29weSh0aGlzKS5zZWxmTXVsdGlwbHkodCwwKX19aXNOYU4oKXtyZXR1cm4gaS5pc05hTih0aGlzLl9oaSl9aW50VmFsdWUoKXtyZXR1cm4gTWF0aC50cnVuYyh0aGlzLl9oaSl9dG9TdHJpbmcoKXtjb25zdCB0PVIubWFnbml0dWRlKHRoaXMuX2hpKTtyZXR1cm4gdD49LTMmJnQ8PTIwP3RoaXMudG9TdGFuZGFyZE5vdGF0aW9uKCk6dGhpcy50b1NjaU5vdGF0aW9uKCl9dG9TdGFuZGFyZE5vdGF0aW9uKCl7Y29uc3QgdD10aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtpZihudWxsIT09dClyZXR1cm4gdDtjb25zdCBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITAsZSkscz1lWzBdKzE7bGV0IGk9bjtpZihcIi5cIj09PW4uY2hhckF0KDApKWk9XCIwXCIrbjtlbHNlIGlmKHM8MClpPVwiMC5cIitSLnN0cmluZ09mQ2hhcihcIjBcIiwtcykrbjtlbHNlIGlmKC0xPT09bi5pbmRleE9mKFwiLlwiKSl7Y29uc3QgdD1zLW4ubGVuZ3RoO2k9bitSLnN0cmluZ09mQ2hhcihcIjBcIix0KStcIi4wXCJ9cmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpP1wiLVwiK2k6aX1yZWNpcHJvY2FsKCl7bGV0IHQ9bnVsbCxlPW51bGwsbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGw7aT0xL3RoaXMuX2hpLHI9Ui5TUExJVCppLHQ9ci1pLGw9Ui5TUExJVCp0aGlzLl9oaSx0PXItdCxlPWktdCxuPWwtdGhpcy5faGksbz1pKnRoaXMuX2hpLG49bC1uLHM9dGhpcy5faGktbixsPXQqbi1vK3QqcytlKm4rZSpzLHI9KDEtby1sLWkqdGhpcy5fbG8pL3RoaXMuX2hpO2NvbnN0IGE9aStyO3JldHVybiBuZXcgUihhLGktYStyKX10b1NjaU5vdGF0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gUi5TQ0lfTk9UX1pFUk87Y29uc3QgdD10aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtpZihudWxsIT09dClyZXR1cm4gdDtjb25zdCBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITEsZSkscz1SLlNDSV9OT1RfRVhQT05FTlRfQ0hBUitlWzBdO2lmKFwiMFwiPT09bi5jaGFyQXQoMCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkZvdW5kIGxlYWRpbmcgemVybzogXCIrbik7bGV0IGk9XCJcIjtuLmxlbmd0aD4xJiYoaT1uLnN1YnN0cmluZygxKSk7Y29uc3Qgcj1uLmNoYXJBdCgwKStcIi5cIitpO3JldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIityK3M6citzfWFicygpe3JldHVybiB0aGlzLmlzTmFOKCk/Ui5OYU46dGhpcy5pc05lZ2F0aXZlKCk/dGhpcy5uZWdhdGUoKTpuZXcgUih0aGlzKX1pc1Bvc2l0aXZlKCl7cmV0dXJuIHRoaXMuX2hpPjB8fDA9PT10aGlzLl9oaSYmdGhpcy5fbG8+MH1sdCh0KXtyZXR1cm4gdGhpcy5faGk8dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPHQuX2xvfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIFIuY29weSh0aGlzKS5zZWxmQWRkKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBSLmNvcHkodGhpcykuc2VsZkFkZCh0KX19aW5pdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9oaT10LHRoaXMuX2xvPTB9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2hpPXQuX2hpLHRoaXMuX2xvPXQuX2xvfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9oaT10LHRoaXMuX2xvPWV9fWd0KHQpe3JldHVybiB0aGlzLl9oaT50Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG8+dC5fbG99aXNOZWdhdGl2ZSgpe3JldHVybiB0aGlzLl9oaTwwfHwwPT09dGhpcy5faGkmJnRoaXMuX2xvPDB9dHJ1bmMoKXtyZXR1cm4gdGhpcy5pc05hTigpP1IuTmFOOnRoaXMuaXNQb3NpdGl2ZSgpP3RoaXMuZmxvb3IoKTp0aGlzLmNlaWwoKX1zaWdudW0oKXtyZXR1cm4gdGhpcy5faGk+MD8xOnRoaXMuX2hpPDA/LTE6dGhpcy5fbG8+MD8xOnRoaXMuX2xvPDA/LTE6MH1nZXRDbGFzcygpe3JldHVybiBSfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthLHIsb119fVIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5faGk9MCx0aGlzLl9sbz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1lbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO1IuY29uc3RydWN0b3JfLmNhbGwodGhpcyxSLnBhcnNlKHQpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0KHQsZSl9fSxSLlBJPW5ldyBSKDMuMTQxNTkyNjUzNTg5NzkzLDEyMjQ2NDY3OTkxNDczNTMyZS0zMiksUi5UV09fUEk9bmV3IFIoNi4yODMxODUzMDcxNzk1ODYsMjQ0OTI5MzU5ODI5NDcwNjRlLTMyKSxSLlBJXzI9bmV3IFIoMS41NzA3OTYzMjY3OTQ4OTY2LDYxMjMyMzM5OTU3MzY3NjZlLTMyKSxSLkU9bmV3IFIoMi43MTgyODE4Mjg0NTkwNDUsMTQ0NTY0Njg5MTcyOTI1MDJlLTMyKSxSLk5hTj1uZXcgUihpLk5hTixpLk5hTiksUi5FUFM9MTIzMjU5NTE2NDQwNzgzZS00NixSLlNQTElUPTEzNDIxNzcyOSxSLk1BWF9QUklOVF9ESUdJVFM9MzIsUi5URU49Ui52YWx1ZU9mKDEwKSxSLk9ORT1SLnZhbHVlT2YoMSksUi5TQ0lfTk9UX0VYUE9ORU5UX0NIQVI9XCJFXCIsUi5TQ0lfTk9UX1pFUk89XCIwLjBFMFwiO2NsYXNzIFB7Y29uc3RydWN0b3IoKXtQLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG9yaWVudGF0aW9uSW5kZXgodCxlLG4pe2NvbnN0IHM9UC5vcmllbnRhdGlvbkluZGV4RmlsdGVyKHQsZSxuKTtpZihzPD0xKXJldHVybiBzO2NvbnN0IGk9Ui52YWx1ZU9mKGUueCkuc2VsZkFkZCgtdC54KSxyPVIudmFsdWVPZihlLnkpLnNlbGZBZGQoLXQueSksbz1SLnZhbHVlT2Yobi54KS5zZWxmQWRkKC1lLngpLGw9Ui52YWx1ZU9mKG4ueSkuc2VsZkFkZCgtZS55KTtyZXR1cm4gaS5zZWxmTXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KHIuc2VsZk11bHRpcGx5KG8pKS5zaWdudW0oKX1zdGF0aWMgc2lnbk9mRGV0MngyKCl7aWYoYXJndW1lbnRzWzNdaW5zdGFuY2VvZiBSJiZhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFImJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgUiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtyZXR1cm4gdC5tdWx0aXBseShzKS5zZWxmU3VidHJhY3QoZS5tdWx0aXBseShuKSkuc2lnbnVtKCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1szXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1SLnZhbHVlT2YodCkscj1SLnZhbHVlT2YoZSksbz1SLnZhbHVlT2YobiksbD1SLnZhbHVlT2Yocyk7cmV0dXJuIGkubXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KHIubXVsdGlwbHkobykpLnNpZ251bSgpfX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9Ui52YWx1ZU9mKHMueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KFIudmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpKSxyPVIudmFsdWVPZihzLngpLnNlbGZTdWJ0cmFjdChuLngpLnNlbGZNdWx0aXBseShSLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QodC55KSksbz1pLnN1YnRyYWN0KHIpLGw9Ui52YWx1ZU9mKHMueCkuc2VsZlN1YnRyYWN0KG4ueCkuc2VsZk11bHRpcGx5KFIudmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChuLnkpKSxhPVIudmFsdWVPZihzLnkpLnNlbGZTdWJ0cmFjdChuLnkpLnNlbGZNdWx0aXBseShSLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qobi54KSksYz1sLnN1YnRyYWN0KGEpLnNlbGZEaXZpZGUobykuZG91YmxlVmFsdWUoKSxoPVIudmFsdWVPZih0LngpLnNlbGZBZGQoUi52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KGMpKS5kb3VibGVWYWx1ZSgpLHU9Ui52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KFIudmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChuLnkpKSxkPVIudmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShSLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qobi54KSksXz11LnN1YnRyYWN0KGQpLnNlbGZEaXZpZGUobykuZG91YmxlVmFsdWUoKSxmPVIudmFsdWVPZihuLnkpLnNlbGZBZGQoUi52YWx1ZU9mKHMueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KF8pKS5kb3VibGVWYWx1ZSgpO3JldHVybiBuZXcgZyhoLGYpfXN0YXRpYyBvcmllbnRhdGlvbkluZGV4RmlsdGVyKHQsZSxuKXtsZXQgcz1udWxsO2NvbnN0IGk9KHQueC1uLngpKihlLnktbi55KSxyPSh0Lnktbi55KSooZS54LW4ueCksbz1pLXI7aWYoaT4wKXtpZihyPD0wKXJldHVybiBQLnNpZ251bShvKTtzPWkrcn1lbHNle2lmKCEoaTwwKSlyZXR1cm4gUC5zaWdudW0obyk7aWYocj49MClyZXR1cm4gUC5zaWdudW0obyk7cz0taS1yfWNvbnN0IGw9UC5EUF9TQUZFX0VQU0lMT04qcztyZXR1cm4gbz49bHx8LW8+PWw/UC5zaWdudW0obyk6Mn1zdGF0aWMgc2lnbnVtKHQpe3JldHVybiB0PjA/MTp0PDA/LTE6MH1nZXRDbGFzcygpe3JldHVybiBQfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1QLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sUC5EUF9TQUZFX0VQU0lMT049MWUtMTU7Y2xhc3Mgdntjb25zdHJ1Y3Rvcigpe3YuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW5kZXgodCxlLG4pe3JldHVybiBQLm9yaWVudGF0aW9uSW5kZXgodCxlLG4pfXN0YXRpYyBpc0NDVyh0KXtjb25zdCBlPXQubGVuZ3RoLTE7aWYoZTwzKXRocm93IG5ldyBuKFwiUmluZyBoYXMgZmV3ZXIgdGhhbiA0IHBvaW50cywgc28gb3JpZW50YXRpb24gY2Fubm90IGJlIGRldGVybWluZWRcIik7bGV0IHM9dFswXSxpPTA7Zm9yKGxldCBuPTE7bjw9ZTtuKyspe2NvbnN0IGU9dFtuXTtlLnk+cy55JiYocz1lLGk9bil9bGV0IHI9aTtkb3tyLT0xLHI8MCYmKHI9ZSl9d2hpbGUodFtyXS5lcXVhbHMyRChzKSYmciE9PWkpO2xldCBvPWk7ZG97bz0obysxKSVlfXdoaWxlKHRbb10uZXF1YWxzMkQocykmJm8hPT1pKTtjb25zdCBsPXRbcl0sYT10W29dO2lmKGwuZXF1YWxzMkQocyl8fGEuZXF1YWxzMkQocyl8fGwuZXF1YWxzMkQoYSkpcmV0dXJuITE7Y29uc3QgYz12LmluZGV4KGwscyxhKTtsZXQgaD1udWxsO3JldHVybiBoPTA9PT1jP2wueD5hLng6Yz4wLGh9Z2V0Q2xhc3MoKXtyZXR1cm4gdn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gTygpe312LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sdi5DTE9DS1dJU0U9LTEsdi5SSUdIVD12LkNMT0NLV0lTRSx2LkNPVU5URVJDTE9DS1dJU0U9MSx2LkxFRlQ9di5DT1VOVEVSQ0xPQ0tXSVNFLHYuQ09MTElORUFSPTAsdi5TVFJBSUdIVD12LkNPTExJTkVBUixPLmFycmF5Y29weT0odCxlLG4scyxpKT0+e2xldCByPTA7Zm9yKGxldCBvPWU7bzxlK2k7bysrKW5bcytyXT10W29dLHIrK30sTy5nZXRQcm9wZXJ0eT10PT4oe1wibGluZS5zZXBhcmF0b3JcIjpcIlxcblwifVt0XSk7Y2xhc3MgYntjb25zdHJ1Y3Rvcigpe2IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IHI9dC55LWUueSxvPWUueC10LngsbD10LngqZS55LWUueCp0LnksYT1uLnktcy55LGM9cy54LW4ueCxoPW4ueCpzLnktcy54Km4ueSx1PXIqYy1hKm8sZD0obypoLWMqbCkvdSxfPShhKmwtcipoKS91O2lmKGkuaXNOYU4oZCl8fGkuaXNJbmZpbml0ZShkKXx8aS5pc05hTihfKXx8aS5pc0luZmluaXRlKF8pKXRocm93IG5ldyBTO3JldHVybiBuZXcgZyhkLF8pfWdldFkoKXtjb25zdCB0PXRoaXMueS90aGlzLnc7aWYoaS5pc05hTih0KXx8aS5pc0luZmluaXRlKHQpKXRocm93IG5ldyBTO3JldHVybiB0fWdldFgoKXtjb25zdCB0PXRoaXMueC90aGlzLnc7aWYoaS5pc05hTih0KXx8aS5pc0luZmluaXRlKHQpKXRocm93IG5ldyBTO3JldHVybiB0fWdldENvb3JkaW5hdGUoKXtjb25zdCB0PW5ldyBnO3JldHVybiB0Lng9dGhpcy5nZXRYKCksdC55PXRoaXMuZ2V0WSgpLHR9Z2V0Q2xhc3MoKXtyZXR1cm4gYn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Yi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLnc9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLng9MCx0aGlzLnk9MCx0aGlzLnc9MTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy53PTF9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy54PXQsdGhpcy55PWUsdGhpcy53PTF9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGImJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgYil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy54PXQueSplLnctZS55KnQudyx0aGlzLnk9ZS54KnQudy10LngqZS53LHRoaXMudz10LngqZS55LWUueCp0Lnl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy54PXQueS1lLnksdGhpcy55PWUueC10LngsdGhpcy53PXQueCplLnktZS54KnQueX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy54PXQsdGhpcy55PWUsdGhpcy53PW59ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT10LnktZS55LHI9ZS54LXQueCxvPXQueCplLnktZS54KnQueSxsPW4ueS1zLnksYT1zLngtbi54LGM9bi54KnMueS1zLngqbi55O3RoaXMueD1yKmMtYSpvLHRoaXMueT1sKm8taSpjLHRoaXMudz1pKmEtbCpyfX07Y2xhc3MgTXtjb25zdHJ1Y3Rvcigpe00uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbG9nMTAodCl7Y29uc3QgZT1NYXRoLmxvZyh0KTtyZXR1cm4gaS5pc0luZmluaXRlKGUpfHxpLmlzTmFOKGUpP2U6ZS9NLkxPR18xMH1zdGF0aWMgbWluKHQsZSxuLHMpe2xldCBpPXQ7cmV0dXJuIGU8aSYmKGk9ZSksbjxpJiYoaT1uKSxzPGkmJihpPXMpLGl9c3RhdGljIGNsYW1wKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQ8ZT9lOnQ+bj9uOnR9aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQ8ZT9lOnQ+bj9uOnR9fXN0YXRpYyB3cmFwKHQsZSl7cmV0dXJuIHQ8MD9lLSAtdCVlOnQlZX1zdGF0aWMgbWF4KCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2xldCBzPXQ7cmV0dXJuIGU+cyYmKHM9ZSksbj5zJiYocz1uKSxzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtsZXQgaT10O3JldHVybiBlPmkmJihpPWUpLG4+aSYmKGk9bikscz5pJiYoaT1zKSxpfX1zdGF0aWMgYXZlcmFnZSh0LGUpe3JldHVybih0K2UpLzJ9Z2V0Q2xhc3MoKXtyZXR1cm4gTX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LE0uTE9HXzEwPU1hdGgubG9nKDEwKTtjbGFzcyBEe2NvbnN0cnVjdG9yKCl7RC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzZWdtZW50VG9TZWdtZW50KHQsZSxuLHMpe2lmKHQuZXF1YWxzKGUpKXJldHVybiBELnBvaW50VG9TZWdtZW50KHQsbixzKTtpZihuLmVxdWFscyhzKSlyZXR1cm4gRC5wb2ludFRvU2VnbWVudChzLHQsZSk7bGV0IGk9ITE7aWYoTi5pbnRlcnNlY3RzKHQsZSxuLHMpKXtjb25zdCByPShlLngtdC54KSoocy55LW4ueSktKGUueS10LnkpKihzLngtbi54KTtpZigwPT09cilpPSEwO2Vsc2V7Y29uc3Qgbz0odC55LW4ueSkqKHMueC1uLngpLSh0Lngtbi54KSoocy55LW4ueSksbD0oKHQueS1uLnkpKihlLngtdC54KS0odC54LW4ueCkqKGUueS10LnkpKS9yLGE9by9yOyhhPDB8fGE+MXx8bDwwfHxsPjEpJiYoaT0hMCl9fWVsc2UgaT0hMDtyZXR1cm4gaT9NLm1pbihELnBvaW50VG9TZWdtZW50KHQsbixzKSxELnBvaW50VG9TZWdtZW50KGUsbixzKSxELnBvaW50VG9TZWdtZW50KG4sdCxlKSxELnBvaW50VG9TZWdtZW50KHMsdCxlKSk6MH1zdGF0aWMgcG9pbnRUb1NlZ21lbnQodCxlLG4pe2lmKGUueD09PW4ueCYmZS55PT09bi55KXJldHVybiB0LmRpc3RhbmNlKGUpO2NvbnN0IHM9KG4ueC1lLngpKihuLngtZS54KSsobi55LWUueSkqKG4ueS1lLnkpLGk9KCh0LngtZS54KSoobi54LWUueCkrKHQueS1lLnkpKihuLnktZS55KSkvcztpZihpPD0wKXJldHVybiB0LmRpc3RhbmNlKGUpO2lmKGk+PTEpcmV0dXJuIHQuZGlzdGFuY2Uobik7Y29uc3Qgcj0oKGUueS10LnkpKihuLngtZS54KS0oZS54LXQueCkqKG4ueS1lLnkpKS9zO3JldHVybiBNYXRoLmFicyhyKSpNYXRoLnNxcnQocyl9c3RhdGljIHBvaW50VG9MaW5lUGVycGVuZGljdWxhcih0LGUsbil7Y29uc3Qgcz0obi54LWUueCkqKG4ueC1lLngpKyhuLnktZS55KSoobi55LWUueSksaT0oKGUueS10LnkpKihuLngtZS54KS0oZS54LXQueCkqKG4ueS1lLnkpKS9zO3JldHVybiBNYXRoLmFicyhpKSpNYXRoLnNxcnQocyl9c3RhdGljIHBvaW50VG9TZWdtZW50U3RyaW5nKHQsZSl7aWYoMD09PWUubGVuZ3RoKXRocm93IG5ldyBuKFwiTGluZSBhcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHZlcnRleFwiKTtsZXQgcz10LmRpc3RhbmNlKGVbMF0pO2ZvcihsZXQgbj0wO248ZS5sZW5ndGgtMTtuKyspe2NvbnN0IGk9RC5wb2ludFRvU2VnbWVudCh0LGVbbl0sZVtuKzFdKTtpPHMmJihzPWkpfXJldHVybiBzfWdldENsYXNzKCl7cmV0dXJuIER9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBBe2NvbnN0cnVjdG9yKCl7QS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldE9yZGluYXRlKHQsZSxuKXt9c2l6ZSgpe31nZXRPcmRpbmF0ZSh0LGUpe31nZXRDb29yZGluYXRlKCl7fWdldENvb3JkaW5hdGVDb3B5KHQpe31nZXREaW1lbnNpb24oKXt9Z2V0WCh0KXt9ZXhwYW5kRW52ZWxvcGUodCl7fWNvcHkoKXt9Z2V0WSh0KXt9dG9Db29yZGluYXRlQXJyYXkoKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gQX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fUEuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxBLlg9MCxBLlk9MSxBLlo9MixBLk09MztjbGFzcyBGe2NvbnN0cnVjdG9yKCl7Ri5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZSgpezE9PT1hcmd1bWVudHMubGVuZ3RoJiYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheXx8Xyhhcmd1bWVudHNbMF0sQSkpfWdldENsYXNzKCl7cmV0dXJuIEZ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUYuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBHe2NvbnN0cnVjdG9yKCl7Ry5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gR31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Ry5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHF7Y29uc3RydWN0b3IoKXtxLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNHZW9tZXRyeUNvbGxlY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRUeXBlQ29kZSgpPT09cS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT059Z2V0RmFjdG9yeSgpe3JldHVybiB0aGlzLl9mYWN0b3J5fWdldEdlb21ldHJ5Tih0KXtyZXR1cm4gdGhpc31nZXRBcmVhKCl7cmV0dXJuIDB9aXNSZWN0YW5nbGUoKXtyZXR1cm4hMX1lcXVhbHMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBudWxsIT09dCYmdGhpcy5lcXVhbHNUb3BvKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZighKHQgaW5zdGFuY2VvZiBxKSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuZXF1YWxzRXhhY3QoZSl9fWVxdWFsc0V4YWN0KHQpe3JldHVybiB0aGlzPT09dHx8dGhpcy5lcXVhbHNFeGFjdCh0LDApfWdlb21ldHJ5Q2hhbmdlZCgpe3RoaXMuYXBwbHkocS5nZW9tZXRyeUNoYW5nZWRGaWx0ZXIpfWdlb21ldHJ5Q2hhbmdlZEFjdGlvbigpe3RoaXMuX2VudmVsb3BlPW51bGx9ZXF1YWxzTm9ybSh0KXtyZXR1cm4gbnVsbCE9PXQmJnRoaXMubm9ybSgpLmVxdWFsc0V4YWN0KHQubm9ybSgpKX1nZXRMZW5ndGgoKXtyZXR1cm4gMH1nZXROdW1HZW9tZXRyaWVzKCl7cmV0dXJuIDF9Y29tcGFyZVRvKCl7bGV0IHQ7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IGU9YXJndW1lbnRzWzBdO3JldHVybiB0PWUsdGhpcy5nZXRUeXBlQ29kZSgpIT09dC5nZXRUeXBlQ29kZSgpP3RoaXMuZ2V0VHlwZUNvZGUoKS10LmdldFR5cGVDb2RlKCk6dGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpPzA6dGhpcy5pc0VtcHR5KCk/LTE6dC5pc0VtcHR5KCk/MTp0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhlKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHQ9ZSx0aGlzLmdldFR5cGVDb2RlKCkhPT10LmdldFR5cGVDb2RlKCk/dGhpcy5nZXRUeXBlQ29kZSgpLXQuZ2V0VHlwZUNvZGUoKTp0aGlzLmlzRW1wdHkoKSYmdC5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTp0LmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKGUsbil9fWdldFVzZXJEYXRhKCl7cmV0dXJuIHRoaXMuX3VzZXJEYXRhfWdldFNSSUQoKXtyZXR1cm4gdGhpcy5fU1JJRH1nZXRFbnZlbG9wZSgpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX1jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KXtpZih0LmdldFR5cGVDb2RlKCk9PT1xLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTil0aHJvdyBuZXcgbihcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKX1lcXVhbCh0LGUsbil7cmV0dXJuIDA9PT1uP3QuZXF1YWxzKGUpOnQuZGlzdGFuY2UoZSk8PW59bm9ybSgpe2NvbnN0IHQ9dGhpcy5jb3B5KCk7cmV0dXJuIHQubm9ybWFsaXplKCksdH1nZXRQcmVjaXNpb25Nb2RlbCgpe3JldHVybiB0aGlzLl9mYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCl9Z2V0RW52ZWxvcGVJbnRlcm5hbCgpe3JldHVybiBudWxsPT09dGhpcy5fZW52ZWxvcGUmJih0aGlzLl9lbnZlbG9wZT10aGlzLmNvbXB1dGVFbnZlbG9wZUludGVybmFsKCkpLG5ldyBOKHRoaXMuX2VudmVsb3BlKX1zZXRTUklEKHQpe3RoaXMuX1NSSUQ9dH1zZXRVc2VyRGF0YSh0KXt0aGlzLl91c2VyRGF0YT10fWNvbXBhcmUodCxlKXtjb25zdCBuPXQuaXRlcmF0b3IoKSxzPWUuaXRlcmF0b3IoKTtmb3IoO24uaGFzTmV4dCgpJiZzLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCksZT1zLm5leHQoKSxpPXQuY29tcGFyZVRvKGUpO2lmKDAhPT1pKXJldHVybiBpfXJldHVybiBuLmhhc05leHQoKT8xOnMuaGFzTmV4dCgpPy0xOjB9aGFzaENvZGUoKXtyZXR1cm4gdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuaGFzaENvZGUoKX1pc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZCgpe3JldHVybiB0aGlzLmdldFR5cGVDb2RlKCk9PT1xLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTnx8dGhpcy5nZXRUeXBlQ29kZSgpPT09cS5UWVBFQ09ERV9NVUxUSVBPSU5UfHx0aGlzLmdldFR5cGVDb2RlKCk9PT1xLlRZUEVDT0RFX01VTFRJTElORVNUUklOR3x8dGhpcy5nZXRUeXBlQ29kZSgpPT09cS5UWVBFQ09ERV9NVUxUSVBPTFlHT059Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW28scixhXX1nZXRDbGFzcygpe3JldHVybiBxfXN0YXRpYyBoYXNOb25FbXB0eUVsZW1lbnRzKHQpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCF0W2VdLmlzRW1wdHkoKSlyZXR1cm4hMDtyZXR1cm4hMX1zdGF0aWMgaGFzTnVsbEVsZW1lbnRzKHQpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKG51bGw9PT10W2VdKXJldHVybiEwO3JldHVybiExfX1xLmNvbnN0cnVjdG9yXz1mdW5jdGlvbih0KXt0JiYodGhpcy5fZW52ZWxvcGU9bnVsbCx0aGlzLl91c2VyRGF0YT1udWxsLHRoaXMuX2ZhY3Rvcnk9dCx0aGlzLl9TUklEPXQuZ2V0U1JJRCgpKX0scS5zZXJpYWxWZXJzaW9uVUlEPTB4Nzk5ZWE0NjUyMjg1NGMwMCxxLlRZUEVDT0RFX1BPSU5UPTAscS5UWVBFQ09ERV9NVUxUSVBPSU5UPTEscS5UWVBFQ09ERV9MSU5FU1RSSU5HPTIscS5UWVBFQ09ERV9MSU5FQVJSSU5HPTMscS5UWVBFQ09ERV9NVUxUSUxJTkVTVFJJTkc9NCxxLlRZUEVDT0RFX1BPTFlHT049NSxxLlRZUEVDT0RFX01VTFRJUE9MWUdPTj02LHEuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OPTcscS5UWVBFTkFNRV9QT0lOVD1cIlBvaW50XCIscS5UWVBFTkFNRV9NVUxUSVBPSU5UPVwiTXVsdGlQb2ludFwiLHEuVFlQRU5BTUVfTElORVNUUklORz1cIkxpbmVTdHJpbmdcIixxLlRZUEVOQU1FX0xJTkVBUlJJTkc9XCJMaW5lYXJSaW5nXCIscS5UWVBFTkFNRV9NVUxUSUxJTkVTVFJJTkc9XCJNdWx0aUxpbmVTdHJpbmdcIixxLlRZUEVOQU1FX1BPTFlHT049XCJQb2x5Z29uXCIscS5UWVBFTkFNRV9NVUxUSVBPTFlHT049XCJNdWx0aVBvbHlnb25cIixxLlRZUEVOQU1FX0dFT01FVFJZQ09MTEVDVElPTj1cIkdlb21ldHJ5Q29sbGVjdGlvblwiLHEuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyPXtnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR119LGZpbHRlcih0KXt0Lmdlb21ldHJ5Q2hhbmdlZEFjdGlvbigpfX07Y2xhc3MgQntjb25zdHJ1Y3Rvcigpe0IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7fWdldENsYXNzKCl7cmV0dXJuIEJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBWe2NvbnN0cnVjdG9yKCl7Vi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5Cb3VuZGFyeSh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gVn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3Mgentjb25zdHJ1Y3Rvcigpe3ouY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0luQm91bmRhcnkodCl7cmV0dXJuIHQlMj09MX1nZXRDbGFzcygpe3JldHVybiB6fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltWXX19ei5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFl7Y29uc3RydWN0b3IoKXtZLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0PjB9Z2V0Q2xhc3MoKXtyZXR1cm4gWX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVl19fVkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBVe2NvbnN0cnVjdG9yKCl7VS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdD4xfWdldENsYXNzKCl7cmV0dXJuIFV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1ZdfX1VLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3Mga3tjb25zdHJ1Y3Rvcigpe2suY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0luQm91bmRhcnkodCl7cmV0dXJuIDE9PT10fWdldENsYXNzKCl7cmV0dXJuIGt9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1ZdfX1rLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sVi5Nb2QyQm91bmRhcnlOb2RlUnVsZT16LFYuRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPVksVi5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1VLFYuTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1rLFYuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxWLk1PRDJfQk9VTkRBUllfUlVMRT1uZXcgeixWLkVORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IFksVi5NVUxUSVZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBVLFYuTU9OT1ZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBrLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFPVYuTU9EMl9CT1VOREFSWV9SVUxFO2NsYXNzIFh7Y29uc3RydWN0b3IoKXtYLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzUmluZyh0KXtyZXR1cm4hKHQubGVuZ3RoPDQpJiYhIXRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSl9c3RhdGljIHB0Tm90SW5MaXN0KHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHM9dFtuXTtpZihYLmluZGV4T2YocyxlKTwwKXJldHVybiBzfXJldHVybiBudWxsfXN0YXRpYyBzY3JvbGwodCxlKXtjb25zdCBuPVguaW5kZXhPZihlLHQpO2lmKG48MClyZXR1cm4gbnVsbDtjb25zdCBzPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtPLmFycmF5Y29weSh0LG4scywwLHQubGVuZ3RoLW4pLE8uYXJyYXljb3B5KHQsMCxzLHQubGVuZ3RoLW4sbiksTy5hcnJheWNvcHkocywwLHQsMCx0Lmxlbmd0aCl9c3RhdGljIGVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT09dHx8bnVsbD09PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZighdFtuXS5lcXVhbHMoZVtuXSkpcmV0dXJuITE7cmV0dXJuITB9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKWlmKDAhPT1uLmNvbXBhcmUodFtzXSxlW3NdKSlyZXR1cm4hMTtyZXR1cm4hMH19c3RhdGljIGludGVyc2VjdGlvbih0LGUpe2NvbnN0IG49bmV3IEk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspZS5pbnRlcnNlY3RzKHRbc10pJiZuLmFkZCh0W3NdLCEwKTtyZXR1cm4gbi50b0Nvb3JkaW5hdGVBcnJheSgpfXN0YXRpYyBoYXNSZXBlYXRlZFBvaW50cyh0KXtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKylpZih0W2UtMV0uZXF1YWxzKHRbZV0pKXJldHVybiEwO3JldHVybiExfXN0YXRpYyByZW1vdmVSZXBlYXRlZFBvaW50cyh0KXtpZighWC5oYXNSZXBlYXRlZFBvaW50cyh0KSlyZXR1cm4gdDtyZXR1cm4gbmV3IEkodCwhMSkudG9Db29yZGluYXRlQXJyYXkoKX1zdGF0aWMgcmV2ZXJzZSh0KXtjb25zdCBlPXQubGVuZ3RoLTEsbj1NYXRoLnRydW5jKGUvMik7Zm9yKGxldCBzPTA7czw9bjtzKyspe2NvbnN0IG49dFtzXTt0W3NdPXRbZS1zXSx0W2Utc109bn19c3RhdGljIHJlbW92ZU51bGwodCl7bGV0IGU9MDtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyludWxsIT09dFtuXSYmZSsrO2NvbnN0IG49bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7aWYoMD09PWUpcmV0dXJuIG47bGV0IHM9MDtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyludWxsIT09dFtlXSYmKG5bcysrXT10W2VdKTtyZXR1cm4gbn1zdGF0aWMgY29weURlZXAoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZVtuXT1uZXcgZyh0W25dKTtyZXR1cm4gZX1pZig1PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF07Zm9yKGxldCByPTA7cjxpO3IrKyluW3Mrcl09bmV3IGcodFtlK3JdKX19c3RhdGljIGlzRXF1YWxSZXZlcnNlZCh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtjb25zdCBzPXRbbl0saT1lW3QubGVuZ3RoLW4tMV07aWYoMCE9PXMuY29tcGFyZVRvKGkpKXJldHVybiExfXJldHVybiEwfXN0YXRpYyBlbnZlbG9wZSh0KXtjb25zdCBlPW5ldyBOO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWUuZXhwYW5kVG9JbmNsdWRlKHRbbl0pO3JldHVybiBlfXN0YXRpYyB0b0Nvb3JkaW5hdGVBcnJheSh0KXtyZXR1cm4gdC50b0FycmF5KFguY29vcmRBcnJheVR5cGUpfXN0YXRpYyBhdExlYXN0TkNvb3JkaW5hdGVzT3JOb3RoaW5nKHQsZSl7cmV0dXJuIGUubGVuZ3RoPj10P2U6W119c3RhdGljIGluZGV4T2YodCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKylpZih0LmVxdWFscyhlW25dKSlyZXR1cm4gbjtyZXR1cm4tMX1zdGF0aWMgaW5jcmVhc2luZ0RpcmVjdGlvbih0KXtmb3IobGV0IGU9MDtlPE1hdGgudHJ1bmModC5sZW5ndGgvMik7ZSsrKXtjb25zdCBuPXQubGVuZ3RoLTEtZSxzPXRbZV0uY29tcGFyZVRvKHRbbl0pO2lmKDAhPT1zKXJldHVybiBzfXJldHVybiAxfXN0YXRpYyBjb21wYXJlKHQsZSl7bGV0IG49MDtmb3IoO248dC5sZW5ndGgmJm48ZS5sZW5ndGg7KXtjb25zdCBzPXRbbl0uY29tcGFyZVRvKGVbbl0pO2lmKDAhPT1zKXJldHVybiBzO24rK31yZXR1cm4gbjxlLmxlbmd0aD8tMTpuPHQubGVuZ3RoPzE6MH1zdGF0aWMgbWluQ29vcmRpbmF0ZSh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKShudWxsPT09ZXx8ZS5jb21wYXJlVG8odFtuXSk+MCkmJihlPXRbbl0pO3JldHVybiBlfXN0YXRpYyBleHRyYWN0KHQsZSxuKXtlPU0uY2xhbXAoZSwwLHQubGVuZ3RoKTtsZXQgcz0obj1NLmNsYW1wKG4sLTEsdC5sZW5ndGgpKS1lKzE7bjwwJiYocz0wKSxlPj10Lmxlbmd0aCYmKHM9MCksbjxlJiYocz0wKTtjb25zdCBpPW5ldyBBcnJheShzKS5maWxsKG51bGwpO2lmKDA9PT1zKXJldHVybiBpO2xldCByPTA7Zm9yKGxldCBzPWU7czw9bjtzKyspaVtyKytdPXRbc107cmV0dXJuIGl9Z2V0Q2xhc3MoKXtyZXR1cm4gWH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgSHtjb25zdHJ1Y3Rvcigpe0guY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtyZXR1cm4gWC5jb21wYXJlKG4scyl9Z2V0Q2xhc3MoKXtyZXR1cm4gSH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fUguY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBXe2NvbnN0cnVjdG9yKCl7Vy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO2lmKG4ubGVuZ3RoPHMubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPnMubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDtjb25zdCBpPVguY29tcGFyZShuLHMpO3JldHVybiBYLmlzRXF1YWxSZXZlcnNlZChuLHMpPzA6aX1PTERjb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtpZihuLmxlbmd0aDxzLmxlbmd0aClyZXR1cm4tMTtpZihuLmxlbmd0aD5zLmxlbmd0aClyZXR1cm4gMTtpZigwPT09bi5sZW5ndGgpcmV0dXJuIDA7Y29uc3QgaT1YLmluY3JlYXNpbmdEaXJlY3Rpb24obikscj1YLmluY3JlYXNpbmdEaXJlY3Rpb24ocyk7bGV0IG89aT4wPzA6bi5sZW5ndGgtMSxsPXI+MD8wOm4ubGVuZ3RoLTE7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IHQ9bltvXS5jb21wYXJlVG8oc1tsXSk7aWYoMCE9PXQpcmV0dXJuIHQ7bys9aSxsKz1yfXJldHVybiAwfWdldENsYXNzKCl7cmV0dXJuIFd9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1mdW5jdGlvbiBqKCl7fWZ1bmN0aW9uIEsoKXt9ZnVuY3Rpb24gWih0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBRKCl7fWZ1bmN0aW9uIEooKXt0aGlzLmFycmF5Xz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGYmJnRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSl9Vy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFguRm9yd2FyZENvbXBhcmF0b3I9SCxYLkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yPVcsWC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFguY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCksai5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7fSxqLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oKXt9LGoucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXt9LGoucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe30sai5wcm90b3R5cGUuZW50cnlTZXQ9ZnVuY3Rpb24oKXt9LEsucHJvdG90eXBlPW5ldyBqLFoucHJvdG90eXBlPW5ldyBFcnJvcixaLnByb3RvdHlwZS5uYW1lPVwiT3BlcmF0aW9uTm90U3VwcG9ydGVkXCIsUS5wcm90b3R5cGU9bmV3IGYsUS5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24oKXt9LEoucHJvdG90eXBlPW5ldyBRLEoucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO2U8bjtlKyspe2lmKHRoaXMuYXJyYXlfW2VdPT09dClyZXR1cm4hMH1yZXR1cm4hMX0sSi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiF0aGlzLmNvbnRhaW5zKHQpJiYodGhpcy5hcnJheV8ucHVzaCh0KSwhMCl9LEoucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbih0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7cmV0dXJuITB9LEoucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgWn0sSi5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LEoucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sSi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2NvbnN0IHQ9W107Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxKLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgJCh0aGlzKX07Y29uc3QgJD1mdW5jdGlvbih0KXt0aGlzLmhhc2hTZXRfPXQsdGhpcy5wb3NpdGlvbl89MH07JC5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy5oYXNoU2V0Xy5zaXplKCkpdGhyb3cgbmV3IHk7cmV0dXJuIHRoaXMuaGFzaFNldF8uYXJyYXlfW3RoaXMucG9zaXRpb25fKytdfSwkLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb25fPHRoaXMuaGFzaFNldF8uc2l6ZSgpfSwkLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgWn07ZnVuY3Rpb24gdHQodCl7cmV0dXJuIG51bGw9PXQ/MDp0LmNvbG9yfWZ1bmN0aW9uIGV0KHQpe3JldHVybiBudWxsPT10P251bGw6dC5wYXJlbnR9ZnVuY3Rpb24gbnQodCxlKXtudWxsIT09dCYmKHQuY29sb3I9ZSl9ZnVuY3Rpb24gc3QodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LmxlZnR9ZnVuY3Rpb24gaXQodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnJpZ2h0fWZ1bmN0aW9uIHJ0KCl7dGhpcy5yb290Xz1udWxsLHRoaXMuc2l6ZV89MH1ydC5wcm90b3R5cGU9bmV3IEsscnQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5yb290XztudWxsIT09ZTspe3ZhciBuPXQuY29tcGFyZVRvKGUua2V5KTtpZihuPDApZT1lLmxlZnQ7ZWxzZXtpZighKG4+MCkpcmV0dXJuIGUudmFsdWU7ZT1lLnJpZ2h0fX1yZXR1cm4gbnVsbH0scnQucHJvdG90eXBlLnB1dD1mdW5jdGlvbih0LGUpe2lmKG51bGw9PT10aGlzLnJvb3RfKXJldHVybiB0aGlzLnJvb3RfPXtrZXk6dCx2YWx1ZTplLGxlZnQ6bnVsbCxyaWdodDpudWxsLHBhcmVudDpudWxsLGNvbG9yOjAsZ2V0VmFsdWUoKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5KCl7cmV0dXJuIHRoaXMua2V5fX0sdGhpcy5zaXplXz0xLG51bGw7dmFyIG4scyxpPXRoaXMucm9vdF87ZG97aWYobj1pLChzPXQuY29tcGFyZVRvKGkua2V5KSk8MClpPWkubGVmdDtlbHNle2lmKCEocz4wKSl7dmFyIHI9aS52YWx1ZTtyZXR1cm4gaS52YWx1ZT1lLHJ9aT1pLnJpZ2h0fX13aGlsZShudWxsIT09aSk7dmFyIG89e2tleTp0LGxlZnQ6bnVsbCxyaWdodDpudWxsLHZhbHVlOmUscGFyZW50Om4sY29sb3I6MCxnZXRWYWx1ZSgpe3JldHVybiB0aGlzLnZhbHVlfSxnZXRLZXkoKXtyZXR1cm4gdGhpcy5rZXl9fTtyZXR1cm4gczwwP24ubGVmdD1vOm4ucmlnaHQ9byx0aGlzLmZpeEFmdGVySW5zZXJ0aW9uKG8pLHRoaXMuc2l6ZV8rKyxudWxsfSxydC5wcm90b3R5cGUuZml4QWZ0ZXJJbnNlcnRpb249ZnVuY3Rpb24odCl7bGV0IGU7Zm9yKHQuY29sb3I9MTtudWxsIT10JiZ0IT09dGhpcy5yb290XyYmMT09PXQucGFyZW50LmNvbG9yOylldCh0KT09PXN0KGV0KGV0KHQpKSk/KGU9aXQoZXQoZXQodCkpKSwxPT09dHQoZSk/KG50KGV0KHQpLDApLG50KGUsMCksbnQoZXQoZXQodCkpLDEpLHQ9ZXQoZXQodCkpKToodD09PWl0KGV0KHQpKSYmKHQ9ZXQodCksdGhpcy5yb3RhdGVMZWZ0KHQpKSxudChldCh0KSwwKSxudChldChldCh0KSksMSksdGhpcy5yb3RhdGVSaWdodChldChldCh0KSkpKSk6KGU9c3QoZXQoZXQodCkpKSwxPT09dHQoZSk/KG50KGV0KHQpLDApLG50KGUsMCksbnQoZXQoZXQodCkpLDEpLHQ9ZXQoZXQodCkpKToodD09PXN0KGV0KHQpKSYmKHQ9ZXQodCksdGhpcy5yb3RhdGVSaWdodCh0KSksbnQoZXQodCksMCksbnQoZXQoZXQodCkpLDEpLHRoaXMucm90YXRlTGVmdChldChldCh0KSkpKSk7dGhpcy5yb290Xy5jb2xvcj0wfSxydC5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IHgsZT10aGlzLmdldEZpcnN0RW50cnkoKTtpZihudWxsIT09ZSlmb3IodC5hZGQoZS52YWx1ZSk7bnVsbCE9PShlPXJ0LnN1Y2Nlc3NvcihlKSk7KXQuYWRkKGUudmFsdWUpO3JldHVybiB0fSxydC5wcm90b3R5cGUuZW50cnlTZXQ9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSixlPXRoaXMuZ2V0Rmlyc3RFbnRyeSgpO2lmKG51bGwhPT1lKWZvcih0LmFkZChlKTtudWxsIT09KGU9cnQuc3VjY2Vzc29yKGUpKTspdC5hZGQoZSk7cmV0dXJuIHR9LHJ0LnByb3RvdHlwZS5yb3RhdGVMZWZ0PWZ1bmN0aW9uKHQpe2lmKG51bGwhPXQpe3ZhciBlPXQucmlnaHQ7dC5yaWdodD1lLmxlZnQsbnVsbCE9ZS5sZWZ0JiYoZS5sZWZ0LnBhcmVudD10KSxlLnBhcmVudD10LnBhcmVudCxudWxsPT10LnBhcmVudD90aGlzLnJvb3RfPWU6dC5wYXJlbnQubGVmdD09PXQ/dC5wYXJlbnQubGVmdD1lOnQucGFyZW50LnJpZ2h0PWUsZS5sZWZ0PXQsdC5wYXJlbnQ9ZX19LHJ0LnByb3RvdHlwZS5yb3RhdGVSaWdodD1mdW5jdGlvbih0KXtpZihudWxsIT10KXt2YXIgZT10LmxlZnQ7dC5sZWZ0PWUucmlnaHQsbnVsbCE9ZS5yaWdodCYmKGUucmlnaHQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5yaWdodD09PXQ/dC5wYXJlbnQucmlnaHQ9ZTp0LnBhcmVudC5sZWZ0PWUsZS5yaWdodD10LHQucGFyZW50PWV9fSxydC5wcm90b3R5cGUuZ2V0Rmlyc3RFbnRyeT1mdW5jdGlvbigpe3ZhciB0PXRoaXMucm9vdF87aWYobnVsbCE9dClmb3IoO251bGwhPXQubGVmdDspdD10LmxlZnQ7cmV0dXJuIHR9LHJ0LnN1Y2Nlc3Nvcj1mdW5jdGlvbih0KXtsZXQgZTtpZihudWxsPT09dClyZXR1cm4gbnVsbDtpZihudWxsIT09dC5yaWdodCl7Zm9yKGU9dC5yaWdodDtudWxsIT09ZS5sZWZ0OyllPWUubGVmdDtyZXR1cm4gZX1lPXQucGFyZW50O2Zvcih2YXIgbj10O251bGwhPT1lJiZuPT09ZS5yaWdodDspbj1lLGU9ZS5wYXJlbnQ7cmV0dXJuIGV9LHJ0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV99LHJ0LnByb3RvdHlwZS5jb250YWluc0tleT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5yb290XztudWxsIT09ZTspe3ZhciBuPXQuY29tcGFyZVRvKGUua2V5KTtpZihuPDApZT1lLmxlZnQ7ZWxzZXtpZighKG4+MCkpcmV0dXJuITA7ZT1lLnJpZ2h0fX1yZXR1cm4hMX07Y2xhc3Mgb3R7Y29uc3RydWN0b3IoKXtvdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIG90fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBsdCgpe31mdW5jdGlvbiBhdCgpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1vdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LGx0LnByb3RvdHlwZT1uZXcgUSxhdC5wcm90b3R5cGU9bmV3IGx0LGF0LnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbih0KXtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXtpZigwPT09dGhpcy5hcnJheV9bZV0uY29tcGFyZVRvKHQpKXJldHVybiEwfXJldHVybiExfSxhdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe2lmKHRoaXMuY29udGFpbnModCkpcmV0dXJuITE7Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl7aWYoMT09PXRoaXMuYXJyYXlfW2VdLmNvbXBhcmVUbyh0KSlyZXR1cm4gdGhpcy5hcnJheV8uc3BsaWNlKGUsMCx0KSwhMH1yZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSwhMH0sYXQucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbih0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7cmV0dXJuITB9LGF0LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IFp9LGF0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sYXQucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sYXQucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtjb25zdCB0PVtdO2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO2U8bjtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sYXQucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBjdCh0aGlzKX07Y29uc3QgY3Q9ZnVuY3Rpb24odCl7dGhpcy50cmVlU2V0Xz10LHRoaXMucG9zaXRpb25fPTB9O2Z1bmN0aW9uIGh0KCl7fWN0LnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLnRyZWVTZXRfLnNpemUoKSl0aHJvdyBuZXcgeTtyZXR1cm4gdGhpcy50cmVlU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK119LGN0LnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb25fPHRoaXMudHJlZVNldF8uc2l6ZSgpfSxjdC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFp9LGh0LnNvcnQ9ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZSxuLHMsaTtpZigxPT09YXJndW1lbnRzLmxlbmd0aClpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY29tcGFyZVRvKGUpfSx0LnNvcnQoaSk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aClzPWFyZ3VtZW50c1sxXSxpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHMuY29tcGFyZSh0LGUpfSx0LnNvcnQoaSk7ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7bj10LnNsaWNlKGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pLG4uc29ydCgpO2NvbnN0IHM9dC5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KG4sdC5zbGljZShhcmd1bWVudHNbMl0sdC5sZW5ndGgpKTtmb3IodC5zcGxpY2UoMCx0Lmxlbmd0aCksZT0wO2U8cy5sZW5ndGg7ZSsrKXQucHVzaChzW2VdKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtuPXQuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSkscz1hcmd1bWVudHNbM10saT1mdW5jdGlvbih0LGUpe3JldHVybiBzLmNvbXBhcmUodCxlKX0sbi5zb3J0KGkpO2NvbnN0IHI9dC5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KG4sdC5zbGljZShhcmd1bWVudHNbMl0sdC5sZW5ndGgpKTtmb3IodC5zcGxpY2UoMCx0Lmxlbmd0aCksZT0wO2U8ci5sZW5ndGg7ZSsrKXQucHVzaChyW2VdKX19LGh0LmFzTGlzdD1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj0wLHM9dC5sZW5ndGg7bjxzO24rKyllLmFkZCh0W25dKTtyZXR1cm4gZX07Y2xhc3MgdXR7Y29uc3RydWN0b3IoKXt1dC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0RpbWVuc2lvblN5bWJvbCh0KXtzd2l0Y2godCl7Y2FzZSB1dC5GQUxTRTpyZXR1cm4gdXQuU1lNX0ZBTFNFO2Nhc2UgdXQuVFJVRTpyZXR1cm4gdXQuU1lNX1RSVUU7Y2FzZSB1dC5ET05UQ0FSRTpyZXR1cm4gdXQuU1lNX0RPTlRDQVJFO2Nhc2UgdXQuUDpyZXR1cm4gdXQuU1lNX1A7Y2FzZSB1dC5MOnJldHVybiB1dC5TWU1fTDtjYXNlIHV0LkE6cmV0dXJuIHV0LlNZTV9BfXRocm93IG5ldyBuKFwiVW5rbm93biBkaW1lbnNpb24gdmFsdWU6IFwiK3QpfXN0YXRpYyB0b0RpbWVuc2lvblZhbHVlKHQpe3N3aXRjaChULnRvVXBwZXJDYXNlKHQpKXtjYXNlIHV0LlNZTV9GQUxTRTpyZXR1cm4gdXQuRkFMU0U7Y2FzZSB1dC5TWU1fVFJVRTpyZXR1cm4gdXQuVFJVRTtjYXNlIHV0LlNZTV9ET05UQ0FSRTpyZXR1cm4gdXQuRE9OVENBUkU7Y2FzZSB1dC5TWU1fUDpyZXR1cm4gdXQuUDtjYXNlIHV0LlNZTV9MOnJldHVybiB1dC5MO2Nhc2UgdXQuU1lNX0E6cmV0dXJuIHV0LkF9dGhyb3cgbmV3IG4oXCJVbmtub3duIGRpbWVuc2lvbiBzeW1ib2w6IFwiK3QpfWdldENsYXNzKCl7cmV0dXJuIHV0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX11dC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LHV0LlA9MCx1dC5MPTEsdXQuQT0yLHV0LkZBTFNFPS0xLHV0LlRSVUU9LTIsdXQuRE9OVENBUkU9LTMsdXQuU1lNX0ZBTFNFPVwiRlwiLHV0LlNZTV9UUlVFPVwiVFwiLHV0LlNZTV9ET05UQ0FSRT1cIipcIix1dC5TWU1fUD1cIjBcIix1dC5TWU1fTD1cIjFcIix1dC5TWU1fQT1cIjJcIjtjbGFzcyBndHtjb25zdHJ1Y3Rvcigpe2d0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe31nZXRDbGFzcygpe3JldHVybiBndH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Z3QuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBkdHtjb25zdHJ1Y3Rvcigpe2R0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQsZSl7fWlzRG9uZSgpe31pc0dlb21ldHJ5Q2hhbmdlZCgpe31nZXRDbGFzcygpe3JldHVybiBkdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBfdCBleHRlbmRzIHF7Y29uc3RydWN0b3IoKXtzdXBlcigpLF90LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtjb25zdCB0PW5ldyBOO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtyZXR1cm4gdH1nZXRHZW9tZXRyeU4odCl7cmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbdF19Z2V0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpO2xldCBlPS0xO2ZvcihsZXQgbj0wO248dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKXtjb25zdCBzPXRoaXMuX2dlb21ldHJpZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPHMubGVuZ3RoO24rKyllKyssdFtlXT1zW25dfXJldHVybiB0fWdldEFyZWEoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0QXJlYSgpO3JldHVybiB0fWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7Y29uc3Qgbj10O2lmKHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoIT09bi5fZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uZXF1YWxzRXhhY3Qobi5fZ2VvbWV0cmllc1t0XSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKXRoaXMuX2dlb21ldHJpZXNbdF0ubm9ybWFsaXplKCk7aHQuc29ydCh0aGlzLl9nZW9tZXRyaWVzKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5fZ2VvbWV0cmllc1swXS5nZXRDb29yZGluYXRlKCl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtsZXQgdD11dC5GQUxTRTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0PU1hdGgubWF4KHQsdGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKTtyZXR1cm4gdH1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTn1nZXREaW1lbnNpb24oKXtsZXQgdD11dC5GQUxTRTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0PU1hdGgubWF4KHQsdGhpcy5fZ2VvbWV0cmllc1tlXS5nZXREaW1lbnNpb24oKSk7cmV0dXJuIHR9Z2V0TGVuZ3RoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fWdldE51bVBvaW50cygpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH1nZXROdW1HZW9tZXRyaWVzKCl7cmV0dXJuIHRoaXMuX2dlb21ldHJpZXMubGVuZ3RofXJldmVyc2UoKXtjb25zdCB0PXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspZVt0XT10aGlzLl9nZW9tZXRyaWVzW3RdLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBhdChodC5hc0xpc3QodGhpcy5fZ2VvbWV0cmllcykpLG49bmV3IGF0KGh0LmFzTGlzdCh0Ll9nZW9tZXRyaWVzKSk7cmV0dXJuIHRoaXMuY29tcGFyZShlLG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQscz10aGlzLmdldE51bUdlb21ldHJpZXMoKSxpPW4uZ2V0TnVtR2VvbWV0cmllcygpO2xldCByPTA7Zm9yKDtyPHMmJnI8aTspe2NvbnN0IHQ9dGhpcy5nZXRHZW9tZXRyeU4ocikscz1uLmdldEdlb21ldHJ5TihyKSxpPXQuY29tcGFyZVRvU2FtZUNsYXNzKHMsZSk7aWYoMCE9PWkpcmV0dXJuIGk7cisrfXJldHVybiByPHM/MTpyPGk/LTE6MH19YXBwbHkoKXtpZihfKGFyZ3VtZW50c1swXSxCKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGR0KSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgmJih0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGd0KSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5maWx0ZXIodGhpcyk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmZpbHRlcih0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfX1nZXRCb3VuZGFyeSgpe3JldHVybiB0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSxudWxsfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX0dFT01FVFJZQ09MTEVDVElPTn1jb3B5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IF90KHQsdGhpcy5fZmFjdG9yeSl9aXNFbXB0eSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9nZW9tZXRyaWVzW3RdLmlzRW1wdHkoKSlyZXR1cm4hMTtyZXR1cm4hMH1nZXRDbGFzcygpe3JldHVybiBfdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19X3QuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZ2VvbWV0cmllcz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMF07Y29uc3QgZT1hcmd1bWVudHNbMV07aWYocS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLG51bGw9PT10JiYodD1bXSkscS5oYXNOdWxsRWxlbWVudHModCkpdGhyb3cgbmV3IG4oXCJnZW9tZXRyaWVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50c1wiKTt0aGlzLl9nZW9tZXRyaWVzPXR9fSxfdC5zZXJpYWxWZXJzaW9uVUlEPS0weDRmMDdiY2IxZjg1N2Q4MDA7Y2xhc3MgZnQgZXh0ZW5kcyBfdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmc3VwZXIuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/dXQuRkFMU0U6MH1pc0Nsb3NlZCgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9nZW9tZXRyaWVzW3RdLmlzQ2xvc2VkKCkpcmV0dXJuITE7cmV0dXJuITB9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gcS5UWVBFQ09ERV9NVUxUSUxJTkVTVFJJTkd9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDF9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO24rKyllW3QtMS1uXT10aGlzLl9nZW9tZXRyaWVzW25dLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfWdldEJvdW5kYXJ5KCl7cmV0dXJuIG5ldyBwdCh0aGlzKS5nZXRCb3VuZGFyeSgpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX01VTFRJTElORVNUUklOR31jb3B5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IGZ0KHQsdGhpcy5fZmFjdG9yeSl9Z2V0Q2xhc3MoKXtyZXR1cm4gZnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW290XX19ZnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07X3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfSxmdC5zZXJpYWxWZXJzaW9uVUlEPTB4NzE1NWQyYWI0YWZhODAwMDtjbGFzcyBwdHtjb25zdHJ1Y3Rvcigpe3B0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldEJvdW5kYXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgcHQodCkuZ2V0Qm91bmRhcnkoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBwdCh0LGUpLmdldEJvdW5kYXJ5KCl9fWJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nKHQpe2lmKHRoaXMuX2dlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpO2NvbnN0IGU9dGhpcy5jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyh0KTtyZXR1cm4gMT09PWUubGVuZ3RoP3RoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KGVbMF0pOnRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKGUpfWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuX2dlb20gaW5zdGFuY2VvZiBUdD90aGlzLmJvdW5kYXJ5TGluZVN0cmluZyh0aGlzLl9nZW9tKTp0aGlzLl9nZW9tIGluc3RhbmNlb2YgZnQ/dGhpcy5ib3VuZGFyeU11bHRpTGluZVN0cmluZyh0aGlzLl9nZW9tKTp0aGlzLl9nZW9tLmdldEJvdW5kYXJ5KCl9Ym91bmRhcnlMaW5lU3RyaW5nKHQpe2lmKHRoaXMuX2dlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpO2lmKHQuaXNDbG9zZWQoKSl7cmV0dXJuIHRoaXMuX2JuUnVsZS5pc0luQm91bmRhcnkoMik/dC5nZXRTdGFydFBvaW50KCk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpfXJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KFt0LmdldFN0YXJ0UG9pbnQoKSx0LmdldEVuZFBvaW50KCldKX1nZXRFbXB0eU11bHRpUG9pbnQoKXtyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpfWNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IHg7dGhpcy5fZW5kcG9pbnRNYXA9bmV3IHJ0O2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpOzAhPT1uLmdldE51bVBvaW50cygpJiYodGhpcy5hZGRFbmRwb2ludChuLmdldENvb3JkaW5hdGVOKDApKSx0aGlzLmFkZEVuZHBvaW50KG4uZ2V0Q29vcmRpbmF0ZU4obi5nZXROdW1Qb2ludHMoKS0xKSkpfWZvcihsZXQgdD10aGlzLl9lbmRwb2ludE1hcC5lbnRyeVNldCgpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRWYWx1ZSgpLmNvdW50O3RoaXMuX2JuUnVsZS5pc0luQm91bmRhcnkocykmJmUuYWRkKG4uZ2V0S2V5KCkpfXJldHVybiBYLnRvQ29vcmRpbmF0ZUFycmF5KGUpfWFkZEVuZHBvaW50KHQpe2xldCBlPXRoaXMuX2VuZHBvaW50TWFwLmdldCh0KTtudWxsPT09ZSYmKGU9bmV3IG10LHRoaXMuX2VuZHBvaW50TWFwLnB1dCh0LGUpKSxlLmNvdW50Kyt9Z2V0Q2xhc3MoKXtyZXR1cm4gcHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXB0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2dlb209bnVsbCx0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX2JuUnVsZT1udWxsLHRoaXMuX2VuZHBvaW50TWFwPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3B0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxWLk1PRDJfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbT10LHRoaXMuX2dlb21GYWN0PXQuZ2V0RmFjdG9yeSgpLHRoaXMuX2JuUnVsZT1lfX07Y2xhc3MgbXR7Y29uc3RydWN0b3IoKXttdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIG10fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1tdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmNvdW50PW51bGx9O2NsYXNzIHl0e2NvbnN0cnVjdG9yKCl7eXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb2ZMaW5lKHQpe2NvbnN0IGU9dC5zaXplKCk7aWYoZTw9MSlyZXR1cm4gMDtsZXQgbj0wO2NvbnN0IHM9bmV3IGc7dC5nZXRDb29yZGluYXRlKDAscyk7bGV0IGk9cy54LHI9cy55O2ZvcihsZXQgbz0xO288ZTtvKyspe3QuZ2V0Q29vcmRpbmF0ZShvLHMpO2NvbnN0IGU9cy54LGw9cy55LGE9ZS1pLGM9bC1yO24rPU1hdGguc3FydChhKmErYypjKSxpPWUscj1sfXJldHVybiBufWdldENsYXNzKCl7cmV0dXJuIHl0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiB4dCgpe31mdW5jdGlvbiBFdCgpe31mdW5jdGlvbiBJdCgpe31mdW5jdGlvbiBOdCgpe31mdW5jdGlvbiBDdCgpe315dC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFN0e2NvbnN0cnVjdG9yKCl7U3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY2hhcnModCxlKXtjb25zdCBuPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2ZvcihsZXQgcz0wO3M8ZTtzKyspbltzXT10O3JldHVybiBuZXcgU3RyaW5nKG4pfXN0YXRpYyBnZXRTdGFja1RyYWNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEl0LG49bmV3IHh0KGUpO3JldHVybiB0LnByaW50U3RhY2tUcmFjZShuKSxlLnRvU3RyaW5nKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPVwiXCI7Y29uc3Qgcz1uZXcgQ3QobmV3IEV0KFN0LmdldFN0YWNrVHJhY2UodCkpKTtmb3IobGV0IHQ9MDt0PGU7dCsrKXRyeXtuKz1zLnJlYWRMaW5lKCkrU3QuTkVXTElORX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBOdCkpdGhyb3cgdDt1LnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIG59fXN0YXRpYyBzcGxpdCh0LGUpe2NvbnN0IG49ZS5sZW5ndGgscz1uZXcgeDtsZXQgaT1cIlwiK3Qscj1pLmluZGV4T2YoZSk7Zm9yKDtyPj0wOyl7Y29uc3QgdD1pLnN1YnN0cmluZygwLHIpO3MuYWRkKHQpLGk9aS5zdWJzdHJpbmcocituKSxyPWkuaW5kZXhPZihlKX1pLmxlbmd0aD4wJiZzLmFkZChpKTtjb25zdCBvPW5ldyBBcnJheShzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKylvW3RdPXMuZ2V0KHQpO3JldHVybiBvfXN0YXRpYyB0b1N0cmluZygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gU3QuU0lNUExFX09SRElOQVRFX0ZPUk1BVC5mb3JtYXQodCl9fXN0YXRpYyBzcGFjZXModCl7cmV0dXJuIFN0LmNoYXJzKFwiIFwiLHQpfWdldENsYXNzKCl7cmV0dXJuIFN0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiB3dCh0KXt0aGlzLnN0cj10fVN0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sU3QuTkVXTElORT1PLmdldFByb3BlcnR5KFwibGluZS5zZXBhcmF0b3JcIiksU3QuU0lNUExFX09SRElOQVRFX0ZPUk1BVD1uZXcgZnVuY3Rpb24oKXt9KFwiMC4jXCIpLHd0LnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24odCl7dGhpcy5zdHIrPXR9LHd0LnByb3RvdHlwZS5zZXRDaGFyQXQ9ZnVuY3Rpb24odCxlKXt0aGlzLnN0cj10aGlzLnN0ci5zdWJzdHIoMCx0KStlK3RoaXMuc3RyLnN1YnN0cih0KzEpfSx3dC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RyfTtjbGFzcyBMdHtjb25zdHJ1Y3Rvcigpe0x0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvcHlDb29yZCh0LGUsbixzKXtjb25zdCBpPU1hdGgubWluKHQuZ2V0RGltZW5zaW9uKCksbi5nZXREaW1lbnNpb24oKSk7Zm9yKGxldCByPTA7cjxpO3IrKyluLnNldE9yZGluYXRlKHMscix0LmdldE9yZGluYXRlKGUscikpfXN0YXRpYyBpc1JpbmcodCl7Y29uc3QgZT10LnNpemUoKTtyZXR1cm4gMD09PWV8fCEoZTw9MykmJih0LmdldE9yZGluYXRlKDAsQS5YKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEEuWCkmJnQuZ2V0T3JkaW5hdGUoMCxBLlkpPT09dC5nZXRPcmRpbmF0ZShlLTEsQS5ZKSl9c3RhdGljIGlzRXF1YWwodCxlKXtjb25zdCBuPXQuc2l6ZSgpO2lmKG4hPT1lLnNpemUoKSlyZXR1cm4hMTtjb25zdCBzPU1hdGgubWluKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSk7Zm9yKGxldCByPTA7cjxuO3IrKylmb3IobGV0IG49MDtuPHM7bisrKXtjb25zdCBzPXQuZ2V0T3JkaW5hdGUocixuKSxvPWUuZ2V0T3JkaW5hdGUocixuKTtpZih0LmdldE9yZGluYXRlKHIsbikhPT1lLmdldE9yZGluYXRlKHIsbikmJighaS5pc05hTihzKXx8IWkuaXNOYU4obykpKXJldHVybiExfXJldHVybiEwfXN0YXRpYyBleHRlbmQodCxlLG4pe2NvbnN0IHM9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxpPWUuc2l6ZSgpO2lmKEx0LmNvcHkoZSwwLHMsMCxpKSxpPjApZm9yKGxldCB0PWk7dDxuO3QrKylMdC5jb3B5KGUsaS0xLHMsdCwxKTtyZXR1cm4gc31zdGF0aWMgcmV2ZXJzZSh0KXtjb25zdCBlPXQuc2l6ZSgpLTEsbj1NYXRoLnRydW5jKGUvMik7Zm9yKGxldCBzPTA7czw9bjtzKyspTHQuc3dhcCh0LHMsZS1zKX1zdGF0aWMgc3dhcCh0LGUsbil7aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKGxldCBzPTA7czx0LmdldERpbWVuc2lvbigpO3MrKyl7Y29uc3QgaT10LmdldE9yZGluYXRlKGUscyk7dC5zZXRPcmRpbmF0ZShlLHMsdC5nZXRPcmRpbmF0ZShuLHMpKSx0LnNldE9yZGluYXRlKG4scyxpKX19c3RhdGljIGNvcHkodCxlLG4scyxpKXtmb3IobGV0IHI9MDtyPGk7cisrKUx0LmNvcHlDb29yZCh0LGUrcixuLHMrcil9c3RhdGljIHRvU3RyaW5nKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJl8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuc2l6ZSgpO2lmKDA9PT1lKXJldHVyblwiKClcIjtjb25zdCBuPXQuZ2V0RGltZW5zaW9uKCkscz1uZXcgd3Q7cy5hcHBlbmQoXCIoXCIpO2ZvcihsZXQgaT0wO2k8ZTtpKyspe2k+MCYmcy5hcHBlbmQoXCIgXCIpO2ZvcihsZXQgZT0wO2U8bjtlKyspZT4wJiZzLmFwcGVuZChcIixcIikscy5hcHBlbmQoU3QudG9TdHJpbmcodC5nZXRPcmRpbmF0ZShpLGUpKSl9cmV0dXJuIHMuYXBwZW5kKFwiKVwiKSxzLnRvU3RyaW5nKCl9fXN0YXRpYyBlbnN1cmVWYWxpZFJpbmcodCxlKXtjb25zdCBuPWUuc2l6ZSgpO3JldHVybiAwPT09bj9lOm48PTM/THQuY3JlYXRlQ2xvc2VkUmluZyh0LGUsNCk6ZS5nZXRPcmRpbmF0ZSgwLEEuWCk9PT1lLmdldE9yZGluYXRlKG4tMSxBLlgpJiZlLmdldE9yZGluYXRlKDAsQS5ZKT09PWUuZ2V0T3JkaW5hdGUobi0xLEEuWSk/ZTpMdC5jcmVhdGVDbG9zZWRSaW5nKHQsZSxuKzEpfXN0YXRpYyBjcmVhdGVDbG9zZWRSaW5nKHQsZSxuKXtjb25zdCBzPXQuY3JlYXRlKG4sZS5nZXREaW1lbnNpb24oKSksaT1lLnNpemUoKTtMdC5jb3B5KGUsMCxzLDAsaSk7Zm9yKGxldCB0PWk7dDxuO3QrKylMdC5jb3B5KGUsMCxzLHQsMSk7cmV0dXJuIHN9Z2V0Q2xhc3MoKXtyZXR1cm4gTHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUx0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgVHQgZXh0ZW5kcyBxe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxUdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP25ldyBOOnRoaXMuX3BvaW50cy5leHBhbmRFbnZlbG9wZShuZXcgTil9aXNSaW5nKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKSYmdGhpcy5pc1NpbXBsZSgpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3BvaW50cy50b0Nvb3JkaW5hdGVBcnJheSgpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7Y29uc3Qgbj10O2lmKHRoaXMuX3BvaW50cy5zaXplKCkhPT1uLl9wb2ludHMuc2l6ZSgpKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcG9pbnRzLnNpemUoKTt0KyspaWYoIXRoaXMuZXF1YWwodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCksbi5fcG9pbnRzLmdldENvb3JkaW5hdGUodCksZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXtmb3IobGV0IHQ9MDt0PE1hdGgudHJ1bmModGhpcy5fcG9pbnRzLnNpemUoKS8yKTt0Kyspe2NvbnN0IGU9dGhpcy5fcG9pbnRzLnNpemUoKS0xLXQ7aWYoIXRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLmVxdWFscyh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSkpe2lmKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLmNvbXBhcmVUbyh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSk+MCl7Y29uc3QgdD10aGlzLl9wb2ludHMuY29weSgpO0x0LnJldmVyc2UodCksdGhpcy5fcG9pbnRzPXR9cmV0dXJuIG51bGx9fX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoMCl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpP3V0LkZBTFNFOjB9aXNDbG9zZWQoKXtyZXR1cm4hdGhpcy5pc0VtcHR5KCkmJnRoaXMuZ2V0Q29vcmRpbmF0ZU4oMCkuZXF1YWxzMkQodGhpcy5nZXRDb29yZGluYXRlTih0aGlzLmdldE51bVBvaW50cygpLTEpKX1nZXRFbmRQb2ludCgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2V0UG9pbnROKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gcS5UWVBFQ09ERV9MSU5FU1RSSU5HfWdldERpbWVuc2lvbigpe3JldHVybiAxfWdldExlbmd0aCgpe3JldHVybiB5dC5vZkxpbmUodGhpcy5fcG9pbnRzKX1nZXROdW1Qb2ludHMoKXtyZXR1cm4gdGhpcy5fcG9pbnRzLnNpemUoKX1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLl9wb2ludHMuY29weSgpO3JldHVybiBMdC5yZXZlcnNlKHQpLHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodCl9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPTAsbj0wO2Zvcig7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpJiZuPHQuX3BvaW50cy5zaXplKCk7KXtjb25zdCBzPXRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpLmNvbXBhcmVUbyh0Ll9wb2ludHMuZ2V0Q29vcmRpbmF0ZShuKSk7aWYoMCE9PXMpcmV0dXJuIHM7ZSsrLG4rK31yZXR1cm4gZTx0aGlzLl9wb2ludHMuc2l6ZSgpPzE6bjx0Ll9wb2ludHMuc2l6ZSgpPy0xOjB9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBhcmd1bWVudHNbMV0uY29tcGFyZSh0aGlzLl9wb2ludHMsdC5fcG9pbnRzKX19YXBwbHkoKXtpZihfKGFyZ3VtZW50c1swXSxCKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpO2UrKyl0LmZpbHRlcih0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxkdCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDA9PT10aGlzLl9wb2ludHMuc2l6ZSgpKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9pbnRzLnNpemUoKSYmKHQuZmlsdGVyKHRoaXMuX3BvaW50cyxlKSwhdC5pc0RvbmUoKSk7ZSsrKTt0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxndCkpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxHKSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX19Z2V0Qm91bmRhcnkoKXtyZXR1cm4gbmV3IHB0KHRoaXMpLmdldEJvdW5kYXJ5KCl9aXNFcXVpdmFsZW50Q2xhc3ModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBUdH1nZXRDb29yZGluYXRlTih0KXtyZXR1cm4gdGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfTElORVNUUklOR31jb3B5KCl7cmV0dXJuIG5ldyBUdCh0aGlzLl9wb2ludHMuY29weSgpLHRoaXMuX2ZhY3RvcnkpfWdldENvb3JkaW5hdGVTZXF1ZW5jZSgpe3JldHVybiB0aGlzLl9wb2ludHN9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5fcG9pbnRzLnNpemUoKX1pbml0KHQpe2lmKG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksMT09PXQuc2l6ZSgpKXRocm93IG5ldyBuKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVTdHJpbmcgKGZvdW5kIFwiK3Quc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDIpXCIpO3RoaXMuX3BvaW50cz10fWlzQ29vcmRpbmF0ZSh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCk7ZSsrKWlmKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpLmVxdWFscyh0KSlyZXR1cm4hMDtyZXR1cm4hMX1nZXRTdGFydFBvaW50KCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4oMCl9Z2V0UG9pbnROKHQpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSl9Z2V0Q2xhc3MoKXtyZXR1cm4gVHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW290XX19VHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcG9pbnRzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3EuY29uc3RydWN0b3JfLmNhbGwodGhpcyxlKSx0aGlzLmluaXQodCl9fSxUdC5zZXJpYWxWZXJzaW9uVUlEPTB4MmIyYjUxYmE0MzVjOGUwMDtjbGFzcyBSdHtjb25zdHJ1Y3Rvcigpe1J0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gUnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVJ0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgUHQgZXh0ZW5kcyBxe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxQdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG5ldyBOO2NvbnN0IHQ9bmV3IE47cmV0dXJuIHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2Nvb3JkaW5hdGVzLmdldFgoMCksdGhpcy5fY29vcmRpbmF0ZXMuZ2V0WSgwKSksdH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9bXTpbdGhpcy5nZXRDb29yZGluYXRlKCldfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiYoISghdGhpcy5pc0VtcHR5KCl8fCF0LmlzRW1wdHkoKSl8fHRoaXMuaXNFbXB0eSgpPT09dC5pc0VtcHR5KCkmJnRoaXMuZXF1YWwodC5nZXRDb29yZGluYXRlKCksdGhpcy5nZXRDb29yZGluYXRlKCksZSkpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gMCE9PXRoaXMuX2Nvb3JkaW5hdGVzLnNpemUoKT90aGlzLl9jb29yZGluYXRlcy5nZXRDb29yZGluYXRlKDApOm51bGx9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gdXQuRkFMU0V9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gcS5UWVBFQ09ERV9QT0lOVH1nZXREaW1lbnNpb24oKXtyZXR1cm4gMH1nZXROdW1Qb2ludHMoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoxfXJldmVyc2UoKXtyZXR1cm4gdGhpcy5jb3B5KCl9Z2V0WCgpe2lmKG51bGw9PT10aGlzLmdldENvb3JkaW5hdGUoKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiZ2V0WCBjYWxsZWQgb24gZW1wdHkgUG9pbnRcIik7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnh9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odC5nZXRDb29yZGluYXRlKCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gYXJndW1lbnRzWzFdLmNvbXBhcmUodGhpcy5fY29vcmRpbmF0ZXMsdC5fY29vcmRpbmF0ZXMpfX1hcHBseSgpe2lmKF8oYXJndW1lbnRzWzBdLEIpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0LmZpbHRlcih0aGlzLmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxkdCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3QuZmlsdGVyKHRoaXMuX2Nvb3JkaW5hdGVzLDApLHQuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGd0KSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLEcpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfX1nZXRCb3VuZGFyeSgpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9QT0lOVH1jb3B5KCl7cmV0dXJuIG5ldyBQdCh0aGlzLl9jb29yZGluYXRlcy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzfWdldFkoKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcImdldFkgY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS55fWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuX2Nvb3JkaW5hdGVzLnNpemUoKX1pbml0KHQpe251bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksdS5pc1RydWUodC5zaXplKCk8PTEpLHRoaXMuX2Nvb3JkaW5hdGVzPXR9aXNTaW1wbGUoKXtyZXR1cm4hMH1nZXRDbGFzcygpe3JldHVybiBQdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUnRdfX1QdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb29yZGluYXRlcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3EuY29uc3RydWN0b3JfLmNhbGwodGhpcyxlKSx0aGlzLmluaXQodCl9LFB0LnNlcmlhbFZlcnNpb25VSUQ9MHg0NDA3N2JhZDE2MWNiYzAwO2NsYXNzIHZ0e2NvbnN0cnVjdG9yKCl7dnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb2ZSaW5nKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYWJzKHZ0Lm9mUmluZ1NpZ25lZCh0KSl9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmFicyh2dC5vZlJpbmdTaWduZWQodCkpfX1zdGF0aWMgb2ZSaW5nU2lnbmVkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5sZW5ndGg8MylyZXR1cm4gMDtsZXQgZT0wO2NvbnN0IG49dFswXS54O2ZvcihsZXQgcz0xO3M8dC5sZW5ndGgtMTtzKyspe2NvbnN0IGk9dFtzXS54LW4scj10W3MrMV0ueTtlKz1pKih0W3MtMV0ueS1yKX1yZXR1cm4gZS8yfWlmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuc2l6ZSgpO2lmKGU8MylyZXR1cm4gMDtjb25zdCBuPW5ldyBnLHM9bmV3IGcsaT1uZXcgZzt0LmdldENvb3JkaW5hdGUoMCxzKSx0LmdldENvb3JkaW5hdGUoMSxpKTtjb25zdCByPXMueDtpLngtPXI7bGV0IG89MDtmb3IobGV0IGw9MTtsPGUtMTtsKyspbi55PXMueSxzLng9aS54LHMueT1pLnksdC5nZXRDb29yZGluYXRlKGwrMSxpKSxpLngtPXIsbys9cy54KihuLnktaS55KTtyZXR1cm4gby8yfX1nZXRDbGFzcygpe3JldHVybiB2dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBPdHtjb25zdHJ1Y3Rvcigpe090LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gT3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU90LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgYnQgZXh0ZW5kcyBxe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxidC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7cmV0dXJuIHRoaXMuX3NoZWxsLmdldEVudmVsb3BlSW50ZXJuYWwoKX1nZXRDb29yZGluYXRlcygpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybltdO2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCk7bGV0IGU9LTE7Y29uc3Qgbj10aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgcz0wO3M8bi5sZW5ndGg7cysrKWUrKyx0W2VdPW5bc107Zm9yKGxldCBuPTA7bjx0aGlzLl9ob2xlcy5sZW5ndGg7bisrKXtjb25zdCBzPXRoaXMuX2hvbGVzW25dLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxzLmxlbmd0aDtuKyspZSsrLHRbZV09c1tuXX1yZXR1cm4gdH1nZXRBcmVhKCl7bGV0IHQ9MDt0Kz12dC5vZlJpbmcodGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0LT12dC5vZlJpbmcodGhpcy5faG9sZXNbZV0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO3JldHVybiB0fWlzUmVjdGFuZ2xlKCl7aWYoMCE9PXRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCkpcmV0dXJuITE7aWYobnVsbD09PXRoaXMuX3NoZWxsKXJldHVybiExO2lmKDUhPT10aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKSlyZXR1cm4hMTtjb25zdCB0PXRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLGU9dGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCk7Zm9yKGxldCBuPTA7bjw1O24rKyl7Y29uc3Qgcz10LmdldFgobik7aWYocyE9PWUuZ2V0TWluWCgpJiZzIT09ZS5nZXRNYXhYKCkpcmV0dXJuITE7Y29uc3QgaT10LmdldFkobik7aWYoaSE9PWUuZ2V0TWluWSgpJiZpIT09ZS5nZXRNYXhZKCkpcmV0dXJuITF9bGV0IG49dC5nZXRYKDApLHM9dC5nZXRZKDApO2ZvcihsZXQgZT0xO2U8PTQ7ZSsrKXtjb25zdCBpPXQuZ2V0WChlKSxyPXQuZ2V0WShlKTtpZihpIT09bj09PShyIT09cykpcmV0dXJuITE7bj1pLHM9cn1yZXR1cm4hMH1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO2NvbnN0IG49dCxzPXRoaXMuX3NoZWxsLGk9bi5fc2hlbGw7aWYoIXMuZXF1YWxzRXhhY3QoaSxlKSlyZXR1cm4hMTtpZih0aGlzLl9ob2xlcy5sZW5ndGghPT1uLl9ob2xlcy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9ob2xlc1t0XS5lcXVhbHNFeGFjdChuLl9ob2xlc1t0XSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLm5vcm1hbGl6ZSh0aGlzLl9zaGVsbCwhMCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5sZW5ndGg7dCsrKXRoaXMubm9ybWFsaXplKHRoaXMuX2hvbGVzW3RdLCExKTtodC5zb3J0KHRoaXMuX2hvbGVzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBBcnJheSh0LmdldENvb3JkaW5hdGVzKCkubGVuZ3RoLTEpLmZpbGwobnVsbCk7Ty5hcnJheWNvcHkodC5nZXRDb29yZGluYXRlcygpLDAsbiwwLG4ubGVuZ3RoKTtjb25zdCBzPVgubWluQ29vcmRpbmF0ZSh0LmdldENvb3JkaW5hdGVzKCkpO1guc2Nyb2xsKG4scyksTy5hcnJheWNvcHkobiwwLHQuZ2V0Q29vcmRpbmF0ZXMoKSwwLG4ubGVuZ3RoKSx0LmdldENvb3JkaW5hdGVzKClbbi5sZW5ndGhdPW5bMF0sdi5pc0NDVyh0LmdldENvb3JkaW5hdGVzKCkpPT09ZSYmWC5yZXZlcnNlKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZSgpfWdldE51bUludGVyaW9yUmluZygpe3JldHVybiB0aGlzLl9ob2xlcy5sZW5ndGh9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gMX1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX1BPTFlHT059Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDJ9Z2V0TGVuZ3RoKCl7bGV0IHQ9MDt0Kz10aGlzLl9zaGVsbC5nZXRMZW5ndGgoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5faG9sZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9Z2V0TnVtUG9pbnRzKCl7bGV0IHQ9dGhpcy5fc2hlbGwuZ2V0TnVtUG9pbnRzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2hvbGVzW2VdLmdldE51bVBvaW50cygpO3JldHVybiB0fXJldmVyc2UoKXtjb25zdCB0PXRoaXMuY29weSgpO3QuX3NoZWxsPXRoaXMuX3NoZWxsLmNvcHkoKS5yZXZlcnNlKCksdC5faG9sZXM9bmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdC5faG9sZXNbZV09dGhpcy5faG9sZXNbZV0uY29weSgpLnJldmVyc2UoKTtyZXR1cm4gdH1jb252ZXhIdWxsKCl7cmV0dXJuIHRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkuY29udmV4SHVsbCgpfWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX3NoZWxsLG49dC5fc2hlbGw7cmV0dXJuIGUuY29tcGFyZVRvU2FtZUNsYXNzKG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQscz10aGlzLl9zaGVsbCxpPW4uX3NoZWxsLHI9cy5jb21wYXJlVG9TYW1lQ2xhc3MoaSxlKTtpZigwIT09cilyZXR1cm4gcjtjb25zdCBvPXRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCksbD1uLmdldE51bUludGVyaW9yUmluZygpO2xldCBhPTA7Zm9yKDthPG8mJmE8bDspe2NvbnN0IHQ9dGhpcy5nZXRJbnRlcmlvclJpbmdOKGEpLHM9bi5nZXRJbnRlcmlvclJpbmdOKGEpLGk9dC5jb21wYXJlVG9TYW1lQ2xhc3MocyxlKTtpZigwIT09aSlyZXR1cm4gaTthKyt9cmV0dXJuIGE8bz8xOmE8bD8tMTowfX1hcHBseSgpe2lmKF8oYXJndW1lbnRzWzBdLEIpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaGVsbC5hcHBseSh0KTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdGhpcy5faG9sZXNbZV0uYXBwbHkodCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxkdCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuX3NoZWxsLmFwcGx5KHQpLCF0LmlzRG9uZSgpKWZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoJiYodGhpcy5faG9sZXNbZV0uYXBwbHkodCksIXQuaXNEb25lKCkpO2UrKyk7dC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZ3QpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuZmlsdGVyKHRoaXMpLHRoaXMuX3NoZWxsLmFwcGx5KHQpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0aGlzLl9ob2xlc1tlXS5hcHBseSh0KX19Z2V0Qm91bmRhcnkoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKzEpLmZpbGwobnVsbCk7dFswXT10aGlzLl9zaGVsbDtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdFtlKzFdPXRoaXMuX2hvbGVzW2VdO3JldHVybiB0Lmxlbmd0aDw9MT90aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHRbMF0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpOnRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0KX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9QT0xZR09OfWNvcHkoKXtjb25zdCB0PXRoaXMuX3NoZWxsLmNvcHkoKSxlPW5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5sZW5ndGg7dCsrKWVbdF09dGhpcy5faG9sZXNbdF0uY29weSgpO3JldHVybiBuZXcgYnQodCxlLHRoaXMuX2ZhY3RvcnkpfWdldEV4dGVyaW9yUmluZygpe3JldHVybiB0aGlzLl9zaGVsbH1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX3NoZWxsLmlzRW1wdHkoKX1nZXRJbnRlcmlvclJpbmdOKHQpe3JldHVybiB0aGlzLl9ob2xlc1t0XX1nZXRDbGFzcygpe3JldHVybiBidH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bT3RdfX1idC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zaGVsbD1udWxsLHRoaXMuX2hvbGVzPW51bGw7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2NvbnN0IHM9YXJndW1lbnRzWzJdO2lmKHEuY29uc3RydWN0b3JfLmNhbGwodGhpcyxzKSxudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZygpKSxudWxsPT09ZSYmKGU9W10pLHEuaGFzTnVsbEVsZW1lbnRzKGUpKXRocm93IG5ldyBuKFwiaG9sZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO2lmKHQuaXNFbXB0eSgpJiZxLmhhc05vbkVtcHR5RWxlbWVudHMoZSkpdGhyb3cgbmV3IG4oXCJzaGVsbCBpcyBlbXB0eSBidXQgaG9sZXMgYXJlIG5vdFwiKTt0aGlzLl9zaGVsbD10LHRoaXMuX2hvbGVzPWV9LGJ0LnNlcmlhbFZlcnNpb25VSUQ9LTB4MzA3ZmZlZmQ4ZGM5NzIwMDtjbGFzcyBNdCBleHRlbmRzIF90e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxNdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzVmFsaWQoKXtyZXR1cm4hMH1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmc3VwZXIuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbdF0uZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiBzdXBlci5nZXRDb29yZGluYXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB1dC5GQUxTRX1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX01VTFRJUE9JTlR9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDB9Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfTVVMVElQT0lOVH1jb3B5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IE10KHQsdGhpcy5fZmFjdG9yeSl9Z2V0Q2xhc3MoKXtyZXR1cm4gTXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1J0XX19TXQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07X3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfSxNdC5zZXJpYWxWZXJzaW9uVUlEPS0weDZmYjFlZDQxNjJlMGZjMDA7Y2xhc3MgRHQgZXh0ZW5kcyBUdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB1dC5GQUxTRX1pc0Nsb3NlZCgpe3JldHVybiEhdGhpcy5pc0VtcHR5KCl8fHN1cGVyLmlzQ2xvc2VkLmNhbGwodGhpcyl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gcS5UWVBFQ09ERV9MSU5FQVJSSU5HfXJldmVyc2UoKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7cmV0dXJuIEx0LnJldmVyc2UodCksdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyh0KX12YWxpZGF0ZUNvbnN0cnVjdGlvbigpe2lmKCF0aGlzLmlzRW1wdHkoKSYmIXN1cGVyLmlzQ2xvc2VkLmNhbGwodGhpcykpdGhyb3cgbmV3IG4oXCJQb2ludHMgb2YgTGluZWFyUmluZyBkbyBub3QgZm9ybSBhIGNsb3NlZCBsaW5lc3RyaW5nXCIpO2lmKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPj0xJiZ0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKTxEdC5NSU5JTVVNX1ZBTElEX1NJWkUpdGhyb3cgbmV3IG4oXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZWFyUmluZyAoZm91bmQgXCIrdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gNClcIil9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfTElORUFSUklOR31jb3B5KCl7cmV0dXJuIG5ldyBEdCh0aGlzLl9wb2ludHMuY29weSgpLHRoaXMuX2ZhY3RvcnkpfWdldENsYXNzKCl7cmV0dXJuIER0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1EdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEh0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtEdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KSxlKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLEEpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEh0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtUdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy52YWxpZGF0ZUNvbnN0cnVjdGlvbigpfX0sRHQuTUlOSU1VTV9WQUxJRF9TSVpFPTQsRHQuc2VyaWFsVmVyc2lvblVJRD0tMHgzYjIyOWUyNjIzNjdhNjAwO2NsYXNzIEF0IGV4dGVuZHMgX3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLEF0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJnN1cGVyLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gMX1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX01VTFRJUE9MWUdPTn1nZXREaW1lbnNpb24oKXtyZXR1cm4gMn1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWVbdF09dGhpcy5fZ2VvbWV0cmllc1t0XS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpUG9seWdvbihlKX1nZXRCb3VuZGFyeSgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTtjb25zdCB0PW5ldyB4O2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0Qm91bmRhcnkoKTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl0LmFkZChuLmdldEdlb21ldHJ5TihlKSl9Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0LnRvQXJyYXkoZSkpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX01VTFRJUE9MWUdPTn1jb3B5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IEF0KHQsdGhpcy5fZmFjdG9yeSl9Z2V0Q2xhc3MoKXtyZXR1cm4gQXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW090XX19QXQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07X3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfSxBdC5zZXJpYWxWZXJzaW9uVUlEPS0weDdhNWFhMTM2OTE3MTk4MDtjbGFzcyBGdHtjb25zdHJ1Y3Rvcigpe0Z0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0Q29weVVzZXJEYXRhKHQpe3RoaXMuX2lzVXNlckRhdGFDb3BpZWQ9dH1lZGl0KHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Y29uc3Qgbj10aGlzLmVkaXRJbnRlcm5hbCh0LGUpO3JldHVybiB0aGlzLl9pc1VzZXJEYXRhQ29waWVkJiZuLnNldFVzZXJEYXRhKHQuZ2V0VXNlckRhdGEoKSksbn1lZGl0SW50ZXJuYWwodCxlKXtyZXR1cm4gbnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0IGluc3RhbmNlb2YgX3Q/dGhpcy5lZGl0R2VvbWV0cnlDb2xsZWN0aW9uKHQsZSk6dCBpbnN0YW5jZW9mIGJ0P3RoaXMuZWRpdFBvbHlnb24odCxlKTp0IGluc3RhbmNlb2YgUHR8fHQgaW5zdGFuY2VvZiBUdD9lLmVkaXQodCx0aGlzLl9mYWN0b3J5KToodS5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuc3VwcG9ydGVkIEdlb21ldHJ5IGNsYXNzOiBcIit0LmdldENsYXNzKCkuZ2V0TmFtZSgpKSxudWxsKX1lZGl0R2VvbWV0cnlDb2xsZWN0aW9uKHQsZSl7Y29uc3Qgbj1lLmVkaXQodCx0aGlzLl9mYWN0b3J5KSxzPW5ldyB4O2ZvcihsZXQgdD0wO3Q8bi5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBpPXRoaXMuZWRpdChuLmdldEdlb21ldHJ5Tih0KSxlKTtudWxsPT09aXx8aS5pc0VtcHR5KCl8fHMuYWRkKGkpfXJldHVybiBuLmdldENsYXNzKCk9PT1NdD90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQocy50b0FycmF5KFtdKSk6bi5nZXRDbGFzcygpPT09ZnQ/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcocy50b0FycmF5KFtdKSk6bi5nZXRDbGFzcygpPT09QXQ/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24ocy50b0FycmF5KFtdKSk6dGhpcy5fZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24ocy50b0FycmF5KFtdKSl9ZWRpdFBvbHlnb24odCxlKXtsZXQgbj1lLmVkaXQodCx0aGlzLl9mYWN0b3J5KTtpZihudWxsPT09biYmKG49dGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKCkpLG4uaXNFbXB0eSgpKXJldHVybiBuO2NvbnN0IHM9dGhpcy5lZGl0KG4uZ2V0RXh0ZXJpb3JSaW5nKCksZSk7aWYobnVsbD09PXN8fHMuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKTtjb25zdCBpPW5ldyB4O2ZvcihsZXQgdD0wO3Q8bi5nZXROdW1JbnRlcmlvclJpbmcoKTt0Kyspe2NvbnN0IHM9dGhpcy5lZGl0KG4uZ2V0SW50ZXJpb3JSaW5nTih0KSxlKTtudWxsPT09c3x8cy5pc0VtcHR5KCl8fGkuYWRkKHMpfXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24ocyxpLnRvQXJyYXkoW10pKX1nZXRDbGFzcygpe3JldHVybiBGdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gR3QoKXt9RnQuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb249R3Q7Y2xhc3MgcXR7Y29uc3RydWN0b3IoKXtxdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVkaXQodCxlKXtyZXR1cm4gdH1nZXRDbGFzcygpe3JldHVybiBxdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR3RdfX1xdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEJ0e2NvbnN0cnVjdG9yKCl7QnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lZGl0KHQsZSl7Y29uc3Qgbj10aGlzLmVkaXQodC5nZXRDb29yZGluYXRlcygpLHQpO3JldHVybiB0IGluc3RhbmNlb2YgRHQ/bnVsbD09PW4/ZS5jcmVhdGVMaW5lYXJSaW5nKCk6ZS5jcmVhdGVMaW5lYXJSaW5nKG4pOnQgaW5zdGFuY2VvZiBUdD9udWxsPT09bj9lLmNyZWF0ZUxpbmVTdHJpbmcoKTplLmNyZWF0ZUxpbmVTdHJpbmcobik6dCBpbnN0YW5jZW9mIFB0P251bGw9PT1ufHwwPT09bi5sZW5ndGg/ZS5jcmVhdGVQb2ludCgpOmUuY3JlYXRlUG9pbnQoblswXSk6dH1nZXRDbGFzcygpe3JldHVybiBCdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR3RdfX1CdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFZ0e2NvbnN0cnVjdG9yKCl7VnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lZGl0KHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBEdD9lLmNyZWF0ZUxpbmVhclJpbmcodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnQgaW5zdGFuY2VvZiBUdD9lLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnQgaW5zdGFuY2VvZiBQdD9lLmNyZWF0ZVBvaW50KHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0fWdldENsYXNzKCl7cmV0dXJuIFZ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHdF19fVZ0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sRnQuTm9PcEdlb21ldHJ5T3BlcmF0aW9uPXF0LEZ0LkNvb3JkaW5hdGVPcGVyYXRpb249QnQsRnQuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uPVZ0LEZ0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9pc1VzZXJEYXRhQ29waWVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9fTtjbGFzcyB6dHtjb25zdHJ1Y3Rvcigpe3p0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0T3JkaW5hdGUodCxlLHMpe3N3aXRjaChlKXtjYXNlIEEuWDp0aGlzLl9jb29yZGluYXRlc1t0XS54PXM7YnJlYWs7Y2FzZSBBLlk6dGhpcy5fY29vcmRpbmF0ZXNbdF0ueT1zO2JyZWFrO2Nhc2UgQS5aOnRoaXMuX2Nvb3JkaW5hdGVzW3RdLno9czticmVhaztkZWZhdWx0OnRocm93IG5ldyBuKFwiaW52YWxpZCBvcmRpbmF0ZUluZGV4XCIpfX1zaXplKCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aH1nZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaChlKXtjYXNlIEEuWDpyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueDtjYXNlIEEuWTpyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueTtjYXNlIEEuWjpyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0uen1yZXR1cm4gaS5OYU59Z2V0Q29vcmRpbmF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF19aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2UueD10aGlzLl9jb29yZGluYXRlc1t0XS54LGUueT10aGlzLl9jb29yZGluYXRlc1t0XS55LGUuej10aGlzLl9jb29yZGluYXRlc1t0XS56fX1nZXRDb29yZGluYXRlQ29weSh0KXtyZXR1cm4gbmV3IGcodGhpcy5fY29vcmRpbmF0ZXNbdF0pfWdldERpbWVuc2lvbigpe3JldHVybiB0aGlzLl9kaW1lbnNpb259Z2V0WCh0KXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueH1leHBhbmRFbnZlbG9wZSh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0fWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdFtlXT10aGlzLl9jb29yZGluYXRlc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyB6dCh0LHRoaXMuX2RpbWVuc2lvbil9dG9TdHJpbmcoKXtpZih0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg+MCl7Y29uc3QgdD1uZXcgd3QoMTcqdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoKTt0LmFwcGVuZChcIihcIiksdC5hcHBlbmQodGhpcy5fY29vcmRpbmF0ZXNbMF0pO2ZvcihsZXQgZT0xO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0LmFwcGVuZChcIiwgXCIpLHQuYXBwZW5kKHRoaXMuX2Nvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdC5hcHBlbmQoXCIpXCIpLHQudG9TdHJpbmcoKX1yZXR1cm5cIigpXCJ9Z2V0WSh0KXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueX10b0Nvb3JkaW5hdGVBcnJheSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc31nZXRDbGFzcygpe3JldHVybiB6dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQSxhXX19enQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZGltZW5zaW9uPTMsdGhpcy5fY29vcmRpbmF0ZXM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07enQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDMpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkodCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXRoaXMuX2Nvb3JkaW5hdGVzW2VdPW5ldyBnfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXJldHVybiB0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO3RoaXMuX2RpbWVuc2lvbj10LmdldERpbWVuc2lvbigpLHRoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdGhpcy5fY29vcmRpbmF0ZXNbZV09dC5nZXRDb29yZGluYXRlQ29weShlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Nvb3JkaW5hdGVzPXQsdGhpcy5fZGltZW5zaW9uPWUsbnVsbD09PXQmJih0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksdGhpcy5fZGltZW5zaW9uPWU7Zm9yKGxldCBlPTA7ZTx0O2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT1uZXcgZ319LHp0LnNlcmlhbFZlcnNpb25VSUQ9LTB4Y2I0NGE3NzhkYjE4ZTAwO2NsYXNzIFl0e2NvbnN0cnVjdG9yKCl7WXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW5zdGFuY2UoKXtyZXR1cm4gWXQuaW5zdGFuY2VPYmplY3R9cmVhZFJlc29sdmUoKXtyZXR1cm4gWXQuaW5zdGFuY2UoKX1jcmVhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyB6dCh0KX1pZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyB6dCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9YXJndW1lbnRzWzFdO3JldHVybiBlPjMmJihlPTMpLGU8Mj9uZXcgenQodCk6bmV3IHp0KHQsZSl9fWdldENsYXNzKCl7cmV0dXJuIFl0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltGLGFdfX1mdW5jdGlvbiBVdCgpe3RoaXMubWFwXz1uZXcgTWFwfVl0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sWXQuc2VyaWFsVmVyc2lvblVJRD0tMHgzOGU0OWZhNmNmNmYyZTAwLFl0Lmluc3RhbmNlT2JqZWN0PW5ldyBZdCxVdC5wcm90b3R5cGU9bmV3IGosVXQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5tYXBfLmdldCh0KXx8bnVsbH0sVXQucHJvdG90eXBlLnB1dD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLm1hcF8uc2V0KHQsZSksZX0sVXQucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe2NvbnN0IHQ9bmV3IHgsZT10aGlzLm1hcF8udmFsdWVzKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDshbi5kb25lOyl0LmFkZChuLnZhbHVlKSxuPWUubmV4dCgpO3JldHVybiB0fSxVdC5wcm90b3R5cGUuZW50cnlTZXQ9ZnVuY3Rpb24oKXtjb25zdCB0PW5ldyBKO3JldHVybiB0aGlzLm1hcF8uZW50cmllcygpLmZvckVhY2goZT0+dC5hZGQoZSkpLHR9LFV0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwXy5zaXplKCl9O2NsYXNzIGt0e2NvbnN0cnVjdG9yKCl7a3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbW9zdFByZWNpc2UodCxlKXtyZXR1cm4gdC5jb21wYXJlVG8oZSk+PTA/dDplfWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBrdCkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1lLl9tb2RlbFR5cGUmJnRoaXMuX3NjYWxlPT09ZS5fc2NhbGV9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dCxuPXRoaXMuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCkscz1lLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpO3JldHVybiBuZXcgTChuKS5jb21wYXJlVG8obmV3IEwocykpfWdldFNjYWxlKCl7cmV0dXJuIHRoaXMuX3NjYWxlfWlzRmxvYXRpbmcoKXtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkd8fHRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HX1NJTkdMRX1nZXRUeXBlKCl7cmV0dXJuIHRoaXMuX21vZGVsVHlwZX10b1N0cmluZygpe2xldCB0PVwiVU5LTk9XTlwiO3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElORz90PVwiRmxvYXRpbmdcIjp0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElOR19TSU5HTEU/dD1cIkZsb2F0aW5nLVNpbmdsZVwiOnRoaXMuX21vZGVsVHlwZT09PWt0LkZJWEVEJiYodD1cIkZpeGVkIChTY2FsZT1cIit0aGlzLmdldFNjYWxlKCkrXCIpXCIpLHR9bWFrZVByZWNpc2UoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihpLmlzTmFOKHQpKXJldHVybiB0O2lmKHRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HX1NJTkdMRSl7cmV0dXJuIHR9cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PWt0LkZJWEVEP01hdGgucm91bmQodCp0aGlzLl9zY2FsZSkvdGhpcy5fc2NhbGU6dH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HKXJldHVybiBudWxsO3QueD10aGlzLm1ha2VQcmVjaXNlKHQueCksdC55PXRoaXMubWFrZVByZWNpc2UodC55KX19Z2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCl7bGV0IHQ9MTY7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HP3Q9MTY6dGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkdfU0lOR0xFP3Q9Njp0aGlzLl9tb2RlbFR5cGU9PT1rdC5GSVhFRCYmKHQ9MStNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLmxvZyh0aGlzLmdldFNjYWxlKCkpL01hdGgubG9nKDEwKSkpKSx0fXNldFNjYWxlKHQpe3RoaXMuX3NjYWxlPU1hdGguYWJzKHQpfWdldENsYXNzKCl7cmV0dXJuIGt0fWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthLHJdfX1jbGFzcyBYdHtjb25zdHJ1Y3Rvcigpe1h0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmVhZFJlc29sdmUoKXtyZXR1cm4gWHQubmFtZVRvVHlwZU1hcC5nZXQodGhpcy5fbmFtZSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fbmFtZX1nZXRDbGFzcygpe3JldHVybiBYdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fVh0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25hbWU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9uYW1lPXQsWHQubmFtZVRvVHlwZU1hcC5wdXQodCx0aGlzKX0sWHQuc2VyaWFsVmVyc2lvblVJRD0tNTUyODYwMjYzMTczMTU5ZTQsWHQubmFtZVRvVHlwZU1hcD1uZXcgVXQsa3QuVHlwZT1YdCxrdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9tb2RlbFR5cGU9bnVsbCx0aGlzLl9zY2FsZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX21vZGVsVHlwZT1rdC5GTE9BVElORztlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21vZGVsVHlwZT10LHQ9PT1rdC5GSVhFRCYmdGhpcy5zZXRTY2FsZSgxKX1lbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21vZGVsVHlwZT1rdC5GSVhFRCx0aGlzLnNldFNjYWxlKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBrdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPXQuX21vZGVsVHlwZSx0aGlzLl9zY2FsZT10Ll9zY2FsZX19LGt0LnNlcmlhbFZlcnNpb25VSUQ9MHg2YmVlNjQwNGU5YTI1YzAwLGt0LkZJWEVEPW5ldyBYdChcIkZJWEVEXCIpLGt0LkZMT0FUSU5HPW5ldyBYdChcIkZMT0FUSU5HXCIpLGt0LkZMT0FUSU5HX1NJTkdMRT1uZXcgWHQoXCJGTE9BVElORyBTSU5HTEVcIiksa3QubWF4aW11bVByZWNpc2VWYWx1ZT05MDA3MTk5MjU0NzQwOTkyO2NsYXNzIEh0e2NvbnN0cnVjdG9yKCl7SHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9NdWx0aVBvbHlnb25BcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b0dlb21ldHJ5QXJyYXkodCl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKXtyZXR1cm4gWXQuaW5zdGFuY2UoKX1zdGF0aWMgdG9NdWx0aUxpbmVTdHJpbmdBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b0xpbmVTdHJpbmdBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b011bHRpUG9pbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b0xpbmVhclJpbmdBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b1BvaW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9Qb2x5Z29uQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9dG9HZW9tZXRyeSh0KXtyZXR1cm4gdC5pc051bGwoKT90aGlzLmNyZWF0ZVBvaW50KCk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKSYmdC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZVBvaW50KG5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKXx8dC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSldKTp0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKSxuZXcgZyh0LmdldE1heFgoKSx0LmdldE1pblkoKSksbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpXSksbnVsbCl9Y3JlYXRlTGluZVN0cmluZygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWlmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IFR0KHQsdGhpcyl9fX1jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IGZ0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgZnQodCx0aGlzKX19YnVpbGRHZW9tZXRyeSh0KXtsZXQgZT1udWxsLG49ITEscz0hMTtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKSxyPXQuZ2V0Q2xhc3MoKTtudWxsPT09ZSYmKGU9ciksciE9PWUmJihuPSEwKSx0IGluc3RhbmNlb2YgX3QmJihzPSEwKX1pZihudWxsPT09ZSlyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTtpZihufHxzKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihIdC50b0dlb21ldHJ5QXJyYXkodCkpO2NvbnN0IGk9dC5pdGVyYXRvcigpLm5leHQoKTtpZih0LnNpemUoKT4xKXtpZihpIGluc3RhbmNlb2YgYnQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2x5Z29uKEh0LnRvUG9seWdvbkFycmF5KHQpKTtpZihpIGluc3RhbmNlb2YgVHQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKEh0LnRvTGluZVN0cmluZ0FycmF5KHQpKTtpZihpIGluc3RhbmNlb2YgUHQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChIdC50b1BvaW50QXJyYXkodCkpO3Uuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbmhhbmRsZWQgY2xhc3M6IFwiK2kuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfXJldHVybiBpfWNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKHQpe3JldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWNyZWF0ZVBvaW50KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFt0XSk6bnVsbCl9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgUHQodCx0aGlzKX19fWdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeX1jcmVhdGVQb2x5Z29uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbihudWxsLG51bGwpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcodCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIER0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHQsbnVsbCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgYnQodCxlLHRoaXMpfX1nZXRTUklEKCl7cmV0dXJuIHRoaXMuX1NSSUR9Y3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBfdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IF90KHQsdGhpcyl9fWNyZWF0ZUdlb21ldHJ5KHQpe3JldHVybiBuZXcgRnQodGhpcykuZWRpdCh0LG5ldyBXdCh0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KSl9Z2V0UHJlY2lzaW9uTW9kZWwoKXtyZXR1cm4gdGhpcy5fcHJlY2lzaW9uTW9kZWx9Y3JlYXRlTGluZWFyUmluZygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWlmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IER0KHQsdGhpcyl9fX1jcmVhdGVNdWx0aVBvbHlnb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IEF0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgQXQodCx0aGlzKX19Y3JlYXRlTXVsdGlQb2ludCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgTXQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBNdCh0LHRoaXMpfWlmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKTtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKyl7Y29uc3Qgcz10aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoMSx0LmdldERpbWVuc2lvbigpKTtMdC5jb3B5KHQsbixzLDAsMSksZVtuXT10aGlzLmNyZWF0ZVBvaW50KHMpfXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoZSl9fX1nZXRDbGFzcygpe3JldHVybiBIdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fWNsYXNzIFd0IGV4dGVuZHMgRnQuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9ue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxXdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVkaXQoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBxJiZfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeS5jcmVhdGUodCl9cmV0dXJuIHN1cGVyLmVkaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIFd0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1XdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9dH0sSHQuQ2xvbmVPcD1XdCxIdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9bnVsbCx0aGlzLl9TUklEPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpSHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcga3QsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMF0sRikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0h0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IGt0LDAsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGt0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtIdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMCxIdC5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07SHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsSHQuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW4sdGhpcy5fU1JJRD1lfX0sSHQuc2VyaWFsVmVyc2lvblVJRD0tMHg1ZWE3NWYyMDUxZWViNDAwO2NvbnN0IGp0PXt0eXBlU3RyOi9eXFxzKihcXHcrKVxccypcXChcXHMqKC4qKVxccypcXClcXHMqJC8sZW1wdHlUeXBlU3RyOi9eXFxzKihcXHcrKVxccypFTVBUWVxccyokLyxzcGFjZXM6L1xccysvLHBhcmVuQ29tbWE6L1xcKVxccyosXFxzKlxcKC8sZG91YmxlUGFyZW5Db21tYTovXFwpXFxzKlxcKVxccyosXFxzKlxcKFxccypcXCgvLHRyaW1QYXJlbnM6L15cXHMqXFwoPyguKj8pXFwpP1xccyokL307Y2xhc3MgS3R7Y29uc3RydWN0b3IodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IEh0LHRoaXMucHJlY2lzaW9uTW9kZWw9dGhpcy5nZW9tZXRyeUZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKX1yZWFkKHQpe3ZhciBlLG4sczt0PXQucmVwbGFjZSgvW1xcblxccl0vZyxcIiBcIik7dmFyIGk9anQudHlwZVN0ci5leGVjKHQpO2lmKC0xIT09dC5zZWFyY2goXCJFTVBUWVwiKSYmKChpPWp0LmVtcHR5VHlwZVN0ci5leGVjKHQpKVsyXT12b2lkIDApLGkmJihuPWlbMV0udG9Mb3dlckNhc2UoKSxzPWlbMl0sUXRbbl0mJihlPVF0W25dLmNhbGwodGhpcyxzKSkpLHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIFdLVCBcIit0KTtyZXR1cm4gZX13cml0ZSh0KXtyZXR1cm4gdGhpcy5leHRyYWN0R2VvbWV0cnkodCl9ZXh0cmFjdEdlb21ldHJ5KHQpe3ZhciBlPXQuZ2V0R2VvbWV0cnlUeXBlKCkudG9Mb3dlckNhc2UoKTtpZighWnRbZV0pcmV0dXJuIG51bGw7dmFyIG49ZS50b1VwcGVyQ2FzZSgpO3JldHVybiB0LmlzRW1wdHkoKT9uK1wiIEVNUFRZXCI6bitcIihcIitadFtlXS5jYWxsKHRoaXMsdCkrXCIpXCJ9fWNvbnN0IFp0PXtjb29yZGluYXRlKHQpe3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKHQpLHQueCtcIiBcIit0Lnl9LHBvaW50KHQpe3JldHVybiBadC5jb29yZGluYXRlLmNhbGwodGhpcyx0Ll9jb29yZGluYXRlcy5fY29vcmRpbmF0ZXNbMF0pfSxtdWx0aXBvaW50KHQpe3ZhciBlPVtdO2ZvcihsZXQgbj0wLHM9dC5fZ2VvbWV0cmllcy5sZW5ndGg7bjxzOysrbillLnB1c2goXCIoXCIrWnQucG9pbnQuY2FsbCh0aGlzLHQuX2dlb21ldHJpZXNbbl0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbGluZXN0cmluZyh0KXt2YXIgZT1bXTtmb3IobGV0IG49MCxzPXQuX3BvaW50cy5fY29vcmRpbmF0ZXMubGVuZ3RoO248czsrK24pZS5wdXNoKFp0LmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuX3BvaW50cy5fY29vcmRpbmF0ZXNbbl0pKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbGluZWFycmluZyh0KXt2YXIgZT1bXTtmb3IobGV0IG49MCxzPXQuX3BvaW50cy5fY29vcmRpbmF0ZXMubGVuZ3RoO248czsrK24pZS5wdXNoKFp0LmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuX3BvaW50cy5fY29vcmRpbmF0ZXNbbl0pKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbXVsdGlsaW5lc3RyaW5nKHQpe3ZhciBlPVtdO2ZvcihsZXQgbj0wLHM9dC5fZ2VvbWV0cmllcy5sZW5ndGg7bjxzOysrbillLnB1c2goXCIoXCIrWnQubGluZXN0cmluZy5jYWxsKHRoaXMsdC5fZ2VvbWV0cmllc1tuXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxwb2x5Z29uKHQpe3ZhciBlPVtdO2UucHVzaChcIihcIitadC5saW5lc3RyaW5nLmNhbGwodGhpcyx0Ll9zaGVsbCkrXCIpXCIpO2ZvcihsZXQgbj0wLHM9dC5faG9sZXMubGVuZ3RoO248czsrK24pZS5wdXNoKFwiKFwiK1p0LmxpbmVzdHJpbmcuY2FsbCh0aGlzLHQuX2hvbGVzW25dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LG11bHRpcG9seWdvbih0KXt2YXIgZT1bXTtmb3IobGV0IG49MCxzPXQuX2dlb21ldHJpZXMubGVuZ3RoO248czsrK24pZS5wdXNoKFwiKFwiK1p0LnBvbHlnb24uY2FsbCh0aGlzLHQuX2dlb21ldHJpZXNbbl0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sZ2VvbWV0cnljb2xsZWN0aW9uKHQpe3ZhciBlPVtdO2ZvcihsZXQgbj0wLHM9dC5fZ2VvbWV0cmllcy5sZW5ndGg7bjxzOysrbillLnB1c2godGhpcy5leHRyYWN0R2VvbWV0cnkodC5fZ2VvbWV0cmllc1tuXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfX0sUXQ9e2Nvb3JkKHQpe3ZhciBlPXQudHJpbSgpLnNwbGl0KGp0LnNwYWNlcyksbj1uZXcgZyhOdW1iZXIucGFyc2VGbG9hdChlWzBdKSxOdW1iZXIucGFyc2VGbG9hdChlWzFdKSk7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2Uobiksbn0scG9pbnQodCl7cmV0dXJuIHZvaWQgMD09PXQ/dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoKTp0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChRdC5jb29yZC5jYWxsKHRoaXMsdCkpfSxtdWx0aXBvaW50KHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoKTt2YXIgZSxuPXQudHJpbSgpLnNwbGl0KFwiLFwiKSxzPVtdO2ZvcihsZXQgdD0wLGk9bi5sZW5ndGg7dDxpOysrdCllPW5bdF0ucmVwbGFjZShqdC50cmltUGFyZW5zLFwiJDFcIikscy5wdXNoKFF0LnBvaW50LmNhbGwodGhpcyxlKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQocyl9LGxpbmVzdHJpbmcodCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZygpO3ZhciBlPXQudHJpbSgpLnNwbGl0KFwiLFwiKSxuPVtdO2ZvcihsZXQgdD0wLHM9ZS5sZW5ndGg7dDxzOysrdCluLnB1c2goUXQuY29vcmQuY2FsbCh0aGlzLGVbdF0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhuKX0sbGluZWFycmluZyh0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKCk7dmFyIGU9dC50cmltKCkuc3BsaXQoXCIsXCIpLG49W107Zm9yKGxldCB0PTAscz1lLmxlbmd0aDt0PHM7Kyt0KW4ucHVzaChRdC5jb29yZC5jYWxsKHRoaXMsZVt0XSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4pfSxtdWx0aWxpbmVzdHJpbmcodCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7dmFyIGUsbj10LnRyaW0oKS5zcGxpdChqdC5wYXJlbkNvbW1hKSxzPVtdO2ZvcihsZXQgdD0wLGk9bi5sZW5ndGg7dDxpOysrdCllPW5bdF0ucmVwbGFjZShqdC50cmltUGFyZW5zLFwiJDFcIikscy5wdXNoKFF0LmxpbmVzdHJpbmcuY2FsbCh0aGlzLGUpKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHMpfSxwb2x5Z29uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24oKTt2YXIgZSxuLHMsaSxyPXQudHJpbSgpLnNwbGl0KGp0LnBhcmVuQ29tbWEpLG89W107Zm9yKGxldCB0PTAsbD1yLmxlbmd0aDt0PGw7Kyt0KWU9clt0XS5yZXBsYWNlKGp0LnRyaW1QYXJlbnMsXCIkMVwiKSxuPVF0LmxpbmVzdHJpbmcuY2FsbCh0aGlzLGUpLHM9dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhuLl9wb2ludHMpLDA9PT10P2k9czpvLnB1c2gocyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24oaSxvKX0sbXVsdGlwb2x5Z29uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbigpO3ZhciBlLG49dC50cmltKCkuc3BsaXQoanQuZG91YmxlUGFyZW5Db21tYSkscz1bXTtmb3IobGV0IHQ9MCxpPW4ubGVuZ3RoO3Q8aTsrK3QpZT1uW3RdLnJlcGxhY2UoanQudHJpbVBhcmVucyxcIiQxXCIpLHMucHVzaChRdC5wb2x5Z29uLmNhbGwodGhpcyxlKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihzKX0sZ2VvbWV0cnljb2xsZWN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO3ZhciBlPSh0PXQucmVwbGFjZSgvLFxccyooW0EtWmEtel0pL2csXCJ8JDFcIikpLnRyaW0oKS5zcGxpdChcInxcIiksbj1bXTtmb3IobGV0IHQ9MCxzPWUubGVuZ3RoO3Q8czsrK3Qpbi5wdXNoKHRoaXMucmVhZChlW3RdKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuKX19O2NsYXNzIEp0e2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPW5ldyBLdCh0KX13cml0ZSh0KXtyZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUodCl9c3RhdGljIHRvTGluZVN0cmluZyh0LGUpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtyZXR1cm5cIkxJTkVTVFJJTkcgKCBcIit0LngrXCIgXCIrdC55K1wiLCBcIitlLngrXCIgXCIrZS55K1wiIClcIn19Y2xhc3MgJHR7Y29uc3RydWN0b3IoKXskdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21wdXRlRWRnZURpc3RhbmNlKHQsZSxuKXtjb25zdCBzPU1hdGguYWJzKG4ueC1lLngpLGk9TWF0aC5hYnMobi55LWUueSk7bGV0IHI9LTE7aWYodC5lcXVhbHMoZSkpcj0wO2Vsc2UgaWYodC5lcXVhbHMobikpcj1zPmk/czppO2Vsc2V7Y29uc3Qgbj1NYXRoLmFicyh0LngtZS54KSxvPU1hdGguYWJzKHQueS1lLnkpO3I9cz5pP246bywwIT09cnx8dC5lcXVhbHMoZSl8fChyPU1hdGgubWF4KG4sbykpfXJldHVybiB1LmlzVHJ1ZSghKDA9PT1yJiYhdC5lcXVhbHMoZSkpLFwiQmFkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHJ9c3RhdGljIG5vblJvYnVzdENvbXB1dGVFZGdlRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9dC54LWUueCxpPXQueS1lLnkscj1NYXRoLnNxcnQocypzK2kqaSk7cmV0dXJuIHUuaXNUcnVlKCEoMD09PXImJiF0LmVxdWFscyhlKSksXCJJbnZhbGlkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHJ9Z2V0SW5kZXhBbG9uZ1NlZ21lbnQodCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5faW50TGluZUluZGV4W3RdW2VdfWdldFRvcG9sb2d5U3VtbWFyeSgpe2NvbnN0IHQ9bmV3IHd0O3JldHVybiB0aGlzLmlzRW5kUG9pbnQoKSYmdC5hcHBlbmQoXCIgZW5kcG9pbnRcIiksdGhpcy5faXNQcm9wZXImJnQuYXBwZW5kKFwiIHByb3BlclwiKSx0aGlzLmlzQ29sbGluZWFyKCkmJnQuYXBwZW5kKFwiIGNvbGxpbmVhclwiKSx0LnRvU3RyaW5nKCl9Y29tcHV0ZUludGVyc2VjdGlvbih0LGUsbixzKXt0aGlzLl9pbnB1dExpbmVzWzBdWzBdPXQsdGhpcy5faW5wdXRMaW5lc1swXVsxXT1lLHRoaXMuX2lucHV0TGluZXNbMV1bMF09bix0aGlzLl9pbnB1dExpbmVzWzFdWzFdPXMsdGhpcy5fcmVzdWx0PXRoaXMuY29tcHV0ZUludGVyc2VjdCh0LGUsbixzKX1nZXRJbnRlcnNlY3Rpb25OdW0oKXtyZXR1cm4gdGhpcy5fcmVzdWx0fWNvbXB1dGVJbnRMaW5lSW5kZXgoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCludWxsPT09dGhpcy5faW50TGluZUluZGV4JiYodGhpcy5faW50TGluZUluZGV4PUFycmF5KDIpLmZpbGwoKS5tYXAoKCk9PkFycmF5KDIpKSx0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMCksdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDEpKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmdldEVkZ2VEaXN0YW5jZSh0LDApPnRoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMSk/KHRoaXMuX2ludExpbmVJbmRleFt0XVswXT0wLHRoaXMuX2ludExpbmVJbmRleFt0XVsxXT0xKToodGhpcy5faW50TGluZUluZGV4W3RdWzBdPTEsdGhpcy5faW50TGluZUluZGV4W3RdWzFdPTApfX1pc1Byb3Blcigpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLl9pc1Byb3Blcn1zZXRQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl9wcmVjaXNpb25Nb2RlbD10fWlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4hIXRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigwKXx8ISF0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dGhpcy5fcmVzdWx0O2UrKylpZighdGhpcy5faW50UHRbZV0uZXF1YWxzMkQodGhpcy5faW5wdXRMaW5lc1t0XVswXSkmJiF0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0aGlzLl9pbnB1dExpbmVzW3RdWzFdKSlyZXR1cm4hMDtyZXR1cm4hMX19Z2V0SW50ZXJzZWN0aW9uKHQpe3JldHVybiB0aGlzLl9pbnRQdFt0XX1pc0VuZFBvaW50KCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkmJiF0aGlzLl9pc1Byb3Blcn1oYXNJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVzdWx0IT09JHQuTk9fSU5URVJTRUNUSU9OfWdldEVkZ2VEaXN0YW5jZSh0LGUpe3JldHVybiAkdC5jb21wdXRlRWRnZURpc3RhbmNlKHRoaXMuX2ludFB0W2VdLHRoaXMuX2lucHV0TGluZXNbdF1bMF0sdGhpcy5faW5wdXRMaW5lc1t0XVsxXSl9aXNDb2xsaW5lYXIoKXtyZXR1cm4gdGhpcy5fcmVzdWx0PT09JHQuQ09MTElORUFSX0lOVEVSU0VDVElPTn10b1N0cmluZygpe3JldHVybiBKdC50b0xpbmVTdHJpbmcodGhpcy5faW5wdXRMaW5lc1swXVswXSx0aGlzLl9pbnB1dExpbmVzWzBdWzFdKStcIiAtIFwiK0p0LnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzFdWzBdLHRoaXMuX2lucHV0TGluZXNbMV1bMV0pK3RoaXMuZ2V0VG9wb2xvZ3lTdW1tYXJ5KCl9Z2V0RW5kcG9pbnQodCxlKXtyZXR1cm4gdGhpcy5faW5wdXRMaW5lc1t0XVtlXX1pc0ludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9MDtlPHRoaXMuX3Jlc3VsdDtlKyspaWYodGhpcy5faW50UHRbZV0uZXF1YWxzMkQodCkpcmV0dXJuITA7cmV0dXJuITF9Z2V0SW50ZXJzZWN0aW9uQWxvbmdTZWdtZW50KHQsZSl7cmV0dXJuIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpLHRoaXMuX2ludFB0W3RoaXMuX2ludExpbmVJbmRleFt0XVtlXV19Z2V0Q2xhc3MoKXtyZXR1cm4gJHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fSR0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3Jlc3VsdD1udWxsLHRoaXMuX2lucHV0TGluZXM9QXJyYXkoMikuZmlsbCgpLm1hcCgoKT0+QXJyYXkoMikpLHRoaXMuX2ludFB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2ludExpbmVJbmRleD1udWxsLHRoaXMuX2lzUHJvcGVyPW51bGwsdGhpcy5fcGE9bnVsbCx0aGlzLl9wYj1udWxsLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5faW50UHRbMF09bmV3IGcsdGhpcy5faW50UHRbMV09bmV3IGcsdGhpcy5fcGE9dGhpcy5faW50UHRbMF0sdGhpcy5fcGI9dGhpcy5faW50UHRbMV0sdGhpcy5fcmVzdWx0PTB9LCR0LkRPTlRfSU5URVJTRUNUPTAsJHQuRE9fSU5URVJTRUNUPTEsJHQuQ09MTElORUFSPTIsJHQuTk9fSU5URVJTRUNUSU9OPTAsJHQuUE9JTlRfSU5URVJTRUNUSU9OPTEsJHQuQ09MTElORUFSX0lOVEVSU0VDVElPTj0yO2NsYXNzIHRlIGV4dGVuZHMgJHR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG5lYXJlc3RFbmRwb2ludCh0LGUsbixzKXtsZXQgaT10LHI9RC5wb2ludFRvU2VnbWVudCh0LG4scyksbz1ELnBvaW50VG9TZWdtZW50KGUsbixzKTtyZXR1cm4gbzxyJiYocj1vLGk9ZSksbz1ELnBvaW50VG9TZWdtZW50KG4sdCxlKSxvPHImJihyPW8saT1uKSxvPUQucG9pbnRUb1NlZ21lbnQocyx0LGUpLG88ciYmKHI9byxpPXMpLGl9aXNJblNlZ21lbnRFbnZlbG9wZXModCl7Y29uc3QgZT1uZXcgTih0aGlzLl9pbnB1dExpbmVzWzBdWzBdLHRoaXMuX2lucHV0TGluZXNbMF1bMV0pLG49bmV3IE4odGhpcy5faW5wdXRMaW5lc1sxXVswXSx0aGlzLl9pbnB1dExpbmVzWzFdWzFdKTtyZXR1cm4gZS5jb250YWlucyh0KSYmbi5jb250YWlucyh0KX1jb21wdXRlSW50ZXJzZWN0aW9uKCl7aWYoMyE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHN1cGVyLmNvbXB1dGVJbnRlcnNlY3Rpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0aGlzLl9pc1Byb3Blcj0hMSxOLmludGVyc2VjdHMoZSxuLHQpJiYwPT09di5pbmRleChlLG4sdCkmJjA9PT12LmluZGV4KG4sZSx0KSlyZXR1cm4gdGhpcy5faXNQcm9wZXI9ITAsKHQuZXF1YWxzKGUpfHx0LmVxdWFscyhuKSkmJih0aGlzLl9pc1Byb3Blcj0hMSksdGhpcy5fcmVzdWx0PSR0LlBPSU5UX0lOVEVSU0VDVElPTixudWxsO3RoaXMuX3Jlc3VsdD0kdC5OT19JTlRFUlNFQ1RJT059fW5vcm1hbGl6ZVRvTWluaW11bSh0LGUsbixzLGkpe2kueD10aGlzLnNtYWxsZXN0SW5BYnNWYWx1ZSh0LngsZS54LG4ueCxzLngpLGkueT10aGlzLnNtYWxsZXN0SW5BYnNWYWx1ZSh0LnksZS55LG4ueSxzLnkpLHQueC09aS54LHQueS09aS55LGUueC09aS54LGUueS09aS55LG4ueC09aS54LG4ueS09aS55LHMueC09aS54LHMueS09aS55fXNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbih0LGUsbixzKXtsZXQgaT1udWxsO3RyeXtpPWIuaW50ZXJzZWN0aW9uKHQsZSxuLHMpfWNhdGNoKHIpe2lmKCEociBpbnN0YW5jZW9mIFMpKXRocm93IHI7aT10ZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4scyl9cmV0dXJuIGl9aW50ZXJzZWN0aW9uKHQsZSxuLHMpe2xldCBpPXRoaXMuaW50ZXJzZWN0aW9uV2l0aE5vcm1hbGl6YXRpb24odCxlLG4scyk7cmV0dXJuIHRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMoaSl8fChpPW5ldyBnKHRlLm5lYXJlc3RFbmRwb2ludCh0LGUsbixzKSkpLG51bGwhPT10aGlzLl9wcmVjaXNpb25Nb2RlbCYmdGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoaSksaX1zbWFsbGVzdEluQWJzVmFsdWUodCxlLG4scyl7bGV0IGk9dCxyPU1hdGguYWJzKGkpO3JldHVybiBNYXRoLmFicyhlKTxyJiYoaT1lLHI9TWF0aC5hYnMoZSkpLE1hdGguYWJzKG4pPHImJihpPW4scj1NYXRoLmFicyhuKSksTWF0aC5hYnMocyk8ciYmKGk9cyksaX1jaGVja0REKHQsZSxuLHMsaSl7Y29uc3Qgcj1QLmludGVyc2VjdGlvbih0LGUsbixzKSxvPXRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMocik7Ty5vdXQucHJpbnRsbihcIkREIGluIGVudiA9IFwiK28rXCIgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcIityKSxpLmRpc3RhbmNlKHIpPjFlLTQmJk8ub3V0LnByaW50bG4oXCJEaXN0YW5jZSA9IFwiK2kuZGlzdGFuY2UocikpfWludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uKHQsZSxuLHMpe2NvbnN0IGk9bmV3IGcodCkscj1uZXcgZyhlKSxvPW5ldyBnKG4pLGw9bmV3IGcocyksYT1uZXcgZzt0aGlzLm5vcm1hbGl6ZVRvRW52Q2VudHJlKGkscixvLGwsYSk7Y29uc3QgYz10aGlzLnNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbihpLHIsbyxsKTtyZXR1cm4gYy54Kz1hLngsYy55Kz1hLnksY31jb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9Ti5pbnRlcnNlY3RzKHQsZSxuKSxyPU4uaW50ZXJzZWN0cyh0LGUscyksbz1OLmludGVyc2VjdHMobixzLHQpLGw9Ti5pbnRlcnNlY3RzKG4scyxlKTtyZXR1cm4gaSYmcj8odGhpcy5faW50UHRbMF09bix0aGlzLl9pbnRQdFsxXT1zLCR0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT04pOm8mJmw/KHRoaXMuX2ludFB0WzBdPXQsdGhpcy5faW50UHRbMV09ZSwkdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTppJiZvPyh0aGlzLl9pbnRQdFswXT1uLHRoaXMuX2ludFB0WzFdPXQsIW4uZXF1YWxzKHQpfHxyfHxsPyR0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046JHQuUE9JTlRfSU5URVJTRUNUSU9OKTppJiZsPyh0aGlzLl9pbnRQdFswXT1uLHRoaXMuX2ludFB0WzFdPWUsIW4uZXF1YWxzKGUpfHxyfHxvPyR0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046JHQuUE9JTlRfSU5URVJTRUNUSU9OKTpyJiZvPyh0aGlzLl9pbnRQdFswXT1zLHRoaXMuX2ludFB0WzFdPXQsIXMuZXF1YWxzKHQpfHxpfHxsPyR0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046JHQuUE9JTlRfSU5URVJTRUNUSU9OKTpyJiZsPyh0aGlzLl9pbnRQdFswXT1zLHRoaXMuX2ludFB0WzFdPWUsIXMuZXF1YWxzKGUpfHxpfHxvPyR0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046JHQuUE9JTlRfSU5URVJTRUNUSU9OKTokdC5OT19JTlRFUlNFQ1RJT059bm9ybWFsaXplVG9FbnZDZW50cmUodCxlLG4scyxpKXtjb25zdCByPXQueDxlLng/dC54OmUueCxvPXQueTxlLnk/dC55OmUueSxsPXQueD5lLng/dC54OmUueCxhPXQueT5lLnk/dC55OmUueSxjPW4ueDxzLng/bi54OnMueCxoPW4ueTxzLnk/bi55OnMueSx1PW4ueD5zLng/bi54OnMueCxnPW4ueT5zLnk/bi55OnMueSxkPSgocj5jP3I6YykrKGw8dT9sOnUpKS8yLF89KChvPmg/bzpoKSsoYTxnP2E6ZykpLzI7aS54PWQsaS55PV8sdC54LT1pLngsdC55LT1pLnksZS54LT1pLngsZS55LT1pLnksbi54LT1pLngsbi55LT1pLnkscy54LT1pLngscy55LT1pLnl9Y29tcHV0ZUludGVyc2VjdCh0LGUsbixzKXtpZih0aGlzLl9pc1Byb3Blcj0hMSwhTi5pbnRlcnNlY3RzKHQsZSxuLHMpKXJldHVybiAkdC5OT19JTlRFUlNFQ1RJT047Y29uc3QgaT12LmluZGV4KHQsZSxuKSxyPXYuaW5kZXgodCxlLHMpO2lmKGk+MCYmcj4wfHxpPDAmJnI8MClyZXR1cm4gJHQuTk9fSU5URVJTRUNUSU9OO2NvbnN0IG89di5pbmRleChuLHMsdCksbD12LmluZGV4KG4scyxlKTtyZXR1cm4gbz4wJiZsPjB8fG88MCYmbDwwPyR0Lk5PX0lOVEVSU0VDVElPTjowPT09aSYmMD09PXImJjA9PT1vJiYwPT09bD90aGlzLmNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24odCxlLG4scyk6KDA9PT1pfHwwPT09cnx8MD09PW98fDA9PT1sPyh0aGlzLl9pc1Byb3Blcj0hMSx0LmVxdWFsczJEKG4pfHx0LmVxdWFsczJEKHMpP3RoaXMuX2ludFB0WzBdPXQ6ZS5lcXVhbHMyRChuKXx8ZS5lcXVhbHMyRChzKT90aGlzLl9pbnRQdFswXT1lOjA9PT1pP3RoaXMuX2ludFB0WzBdPW5ldyBnKG4pOjA9PT1yP3RoaXMuX2ludFB0WzBdPW5ldyBnKHMpOjA9PT1vP3RoaXMuX2ludFB0WzBdPW5ldyBnKHQpOjA9PT1sJiYodGhpcy5faW50UHRbMF09bmV3IGcoZSkpKToodGhpcy5faXNQcm9wZXI9ITAsdGhpcy5faW50UHRbMF09dGhpcy5pbnRlcnNlY3Rpb24odCxlLG4scykpLCR0LlBPSU5UX0lOVEVSU0VDVElPTil9Z2V0Q2xhc3MoKXtyZXR1cm4gdGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXRlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgZWV7Y29uc3RydWN0b3IoKXtlZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtaWRQb2ludCh0LGUpe3JldHVybiBuZXcgZygodC54K2UueCkvMiwodC55K2UueSkvMil9bWluWCgpe3JldHVybiBNYXRoLm1pbih0aGlzLnAwLngsdGhpcy5wMS54KX1vcmllbnRhdGlvbkluZGV4KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT12LmluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAwKSxuPXYuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDEpO3JldHVybiBlPj0wJiZuPj0wfHxlPD0wJiZuPD0wP01hdGgubWF4KGUsbik6MH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB2LmluZGV4KHRoaXMucDAsdGhpcy5wMSx0KX19dG9HZW9tZXRyeSh0KXtyZXR1cm4gdC5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLnAwLHRoaXMucDFdKX1pc1ZlcnRpY2FsKCl7cmV0dXJuIHRoaXMucDAueD09PXRoaXMucDEueH1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2YgZWUpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5wMC5lcXVhbHMoZS5wMCkmJnRoaXMucDEuZXF1YWxzKGUucDEpfWludGVyc2VjdGlvbih0KXtjb25zdCBlPW5ldyB0ZTtyZXR1cm4gZS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpLGUuaGFzSW50ZXJzZWN0aW9uKCk/ZS5nZXRJbnRlcnNlY3Rpb24oMCk6bnVsbH1wcm9qZWN0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmVxdWFscyh0aGlzLnAwKXx8dC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIG5ldyBnKHQpO2NvbnN0IGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpLG49bmV3IGc7cmV0dXJuIG4ueD10aGlzLnAwLngrZSoodGhpcy5wMS54LXRoaXMucDAueCksbi55PXRoaXMucDAueStlKih0aGlzLnAxLnktdGhpcy5wMC55KSxufWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQucDApLG49dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQucDEpO2lmKGU+PTEmJm4+PTEpcmV0dXJuIG51bGw7aWYoZTw9MCYmbjw9MClyZXR1cm4gbnVsbDtsZXQgcz10aGlzLnByb2plY3QodC5wMCk7ZTwwJiYocz10aGlzLnAwKSxlPjEmJihzPXRoaXMucDEpO2xldCBpPXRoaXMucHJvamVjdCh0LnAxKTtyZXR1cm4gbjwwJiYoaT10aGlzLnAwKSxuPjEmJihpPXRoaXMucDEpLG5ldyBlZShzLGkpfX1ub3JtYWxpemUoKXt0aGlzLnAxLmNvbXBhcmVUbyh0aGlzLnAwKTwwJiZ0aGlzLnJldmVyc2UoKX1hbmdsZSgpe3JldHVybiBNYXRoLmF0YW4yKHRoaXMucDEueS10aGlzLnAwLnksdGhpcy5wMS54LXRoaXMucDAueCl9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gMD09PXQ/dGhpcy5wMDp0aGlzLnAxfWRpc3RhbmNlUGVycGVuZGljdWxhcih0KXtyZXR1cm4gRC5wb2ludFRvTGluZVBlcnBlbmRpY3VsYXIodCx0aGlzLnAwLHRoaXMucDEpfW1pblkoKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC55LHRoaXMucDEueSl9bWlkUG9pbnQoKXtyZXR1cm4gZWUubWlkUG9pbnQodGhpcy5wMCx0aGlzLnAxKX1wcm9qZWN0aW9uRmFjdG9yKHQpe2lmKHQuZXF1YWxzKHRoaXMucDApKXJldHVybiAwO2lmKHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiAxO2NvbnN0IGU9dGhpcy5wMS54LXRoaXMucDAueCxuPXRoaXMucDEueS10aGlzLnAwLnkscz1lKmUrbipuO3JldHVybiBzPD0wP2kuTmFOOigodC54LXRoaXMucDAueCkqZSsodC55LXRoaXMucDAueSkqbikvc31jbG9zZXN0UG9pbnRzKHQpe2NvbnN0IGU9dGhpcy5pbnRlcnNlY3Rpb24odCk7aWYobnVsbCE9PWUpcmV0dXJuW2UsZV07Y29uc3Qgbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtsZXQgcz1pLk1BWF9WQUxVRSxyPW51bGw7Y29uc3Qgbz10aGlzLmNsb3Nlc3RQb2ludCh0LnAwKTtzPW8uZGlzdGFuY2UodC5wMCksblswXT1vLG5bMV09dC5wMDtjb25zdCBsPXRoaXMuY2xvc2VzdFBvaW50KHQucDEpO3I9bC5kaXN0YW5jZSh0LnAxKSxyPHMmJihzPXIsblswXT1sLG5bMV09dC5wMSk7Y29uc3QgYT10LmNsb3Nlc3RQb2ludCh0aGlzLnAwKTtyPWEuZGlzdGFuY2UodGhpcy5wMCkscjxzJiYocz1yLG5bMF09dGhpcy5wMCxuWzFdPWEpO2NvbnN0IGM9dC5jbG9zZXN0UG9pbnQodGhpcy5wMSk7cmV0dXJuIHI9Yy5kaXN0YW5jZSh0aGlzLnAxKSxyPHMmJihzPXIsblswXT10aGlzLnAxLG5bMV09Yyksbn1jbG9zZXN0UG9pbnQodCl7Y29uc3QgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCk7cmV0dXJuIGU+MCYmZTwxP3RoaXMucHJvamVjdCh0KTp0aGlzLnAwLmRpc3RhbmNlKHQpPHRoaXMucDEuZGlzdGFuY2UodCk/dGhpcy5wMDp0aGlzLnAxfW1heFgoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC54LHRoaXMucDEueCl9Z2V0TGVuZ3RoKCl7cmV0dXJuIHRoaXMucDAuZGlzdGFuY2UodGhpcy5wMSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dCxuPXRoaXMucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnRoaXMucDEuY29tcGFyZVRvKGUucDEpfXJldmVyc2UoKXtjb25zdCB0PXRoaXMucDA7dGhpcy5wMD10aGlzLnAxLHRoaXMucDE9dH1lcXVhbHNUb3BvKHQpe3JldHVybiB0aGlzLnAwLmVxdWFscyh0LnAwKSYmdGhpcy5wMS5lcXVhbHModC5wMSl8fHRoaXMucDAuZXF1YWxzKHQucDEpJiZ0aGlzLnAxLmVxdWFscyh0LnAwKX1saW5lSW50ZXJzZWN0aW9uKHQpe3RyeXtyZXR1cm4gYi5pbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgUykpdGhyb3cgdH1yZXR1cm4gbnVsbH1tYXhZKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMucDAueSx0aGlzLnAxLnkpfXBvaW50QWxvbmdPZmZzZXQodCxlKXtjb25zdCBuPXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxzPXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxpPXRoaXMucDEueC10aGlzLnAwLngscj10aGlzLnAxLnktdGhpcy5wMC55LG89TWF0aC5zcXJ0KGkqaStyKnIpO2xldCBsPTAsYT0wO2lmKDAhPT1lKXtpZihvPD0wKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJDYW5ub3QgY29tcHV0ZSBvZmZzZXQgZnJvbSB6ZXJvLWxlbmd0aCBsaW5lIHNlZ21lbnRcIik7bD1lKmkvbyxhPWUqci9vfXJldHVybiBuZXcgZyhuLWEscytsKX1zZXRDb29yZGluYXRlcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldENvb3JkaW5hdGVzKHQucDAsdC5wMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wMC54PXQueCx0aGlzLnAwLnk9dC55LHRoaXMucDEueD1lLngsdGhpcy5wMS55PWUueX19c2VnbWVudEZyYWN0aW9uKHQpe2xldCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KTtyZXR1cm4gZTwwP2U9MDooZT4xfHxpLmlzTmFOKGUpKSYmKGU9MSksZX10b1N0cmluZygpe3JldHVyblwiTElORVNUUklORyggXCIrdGhpcy5wMC54K1wiIFwiK3RoaXMucDAueStcIiwgXCIrdGhpcy5wMS54K1wiIFwiK3RoaXMucDEueStcIilcIn1pc0hvcml6b250YWwoKXtyZXR1cm4gdGhpcy5wMC55PT09dGhpcy5wMS55fWRpc3RhbmNlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEQuc2VnbWVudFRvU2VnbWVudCh0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBELnBvaW50VG9TZWdtZW50KHQsdGhpcy5wMCx0aGlzLnAxKX19cG9pbnRBbG9uZyh0KXtjb25zdCBlPW5ldyBnO3JldHVybiBlLng9dGhpcy5wMC54K3QqKHRoaXMucDEueC10aGlzLnAwLngpLGUueT10aGlzLnAwLnkrdCoodGhpcy5wMS55LXRoaXMucDAueSksZX1oYXNoQ29kZSgpe2xldCB0PWphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAwLngpO3RePTMxKmphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAwLnkpO2NvbnN0IGU9TWF0aC50cnVuYyh0KV5NYXRoLnRydW5jKHQ+PjMyKTtsZXQgbj1qYXZhLmxhbmcuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS54KTtyZXR1cm4gbl49MzEqamF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueSksZV4oTWF0aC50cnVuYyhuKV5NYXRoLnRydW5jKG4+PjMyKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gZWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3IsYV19fWVlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpZWUuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgZyxuZXcgZyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07ZWUuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LnAwLHQucDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucDA9dCx0aGlzLnAxPWV9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107ZWUuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgZyh0LGUpLG5ldyBnKG4scykpfX0sZWUuc2VyaWFsVmVyc2lvblVJRD0weDJkMjE3MjEzNWY0MTFjMDA7Y2xhc3MgbmV7Y29uc3RydWN0b3IoKXtuZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0xvY2F0aW9uU3ltYm9sKHQpe3N3aXRjaCh0KXtjYXNlIG5lLkVYVEVSSU9SOnJldHVyblwiZVwiO2Nhc2UgbmUuQk9VTkRBUlk6cmV0dXJuXCJiXCI7Y2FzZSBuZS5JTlRFUklPUjpyZXR1cm5cImlcIjtjYXNlIG5lLk5PTkU6cmV0dXJuXCItXCJ9dGhyb3cgbmV3IG4oXCJVbmtub3duIGxvY2F0aW9uIHZhbHVlOiBcIit0KX1nZXRDbGFzcygpe3JldHVybiBuZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxuZS5JTlRFUklPUj0wLG5lLkJPVU5EQVJZPTEsbmUuRVhURVJJT1I9MixuZS5OT05FPS0xO2NsYXNzIHNle2NvbnN0cnVjdG9yKCl7c2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbWF0Y2hlcygpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGU9PT11dC5TWU1fRE9OVENBUkV8fChlPT09dXQuU1lNX1RSVUUmJih0Pj0wfHx0PT09dXQuVFJVRSl8fChlPT09dXQuU1lNX0ZBTFNFJiZ0PT09dXQuRkFMU0V8fChlPT09dXQuU1lNX1AmJnQ9PT11dC5QfHwoZT09PXV0LlNZTV9MJiZ0PT09dXQuTHx8ZT09PXV0LlNZTV9BJiZ0PT09dXQuQSkpKSl9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBzZSh0KS5tYXRjaGVzKGUpfX1zdGF0aWMgaXNUcnVlKHQpe3JldHVybiB0Pj0wfHx0PT09dXQuVFJVRX1pc0ludGVyc2VjdHMoKXtyZXR1cm4hdGhpcy5pc0Rpc2pvaW50KCl9aXNDb3ZlcnMoKXtyZXR1cm4oc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuQk9VTkRBUlldKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuSU5URVJJT1JdKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuQk9VTkRBUlldKSkmJnRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuQk9VTkRBUlldPT09dXQuRkFMU0V9aXNDb3ZlcmVkQnkoKXtyZXR1cm4oc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuQk9VTkRBUlldKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuSU5URVJJT1JdKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuQk9VTkRBUlldKSkmJnRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuRVhURVJJT1JdPT09dXQuRkFMU0V9c2V0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPU1hdGgudHJ1bmMoZS8zKSxzPWUlMzt0aGlzLl9tYXRyaXhbbl1bc109dXQudG9EaW1lbnNpb25WYWx1ZSh0LmNoYXJBdChlKSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX21hdHJpeFt0XVtlXT1ufX1pc0NvbnRhaW5zKCl7cmV0dXJuIHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSkmJnRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuQk9VTkRBUlldPT09dXQuRkFMU0V9c2V0QXRMZWFzdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj1NYXRoLnRydW5jKGUvMykscz1lJTM7dGhpcy5zZXRBdExlYXN0KG4scyx1dC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX21hdHJpeFt0XVtlXTxuJiYodGhpcy5fbWF0cml4W3RdW2VdPW4pfX1zZXRBdExlYXN0SWZWYWxpZCh0LGUsbil7dD49MCYmZT49MCYmdGhpcy5zZXRBdExlYXN0KHQsZSxuKX1pc1dpdGhpbigpe3JldHVybiBzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pJiZ0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkVYVEVSSU9SXT09PXV0LkZBTFNFfWlzVG91Y2hlcyh0LGUpe3JldHVybiB0PmU/dGhpcy5pc1RvdWNoZXMoZSx0KToodD09PXV0LkEmJmU9PT11dC5BfHx0PT09dXQuTCYmZT09PXV0Lkx8fHQ9PT11dC5MJiZlPT09dXQuQXx8dD09PXV0LlAmJmU9PT11dC5BfHx0PT09dXQuUCYmZT09PXV0LkwpJiYodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmKHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkJPVU5EQVJZXSl8fHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLklOVEVSSU9SXSl8fHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkJPVU5EQVJZXSkpKX1pc092ZXJsYXBzKHQsZSl7cmV0dXJuIHQ9PT11dC5QJiZlPT09dXQuUHx8dD09PXV0LkEmJmU9PT11dC5BP3NlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSkmJnNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXSkmJnNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXSk6dD09PXV0LkwmJmU9PT11dC5MJiYoMT09PXRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdJiZzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl0pJiZzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl0pKX1pc0VxdWFscyh0LGUpe3JldHVybiB0PT09ZSYmKHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSkmJnRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuRVhURVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuQk9VTkRBUlldPT09dXQuRkFMU0UpfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgd3QoXCIxMjM0NTY3ODlcIik7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKXQuc2V0Q2hhckF0KDMqZStuLHV0LnRvRGltZW5zaW9uU3ltYm9sKHRoaXMuX21hdHJpeFtlXVtuXSkpO3JldHVybiB0LnRvU3RyaW5nKCl9c2V0QWxsKHQpe2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKyl0aGlzLl9tYXRyaXhbZV1bbl09dH1nZXQodCxlKXtyZXR1cm4gdGhpcy5fbWF0cml4W3RdW2VdfXRyYW5zcG9zZSgpe2xldCB0PXRoaXMuX21hdHJpeFsxXVswXTtyZXR1cm4gdGhpcy5fbWF0cml4WzFdWzBdPXRoaXMuX21hdHJpeFswXVsxXSx0aGlzLl9tYXRyaXhbMF1bMV09dCx0PXRoaXMuX21hdHJpeFsyXVswXSx0aGlzLl9tYXRyaXhbMl1bMF09dGhpcy5fbWF0cml4WzBdWzJdLHRoaXMuX21hdHJpeFswXVsyXT10LHQ9dGhpcy5fbWF0cml4WzJdWzFdLHRoaXMuX21hdHJpeFsyXVsxXT10aGlzLl9tYXRyaXhbMV1bMl0sdGhpcy5fbWF0cml4WzFdWzJdPXQsdGhpc31tYXRjaGVzKHQpe2lmKDkhPT10Lmxlbmd0aCl0aHJvdyBuZXcgbihcIlNob3VsZCBiZSBsZW5ndGggOTogXCIrdCk7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKWlmKCFzZS5tYXRjaGVzKHRoaXMuX21hdHJpeFtlXVtuXSx0LmNoYXJBdCgzKmUrbikpKXJldHVybiExO3JldHVybiEwfWFkZCh0KXtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdGhpcy5zZXRBdExlYXN0KGUsbix0LmdldChlLG4pKX1pc0Rpc2pvaW50KCl7cmV0dXJuIHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuQk9VTkRBUlldPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuSU5URVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuQk9VTkRBUlldPT09dXQuRkFMU0V9aXNDcm9zc2VzKHQsZSl7cmV0dXJuIHQ9PT11dC5QJiZlPT09dXQuTHx8dD09PXV0LlAmJmU9PT11dC5BfHx0PT09dXQuTCYmZT09PXV0LkE/c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdKTp0PT09dXQuTCYmZT09PXV0LlB8fHQ9PT11dC5BJiZlPT09dXQuUHx8dD09PXV0LkEmJmU9PT11dC5MP3NlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSkmJnNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXSk6dD09PXV0LkwmJmU9PT11dC5MJiYwPT09dGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl19Z2V0Q2xhc3MoKXtyZXR1cm4gc2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1zZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9tYXRyaXg9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9tYXRyaXg9QXJyYXkoMykuZmlsbCgpLm1hcCgoKT0+QXJyYXkoMykpLHRoaXMuc2V0QWxsKHV0LkZBTFNFKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3NlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpLHRoaXMuc2V0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBzZSl7Y29uc3QgdD1hcmd1bWVudHNbMF07c2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyksdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl09dC5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0sdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5CT1VOREFSWV09dC5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5CT1VOREFSWV0sdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl09dC5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl0sdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5JTlRFUklPUl09dC5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5JTlRFUklPUl0sdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5CT1VOREFSWV09dC5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5CT1VOREFSWV0sdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5FWFRFUklPUl09dC5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5FWFRFUklPUl0sdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl09dC5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl0sdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5CT1VOREFSWV09dC5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5CT1VOREFSWV0sdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5FWFRFUklPUl09dC5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5FWFRFUklPUl19fTtjbGFzcyBpZXtjb25zdHJ1Y3Rvcigpe2llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvRGVncmVlcyh0KXtyZXR1cm4gMTgwKnQvTWF0aC5QSX1zdGF0aWMgbm9ybWFsaXplKHQpe2Zvcig7dD5NYXRoLlBJOyl0LT1pZS5QSV9USU1FU18yO2Zvcig7dDw9LU1hdGguUEk7KXQrPWllLlBJX1RJTUVTXzI7cmV0dXJuIHR9c3RhdGljIGFuZ2xlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmF0YW4yKHQueSx0LngpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWUueC10Lngscz1lLnktdC55O3JldHVybiBNYXRoLmF0YW4yKHMsbil9fXN0YXRpYyBpc0FjdXRlKHQsZSxuKXtjb25zdCBzPXQueC1lLngsaT10LnktZS55O3JldHVybiBzKihuLngtZS54KStpKihuLnktZS55KT4wfXN0YXRpYyBpc09idHVzZSh0LGUsbil7Y29uc3Qgcz10LngtZS54LGk9dC55LWUueTtyZXR1cm4gcyoobi54LWUueCkraSoobi55LWUueSk8MH1zdGF0aWMgaW50ZXJpb3JBbmdsZSh0LGUsbil7Y29uc3Qgcz1pZS5hbmdsZShlLHQpLGk9aWUuYW5nbGUoZSxuKTtyZXR1cm4gTWF0aC5hYnMoaS1zKX1zdGF0aWMgbm9ybWFsaXplUG9zaXRpdmUodCl7aWYodDwwKXtmb3IoO3Q8MDspdCs9aWUuUElfVElNRVNfMjt0Pj1pZS5QSV9USU1FU18yJiYodD0wKX1lbHNle2Zvcig7dD49aWUuUElfVElNRVNfMjspdC09aWUuUElfVElNRVNfMjt0PDAmJih0PTApfXJldHVybiB0fXN0YXRpYyBhbmdsZUJldHdlZW4odCxlLG4pe2NvbnN0IHM9aWUuYW5nbGUoZSx0KSxpPWllLmFuZ2xlKGUsbik7cmV0dXJuIGllLmRpZmYocyxpKX1zdGF0aWMgZGlmZih0LGUpe2xldCBuPW51bGw7cmV0dXJuIG49dDxlP2UtdDp0LWUsbj5NYXRoLlBJJiYobj0yKk1hdGguUEktbiksbn1zdGF0aWMgdG9SYWRpYW5zKHQpe3JldHVybiB0Kk1hdGguUEkvMTgwfXN0YXRpYyBnZXRUdXJuKHQsZSl7Y29uc3Qgbj1NYXRoLnNpbihlLXQpO3JldHVybiBuPjA/aWUuQ09VTlRFUkNMT0NLV0lTRTpuPDA/aWUuQ0xPQ0tXSVNFOmllLk5PTkV9c3RhdGljIGFuZ2xlQmV0d2Vlbk9yaWVudGVkKHQsZSxuKXtjb25zdCBzPWllLmFuZ2xlKGUsdCksaT1pZS5hbmdsZShlLG4pLXM7cmV0dXJuIGk8PS1NYXRoLlBJP2kraWUuUElfVElNRVNfMjppPk1hdGguUEk/aS1pZS5QSV9USU1FU18yOml9Z2V0Q2xhc3MoKXtyZXR1cm4gaWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWllLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30saWUuUElfVElNRVNfMj0yKk1hdGguUEksaWUuUElfT1ZFUl8yPU1hdGguUEkvMixpZS5QSV9PVkVSXzQ9TWF0aC5QSS80LGllLkNPVU5URVJDTE9DS1dJU0U9di5DT1VOVEVSQ0xPQ0tXSVNFLGllLkNMT0NLV0lTRT12LkNMT0NLV0lTRSxpZS5OT05FPXYuQ09MTElORUFSO2NsYXNzIHJle2NvbnN0cnVjdG9yKCl7cmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgYXJlYSh0LGUsbil7cmV0dXJuIE1hdGguYWJzKCgobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzIpfXN0YXRpYyBzaWduZWRBcmVhKHQsZSxuKXtyZXR1cm4oKG4ueC10LngpKihlLnktdC55KS0oZS54LXQueCkqKG4ueS10LnkpKS8yfXN0YXRpYyBkZXQodCxlLG4scyl7cmV0dXJuIHQqcy1lKm59c3RhdGljIGludGVycG9sYXRlWih0LGUsbixzKXtjb25zdCBpPWUueCxyPWUueSxvPW4ueC1pLGw9cy54LWksYT1uLnktcixjPXMueS1yLGg9bypjLWwqYSx1PXQueC1pLGc9dC55LXIsZD0oYyp1LWwqZykvaCxfPSgtYSp1K28qZykvaDtyZXR1cm4gZS56K2QqKG4uei1lLnopK18qKHMuei1lLnopfXN0YXRpYyBsb25nZXN0U2lkZUxlbmd0aCh0LGUsbil7Y29uc3Qgcz10LmRpc3RhbmNlKGUpLGk9ZS5kaXN0YW5jZShuKSxyPW4uZGlzdGFuY2UodCk7bGV0IG89cztyZXR1cm4gaT5vJiYobz1pKSxyPm8mJihvPXIpLG99c3RhdGljIGlzQWN1dGUodCxlLG4pe3JldHVybiEhaWUuaXNBY3V0ZSh0LGUsbikmJighIWllLmlzQWN1dGUoZSxuLHQpJiYhIWllLmlzQWN1dGUobix0LGUpKX1zdGF0aWMgY2lyY3VtY2VudHJlKHQsZSxuKXtjb25zdCBzPW4ueCxpPW4ueSxyPXQueC1zLG89dC55LWksbD1lLngtcyxhPWUueS1pLGM9MipyZS5kZXQocixvLGwsYSksaD1yZS5kZXQobyxyKnIrbypvLGEsbCpsK2EqYSksdT1yZS5kZXQocixyKnIrbypvLGwsbCpsK2EqYSk7cmV0dXJuIG5ldyBnKHMtaC9jLGkrdS9jKX1zdGF0aWMgcGVycGVuZGljdWxhckJpc2VjdG9yKHQsZSl7Y29uc3Qgbj1lLngtdC54LHM9ZS55LXQueSxpPW5ldyBiKHQueCtuLzIsdC55K3MvMiwxKSxyPW5ldyBiKHQueC1zK24vMix0LnkrbitzLzIsMSk7cmV0dXJuIG5ldyBiKGkscil9c3RhdGljIGFuZ2xlQmlzZWN0b3IodCxlLG4pe2NvbnN0IHM9ZS5kaXN0YW5jZSh0KSxpPXMvKHMrZS5kaXN0YW5jZShuKSkscj1uLngtdC54LG89bi55LXQueTtyZXR1cm4gbmV3IGcodC54K2kqcix0LnkraSpvKX1zdGF0aWMgYXJlYTNEKHQsZSxuKXtjb25zdCBzPWUueC10LngsaT1lLnktdC55LHI9ZS56LXQueixvPW4ueC10LngsbD1uLnktdC55LGE9bi56LXQueixjPWkqYS1yKmwsaD1yKm8tcyphLHU9cypsLWkqbyxnPWMqYytoKmgrdSp1O3JldHVybiBNYXRoLnNxcnQoZykvMn1zdGF0aWMgY2VudHJvaWQodCxlLG4pe2NvbnN0IHM9KHQueCtlLngrbi54KS8zLGk9KHQueStlLnkrbi55KS8zO3JldHVybiBuZXcgZyhzLGkpfXN0YXRpYyBpbkNlbnRyZSh0LGUsbil7Y29uc3Qgcz1lLmRpc3RhbmNlKG4pLGk9dC5kaXN0YW5jZShuKSxyPXQuZGlzdGFuY2UoZSksbz1zK2krcixsPShzKnQueCtpKmUueCtyKm4ueCkvbyxhPShzKnQueStpKmUueStyKm4ueSkvbztyZXR1cm4gbmV3IGcobCxhKX1hcmVhKCl7cmV0dXJuIHJlLmFyZWEodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfXNpZ25lZEFyZWEoKXtyZXR1cm4gcmUuc2lnbmVkQXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9aW50ZXJwb2xhdGVaKHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBuKFwiU3VwcGxpZWQgcG9pbnQgaXMgbnVsbC5cIik7cmV0dXJuIHJlLmludGVycG9sYXRlWih0LHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1sb25nZXN0U2lkZUxlbmd0aCgpe3JldHVybiByZS5sb25nZXN0U2lkZUxlbmd0aCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9aXNBY3V0ZSgpe3JldHVybiByZS5pc0FjdXRlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1jaXJjdW1jZW50cmUoKXtyZXR1cm4gcmUuY2lyY3VtY2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1hcmVhM0QoKXtyZXR1cm4gcmUuYXJlYTNEKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1jZW50cm9pZCgpe3JldHVybiByZS5jZW50cm9pZCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9aW5DZW50cmUoKXtyZXR1cm4gcmUuaW5DZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWdldENsYXNzKCl7cmV0dXJuIHJlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1yZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLHRoaXMucDI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLnAwPXQsdGhpcy5wMT1lLHRoaXMucDI9bn07Y2xhc3Mgb2UgZXh0ZW5kcyBDe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIG9lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1vZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClDLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19O2NsYXNzIGxle2NvbnN0cnVjdG9yKCl7bGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdHJhbnNsYXRpb25JbnN0YW5jZSh0LGUpe2NvbnN0IG49bmV3IGxlO3JldHVybiBuLnNldFRvVHJhbnNsYXRpb24odCxlKSxufXN0YXRpYyBzaGVhckluc3RhbmNlKHQsZSl7Y29uc3Qgbj1uZXcgbGU7cmV0dXJuIG4uc2V0VG9TaGVhcih0LGUpLG59c3RhdGljIHJlZmxlY3Rpb25JbnN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBsZTtyZXR1cm4gbi5zZXRUb1JlZmxlY3Rpb24odCxlKSxufWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBsZTtyZXR1cm4gaS5zZXRUb1JlZmxlY3Rpb24odCxlLG4scyksaX19c3RhdGljIHJvdGF0aW9uSW5zdGFuY2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGxlLnJvdGF0aW9uSW5zdGFuY2UoTWF0aC5zaW4odCksTWF0aC5jb3ModCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBsZTtyZXR1cm4gbi5zZXRUb1JvdGF0aW9uKHQsZSksbn1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIGxlLnJvdGF0aW9uSW5zdGFuY2UoTWF0aC5zaW4odCksTWF0aC5jb3ModCksZSxuKX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgbGU7cmV0dXJuIGkuc2V0VG9Sb3RhdGlvbih0LGUsbixzKSxpfX1zdGF0aWMgc2NhbGVJbnN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBsZTtyZXR1cm4gbi5zZXRUb1NjYWxlKHQsZSksbn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgbGU7cmV0dXJuIGkudHJhbnNsYXRlKC1uLC1zKSxpLnNjYWxlKHQsZSksaS50cmFuc2xhdGUobixzKSxpfX1zZXRUb1JlZmxlY3Rpb25CYXNpYyh0LGUscyxpKXtpZih0PT09cyYmZT09PWkpdGhyb3cgbmV3IG4oXCJSZWZsZWN0aW9uIGxpbmUgcG9pbnRzIG11c3QgYmUgZGlzdGluY3RcIik7Y29uc3Qgcj1zLXQsbz1pLWUsbD1NYXRoLnNxcnQocipyK28qbyksYT1vL2wsYz1yL2wsaD0yKmEqYyx1PWMqYy1hKmE7cmV0dXJuIHRoaXMuX20wMD11LHRoaXMuX20wMT1oLHRoaXMuX20wMj0wLHRoaXMuX20xMD1oLHRoaXMuX20xMT0tdSx0aGlzLl9tMTI9MCx0aGlzfWdldEludmVyc2UoKXtjb25zdCB0PXRoaXMuZ2V0RGV0ZXJtaW5hbnQoKTtpZigwPT09dCl0aHJvdyBuZXcgb2UoXCJUcmFuc2Zvcm1hdGlvbiBpcyBub24taW52ZXJ0aWJsZVwiKTtjb25zdCBlPXRoaXMuX20xMS90LG49LXRoaXMuX20xMC90LHM9LXRoaXMuX20wMS90LGk9dGhpcy5fbTAwL3Qscj0odGhpcy5fbTAxKnRoaXMuX20xMi10aGlzLl9tMDIqdGhpcy5fbTExKS90LG89KC10aGlzLl9tMDAqdGhpcy5fbTEyK3RoaXMuX20xMCp0aGlzLl9tMDIpL3Q7cmV0dXJuIG5ldyBsZShlLHMscixuLGksbyl9Y29tcG9zZSh0KXtjb25zdCBlPXQuX20wMCp0aGlzLl9tMDArdC5fbTAxKnRoaXMuX20xMCxuPXQuX20wMCp0aGlzLl9tMDErdC5fbTAxKnRoaXMuX20xMSxzPXQuX20wMCp0aGlzLl9tMDIrdC5fbTAxKnRoaXMuX20xMit0Ll9tMDIsaT10Ll9tMTAqdGhpcy5fbTAwK3QuX20xMSp0aGlzLl9tMTAscj10Ll9tMTAqdGhpcy5fbTAxK3QuX20xMSp0aGlzLl9tMTEsbz10Ll9tMTAqdGhpcy5fbTAyK3QuX20xMSp0aGlzLl9tMTIrdC5fbTEyO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9bix0aGlzLl9tMDI9cyx0aGlzLl9tMTA9aSx0aGlzLl9tMTE9cix0aGlzLl9tMTI9byx0aGlzfWVxdWFscyh0KXtpZihudWxsPT09dClyZXR1cm4hMTtpZighKHQgaW5zdGFuY2VvZiBsZSkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLl9tMDA9PT1lLl9tMDAmJnRoaXMuX20wMT09PWUuX20wMSYmdGhpcy5fbTAyPT09ZS5fbTAyJiZ0aGlzLl9tMTA9PT1lLl9tMTAmJnRoaXMuX20xMT09PWUuX20xMSYmdGhpcy5fbTEyPT09ZS5fbTEyfXNldFRvU2NhbGUodCxlKXtyZXR1cm4gdGhpcy5fbTAwPXQsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPTAsdGhpcy5fbTExPWUsdGhpcy5fbTEyPTAsdGhpc31pc0lkZW50aXR5KCl7cmV0dXJuIDE9PT10aGlzLl9tMDAmJjA9PT10aGlzLl9tMDEmJjA9PT10aGlzLl9tMDImJjA9PT10aGlzLl9tMTAmJjE9PT10aGlzLl9tMTEmJjA9PT10aGlzLl9tMTJ9c2NhbGUodCxlKXtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnNjYWxlSW5zdGFuY2UodCxlKSksdGhpc31zZXRUb0lkZW50aXR5KCl7cmV0dXJuIHRoaXMuX20wMD0xLHRoaXMuX20wMT0wLHRoaXMuX20wMj0wLHRoaXMuX20xMD0wLHRoaXMuX20xMT0xLHRoaXMuX20xMj0wLHRoaXN9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMH1zZXRUcmFuc2Zvcm1hdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbTAwPXQuX20wMCx0aGlzLl9tMDE9dC5fbTAxLHRoaXMuX20wMj10Ll9tMDIsdGhpcy5fbTEwPXQuX20xMCx0aGlzLl9tMTE9dC5fbTExLHRoaXMuX20xMj10Ll9tMTIsdGhpc31pZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07cmV0dXJuIHRoaXMuX20wMD10LHRoaXMuX20wMT1lLHRoaXMuX20wMj1uLHRoaXMuX20xMD1zLHRoaXMuX20xMT1pLHRoaXMuX20xMj1yLHRoaXN9fXNldFRvUm90YXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2V0VG9Sb3RhdGlvbihNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSksdGhpc31pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT0tdCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9dCx0aGlzLl9tMTE9ZSx0aGlzLl9tMTI9MCx0aGlzfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdGhpcy5zZXRUb1JvdGF0aW9uKE1hdGguc2luKHQpLE1hdGguY29zKHQpLGUsbiksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT0tdCx0aGlzLl9tMDI9bi1uKmUrcyp0LHRoaXMuX20xMD10LHRoaXMuX20xMT1lLHRoaXMuX20xMj1zLW4qdC1zKmUsdGhpc319Z2V0TWF0cml4RW50cmllcygpe3JldHVyblt0aGlzLl9tMDAsdGhpcy5fbTAxLHRoaXMuX20wMix0aGlzLl9tMTAsdGhpcy5fbTExLHRoaXMuX20xMl19ZmlsdGVyKHQsZSl7dGhpcy50cmFuc2Zvcm0odCxlKX1yb3RhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY29tcG9zZShsZS5yb3RhdGlvbkluc3RhbmNlKHQpKSx0aGlzfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnJvdGF0aW9uSW5zdGFuY2UodCxlKSksdGhpc31pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHRoaXMuY29tcG9zZShsZS5yb3RhdGlvbkluc3RhbmNlKHQsZSxuKSksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcG9zZShsZS5yb3RhdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9fWdldERldGVybWluYW50KCl7cmV0dXJuIHRoaXMuX20wMCp0aGlzLl9tMTEtdGhpcy5fbTAxKnRoaXMuX20xMH1jb21wb3NlQmVmb3JlKHQpe2NvbnN0IGU9dGhpcy5fbTAwKnQuX20wMCt0aGlzLl9tMDEqdC5fbTEwLG49dGhpcy5fbTAwKnQuX20wMSt0aGlzLl9tMDEqdC5fbTExLHM9dGhpcy5fbTAwKnQuX20wMit0aGlzLl9tMDEqdC5fbTEyK3RoaXMuX20wMixpPXRoaXMuX20xMCp0Ll9tMDArdGhpcy5fbTExKnQuX20xMCxyPXRoaXMuX20xMCp0Ll9tMDErdGhpcy5fbTExKnQuX20xMSxvPXRoaXMuX20xMCp0Ll9tMDIrdGhpcy5fbTExKnQuX20xMit0aGlzLl9tMTI7cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT1uLHRoaXMuX20wMj1zLHRoaXMuX20xMD1pLHRoaXMuX20xMT1yLHRoaXMuX20xMj1vLHRoaXN9c2V0VG9TaGVhcih0LGUpe3JldHVybiB0aGlzLl9tMDA9MSx0aGlzLl9tMDE9dCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9ZSx0aGlzLl9tMTE9MSx0aGlzLl9tMTI9MCx0aGlzfWlzRG9uZSgpe3JldHVybiExfWNsb25lKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIEMpKXRocm93IHQ7dS5zaG91bGROZXZlclJlYWNoSGVyZSgpfXJldHVybiBudWxsfXRyYW5zbGF0ZSh0LGUpe3JldHVybiB0aGlzLmNvbXBvc2UobGUudHJhbnNsYXRpb25JbnN0YW5jZSh0LGUpKSx0aGlzfXNldFRvUmVmbGVjdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dCYmMD09PWUpdGhyb3cgbmV3IG4oXCJSZWZsZWN0aW9uIHZlY3RvciBtdXN0IGJlIG5vbi16ZXJvXCIpO2lmKHQ9PT1lKXJldHVybiB0aGlzLl9tMDA9MCx0aGlzLl9tMDE9MSx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9MSx0aGlzLl9tMTE9MCx0aGlzLl9tMTI9MCx0aGlzO2NvbnN0IHM9TWF0aC5zcXJ0KHQqdCtlKmUpLGk9ZS9zLHI9dC9zO3JldHVybiB0aGlzLnJvdGF0ZSgtaSxyKSx0aGlzLnNjYWxlKDEsLTEpLHRoaXMucm90YXRlKGksciksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107aWYodD09PXMmJmU9PT1pKXRocm93IG5ldyBuKFwiUmVmbGVjdGlvbiBsaW5lIHBvaW50cyBtdXN0IGJlIGRpc3RpbmN0XCIpO3RoaXMuc2V0VG9UcmFuc2xhdGlvbigtdCwtZSk7Y29uc3Qgcj1zLXQsbz1pLWUsbD1NYXRoLnNxcnQocipyK28qbyksYT1vL2wsYz1yL2w7cmV0dXJuIHRoaXMucm90YXRlKC1hLGMpLHRoaXMuc2NhbGUoMSwtMSksdGhpcy5yb3RhdGUoYSxjKSx0aGlzLnRyYW5zbGF0ZSh0LGUpLHRoaXN9fXRvU3RyaW5nKCl7cmV0dXJuXCJBZmZpbmVUcmFuc2Zvcm1hdGlvbltbXCIrdGhpcy5fbTAwK1wiLCBcIit0aGlzLl9tMDErXCIsIFwiK3RoaXMuX20wMitcIl0sIFtcIit0aGlzLl9tMTArXCIsIFwiK3RoaXMuX20xMStcIiwgXCIrdGhpcy5fbTEyK1wiXV1cIn1zZXRUb1RyYW5zbGF0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX20wMD0xLHRoaXMuX20wMT0wLHRoaXMuX20wMj10LHRoaXMuX20xMD0wLHRoaXMuX20xMT0xLHRoaXMuX20xMj1lLHRoaXN9c2hlYXIodCxlKXtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnNoZWFySW5zdGFuY2UodCxlKSksdGhpc310cmFuc2Zvcm0oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0uY29weSgpO3JldHVybiB0LmFwcGx5KHRoaXMpLHR9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX20wMCp0LngrdGhpcy5fbTAxKnQueSt0aGlzLl9tMDIscz10aGlzLl9tMTAqdC54K3RoaXMuX20xMSp0LnkrdGhpcy5fbTEyO3JldHVybiBlLng9bixlLnk9cyxlfWlmKF8oYXJndW1lbnRzWzBdLEEpJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fbTAwKnQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLl9tMDEqdC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMuX20wMixzPXRoaXMuX20xMCp0LmdldE9yZGluYXRlKGUsMCkrdGhpcy5fbTExKnQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLl9tMTI7dC5zZXRPcmRpbmF0ZShlLDAsbiksdC5zZXRPcmRpbmF0ZShlLDEscyl9fX1yZWZsZWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXBvc2UobGUucmVmbGVjdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiB0aGlzLmNvbXBvc2UobGUucmVmbGVjdGlvbkluc3RhbmNlKHQsZSxuLHMpKSx0aGlzfX1nZXRDbGFzcygpe3JldHVybiBsZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbyxkdF19fWxlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX20wMD1udWxsLHRoaXMuX20wMT1udWxsLHRoaXMuX20wMj1udWxsLHRoaXMuX20xMD1udWxsLHRoaXMuX20xMT1udWxsLHRoaXMuX20xMj1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuc2V0VG9JZGVudGl0eSgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX20wMD10WzBdLHRoaXMuX20wMT10WzFdLHRoaXMuX20wMj10WzJdLHRoaXMuX20xMD10WzNdLHRoaXMuX20xMT10WzRdLHRoaXMuX20xMj10WzVdfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBsZSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRUcmFuc2Zvcm1hdGlvbih0KX19ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1s1XSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1s0XSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1szXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07dGhpcy5zZXRUcmFuc2Zvcm1hdGlvbih0LGUsbixzLGkscil9fTtjbGFzcyBhZXtjb25zdHJ1Y3Rvcigpe2FlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNvbHZlKHQsZSl7Y29uc3Qgcz1lLmxlbmd0aDtpZih0Lmxlbmd0aCE9PXN8fHRbMF0ubGVuZ3RoIT09cyl0aHJvdyBuZXcgbihcIk1hdHJpeCBBIGlzIGluY29ycmVjdGx5IHNpemVkXCIpO2ZvcihsZXQgbj0wO248cztuKyspe2xldCBpPW47Zm9yKGxldCBlPW4rMTtlPHM7ZSsrKU1hdGguYWJzKHRbZV1bbl0pPk1hdGguYWJzKHRbaV1bbl0pJiYoaT1lKTtpZigwPT09dFtpXVtuXSlyZXR1cm4gbnVsbDthZS5zd2FwUm93cyh0LG4saSksYWUuc3dhcFJvd3MoZSxuLGkpO2ZvcihsZXQgaT1uKzE7aTxzO2krKyl7Y29uc3Qgcj10W2ldW25dL3Rbbl1bbl07Zm9yKGxldCBlPXMtMTtlPj1uO2UtLSl0W2ldW2VdLT10W25dW2VdKnI7ZVtpXS09ZVtuXSpyfX1jb25zdCBpPW5ldyBBcnJheShzKS5maWxsKG51bGwpO2ZvcihsZXQgbj1zLTE7bj49MDtuLS0pe2xldCByPTA7Zm9yKGxldCBlPW4rMTtlPHM7ZSsrKXIrPXRbbl1bZV0qaVtlXTtpW25dPShlW25dLXIpL3Rbbl1bbl19cmV0dXJuIGl9c3RhdGljIHN3YXBSb3dzKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKGU9PT1uKXJldHVybiBudWxsO2ZvcihsZXQgcz0wO3M8dFswXS5sZW5ndGg7cysrKXtjb25zdCBpPXRbZV1bc107dFtlXVtzXT10W25dW3NdLHRbbl1bc109aX19ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZT09PW4pcmV0dXJuIG51bGw7Y29uc3Qgcz10W2VdO3RbZV09dFtuXSx0W25dPXN9fWdldENsYXNzKCl7cmV0dXJuIGFlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1hZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGNle2NvbnN0cnVjdG9yKCl7Y2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zb2x2ZSh0KXtjb25zdCBlPVtbdGhpcy5fc3JjMC54LHRoaXMuX3NyYzAueSwxXSxbdGhpcy5fc3JjMS54LHRoaXMuX3NyYzEueSwxXSxbdGhpcy5fc3JjMi54LHRoaXMuX3NyYzIueSwxXV07cmV0dXJuIGFlLnNvbHZlKGUsdCl9Y29tcHV0ZSgpe2NvbnN0IHQ9W3RoaXMuX2Rlc3QwLngsdGhpcy5fZGVzdDEueCx0aGlzLl9kZXN0Mi54XSxlPXRoaXMuc29sdmUodCk7aWYobnVsbD09PWUpcmV0dXJuITE7dGhpcy5fbTAwPWVbMF0sdGhpcy5fbTAxPWVbMV0sdGhpcy5fbTAyPWVbMl07Y29uc3Qgbj1bdGhpcy5fZGVzdDAueSx0aGlzLl9kZXN0MS55LHRoaXMuX2Rlc3QyLnldLHM9dGhpcy5zb2x2ZShuKTtyZXR1cm4gbnVsbCE9PXMmJih0aGlzLl9tMTA9c1swXSx0aGlzLl9tMTE9c1sxXSx0aGlzLl9tMTI9c1syXSwhMCl9Z2V0VHJhbnNmb3JtYXRpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCk/bmV3IGxlKHRoaXMuX20wMCx0aGlzLl9tMDEsdGhpcy5fbTAyLHRoaXMuX20xMCx0aGlzLl9tMTEsdGhpcy5fbTEyKTpudWxsfWdldENsYXNzKCl7cmV0dXJuIGNlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zcmMwPW51bGwsdGhpcy5fc3JjMT1udWxsLHRoaXMuX3NyYzI9bnVsbCx0aGlzLl9kZXN0MD1udWxsLHRoaXMuX2Rlc3QxPW51bGwsdGhpcy5fZGVzdDI9bnVsbCx0aGlzLl9tMDA9bnVsbCx0aGlzLl9tMDE9bnVsbCx0aGlzLl9tMDI9bnVsbCx0aGlzLl9tMTA9bnVsbCx0aGlzLl9tMTE9bnVsbCx0aGlzLl9tMTI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTt0aGlzLl9zcmMwPXQsdGhpcy5fc3JjMT1lLHRoaXMuX3NyYzI9bix0aGlzLl9kZXN0MD1zLHRoaXMuX2Rlc3QxPWksdGhpcy5fZGVzdDI9cn07Y2xhc3MgaGV7Y29uc3RydWN0b3IoKXtoZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjcmVhdGVGcm9tQmFzZUxpbmVzKHQsZSxuLHMpe2NvbnN0IGk9bmV3IGcodC54K3MueC1uLngsdC55K3MueS1uLnkpLHI9aWUuYW5nbGVCZXR3ZWVuT3JpZW50ZWQoZSx0LGkpLG89ZS5kaXN0YW5jZSh0KSxsPXMuZGlzdGFuY2Uobik7aWYoMD09PW8pcmV0dXJuIG5ldyBsZTtjb25zdCBhPWwvbyxjPWxlLnRyYW5zbGF0aW9uSW5zdGFuY2UoLXQueCwtdC55KTtyZXR1cm4gYy5yb3RhdGUociksYy5zY2FsZShhLGEpLGMudHJhbnNsYXRlKG4ueCxuLnkpLGN9c3RhdGljIGNyZWF0ZUZyb21Db250cm9sVmVjdG9ycygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1lLngtdC54LHM9ZS55LXQueTtyZXR1cm4gbGUudHJhbnNsYXRpb25JbnN0YW5jZShuLHMpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IG4oXCJTcmMgYW5kIERlc3QgYXJyYXlzIGFyZSBub3QgdGhlIHNhbWUgbGVuZ3RoXCIpO2lmKHQubGVuZ3RoPD0wKXRocm93IG5ldyBuKFwiVG9vIGZldyBjb250cm9sIHBvaW50c1wiKTtpZih0Lmxlbmd0aD4zKXRocm93IG5ldyBuKFwiVG9vIG1hbnkgY29udHJvbCBwb2ludHNcIik7cmV0dXJuIDE9PT10Lmxlbmd0aD9oZS5jcmVhdGVGcm9tQ29udHJvbFZlY3RvcnModFswXSxlWzBdKToyPT09dC5sZW5ndGg/aGUuY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKHRbMF0sdFsxXSxlWzBdLGVbMV0pOmhlLmNyZWF0ZUZyb21Db250cm9sVmVjdG9ycyh0WzBdLHRbMV0sdFsyXSxlWzBdLGVbMV0sZVsyXSl9fWVsc2V7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGcocy54LW4ueCxzLnktbi55KSxyPWllLmFuZ2xlQmV0d2Vlbk9yaWVudGVkKGUsdCxpKSxvPWUuZGlzdGFuY2UodCksbD1zLmRpc3RhbmNlKG4pO2lmKDA9PT1vKXJldHVybiBudWxsO2NvbnN0IGE9bC9vLGM9bGUudHJhbnNsYXRpb25JbnN0YW5jZSgtdC54LC10LnkpO3JldHVybiBjLnJvdGF0ZShyKSxjLnNjYWxlKGEsYSksYy50cmFuc2xhdGUobi54LG4ueSksY31pZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07cmV0dXJuIG5ldyBjZSh0LGUsbixzLGkscikuZ2V0VHJhbnNmb3JtYXRpb24oKX19fWdldENsYXNzKCl7cmV0dXJuIGhlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1oZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHVle2NvbnN0cnVjdG9yKCl7dWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgeDtyZXR1cm4gdC5hcHBseShuZXcgdWUoZSkpLGV9ZmlsdGVyKHQpeyh0IGluc3RhbmNlb2YgVHR8fHQgaW5zdGFuY2VvZiBQdCkmJnRoaXMuX2Nvb3Jkcy5hZGQodC5nZXRDb29yZGluYXRlKCkpfWdldENsYXNzKCl7cmV0dXJuIHVlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX19dWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29vcmRzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29vcmRzPXR9O2NsYXNzIGdle2NvbnN0cnVjdG9yKCl7Z2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbWFwKHQsZSl7cmV0dXJuIG5ldyBnZShlKS5tYXAodCl9bWFwKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dGhpcy5fbWFwT3AubWFwKHQuZ2V0R2VvbWV0cnlOKG4pKTtzLmlzRW1wdHkoKXx8ZS5hZGQocyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihIdC50b0dlb21ldHJ5QXJyYXkoZSkpfWdldENsYXNzKCl7cmV0dXJuIGdlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1nZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9tYXBPcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21hcE9wPXR9O2NsYXNzIGRle2NvbnN0cnVjdG9yKCl7ZGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tYmluZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IGRlKHQpLmNvbWJpbmUoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBkZShkZS5jcmVhdGVMaXN0KHQsZSkpLmNvbWJpbmUoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG5ldyBkZShkZS5jcmVhdGVMaXN0KHQsZSxuKSkuY29tYmluZSgpfX1zdGF0aWMgZXh0cmFjdEZhY3RvcnkodCl7cmV0dXJuIHQuaXNFbXB0eSgpP251bGw6dC5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCl9c3RhdGljIGNyZWF0ZUxpc3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgeDtyZXR1cm4gbi5hZGQodCksbi5hZGQoZSksbn1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgeDtyZXR1cm4gcy5hZGQodCkscy5hZGQoZSkscy5hZGQobiksc319ZXh0cmFjdEVsZW1lbnRzKHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7dGhpcy5fc2tpcEVtcHR5JiZzLmlzRW1wdHkoKXx8ZS5hZGQocyl9fWNvbWJpbmUoKXtjb25zdCB0PW5ldyB4O2ZvcihsZXQgZT10aGlzLl9pbnB1dEdlb21zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuZXh0cmFjdEVsZW1lbnRzKG4sdCl9cmV0dXJuIDA9PT10LnNpemUoKT9udWxsIT09dGhpcy5fZ2VvbUZhY3Rvcnk/dGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6bnVsbDp0aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHQpfWdldENsYXNzKCl7cmV0dXJuIGRlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1kZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tRmFjdG9yeT1udWxsLHRoaXMuX3NraXBFbXB0eT0hMSx0aGlzLl9pbnB1dEdlb21zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Rvcnk9ZGUuZXh0cmFjdEZhY3RvcnkodCksdGhpcy5faW5wdXRHZW9tcz10fTtjbGFzcyBfZXtjb25zdHJ1Y3Rvcigpe19lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzT2ZUeXBlKHQsZSl7cmV0dXJuIHQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1lfHxlPT09cS5UWVBFTkFNRV9MSU5FU1RSSU5HJiZ0LmdldEdlb21ldHJ5VHlwZSgpPT09cS5UWVBFTkFNRV9MSU5FQVJSSU5HfXN0YXRpYyBleHRyYWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBfZS5leHRyYWN0KHQsZSxuZXcgeCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzJdLG0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJlwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0LmdldEdlb21ldHJ5VHlwZSgpPT09ZT9uLmFkZCh0KTp0IGluc3RhbmNlb2YgX3QmJnQuYXBwbHkobmV3IF9lKGUsbikpLG59aWYoXyhhcmd1bWVudHNbMl0sbSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBDbGFzcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIF9lLmV4dHJhY3QodCxfZS50b0dlb21ldHJ5VHlwZShlKSxuKX19fWZpbHRlcih0KXsobnVsbD09PXRoaXMuX2dlb21ldHJ5VHlwZXx8X2UuaXNPZlR5cGUodCx0aGlzLl9nZW9tZXRyeVR5cGUpKSYmdGhpcy5fY29tcHMuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIF9lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltndF19fV9lLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb21ldHJ5VHlwZT1udWxsLHRoaXMuX2NvbXBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbWV0cnlUeXBlPXQsdGhpcy5fY29tcHM9ZX07Y2xhc3MgZmV7Y29uc3RydWN0b3IoKXtmZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfW1hcCh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gZmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgcGV7Y29uc3RydWN0b3IoKXtwZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtYXAoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJl8oYXJndW1lbnRzWzFdLGZlKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgeDtmb3IobGV0IHM9MDtzPHQuZ2V0TnVtR2VvbWV0cmllcygpO3MrKyl7Y29uc3QgaT1lLm1hcCh0LmdldEdlb21ldHJ5TihzKSk7bnVsbCE9PWkmJm4uYWRkKGkpfXJldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KG4pfWlmKF8oYXJndW1lbnRzWzBdLGYpJiZfKGFyZ3VtZW50c1sxXSxmZSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IHg7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCksaT1lLm1hcCh0KTtudWxsIT09aSYmbi5hZGQoaSl9cmV0dXJuIG59fWdldENsYXNzKCl7cmV0dXJuIHBlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1wZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIG1le2NvbnN0cnVjdG9yKCl7bWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX10cmFuc2Zvcm1Qb2ludCh0LGUpe3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9dHJhbnNmb3JtUG9seWdvbih0LGUpe2xldCBuPSEwO2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksdCk7bnVsbCE9PXMmJnMgaW5zdGFuY2VvZiBEdCYmIXMuaXNFbXB0eSgpfHwobj0hMSk7Y29uc3QgaT1uZXcgeDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEludGVyaW9yUmluZ04oZSksdCk7bnVsbD09PXN8fHMuaXNFbXB0eSgpfHwocyBpbnN0YW5jZW9mIER0fHwobj0hMSksaS5hZGQocykpfWlmKG4pcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbihzLGkudG9BcnJheShbXSkpO3tjb25zdCB0PW5ldyB4O3JldHVybiBudWxsIT09cyYmdC5hZGQocyksdC5hZGRBbGwoaSksdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHQpfX1jcmVhdGVDb29yZGluYXRlU2VxdWVuY2UodCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KX1nZXRJbnB1dEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2lucHV0R2VvbX10cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcodCxlKXtjb25zdCBuPW5ldyB4O2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtTGluZVN0cmluZyh0LmdldEdlb21ldHJ5TihlKSx0KTtudWxsIT09cyYmKHMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe3JldHVybiB0aGlzLmNvcHkodCl9dHJhbnNmb3JtTGluZVN0cmluZyh0LGUpe3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX10cmFuc2Zvcm1NdWx0aVBvaW50KHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybVBvaW50KHQuZ2V0R2VvbWV0cnlOKGUpLHQpO251bGwhPT1zJiYocy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQuZ2V0R2VvbWV0cnlOKGUpLHQpO251bGwhPT1zJiYocy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfWNvcHkodCl7cmV0dXJuIHQuY29weSgpfXRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbih0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm0odC5nZXRHZW9tZXRyeU4oZSkpO251bGwhPT1zJiYodGhpcy5fcHJ1bmVFbXB0eUdlb21ldHJ5JiZzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU/dGhpcy5fZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oSHQudG9HZW9tZXRyeUFycmF5KG4pKTp0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9dHJhbnNmb3JtKHQpe2lmKHRoaXMuX2lucHV0R2VvbT10LHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksdCBpbnN0YW5jZW9mIFB0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIE10KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgRHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBUdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGZ0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpTGluZVN0cmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBidClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIEF0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9seWdvbih0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBfdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24odCxudWxsKTt0aHJvdyBuZXcgbihcIlVua25vd24gR2VvbWV0cnkgc3VidHlwZTogXCIrdC5nZXRDbGFzcygpLmdldE5hbWUoKSl9dHJhbnNmb3JtTGluZWFyUmluZyh0LGUpe2NvbnN0IG49dGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpO2lmKG51bGw9PT1uKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobnVsbCk7Y29uc3Qgcz1uLnNpemUoKTtyZXR1cm4gcz4wJiZzPDQmJiF0aGlzLl9wcmVzZXJ2ZVR5cGU/dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKG4pOnRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhuKX1nZXRDbGFzcygpe3JldHVybiBtZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX3BydW5lRW1wdHlHZW9tZXRyeT0hMCx0aGlzLl9wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU9ITAsdGhpcy5fcHJlc2VydmVDb2xsZWN0aW9ucz0hMSx0aGlzLl9wcmVzZXJ2ZVR5cGU9ITF9O2NsYXNzIHlle2NvbnN0cnVjdG9yKCl7eWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0R2VvbWV0cnkodCl7cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoeWUuZ2V0TGluZXModCkpfXN0YXRpYyBnZXRMaW5lcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4geWUuZ2V0TGluZXModCxuZXcgeCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgVHQ/ZS5hZGQodCk6dCBpbnN0YW5jZW9mIF90JiZ0LmFwcGx5KG5ldyB5ZShlKSksZX19ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBUdCYmdGhpcy5fY29tcHMuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIHllfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltndF19fXllLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2NvbXBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29tcHM9dH07Y2xhc3MgeGV7Y29uc3RydWN0b3IoKXt4ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRHZW9tZXRyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh4ZS5nZXRMaW5lcyh0KSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHhlLmdldExpbmVzKHQsZSkpfX1zdGF0aWMgZ2V0TGluZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHhlLmdldExpbmVzKHQsITEpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1swXSxmKSYmXyhhcmd1bWVudHNbMV0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3hlLmdldExpbmVzKHQsZSl9cmV0dXJuIGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgeDtyZXR1cm4gdC5hcHBseShuZXcgeGUobixlKSksbn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJl8oYXJndW1lbnRzWzFdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIFR0P2UuYWRkKHQpOnQuYXBwbHkobmV3IHhlKGUpKSxlfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXyhhcmd1bWVudHNbMF0sZikmJl8oYXJndW1lbnRzWzFdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt4ZS5nZXRMaW5lcyh0LGUsbil9cmV0dXJuIGV9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXyhhcmd1bWVudHNbMV0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0LmFwcGx5KG5ldyB4ZShlLG4pKSxlfX19ZmlsdGVyKHQpe2lmKHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nJiZ0IGluc3RhbmNlb2YgRHQpe2NvbnN0IGU9dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtyZXR1cm4gdGhpcy5fbGluZXMuYWRkKGUpLG51bGx9dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLl9saW5lcy5hZGQodCl9c2V0Rm9yY2VUb0xpbmVTdHJpbmcodCl7dGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmc9dH1nZXRDbGFzcygpe3JldHVybiB4ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR119fXhlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2xpbmVzPW51bGwsdGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmc9ITEsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVzPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbGluZXM9dCx0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz1lfX07Y29uc3QgRWU9e3JldmVyc2VPcmRlcjpmdW5jdGlvbigpe3JldHVybntjb21wYXJlOih0LGUpPT5lLmNvbXBhcmVUbyh0KX19LG1pbjpmdW5jdGlvbih0KXtyZXR1cm4gRWUuc29ydCh0KSx0LmdldCgwKX0sc29ydDpmdW5jdGlvbih0LGUpe2NvbnN0IG49dC50b0FycmF5KCk7ZT9odC5zb3J0KG4sZSk6aHQuc29ydChuKTtjb25zdCBzPXQuaXRlcmF0b3IoKTtmb3IobGV0IHQ9MCxlPW4ubGVuZ3RoO3Q8ZTt0Kyspcy5uZXh0KCkscy5zZXQoblt0XSl9LHNpbmdsZXRvbkxpc3Q6ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgeDtyZXR1cm4gZS5hZGQodCksZX19O2NsYXNzIElle2NvbnN0cnVjdG9yKCl7SWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0UG9pbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0IGluc3RhbmNlb2YgUHQ/RWUuc2luZ2xldG9uTGlzdCh0KTpJZS5nZXRQb2ludHModCxuZXcgeCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgUHQ/ZS5hZGQodCk6dCBpbnN0YW5jZW9mIF90JiZ0LmFwcGx5KG5ldyBJZShlKSksZX19ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBQdCYmdGhpcy5fcHRzLmFkZCh0KX1nZXRDbGFzcygpe3JldHVybiBJZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ3RdfX1JZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dH07Y2xhc3MgTmV7Y29uc3RydWN0b3IoKXtOZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRQb2x5Z29ucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTmUuZ2V0UG9seWdvbnModCxuZXcgeCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgYnQ/ZS5hZGQodCk6dCBpbnN0YW5jZW9mIF90JiZ0LmFwcGx5KG5ldyBOZShlKSksZX19ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBidCYmdGhpcy5fY29tcHMuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIE5lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltndF19fU5lLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2NvbXBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29tcHM9dH07Y2xhc3MgQ2V7Y29uc3RydWN0b3IoKXtDZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFwcGx5VG8odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKSYmIXRoaXMuX2lzRG9uZTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYobiBpbnN0YW5jZW9mIF90KXRoaXMuYXBwbHlUbyhuKTtlbHNlIGlmKHRoaXMudmlzaXQobiksdGhpcy5pc0RvbmUoKSlyZXR1cm4gdGhpcy5faXNEb25lPSEwLG51bGx9fWdldENsYXNzKCl7cmV0dXJuIENlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1DZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc0RvbmU9ITF9O2NsYXNzIFNle2NvbnN0cnVjdG9yKCl7U2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVTdXBlcmNpcmNsZSh0KXtjb25zdCBlPTEvdCxuPXRoaXMuX2RpbS5nZXRNaW5TaXplKCkvMixzPXRoaXMuX2RpbS5nZXRDZW50cmUoKSxpPU1hdGgucG93KG4sdCkscj1uLG89TWF0aC5wb3coaS8yLGUpLGw9TWF0aC50cnVuYyh0aGlzLl9uUHRzLzgpLGE9bmV3IEFycmF5KDgqbCsxKS5maWxsKG51bGwpLGM9by9sO2ZvcihsZXQgbj0wO248PWw7bisrKXtsZXQgbz0wLGg9cjtpZigwIT09bil7bz1jKm47Y29uc3Qgcz1NYXRoLnBvdyhvLHQpO2g9TWF0aC5wb3coaS1zLGUpfWFbbl09dGhpcy5jb29yZFRyYW5zKG8saCxzKSxhWzIqbC1uXT10aGlzLmNvb3JkVHJhbnMoaCxvLHMpLGFbMipsK25dPXRoaXMuY29vcmRUcmFucyhoLC1vLHMpLGFbNCpsLW5dPXRoaXMuY29vcmRUcmFucyhvLC1oLHMpLGFbNCpsK25dPXRoaXMuY29vcmRUcmFucygtbywtaCxzKSxhWzYqbC1uXT10aGlzLmNvb3JkVHJhbnMoLWgsLW8scyksYVs2Kmwrbl09dGhpcy5jb29yZFRyYW5zKC1oLG8scyksYVs4Kmwtbl09dGhpcy5jb29yZFRyYW5zKC1vLGgscyl9YVthLmxlbmd0aC0xXT1uZXcgZyhhWzBdKTtjb25zdCBoPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcoYSksdT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGgpO3JldHVybiB0aGlzLnJvdGF0ZSh1KX1zZXROdW1Qb2ludHModCl7dGhpcy5fblB0cz10fXNldEJhc2UodCl7dGhpcy5fZGltLnNldEJhc2UodCl9c2V0Um90YXRpb24odCl7dGhpcy5fcm90YXRpb25BbmdsZT10fXNldFdpZHRoKHQpe3RoaXMuX2RpbS5zZXRXaWR0aCh0KX1jcmVhdGVFbGxpcHNlKCl7Y29uc3QgdD10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxlPXQuZ2V0V2lkdGgoKS8yLG49dC5nZXRIZWlnaHQoKS8yLHM9dC5nZXRNaW5YKCkrZSxpPXQuZ2V0TWluWSgpK24scj1uZXcgQXJyYXkodGhpcy5fblB0cysxKS5maWxsKG51bGwpO2xldCBvPTA7Zm9yKGxldCB0PTA7dDx0aGlzLl9uUHRzO3QrKyl7Y29uc3QgbD10KigyKk1hdGguUEkvdGhpcy5fblB0cyksYT1lKk1hdGguY29zKGwpK3MsYz1uKk1hdGguc2luKGwpK2k7cltvKytdPXRoaXMuY29vcmQoYSxjKX1yW29dPW5ldyBnKHJbMF0pO2NvbnN0IGw9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhyKSxhPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24obCk7cmV0dXJuIHRoaXMucm90YXRlKGEpfWNvb3JkVHJhbnModCxlLG4pe3JldHVybiB0aGlzLmNvb3JkKHQrbi54LGUrbi55KX1jcmVhdGVTcXVpcmNsZSgpe3JldHVybiB0aGlzLmNyZWF0ZVN1cGVyY2lyY2xlKDQpfXNldEVudmVsb3BlKHQpe3RoaXMuX2RpbS5zZXRFbnZlbG9wZSh0KX1zZXRDZW50cmUodCl7dGhpcy5fZGltLnNldENlbnRyZSh0KX1jcmVhdGVBcmModCxlKXtjb25zdCBuPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLHM9bi5nZXRXaWR0aCgpLzIsaT1uLmdldEhlaWdodCgpLzIscj1uLmdldE1pblgoKStzLG89bi5nZXRNaW5ZKCkraTtsZXQgbD1lOyhsPD0wfHxsPjIqTWF0aC5QSSkmJihsPTIqTWF0aC5QSSk7Y29uc3QgYT1sLyh0aGlzLl9uUHRzLTEpLGM9bmV3IEFycmF5KHRoaXMuX25QdHMpLmZpbGwobnVsbCk7bGV0IGg9MDtmb3IobGV0IGU9MDtlPHRoaXMuX25QdHM7ZSsrKXtjb25zdCBuPXQrZSphLGw9cypNYXRoLmNvcyhuKStyLHU9aSpNYXRoLnNpbihuKStvO2NbaCsrXT10aGlzLmNvb3JkKGwsdSl9Y29uc3QgdT10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lU3RyaW5nKGMpO3JldHVybiB0aGlzLnJvdGF0ZSh1KX1yb3RhdGUodCl7aWYoMCE9PXRoaXMuX3JvdGF0aW9uQW5nbGUpe2NvbnN0IGU9bGUucm90YXRpb25JbnN0YW5jZSh0aGlzLl9yb3RhdGlvbkFuZ2xlLHRoaXMuX2RpbS5nZXRDZW50cmUoKS54LHRoaXMuX2RpbS5nZXRDZW50cmUoKS55KTt0LmFwcGx5KGUpfXJldHVybiB0fWNvb3JkKHQsZSl7Y29uc3Qgbj1uZXcgZyh0LGUpO3JldHVybiB0aGlzLl9wcmVjTW9kZWwubWFrZVByZWNpc2Uobiksbn1jcmVhdGVBcmNQb2x5Z29uKHQsZSl7Y29uc3Qgbj10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxzPW4uZ2V0V2lkdGgoKS8yLGk9bi5nZXRIZWlnaHQoKS8yLHI9bi5nZXRNaW5YKCkrcyxvPW4uZ2V0TWluWSgpK2k7bGV0IGw9ZTsobDw9MHx8bD4yKk1hdGguUEkpJiYobD0yKk1hdGguUEkpO2NvbnN0IGE9bC8odGhpcy5fblB0cy0xKSxjPW5ldyBBcnJheSh0aGlzLl9uUHRzKzIpLmZpbGwobnVsbCk7bGV0IGg9MDtjW2grK109dGhpcy5jb29yZChyLG8pO2ZvcihsZXQgZT0wO2U8dGhpcy5fblB0cztlKyspe2NvbnN0IG49dCthKmUsbD1zKk1hdGguY29zKG4pK3IsdT1pKk1hdGguc2luKG4pK287Y1toKytdPXRoaXMuY29vcmQobCx1KX1jW2grK109dGhpcy5jb29yZChyLG8pO2NvbnN0IHU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhjKSxnPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24odSk7cmV0dXJuIHRoaXMucm90YXRlKGcpfWNyZWF0ZVJlY3RhbmdsZSgpe2xldCB0PW51bGwsZT0wLG49TWF0aC50cnVuYyh0aGlzLl9uUHRzLzQpO248MSYmKG49MSk7Y29uc3Qgcz10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKS5nZXRXaWR0aCgpL24saT10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKS5nZXRIZWlnaHQoKS9uLHI9bmV3IEFycmF5KDQqbisxKS5maWxsKG51bGwpLG89dGhpcy5fZGltLmdldEVudmVsb3BlKCk7Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWluWCgpK3QqcyxpPW8uZ2V0TWluWSgpO3JbZSsrXT10aGlzLmNvb3JkKG4saSl9Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWF4WCgpLHM9by5nZXRNaW5ZKCkrdCppO3JbZSsrXT10aGlzLmNvb3JkKG4scyl9Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWF4WCgpLXQqcyxpPW8uZ2V0TWF4WSgpO3JbZSsrXT10aGlzLmNvb3JkKG4saSl9Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWluWCgpLHM9by5nZXRNYXhZKCktdCppO3JbZSsrXT10aGlzLmNvb3JkKG4scyl9cltlKytdPW5ldyBnKHJbMF0pO2NvbnN0IGw9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhyKSxhPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24obCk7cmV0dXJuIHRoaXMucm90YXRlKGEpfWNyZWF0ZUNpcmNsZSgpe3JldHVybiB0aGlzLmNyZWF0ZUVsbGlwc2UoKX1zZXRIZWlnaHQodCl7dGhpcy5fZGltLnNldEhlaWdodCh0KX1zZXRTaXplKHQpe3RoaXMuX2RpbS5zZXRTaXplKHQpfWdldENsYXNzKCl7cmV0dXJuIFNlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyB3ZXtjb25zdHJ1Y3Rvcigpe3dlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0QmFzZSh0KXt0aGlzLmJhc2U9dH1zZXRXaWR0aCh0KXt0aGlzLndpZHRoPXR9Z2V0QmFzZSgpe3JldHVybiB0aGlzLmJhc2V9Z2V0V2lkdGgoKXtyZXR1cm4gdGhpcy53aWR0aH1zZXRFbnZlbG9wZSh0KXt0aGlzLndpZHRoPXQuZ2V0V2lkdGgoKSx0aGlzLmhlaWdodD10LmdldEhlaWdodCgpLHRoaXMuYmFzZT1uZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSksdGhpcy5jZW50cmU9bmV3IGcodC5jZW50cmUoKSl9c2V0Q2VudHJlKHQpe3RoaXMuY2VudHJlPXR9Z2V0TWluU2l6ZSgpe3JldHVybiBNYXRoLm1pbih0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KX1nZXRFbnZlbG9wZSgpe3JldHVybiBudWxsIT09dGhpcy5iYXNlP25ldyBOKHRoaXMuYmFzZS54LHRoaXMuYmFzZS54K3RoaXMud2lkdGgsdGhpcy5iYXNlLnksdGhpcy5iYXNlLnkrdGhpcy5oZWlnaHQpOm51bGwhPT10aGlzLmNlbnRyZT9uZXcgTih0aGlzLmNlbnRyZS54LXRoaXMud2lkdGgvMix0aGlzLmNlbnRyZS54K3RoaXMud2lkdGgvMix0aGlzLmNlbnRyZS55LXRoaXMuaGVpZ2h0LzIsdGhpcy5jZW50cmUueSt0aGlzLmhlaWdodC8yKTpuZXcgTigwLHRoaXMud2lkdGgsMCx0aGlzLmhlaWdodCl9Z2V0Q2VudHJlKCl7cmV0dXJuIG51bGw9PT10aGlzLmNlbnRyZSYmKHRoaXMuY2VudHJlPW5ldyBnKHRoaXMuYmFzZS54K3RoaXMud2lkdGgvMix0aGlzLmJhc2UueSt0aGlzLmhlaWdodC8yKSksdGhpcy5jZW50cmV9Z2V0SGVpZ2h0KCl7cmV0dXJuIHRoaXMuaGVpZ2h0fXNldEhlaWdodCh0KXt0aGlzLmhlaWdodD10fXNldFNpemUodCl7dGhpcy5oZWlnaHQ9dCx0aGlzLndpZHRoPXR9Z2V0Q2xhc3MoKXtyZXR1cm4gd2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXdlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuYmFzZT1udWxsLHRoaXMuY2VudHJlPW51bGwsdGhpcy53aWR0aD1udWxsLHRoaXMuaGVpZ2h0PW51bGx9LFNlLkRpbWVuc2lvbnM9d2UsU2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9wcmVjTW9kZWw9bnVsbCx0aGlzLl9kaW09bmV3IHdlLHRoaXMuX25QdHM9MTAwLHRoaXMuX3JvdGF0aW9uQW5nbGU9MCwwPT09YXJndW1lbnRzLmxlbmd0aClTZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBIdCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Q9dCx0aGlzLl9wcmVjTW9kZWw9dC5nZXRQcmVjaXNpb25Nb2RlbCgpfX07Y2xhc3MgTGUgZXh0ZW5kcyBTZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXROdW1Bcm1zKHQpe3RoaXMuX251bUFybXM9dH1zZXRBcm1MZW5ndGhSYXRpbyh0KXt0aGlzLl9hcm1MZW5ndGhSYXRpbz10fWNyZWF0ZVNpbmVTdGFyKCl7Y29uc3QgdD10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxlPXQuZ2V0V2lkdGgoKS8yO2xldCBuPXRoaXMuX2FybUxlbmd0aFJhdGlvO248MCYmKG49MCksbj4xJiYobj0xKTtjb25zdCBzPW4qZSxpPSgxLW4pKmUscj10LmdldE1pblgoKStlLG89dC5nZXRNaW5ZKCkrZSxsPW5ldyBBcnJheSh0aGlzLl9uUHRzKzEpLmZpbGwobnVsbCk7bGV0IGE9MDtmb3IobGV0IHQ9MDt0PHRoaXMuX25QdHM7dCsrKXtjb25zdCBlPXQvdGhpcy5fblB0cyp0aGlzLl9udW1Bcm1zLG49ZS1NYXRoLmZsb29yKGUpLGM9MipNYXRoLlBJKm4saD1pK3MqKChNYXRoLmNvcyhjKSsxKS8yKSx1PXQqKDIqTWF0aC5QSS90aGlzLl9uUHRzKSxnPWgqTWF0aC5jb3ModSkrcixkPWgqTWF0aC5zaW4odSkrbztsW2ErK109dGhpcy5jb29yZChnLGQpfWxbYV09bmV3IGcobFswXSk7Y29uc3QgYz10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKGwpO3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGMpfWdldENsYXNzKCl7cmV0dXJuIExlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1MZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9udW1Bcm1zPTgsdGhpcy5fYXJtTGVuZ3RoUmF0aW89LjUsMD09PWFyZ3VtZW50cy5sZW5ndGgpU2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07U2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19O3ZhciBUZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxBZmZpbmVUcmFuc2Zvcm1hdGlvbjpsZSxBZmZpbmVUcmFuc2Zvcm1hdGlvbkJ1aWxkZXI6Y2UsQWZmaW5lVHJhbnNmb3JtYXRpb25GYWN0b3J5OmhlLENvbXBvbmVudENvb3JkaW5hdGVFeHRyYWN0ZXI6dWUsR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyOmdlLEdlb21ldHJ5Q29tYmluZXI6ZGUsR2VvbWV0cnlFZGl0b3I6RnQsR2VvbWV0cnlFeHRyYWN0ZXI6X2UsR2VvbWV0cnlNYXBwZXI6cGUsR2VvbWV0cnlUcmFuc2Zvcm1lcjptZSxMaW5lU3RyaW5nRXh0cmFjdGVyOnllLExpbmVhckNvbXBvbmVudEV4dHJhY3Rlcjp4ZSxNYXBPcDpmZSxQb2ludEV4dHJhY3RlcjpJZSxQb2x5Z29uRXh0cmFjdGVyOk5lLFNob3J0Q2lyY3VpdGVkR2VvbWV0cnlWaXNpdG9yOkNlLFNpbmVTdGFyRmFjdG9yeTpMZX0pLFJlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLENvb3JkaW5hdGU6ZyxDb29yZGluYXRlTGlzdDpJLEVudmVsb3BlOk4sTGluZVNlZ21lbnQ6ZWUsR2VvbWV0cnlGYWN0b3J5Okh0LEdlb21ldHJ5OnEsUG9pbnQ6UHQsTGluZVN0cmluZzpUdCxMaW5lYXJSaW5nOkR0LFBvbHlnb246YnQsR2VvbWV0cnlDb2xsZWN0aW9uOl90LE11bHRpUG9pbnQ6TXQsTXVsdGlMaW5lU3RyaW5nOmZ0LE11bHRpUG9seWdvbjpBdCxEaW1lbnNpb246dXQsSW50ZXJzZWN0aW9uTWF0cml4OnNlLFByZWNpc2lvbk1vZGVsOmt0LExvY2F0aW9uOm5lLFRyaWFuZ2xlOnJlLHV0aWw6VGV9KTtjbGFzcyBQZXtjb25zdHJ1Y3Rvcigpe1BlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHR9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRbdF19c2V0TWluaW11bSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldE1pbmltdW0odC5fcHRbMF0sdC5fcHRbMV0pfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuX2lzTnVsbClyZXR1cm4gdGhpcy5pbml0aWFsaXplKHQsZSksbnVsbDtjb25zdCBuPXQuZGlzdGFuY2UoZSk7bjx0aGlzLl9kaXN0YW5jZSYmdGhpcy5pbml0aWFsaXplKHQsZSxuKX19aW5pdGlhbGl6ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX2lzTnVsbD0hMDtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHQpLHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUoZSksdGhpcy5fZGlzdGFuY2U9dC5kaXN0YW5jZShlKSx0aGlzLl9pc051bGw9ITF9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZSh0KSx0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKGUpLHRoaXMuX2Rpc3RhbmNlPW4sdGhpcy5faXNOdWxsPSExfX10b1N0cmluZygpe3JldHVybiBKdC50b0xpbmVTdHJpbmcodGhpcy5fcHRbMF0sdGhpcy5fcHRbMV0pfWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfXNldE1heGltdW0oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRNYXhpbXVtKHQuX3B0WzBdLHQuX3B0WzFdKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLl9pc051bGwpcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZSh0LGUpLG51bGw7Y29uc3Qgbj10LmRpc3RhbmNlKGUpO24+dGhpcy5fZGlzdGFuY2UmJnRoaXMuaW5pdGlhbGl6ZSh0LGUsbil9fWdldENsYXNzKCl7cmV0dXJuIFBlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1QZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdD1bbmV3IGcsbmV3IGddLHRoaXMuX2Rpc3RhbmNlPWkuTmFOLHRoaXMuX2lzTnVsbD0hMH07Y2xhc3MgdmV7Y29uc3RydWN0b3IoKXt2ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21wdXRlRGlzdGFuY2UoKXtpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFBlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IGVlLGk9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGgtMTt0Kyspe3Muc2V0Q29vcmRpbmF0ZXMoaVt0XSxpW3QrMV0pO2NvbnN0IHI9cy5jbG9zZXN0UG9pbnQoZSk7bi5zZXRNaW5pbXVtKHIsZSl9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBQZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBidCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt2ZS5jb21wdXRlRGlzdGFuY2UodC5nZXRFeHRlcmlvclJpbmcoKSxlLG4pO2ZvcihsZXQgcz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspdmUuY29tcHV0ZURpc3RhbmNlKHQuZ2V0SW50ZXJpb3JSaW5nTihzKSxlLG4pfWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBQZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQgaW5zdGFuY2VvZiBUdCl2ZS5jb21wdXRlRGlzdGFuY2UodCxlLG4pO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGJ0KXZlLmNvbXB1dGVEaXN0YW5jZSh0LGUsbik7ZWxzZSBpZih0IGluc3RhbmNlb2YgX3Qpe2NvbnN0IHM9dDtmb3IobGV0IHQ9MDt0PHMuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3QgaT1zLmdldEdlb21ldHJ5Tih0KTt2ZS5jb21wdXRlRGlzdGFuY2UoaSxlLG4pfX1lbHNlIG4uc2V0TWluaW11bSh0LmdldENvb3JkaW5hdGUoKSxlKX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUGUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz10LmNsb3Nlc3RQb2ludChlKTtuLnNldE1pbmltdW0ocyxlKX19Z2V0Q2xhc3MoKXtyZXR1cm4gdmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXZlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgT2V7Y29uc3RydWN0b3IoKXtPZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkaXN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IE9lKHQsZSkuZGlzdGFuY2UoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgT2UodCxlKTtyZXR1cm4gcy5zZXREZW5zaWZ5RnJhY3Rpb24obikscy5kaXN0YW5jZSgpfX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdERpc3QuZ2V0Q29vcmRpbmF0ZXMoKX1zZXREZW5zaWZ5RnJhY3Rpb24odCl7aWYodD4xfHx0PD0wKXRocm93IG5ldyBuKFwiRnJhY3Rpb24gaXMgbm90IGluIHJhbmdlICgwLjAgLSAxLjBdXCIpO3RoaXMuX2RlbnNpZnlGcmFjPXR9Y29tcHV0ZSh0LGUpe3RoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodCxlLHRoaXMuX3B0RGlzdCksdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZShlLHQsdGhpcy5fcHREaXN0KX1kaXN0YW5jZSgpe3JldHVybiB0aGlzLmNvbXB1dGUodGhpcy5fZzAsdGhpcy5fZzEpLHRoaXMuX3B0RGlzdC5nZXREaXN0YW5jZSgpfWNvbXB1dGVPcmllbnRlZERpc3RhbmNlKHQsZSxuKXtjb25zdCBzPW5ldyBiZShlKTtpZih0LmFwcGx5KHMpLG4uc2V0TWF4aW11bShzLmdldE1heFBvaW50RGlzdGFuY2UoKSksdGhpcy5fZGVuc2lmeUZyYWM+MCl7Y29uc3Qgcz1uZXcgTWUoZSx0aGlzLl9kZW5zaWZ5RnJhYyk7dC5hcHBseShzKSxuLnNldE1heGltdW0ocy5nZXRNYXhQb2ludERpc3RhbmNlKCkpfX1vcmllbnRlZERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodGhpcy5fZzAsdGhpcy5fZzEsdGhpcy5fcHREaXN0KSx0aGlzLl9wdERpc3QuZ2V0RGlzdGFuY2UoKX1nZXRDbGFzcygpe3JldHVybiBPZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgYmV7Y29uc3RydWN0b3IoKXtiZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt0aGlzLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpLHZlLmNvbXB1dGVEaXN0YW5jZSh0aGlzLl9nZW9tLHQsdGhpcy5fbWluUHREaXN0KSx0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzLl9taW5QdERpc3QpfWdldE1heFBvaW50RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fbWF4UHREaXN0fWdldENsYXNzKCl7cmV0dXJuIGJlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltCXX19YmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbWF4UHREaXN0PW5ldyBQZSx0aGlzLl9taW5QdERpc3Q9bmV3IFBlLHRoaXMuX2V1Y2xpZGVhbkRpc3Q9bmV3IHZlLHRoaXMuX2dlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tPXR9O2NsYXNzIE1le2NvbnN0cnVjdG9yKCl7TWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCxlKXtpZigwPT09ZSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZShlLTEpLHM9dC5nZXRDb29yZGluYXRlKGUpLGk9KHMueC1uLngpL3RoaXMuX251bVN1YlNlZ3Mscj0ocy55LW4ueSkvdGhpcy5fbnVtU3ViU2Vncztmb3IobGV0IHQ9MDt0PHRoaXMuX251bVN1YlNlZ3M7dCsrKXtjb25zdCBlPW4ueCt0Kmkscz1uLnkrdCpyLG89bmV3IGcoZSxzKTt0aGlzLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpLHZlLmNvbXB1dGVEaXN0YW5jZSh0aGlzLl9nZW9tLG8sdGhpcy5fbWluUHREaXN0KSx0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzLl9taW5QdERpc3QpfX1pc0RvbmUoKXtyZXR1cm4hMX1pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiExfWdldE1heFBvaW50RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fbWF4UHREaXN0fWdldENsYXNzKCl7cmV0dXJuIE1lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltkdF19fU1lLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX21heFB0RGlzdD1uZXcgUGUsdGhpcy5fbWluUHREaXN0PW5ldyBQZSx0aGlzLl9nZW9tPW51bGwsdGhpcy5fbnVtU3ViU2Vncz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb209dCx0aGlzLl9udW1TdWJTZWdzPU1hdGgudHJ1bmMoTWF0aC5yb3VuZCgxL2UpKX0sT2UuTWF4UG9pbnREaXN0YW5jZUZpbHRlcj1iZSxPZS5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXI9TWUsT2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZzA9bnVsbCx0aGlzLl9nMT1udWxsLHRoaXMuX3B0RGlzdD1uZXcgUGUsdGhpcy5fZGVuc2lmeUZyYWM9MDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nMD10LHRoaXMuX2cxPWV9O3ZhciBEZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlOk9lLERpc3RhbmNlVG9Qb2ludDp2ZSxQb2ludFBhaXJEaXN0YW5jZTpQZX0pO2NsYXNzIEFle2NvbnN0cnVjdG9yKCl7QWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdEl0ZW0odCl7fWdldENsYXNzKCl7cmV0dXJuIEFlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1BZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEZle2NvbnN0cnVjdG9yKCl7RmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1sb2NhdGUodCl7fWdldENsYXNzKCl7cmV0dXJuIEZlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1GZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEdle2NvbnN0cnVjdG9yKCl7R2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRNaW4oKXtyZXR1cm4gdGhpcy5fbWlufWludGVyc2VjdHModCxlKXtyZXR1cm4hKHRoaXMuX21pbj5lfHx0aGlzLl9tYXg8dCl9Z2V0TWF4KCl7cmV0dXJuIHRoaXMuX21heH10b1N0cmluZygpe3JldHVybiBKdC50b0xpbmVTdHJpbmcobmV3IGcodGhpcy5fbWluLDApLG5ldyBnKHRoaXMuX21heCwwKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gR2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHFle2NvbnN0cnVjdG9yKCl7cWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZSxpPShuLl9taW4rbi5fbWF4KS8yLHI9KHMuX21pbitzLl9tYXgpLzI7cmV0dXJuIGk8cj8tMTppPnI/MTowfWdldENsYXNzKCl7cmV0dXJuIHFlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19cWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxHZS5Ob2RlQ29tcGFyYXRvcj1xZSxHZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9taW49aS5QT1NJVElWRV9JTkZJTklUWSx0aGlzLl9tYXg9aS5ORUdBVElWRV9JTkZJTklUWX07Y2xhc3MgQmUgZXh0ZW5kcyBHZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1xdWVyeSh0LGUsbil7aWYoIXRoaXMuaW50ZXJzZWN0cyh0LGUpKXJldHVybiBudWxsO24udmlzaXRJdGVtKHRoaXMuX2l0ZW0pfWdldENsYXNzKCl7cmV0dXJuIEJlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1CZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pdGVtPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbWluPXQsdGhpcy5fbWF4PWUsdGhpcy5faXRlbT1ufTtjbGFzcyBWZSBleHRlbmRzIEdle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxWZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWJ1aWxkRXh0ZW50KHQsZSl7dGhpcy5fbWluPU1hdGgubWluKHQuX21pbixlLl9taW4pLHRoaXMuX21heD1NYXRoLm1heCh0Ll9tYXgsZS5fbWF4KX1xdWVyeSh0LGUsbil7aWYoIXRoaXMuaW50ZXJzZWN0cyh0LGUpKXJldHVybiBudWxsO251bGwhPT10aGlzLl9ub2RlMSYmdGhpcy5fbm9kZTEucXVlcnkodCxlLG4pLG51bGwhPT10aGlzLl9ub2RlMiYmdGhpcy5fbm9kZTIucXVlcnkodCxlLG4pfWdldENsYXNzKCl7cmV0dXJuIFZlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1WZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ub2RlMT1udWxsLHRoaXMuX25vZGUyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbm9kZTE9dCx0aGlzLl9ub2RlMj1lLHRoaXMuYnVpbGRFeHRlbnQodGhpcy5fbm9kZTEsdGhpcy5fbm9kZTIpfTtjbGFzcyB6ZXtjb25zdHJ1Y3Rvcigpe3plLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YnVpbGRUcmVlKCl7RWUuc29ydCh0aGlzLl9sZWF2ZXMsbmV3IEdlLk5vZGVDb21wYXJhdG9yKTtsZXQgdD10aGlzLl9sZWF2ZXMsZT1udWxsLG49bmV3IHg7Zm9yKDs7KXtpZih0aGlzLmJ1aWxkTGV2ZWwodCxuKSwxPT09bi5zaXplKCkpcmV0dXJuIG4uZ2V0KDApO2U9dCx0PW4sbj1lfX1pbnNlcnQodCxlLG4pe2lmKG51bGwhPT10aGlzLl9yb290KXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJJbmRleCBjYW5ub3QgYmUgYWRkZWQgdG8gb25jZSBpdCBoYXMgYmVlbiBxdWVyaWVkXCIpO3RoaXMuX2xlYXZlcy5hZGQobmV3IEJlKHQsZSxuKSl9cXVlcnkodCxlLG4pe3RoaXMuaW5pdCgpLHRoaXMuX3Jvb3QucXVlcnkodCxlLG4pfWJ1aWxkUm9vdCgpe2lmKG51bGwhPT10aGlzLl9yb290KXJldHVybiBudWxsO3RoaXMuX3Jvb3Q9dGhpcy5idWlsZFRyZWUoKX1wcmludE5vZGUodCl7Ty5vdXQucHJpbnRsbihKdC50b0xpbmVTdHJpbmcobmV3IGcodC5fbWluLHRoaXMuX2xldmVsKSxuZXcgZyh0Ll9tYXgsdGhpcy5fbGV2ZWwpKSl9aW5pdCgpe2lmKG51bGwhPT10aGlzLl9yb290KXJldHVybiBudWxsO3RoaXMuYnVpbGRSb290KCl9YnVpbGRMZXZlbCh0LGUpe3RoaXMuX2xldmVsKyssZS5jbGVhcigpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bis9Mil7Y29uc3Qgcz10LmdldChuKTtpZihudWxsPT09KG4rMTx0LnNpemUoKT90LmdldChuKTpudWxsKSllLmFkZChzKTtlbHNle2NvbnN0IHM9bmV3IFZlKHQuZ2V0KG4pLHQuZ2V0KG4rMSkpO2UuYWRkKHMpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gemV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXplLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xlYXZlcz1uZXcgeCx0aGlzLl9yb290PW51bGwsdGhpcy5fbGV2ZWw9MH07Y2xhc3MgWWV7Y29uc3RydWN0b3IoKXtZZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0SXRlbSh0KXt0aGlzLl9pdGVtcy5hZGQodCl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9Z2V0Q2xhc3MoKXtyZXR1cm4gWWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FlXX19WWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXRlbXM9bmV3IHh9O2NsYXNzIFVle2NvbnN0cnVjdG9yKCl7VWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbG9jYXRlUG9pbnRJblJpbmcoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJl8oYXJndW1lbnRzWzFdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBVZSh0KSxzPW5ldyBnLGk9bmV3IGc7Zm9yKGxldCB0PTE7dDxlLnNpemUoKTt0KyspaWYoZS5nZXRDb29yZGluYXRlKHQscyksZS5nZXRDb29yZGluYXRlKHQtMSxpKSxuLmNvdW50U2VnbWVudChzLGkpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpO3JldHVybiBuLmdldExvY2F0aW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBVZSh0KTtmb3IobGV0IHQ9MTt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgcz1lW3RdLGk9ZVt0LTFdO2lmKG4uY291bnRTZWdtZW50KHMsaSksbi5pc09uU2VnbWVudCgpKXJldHVybiBuLmdldExvY2F0aW9uKCl9cmV0dXJuIG4uZ2V0TG9jYXRpb24oKX19Y291bnRTZWdtZW50KHQsZSl7aWYodC54PHRoaXMuX3AueCYmZS54PHRoaXMuX3AueClyZXR1cm4gbnVsbDtpZih0aGlzLl9wLng9PT1lLngmJnRoaXMuX3AueT09PWUueSlyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2lmKHQueT09PXRoaXMuX3AueSYmZS55PT09dGhpcy5fcC55KXtsZXQgbj10Lngscz1lLng7cmV0dXJuIG4+cyYmKG49ZS54LHM9dC54KSx0aGlzLl9wLng+PW4mJnRoaXMuX3AueDw9cyYmKHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITApLG51bGx9aWYodC55PnRoaXMuX3AueSYmZS55PD10aGlzLl9wLnl8fGUueT50aGlzLl9wLnkmJnQueTw9dGhpcy5fcC55KXtsZXQgbj12LmluZGV4KHQsZSx0aGlzLl9wKTtpZihuPT09di5DT0xMSU5FQVIpcmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITAsbnVsbDtlLnk8dC55JiYobj0tbiksbj09PXYuTEVGVCYmdGhpcy5fY3Jvc3NpbmdDb3VudCsrfX1pc1BvaW50SW5Qb2x5Z29uKCl7cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24oKSE9PW5lLkVYVEVSSU9SfWdldExvY2F0aW9uKCl7cmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ/bmUuQk9VTkRBUlk6dGhpcy5fY3Jvc3NpbmdDb3VudCUyPT0xP25lLklOVEVSSU9SOm5lLkVYVEVSSU9SfWlzT25TZWdtZW50KCl7cmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnR9Z2V0Q2xhc3MoKXtyZXR1cm4gVWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVVlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3A9bnVsbCx0aGlzLl9jcm9zc2luZ0NvdW50PTAsdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wPXR9O2NsYXNzIGtle2NvbnN0cnVjdG9yKCl7a2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1sb2NhdGUodCl7Y29uc3QgZT1uZXcgVWUodCksbj1uZXcgWGUoZSk7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHQueSx0LnksbiksZS5nZXRMb2NhdGlvbigpfWdldENsYXNzKCl7cmV0dXJuIGtlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltGZV19fWNsYXNzIFhle2NvbnN0cnVjdG9yKCl7WGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdEl0ZW0odCl7Y29uc3QgZT10O3RoaXMuX2NvdW50ZXIuY291bnRTZWdtZW50KGUuZ2V0Q29vcmRpbmF0ZSgwKSxlLmdldENvb3JkaW5hdGUoMSkpfWdldENsYXNzKCl7cmV0dXJuIFhlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19fVhlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2NvdW50ZXI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb3VudGVyPXR9O2NsYXNzIEhle2NvbnN0cnVjdG9yKCl7SGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbml0KHQpe2ZvcihsZXQgZT14ZS5nZXRMaW5lcyh0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKS5nZXRDb29yZGluYXRlcygpO3RoaXMuYWRkTGluZSh0KX19YWRkTGluZSh0KXtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj1uZXcgZWUodFtlLTFdLHRbZV0pLHM9TWF0aC5taW4obi5wMC55LG4ucDEueSksaT1NYXRoLm1heChuLnAwLnksbi5wMS55KTt0aGlzLl9pbmRleC5pbnNlcnQocyxpLG4pfX1xdWVyeSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBZZTtyZXR1cm4gdGhpcy5faW5kZXgucXVlcnkodCxlLG4pLG4uZ2V0SXRlbXMoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5faW5kZXgucXVlcnkodCxlLG4pfX1nZXRDbGFzcygpe3JldHVybiBIZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5kZXg9bmV3IHplO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX0sa2UuU2VnbWVudFZpc2l0b3I9WGUsa2UuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnk9SGUsa2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTtpZighKF8odCxPdCl8fHQgaW5zdGFuY2VvZiBEdCkpdGhyb3cgbmV3IG4oXCJBcmd1bWVudCBtdXN0IGJlIFBvbHlnb25hbCBvciBMaW5lYXJSaW5nXCIpO3RoaXMuX2luZGV4PW5ldyBIZSh0KX07Y2xhc3MgV2V7Y29uc3RydWN0b3IoKXtXZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc09uTGluZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmXyhhcmd1bWVudHNbMV0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IHRlLHM9bmV3IGcsaT1uZXcgZyxyPWUuc2l6ZSgpO2ZvcihsZXQgbz0xO288cjtvKyspaWYoZS5nZXRDb29yZGluYXRlKG8tMSxzKSxlLmdldENvb3JkaW5hdGUobyxpKSxuLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxzLGkpLG4uaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuITA7cmV0dXJuITF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB0ZTtmb3IobGV0IHM9MTtzPGUubGVuZ3RoO3MrKyl7Y29uc3QgaT1lW3MtMV0scj1lW3NdO2lmKG4uY29tcHV0ZUludGVyc2VjdGlvbih0LGksciksbi5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4hMH1yZXR1cm4hMX19c3RhdGljIGxvY2F0ZUluUmluZyh0LGUpe3JldHVybiBVZS5sb2NhdGVQb2ludEluUmluZyh0LGUpfXN0YXRpYyBpc0luUmluZyh0LGUpe3JldHVybiBXZS5sb2NhdGVJblJpbmcodCxlKSE9PW5lLkVYVEVSSU9SfWdldENsYXNzKCl7cmV0dXJuIFdlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBqZSgpe31XZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LGplLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7fSxqZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe30samUucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe307Y2xhc3MgS2V7Y29uc3RydWN0b3IoKXtLZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc0F0b21pYyh0KXtyZXR1cm4hKHQgaW5zdGFuY2VvZiBfdCl9bmV4dCgpe2lmKHRoaXMuX2F0U3RhcnQpcmV0dXJuIHRoaXMuX2F0U3RhcnQ9ITEsS2UuaXNBdG9taWModGhpcy5fcGFyZW50KSYmdGhpcy5faW5kZXgrKyx0aGlzLl9wYXJlbnQ7aWYobnVsbCE9PXRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcil7aWYodGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSlyZXR1cm4gdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKTt0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1pZih0aGlzLl9pbmRleD49dGhpcy5fbWF4KXRocm93IG5ldyB5O2NvbnN0IHQ9dGhpcy5fcGFyZW50LmdldEdlb21ldHJ5Tih0aGlzLl9pbmRleCsrKTtyZXR1cm4gdCBpbnN0YW5jZW9mIF90Pyh0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bmV3IEtlKHQpLHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCkpOnR9cmVtb3ZlKCl7dGhyb3cgbmV3IFoodGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSl9aGFzTmV4dCgpe2lmKHRoaXMuX2F0U3RhcnQpcmV0dXJuITA7aWYobnVsbCE9PXRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcil7aWYodGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSlyZXR1cm4hMDt0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1yZXR1cm4hKHRoaXMuX2luZGV4Pj10aGlzLl9tYXgpfWdldENsYXNzKCl7cmV0dXJuIEtlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltqZV19fUtlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3BhcmVudD1udWxsLHRoaXMuX2F0U3RhcnQ9bnVsbCx0aGlzLl9tYXg9bnVsbCx0aGlzLl9pbmRleD1udWxsLHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BhcmVudD10LHRoaXMuX2F0U3RhcnQ9ITAsdGhpcy5faW5kZXg9MCx0aGlzLl9tYXg9dC5nZXROdW1HZW9tZXRyaWVzKCl9O2NsYXNzIFple2NvbnN0cnVjdG9yKCl7WmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbG9jYXRlUG9pbnRJblBvbHlnb24odCxlKXtpZihlLmlzRW1wdHkoKSlyZXR1cm4gbmUuRVhURVJJT1I7Y29uc3Qgbj1lLmdldEV4dGVyaW9yUmluZygpLHM9WmUubG9jYXRlUG9pbnRJblJpbmcodCxuKTtpZihzIT09bmUuSU5URVJJT1IpcmV0dXJuIHM7Zm9yKGxldCBuPTA7bjxlLmdldE51bUludGVyaW9yUmluZygpO24rKyl7Y29uc3Qgcz1lLmdldEludGVyaW9yUmluZ04obiksaT1aZS5sb2NhdGVQb2ludEluUmluZyh0LHMpO2lmKGk9PT1uZS5CT1VOREFSWSlyZXR1cm4gbmUuQk9VTkRBUlk7aWYoaT09PW5lLklOVEVSSU9SKXJldHVybiBuZS5FWFRFUklPUn1yZXR1cm4gbmUuSU5URVJJT1J9c3RhdGljIGxvY2F0ZVBvaW50SW5SaW5nKHQsZSl7cmV0dXJuIGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/V2UubG9jYXRlSW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKTpuZS5FWFRFUklPUn1zdGF0aWMgY29udGFpbnNQb2ludEluUG9seWdvbih0LGUpe3JldHVybiBuZS5FWFRFUklPUiE9PVplLmxvY2F0ZVBvaW50SW5Qb2x5Z29uKHQsZSl9c3RhdGljIGxvY2F0ZUluR2VvbWV0cnkodCxlKXtpZihlIGluc3RhbmNlb2YgYnQpcmV0dXJuIFplLmxvY2F0ZVBvaW50SW5Qb2x5Z29uKHQsZSk7aWYoZSBpbnN0YW5jZW9mIF90KXtjb25zdCBuPW5ldyBLZShlKTtmb3IoO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtpZihzIT09ZSl7Y29uc3QgZT1aZS5sb2NhdGVJbkdlb21ldHJ5KHQscyk7aWYoZSE9PW5lLkVYVEVSSU9SKXJldHVybiBlfX19cmV0dXJuIG5lLkVYVEVSSU9SfXN0YXRpYyBsb2NhdGUodCxlKXtyZXR1cm4gZS5pc0VtcHR5KCk/bmUuRVhURVJJT1I6WmUubG9jYXRlSW5HZW9tZXRyeSh0LGUpfWxvY2F0ZSh0KXtyZXR1cm4gWmUubG9jYXRlKHQsdGhpcy5fZ2VvbSl9Z2V0Q2xhc3MoKXtyZXR1cm4gWmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ZlXX19WmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb209dH07dmFyIFFlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3I6a2UsUG9pbnRPbkdlb21ldHJ5TG9jYXRvcjpGZSxTaW1wbGVQb2ludEluQXJlYUxvY2F0b3I6WmV9KTtjbGFzcyBKZXtjb25zdHJ1Y3Rvcigpe0plLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bWVhc3VyZSh0LGUpe31nZXRDbGFzcygpe3JldHVybiBKZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyAkZXtjb25zdHJ1Y3RvcigpeyRlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bWVhc3VyZSh0LGUpe3JldHVybiB0LmludGVyc2VjdGlvbihlKS5nZXRBcmVhKCkvdC51bmlvbihlKS5nZXRBcmVhKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gJGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0plXX19JGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB0bntjb25zdHJ1Y3Rvcigpe3RuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRpYWdvbmFsU2l6ZSh0KXtpZih0LmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4pfW1lYXN1cmUodCxlKXtjb25zdCBuPU9lLmRpc3RhbmNlKHQsZSx0bi5ERU5TSUZZX0ZSQUNUSU9OKSxzPW5ldyBOKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtyZXR1cm4gcy5leHBhbmRUb0luY2x1ZGUoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpLDEtbi90bi5kaWFnb25hbFNpemUocyl9Z2V0Q2xhc3MoKXtyZXR1cm4gdG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0plXX19dG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSx0bi5ERU5TSUZZX0ZSQUNUSU9OPS4yNTtjbGFzcyBlbntjb25zdHJ1Y3Rvcigpe2VuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbWJpbmUodCxlKXtyZXR1cm4gTWF0aC5taW4odCxlKX1nZXRDbGFzcygpe3JldHVybiBlbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTt2YXIgbm49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQXJlYVNpbWlsYXJpdHlNZWFzdXJlOiRlLEhhdXNkb3JmZlNpbWlsYXJpdHlNZWFzdXJlOnRuLFNpbWlsYXJpdHlNZWFzdXJlOkplLFNpbWlsYXJpdHlNZWFzdXJlQ29tYmluZXI6ZW59KTtjbGFzcyBzbntjb25zdHJ1Y3Rvcigpe3NuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGFyZWEyKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShuLngtdC54KSooZS55LXQueSl9c3RhdGljIGNlbnRyb2lkMyh0LGUsbixzKXtyZXR1cm4gcy54PXQueCtlLngrbi54LHMueT10LnkrZS55K24ueSxudWxsfXN0YXRpYyBnZXRDZW50cm9pZCh0KXtyZXR1cm4gbmV3IHNuKHQpLmdldENlbnRyb2lkKCl9c2V0QXJlYUJhc2VQb2ludCh0KXt0aGlzLl9hcmVhQmFzZVB0PXR9YWRkUG9pbnQodCl7dGhpcy5fcHRDb3VudCs9MSx0aGlzLl9wdENlbnRTdW0ueCs9dC54LHRoaXMuX3B0Q2VudFN1bS55Kz10Lnl9YWRkTGluZVNlZ21lbnRzKHQpe2xldCBlPTA7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl7Y29uc3Qgcz10W25dLmRpc3RhbmNlKHRbbisxXSk7aWYoMD09PXMpY29udGludWU7ZSs9cztjb25zdCBpPSh0W25dLngrdFtuKzFdLngpLzI7dGhpcy5fbGluZUNlbnRTdW0ueCs9cyppO2NvbnN0IHI9KHRbbl0ueSt0W24rMV0ueSkvMjt0aGlzLl9saW5lQ2VudFN1bS55Kz1zKnJ9dGhpcy5fdG90YWxMZW5ndGgrPWUsMD09PWUmJnQubGVuZ3RoPjAmJnRoaXMuYWRkUG9pbnQodFswXSl9YWRkSG9sZSh0KXtjb25zdCBlPXYuaXNDQ1codCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl0aGlzLmFkZFRyaWFuZ2xlKHRoaXMuX2FyZWFCYXNlUHQsdFtuXSx0W24rMV0sZSk7dGhpcy5hZGRMaW5lU2VnbWVudHModCl9Z2V0Q2VudHJvaWQoKXtjb25zdCB0PW5ldyBnO2lmKE1hdGguYWJzKHRoaXMuX2FyZWFzdW0yKT4wKXQueD10aGlzLl9jZzMueC8zL3RoaXMuX2FyZWFzdW0yLHQueT10aGlzLl9jZzMueS8zL3RoaXMuX2FyZWFzdW0yO2Vsc2UgaWYodGhpcy5fdG90YWxMZW5ndGg+MCl0Lng9dGhpcy5fbGluZUNlbnRTdW0ueC90aGlzLl90b3RhbExlbmd0aCx0Lnk9dGhpcy5fbGluZUNlbnRTdW0ueS90aGlzLl90b3RhbExlbmd0aDtlbHNle2lmKCEodGhpcy5fcHRDb3VudD4wKSlyZXR1cm4gbnVsbDt0Lng9dGhpcy5fcHRDZW50U3VtLngvdGhpcy5fcHRDb3VudCx0Lnk9dGhpcy5fcHRDZW50U3VtLnkvdGhpcy5fcHRDb3VudH1yZXR1cm4gdH1hZGRTaGVsbCh0KXt0Lmxlbmd0aD4wJiZ0aGlzLnNldEFyZWFCYXNlUG9pbnQodFswXSk7Y29uc3QgZT0hdi5pc0NDVyh0KTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5fYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX1hZGRUcmlhbmdsZSh0LGUsbixzKXtjb25zdCBpPXM/MTotMTtzbi5jZW50cm9pZDModCxlLG4sdGhpcy5fdHJpYW5nbGVDZW50Myk7Y29uc3Qgcj1zbi5hcmVhMih0LGUsbik7dGhpcy5fY2czLngrPWkqcip0aGlzLl90cmlhbmdsZUNlbnQzLngsdGhpcy5fY2czLnkrPWkqcip0aGlzLl90cmlhbmdsZUNlbnQzLnksdGhpcy5fYXJlYXN1bTIrPWkqcn1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZFNoZWxsKHQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSk7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl0aGlzLmFkZEhvbGUodC5nZXRJbnRlcmlvclJpbmdOKGUpLmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGRQb2ludCh0LmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRMaW5lU2VnbWVudHModC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBidCl7Y29uc3QgZT10O3RoaXMuYWRkKGUpfWVsc2UgaWYodCBpbnN0YW5jZW9mIF90KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4odCkpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gc259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIHJuKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIG9uKCl7dGhpcy5hcnJheV89W119c24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fYXJlYUJhc2VQdD1udWxsLHRoaXMuX3RyaWFuZ2xlQ2VudDM9bmV3IGcsdGhpcy5fYXJlYXN1bTI9MCx0aGlzLl9jZzM9bmV3IGcsdGhpcy5fbGluZUNlbnRTdW09bmV3IGcsdGhpcy5fdG90YWxMZW5ndGg9MCx0aGlzLl9wdENvdW50PTAsdGhpcy5fcHRDZW50U3VtPW5ldyBnO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2FyZWFCYXNlUHQ9bnVsbCx0aGlzLmFkZCh0KX0scm4ucHJvdG90eXBlPW5ldyBFcnJvcixybi5wcm90b3R5cGUubmFtZT1cIkVtcHR5U3RhY2tFeGNlcHRpb25cIixvbi5wcm90b3R5cGU9bmV3IG0sb24ucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSwhMH0sb24ucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtpZih0PDB8fHQ+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyBwO3JldHVybiB0aGlzLmFycmF5X1t0XX0sb24ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLnB1c2godCksdH0sb24ucHJvdG90eXBlLnBvcD1mdW5jdGlvbih0KXtpZigwPT09dGhpcy5hcnJheV8ubGVuZ3RoKXRocm93IG5ldyBybjtyZXR1cm4gdGhpcy5hcnJheV8ucG9wKCl9LG9uLnByb3RvdHlwZS5wZWVrPWZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuYXJyYXlfLmxlbmd0aCl0aHJvdyBuZXcgcm47cmV0dXJuIHRoaXMuYXJyYXlfW3RoaXMuYXJyYXlfLmxlbmd0aC0xXX0sb24ucHJvdG90eXBlLmVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9LG9uLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW1wdHkoKX0sb24ucHJvdG90eXBlLnNlYXJjaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8uaW5kZXhPZih0KX0sb24ucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxvbi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fTtjbGFzcyBsbntjb25zdHJ1Y3Rvcigpe2xuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGZpbHRlckNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IGxuO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWUuZmlsdGVyKHRbbl0pO3JldHVybiBlLmdldENvb3JkaW5hdGVzKCl9ZmlsdGVyKHQpe3RoaXMudHJlZVNldC5jb250YWlucyh0KXx8KHRoaXMubGlzdC5hZGQodCksdGhpcy50cmVlU2V0LmFkZCh0KSl9Z2V0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLmxpc3Quc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLmxpc3QudG9BcnJheSh0KX1nZXRDbGFzcygpe3JldHVybiBsbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQl19fWxuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMudHJlZVNldD1uZXcgYXQsdGhpcy5saXN0PW5ldyB4fTtjbGFzcyBhbntjb25zdHJ1Y3Rvcigpe2FuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGV4dHJhY3RDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBsbjtyZXR1cm4gdC5hcHBseShlKSxlLmdldENvb3JkaW5hdGVzKCl9cHJlU29ydCh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKSh0W25dLnk8dFswXS55fHx0W25dLnk9PT10WzBdLnkmJnRbbl0ueDx0WzBdLngpJiYoZT10WzBdLHRbMF09dFtuXSx0W25dPWUpO3JldHVybiBodC5zb3J0KHQsMSx0Lmxlbmd0aCxuZXcgY24odFswXSkpLHR9Y29tcHV0ZU9jdFJpbmcodCl7Y29uc3QgZT10aGlzLmNvbXB1dGVPY3RQdHModCksbj1uZXcgSTtyZXR1cm4gbi5hZGQoZSwhMSksbi5zaXplKCk8Mz9udWxsOihuLmNsb3NlUmluZygpLG4udG9Db29yZGluYXRlQXJyYXkoKSl9bGluZU9yUG9seWdvbih0KXtpZigzPT09KHQ9dGhpcy5jbGVhblJpbmcodCkpLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbdFswXSx0WzFdXSk7Y29uc3QgZT10aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpO3JldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVQb2x5Z29uKGUpfWNsZWFuUmluZyh0KXt1LmVxdWFscyh0WzBdLHRbdC5sZW5ndGgtMV0pO2NvbnN0IGU9bmV3IHg7bGV0IG49bnVsbDtmb3IobGV0IHM9MDtzPD10Lmxlbmd0aC0yO3MrKyl7Y29uc3QgaT10W3NdLHI9dFtzKzFdO2kuZXF1YWxzKHIpfHwobnVsbCE9PW4mJnRoaXMuaXNCZXR3ZWVuKG4saSxyKXx8KGUuYWRkKGkpLG49aSkpfWUuYWRkKHRbdC5sZW5ndGgtMV0pO2NvbnN0IHM9bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiBlLnRvQXJyYXkocyl9aXNCZXR3ZWVuKHQsZSxuKXtpZigwIT09di5pbmRleCh0LGUsbikpcmV0dXJuITE7aWYodC54IT09bi54KXtpZih0Lng8PWUueCYmZS54PD1uLngpcmV0dXJuITA7aWYobi54PD1lLngmJmUueDw9dC54KXJldHVybiEwfWlmKHQueSE9PW4ueSl7aWYodC55PD1lLnkmJmUueTw9bi55KXJldHVybiEwO2lmKG4ueTw9ZS55JiZlLnk8PXQueSlyZXR1cm4hMH1yZXR1cm4hMX1yZWR1Y2UodCl7Y29uc3QgZT10aGlzLmNvbXB1dGVPY3RSaW5nKHQpO2lmKG51bGw9PT1lKXJldHVybiB0O2NvbnN0IG49bmV3IGF0O2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKW4uYWRkKGVbdF0pO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKVdlLmlzSW5SaW5nKHRbc10sZSl8fG4uYWRkKHRbc10pO2NvbnN0IHM9WC50b0Nvb3JkaW5hdGVBcnJheShuKTtyZXR1cm4gcy5sZW5ndGg8Mz90aGlzLnBhZEFycmF5MyhzKTpzfWdldENvbnZleEh1bGwoKXtpZigwPT09dGhpcy5faW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTtpZigxPT09dGhpcy5faW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLl9pbnB1dFB0c1swXSk7aWYoMj09PXRoaXMuX2lucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLl9pbnB1dFB0cyk7bGV0IHQ9dGhpcy5faW5wdXRQdHM7dGhpcy5faW5wdXRQdHMubGVuZ3RoPjUwJiYodD10aGlzLnJlZHVjZSh0aGlzLl9pbnB1dFB0cykpO2NvbnN0IGU9dGhpcy5wcmVTb3J0KHQpLG49dGhpcy5ncmFoYW1TY2FuKGUpLHM9dGhpcy50b0Nvb3JkaW5hdGVBcnJheShuKTtyZXR1cm4gdGhpcy5saW5lT3JQb2x5Z29uKHMpfXBhZEFycmF5Myh0KXtjb25zdCBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKW48dC5sZW5ndGg/ZVtuXT10W25dOmVbbl09dFswXTtyZXR1cm4gZX1jb21wdXRlT2N0UHRzKHQpe2NvbnN0IGU9bmV3IEFycmF5KDgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10WzBdO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKXRbbl0ueDxlWzBdLngmJihlWzBdPXRbbl0pLHRbbl0ueC10W25dLnk8ZVsxXS54LWVbMV0ueSYmKGVbMV09dFtuXSksdFtuXS55PmVbMl0ueSYmKGVbMl09dFtuXSksdFtuXS54K3Rbbl0ueT5lWzNdLngrZVszXS55JiYoZVszXT10W25dKSx0W25dLng+ZVs0XS54JiYoZVs0XT10W25dKSx0W25dLngtdFtuXS55PmVbNV0ueC1lWzVdLnkmJihlWzVdPXRbbl0pLHRbbl0ueTxlWzZdLnkmJihlWzZdPXRbbl0pLHRbbl0ueCt0W25dLnk8ZVs3XS54K2VbN10ueSYmKGVbN109dFtuXSk7cmV0dXJuIGV9dG9Db29yZGluYXRlQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKyspe2NvbnN0IHM9dC5nZXQobik7ZVtuXT1zfXJldHVybiBlfWdyYWhhbVNjYW4odCl7bGV0IGU9bnVsbDtjb25zdCBuPW5ldyBvbjtuLnB1c2godFswXSksbi5wdXNoKHRbMV0pLG4ucHVzaCh0WzJdKTtmb3IobGV0IHM9MztzPHQubGVuZ3RoO3MrKyl7Zm9yKGU9bi5wb3AoKTshbi5lbXB0eSgpJiZ2LmluZGV4KG4ucGVlaygpLGUsdFtzXSk+MDspZT1uLnBvcCgpO24ucHVzaChlKSxuLnB1c2godFtzXSl9cmV0dXJuIG4ucHVzaCh0WzBdKSxufWdldENsYXNzKCl7cmV0dXJuIGFufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBjbntjb25zdHJ1Y3Rvcigpe2NuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHBvbGFyQ29tcGFyZSh0LGUsbil7Y29uc3Qgcz1lLngtdC54LGk9ZS55LXQueSxyPW4ueC10Lngsbz1uLnktdC55LGw9di5pbmRleCh0LGUsbik7aWYobD09PXYuQ09VTlRFUkNMT0NLV0lTRSlyZXR1cm4gMTtpZihsPT09di5DTE9DS1dJU0UpcmV0dXJuLTE7Y29uc3QgYT1zKnMraSppLGM9cipyK28qbztyZXR1cm4gYTxjPy0xOmE+Yz8xOjB9Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7cmV0dXJuIGNuLnBvbGFyQ29tcGFyZSh0aGlzLl9vcmlnaW4sbixzKX1nZXRDbGFzcygpe3JldHVybiBjbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fWNuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX29yaWdpbj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX29yaWdpbj10fSxhbi5SYWRpYWxDb21wYXJhdG9yPWNuLGFuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5faW5wdXRQdHM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07YW4uY29uc3RydWN0b3JfLmNhbGwodGhpcyxhbi5leHRyYWN0Q29vcmRpbmF0ZXModCksdC5nZXRGYWN0b3J5KCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0UHRzPWxuLmZpbHRlckNvb3JkaW5hdGVzKHQpLHRoaXMuX2dlb21GYWN0b3J5PWV9fTtjbGFzcyBobntjb25zdHJ1Y3Rvcigpe2huLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNlbnRyZSh0KXtyZXR1cm4gbmV3IGcoaG4uYXZnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WCgpKSxobi5hdmcodC5nZXRNaW5ZKCksdC5nZXRNYXhZKCkpKX1zdGF0aWMgYXZnKHQsZSl7cmV0dXJuKHQrZSkvMn1hZGRQb2x5Z29uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2xldCBlPW51bGwsbj1udWxsO2NvbnN0IHM9dGhpcy5ob3Jpem9udGFsQmlzZWN0b3IodCk7aWYoMD09PXMuZ2V0TGVuZ3RoKCkpbj0wLGU9cy5nZXRDb29yZGluYXRlKCk7ZWxzZXtjb25zdCBpPXMuaW50ZXJzZWN0aW9uKHQpLHI9dGhpcy53aWRlc3RHZW9tZXRyeShpKTtuPXIuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCksZT1obi5jZW50cmUoci5nZXRFbnZlbG9wZUludGVybmFsKCkpfShudWxsPT09dGhpcy5faW50ZXJpb3JQb2ludHx8bj50aGlzLl9tYXhXaWR0aCkmJih0aGlzLl9pbnRlcmlvclBvaW50PWUsdGhpcy5fbWF4V2lkdGg9bil9Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fXdpZGVzdEdlb21ldHJ5KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIHQ7bGV0IGU9dC5nZXRHZW9tZXRyeU4oMCk7Zm9yKGxldCBuPTE7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspdC5nZXRHZW9tZXRyeU4obikuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCk+ZS5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKSYmKGU9dC5nZXRHZW9tZXRyeU4obikpO3JldHVybiBlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQgaW5zdGFuY2VvZiBfdD90aGlzLndpZGVzdEdlb21ldHJ5KHQpOnR9fWhvcml6b250YWxCaXNlY3Rvcih0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG49dW4uZ2V0QmlzZWN0b3JZKHQpO3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBnKGUuZ2V0TWluWCgpLG4pLG5ldyBnKGUuZ2V0TWF4WCgpLG4pXSl9YWRkKHQpe2lmKHQgaW5zdGFuY2VvZiBidCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgX3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5Tih0KSl9fWdldENsYXNzKCl7cmV0dXJuIGhufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyB1bntjb25zdHJ1Y3Rvcigpe3VuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldEJpc2VjdG9yWSh0KXtyZXR1cm4gbmV3IHVuKHQpLmdldEJpc2VjdG9yWSgpfXVwZGF0ZUludGVydmFsKHQpe3Q8PXRoaXMuX2NlbnRyZVk/dD50aGlzLl9sb1kmJih0aGlzLl9sb1k9dCk6dD50aGlzLl9jZW50cmVZJiZ0PHRoaXMuX2hpWSYmKHRoaXMuX2hpWT10KX1nZXRCaXNlY3RvclkoKXt0aGlzLnByb2Nlc3ModGhpcy5fcG9seS5nZXRFeHRlcmlvclJpbmcoKSk7Zm9yKGxldCB0PTA7dDx0aGlzLl9wb2x5LmdldE51bUludGVyaW9yUmluZygpO3QrKyl0aGlzLnByb2Nlc3ModGhpcy5fcG9seS5nZXRJbnRlcmlvclJpbmdOKHQpKTtyZXR1cm4gaG4uYXZnKHRoaXMuX2hpWSx0aGlzLl9sb1kpfXByb2Nlc3ModCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBuPWUuZ2V0WSh0KTt0aGlzLnVwZGF0ZUludGVydmFsKG4pfX1nZXRDbGFzcygpe3JldHVybiB1bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcG9seT1udWxsLHRoaXMuX2NlbnRyZVk9bnVsbCx0aGlzLl9oaVk9aS5NQVhfVkFMVUUsdGhpcy5fbG9ZPS1pLk1BWF9WQUxVRTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wb2x5PXQsdGhpcy5faGlZPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldE1heFkoKSx0aGlzLl9sb1k9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWluWSgpLHRoaXMuX2NlbnRyZVk9aG4uYXZnKHRoaXMuX2xvWSx0aGlzLl9oaVkpfSxobi5TYWZlQmlzZWN0b3JGaW5kZXI9dW4saG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbCx0aGlzLl9tYXhXaWR0aD0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksdGhpcy5hZGQodCl9O2NsYXNzIGdue2NvbnN0cnVjdG9yKCl7Z24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGRFbmRwb2ludHMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZEVuZHBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIF90KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGRFbmRwb2ludHMoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHRbMF0pLHRoaXMuYWRkKHRbdC5sZW5ndGgtMV0pfX1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9YWRkSW50ZXJpb3IoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZEludGVyaW9yKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgX3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZEludGVyaW9yKGUuZ2V0R2VvbWV0cnlOKHQpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoLTE7ZSsrKXRoaXMuYWRkKHRbZV0pfX1hZGQodCl7Y29uc3QgZT10LmRpc3RhbmNlKHRoaXMuX2NlbnRyb2lkKTtlPHRoaXMuX21pbkRpc3RhbmNlJiYodGhpcy5faW50ZXJpb3JQb2ludD1uZXcgZyh0KSx0aGlzLl9taW5EaXN0YW5jZT1lKX1nZXRDbGFzcygpe3JldHVybiBnbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Z24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY2VudHJvaWQ9bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1pLk1BWF9WQUxVRSx0aGlzLl9pbnRlcmlvclBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5pc0VtcHR5KCk/dGhpcy5fY2VudHJvaWQ9bmV3IGc6dGhpcy5fY2VudHJvaWQ9c24uZ2V0Q2VudHJvaWQodCksdGhpcy5hZGRJbnRlcmlvcih0KSxudWxsPT09dGhpcy5faW50ZXJpb3JQb2ludCYmdGhpcy5hZGRFbmRwb2ludHModCl9O2NsYXNzIGRue2NvbnN0cnVjdG9yKCl7ZG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGQodC5nZXRDb29yZGluYXRlKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIF90KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LmRpc3RhbmNlKHRoaXMuX2NlbnRyb2lkKTtlPHRoaXMuX21pbkRpc3RhbmNlJiYodGhpcy5faW50ZXJpb3JQb2ludD1uZXcgZyh0KSx0aGlzLl9taW5EaXN0YW5jZT1lKX19Z2V0Q2xhc3MoKXtyZXR1cm4gZG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWRuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2NlbnRyb2lkPW51bGwsdGhpcy5fbWluRGlzdGFuY2U9aS5NQVhfVkFMVUUsdGhpcy5faW50ZXJpb3JQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NlbnRyb2lkPXQuZ2V0Q2VudHJvaWQoKS5nZXRDb29yZGluYXRlKCksdGhpcy5hZGQodCl9O2NsYXNzIF9ue2NvbnN0cnVjdG9yKCl7X24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1sb2NhdGVJblBvbHlnb25SaW5nKHQsZSl7cmV0dXJuIGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/V2UubG9jYXRlSW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKTpuZS5FWFRFUklPUn1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRlKHQsZSkhPT1uZS5FWFRFUklPUn11cGRhdGVMb2NhdGlvbkluZm8odCl7dD09PW5lLklOVEVSSU9SJiYodGhpcy5faXNJbj0hMCksdD09PW5lLkJPVU5EQVJZJiZ0aGlzLl9udW1Cb3VuZGFyaWVzKyt9Y29tcHV0ZUxvY2F0aW9uKHQsZSl7aWYoZSBpbnN0YW5jZW9mIFB0JiZ0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uUG9pbnQodCxlKSksZSBpbnN0YW5jZW9mIFR0KXRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlT25MaW5lU3RyaW5nKHQsZSkpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIGJ0KXRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW5Qb2x5Z29uKHQsZSkpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIGZ0KXtjb25zdCBuPWU7Zm9yKGxldCBlPTA7ZTxuLmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9bi5nZXRHZW9tZXRyeU4oZSk7dGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVPbkxpbmVTdHJpbmcodCxzKSl9fWVsc2UgaWYoZSBpbnN0YW5jZW9mIEF0KXtjb25zdCBuPWU7Zm9yKGxldCBlPTA7ZTxuLmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9bi5nZXRHZW9tZXRyeU4oZSk7dGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJblBvbHlnb24odCxzKSl9fWVsc2UgaWYoZSBpbnN0YW5jZW9mIF90KXtjb25zdCBuPW5ldyBLZShlKTtmb3IoO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzIT09ZSYmdGhpcy5jb21wdXRlTG9jYXRpb24odCxzKX19fWxvY2F0ZU9uUG9pbnQodCxlKXtyZXR1cm4gZS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodCk/bmUuSU5URVJJT1I6bmUuRVhURVJJT1J9bG9jYXRlT25MaW5lU3RyaW5nKHQsZSl7aWYoIWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCkpcmV0dXJuIG5lLkVYVEVSSU9SO2NvbnN0IG49ZS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtyZXR1cm4gZS5pc0Nsb3NlZCgpfHwhdC5lcXVhbHMobi5nZXRDb29yZGluYXRlKDApKSYmIXQuZXF1YWxzKG4uZ2V0Q29vcmRpbmF0ZShuLnNpemUoKS0xKSk/V2UuaXNPbkxpbmUodCxuKT9uZS5JTlRFUklPUjpuZS5FWFRFUklPUjpuZS5CT1VOREFSWX1sb2NhdGVJblBvbHlnb24odCxlKXtpZihlLmlzRW1wdHkoKSlyZXR1cm4gbmUuRVhURVJJT1I7Y29uc3Qgbj1lLmdldEV4dGVyaW9yUmluZygpLHM9dGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHQsbik7aWYocz09PW5lLkVYVEVSSU9SKXJldHVybiBuZS5FWFRFUklPUjtpZihzPT09bmUuQk9VTkRBUlkpcmV0dXJuIG5lLkJPVU5EQVJZO2ZvcihsZXQgbj0wO248ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtuKyspe2NvbnN0IHM9ZS5nZXRJbnRlcmlvclJpbmdOKG4pLGk9dGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHQscyk7aWYoaT09PW5lLklOVEVSSU9SKXJldHVybiBuZS5FWFRFUklPUjtpZihpPT09bmUuQk9VTkRBUlkpcmV0dXJuIG5lLkJPVU5EQVJZfXJldHVybiBuZS5JTlRFUklPUn1sb2NhdGUodCxlKXtyZXR1cm4gZS5pc0VtcHR5KCk/bmUuRVhURVJJT1I6ZSBpbnN0YW5jZW9mIFR0P3RoaXMubG9jYXRlT25MaW5lU3RyaW5nKHQsZSk6ZSBpbnN0YW5jZW9mIGJ0P3RoaXMubG9jYXRlSW5Qb2x5Z29uKHQsZSk6KHRoaXMuX2lzSW49ITEsdGhpcy5fbnVtQm91bmRhcmllcz0wLHRoaXMuY29tcHV0ZUxvY2F0aW9uKHQsZSksdGhpcy5fYm91bmRhcnlSdWxlLmlzSW5Cb3VuZGFyeSh0aGlzLl9udW1Cb3VuZGFyaWVzKT9uZS5CT1VOREFSWTp0aGlzLl9udW1Cb3VuZGFyaWVzPjB8fHRoaXMuX2lzSW4/bmUuSU5URVJJT1I6bmUuRVhURVJJT1IpfWdldENsYXNzKCl7cmV0dXJuIF9ufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1fbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9ib3VuZGFyeVJ1bGU9Vi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUsdGhpcy5faXNJbj1udWxsLHRoaXMuX251bUJvdW5kYXJpZXM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpdGhyb3cgbmV3IG4oXCJSdWxlIG11c3QgYmUgbm9uLW51bGxcIik7dGhpcy5fYm91bmRhcnlSdWxlPXR9fTtjbGFzcyBmbntjb25zdHJ1Y3Rvcigpe2ZuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHBvaW50V2l0TWluQW5nbGVXaXRoWCh0LGUpe2xldCBuPWkuTUFYX1ZBTFVFLHM9bnVsbDtmb3IobGV0IGk9MDtpPHQubGVuZ3RoO2krKyl7Y29uc3Qgcj10W2ldO2lmKHI9PT1lKWNvbnRpbnVlO2NvbnN0IG89ci54LWUueDtsZXQgbD1yLnktZS55O2w8MCYmKGw9LWwpO2NvbnN0IGE9bC9NYXRoLnNxcnQobypvK2wqbCk7YTxuJiYobj1hLHM9cil9cmV0dXJuIHN9c3RhdGljIGxvd2VzdFBvaW50KHQpe2xldCBlPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspdFtuXS55PGUueSYmKGU9dFtuXSk7cmV0dXJuIGV9c3RhdGljIHBvaW50V2l0aE1pbkFuZ2xlV2l0aFNlZ21lbnQodCxlLG4pe2xldCBzPWkuTUFYX1ZBTFVFLHI9bnVsbDtmb3IobGV0IGk9MDtpPHQubGVuZ3RoO2krKyl7Y29uc3Qgbz10W2ldO2lmKG89PT1lKWNvbnRpbnVlO2lmKG89PT1uKWNvbnRpbnVlO2NvbnN0IGw9aWUuYW5nbGVCZXR3ZWVuKGUsbyxuKTtsPHMmJihzPWwscj1vKX1yZXR1cm4gcn1nZXRSYWRpdXMoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5fcmFkaXVzfWdldERpYW1ldGVyKCl7c3dpdGNoKHRoaXMuY29tcHV0ZSgpLHRoaXMuX2V4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMTpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX2NlbnRyZSl9Y29uc3QgdD10aGlzLl9leHRyZW1hbFB0c1swXSxlPXRoaXMuX2V4dHJlbWFsUHRzWzFdO3JldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCxlXSl9Z2V0RXh0cmVtYWxQb2ludHMoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5fZXh0cmVtYWxQdHN9Y29tcHV0ZUNpcmNsZVBvaW50cygpe2lmKHRoaXMuX2lucHV0LmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9bmV3IEFycmF5KDApLmZpbGwobnVsbCksbnVsbDtpZigxPT09dGhpcy5faW5wdXQuZ2V0TnVtUG9pbnRzKCkpe2NvbnN0IHQ9dGhpcy5faW5wdXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9W25ldyBnKHRbMF0pXSxudWxsfWNvbnN0IHQ9dGhpcy5faW5wdXQuY29udmV4SHVsbCgpLmdldENvb3JkaW5hdGVzKCk7bGV0IGU9dDtpZih0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pJiYoZT1uZXcgQXJyYXkodC5sZW5ndGgtMSkuZmlsbChudWxsKSxYLmNvcHlEZWVwKHQsMCxlLDAsdC5sZW5ndGgtMSkpLGUubGVuZ3RoPD0yKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1YLmNvcHlEZWVwKGUpLG51bGw7bGV0IG49Zm4ubG93ZXN0UG9pbnQoZSkscz1mbi5wb2ludFdpdE1pbkFuZ2xlV2l0aFgoZSxuKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3QgdD1mbi5wb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50KGUsbixzKTtpZihpZS5pc09idHVzZShuLHQscykpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVtuZXcgZyhuKSxuZXcgZyhzKV0sbnVsbDtpZihpZS5pc09idHVzZSh0LG4scykpbj10O2Vsc2V7aWYoIWllLmlzT2J0dXNlKHQscyxuKSlyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9W25ldyBnKG4pLG5ldyBnKHMpLG5ldyBnKHQpXSxudWxsO3M9dH19dS5zaG91bGROZXZlclJlYWNoSGVyZShcIkxvZ2ljIGZhaWx1cmUgaW4gTWluaW11bSBCb3VuZGluZyBDaXJjbGUgYWxnb3JpdGhtIVwiKX1jb21wdXRlKCl7aWYobnVsbCE9PXRoaXMuX2V4dHJlbWFsUHRzKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUNpcmNsZVBvaW50cygpLHRoaXMuY29tcHV0ZUNlbnRyZSgpLG51bGwhPT10aGlzLl9jZW50cmUmJih0aGlzLl9yYWRpdXM9dGhpcy5fY2VudHJlLmRpc3RhbmNlKHRoaXMuX2V4dHJlbWFsUHRzWzBdKSl9Z2V0RmFydGhlc3RQb2ludHMoKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKX1jb25zdCB0PXRoaXMuX2V4dHJlbWFsUHRzWzBdLGU9dGhpcy5fZXh0cmVtYWxQdHNbdGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoLTFdO3JldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCxlXSl9Z2V0Q2lyY2xlKCl7aWYodGhpcy5jb21wdXRlKCksbnVsbD09PXRoaXMuX2NlbnRyZSlyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24oKTtjb25zdCB0PXRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpO3JldHVybiAwPT09dGhpcy5fcmFkaXVzP3Q6dC5idWZmZXIodGhpcy5fcmFkaXVzKX1nZXRDZW50cmUoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5fY2VudHJlfWNvbXB1dGVDZW50cmUoKXtzd2l0Y2godGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6dGhpcy5fY2VudHJlPW51bGw7YnJlYWs7Y2FzZSAxOnRoaXMuX2NlbnRyZT10aGlzLl9leHRyZW1hbFB0c1swXTticmVhaztjYXNlIDI6dGhpcy5fY2VudHJlPW5ldyBnKCh0aGlzLl9leHRyZW1hbFB0c1swXS54K3RoaXMuX2V4dHJlbWFsUHRzWzFdLngpLzIsKHRoaXMuX2V4dHJlbWFsUHRzWzBdLnkrdGhpcy5fZXh0cmVtYWxQdHNbMV0ueSkvMik7YnJlYWs7Y2FzZSAzOnRoaXMuX2NlbnRyZT1yZS5jaXJjdW1jZW50cmUodGhpcy5fZXh0cmVtYWxQdHNbMF0sdGhpcy5fZXh0cmVtYWxQdHNbMV0sdGhpcy5fZXh0cmVtYWxQdHNbMl0pfX1nZXRDbGFzcygpe3JldHVybiBmbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Zm4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXQ9bnVsbCx0aGlzLl9leHRyZW1hbFB0cz1udWxsLHRoaXMuX2NlbnRyZT1udWxsLHRoaXMuX3JhZGl1cz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0PXR9O2NsYXNzIHBue2NvbnN0cnVjdG9yKCl7cG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbmV4dEluZGV4KHQsZSl7cmV0dXJuKytlPj10Lmxlbmd0aCYmKGU9MCksZX1zdGF0aWMgY29tcHV0ZUModCxlLG4pe3JldHVybiB0Km4ueS1lKm4ueH1zdGF0aWMgZ2V0TWluaW11bURpYW1ldGVyKHQpe3JldHVybiBuZXcgcG4odCkuZ2V0RGlhbWV0ZXIoKX1zdGF0aWMgZ2V0TWluaW11bVJlY3RhbmdsZSh0KXtyZXR1cm4gbmV3IHBuKHQpLmdldE1pbmltdW1SZWN0YW5nbGUoKX1zdGF0aWMgY29tcHV0ZVNlZ21lbnRGb3JMaW5lKHQsZSxuKXtsZXQgcz1udWxsLGk9bnVsbDtyZXR1cm4gTWF0aC5hYnMoZSk+TWF0aC5hYnModCk/KHM9bmV3IGcoMCxuL2UpLGk9bmV3IGcoMSxuL2UtdC9lKSk6KHM9bmV3IGcobi90LDApLGk9bmV3IGcobi90LWUvdCwxKSksbmV3IGVlKHMsaSl9Z2V0V2lkdGhDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMuX21pbldpZHRoUHR9Z2V0U3VwcG9ydGluZ1NlZ21lbnQoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLl9taW5CYXNlU2VnLnAwLHRoaXMuX21pbkJhc2VTZWcucDFdKX1nZXREaWFtZXRlcigpe2lmKHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLG51bGw9PT10aGlzLl9taW5XaWR0aFB0KXJldHVybiB0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjb25zdCB0PXRoaXMuX21pbkJhc2VTZWcucHJvamVjdCh0aGlzLl9taW5XaWR0aFB0KTtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LHRoaXMuX21pbldpZHRoUHRdKX1jb21wdXRlV2lkdGhDb252ZXgodCl7dGhpcy5fY29udmV4SHVsbFB0cz10IGluc3RhbmNlb2YgYnQ/dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpOnQuZ2V0Q29vcmRpbmF0ZXMoKSwwPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMuX21pbldpZHRoPTAsdGhpcy5fbWluV2lkdGhQdD1udWxsLHRoaXMuX21pbkJhc2VTZWc9bnVsbCk6MT09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLl9taW5XaWR0aD0wLHRoaXMuX21pbldpZHRoUHQ9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAwPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMT10aGlzLl9jb252ZXhIdWxsUHRzWzBdKToyPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGh8fDM9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5fbWluV2lkdGg9MCx0aGlzLl9taW5XaWR0aFB0PXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDE9dGhpcy5fY29udmV4SHVsbFB0c1sxXSk6dGhpcy5jb21wdXRlQ29udmV4UmluZ01pbkRpYW1ldGVyKHRoaXMuX2NvbnZleEh1bGxQdHMpfWNvbXB1dGVDb252ZXhSaW5nTWluRGlhbWV0ZXIodCl7dGhpcy5fbWluV2lkdGg9aS5NQVhfVkFMVUU7bGV0IGU9MTtjb25zdCBuPW5ldyBlZTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoLTE7cysrKW4ucDA9dFtzXSxuLnAxPXRbcysxXSxlPXRoaXMuZmluZE1heFBlcnBEaXN0YW5jZSh0LG4sZSl9Y29tcHV0ZU1pbmltdW1EaWFtZXRlcigpe2lmKG51bGwhPT10aGlzLl9taW5XaWR0aFB0KXJldHVybiBudWxsO2lmKHRoaXMuX2lzQ29udmV4KXRoaXMuY29tcHV0ZVdpZHRoQ29udmV4KHRoaXMuX2lucHV0R2VvbSk7ZWxzZXtjb25zdCB0PW5ldyBhbih0aGlzLl9pbnB1dEdlb20pLmdldENvbnZleEh1bGwoKTt0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0KX19Z2V0TGVuZ3RoKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMuX21pbldpZHRofWZpbmRNYXhQZXJwRGlzdGFuY2UodCxlLG4pe2xldCBzPWUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHRbbl0pLGk9cyxyPW4sbz1yO2Zvcig7aT49czspcz1pLHI9byxvPXBuLm5leHRJbmRleCh0LHIpLGk9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtvXSk7cmV0dXJuIHM8dGhpcy5fbWluV2lkdGgmJih0aGlzLl9taW5QdEluZGV4PXIsdGhpcy5fbWluV2lkdGg9cyx0aGlzLl9taW5XaWR0aFB0PXRbdGhpcy5fbWluUHRJbmRleF0sdGhpcy5fbWluQmFzZVNlZz1uZXcgZWUoZSkpLHJ9Z2V0TWluaW11bVJlY3RhbmdsZSgpe2lmKHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLDA9PT10aGlzLl9taW5XaWR0aClyZXR1cm4gdGhpcy5fbWluQmFzZVNlZy5wMC5lcXVhbHMyRCh0aGlzLl9taW5CYXNlU2VnLnAxKT90aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX21pbkJhc2VTZWcucDApOnRoaXMuX21pbkJhc2VTZWcudG9HZW9tZXRyeSh0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpKTtjb25zdCB0PXRoaXMuX21pbkJhc2VTZWcucDEueC10aGlzLl9taW5CYXNlU2VnLnAwLngsZT10aGlzLl9taW5CYXNlU2VnLnAxLnktdGhpcy5fbWluQmFzZVNlZy5wMC55O2xldCBuPWkuTUFYX1ZBTFVFLHM9LWkuTUFYX1ZBTFVFLHI9aS5NQVhfVkFMVUUsbz0taS5NQVhfVkFMVUU7Zm9yKGxldCBpPTA7aTx0aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aDtpKyspe2NvbnN0IGw9cG4uY29tcHV0ZUModCxlLHRoaXMuX2NvbnZleEh1bGxQdHNbaV0pO2w+cyYmKHM9bCksbDxuJiYobj1sKTtjb25zdCBhPXBuLmNvbXB1dGVDKC1lLHQsdGhpcy5fY29udmV4SHVsbFB0c1tpXSk7YT5vJiYobz1hKSxhPHImJihyPWEpfWNvbnN0IGw9cG4uY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC10LC1lLG8pLGE9cG4uY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC10LC1lLHIpLGM9cG4uY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC1lLHQscyksaD1wbi5jb21wdXRlU2VnbWVudEZvckxpbmUoLWUsdCxuKSx1PWMubGluZUludGVyc2VjdGlvbihsKSxnPWgubGluZUludGVyc2VjdGlvbihsKSxkPWgubGluZUludGVyc2VjdGlvbihhKSxfPWMubGluZUludGVyc2VjdGlvbihhKSxmPXRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhbdSxnLGQsXyx1XSk7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbihmKX1nZXRDbGFzcygpe3JldHVybiBwbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5faXNDb252ZXg9bnVsbCx0aGlzLl9jb252ZXhIdWxsUHRzPW51bGwsdGhpcy5fbWluQmFzZVNlZz1uZXcgZWUsdGhpcy5fbWluV2lkdGhQdD1udWxsLHRoaXMuX21pblB0SW5kZXg9bnVsbCx0aGlzLl9taW5XaWR0aD0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtwbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsITEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2lzQ29udmV4PWV9fTt2YXIgbW49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGlzdGFuY2U6RGUsbG9jYXRlOlFlLG1hdGNoOm5uLEFuZ2xlOmllLEFyZWE6dnQsQ2VudHJvaWQ6c24sQ29udmV4SHVsbDphbixEaXN0YW5jZTpELEludGVyaW9yUG9pbnRBcmVhOmhuLEludGVyaW9yUG9pbnRMaW5lOmduLEludGVyaW9yUG9pbnRQb2ludDpkbixMZW5ndGg6eXQsT3JpZW50YXRpb246dixQb2ludExvY2F0aW9uOldlLFBvaW50TG9jYXRvcjpfbixSb2J1c3RMaW5lSW50ZXJzZWN0b3I6dGUsTWluaW11bUJvdW5kaW5nQ2lyY2xlOmZuLE1pbmltdW1EaWFtZXRlcjpwbn0pO2NsYXNzIHlue2NvbnN0cnVjdG9yKCl7eW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGVuc2lmeVBvaW50cyh0LGUsbil7Y29uc3Qgcz1uZXcgZWUsaT1uZXcgSTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoLTE7cisrKXtzLnAwPXRbcl0scy5wMT10W3IrMV0saS5hZGQocy5wMCwhMSk7Y29uc3Qgbz1zLmdldExlbmd0aCgpLGw9TWF0aC50cnVuYyhvL2UpKzE7aWYobD4xKXtjb25zdCB0PW8vbDtmb3IobGV0IGU9MTtlPGw7ZSsrKXtjb25zdCByPWUqdC9vLGw9cy5wb2ludEFsb25nKHIpO24ubWFrZVByZWNpc2UobCksaS5hZGQobCwhMSl9fX1yZXR1cm4gaS5hZGQodFt0Lmxlbmd0aC0xXSwhMSksaS50b0Nvb3JkaW5hdGVBcnJheSgpfXN0YXRpYyBkZW5zaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgeW4odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfWdldFJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIG5ldyB4bih0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDw9MCl0aHJvdyBuZXcgbihcIlRvbGVyYW5jZSBtdXN0IGJlIHBvc2l0aXZlXCIpO3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9Z2V0Q2xhc3MoKXtyZXR1cm4geW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHhuIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLHhuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBBdD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IHM9eW4uZGVuc2lmeVBvaW50cyhuLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UsZS5nZXRQcmVjaXNpb25Nb2RlbCgpKTtyZXR1cm4gZSBpbnN0YW5jZW9mIFR0JiYxPT09cy5sZW5ndGgmJihzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9Y3JlYXRlVmFsaWRBcmVhKHQpe3JldHVybiB0LmJ1ZmZlcigwKX1nZXRDbGFzcygpe3JldHVybiB4bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0seW4uRGVuc2lmeVRyYW5zZm9ybWVyPXhuLHluLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9O3ZhciBFbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEZW5zaWZpZXI6eW59KTtjbGFzcyBJbntjb25zdHJ1Y3Rvcigpe0luLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzTm9ydGhlcm4odCl7cmV0dXJuIHQ9PT1Jbi5ORXx8dD09PUluLk5XfXN0YXRpYyBpc09wcG9zaXRlKHQsZSl7aWYodD09PWUpcmV0dXJuITE7cmV0dXJuIDI9PT0odC1lKzQpJTR9c3RhdGljIGNvbW1vbkhhbGZQbGFuZSh0LGUpe2lmKHQ9PT1lKXJldHVybiB0O2lmKDI9PT0odC1lKzQpJTQpcmV0dXJuLTE7Y29uc3Qgbj10PGU/dDplO3JldHVybiAwPT09biYmMz09PSh0PmU/dDplKT8zOm59c3RhdGljIGlzSW5IYWxmUGxhbmUodCxlKXtyZXR1cm4gZT09PUluLlNFP3Q9PT1Jbi5TRXx8dD09PUluLlNXOnQ9PT1lfHx0PT09ZSsxfXN0YXRpYyBxdWFkcmFudCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgbihcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7cmV0dXJuIHQ+PTA/ZT49MD9Jbi5ORTpJbi5TRTplPj0wP0luLk5XOkluLlNXfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihlLng9PT10LngmJmUueT09PXQueSl0aHJvdyBuZXcgbihcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgXCIrdCk7cmV0dXJuIGUueD49dC54P2UueT49dC55P0luLk5FOkluLlNFOmUueT49dC55P0luLk5XOkluLlNXfX1nZXRDbGFzcygpe3JldHVybiBJbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxJbi5ORT0wLEluLk5XPTEsSW4uU1c9MixJbi5TRT0zO2NsYXNzIE5ue2NvbnN0cnVjdG9yKCl7Tm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW5pdCh0LGUpe2lmKG51bGwhPT10Ll9zeW18fG51bGwhPT1lLl9zeW18fG51bGwhPT10Ll9uZXh0fHxudWxsIT09ZS5fbmV4dCl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiRWRnZXMgYXJlIGFscmVhZHkgaW5pdGlhbGl6ZWRcIik7cmV0dXJuIHQuaW5pdChlKSx0fXN0YXRpYyBjcmVhdGUodCxlKXtjb25zdCBuPW5ldyBObih0KSxzPW5ldyBObihlKTtyZXR1cm4gbi5pbml0KHMpLG59ZmluZCh0KXtsZXQgZT10aGlzO2Rve2lmKG51bGw9PT1lKXJldHVybiBudWxsO2lmKGUuZGVzdCgpLmVxdWFsczJEKHQpKXJldHVybiBlO2U9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gbnVsbH1kZXN0KCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZ31vTmV4dCgpe3JldHVybiB0aGlzLl9zeW0uX25leHR9aW5zZXJ0KHQpe2lmKHRoaXMub05leHQoKT09PXRoaXMpcmV0dXJuIHRoaXMuaW5zZXJ0QWZ0ZXIodCksbnVsbDtjb25zdCBlPXRoaXMuY29tcGFyZVRvKHQpO2xldCBuPXRoaXM7ZG97Y29uc3Qgcz1uLm9OZXh0KCk7aWYocy5jb21wYXJlVG8odCkhPT1lfHxzPT09dGhpcylyZXR1cm4gbi5pbnNlcnRBZnRlcih0KSxudWxsO249c313aGlsZShuIT09dGhpcyk7dS5zaG91bGROZXZlclJlYWNoSGVyZSgpfWluc2VydEFmdGVyKHQpe3UuZXF1YWxzKHRoaXMuX29yaWcsdC5vcmlnKCkpO2NvbnN0IGU9dGhpcy5vTmV4dCgpO3RoaXMuX3N5bS5zZXROZXh0KHQpLHQuc3ltKCkuc2V0TmV4dChlKX1kZWdyZWUoKXtsZXQgdD0wLGU9dGhpcztkb3t0KyssZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiB0fWVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX29yaWcuZXF1YWxzMkQodCkmJnRoaXMuX3N5bS5fb3JpZy5lcXVhbHMoZSl9fWRlbHRhWSgpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueS10aGlzLl9vcmlnLnl9c3ltKCl7cmV0dXJuIHRoaXMuX3N5bX1wcmV2KCl7cmV0dXJuIHRoaXMuX3N5bS5uZXh0KCkuX3N5bX1jb21wYXJlQW5ndWxhckRpcmVjdGlvbih0KXtjb25zdCBlPXRoaXMuZGVsdGFYKCksbj10aGlzLmRlbHRhWSgpLHM9dC5kZWx0YVgoKSxpPXQuZGVsdGFZKCk7aWYoZT09PXMmJm49PT1pKXJldHVybiAwO2NvbnN0IHI9SW4ucXVhZHJhbnQoZSxuKSxvPUluLnF1YWRyYW50KHMsaSk7cmV0dXJuIHI+bz8xOnI8bz8tMTp2LmluZGV4KHQuX29yaWcsdC5kZXN0KCksdGhpcy5kZXN0KCkpfXByZXZOb2RlKCl7bGV0IHQ9dGhpcztmb3IoOzI9PT10LmRlZ3JlZSgpOylpZih0PXQucHJldigpLHQ9PT10aGlzKXJldHVybiBudWxsO3JldHVybiB0fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZUFuZ3VsYXJEaXJlY3Rpb24oZSl9bmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fXNldFN5bSh0KXt0aGlzLl9zeW09dH1vcmlnKCl7cmV0dXJuIHRoaXMuX29yaWd9dG9TdHJpbmcoKXtyZXR1cm5cIkhFKFwiK3RoaXMuX29yaWcueCtcIiBcIit0aGlzLl9vcmlnLnkrXCIsIFwiK3RoaXMuX3N5bS5fb3JpZy54K1wiIFwiK3RoaXMuX3N5bS5fb3JpZy55K1wiKVwifXNldE5leHQodCl7dGhpcy5fbmV4dD10fWluaXQodCl7dGhpcy5zZXRTeW0odCksdC5zZXRTeW0odGhpcyksdGhpcy5zZXROZXh0KHQpLHQuc2V0TmV4dCh0aGlzKX1kZWx0YVgoKXtyZXR1cm4gdGhpcy5fc3ltLl9vcmlnLngtdGhpcy5fb3JpZy54fWdldENsYXNzKCl7cmV0dXJuIE5ufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Obi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9vcmlnPW51bGwsdGhpcy5fc3ltPW51bGwsdGhpcy5fbmV4dD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX29yaWc9dH07Y2xhc3MgQ24gZXh0ZW5kcyBObntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQ24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2V0TWFya0JvdGgodCxlKXt0LnNldE1hcmsoZSksdC5zeW0oKS5zZXRNYXJrKGUpfXN0YXRpYyBpc01hcmtlZCh0KXtyZXR1cm4gdC5pc01hcmtlZCgpfXN0YXRpYyBzZXRNYXJrKHQsZSl7dC5zZXRNYXJrKGUpfXN0YXRpYyBtYXJrQm90aCh0KXt0Lm1hcmsoKSx0LnN5bSgpLm1hcmsoKX1zdGF0aWMgbWFyayh0KXt0Lm1hcmsoKX1tYXJrKCl7dGhpcy5faXNNYXJrZWQ9ITB9c2V0TWFyayh0KXt0aGlzLl9pc01hcmtlZD10fWlzTWFya2VkKCl7cmV0dXJuIHRoaXMuX2lzTWFya2VkfWdldENsYXNzKCl7cmV0dXJuIENufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Dbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc01hcmtlZD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTtObi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfTtjbGFzcyBTbntjb25zdHJ1Y3Rvcigpe1NuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzVmFsaWRFZGdlKHQsZSl7cmV0dXJuIDAhPT1lLmNvbXBhcmVUbyh0KX1pbnNlcnQodCxlLG4pe2NvbnN0IHM9dGhpcy5jcmVhdGUodCxlKTtudWxsIT09bj9uLmluc2VydChzKTp0aGlzLl92ZXJ0ZXhNYXAucHV0KHQscyk7Y29uc3QgaT10aGlzLl92ZXJ0ZXhNYXAuZ2V0KGUpO3JldHVybiBudWxsIT09aT9pLmluc2VydChzLnN5bSgpKTp0aGlzLl92ZXJ0ZXhNYXAucHV0KGUscy5zeW0oKSksc31jcmVhdGUodCxlKXtjb25zdCBuPXRoaXMuY3JlYXRlRWRnZSh0KSxzPXRoaXMuY3JlYXRlRWRnZShlKTtyZXR1cm4gTm4uaW5pdChuLHMpLG59Y3JlYXRlRWRnZSh0KXtyZXR1cm4gbmV3IE5uKHQpfWFkZEVkZ2UodCxlKXtpZighU24uaXNWYWxpZEVkZ2UodCxlKSlyZXR1cm4gbnVsbDtjb25zdCBuPXRoaXMuX3ZlcnRleE1hcC5nZXQodCk7bGV0IHM9bnVsbDtpZihudWxsIT09biYmKHM9bi5maW5kKGUpKSxudWxsIT09cylyZXR1cm4gcztyZXR1cm4gdGhpcy5pbnNlcnQodCxlLG4pfWdldFZlcnRleEVkZ2VzKCl7cmV0dXJuIHRoaXMuX3ZlcnRleE1hcC52YWx1ZXMoKX1maW5kRWRnZSh0LGUpe2NvbnN0IG49dGhpcy5fdmVydGV4TWFwLmdldCh0KTtyZXR1cm4gbnVsbD09PW4/bnVsbDpuLmZpbmQoZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gU259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVNuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3ZlcnRleE1hcD1uZXcgVXR9O2NsYXNzIHduIGV4dGVuZHMgQ257Y29uc3RydWN0b3IoKXtzdXBlcigpLHduLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0U3RhcnQoKXt0aGlzLl9pc1N0YXJ0PSEwfWlzU3RhcnQoKXtyZXR1cm4gdGhpcy5faXNTdGFydH1nZXRDbGFzcygpe3JldHVybiB3bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19d24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNTdGFydD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTtDbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfTtjbGFzcyBMbiBleHRlbmRzIFNue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxMbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZUVkZ2UodCl7cmV0dXJuIG5ldyB3bih0KX1nZXRDbGFzcygpe3JldHVybiBMbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBUbntjb25zdHJ1Y3Rvcigpe1RuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRpc3NvbHZlKHQpe2NvbnN0IGU9bmV3IFRuO3JldHVybiBlLmFkZCh0KSxlLmdldFJlc3VsdCgpfWFkZExpbmUodCl7dGhpcy5fbGluZXMuYWRkKHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LnRvQ29vcmRpbmF0ZUFycmF5KCkpKX11cGRhdGVSaW5nU3RhcnRFZGdlKHQpe3JldHVybiB0LmlzU3RhcnQoKXx8KHQ9dC5zeW0oKSkuaXNTdGFydCgpP251bGw9PT10aGlzLl9yaW5nU3RhcnRFZGdlPyh0aGlzLl9yaW5nU3RhcnRFZGdlPXQsbnVsbCk6dm9pZCh0Lm9yaWcoKS5jb21wYXJlVG8odGhpcy5fcmluZ1N0YXJ0RWRnZS5vcmlnKCkpPDAmJih0aGlzLl9yaW5nU3RhcnRFZGdlPXQpKTpudWxsfWdldFJlc3VsdCgpe3JldHVybiBudWxsPT09dGhpcy5fcmVzdWx0JiZ0aGlzLmNvbXB1dGVSZXN1bHQoKSx0aGlzLl9yZXN1bHR9cHJvY2Vzcyh0KXtsZXQgZT10LnByZXZOb2RlKCk7bnVsbD09PWUmJihlPXQpLHRoaXMuc3RhY2tFZGdlcyhlKSx0aGlzLmJ1aWxkTGluZXMoKX1idWlsZFJpbmcodCl7Y29uc3QgZT1uZXcgSTtsZXQgbj10O2ZvcihlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7Y29uc3Qgcz1uLm5leHQoKTtpZihzPT09dClicmVhaztlLmFkZChzLm9yaWcoKS5jb3B5KCksITEpLG49c31lLmFkZChuLmRlc3QoKS5jb3B5KCksITEpLHRoaXMuYWRkTGluZShlKX1idWlsZExpbmUodCl7Y29uc3QgZT1uZXcgSTtsZXQgbj10O2Zvcih0aGlzLl9yaW5nU3RhcnRFZGdlPW51bGwsQ24ubWFya0JvdGgobiksZS5hZGQobi5vcmlnKCkuY29weSgpLCExKTsyPT09bi5zeW0oKS5kZWdyZWUoKTspe3RoaXMudXBkYXRlUmluZ1N0YXJ0RWRnZShuKTtjb25zdCBzPW4ubmV4dCgpO2lmKHM9PT10KXJldHVybiB0aGlzLmJ1aWxkUmluZyh0aGlzLl9yaW5nU3RhcnRFZGdlKSxudWxsO2UuYWRkKHMub3JpZygpLmNvcHkoKSwhMSksbj1zLENuLm1hcmtCb3RoKG4pfWUuYWRkKG4uZGVzdCgpLmNsb25lKCksITEpLHRoaXMuc3RhY2tFZGdlcyhuLnN5bSgpKSx0aGlzLmFkZExpbmUoZSl9c3RhY2tFZGdlcyh0KXtsZXQgZT10O2Rve0NuLmlzTWFya2VkKGUpfHx0aGlzLl9ub2RlRWRnZVN0YWNrLmFkZChlKSxlPWUub05leHQoKX13aGlsZShlIT09dCl9Y29tcHV0ZVJlc3VsdCgpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXRWZXJ0ZXhFZGdlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO0NuLmlzTWFya2VkKGUpfHx0aGlzLnByb2Nlc3MoZSl9dGhpcy5fcmVzdWx0PXRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLl9saW5lcyl9YnVpbGRMaW5lcygpe2Zvcig7IXRoaXMuX25vZGVFZGdlU3RhY2suZW1wdHkoKTspe2NvbnN0IHQ9dGhpcy5fbm9kZUVkZ2VTdGFjay5wb3AoKTtDbi5pc01hcmtlZCh0KXx8dGhpcy5idWlsZExpbmUodCl9fWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7YXJndW1lbnRzWzBdLmFwcGx5KG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR119ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBUdCYmdGhpcy5hZGQodCl9fSl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtsZXQgbj0hMTtmb3IobGV0IHQ9MTt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz10aGlzLl9ncmFwaC5hZGRFZGdlKGUuZ2V0Q29vcmRpbmF0ZSh0LTEpLGUuZ2V0Q29vcmRpbmF0ZSh0KSk7bnVsbCE9PXMmJihufHwocy5zZXRTdGFydCgpLG49ITApKX19fWdldENsYXNzKCl7cmV0dXJuIFRufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ubi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yZXN1bHQ9bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9saW5lcz1uZXcgeCx0aGlzLl9ub2RlRWRnZVN0YWNrPW5ldyBvbix0aGlzLl9yaW5nU3RhcnRFZGdlPW51bGwsdGhpcy5fZ3JhcGg9bmV3IExufTt2YXIgUm49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTGluZURpc3NvbHZlcjpUbn0pO2NsYXNzIFBue2NvbnN0cnVjdG9yKCl7UG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb3Bwb3NpdGUodCl7cmV0dXJuIHQ9PT1Qbi5MRUZUP1BuLlJJR0hUOnQ9PT1Qbi5SSUdIVD9Qbi5MRUZUOnR9Z2V0Q2xhc3MoKXtyZXR1cm4gUG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVBuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sUG4uT049MCxQbi5MRUZUPTEsUG4uUklHSFQ9MjtjbGFzcyB2bntjb25zdHJ1Y3Rvcigpe3ZuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZUludGVyc2VjdGlvbnModCxlKXt0aGlzLm1jZS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuY2hhaW5JbmRleCx0Lm1jZSx0LmNoYWluSW5kZXgsZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gdm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXZuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMubWNlPW51bGwsdGhpcy5jaGFpbkluZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5tY2U9dCx0aGlzLmNoYWluSW5kZXg9ZX07Y2xhc3MgT257Y29uc3RydWN0b3IoKXtPbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzRGVsZXRlKCl7cmV0dXJuIHRoaXMuX2V2ZW50VHlwZT09PU9uLkRFTEVURX1zZXREZWxldGVFdmVudEluZGV4KHQpe3RoaXMuX2RlbGV0ZUV2ZW50SW5kZXg9dH1nZXRPYmplY3QoKXtyZXR1cm4gdGhpcy5fb2JqfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX3hWYWx1ZTxlLl94VmFsdWU/LTE6dGhpcy5feFZhbHVlPmUuX3hWYWx1ZT8xOnRoaXMuX2V2ZW50VHlwZTxlLl9ldmVudFR5cGU/LTE6dGhpcy5fZXZlbnRUeXBlPmUuX2V2ZW50VHlwZT8xOjB9Z2V0SW5zZXJ0RXZlbnQoKXtyZXR1cm4gdGhpcy5faW5zZXJ0RXZlbnR9aXNJbnNlcnQoKXtyZXR1cm4gdGhpcy5fZXZlbnRUeXBlPT09T24uSU5TRVJUfWlzU2FtZUxhYmVsKHQpe3JldHVybiBudWxsIT09dGhpcy5fbGFiZWwmJnRoaXMuX2xhYmVsPT09dC5fbGFiZWx9Z2V0RGVsZXRlRXZlbnRJbmRleCgpe3JldHVybiB0aGlzLl9kZWxldGVFdmVudEluZGV4fWdldENsYXNzKCl7cmV0dXJuIE9ufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19T24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbGFiZWw9bnVsbCx0aGlzLl94VmFsdWU9bnVsbCx0aGlzLl9ldmVudFR5cGU9bnVsbCx0aGlzLl9pbnNlcnRFdmVudD1udWxsLHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXg9bnVsbCx0aGlzLl9vYmo9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZXZlbnRUeXBlPU9uLkRFTEVURSx0aGlzLl94VmFsdWU9dCx0aGlzLl9pbnNlcnRFdmVudD1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2V2ZW50VHlwZT1Pbi5JTlNFUlQsdGhpcy5fbGFiZWw9dCx0aGlzLl94VmFsdWU9ZSx0aGlzLl9vYmo9bn19LE9uLklOU0VSVD0xLE9uLkRFTEVURT0yO2NsYXNzIGJue2NvbnN0cnVjdG9yKCl7Ym4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBibn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Ym4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBNbntjb25zdHJ1Y3Rvcigpe01uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzQWRqYWNlbnRTZWdtZW50cyh0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX1pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl7aWYodD09PW4mJjE9PT10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYoTW4uaXNBZGphY2VudFNlZ21lbnRzKGUscykpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXtjb25zdCBuPXQuZ2V0TnVtUG9pbnRzKCktMTtpZigwPT09ZSYmcz09PW58fDA9PT1zJiZlPT09bilyZXR1cm4hMH19cmV0dXJuITF9Z2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKXtyZXR1cm4gdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnR9c2V0SXNEb25lSWZQcm9wZXJJbnQodCl7dGhpcy5faXNEb25lV2hlblByb3BlckludD10fWhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3BlckludGVyaW9yfWlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCkuZ2V0Q29vcmRpbmF0ZSgpO2lmKHQuaXNJbnRlcnNlY3Rpb24oZSkpcmV0dXJuITB9cmV0dXJuITF9aGFzUHJvcGVySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3Blcn1oYXNJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufWlzRG9uZSgpe3JldHVybiB0aGlzLl9pc0RvbmV9aXNCb3VuZGFyeVBvaW50KHQsZSl7cmV0dXJuIG51bGwhPT1lJiYoISF0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZVswXSl8fCEhdGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMV0pKX1zZXRCb3VuZGFyeU5vZGVzKHQsZSl7dGhpcy5fYmR5Tm9kZXM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fYmR5Tm9kZXNbMF09dCx0aGlzLl9iZHlOb2Rlc1sxXT1lfWFkZEludGVyc2VjdGlvbnModCxlLG4scyl7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO3RoaXMubnVtVGVzdHMrKztjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMuX3JlY29yZElzb2xhdGVkJiYodC5zZXRJc29sYXRlZCghMSksbi5zZXRJc29sYXRlZCghMSkpLHRoaXMuX251bUludGVyc2VjdGlvbnMrKyx0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXx8KHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCwhdGhpcy5faW5jbHVkZVByb3BlciYmdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxzLDEpKSx0aGlzLl9saS5pc1Byb3BlcigpJiYodGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApLmNvcHkoKSx0aGlzLl9oYXNQcm9wZXI9ITAsdGhpcy5faXNEb25lV2hlblByb3BlckludCYmKHRoaXMuX2lzRG9uZT0hMCksdGhpcy5pc0JvdW5kYXJ5UG9pbnQodGhpcy5fbGksdGhpcy5fYmR5Tm9kZXMpfHwodGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITApKSkpfWdldENsYXNzKCl7cmV0dXJuIE1ufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Nbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5faGFzUHJvcGVyPSExLHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSExLHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9pbmNsdWRlUHJvcGVyPW51bGwsdGhpcy5fcmVjb3JkSXNvbGF0ZWQ9bnVsbCx0aGlzLl9pc1NlbGZJbnRlcnNlY3Rpb249bnVsbCx0aGlzLl9udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wLHRoaXMuX2JkeU5vZGVzPW51bGwsdGhpcy5faXNEb25lPSExLHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbGk9dCx0aGlzLl9pbmNsdWRlUHJvcGVyPWUsdGhpcy5fcmVjb3JkSXNvbGF0ZWQ9bn07Y2xhc3MgRG4gZXh0ZW5kcyBibntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1wcmVwYXJlRXZlbnRzKCl7RWUuc29ydCh0aGlzLmV2ZW50cyk7Zm9yKGxldCB0PTA7dDx0aGlzLmV2ZW50cy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuZXZlbnRzLmdldCh0KTtlLmlzRGVsZXRlKCkmJmUuZ2V0SW5zZXJ0RXZlbnQoKS5zZXREZWxldGVFdmVudEluZGV4KHQpfX1jb21wdXRlSW50ZXJzZWN0aW9ucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm5PdmVybGFwcz0wLHRoaXMucHJlcGFyZUV2ZW50cygpO2ZvcihsZXQgZT0wO2U8dGhpcy5ldmVudHMuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10aGlzLmV2ZW50cy5nZXQoZSk7aWYobi5pc0luc2VydCgpJiZ0aGlzLnByb2Nlc3NPdmVybGFwcyhlLG4uZ2V0RGVsZXRlRXZlbnRJbmRleCgpLG4sdCksdC5pc0RvbmUoKSlicmVha319ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIE1uJiZfKGFyZ3VtZW50c1swXSxtKSYmXyhhcmd1bWVudHNbMV0sbSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuYWRkRWRnZXModCx0KSx0aGlzLmFkZEVkZ2VzKGUsZSksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhuKX1lbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZfKGFyZ3VtZW50c1swXSxtKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBNbil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdP3RoaXMuYWRkRWRnZXModCxudWxsKTp0aGlzLmFkZEVkZ2VzKHQpLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMoZSl9fWFkZEVkZ2UodCxlKXtjb25zdCBuPXQuZ2V0TW9ub3RvbmVDaGFpbkVkZ2UoKSxzPW4uZ2V0U3RhcnRJbmRleGVzKCk7Zm9yKGxldCB0PTA7dDxzLmxlbmd0aC0xO3QrKyl7Y29uc3Qgcz1uZXcgdm4obix0KSxpPW5ldyBPbihlLG4uZ2V0TWluWCh0KSxzKTt0aGlzLmV2ZW50cy5hZGQoaSksdGhpcy5ldmVudHMuYWRkKG5ldyBPbihuLmdldE1heFgodCksaSkpfX1wcm9jZXNzT3ZlcmxhcHModCxlLG4scyl7Y29uc3QgaT1uLmdldE9iamVjdCgpO2ZvcihsZXQgcj10O3I8ZTtyKyspe2NvbnN0IHQ9dGhpcy5ldmVudHMuZ2V0KHIpO2lmKHQuaXNJbnNlcnQoKSl7Y29uc3QgZT10LmdldE9iamVjdCgpO24uaXNTYW1lTGFiZWwodCl8fChpLmNvbXB1dGVJbnRlcnNlY3Rpb25zKGUscyksdGhpcy5uT3ZlcmxhcHMrKyl9fX1hZGRFZGdlcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkRWRnZShlLGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLmFkZEVkZ2UodCxlKX19fWdldENsYXNzKCl7cmV0dXJuIERufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ebi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmV2ZW50cz1uZXcgeCx0aGlzLm5PdmVybGFwcz1udWxsfTtjbGFzcyBBbntjb25zdHJ1Y3Rvcigpe0FuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0QWxsTG9jYXRpb25zKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09dH1pc051bGwoKXtmb3IobGV0IHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdIT09bmUuTk9ORSlyZXR1cm4hMTtyZXR1cm4hMH1zZXRBbGxMb2NhdGlvbnNJZk51bGwodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PW5lLk5PTkUmJih0aGlzLmxvY2F0aW9uW2VdPXQpfWlzTGluZSgpe3JldHVybiAxPT09dGhpcy5sb2NhdGlvbi5sZW5ndGh9bWVyZ2UodCl7aWYodC5sb2NhdGlvbi5sZW5ndGg+dGhpcy5sb2NhdGlvbi5sZW5ndGgpe2NvbnN0IHQ9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7dFtQbi5PTl09dGhpcy5sb2NhdGlvbltQbi5PTl0sdFtQbi5MRUZUXT1uZS5OT05FLHRbUG4uUklHSFRdPW5lLk5PTkUsdGhpcy5sb2NhdGlvbj10fWZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09PT1uZS5OT05FJiZlPHQubG9jYXRpb24ubGVuZ3RoJiYodGhpcy5sb2NhdGlvbltlXT10LmxvY2F0aW9uW2VdKX1nZXRMb2NhdGlvbnMoKXtyZXR1cm4gdGhpcy5sb2NhdGlvbn1mbGlwKCl7aWYodGhpcy5sb2NhdGlvbi5sZW5ndGg8PTEpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLmxvY2F0aW9uW1BuLkxFRlRdO3RoaXMubG9jYXRpb25bUG4uTEVGVF09dGhpcy5sb2NhdGlvbltQbi5SSUdIVF0sdGhpcy5sb2NhdGlvbltQbi5SSUdIVF09dH10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHc7cmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKG5lLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltQbi5MRUZUXSkpLHQuYXBwZW5kKG5lLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltQbi5PTl0pKSx0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChuZS50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bUG4uUklHSFRdKSksdC50b1N0cmluZygpfXNldExvY2F0aW9ucyh0LGUsbil7dGhpcy5sb2NhdGlvbltQbi5PTl09dCx0aGlzLmxvY2F0aW9uW1BuLkxFRlRdPWUsdGhpcy5sb2NhdGlvbltQbi5SSUdIVF09bn1nZXQodCl7cmV0dXJuIHQ8dGhpcy5sb2NhdGlvbi5sZW5ndGg/dGhpcy5sb2NhdGlvblt0XTpuZS5OT05FfWlzQXJlYSgpe3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xfWlzQW55TnVsbCgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5sb2NhdGlvbi5sZW5ndGg7dCsrKWlmKHRoaXMubG9jYXRpb25bdF09PT1uZS5OT05FKXJldHVybiEwO3JldHVybiExfXNldExvY2F0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TG9jYXRpb24oUG4uT04sdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5sb2NhdGlvblt0XT1lfX1pbml0KHQpe3RoaXMubG9jYXRpb249bmV3IEFycmF5KHQpLmZpbGwobnVsbCksdGhpcy5zZXRBbGxMb2NhdGlvbnMobmUuTk9ORSl9aXNFcXVhbE9uU2lkZSh0LGUpe3JldHVybiB0aGlzLmxvY2F0aW9uW2VdPT09dC5sb2NhdGlvbltlXX1hbGxQb3NpdGlvbnNFcXVhbCh0KXtmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKylpZih0aGlzLmxvY2F0aW9uW2VdIT09dClyZXR1cm4hMTtyZXR1cm4hMH1nZXRDbGFzcygpe3JldHVybiBBbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19QW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5sb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC5sZW5ndGgpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQoMSksdGhpcy5sb2NhdGlvbltQbi5PTl09dH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQW4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaW5pdCh0LmxvY2F0aW9uLmxlbmd0aCksbnVsbCE9PXQpZm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10LmxvY2F0aW9uW2VdfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmluaXQoMyksdGhpcy5sb2NhdGlvbltQbi5PTl09dCx0aGlzLmxvY2F0aW9uW1BuLkxFRlRdPWUsdGhpcy5sb2NhdGlvbltQbi5SSUdIVF09bn19O2NsYXNzIEZue2NvbnN0cnVjdG9yKCl7Rm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9MaW5lTGFiZWwodCl7Y29uc3QgZT1uZXcgRm4obmUuTk9ORSk7Zm9yKGxldCBuPTA7bjwyO24rKyllLnNldExvY2F0aW9uKG4sdC5nZXRMb2NhdGlvbihuKSk7cmV0dXJuIGV9Z2V0R2VvbWV0cnlDb3VudCgpe2xldCB0PTA7cmV0dXJuIHRoaXMuZWx0WzBdLmlzTnVsbCgpfHx0KyssdGhpcy5lbHRbMV0uaXNOdWxsKCl8fHQrKyx0fXNldEFsbExvY2F0aW9ucyh0LGUpe3RoaXMuZWx0W3RdLnNldEFsbExvY2F0aW9ucyhlKX1pc051bGwodCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTnVsbCgpfXNldEFsbExvY2F0aW9uc0lmTnVsbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLHQpLHRoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbdF0uc2V0QWxsTG9jYXRpb25zSWZOdWxsKGUpfX1pc0xpbmUodCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTGluZSgpfW1lcmdlKHQpe2ZvcihsZXQgZT0wO2U8MjtlKyspbnVsbD09PXRoaXMuZWx0W2VdJiZudWxsIT09dC5lbHRbZV0/dGhpcy5lbHRbZV09bmV3IEFuKHQuZWx0W2VdKTp0aGlzLmVsdFtlXS5tZXJnZSh0LmVsdFtlXSl9ZmxpcCgpe3RoaXMuZWx0WzBdLmZsaXAoKSx0aGlzLmVsdFsxXS5mbGlwKCl9Z2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWx0W3RdLmdldChQbi5PTil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmVsdFt0XS5nZXQoZSl9fXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdztyZXR1cm4gbnVsbCE9PXRoaXMuZWx0WzBdJiYodC5hcHBlbmQoXCJBOlwiKSx0LmFwcGVuZCh0aGlzLmVsdFswXS50b1N0cmluZygpKSksbnVsbCE9PXRoaXMuZWx0WzFdJiYodC5hcHBlbmQoXCIgQjpcIiksdC5hcHBlbmQodGhpcy5lbHRbMV0udG9TdHJpbmcoKSkpLHQudG9TdHJpbmcoKX1pc0FyZWEoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5lbHRbMF0uaXNBcmVhKCl8fHRoaXMuZWx0WzFdLmlzQXJlYSgpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBcmVhKCl9fWlzQW55TnVsbCh0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBbnlOdWxsKCl9c2V0TG9jYXRpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oUG4uT04sZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oZSxuKX19aXNFcXVhbE9uU2lkZSh0LGUpe3JldHVybiB0aGlzLmVsdFswXS5pc0VxdWFsT25TaWRlKHQuZWx0WzBdLGUpJiZ0aGlzLmVsdFsxXS5pc0VxdWFsT25TaWRlKHQuZWx0WzFdLGUpfWFsbFBvc2l0aW9uc0VxdWFsKHQsZSl7cmV0dXJuIHRoaXMuZWx0W3RdLmFsbFBvc2l0aW9uc0VxdWFsKGUpfXRvTGluZSh0KXt0aGlzLmVsdFt0XS5pc0FyZWEoKSYmKHRoaXMuZWx0W3RdPW5ldyBBbih0aGlzLmVsdFt0XS5sb2NhdGlvblswXSkpfWdldENsYXNzKCl7cmV0dXJuIEZufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Gbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLmVsdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgQW4odCksdGhpcy5lbHRbMV09bmV3IEFuKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGbil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IEFuKHQuZWx0WzBdKSx0aGlzLmVsdFsxXT1uZXcgQW4odC5lbHRbMV0pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFswXT1uZXcgQW4obmUuTk9ORSksdGhpcy5lbHRbMV09bmV3IEFuKG5lLk5PTkUpLHRoaXMuZWx0W3RdLnNldExvY2F0aW9uKGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuZWx0WzBdPW5ldyBBbih0LGUsbiksdGhpcy5lbHRbMV09bmV3IEFuKHQsZSxuKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLmVsdFswXT1uZXcgQW4obmUuTk9ORSxuZS5OT05FLG5lLk5PTkUpLHRoaXMuZWx0WzFdPW5ldyBBbihuZS5OT05FLG5lLk5PTkUsbmUuTk9ORSksdGhpcy5lbHRbdF0uc2V0TG9jYXRpb25zKGUsbixzKX19O2NsYXNzIEdue2NvbnN0cnVjdG9yKCl7R24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRTZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXh9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmNvb3JkfXByaW50KHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KSx0LnByaW50bG4oXCIgZGlzdCA9IFwiK3RoaXMuZGlzdCl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlKGUuc2VnbWVudEluZGV4LGUuZGlzdCl9aXNFbmRQb2ludCh0KXtyZXR1cm4gMD09PXRoaXMuc2VnbWVudEluZGV4JiYwPT09dGhpcy5kaXN0fHx0aGlzLnNlZ21lbnRJbmRleD09PXR9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5jb29yZCtcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4K1wiIGRpc3QgPSBcIit0aGlzLmRpc3R9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5kaXN0fWNvbXBhcmUodCxlKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg8dD8tMTp0aGlzLnNlZ21lbnRJbmRleD50PzE6dGhpcy5kaXN0PGU/LTE6dGhpcy5kaXN0PmU/MTowfWdldENsYXNzKCl7cmV0dXJuIEdufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19R24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5jb29yZD1udWxsLHRoaXMuc2VnbWVudEluZGV4PW51bGwsdGhpcy5kaXN0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5jb29yZD1uZXcgZyh0KSx0aGlzLnNlZ21lbnRJbmRleD1lLHRoaXMuZGlzdD1ufTtjbGFzcyBxbntjb25zdHJ1Y3Rvcigpe3FuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cHJpbnQodCl7dC5wcmludGxuKFwiSW50ZXJzZWN0aW9uczpcIik7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9YWRkU3BsaXRFZGdlcyh0KXt0aGlzLmFkZEVuZHBvaW50cygpO2NvbnN0IGU9dGhpcy5pdGVyYXRvcigpO2xldCBuPWUubmV4dCgpO2Zvcig7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpLGk9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixzKTt0LmFkZChpKSxuPXN9fWFkZEVuZHBvaW50cygpe2NvbnN0IHQ9dGhpcy5lZGdlLnB0cy5sZW5ndGgtMTt0aGlzLmFkZCh0aGlzLmVkZ2UucHRzWzBdLDAsMCksdGhpcy5hZGQodGhpcy5lZGdlLnB0c1t0XSx0LDApfWNyZWF0ZVNwbGl0RWRnZSh0LGUpe2xldCBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzI7Y29uc3Qgcz10aGlzLmVkZ2UucHRzW2Uuc2VnbWVudEluZGV4XSxpPWUuZGlzdD4wfHwhZS5jb29yZC5lcXVhbHMyRChzKTtpfHxuLS07Y29uc3Qgcj1uZXcgQXJyYXkobikuZmlsbChudWxsKTtsZXQgbz0wO3JbbysrXT1uZXcgZyh0LmNvb3JkKTtmb3IobGV0IG49dC5zZWdtZW50SW5kZXgrMTtuPD1lLnNlZ21lbnRJbmRleDtuKyspcltvKytdPXRoaXMuZWRnZS5wdHNbbl07cmV0dXJuIGkmJihyW29dPWUuY29vcmQpLG5ldyBVbihyLG5ldyBGbih0aGlzLmVkZ2UuX2xhYmVsKSl9YWRkKHQsZSxuKXtjb25zdCBzPW5ldyBHbih0LGUsbiksaT10aGlzLl9ub2RlTWFwLmdldChzKTtyZXR1cm4gbnVsbCE9PWk/aToodGhpcy5fbm9kZU1hcC5wdXQocyxzKSxzKX1pc0ludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7aWYoZS5uZXh0KCkuY29vcmQuZXF1YWxzKHQpKXJldHVybiEwfXJldHVybiExfWdldENsYXNzKCl7cmV0dXJuIHFufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1xbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ub2RlTWFwPW5ldyBydCx0aGlzLmVkZ2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVkZ2U9dH07Y2xhc3MgQm57Y29uc3RydWN0b3IoKXtCbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dC5nZXQobikuaW50VmFsdWUoKTtyZXR1cm4gZX1nZXRDaGFpblN0YXJ0SW5kaWNlcyh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IHg7bi5hZGQobmV3IEwoZSkpO2Rve2NvbnN0IHM9dGhpcy5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChuZXcgTChzKSksZT1zfXdoaWxlKGU8dC5sZW5ndGgtMSk7cmV0dXJuIEJuLnRvSW50QXJyYXkobil9ZmluZENoYWluRW5kKHQsZSl7Y29uc3Qgbj1Jbi5xdWFkcmFudCh0W2VdLHRbZSsxXSk7bGV0IHM9ZSsxO2Zvcig7czx0Lmxlbmd0aDspe2lmKEluLnF1YWRyYW50KHRbcy0xXSx0W3NdKSE9PW4pYnJlYWs7cysrfXJldHVybiBzLTF9Z2V0Q2xhc3MoKXtyZXR1cm4gQm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUJuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgVm57Y29uc3RydWN0b3IoKXtWbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfWdldE1heFgodCl7Y29uc3QgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gZT5uP2U6bn1nZXRNaW5YKHQpe2NvbnN0IGU9dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3RdXS54LG49dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3QrMV1dLng7cmV0dXJuIGU8bj9lOm59Y29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbigpe2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5zdGFydEluZGV4W3RdLHRoaXMuc3RhcnRJbmRleFt0KzFdLGUsZS5zdGFydEluZGV4W25dLGUuc3RhcnRJbmRleFtuKzFdLHMpfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO2lmKGUtdD09MSYmaS1zPT0xKXJldHVybiByLmFkZEludGVyc2VjdGlvbnModGhpcy5lLHQsbi5lLHMpLG51bGw7aWYoIXRoaXMub3ZlcmxhcHModCxlLG4scyxpKSlyZXR1cm4gbnVsbDtjb25zdCBvPU1hdGgudHJ1bmMoKHQrZSkvMiksbD1NYXRoLnRydW5jKChzK2kpLzIpO3Q8byYmKHM8bCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHQsbyxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0LG8sbixsLGkscikpLG88ZSYmKHM8bCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG8sZSxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihvLGUsbixsLGkscikpfX1vdmVybGFwcyh0LGUsbixzLGkpe3JldHVybiBOLmludGVyc2VjdHModGhpcy5wdHNbdF0sdGhpcy5wdHNbZV0sbi5wdHNbc10sbi5wdHNbaV0pfWdldFN0YXJ0SW5kZXhlcygpe3JldHVybiB0aGlzLnN0YXJ0SW5kZXh9Y29tcHV0ZUludGVyc2VjdHModCxlKXtmb3IobGV0IG49MDtuPHRoaXMuc3RhcnRJbmRleC5sZW5ndGgtMTtuKyspZm9yKGxldCBzPTA7czx0LnN0YXJ0SW5kZXgubGVuZ3RoLTE7cysrKXRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihuLHQscyxlKX1nZXRDbGFzcygpe3JldHVybiBWbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Vm4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5lPW51bGwsdGhpcy5wdHM9bnVsbCx0aGlzLnN0YXJ0SW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmU9dCx0aGlzLnB0cz10LmdldENvb3JkaW5hdGVzKCk7Y29uc3QgZT1uZXcgQm47dGhpcy5zdGFydEluZGV4PWUuZ2V0Q2hhaW5TdGFydEluZGljZXModGhpcy5wdHMpfTtjbGFzcyB6bntjb25zdHJ1Y3Rvcigpe3puLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRlcHRoQXRMb2NhdGlvbih0KXtyZXR1cm4gdD09PW5lLkVYVEVSSU9SPzA6dD09PW5lLklOVEVSSU9SPzE6em4uTlVMTF9WQUxVRX1nZXREZXB0aCh0LGUpe3JldHVybiB0aGlzLl9kZXB0aFt0XVtlXX1zZXREZXB0aCh0LGUsbil7dGhpcy5fZGVwdGhbdF1bZV09bn1pc051bGwoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGxldCB0PTA7dDwyO3QrKylmb3IobGV0IGU9MDtlPDM7ZSsrKWlmKHRoaXMuX2RlcHRoW3RdW2VdIT09em4uTlVMTF9WQUxVRSlyZXR1cm4hMTtyZXR1cm4hMH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RlcHRoW3RdWzFdPT09em4uTlVMTF9WQUxVRX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2VdPT09em4uTlVMTF9WQUxVRX19bm9ybWFsaXplKCl7Zm9yKGxldCB0PTA7dDwyO3QrKylpZighdGhpcy5pc051bGwodCkpe2xldCBlPXRoaXMuX2RlcHRoW3RdWzFdO3RoaXMuX2RlcHRoW3RdWzJdPGUmJihlPXRoaXMuX2RlcHRoW3RdWzJdKSxlPDAmJihlPTApO2ZvcihsZXQgbj0xO248MztuKyspe2xldCBzPTA7dGhpcy5fZGVwdGhbdF1bbl0+ZSYmKHM9MSksdGhpcy5fZGVwdGhbdF1bbl09c319fWdldERlbHRhKHQpe3JldHVybiB0aGlzLl9kZXB0aFt0XVtQbi5SSUdIVF0tdGhpcy5fZGVwdGhbdF1bUG4uTEVGVF19Z2V0TG9jYXRpb24odCxlKXtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bZV08PTA/bmUuRVhURVJJT1I6bmUuSU5URVJJT1J9dG9TdHJpbmcoKXtyZXR1cm5cIkE6IFwiK3RoaXMuX2RlcHRoWzBdWzFdK1wiLFwiK3RoaXMuX2RlcHRoWzBdWzJdK1wiIEI6IFwiK3RoaXMuX2RlcHRoWzFdWzFdK1wiLFwiK3RoaXMuX2RlcHRoWzFdWzJdfWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPDI7ZSsrKWZvcihsZXQgbj0xO248MztuKyspe2NvbnN0IHM9dC5nZXRMb2NhdGlvbihlLG4pO3MhPT1uZS5FWFRFUklPUiYmcyE9PW5lLklOVEVSSU9SfHwodGhpcy5pc051bGwoZSxuKT90aGlzLl9kZXB0aFtlXVtuXT16bi5kZXB0aEF0TG9jYXRpb24ocyk6dGhpcy5fZGVwdGhbZV1bbl0rPXpuLmRlcHRoQXRMb2NhdGlvbihzKSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1syXT09PW5lLklOVEVSSU9SJiZ0aGlzLl9kZXB0aFt0XVtlXSsrfX1nZXRDbGFzcygpe3JldHVybiB6bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19em4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZGVwdGg9QXJyYXkoMikuZmlsbCgpLm1hcCgoKT0+QXJyYXkoMykpO2ZvcihsZXQgdD0wO3Q8Mjt0KyspZm9yKGxldCBlPTA7ZTwzO2UrKyl0aGlzLl9kZXB0aFt0XVtlXT16bi5OVUxMX1ZBTFVFfSx6bi5OVUxMX1ZBTFVFPS0xO2NsYXNzIFlue2NvbnN0cnVjdG9yKCl7WW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRWaXNpdGVkKHQpe3RoaXMuX2lzVmlzaXRlZD10fXNldEluUmVzdWx0KHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH1pc0NvdmVyZWQoKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkfWlzQ292ZXJlZFNldCgpe3JldHVybiB0aGlzLl9pc0NvdmVyZWRTZXR9c2V0TGFiZWwodCl7dGhpcy5fbGFiZWw9dH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1zZXRDb3ZlcmVkKHQpe3RoaXMuX2lzQ292ZXJlZD10LHRoaXMuX2lzQ292ZXJlZFNldD0hMH11cGRhdGVJTSh0KXt1LmlzVHJ1ZSh0aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCk+PTIsXCJmb3VuZCBwYXJ0aWFsIGxhYmVsXCIpLHRoaXMuY29tcHV0ZUlNKHQpfWlzSW5SZXN1bHQoKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfWdldENsYXNzKCl7cmV0dXJuIFlufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Zbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9sYWJlbD1udWxsLHRoaXMuX2lzSW5SZXN1bHQ9ITEsdGhpcy5faXNDb3ZlcmVkPSExLHRoaXMuX2lzQ292ZXJlZFNldD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xhYmVsPXR9fTtjbGFzcyBVbiBleHRlbmRzIFlue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxVbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB1cGRhdGVJTSgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2Ygc2UmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgRm4pKXJldHVybiBzdXBlci51cGRhdGVJTS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Uuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLFBuLk9OKSx0LmdldExvY2F0aW9uKDEsUG4uT04pLDEpLHQuaXNBcmVhKCkmJihlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxQbi5MRUZUKSx0LmdldExvY2F0aW9uKDEsUG4uTEVGVCksMiksZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsUG4uUklHSFQpLHQuZ2V0TG9jYXRpb24oMSxQbi5SSUdIVCksMikpfX1nZXREZXB0aCgpe3JldHVybiB0aGlzLl9kZXB0aH1nZXRDb2xsYXBzZWRFZGdlKCl7Y29uc3QgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtyZXR1cm4gdFswXT10aGlzLnB0c1swXSx0WzFdPXRoaXMucHRzWzFdLG5ldyBVbih0LEZuLnRvTGluZUxhYmVsKHRoaXMuX2xhYmVsKSl9aXNJc29sYXRlZCgpe3JldHVybiB0aGlzLl9pc0lzb2xhdGVkfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfXNldElzb2xhdGVkKHQpe3RoaXMuX2lzSXNvbGF0ZWQ9dH1zZXROYW1lKHQpe3RoaXMuX25hbWU9dH1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2YgVW4pKXJldHVybiExO2NvbnN0IGU9dDtpZih0aGlzLnB0cy5sZW5ndGghPT1lLnB0cy5sZW5ndGgpcmV0dXJuITE7bGV0IG49ITAscz0hMCxpPXRoaXMucHRzLmxlbmd0aDtmb3IobGV0IHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspaWYodGhpcy5wdHNbdF0uZXF1YWxzMkQoZS5wdHNbdF0pfHwobj0hMSksdGhpcy5wdHNbdF0uZXF1YWxzMkQoZS5wdHNbLS1pXSl8fChzPSExKSwhbiYmIXMpcmV0dXJuITE7cmV0dXJuITB9Z2V0Q29vcmRpbmF0ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnB0cy5sZW5ndGg+MD90aGlzLnB0c1swXTpudWxsO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5wdHNbdF19fXByaW50KHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMuX25hbWUrXCI6IFwiKSx0LnByaW50KFwiTElORVNUUklORyAoXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTt0LnByaW50KFwiKSAgXCIrdGhpcy5fbGFiZWwrXCIgXCIrdGhpcy5fZGVwdGhEZWx0YSl9Y29tcHV0ZUlNKHQpe1VuLnVwZGF0ZUlNKHRoaXMuX2xhYmVsLHQpfWlzQ29sbGFwc2VkKCl7cmV0dXJuISF0aGlzLl9sYWJlbC5pc0FyZWEoKSYmKDM9PT10aGlzLnB0cy5sZW5ndGgmJiEhdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzWzJdKSl9aXNDbG9zZWQoKXtyZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aC0xXSl9Z2V0TWF4aW11bVNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLnB0cy5sZW5ndGgtMX1nZXREZXB0aERlbHRhKCl7cmV0dXJuIHRoaXMuX2RlcHRoRGVsdGF9Z2V0TnVtUG9pbnRzKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aH1wcmludFJldmVyc2UodCl7dC5wcmludChcImVkZ2UgXCIrdGhpcy5fbmFtZStcIjogXCIpO2ZvcihsZXQgZT10aGlzLnB0cy5sZW5ndGgtMTtlPj0wO2UtLSl0LnByaW50KHRoaXMucHRzW2VdK1wiIFwiKTt0LnByaW50bG4oXCJcIil9Z2V0TW9ub3RvbmVDaGFpbkVkZ2UoKXtyZXR1cm4gbnVsbD09PXRoaXMuX21jZSYmKHRoaXMuX21jZT1uZXcgVm4odGhpcykpLHRoaXMuX21jZX1nZXRFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9lbnYpe3RoaXMuX2Vudj1uZXcgTjtmb3IobGV0IHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspdGhpcy5fZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLnB0c1t0XSl9cmV0dXJuIHRoaXMuX2Vudn1hZGRJbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1uZXcgZyh0LmdldEludGVyc2VjdGlvbihzKSk7bGV0IHI9ZSxvPXQuZ2V0RWRnZURpc3RhbmNlKG4scyk7Y29uc3QgbD1yKzE7aWYobDx0aGlzLnB0cy5sZW5ndGgpe2NvbnN0IHQ9dGhpcy5wdHNbbF07aS5lcXVhbHMyRCh0KSYmKHI9bCxvPTApfXRoaXMuZWlMaXN0LmFkZChpLHIsbyl9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB3dDt0LmFwcGVuZChcImVkZ2UgXCIrdGhpcy5fbmFtZStcIjogXCIpLHQuYXBwZW5kKFwiTElORVNUUklORyAoXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQuYXBwZW5kKFwiLFwiKSx0LmFwcGVuZCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3JldHVybiB0LmFwcGVuZChcIikgIFwiK3RoaXMuX2xhYmVsK1wiIFwiK3RoaXMuX2RlcHRoRGVsdGEpLHQudG9TdHJpbmcoKX1pc1BvaW50d2lzZUVxdWFsKHQpe2lmKHRoaXMucHRzLmxlbmd0aCE9PXQucHRzLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspaWYoIXRoaXMucHRzW2VdLmVxdWFsczJEKHQucHRzW2VdKSlyZXR1cm4hMTtyZXR1cm4hMH1zZXREZXB0aERlbHRhKHQpe3RoaXMuX2RlcHRoRGVsdGE9dH1nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpe3JldHVybiB0aGlzLmVpTGlzdH1hZGRJbnRlcnNlY3Rpb25zKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7cysrKXRoaXMuYWRkSW50ZXJzZWN0aW9uKHQsZSxuLHMpfWdldENsYXNzKCl7cmV0dXJuIFVufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Vbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLnB0cz1udWxsLHRoaXMuX2Vudj1udWxsLHRoaXMuZWlMaXN0PW5ldyBxbih0aGlzKSx0aGlzLl9uYW1lPW51bGwsdGhpcy5fbWNlPW51bGwsdGhpcy5faXNJc29sYXRlZD0hMCx0aGlzLl9kZXB0aD1uZXcgem4sdGhpcy5fZGVwdGhEZWx0YT0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtVbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wdHM9dCx0aGlzLl9sYWJlbD1lfX07Y2xhc3Mga24gZXh0ZW5kcyBZbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksa24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0luY2lkZW50RWRnZUluUmVzdWx0KCl7Zm9yKGxldCB0PXRoaXMuZ2V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtpZih0Lm5leHQoKS5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKXJldHVybiEwfXJldHVybiExfWlzSXNvbGF0ZWQoKXtyZXR1cm4gMT09PXRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Nvb3JkfXByaW50KHQpe3QucHJpbnRsbihcIm5vZGUgXCIrdGhpcy5fY29vcmQrXCIgbGJsOiBcIit0aGlzLl9sYWJlbCl9Y29tcHV0ZUlNKHQpe31jb21wdXRlTWVyZ2VkTG9jYXRpb24odCxlKXtsZXQgbj1uZS5OT05FO2lmKG49dGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSksIXQuaXNOdWxsKGUpKXtjb25zdCBzPXQuZ2V0TG9jYXRpb24oZSk7biE9PW5lLkJPVU5EQVJZJiYobj1zKX1yZXR1cm4gbn1zZXRMYWJlbCgpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pfHwhTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXJldHVybiBzdXBlci5zZXRMYWJlbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO251bGw9PT10aGlzLl9sYWJlbD90aGlzLl9sYWJlbD1uZXcgRm4odCxlKTp0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUpfX1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31tZXJnZUxhYmVsKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBrbil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQuX2xhYmVsKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRm4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8MjtlKyspe2NvbnN0IG49dGhpcy5jb21wdXRlTWVyZ2VkTG9jYXRpb24odCxlKTt0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlKT09PW5lLk5PTkUmJnRoaXMuX2xhYmVsLnNldExvY2F0aW9uKGUsbil9fX1hZGQodCl7dGhpcy5fZWRnZXMuaW5zZXJ0KHQpLHQuc2V0Tm9kZSh0aGlzKX1zZXRMYWJlbEJvdW5kYXJ5KHQpe2lmKG51bGw9PT10aGlzLl9sYWJlbClyZXR1cm4gbnVsbDtsZXQgZT1uZS5OT05FO251bGwhPT10aGlzLl9sYWJlbCYmKGU9dGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24odCkpO2xldCBuPW51bGw7c3dpdGNoKGUpe2Nhc2UgbmUuQk9VTkRBUlk6bj1uZS5JTlRFUklPUjticmVhaztjYXNlIG5lLklOVEVSSU9SOmRlZmF1bHQ6bj1uZS5CT1VOREFSWX10aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LG4pfWdldENsYXNzKCl7cmV0dXJuIGtufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1rbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb29yZD1udWxsLHRoaXMuX2VkZ2VzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY29vcmQ9dCx0aGlzLl9lZGdlcz1lLHRoaXMuX2xhYmVsPW5ldyBGbigwLG5lLk5PTkUpfTtjbGFzcyBYbntjb25zdHJ1Y3Rvcigpe1huLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluZCh0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLmdldCh0KX1hZGROb2RlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT10aGlzLm5vZGVNYXAuZ2V0KHQpO3JldHVybiBudWxsPT09ZSYmKGU9dGhpcy5ub2RlRmFjdC5jcmVhdGVOb2RlKHQpLHRoaXMubm9kZU1hcC5wdXQodCxlKSksZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGtuKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMubm9kZU1hcC5nZXQodC5nZXRDb29yZGluYXRlKCkpO3JldHVybiBudWxsPT09ZT8odGhpcy5ub2RlTWFwLnB1dCh0LmdldENvb3JkaW5hdGUoKSx0KSx0KTooZS5tZXJnZUxhYmVsKHQpLGUpfX1wcmludCh0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfXZhbHVlcygpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9Z2V0Qm91bmRhcnlOb2Rlcyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KT09PW5lLkJPVU5EQVJZJiZlLmFkZChzKX1yZXR1cm4gZX1hZGQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGUoKTt0aGlzLmFkZE5vZGUoZSkuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIFhufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ybi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLm5vZGVNYXA9bmV3IHJ0LHRoaXMubm9kZUZhY3Q9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVGYWN0PXR9O2NsYXNzIEhue2NvbnN0cnVjdG9yKCl7SG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wYXJlRGlyZWN0aW9uKHQpe3JldHVybiB0aGlzLl9keD09PXQuX2R4JiZ0aGlzLl9keT09PXQuX2R5PzA6dGhpcy5fcXVhZHJhbnQ+dC5fcXVhZHJhbnQ/MTp0aGlzLl9xdWFkcmFudDx0Ll9xdWFkcmFudD8tMTp2LmluZGV4KHQuX3AwLHQuX3AxLHRoaXMuX3AxKX1nZXREeSgpe3JldHVybiB0aGlzLl9keX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3AwfXNldE5vZGUodCl7dGhpcy5fbm9kZT10fXByaW50KHQpe2NvbnN0IGU9TWF0aC5hdGFuMih0aGlzLl9keSx0aGlzLl9keCksbj10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLHM9bi5sYXN0SW5kZXhPZihcIi5cIiksaT1uLnN1YnN0cmluZyhzKzEpO3QucHJpbnQoXCIgIFwiK2krXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrZStcIiAgIFwiK3RoaXMuX2xhYmVsKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9Z2V0RGlyZWN0ZWRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3AxfWdldER4KCl7cmV0dXJuIHRoaXMuX2R4fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fZWRnZX1nZXRRdWFkcmFudCgpe3JldHVybiB0aGlzLl9xdWFkcmFudH1nZXROb2RlKCl7cmV0dXJuIHRoaXMuX25vZGV9dG9TdHJpbmcoKXtjb25zdCB0PU1hdGguYXRhbjIodGhpcy5fZHksdGhpcy5fZHgpLGU9dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxuPWUubGFzdEluZGV4T2YoXCIuXCIpO3JldHVyblwiICBcIitlLnN1YnN0cmluZyhuKzEpK1wiOiBcIit0aGlzLl9wMCtcIiAtIFwiK3RoaXMuX3AxK1wiIFwiK3RoaXMuX3F1YWRyYW50K1wiOlwiK3QrXCIgICBcIit0aGlzLl9sYWJlbH1jb21wdXRlTGFiZWwodCl7fWluaXQodCxlKXt0aGlzLl9wMD10LHRoaXMuX3AxPWUsdGhpcy5fZHg9ZS54LXQueCx0aGlzLl9keT1lLnktdC55LHRoaXMuX3F1YWRyYW50PUluLnF1YWRyYW50KHRoaXMuX2R4LHRoaXMuX2R5KSx1LmlzVHJ1ZSghKDA9PT10aGlzLl9keCYmMD09PXRoaXMuX2R5KSxcIkVkZ2VFbmQgd2l0aCBpZGVudGljYWwgZW5kcG9pbnRzIGZvdW5kXCIpfWdldENsYXNzKCl7cmV0dXJuIEhufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19SG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZWRnZT1udWxsLHRoaXMuX2xhYmVsPW51bGwsdGhpcy5fbm9kZT1udWxsLHRoaXMuX3AwPW51bGwsdGhpcy5fcDE9bnVsbCx0aGlzLl9keD1udWxsLHRoaXMuX2R5PW51bGwsdGhpcy5fcXVhZHJhbnQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZWRnZT10fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO0huLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4sbnVsbCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107SG4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLmluaXQoZSxuKSx0aGlzLl9sYWJlbD1zfX07Y2xhc3MgV24gZXh0ZW5kcyBje2NvbnN0cnVjdG9yKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3N1cGVyKHQpLGMuY2FsbCh0aGlzLHQpfWVsc2V7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgRXJyb3IoKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07c3VwZXIoV24ubXNnV2l0aENvb3JkKHQsZSkpLHRoaXMubmFtZT1cIlRvcG9sb2d5RXhjZXB0aW9uXCIsdGhpcy5wdD1uZXcgZyhlKX19fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5wdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX1nZXRDbGFzcygpe3JldHVybiBXbn1zdGF0aWMgbXNnV2l0aENvb3JkKHQsZSl7cmV0dXJuIG51bGwhPT1lP3QrXCIgWyBcIitlK1wiIF1cIjp0fX1jbGFzcyBqbiBleHRlbmRzIEhue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxqbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkZXB0aEZhY3Rvcih0LGUpe3JldHVybiB0PT09bmUuRVhURVJJT1ImJmU9PT1uZS5JTlRFUklPUj8xOnQ9PT1uZS5JTlRFUklPUiYmZT09PW5lLkVYVEVSSU9SPy0xOjB9Z2V0TmV4dE1pbigpe3JldHVybiB0aGlzLl9uZXh0TWlufWdldERlcHRoKHQpe3JldHVybiB0aGlzLl9kZXB0aFt0XX1zZXRWaXNpdGVkKHQpe3RoaXMuX2lzVmlzaXRlZD10fWNvbXB1dGVEaXJlY3RlZExhYmVsKCl7dGhpcy5fbGFiZWw9bmV3IEZuKHRoaXMuX2VkZ2UuZ2V0TGFiZWwoKSksdGhpcy5faXNGb3J3YXJkfHx0aGlzLl9sYWJlbC5mbGlwKCl9Z2V0TmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fXNldERlcHRoKHQsZSl7aWYoLTk5OSE9PXRoaXMuX2RlcHRoW3RdJiZ0aGlzLl9kZXB0aFt0XSE9PWUpdGhyb3cgbmV3IFduKFwiYXNzaWduZWQgZGVwdGhzIGRvIG5vdCBtYXRjaFwiLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTt0aGlzLl9kZXB0aFt0XT1lfWlzSW50ZXJpb3JBcmVhRWRnZSgpe2xldCB0PSEwO2ZvcihsZXQgZT0wO2U8MjtlKyspdGhpcy5fbGFiZWwuaXNBcmVhKGUpJiZ0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlLFBuLkxFRlQpPT09bmUuSU5URVJJT1ImJnRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUsUG4uUklHSFQpPT09bmUuSU5URVJJT1J8fCh0PSExKTtyZXR1cm4gdH1zZXROZXh0TWluKHQpe3RoaXMuX25leHRNaW49dH1wcmludCh0KXtzdXBlci5wcmludC5jYWxsKHRoaXMsdCksdC5wcmludChcIiBcIit0aGlzLl9kZXB0aFtQbi5MRUZUXStcIi9cIit0aGlzLl9kZXB0aFtQbi5SSUdIVF0pLHQucHJpbnQoXCIgKFwiK3RoaXMuZ2V0RGVwdGhEZWx0YSgpK1wiKVwiKSx0aGlzLl9pc0luUmVzdWx0JiZ0LnByaW50KFwiIGluUmVzdWx0XCIpfXNldE1pbkVkZ2VSaW5nKHQpe3RoaXMuX21pbkVkZ2VSaW5nPXR9aXNMaW5lRWRnZSgpe2NvbnN0IHQ9dGhpcy5fbGFiZWwuaXNMaW5lKDApfHx0aGlzLl9sYWJlbC5pc0xpbmUoMSksZT0hdGhpcy5fbGFiZWwuaXNBcmVhKDApfHx0aGlzLl9sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgwLG5lLkVYVEVSSU9SKSxuPSF0aGlzLl9sYWJlbC5pc0FyZWEoMSl8fHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDEsbmUuRVhURVJJT1IpO3JldHVybiB0JiZlJiZufXNldEVkZ2VSaW5nKHQpe3RoaXMuX2VkZ2VSaW5nPXR9Z2V0TWluRWRnZVJpbmcoKXtyZXR1cm4gdGhpcy5fbWluRWRnZVJpbmd9Z2V0RGVwdGhEZWx0YSgpe2xldCB0PXRoaXMuX2VkZ2UuZ2V0RGVwdGhEZWx0YSgpO3JldHVybiB0aGlzLl9pc0ZvcndhcmR8fCh0PS10KSx0fXNldEluUmVzdWx0KHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH1nZXRTeW0oKXtyZXR1cm4gdGhpcy5fc3ltfWlzRm9yd2FyZCgpe3JldHVybiB0aGlzLl9pc0ZvcndhcmR9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfXByaW50RWRnZSh0KXt0aGlzLnByaW50KHQpLHQucHJpbnQoXCIgXCIpLHRoaXMuX2lzRm9yd2FyZD90aGlzLl9lZGdlLnByaW50KHQpOnRoaXMuX2VkZ2UucHJpbnRSZXZlcnNlKHQpfXNldFN5bSh0KXt0aGlzLl9zeW09dH1zZXRWaXNpdGVkRWRnZSh0KXt0aGlzLnNldFZpc2l0ZWQodCksdGhpcy5fc3ltLnNldFZpc2l0ZWQodCl9c2V0RWRnZURlcHRocyh0LGUpe2xldCBuPXRoaXMuZ2V0RWRnZSgpLmdldERlcHRoRGVsdGEoKTt0aGlzLl9pc0ZvcndhcmR8fChuPS1uKTtsZXQgcz0xO3Q9PT1Qbi5MRUZUJiYocz0tMSk7Y29uc3QgaT1Qbi5vcHBvc2l0ZSh0KSxyPWUrbipzO3RoaXMuc2V0RGVwdGgodCxlKSx0aGlzLnNldERlcHRoKGkscil9Z2V0RWRnZVJpbmcoKXtyZXR1cm4gdGhpcy5fZWRnZVJpbmd9aXNJblJlc3VsdCgpe3JldHVybiB0aGlzLl9pc0luUmVzdWx0fXNldE5leHQodCl7dGhpcy5fbmV4dD10fWlzVmlzaXRlZCgpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9Z2V0Q2xhc3MoKXtyZXR1cm4gam59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWpuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzRm9yd2FyZD1udWxsLHRoaXMuX2lzSW5SZXN1bHQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLHRoaXMuX3N5bT1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9uZXh0TWluPW51bGwsdGhpcy5fZWRnZVJpbmc9bnVsbCx0aGlzLl9taW5FZGdlUmluZz1udWxsLHRoaXMuX2RlcHRoPVswLC05OTksLTk5OV07Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoSG4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLl9pc0ZvcndhcmQ9ZSxlKXRoaXMuaW5pdCh0LmdldENvb3JkaW5hdGUoMCksdC5nZXRDb29yZGluYXRlKDEpKTtlbHNle2NvbnN0IGU9dC5nZXROdW1Qb2ludHMoKS0xO3RoaXMuaW5pdCh0LmdldENvb3JkaW5hdGUoZSksdC5nZXRDb29yZGluYXRlKGUtMSkpfXRoaXMuY29tcHV0ZURpcmVjdGVkTGFiZWwoKX07Y2xhc3MgS257Y29uc3RydWN0b3IoKXtLbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZU5vZGUodCl7cmV0dXJuIG5ldyBrbih0LG51bGwpfWdldENsYXNzKCl7cmV0dXJuIEtufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Lbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFpue2NvbnN0cnVjdG9yKCl7Wm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbGlua1Jlc3VsdERpcmVjdGVkRWRnZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19cHJpbnRFZGdlcyh0KXt0LnByaW50bG4oXCJFZGdlczpcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlcy5zaXplKCk7ZSsrKXt0LnByaW50bG4oXCJlZGdlIFwiK2UrXCI6XCIpO2NvbnN0IG49dGhpcy5fZWRnZXMuZ2V0KGUpO24ucHJpbnQodCksbi5laUxpc3QucHJpbnQodCl9fWZpbmQodCl7cmV0dXJuIHRoaXMuX25vZGVzLmZpbmQodCl9YWRkTm9kZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Yga24pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9ub2Rlcy5hZGROb2RlKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX25vZGVzLmFkZE5vZGUodCl9fWdldE5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2Rlcy5pdGVyYXRvcigpfWxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fWRlYnVnUHJpbnRsbih0KXtPLm91dC5wcmludGxuKHQpfWlzQm91bmRhcnlOb2RlKHQsZSl7Y29uc3Qgbj10aGlzLl9ub2Rlcy5maW5kKGUpO2lmKG51bGw9PT1uKXJldHVybiExO2NvbnN0IHM9bi5nZXRMYWJlbCgpO3JldHVybiBudWxsIT09cyYmcy5nZXRMb2NhdGlvbih0KT09PW5lLkJPVU5EQVJZfWxpbmtBbGxEaXJlY3RlZEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmxpbmtBbGxEaXJlY3RlZEVkZ2VzKCl9fW1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxuLHMpe3JldHVybiEhdC5lcXVhbHMobikmJih2LmluZGV4KHQsZSxzKT09PXYuQ09MTElORUFSJiZJbi5xdWFkcmFudCh0LGUpPT09SW4ucXVhZHJhbnQobixzKSl9Z2V0RWRnZUVuZHMoKXtyZXR1cm4gdGhpcy5fZWRnZUVuZExpc3R9ZGVidWdQcmludCh0KXtPLm91dC5wcmludCh0KX1nZXRFZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1maW5kRWRnZUluU2FtZURpcmVjdGlvbih0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5fZWRnZXMuc2l6ZSgpO24rKyl7Y29uc3Qgcz10aGlzLl9lZGdlcy5nZXQobiksaT1zLmdldENvb3JkaW5hdGVzKCk7aWYodGhpcy5tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsaVswXSxpWzFdKSlyZXR1cm4gcztpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxpW2kubGVuZ3RoLTFdLGlbaS5sZW5ndGgtMl0pKXJldHVybiBzfXJldHVybiBudWxsfWluc2VydEVkZ2UodCl7dGhpcy5fZWRnZXMuYWRkKHQpfWZpbmRFZGdlRW5kKHQpe2ZvcihsZXQgZT10aGlzLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYobi5nZXRFZGdlKCk9PT10KXJldHVybiBufXJldHVybiBudWxsfWFkZEVkZ2VzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuX2VkZ2VzLmFkZCh0KTtjb25zdCBuPW5ldyBqbih0LCEwKSxzPW5ldyBqbih0LCExKTtuLnNldFN5bShzKSxzLnNldFN5bShuKSx0aGlzLmFkZChuKSx0aGlzLmFkZChzKX19YWRkKHQpe3RoaXMuX25vZGVzLmFkZCh0KSx0aGlzLl9lZGdlRW5kTGlzdC5hZGQodCl9Z2V0Tm9kZXMoKXtyZXR1cm4gdGhpcy5fbm9kZXMudmFsdWVzKCl9ZmluZEVkZ2UodCxlKXtmb3IobGV0IG49MDtuPHRoaXMuX2VkZ2VzLnNpemUoKTtuKyspe2NvbnN0IHM9dGhpcy5fZWRnZXMuZ2V0KG4pLGk9cy5nZXRDb29yZGluYXRlcygpO2lmKHQuZXF1YWxzKGlbMF0pJiZlLmVxdWFscyhpWzFdKSlyZXR1cm4gc31yZXR1cm4gbnVsbH1nZXRDbGFzcygpe3JldHVybiBabn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Wm4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZWRnZXM9bmV3IHgsdGhpcy5fbm9kZXM9bnVsbCx0aGlzLl9lZGdlRW5kTGlzdD1uZXcgeCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9ub2Rlcz1uZXcgWG4obmV3IEtuKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ub2Rlcz1uZXcgWG4odCl9fTtjbGFzcyBRbiBleHRlbmRzIFpue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxRbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkZXRlcm1pbmVCb3VuZGFyeSh0LGUpe3JldHVybiB0LmlzSW5Cb3VuZGFyeShlKT9uZS5CT1VOREFSWTpuZS5JTlRFUklPUn1pbnNlcnRCb3VuZGFyeVBvaW50KHQsZSl7Y29uc3Qgbj10aGlzLl9ub2Rlcy5hZGROb2RlKGUpLmdldExhYmVsKCk7bGV0IHM9MSxpPW5lLk5PTkU7aT1uLmdldExvY2F0aW9uKHQsUG4uT04pLGk9PT1uZS5CT1VOREFSWSYmcysrO2NvbnN0IHI9UW4uZGV0ZXJtaW5lQm91bmRhcnkodGhpcy5fYm91bmRhcnlOb2RlUnVsZSxzKTtuLnNldExvY2F0aW9uKHQscil9Y29tcHV0ZVNlbGZOb2Rlcygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wdXRlU2VsZk5vZGVzKHQsZSwhMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IE1uKHQsITAsITEpO3Muc2V0SXNEb25lSWZQcm9wZXJJbnQobik7Y29uc3QgaT10aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpLHI9dGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIER0fHx0aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgYnR8fHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBBdCxvPWV8fCFyO3JldHVybiBpLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuX2VkZ2VzLHMsbyksdGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXModGhpcy5fYXJnSW5kZXgpLHN9fWNvbXB1dGVTcGxpdEVkZ2VzKHQpe2ZvcihsZXQgZT10aGlzLl9lZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuZWlMaXN0LmFkZFNwbGl0RWRnZXModCl9fWNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0LGUsbil7Y29uc3Qgcz1uZXcgTW4oZSxuLCEwKTtyZXR1cm4gcy5zZXRCb3VuZGFyeU5vZGVzKHRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLHQuZ2V0Qm91bmRhcnlOb2RlcygpKSx0aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuX2VkZ2VzLHQuX2VkZ2VzLHMpLHN9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5fcGFyZW50R2VvbX1nZXRCb3VuZGFyeU5vZGVSdWxlKCl7cmV0dXJuIHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGV9aGFzVG9vRmV3UG9pbnRzKCl7cmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50c31hZGRQb2ludCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGUoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LHQsbmUuSU5URVJJT1IpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LHQsbmUuSU5URVJJT1IpfX1hZGRQb2x5Z29uKHQpe3RoaXMuYWRkUG9seWdvblJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSxuZS5FWFRFUklPUixuZS5JTlRFUklPUik7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl7Y29uc3Qgbj10LmdldEludGVyaW9yUmluZ04oZSk7dGhpcy5hZGRQb2x5Z29uUmluZyhuLG5lLklOVEVSSU9SLG5lLkVYVEVSSU9SKX19YWRkRWRnZSh0KXt0aGlzLmluc2VydEVkZ2UodCk7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7dGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCxlWzBdLG5lLkJPVU5EQVJZKSx0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LGVbZS5sZW5ndGgtMV0sbmUuQk9VTkRBUlkpfWFkZExpbmVTdHJpbmcodCl7Y29uc3QgZT1YLnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8MilyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzPSEwLHRoaXMuX2ludmFsaWRQb2ludD1lWzBdLG51bGw7Y29uc3Qgbj1uZXcgVW4oZSxuZXcgRm4odGhpcy5fYXJnSW5kZXgsbmUuSU5URVJJT1IpKTt0aGlzLl9saW5lRWRnZU1hcC5wdXQodCxuKSx0aGlzLmluc2VydEVkZ2UobiksdS5pc1RydWUoZS5sZW5ndGg+PTIsXCJmb3VuZCBMaW5lU3RyaW5nIHdpdGggc2luZ2xlIHBvaW50XCIpLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLl9hcmdJbmRleCxlWzBdKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSl9Z2V0SW52YWxpZFBvaW50KCl7cmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludH1nZXRCb3VuZGFyeVBvaW50cygpe2NvbnN0IHQ9dGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7bGV0IG49MDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtlW24rK109dC5nZXRDb29yZGluYXRlKCkuY29weSgpfXJldHVybiBlfWdldEJvdW5kYXJ5Tm9kZXMoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2JvdW5kYXJ5Tm9kZXMmJih0aGlzLl9ib3VuZGFyeU5vZGVzPXRoaXMuX25vZGVzLmdldEJvdW5kYXJ5Tm9kZXModGhpcy5fYXJnSW5kZXgpKSx0aGlzLl9ib3VuZGFyeU5vZGVzfWFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlKHQsZSxuKXtpZih0aGlzLmlzQm91bmRhcnlOb2RlKHQsZSkpcmV0dXJuIG51bGw7bj09PW5lLkJPVU5EQVJZJiZ0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlP3RoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0LGUpOnRoaXMuaW5zZXJ0UG9pbnQodCxlLG4pfWFkZFBvbHlnb25SaW5nKHQsZSxuKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBzPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihzLmxlbmd0aDw0KXJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHM9ITAsdGhpcy5faW52YWxpZFBvaW50PXNbMF0sbnVsbDtsZXQgaT1lLHI9bjt2LmlzQ0NXKHMpJiYoaT1uLHI9ZSk7Y29uc3Qgbz1uZXcgVW4ocyxuZXcgRm4odGhpcy5fYXJnSW5kZXgsbmUuQk9VTkRBUlksaSxyKSk7dGhpcy5fbGluZUVkZ2VNYXAucHV0KHQsbyksdGhpcy5pbnNlcnRFZGdlKG8pLHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsc1swXSxuZS5CT1VOREFSWSl9aW5zZXJ0UG9pbnQodCxlLG4pe2NvbnN0IHM9dGhpcy5fbm9kZXMuYWRkTm9kZShlKSxpPXMuZ2V0TGFiZWwoKTtudWxsPT09aT9zLl9sYWJlbD1uZXcgRm4odCxuKTppLnNldExvY2F0aW9uKHQsbil9Y3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCl7cmV0dXJuIG5ldyBEbn1hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2ZvcihsZXQgZT1uLmVpTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlKHQsbi5jb29yZCxzKX19fWFkZCgpe2lmKCEoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSkpcmV0dXJuIHN1cGVyLmFkZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBBdCYmKHRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITEpLHQgaW5zdGFuY2VvZiBidCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgTXQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBBdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBfdCkpdGhyb3cgbmV3IFoodC5nZXRDbGFzcygpLmdldE5hbWUoKSk7dGhpcy5hZGRDb2xsZWN0aW9uKHQpfX19YWRkQ29sbGVjdGlvbih0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19bG9jYXRlKHQpe3JldHVybiBfKHRoaXMuX3BhcmVudEdlb20sT3QpJiZ0aGlzLl9wYXJlbnRHZW9tLmdldE51bUdlb21ldHJpZXMoKT41MD8obnVsbD09PXRoaXMuX2FyZWFQdExvY2F0b3ImJih0aGlzLl9hcmVhUHRMb2NhdG9yPW5ldyBrZSh0aGlzLl9wYXJlbnRHZW9tKSksdGhpcy5fYXJlYVB0TG9jYXRvci5sb2NhdGUodCkpOnRoaXMuX3B0TG9jYXRvci5sb2NhdGUodCx0aGlzLl9wYXJlbnRHZW9tKX1maW5kRWRnZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbGluZUVkZ2VNYXAuZ2V0KHQpfXJldHVybiBzdXBlci5maW5kRWRnZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gUW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVFuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3BhcmVudEdlb209bnVsbCx0aGlzLl9saW5lRWRnZU1hcD1uZXcgVXQsdGhpcy5fYm91bmRhcnlOb2RlUnVsZT1udWxsLHRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITAsdGhpcy5fYXJnSW5kZXg9bnVsbCx0aGlzLl9ib3VuZGFyeU5vZGVzPW51bGwsdGhpcy5faGFzVG9vRmV3UG9pbnRzPSExLHRoaXMuX2ludmFsaWRQb2ludD1udWxsLHRoaXMuX2FyZWFQdExvY2F0b3I9bnVsbCx0aGlzLl9wdExvY2F0b3I9bmV3IF9uLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtRbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxWLk9HQ19TRlNfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fYXJnSW5kZXg9dCx0aGlzLl9wYXJlbnRHZW9tPWUsdGhpcy5fYm91bmRhcnlOb2RlUnVsZT1uLG51bGwhPT1lJiZ0aGlzLmFkZChlKX19O3ZhciBKbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxHZW9tZXRyeUdyYXBoOlFufSk7Y2xhc3MgJG57Y29uc3RydWN0b3IoKXskbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0KHQpe31nZXRDbGFzcygpe3JldHVybiAkbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19JG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB0c3tjb25zdHJ1Y3Rvcigpe3RzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNSZXBlYXRlZCgpe3JldHVybiB0aGlzLl9jb3VudD4xfWdldFJpZ2h0KCl7cmV0dXJuIHRoaXMuX3JpZ2h0fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcH1zZXRMZWZ0KHQpe3RoaXMuX2xlZnQ9dH1nZXRYKCl7cmV0dXJuIHRoaXMuX3AueH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5fY291bnR9Z2V0TGVmdCgpe3JldHVybiB0aGlzLl9sZWZ0fWdldFkoKXtyZXR1cm4gdGhpcy5fcC55fWluY3JlbWVudCgpe3RoaXMuX2NvdW50PXRoaXMuX2NvdW50KzF9c2V0UmlnaHQodCl7dGhpcy5fcmlnaHQ9dH1nZXRDbGFzcygpe3JldHVybiB0c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcD1udWxsLHRoaXMuX2RhdGE9bnVsbCx0aGlzLl9sZWZ0PW51bGwsdGhpcy5fcmlnaHQ9bnVsbCx0aGlzLl9jb3VudD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wPW5ldyBnKHQpLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2NvdW50PTEsdGhpcy5fZGF0YT1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3A9bmV3IGcodCxlKSx0aGlzLl9sZWZ0PW51bGwsdGhpcy5fcmlnaHQ9bnVsbCx0aGlzLl9jb3VudD0xLHRoaXMuX2RhdGE9bn19O2NsYXNzIGVze2NvbnN0cnVjdG9yKCl7ZXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9Db29yZGluYXRlcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gZXMudG9Db29yZGluYXRlcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgSTtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPWU/dC5nZXRDb3VudCgpOjE7Zm9yKGxldCBlPTA7ZTxpO2UrKyluLmFkZCh0LmdldENvb3JkaW5hdGUoKSwhMCl9cmV0dXJuIG4udG9Db29yZGluYXRlQXJyYXkoKX19aW5zZXJ0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluc2VydCh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihudWxsPT09dGhpcy5fcm9vdClyZXR1cm4gdGhpcy5fcm9vdD1uZXcgdHModCxlKSx0aGlzLl9yb290O2lmKHRoaXMuX3RvbGVyYW5jZT4wKXtjb25zdCBlPXRoaXMuZmluZEJlc3RNYXRjaE5vZGUodCk7aWYobnVsbCE9PWUpcmV0dXJuIGUuaW5jcmVtZW50KCksZX1yZXR1cm4gdGhpcy5pbnNlcnRFeGFjdCh0LGUpfX1xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4O3JldHVybiB0aGlzLnF1ZXJ5KHQsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4mJl8oYXJndW1lbnRzWzFdLG0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnF1ZXJ5Tm9kZSh0aGlzLl9yb290LHQsITAsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVyblskbl19dmlzaXQodCl7ZS5hZGQodCl9fSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4mJl8oYXJndW1lbnRzWzFdLCRuKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5xdWVyeU5vZGUodGhpcy5fcm9vdCx0LCEwLGUpfX1xdWVyeU5vZGUodCxlLG4scyl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7bGV0IGk9bnVsbCxyPW51bGwsbz1udWxsO24/KGk9ZS5nZXRNaW5YKCkscj1lLmdldE1heFgoKSxvPXQuZ2V0WCgpKTooaT1lLmdldE1pblkoKSxyPWUuZ2V0TWF4WSgpLG89dC5nZXRZKCkpO2NvbnN0IGw9bzw9cjtpPG8mJnRoaXMucXVlcnlOb2RlKHQuZ2V0TGVmdCgpLGUsIW4scyksZS5jb250YWlucyh0LmdldENvb3JkaW5hdGUoKSkmJnMudmlzaXQodCksbCYmdGhpcy5xdWVyeU5vZGUodC5nZXRSaWdodCgpLGUsIW4scyl9ZmluZEJlc3RNYXRjaE5vZGUodCl7Y29uc3QgZT1uZXcgbnModCx0aGlzLl90b2xlcmFuY2UpO3JldHVybiB0aGlzLnF1ZXJ5KGUucXVlcnlFbnZlbG9wZSgpLGUpLGUuZ2V0Tm9kZSgpfWlzRW1wdHkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Jvb3R9aW5zZXJ0RXhhY3QodCxlKXtsZXQgbj10aGlzLl9yb290LHM9dGhpcy5fcm9vdCxpPSEwLHI9ITA7Zm9yKDtudWxsIT09bjspe2lmKG51bGwhPT1uKXtpZih0LmRpc3RhbmNlKG4uZ2V0Q29vcmRpbmF0ZSgpKTw9dGhpcy5fdG9sZXJhbmNlKXJldHVybiBuLmluY3JlbWVudCgpLG59cj1pP3QueDxuLmdldFgoKTp0Lnk8bi5nZXRZKCkscz1uLG49cj9uLmdldExlZnQoKTpuLmdldFJpZ2h0KCksaT0haX10aGlzLl9udW1iZXJPZk5vZGVzPXRoaXMuX251bWJlck9mTm9kZXMrMTtjb25zdCBvPW5ldyB0cyh0LGUpO3JldHVybiByP3Muc2V0TGVmdChvKTpzLnNldFJpZ2h0KG8pLG99Z2V0Q2xhc3MoKXtyZXR1cm4gZXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIG5ze2NvbnN0cnVjdG9yKCl7bnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdCh0KXtjb25zdCBlPXRoaXMuX3AuZGlzdGFuY2UodC5nZXRDb29yZGluYXRlKCkpO2lmKCEoZTw9dGhpcy5fdG9sZXJhbmNlKSlyZXR1cm4gbnVsbDtsZXQgbj0hMTsobnVsbD09PXRoaXMuX21hdGNoTm9kZXx8ZTx0aGlzLl9tYXRjaERpc3R8fG51bGwhPT10aGlzLl9tYXRjaE5vZGUmJmU9PT10aGlzLl9tYXRjaERpc3QmJnQuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLl9tYXRjaE5vZGUuZ2V0Q29vcmRpbmF0ZSgpKTwxKSYmKG49ITApLG4mJih0aGlzLl9tYXRjaE5vZGU9dCx0aGlzLl9tYXRjaERpc3Q9ZSl9cXVlcnlFbnZlbG9wZSgpe2NvbnN0IHQ9bmV3IE4odGhpcy5fcCk7cmV0dXJuIHQuZXhwYW5kQnkodGhpcy5fdG9sZXJhbmNlKSx0fWdldE5vZGUoKXtyZXR1cm4gdGhpcy5fbWF0Y2hOb2RlfWdldENsYXNzKCl7cmV0dXJuIG5zfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblskbl19fW5zLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3RvbGVyYW5jZT1udWxsLHRoaXMuX21hdGNoTm9kZT1udWxsLHRoaXMuX21hdGNoRGlzdD0wLHRoaXMuX3A9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wPXQsdGhpcy5fdG9sZXJhbmNlPWV9LGVzLkJlc3RNYXRjaFZpc2l0b3I9bnMsZXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcm9vdD1udWxsLHRoaXMuX251bWJlck9mTm9kZXM9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCllcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3RvbGVyYW5jZT10fX07dmFyIHNzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEtkVHJlZTplc30pO2NsYXNzIGlze2NvbnN0cnVjdG9yKCl7aXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0U3Vibm9kZUluZGV4KHQsZSxuKXtsZXQgcz0tMTtyZXR1cm4gdC5nZXRNaW5YKCk+PWUmJih0LmdldE1pblkoKT49biYmKHM9MyksdC5nZXRNYXhZKCk8PW4mJihzPTEpKSx0LmdldE1heFgoKTw9ZSYmKHQuZ2V0TWluWSgpPj1uJiYocz0yKSx0LmdldE1heFkoKTw9biYmKHM9MCkpLHN9aGFzQ2hpbGRyZW4oKXtmb3IobGV0IHQ9MDt0PDQ7dCsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW3RdKXJldHVybiEwO3JldHVybiExfWlzUHJ1bmFibGUoKXtyZXR1cm4hKHRoaXMuaGFzQ2hpbGRyZW4oKXx8dGhpcy5oYXNJdGVtcygpKX1hZGRBbGxJdGVtcyh0KXt0LmFkZEFsbCh0aGlzLl9pdGVtcyk7Zm9yKGxldCBlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmdGhpcy5fc3Vibm9kZVtlXS5hZGRBbGxJdGVtcyh0KTtyZXR1cm4gdH1nZXROb2RlQ291bnQoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJih0Kz10aGlzLl9zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrMX1zaXplKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLl9zdWJub2RlW2VdJiYodCs9dGhpcy5fc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0K3RoaXMuX2l0ZW1zLnNpemUoKX1hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuIG51bGw7ZS5hZGRBbGwodGhpcy5faXRlbXMpO2ZvcihsZXQgbj0wO248NDtuKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbbl0mJnRoaXMuX3N1Ym5vZGVbbl0uYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKX12aXNpdEl0ZW1zKHQsZSl7Zm9yKGxldCB0PXRoaXMuX2l0ZW1zLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWUudmlzaXRJdGVtKHQubmV4dCgpKX1oYXNJdGVtcygpe3JldHVybiF0aGlzLl9pdGVtcy5pc0VtcHR5KCl9cmVtb3ZlKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4hMTtsZXQgbj0hMTtmb3IobGV0IHM9MDtzPDQ7cysrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW3NdJiYobj10aGlzLl9zdWJub2RlW3NdLnJlbW92ZSh0LGUpLG4pKXt0aGlzLl9zdWJub2RlW3NdLmlzUHJ1bmFibGUoKSYmKHRoaXMuX3N1Ym5vZGVbc109bnVsbCk7YnJlYWt9cmV0dXJuIG58fChuPXRoaXMuX2l0ZW1zLnJlbW92ZShlKSxuKX12aXNpdCh0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuIG51bGw7dGhpcy52aXNpdEl0ZW1zKHQsZSk7Zm9yKGxldCBuPTA7bjw0O24rKyludWxsIT09dGhpcy5fc3Vibm9kZVtuXSYmdGhpcy5fc3Vibm9kZVtuXS52aXNpdCh0LGUpfWdldEl0ZW1zKCl7cmV0dXJuIHRoaXMuX2l0ZW1zfWRlcHRoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPDQ7ZSsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdKXtjb25zdCBuPXRoaXMuX3N1Ym5vZGVbZV0uZGVwdGgoKTtuPnQmJih0PW4pfXJldHVybiB0KzF9aXNFbXB0eSgpe2xldCB0PSEwO2lmKHRoaXMuX2l0ZW1zLmlzRW1wdHkoKSl7Zm9yKGxldCBlPTA7ZTw0O2UrKylpZihudWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmIXRoaXMuX3N1Ym5vZGVbZV0uaXNFbXB0eSgpKXt0PSExO2JyZWFrfX1lbHNlIHQ9ITE7cmV0dXJuIHR9YWRkKHQpe3RoaXMuX2l0ZW1zLmFkZCh0KX1nZXRDbGFzcygpe3JldHVybiBpc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fWZ1bmN0aW9uIHJzKCl7fWlzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2l0ZW1zPW5ldyB4LHRoaXMuX3N1Ym5vZGU9bmV3IEFycmF5KDQpLmZpbGwobnVsbCl9LHJzLmV4cG9uZW50PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUpe2xldCBuLHMsaSxyO2NvbnN0IG89ezMyOntkOjEyNyxjOjEyOCxiOjAsYTowfSw2NDp7ZDozMjc1MixjOjAsYjowLGE6MH19LGw9ezMyOjgsNjQ6MTF9W3RdO3J8fChuPWU8MHx8MS9lPDAsaXNGaW5pdGUoZSl8fChyPW9bdF0sbiYmKHIuZCs9MTw8dC80LTEpLHM9TWF0aC5wb3coMixsKS0xLGk9MCkpO2lmKCFyKXtmb3Iocz17MzI6MTI3LDY0OjEwMjN9W3RdLGk9TWF0aC5hYnMoZSk7aT49MjspcysrLGkvPTI7Zm9yKDtpPDEmJnM+MDspcy0tLGkqPTI7czw9MCYmKGkvPTIpLDMyPT09dCYmcz4yNTQmJihyPXtkOm4/MjU1OjEyNyxjOjEyOCxiOjAsYTowfSxzPU1hdGgucG93KDIsbCktMSxpPTApfXJldHVybiBzfSg2NCx0KS0xMDIzfSxycy5wb3dlck9mMj1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMix0KX07Y2xhc3Mgb3N7Y29uc3RydWN0b3IoKXtvcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21wdXRlUXVhZExldmVsKHQpe2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKSxzPWU+bj9lOm47cmV0dXJuIHJzLmV4cG9uZW50KHMpKzF9Z2V0TGV2ZWwoKXtyZXR1cm4gdGhpcy5fbGV2ZWx9Y29tcHV0ZUtleSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IodGhpcy5fbGV2ZWw9b3MuY29tcHV0ZVF1YWRMZXZlbCh0KSx0aGlzLl9lbnY9bmV3IE4sdGhpcy5jb21wdXRlS2V5KHRoaXMuX2xldmVsLHQpOyF0aGlzLl9lbnYuY29udGFpbnModCk7KXRoaXMuX2xldmVsKz0xLHRoaXMuY29tcHV0ZUtleSh0aGlzLl9sZXZlbCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXJzLnBvd2VyT2YyKHQpO3RoaXMuX3B0Lng9TWF0aC5mbG9vcihlLmdldE1pblgoKS9uKSpuLHRoaXMuX3B0Lnk9TWF0aC5mbG9vcihlLmdldE1pblkoKS9uKSpuLHRoaXMuX2Vudi5pbml0KHRoaXMuX3B0LngsdGhpcy5fcHQueCtuLHRoaXMuX3B0LnksdGhpcy5fcHQueStuKX19Z2V0RW52ZWxvcGUoKXtyZXR1cm4gdGhpcy5fZW52fWdldENlbnRyZSgpe3JldHVybiBuZXcgZygodGhpcy5fZW52LmdldE1pblgoKSt0aGlzLl9lbnYuZ2V0TWF4WCgpKS8yLCh0aGlzLl9lbnYuZ2V0TWluWSgpK3RoaXMuX2Vudi5nZXRNYXhZKCkpLzIpfWdldFBvaW50KCl7cmV0dXJuIHRoaXMuX3B0fWdldENsYXNzKCl7cmV0dXJuIG9zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1vcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdD1uZXcgZyx0aGlzLl9sZXZlbD0wLHRoaXMuX2Vudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY29tcHV0ZUtleSh0KX07Y2xhc3MgbHMgZXh0ZW5kcyBpc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY3JlYXRlTm9kZSh0KXtjb25zdCBlPW5ldyBvcyh0KTtyZXR1cm4gbmV3IGxzKGUuZ2V0RW52ZWxvcGUoKSxlLmdldExldmVsKCkpfXN0YXRpYyBjcmVhdGVFeHBhbmRlZCh0LGUpe2NvbnN0IG49bmV3IE4oZSk7bnVsbCE9PXQmJm4uZXhwYW5kVG9JbmNsdWRlKHQuX2Vudik7Y29uc3Qgcz1scy5jcmVhdGVOb2RlKG4pO3JldHVybiBudWxsIT09dCYmcy5pbnNlcnROb2RlKHQpLHN9ZmluZCh0KXtjb25zdCBlPWlzLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuX2NlbnRyZXgsdGhpcy5fY2VudHJleSk7aWYoLTE9PT1lKXJldHVybiB0aGlzO2lmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdKXtyZXR1cm4gdGhpcy5fc3Vibm9kZVtlXS5maW5kKHQpfXJldHVybiB0aGlzfWlzU2VhcmNoTWF0Y2godCl7cmV0dXJuIG51bGwhPT10JiZ0aGlzLl9lbnYuaW50ZXJzZWN0cyh0KX1nZXRTdWJub2RlKHQpe3JldHVybiBudWxsPT09dGhpcy5fc3Vibm9kZVt0XSYmKHRoaXMuX3N1Ym5vZGVbdF09dGhpcy5jcmVhdGVTdWJub2RlKHQpKSx0aGlzLl9zdWJub2RlW3RdfWdldEVudmVsb3BlKCl7cmV0dXJuIHRoaXMuX2Vudn1nZXROb2RlKHQpe2NvbnN0IGU9aXMuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5fY2VudHJleCx0aGlzLl9jZW50cmV5KTtpZigtMSE9PWUpe3JldHVybiB0aGlzLmdldFN1Ym5vZGUoZSkuZ2V0Tm9kZSh0KX1yZXR1cm4gdGhpc31jcmVhdGVTdWJub2RlKHQpe2xldCBlPTAsbj0wLHM9MCxpPTA7c3dpdGNoKHQpe2Nhc2UgMDplPXRoaXMuX2Vudi5nZXRNaW5YKCksbj10aGlzLl9jZW50cmV4LHM9dGhpcy5fZW52LmdldE1pblkoKSxpPXRoaXMuX2NlbnRyZXk7YnJlYWs7Y2FzZSAxOmU9dGhpcy5fY2VudHJleCxuPXRoaXMuX2Vudi5nZXRNYXhYKCkscz10aGlzLl9lbnYuZ2V0TWluWSgpLGk9dGhpcy5fY2VudHJleTticmVhaztjYXNlIDI6ZT10aGlzLl9lbnYuZ2V0TWluWCgpLG49dGhpcy5fY2VudHJleCxzPXRoaXMuX2NlbnRyZXksaT10aGlzLl9lbnYuZ2V0TWF4WSgpO2JyZWFrO2Nhc2UgMzplPXRoaXMuX2NlbnRyZXgsbj10aGlzLl9lbnYuZ2V0TWF4WCgpLHM9dGhpcy5fY2VudHJleSxpPXRoaXMuX2Vudi5nZXRNYXhZKCl9Y29uc3Qgcj1uZXcgTihlLG4scyxpKTtyZXR1cm4gbmV3IGxzKHIsdGhpcy5fbGV2ZWwtMSl9aW5zZXJ0Tm9kZSh0KXt1LmlzVHJ1ZShudWxsPT09dGhpcy5fZW52fHx0aGlzLl9lbnYuY29udGFpbnModC5fZW52KSk7Y29uc3QgZT1pcy5nZXRTdWJub2RlSW5kZXgodC5fZW52LHRoaXMuX2NlbnRyZXgsdGhpcy5fY2VudHJleSk7aWYodC5fbGV2ZWw9PT10aGlzLl9sZXZlbC0xKXRoaXMuX3N1Ym5vZGVbZV09dDtlbHNle2NvbnN0IG49dGhpcy5jcmVhdGVTdWJub2RlKGUpO24uaW5zZXJ0Tm9kZSh0KSx0aGlzLl9zdWJub2RlW2VdPW59fWdldENsYXNzKCl7cmV0dXJuIGxzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1scy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9lbnY9bnVsbCx0aGlzLl9jZW50cmV4PW51bGwsdGhpcy5fY2VudHJleT1udWxsLHRoaXMuX2xldmVsPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZW52PXQsdGhpcy5fbGV2ZWw9ZSx0aGlzLl9jZW50cmV4PSh0LmdldE1pblgoKSt0LmdldE1heFgoKSkvMix0aGlzLl9jZW50cmV5PSh0LmdldE1pblkoKSt0LmdldE1heFkoKSkvMn07Y2xhc3MgYXN7Y29uc3RydWN0b3IoKXthcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc1plcm9XaWR0aCh0LGUpe2NvbnN0IG49ZS10O2lmKDA9PT1uKXJldHVybiEwO2NvbnN0IHM9bi9NYXRoLm1heChNYXRoLmFicyh0KSxNYXRoLmFicyhlKSk7cmV0dXJuIHJzLmV4cG9uZW50KHMpPD1hcy5NSU5fQklOQVJZX0VYUE9ORU5UfWdldENsYXNzKCl7cmV0dXJuIGFzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1hcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LGFzLk1JTl9CSU5BUllfRVhQT05FTlQ9LTUwO2NsYXNzIGNzIGV4dGVuZHMgaXN7Y29uc3RydWN0b3IoKXtzdXBlcigpLGNzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0KHQsZSl7Y29uc3Qgbj1pcy5nZXRTdWJub2RlSW5kZXgodCxjcy5vcmlnaW4ueCxjcy5vcmlnaW4ueSk7aWYoLTE9PT1uKXJldHVybiB0aGlzLmFkZChlKSxudWxsO2NvbnN0IHM9dGhpcy5fc3Vibm9kZVtuXTtpZihudWxsPT09c3x8IXMuZ2V0RW52ZWxvcGUoKS5jb250YWlucyh0KSl7Y29uc3QgZT1scy5jcmVhdGVFeHBhbmRlZChzLHQpO3RoaXMuX3N1Ym5vZGVbbl09ZX10aGlzLmluc2VydENvbnRhaW5lZCh0aGlzLl9zdWJub2RlW25dLHQsZSl9aXNTZWFyY2hNYXRjaCh0KXtyZXR1cm4hMH1pbnNlcnRDb250YWluZWQodCxlLG4pe3UuaXNUcnVlKHQuZ2V0RW52ZWxvcGUoKS5jb250YWlucyhlKSk7Y29uc3Qgcz1hcy5pc1plcm9XaWR0aChlLmdldE1pblgoKSxlLmdldE1heFgoKSksaT1hcy5pc1plcm9XaWR0aChlLmdldE1pblkoKSxlLmdldE1heFkoKSk7bGV0IHI9bnVsbDtyPXN8fGk/dC5maW5kKGUpOnQuZ2V0Tm9kZShlKSxyLmFkZChuKX1nZXRDbGFzcygpe3JldHVybiBjc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y3MuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxjcy5vcmlnaW49bmV3IGcoMCwwKTtjbGFzcyBoc3tjb25zdHJ1Y3Rvcigpe2hzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0KHQsZSl7fXJlbW92ZSh0LGUpe31xdWVyeSgpe31nZXRDbGFzcygpe3JldHVybiBoc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB1c3tjb25zdHJ1Y3Rvcigpe3VzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGVuc3VyZUV4dGVudCh0LGUpe2xldCBuPXQuZ2V0TWluWCgpLHM9dC5nZXRNYXhYKCksaT10LmdldE1pblkoKSxyPXQuZ2V0TWF4WSgpO3JldHVybiBuIT09cyYmaSE9PXI/dDoobj09PXMmJihuLT1lLzIscz1uK2UvMiksaT09PXImJihpLT1lLzIscj1pK2UvMiksbmV3IE4obixzLGkscikpfXNpemUoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3Jvb3Q/dGhpcy5fcm9vdC5zaXplKCk6MH1pbnNlcnQodCxlKXt0aGlzLmNvbGxlY3RTdGF0cyh0KTtjb25zdCBuPXVzLmVuc3VyZUV4dGVudCh0LHRoaXMuX21pbkV4dGVudCk7dGhpcy5fcm9vdC5pbnNlcnQobixlKX1xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBZZTtyZXR1cm4gdGhpcy5xdWVyeSh0LGUpLGUuZ2V0SXRlbXMoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcm9vdC52aXNpdCh0LGUpfX1xdWVyeUFsbCgpe2NvbnN0IHQ9bmV3IHg7cmV0dXJuIHRoaXMuX3Jvb3QuYWRkQWxsSXRlbXModCksdH1yZW1vdmUodCxlKXtjb25zdCBuPXVzLmVuc3VyZUV4dGVudCh0LHRoaXMuX21pbkV4dGVudCk7cmV0dXJuIHRoaXMuX3Jvb3QucmVtb3ZlKG4sZSl9Y29sbGVjdFN0YXRzKHQpe2NvbnN0IGU9dC5nZXRXaWR0aCgpO2U8dGhpcy5fbWluRXh0ZW50JiZlPjAmJih0aGlzLl9taW5FeHRlbnQ9ZSk7Y29uc3Qgbj10LmdldEhlaWdodCgpO248dGhpcy5fbWluRXh0ZW50JiZuPjAmJih0aGlzLl9taW5FeHRlbnQ9bil9ZGVwdGgoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3Jvb3Q/dGhpcy5fcm9vdC5kZXB0aCgpOjB9aXNFbXB0eSgpe3JldHVybiBudWxsPT09dGhpcy5fcm9vdHx8dGhpcy5fcm9vdC5pc0VtcHR5KCl9Z2V0Q2xhc3MoKXtyZXR1cm4gdXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2hzLGFdfX11cy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yb290PW51bGwsdGhpcy5fbWluRXh0ZW50PTEsdGhpcy5fcm9vdD1uZXcgY3N9LHVzLnNlcmlhbFZlcnNpb25VSUQ9LTB4Njc4YjYwYzk2N2EyNTQwMDt2YXIgZ3M9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsUXVhZHRyZWU6dXN9KTtjbGFzcyBkc3tjb25zdHJ1Y3Rvcigpe2RzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRzKCl7fWdldENsYXNzKCl7cmV0dXJuIGRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1kcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIF9ze2NvbnN0cnVjdG9yKCl7X3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRJdGVtKCl7cmV0dXJuIHRoaXMuX2l0ZW19Z2V0Qm91bmRzKCl7cmV0dXJuIHRoaXMuX2JvdW5kc31nZXRDbGFzcygpe3JldHVybiBfc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZHMsYV19fV9zLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2JvdW5kcz1udWxsLHRoaXMuX2l0ZW09bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ib3VuZHM9dCx0aGlzLl9pdGVtPWV9O2NsYXNzIGZze2NvbnN0cnVjdG9yKCl7ZnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1wb2xsKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLl9pdGVtcy5nZXQoMSk7cmV0dXJuIHRoaXMuX2l0ZW1zLnNldCgxLHRoaXMuX2l0ZW1zLmdldCh0aGlzLl9zaXplKSksdGhpcy5fc2l6ZS09MSx0aGlzLnJlb3JkZXIoMSksdH1zaXplKCl7cmV0dXJuIHRoaXMuX3NpemV9cmVvcmRlcih0KXtsZXQgZT1udWxsO2NvbnN0IG49dGhpcy5faXRlbXMuZ2V0KHQpO2Zvcig7Mip0PD10aGlzLl9zaXplJiYoZT0yKnQsZSE9PXRoaXMuX3NpemUmJnRoaXMuX2l0ZW1zLmdldChlKzEpLmNvbXBhcmVUbyh0aGlzLl9pdGVtcy5nZXQoZSkpPDAmJmUrKyx0aGlzLl9pdGVtcy5nZXQoZSkuY29tcGFyZVRvKG4pPDApO3Q9ZSl0aGlzLl9pdGVtcy5zZXQodCx0aGlzLl9pdGVtcy5nZXQoZSkpO3RoaXMuX2l0ZW1zLnNldCh0LG4pfWNsZWFyKCl7dGhpcy5fc2l6ZT0wLHRoaXMuX2l0ZW1zLmNsZWFyKCl9cGVlaygpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3JldHVybiB0aGlzLl9pdGVtcy5nZXQoMSl9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5fc2l6ZX1hZGQodCl7dGhpcy5faXRlbXMuYWRkKG51bGwpLHRoaXMuX3NpemUrPTE7bGV0IGU9dGhpcy5fc2l6ZTtmb3IodGhpcy5faXRlbXMuc2V0KDAsdCk7dC5jb21wYXJlVG8odGhpcy5faXRlbXMuZ2V0KE1hdGgudHJ1bmMoZS8yKSkpPDA7ZS89Mil0aGlzLl9pdGVtcy5zZXQoZSx0aGlzLl9pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk7dGhpcy5faXRlbXMuc2V0KGUsdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gZnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NpemU9bnVsbCx0aGlzLl9pdGVtcz1udWxsLHRoaXMuX3NpemU9MCx0aGlzLl9pdGVtcz1uZXcgeCx0aGlzLl9pdGVtcy5hZGQobnVsbCl9O2NsYXNzIHBze2NvbnN0cnVjdG9yKCl7cHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRMZXZlbCgpe3JldHVybiB0aGlzLl9sZXZlbH1zaXplKCl7cmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5zaXplKCl9Z2V0Q2hpbGRCb3VuZGFibGVzKCl7cmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlc31hZGRDaGlsZEJvdW5kYWJsZSh0KXt1LmlzVHJ1ZShudWxsPT09dGhpcy5fYm91bmRzKSx0aGlzLl9jaGlsZEJvdW5kYWJsZXMuYWRkKHQpfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzLmlzRW1wdHkoKX1nZXRCb3VuZHMoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2JvdW5kcyYmKHRoaXMuX2JvdW5kcz10aGlzLmNvbXB1dGVCb3VuZHMoKSksdGhpcy5fYm91bmRzfWdldENsYXNzKCl7cmV0dXJuIHBzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltkcyxhXX19cHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fY2hpbGRCb3VuZGFibGVzPW5ldyB4LHRoaXMuX2JvdW5kcz1udWxsLHRoaXMuX2xldmVsPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xldmVsPXR9fSxwcy5zZXJpYWxWZXJzaW9uVUlEPTB4NWExZTU1ZWM0MTM2OTgwMDtjbGFzcyBtc3tjb25zdHJ1Y3Rvcigpe21zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGFyZWEodCl7cmV0dXJuIHQuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpfXN0YXRpYyBpc0NvbXBvc2l0ZSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHBzfWV4cGFuZFRvUXVldWUodCxlKXtjb25zdCBzPW1zLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTEpLGk9bXMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMik7aWYocyYmaSlyZXR1cm4gbXMuYXJlYSh0aGlzLl9ib3VuZGFibGUxKT5tcy5hcmVhKHRoaXMuX2JvdW5kYWJsZTIpPyh0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUxLHRoaXMuX2JvdW5kYWJsZTIsdCxlKSxudWxsKToodGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMix0aGlzLl9ib3VuZGFibGUxLHQsZSksbnVsbCk7aWYocylyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMSx0aGlzLl9ib3VuZGFibGUyLHQsZSksbnVsbDtpZihpKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUyLHRoaXMuX2JvdW5kYWJsZTEsdCxlKSxudWxsO3Rocm93IG5ldyBuKFwibmVpdGhlciBib3VuZGFibGUgaXMgY29tcG9zaXRlXCIpfWlzTGVhdmVzKCl7cmV0dXJuIShtcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUxKXx8bXMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMikpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlPGUuX2Rpc3RhbmNlPy0xOnRoaXMuX2Rpc3RhbmNlPmUuX2Rpc3RhbmNlPzE6MH1leHBhbmQodCxlLG4scyl7Zm9yKGxldCBpPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IHQ9aS5uZXh0KCkscj1uZXcgbXModCxlLHRoaXMuX2l0ZW1EaXN0YW5jZSk7ci5nZXREaXN0YW5jZSgpPHMmJm4uYWRkKHIpfX1nZXRCb3VuZGFibGUodCl7cmV0dXJuIDA9PT10P3RoaXMuX2JvdW5kYWJsZTE6dGhpcy5fYm91bmRhYmxlMn1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9kaXN0YW5jZX1kaXN0YW5jZSgpe3JldHVybiB0aGlzLmlzTGVhdmVzKCk/dGhpcy5faXRlbURpc3RhbmNlLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMik6dGhpcy5fYm91bmRhYmxlMS5nZXRCb3VuZHMoKS5kaXN0YW5jZSh0aGlzLl9ib3VuZGFibGUyLmdldEJvdW5kcygpKX1nZXRDbGFzcygpe3JldHVybiBtc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fW1zLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2JvdW5kYWJsZTE9bnVsbCx0aGlzLl9ib3VuZGFibGUyPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLl9pdGVtRGlzdGFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9ib3VuZGFibGUxPXQsdGhpcy5fYm91bmRhYmxlMj1lLHRoaXMuX2l0ZW1EaXN0YW5jZT1uLHRoaXMuX2Rpc3RhbmNlPXRoaXMuZGlzdGFuY2UoKX07Y2xhc3MgeXN7Y29uc3RydWN0b3IoKXt5cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21wYXJlRG91Ymxlcyh0LGUpe3JldHVybiB0PmU/MTp0PGU/LTE6MH1xdWVyeUludGVybmFsKCl7aWYoXyhhcmd1bWVudHNbMl0sQWUpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBwcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1lLmdldENoaWxkQm91bmRhYmxlcygpO2ZvcihsZXQgZT0wO2U8cy5zaXplKCk7ZSsrKXtjb25zdCBpPXMuZ2V0KGUpO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhpLmdldEJvdW5kcygpLHQpJiYoaSBpbnN0YW5jZW9mIHBzP3RoaXMucXVlcnlJbnRlcm5hbCh0LGksbik6aSBpbnN0YW5jZW9mIF9zP24udmlzaXRJdGVtKGkuZ2V0SXRlbSgpKTp1LnNob3VsZE5ldmVyUmVhY2hIZXJlKCkpfX1lbHNlIGlmKF8oYXJndW1lbnRzWzJdLG0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBwcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1lLmdldENoaWxkQm91bmRhYmxlcygpO2ZvcihsZXQgZT0wO2U8cy5zaXplKCk7ZSsrKXtjb25zdCBpPXMuZ2V0KGUpO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhpLmdldEJvdW5kcygpLHQpJiYoaSBpbnN0YW5jZW9mIHBzP3RoaXMucXVlcnlJbnRlcm5hbCh0LGksbik6aSBpbnN0YW5jZW9mIF9zP24uYWRkKGkuZ2V0SXRlbSgpKTp1LnNob3VsZE5ldmVyUmVhY2hIZXJlKCkpfX19Z2V0Tm9kZUNhcGFjaXR5KCl7cmV0dXJuIHRoaXMuX25vZGVDYXBhY2l0eX1sYXN0Tm9kZSh0KXtyZXR1cm4gdC5nZXQodC5zaXplKCktMSl9c2l6ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5zaXplKHRoaXMuX3Jvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9MDtmb3IobGV0IGU9YXJndW1lbnRzWzBdLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24gaW5zdGFuY2VvZiBwcz90Kz10aGlzLnNpemUobik6biBpbnN0YW5jZW9mIF9zJiYodCs9MSl9cmV0dXJuIHR9fXJlbW92ZUl0ZW0odCxlKXtsZXQgbj1udWxsO2ZvcihsZXQgcz10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QgaW5zdGFuY2VvZiBfcyYmdC5nZXRJdGVtKCk9PT1lJiYobj10KX1yZXR1cm4gbnVsbCE9PW4mJih0LmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShuKSwhMCl9aXRlbXNUcmVlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMuYnVpbGQoKTtjb25zdCB0PXRoaXMuaXRlbXNUcmVlKHRoaXMuX3Jvb3QpO3JldHVybiBudWxsPT09dD9uZXcgeDp0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4O2ZvcihsZXQgbj10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQgaW5zdGFuY2VvZiBwcyl7Y29uc3Qgbj10aGlzLml0ZW1zVHJlZSh0KTtudWxsIT09biYmZS5hZGQobil9ZWxzZSB0IGluc3RhbmNlb2YgX3M/ZS5hZGQodC5nZXRJdGVtKCkpOnUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gZS5zaXplKCk8PTA/bnVsbDplfX1pbnNlcnQodCxlKXt1LmlzVHJ1ZSghdGhpcy5fYnVpbHQsXCJDYW5ub3QgaW5zZXJ0IGl0ZW1zIGludG8gYW4gU1RSIHBhY2tlZCBSLXRyZWUgYWZ0ZXIgaXQgaGFzIGJlZW4gYnVpbHQuXCIpLHRoaXMuX2l0ZW1Cb3VuZGFibGVzLmFkZChuZXcgX3ModCxlKSl9Ym91bmRhYmxlc0F0TGV2ZWwoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgeDtyZXR1cm4gdGhpcy5ib3VuZGFibGVzQXRMZXZlbCh0LHRoaXMuX3Jvb3QsZSksZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodS5pc1RydWUodD4tMiksZS5nZXRMZXZlbCgpPT09dClyZXR1cm4gbi5hZGQoZSksbnVsbDtmb3IobGV0IHM9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgZT1zLm5leHQoKTtlIGluc3RhbmNlb2YgcHM/dGhpcy5ib3VuZGFibGVzQXRMZXZlbCh0LGUsbik6KHUuaXNUcnVlKGUgaW5zdGFuY2VvZiBfcyksLTE9PT10JiZuLmFkZChlKSl9cmV0dXJuIG51bGx9fXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYnVpbGQoKTtjb25zdCBlPW5ldyB4O3JldHVybiB0aGlzLmlzRW1wdHkoKXx8dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucXVlcnlJbnRlcm5hbCh0LHRoaXMuX3Jvb3QsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5idWlsZCgpLHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnF1ZXJ5SW50ZXJuYWwodCx0aGlzLl9yb290LGUpfX1idWlsZCgpe2lmKHRoaXMuX2J1aWx0KXJldHVybiBudWxsO3RoaXMuX3Jvb3Q9dGhpcy5faXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpP3RoaXMuY3JlYXRlTm9kZSgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyh0aGlzLl9pdGVtQm91bmRhYmxlcywtMSksdGhpcy5faXRlbUJvdW5kYWJsZXM9bnVsbCx0aGlzLl9idWlsdD0hMH1nZXRSb290KCl7cmV0dXJuIHRoaXMuYnVpbGQoKSx0aGlzLl9yb290fXJlbW92ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5idWlsZCgpLCEhdGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucmVtb3ZlKHQsdGhpcy5fcm9vdCxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bGV0IHM9dGhpcy5yZW1vdmVJdGVtKGUsbik7aWYocylyZXR1cm4hMDtsZXQgaT1udWxsO2ZvcihsZXQgcj1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXtjb25zdCBlPXIubmV4dCgpO2lmKHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhlLmdldEJvdW5kcygpLHQpJiYoZSBpbnN0YW5jZW9mIHBzJiYocz10aGlzLnJlbW92ZSh0LGUsbikscykpKXtpPWU7YnJlYWt9fXJldHVybiBudWxsIT09aSYmaS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pc0VtcHR5KCkmJmUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKGkpLHN9fWNyZWF0ZUhpZ2hlckxldmVscyh0LGUpe3UuaXNUcnVlKCF0LmlzRW1wdHkoKSk7Y29uc3Qgbj10aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKzEpO3JldHVybiAxPT09bi5zaXplKCk/bi5nZXQoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHMobixlKzEpfWRlcHRoKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLmRlcHRoKHRoaXMuX3Jvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9MDtmb3IobGV0IGU9YXJndW1lbnRzWzBdLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4gaW5zdGFuY2VvZiBwcyl7Y29uc3QgZT10aGlzLmRlcHRoKG4pO2U+dCYmKHQ9ZSl9fXJldHVybiB0KzF9fWNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKXt1LmlzVHJ1ZSghdC5pc0VtcHR5KCkpO2NvbnN0IG49bmV3IHg7bi5hZGQodGhpcy5jcmVhdGVOb2RlKGUpKTtjb25zdCBzPW5ldyB4KHQpO0VlLnNvcnQocyx0aGlzLmdldENvbXBhcmF0b3IoKSk7Zm9yKGxldCB0PXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IHM9dC5uZXh0KCk7dGhpcy5sYXN0Tm9kZShuKS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5zaXplKCk9PT10aGlzLmdldE5vZGVDYXBhY2l0eSgpJiZuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpLHRoaXMubGFzdE5vZGUobikuYWRkQ2hpbGRCb3VuZGFibGUocyl9cmV0dXJuIG59aXNFbXB0eSgpe3JldHVybiB0aGlzLl9idWlsdD90aGlzLl9yb290LmlzRW1wdHkoKTp0aGlzLl9pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCl9Z2V0Q2xhc3MoKXtyZXR1cm4geXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX15cy5JbnRlcnNlY3RzT3A9ZnVuY3Rpb24oKXt9LHlzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9idWlsdD0hMSx0aGlzLl9pdGVtQm91bmRhYmxlcz1uZXcgeCx0aGlzLl9ub2RlQ2FwYWNpdHk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl5cy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHlzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dS5pc1RydWUodD4xLFwiTm9kZSBjYXBhY2l0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxXCIpLHRoaXMuX25vZGVDYXBhY2l0eT10fX0seXMuc2VyaWFsVmVyc2lvblVJRD0tMHgzNWVmNjRjODJkNGM1NDAwLHlzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWT0xMDtjbGFzcyB4c3tjb25zdHJ1Y3Rvcigpe3hzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZGlzdGFuY2UodCxlKXt9Z2V0Q2xhc3MoKXtyZXR1cm4geHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXhzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgRXMgZXh0ZW5kcyB5c3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY2VudHJlWCh0KXtyZXR1cm4gRXMuYXZnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WCgpKX1zdGF0aWMgYXZnKHQsZSl7cmV0dXJuKHQrZSkvMn1zdGF0aWMgZ2V0SXRlbXModCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7bGV0IG49MDtmb3IoOyF0LmlzRW1wdHkoKTspe2NvbnN0IHM9dC5wb2xsKCk7ZVtuXT1zLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksbisrfXJldHVybiBlfXN0YXRpYyBjZW50cmVZKHQpe3JldHVybiBFcy5hdmcodC5nZXRNaW5ZKCksdC5nZXRNYXhZKCkpfWNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXModCxlKXt1LmlzVHJ1ZSh0Lmxlbmd0aD4wKTtjb25zdCBuPW5ldyB4O2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKW4uYWRkQWxsKHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHRbc10sZSkpO3JldHVybiBufWNyZWF0ZU5vZGUodCl7cmV0dXJuIG5ldyBJcyh0KX1zaXplKCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP3N1cGVyLnNpemUuY2FsbCh0aGlzKTpzdXBlci5zaXplLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnQoKXtpZighKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKSlyZXR1cm4gc3VwZXIuaW5zZXJ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodC5pc051bGwoKSlyZXR1cm4gbnVsbDtzdXBlci5pbnNlcnQuY2FsbCh0aGlzLHQsZSl9fWdldEludGVyc2VjdHNPcCgpe3JldHVybiBFcy5pbnRlcnNlY3RzT3B9dmVydGljYWxTbGljZXModCxlKXtjb25zdCBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL2UpKSxzPW5ldyBBcnJheShlKS5maWxsKG51bGwpLGk9dC5pdGVyYXRvcigpO2ZvcihsZXQgdD0wO3Q8ZTt0Kyspe3NbdF09bmV3IHg7bGV0IGU9MDtmb3IoO2kuaGFzTmV4dCgpJiZlPG47KXtjb25zdCBuPWkubmV4dCgpO3NbdF0uYWRkKG4pLGUrK319cmV0dXJuIHN9cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHN1cGVyLnF1ZXJ5LmNhbGwodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07c3VwZXIucXVlcnkuY2FsbCh0aGlzLHQsZSl9fWdldENvbXBhcmF0b3IoKXtyZXR1cm4gRXMueUNvbXBhcmF0b3J9Y3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHQsZSl7cmV0dXJuIHN1cGVyLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXMuY2FsbCh0aGlzLHQsZSl9cmVtb3ZlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBzdXBlci5yZW1vdmUuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLnJlbW92ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZGVwdGgoKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/c3VwZXIuZGVwdGguY2FsbCh0aGlzKTpzdXBlci5kZXB0aC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUpe3UuaXNUcnVlKCF0LmlzRW1wdHkoKSk7Y29uc3Qgbj1NYXRoLnRydW5jKE1hdGguY2VpbCh0LnNpemUoKS90aGlzLmdldE5vZGVDYXBhY2l0eSgpKSkscz1uZXcgeCh0KTtFZS5zb3J0KHMsRXMueENvbXBhcmF0b3IpO2NvbnN0IGk9dGhpcy52ZXJ0aWNhbFNsaWNlcyhzLE1hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGguc3FydChuKSkpKTtyZXR1cm4gdGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzKGksZSl9bmVhcmVzdE5laWdoYm91cigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1swXSx4cykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IG1zKHRoaXMuZ2V0Um9vdCgpLHRoaXMuZ2V0Um9vdCgpLHQpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoZSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cih0LGkuUE9TSVRJVkVfSU5GSU5JVFkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEVzJiZfKGFyZ3VtZW50c1sxXSx4cykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IG1zKHRoaXMuZ2V0Um9vdCgpLHQuZ2V0Um9vdCgpLGUpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIobil9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcyYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9YXJndW1lbnRzWzFdLG49bnVsbDtjb25zdCBzPW5ldyBmcztmb3Iocy5hZGQodCk7IXMuaXNFbXB0eSgpJiZlPjA7KXtjb25zdCB0PXMucG9sbCgpLGk9dC5nZXREaXN0YW5jZSgpO2lmKGk+PWUpYnJlYWs7dC5pc0xlYXZlcygpPyhlPWksbj10KTp0LmV4cGFuZFRvUXVldWUocyxlKX1yZXR1cm5bbi5nZXRCb3VuZGFibGUoMCkuZ2V0SXRlbSgpLG4uZ2V0Qm91bmRhYmxlKDEpLmdldEl0ZW0oKV19aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcyYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKHQsaS5QT1NJVElWRV9JTkZJTklUWSxlKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMl0seHMpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgT2JqZWN0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBfcyh0LGUpLGk9bmV3IG1zKHRoaXMuZ2V0Um9vdCgpLHMsbik7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihpKVswXX1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgbXMmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2xldCBzPWU7Y29uc3QgaT1uZXcgZnM7aS5hZGQodCk7Y29uc3Qgcj1uZXcgZnM7Zm9yKDshaS5pc0VtcHR5KCkmJnM+PTA7KXtjb25zdCB0PWkucG9sbCgpLGU9dC5nZXREaXN0YW5jZSgpO2lmKGU+PXMpYnJlYWs7aWYodC5pc0xlYXZlcygpKWlmKHIuc2l6ZSgpPG4pci5hZGQodCk7ZWxzZXtyLnBlZWsoKS5nZXREaXN0YW5jZSgpPmUmJihyLnBvbGwoKSxyLmFkZCh0KSkscz1yLnBlZWsoKS5nZXREaXN0YW5jZSgpfWVsc2UgdC5leHBhbmRUb1F1ZXVlKGkscyl9cmV0dXJuIEVzLmdldEl0ZW1zKHIpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBfcyh0LGUpLHI9bmV3IG1zKHRoaXMuZ2V0Um9vdCgpLGksbik7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihyLHMpfX1nZXRDbGFzcygpe3JldHVybiBFc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5baHMsYV19fWNsYXNzIElzIGV4dGVuZHMgcHN7Y29uc3RydWN0b3IoKXtzdXBlcigpLElzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZUJvdW5kcygpe2xldCB0PW51bGw7Zm9yKGxldCBlPXRoaXMuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7bnVsbD09PXQ/dD1uZXcgTihuLmdldEJvdW5kcygpKTp0LmV4cGFuZFRvSW5jbHVkZShuLmdldEJvdW5kcygpKX1yZXR1cm4gdH1nZXRDbGFzcygpe3JldHVybiBJc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cHMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX0sRXMuU1RSdHJlZU5vZGU9SXMsRXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpRXMuY29uc3RydWN0b3JfLmNhbGwodGhpcyxFcy5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3lzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fSxFcy5zZXJpYWxWZXJzaW9uVUlEPTB4Mzk5MjBmN2Q1ZjI2MWUwLEVzLnhDb21wYXJhdG9yPW5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19Y29tcGFyZSh0LGUpe3JldHVybiB5cy5jb21wYXJlRG91YmxlcyhFcy5jZW50cmVYKHQuZ2V0Qm91bmRzKCkpLEVzLmNlbnRyZVgoZS5nZXRCb3VuZHMoKSkpfX0sRXMueUNvbXBhcmF0b3I9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX1jb21wYXJlKHQsZSl7cmV0dXJuIHlzLmNvbXBhcmVEb3VibGVzKEVzLmNlbnRyZVkodC5nZXRCb3VuZHMoKSksRXMuY2VudHJlWShlLmdldEJvdW5kcygpKSl9fSxFcy5pbnRlcnNlY3RzT3A9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltJbnRlcnNlY3RzT3BdfWludGVyc2VjdHModCxlKXtyZXR1cm4gdC5pbnRlcnNlY3RzKGUpfX0sRXMuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwO3ZhciBOcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxTVFJ0cmVlOkVzfSksQ3M9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsa2R0cmVlOnNzLHF1YWR0cmVlOmdzLHN0cnRyZWU6TnN9KTtjb25zdCBTcz1bXCJQb2ludFwiLFwiTXVsdGlQb2ludFwiLFwiTGluZVN0cmluZ1wiLFwiTXVsdGlMaW5lU3RyaW5nXCIsXCJQb2x5Z29uXCIsXCJNdWx0aVBvbHlnb25cIl07Y2xhc3Mgd3N7Y29uc3RydWN0b3IodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IEh0fXJlYWQodCl7bGV0IGU7ZT1cInN0cmluZ1wiPT10eXBlb2YgdD9KU09OLnBhcnNlKHQpOnQ7Y29uc3Qgbj1lLnR5cGU7aWYoIUxzW25dKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvSlNPTiB0eXBlOiBcIitlLnR5cGUpO3JldHVybi0xIT09U3MuaW5kZXhPZihuKT9Mc1tuXS5jYWxsKHRoaXMsZS5jb29yZGluYXRlcyk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PW4/THNbbl0uY2FsbCh0aGlzLGUuZ2VvbWV0cmllcyk6THNbbl0uY2FsbCh0aGlzLGUpfXdyaXRlKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeVR5cGUoKTtpZighVHNbZV0pdGhyb3cgbmV3IEVycm9yKFwiR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gVHNbZV0uY2FsbCh0aGlzLHQpfX1jb25zdCBMcz17RmVhdHVyZTpmdW5jdGlvbih0KXtjb25zdCBlPXt9O2Zvcihjb25zdCBuIGluIHQpZVtuXT10W25dO2lmKHQuZ2VvbWV0cnkpe2NvbnN0IG49dC5nZW9tZXRyeS50eXBlO2lmKCFMc1tuXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrdC50eXBlKTtlLmdlb21ldHJ5PXRoaXMucmVhZCh0Lmdlb21ldHJ5KX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PUxzLmJib3guY2FsbCh0aGlzLHQuYmJveCkpLGV9LEZlYXR1cmVDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9e307aWYodC5mZWF0dXJlcyl7ZS5mZWF0dXJlcz1bXTtmb3IobGV0IG49MDtuPHQuZmVhdHVyZXMubGVuZ3RoOysrbillLmZlYXR1cmVzLnB1c2godGhpcy5yZWFkKHQuZmVhdHVyZXNbbl0pKX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PXRoaXMucGFyc2UuYmJveC5jYWxsKHRoaXMsdC5iYm94KSksZX0sY29vcmRpbmF0ZXM6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbil7Y29uc3Qgcz10W25dO2UucHVzaChuZXcgZyhzWzBdLHNbMV0pKX1yZXR1cm4gZX0sYmJveDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhbbmV3IGcodFswXSx0WzFdKSxuZXcgZyh0WzJdLHRbMV0pLG5ldyBnKHRbMl0sdFszXSksbmV3IGcodFswXSx0WzNdKSxuZXcgZyh0WzBdLHRbMV0pXSl9LFBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IGcodFswXSx0WzFdKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSl9LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbillLnB1c2goTHMuUG9pbnQuY2FsbCh0aGlzLHRbbl0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPUxzLmNvb3JkaW5hdGVzLmNhbGwodGhpcyx0KTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlKX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKExzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHRbbl0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9THMuY29vcmRpbmF0ZXMuY2FsbCh0aGlzLHRbMF0pLG49dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhlKSxzPVtdO2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7KytlKXtjb25zdCBuPXRbZV0saT1Mcy5jb29yZGluYXRlcy5jYWxsKHRoaXMsbikscj10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGkpO3MucHVzaChyKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLHMpfSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbil7Y29uc3Qgcz10W25dO2UucHVzaChMcy5Qb2x5Z29uLmNhbGwodGhpcyxzKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pe2NvbnN0IHM9dFtuXTtlLnB1c2godGhpcy5yZWFkKHMpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0sVHM9e2Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuW3QueCx0LnldfSxQb2ludDpmdW5jdGlvbih0KXtyZXR1cm57dHlwZTpcIlBvaW50XCIsY29vcmRpbmF0ZXM6VHMuY29vcmRpbmF0ZS5jYWxsKHRoaXMsdC5nZXRDb29yZGluYXRlKCkpfX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1Ucy5Qb2ludC5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2ludFwiLGNvb3JkaW5hdGVzOmV9fSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W10sbj10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDsrK3Qpe2NvbnN0IHM9blt0XTtlLnB1c2goVHMuY29vcmRpbmF0ZS5jYWxsKHRoaXMscykpfXJldHVybnt0eXBlOlwiTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9VHMuTGluZVN0cmluZy5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6ZX19LFBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXSxuPVRzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHQuX3NoZWxsKTtlLnB1c2gobi5jb29yZGluYXRlcyk7Zm9yKGxldCBuPTA7bjx0Ll9ob2xlcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2hvbGVzW25dLGk9VHMuTGluZVN0cmluZy5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiUG9seWdvblwiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9VHMuUG9seWdvbi5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1zLmdldEdlb21ldHJ5VHlwZSgpO2UucHVzaChUc1tpXS5jYWxsKHRoaXMscykpfXJldHVybnt0eXBlOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsZ2VvbWV0cmllczplfX19O2Z1bmN0aW9uIFJzKHQpe3JldHVyblt0LngsdC55XX12YXIgUHM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvSlNPTlJlYWRlcjpjbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj1uZXcgd3ModHx8bmV3IEh0KX1yZWFkKHQpe3JldHVybiB0aGlzLnBhcnNlci5yZWFkKHQpfX0sR2VvSlNPTldyaXRlcjpjbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMucGFyc2VyPW5ldyB3cyh0aGlzLmdlb21ldHJ5RmFjdG9yeSl9d3JpdGUodCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfX0sT0wzUGFyc2VyOmNsYXNze2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IEh0LHRoaXMub2w9ZXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG9sJiZvbH1pbmplY3QodCxlLG4scyxpLHIsbyxsKXt0aGlzLm9sPXtnZW9tOntQb2ludDp0LExpbmVTdHJpbmc6ZSxMaW5lYXJSaW5nOm4sUG9seWdvbjpzLE11bHRpUG9pbnQ6aSxNdWx0aUxpbmVTdHJpbmc6cixNdWx0aVBvbHlnb246byxHZW9tZXRyeUNvbGxlY3Rpb246bH19fXJlYWQodCl7Y29uc3QgZT10aGlzLm9sO3JldHVybiB0IGluc3RhbmNlb2YgZS5nZW9tLlBvaW50P3RoaXMuY29udmVydEZyb21Qb2ludCh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5MaW5lYXJSaW5nP3RoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9pbnQodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aUxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uP3RoaXMuY29udmVydEZyb21Db2xsZWN0aW9uKHQpOnZvaWQgMH1jb252ZXJ0RnJvbVBvaW50KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChuZXcgZyhlWzBdLGVbMV0pKX1jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnKHRbMF0sdFsxXSl9KSkpfWNvbnZlcnRGcm9tTGluZWFyUmluZyh0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0LmdldENvb3JkaW5hdGVzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodFswXSx0WzFdKX0pKSl9Y29udmVydEZyb21Qb2x5Z29uKHQpe2NvbnN0IGU9dC5nZXRMaW5lYXJSaW5ncygpO2xldCBuPW51bGw7Y29uc3Qgcz1bXTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3QgaT10aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyhlW3RdKTswPT09dD9uPWk6cy5wdXNoKGkpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4scyl9Y29udmVydEZyb21NdWx0aVBvaW50KHQpe2NvbnN0IGU9dC5nZXRQb2ludHMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9pbnQodCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX1jb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZyh0KXtjb25zdCBlPXQuZ2V0TGluZVN0cmluZ3MoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tTGluZVN0cmluZyh0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9Y29udmVydEZyb21NdWx0aVBvbHlnb24odCl7Y29uc3QgZT10LmdldFBvbHlnb25zKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbVBvbHlnb24odCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfWNvbnZlcnRGcm9tQ29sbGVjdGlvbih0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cmllcygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZCh0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9d3JpdGUodCl7cmV0dXJuXCJQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb1BvaW50KHQuZ2V0Q29vcmRpbmF0ZSgpKTpcIkxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9MaW5lU3RyaW5nKHQpOlwiTGluZWFyUmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVhclJpbmcodCk6XCJQb2x5Z29uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9seWdvbih0KTpcIk11bHRpUG9pbnRcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvaW50KHQpOlwiTXVsdGlMaW5lU3RyaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlMaW5lU3RyaW5nKHQpOlwiTXVsdGlQb2x5Z29uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlQb2x5Z29uKHQpOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvQ29sbGVjdGlvbih0KTp2b2lkIDB9Y29udmVydFRvUG9pbnQodCl7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uUG9pbnQoW3QueCx0LnldKX1jb252ZXJ0VG9MaW5lU3RyaW5nKHQpe2NvbnN0IGU9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoUnMpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLkxpbmVTdHJpbmcoZSl9Y29udmVydFRvTGluZWFyUmluZyh0KXtjb25zdCBlPXQuX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKFJzKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5MaW5lYXJSaW5nKGUpfWNvbnZlcnRUb1BvbHlnb24odCl7Y29uc3QgZT1bdC5fc2hlbGwuX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKFJzKV07Zm9yKGxldCBuPTA7bjx0Ll9ob2xlcy5sZW5ndGg7bisrKWUucHVzaCh0Ll9ob2xlc1tuXS5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoUnMpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5Qb2x5Z29uKGUpfWNvbnZlcnRUb011bHRpUG9pbnQodCl7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTXVsdGlQb2ludCh0LmdldENvb3JkaW5hdGVzKCkubWFwKFJzKSl9Y29udmVydFRvTXVsdGlMaW5lU3RyaW5nKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvTGluZVN0cmluZyh0Ll9nZW9tZXRyaWVzW25dKS5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aUxpbmVTdHJpbmcoZSl9Y29udmVydFRvTXVsdGlQb2x5Z29uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvUG9seWdvbih0Ll9nZW9tZXRyaWVzW25dKS5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aVBvbHlnb24oZSl9Y29udmVydFRvQ29sbGVjdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl07ZS5wdXNoKHRoaXMud3JpdGUocykpfXJldHVybiBuZXcgdGhpcy5vbC5nZW9tLkdlb21ldHJ5Q29sbGVjdGlvbihlKX19LFdLVFJlYWRlcjpjbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj1uZXcgS3QodHx8bmV3IEh0KX1yZWFkKHQpe3JldHVybiB0aGlzLnBhcnNlci5yZWFkKHQpfX0sV0tUV3JpdGVyOkp0fSk7Y2xhc3MgdnN7Y29uc3RydWN0b3IoKXt2cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyByZWxhdGl2ZVNpZ24odCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOjB9c3RhdGljIGNvbXBhcmUodCxlLG4pe2lmKGUuZXF1YWxzMkQobikpcmV0dXJuIDA7Y29uc3Qgcz12cy5yZWxhdGl2ZVNpZ24oZS54LG4ueCksaT12cy5yZWxhdGl2ZVNpZ24oZS55LG4ueSk7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKHMsaSk7Y2FzZSAxOnJldHVybiB2cy5jb21wYXJlVmFsdWUoaSxzKTtjYXNlIDI6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZShpLC1zKTtjYXNlIDM6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZSgtcyxpKTtjYXNlIDQ6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZSgtcywtaSk7Y2FzZSA1OnJldHVybiB2cy5jb21wYXJlVmFsdWUoLWksLXMpO2Nhc2UgNjpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKC1pLHMpO2Nhc2UgNzpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKHMsLWkpfXJldHVybiB1LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiaW52YWxpZCBvY3RhbnQgdmFsdWVcIiksMH1zdGF0aWMgY29tcGFyZVZhbHVlKHQsZSl7cmV0dXJuIHQ8MD8tMTp0PjA/MTplPDA/LTE6ZT4wPzE6MH1nZXRDbGFzcygpe3JldHVybiB2c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBPc3tjb25zdHJ1Y3Rvcigpe09zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmNvb3JkfXByaW50KHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDxlLnNlZ21lbnRJbmRleD8tMTp0aGlzLnNlZ21lbnRJbmRleD5lLnNlZ21lbnRJbmRleD8xOnRoaXMuY29vcmQuZXF1YWxzMkQoZS5jb29yZCk/MDp2cy5jb21wYXJlKHRoaXMuX3NlZ21lbnRPY3RhbnQsdGhpcy5jb29yZCxlLmNvb3JkKX1pc0VuZFBvaW50KHQpe3JldHVybiAwPT09dGhpcy5zZWdtZW50SW5kZXgmJiF0aGlzLl9pc0ludGVyaW9yfHx0aGlzLnNlZ21lbnRJbmRleD09PXR9aXNJbnRlcmlvcigpe3JldHVybiB0aGlzLl9pc0ludGVyaW9yfWdldENsYXNzKCl7cmV0dXJuIE9zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19T3MuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2VnU3RyaW5nPW51bGwsdGhpcy5jb29yZD1udWxsLHRoaXMuc2VnbWVudEluZGV4PW51bGwsdGhpcy5fc2VnbWVudE9jdGFudD1udWxsLHRoaXMuX2lzSW50ZXJpb3I9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9zZWdTdHJpbmc9dCx0aGlzLmNvb3JkPW5ldyBnKGUpLHRoaXMuc2VnbWVudEluZGV4PW4sdGhpcy5fc2VnbWVudE9jdGFudD1zLHRoaXMuX2lzSW50ZXJpb3I9IWUuZXF1YWxzMkQodC5nZXRDb29yZGluYXRlKG4pKX07Y2xhc3MgYnN7Y29uc3RydWN0b3IoKXticy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldFNwbGl0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBJO3RoaXMuYWRkRW5kcG9pbnRzKCk7Y29uc3QgZT10aGlzLml0ZXJhdG9yKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCk7dGhpcy5hZGRFZGdlQ29vcmRpbmF0ZXMobixzLHQpLG49c31yZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWFkZENvbGxhcHNlZE5vZGVzKCl7Y29uc3QgdD1uZXcgeDt0aGlzLmZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2Rlcyh0KSx0aGlzLmZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyh0KTtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKS5pbnRWYWx1ZSgpO3RoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSh0KSx0KX19cHJpbnQodCl7dC5wcmludGxuKFwiSW50ZXJzZWN0aW9uczpcIik7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1maW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXModCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlLnNpemUoKS0yO2UrKyl7Y29uc3Qgbj10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSkscz0odGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUrMSksdGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUrMikpO24uZXF1YWxzMkQocykmJnQuYWRkKG5ldyBMKGUrMSkpfX1hZGRFZGdlQ29vcmRpbmF0ZXModCxlLG4pe2Uuc2VnbWVudEluZGV4LHQuc2VnbWVudEluZGV4O2NvbnN0IHM9dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUuc2VnbWVudEluZGV4KSxpPWUuaXNJbnRlcmlvcigpfHwhZS5jb29yZC5lcXVhbHMyRChzKTtuLmFkZChuZXcgZyh0LmNvb3JkKSwhMSk7Zm9yKGxldCBzPXQuc2VnbWVudEluZGV4KzE7czw9ZS5zZWdtZW50SW5kZXg7cysrKW4uYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShzKSk7aSYmbi5hZGQobmV3IGcoZS5jb29yZCkpfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX1hZGRTcGxpdEVkZ2VzKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCksdGhpcy5hZGRDb2xsYXBzZWROb2RlcygpO2NvbnN0IGU9dGhpcy5pdGVyYXRvcigpO2xldCBuPWUubmV4dCgpO2Zvcig7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpLGk9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixzKTt0LmFkZChpKSxuPXN9fWZpbmRDb2xsYXBzZUluZGV4KHQsZSxuKXtpZighdC5jb29yZC5lcXVhbHMyRChlLmNvb3JkKSlyZXR1cm4hMTtsZXQgcz1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleDtyZXR1cm4gZS5pc0ludGVyaW9yKCl8fHMtLSwxPT09cyYmKG5bMF09dC5zZWdtZW50SW5kZXgrMSwhMCl9ZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpe2NvbnN0IGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLml0ZXJhdG9yKCk7bGV0IHM9bi5uZXh0KCk7Zm9yKDtuLmhhc05leHQoKTspe2NvbnN0IGk9bi5uZXh0KCk7dGhpcy5maW5kQ29sbGFwc2VJbmRleChzLGksZSkmJnQuYWRkKG5ldyBMKGVbMF0pKSxzPWl9fWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fZWRnZX1hZGRFbmRwb2ludHMoKXtjb25zdCB0PXRoaXMuX2VkZ2Uuc2l6ZSgpLTE7dGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKDApLDApLHRoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSh0KSx0KX1jcmVhdGVTcGxpdEVkZ2UodCxlKXtsZXQgbj1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyO2NvbnN0IHM9dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUuc2VnbWVudEluZGV4KSxpPWUuaXNJbnRlcmlvcigpfHwhZS5jb29yZC5lcXVhbHMyRChzKTtpfHxuLS07Y29uc3Qgcj1uZXcgQXJyYXkobikuZmlsbChudWxsKTtsZXQgbz0wO3JbbysrXT1uZXcgZyh0LmNvb3JkKTtmb3IobGV0IG49dC5zZWdtZW50SW5kZXgrMTtuPD1lLnNlZ21lbnRJbmRleDtuKyspcltvKytdPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShuKTtyZXR1cm4gaSYmKHJbb109bmV3IGcoZS5jb29yZCkpLG5ldyBGcyhyLHRoaXMuX2VkZ2UuZ2V0RGF0YSgpKX1hZGQodCxlKXtjb25zdCBuPW5ldyBPcyh0aGlzLl9lZGdlLHQsZSx0aGlzLl9lZGdlLmdldFNlZ21lbnRPY3RhbnQoZSkpLHM9dGhpcy5fbm9kZU1hcC5nZXQobik7cmV0dXJuIG51bGwhPT1zPyh1LmlzVHJ1ZShzLmNvb3JkLmVxdWFsczJEKHQpLFwiRm91bmQgZXF1YWwgbm9kZXMgd2l0aCBkaWZmZXJlbnQgY29vcmRpbmF0ZXNcIikscyk6KHRoaXMuX25vZGVNYXAucHV0KG4sbiksbil9Y2hlY2tTcGxpdEVkZ2VzQ29ycmVjdG5lc3ModCl7Y29uc3QgZT10aGlzLl9lZGdlLmdldENvb3JkaW5hdGVzKCksbj10LmdldCgwKS5nZXRDb29yZGluYXRlKDApO2lmKCFuLmVxdWFsczJEKGVbMF0pKXRocm93IG5ldyBjKFwiYmFkIHNwbGl0IGVkZ2Ugc3RhcnQgcG9pbnQgYXQgXCIrbik7Y29uc3Qgcz10LmdldCh0LnNpemUoKS0xKS5nZXRDb29yZGluYXRlcygpLGk9c1tzLmxlbmd0aC0xXTtpZighaS5lcXVhbHMyRChlW2UubGVuZ3RoLTFdKSl0aHJvdyBuZXcgYyhcImJhZCBzcGxpdCBlZGdlIGVuZCBwb2ludCBhdCBcIitpKX1nZXRDbGFzcygpe3JldHVybiBic31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19YnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbm9kZU1hcD1uZXcgcnQsdGhpcy5fZWRnZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2VkZ2U9dH07Y2xhc3MgTXN7Y29uc3RydWN0b3IoKXtNcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvY3RhbnQoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dCYmMD09PWUpdGhyb3cgbmV3IG4oXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTtjb25zdCBzPU1hdGguYWJzKHQpLGk9TWF0aC5hYnMoZSk7cmV0dXJuIHQ+PTA/ZT49MD9zPj1pPzA6MTpzPj1pPzc6NjplPj0wP3M+PWk/MzoyOnM+PWk/NDo1fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxzPWUueC10LngsaT1lLnktdC55O2lmKDA9PT1zJiYwPT09aSl0aHJvdyBuZXcgbihcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK3QpO3JldHVybiBNcy5vY3RhbnQocyxpKX19Z2V0Q2xhc3MoKXtyZXR1cm4gTXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU1zLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgRHN7Y29uc3RydWN0b3IoKXtEcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGVzKCl7fXNpemUoKXt9Z2V0Q29vcmRpbmF0ZSh0KXt9aXNDbG9zZWQoKXt9c2V0RGF0YSh0KXt9Z2V0RGF0YSgpe31nZXRDbGFzcygpe3JldHVybiBEc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBBc3tjb25zdHJ1Y3Rvcigpe0FzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkSW50ZXJzZWN0aW9uKHQsZSl7fWdldENsYXNzKCl7cmV0dXJuIEFzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltEc119fUFzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgRnN7Y29uc3RydWN0b3IoKXtGcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXROb2RlZFN1YnN0cmluZ3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgeDtyZXR1cm4gRnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLmdldE5vZGVMaXN0KCkuYWRkU3BsaXRFZGdlcyhlKX19fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0c31zaXplKCl7cmV0dXJuIHRoaXMuX3B0cy5sZW5ndGh9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzW3RdfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGgtMV0pfWdldFNlZ21lbnRPY3RhbnQodCl7cmV0dXJuIHQ9PT10aGlzLl9wdHMubGVuZ3RoLTE/LTE6dGhpcy5zYWZlT2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KSx0aGlzLmdldENvb3JkaW5hdGUodCsxKSl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9c2FmZU9jdGFudCh0LGUpe3JldHVybiB0LmVxdWFsczJEKGUpPzA6TXMub2N0YW50KHQsZSl9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWFkZEludGVyc2VjdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmFkZEludGVyc2VjdGlvbk5vZGUodCxlKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1szXSxzPW5ldyBnKHQuZ2V0SW50ZXJzZWN0aW9uKG4pKTt0aGlzLmFkZEludGVyc2VjdGlvbihzLGUpfX10b1N0cmluZygpe3JldHVybiBKdC50b0xpbmVTdHJpbmcobmV3IHp0KHRoaXMuX3B0cykpfWdldE5vZGVMaXN0KCl7cmV0dXJuIHRoaXMuX25vZGVMaXN0fWFkZEludGVyc2VjdGlvbk5vZGUodCxlKXtsZXQgbj1lO2NvbnN0IHM9bisxO2lmKHM8dGhpcy5fcHRzLmxlbmd0aCl7Y29uc3QgZT10aGlzLl9wdHNbc107dC5lcXVhbHMyRChlKSYmKG49cyl9cmV0dXJuIHRoaXMuX25vZGVMaXN0LmFkZCh0LG4pfWFkZEludGVyc2VjdGlvbnModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtzKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4scyl9Z2V0Q2xhc3MoKXtyZXR1cm4gRnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FzXX19RnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbm9kZUxpc3Q9bmV3IGJzKHRoaXMpLHRoaXMuX3B0cz1udWxsLHRoaXMuX2RhdGE9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdHM9dCx0aGlzLl9kYXRhPWV9O2NsYXNzIEdze2NvbnN0cnVjdG9yKCl7R3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1vdmVybGFwKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3QuZ2V0TGluZVNlZ21lbnQoZSx0aGlzLl9vdmVybGFwU2VnMSksbi5nZXRMaW5lU2VnbWVudChzLHRoaXMuX292ZXJsYXBTZWcyKSx0aGlzLm92ZXJsYXAodGhpcy5fb3ZlcmxhcFNlZzEsdGhpcy5fb3ZlcmxhcFNlZzIpfX1nZXRDbGFzcygpe3JldHVybiBHc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19R3MuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fb3ZlcmxhcFNlZzE9bmV3IGVlLHRoaXMuX292ZXJsYXBTZWcyPW5ldyBlZX07Y2xhc3MgcXN7Y29uc3RydWN0b3IoKXtxcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldExpbmVTZWdtZW50KHQsZSl7ZS5wMD10aGlzLl9wdHNbdF0sZS5wMT10aGlzLl9wdHNbdCsxXX1jb21wdXRlU2VsZWN0KHQsZSxuLHMpe2NvbnN0IGk9dGhpcy5fcHRzW2VdLHI9dGhpcy5fcHRzW25dO2lmKG4tZT09MSlyZXR1cm4gcy5zZWxlY3QodGhpcyxlKSxudWxsO2lmKCF0LmludGVyc2VjdHMoaSxyKSlyZXR1cm4gbnVsbDtjb25zdCBvPU1hdGgudHJ1bmMoKGUrbikvMik7ZTxvJiZ0aGlzLmNvbXB1dGVTZWxlY3QodCxlLG8scyksbzxuJiZ0aGlzLmNvbXB1dGVTZWxlY3QodCxvLG4scyl9Z2V0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9lbmQtdGhpcy5fc3RhcnQrMSkuZmlsbChudWxsKTtsZXQgZT0wO2ZvcihsZXQgbj10aGlzLl9zdGFydDtuPD10aGlzLl9lbmQ7bisrKXRbZSsrXT10aGlzLl9wdHNbbl07cmV0dXJuIHR9Y29tcHV0ZU92ZXJsYXBzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuY29tcHV0ZU92ZXJsYXBzKHRoaXMuX3N0YXJ0LHRoaXMuX2VuZCx0LHQuX3N0YXJ0LHQuX2VuZCxlKX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtpZihlLXQ9PTEmJmktcz09MSlyZXR1cm4gci5vdmVybGFwKHRoaXMsdCxuLHMpLG51bGw7aWYoIXRoaXMub3ZlcmxhcHModCxlLG4scyxpKSlyZXR1cm4gbnVsbDtjb25zdCBvPU1hdGgudHJ1bmMoKHQrZSkvMiksbD1NYXRoLnRydW5jKChzK2kpLzIpO3Q8byYmKHM8bCYmdGhpcy5jb21wdXRlT3ZlcmxhcHModCxvLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHModCxvLG4sbCxpLHIpKSxvPGUmJihzPGwmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKG8sZSxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKG8sZSxuLGwsaSxyKSl9fXNldElkKHQpe3RoaXMuX2lkPXR9c2VsZWN0KHQsZSl7dGhpcy5jb21wdXRlU2VsZWN0KHQsdGhpcy5fc3RhcnQsdGhpcy5fZW5kLGUpfWdldEVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX2Vudil7Y29uc3QgdD10aGlzLl9wdHNbdGhpcy5fc3RhcnRdLGU9dGhpcy5fcHRzW3RoaXMuX2VuZF07dGhpcy5fZW52PW5ldyBOKHQsZSl9cmV0dXJuIHRoaXMuX2Vudn1vdmVybGFwcyh0LGUsbixzLGkpe3JldHVybiBOLmludGVyc2VjdHModGhpcy5fcHRzW3RdLHRoaXMuX3B0c1tlXSxuLl9wdHNbc10sbi5fcHRzW2ldKX1nZXRFbmRJbmRleCgpe3JldHVybiB0aGlzLl9lbmR9Z2V0U3RhcnRJbmRleCgpe3JldHVybiB0aGlzLl9zdGFydH1nZXRDb250ZXh0KCl7cmV0dXJuIHRoaXMuX2NvbnRleHR9Z2V0SWQoKXtyZXR1cm4gdGhpcy5faWR9Z2V0Q2xhc3MoKXtyZXR1cm4gcXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXFzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0cz1udWxsLHRoaXMuX3N0YXJ0PW51bGwsdGhpcy5fZW5kPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5fY29udGV4dD1udWxsLHRoaXMuX2lkPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fcHRzPXQsdGhpcy5fc3RhcnQ9ZSx0aGlzLl9lbmQ9bix0aGlzLl9jb250ZXh0PXN9O2NsYXNzIEJze2NvbnN0cnVjdG9yKCl7QnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0Q2hhaW5TdGFydEluZGljZXModCl7bGV0IGU9MDtjb25zdCBuPW5ldyB4O24uYWRkKG5ldyBMKGUpKTtkb3tjb25zdCBzPUJzLmZpbmRDaGFpbkVuZCh0LGUpO24uYWRkKG5ldyBMKHMpKSxlPXN9d2hpbGUoZTx0Lmxlbmd0aC0xKTtyZXR1cm4gQnMudG9JbnRBcnJheShuKX1zdGF0aWMgZmluZENoYWluRW5kKHQsZSl7bGV0IG49ZTtmb3IoO248dC5sZW5ndGgtMSYmdFtuXS5lcXVhbHMyRCh0W24rMV0pOyluKys7aWYobj49dC5sZW5ndGgtMSlyZXR1cm4gdC5sZW5ndGgtMTtjb25zdCBzPUluLnF1YWRyYW50KHRbbl0sdFtuKzFdKTtsZXQgaT1lKzE7Zm9yKDtpPHQubGVuZ3RoOyl7aWYoIXRbaS0xXS5lcXVhbHMyRCh0W2ldKSl7aWYoSW4ucXVhZHJhbnQodFtpLTFdLHRbaV0pIT09cylicmVha31pKyt9cmV0dXJuIGktMX1zdGF0aWMgZ2V0Q2hhaW5zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBCcy5nZXRDaGFpbnModCxudWxsKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgeCxzPUJzLmdldENoYWluU3RhcnRJbmRpY2VzKHQpO2ZvcihsZXQgaT0wO2k8cy5sZW5ndGgtMTtpKyspe2NvbnN0IHI9bmV3IHFzKHQsc1tpXSxzW2krMV0sZSk7bi5hZGQocil9cmV0dXJuIG59fXN0YXRpYyB0b0ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dC5nZXQobikuaW50VmFsdWUoKTtyZXR1cm4gZX1nZXRDbGFzcygpe3JldHVybiBCc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19QnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBWc3tjb25zdHJ1Y3Rvcigpe1ZzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZU5vZGVzKHQpe31nZXROb2RlZFN1YnN0cmluZ3MoKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gVnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVZzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgenN7Y29uc3RydWN0b3IoKXt6cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldFNlZ21lbnRJbnRlcnNlY3Rvcih0KXt0aGlzLl9zZWdJbnQ9dH1nZXRDbGFzcygpe3JldHVybiB6c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVnNdfX16cy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9zZWdJbnQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRTZWdtZW50SW50ZXJzZWN0b3IodCl9fTtjbGFzcyBZcyBleHRlbmRzIHpze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxZcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE1vbm90b25lQ2hhaW5zKCl7cmV0dXJuIHRoaXMuX21vbm9DaGFpbnN9Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7cmV0dXJuIEZzLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLl9ub2RlZFNlZ1N0cmluZ3MpfWdldEluZGV4KCl7cmV0dXJuIHRoaXMuX2luZGV4fWFkZCh0KXtmb3IobGV0IGU9QnMuZ2V0Q2hhaW5zKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LnNldElkKHRoaXMuX2lkQ291bnRlcisrKSx0aGlzLl9pbmRleC5pbnNlcnQodC5nZXRFbnZlbG9wZSgpLHQpLHRoaXMuX21vbm9DaGFpbnMuYWRkKHQpfX1jb21wdXRlTm9kZXModCl7dGhpcy5fbm9kZWRTZWdTdHJpbmdzPXQ7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3RoaXMuaW50ZXJzZWN0Q2hhaW5zKCl9aW50ZXJzZWN0Q2hhaW5zKCl7Y29uc3QgdD1uZXcgVXModGhpcy5fc2VnSW50KTtmb3IobGV0IGU9dGhpcy5fbW9ub0NoYWlucy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtmb3IobGV0IGU9dGhpcy5faW5kZXgucXVlcnkobi5nZXRFbnZlbG9wZSgpKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKTtpZihzLmdldElkKCk+bi5nZXRJZCgpJiYobi5jb21wdXRlT3ZlcmxhcHMocyx0KSx0aGlzLl9uT3ZlcmxhcHMrKyksdGhpcy5fc2VnSW50LmlzRG9uZSgpKXJldHVybiBudWxsfX19Z2V0Q2xhc3MoKXtyZXR1cm4gWXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIFVzIGV4dGVuZHMgR3N7Y29uc3RydWN0b3IoKXtzdXBlcigpLFVzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9b3ZlcmxhcCgpe2lmKDQhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBzdXBlci5vdmVybGFwLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT10LmdldENvbnRleHQoKSxyPW4uZ2V0Q29udGV4dCgpO3RoaXMuX3NpLnByb2Nlc3NJbnRlcnNlY3Rpb25zKGksZSxyLHMpfX1nZXRDbGFzcygpe3JldHVybiBVc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2k9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaT10fSxZcy5TZWdtZW50T3ZlcmxhcEFjdGlvbj1VcyxZcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9tb25vQ2hhaW5zPW5ldyB4LHRoaXMuX2luZGV4PW5ldyBFcyx0aGlzLl9pZENvdW50ZXI9MCx0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9bnVsbCx0aGlzLl9uT3ZlcmxhcHM9MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07enMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19O2NsYXNzIGtze2NvbnN0cnVjdG9yKCl7a3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXNjYWxlKCl7aWYoXyhhcmd1bWVudHNbMF0sZikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5yZXNjYWxlKGUuZ2V0Q29vcmRpbmF0ZXMoKSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbCxuPW51bGw7Mj09PXQubGVuZ3RoJiYoZT1uZXcgZyh0WzBdKSxuPW5ldyBnKHRbMV0pKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdLng9dFtlXS54L3RoaXMuX3NjYWxlRmFjdG9yK3RoaXMuX29mZnNldFgsdFtlXS55PXRbZV0ueS90aGlzLl9zY2FsZUZhY3Rvcit0aGlzLl9vZmZzZXRZOzI9PT10Lmxlbmd0aCYmdFswXS5lcXVhbHMyRCh0WzFdKSYmTy5vdXQucHJpbnRsbih0KX19c2NhbGUoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgeCh0LnNpemUoKSk7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGQobmV3IEZzKHRoaXMuc2NhbGUodC5nZXRDb29yZGluYXRlcygpKSx0LmdldERhdGEoKSkpfXJldHVybiBlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWVbbl09bmV3IGcoTWF0aC5yb3VuZCgodFtuXS54LXRoaXMuX29mZnNldFgpKnRoaXMuX3NjYWxlRmFjdG9yKSxNYXRoLnJvdW5kKCh0W25dLnktdGhpcy5fb2Zmc2V0WSkqdGhpcy5fc2NhbGVGYWN0b3IpLHRbbl0ueik7cmV0dXJuIFgucmVtb3ZlUmVwZWF0ZWRQb2ludHMoZSl9fWlzSW50ZWdlclByZWNpc2lvbigpe3JldHVybiAxPT09dGhpcy5fc2NhbGVGYWN0b3J9Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7Y29uc3QgdD10aGlzLl9ub2Rlci5nZXROb2RlZFN1YnN0cmluZ3MoKTtyZXR1cm4gdGhpcy5faXNTY2FsZWQmJnRoaXMucmVzY2FsZSh0KSx0fWNvbXB1dGVOb2Rlcyh0KXtsZXQgZT10O3RoaXMuX2lzU2NhbGVkJiYoZT10aGlzLnNjYWxlKHQpKSx0aGlzLl9ub2Rlci5jb21wdXRlTm9kZXMoZSl9Z2V0Q2xhc3MoKXtyZXR1cm4ga3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1ZzXX19a3MuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbm9kZXI9bnVsbCx0aGlzLl9zY2FsZUZhY3Rvcj1udWxsLHRoaXMuX29mZnNldFg9bnVsbCx0aGlzLl9vZmZzZXRZPW51bGwsdGhpcy5faXNTY2FsZWQ9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2tzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLDAsMCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbm9kZXI9dCx0aGlzLl9zY2FsZUZhY3Rvcj1lLHRoaXMuX2lzU2NhbGVkPSF0aGlzLmlzSW50ZWdlclByZWNpc2lvbigpfX07dmFyIFhzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLE1DSW5kZXhOb2RlcjpZcyxTY2FsZWROb2RlcjprcyxTZWdtZW50U3RyaW5nOkRzfSk7Y2xhc3MgSHN7Y29uc3RydWN0b3IoKXtIcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc1NpbXBsZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IEhzKHQpLmlzU2ltcGxlKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgSHModCxlKS5pc1NpbXBsZSgpfX1pc1NpbXBsZU11bHRpUG9pbnQodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7Y29uc3QgZT1uZXcgYXQ7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obikuZ2V0Q29vcmRpbmF0ZSgpO2lmKGUuY29udGFpbnMocykpcmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPXMsITE7ZS5hZGQocyl9cmV0dXJuITB9aXNTaW1wbGVQb2x5Z29uYWwodCl7Zm9yKGxldCBlPXhlLmdldExpbmVzKHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKCF0aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCkpcmV0dXJuITF9cmV0dXJuITB9aGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb24odCl7Y29uc3QgZT1uZXcgcnQ7Zm9yKGxldCBuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLHM9KHQuZ2V0TWF4aW11bVNlZ21lbnRJbmRleCgpLHQuaXNDbG9zZWQoKSksaT10LmdldENvb3JkaW5hdGUoMCk7dGhpcy5hZGRFbmRwb2ludChlLGkscyk7Y29uc3Qgcj10LmdldENvb3JkaW5hdGUodC5nZXROdW1Qb2ludHMoKS0xKTt0aGlzLmFkZEVuZHBvaW50KGUscixzKX1mb3IobGV0IHQ9ZS52YWx1ZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtpZihlLmlzQ2xvc2VkJiYyIT09ZS5kZWdyZWUpcmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPWUuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfWdldE5vblNpbXBsZUxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9ufWlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7Y29uc3QgZT1uZXcgUW4oMCx0KSxuPW5ldyB0ZSxzPWUuY29tcHV0ZVNlbGZOb2RlcyhuLCEwKTtyZXR1cm4hcy5oYXNJbnRlcnNlY3Rpb24oKXx8KHMuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPXMuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6IXRoaXMuaGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSkmJighdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yfHwhdGhpcy5oYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbihlKSkpfWhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0TWF4aW11bVNlZ21lbnRJbmRleCgpO2ZvcihsZXQgZT10LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYoIXQuaXNFbmRQb2ludChuKSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249dC5nZXRDb29yZGluYXRlKCksITB9fXJldHVybiExfWFkZEVuZHBvaW50KHQsZSxuKXtsZXQgcz10LmdldChlKTtudWxsPT09cyYmKHM9bmV3IFdzKGUpLHQucHV0KGUscykpLHMuYWRkRW5kcG9pbnQobil9Y29tcHV0ZVNpbXBsZSh0KXtyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249bnVsbCwhIXQuaXNFbXB0eSgpfHwodCBpbnN0YW5jZW9mIFR0fHx0IGluc3RhbmNlb2YgZnQ/dGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpOnQgaW5zdGFuY2VvZiBNdD90aGlzLmlzU2ltcGxlTXVsdGlQb2ludCh0KTpfKHQsT3QpP3RoaXMuaXNTaW1wbGVQb2x5Z29uYWwodCk6ISh0IGluc3RhbmNlb2YgX3QpfHx0aGlzLmlzU2ltcGxlR2VvbWV0cnlDb2xsZWN0aW9uKHQpKX1pc1NpbXBsZSgpe3JldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1udWxsLHRoaXMuY29tcHV0ZVNpbXBsZSh0aGlzLl9pbnB1dEdlb20pfWlzU2ltcGxlR2VvbWV0cnlDb2xsZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmNvbXB1dGVTaW1wbGUobikpcmV0dXJuITF9cmV0dXJuITB9Z2V0Q2xhc3MoKXtyZXR1cm4gSHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIFdze2NvbnN0cnVjdG9yKCl7V3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGRFbmRwb2ludCh0KXt0aGlzLmRlZ3JlZSsrLHRoaXMuaXNDbG9zZWR8PXR9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLnB0fWdldENsYXNzKCl7cmV0dXJuIFdzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Xcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLnB0PW51bGwsdGhpcy5pc0Nsb3NlZD1udWxsLHRoaXMuZGVncmVlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wdD10LHRoaXMuaXNDbG9zZWQ9ITEsdGhpcy5kZWdyZWU9MH0sSHMuRW5kcG9pbnRJbmZvPVdzLEhzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2lzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hMCx0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbnB1dEdlb209dCx0aGlzLl9pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3I9IWUuaXNJbkJvdW5kYXJ5KDIpfX07Y2xhc3MganN7Y29uc3RydWN0b3IoKXtqcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBidWZmZXJEaXN0YW5jZUVycm9yKHQpe2NvbnN0IGU9TWF0aC5QSS8yL3Q7cmV0dXJuIDEtTWF0aC5jb3MoZS8yKX1nZXRFbmRDYXBTdHlsZSgpe3JldHVybiB0aGlzLl9lbmRDYXBTdHlsZX1pc1NpbmdsZVNpZGVkKCl7cmV0dXJuIHRoaXMuX2lzU2luZ2xlU2lkZWR9c2V0UXVhZHJhbnRTZWdtZW50cyh0KXt0aGlzLl9xdWFkcmFudFNlZ21lbnRzPXQsMD09PXRoaXMuX3F1YWRyYW50U2VnbWVudHMmJih0aGlzLl9qb2luU3R5bGU9anMuSk9JTl9CRVZFTCksdGhpcy5fcXVhZHJhbnRTZWdtZW50czwwJiYodGhpcy5fam9pblN0eWxlPWpzLkpPSU5fTUlUUkUsdGhpcy5fbWl0cmVMaW1pdD1NYXRoLmFicyh0aGlzLl9xdWFkcmFudFNlZ21lbnRzKSksdDw9MCYmKHRoaXMuX3F1YWRyYW50U2VnbWVudHM9MSksdGhpcy5fam9pblN0eWxlIT09anMuSk9JTl9ST1VORCYmKHRoaXMuX3F1YWRyYW50U2VnbWVudHM9anMuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUyl9Z2V0Sm9pblN0eWxlKCl7cmV0dXJuIHRoaXMuX2pvaW5TdHlsZX1zZXRKb2luU3R5bGUodCl7dGhpcy5fam9pblN0eWxlPXR9c2V0U2ltcGxpZnlGYWN0b3IodCl7dGhpcy5fc2ltcGxpZnlGYWN0b3I9dDwwPzA6dH1nZXRTaW1wbGlmeUZhY3Rvcigpe3JldHVybiB0aGlzLl9zaW1wbGlmeUZhY3Rvcn1nZXRRdWFkcmFudFNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50U2VnbWVudHN9c2V0RW5kQ2FwU3R5bGUodCl7dGhpcy5fZW5kQ2FwU3R5bGU9dH1nZXRNaXRyZUxpbWl0KCl7cmV0dXJuIHRoaXMuX21pdHJlTGltaXR9c2V0TWl0cmVMaW1pdCh0KXt0aGlzLl9taXRyZUxpbWl0PXR9c2V0U2luZ2xlU2lkZWQodCl7dGhpcy5faXNTaW5nbGVTaWRlZD10fWdldENsYXNzKCl7cmV0dXJuIGpzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1qcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9xdWFkcmFudFNlZ21lbnRzPWpzLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMsdGhpcy5fZW5kQ2FwU3R5bGU9anMuQ0FQX1JPVU5ELHRoaXMuX2pvaW5TdHlsZT1qcy5KT0lOX1JPVU5ELHRoaXMuX21pdHJlTGltaXQ9anMuREVGQVVMVF9NSVRSRV9MSU1JVCx0aGlzLl9pc1NpbmdsZVNpZGVkPSExLHRoaXMuX3NpbXBsaWZ5RmFjdG9yPWpzLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpLHRoaXMuc2V0RW5kQ2FwU3R5bGUoZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpLHRoaXMuc2V0RW5kQ2FwU3R5bGUoZSksdGhpcy5zZXRKb2luU3R5bGUobiksdGhpcy5zZXRNaXRyZUxpbWl0KHMpfX0sanMuQ0FQX1JPVU5EPTEsanMuQ0FQX0ZMQVQ9Mixqcy5DQVBfU1FVQVJFPTMsanMuSk9JTl9ST1VORD0xLGpzLkpPSU5fTUlUUkU9Mixqcy5KT0lOX0JFVkVMPTMsanMuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUz04LGpzLkRFRkFVTFRfTUlUUkVfTElNSVQ9NSxqcy5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUj0uMDE7Y2xhc3MgS3N7Y29uc3RydWN0b3IoKXtLcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fbWluQ29vcmR9Z2V0UmlnaHRtb3N0U2lkZSh0LGUpe2xldCBuPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUpO3JldHVybiBuPDAmJihuPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUtMSkpLG48MCYmKHRoaXMuX21pbkNvb3JkPW51bGwsdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCkpLG59ZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpe2NvbnN0IHQ9dGhpcy5fbWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7dS5pc1RydWUodGhpcy5fbWluSW5kZXg+MCYmdGhpcy5fbWluSW5kZXg8dC5sZW5ndGgsXCJyaWdodG1vc3QgcG9pbnQgZXhwZWN0ZWQgdG8gYmUgaW50ZXJpb3IgdmVydGV4IG9mIGVkZ2VcIik7Y29uc3QgZT10W3RoaXMuX21pbkluZGV4LTFdLG49dFt0aGlzLl9taW5JbmRleCsxXSxzPXYuaW5kZXgodGhpcy5fbWluQ29vcmQsbixlKTtsZXQgaT0hMTsoZS55PHRoaXMuX21pbkNvb3JkLnkmJm4ueTx0aGlzLl9taW5Db29yZC55JiZzPT09di5DT1VOVEVSQ0xPQ0tXSVNFfHxlLnk+dGhpcy5fbWluQ29vcmQueSYmbi55PnRoaXMuX21pbkNvb3JkLnkmJnM9PT12LkNMT0NLV0lTRSkmJihpPSEwKSxpJiYodGhpcy5fbWluSW5kZXg9dGhpcy5fbWluSW5kZXgtMSl9Z2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUpe2NvbnN0IG49dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlPDB8fGUrMT49bi5sZW5ndGgpcmV0dXJuLTE7aWYobltlXS55PT09bltlKzFdLnkpcmV0dXJuLTE7bGV0IHM9UG4uTEVGVDtyZXR1cm4gbltlXS55PG5bZSsxXS55JiYocz1Qbi5SSUdIVCksc31nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX29yaWVudGVkRGV9Y2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpe2NvbnN0IGU9dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoLTE7bisrKShudWxsPT09dGhpcy5fbWluQ29vcmR8fGVbbl0ueD50aGlzLl9taW5Db29yZC54KSYmKHRoaXMuX21pbkRlPXQsdGhpcy5fbWluSW5kZXg9bix0aGlzLl9taW5Db29yZD1lW25dKX1maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpe2NvbnN0IHQ9dGhpcy5fbWluRGUuZ2V0Tm9kZSgpLmdldEVkZ2VzKCk7dGhpcy5fbWluRGU9dC5nZXRSaWdodG1vc3RFZGdlKCksdGhpcy5fbWluRGUuaXNGb3J3YXJkKCl8fCh0aGlzLl9taW5EZT10aGlzLl9taW5EZS5nZXRTeW0oKSx0aGlzLl9taW5JbmRleD10aGlzLl9taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSl9ZmluZEVkZ2UodCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5pc0ZvcndhcmQoKSYmdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCl9dS5pc1RydWUoMCE9PXRoaXMuX21pbkluZGV4fHx0aGlzLl9taW5Db29yZC5lcXVhbHModGhpcy5fbWluRGUuZ2V0Q29vcmRpbmF0ZSgpKSxcImluY29uc2lzdGVuY3kgaW4gcmlnaHRtb3N0IHByb2Nlc3NpbmdcIiksMD09PXRoaXMuX21pbkluZGV4P3RoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUoKTp0aGlzLmZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXgoKSx0aGlzLl9vcmllbnRlZERlPXRoaXMuX21pbkRlLHRoaXMuZ2V0UmlnaHRtb3N0U2lkZSh0aGlzLl9taW5EZSx0aGlzLl9taW5JbmRleCk9PT1Qbi5MRUZUJiYodGhpcy5fb3JpZW50ZWREZT10aGlzLl9taW5EZS5nZXRTeW0oKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gS3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIFpzKCl7dGhpcy5hcnJheV89W119S3MuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbWluSW5kZXg9LTEsdGhpcy5fbWluQ29vcmQ9bnVsbCx0aGlzLl9taW5EZT1udWxsLHRoaXMuX29yaWVudGVkRGU9bnVsbH0sWnMucHJvdG90eXBlLmFkZExhc3Q9ZnVuY3Rpb24odCl7dGhpcy5hcnJheV8ucHVzaCh0KX0sWnMucHJvdG90eXBlLnJlbW92ZUZpcnN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLnNoaWZ0KCl9LFpzLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9O2NsYXNzIFFze2NvbnN0cnVjdG9yKCl7UXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbGVhclZpc2l0ZWRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0VmlzaXRlZCghMSl9fWdldFJpZ2h0bW9zdENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcmlnaHRNb3N0Q29vcmR9Y29tcHV0ZU5vZGVEZXB0aCh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc1Zpc2l0ZWQoKXx8dC5nZXRTeW0oKS5pc1Zpc2l0ZWQoKSl7ZT10O2JyZWFrfX1pZihudWxsPT09ZSl0aHJvdyBuZXcgV24oXCJ1bmFibGUgdG8gZmluZCBlZGdlIHRvIGNvbXB1dGUgZGVwdGhzIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKTt0LmdldEVkZ2VzKCkuY29tcHV0ZURlcHRocyhlKTtmb3IobGV0IGU9dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0VmlzaXRlZCghMCksdGhpcy5jb3B5U3ltRGVwdGhzKHQpfX1jb21wdXRlRGVwdGgodCl7dGhpcy5jbGVhclZpc2l0ZWRFZGdlcygpO2NvbnN0IGU9dGhpcy5fZmluZGVyLmdldEVkZ2UoKTtlLmdldE5vZGUoKSxlLmdldExhYmVsKCk7ZS5zZXRFZGdlRGVwdGhzKFBuLlJJR0hULHQpLHRoaXMuY29weVN5bURlcHRocyhlKSx0aGlzLmNvbXB1dGVEZXB0aHMoZSl9Y3JlYXRlKHQpe3RoaXMuYWRkUmVhY2hhYmxlKHQpLHRoaXMuX2ZpbmRlci5maW5kRWRnZSh0aGlzLl9kaXJFZGdlTGlzdCksdGhpcy5fcmlnaHRNb3N0Q29vcmQ9dGhpcy5fZmluZGVyLmdldENvb3JkaW5hdGUoKX1maW5kUmVzdWx0RWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5nZXREZXB0aChQbi5SSUdIVCk+PTEmJmUuZ2V0RGVwdGgoUG4uTEVGVCk8PTAmJiFlLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZlLnNldEluUmVzdWx0KCEwKX19Y29tcHV0ZURlcHRocyh0KXtjb25zdCBlPW5ldyBKLG49bmV3IFpzLHM9dC5nZXROb2RlKCk7Zm9yKG4uYWRkTGFzdChzKSxlLmFkZChzKSx0LnNldFZpc2l0ZWQoITApOyFuLmlzRW1wdHkoKTspe2NvbnN0IHQ9bi5yZW1vdmVGaXJzdCgpO2UuYWRkKHQpLHRoaXMuY29tcHV0ZU5vZGVEZXB0aCh0KTtmb3IobGV0IHM9dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLmdldFN5bSgpO2lmKHQuaXNWaXNpdGVkKCkpY29udGludWU7Y29uc3QgaT10LmdldE5vZGUoKTtlLmNvbnRhaW5zKGkpfHwobi5hZGRMYXN0KGkpLGUuYWRkKGkpKX19fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX3JpZ2h0TW9zdENvb3JkLng8ZS5fcmlnaHRNb3N0Q29vcmQueD8tMTp0aGlzLl9yaWdodE1vc3RDb29yZC54PmUuX3JpZ2h0TW9zdENvb3JkLng/MTowfWdldEVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX2Vudil7Y29uc3QgdD1uZXcgTjtmb3IobGV0IGU9dGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aC0xO2UrKyl0LmV4cGFuZFRvSW5jbHVkZShuW2VdKX10aGlzLl9lbnY9dH1yZXR1cm4gdGhpcy5fZW52fWFkZFJlYWNoYWJsZSh0KXtjb25zdCBlPW5ldyBvbjtmb3IoZS5hZGQodCk7IWUuZW1wdHkoKTspe2NvbnN0IHQ9ZS5wb3AoKTt0aGlzLmFkZCh0LGUpfX1jb3B5U3ltRGVwdGhzKHQpe2NvbnN0IGU9dC5nZXRTeW0oKTtlLnNldERlcHRoKFBuLkxFRlQsdC5nZXREZXB0aChQbi5SSUdIVCkpLGUuc2V0RGVwdGgoUG4uUklHSFQsdC5nZXREZXB0aChQbi5MRUZUKSl9YWRkKHQsZSl7dC5zZXRWaXNpdGVkKCEwKSx0aGlzLl9ub2Rlcy5hZGQodCk7Zm9yKGxldCBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLl9kaXJFZGdlTGlzdC5hZGQodCk7Y29uc3Qgcz10LmdldFN5bSgpLmdldE5vZGUoKTtzLmlzVmlzaXRlZCgpfHxlLnB1c2gocyl9fWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWdldERpcmVjdGVkRWRnZXMoKXtyZXR1cm4gdGhpcy5fZGlyRWRnZUxpc3R9Z2V0Q2xhc3MoKXtyZXR1cm4gUXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Rcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9maW5kZXI9bnVsbCx0aGlzLl9kaXJFZGdlTGlzdD1uZXcgeCx0aGlzLl9ub2Rlcz1uZXcgeCx0aGlzLl9yaWdodE1vc3RDb29yZD1udWxsLHRoaXMuX2Vudj1udWxsLHRoaXMuX2ZpbmRlcj1uZXcgS3N9O2NsYXNzIEpze2NvbnN0cnVjdG9yKCl7SnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlUmluZygpe2lmKG51bGwhPT10aGlzLl9yaW5nKXJldHVybiBudWxsO2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX3B0cy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wdHMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMuX3B0cy5nZXQoZSk7dGhpcy5fcmluZz10aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KSx0aGlzLl9pc0hvbGU9di5pc0NDVyh0aGlzLl9yaW5nLmdldENvb3JkaW5hdGVzKCkpfWlzSXNvbGF0ZWQoKXtyZXR1cm4gMT09PXRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKX1jb21wdXRlUG9pbnRzKHQpe3RoaXMuX3N0YXJ0RGU9dDtsZXQgZT10LG49ITA7ZG97aWYobnVsbD09PWUpdGhyb3cgbmV3IFduKFwiRm91bmQgbnVsbCBEaXJlY3RlZEVkZ2VcIik7aWYoZS5nZXRFZGdlUmluZygpPT09dGhpcyl0aHJvdyBuZXcgV24oXCJEaXJlY3RlZCBFZGdlIHZpc2l0ZWQgdHdpY2UgZHVyaW5nIHJpbmctYnVpbGRpbmcgYXQgXCIrZS5nZXRDb29yZGluYXRlKCkpO3RoaXMuX2VkZ2VzLmFkZChlKTtjb25zdCB0PWUuZ2V0TGFiZWwoKTt1LmlzVHJ1ZSh0LmlzQXJlYSgpKSx0aGlzLm1lcmdlTGFiZWwodCksdGhpcy5hZGRQb2ludHMoZS5nZXRFZGdlKCksZS5pc0ZvcndhcmQoKSxuKSxuPSExLHRoaXMuc2V0RWRnZVJpbmcoZSx0aGlzKSxlPXRoaXMuZ2V0TmV4dChlKX13aGlsZShlIT09dGhpcy5fc3RhcnREZSl9Z2V0TGluZWFyUmluZygpe3JldHVybiB0aGlzLl9yaW5nfWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0cy5nZXQodCl9Y29tcHV0ZU1heE5vZGVEZWdyZWUoKXt0aGlzLl9tYXhOb2RlRGVncmVlPTA7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3tjb25zdCBlPXQuZ2V0Tm9kZSgpLmdldEVkZ2VzKCkuZ2V0T3V0Z29pbmdEZWdyZWUodGhpcyk7ZT50aGlzLl9tYXhOb2RlRGVncmVlJiYodGhpcy5fbWF4Tm9kZURlZ3JlZT1lKSx0PXRoaXMuZ2V0TmV4dCh0KX13aGlsZSh0IT09dGhpcy5fc3RhcnREZSk7dGhpcy5fbWF4Tm9kZURlZ3JlZSo9Mn1hZGRQb2ludHModCxlLG4pe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpO2lmKGUpe2xldCB0PTE7biYmKHQ9MCk7Zm9yKGxldCBlPXQ7ZTxzLmxlbmd0aDtlKyspdGhpcy5fcHRzLmFkZChzW2VdKX1lbHNle2xldCB0PXMubGVuZ3RoLTI7biYmKHQ9cy5sZW5ndGgtMSk7Zm9yKGxldCBlPXQ7ZT49MDtlLS0pdGhpcy5fcHRzLmFkZChzW2VdKX19aXNIb2xlKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX1zZXRJblJlc3VsdCgpe2xldCB0PXRoaXMuX3N0YXJ0RGU7ZG97dC5nZXRFZGdlKCkuc2V0SW5SZXN1bHQoITApLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuX3N0YXJ0RGUpfWNvbnRhaW5zUG9pbnQodCl7Y29uc3QgZT10aGlzLmdldExpbmVhclJpbmcoKTtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuY29udGFpbnModCkpcmV0dXJuITE7aWYoIVdlLmlzSW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKSlyZXR1cm4hMTtmb3IobGV0IGU9dGhpcy5faG9sZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2lmKGUubmV4dCgpLmNvbnRhaW5zUG9pbnQodCkpcmV0dXJuITF9cmV0dXJuITB9YWRkSG9sZSh0KXt0aGlzLl9ob2xlcy5hZGQodCl9aXNTaGVsbCgpe3JldHVybiBudWxsPT09dGhpcy5fc2hlbGx9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9Z2V0TWF4Tm9kZURlZ3JlZSgpe3JldHVybiB0aGlzLl9tYXhOb2RlRGVncmVlPDAmJnRoaXMuY29tcHV0ZU1heE5vZGVEZWdyZWUoKSx0aGlzLl9tYXhOb2RlRGVncmVlfWdldFNoZWxsKCl7cmV0dXJuIHRoaXMuX3NoZWxsfW1lcmdlTGFiZWwoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQsMCksdGhpcy5tZXJnZUxhYmVsKHQsMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldExvY2F0aW9uKGUsUG4uUklHSFQpO2lmKG49PT1uZS5OT05FKXJldHVybiBudWxsO2lmKHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUpPT09bmUuTk9ORSlyZXR1cm4gdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24oZSxuKSxudWxsfX1zZXRTaGVsbCh0KXt0aGlzLl9zaGVsbD10LG51bGwhPT10JiZ0LmFkZEhvbGUodGhpcyl9dG9Qb2x5Z29uKHQpe2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuX2hvbGVzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLnNpemUoKTt0KyspZVt0XT10aGlzLl9ob2xlcy5nZXQodCkuZ2V0TGluZWFyUmluZygpO3JldHVybiB0LmNyZWF0ZVBvbHlnb24odGhpcy5nZXRMaW5lYXJSaW5nKCksZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gSnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUpzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3N0YXJ0RGU9bnVsbCx0aGlzLl9tYXhOb2RlRGVncmVlPS0xLHRoaXMuX2VkZ2VzPW5ldyB4LHRoaXMuX3B0cz1uZXcgeCx0aGlzLl9sYWJlbD1uZXcgRm4obmUuTk9ORSksdGhpcy5fcmluZz1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuX3NoZWxsPW51bGwsdGhpcy5faG9sZXM9bmV3IHgsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21ldHJ5RmFjdG9yeT1lLHRoaXMuY29tcHV0ZVBvaW50cyh0KSx0aGlzLmNvbXB1dGVSaW5nKCl9fTtjbGFzcyAkcyBleHRlbmRzIEpze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSwkcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldEVkZ2VSaW5nKHQsZSl7dC5zZXRNaW5FZGdlUmluZyhlKX1nZXROZXh0KHQpe3JldHVybiB0LmdldE5leHRNaW4oKX1nZXRDbGFzcygpe3JldHVybiAkc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19JHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07SnMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfTtjbGFzcyB0aSBleHRlbmRzIEpze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWJ1aWxkTWluaW1hbFJpbmdzKCl7Y29uc3QgdD1uZXcgeDtsZXQgZT10aGlzLl9zdGFydERlO2Rve2lmKG51bGw9PT1lLmdldE1pbkVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3ICRzKGUsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTt0LmFkZChuKX1lPWUuZ2V0TmV4dCgpfXdoaWxlKGUhPT10aGlzLl9zdGFydERlKTtyZXR1cm4gdH1zZXRFZGdlUmluZyh0LGUpe3Quc2V0RWRnZVJpbmcoZSl9bGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCl7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3t0LmdldE5vZGUoKS5nZXRFZGdlcygpLmxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0aGlzKSx0PXQuZ2V0TmV4dCgpfXdoaWxlKHQhPT10aGlzLl9zdGFydERlKX1nZXROZXh0KHQpe3JldHVybiB0LmdldE5leHQoKX1nZXRDbGFzcygpe3JldHVybiB0aX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07SnMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfTtjbGFzcyBlaXtjb25zdHJ1Y3Rvcigpe2VpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c29ydFNoZWxsc0FuZEhvbGVzKHQsZSxuKXtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmlzSG9sZSgpP24uYWRkKHQpOmUuYWRkKHQpfX1jb21wdXRlUG9seWdvbnModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKS50b1BvbHlnb24odGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZCh0KX1yZXR1cm4gZX1wbGFjZUZyZWVIb2xlcyh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpO2lmKG51bGw9PT1lLmdldFNoZWxsKCkpe2NvbnN0IG49dGhpcy5maW5kRWRnZVJpbmdDb250YWluaW5nKGUsdCk7aWYobnVsbD09PW4pdGhyb3cgbmV3IFduKFwidW5hYmxlIHRvIGFzc2lnbiBob2xlIHRvIGEgc2hlbGxcIixlLmdldENvb3JkaW5hdGUoMCkpO2Uuc2V0U2hlbGwobil9fX1idWlsZE1pbmltYWxFZGdlUmluZ3ModCxlLG4pe2NvbnN0IHM9bmV3IHg7Zm9yKGxldCBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IHQ9aS5uZXh0KCk7aWYodC5nZXRNYXhOb2RlRGVncmVlKCk+Mil7dC5saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKTtjb25zdCBzPXQuYnVpbGRNaW5pbWFsUmluZ3MoKSxpPXRoaXMuZmluZFNoZWxsKHMpO251bGwhPT1pPyh0aGlzLnBsYWNlUG9seWdvbkhvbGVzKGkscyksZS5hZGQoaSkpOm4uYWRkQWxsKHMpfWVsc2Ugcy5hZGQodCl9cmV0dXJuIHN9Y29udGFpbnNQb2ludCh0KXtmb3IobGV0IGU9dGhpcy5fc2hlbGxMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtpZihlLm5leHQoKS5jb250YWluc1BvaW50KHQpKXJldHVybiEwfXJldHVybiExfWJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQuaXNJblJlc3VsdCgpJiZ0LmdldExhYmVsKCkuaXNBcmVhKCkmJm51bGw9PT10LmdldEVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3IHRpKHQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZChuKSxuLnNldEluUmVzdWx0KCl9fXJldHVybiBlfXBsYWNlUG9seWdvbkhvbGVzKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCk7ZS5pc0hvbGUoKSYmZS5zZXRTaGVsbCh0KX19Z2V0UG9seWdvbnMoKXtyZXR1cm4gdGhpcy5jb21wdXRlUG9seWdvbnModGhpcy5fc2hlbGxMaXN0KX1maW5kRWRnZVJpbmdDb250YWluaW5nKHQsZSl7Y29uc3Qgbj10LmdldExpbmVhclJpbmcoKSxzPW4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9bi5nZXRDb29yZGluYXRlTigwKTtsZXQgcj1udWxsLG89bnVsbDtmb3IobGV0IHQ9ZS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0TGluZWFyUmluZygpLGw9bi5nZXRFbnZlbG9wZUludGVybmFsKCk7bnVsbCE9PXImJihvPXIuZ2V0TGluZWFyUmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7bGV0IGE9ITE7bC5jb250YWlucyhzKSYmV2UuaXNJblJpbmcoaSxuLmdldENvb3JkaW5hdGVzKCkpJiYoYT0hMCksYSYmKG51bGw9PT1yfHxvLmNvbnRhaW5zKGwpKSYmKHI9ZSl9cmV0dXJuIHJ9ZmluZFNoZWxsKHQpe2xldCBlPTAsbj1udWxsO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuaXNIb2xlKCl8fChuPXQsZSsrKX1yZXR1cm4gdS5pc1RydWUoZTw9MSxcImZvdW5kIHR3byBzaGVsbHMgaW4gTWluaW1hbEVkZ2VSaW5nIGxpc3RcIiksbn1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodC5nZXRFZGdlRW5kcygpLHQuZ2V0Tm9kZXMoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Wm4ubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoZSk7Y29uc3Qgbj10aGlzLmJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyh0KSxzPW5ldyB4LGk9dGhpcy5idWlsZE1pbmltYWxFZGdlUmluZ3Mobix0aGlzLl9zaGVsbExpc3Qscyk7dGhpcy5zb3J0U2hlbGxzQW5kSG9sZXMoaSx0aGlzLl9zaGVsbExpc3QscyksdGhpcy5wbGFjZUZyZWVIb2xlcyh0aGlzLl9zaGVsbExpc3Qscyl9fWdldENsYXNzKCl7cmV0dXJuIGVpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1laS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLl9zaGVsbExpc3Q9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PXR9O2NsYXNzIG5pe2NvbnN0cnVjdG9yKCl7bmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2ltcGxpZnkodCxlKXtyZXR1cm4gbmV3IG5pKHQpLnNpbXBsaWZ5KGUpfWlzRGVsZXRhYmxlKHQsZSxuLHMpe2NvbnN0IGk9dGhpcy5faW5wdXRMaW5lW3RdLHI9dGhpcy5faW5wdXRMaW5lW2VdLG89dGhpcy5faW5wdXRMaW5lW25dO3JldHVybiEhdGhpcy5pc0NvbmNhdmUoaSxyLG8pJiYoISF0aGlzLmlzU2hhbGxvdyhpLHIsbyxzKSYmdGhpcy5pc1NoYWxsb3dTYW1wbGVkKGkscix0LG4scykpfWRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpe2xldCB0PTE7dGhpcy5faW5wdXRMaW5lLmxlbmd0aDtsZXQgZT10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKSxzPSExO2Zvcig7bjx0aGlzLl9pbnB1dExpbmUubGVuZ3RoOyl7bGV0IGk9ITE7dGhpcy5pc0RlbGV0YWJsZSh0LGUsbix0aGlzLl9kaXN0YW5jZVRvbCkmJih0aGlzLl9pc0RlbGV0ZWRbZV09bmkuREVMRVRFLGk9ITAscz0hMCksdD1pP246ZSxlPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCksbj10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGUpfXJldHVybiBzfWlzU2hhbGxvd0NvbmNhdml0eSh0LGUsbixzKXtyZXR1cm4gdi5pbmRleCh0LGUsbik9PT10aGlzLl9hbmdsZU9yaWVudGF0aW9uJiZELnBvaW50VG9TZWdtZW50KGUsdCxuKTxzfWlzU2hhbGxvd1NhbXBsZWQodCxlLG4scyxpKXtsZXQgcj1NYXRoLnRydW5jKChzLW4pL25pLk5VTV9QVFNfVE9fQ0hFQ0spO3I8PTAmJihyPTEpO2ZvcihsZXQgbz1uO288cztvKz1yKWlmKCF0aGlzLmlzU2hhbGxvdyh0LGUsdGhpcy5faW5wdXRMaW5lW29dLGkpKXJldHVybiExO3JldHVybiEwfWlzQ29uY2F2ZSh0LGUsbil7cmV0dXJuIHYuaW5kZXgodCxlLG4pPT09dGhpcy5fYW5nbGVPcmllbnRhdGlvbn1zaW1wbGlmeSh0KXt0aGlzLl9kaXN0YW5jZVRvbD1NYXRoLmFicyh0KSx0PDAmJih0aGlzLl9hbmdsZU9yaWVudGF0aW9uPXYuQ0xPQ0tXSVNFKSx0aGlzLl9pc0RlbGV0ZWQ9bmV3IEFycmF5KHRoaXMuX2lucHV0TGluZS5sZW5ndGgpLmZpbGwobnVsbCk7bGV0IGU9ITE7ZG97ZT10aGlzLmRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpfXdoaWxlKGUpO3JldHVybiB0aGlzLmNvbGxhcHNlTGluZSgpfWZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpe2xldCBlPXQrMTtmb3IoO2U8dGhpcy5faW5wdXRMaW5lLmxlbmd0aCYmdGhpcy5faXNEZWxldGVkW2VdPT09bmkuREVMRVRFOyllKys7cmV0dXJuIGV9aXNTaGFsbG93KHQsZSxuLHMpe3JldHVybiBELnBvaW50VG9TZWdtZW50KGUsdCxuKTxzfWNvbGxhcHNlTGluZSgpe2NvbnN0IHQ9bmV3IEk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9pbnB1dExpbmUubGVuZ3RoO2UrKyl0aGlzLl9pc0RlbGV0ZWRbZV0hPT1uaS5ERUxFVEUmJnQuYWRkKHRoaXMuX2lucHV0TGluZVtlXSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX1nZXRDbGFzcygpe3JldHVybiBuaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRMaW5lPW51bGwsdGhpcy5fZGlzdGFuY2VUb2w9bnVsbCx0aGlzLl9pc0RlbGV0ZWQ9bnVsbCx0aGlzLl9hbmdsZU9yaWVudGF0aW9uPXYuQ09VTlRFUkNMT0NLV0lTRTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dExpbmU9dH0sbmkuSU5JVD0wLG5pLkRFTEVURT0xLG5pLktFRVA9MSxuaS5OVU1fUFRTX1RPX0NIRUNLPTEwO2NsYXNzIHNpe2NvbnN0cnVjdG9yKCl7c2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdExpc3QudG9BcnJheShzaS5DT09SRElOQVRFX0FSUkFZX1RZUEUpfXNldFByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX3ByZWNpc2lvbk1vZGVsPXR9YWRkUHQodCl7Y29uc3QgZT1uZXcgZyh0KTtpZih0aGlzLl9wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShlKSx0aGlzLmlzUmVkdW5kYW50KGUpKXJldHVybiBudWxsO3RoaXMuX3B0TGlzdC5hZGQoZSl9cmV2ZXJzZSgpe31hZGRQdHModCxlKXtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRoaXMuYWRkUHQodFtlXSk7ZWxzZSBmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl0aGlzLmFkZFB0KHRbZV0pfWlzUmVkdW5kYW50KHQpe2lmKHRoaXMuX3B0TGlzdC5zaXplKCk8MSlyZXR1cm4hMTtjb25zdCBlPXRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKS0xKTtyZXR1cm4gdC5kaXN0YW5jZShlKTx0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2V9dG9TdHJpbmcoKXtyZXR1cm4obmV3IEh0KS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSkudG9TdHJpbmcoKX1jbG9zZVJpbmcoKXtpZih0aGlzLl9wdExpc3Quc2l6ZSgpPDEpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgZyh0aGlzLl9wdExpc3QuZ2V0KDApKSxlPXRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKS0xKTtsZXQgbj1udWxsO2lmKHRoaXMuX3B0TGlzdC5zaXplKCk+PTImJnRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKS0yKSx0LmVxdWFscyhlKSlyZXR1cm4gbnVsbDt0aGlzLl9wdExpc3QuYWRkKHQpfXNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KXt0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2U9dH1nZXRDbGFzcygpe3JldHVybiBzaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19c2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRMaXN0PW51bGwsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2U9MCx0aGlzLl9wdExpc3Q9bmV3IHh9LHNpLkNPT1JESU5BVEVfQVJSQVlfVFlQRT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKTtjbGFzcyBpaXtjb25zdHJ1Y3Rvcigpe2lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkTmV4dFNlZ21lbnQodCxlKXtpZih0aGlzLl9zMD10aGlzLl9zMSx0aGlzLl9zMT10aGlzLl9zMix0aGlzLl9zMj10LHRoaXMuX3NlZzAuc2V0Q29vcmRpbmF0ZXModGhpcy5fczAsdGhpcy5fczEpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMCx0aGlzLl9zaWRlLHRoaXMuX2Rpc3RhbmNlLHRoaXMuX29mZnNldDApLHRoaXMuX3NlZzEuc2V0Q29vcmRpbmF0ZXModGhpcy5fczEsdGhpcy5fczIpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMSx0aGlzLl9zaWRlLHRoaXMuX2Rpc3RhbmNlLHRoaXMuX29mZnNldDEpLHRoaXMuX3MxLmVxdWFscyh0aGlzLl9zMikpcmV0dXJuIG51bGw7Y29uc3Qgbj12LmluZGV4KHRoaXMuX3MwLHRoaXMuX3MxLHRoaXMuX3MyKSxzPW49PT12LkNMT0NLV0lTRSYmdGhpcy5fc2lkZT09PVBuLkxFRlR8fG49PT12LkNPVU5URVJDTE9DS1dJU0UmJnRoaXMuX3NpZGU9PT1Qbi5SSUdIVDswPT09bj90aGlzLmFkZENvbGxpbmVhcihlKTpzP3RoaXMuYWRkT3V0c2lkZVR1cm4obixlKTp0aGlzLmFkZEluc2lkZVR1cm4obixlKX1hZGRMaW5lRW5kQ2FwKHQsZSl7Y29uc3Qgbj1uZXcgZWUodCxlKSxzPW5ldyBlZTt0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KG4sUG4uTEVGVCx0aGlzLl9kaXN0YW5jZSxzKTtjb25zdCBpPW5ldyBlZTt0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KG4sUG4uUklHSFQsdGhpcy5fZGlzdGFuY2UsaSk7Y29uc3Qgcj1lLngtdC54LG89ZS55LXQueSxsPU1hdGguYXRhbjIobyxyKTtzd2l0Y2godGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UganMuQ0FQX1JPVU5EOnRoaXMuX3NlZ0xpc3QuYWRkUHQocy5wMSksdGhpcy5hZGREaXJlY3RlZEZpbGxldChlLGwrTWF0aC5QSS8yLGwtTWF0aC5QSS8yLHYuQ0xPQ0tXSVNFLHRoaXMuX2Rpc3RhbmNlKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGkucDEpO2JyZWFrO2Nhc2UganMuQ0FQX0ZMQVQ6dGhpcy5fc2VnTGlzdC5hZGRQdChzLnAxKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGkucDEpO2JyZWFrO2Nhc2UganMuQ0FQX1NRVUFSRTpjb25zdCB0PW5ldyBnO3QueD1NYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkqTWF0aC5jb3MobCksdC55PU1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSpNYXRoLnNpbihsKTtjb25zdCBuPW5ldyBnKHMucDEueCt0Lngscy5wMS55K3QueSkscj1uZXcgZyhpLnAxLngrdC54LGkucDEueSt0LnkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQobiksdGhpcy5fc2VnTGlzdC5hZGRQdChyKX19Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fc2VnTGlzdC5nZXRDb29yZGluYXRlcygpfWFkZE1pdHJlSm9pbih0LGUsbixzKXtsZXQgaT0hMCxyPW51bGw7dHJ5e3I9Yi5pbnRlcnNlY3Rpb24oZS5wMCxlLnAxLG4ucDAsbi5wMSksKHM8PTA/MTpyLmRpc3RhbmNlKHQpL01hdGguYWJzKHMpKT50aGlzLl9idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpJiYoaT0hMSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgUykpdGhyb3cgdDtyPW5ldyBnKDAsMCksaT0hMX1pP3RoaXMuX3NlZ0xpc3QuYWRkUHQocik6dGhpcy5hZGRMaW1pdGVkTWl0cmVKb2luKGUsbixzLHRoaXMuX2J1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkpfWFkZE91dHNpZGVUdXJuKHQsZSl7aWYodGhpcy5fb2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLl9vZmZzZXQxLnAwKTx0aGlzLl9kaXN0YW5jZSppaS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUilyZXR1cm4gdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSxudWxsO3RoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWpzLkpPSU5fTUlUUkU/dGhpcy5hZGRNaXRyZUpvaW4odGhpcy5fczEsdGhpcy5fb2Zmc2V0MCx0aGlzLl9vZmZzZXQxLHRoaXMuX2Rpc3RhbmNlKTp0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1qcy5KT0lOX0JFVkVMP3RoaXMuYWRkQmV2ZWxKb2luKHRoaXMuX29mZnNldDAsdGhpcy5fb2Zmc2V0MSk6KGUmJnRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksdGhpcy5hZGRDb3JuZXJGaWxsZXQodGhpcy5fczEsdGhpcy5fb2Zmc2V0MC5wMSx0aGlzLl9vZmZzZXQxLnAwLHQsdGhpcy5fZGlzdGFuY2UpLHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCkpfWNyZWF0ZVNxdWFyZSh0KXt0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBnKHQueCt0aGlzLl9kaXN0YW5jZSx0LnkrdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBnKHQueCt0aGlzLl9kaXN0YW5jZSx0LnktdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBnKHQueC10aGlzLl9kaXN0YW5jZSx0LnktdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBnKHQueC10aGlzLl9kaXN0YW5jZSx0LnkrdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpfWFkZFNlZ21lbnRzKHQsZSl7dGhpcy5fc2VnTGlzdC5hZGRQdHModCxlKX1hZGRGaXJzdFNlZ21lbnQoKXt0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApfWFkZENvcm5lckZpbGxldCh0LGUsbixzLGkpe2NvbnN0IHI9ZS54LXQueCxvPWUueS10Lnk7bGV0IGw9TWF0aC5hdGFuMihvLHIpO2NvbnN0IGE9bi54LXQueCxjPW4ueS10LnksaD1NYXRoLmF0YW4yKGMsYSk7cz09PXYuQ0xPQ0tXSVNFP2w8PWgmJihsKz0yKk1hdGguUEkpOmw+PWgmJihsLT0yKk1hdGguUEkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGREaXJlY3RlZEZpbGxldCh0LGwsaCxzLGkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobil9YWRkTGFzdFNlZ21lbnQoKXt0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDEpfWluaXRTaWRlU2VnbWVudHModCxlLG4pe3RoaXMuX3MxPXQsdGhpcy5fczI9ZSx0aGlzLl9zaWRlPW4sdGhpcy5fc2VnMS5zZXRDb29yZGluYXRlcyh0LGUpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMSxuLHRoaXMuX2Rpc3RhbmNlLHRoaXMuX29mZnNldDEpfWFkZExpbWl0ZWRNaXRyZUpvaW4odCxlLG4scyl7Y29uc3QgaT10aGlzLl9zZWcwLnAxLHI9aWUuYW5nbGUoaSx0aGlzLl9zZWcwLnAwKSxvPShpZS5hbmdsZShpLHRoaXMuX3NlZzEucDEpLGllLmFuZ2xlQmV0d2Vlbk9yaWVudGVkKHRoaXMuX3NlZzAucDAsaSx0aGlzLl9zZWcxLnAxKS8yKSxsPWllLm5vcm1hbGl6ZShyK28pLGE9aWUubm9ybWFsaXplKGwrTWF0aC5QSSksYz1zKm4saD1uLWMqTWF0aC5hYnMoTWF0aC5zaW4obykpLHU9aS54K2MqTWF0aC5jb3MoYSksZD1pLnkrYypNYXRoLnNpbihhKSxfPW5ldyBnKHUsZCksZj1uZXcgZWUoaSxfKSxwPWYucG9pbnRBbG9uZ09mZnNldCgxLGgpLG09Zi5wb2ludEFsb25nT2Zmc2V0KDEsLWgpO3RoaXMuX3NpZGU9PT1Qbi5MRUZUPyh0aGlzLl9zZWdMaXN0LmFkZFB0KHApLHRoaXMuX3NlZ0xpc3QuYWRkUHQobSkpOih0aGlzLl9zZWdMaXN0LmFkZFB0KG0pLHRoaXMuX3NlZ0xpc3QuYWRkUHQocCkpfWFkZERpcmVjdGVkRmlsbGV0KHQsZSxuLHMsaSl7Y29uc3Qgcj1zPT09di5DTE9DS1dJU0U/LTE6MSxvPU1hdGguYWJzKGUtbiksbD1NYXRoLnRydW5jKG8vdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtKy41KTtpZihsPDEpcmV0dXJuIG51bGw7bGV0IGE9bnVsbCxjPW51bGw7YT0wLGM9by9sO2xldCBoPTA7Y29uc3QgdT1uZXcgZztmb3IoO2g8bzspe2NvbnN0IG49ZStyKmg7dS54PXQueCtpKk1hdGguY29zKG4pLHUueT10LnkraSpNYXRoLnNpbihuKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHUpLGgrPWN9fWNvbXB1dGVPZmZzZXRTZWdtZW50KHQsZSxuLHMpe2NvbnN0IGk9ZT09PVBuLkxFRlQ/MTotMSxyPXQucDEueC10LnAwLngsbz10LnAxLnktdC5wMC55LGw9TWF0aC5zcXJ0KHIqcitvKm8pLGE9aSpuKnIvbCxjPWkqbipvL2w7cy5wMC54PXQucDAueC1jLHMucDAueT10LnAwLnkrYSxzLnAxLng9dC5wMS54LWMscy5wMS55PXQucDEueSthfWFkZEluc2lkZVR1cm4odCxlKXtpZih0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuX29mZnNldDAucDAsdGhpcy5fb2Zmc2V0MC5wMSx0aGlzLl9vZmZzZXQxLnAwLHRoaXMuX29mZnNldDEucDEpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKXRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApKTtlbHNlIGlmKHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMCx0aGlzLl9vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMuX29mZnNldDEucDApPHRoaXMuX2Rpc3RhbmNlKmlpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpO2Vsc2V7aWYodGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSx0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPjApe2NvbnN0IHQ9bmV3IGcoKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MC5wMS54K3RoaXMuX3MxLngpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDAucDEueSt0aGlzLl9zMS55KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5fc2VnTGlzdC5hZGRQdCh0KTtjb25zdCBlPW5ldyBnKCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDEucDAueCt0aGlzLl9zMS54KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQxLnAwLnkrdGhpcy5fczEueSkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQoZSl9ZWxzZSB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX3MxKTt0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApfX1jcmVhdGVDaXJjbGUodCl7Y29uc3QgZT1uZXcgZyh0LngrdGhpcy5fZGlzdGFuY2UsdC55KTt0aGlzLl9zZWdMaXN0LmFkZFB0KGUpLHRoaXMuYWRkRGlyZWN0ZWRGaWxsZXQodCwwLDIqTWF0aC5QSSwtMSx0aGlzLl9kaXN0YW5jZSksdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKX1hZGRCZXZlbEpvaW4odCxlKXt0aGlzLl9zZWdMaXN0LmFkZFB0KHQucDEpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoZS5wMCl9aW5pdCh0KXt0aGlzLl9kaXN0YW5jZT10LHRoaXMuX21heEN1cnZlU2VnbWVudEVycm9yPXQqKDEtTWF0aC5jb3ModGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtLzIpKSx0aGlzLl9zZWdMaXN0PW5ldyBzaSx0aGlzLl9zZWdMaXN0LnNldFByZWNpc2lvbk1vZGVsKHRoaXMuX3ByZWNpc2lvbk1vZGVsKSx0aGlzLl9zZWdMaXN0LnNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KmlpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil9YWRkQ29sbGluZWFyKHQpe3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5fczAsdGhpcy5fczEsdGhpcy5fczEsdGhpcy5fczIpLHRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpPj0yJiYodGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09anMuSk9JTl9CRVZFTHx8dGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09anMuSk9JTl9NSVRSRT8odCYmdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApKTp0aGlzLmFkZENvcm5lckZpbGxldCh0aGlzLl9zMSx0aGlzLl9vZmZzZXQwLnAxLHRoaXMuX29mZnNldDEucDAsdi5DTE9DS1dJU0UsdGhpcy5fZGlzdGFuY2UpKX1jbG9zZVJpbmcoKXt0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpfWhhc05hcnJvd0NvbmNhdmVBbmdsZSgpe3JldHVybiB0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGV9Z2V0Q2xhc3MoKXtyZXR1cm4gaWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWlpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX21heEN1cnZlU2VnbWVudEVycm9yPTAsdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtPW51bGwsdGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj0xLHRoaXMuX3NlZ0xpc3Q9bnVsbCx0aGlzLl9kaXN0YW5jZT0wLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYnVmUGFyYW1zPW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9zMD1udWxsLHRoaXMuX3MxPW51bGwsdGhpcy5fczI9bnVsbCx0aGlzLl9zZWcwPW5ldyBlZSx0aGlzLl9zZWcxPW5ldyBlZSx0aGlzLl9vZmZzZXQwPW5ldyBlZSx0aGlzLl9vZmZzZXQxPW5ldyBlZSx0aGlzLl9zaWRlPTAsdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fYnVmUGFyYW1zPWUsdGhpcy5fbGk9bmV3IHRlLHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bT1NYXRoLlBJLzIvZS5nZXRRdWFkcmFudFNlZ21lbnRzKCksZS5nZXRRdWFkcmFudFNlZ21lbnRzKCk+PTgmJmUuZ2V0Sm9pblN0eWxlKCk9PT1qcy5KT0lOX1JPVU5EJiYodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj1paS5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUiksdGhpcy5pbml0KG4pfSxpaS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj0uMDAxLGlpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0uMDAxLGlpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0xZS02LGlpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SPTgwO2NsYXNzIHJpe2NvbnN0cnVjdG9yKCl7cmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29weUNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09bmV3IGcodFtuXSk7cmV0dXJuIGV9Z2V0T2Zmc2V0Q3VydmUodCxlKXtpZih0aGlzLl9kaXN0YW5jZT1lLDA9PT1lKXJldHVybiBudWxsO2NvbnN0IG49ZTwwLHM9TWF0aC5hYnMoZSksaT10aGlzLmdldFNlZ0dlbihzKTt0Lmxlbmd0aDw9MT90aGlzLmNvbXB1dGVQb2ludEN1cnZlKHRbMF0saSk6dGhpcy5jb21wdXRlT2Zmc2V0Q3VydmUodCxuLGkpO2NvbnN0IHI9aS5nZXRDb29yZGluYXRlcygpO3JldHVybiBuJiZYLnJldmVyc2Uocikscn1jb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZSh0LGUsbil7Y29uc3Qgcz10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtpZihlKXtuLmFkZFNlZ21lbnRzKHQsITApO2NvbnN0IGU9bmkuc2ltcGxpZnkodCwtcyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlW2ldLGVbaS0xXSxQbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD1pLTI7dD49MDt0LS0pbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1lbHNle24uYWRkU2VnbWVudHModCwhMSk7Y29uc3QgZT1uaS5zaW1wbGlmeSh0LHMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVswXSxlWzFdLFBuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PTI7dDw9aTt0Kyspbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1uLmFkZExhc3RTZWdtZW50KCksbi5jbG9zZVJpbmcoKX1jb21wdXRlUmluZ0J1ZmZlckN1cnZlKHQsZSxuKXtsZXQgcz10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtlPT09UG4uUklHSFQmJihzPS1zKTtjb25zdCBpPW5pLnNpbXBsaWZ5KHQscykscj1pLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhpW3ItMV0saVswXSxlKTtmb3IobGV0IHQ9MTt0PD1yO3QrKyl7Y29uc3QgZT0xIT09dDtuLmFkZE5leHRTZWdtZW50KGlbdF0sZSl9bi5jbG9zZVJpbmcoKX1jb21wdXRlTGluZUJ1ZmZlckN1cnZlKHQsZSl7Y29uc3Qgbj10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKSxzPW5pLnNpbXBsaWZ5KHQsbiksaT1zLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhzWzBdLHNbMV0sUG4uTEVGVCk7Zm9yKGxldCB0PTI7dDw9aTt0KyspZS5hZGROZXh0U2VnbWVudChzW3RdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKHNbaS0xXSxzW2ldKTtjb25zdCByPW5pLnNpbXBsaWZ5KHQsLW4pLG89ci5sZW5ndGgtMTtlLmluaXRTaWRlU2VnbWVudHMocltvXSxyW28tMV0sUG4uTEVGVCk7Zm9yKGxldCB0PW8tMjt0Pj0wO3QtLSllLmFkZE5leHRTZWdtZW50KHJbdF0sITApO2UuYWRkTGFzdFNlZ21lbnQoKSxlLmFkZExpbmVFbmRDYXAoclsxXSxyWzBdKSxlLmNsb3NlUmluZygpfWNvbXB1dGVQb2ludEN1cnZlKHQsZSl7c3dpdGNoKHRoaXMuX2J1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKXtjYXNlIGpzLkNBUF9ST1VORDplLmNyZWF0ZUNpcmNsZSh0KTticmVhaztjYXNlIGpzLkNBUF9TUVVBUkU6ZS5jcmVhdGVTcXVhcmUodCl9fWdldExpbmVDdXJ2ZSh0LGUpe2lmKHRoaXMuX2Rpc3RhbmNlPWUsZTwwJiYhdGhpcy5fYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDtpZigwPT09ZSlyZXR1cm4gbnVsbDtjb25zdCBuPU1hdGguYWJzKGUpLHM9dGhpcy5nZXRTZWdHZW4obik7aWYodC5sZW5ndGg8PTEpdGhpcy5jb21wdXRlUG9pbnRDdXJ2ZSh0WzBdLHMpO2Vsc2UgaWYodGhpcy5fYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSl7Y29uc3Qgbj1lPDA7dGhpcy5jb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZSh0LG4scyl9ZWxzZSB0aGlzLmNvbXB1dGVMaW5lQnVmZmVyQ3VydmUodCxzKTtyZXR1cm4gcy5nZXRDb29yZGluYXRlcygpfWdldEJ1ZmZlclBhcmFtZXRlcnMoKXtyZXR1cm4gdGhpcy5fYnVmUGFyYW1zfXNpbXBsaWZ5VG9sZXJhbmNlKHQpe3JldHVybiB0KnRoaXMuX2J1ZlBhcmFtcy5nZXRTaW1wbGlmeUZhY3RvcigpfWdldFJpbmdDdXJ2ZSh0LGUsbil7aWYodGhpcy5fZGlzdGFuY2U9bix0Lmxlbmd0aDw9MilyZXR1cm4gdGhpcy5nZXRMaW5lQ3VydmUodCxuKTtpZigwPT09bilyZXR1cm4gcmkuY29weUNvb3JkaW5hdGVzKHQpO2NvbnN0IHM9dGhpcy5nZXRTZWdHZW4obik7cmV0dXJuIHRoaXMuY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZSh0LGUscykscy5nZXRDb29yZGluYXRlcygpfWNvbXB1dGVPZmZzZXRDdXJ2ZSh0LGUsbil7Y29uc3Qgcz10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtpZihlKXtjb25zdCBlPW5pLnNpbXBsaWZ5KHQsLXMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVtpXSxlW2ktMV0sUG4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9aS0yO3Q+PTA7dC0tKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9ZWxzZXtjb25zdCBlPW5pLnNpbXBsaWZ5KHQscyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlWzBdLGVbMV0sUG4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfW4uYWRkTGFzdFNlZ21lbnQoKX1nZXRTZWdHZW4odCl7cmV0dXJuIG5ldyBpaSh0aGlzLl9wcmVjaXNpb25Nb2RlbCx0aGlzLl9idWZQYXJhbXMsdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gcml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXJpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Rpc3RhbmNlPTAsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9idWZQYXJhbXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wcmVjaXNpb25Nb2RlbD10LHRoaXMuX2J1ZlBhcmFtcz1lfTtjbGFzcyBvaXtjb25zdHJ1Y3Rvcigpe29pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluZFN0YWJiZWRTZWdtZW50cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4O2ZvcihsZXQgbj10aGlzLl9zdWJncmFwaHMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCksaT1zLmdldEVudmVsb3BlKCk7dC55PGkuZ2V0TWluWSgpfHx0Lnk+aS5nZXRNYXhZKCl8fHRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0LHMuZ2V0RGlyZWN0ZWRFZGdlcygpLGUpfXJldHVybiBlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKF8oYXJndW1lbnRzWzJdLG0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2Ygam4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9ZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGk9MDtpPHMubGVuZ3RoLTE7aSsrKXtpZih0aGlzLl9zZWcucDA9c1tpXSx0aGlzLl9zZWcucDE9c1tpKzFdLHRoaXMuX3NlZy5wMC55PnRoaXMuX3NlZy5wMS55JiZ0aGlzLl9zZWcucmV2ZXJzZSgpLE1hdGgubWF4KHRoaXMuX3NlZy5wMC54LHRoaXMuX3NlZy5wMS54KTx0LngpY29udGludWU7aWYodGhpcy5fc2VnLmlzSG9yaXpvbnRhbCgpKWNvbnRpbnVlO2lmKHQueTx0aGlzLl9zZWcucDAueXx8dC55PnRoaXMuX3NlZy5wMS55KWNvbnRpbnVlO2lmKHYuaW5kZXgodGhpcy5fc2VnLnAwLHRoaXMuX3NlZy5wMSx0KT09PXYuUklHSFQpY29udGludWU7bGV0IHI9ZS5nZXREZXB0aChQbi5MRUZUKTt0aGlzLl9zZWcucDAuZXF1YWxzKHNbaV0pfHwocj1lLmdldERlcHRoKFBuLlJJR0hUKSk7Y29uc3Qgbz1uZXcgbGkodGhpcy5fc2VnLHIpO24uYWRkKG8pfX1lbHNlIGlmKF8oYXJndW1lbnRzWzJdLG0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJl8oYXJndW1lbnRzWzFdLG0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtmb3IobGV0IHM9ZS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgZT1zLm5leHQoKTtlLmlzRm9yd2FyZCgpJiZ0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCxlLG4pfX19Z2V0RGVwdGgodCl7Y29uc3QgZT10aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCk7cmV0dXJuIDA9PT1lLnNpemUoKT8wOkVlLm1pbihlKS5fbGVmdERlcHRofWdldENsYXNzKCl7cmV0dXJuIG9pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBsaXtjb25zdHJ1Y3Rvcigpe2xpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtpZih0aGlzLl91cHdhcmRTZWcubWluWCgpPj1lLl91cHdhcmRTZWcubWF4WCgpKXJldHVybiAxO2lmKHRoaXMuX3Vwd2FyZFNlZy5tYXhYKCk8PWUuX3Vwd2FyZFNlZy5taW5YKCkpcmV0dXJuLTE7bGV0IG49dGhpcy5fdXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgoZS5fdXB3YXJkU2VnKTtyZXR1cm4gMCE9PW4/bjoobj0tMSplLl91cHdhcmRTZWcub3JpZW50YXRpb25JbmRleCh0aGlzLl91cHdhcmRTZWcpLDAhPT1uP246dGhpcy5fdXB3YXJkU2VnLmNvbXBhcmVUbyhlLl91cHdhcmRTZWcpKX1jb21wYXJlWCh0LGUpe2NvbnN0IG49dC5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dC5wMS5jb21wYXJlVG8oZS5wMSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fdXB3YXJkU2VnLnRvU3RyaW5nKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gbGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1saS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl91cHdhcmRTZWc9bnVsbCx0aGlzLl9sZWZ0RGVwdGg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl91cHdhcmRTZWc9bmV3IGVlKHQpLHRoaXMuX2xlZnREZXB0aD1lfSxvaS5EZXB0aFNlZ21lbnQ9bGksb2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc3ViZ3JhcGhzPW51bGwsdGhpcy5fc2VnPW5ldyBlZTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJncmFwaHM9dH07Y2xhc3MgYWl7Y29uc3RydWN0b3IoKXthaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZFBvaW50KHQpe2lmKHRoaXMuX2Rpc3RhbmNlPD0wKXJldHVybiBudWxsO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpLG49dGhpcy5fY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShlLHRoaXMuX2Rpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKG4sbmUuRVhURVJJT1IsbmUuSU5URVJJT1IpfWFkZFBvbHlnb24odCl7bGV0IGU9dGhpcy5fZGlzdGFuY2Usbj1Qbi5MRUZUO3RoaXMuX2Rpc3RhbmNlPDAmJihlPS10aGlzLl9kaXN0YW5jZSxuPVBuLlJJR0hUKTtjb25zdCBzPXQuZ2V0RXh0ZXJpb3JSaW5nKCksaT1YLnJlbW92ZVJlcGVhdGVkUG9pbnRzKHMuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYodGhpcy5fZGlzdGFuY2U8MCYmdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkocyx0aGlzLl9kaXN0YW5jZSkpcmV0dXJuIG51bGw7aWYodGhpcy5fZGlzdGFuY2U8PTAmJmkubGVuZ3RoPDMpcmV0dXJuIG51bGw7dGhpcy5hZGRQb2x5Z29uUmluZyhpLGUsbixuZS5FWFRFUklPUixuZS5JTlRFUklPUik7Zm9yKGxldCBzPTA7czx0LmdldE51bUludGVyaW9yUmluZygpO3MrKyl7Y29uc3QgaT10LmdldEludGVyaW9yUmluZ04ocykscj1YLnJlbW92ZVJlcGVhdGVkUG9pbnRzKGkuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5fZGlzdGFuY2U+MCYmdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkoaSwtdGhpcy5fZGlzdGFuY2UpfHx0aGlzLmFkZFBvbHlnb25SaW5nKHIsZSxQbi5vcHBvc2l0ZShuKSxuZS5JTlRFUklPUixuZS5FWFRFUklPUil9fWlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5KHQsZSl7Y29uc3Qgbj1uZXcgcmUodFswXSx0WzFdLHRbMl0pLHM9bi5pbkNlbnRyZSgpO3JldHVybiBELnBvaW50VG9TZWdtZW50KHMsbi5wMCxuLnAxKTxNYXRoLmFicyhlKX1hZGRMaW5lU3RyaW5nKHQpe2lmKHRoaXMuX2Rpc3RhbmNlPD0wJiYhdGhpcy5fY3VydmVCdWlsZGVyLmdldEJ1ZmZlclBhcmFtZXRlcnMoKS5pc1NpbmdsZVNpZGVkKCkpcmV0dXJuIG51bGw7Y29uc3QgZT1YLnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbj10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5fZGlzdGFuY2UpO3RoaXMuYWRkQ3VydmUobixuZS5FWFRFUklPUixuZS5JTlRFUklPUil9YWRkQ3VydmUodCxlLG4pe2lmKG51bGw9PT10fHx0Lmxlbmd0aDwyKXJldHVybiBudWxsO2NvbnN0IHM9bmV3IEZzKHQsbmV3IEZuKDAsbmUuQk9VTkRBUlksZSxuKSk7dGhpcy5fY3VydmVMaXN0LmFkZChzKX1nZXRDdXJ2ZXMoKXtyZXR1cm4gdGhpcy5hZGQodGhpcy5faW5wdXRHZW9tKSx0aGlzLl9jdXJ2ZUxpc3R9YWRkUG9seWdvblJpbmcodCxlLG4scyxpKXtpZigwPT09ZSYmdC5sZW5ndGg8RHQuTUlOSU1VTV9WQUxJRF9TSVpFKXJldHVybiBudWxsO2xldCByPXMsbz1pO3QubGVuZ3RoPj1EdC5NSU5JTVVNX1ZBTElEX1NJWkUmJnYuaXNDQ1codCkmJihyPWksbz1zLG49UG4ub3Bwb3NpdGUobikpO2NvbnN0IGw9dGhpcy5fY3VydmVCdWlsZGVyLmdldFJpbmdDdXJ2ZSh0LG4sZSk7dGhpcy5hZGRDdXJ2ZShsLHIsbyl9YWRkKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBidCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgTXQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBBdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBfdCkpdGhyb3cgbmV3IFoodC5nZXRDbGFzcygpLmdldE5hbWUoKSk7dGhpcy5hZGRDb2xsZWN0aW9uKHQpfX1pc0Vyb2RlZENvbXBsZXRlbHkodCxlKXtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtpZihuLmxlbmd0aDw0KXJldHVybiBlPDA7aWYoND09PW4ubGVuZ3RoKXJldHVybiB0aGlzLmlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5KG4sZSk7Y29uc3Qgcz10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxpPU1hdGgubWluKHMuZ2V0SGVpZ2h0KCkscy5nZXRXaWR0aCgpKTtyZXR1cm4gZTwwJiYyKk1hdGguYWJzKGUpPml9YWRkQ29sbGVjdGlvbih0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19Z2V0Q2xhc3MoKXtyZXR1cm4gYWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWFpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5fY3VydmVCdWlsZGVyPW51bGwsdGhpcy5fY3VydmVMaXN0PW5ldyB4O2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2Rpc3RhbmNlPWUsdGhpcy5fY3VydmVCdWlsZGVyPW59O2NsYXNzIGNpe2NvbnN0cnVjdG9yKCl7Y2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXROZXh0Q1codCl7dGhpcy5nZXRFZGdlcygpO2NvbnN0IGU9dGhpcy5fZWRnZUxpc3QuaW5kZXhPZih0KTtsZXQgbj1lLTE7cmV0dXJuIDA9PT1lJiYobj10aGlzLl9lZGdlTGlzdC5zaXplKCktMSksdGhpcy5fZWRnZUxpc3QuZ2V0KG4pfXByb3BhZ2F0ZVNpZGVMYWJlbHModCl7bGV0IGU9bmUuTk9ORTtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKS5nZXRMYWJlbCgpO3MuaXNBcmVhKHQpJiZzLmdldExvY2F0aW9uKHQsUG4uTEVGVCkhPT1uZS5OT05FJiYoZT1zLmdldExvY2F0aW9uKHQsUG4uTEVGVCkpfWlmKGU9PT1uZS5OT05FKXJldHVybiBudWxsO2xldCBuPWU7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT1zLmdldExhYmVsKCk7aWYoaS5nZXRMb2NhdGlvbih0LFBuLk9OKT09PW5lLk5PTkUmJmkuc2V0TG9jYXRpb24odCxQbi5PTixuKSxpLmlzQXJlYSh0KSl7Y29uc3QgZT1pLmdldExvY2F0aW9uKHQsUG4uTEVGVCkscj1pLmdldExvY2F0aW9uKHQsUG4uUklHSFQpO2lmKHIhPT1uZS5OT05FKXtpZihyIT09bil0aHJvdyBuZXcgV24oXCJzaWRlIGxvY2F0aW9uIGNvbmZsaWN0XCIscy5nZXRDb29yZGluYXRlKCkpO2U9PT1uZS5OT05FJiZ1LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiZm91bmQgc2luZ2xlIG51bGwgc2lkZSAoYXQgXCIrcy5nZXRDb29yZGluYXRlKCkrXCIpXCIpLG49ZX1lbHNlIHUuaXNUcnVlKGkuZ2V0TG9jYXRpb24odCxQbi5MRUZUKT09PW5lLk5PTkUsXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlXCIpLGkuc2V0TG9jYXRpb24odCxQbi5SSUdIVCxuKSxpLnNldExvY2F0aW9uKHQsUG4uTEVGVCxuKX19fWdldENvb3JkaW5hdGUoKXtjb25zdCB0PXRoaXMuaXRlcmF0b3IoKTtyZXR1cm4gdC5oYXNOZXh0KCk/dC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZSgpOm51bGx9cHJpbnQodCl7Ty5vdXQucHJpbnRsbihcIkVkZ2VFbmRTdGFyOiAgIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWlzQXJlYUxhYmVsc0NvbnNpc3RlbnQodCl7cmV0dXJuIHRoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHModC5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpLHRoaXMuY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCgwKX1jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50KHQpe2NvbnN0IGU9dGhpcy5nZXRFZGdlcygpO2lmKGUuc2l6ZSgpPD0wKXJldHVybiEwO2NvbnN0IG49ZS5zaXplKCktMSxzPWUuZ2V0KG4pLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCxQbi5MRUZUKTt1LmlzVHJ1ZShzIT09bmUuTk9ORSxcIkZvdW5kIHVubGFiZWxsZWQgYXJlYSBlZGdlXCIpO2xldCBpPXM7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0TGFiZWwoKTt1LmlzVHJ1ZShuLmlzQXJlYSh0KSxcIkZvdW5kIG5vbi1hcmVhIGVkZ2VcIik7Y29uc3Qgcz1uLmdldExvY2F0aW9uKHQsUG4uTEVGVCkscj1uLmdldExvY2F0aW9uKHQsUG4uUklHSFQpO2lmKHM9PT1yKXJldHVybiExO2lmKHIhPT1pKXJldHVybiExO2k9c31yZXR1cm4hMH1maW5kSW5kZXgodCl7dGhpcy5pdGVyYXRvcigpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZUxpc3Quc2l6ZSgpO2UrKyl7aWYodGhpcy5fZWRnZUxpc3QuZ2V0KGUpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pdGVyYXRvcigpe3JldHVybiB0aGlzLmdldEVkZ2VzKCkuaXRlcmF0b3IoKX1nZXRFZGdlcygpe3JldHVybiBudWxsPT09dGhpcy5fZWRnZUxpc3QmJih0aGlzLl9lZGdlTGlzdD1uZXcgeCh0aGlzLl9lZGdlTWFwLnZhbHVlcygpKSksdGhpcy5fZWRnZUxpc3R9Z2V0TG9jYXRpb24odCxlLG4pe3JldHVybiB0aGlzLl9wdEluQXJlYUxvY2F0aW9uW3RdPT09bmUuTk9ORSYmKHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bdF09WmUubG9jYXRlKGUsblt0XS5nZXRHZW9tZXRyeSgpKSksdGhpcy5fcHRJbkFyZWFMb2NhdGlvblt0XX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHc7dC5hcHBlbmQoXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSksdC5hcHBlbmQoXCJcXG5cIik7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dC5hcHBlbmQobiksdC5hcHBlbmQoXCJcXG5cIil9cmV0dXJuIHQudG9TdHJpbmcoKX1jb21wdXRlRWRnZUVuZExhYmVscyh0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuY29tcHV0ZUxhYmVsKHQpfX1jb21wdXRlTGFiZWxsaW5nKHQpe3RoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHModFswXS5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygwKSx0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMSk7Y29uc3QgZT1bITEsITFdO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLmdldExhYmVsKCk7Zm9yKGxldCB0PTA7dDwyO3QrKyluLmlzTGluZSh0KSYmbi5nZXRMb2NhdGlvbih0KT09PW5lLkJPVU5EQVJZJiYoZVt0XT0hMCl9Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCksaT1zLmdldExhYmVsKCk7Zm9yKGxldCBuPTA7bjwyO24rKylpZihpLmlzQW55TnVsbChuKSl7bGV0IHI9bmUuTk9ORTtpZihlW25dKXI9bmUuRVhURVJJT1I7ZWxzZXtjb25zdCBlPXMuZ2V0Q29vcmRpbmF0ZSgpO3I9dGhpcy5nZXRMb2NhdGlvbihuLGUsdCl9aS5zZXRBbGxMb2NhdGlvbnNJZk51bGwobixyKX19fWdldERlZ3JlZSgpe3JldHVybiB0aGlzLl9lZGdlTWFwLnNpemUoKX1pbnNlcnRFZGdlRW5kKHQsZSl7dGhpcy5fZWRnZU1hcC5wdXQodCxlKSx0aGlzLl9lZGdlTGlzdD1udWxsfWdldENsYXNzKCl7cmV0dXJuIGNpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9lZGdlTWFwPW5ldyBydCx0aGlzLl9lZGdlTGlzdD1udWxsLHRoaXMuX3B0SW5BcmVhTG9jYXRpb249W25lLk5PTkUsbmUuTk9ORV19O2NsYXNzIGhpIGV4dGVuZHMgY2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLGhpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKXt0aGlzLmdldFJlc3VsdEFyZWFFZGdlcygpO2xldCB0PW51bGwsZT1udWxsLG49dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO2ZvcihsZXQgcz0wO3M8dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKTtzKyspe2NvbnN0IGk9dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LmdldChzKSxyPWkuZ2V0U3ltKCk7aWYoaS5nZXRMYWJlbCgpLmlzQXJlYSgpKXN3aXRjaChudWxsPT09dCYmaS5pc0luUmVzdWx0KCkmJih0PWkpLG4pe2Nhc2UgdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKCFyLmlzSW5SZXN1bHQoKSljb250aW51ZTtlPXIsbj10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5fTElOS0lOR19UT19PVVRHT0lORzppZighaS5pc0luUmVzdWx0KCkpY29udGludWU7ZS5zZXROZXh0KGkpLG49dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HfX1pZihuPT09dGhpcy5fTElOS0lOR19UT19PVVRHT0lORyl7aWYobnVsbD09PXQpdGhyb3cgbmV3IFduKFwibm8gb3V0Z29pbmcgZGlyRWRnZSBmb3VuZFwiLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTt1LmlzVHJ1ZSh0LmlzSW5SZXN1bHQoKSxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxlLnNldE5leHQodCl9fWluc2VydCh0KXtjb25zdCBlPXQ7dGhpcy5pbnNlcnRFZGdlRW5kKGUsZSl9Z2V0UmlnaHRtb3N0RWRnZSgpe2NvbnN0IHQ9dGhpcy5nZXRFZGdlcygpLGU9dC5zaXplKCk7aWYoZTwxKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXQoMCk7aWYoMT09PWUpcmV0dXJuIG47Y29uc3Qgcz10LmdldChlLTEpLGk9bi5nZXRRdWFkcmFudCgpLHI9cy5nZXRRdWFkcmFudCgpO3JldHVybiBJbi5pc05vcnRoZXJuKGkpJiZJbi5pc05vcnRoZXJuKHIpP246SW4uaXNOb3J0aGVybihpKXx8SW4uaXNOb3J0aGVybihyKT8wIT09bi5nZXREeSgpP246MCE9PXMuZ2V0RHkoKT9zOih1LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiZm91bmQgdHdvIGhvcml6b250YWwgZWRnZXMgaW5jaWRlbnQgb24gbm9kZVwiKSxudWxsKTpzfXByaW50KHQpe08ub3V0LnByaW50bG4oXCJEaXJlY3RlZEVkZ2VTdGFyOiBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dC5wcmludChcIm91dCBcIiksbi5wcmludCh0KSx0LnByaW50bG4oKSx0LnByaW50KFwiaW4gXCIpLG4uZ2V0U3ltKCkucHJpbnQodCksdC5wcmludGxuKCl9fWdldFJlc3VsdEFyZWFFZGdlcygpe2lmKG51bGwhPT10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QpcmV0dXJuIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdDt0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Q9bmV3IHg7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7KGUuaXNJblJlc3VsdCgpfHxlLmdldFN5bSgpLmlzSW5SZXN1bHQoKSkmJnRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5hZGQoZSl9cmV0dXJuIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdH11cGRhdGVMYWJlbGxpbmcodCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0TGFiZWwoKTtuLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLHQuZ2V0TG9jYXRpb24oMCkpLG4uc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsdC5nZXRMb2NhdGlvbigxKSl9fWxpbmtBbGxEaXJlY3RlZEVkZ2VzKCl7dGhpcy5nZXRFZGdlcygpO2xldCB0PW51bGwsZT1udWxsO2ZvcihsZXQgbj10aGlzLl9lZGdlTGlzdC5zaXplKCktMTtuPj0wO24tLSl7Y29uc3Qgcz10aGlzLl9lZGdlTGlzdC5nZXQobiksaT1zLmdldFN5bSgpO251bGw9PT1lJiYoZT1pKSxudWxsIT09dCYmaS5zZXROZXh0KHQpLHQ9c31lLnNldE5leHQodCl9Y29tcHV0ZURlcHRocygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZmluZEluZGV4KHQpLG49dC5nZXREZXB0aChQbi5MRUZUKSxzPXQuZ2V0RGVwdGgoUG4uUklHSFQpLGk9dGhpcy5jb21wdXRlRGVwdGhzKGUrMSx0aGlzLl9lZGdlTGlzdC5zaXplKCksbik7aWYodGhpcy5jb21wdXRlRGVwdGhzKDAsZSxpKSE9PXMpdGhyb3cgbmV3IFduKFwiZGVwdGggbWlzbWF0Y2ggYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPWFyZ3VtZW50c1syXTtmb3IobGV0IHM9dDtzPGU7cysrKXtjb25zdCB0PXRoaXMuX2VkZ2VMaXN0LmdldChzKTt0LnNldEVkZ2VEZXB0aHMoUG4uUklHSFQsbiksbj10LmdldERlcHRoKFBuLkxFRlQpfXJldHVybiBufX1tZXJnZVN5bUxhYmVscygpe2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2UuZ2V0TGFiZWwoKS5tZXJnZShlLmdldFN5bSgpLmdldExhYmVsKCkpfX1saW5rTWluaW1hbERpcmVjdGVkRWRnZXModCl7bGV0IGU9bnVsbCxuPW51bGwscz10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7Zm9yKGxldCBpPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCktMTtpPj0wO2ktLSl7Y29uc3Qgcj10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KGkpLG89ci5nZXRTeW0oKTtzd2l0Y2gobnVsbD09PWUmJnIuZ2V0RWRnZVJpbmcoKT09PXQmJihlPXIpLHMpe2Nhc2UgdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKG8uZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bj1vLHM9dGhpcy5fTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc6aWYoci5nZXRFZGdlUmluZygpIT09dCljb250aW51ZTtuLnNldE5leHRNaW4ocikscz10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkd9fXM9PT10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HJiYodS5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIGZvciBmaXJzdCBvdXRnb2luZyBkaXJFZGdlXCIpLHUuaXNUcnVlKGUuZ2V0RWRnZVJpbmcoKT09PXQsXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksbi5zZXROZXh0TWluKGUpKX1nZXRPdXRnb2luZ0RlZ3JlZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD0wO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5pc0luUmVzdWx0KCkmJnQrK31yZXR1cm4gdH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9MDtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuZ2V0RWRnZVJpbmcoKT09PXQmJmUrK31yZXR1cm4gZX19Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9ZmluZENvdmVyZWRMaW5lRWRnZXMoKXtsZXQgdD1uZS5OT05FO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRTeW0oKTtpZighbi5pc0xpbmVFZGdlKCkpe2lmKG4uaXNJblJlc3VsdCgpKXt0PW5lLklOVEVSSU9SO2JyZWFrfWlmKHMuaXNJblJlc3VsdCgpKXt0PW5lLkVYVEVSSU9SO2JyZWFrfX19aWYodD09PW5lLk5PTkUpcmV0dXJuIG51bGw7bGV0IGU9dDtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKSxzPW4uZ2V0U3ltKCk7bi5pc0xpbmVFZGdlKCk/bi5nZXRFZGdlKCkuc2V0Q292ZXJlZChlPT09bmUuSU5URVJJT1IpOihuLmlzSW5SZXN1bHQoKSYmKGU9bmUuRVhURVJJT1IpLHMuaXNJblJlc3VsdCgpJiYoZT1uZS5JTlRFUklPUikpfX1jb21wdXRlTGFiZWxsaW5nKHQpe3N1cGVyLmNvbXB1dGVMYWJlbGxpbmcuY2FsbCh0aGlzLHQpLHRoaXMuX2xhYmVsPW5ldyBGbihuZS5OT05FKTtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKS5nZXRFZGdlKCkuZ2V0TGFiZWwoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKXtjb25zdCBuPWUuZ2V0TG9jYXRpb24odCk7biE9PW5lLklOVEVSSU9SJiZuIT09bmUuQk9VTkRBUll8fHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsbmUuSU5URVJJT1IpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gaGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWhpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdD1udWxsLHRoaXMuX2xhYmVsPW51bGwsdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HPTEsdGhpcy5fTElOS0lOR19UT19PVVRHT0lORz0yfTtjbGFzcyB1aSBleHRlbmRzIEtue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx1aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZU5vZGUodCl7cmV0dXJuIG5ldyBrbih0LG5ldyBoaSl9Z2V0Q2xhc3MoKXtyZXR1cm4gdWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXVpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgZ2l7Y29uc3RydWN0b3IoKXtnaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvcmllbnRhdGlvbih0KXtyZXR1cm4gMT09PVguaW5jcmVhc2luZ0RpcmVjdGlvbih0KX1zdGF0aWMgY29tcGFyZU9yaWVudGVkKHQsZSxuLHMpe2NvbnN0IGk9ZT8xOi0xLHI9cz8xOi0xLG89ZT90Lmxlbmd0aDotMSxsPXM/bi5sZW5ndGg6LTE7bGV0IGE9ZT8wOnQubGVuZ3RoLTEsYz1zPzA6bi5sZW5ndGgtMTtmb3IoOzspe2NvbnN0IGU9dFthXS5jb21wYXJlVG8obltjXSk7aWYoMCE9PWUpcmV0dXJuIGU7YSs9aSxjKz1yO2NvbnN0IHM9YT09PW8saD1jPT09bDtpZihzJiYhaClyZXR1cm4tMTtpZighcyYmaClyZXR1cm4gMTtpZihzJiZoKXJldHVybiAwfX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiBnaS5jb21wYXJlT3JpZW50ZWQodGhpcy5fcHRzLHRoaXMuX29yaWVudGF0aW9uLGUuX3B0cyxlLl9vcmllbnRhdGlvbil9Z2V0Q2xhc3MoKXtyZXR1cm4gZ2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1naS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl9vcmllbnRhdGlvbj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0cz10LHRoaXMuX29yaWVudGF0aW9uPWdpLm9yaWVudGF0aW9uKHQpfTtjbGFzcyBkaXtjb25zdHJ1Y3Rvcigpe2RpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cHJpbnQodCl7dC5wcmludChcIk1VTFRJTElORVNUUklORyAoIFwiKTtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspe2NvbnN0IG49dGhpcy5fZWRnZXMuZ2V0KGUpO2U+MCYmdC5wcmludChcIixcIiksdC5wcmludChcIihcIik7Y29uc3Qgcz1uLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTA7ZTxzLmxlbmd0aDtlKyspZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KHNbZV0ueCtcIiBcIitzW2VdLnkpO3QucHJpbnRsbihcIilcIil9dC5wcmludChcIikgIFwiKX1hZGRBbGwodCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpfWZpbmRFZGdlSW5kZXgodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlcy5zaXplKCk7ZSsrKWlmKHRoaXMuX2VkZ2VzLmdldChlKS5lcXVhbHModCkpcmV0dXJuIGU7cmV0dXJuLTF9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31nZXQodCl7cmV0dXJuIHRoaXMuX2VkZ2VzLmdldCh0KX1maW5kRXF1YWxFZGdlKHQpe2NvbnN0IGU9bmV3IGdpKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIHRoaXMuX29jYU1hcC5nZXQoZSl9YWRkKHQpe3RoaXMuX2VkZ2VzLmFkZCh0KTtjb25zdCBlPW5ldyBnaSh0LmdldENvb3JkaW5hdGVzKCkpO3RoaXMuX29jYU1hcC5wdXQoZSx0KX1nZXRDbGFzcygpe3JldHVybiBkaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZWRnZXM9bmV3IHgsdGhpcy5fb2NhTWFwPW5ldyBydH07Y2xhc3MgX2l7Y29uc3RydWN0b3IoKXtfaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe31pc0RvbmUoKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gX2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fV9pLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgZml7Y29uc3RydWN0b3IoKXtmaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc0FkamFjZW50U2VnbWVudHModCxlKXtyZXR1cm4gMT09PU1hdGguYWJzKHQtZSl9aXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2lmKHQ9PT1uJiYxPT09dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkpe2lmKGZpLmlzQWRqYWNlbnRTZWdtZW50cyhlLHMpKXJldHVybiEwO2lmKHQuaXNDbG9zZWQoKSl7Y29uc3Qgbj10LnNpemUoKS0xO2lmKDA9PT1lJiZzPT09bnx8MD09PXMmJmU9PT1uKXJldHVybiEwfX1yZXR1cm4hMX1nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpe3JldHVybiB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH1oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcn1nZXRMaW5lSW50ZXJzZWN0b3IoKXtyZXR1cm4gdGhpcy5fbGl9aGFzUHJvcGVySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3Blcn1wcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpJiYodGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnMrKyx0aGlzLl9oYXNJbnRlcmlvcj0hMCksdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl8fCh0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsdC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLHMsMSksdGhpcy5fbGkuaXNQcm9wZXIoKSYmKHRoaXMubnVtUHJvcGVySW50ZXJzZWN0aW9ucysrLHRoaXMuX2hhc1Byb3Blcj0hMCx0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKX1oYXNJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufWlzRG9uZSgpe3JldHVybiExfWhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyaW9yfWdldENsYXNzKCl7cmV0dXJuIGZpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltfaV19fWZpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9oYXNQcm9wZXI9ITEsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5faGFzSW50ZXJpb3I9ITEsdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX2lzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMubnVtSW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpPXR9O2NsYXNzIHBpe2NvbnN0cnVjdG9yKCl7cGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGVwdGhEZWx0YSh0KXtjb25zdCBlPXQuZ2V0TG9jYXRpb24oMCxQbi5MRUZUKSxuPXQuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCk7cmV0dXJuIGU9PT1uZS5JTlRFUklPUiYmbj09PW5lLkVYVEVSSU9SPzE6ZT09PW5lLkVYVEVSSU9SJiZuPT09bmUuSU5URVJJT1I/LTE6MH1zdGF0aWMgY29udmVydFNlZ1N0cmluZ3ModCl7Y29uc3QgZT1uZXcgSHQsbj1uZXcgeDtmb3IoO3QuaGFzTmV4dCgpOyl7Y29uc3Qgcz10Lm5leHQoKSxpPWUuY3JlYXRlTGluZVN0cmluZyhzLmdldENvb3JkaW5hdGVzKCkpO24uYWRkKGkpfXJldHVybiBlLmJ1aWxkR2VvbWV0cnkobil9c2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbD10fWluc2VydFVuaXF1ZUVkZ2UodCl7Y29uc3QgZT10aGlzLl9lZGdlTGlzdC5maW5kRXF1YWxFZGdlKHQpO2lmKG51bGwhPT1lKXtjb25zdCBuPWUuZ2V0TGFiZWwoKTtsZXQgcz10LmdldExhYmVsKCk7ZS5pc1BvaW50d2lzZUVxdWFsKHQpfHwocz1uZXcgRm4odC5nZXRMYWJlbCgpKSxzLmZsaXAoKSksbi5tZXJnZShzKTtjb25zdCBpPXBpLmRlcHRoRGVsdGEocykscj1lLmdldERlcHRoRGVsdGEoKStpO2Uuc2V0RGVwdGhEZWx0YShyKX1lbHNlIHRoaXMuX2VkZ2VMaXN0LmFkZCh0KSx0LnNldERlcHRoRGVsdGEocGkuZGVwdGhEZWx0YSh0LmdldExhYmVsKCkpKX1idWlsZFN1YmdyYXBocyh0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCksaT10LmdldFJpZ2h0bW9zdENvb3JkaW5hdGUoKSxyPW5ldyBvaShuKS5nZXREZXB0aChpKTt0LmNvbXB1dGVEZXB0aChyKSx0LmZpbmRSZXN1bHRFZGdlcygpLG4uYWRkKHQpLGUuYWRkKHQuZ2V0RGlyZWN0ZWRFZGdlcygpLHQuZ2V0Tm9kZXMoKSl9fWNyZWF0ZVN1YmdyYXBocyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10LmdldE5vZGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYoIXQuaXNWaXNpdGVkKCkpe2NvbnN0IG49bmV3IFFzO24uY3JlYXRlKHQpLGUuYWRkKG4pfX1yZXR1cm4gRWUuc29ydChlLEVlLnJldmVyc2VPcmRlcigpKSxlfWNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbigpfWdldE5vZGVyKHQpe2lmKG51bGwhPT10aGlzLl93b3JraW5nTm9kZXIpcmV0dXJuIHRoaXMuX3dvcmtpbmdOb2Rlcjtjb25zdCBlPW5ldyBZcyxuPW5ldyB0ZTtyZXR1cm4gbi5zZXRQcmVjaXNpb25Nb2RlbCh0KSxlLnNldFNlZ21lbnRJbnRlcnNlY3RvcihuZXcgZmkobikpLGV9YnVmZmVyKHQsZSl7bGV0IG49dGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsO251bGw9PT1uJiYobj10LmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuX2dlb21GYWN0PXQuZ2V0RmFjdG9yeSgpO2NvbnN0IHM9bmV3IHJpKG4sdGhpcy5fYnVmUGFyYW1zKSxpPW5ldyBhaSh0LGUscykuZ2V0Q3VydmVzKCk7aWYoaS5zaXplKCk8PTApcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpO3RoaXMuY29tcHV0ZU5vZGVkRWRnZXMoaSxuKSx0aGlzLl9ncmFwaD1uZXcgWm4obmV3IHVpKSx0aGlzLl9ncmFwaC5hZGRFZGdlcyh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKTtjb25zdCByPXRoaXMuY3JlYXRlU3ViZ3JhcGhzKHRoaXMuX2dyYXBoKSxvPW5ldyBlaSh0aGlzLl9nZW9tRmFjdCk7dGhpcy5idWlsZFN1YmdyYXBocyhyLG8pO2NvbnN0IGw9by5nZXRQb2x5Z29ucygpO3JldHVybiBsLnNpemUoKTw9MD90aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKTp0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KGwpfWNvbXB1dGVOb2RlZEVkZ2VzKHQsZSl7Y29uc3Qgbj10aGlzLmdldE5vZGVyKGUpO24uY29tcHV0ZU5vZGVzKHQpO2ZvcihsZXQgdD1uLmdldE5vZGVkU3Vic3RyaW5ncygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRDb29yZGluYXRlcygpO2lmKDI9PT1uLmxlbmd0aCYmblswXS5lcXVhbHMyRChuWzFdKSljb250aW51ZTtjb25zdCBzPWUuZ2V0RGF0YSgpLGk9bmV3IFVuKGUuZ2V0Q29vcmRpbmF0ZXMoKSxuZXcgRm4ocykpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZShpKX19c2V0Tm9kZXIodCl7dGhpcy5fd29ya2luZ05vZGVyPXR9Z2V0Q2xhc3MoKXtyZXR1cm4gcGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXBpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2J1ZlBhcmFtcz1udWxsLHRoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX3dvcmtpbmdOb2Rlcj1udWxsLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9lZGdlTGlzdD1uZXcgZGk7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYnVmUGFyYW1zPXR9O2NsYXNzIG1pe2NvbnN0cnVjdG9yKCl7bWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhlWzBdLHRoaXMuX3NlZ1N0cmluZ3MpLHRoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoZVtlLmxlbmd0aC0xXSx0aGlzLl9zZWdTdHJpbmdzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9YXJndW1lbnRzWzFdLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTE7ZTxuLmxlbmd0aC0xO2UrKylpZihuW2VdLmVxdWFscyh0KSl0aHJvdyBuZXcgYyhcImZvdW5kIGVuZHB0L2ludGVyaW9yIHB0IGludGVyc2VjdGlvbiBhdCBpbmRleCBcIitlK1wiIDpwdCBcIit0KX19fWNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7Zm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7dGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyhlLG4pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxzPWUuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGk9MDtpPG4ubGVuZ3RoLTE7aSsrKWZvcihsZXQgbj0wO248cy5sZW5ndGgtMTtuKyspdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGksZSxuKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO2lmKHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLl9saS5pc1Byb3BlcigpfHx0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMuX2xpLGkscil8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5fbGksbyxsKSkpdGhyb3cgbmV3IGMoXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGF0IFwiK2krXCItXCIrcitcIiBhbmQgXCIrbytcIi1cIitsKX19Y2hlY2tWYWxpZCgpe3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0NvbGxhcHNlcygpfWNoZWNrQ29sbGFwc2VzKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5jaGVja0NvbGxhcHNlcyhlKX1lbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMjtlKyspdGhpcy5jaGVja0NvbGxhcHNlKHRbZV0sdFtlKzFdLHRbZSsyXSl9fWhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7cysrKXtjb25zdCBpPXQuZ2V0SW50ZXJzZWN0aW9uKHMpO2lmKCFpLmVxdWFscyhlKSYmIWkuZXF1YWxzKG4pKXJldHVybiEwfXJldHVybiExfWNoZWNrQ29sbGFwc2UodCxlLG4pe2lmKHQuZXF1YWxzKG4pKXRocm93IG5ldyBjKFwiZm91bmQgbm9uLW5vZGVkIGNvbGxhcHNlIGF0IFwiK21pLmZhY3QuY3JlYXRlTGluZVN0cmluZyhbdCxlLG5dKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gbWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW1pLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW5ldyB0ZSx0aGlzLl9zZWdTdHJpbmdzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2VnU3RyaW5ncz10fSxtaS5mYWN0PW5ldyBIdDtjbGFzcyB5aXtjb25zdHJ1Y3Rvcigpe3lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW50ZXJzZWN0c1NjYWxlZCh0LGUpe2NvbnN0IG49TWF0aC5taW4odC54LGUueCkscz1NYXRoLm1heCh0LngsZS54KSxpPU1hdGgubWluKHQueSxlLnkpLHI9TWF0aC5tYXgodC55LGUueSksbz10aGlzLl9tYXh4PG58fHRoaXMuX21pbng+c3x8dGhpcy5fbWF4eTxpfHx0aGlzLl9taW55PnI7aWYobylyZXR1cm4hMTtjb25zdCBsPXRoaXMuaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSh0LGUpO3JldHVybiB1LmlzVHJ1ZSghKG8mJmwpLFwiRm91bmQgYmFkIGVudmVsb3BlIHRlc3RcIiksbH1pbml0Q29ybmVycyh0KXt0aGlzLl9taW54PXQueC0uNSx0aGlzLl9tYXh4PXQueCsuNSx0aGlzLl9taW55PXQueS0uNSx0aGlzLl9tYXh5PXQueSsuNSx0aGlzLl9jb3JuZXJbMF09bmV3IGcodGhpcy5fbWF4eCx0aGlzLl9tYXh5KSx0aGlzLl9jb3JuZXJbMV09bmV3IGcodGhpcy5fbWlueCx0aGlzLl9tYXh5KSx0aGlzLl9jb3JuZXJbMl09bmV3IGcodGhpcy5fbWlueCx0aGlzLl9taW55KSx0aGlzLl9jb3JuZXJbM109bmV3IGcodGhpcy5fbWF4eCx0aGlzLl9taW55KX1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuIDE9PT10aGlzLl9zY2FsZUZhY3Rvcj90aGlzLmludGVyc2VjdHNTY2FsZWQodCxlKToodGhpcy5jb3B5U2NhbGVkKHQsdGhpcy5fcDBTY2FsZWQpLHRoaXMuY29weVNjYWxlZChlLHRoaXMuX3AxU2NhbGVkKSx0aGlzLmludGVyc2VjdHNTY2FsZWQodGhpcy5fcDBTY2FsZWQsdGhpcy5fcDFTY2FsZWQpKX1zY2FsZSh0KXtyZXR1cm4gTWF0aC5yb3VuZCh0KnRoaXMuX3NjYWxlRmFjdG9yKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX29yaWdpbmFsUHR9Y29weVNjYWxlZCh0LGUpe2UueD10aGlzLnNjYWxlKHQueCksZS55PXRoaXMuc2NhbGUodC55KX1nZXRTYWZlRW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fc2FmZUVudil7Y29uc3QgdD15aS5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SL3RoaXMuX3NjYWxlRmFjdG9yO3RoaXMuX3NhZmVFbnY9bmV3IE4odGhpcy5fb3JpZ2luYWxQdC54LXQsdGhpcy5fb3JpZ2luYWxQdC54K3QsdGhpcy5fb3JpZ2luYWxQdC55LXQsdGhpcy5fb3JpZ2luYWxQdC55K3QpfXJldHVybiB0aGlzLl9zYWZlRW52fWludGVyc2VjdHNQaXhlbENsb3N1cmUodCxlKXtyZXR1cm4gdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzBdLHRoaXMuX2Nvcm5lclsxXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsxXSx0aGlzLl9jb3JuZXJbMl0pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMl0sdGhpcy5fY29ybmVyWzNdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzNdLHRoaXMuX2Nvcm5lclswXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkpKX1pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlKHQsZSl7bGV0IG49ITEscz0hMTtyZXR1cm4gdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzBdLHRoaXMuX2Nvcm5lclsxXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzFdLHRoaXMuX2Nvcm5lclsyXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJihuPSEwKSx0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMl0sdGhpcy5fY29ybmVyWzNdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHM9ITApLHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclszXSx0aGlzLl9jb3JuZXJbMF0pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KCEoIW58fCFzKXx8KCEhdC5lcXVhbHModGhpcy5fcHQpfHwhIWUuZXF1YWxzKHRoaXMuX3B0KSkpKSkpfWFkZFNuYXBwZWROb2RlKHQsZSl7Y29uc3Qgbj10LmdldENvb3JkaW5hdGUoZSkscz10LmdldENvb3JkaW5hdGUoZSsxKTtyZXR1cm4hIXRoaXMuaW50ZXJzZWN0cyhuLHMpJiYodC5hZGRJbnRlcnNlY3Rpb24odGhpcy5nZXRDb29yZGluYXRlKCksZSksITApfWdldENsYXNzKCl7cmV0dXJuIHlpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX15aS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saT1udWxsLHRoaXMuX3B0PW51bGwsdGhpcy5fb3JpZ2luYWxQdD1udWxsLHRoaXMuX3B0U2NhbGVkPW51bGwsdGhpcy5fcDBTY2FsZWQ9bnVsbCx0aGlzLl9wMVNjYWxlZD1udWxsLHRoaXMuX3NjYWxlRmFjdG9yPW51bGwsdGhpcy5fbWlueD1udWxsLHRoaXMuX21heHg9bnVsbCx0aGlzLl9taW55PW51bGwsdGhpcy5fbWF4eT1udWxsLHRoaXMuX2Nvcm5lcj1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0aGlzLl9zYWZlRW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07aWYodGhpcy5fb3JpZ2luYWxQdD10LHRoaXMuX3B0PXQsdGhpcy5fc2NhbGVGYWN0b3I9ZSx0aGlzLl9saT1zLGU8PTApdGhyb3cgbmV3IG4oXCJTY2FsZSBmYWN0b3IgbXVzdCBiZSBub24temVyb1wiKTsxIT09ZSYmKHRoaXMuX3B0PW5ldyBnKHRoaXMuc2NhbGUodC54KSx0aGlzLnNjYWxlKHQueSkpLHRoaXMuX3AwU2NhbGVkPW5ldyBnLHRoaXMuX3AxU2NhbGVkPW5ldyBnKSx0aGlzLmluaXRDb3JuZXJzKHRoaXMuX3B0KX0seWkuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUj0uNzU7Y2xhc3MgeGl7Y29uc3RydWN0b3IoKXt4aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNlbGVjdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0LmdldExpbmVTZWdtZW50KGUsdGhpcy5zZWxlY3RlZFNlZ21lbnQpLHRoaXMuc2VsZWN0KHRoaXMuc2VsZWN0ZWRTZWdtZW50KX19Z2V0Q2xhc3MoKXtyZXR1cm4geGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXhpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuc2VsZWN0ZWRTZWdtZW50PW5ldyBlZX07Y2xhc3MgRWl7Y29uc3RydWN0b3IoKXtFaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNuYXAoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc25hcCh0LG51bGwsLTEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPXQuZ2V0U2FmZUVudmVsb3BlKCksaT1uZXcgSWkodCxlLG4pO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeShzLG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQWVdfXZpc2l0SXRlbSh0KXt0LnNlbGVjdChzLGkpfX0pLGkuaXNOb2RlQWRkZWQoKX19Z2V0Q2xhc3MoKXtyZXR1cm4gRWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIElpIGV4dGVuZHMgeGl7Y29uc3RydWN0b3IoKXtzdXBlcigpLElpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNOb2RlQWRkZWQoKXtyZXR1cm4gdGhpcy5faXNOb2RlQWRkZWR9c2VsZWN0KCl7aWYoISgyPT09YXJndW1lbnRzLmxlbmd0aCYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHFzKSlyZXR1cm4gc3VwZXIuc2VsZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldENvbnRleHQoKTtpZihudWxsIT09dGhpcy5fcGFyZW50RWRnZSYmbj09PXRoaXMuX3BhcmVudEVkZ2UmJmU9PT10aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4KXJldHVybiBudWxsO3RoaXMuX2lzTm9kZUFkZGVkPXRoaXMuX2hvdFBpeGVsLmFkZFNuYXBwZWROb2RlKG4sZSl9fWdldENsYXNzKCl7cmV0dXJuIElpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1JaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ob3RQaXhlbD1udWxsLHRoaXMuX3BhcmVudEVkZ2U9bnVsbCx0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4PW51bGwsdGhpcy5faXNOb2RlQWRkZWQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5faG90UGl4ZWw9dCx0aGlzLl9wYXJlbnRFZGdlPWUsdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleD1ufSxFaS5Ib3RQaXhlbFNuYXBBY3Rpb249SWksRWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbmRleD10fTtjbGFzcyBOaXtjb25zdHJ1Y3Rvcigpe05pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTtpZih0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkpe2ZvcihsZXQgdD0wO3Q8dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7dCsrKXRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucy5hZGQodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKHQpKTt0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKX19aXNEb25lKCl7cmV0dXJuITF9Z2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7cmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uc31nZXRDbGFzcygpe3JldHVybiBOaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bX2ldfX1OaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saT1udWxsLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpPXQsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zPW5ldyB4fTtjbGFzcyBDaXtjb25zdHJ1Y3Rvcigpe0NpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2hlY2tDb3JyZWN0bmVzcyh0KXtjb25zdCBlPUZzLmdldE5vZGVkU3Vic3RyaW5ncyh0KSxuPW5ldyBtaShlKTt0cnl7bi5jaGVja1ZhbGlkKCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgQykpdGhyb3cgdDt0LnByaW50U3RhY2tUcmFjZSgpfX1nZXROb2RlZFN1YnN0cmluZ3MoKXtyZXR1cm4gRnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMuX25vZGVkU2VnU3RyaW5ncyl9c25hcFJvdW5kKHQsZSl7Y29uc3Qgbj10aGlzLmZpbmRJbnRlcmlvckludGVyc2VjdGlvbnModCxlKTt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyhuKSx0aGlzLmNvbXB1dGVWZXJ0ZXhTbmFwcyh0KX1maW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHQsZSl7Y29uc3Qgbj1uZXcgTmkoZSk7cmV0dXJuIHRoaXMuX25vZGVyLnNldFNlZ21lbnRJbnRlcnNlY3RvcihuKSx0aGlzLl9ub2Rlci5jb21wdXRlTm9kZXModCksbi5nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKX1jb21wdXRlVmVydGV4U25hcHMoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmNvbXB1dGVWZXJ0ZXhTbmFwcyhlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7Y29uc3Qgcz1uZXcgeWkoZVtuXSx0aGlzLl9zY2FsZUZhY3Rvcix0aGlzLl9saSk7dGhpcy5fcG9pbnRTbmFwcGVyLnNuYXAocyx0LG4pJiZ0LmFkZEludGVyc2VjdGlvbihlW25dLG4pfX19Y29tcHV0ZU5vZGVzKHQpe3RoaXMuX25vZGVkU2VnU3RyaW5ncz10LHRoaXMuX25vZGVyPW5ldyBZcyx0aGlzLl9wb2ludFNuYXBwZXI9bmV3IEVpKHRoaXMuX25vZGVyLmdldEluZGV4KCkpLHRoaXMuc25hcFJvdW5kKHQsdGhpcy5fbGkpfWNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPW5ldyB5aSh0LHRoaXMuX3NjYWxlRmFjdG9yLHRoaXMuX2xpKTt0aGlzLl9wb2ludFNuYXBwZXIuc25hcChuKX19Z2V0Q2xhc3MoKXtyZXR1cm4gQ2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1ZzXX19Q2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcG09bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX3NjYWxlRmFjdG9yPW51bGwsdGhpcy5fbm9kZXI9bnVsbCx0aGlzLl9wb2ludFNuYXBwZXI9bnVsbCx0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wbT10LHRoaXMuX2xpPW5ldyB0ZSx0aGlzLl9saS5zZXRQcmVjaXNpb25Nb2RlbCh0KSx0aGlzLl9zY2FsZUZhY3Rvcj10LmdldFNjYWxlKCl9O2NsYXNzIFNpe2NvbnN0cnVjdG9yKCl7U2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgYnVmZmVyT3AoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBTaSh0KS5nZXRSZXN1bHRHZW9tZXRyeShlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IFNpKHQpO3JldHVybiBzLnNldFF1YWRyYW50U2VnbWVudHMobikscy5nZXRSZXN1bHRHZW9tZXRyeShlKX1pZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIGpzJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuZXcgU2kodCxuKS5nZXRSZXN1bHRHZW9tZXRyeShlKX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgU2kodCk7cmV0dXJuIGkuc2V0UXVhZHJhbnRTZWdtZW50cyhuKSxpLnNldEVuZENhcFN0eWxlKHMpLGkuZ2V0UmVzdWx0R2VvbWV0cnkoZSl9fXN0YXRpYyBwcmVjaXNpb25TY2FsZUZhY3Rvcih0LGUsbil7Y29uc3Qgcz10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxpPU0ubWF4KE1hdGguYWJzKHMuZ2V0TWF4WCgpKSxNYXRoLmFicyhzLmdldE1heFkoKSksTWF0aC5hYnMocy5nZXRNaW5YKCkpLE1hdGguYWJzKHMuZ2V0TWluWSgpKSkrMiooZT4wP2U6MCkscj1uLU1hdGgudHJ1bmMoTWF0aC5sb2coaSkvTWF0aC5sb2coMTApKzEpO3JldHVybiBNYXRoLnBvdygxMCxyKX1idWZmZXJGaXhlZFByZWNpc2lvbih0KXtjb25zdCBlPW5ldyBrcyhuZXcgQ2kobmV3IGt0KDEpKSx0LmdldFNjYWxlKCkpLG49bmV3IHBpKHRoaXMuX2J1ZlBhcmFtcyk7bi5zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwodCksbi5zZXROb2RlcihlKSx0aGlzLl9yZXN1bHRHZW9tZXRyeT1uLmJ1ZmZlcih0aGlzLl9hcmdHZW9tLHRoaXMuX2Rpc3RhbmNlKX1idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD1TaS5NQVhfUFJFQ0lTSU9OX0RJR0lUUzt0Pj0wO3QtLSl7dHJ5e3RoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbih0KX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBXbikpdGhyb3cgdDt0aGlzLl9zYXZlRXhjZXB0aW9uPXR9aWYobnVsbCE9PXRoaXMuX3Jlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsfXRocm93IHRoaXMuX3NhdmVFeGNlcHRpb259aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9U2kucHJlY2lzaW9uU2NhbGVGYWN0b3IodGhpcy5fYXJnR2VvbSx0aGlzLl9kaXN0YW5jZSx0KSxuPW5ldyBrdChlKTt0aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKG4pfX1jb21wdXRlR2VvbWV0cnkoKXtpZih0aGlzLmJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uKCksbnVsbCE9PXRoaXMuX3Jlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy5fYXJnR2VvbS5nZXRGYWN0b3J5KCkuZ2V0UHJlY2lzaW9uTW9kZWwoKTt0LmdldFR5cGUoKT09PWt0LkZJWEVEP3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24odCk6dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKCl9c2V0UXVhZHJhbnRTZWdtZW50cyh0KXt0aGlzLl9idWZQYXJhbXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX1idWZmZXJPcmlnaW5hbFByZWNpc2lvbigpe3RyeXtjb25zdCB0PW5ldyBwaSh0aGlzLl9idWZQYXJhbXMpO3RoaXMuX3Jlc3VsdEdlb21ldHJ5PXQuYnVmZmVyKHRoaXMuX2FyZ0dlb20sdGhpcy5fZGlzdGFuY2UpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGMpKXRocm93IHQ7dGhpcy5fc2F2ZUV4Y2VwdGlvbj10fX1nZXRSZXN1bHRHZW9tZXRyeSh0KXtyZXR1cm4gdGhpcy5fZGlzdGFuY2U9dCx0aGlzLmNvbXB1dGVHZW9tZXRyeSgpLHRoaXMuX3Jlc3VsdEdlb21ldHJ5fXNldEVuZENhcFN0eWxlKHQpe3RoaXMuX2J1ZlBhcmFtcy5zZXRFbmRDYXBTdHlsZSh0KX1nZXRDbGFzcygpe3JldHVybiBTaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19U2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fYXJnR2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5fYnVmUGFyYW1zPW5ldyBqcyx0aGlzLl9yZXN1bHRHZW9tZXRyeT1udWxsLHRoaXMuX3NhdmVFeGNlcHRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYXJnR2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2FyZ0dlb209dCx0aGlzLl9idWZQYXJhbXM9ZX19LFNpLkNBUF9ST1VORD1qcy5DQVBfUk9VTkQsU2kuQ0FQX0JVVFQ9anMuQ0FQX0ZMQVQsU2kuQ0FQX0ZMQVQ9anMuQ0FQX0ZMQVQsU2kuQ0FQX1NRVUFSRT1qcy5DQVBfU1FVQVJFLFNpLk1BWF9QUkVDSVNJT05fRElHSVRTPTEyO3ZhciB3aT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxCdWZmZXJPcDpTaSxCdWZmZXJQYXJhbWV0ZXJzOmpzfSk7Y2xhc3MgTGl7Y29uc3RydWN0b3IoKXtMaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5zaWRlQXJlYSgpe3JldHVybiB0aGlzLl9zZWdJbmRleD09PUxpLklOU0lERV9BUkVBfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9Z2V0R2VvbWV0cnlDb21wb25lbnQoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50fWdldFNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLl9zZWdJbmRleH1nZXRDbGFzcygpe3JldHVybiBMaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fY29tcG9uZW50PW51bGwsdGhpcy5fc2VnSW5kZXg9bnVsbCx0aGlzLl9wdD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtMaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsTGkuSU5TSURFX0FSRUEsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fY29tcG9uZW50PXQsdGhpcy5fc2VnSW5kZXg9ZSx0aGlzLl9wdD1ufX0sTGkuSU5TSURFX0FSRUE9LTE7Y2xhc3MgVGl7Y29uc3RydWN0b3IoKXtUaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRMb2NhdGlvbnModCl7Y29uc3QgZT1uZXcgeDtyZXR1cm4gdC5hcHBseShuZXcgVGkoZSkpLGV9ZmlsdGVyKHQpeyh0IGluc3RhbmNlb2YgUHR8fHQgaW5zdGFuY2VvZiBUdHx8dCBpbnN0YW5jZW9mIGJ0KSYmdGhpcy5fbG9jYXRpb25zLmFkZChuZXcgTGkodCwwLHQuZ2V0Q29vcmRpbmF0ZSgpKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gVGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2d0XX19VGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbG9jYXRpb25zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbG9jYXRpb25zPXR9O2NsYXNzIFJpe2NvbnN0cnVjdG9yKCl7UmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGlzdGFuY2UodCxlKXtyZXR1cm4gbmV3IFJpKHQsZSkuZGlzdGFuY2UoKX1zdGF0aWMgaXNXaXRoaW5EaXN0YW5jZSh0LGUsbil7cmV0dXJuISh0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+bikmJm5ldyBSaSh0LGUsbikuZGlzdGFuY2UoKTw9bn1zdGF0aWMgbmVhcmVzdFBvaW50cyh0LGUpe3JldHVybiBuZXcgUmkodCxlKS5uZWFyZXN0UG9pbnRzKCl9Y29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDAsdCksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMSx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX2dlb21bdF07aWYobi5nZXREaW1lbnNpb24oKTwyKXJldHVybiBudWxsO2NvbnN0IHM9MS10LGk9TmUuZ2V0UG9seWdvbnMobik7aWYoaS5zaXplKCk+MCl7Y29uc3Qgbj1UaS5nZXRMb2NhdGlvbnModGhpcy5fZ2VvbVtzXSk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShuLGksZSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW3NdPWVbMF0sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblt0XT1lWzFdLG51bGx9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmXyhhcmd1bWVudHNbMF0sbSkmJl8oYXJndW1lbnRzWzFdLG0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKylpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKGksZS5nZXQodCksbiksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTGkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgYnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9dC5nZXRDb29yZGluYXRlKCk7aWYobmUuRVhURVJJT1IhPT10aGlzLl9wdExvY2F0b3IubG9jYXRlKHMsZSkpcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlPTAsblswXT10LG5bMV09bmV3IExpKGUscyksbnVsbH19Y29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPWUuZ2V0KHQpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKGkscyxuKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX1jb21wdXRlRmFjZXREaXN0YW5jZSgpe2NvbnN0IHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksZT14ZS5nZXRMaW5lcyh0aGlzLl9nZW9tWzBdKSxuPXhlLmdldExpbmVzKHRoaXMuX2dlb21bMV0pLHM9SWUuZ2V0UG9pbnRzKHRoaXMuX2dlb21bMF0pLGk9SWUuZ2V0UG9pbnRzKHRoaXMuX2dlb21bMV0pO3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzKGUsbix0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMoZSxpLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhuLHMsdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCEwKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyhzLGksdCksdm9pZCB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpKSkpfW5lYXJlc3RMb2NhdGlvbnMoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9ufXVwZGF0ZU1pbkRpc3RhbmNlKHQsZSl7aWYobnVsbD09PXRbMF0pcmV0dXJuIG51bGw7ZT8odGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXT10WzFdLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV09dFswXSk6KHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF09dFswXSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMV0pfW5lYXJlc3RQb2ludHMoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKSxbdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXS5nZXRDb29yZGluYXRlKCksdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXS5nZXRDb29yZGluYXRlKCldfWNvbXB1dGVNaW5EaXN0YW5jZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihudWxsIT09dGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbilyZXR1cm4gbnVsbDtpZih0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlRmFjZXREaXN0YW5jZSgpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBQdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMuX21pbkRpc3RhbmNlKXJldHVybiBudWxsO2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRDb29yZGluYXRlKCk7Zm9yKGxldCByPTA7cjxzLmxlbmd0aC0xO3IrKyl7Y29uc3Qgbz1ELnBvaW50VG9TZWdtZW50KGksc1tyXSxzW3IrMV0pO2lmKG88dGhpcy5fbWluRGlzdGFuY2Upe3RoaXMuX21pbkRpc3RhbmNlPW87Y29uc3QgbD1uZXcgZWUoc1tyXSxzW3IrMV0pLmNsb3Nlc3RQb2ludChpKTtuWzBdPW5ldyBMaSh0LHIsbCksblsxXT1uZXcgTGkoZSwwLGkpfWlmKHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFR0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5fbWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCByPTA7cjxzLmxlbmd0aC0xO3IrKylmb3IobGV0IG89MDtvPGkubGVuZ3RoLTE7bysrKXtjb25zdCBsPUQuc2VnbWVudFRvU2VnbWVudChzW3JdLHNbcisxXSxpW29dLGlbbysxXSk7aWYobDx0aGlzLl9taW5EaXN0YW5jZSl7dGhpcy5fbWluRGlzdGFuY2U9bDtjb25zdCBhPW5ldyBlZShzW3JdLHNbcisxXSksYz1uZXcgZWUoaVtvXSxpW28rMV0pLGg9YS5jbG9zZXN0UG9pbnRzKGMpO25bMF09bmV3IExpKHQscixoWzBdKSxuWzFdPW5ldyBMaShlLG8saFsxXSl9aWYodGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19Y29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz1lLmdldCh0KSxyPWkuZ2V0Q29vcmRpbmF0ZSgpLmRpc3RhbmNlKHMuZ2V0Q29vcmRpbmF0ZSgpKTtpZihyPHRoaXMuX21pbkRpc3RhbmNlJiYodGhpcy5fbWluRGlzdGFuY2U9cixuWzBdPW5ldyBMaShpLDAsaS5nZXRDb29yZGluYXRlKCkpLG5bMV09bmV3IExpKHMsMCxzLmdldENvb3JkaW5hdGUoKSkpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fWRpc3RhbmNlKCl7aWYobnVsbD09PXRoaXMuX2dlb21bMF18fG51bGw9PT10aGlzLl9nZW9tWzFdKXRocm93IG5ldyBuKFwibnVsbCBnZW9tZXRyaWVzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiB0aGlzLl9nZW9tWzBdLmlzRW1wdHkoKXx8dGhpcy5fZ2VvbVsxXS5pc0VtcHR5KCk/MDoodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKSx0aGlzLl9taW5EaXN0YW5jZSl9Y29tcHV0ZU1pbkRpc3RhbmNlTGluZXModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPWUuZ2V0KHQpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKGkscyxuKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX1nZXRDbGFzcygpe3JldHVybiBSaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZ2VvbT1udWxsLHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlPTAsdGhpcy5fcHRMb2NhdG9yPW5ldyBfbix0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uPW51bGwsdGhpcy5fbWluRGlzdGFuY2U9aS5NQVhfVkFMVUUsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1JpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLDApfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2dlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fZ2VvbVswXT10LHRoaXMuX2dlb21bMV09ZSx0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT1ufX07dmFyIFBpPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERpc3RhbmNlT3A6Uml9KTtjbGFzcyB2aXtjb25zdHJ1Y3Rvcigpe3ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZXMoKXtpZihudWxsPT09dGhpcy5fY29vcmRpbmF0ZXMpe2xldCB0PTAsZT0wO2NvbnN0IG49bmV3IEk7Zm9yKGxldCBzPXRoaXMuX2RpcmVjdGVkRWRnZXMuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGk9cy5uZXh0KCk7aS5nZXRFZGdlRGlyZWN0aW9uKCk/dCsrOmUrKyxuLmFkZChpLmdldEVkZ2UoKS5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSwhMSxpLmdldEVkZ2VEaXJlY3Rpb24oKSl9dGhpcy5fY29vcmRpbmF0ZXM9bi50b0Nvb3JkaW5hdGVBcnJheSgpLGU+dCYmWC5yZXZlcnNlKHRoaXMuX2Nvb3JkaW5hdGVzKX1yZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXN9dG9MaW5lU3RyaW5nKCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpfWFkZCh0KXt0aGlzLl9kaXJlY3RlZEVkZ2VzLmFkZCh0KX1nZXRDbGFzcygpe3JldHVybiB2aX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2RpcmVjdGVkRWRnZXM9bmV3IHgsdGhpcy5fY29vcmRpbmF0ZXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9O2NsYXNzIE9pe2NvbnN0cnVjdG9yKCl7T2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0Q29tcG9uZW50V2l0aFZpc2l0ZWRTdGF0ZSh0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO2lmKG4uaXNWaXNpdGVkKCk9PT1lKXJldHVybiBufXJldHVybiBudWxsfXN0YXRpYyBzZXRWaXNpdGVkKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3QubmV4dCgpLnNldFZpc2l0ZWQoZSl9fXN0YXRpYyBzZXRNYXJrZWQodCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0TWFya2VkKGUpfX1zZXRWaXNpdGVkKHQpe3RoaXMuX2lzVmlzaXRlZD10fWlzTWFya2VkKCl7cmV0dXJuIHRoaXMuX2lzTWFya2VkfXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1zZXRNYXJrZWQodCl7dGhpcy5faXNNYXJrZWQ9dH1nZXRDb250ZXh0KCl7cmV0dXJuIHRoaXMuX2RhdGF9aXNWaXNpdGVkKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH1zZXRDb250ZXh0KHQpe3RoaXMuX2RhdGE9dH1nZXRDbGFzcygpe3JldHVybiBPaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19T2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNNYXJrZWQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLHRoaXMuX2RhdGE9bnVsbH07Y2xhc3MgYmkgZXh0ZW5kcyBPaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksYmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9FZGdlcyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUuYWRkKG4ubmV4dCgpLl9wYXJlbnRFZGdlKTtyZXR1cm4gZX1pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3BhcmVudEVkZ2V9Y29tcGFyZURpcmVjdGlvbih0KXtyZXR1cm4gdGhpcy5fcXVhZHJhbnQ+dC5fcXVhZHJhbnQ/MTp0aGlzLl9xdWFkcmFudDx0Ll9xdWFkcmFudD8tMTp2LmluZGV4KHQuX3AwLHQuX3AxLHRoaXMuX3AxKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Zyb20uZ2V0Q29vcmRpbmF0ZSgpfXByaW50KHQpe2NvbnN0IGU9dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxuPWUubGFzdEluZGV4T2YoXCIuXCIpLHM9ZS5zdWJzdHJpbmcobisxKTt0LnByaW50KFwiICBcIitzK1wiOiBcIit0aGlzLl9wMCtcIiAtIFwiK3RoaXMuX3AxK1wiIFwiK3RoaXMuX3F1YWRyYW50K1wiOlwiK3RoaXMuX2FuZ2xlKX1nZXREaXJlY3Rpb25QdCgpe3JldHVybiB0aGlzLl9wMX1nZXRBbmdsZSgpe3JldHVybiB0aGlzLl9hbmdsZX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9Z2V0RnJvbU5vZGUoKXtyZXR1cm4gdGhpcy5fZnJvbX1nZXRTeW0oKXtyZXR1cm4gdGhpcy5fc3ltfXNldEVkZ2UodCl7dGhpcy5fcGFyZW50RWRnZT10fXJlbW92ZSgpe3RoaXMuX3N5bT1udWxsLHRoaXMuX3BhcmVudEVkZ2U9bnVsbH1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX3BhcmVudEVkZ2V9Z2V0UXVhZHJhbnQoKXtyZXR1cm4gdGhpcy5fcXVhZHJhbnR9c2V0U3ltKHQpe3RoaXMuX3N5bT10fWdldFRvTm9kZSgpe3JldHVybiB0aGlzLl90b31nZXRFZGdlRGlyZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2VkZ2VEaXJlY3Rpb259Z2V0Q2xhc3MoKXtyZXR1cm4gYml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1iaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wYXJlbnRFZGdlPW51bGwsdGhpcy5fZnJvbT1udWxsLHRoaXMuX3RvPW51bGwsdGhpcy5fcDA9bnVsbCx0aGlzLl9wMT1udWxsLHRoaXMuX3N5bT1udWxsLHRoaXMuX2VkZ2VEaXJlY3Rpb249bnVsbCx0aGlzLl9xdWFkcmFudD1udWxsLHRoaXMuX2FuZ2xlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX2Zyb209dCx0aGlzLl90bz1lLHRoaXMuX2VkZ2VEaXJlY3Rpb249cyx0aGlzLl9wMD10LmdldENvb3JkaW5hdGUoKSx0aGlzLl9wMT1uO2NvbnN0IGk9dGhpcy5fcDEueC10aGlzLl9wMC54LHI9dGhpcy5fcDEueS10aGlzLl9wMC55O3RoaXMuX3F1YWRyYW50PUluLnF1YWRyYW50KGksciksdGhpcy5fYW5nbGU9TWF0aC5hdGFuMihyLGkpfX07Y2xhc3MgTWkgZXh0ZW5kcyBiaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXROZXh0KCl7cmV0dXJuIDIhPT10aGlzLmdldFRvTm9kZSgpLmdldERlZ3JlZSgpP251bGw6dGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApPT09dGhpcy5nZXRTeW0oKT90aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMSk6KHUuaXNUcnVlKHRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKT09PXRoaXMuZ2V0U3ltKCkpLHRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgwKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gTWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU1pLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2JpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4scyl9O2NsYXNzIERpIGV4dGVuZHMgT2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLERpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNSZW1vdmVkKCl7cmV0dXJuIG51bGw9PT10aGlzLl9kaXJFZGdlfXNldERpcmVjdGVkRWRnZXModCxlKXt0aGlzLl9kaXJFZGdlPVt0LGVdLHQuc2V0RWRnZSh0aGlzKSxlLnNldEVkZ2UodGhpcyksdC5zZXRTeW0oZSksZS5zZXRTeW0odCksdC5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UodCksZS5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UoZSl9Z2V0RGlyRWRnZSgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RpckVkZ2VbdF19aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVswXTp0aGlzLl9kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMV06bnVsbH19cmVtb3ZlKCl7dGhpcy5fZGlyRWRnZT1udWxsfWdldE9wcG9zaXRlTm9kZSh0KXtyZXR1cm4gdGhpcy5fZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzBdLmdldFRvTm9kZSgpOnRoaXMuX2RpckVkZ2VbMV0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVsxXS5nZXRUb05vZGUoKTpudWxsfWdldENsYXNzKCl7cmV0dXJuIERpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1EaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9kaXJFZGdlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc2V0RGlyZWN0ZWRFZGdlcyh0LGUpfX07Y2xhc3MgQWl7Y29uc3RydWN0b3IoKXtBaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE5leHRFZGdlKHQpe2NvbnN0IGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5fb3V0RWRnZXMuZ2V0KHRoaXMuZ2V0SW5kZXgoZSsxKSl9Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9dGhpcy5pdGVyYXRvcigpO3JldHVybiB0Lmhhc05leHQoKT90Lm5leHQoKS5nZXRDb29yZGluYXRlKCk6bnVsbH1pdGVyYXRvcigpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMuX291dEVkZ2VzLml0ZXJhdG9yKCl9c29ydEVkZ2VzKCl7dGhpcy5fc29ydGVkfHwoRWUuc29ydCh0aGlzLl9vdXRFZGdlcyksdGhpcy5fc29ydGVkPSEwKX1yZW1vdmUodCl7dGhpcy5fb3V0RWRnZXMucmVtb3ZlKHQpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuc29ydEVkZ2VzKCksdGhpcy5fb3V0RWRnZXN9Z2V0TmV4dENXRWRnZSh0KXtjb25zdCBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMuX291dEVkZ2VzLmdldCh0aGlzLmdldEluZGV4KGUtMSkpfWdldEluZGV4KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX291dEVkZ2VzLnNpemUoKTtlKyspe2lmKHRoaXMuX291dEVkZ2VzLmdldChlKS5nZXRFZGdlKCk9PT10KXJldHVybiBlfXJldHVybi0xfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc29ydEVkZ2VzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9vdXRFZGdlcy5zaXplKCk7ZSsrKXtpZih0aGlzLl9vdXRFZGdlcy5nZXQoZSk9PT10KXJldHVybiBlfXJldHVybi0xfWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7bGV0IHQ9YXJndW1lbnRzWzBdJXRoaXMuX291dEVkZ2VzLnNpemUoKTtyZXR1cm4gdDwwJiYodCs9dGhpcy5fb3V0RWRnZXMuc2l6ZSgpKSx0fX1hZGQodCl7dGhpcy5fb3V0RWRnZXMuYWRkKHQpLHRoaXMuX3NvcnRlZD0hMX1nZXREZWdyZWUoKXtyZXR1cm4gdGhpcy5fb3V0RWRnZXMuc2l6ZSgpfWdldENsYXNzKCl7cmV0dXJuIEFpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1BaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9vdXRFZGdlcz1uZXcgeCx0aGlzLl9zb3J0ZWQ9ITF9O2NsYXNzIEZpIGV4dGVuZHMgT2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLEZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldEVkZ2VzQmV0d2Vlbih0LGUpe2NvbnN0IG49bmV3IEooYmkudG9FZGdlcyh0LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSkpLHM9YmkudG9FZGdlcyhlLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSk7cmV0dXJuIG4ucmV0YWluQWxsKHMpLG59aXNSZW1vdmVkKCl7cmV0dXJuIG51bGw9PT10aGlzLl9wdH1hZGRPdXRFZGdlKHQpe3RoaXMuX2RlU3Rhci5hZGQodCl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wdH1nZXRPdXRFZGdlcygpe3JldHVybiB0aGlzLl9kZVN0YXJ9cmVtb3ZlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fcHQ9bnVsbDtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9kZVN0YXIucmVtb3ZlKHQpfX1nZXRJbmRleCh0KXtyZXR1cm4gdGhpcy5fZGVTdGFyLmdldEluZGV4KHQpfWdldERlZ3JlZSgpe3JldHVybiB0aGlzLl9kZVN0YXIuZ2V0RGVncmVlKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gRml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUZpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3B0PW51bGwsdGhpcy5fZGVTdGFyPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0ZpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxuZXcgQWkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0PXQsdGhpcy5fZGVTdGFyPWV9fTtjbGFzcyBHaSBleHRlbmRzIERpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxHaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldExpbmUoKXtyZXR1cm4gdGhpcy5fbGluZX1nZXRDbGFzcygpe3JldHVybiBHaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19R2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmU9dH07Y2xhc3MgcWl7Y29uc3RydWN0b3IoKXtxaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmQodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuZ2V0KHQpfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX1yZW1vdmUodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAucmVtb3ZlKHQpfXZhbHVlcygpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpfWFkZCh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5wdXQodC5nZXRDb29yZGluYXRlKCksdCksdH1nZXRDbGFzcygpe3JldHVybiBxaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbm9kZU1hcD1uZXcgcnR9O2NsYXNzIEJpe2NvbnN0cnVjdG9yKCl7QmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5kTm9kZXNPZkRlZ3JlZSh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10aGlzLm5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzLmdldERlZ3JlZSgpPT09dCYmZS5hZGQocyl9cmV0dXJuIGV9ZGlyRWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCl9ZWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9cmVtb3ZlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDApKSx0aGlzLnJlbW92ZSh0LmdldERpckVkZ2UoMSkpLHRoaXMuX2VkZ2VzLnJlbW92ZSh0KSx0LnJlbW92ZSgpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBiaSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LmdldFN5bSgpO251bGwhPT1lJiZlLnNldFN5bShudWxsKSx0LmdldEZyb21Ob2RlKCkucmVtb3ZlKHQpLHQucmVtb3ZlKCksdGhpcy5fZGlyRWRnZXMucmVtb3ZlKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRTeW0oKTtudWxsIT09biYmdGhpcy5yZW1vdmUobiksdGhpcy5fZGlyRWRnZXMucmVtb3ZlKHQpO2NvbnN0IHM9dC5nZXRFZGdlKCk7bnVsbCE9PXMmJnRoaXMuX2VkZ2VzLnJlbW92ZShzKX10aGlzLl9ub2RlTWFwLnJlbW92ZSh0LmdldENvb3JkaW5hdGUoKSksdC5yZW1vdmUoKX19ZmluZE5vZGUodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuZmluZCh0KX1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31ub2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5pdGVyYXRvcigpfWNvbnRhaW5zKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kaXJFZGdlcy5jb250YWlucyh0KX19YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbm9kZU1hcC5hZGQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIERpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlcy5hZGQodCksdGhpcy5hZGQodC5nZXREaXJFZGdlKDApKSx0aGlzLmFkZCh0LmdldERpckVkZ2UoMSkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBiaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZGlyRWRnZXMuYWRkKHQpfX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpfWdldENsYXNzKCl7cmV0dXJuIEJpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1CaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9lZGdlcz1uZXcgSix0aGlzLl9kaXJFZGdlcz1uZXcgSix0aGlzLl9ub2RlTWFwPW5ldyBxaX07Y2xhc3MgVmkgZXh0ZW5kcyBCaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksVmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGRFZGdlKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IGU9WC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPD0xKXJldHVybiBudWxsO2NvbnN0IG49ZVswXSxzPWVbZS5sZW5ndGgtMV0saT10aGlzLmdldE5vZGUobikscj10aGlzLmdldE5vZGUocyksbz1uZXcgTWkoaSxyLGVbMV0sITApLGw9bmV3IE1pKHIsaSxlW2UubGVuZ3RoLTJdLCExKSxhPW5ldyBHaSh0KTthLnNldERpcmVjdGVkRWRnZXMobyxsKSx0aGlzLmFkZChhKX1nZXROb2RlKHQpe2xldCBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgRmkodCksdGhpcy5hZGQoZSkpLGV9Z2V0Q2xhc3MoKXtyZXR1cm4gVml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVZpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3Mgeml7Y29uc3RydWN0b3IoKXt6aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWJ1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5pc01hcmtlZCgpfHwodS5pc1RydWUoMj09PWUuZ2V0RGVncmVlKCkpLHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19YnVpbGRFZGdlU3RyaW5nc0Zvck5vbkRlZ3JlZTJOb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpOzIhPT1lLmdldERlZ3JlZSgpJiYodGhpcy5idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdChlKSxlLnNldE1hcmtlZCghMCkpfX1idWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXMoKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXMoKX1nZXRNZXJnZWRMaW5lU3RyaW5ncygpe3JldHVybiB0aGlzLm1lcmdlKCksdGhpcy5fbWVyZ2VkTGluZVN0cmluZ3N9YnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQodCl7Zm9yKGxldCBlPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmdldEVkZ2UoKS5pc01hcmtlZCgpfHx0aGlzLl9lZGdlU3RyaW5ncy5hZGQodGhpcy5idWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGgodCkpfX1tZXJnZSgpe2lmKG51bGwhPT10aGlzLl9tZXJnZWRMaW5lU3RyaW5ncylyZXR1cm4gbnVsbDtPaS5zZXRNYXJrZWQodGhpcy5fZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpLE9pLnNldE1hcmtlZCh0aGlzLl9ncmFwaC5lZGdlSXRlcmF0b3IoKSwhMSksdGhpcy5fZWRnZVN0cmluZ3M9bmV3IHgsdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXMoKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzKCksdGhpcy5fbWVyZ2VkTGluZVN0cmluZ3M9bmV3IHg7Zm9yKGxldCB0PXRoaXMuX2VkZ2VTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuX21lcmdlZExpbmVTdHJpbmdzLmFkZChlLnRvTGluZVN0cmluZygpKX19YWRkTGluZVN0cmluZyh0KXtudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHRoaXMuX2dyYXBoLmFkZEVkZ2UodCl9YnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoKHQpe2NvbnN0IGU9bmV3IHZpKHRoaXMuX2ZhY3RvcnkpO2xldCBuPXQ7ZG97ZS5hZGQobiksbi5nZXRFZGdlKCkuc2V0TWFya2VkKCEwKSxuPW4uZ2V0TmV4dCgpfXdoaWxlKG51bGwhPT1uJiZuIT09dCk7cmV0dXJuIGV9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtuIGluc3RhbmNlb2YgVHQmJnRoaXMuYWRkTGluZVN0cmluZyhuKX19ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWVyZ2VkTGluZVN0cmluZ3M9bnVsbDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmFkZCh0KX19fWJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2RlcygpfWdldENsYXNzKCl7cmV0dXJuIHppfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX16aS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ncmFwaD1uZXcgVmksdGhpcy5fbWVyZ2VkTGluZVN0cmluZ3M9bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZWRnZVN0cmluZ3M9bnVsbH07Y2xhc3MgWWl7Y29uc3RydWN0b3IoKXtZaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWRpckVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9kaXJFZGdlcy5pdGVyYXRvcigpfWVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWdldFBhcmVudCgpe3JldHVybiB0aGlzLl9wYXJlbnRHcmFwaH1ub2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5pdGVyYXRvcigpfWNvbnRhaW5zKHQpe3JldHVybiB0aGlzLl9lZGdlcy5jb250YWlucyh0KX1hZGQodCl7aWYodGhpcy5fZWRnZXMuY29udGFpbnModCkpcmV0dXJuIG51bGw7dGhpcy5fZWRnZXMuYWRkKHQpLHRoaXMuX2RpckVkZ2VzLmFkZCh0LmdldERpckVkZ2UoMCkpLHRoaXMuX2RpckVkZ2VzLmFkZCh0LmdldERpckVkZ2UoMSkpLHRoaXMuX25vZGVNYXAuYWRkKHQuZ2V0RGlyRWRnZSgwKS5nZXRGcm9tTm9kZSgpKSx0aGlzLl9ub2RlTWFwLmFkZCh0LmdldERpckVkZ2UoMSkuZ2V0RnJvbU5vZGUoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gWWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVlpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3BhcmVudEdyYXBoPW51bGwsdGhpcy5fZWRnZXM9bmV3IEosdGhpcy5fZGlyRWRnZXM9bmV3IHgsdGhpcy5fbm9kZU1hcD1uZXcgcWk7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50R3JhcGg9dH07Y2xhc3MgVWl7Y29uc3RydWN0b3IoKXtVaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZFJlYWNoYWJsZSh0LGUpe2NvbnN0IG49bmV3IG9uO2ZvcihuLmFkZCh0KTshbi5lbXB0eSgpOyl7Y29uc3QgdD1uLnBvcCgpO3RoaXMuYWRkRWRnZXModCxuLGUpfX1maW5kU3ViZ3JhcGgodCl7Y29uc3QgZT1uZXcgWWkodGhpcy5fZ3JhcGgpO3JldHVybiB0aGlzLmFkZFJlYWNoYWJsZSh0LGUpLGV9Z2V0Q29ubmVjdGVkU3ViZ3JhcGhzKCl7Y29uc3QgdD1uZXcgeDtPaS5zZXRWaXNpdGVkKHRoaXMuX2dyYXBoLm5vZGVJdGVyYXRvcigpLCExKTtmb3IobGV0IGU9dGhpcy5fZ3JhcGguZWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldERpckVkZ2UoMCkuZ2V0RnJvbU5vZGUoKTtuLmlzVmlzaXRlZCgpfHx0LmFkZCh0aGlzLmZpbmRTdWJncmFwaChuKSl9cmV0dXJuIHR9YWRkRWRnZXModCxlLG4pe3Quc2V0VmlzaXRlZCghMCk7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtuLmFkZCh0LmdldEVkZ2UoKSk7Y29uc3QgaT10LmdldFRvTm9kZSgpO2kuaXNWaXNpdGVkKCl8fGUucHVzaChpKX19Z2V0Q2xhc3MoKXtyZXR1cm4gVWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVVpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dyYXBoPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ3JhcGg9dH07Y2xhc3Mga2l7Y29uc3RydWN0b3IoKXtraS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaW5kVW52aXNpdGVkQmVzdE9yaWVudGVkREUodCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmdldEVkZ2UoKS5pc1Zpc2l0ZWQoKXx8KG49dCx0LmdldEVkZ2VEaXJlY3Rpb24oKSYmKGU9dCkpfXJldHVybiBudWxsIT09ZT9lOm59c3RhdGljIGZpbmRMb3dlc3REZWdyZWVOb2RlKHQpe2xldCBlPUwuTUFYX1ZBTFVFLG49bnVsbDtmb3IobGV0IHM9dC5ub2RlSXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7KG51bGw9PT1ufHx0LmdldERlZ3JlZSgpPGUpJiYoZT10LmdldERlZ3JlZSgpLG49dCl9cmV0dXJuIG59c3RhdGljIGlzU2VxdWVuY2VkKHQpe2lmKCEodCBpbnN0YW5jZW9mIGZ0KSlyZXR1cm4hMDtjb25zdCBlPXQsbj1uZXcgYXQ7bGV0IHM9bnVsbDtjb25zdCBpPW5ldyB4O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCByPWUuZ2V0R2VvbWV0cnlOKHQpLG89ci5nZXRDb29yZGluYXRlTigwKSxsPXIuZ2V0Q29vcmRpbmF0ZU4oci5nZXROdW1Qb2ludHMoKS0xKTtpZihuLmNvbnRhaW5zKG8pKXJldHVybiExO2lmKG4uY29udGFpbnMobCkpcmV0dXJuITE7bnVsbCE9PXMmJihvLmVxdWFscyhzKXx8KG4uYWRkQWxsKGkpLGkuY2xlYXIoKSkpLGkuYWRkKG8pLGkuYWRkKGwpLHM9bH1yZXR1cm4hMH1zdGF0aWMgcmV2ZXJzZSh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKSxuPW5ldyBBcnJheShlLmxlbmd0aCkuZmlsbChudWxsKSxzPWUubGVuZ3RoO2ZvcihsZXQgdD0wO3Q8czt0KyspbltzLTEtdF09bmV3IGcoZVt0XSk7cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcobil9c3RhdGljIHNlcXVlbmNlKHQpe2NvbnN0IGU9bmV3IGtpO3JldHVybiBlLmFkZCh0KSxlLmdldFNlcXVlbmNlZExpbmVTdHJpbmdzKCl9YWRkTGluZSh0KXtudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHRoaXMuX2dyYXBoLmFkZEVkZ2UodCksdGhpcy5fbGluZUNvdW50Kyt9aGFzU2VxdWVuY2UodCl7bGV0IGU9MDtmb3IobGV0IG49dC5ub2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLmdldERlZ3JlZSgpJTI9PTEmJmUrK31yZXR1cm4gZTw9Mn1jb21wdXRlU2VxdWVuY2UoKXtpZih0aGlzLl9pc1J1bilyZXR1cm4gbnVsbDt0aGlzLl9pc1J1bj0hMDtjb25zdCB0PXRoaXMuZmluZFNlcXVlbmNlcygpO2lmKG51bGw9PT10KXJldHVybiBudWxsO3RoaXMuX3NlcXVlbmNlZEdlb21ldHJ5PXRoaXMuYnVpbGRTZXF1ZW5jZWRHZW9tZXRyeSh0KSx0aGlzLl9pc1NlcXVlbmNlYWJsZT0hMDtjb25zdCBlPXRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5LmdldE51bUdlb21ldHJpZXMoKTt1LmlzVHJ1ZSh0aGlzLl9saW5lQ291bnQ9PT1lLFwiTGluZXMgd2VyZSBtaXNzaW5nIGZyb20gcmVzdWx0XCIpLHUuaXNUcnVlKHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5IGluc3RhbmNlb2YgVHR8fHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5IGluc3RhbmNlb2YgZnQsXCJSZXN1bHQgaXMgbm90IGxpbmVhbFwiKX1maW5kU2VxdWVuY2VzKCl7Y29uc3QgdD1uZXcgeDtmb3IobGV0IGU9bmV3IFVpKHRoaXMuX2dyYXBoKS5nZXRDb25uZWN0ZWRTdWJncmFwaHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZighdGhpcy5oYXNTZXF1ZW5jZShuKSlyZXR1cm4gbnVsbDt7Y29uc3QgZT10aGlzLmZpbmRTZXF1ZW5jZShuKTt0LmFkZChlKX19cmV0dXJuIHR9YWRkUmV2ZXJzZVN1YnBhdGgodCxlLG4pe2NvbnN0IHM9dC5nZXRUb05vZGUoKTtsZXQgaT1udWxsO2Zvcig7Oyl7ZS5hZGQodC5nZXRTeW0oKSksdC5nZXRFZGdlKCkuc2V0VmlzaXRlZCghMCksaT10LmdldEZyb21Ob2RlKCk7Y29uc3Qgbj1raS5maW5kVW52aXNpdGVkQmVzdE9yaWVudGVkREUoaSk7aWYobnVsbD09PW4pYnJlYWs7dD1uLmdldFN5bSgpfW4mJnUuaXNUcnVlKGk9PT1zLFwicGF0aCBub3QgY29udGlndW91c1wiKX1maW5kU2VxdWVuY2UodCl7T2kuc2V0VmlzaXRlZCh0LmVkZ2VJdGVyYXRvcigpLCExKTtjb25zdCBlPWtpLmZpbmRMb3dlc3REZWdyZWVOb2RlKHQpLmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0U3ltKCksbj1uZXcgWnMscz1uLmxpc3RJdGVyYXRvcigpO2Zvcih0aGlzLmFkZFJldmVyc2VTdWJwYXRoKGUscywhMSk7cy5oYXNQcmV2aW91cygpOyl7Y29uc3QgdD1zLnByZXZpb3VzKCksZT1raS5maW5kVW52aXNpdGVkQmVzdE9yaWVudGVkREUodC5nZXRGcm9tTm9kZSgpKTtudWxsIT09ZSYmdGhpcy5hZGRSZXZlcnNlU3VicGF0aChlLmdldFN5bSgpLHMsITApfXJldHVybiB0aGlzLm9yaWVudChuKX1yZXZlcnNlKHQpe2NvbnN0IGU9bmV3IFpzO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkRmlyc3QodC5nZXRTeW0oKSl9cmV0dXJuIGV9b3JpZW50KHQpe2NvbnN0IGU9dC5nZXQoMCksbj10LmdldCh0LnNpemUoKS0xKSxzPWUuZ2V0RnJvbU5vZGUoKSxpPW4uZ2V0VG9Ob2RlKCk7bGV0IHI9ITE7aWYoMT09PXMuZ2V0RGVncmVlKCl8fDE9PT1pLmdldERlZ3JlZSgpKXtsZXQgdD0hMTsxPT09bi5nZXRUb05vZGUoKS5nZXREZWdyZWUoKSYmITE9PT1uLmdldEVkZ2VEaXJlY3Rpb24oKSYmKHQ9ITAscj0hMCksMT09PWUuZ2V0RnJvbU5vZGUoKS5nZXREZWdyZWUoKSYmITA9PT1lLmdldEVkZ2VEaXJlY3Rpb24oKSYmKHQ9ITAscj0hMSksdHx8MT09PWUuZ2V0RnJvbU5vZGUoKS5nZXREZWdyZWUoKSYmKHI9ITApfXJldHVybiByP3RoaXMucmV2ZXJzZSh0KTp0fWJ1aWxkU2VxdWVuY2VkR2VvbWV0cnkodCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Zm9yKGxldCB0PW4ubmV4dCgpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRFZGdlKCkuZ2V0TGluZSgpO2xldCBpPXM7bi5nZXRFZGdlRGlyZWN0aW9uKCl8fHMuaXNDbG9zZWQoKXx8KGk9a2kucmV2ZXJzZShzKSksZS5hZGQoaSl9fXJldHVybiAwPT09ZS5zaXplKCk/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobmV3IEFycmF5KDApLmZpbGwobnVsbCkpOnRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShlKX1nZXRTZXF1ZW5jZWRMaW5lU3RyaW5ncygpe3JldHVybiB0aGlzLmNvbXB1dGVTZXF1ZW5jZSgpLHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5fWlzU2VxdWVuY2VhYmxlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVNlcXVlbmNlKCksdGhpcy5faXNTZXF1ZW5jZWFibGV9YWRkKCl7aWYoXyhhcmd1bWVudHNbMF0sZikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGQoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXthcmd1bWVudHNbMF0uYXBwbHkobmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLmFkZExpbmUodCl9fSl9fWdldENsYXNzKCl7cmV0dXJuIGtpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1raS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ncmFwaD1uZXcgVmksdGhpcy5fZmFjdG9yeT1uZXcgSHQsdGhpcy5fbGluZUNvdW50PTAsdGhpcy5faXNSdW49ITEsdGhpcy5fc2VxdWVuY2VkR2VvbWV0cnk9bnVsbCx0aGlzLl9pc1NlcXVlbmNlYWJsZT0hMX07dmFyIFhpPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLExpbmVNZXJnZXI6emksTGluZVNlcXVlbmNlcjpraX0pO2NsYXNzIEhpe2NvbnN0cnVjdG9yKCl7SGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNDbG9zZWQodCl7cmV0dXJuISh0Lmxlbmd0aDw9MSkmJnRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSl9c25hcFZlcnRpY2VzKHQsZSl7Y29uc3Qgbj10aGlzLl9pc0Nsb3NlZD90LnNpemUoKS0xOnQuc2l6ZSgpO2ZvcihsZXQgcz0wO3M8bjtzKyspe2NvbnN0IG49dC5nZXQocyksaT10aGlzLmZpbmRTbmFwRm9yVmVydGV4KG4sZSk7bnVsbCE9PWkmJih0LnNldChzLG5ldyBnKGkpKSwwPT09cyYmdGhpcy5faXNDbG9zZWQmJnQuc2V0KHQuc2l6ZSgpLTEsbmV3IGcoaSkpKX19ZmluZFNuYXBGb3JWZXJ0ZXgodCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7aWYodC5lcXVhbHMyRChlW25dKSlyZXR1cm4gbnVsbDtpZih0LmRpc3RhbmNlKGVbbl0pPHRoaXMuX3NuYXBUb2xlcmFuY2UpcmV0dXJuIGVbbl19cmV0dXJuIG51bGx9c25hcFRvKHQpe2NvbnN0IGU9bmV3IEkodGhpcy5fc3JjUHRzKTtyZXR1cm4gdGhpcy5zbmFwVmVydGljZXMoZSx0KSx0aGlzLnNuYXBTZWdtZW50cyhlLHQpLGUudG9Db29yZGluYXRlQXJyYXkoKX1zbmFwU2VnbWVudHModCxlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIG51bGw7bGV0IG49ZS5sZW5ndGg7ZVswXS5lcXVhbHMyRChlW2UubGVuZ3RoLTFdKSYmKG49ZS5sZW5ndGgtMSk7Zm9yKGxldCBzPTA7czxuO3MrKyl7Y29uc3Qgbj1lW3NdLGk9dGhpcy5maW5kU2VnbWVudEluZGV4VG9TbmFwKG4sdCk7aT49MCYmdC5hZGQoaSsxLG5ldyBnKG4pLCExKX19ZmluZFNlZ21lbnRJbmRleFRvU25hcCh0LGUpe2xldCBuPWkuTUFYX1ZBTFVFLHM9LTE7Zm9yKGxldCBpPTA7aTxlLnNpemUoKS0xO2krKyl7aWYodGhpcy5fc2VnLnAwPWUuZ2V0KGkpLHRoaXMuX3NlZy5wMT1lLmdldChpKzEpLHRoaXMuX3NlZy5wMC5lcXVhbHMyRCh0KXx8dGhpcy5fc2VnLnAxLmVxdWFsczJEKHQpKXtpZih0aGlzLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyljb250aW51ZTtyZXR1cm4tMX1jb25zdCByPXRoaXMuX3NlZy5kaXN0YW5jZSh0KTtyPHRoaXMuX3NuYXBUb2xlcmFuY2UmJnI8biYmKG49cixzPWkpfXJldHVybiBzfXNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKHQpe3RoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzPXR9Z2V0Q2xhc3MoKXtyZXR1cm4gSGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUhpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3NuYXBUb2xlcmFuY2U9MCx0aGlzLl9zcmNQdHM9bnVsbCx0aGlzLl9zZWc9bmV3IGVlLHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzPSExLHRoaXMuX2lzQ2xvc2VkPSExLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0hpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC5nZXRDb29yZGluYXRlcygpLGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fc3JjUHRzPXQsdGhpcy5faXNDbG9zZWQ9SGkuaXNDbG9zZWQodCksdGhpcy5fc25hcFRvbGVyYW5jZT1lfX07Y2xhc3MgV2l7Y29uc3RydWN0b3IoKXtXaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzbmFwKHQsZSxuKXtjb25zdCBzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLGk9bmV3IFdpKHQpO3NbMF09aS5zbmFwVG8oZSxuKTtjb25zdCByPW5ldyBXaShlKTtyZXR1cm4gc1sxXT1yLnNuYXBUbyhzWzBdLG4pLHN9c3RhdGljIGNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1XaS5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSh0KTtjb25zdCBuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKTtpZihuLmdldFR5cGUoKT09PWt0LkZJWEVEKXtjb25zdCB0PTEvbi5nZXRTY2FsZSgpKjIvMS40MTU7dD5lJiYoZT10KX1yZXR1cm4gZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIE1hdGgubWluKFdpLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSh0KSxXaS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UoZSkpfX1zdGF0aWMgY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtyZXR1cm4gTWF0aC5taW4oZS5nZXRIZWlnaHQoKSxlLmdldFdpZHRoKCkpKldpLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUn1zdGF0aWMgc25hcFRvU2VsZih0LGUsbil7cmV0dXJuIG5ldyBXaSh0KS5zbmFwVG9TZWxmKGUsbil9c25hcFRvKHQsZSl7Y29uc3Qgbj10aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0KTtyZXR1cm4gbmV3IGppKGUsbikudHJhbnNmb3JtKHRoaXMuX3NyY0dlb20pfXNuYXBUb1NlbGYodCxlKXtjb25zdCBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHRoaXMuX3NyY0dlb20pLHM9bmV3IGppKHQsbiwhMCkudHJhbnNmb3JtKHRoaXMuX3NyY0dlb20pO2xldCBpPXM7cmV0dXJuIGUmJl8oaSxPdCkmJihpPXMuYnVmZmVyKDApKSxpfWNvbXB1dGVTbmFwVG9sZXJhbmNlKHQpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCh0KS8xMH1leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgYXQsbj10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0KyspZS5hZGQoblt0XSk7cmV0dXJuIGUudG9BcnJheShuZXcgQXJyYXkoMCkuZmlsbChudWxsKSl9Y29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHQpe2xldCBlPWkuTUFYX1ZBTFVFO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspe2NvbnN0IHM9dFtuXS5kaXN0YW5jZSh0W24rMV0pO3M8ZSYmKGU9cyl9cmV0dXJuIGV9Z2V0Q2xhc3MoKXtyZXR1cm4gV2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVdpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NyY0dlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zcmNHZW9tPXR9LFdpLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUj0xZS05O2NsYXNzIGppIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLGppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c25hcExpbmUodCxlKXtjb25zdCBuPW5ldyBIaSh0LHRoaXMuX3NuYXBUb2xlcmFuY2UpO3JldHVybiBuLnNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKHRoaXMuX2lzU2VsZlNuYXApLG4uc25hcFRvKGUpfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCkscz10aGlzLnNuYXBMaW5lKG4sdGhpcy5fc25hcFB0cyk7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX1nZXRDbGFzcygpe3JldHVybiBqaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19amkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuX3NuYXBQdHM9bnVsbCx0aGlzLl9pc1NlbGZTbmFwPSExLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9zbmFwVG9sZXJhbmNlPXQsdGhpcy5fc25hcFB0cz1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3NuYXBUb2xlcmFuY2U9dCx0aGlzLl9zbmFwUHRzPWUsdGhpcy5faXNTZWxmU25hcD1ufX07dmFyIEtpPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb21ldHJ5U25hcHBlcjpXaSxMaW5lU3RyaW5nU25hcHBlcjpIaX0pO2NsYXNzIFppe2NvbnN0cnVjdG9yKCl7WmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdHN9c2l6ZSgpe3JldHVybiB0aGlzLl9wdHMubGVuZ3RofWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0c1t0XX1pc0Nsb3NlZCgpe3JldHVybiB0aGlzLl9wdHNbMF0uZXF1YWxzKHRoaXMuX3B0c1t0aGlzLl9wdHMubGVuZ3RoLTFdKX1nZXRTZWdtZW50T2N0YW50KHQpe3JldHVybiB0PT09dGhpcy5fcHRzLmxlbmd0aC0xPy0xOk1zLm9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX10b1N0cmluZygpe3JldHVybiBKdC50b0xpbmVTdHJpbmcobmV3IHp0KHRoaXMuX3B0cykpfWdldENsYXNzKCl7cmV0dXJuIFppfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltEc119fVppLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0cz1udWxsLHRoaXMuX2RhdGE9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdHM9dCx0aGlzLl9kYXRhPWV9O2NsYXNzIFFpe2NvbnN0cnVjdG9yKCl7UWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY3JlYXRlQWxsSW50ZXJzZWN0aW9uc0ZpbmRlcih0KXtjb25zdCBlPW5ldyBRaSh0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZX1zdGF0aWMgY3JlYXRlQW55SW50ZXJzZWN0aW9uRmluZGVyKHQpe3JldHVybiBuZXcgUWkodCl9c3RhdGljIGNyZWF0ZUludGVyc2VjdGlvbkNvdW50ZXIodCl7Y29uc3QgZT1uZXcgUWkodCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuc2V0S2VlcEludGVyc2VjdGlvbnMoITEpLGV9Z2V0SW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259c2V0Q2hlY2tFbmRTZWdtZW50c09ubHkodCl7dGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seT10fWdldEludGVyc2VjdGlvblNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX2ludFNlZ21lbnRzfWNvdW50KCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbkNvdW50fWdldEludGVyc2VjdGlvbnMoKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uc31zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0KXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz10fXNldEtlZXBJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2tlZXBJbnRlcnNlY3Rpb25zPXR9cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7aWYoIXRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zJiZ0aGlzLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiBudWxsO2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDtpZih0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5KXtpZighKHRoaXMuaXNFbmRTZWdtZW50KHQsZSl8fHRoaXMuaXNFbmRTZWdtZW50KG4scykpKXJldHVybiBudWxsfWNvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLl9pbnRTZWdtZW50cz1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0aGlzLl9pbnRTZWdtZW50c1swXT1pLHRoaXMuX2ludFNlZ21lbnRzWzFdPXIsdGhpcy5faW50U2VnbWVudHNbMl09byx0aGlzLl9pbnRTZWdtZW50c1szXT1sLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uPXRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKSx0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucyYmdGhpcy5faW50ZXJzZWN0aW9ucy5hZGQodGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24pLHRoaXMuX2ludGVyc2VjdGlvbkNvdW50KyspfWlzRW5kU2VnbWVudCh0LGUpe3JldHVybiAwPT09ZXx8ZT49dC5zaXplKCktMn1oYXNJbnRlcnNlY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ufWlzRG9uZSgpe3JldHVybiF0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyYmbnVsbCE9PXRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ufWdldENsYXNzKCl7cmV0dXJuIFFpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltfaV19fVFpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHk9ITEsdGhpcy5fbGk9bnVsbCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbj1udWxsLHRoaXMuX2ludFNlZ21lbnRzPW51bGwsdGhpcy5faW50ZXJzZWN0aW9ucz1uZXcgeCx0aGlzLl9pbnRlcnNlY3Rpb25Db3VudD0wLHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpPXQsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb249bnVsbH07Y2xhc3MgSml7Y29uc3RydWN0b3IoKXtKaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21wdXRlSW50ZXJzZWN0aW9ucyh0KXtjb25zdCBlPW5ldyBKaSh0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5pc1ZhbGlkKCksZS5nZXRJbnRlcnNlY3Rpb25zKCl9ZXhlY3V0ZSgpe2lmKG51bGwhPT10aGlzLl9zZWdJbnQpcmV0dXJuIG51bGw7dGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpfWdldEludGVyc2VjdGlvbnMoKXtyZXR1cm4gdGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvbnMoKX1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMuZXhlY3V0ZSgpLHRoaXMuX2lzVmFsaWR9c2V0RmluZEFsbEludGVyc2VjdGlvbnModCl7dGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9dH1jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpe3RoaXMuX2lzVmFsaWQ9ITAsdGhpcy5fc2VnSW50PW5ldyBRaSh0aGlzLl9saSksdGhpcy5fc2VnSW50LnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zKTtjb25zdCB0PW5ldyBZcztpZih0LnNldFNlZ21lbnRJbnRlcnNlY3Rvcih0aGlzLl9zZWdJbnQpLHQuY29tcHV0ZU5vZGVzKHRoaXMuX3NlZ1N0cmluZ3MpLHRoaXMuX3NlZ0ludC5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4gdGhpcy5faXNWYWxpZD0hMSxudWxsfWNoZWNrVmFsaWQoKXtpZih0aGlzLmV4ZWN1dGUoKSwhdGhpcy5faXNWYWxpZCl0aHJvdyBuZXcgV24odGhpcy5nZXRFcnJvck1lc3NhZ2UoKSx0aGlzLl9zZWdJbnQuZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb24oKSl9Z2V0RXJyb3JNZXNzYWdlKCl7aWYodGhpcy5faXNWYWxpZClyZXR1cm5cIm5vIGludGVyc2VjdGlvbnMgZm91bmRcIjtjb25zdCB0PXRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb25TZWdtZW50cygpO3JldHVyblwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBiZXR3ZWVuIFwiK0p0LnRvTGluZVN0cmluZyh0WzBdLHRbMV0pK1wiIGFuZCBcIitKdC50b0xpbmVTdHJpbmcodFsyXSx0WzNdKX1nZXRDbGFzcygpe3JldHVybiBKaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bmV3IHRlLHRoaXMuX3NlZ1N0cmluZ3M9bnVsbCx0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLl9zZWdJbnQ9bnVsbCx0aGlzLl9pc1ZhbGlkPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NlZ1N0cmluZ3M9dH07Y2xhc3MgJGl7Y29uc3RydWN0b3IoKXskaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b1NlZ21lbnRTdHJpbmdzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGQobmV3IFppKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KSl9cmV0dXJuIGV9c3RhdGljIGNoZWNrVmFsaWQodCl7bmV3ICRpKHQpLmNoZWNrVmFsaWQoKX1jaGVja1ZhbGlkKCl7dGhpcy5fbnYuY2hlY2tWYWxpZCgpfWdldENsYXNzKCl7cmV0dXJuICRpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX0kaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9udj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX252PW5ldyBKaSgkaS50b1NlZ21lbnRTdHJpbmdzKHQpKX07Y2xhc3MgdHJ7Y29uc3RydWN0b3IoKXt0ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbGxlY3RMaW5lcyh0KXtmb3IobGV0IGU9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuY29sbGVjdExpbmVFZGdlKG4sdCx0aGlzLl9saW5lRWRnZXNMaXN0KSx0aGlzLmNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZShuLHQsdGhpcy5fbGluZUVkZ2VzTGlzdCl9fWxhYmVsSXNvbGF0ZWRMaW5lKHQsZSl7Y29uc3Qgbj10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX29wLmdldEFyZ0dlb21ldHJ5KGUpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX1idWlsZCh0KXtyZXR1cm4gdGhpcy5maW5kQ292ZXJlZExpbmVFZGdlcygpLHRoaXMuY29sbGVjdExpbmVzKHQpLHRoaXMuYnVpbGRMaW5lcyh0KSx0aGlzLl9yZXN1bHRMaW5lTGlzdH1jb2xsZWN0TGluZUVkZ2UodCxlLG4pe2NvbnN0IHM9dC5nZXRMYWJlbCgpLGk9dC5nZXRFZGdlKCk7dC5pc0xpbmVFZGdlKCkmJih0LmlzVmlzaXRlZCgpfHwhY3IuaXNSZXN1bHRPZk9wKHMsZSl8fGkuaXNDb3ZlcmVkKCl8fChuLmFkZChpKSx0LnNldFZpc2l0ZWRFZGdlKCEwKSkpfWZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5maW5kQ292ZXJlZExpbmVFZGdlcygpfWZvcihsZXQgdD10aGlzLl9vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldEVkZ2UoKTtpZihlLmlzTGluZUVkZ2UoKSYmIW4uaXNDb3ZlcmVkU2V0KCkpe2NvbnN0IHQ9dGhpcy5fb3AuaXNDb3ZlcmVkQnlBKGUuZ2V0Q29vcmRpbmF0ZSgpKTtuLnNldENvdmVyZWQodCl9fX1sYWJlbElzb2xhdGVkTGluZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldExhYmVsKCk7dC5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKHQsMCk6dGhpcy5sYWJlbElzb2xhdGVkTGluZSh0LDEpKX19YnVpbGRMaW5lcyh0KXtmb3IobGV0IHQ9dGhpcy5fbGluZUVkZ2VzTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPShlLmdldExhYmVsKCksdGhpcy5fZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoZS5nZXRDb29yZGluYXRlcygpKSk7dGhpcy5fcmVzdWx0TGluZUxpc3QuYWRkKG4pLGUuc2V0SW5SZXN1bHQoITApfX1jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UodCxlLG4pe2NvbnN0IHM9dC5nZXRMYWJlbCgpO3JldHVybiB0LmlzTGluZUVkZ2UoKXx8dC5pc1Zpc2l0ZWQoKXx8dC5pc0ludGVyaW9yQXJlYUVkZ2UoKXx8dC5nZXRFZGdlKCkuaXNJblJlc3VsdCgpP251bGw6KHUuaXNUcnVlKCEodC5pc0luUmVzdWx0KCl8fHQuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKXx8IXQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSksdm9pZChjci5pc1Jlc3VsdE9mT3AocyxlKSYmZT09PWNyLklOVEVSU0VDVElPTiYmKG4uYWRkKHQuZ2V0RWRnZSgpKSx0LnNldFZpc2l0ZWRFZGdlKCEwKSkpKX1nZXRDbGFzcygpe3JldHVybiB0cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fb3A9bnVsbCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLl9wdExvY2F0b3I9bnVsbCx0aGlzLl9saW5lRWRnZXNMaXN0PW5ldyB4LHRoaXMuX3Jlc3VsdExpbmVMaXN0PW5ldyB4O2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX29wPXQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5fcHRMb2NhdG9yPW59O2NsYXNzIGVye2NvbnN0cnVjdG9yKCl7ZXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGUoKTtpZighdGhpcy5fb3AuaXNDb3ZlcmVkQnlMQShlKSl7Y29uc3QgdD10aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSk7dGhpcy5fcmVzdWx0UG9pbnRMaXN0LmFkZCh0KX19ZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKCFuLmlzSW5SZXN1bHQoKSYmKCFuLmlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKSYmKDA9PT1uLmdldEVkZ2VzKCkuZ2V0RGVncmVlKCl8fHQ9PT1jci5JTlRFUlNFQ1RJT04pKSl7Y29uc3QgZT1uLmdldExhYmVsKCk7Y3IuaXNSZXN1bHRPZk9wKGUsdCkmJnRoaXMuZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50KG4pfX19YnVpbGQodCl7cmV0dXJuIHRoaXMuZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2Rlcyh0KSx0aGlzLl9yZXN1bHRQb2ludExpc3R9Z2V0Q2xhc3MoKXtyZXR1cm4gZXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWVyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX29wPW51bGwsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5fcmVzdWx0UG9pbnRMaXN0PW5ldyB4O2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX29wPXQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PWV9O2NsYXNzIG5ye2NvbnN0cnVjdG9yKCl7dGhpcy5faXNGaXJzdD0hMCx0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudD01Myx0aGlzLl9jb21tb25CaXRzPW5ldyBzLHRoaXMuX2NvbW1vblNpZ25FeHA9bnVsbH1nZXRDb21tb24oKXtyZXR1cm4gaS5sb25nQml0c1RvRG91YmxlKHRoaXMuX2NvbW1vbkJpdHMpfWFkZCh0KXtjb25zdCBlPWkuZG91YmxlVG9Mb25nQml0cyh0KTtyZXR1cm4gdGhpcy5faXNGaXJzdD8odGhpcy5fY29tbW9uQml0cz1lLHRoaXMuX2NvbW1vblNpZ25FeHA9bnIuc2lnbkV4cEJpdHModGhpcy5fY29tbW9uQml0cyksdGhpcy5faXNGaXJzdD0hMSxudWxsKTpuci5zaWduRXhwQml0cyhlKSE9PXRoaXMuX2NvbW1vblNpZ25FeHA/KHRoaXMuX2NvbW1vbkJpdHMuaGlnaD0wLHRoaXMuX2NvbW1vbkJpdHMubG93PTAsbnVsbCk6KHRoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50PW5yLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHModGhpcy5fY29tbW9uQml0cyxlKSx2b2lkKHRoaXMuX2NvbW1vbkJpdHM9bnIuemVyb0xvd2VyQml0cyh0aGlzLl9jb21tb25CaXRzLDY0LSgxMit0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudCkpKSl9dG9TdHJpbmcoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1pLmxvbmdCaXRzVG9Eb3VibGUodCksbj1cIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIitzLnRvQmluYXJ5U3RyaW5nKHQpLHI9bi5zdWJzdHJpbmcobi5sZW5ndGgtNjQpO3JldHVybiByLnN1YnN0cmluZygwLDEpK1wiICBcIityLnN1YnN0cmluZygxLDEyKStcIihleHApIFwiK3Iuc3Vic3RyaW5nKDEyKStcIiBbIFwiK2UrXCIgXVwifX1nZXRDbGFzcygpe3JldHVybiBucn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX1zdGF0aWMgZ2V0Qml0KHQsZSl7Y29uc3Qgbj0xPDxlJTMyO3JldHVybiBlPDMyPzAhPSh0LmxvdyZuKT8xOjA6MCE9KHQuaGlnaCZuKT8xOjB9c3RhdGljIHNpZ25FeHBCaXRzKHQpe3JldHVybiB0LmhpZ2g+Pj4yMH1zdGF0aWMgemVyb0xvd2VyQml0cyh0LGUpe2xldCBuPVwibG93XCI7aWYoZT4zMiYmKHQubG93PTAsZSU9MzIsbj1cImhpZ2hcIiksZT4wKXtjb25zdCBzPWU8MzI/figoMTw8ZSktMSk6MDt0W25dJj1zfXJldHVybiB0fXN0YXRpYyBudW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHQsZSl7bGV0IG49MDtmb3IobGV0IHM9NTI7cz49MDtzLS0pe2lmKG5yLmdldEJpdCh0LHMpIT09bnIuZ2V0Qml0KGUscykpcmV0dXJuIG47bisrfXJldHVybiA1Mn19Y2xhc3Mgc3J7Y29uc3RydWN0b3IoKXtzci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZENvbW1vbkJpdHModCl7Y29uc3QgZT1uZXcgcnIodGhpcy5fY29tbW9uQ29vcmQpO3QuYXBwbHkoZSksdC5nZW9tZXRyeUNoYW5nZWQoKX1yZW1vdmVDb21tb25CaXRzKHQpe2lmKDA9PT10aGlzLl9jb21tb25Db29yZC54JiYwPT09dGhpcy5fY29tbW9uQ29vcmQueSlyZXR1cm4gdDtjb25zdCBlPW5ldyBnKHRoaXMuX2NvbW1vbkNvb3JkKTtlLng9LWUueCxlLnk9LWUueTtjb25zdCBuPW5ldyBycihlKTtyZXR1cm4gdC5hcHBseShuKSx0Lmdlb21ldHJ5Q2hhbmdlZCgpLHR9Z2V0Q29tbW9uQ29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9jb21tb25Db29yZH1hZGQodCl7dC5hcHBseSh0aGlzLl9jY0ZpbHRlciksdGhpcy5fY29tbW9uQ29vcmQ9dGhpcy5fY2NGaWx0ZXIuZ2V0Q29tbW9uQ29vcmRpbmF0ZSgpfWdldENsYXNzKCl7cmV0dXJuIHNyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBpcntjb25zdHJ1Y3Rvcigpe2lyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe3RoaXMuX2NvbW1vbkJpdHNYLmFkZCh0LngpLHRoaXMuX2NvbW1vbkJpdHNZLmFkZCh0LnkpfWdldENvbW1vbkNvb3JkaW5hdGUoKXtyZXR1cm4gbmV3IGcodGhpcy5fY29tbW9uQml0c1guZ2V0Q29tbW9uKCksdGhpcy5fY29tbW9uQml0c1kuZ2V0Q29tbW9uKCkpfWdldENsYXNzKCl7cmV0dXJuIGlyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltCXX19aXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29tbW9uQml0c1g9bmV3IG5yLHRoaXMuX2NvbW1vbkJpdHNZPW5ldyBucn07Y2xhc3MgcnJ7Y29uc3RydWN0b3IoKXtyci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0LGUpe2NvbnN0IG49dC5nZXRPcmRpbmF0ZShlLDApK3RoaXMudHJhbnMueCxzPXQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLnRyYW5zLnk7dC5zZXRPcmRpbmF0ZShlLDAsbiksdC5zZXRPcmRpbmF0ZShlLDEscyl9aXNEb25lKCl7cmV0dXJuITF9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMH1nZXRDbGFzcygpe3JldHVybiBycn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZHRdfX1yci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLnRyYW5zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy50cmFucz10fSxzci5Db21tb25Db29yZGluYXRlRmlsdGVyPWlyLHNyLlRyYW5zbGF0ZXI9cnIsc3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29tbW9uQ29vcmQ9bnVsbCx0aGlzLl9jY0ZpbHRlcj1uZXcgaXJ9O2NsYXNzIG9ye2NvbnN0cnVjdG9yKCl7b3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb3ZlcmxheU9wKHQsZSxuKXtyZXR1cm4gbmV3IG9yKHQsZSkuZ2V0UmVzdWx0R2VvbWV0cnkobil9c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIG9yLm92ZXJsYXlPcCh0LGUsY3IuVU5JT04pfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtyZXR1cm4gb3Iub3ZlcmxheU9wKHQsZSxjci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7cmV0dXJuIG9yLm92ZXJsYXlPcCh0LGUsY3IuU1lNRElGRkVSRU5DRSl9c3RhdGljIGRpZmZlcmVuY2UodCxlKXtyZXR1cm4gb3Iub3ZlcmxheU9wKHQsZSxjci5ESUZGRVJFTkNFKX1zZWxmU25hcCh0KXtyZXR1cm4gbmV3IFdpKHQpLnNuYXBUbyh0LHRoaXMuX3NuYXBUb2xlcmFuY2UpfXJlbW92ZUNvbW1vbkJpdHModCl7dGhpcy5fY2JyPW5ldyBzcix0aGlzLl9jYnIuYWRkKHRbMF0pLHRoaXMuX2Nici5hZGQodFsxXSk7Y29uc3QgZT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtyZXR1cm4gZVswXT10aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzBdLmNvcHkoKSksZVsxXT10aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzFdLmNvcHkoKSksZX1wcmVwYXJlUmVzdWx0KHQpe3JldHVybiB0aGlzLl9jYnIuYWRkQ29tbW9uQml0cyh0KSx0fWdldFJlc3VsdEdlb21ldHJ5KHQpe2NvbnN0IGU9dGhpcy5zbmFwKHRoaXMuX2dlb20pLG49Y3Iub3ZlcmxheU9wKGVbMF0sZVsxXSx0KTtyZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KG4pfWNoZWNrVmFsaWQodCl7dC5pc1ZhbGlkKCl8fE8ub3V0LnByaW50bG4oXCJTbmFwcGVkIGdlb21ldHJ5IGlzIGludmFsaWRcIil9Y29tcHV0ZVNuYXBUb2xlcmFuY2UoKXt0aGlzLl9zbmFwVG9sZXJhbmNlPVdpLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSh0aGlzLl9nZW9tWzBdLHRoaXMuX2dlb21bMV0pfXNuYXAodCl7Y29uc3QgZT10aGlzLnJlbW92ZUNvbW1vbkJpdHModCk7cmV0dXJuIFdpLnNuYXAoZVswXSxlWzFdLHRoaXMuX3NuYXBUb2xlcmFuY2UpfWdldENsYXNzKCl7cmV0dXJuIG9yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1vci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX3NuYXBUb2xlcmFuY2U9bnVsbCx0aGlzLl9jYnI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tWzBdPXQsdGhpcy5fZ2VvbVsxXT1lLHRoaXMuY29tcHV0ZVNuYXBUb2xlcmFuY2UoKX07Y2xhc3MgbHJ7Y29uc3RydWN0b3IoKXtsci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvdmVybGF5T3AodCxlLG4pe3JldHVybiBuZXcgbHIodCxlKS5nZXRSZXN1bHRHZW9tZXRyeShuKX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5VTklPTil9c3RhdGljIGludGVyc2VjdGlvbih0LGUpe3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLklOVEVSU0VDVElPTil9c3RhdGljIHN5bURpZmZlcmVuY2UodCxlKXtyZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5TWU1ESUZGRVJFTkNFKX1zdGF0aWMgZGlmZmVyZW5jZSh0LGUpe3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLkRJRkZFUkVOQ0UpfWdldFJlc3VsdEdlb21ldHJ5KHQpe2xldCBlPW51bGwsbj0hMSxzPW51bGw7dHJ5e2U9Y3Iub3ZlcmxheU9wKHRoaXMuX2dlb21bMF0sdGhpcy5fZ2VvbVsxXSx0KSwhMCYmKG49ITApfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGMpKXRocm93IHQ7cz10fWlmKCFuKXRyeXtlPW9yLm92ZXJsYXlPcCh0aGlzLl9nZW9tWzBdLHRoaXMuX2dlb21bMV0sdCl9Y2F0Y2godCl7dGhyb3cgdCBpbnN0YW5jZW9mIGM/czp0fXJldHVybiBlfWdldENsYXNzKCl7cmV0dXJuIGxyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1sci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21bMF09dCx0aGlzLl9nZW9tWzFdPWV9O2NsYXNzIGFye2NvbnN0cnVjdG9yKCl7YXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRBcmdHZW9tZXRyeSh0KXtyZXR1cm4gdGhpcy5fYXJnW3RdLmdldEdlb21ldHJ5KCl9c2V0Q29tcHV0YXRpb25QcmVjaXNpb24odCl7dGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9saS5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbCl9Z2V0Q2xhc3MoKXtyZXR1cm4gYXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWFyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2xpPW5ldyB0ZSx0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2FyZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5fYXJnPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLHRoaXMuX2FyZ1swXT1uZXcgUW4oMCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxWLk9HQ19TRlNfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dC5nZXRQcmVjaXNpb25Nb2RlbCgpLmNvbXBhcmVUbyhlLmdldFByZWNpc2lvbk1vZGVsKCkpPj0wP3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24odC5nZXRQcmVjaXNpb25Nb2RlbCgpKTp0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5fYXJnPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2FyZ1swXT1uZXcgUW4oMCx0LG4pLHRoaXMuX2FyZ1sxXT1uZXcgUW4oMSxlLG4pfX07Y2xhc3MgY3IgZXh0ZW5kcyBhcntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksY3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb3ZlcmxheU9wKHQsZSxuKXtyZXR1cm4gbmV3IGNyKHQsZSkuZ2V0UmVzdWx0R2VvbWV0cnkobil9c3RhdGljIHVuaW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIGNyLmNyZWF0ZUVtcHR5UmVzdWx0KGNyLlVOSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1pZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl0aHJvdyBuZXcgbihcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKTtyZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5VTklPTil9c3RhdGljIGludGVyc2VjdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSlyZXR1cm4gY3IuY3JlYXRlRW1wdHlSZXN1bHQoY3IuSU5URVJTRUNUSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXtjb25zdCBuPWU7cmV0dXJuIGdlLm1hcCh0LG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZmVdfW1hcCh0KXtyZXR1cm4gY3IuaW50ZXJzZWN0aW9uKHQsbil9fSl9cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiBjci5jcmVhdGVFbXB0eVJlc3VsdChjci5TWU1ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1pZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl0aHJvdyBuZXcgbihcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKTtyZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5TWU1ESUZGRVJFTkNFKX1zdGF0aWMgcmVzdWx0RGltZW5zaW9uKHQsZSxuKXtjb25zdCBzPWUuZ2V0RGltZW5zaW9uKCksaT1uLmdldERpbWVuc2lvbigpO2xldCByPS0xO3N3aXRjaCh0KXtjYXNlIGNyLklOVEVSU0VDVElPTjpyPU1hdGgubWluKHMsaSk7YnJlYWs7Y2FzZSBjci5VTklPTjpyPU1hdGgubWF4KHMsaSk7YnJlYWs7Y2FzZSBjci5ESUZGRVJFTkNFOnI9czticmVhaztjYXNlIGNyLlNZTURJRkZFUkVOQ0U6cj1NYXRoLm1heChzLGkpfXJldHVybiByfXN0YXRpYyBjcmVhdGVFbXB0eVJlc3VsdCh0LGUsbixzKXtsZXQgaT1udWxsO3N3aXRjaChjci5yZXN1bHREaW1lbnNpb24odCxlLG4pKXtjYXNlLTE6aT1zLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2JyZWFrO2Nhc2UgMDppPXMuY3JlYXRlUG9pbnQoKTticmVhaztjYXNlIDE6aT1zLmNyZWF0ZUxpbmVTdHJpbmcoKTticmVhaztjYXNlIDI6aT1zLmNyZWF0ZVBvbHlnb24oKX1yZXR1cm4gaX1zdGF0aWMgZGlmZmVyZW5jZSh0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBjci5jcmVhdGVFbXB0eVJlc3VsdChjci5ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpO2lmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBuKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLkRJRkZFUkVOQ0UpfXN0YXRpYyBpc1Jlc3VsdE9mT3AoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldExvY2F0aW9uKDApLHM9dC5nZXRMb2NhdGlvbigxKTtyZXR1cm4gY3IuaXNSZXN1bHRPZk9wKG4scyxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2NvbnN0IG49YXJndW1lbnRzWzJdO3N3aXRjaCh0PT09bmUuQk9VTkRBUlkmJih0PW5lLklOVEVSSU9SKSxlPT09bmUuQk9VTkRBUlkmJihlPW5lLklOVEVSSU9SKSxuKXtjYXNlIGNyLklOVEVSU0VDVElPTjpyZXR1cm4gdD09PW5lLklOVEVSSU9SJiZlPT09bmUuSU5URVJJT1I7Y2FzZSBjci5VTklPTjpyZXR1cm4gdD09PW5lLklOVEVSSU9SfHxlPT09bmUuSU5URVJJT1I7Y2FzZSBjci5ESUZGRVJFTkNFOnJldHVybiB0PT09bmUuSU5URVJJT1ImJmUhPT1uZS5JTlRFUklPUjtjYXNlIGNyLlNZTURJRkZFUkVOQ0U6cmV0dXJuIHQ9PT1uZS5JTlRFUklPUiYmZSE9PW5lLklOVEVSSU9SfHx0IT09bmUuSU5URVJJT1ImJmU9PT1uZS5JTlRFUklPUn1yZXR1cm4hMX19aW5zZXJ0VW5pcXVlRWRnZSh0KXtjb25zdCBlPXRoaXMuX2VkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe2NvbnN0IG49ZS5nZXRMYWJlbCgpO2xldCBzPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChzPW5ldyBGbih0LmdldExhYmVsKCkpLHMuZmxpcCgpKTtjb25zdCBpPWUuZ2V0RGVwdGgoKTtpLmlzTnVsbCgpJiZpLmFkZChuKSxpLmFkZChzKSxuLm1lcmdlKHMpfWVsc2UgdGhpcy5fZWRnZUxpc3QuYWRkKHQpfWdldEdyYXBoKCl7cmV0dXJuIHRoaXMuX2dyYXBofWNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldFN5bSgpO2UuaXNJblJlc3VsdCgpJiZuLmlzSW5SZXN1bHQoKSYmKGUuc2V0SW5SZXN1bHQoITEpLG4uc2V0SW5SZXN1bHQoITEpKX19aXNDb3ZlcmVkQnlMQSh0KXtyZXR1cm4hIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5fcmVzdWx0TGluZUxpc3QpfHwhIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5fcmVzdWx0UG9seUxpc3QpfWNvbXB1dGVHZW9tZXRyeSh0LGUsbixzKXtjb25zdCBpPW5ldyB4O3JldHVybiBpLmFkZEFsbCh0KSxpLmFkZEFsbChlKSxpLmFkZEFsbChuKSxpLmlzRW1wdHkoKT9jci5jcmVhdGVFbXB0eVJlc3VsdChzLHRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLHRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpLHRoaXMuX2dlb21GYWN0KTp0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KGkpfW1lcmdlU3ltTGFiZWxzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubWVyZ2VTeW1MYWJlbHMoKX19aXNDb3ZlcmVkKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCk7aWYodGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LGUpIT09bmUuRVhURVJJT1IpcmV0dXJuITB9cmV0dXJuITF9cmVwbGFjZUNvbGxhcHNlZEVkZ2VzKCl7Y29uc3QgdD1uZXcgeDtmb3IobGV0IGU9dGhpcy5fZWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7bi5pc0NvbGxhcHNlZCgpJiYoZS5yZW1vdmUoKSx0LmFkZChuLmdldENvbGxhcHNlZEVkZ2UoKSkpfXRoaXMuX2VkZ2VMaXN0LmFkZEFsbCh0KX11cGRhdGVOb2RlTGFiZWxsaW5nKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldEVkZ2VzKCkuZ2V0TGFiZWwoKTtlLmdldExhYmVsKCkubWVyZ2Uobil9fWdldFJlc3VsdEdlb21ldHJ5KHQpe3JldHVybiB0aGlzLmNvbXB1dGVPdmVybGF5KHQpLHRoaXMuX3Jlc3VsdEdlb219aW5zZXJ0VW5pcXVlRWRnZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKHQpfX1jb21wdXRlT3ZlcmxheSh0KXt0aGlzLmNvcHlQb2ludHMoMCksdGhpcy5jb3B5UG9pbnRzKDEpLHRoaXMuX2FyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSksdGhpcy5fYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLl9hcmdbMV0sdGhpcy5fbGksITApO2NvbnN0IGU9bmV3IHg7dGhpcy5fYXJnWzBdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpLHRoaXMuX2FyZ1sxXS5jb21wdXRlU3BsaXRFZGdlcyhlKSx0aGlzLmluc2VydFVuaXF1ZUVkZ2VzKGUpLHRoaXMuY29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMoKSx0aGlzLnJlcGxhY2VDb2xsYXBzZWRFZGdlcygpLCRpLmNoZWNrVmFsaWQodGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5jb21wdXRlTGFiZWxsaW5nKCksdGhpcy5sYWJlbEluY29tcGxldGVOb2RlcygpLHRoaXMuZmluZFJlc3VsdEFyZWFFZGdlcyh0KSx0aGlzLmNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCk7Y29uc3Qgbj1uZXcgZWkodGhpcy5fZ2VvbUZhY3QpO24uYWRkKHRoaXMuX2dyYXBoKSx0aGlzLl9yZXN1bHRQb2x5TGlzdD1uLmdldFBvbHlnb25zKCk7Y29uc3Qgcz1uZXcgdHIodGhpcyx0aGlzLl9nZW9tRmFjdCx0aGlzLl9wdExvY2F0b3IpO3RoaXMuX3Jlc3VsdExpbmVMaXN0PXMuYnVpbGQodCk7Y29uc3QgaT1uZXcgZXIodGhpcyx0aGlzLl9nZW9tRmFjdCx0aGlzLl9wdExvY2F0b3IpO3RoaXMuX3Jlc3VsdFBvaW50TGlzdD1pLmJ1aWxkKHQpLHRoaXMuX3Jlc3VsdEdlb209dGhpcy5jb21wdXRlR2VvbWV0cnkodGhpcy5fcmVzdWx0UG9pbnRMaXN0LHRoaXMuX3Jlc3VsdExpbmVMaXN0LHRoaXMuX3Jlc3VsdFBvbHlMaXN0LHQpfWxhYmVsSW5jb21wbGV0ZU5vZGUodCxlKXtjb25zdCBuPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5fYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbihlLG4pfWNvcHlQb2ludHModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5fZ3JhcGguYWRkTm9kZShuLmdldENvb3JkaW5hdGUoKSkuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX1maW5kUmVzdWx0QXJlYUVkZ2VzKHQpe2ZvcihsZXQgZT10aGlzLl9ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpO3MuaXNBcmVhKCkmJiFuLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZjci5pc1Jlc3VsdE9mT3Aocy5nZXRMb2NhdGlvbigwLFBuLlJJR0hUKSxzLmdldExvY2F0aW9uKDEsUG4uUklHSFQpLHQpJiZuLnNldEluUmVzdWx0KCEwKX19Y29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMoKXtmb3IobGV0IHQ9dGhpcy5fZWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCkscz1lLmdldERlcHRoKCk7aWYoIXMuaXNOdWxsKCkpe3Mubm9ybWFsaXplKCk7Zm9yKGxldCB0PTA7dDwyO3QrKyluLmlzTnVsbCh0KXx8IW4uaXNBcmVhKCl8fHMuaXNOdWxsKHQpfHwoMD09PXMuZ2V0RGVsdGEodCk/bi50b0xpbmUodCk6KHUuaXNUcnVlKCFzLmlzTnVsbCh0LFBuLkxFRlQpLFwiZGVwdGggb2YgTEVGVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKSxuLnNldExvY2F0aW9uKHQsUG4uTEVGVCxzLmdldExvY2F0aW9uKHQsUG4uTEVGVCkpLHUuaXNUcnVlKCFzLmlzTnVsbCh0LFBuLlJJR0hUKSxcImRlcHRoIG9mIFJJR0hUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24odCxQbi5SSUdIVCxzLmdldExvY2F0aW9uKHQsUG4uUklHSFQpKSkpfX19Y29tcHV0ZUxhYmVsbGluZygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcy5fYXJnKX10aGlzLm1lcmdlU3ltTGFiZWxzKCksdGhpcy51cGRhdGVOb2RlTGFiZWxsaW5nKCl9bGFiZWxJbmNvbXBsZXRlTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKTtlLmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShlLDApOnRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShlLDEpKSxlLmdldEVkZ2VzKCkudXBkYXRlTGFiZWxsaW5nKG4pfX1pc0NvdmVyZWRCeUEodCl7cmV0dXJuISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMuX3Jlc3VsdFBvbHlMaXN0KX1nZXRDbGFzcygpe3JldHVybiBjcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRMb2NhdG9yPW5ldyBfbix0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX3Jlc3VsdEdlb209bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2VkZ2VMaXN0PW5ldyBkaSx0aGlzLl9yZXN1bHRQb2x5TGlzdD1uZXcgeCx0aGlzLl9yZXN1bHRMaW5lTGlzdD1uZXcgeCx0aGlzLl9yZXN1bHRQb2ludExpc3Q9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMuX2dyYXBoPW5ldyBabihuZXcgdWkpLHRoaXMuX2dlb21GYWN0PXQuZ2V0RmFjdG9yeSgpfSxjci5JTlRFUlNFQ1RJT049MSxjci5VTklPTj0yLGNyLkRJRkZFUkVOQ0U9Myxjci5TWU1ESUZGRVJFTkNFPTQ7dmFyIGhyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLHNuYXA6S2ksT3ZlcmxheU9wOmNyfSk7Y2xhc3MgdXIgZXh0ZW5kcyBiaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXROZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9aXNJblJpbmcoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX2VkZ2VSaW5nfXNldFJpbmcodCl7dGhpcy5fZWRnZVJpbmc9dH1zZXRMYWJlbCh0KXt0aGlzLl9sYWJlbD10fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfXNldE5leHQodCl7dGhpcy5fbmV4dD10fWdldFJpbmcoKXtyZXR1cm4gdGhpcy5fZWRnZVJpbmd9Z2V0Q2xhc3MoKXtyZXR1cm4gdXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXVyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2VkZ2VSaW5nPW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2xhYmVsPS0xO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2JpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4scyl9O2NsYXNzIGdyIGV4dGVuZHMgRGl7Y29uc3RydWN0b3IoKXtzdXBlcigpLGdyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TGluZSgpe3JldHVybiB0aGlzLl9saW5lfWdldENsYXNzKCl7cmV0dXJuIGdyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1nci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZT10fTtjbGFzcyBkcntjb25zdHJ1Y3Rvcigpe2RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGZpbmREaWZmZXJlbnRQb2ludCh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlKSlyZXR1cm4gdFtuXTtyZXR1cm4gbnVsbH12aXNpdEludGVyaW9yUmluZyh0LGUpe2NvbnN0IG49dC5nZXRDb29yZGluYXRlcygpLHM9blswXSxpPWRyLmZpbmREaWZmZXJlbnRQb2ludChuLHMpLHI9ZS5maW5kRWRnZUluU2FtZURpcmVjdGlvbihzLGkpLG89ZS5maW5kRWRnZUVuZChyKTtsZXQgbD1udWxsO28uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLFBuLlJJR0hUKT09PW5lLklOVEVSSU9SP2w9bzpvLmdldFN5bSgpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCk9PT1uZS5JTlRFUklPUiYmKGw9by5nZXRTeW0oKSksdS5pc1RydWUobnVsbCE9PWwsXCJ1bmFibGUgdG8gZmluZCBkaXJFZGdlIHdpdGggSW50ZXJpb3Igb24gUkhTXCIpLHRoaXMudmlzaXRMaW5rZWREaXJlY3RlZEVkZ2VzKGwpfXZpc2l0U2hlbGxJbnRlcmlvcnModCxlKXtpZih0IGluc3RhbmNlb2YgYnQpe2NvbnN0IG49dDt0aGlzLnZpc2l0SW50ZXJpb3JSaW5nKG4uZ2V0RXh0ZXJpb3JSaW5nKCksZSl9aWYodCBpbnN0YW5jZW9mIEF0KXtjb25zdCBuPXQ7Zm9yKGxldCB0PTA7dDxuLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IHM9bi5nZXRHZW9tZXRyeU4odCk7dGhpcy52aXNpdEludGVyaW9yUmluZyhzLmdldEV4dGVyaW9yUmluZygpLGUpfX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9kaXNjb25uZWN0ZWRSaW5nY29vcmR9c2V0SW50ZXJpb3JFZGdlc0luUmVzdWx0KHQpe2ZvcihsZXQgZT10LmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsUG4uUklHSFQpPT09bmUuSU5URVJJT1ImJnQuc2V0SW5SZXN1bHQoITApfX12aXNpdExpbmtlZERpcmVjdGVkRWRnZXModCl7Y29uc3QgZT10O2xldCBuPXQ7ZG97dS5pc1RydWUobnVsbCE9PW4sXCJmb3VuZCBudWxsIERpcmVjdGVkIEVkZ2VcIiksbi5zZXRWaXNpdGVkKCEwKSxuPW4uZ2V0TmV4dCgpfXdoaWxlKG4hPT1lKX1idWlsZEVkZ2VSaW5ncyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQuaXNJblJlc3VsdCgpJiZudWxsPT09dC5nZXRFZGdlUmluZygpKXtjb25zdCBuPW5ldyB0aSh0LHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7bi5saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKTtjb25zdCBzPW4uYnVpbGRNaW5pbWFsUmluZ3MoKTtlLmFkZEFsbChzKX19cmV0dXJuIGV9aGFzVW52aXNpdGVkU2hlbGxFZGdlKHQpe2ZvcihsZXQgZT0wO2U8dC5zaXplKCk7ZSsrKXtjb25zdCBuPXQuZ2V0KGUpO2lmKG4uaXNIb2xlKCkpY29udGludWU7Y29uc3Qgcz1uLmdldEVkZ2VzKCk7bGV0IGk9cy5nZXQoMCk7aWYoaS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsUG4uUklHSFQpPT09bmUuSU5URVJJT1IpZm9yKGxldCB0PTA7dDxzLnNpemUoKTt0KyspaWYoaT1zLmdldCh0KSwhaS5pc1Zpc2l0ZWQoKSlyZXR1cm4gdGhpcy5fZGlzY29ubmVjdGVkUmluZ2Nvb3JkPWkuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfWlzSW50ZXJpb3JzQ29ubmVjdGVkKCl7Y29uc3QgdD1uZXcgeDt0aGlzLl9nZW9tR3JhcGguY29tcHV0ZVNwbGl0RWRnZXModCk7Y29uc3QgZT1uZXcgWm4obmV3IHVpKTtlLmFkZEVkZ2VzKHQpLHRoaXMuc2V0SW50ZXJpb3JFZGdlc0luUmVzdWx0KGUpLGUubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKTtjb25zdCBuPXRoaXMuYnVpbGRFZGdlUmluZ3MoZS5nZXRFZGdlRW5kcygpKTtyZXR1cm4gdGhpcy52aXNpdFNoZWxsSW50ZXJpb3JzKHRoaXMuX2dlb21HcmFwaC5nZXRHZW9tZXRyeSgpLGUpLCF0aGlzLmhhc1VudmlzaXRlZFNoZWxsRWRnZShuKX1nZXRDbGFzcygpe3JldHVybiBkcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW5ldyBIdCx0aGlzLl9nZW9tR3JhcGg9bnVsbCx0aGlzLl9kaXNjb25uZWN0ZWRSaW5nY29vcmQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tR3JhcGg9dH07Y2xhc3MgX3J7Y29uc3RydWN0b3IoKXtfci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZUVkZ2VFbmRGb3JOZXh0KHQsZSxuLHMpe2NvbnN0IGk9bi5zZWdtZW50SW5kZXgrMTtpZihpPj10LmdldE51bVBvaW50cygpJiZudWxsPT09cylyZXR1cm4gbnVsbDtsZXQgcj10LmdldENvb3JkaW5hdGUoaSk7bnVsbCE9PXMmJnMuc2VnbWVudEluZGV4PT09bi5zZWdtZW50SW5kZXgmJihyPXMuY29vcmQpO2NvbnN0IG89bmV3IEhuKHQsbi5jb29yZCxyLG5ldyBGbih0LmdldExhYmVsKCkpKTtlLmFkZChvKX1jcmVhdGVFZGdlRW5kRm9yUHJldih0LGUsbixzKXtsZXQgaT1uLnNlZ21lbnRJbmRleDtpZigwPT09bi5kaXN0KXtpZigwPT09aSlyZXR1cm4gbnVsbDtpLS19bGV0IHI9dC5nZXRDb29yZGluYXRlKGkpO251bGwhPT1zJiZzLnNlZ21lbnRJbmRleD49aSYmKHI9cy5jb29yZCk7Y29uc3Qgbz1uZXcgRm4odC5nZXRMYWJlbCgpKTtvLmZsaXAoKTtjb25zdCBsPW5ldyBIbih0LG4uY29vcmQscixvKTtlLmFkZChsKX1jb21wdXRlRWRnZUVuZHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgeDtmb3IobGV0IG49dDtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5jb21wdXRlRWRnZUVuZHModCxlKX1yZXR1cm4gZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCk7bi5hZGRFbmRwb2ludHMoKTtjb25zdCBzPW4uaXRlcmF0b3IoKTtsZXQgaT1udWxsLHI9bnVsbDtpZighcy5oYXNOZXh0KCkpcmV0dXJuIG51bGw7bGV0IG89cy5uZXh0KCk7ZG97aT1yLHI9byxvPW51bGwscy5oYXNOZXh0KCkmJihvPXMubmV4dCgpKSxudWxsIT09ciYmKHRoaXMuY3JlYXRlRWRnZUVuZEZvclByZXYodCxlLHIsaSksdGhpcy5jcmVhdGVFZGdlRW5kRm9yTmV4dCh0LGUscixvKSl9d2hpbGUobnVsbCE9PXIpfX1nZXRDbGFzcygpe3JldHVybiBfcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19X3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBmciBleHRlbmRzIEhue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxmci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydCh0KXt0aGlzLl9lZGdlRW5kcy5hZGQodCl9cHJpbnQodCl7dC5wcmludGxuKFwiRWRnZUVuZEJ1bmRsZS0tXFx4M2UgTGFiZWw6IFwiK3RoaXMuX2xhYmVsKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCksdC5wcmludGxuKCl9fWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VFbmRzLml0ZXJhdG9yKCl9Z2V0RWRnZUVuZHMoKXtyZXR1cm4gdGhpcy5fZWRnZUVuZHN9Y29tcHV0ZUxhYmVsT24odCxlKXtsZXQgbj0wLHM9ITE7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IGk9ZS5uZXh0KCkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtpPT09bmUuQk9VTkRBUlkmJm4rKyxpPT09bmUuSU5URVJJT1ImJihzPSEwKX1sZXQgaT1uZS5OT05FO3MmJihpPW5lLklOVEVSSU9SKSxuPjAmJihpPVFuLmRldGVybWluZUJvdW5kYXJ5KGUsbikpLHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsaSl9Y29tcHV0ZUxhYmVsU2lkZSh0LGUpe2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO2lmKHMuZ2V0TGFiZWwoKS5pc0FyZWEoKSl7Y29uc3Qgbj1zLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCxlKTtpZihuPT09bmUuSU5URVJJT1IpcmV0dXJuIHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSxuZS5JTlRFUklPUiksbnVsbDtuPT09bmUuRVhURVJJT1ImJnRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSxuZS5FWFRFUklPUil9fX1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1jb21wdXRlTGFiZWxTaWRlcyh0KXt0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxQbi5MRUZUKSx0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxQbi5SSUdIVCl9dXBkYXRlSU0odCl7VW4udXBkYXRlSU0odGhpcy5fbGFiZWwsdCl9Y29tcHV0ZUxhYmVsKHQpe2xldCBlPSExO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRMYWJlbCgpLmlzQXJlYSgpJiYoZT0hMCl9dGhpcy5fbGFiZWw9ZT9uZXcgRm4obmUuTk9ORSxuZS5OT05FLG5lLk5PTkUpOm5ldyBGbihuZS5OT05FKTtmb3IobGV0IG49MDtuPDI7bisrKXRoaXMuY29tcHV0ZUxhYmVsT24obix0KSxlJiZ0aGlzLmNvbXB1dGVMYWJlbFNpZGVzKG4pfWdldENsYXNzKCl7cmV0dXJuIGZyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9lZGdlRW5kcz1uZXcgeCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07ZnIuY29uc3RydWN0b3JfLmNhbGwodGhpcyxudWxsLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO0huLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC5nZXRFZGdlKCksdC5nZXRDb29yZGluYXRlKCksdC5nZXREaXJlY3RlZENvb3JkaW5hdGUoKSxuZXcgRm4odC5nZXRMYWJlbCgpKSksdGhpcy5pbnNlcnQodCl9fTtjbGFzcyBwciBleHRlbmRzIGNpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxwci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXVwZGF0ZUlNKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS51cGRhdGVJTSh0KX19aW5zZXJ0KHQpe2xldCBlPXRoaXMuX2VkZ2VNYXAuZ2V0KHQpO251bGw9PT1lPyhlPW5ldyBmcih0KSx0aGlzLmluc2VydEVkZ2VFbmQodCxlKSk6ZS5pbnNlcnQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gcHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXByLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgbXIgZXh0ZW5kcyBrbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX11cGRhdGVJTUZyb21FZGdlcyh0KXt0aGlzLl9lZGdlcy51cGRhdGVJTSh0KX1jb21wdXRlSU0odCl7dC5zZXRBdExlYXN0SWZWYWxpZCh0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbigwKSx0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbigxKSwwKX1nZXRDbGFzcygpe3JldHVybiBtcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07a24uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfTtjbGFzcyB5ciBleHRlbmRzIEtue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx5ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZU5vZGUodCl7cmV0dXJuIG5ldyBtcih0LG5ldyBwcil9Z2V0Q2xhc3MoKXtyZXR1cm4geXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXlyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgeHJ7Y29uc3RydWN0b3IoKXt4ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydEVkZ2VFbmRzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuX25vZGVzLmFkZCh0KX19Z2V0Tm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVzLml0ZXJhdG9yKCl9Y29weU5vZGVzQW5kTGFiZWxzKHQsZSl7Zm9yKGxldCBuPXQuZ2V0Tm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuX25vZGVzLmFkZE5vZGUodC5nZXRDb29yZGluYXRlKCkpLnNldExhYmVsKGUsdC5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGUpKX19YnVpbGQodCl7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCwwKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscyh0LDApO2NvbnN0IGU9KG5ldyBfcikuY29tcHV0ZUVkZ2VFbmRzKHQuZ2V0RWRnZUl0ZXJhdG9yKCkpO3RoaXMuaW5zZXJ0RWRnZUVuZHMoZSl9Y29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKHQsZSl7Zm9yKGxldCBuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLHM9dC5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGUpO2ZvcihsZXQgbj10LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCksaT10aGlzLl9ub2Rlcy5hZGROb2RlKHQuY29vcmQpO3M9PT1uZS5CT1VOREFSWT9pLnNldExhYmVsQm91bmRhcnkoZSk6aS5nZXRMYWJlbCgpLmlzTnVsbChlKSYmaS5zZXRMYWJlbChlLG5lLklOVEVSSU9SKX19fWdldENsYXNzKCl7cmV0dXJuIHhyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX14ci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ub2Rlcz1uZXcgWG4obmV3IHlyKX07Y2xhc3MgRXJ7Y29uc3RydWN0b3IoKXtFci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudCgpe2ZvcihsZXQgdD10aGlzLl9ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2lmKCFlLmdldEVkZ2VzKCkuaXNBcmVhTGFiZWxzQ29uc2lzdGVudCh0aGlzLl9nZW9tR3JhcGgpKXJldHVybiB0aGlzLl9pbnZhbGlkUG9pbnQ9ZS5nZXRDb29yZGluYXRlKCkuY29weSgpLCExfXJldHVybiEwfWdldEludmFsaWRQb2ludCgpe3JldHVybiB0aGlzLl9pbnZhbGlkUG9pbnR9aGFzRHVwbGljYXRlUmluZ3MoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Zm9yKGxldCBlPXQubmV4dCgpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYodC5nZXRFZGdlRW5kcygpLnNpemUoKT4xKXJldHVybiB0aGlzLl9pbnZhbGlkUG9pbnQ9dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZSgwKSwhMH19cmV0dXJuITF9aXNOb2RlQ29uc2lzdGVudEFyZWEoKXtjb25zdCB0PXRoaXMuX2dlb21HcmFwaC5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCEwLCEwKTtyZXR1cm4gdC5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKT8odGhpcy5faW52YWxpZFBvaW50PXQuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6KHRoaXMuX25vZGVHcmFwaC5idWlsZCh0aGlzLl9nZW9tR3JhcGgpLHRoaXMuaXNOb2RlRWRnZUFyZWFMYWJlbHNDb25zaXN0ZW50KCkpfWdldENsYXNzKCl7cmV0dXJuIEVyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Fci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saT1uZXcgdGUsdGhpcy5fZ2VvbUdyYXBoPW51bGwsdGhpcy5fbm9kZUdyYXBoPW5ldyB4cix0aGlzLl9pbnZhbGlkUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tR3JhcGg9dH07Y2xhc3MgSXJ7Y29uc3RydWN0b3IoKXtJci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWJ1aWxkSW5kZXgoKXt0aGlzLl9pbmRleD1uZXcgRXM7Zm9yKGxldCB0PTA7dDx0aGlzLl9yaW5ncy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX3JpbmdzLmdldCh0KSxuPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3RoaXMuX2luZGV4Lmluc2VydChuLGUpfX1nZXROZXN0ZWRQb2ludCgpe3JldHVybiB0aGlzLl9uZXN0ZWRQdH1pc05vbk5lc3RlZCgpe3RoaXMuYnVpbGRJbmRleCgpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcmluZ3Muc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9yaW5ncy5nZXQodCksbj1lLmdldENvb3JkaW5hdGVzKCkscz10aGlzLl9pbmRleC5xdWVyeShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7Zm9yKGxldCB0PTA7dDxzLnNpemUoKTt0Kyspe2NvbnN0IGk9cy5nZXQodCkscj1pLmdldENvb3JkaW5hdGVzKCk7aWYoZT09PWkpY29udGludWU7aWYoIWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoaS5nZXRFbnZlbG9wZUludGVybmFsKCkpKWNvbnRpbnVlO2NvbnN0IG89Q3IuZmluZFB0Tm90Tm9kZShuLGksdGhpcy5fZ3JhcGgpO2lmKG51bGwhPT1vJiZXZS5pc0luUmluZyhvLHIpKXJldHVybiB0aGlzLl9uZXN0ZWRQdD1vLCExfX1yZXR1cm4hMH1hZGQodCl7dGhpcy5fcmluZ3MuYWRkKHQpLHRoaXMuX3RvdGFsRW52LmV4cGFuZFRvSW5jbHVkZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gSXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUlyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dyYXBoPW51bGwsdGhpcy5fcmluZ3M9bmV3IHgsdGhpcy5fdG90YWxFbnY9bmV3IE4sdGhpcy5faW5kZXg9bnVsbCx0aGlzLl9uZXN0ZWRQdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dyYXBoPXR9O2NsYXNzIE5ye2NvbnN0cnVjdG9yKCl7TnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRFcnJvclR5cGUoKXtyZXR1cm4gdGhpcy5fZXJyb3JUeXBlfWdldE1lc3NhZ2UoKXtyZXR1cm4gTnIuZXJyTXNnW3RoaXMuX2Vycm9yVHlwZV19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wdH10b1N0cmluZygpe2xldCB0PVwiXCI7cmV0dXJuIG51bGwhPT10aGlzLl9wdCYmKHQ9XCIgYXQgb3IgbmVhciBwb2ludCBcIit0aGlzLl9wdCksdGhpcy5nZXRNZXNzYWdlKCkrdH1nZXRDbGFzcygpe3JldHVybiBOcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZXJyb3JUeXBlPW51bGwsdGhpcy5fcHQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07TnIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Vycm9yVHlwZT10LG51bGwhPT1lJiYodGhpcy5fcHQ9ZS5jb3B5KCkpfX0sTnIuRVJST1I9MCxOci5SRVBFQVRFRF9QT0lOVD0xLE5yLkhPTEVfT1VUU0lERV9TSEVMTD0yLE5yLk5FU1RFRF9IT0xFUz0zLE5yLkRJU0NPTk5FQ1RFRF9JTlRFUklPUj00LE5yLlNFTEZfSU5URVJTRUNUSU9OPTUsTnIuUklOR19TRUxGX0lOVEVSU0VDVElPTj02LE5yLk5FU1RFRF9TSEVMTFM9NyxOci5EVVBMSUNBVEVfUklOR1M9OCxOci5UT09fRkVXX1BPSU5UUz05LE5yLklOVkFMSURfQ09PUkRJTkFURT0xMCxOci5SSU5HX05PVF9DTE9TRUQ9MTEsTnIuZXJyTXNnPVtcIlRvcG9sb2d5IFZhbGlkYXRpb24gRXJyb3JcIixcIlJlcGVhdGVkIFBvaW50XCIsXCJIb2xlIGxpZXMgb3V0c2lkZSBzaGVsbFwiLFwiSG9sZXMgYXJlIG5lc3RlZFwiLFwiSW50ZXJpb3IgaXMgZGlzY29ubmVjdGVkXCIsXCJTZWxmLWludGVyc2VjdGlvblwiLFwiUmluZyBTZWxmLWludGVyc2VjdGlvblwiLFwiTmVzdGVkIHNoZWxsc1wiLFwiRHVwbGljYXRlIFJpbmdzXCIsXCJUb28gZmV3IGRpc3RpbmN0IHBvaW50cyBpbiBnZW9tZXRyeSBjb21wb25lbnRcIixcIkludmFsaWQgQ29vcmRpbmF0ZVwiLFwiUmluZyBpcyBub3QgY2xvc2VkXCJdO2NsYXNzIENye2NvbnN0cnVjdG9yKCl7Q3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmluZFB0Tm90Tm9kZSh0LGUsbil7Y29uc3Qgcz1uLmZpbmRFZGdlKGUpLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49dFtlXTtpZighcy5pc0ludGVyc2VjdGlvbihuKSlyZXR1cm4gbn1yZXR1cm4gbnVsbH1zdGF0aWMgaXNWYWxpZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBDcih0KS5pc1ZhbGlkKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4haS5pc05hTih0LngpJiYoIWkuaXNJbmZpbml0ZSh0LngpJiYoIWkuaXNOYU4odC55KSYmIWkuaXNJbmZpbml0ZSh0LnkpKSl9fWNoZWNrSW52YWxpZENvb3JkaW5hdGVzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIUNyLmlzVmFsaWQodFtlXSkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5JTlZBTElEX0NPT1JESU5BVEUsdFtlXSksbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fWNoZWNrSG9sZXNOb3ROZXN0ZWQodCxlKXtjb25zdCBuPW5ldyBJcihlKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBzPXQuZ2V0SW50ZXJpb3JSaW5nTihlKTtuLmFkZChzKX1uLmlzTm9uTmVzdGVkKCl8fCh0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuTkVTVEVEX0hPTEVTLG4uZ2V0TmVzdGVkUG9pbnQoKSkpfWNoZWNrQ29uc2lzdGVudEFyZWEodCl7Y29uc3QgZT1uZXcgRXIodCk7aWYoIWUuaXNOb2RlQ29uc2lzdGVudEFyZWEoKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLlNFTEZfSU5URVJTRUNUSU9OLGUuZ2V0SW52YWxpZFBvaW50KCkpLG51bGw7ZS5oYXNEdXBsaWNhdGVSaW5ncygpJiYodGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLkRVUExJQ0FURV9SSU5HUyxlLmdldEludmFsaWRQb2ludCgpKSl9aXNWYWxpZCgpe3JldHVybiB0aGlzLmNoZWNrVmFsaWQodGhpcy5fcGFyZW50R2VvbWV0cnkpLG51bGw9PT10aGlzLl92YWxpZEVycn1jaGVja1NoZWxsSW5zaWRlSG9sZSh0LGUsbil7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGVzKCkscj1Dci5maW5kUHROb3ROb2RlKHMsZSxuKTtpZihudWxsIT09cil7aWYoIVdlLmlzSW5SaW5nKHIsaSkpcmV0dXJuIHJ9Y29uc3Qgbz1Dci5maW5kUHROb3ROb2RlKGksdCxuKTtpZihudWxsIT09byl7cmV0dXJuIFdlLmlzSW5SaW5nKG8scyk/bzpudWxsfXJldHVybiB1LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwicG9pbnRzIGluIHNoZWxsIGFuZCBob2xlIGFwcGVhciB0byBiZSBlcXVhbFwiKSxudWxsfWNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3ModCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nKHQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX1jaGVja0Nvbm5lY3RlZEludGVyaW9ycyh0KXtjb25zdCBlPW5ldyBkcih0KTtlLmlzSW50ZXJpb3JzQ29ubmVjdGVkKCl8fCh0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuRElTQ09OTkVDVEVEX0lOVEVSSU9SLGUuZ2V0Q29vcmRpbmF0ZSgpKSl9Y2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nKHQpe2NvbnN0IGU9bmV3IGF0O2xldCBuPSEwO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2lmKG4pbj0hMTtlbHNle2lmKGUuY29udGFpbnModC5jb29yZCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5SSU5HX1NFTEZfSU5URVJTRUNUSU9OLHQuY29vcmQpLG51bGw7ZS5hZGQodC5jb29yZCl9fX1jaGVja0hvbGVzSW5TaGVsbCh0LGUpe2NvbnN0IG49dC5nZXRFeHRlcmlvclJpbmcoKSxzPW5ldyBrZShuKTtmb3IobGV0IGk9MDtpPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7aSsrKXtjb25zdCByPXQuZ2V0SW50ZXJpb3JSaW5nTihpKSxvPUNyLmZpbmRQdE5vdE5vZGUoci5nZXRDb29yZGluYXRlcygpLG4sZSk7aWYobnVsbD09PW8pcmV0dXJuIG51bGw7aWYobmUuRVhURVJJT1I9PT1zLmxvY2F0ZShvKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLkhPTEVfT1VUU0lERV9TSEVMTCxvKSxudWxsfX1jaGVja1Rvb0Zld1BvaW50cyh0KXtpZih0Lmhhc1Rvb0Zld1BvaW50cygpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuVE9PX0ZFV19QT0lOVFMsdC5nZXRJbnZhbGlkUG9pbnQoKSksbnVsbH1nZXRWYWxpZGF0aW9uRXJyb3IoKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMuX3BhcmVudEdlb21ldHJ5KSx0aGlzLl92YWxpZEVycn1jaGVja1ZhbGlkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBNdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0KSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgUW4oMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyB0ZTtlLmNvbXB1dGVTZWxmTm9kZXMobiwhMCwhMCksdGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBRbigwLHQpO3RoaXMuY2hlY2tUb29GZXdQb2ludHMoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3ModCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IFFuKDAsdCk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0NvbnNpc3RlbnRBcmVhKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tIb2xlc0luU2hlbGwodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKHQsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO3RoaXMuY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnMoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEF0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4pLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3MobiksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWNvbnN0IGU9bmV3IFFuKDAsdCk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0NvbnNpc3RlbnRBcmVhKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpKXJldHVybiBudWxsO2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pO2lmKHRoaXMuY2hlY2tIb2xlc0luU2hlbGwocyxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKHMsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWlmKHRoaXMuY2hlY2tTaGVsbHNOb3ROZXN0ZWQodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgX3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKHRoaXMuY2hlY2tWYWxpZChuKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLl92YWxpZEVycj1udWxsLHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBQdCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgTXQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIER0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgYnQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEF0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIF90KSl0aHJvdyBuZXcgWih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmNoZWNrVmFsaWQodCl9fX1zZXRTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCh0KXt0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkPXR9Y2hlY2tTaGVsbE5vdE5lc3RlZCh0LGUsbil7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldEV4dGVyaW9yUmluZygpLHI9aS5nZXRDb29yZGluYXRlcygpLG89Q3IuZmluZFB0Tm90Tm9kZShzLGksbik7aWYobnVsbD09PW8pcmV0dXJuIG51bGw7aWYoIVdlLmlzSW5SaW5nKG8scikpcmV0dXJuIG51bGw7aWYoZS5nZXROdW1JbnRlcmlvclJpbmcoKTw9MClyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLk5FU1RFRF9TSEVMTFMsbyksbnVsbDtsZXQgbD1udWxsO2ZvcihsZXQgcz0wO3M8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe2NvbnN0IGk9ZS5nZXRJbnRlcmlvclJpbmdOKHMpO2lmKGw9dGhpcy5jaGVja1NoZWxsSW5zaWRlSG9sZSh0LGksbiksbnVsbD09PWwpcmV0dXJuIG51bGx9dGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLk5FU1RFRF9TSEVMTFMsbCl9Y2hlY2tDbG9zZWRSaW5ncyh0KXtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0LmdldEV4dGVyaW9yUmluZygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0LmdldEludGVyaW9yUmluZ04oZSkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1jaGVja0Nsb3NlZFJpbmcodCl7aWYoIXQuaXNDbG9zZWQoKSl7bGV0IGU9bnVsbDt0LmdldE51bVBvaW50cygpPj0xJiYoZT10LmdldENvb3JkaW5hdGVOKDApKSx0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuUklOR19OT1RfQ0xPU0VELGUpfX1jaGVja1NoZWxsc05vdE5lc3RlZCh0LGUpe2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pLmdldEV4dGVyaW9yUmluZygpO2ZvcihsZXQgaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXtpZihuPT09aSljb250aW51ZTtjb25zdCByPXQuZ2V0R2VvbWV0cnlOKGkpO2lmKHRoaXMuY2hlY2tTaGVsbE5vdE5lc3RlZChzLHIsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX19Z2V0Q2xhc3MoKXtyZXR1cm4gQ3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUNyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3BhcmVudEdlb21ldHJ5PW51bGwsdGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZD0hMSx0aGlzLl92YWxpZEVycj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BhcmVudEdlb21ldHJ5PXR9O2NsYXNzIFNye2NvbnN0cnVjdG9yKCl7U3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmluZERpckVkZ2VzSW5SaW5nKHQpe2xldCBlPXQ7Y29uc3Qgbj1uZXcgeDtkb3tuLmFkZChlKSxlPWUuZ2V0TmV4dCgpLHUuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLHUuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKGUhPT10KTtyZXR1cm4gbn1zdGF0aWMgYWRkRWRnZSh0LGUsbil7aWYoZSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyluLmFkZCh0W2VdLCExKTtlbHNlIGZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKW4uYWRkKHRbZV0sITEpfXN0YXRpYyBmaW5kRWRnZVJpbmdDb250YWluaW5nKHQsZSl7Y29uc3Qgbj10LmdldFJpbmcoKSxzPW4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2xldCBpPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscj1udWxsLG89bnVsbDtmb3IobGV0IHQ9ZS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxsPWUuZ2V0UmluZygpLGE9bC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoYS5lcXVhbHMocykpY29udGludWU7aWYoIWEuY29udGFpbnMocykpY29udGludWU7aT1YLnB0Tm90SW5MaXN0KG4uZ2V0Q29vcmRpbmF0ZXMoKSxsLmdldENvb3JkaW5hdGVzKCkpO2xldCBjPSExO1dlLmlzSW5SaW5nKGksbC5nZXRDb29yZGluYXRlcygpKSYmKGM9ITApLGMmJihudWxsPT09cnx8by5jb250YWlucyhhKSkmJihyPWUsbz1yLmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpfXJldHVybiByfWlzSW5jbHVkZWQoKXtyZXR1cm4gdGhpcy5faXNJbmNsdWRlZH1nZXRDb29yZGluYXRlcygpe2lmKG51bGw9PT10aGlzLl9yaW5nUHRzKXtjb25zdCB0PW5ldyBJO2ZvcihsZXQgZT10aGlzLl9kZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldEVkZ2UoKTtTci5hZGRFZGdlKHMuZ2V0TGluZSgpLmdldENvb3JkaW5hdGVzKCksbi5nZXRFZGdlRGlyZWN0aW9uKCksdCl9dGhpcy5fcmluZ1B0cz10LnRvQ29vcmRpbmF0ZUFycmF5KCl9cmV0dXJuIHRoaXMuX3JpbmdQdHN9aXNJbmNsdWRlZFNldCgpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkU2V0fWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlcygpLCEodGhpcy5fcmluZ1B0cy5sZW5ndGg8PTMpJiYodGhpcy5nZXRSaW5nKCksQ3IuaXNWYWxpZCh0aGlzLl9yaW5nKSl9YnVpbGQodCl7bGV0IGU9dDtkb3t0aGlzLmFkZChlKSxlLnNldFJpbmcodGhpcyksZT1lLmdldE5leHQoKSx1LmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSx1LmlzVHJ1ZShlPT09dHx8IWUuaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShlIT09dCl9aXNPdXRlckhvbGUoKXtyZXR1cm4hIXRoaXMuX2lzSG9sZSYmIXRoaXMuaGFzU2hlbGwoKX1nZXRQb2x5Z29uKCl7bGV0IHQ9bnVsbDtpZihudWxsIT09dGhpcy5faG9sZXMpe3Q9bmV3IEFycmF5KHRoaXMuX2hvbGVzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLnNpemUoKTtlKyspdFtlXT10aGlzLl9ob2xlcy5nZXQoZSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbih0aGlzLl9yaW5nLHQpfWlzSG9sZSgpe3JldHVybiB0aGlzLl9pc0hvbGV9aXNQcm9jZXNzZWQoKXtyZXR1cm4gdGhpcy5faXNQcm9jZXNzZWR9YWRkSG9sZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9ob2xlcyYmKHRoaXMuX2hvbGVzPW5ldyB4KSx0aGlzLl9ob2xlcy5hZGQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFNyKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LnNldFNoZWxsKHRoaXMpO2NvbnN0IGU9dC5nZXRSaW5nKCk7bnVsbD09PXRoaXMuX2hvbGVzJiYodGhpcy5faG9sZXM9bmV3IHgpLHRoaXMuX2hvbGVzLmFkZChlKX19c2V0SW5jbHVkZWQodCl7dGhpcy5faXNJbmNsdWRlZD10LHRoaXMuX2lzSW5jbHVkZWRTZXQ9ITB9Z2V0T3V0ZXJIb2xlKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IHQ9MDt0PHRoaXMuX2RlTGlzdC5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX2RlTGlzdC5nZXQodCkuZ2V0U3ltKCkuZ2V0UmluZygpO2lmKGUuaXNPdXRlckhvbGUoKSlyZXR1cm4gZX1yZXR1cm4gbnVsbH1jb21wdXRlSG9sZSgpe2NvbnN0IHQ9dGhpcy5nZXRSaW5nKCk7dGhpcy5faXNIb2xlPXYuaXNDQ1codC5nZXRDb29yZGluYXRlcygpKX1oYXNTaGVsbCgpe3JldHVybiBudWxsIT09dGhpcy5fc2hlbGx9aXNPdXRlclNoZWxsKCl7cmV0dXJuIG51bGwhPT10aGlzLmdldE91dGVySG9sZSgpfWdldExpbmVTdHJpbmcoKXtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLl9yaW5nUHRzKX10b1N0cmluZygpe3JldHVybiBKdC50b0xpbmVTdHJpbmcobmV3IHp0KHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSkpfWdldFNoZWxsKCl7cmV0dXJuIHRoaXMuaXNIb2xlKCk/dGhpcy5fc2hlbGw6dGhpc31hZGQodCl7dGhpcy5fZGVMaXN0LmFkZCh0KX1nZXRSaW5nKCl7aWYobnVsbCE9PXRoaXMuX3JpbmcpcmV0dXJuIHRoaXMuX3Jpbmc7dGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMuX3JpbmdQdHMubGVuZ3RoPDMmJk8ub3V0LnByaW50bG4odGhpcy5fcmluZ1B0cyk7dHJ5e3RoaXMuX3Jpbmc9dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuX3JpbmdQdHMpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIEMpKXRocm93IHQ7Ty5vdXQucHJpbnRsbih0aGlzLl9yaW5nUHRzKX1yZXR1cm4gdGhpcy5fcmluZ311cGRhdGVJbmNsdWRlZCgpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKGxldCB0PTA7dDx0aGlzLl9kZUxpc3Quc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9kZUxpc3QuZ2V0KHQpLmdldFN5bSgpLmdldFJpbmcoKS5nZXRTaGVsbCgpO2lmKG51bGwhPT1lJiZlLmlzSW5jbHVkZWRTZXQoKSlyZXR1cm4gdGhpcy5zZXRJbmNsdWRlZCghZS5pc0luY2x1ZGVkKCkpLG51bGx9fXNldFNoZWxsKHQpe3RoaXMuX3NoZWxsPXR9c2V0UHJvY2Vzc2VkKHQpe3RoaXMuX2lzUHJvY2Vzc2VkPXR9Z2V0Q2xhc3MoKXtyZXR1cm4gU3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHdye2NvbnN0cnVjdG9yKCl7d3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wYXJlKHQsZSl7Y29uc3Qgbj1lO3JldHVybiB0LmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpLmNvbXBhcmVUbyhuLmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpKX1nZXRDbGFzcygpe3JldHVybiB3cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fXdyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sU3IuRW52ZWxvcGVDb21wYXJhdG9yPXdyLFNyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9kZUxpc3Q9bmV3IHgsdGhpcy5fbG93ZXN0RWRnZT1udWxsLHRoaXMuX3Jpbmc9bnVsbCx0aGlzLl9yaW5nUHRzPW51bGwsdGhpcy5faG9sZXM9bnVsbCx0aGlzLl9zaGVsbD1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuX2lzUHJvY2Vzc2VkPSExLHRoaXMuX2lzSW5jbHVkZWRTZXQ9ITEsdGhpcy5faXNJbmNsdWRlZD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9O2NsYXNzIExyIGV4dGVuZHMgQml7Y29uc3RydWN0b3IoKXtzdXBlcigpLExyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGZpbmRMYWJlbGVkRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IHg7bGV0IG49MTtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtpZih0LmlzTWFya2VkKCkpY29udGludWU7aWYodC5nZXRMYWJlbCgpPj0wKWNvbnRpbnVlO2UuYWRkKHQpO2NvbnN0IGk9U3IuZmluZERpckVkZ2VzSW5SaW5nKHQpO0xyLmxhYmVsKGksbiksbisrfXJldHVybiBlfXN0YXRpYyBnZXREZWdyZWVOb25EZWxldGVkKHQpe2xldCBlPTA7Zm9yKGxldCBuPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5pc01hcmtlZCgpfHxlKyt9cmV0dXJuIGV9c3RhdGljIGRlbGV0ZUFsbEVkZ2VzKHQpe2ZvcihsZXQgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LnNldE1hcmtlZCghMCk7Y29uc3Qgbj10LmdldFN5bSgpO251bGwhPT1uJiZuLnNldE1hcmtlZCghMCl9fXN0YXRpYyBsYWJlbCh0LGUpe2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5zZXRMYWJlbChlKX19c3RhdGljIGNvbXB1dGVOZXh0Q1dFZGdlcyh0KXtsZXQgZT1udWxsLG49bnVsbDtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7aWYoIXQuaXNNYXJrZWQoKSl7aWYobnVsbD09PWUmJihlPXQpLG51bGwhPT1uKXtuLmdldFN5bSgpLnNldE5leHQodCl9bj10fX1pZihudWxsIT09bil7bi5nZXRTeW0oKS5zZXROZXh0KGUpfX1zdGF0aWMgY29tcHV0ZU5leHRDQ1dFZGdlcyh0LGUpe2xldCBuPW51bGwscz1udWxsO2NvbnN0IGk9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCk7Zm9yKGxldCB0PWkuc2l6ZSgpLTE7dD49MDt0LS0pe2NvbnN0IHI9aS5nZXQodCksbz1yLmdldFN5bSgpO2xldCBsPW51bGw7ci5nZXRMYWJlbCgpPT09ZSYmKGw9cik7bGV0IGE9bnVsbDtvLmdldExhYmVsKCk9PT1lJiYoYT1vKSxudWxsPT09bCYmbnVsbD09PWF8fChudWxsIT09YSYmKHM9YSksbnVsbCE9PWwmJihudWxsIT09cyYmKHMuc2V0TmV4dChsKSxzPW51bGwpLG51bGw9PT1uJiYobj1sKSkpfW51bGwhPT1zJiYodS5pc1RydWUobnVsbCE9PW4pLHMuc2V0TmV4dChuKSl9c3RhdGljIGdldERlZ3JlZSh0LGUpe2xldCBuPTA7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtzLm5leHQoKS5nZXRMYWJlbCgpPT09ZSYmbisrfXJldHVybiBufXN0YXRpYyBmaW5kSW50ZXJzZWN0aW9uTm9kZXModCxlKXtsZXQgbj10LHM9bnVsbDtkb3tjb25zdCBpPW4uZ2V0RnJvbU5vZGUoKTtMci5nZXREZWdyZWUoaSxlKT4xJiYobnVsbD09PXMmJihzPW5ldyB4KSxzLmFkZChpKSksbj1uLmdldE5leHQoKSx1LmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSx1LmlzVHJ1ZShuPT09dHx8IW4uaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShuIT09dCk7cmV0dXJuIHN9ZmluZEVkZ2VSaW5nKHQpe2NvbnN0IGU9bmV3IFNyKHRoaXMuX2ZhY3RvcnkpO3JldHVybiBlLmJ1aWxkKHQpLGV9Y29tcHV0ZURlcHRoUGFyaXR5KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKDs7KXJldHVybiBudWxsfWNvbXB1dGVOZXh0Q1dFZGdlcygpe2ZvcihsZXQgdD10aGlzLm5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtMci5jb21wdXRlTmV4dENXRWRnZXMoZSl9fWFkZEVkZ2UodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgZT1YLnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8MilyZXR1cm4gbnVsbDtjb25zdCBuPWVbMF0scz1lW2UubGVuZ3RoLTFdLGk9dGhpcy5nZXROb2RlKG4pLHI9dGhpcy5nZXROb2RlKHMpLG89bmV3IHVyKGkscixlWzFdLCEwKSxsPW5ldyB1cihyLGksZVtlLmxlbmd0aC0yXSwhMSksYT1uZXcgZ3IodCk7YS5zZXREaXJlY3RlZEVkZ2VzKG8sbCksdGhpcy5hZGQoYSl9ZGVsZXRlQ3V0RWRnZXMoKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLExyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuX2RpckVkZ2VzKTtjb25zdCB0PW5ldyB4O2ZvcihsZXQgZT10aGlzLl9kaXJFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZihuLmlzTWFya2VkKCkpY29udGludWU7Y29uc3Qgcz1uLmdldFN5bSgpO2lmKG4uZ2V0TGFiZWwoKT09PXMuZ2V0TGFiZWwoKSl7bi5zZXRNYXJrZWQoITApLHMuc2V0TWFya2VkKCEwKTtjb25zdCBlPW4uZ2V0RWRnZSgpO3QuYWRkKGUuZ2V0TGluZSgpKX19cmV0dXJuIHR9Z2V0RWRnZVJpbmdzKCl7dGhpcy5jb21wdXRlTmV4dENXRWRnZXMoKSxMci5sYWJlbCh0aGlzLl9kaXJFZGdlcywtMSk7Y29uc3QgdD1Mci5maW5kTGFiZWxlZEVkZ2VSaW5ncyh0aGlzLl9kaXJFZGdlcyk7dGhpcy5jb252ZXJ0TWF4aW1hbFRvTWluaW1hbEVkZ2VSaW5ncyh0KTtjb25zdCBlPW5ldyB4O2ZvcihsZXQgdD10aGlzLl9kaXJFZGdlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKTtpZihuLmlzTWFya2VkKCkpY29udGludWU7aWYobi5pc0luUmluZygpKWNvbnRpbnVlO2NvbnN0IHM9dGhpcy5maW5kRWRnZVJpbmcobik7ZS5hZGQocyl9cmV0dXJuIGV9Z2V0Tm9kZSh0KXtsZXQgZT10aGlzLmZpbmROb2RlKHQpO3JldHVybiBudWxsPT09ZSYmKGU9bmV3IEZpKHQpLHRoaXMuYWRkKGUpKSxlfWNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRMYWJlbCgpLHM9THIuZmluZEludGVyc2VjdGlvbk5vZGVzKHQsbik7aWYobnVsbCE9PXMpZm9yKGxldCB0PXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7THIuY29tcHV0ZU5leHRDQ1dFZGdlcyhlLG4pfX19ZGVsZXRlRGFuZ2xlcygpe2NvbnN0IHQ9dGhpcy5maW5kTm9kZXNPZkRlZ3JlZSgxKSxlPW5ldyBKLG49bmV3IG9uO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KW4ucHVzaChlLm5leHQoKSk7Zm9yKDshbi5pc0VtcHR5KCk7KXtjb25zdCB0PW4ucG9wKCk7THIuZGVsZXRlQWxsRWRnZXModCk7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3Quc2V0TWFya2VkKCEwKTtjb25zdCBpPXQuZ2V0U3ltKCk7bnVsbCE9PWkmJmkuc2V0TWFya2VkKCEwKTtjb25zdCByPXQuZ2V0RWRnZSgpO2UuYWRkKHIuZ2V0TGluZSgpKTtjb25zdCBvPXQuZ2V0VG9Ob2RlKCk7MT09PUxyLmdldERlZ3JlZU5vbkRlbGV0ZWQobykmJm4ucHVzaChvKX19cmV0dXJuIGV9Z2V0Q2xhc3MoKXtyZXR1cm4gTHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUxyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2ZhY3Rvcnk9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9O2NsYXNzIFRye2NvbnN0cnVjdG9yKCl7VHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmluZE91dGVyU2hlbGxzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRPdXRlckhvbGUoKTtudWxsPT09bnx8bi5pc1Byb2Nlc3NlZCgpfHwodC5zZXRJbmNsdWRlZCghMCksbi5zZXRQcm9jZXNzZWQoITApKX19c3RhdGljIGV4dHJhY3RQb2x5Z29ucyh0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7KGV8fHQuaXNJbmNsdWRlZCgpKSYmbi5hZGQodC5nZXRQb2x5Z29uKCkpfXJldHVybiBufXN0YXRpYyBhc3NpZ25Ib2xlc1RvU2hlbGxzKHQsZSl7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7VHIuYXNzaWduSG9sZVRvU2hlbGwodCxlKX19c3RhdGljIGFzc2lnbkhvbGVUb1NoZWxsKHQsZSl7Y29uc3Qgbj1Tci5maW5kRWRnZVJpbmdDb250YWluaW5nKHQsZSk7bnVsbCE9PW4mJm4uYWRkSG9sZSh0KX1zdGF0aWMgZmluZERpc2pvaW50U2hlbGxzKHQpe1RyLmZpbmRPdXRlclNoZWxscyh0KTtsZXQgZT1udWxsO2Rve2U9ITE7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dC5pc0luY2x1ZGVkU2V0KCl8fCh0LnVwZGF0ZUluY2x1ZGVkKCksdC5pc0luY2x1ZGVkU2V0KCl8fChlPSEwKSl9fXdoaWxlKGUpfWdldEdlb21ldHJ5KCl7cmV0dXJuIG51bGw9PT10aGlzLl9nZW9tRmFjdG9yeSYmKHRoaXMuX2dlb21GYWN0b3J5PW5ldyBIdCksdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWw/dGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLl9wb2x5TGlzdCk6dGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEh0LnRvR2VvbWV0cnlBcnJheSh0aGlzLl9wb2x5TGlzdCkpfWdldEludmFsaWRSaW5nTGluZXMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5faW52YWxpZFJpbmdMaW5lc31maW5kVmFsaWRSaW5ncyh0LGUsbil7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5pc1ZhbGlkKCk/ZS5hZGQodCk6bi5hZGQodC5nZXRMaW5lU3RyaW5nKCkpfX1wb2x5Z29uaXplKCl7aWYobnVsbCE9PXRoaXMuX3BvbHlMaXN0KXJldHVybiBudWxsO2lmKHRoaXMuX3BvbHlMaXN0PW5ldyB4LG51bGw9PT10aGlzLl9ncmFwaClyZXR1cm4gbnVsbDt0aGlzLl9kYW5nbGVzPXRoaXMuX2dyYXBoLmRlbGV0ZURhbmdsZXMoKSx0aGlzLl9jdXRFZGdlcz10aGlzLl9ncmFwaC5kZWxldGVDdXRFZGdlcygpO2NvbnN0IHQ9dGhpcy5fZ3JhcGguZ2V0RWRnZVJpbmdzKCk7bGV0IGU9bmV3IHg7dGhpcy5faW52YWxpZFJpbmdMaW5lcz1uZXcgeCx0aGlzLl9pc0NoZWNraW5nUmluZ3NWYWxpZD90aGlzLmZpbmRWYWxpZFJpbmdzKHQsZSx0aGlzLl9pbnZhbGlkUmluZ0xpbmVzKTplPXQsdGhpcy5maW5kU2hlbGxzQW5kSG9sZXMoZSksVHIuYXNzaWduSG9sZXNUb1NoZWxscyh0aGlzLl9ob2xlTGlzdCx0aGlzLl9zaGVsbExpc3QpLEVlLnNvcnQodGhpcy5fc2hlbGxMaXN0LG5ldyBTci5FbnZlbG9wZUNvbXBhcmF0b3IpO2xldCBuPSEwO3RoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsJiYoVHIuZmluZERpc2pvaW50U2hlbGxzKHRoaXMuX3NoZWxsTGlzdCksbj0hMSksdGhpcy5fcG9seUxpc3Q9VHIuZXh0cmFjdFBvbHlnb25zKHRoaXMuX3NoZWxsTGlzdCxuKX1nZXREYW5nbGVzKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2RhbmdsZXN9Z2V0Q3V0RWRnZXMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fY3V0RWRnZXN9Z2V0UG9seWdvbnMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fcG9seUxpc3R9YWRkKCl7aWYoXyhhcmd1bWVudHNbMF0sZikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGQoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksbnVsbD09PXRoaXMuX2dyYXBoJiYodGhpcy5fZ3JhcGg9bmV3IExyKHRoaXMuX2dlb21GYWN0b3J5KSksdGhpcy5fZ3JhcGguYWRkRWRnZSh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7YXJndW1lbnRzWzBdLmFwcGx5KHRoaXMuX2xpbmVTdHJpbmdBZGRlcil9fXNldENoZWNrUmluZ3NWYWxpZCh0KXt0aGlzLl9pc0NoZWNraW5nUmluZ3NWYWxpZD10fWZpbmRTaGVsbHNBbmRIb2xlcyh0KXt0aGlzLl9ob2xlTGlzdD1uZXcgeCx0aGlzLl9zaGVsbExpc3Q9bmV3IHg7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5jb21wdXRlSG9sZSgpLHQuaXNIb2xlKCk/dGhpcy5faG9sZUxpc3QuYWRkKHQpOnRoaXMuX3NoZWxsTGlzdC5hZGQodCl9fWdldENsYXNzKCl7cmV0dXJuIFRyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBScntjb25zdHJ1Y3Rvcigpe1JyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBUdCYmdGhpcy5wLmFkZCh0KX1nZXRDbGFzcygpe3JldHVybiBScn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR119fVJyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMucD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucD10fSxUci5MaW5lU3RyaW5nQWRkZXI9UnIsVHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbGluZVN0cmluZ0FkZGVyPW5ldyBScih0aGlzKSx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2RhbmdsZXM9bmV3IHgsdGhpcy5fY3V0RWRnZXM9bmV3IHgsdGhpcy5faW52YWxpZFJpbmdMaW5lcz1uZXcgeCx0aGlzLl9ob2xlTGlzdD1udWxsLHRoaXMuX3NoZWxsTGlzdD1udWxsLHRoaXMuX3BvbHlMaXN0PW51bGwsdGhpcy5faXNDaGVja2luZ1JpbmdzVmFsaWQ9ITAsdGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWw9bnVsbCx0aGlzLl9nZW9tRmFjdG9yeT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKVRyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsITEpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsPXR9fTt2YXIgUHI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsUG9seWdvbml6ZXI6VHJ9KTtjbGFzcyB2cntjb25zdHJ1Y3Rvcigpe3ZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0RWRnZUVuZHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkKHQpfX1jb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU0odCxlKXtjb25zdCBuPXRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLmdldERpbWVuc2lvbigpLHM9dGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCksaT10Lmhhc1Byb3BlckludGVyc2VjdGlvbigpLHI9dC5oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpOzI9PT1uJiYyPT09cz9pJiZlLnNldEF0TGVhc3QoXCIyMTIxMDEyMTJcIik6Mj09PW4mJjE9PT1zPyhpJiZlLnNldEF0TGVhc3QoXCJGRkYwRkZGRjJcIiksciYmZS5zZXRBdExlYXN0KFwiMUZGRkZGMUZGXCIpKToxPT09biYmMj09PXM/KGkmJmUuc2V0QXRMZWFzdChcIkYwRkZGRkZGMlwiKSxyJiZlLnNldEF0TGVhc3QoXCIxRjFGRkZGRkZcIikpOjE9PT1uJiYxPT09cyYmciYmZS5zZXRBdExlYXN0KFwiMEZGRkZGRkZGXCIpfWxhYmVsSXNvbGF0ZWRFZGdlcyh0LGUpe2ZvcihsZXQgbj10aGlzLl9hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3QuaXNJc29sYXRlZCgpJiYodGhpcy5sYWJlbElzb2xhdGVkRWRnZSh0LGUsdGhpcy5fYXJnW2VdLmdldEdlb21ldHJ5KCkpLHRoaXMuX2lzb2xhdGVkRWRnZXMuYWRkKHQpKX19bGFiZWxJc29sYXRlZEVkZ2UodCxlLG4pe2lmKG4uZ2V0RGltZW5zaW9uKCk+MCl7Y29uc3Qgcz10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLG4pO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxzKX1lbHNlIHQuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxuZS5FWFRFUklPUil9Y29tcHV0ZUlNKCl7Y29uc3QgdD1uZXcgc2U7aWYodC5zZXQobmUuRVhURVJJT1IsbmUuRVhURVJJT1IsMiksIXRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuIHRoaXMuY29tcHV0ZURpc2pvaW50SU0odCksdDt0aGlzLl9hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSksdGhpcy5fYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpO2NvbnN0IGU9dGhpcy5fYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLl9hcmdbMV0sdGhpcy5fbGksITEpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDApLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDEpLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDEpLHRoaXMubGFiZWxJc29sYXRlZE5vZGVzKCksdGhpcy5jb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU0oZSx0KTtjb25zdCBuPW5ldyBfcixzPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuX2FyZ1swXS5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhzKTtjb25zdCBpPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuX2FyZ1sxXS5nZXRFZGdlSXRlcmF0b3IoKSk7cmV0dXJuIHRoaXMuaW5zZXJ0RWRnZUVuZHMoaSksdGhpcy5sYWJlbE5vZGVFZGdlcygpLHRoaXMubGFiZWxJc29sYXRlZEVkZ2VzKDAsMSksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMSwwKSx0aGlzLnVwZGF0ZUlNKHQpLHR9bGFiZWxOb2RlRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLl9hcmcpfX1jb3B5Tm9kZXNBbmRMYWJlbHModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkTm9kZShuLmdldENvb3JkaW5hdGUoKSkuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX1sYWJlbEludGVyc2VjdGlvbk5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2ZvcihsZXQgZT1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCksaT10aGlzLl9ub2Rlcy5maW5kKG4uY29vcmQpO2kuZ2V0TGFiZWwoKS5pc051bGwodCkmJihzPT09bmUuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KHQpOmkuc2V0TGFiZWwodCxuZS5JTlRFUklPUikpfX19bGFiZWxJc29sYXRlZE5vZGUodCxlKXtjb25zdCBuPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5fYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxuKX1jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxpPXRoaXMuX25vZGVzLmFkZE5vZGUobi5jb29yZCk7cz09PW5lLkJPVU5EQVJZP2kuc2V0TGFiZWxCb3VuZGFyeSh0KTppLmdldExhYmVsKCkuaXNOdWxsKHQpJiZpLnNldExhYmVsKHQsbmUuSU5URVJJT1IpfX19bGFiZWxJc29sYXRlZE5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO3UuaXNUcnVlKG4uZ2V0R2VvbWV0cnlDb3VudCgpPjAsXCJub2RlIHdpdGggZW1wdHkgbGFiZWwgZm91bmRcIiksZS5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMCk6dGhpcy5sYWJlbElzb2xhdGVkTm9kZShlLDEpKX19dXBkYXRlSU0odCl7Zm9yKGxldCBlPXRoaXMuX2lzb2xhdGVkRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnVwZGF0ZUlNKHQpfWZvcihsZXQgZT10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtuLnVwZGF0ZUlNKHQpLG4udXBkYXRlSU1Gcm9tRWRnZXModCl9fWNvbXB1dGVEaXNqb2ludElNKHQpe2NvbnN0IGU9dGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCk7ZS5pc0VtcHR5KCl8fCh0LnNldChuZS5JTlRFUklPUixuZS5FWFRFUklPUixlLmdldERpbWVuc2lvbigpKSx0LnNldChuZS5CT1VOREFSWSxuZS5FWFRFUklPUixlLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKTtjb25zdCBuPXRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpO24uaXNFbXB0eSgpfHwodC5zZXQobmUuRVhURVJJT1IsbmUuSU5URVJJT1Isbi5nZXREaW1lbnNpb24oKSksdC5zZXQobmUuRVhURVJJT1IsbmUuQk9VTkRBUlksbi5nZXRCb3VuZGFyeURpbWVuc2lvbigpKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gdnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXZyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW5ldyB0ZSx0aGlzLl9wdExvY2F0b3I9bmV3IF9uLHRoaXMuX2FyZz1udWxsLHRoaXMuX25vZGVzPW5ldyBYbihuZXcgeXIpLHRoaXMuX2ltPW51bGwsdGhpcy5faXNvbGF0ZWRFZGdlcz1uZXcgeCx0aGlzLl9pbnZhbGlkUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9hcmc9dH07Y2xhc3MgT3J7Y29uc3RydWN0b3IoKXtPci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb250YWlucyh0LGUpe3JldHVybiBuZXcgT3IodCkuY29udGFpbnMoZSl9aXNDb250YWluZWRJbkJvdW5kYXJ5KHQpe2lmKHQgaW5zdGFuY2VvZiBidClyZXR1cm4hMTtpZih0IGluc3RhbmNlb2YgUHQpcmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodCk7aWYodCBpbnN0YW5jZW9mIFR0KXJldHVybiB0aGlzLmlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnkodCk7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KG4pKXJldHVybiExfXJldHVybiEwfWlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5KHQsZSl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodCk7aWYodC54PT09ZS54KXtpZih0Lng9PT10aGlzLl9yZWN0RW52LmdldE1pblgoKXx8dC54PT09dGhpcy5fcmVjdEVudi5nZXRNYXhYKCkpcmV0dXJuITB9ZWxzZSBpZih0Lnk9PT1lLnkmJih0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1pblkoKXx8dC55PT09dGhpcy5fcmVjdEVudi5nZXRNYXhZKCkpKXJldHVybiEwO3JldHVybiExfWlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnkodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49bmV3IGcscz1uZXcgZztmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpLTE7dCsrKWlmKGUuZ2V0Q29vcmRpbmF0ZSh0LG4pLGUuZ2V0Q29vcmRpbmF0ZSh0KzEscyksIXRoaXMuaXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnkobixzKSlyZXR1cm4hMTtyZXR1cm4hMH1pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQuZ2V0Q29vcmRpbmF0ZSgpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0Lng9PT10aGlzLl9yZWN0RW52LmdldE1pblgoKXx8dC54PT09dGhpcy5fcmVjdEVudi5nZXRNYXhYKCl8fHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpfHx0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1heFkoKX19Y29udGFpbnModCl7cmV0dXJuISF0aGlzLl9yZWN0RW52LmNvbnRhaW5zKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmIXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KHQpfWdldENsYXNzKCl7cmV0dXJuIE9yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Pci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yZWN0RW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX07Y2xhc3MgYnJ7Y29uc3RydWN0b3IoKXtici5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWludGVyc2VjdHModCxlKXtjb25zdCBuPW5ldyBOKHQsZSk7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhuKSlyZXR1cm4hMTtpZih0aGlzLl9yZWN0RW52LmludGVyc2VjdHModCkpcmV0dXJuITA7aWYodGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiEwO2lmKHQuY29tcGFyZVRvKGUpPjApe2NvbnN0IG49dDt0PWUsZT1ufWxldCBzPSExO3JldHVybiBlLnk+dC55JiYocz0hMCkscz90aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9kaWFnRG93bjAsdGhpcy5fZGlhZ0Rvd24xKTp0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9kaWFnVXAwLHRoaXMuX2RpYWdVcDEpLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gYnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWJyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW5ldyB0ZSx0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5fZGlhZ1VwMD1udWxsLHRoaXMuX2RpYWdVcDE9bnVsbCx0aGlzLl9kaWFnRG93bjA9bnVsbCx0aGlzLl9kaWFnRG93bjE9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQsdGhpcy5fZGlhZ1VwMD1uZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSksdGhpcy5fZGlhZ1VwMT1uZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSksdGhpcy5fZGlhZ0Rvd24wPW5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSx0aGlzLl9kaWFnRG93bjE9bmV3IGcodC5nZXRNYXhYKCksdC5nZXRNaW5ZKCkpfTtjbGFzcyBNcntjb25zdHJ1Y3Rvcigpe01yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGludGVyc2VjdHModCxlKXtyZXR1cm4gbmV3IE1yKHQpLmludGVyc2VjdHMoZSl9aW50ZXJzZWN0cyh0KXtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTtjb25zdCBlPW5ldyBEcih0aGlzLl9yZWN0RW52KTtpZihlLmFwcGx5VG8odCksZS5pbnRlcnNlY3RzKCkpcmV0dXJuITA7Y29uc3Qgbj1uZXcgQXIodGhpcy5fcmVjdGFuZ2xlKTtpZihuLmFwcGx5VG8odCksbi5jb250YWluc1BvaW50KCkpcmV0dXJuITA7Y29uc3Qgcz1uZXcgRnIodGhpcy5fcmVjdGFuZ2xlKTtyZXR1cm4gcy5hcHBseVRvKHQpLCEhcy5pbnRlcnNlY3RzKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gTXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU1yLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3JlY3RhbmdsZT1udWxsLHRoaXMuX3JlY3RFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0YW5nbGU9dCx0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfTtjbGFzcyBEciBleHRlbmRzIENle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxEci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzRG9uZSgpe3JldHVybiEwPT09dGhpcy5faW50ZXJzZWN0c312aXNpdCh0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiB0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSk/dGhpcy5fcmVjdEVudi5jb250YWlucyhlKXx8ZS5nZXRNaW5YKCk+PXRoaXMuX3JlY3RFbnYuZ2V0TWluWCgpJiZlLmdldE1heFgoKTw9dGhpcy5fcmVjdEVudi5nZXRNYXhYKCl8fGUuZ2V0TWluWSgpPj10aGlzLl9yZWN0RW52LmdldE1pblkoKSYmZS5nZXRNYXhZKCk8PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WSgpPyh0aGlzLl9pbnRlcnNlY3RzPSEwLG51bGwpOnZvaWQgMDpudWxsfWludGVyc2VjdHMoKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0c31nZXRDbGFzcygpe3JldHVybiBEcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX2ludGVyc2VjdHM9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10fTtjbGFzcyBBciBleHRlbmRzIENle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxBci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzRG9uZSgpe3JldHVybiEwPT09dGhpcy5fY29udGFpbnNQb2ludH12aXNpdCh0KXtpZighKHQgaW5zdGFuY2VvZiBidCkpcmV0dXJuIG51bGw7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiBudWxsO2NvbnN0IG49bmV3IGc7Zm9yKGxldCBzPTA7czw0O3MrKylpZih0aGlzLl9yZWN0U2VxLmdldENvb3JkaW5hdGUocyxuKSxlLmNvbnRhaW5zKG4pJiZaZS5jb250YWluc1BvaW50SW5Qb2x5Z29uKG4sdCkpcmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnQ9ITAsbnVsbH1jb250YWluc1BvaW50KCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnR9Z2V0Q2xhc3MoKXtyZXR1cm4gQXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUFyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3JlY3RTZXE9bnVsbCx0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5fY29udGFpbnNQb2ludD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0U2VxPXQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX07Y2xhc3MgRnIgZXh0ZW5kcyBDZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnRlcnNlY3RzKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4hMD09PXRoaXMuX2hhc0ludGVyc2VjdGlvbn12aXNpdCh0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj14ZS5nZXRMaW5lcyh0KTt0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzKG4pfWNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKHRoaXMuY2hlY2tJbnRlcnNlY3Rpb25XaXRoU2VnbWVudHModCksdGhpcy5faGFzSW50ZXJzZWN0aW9uKXJldHVybiBudWxsfX1jaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50cyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7Zm9yKGxldCB0PTE7dDxlLnNpemUoKTt0KyspaWYoZS5nZXRDb29yZGluYXRlKHQtMSx0aGlzLl9wMCksZS5nZXRDb29yZGluYXRlKHQsdGhpcy5fcDEpLHRoaXMuX3JlY3RJbnRlcnNlY3Rvci5pbnRlcnNlY3RzKHRoaXMuX3AwLHRoaXMuX3AxKSlyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLG51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gRnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUZyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9yZWN0SW50ZXJzZWN0b3I9bnVsbCx0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5fcDA9bmV3IGcsdGhpcy5fcDE9bmV3IGc7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKSx0aGlzLl9yZWN0SW50ZXJzZWN0b3I9bmV3IGJyKHRoaXMuX3JlY3RFbnYpfTtjbGFzcyBHciBleHRlbmRzIGFye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxHci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb3ZlcnModCxlKXtyZXR1cm4hKDI9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDIpJiYoISgxPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwxJiZlLmdldExlbmd0aCgpPjApJiYoISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb3ZlcnMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYoISF0LmlzUmVjdGFuZ2xlKCl8fG5ldyBHcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzQ292ZXJzKCkpKSl9c3RhdGljIGludGVyc2VjdHModCxlKXtpZighdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuITE7aWYodC5pc1JlY3RhbmdsZSgpKXJldHVybiBNci5pbnRlcnNlY3RzKHQsZSk7aWYoZS5pc1JlY3RhbmdsZSgpKXJldHVybiBNci5pbnRlcnNlY3RzKGUsdCk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKWZvcihsZXQgcz0wO3M8ZS5nZXROdW1HZW9tZXRyaWVzKCk7cysrKWlmKHQuZ2V0R2VvbWV0cnlOKG4pLmludGVyc2VjdHMoZS5nZXRHZW9tZXRyeU4ocykpKXJldHVybiEwO3JldHVybiExfXJldHVybiBuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0ludGVyc2VjdHMoKX1zdGF0aWMgdG91Y2hlcyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJm5ldyBHcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzVG91Y2hlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyBlcXVhbHNUb3BvKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5lcXVhbHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZHci5yZWxhdGUodCxlKS5pc0VxdWFscyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyByZWxhdGUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBHcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbmV3IEdyKHQsZSxuKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKX19c3RhdGljIG92ZXJsYXBzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNPdmVybGFwcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyBjcm9zc2VzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDcm9zc2VzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGNvbnRhaW5zKHQsZSl7cmV0dXJuISgyPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwyKSYmKCEoMT09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MSYmZS5nZXRMZW5ndGgoKT4wKSYmKCEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuY29udGFpbnMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYodC5pc1JlY3RhbmdsZSgpP09yLmNvbnRhaW5zKHQsZSk6bmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDb250YWlucygpKSkpfWdldEludGVyc2VjdGlvbk1hdHJpeCgpe3JldHVybiB0aGlzLl9yZWxhdGUuY29tcHV0ZUlNKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gR3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUdyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3JlbGF0ZT1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy5fcmVsYXRlPW5ldyB2cih0aGlzLl9hcmcpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2FyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4pLHRoaXMuX3JlbGF0ZT1uZXcgdnIodGhpcy5fYXJnKX19O3ZhciBxcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxSZWxhdGVPcDpHcn0pO2NsYXNzIEJye2NvbnN0cnVjdG9yKCl7QnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gbmV3IEJyKHQsZSkudW5pb24oKX11bmlvbigpe2NvbnN0IHQ9bmV3IF9uLGU9bmV3IGF0O2ZvcihsZXQgbj0wO248dGhpcy5fcG9pbnRHZW9tLmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dGhpcy5fcG9pbnRHZW9tLmdldEdlb21ldHJ5TihuKS5nZXRDb29yZGluYXRlKCk7dC5sb2NhdGUocyx0aGlzLl9vdGhlckdlb20pPT09bmUuRVhURVJJT1ImJmUuYWRkKHMpfWlmKDA9PT1lLnNpemUoKSlyZXR1cm4gdGhpcy5fb3RoZXJHZW9tO2xldCBuPW51bGw7Y29uc3Qgcz1YLnRvQ29vcmRpbmF0ZUFycmF5KGUpO3JldHVybiBuPTE9PT1zLmxlbmd0aD90aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludChzWzBdKTp0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyhzKSxkZS5jb21iaW5lKG4sdGhpcy5fb3RoZXJHZW9tKX1nZXRDbGFzcygpe3JldHVybiBCcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19QnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcG9pbnRHZW9tPW51bGwsdGhpcy5fb3RoZXJHZW9tPW51bGwsdGhpcy5fZ2VvbUZhY3Q9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wb2ludEdlb209dCx0aGlzLl9vdGhlckdlb209ZSx0aGlzLl9nZW9tRmFjdD1lLmdldEZhY3RvcnkoKX07Y2xhc3MgVnJ7Y29uc3RydWN0b3IoKXtWci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyByZXN0cmljdFRvUG9seWdvbnModCl7aWYoXyh0LE90KSlyZXR1cm4gdDtjb25zdCBlPU5lLmdldFBvbHlnb25zKHQpO3JldHVybiAxPT09ZS5zaXplKCk/ZS5nZXQoMCk6dC5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKEh0LnRvUG9seWdvbkFycmF5KGUpKX1zdGF0aWMgZ2V0R2VvbWV0cnkodCxlKXtyZXR1cm4gZT49dC5zaXplKCk/bnVsbDp0LmdldChlKX1zdGF0aWMgdW5pb24odCl7cmV0dXJuIG5ldyBWcih0KS51bmlvbigpfXJlZHVjZVRvR2VvbWV0cmllcyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2xldCBzPW51bGw7Xyh0LG0pP3M9dGhpcy51bmlvblRyZWUodCk6dCBpbnN0YW5jZW9mIHEmJihzPXQpLGUuYWRkKHMpfXJldHVybiBlfWV4dHJhY3RCeUVudmVsb3BlKHQsZSxuKXtjb25zdCBzPW5ldyB4O2ZvcihsZXQgaT0wO2k8ZS5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXtjb25zdCByPWUuZ2V0R2VvbWV0cnlOKGkpO3IuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/cy5hZGQocik6bi5hZGQocil9cmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkocyl9dW5pb25PcHRpbWl6ZWQodCxlKXtjb25zdCBuPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHM9ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIW4uaW50ZXJzZWN0cyhzKSl7cmV0dXJuIGRlLmNvbWJpbmUodCxlKX1pZih0LmdldE51bUdlb21ldHJpZXMoKTw9MSYmZS5nZXROdW1HZW9tZXRyaWVzKCk8PTEpcmV0dXJuIHRoaXMudW5pb25BY3R1YWwodCxlKTtjb25zdCBpPW4uaW50ZXJzZWN0aW9uKHMpO3JldHVybiB0aGlzLnVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbih0LGUsaSl9dW5pb24oKXtpZihudWxsPT09dGhpcy5faW5wdXRQb2x5cyl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwidW5pb24oKSBtZXRob2QgY2Fubm90IGJlIGNhbGxlZCB0d2ljZVwiKTtpZih0aGlzLl9pbnB1dFBvbHlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLl9nZW9tRmFjdG9yeT10aGlzLl9pbnB1dFBvbHlzLml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKTtjb25zdCB0PW5ldyBFcyhWci5TVFJUUkVFX05PREVfQ0FQQUNJVFkpO2ZvcihsZXQgZT10aGlzLl9pbnB1dFBvbHlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3QuaW5zZXJ0KG4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG4pfXRoaXMuX2lucHV0UG9seXM9bnVsbDtjb25zdCBlPXQuaXRlbXNUcmVlKCk7cmV0dXJuIHRoaXMudW5pb25UcmVlKGUpfWJpbmFyeVVuaW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmJpbmFyeVVuaW9uKHQsMCx0LnNpemUoKSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKG4tZTw9MSl7Y29uc3Qgbj1Wci5nZXRHZW9tZXRyeSh0LGUpO3JldHVybiB0aGlzLnVuaW9uU2FmZShuLG51bGwpfWlmKG4tZT09MilyZXR1cm4gdGhpcy51bmlvblNhZmUoVnIuZ2V0R2VvbWV0cnkodCxlKSxWci5nZXRHZW9tZXRyeSh0LGUrMSkpO3tjb25zdCBzPU1hdGgudHJ1bmMoKG4rZSkvMiksaT10aGlzLmJpbmFyeVVuaW9uKHQsZSxzKSxyPXRoaXMuYmluYXJ5VW5pb24odCxzLG4pO3JldHVybiB0aGlzLnVuaW9uU2FmZShpLHIpfX19cmVwZWF0ZWRVbmlvbih0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2U9bnVsbD09PWU/dC5jb3B5KCk6ZS51bmlvbih0KX1yZXR1cm4gZX11bmlvblNhZmUodCxlKXtyZXR1cm4gbnVsbD09PXQmJm51bGw9PT1lP251bGw6bnVsbD09PXQ/ZS5jb3B5KCk6bnVsbD09PWU/dC5jb3B5KCk6dGhpcy51bmlvbk9wdGltaXplZCh0LGUpfXVuaW9uQWN0dWFsKHQsZSl7cmV0dXJuIFZyLnJlc3RyaWN0VG9Qb2x5Z29ucyh0LnVuaW9uKGUpKX11bmlvblRyZWUodCl7Y29uc3QgZT10aGlzLnJlZHVjZVRvR2VvbWV0cmllcyh0KTtyZXR1cm4gdGhpcy5iaW5hcnlVbmlvbihlKX11bmlvblVzaW5nRW52ZWxvcGVJbnRlcnNlY3Rpb24odCxlLG4pe2NvbnN0IHM9bmV3IHgsaT10aGlzLmV4dHJhY3RCeUVudmVsb3BlKG4sdCxzKSxyPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUobixlLHMpLG89dGhpcy51bmlvbkFjdHVhbChpLHIpO3JldHVybiBzLmFkZChvKSxkZS5jb21iaW5lKHMpfWJ1ZmZlclVuaW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmdldCgwKS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh0KS5idWZmZXIoMCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oW3QsZV0pLmJ1ZmZlcigwKX19Z2V0Q2xhc3MoKXtyZXR1cm4gVnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVZyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0UG9seXM9bnVsbCx0aGlzLl9nZW9tRmFjdG9yeT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0UG9seXM9dCxudWxsPT09dGhpcy5faW5wdXRQb2x5cyYmKHRoaXMuX2lucHV0UG9seXM9bmV3IHgpfSxWci5TVFJUUkVFX05PREVfQ0FQQUNJVFk9NDtjbGFzcyB6cntjb25zdHJ1Y3Rvcigpe3pyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHVuaW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IHpyKHQpLnVuaW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IHpyKHQpLnVuaW9uKCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgenIodCxlKS51bmlvbigpfX11bmlvbk5vT3B0KHQpe2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoKTtyZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5VTklPTil9dW5pb25XaXRoTnVsbCh0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09ZT90Om51bGw9PT10P2U6dC51bmlvbihlKX1leHRyYWN0KCl7aWYoXyhhcmd1bWVudHNbMF0sZikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5leHRyYWN0KGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuX2dlb21GYWN0JiYodGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCkpLF9lLmV4dHJhY3QodCxxLlRZUEVOQU1FX1BPTFlHT04sdGhpcy5fcG9seWdvbnMpLF9lLmV4dHJhY3QodCxxLlRZUEVOQU1FX0xJTkVTVFJJTkcsdGhpcy5fbGluZXMpLF9lLmV4dHJhY3QodCxxLlRZUEVOQU1FX1BPSU5ULHRoaXMuX3BvaW50cyl9fXVuaW9uKCl7aWYobnVsbD09PXRoaXMuX2dlb21GYWN0KXJldHVybiBudWxsO2xldCB0PW51bGw7aWYodGhpcy5fcG9pbnRzLnNpemUoKT4wKXtjb25zdCBlPXRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5fcG9pbnRzKTt0PXRoaXMudW5pb25Ob09wdChlKX1sZXQgZT1udWxsO2lmKHRoaXMuX2xpbmVzLnNpemUoKT4wKXtjb25zdCB0PXRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5fbGluZXMpO2U9dGhpcy51bmlvbk5vT3B0KHQpfWxldCBuPW51bGw7dGhpcy5fcG9seWdvbnMuc2l6ZSgpPjAmJihuPVZyLnVuaW9uKHRoaXMuX3BvbHlnb25zKSk7Y29uc3Qgcz10aGlzLnVuaW9uV2l0aE51bGwoZSxuKTtsZXQgaT1udWxsO3JldHVybiBpPW51bGw9PT10P3M6bnVsbD09PXM/dDpCci51bmlvbih0LHMpLG51bGw9PT1pP3RoaXMuX2dlb21GYWN0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpOml9Z2V0Q2xhc3MoKXtyZXR1cm4genJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXpyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3BvbHlnb25zPW5ldyB4LHRoaXMuX2xpbmVzPW5ldyB4LHRoaXMuX3BvaW50cz1uZXcgeCx0aGlzLl9nZW9tRmFjdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QodCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21GYWN0PWUsdGhpcy5leHRyYWN0KHQpfX07dmFyIFlyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFVuYXJ5VW5pb25PcDp6cn0pLFVyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLElzVmFsaWRPcDpDcixDb25zaXN0ZW50QXJlYVRlc3RlcjpFcn0pLGtyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEJvdW5kYXJ5T3A6cHQsSXNTaW1wbGVPcDpIcyxidWZmZXI6d2ksZGlzdGFuY2U6UGksbGluZW1lcmdlOlhpLG92ZXJsYXk6aHIscG9seWdvbml6ZTpQcixyZWxhdGU6cXIsdW5pb246WXIsdmFsaWQ6VXJ9KTtjbGFzcyBYciBleHRlbmRzIEZ0LkNvb3JkaW5hdGVPcGVyYXRpb257Y29uc3RydWN0b3IoKXtzdXBlcigpLFhyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZWRpdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHEmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgcz1uZXcgZyh0W2VdKTt0aGlzLl90YXJnZXRQTS5tYWtlUHJlY2lzZShzKSxuW2VdPXN9Y29uc3Qgcz1uZXcgSShuLCExKS50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBpPTA7ZSBpbnN0YW5jZW9mIFR0JiYoaT0yKSxlIGluc3RhbmNlb2YgRHQmJihpPTQpO2xldCByPW47cmV0dXJuIHRoaXMuX3JlbW92ZUNvbGxhcHNlZCYmKHI9bnVsbCkscy5sZW5ndGg8aT9yOnN9cmV0dXJuIHN1cGVyLmVkaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIFhyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Yci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl90YXJnZXRQTT1udWxsLHRoaXMuX3JlbW92ZUNvbGxhcHNlZD0hMDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl90YXJnZXRQTT10LHRoaXMuX3JlbW92ZUNvbGxhcHNlZD1lfTtjbGFzcyBIcntjb25zdHJ1Y3Rvcigpe0hyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHJlZHVjZSh0LGUpe3JldHVybiBuZXcgSHIoZSkucmVkdWNlKHQpfXN0YXRpYyByZWR1Y2VQb2ludHdpc2UodCxlKXtjb25zdCBuPW5ldyBIcihlKTtyZXR1cm4gbi5zZXRQb2ludHdpc2UoITApLG4ucmVkdWNlKHQpfWZpeFBvbHlnb25hbFRvcG9sb2d5KHQpe2xldCBlPXQ7dGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWx8fChlPXRoaXMuY2hhbmdlUE0odCx0aGlzLl90YXJnZXRQTSkpO2NvbnN0IG49U2kuYnVmZmVyT3AoZSwwKTtsZXQgcz1uO3JldHVybiB0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbHx8KHM9dC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnkobikpLHN9cmVkdWNlUG9pbnR3aXNlKHQpe2xldCBlPW51bGw7aWYodGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWwpe2NvbnN0IG49dGhpcy5jcmVhdGVGYWN0b3J5KHQuZ2V0RmFjdG9yeSgpLHRoaXMuX3RhcmdldFBNKTtlPW5ldyBGdChuKX1lbHNlIGU9bmV3IEZ0O2xldCBuPXRoaXMuX3JlbW92ZUNvbGxhcHNlZDtyZXR1cm4gdC5nZXREaW1lbnNpb24oKT49MiYmKG49ITApLGUuZWRpdCh0LG5ldyBYcih0aGlzLl90YXJnZXRQTSxuKSl9Y2hhbmdlUE0odCxlKXtyZXR1cm4gdGhpcy5jcmVhdGVFZGl0b3IodC5nZXRGYWN0b3J5KCksZSkuZWRpdCh0LG5ldyBGdC5Ob09wR2VvbWV0cnlPcGVyYXRpb24pfXNldFJlbW92ZUNvbGxhcHNlZENvbXBvbmVudHModCl7dGhpcy5fcmVtb3ZlQ29sbGFwc2VkPXR9Y3JlYXRlRmFjdG9yeSh0LGUpe3JldHVybiBuZXcgSHQoZSx0LmdldFNSSUQoKSx0LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9c2V0Q2hhbmdlUHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWw9dH1yZWR1Y2UodCl7Y29uc3QgZT10aGlzLnJlZHVjZVBvaW50d2lzZSh0KTtyZXR1cm4gdGhpcy5faXNQb2ludHdpc2U/ZTpfKGUsT3QpP0NyLmlzVmFsaWQoZSk/ZTp0aGlzLmZpeFBvbHlnb25hbFRvcG9sb2d5KGUpOmV9c2V0UG9pbnR3aXNlKHQpe3RoaXMuX2lzUG9pbnR3aXNlPXR9Y3JlYXRlRWRpdG9yKHQsZSl7aWYodC5nZXRQcmVjaXNpb25Nb2RlbCgpPT09ZSlyZXR1cm4gbmV3IEZ0O2NvbnN0IG49dGhpcy5jcmVhdGVGYWN0b3J5KHQsZSk7cmV0dXJuIG5ldyBGdChuKX1nZXRDbGFzcygpe3JldHVybiBIcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdGFyZ2V0UE09bnVsbCx0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9ITAsdGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWw9ITEsdGhpcy5faXNQb2ludHdpc2U9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fdGFyZ2V0UE09dH07dmFyIFdyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb21ldHJ5UHJlY2lzaW9uUmVkdWNlcjpIcn0pO2NsYXNzIGpye2NvbnN0cnVjdG9yKCl7anIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBqcih0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLnNpbXBsaWZ5KCl9c2ltcGxpZnlTZWN0aW9uKHQsZSl7aWYodCsxPT09ZSlyZXR1cm4gbnVsbDt0aGlzLl9zZWcucDA9dGhpcy5fcHRzW3RdLHRoaXMuX3NlZy5wMT10aGlzLl9wdHNbZV07bGV0IG49LTEscz10O2ZvcihsZXQgaT10KzE7aTxlO2krKyl7Y29uc3QgdD10aGlzLl9zZWcuZGlzdGFuY2UodGhpcy5fcHRzW2ldKTt0Pm4mJihuPXQscz1pKX1pZihuPD10aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSlmb3IobGV0IG49dCsxO248ZTtuKyspdGhpcy5fdXNlUHRbbl09ITE7ZWxzZSB0aGlzLnNpbXBsaWZ5U2VjdGlvbih0LHMpLHRoaXMuc2ltcGxpZnlTZWN0aW9uKHMsZSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1zaW1wbGlmeSgpe3RoaXMuX3VzZVB0PW5ldyBBcnJheSh0aGlzLl9wdHMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcHRzLmxlbmd0aDt0KyspdGhpcy5fdXNlUHRbdF09ITA7dGhpcy5zaW1wbGlmeVNlY3Rpb24oMCx0aGlzLl9wdHMubGVuZ3RoLTEpO2NvbnN0IHQ9bmV3IEk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wdHMubGVuZ3RoO2UrKyl0aGlzLl91c2VQdFtlXSYmdC5hZGQobmV3IGcodGhpcy5fcHRzW2VdKSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX1nZXRDbGFzcygpe3JldHVybiBqcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19anIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fdXNlUHQ9bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX3NlZz1uZXcgZWU7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHRzPXR9O2NsYXNzIEtye2NvbnN0cnVjdG9yKCl7S3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBLcih0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9c2V0RW5zdXJlVmFsaWQodCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXR9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKT90aGlzLl9pbnB1dEdlb20uY29weSgpOm5ldyBacih0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgbihcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fWdldENsYXNzKCl7cmV0dXJuIEtyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBaciBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxaci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXRyYW5zZm9ybVBvbHlnb24odCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBBdD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5P3QuYnVmZmVyKDApOnR9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz1udWxsO3JldHVybiBzPTA9PT1uLmxlbmd0aD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTpqci5zaW1wbGlmeShuLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybUxpbmVhclJpbmcodCxlKXtjb25zdCBuPWUgaW5zdGFuY2VvZiBidCxzPXN1cGVyLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fHMgaW5zdGFuY2VvZiBEdD9zOm51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gWnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVpyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPWV9LEtyLkRQVHJhbnNmb3JtZXI9WnIsS3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9O2NsYXNzIFFyIGV4dGVuZHMgZWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLFFyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0SW5kZXgoKXtyZXR1cm4gdGhpcy5faW5kZXh9Z2V0UGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudH1nZXRDbGFzcygpe3JldHVybiBRcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcGFyZW50PW51bGwsdGhpcy5faW5kZXg9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07UXIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbnVsbCwtMSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107ZWUuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMuX3BhcmVudD1uLHRoaXMuX2luZGV4PXN9fTtjbGFzcyBKcntjb25zdHJ1Y3Rvcigpe0pyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGV4dHJhY3RDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSsxKS5maWxsKG51bGwpO2xldCBuPW51bGw7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspbj10LmdldChzKSxlW3NdPW4ucDA7cmV0dXJuIGVbZS5sZW5ndGgtMV09bi5wMSxlfWFkZFRvUmVzdWx0KHQpe3RoaXMuX3Jlc3VsdFNlZ3MuYWRkKHQpfWFzTGluZVN0cmluZygpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKEpyLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLl9yZXN1bHRTZWdzKSl9Z2V0UmVzdWx0U2l6ZSgpe2NvbnN0IHQ9dGhpcy5fcmVzdWx0U2Vncy5zaXplKCk7cmV0dXJuIDA9PT10PzA6dCsxfWdldFBhcmVudCgpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lfWdldFNlZ21lbnQodCl7cmV0dXJuIHRoaXMuX3NlZ3NbdF19Z2V0UGFyZW50Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZS5nZXRDb29yZGluYXRlcygpfWdldE1pbmltdW1TaXplKCl7cmV0dXJuIHRoaXMuX21pbmltdW1TaXplfWFzTGluZWFyUmluZygpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKEpyLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLl9yZXN1bHRTZWdzKSl9Z2V0U2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fc2Vnc31pbml0KCl7Y29uc3QgdD10aGlzLl9wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCk7dGhpcy5fc2Vncz1uZXcgQXJyYXkodC5sZW5ndGgtMSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTE7ZSsrKXtjb25zdCBuPW5ldyBRcih0W2VdLHRbZSsxXSx0aGlzLl9wYXJlbnRMaW5lLGUpO3RoaXMuX3NlZ3NbZV09bn19Z2V0UmVzdWx0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gSnIuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMuX3Jlc3VsdFNlZ3MpfWdldENsYXNzKCl7cmV0dXJuIEpyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Kci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wYXJlbnRMaW5lPW51bGwsdGhpcy5fc2Vncz1udWxsLHRoaXMuX3Jlc3VsdFNlZ3M9bmV3IHgsdGhpcy5fbWluaW11bVNpemU9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07SnIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDIpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3BhcmVudExpbmU9dCx0aGlzLl9taW5pbXVtU2l6ZT1lLHRoaXMuaW5pdCgpfX07Y2xhc3MgJHJ7Y29uc3RydWN0b3IoKXskci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJlbW92ZSh0KXt0aGlzLl9pbmRleC5yZW1vdmUobmV3IE4odC5wMCx0LnAxKSx0KX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEpyKXtjb25zdCB0PWFyZ3VtZW50c1swXS5nZXRTZWdtZW50cygpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPXRbZV07dGhpcy5hZGQobil9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5kZXguaW5zZXJ0KG5ldyBOKHQucDAsdC5wMSksdCl9fXF1ZXJ5KHQpe2NvbnN0IGU9bmV3IE4odC5wMCx0LnAxKSxuPW5ldyB0byh0KTtyZXR1cm4gdGhpcy5faW5kZXgucXVlcnkoZSxuKSxuLmdldEl0ZW1zKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gJHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fSRyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2luZGV4PW5ldyB1c307Y2xhc3MgdG97Y29uc3RydWN0b3IoKXt0by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0SXRlbSh0KXtjb25zdCBlPXQ7Ti5pbnRlcnNlY3RzKGUucDAsZS5wMSx0aGlzLl9xdWVyeVNlZy5wMCx0aGlzLl9xdWVyeVNlZy5wMSkmJnRoaXMuX2l0ZW1zLmFkZCh0KX1nZXRJdGVtcygpe3JldHVybiB0aGlzLl9pdGVtc31nZXRDbGFzcygpe3JldHVybiB0b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQWVdfX10by5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9xdWVyeVNlZz1udWxsLHRoaXMuX2l0ZW1zPW5ldyB4O2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3F1ZXJ5U2VnPXR9O2NsYXNzIGVve2NvbnN0cnVjdG9yKCl7ZW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNJbkxpbmVTZWN0aW9uKHQsZSxuKXtpZihuLmdldFBhcmVudCgpIT09dC5nZXRQYXJlbnQoKSlyZXR1cm4hMTtjb25zdCBzPW4uZ2V0SW5kZXgoKTtyZXR1cm4gcz49ZVswXSYmczxlWzFdfWZsYXR0ZW4odCxlKXtjb25zdCBuPXRoaXMuX2xpbmVQdHNbdF0scz10aGlzLl9saW5lUHRzW2VdLGk9bmV3IGVlKG4scyk7cmV0dXJuIHRoaXMucmVtb3ZlKHRoaXMuX2xpbmUsdCxlKSx0aGlzLl9vdXRwdXRJbmRleC5hZGQoaSksaX1oYXNCYWRJbnRlcnNlY3Rpb24odCxlLG4pe3JldHVybiEhdGhpcy5oYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb24obil8fCEhdGhpcy5oYXNCYWRJbnB1dEludGVyc2VjdGlvbih0LGUsbil9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1zaW1wbGlmeVNlY3Rpb24odCxlLG4pe24rPTE7Y29uc3Qgcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZih0KzE9PT1lKXtjb25zdCBlPXRoaXMuX2xpbmUuZ2V0U2VnbWVudCh0KTtyZXR1cm4gdGhpcy5fbGluZS5hZGRUb1Jlc3VsdChlKSxudWxsfWxldCBpPSEwO2lmKHRoaXMuX2xpbmUuZ2V0UmVzdWx0U2l6ZSgpPHRoaXMuX2xpbmUuZ2V0TWluaW11bVNpemUoKSl7bisxPHRoaXMuX2xpbmUuZ2V0TWluaW11bVNpemUoKSYmKGk9ITEpfWNvbnN0IHI9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbz10aGlzLmZpbmRGdXJ0aGVzdFBvaW50KHRoaXMuX2xpbmVQdHMsdCxlLHIpO3JbMF0+dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UmJihpPSExKTtjb25zdCBsPW5ldyBlZTtpZihsLnAwPXRoaXMuX2xpbmVQdHNbdF0sbC5wMT10aGlzLl9saW5lUHRzW2VdLHNbMF09dCxzWzFdPWUsdGhpcy5oYXNCYWRJbnRlcnNlY3Rpb24odGhpcy5fbGluZSxzLGwpJiYoaT0hMSksaSl7Y29uc3Qgbj10aGlzLmZsYXR0ZW4odCxlKTtyZXR1cm4gdGhpcy5fbGluZS5hZGRUb1Jlc3VsdChuKSxudWxsfXRoaXMuc2ltcGxpZnlTZWN0aW9uKHQsbyxuKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbihvLGUsbil9aGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10aGlzLl9vdXRwdXRJbmRleC5xdWVyeSh0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKG4sdCkpcmV0dXJuITB9cmV0dXJuITF9ZmluZEZ1cnRoZXN0UG9pbnQodCxlLG4scyl7Y29uc3QgaT1uZXcgZWU7aS5wMD10W2VdLGkucDE9dFtuXTtsZXQgcj0tMSxvPWU7Zm9yKGxldCBzPWUrMTtzPG47cysrKXtjb25zdCBlPXRbc10sbj1pLmRpc3RhbmNlKGUpO24+ciYmKHI9bixvPXMpfXJldHVybiBzWzBdPXIsb31zaW1wbGlmeSh0KXt0aGlzLl9saW5lPXQsdGhpcy5fbGluZVB0cz10LmdldFBhcmVudENvb3JkaW5hdGVzKCksdGhpcy5zaW1wbGlmeVNlY3Rpb24oMCx0aGlzLl9saW5lUHRzLmxlbmd0aC0xLDApfXJlbW92ZSh0LGUsbil7Zm9yKGxldCBzPWU7czxuO3MrKyl7Y29uc3QgZT10LmdldFNlZ21lbnQocyk7dGhpcy5faW5wdXRJbmRleC5yZW1vdmUoZSl9fWhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odC5wMCx0LnAxLGUucDAsZS5wMSksdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpfWhhc0JhZElucHV0SW50ZXJzZWN0aW9uKHQsZSxuKXtmb3IobGV0IHM9dGhpcy5faW5wdXRJbmRleC5xdWVyeShuKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKGksbikpe2lmKGVvLmlzSW5MaW5lU2VjdGlvbih0LGUsaSkpY29udGludWU7cmV0dXJuITB9fXJldHVybiExfWdldENsYXNzKCl7cmV0dXJuIGVvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1lby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saT1uZXcgdGUsdGhpcy5faW5wdXRJbmRleD1uZXcgJHIsdGhpcy5fb3V0cHV0SW5kZXg9bmV3ICRyLHRoaXMuX2xpbmU9bnVsbCx0aGlzLl9saW5lUHRzPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9MDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbnB1dEluZGV4PXQsdGhpcy5fb3V0cHV0SW5kZXg9ZX07Y2xhc3Mgbm97Y29uc3RydWN0b3IoKXtuby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9c2ltcGxpZnkodCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5faW5wdXRJbmRleC5hZGQoZS5uZXh0KCkpO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PW5ldyBlbyh0aGlzLl9pbnB1dEluZGV4LHRoaXMuX291dHB1dEluZGV4KTt0LnNldERpc3RhbmNlVG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0LnNpbXBsaWZ5KGUubmV4dCgpKX19Z2V0Q2xhc3MoKXtyZXR1cm4gbm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW5vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0SW5kZXg9bmV3ICRyLHRoaXMuX291dHB1dEluZGV4PW5ldyAkcix0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT0wfTtjbGFzcyBzb3tjb25zdHJ1Y3Rvcigpe3NvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgc28odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfWdldFJlc3VsdEdlb21ldHJ5KCl7aWYodGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmNvcHkoKTtyZXR1cm4gdGhpcy5fbGluZXN0cmluZ01hcD1uZXcgVXQsdGhpcy5faW5wdXRHZW9tLmFwcGx5KG5ldyBybyh0aGlzKSksdGhpcy5fbGluZVNpbXBsaWZpZXIuc2ltcGxpZnkodGhpcy5fbGluZXN0cmluZ01hcC52YWx1ZXMoKSksbmV3IGlvKHRoaXMuX2xpbmVzdHJpbmdNYXApLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgbihcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9saW5lU2ltcGxpZmllci5zZXREaXN0YW5jZVRvbGVyYW5jZSh0KX1nZXRDbGFzcygpe3JldHVybiBzb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgaW8gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksaW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2lmKDA9PT10LnNpemUoKSlyZXR1cm4gbnVsbDtpZihlIGluc3RhbmNlb2YgVHQpe2NvbnN0IHQ9dGhpcy5fbGluZXN0cmluZ01hcC5nZXQoZSk7cmV0dXJuIHRoaXMuY3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlKHQuZ2V0UmVzdWx0Q29vcmRpbmF0ZXMoKSl9cmV0dXJuIHN1cGVyLnRyYW5zZm9ybUNvb3JkaW5hdGVzLmNhbGwodGhpcyx0LGUpfWdldENsYXNzKCl7cmV0dXJuIGlvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1pby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lc3RyaW5nTWFwPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZXN0cmluZ01hcD10fTtjbGFzcyByb3tjb25zdHJ1Y3Rvcigpe3JvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe2lmKHQgaW5zdGFuY2VvZiBUdCl7Y29uc3QgZT10O2lmKGUuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49ZS5pc0Nsb3NlZCgpPzQ6MixzPW5ldyBKcihlLG4pO3RoaXMudHBzLl9saW5lc3RyaW5nTWFwLnB1dChlLHMpfX1nZXRDbGFzcygpe3JldHVybiByb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR119fXJvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMudHBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy50cHM9dH0sc28uTGluZVN0cmluZ1RyYW5zZm9ybWVyPWlvLHNvLkxpbmVTdHJpbmdNYXBCdWlsZGVyRmlsdGVyPXJvLHNvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2xpbmVTaW1wbGlmaWVyPW5ldyBubyx0aGlzLl9saW5lc3RyaW5nTWFwPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9O2NsYXNzIG9ve2NvbnN0cnVjdG9yKCl7b28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2ltcGxpZnkodCxlKXtyZXR1cm4gbmV3IG9vKHQsZSkuc2ltcGxpZnkoKX1zaW1wbGlmeVZlcnRleCh0KXtsZXQgZT10LG49ZS5nZXRBcmVhKCkscz1udWxsO2Zvcig7bnVsbCE9PWU7KXtjb25zdCB0PWUuZ2V0QXJlYSgpO3Q8biYmKG49dCxzPWUpLGU9ZS5fbmV4dH1yZXR1cm4gbnVsbCE9PXMmJm48dGhpcy5fdG9sZXJhbmNlJiZzLnJlbW92ZSgpLHQuaXNMaXZlKCk/bjotMX1zaW1wbGlmeSgpe2NvbnN0IHQ9bG8uYnVpbGRMaW5lKHRoaXMuX3B0cyk7bGV0IGU9dGhpcy5fdG9sZXJhbmNlO2Rve2U9dGhpcy5zaW1wbGlmeVZlcnRleCh0KX13aGlsZShlPHRoaXMuX3RvbGVyYW5jZSk7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIG4ubGVuZ3RoPDI/W25bMF0sbmV3IGcoblswXSldOm59Z2V0Q2xhc3MoKXtyZXR1cm4gb299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGxve2NvbnN0cnVjdG9yKCl7bG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgYnVpbGRMaW5lKHQpe2xldCBlPW51bGwsbj1udWxsO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKXtjb25zdCBpPW5ldyBsbyh0W3NdKTtudWxsPT09ZSYmKGU9aSksaS5zZXRQcmV2KG4pLG51bGwhPT1uJiYobi5zZXROZXh0KGkpLG4udXBkYXRlQXJlYSgpKSxuPWl9cmV0dXJuIGV9Z2V0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBJO2xldCBlPXRoaXM7ZG97dC5hZGQoZS5fcHQsITEpLGU9ZS5fbmV4dH13aGlsZShudWxsIT09ZSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX1nZXRBcmVhKCl7cmV0dXJuIHRoaXMuX2FyZWF9dXBkYXRlQXJlYSgpe2lmKG51bGw9PT10aGlzLl9wcmV2fHxudWxsPT09dGhpcy5fbmV4dClyZXR1cm4gdGhpcy5fYXJlYT1sby5NQVhfQVJFQSxudWxsO3RoaXMuX2FyZWE9TWF0aC5hYnMocmUuYXJlYSh0aGlzLl9wcmV2Ll9wdCx0aGlzLl9wdCx0aGlzLl9uZXh0Ll9wdCkpfXJlbW92ZSgpe2NvbnN0IHQ9dGhpcy5fcHJldixlPXRoaXMuX25leHQ7bGV0IG49bnVsbDtyZXR1cm4gbnVsbCE9PXRoaXMuX3ByZXYmJih0aGlzLl9wcmV2LnNldE5leHQoZSksdGhpcy5fcHJldi51cGRhdGVBcmVhKCksbj10aGlzLl9wcmV2KSxudWxsIT09dGhpcy5fbmV4dCYmKHRoaXMuX25leHQuc2V0UHJldih0KSx0aGlzLl9uZXh0LnVwZGF0ZUFyZWEoKSxudWxsPT09biYmKG49dGhpcy5fbmV4dCkpLHRoaXMuX2lzTGl2ZT0hMSxufWlzTGl2ZSgpe3JldHVybiB0aGlzLl9pc0xpdmV9c2V0UHJldih0KXt0aGlzLl9wcmV2PXR9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9Z2V0Q2xhc3MoKXtyZXR1cm4gbG99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWxvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0PW51bGwsdGhpcy5fcHJldj1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9hcmVhPWxvLk1BWF9BUkVBLHRoaXMuX2lzTGl2ZT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdD10fSxsby5NQVhfQVJFQT1pLk1BWF9WQUxVRSxvby5WV1ZlcnRleD1sbyxvby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdHM9dCx0aGlzLl90b2xlcmFuY2U9ZSplfTtjbGFzcyBhb3tjb25zdHJ1Y3Rvcigpe2FvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgYW8odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfXNldEVuc3VyZVZhbGlkKHQpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10fWdldFJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5pc0VtcHR5KCk/dGhpcy5faW5wdXRHZW9tLmNvcHkoKTpuZXcgY28odGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PDApdGhyb3cgbmV3IG4oXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1nZXRDbGFzcygpe3JldHVybiBhb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgY28gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksY28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgQXQ/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX1jcmVhdGVWYWxpZEFyZWEodCl7cmV0dXJuIHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT90LmJ1ZmZlcigwKTp0fXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IHM9bnVsbDtyZXR1cm4gcz0wPT09bi5sZW5ndGg/bmV3IEFycmF5KDApLmZpbGwobnVsbCk6b28uc2ltcGxpZnkobix0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSksdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1MaW5lYXJSaW5nKHQsZSl7Y29uc3Qgbj1lIGluc3RhbmNlb2YgYnQscz1zdXBlci50cmFuc2Zvcm1MaW5lYXJSaW5nLmNhbGwodGhpcyx0LGUpO3JldHVybiFufHxzIGluc3RhbmNlb2YgRHQ/czpudWxsfWdldENsYXNzKCl7cmV0dXJuIGNvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITAsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1lfSxhby5WV1RyYW5zZm9ybWVyPWNvLGFvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fTt2YXIgaG89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRG91Z2xhc1BldWNrZXJTaW1wbGlmaWVyOktyLFRvcG9sb2d5UHJlc2VydmluZ1NpbXBsaWZpZXI6c28sVldTaW1wbGlmaWVyOmFvfSk7Y2xhc3MgdW97Y29uc3RydWN0b3IoKXt1by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBwb2ludEFsb25nUmV2ZXJzZSh0LGUpe2NvbnN0IG49bmV3IGc7cmV0dXJuIG4ueD10LnAxLngtZSoodC5wMS54LXQucDAueCksbi55PXQucDEueS1lKih0LnAxLnktdC5wMC55KSxufXNwbGl0QXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLl9taW5pbXVtTGVuL3RoaXMuX3NlZ0xlbjtpZih0LmRpc3RhbmNlKHRoaXMuX3NlZy5wMCk8dGhpcy5fbWluaW11bUxlbilyZXR1cm4gdGhpcy5fc3BsaXRQdD10aGlzLl9zZWcucG9pbnRBbG9uZyhlKSxudWxsO2lmKHQuZGlzdGFuY2UodGhpcy5fc2VnLnAxKTx0aGlzLl9taW5pbXVtTGVuKXJldHVybiB0aGlzLl9zcGxpdFB0PXVvLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuX3NlZyxlKSxudWxsO3RoaXMuX3NwbGl0UHQ9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuZ2V0Q29uc3RyYWluZWRMZW5ndGgodCkvdGhpcy5fc2VnTGVuO2UuZXF1YWxzMkQodGhpcy5fc2VnLnAwKT90aGlzLl9zcGxpdFB0PXRoaXMuX3NlZy5wb2ludEFsb25nKG4pOnRoaXMuX3NwbGl0UHQ9dW8ucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5fc2VnLG4pfX1zZXRNaW5pbXVtTGVuZ3RoKHQpe3RoaXMuX21pbmltdW1MZW49dH1nZXRDb25zdHJhaW5lZExlbmd0aCh0KXtyZXR1cm4gdDx0aGlzLl9taW5pbXVtTGVuP3RoaXMuX21pbmltdW1MZW46dH1nZXRTcGxpdFBvaW50KCl7cmV0dXJuIHRoaXMuX3NwbGl0UHR9Z2V0Q2xhc3MoKXtyZXR1cm4gdW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXVvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NlZz1udWxsLHRoaXMuX3NlZ0xlbj1udWxsLHRoaXMuX3NwbGl0UHQ9bnVsbCx0aGlzLl9taW5pbXVtTGVuPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2VnPXQsdGhpcy5fc2VnTGVuPXQuZ2V0TGVuZ3RoKCl9O2NsYXNzIGdve2NvbnN0cnVjdG9yKCl7Z28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5kU3BsaXRQb2ludCh0LGUpe31nZXRDbGFzcygpe3JldHVybiBnb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Z28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBfb3tjb25zdHJ1Y3Rvcigpe19vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHByb2plY3RlZFNwbGl0UG9pbnQodCxlKXtyZXR1cm4gdC5nZXRMaW5lU2VnbWVudCgpLnByb2plY3QoZSl9ZmluZFNwbGl0UG9pbnQodCxlKXtjb25zdCBuPXQuZ2V0TGluZVNlZ21lbnQoKSxzPW4uZ2V0TGVuZ3RoKCkvMixpPW5ldyB1byhuKSxyPV9vLnByb2plY3RlZFNwbGl0UG9pbnQodCxlKTtsZXQgbz0yKnIuZGlzdGFuY2UoZSkqLjg7cmV0dXJuIG8+cyYmKG89cyksaS5zZXRNaW5pbXVtTGVuZ3RoKG8pLGkuc3BsaXRBdChyKSxpLmdldFNwbGl0UG9pbnQoKX1nZXRDbGFzcygpe3JldHVybiBfb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ29dfX1fby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGZve2NvbnN0cnVjdG9yKCl7Zm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdHJpQXJlYSh0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0oZS55LXQueSkqKG4ueC10LngpfXN0YXRpYyBpc0luQ2lyY2xlREROb3JtYWxpemVkKHQsZSxuLHMpe2NvbnN0IGk9Ui52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KHMueCkscj1SLnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3Qocy55KSxvPVIudmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdChzLngpLGw9Ui52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHMueSksYT1SLnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3Qocy54KSxjPVIudmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdChzLnkpLGg9aS5tdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoby5tdWx0aXBseShyKSksdT1vLm11bHRpcGx5KGMpLnNlbGZTdWJ0cmFjdChhLm11bHRpcGx5KGwpKSxnPWEubXVsdGlwbHkocikuc2VsZlN1YnRyYWN0KGkubXVsdGlwbHkoYykpLGQ9aS5tdWx0aXBseShpKS5zZWxmQWRkKHIubXVsdGlwbHkocikpLF89by5tdWx0aXBseShvKS5zZWxmQWRkKGwubXVsdGlwbHkobCkpLGY9YS5tdWx0aXBseShhKS5zZWxmQWRkKGMubXVsdGlwbHkoYykpO3JldHVybiBkLnNlbGZNdWx0aXBseSh1KS5zZWxmQWRkKF8uc2VsZk11bHRpcGx5KGcpKS5zZWxmQWRkKGYuc2VsZk11bHRpcGx5KGgpKS5kb3VibGVWYWx1ZSgpPjB9c3RhdGljIGNoZWNrUm9idXN0SW5DaXJjbGUodCxlLG4scyl7Y29uc3QgaT1mby5pc0luQ2lyY2xlTm9uUm9idXN0KHQsZSxuLHMpLHI9Zm8uaXNJbkNpcmNsZUREU2xvdyh0LGUsbixzKSxvPWZvLmlzSW5DaXJjbGVDQyh0LGUsbixzKSxsPXJlLmNpcmN1bWNlbnRyZSh0LGUsbik7Ty5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCktdC5kaXN0YW5jZShsKSkvdC5kaXN0YW5jZShsKSksaT09PXImJmk9PT1vfHwoTy5vdXQucHJpbnRsbihcImluQ2lyY2xlIHJvYnVzdG5lc3MgZmFpbHVyZSAoZG91YmxlIHJlc3VsdCA9IFwiK2krXCIsIEREIHJlc3VsdCA9IFwiK3IrXCIsIENDIHJlc3VsdCA9IFwiK28rXCIpXCIpLE8ub3V0LnByaW50bG4oSnQudG9MaW5lU3RyaW5nKG5ldyB6dChbdCxlLG4sc10pKSksTy5vdXQucHJpbnRsbihcIkNpcmN1bWNlbnRyZSA9IFwiK0p0LnRvUG9pbnQobCkrXCIgcmFkaXVzID0gXCIrdC5kaXN0YW5jZShsKSksTy5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCkvdC5kaXN0YW5jZShsKS0xKSksTy5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYiA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCkvZS5kaXN0YW5jZShsKS0xKSksTy5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYyA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCkvbi5kaXN0YW5jZShsKS0xKSksTy5vdXQucHJpbnRsbigpKX1zdGF0aWMgaXNJbkNpcmNsZURERmFzdCh0LGUsbixzKXtjb25zdCBpPVIuc3FyKHQueCkuc2VsZkFkZChSLnNxcih0LnkpKS5zZWxmTXVsdGlwbHkoZm8udHJpQXJlYURERmFzdChlLG4scykpLHI9Ui5zcXIoZS54KS5zZWxmQWRkKFIuc3FyKGUueSkpLnNlbGZNdWx0aXBseShmby50cmlBcmVhRERGYXN0KHQsbixzKSksbz1SLnNxcihuLngpLnNlbGZBZGQoUi5zcXIobi55KSkuc2VsZk11bHRpcGx5KGZvLnRyaUFyZWFEREZhc3QodCxlLHMpKSxsPVIuc3FyKHMueCkuc2VsZkFkZChSLnNxcihzLnkpKS5zZWxmTXVsdGlwbHkoZm8udHJpQXJlYURERmFzdCh0LGUsbikpO3JldHVybiBpLnNlbGZTdWJ0cmFjdChyKS5zZWxmQWRkKG8pLnNlbGZTdWJ0cmFjdChsKS5kb3VibGVWYWx1ZSgpPjB9c3RhdGljIGlzSW5DaXJjbGVDQyh0LGUsbixzKXtjb25zdCBpPXJlLmNpcmN1bWNlbnRyZSh0LGUsbikscj10LmRpc3RhbmNlKGkpO3JldHVybiBzLmRpc3RhbmNlKGkpLXI8PTB9c3RhdGljIGlzSW5DaXJjbGVOb3JtYWxpemVkKHQsZSxuLHMpe2NvbnN0IGk9dC54LXMueCxyPXQueS1zLnksbz1lLngtcy54LGw9ZS55LXMueSxhPW4ueC1zLngsYz1uLnktcy55O3JldHVybihpKmkrcipyKSoobypjLWEqbCkrKG8qbytsKmwpKihhKnItaSpjKSsoYSphK2MqYykqKGkqbC1vKnIpPjB9c3RhdGljIGlzSW5DaXJjbGVERFNsb3codCxlLG4scyl7Y29uc3QgaT1SLnZhbHVlT2Yocy54KSxyPVIudmFsdWVPZihzLnkpLG89Ui52YWx1ZU9mKHQueCksbD1SLnZhbHVlT2YodC55KSxhPVIudmFsdWVPZihlLngpLGM9Ui52YWx1ZU9mKGUueSksaD1SLnZhbHVlT2Yobi54KSx1PVIudmFsdWVPZihuLnkpLGc9by5tdWx0aXBseShvKS5hZGQobC5tdWx0aXBseShsKSkubXVsdGlwbHkoZm8udHJpQXJlYUREU2xvdyhhLGMsaCx1LGkscikpLGQ9YS5tdWx0aXBseShhKS5hZGQoYy5tdWx0aXBseShjKSkubXVsdGlwbHkoZm8udHJpQXJlYUREU2xvdyhvLGwsaCx1LGkscikpLF89aC5tdWx0aXBseShoKS5hZGQodS5tdWx0aXBseSh1KSkubXVsdGlwbHkoZm8udHJpQXJlYUREU2xvdyhvLGwsYSxjLGkscikpLGY9aS5tdWx0aXBseShpKS5hZGQoci5tdWx0aXBseShyKSkubXVsdGlwbHkoZm8udHJpQXJlYUREU2xvdyhvLGwsYSxjLGgsdSkpO3JldHVybiBnLnN1YnRyYWN0KGQpLmFkZChfKS5zdWJ0cmFjdChmKS5kb3VibGVWYWx1ZSgpPjB9c3RhdGljIGlzSW5DaXJjbGVOb25Sb2J1c3QodCxlLG4scyl7cmV0dXJuKHQueCp0LngrdC55KnQueSkqZm8udHJpQXJlYShlLG4scyktKGUueCplLngrZS55KmUueSkqZm8udHJpQXJlYSh0LG4scykrKG4ueCpuLngrbi55Km4ueSkqZm8udHJpQXJlYSh0LGUscyktKHMueCpzLngrcy55KnMueSkqZm8udHJpQXJlYSh0LGUsbik+MH1zdGF0aWMgaXNJbkNpcmNsZVJvYnVzdCh0LGUsbixzKXtyZXR1cm4gZm8uaXNJbkNpcmNsZU5vcm1hbGl6ZWQodCxlLG4scyl9c3RhdGljIHRyaUFyZWFERFNsb3codCxlLG4scyxpLHIpe3JldHVybiBuLnN1YnRyYWN0KHQpLm11bHRpcGx5KHIuc3VidHJhY3QoZSkpLnN1YnRyYWN0KHMuc3VidHJhY3QoZSkubXVsdGlwbHkoaS5zdWJ0cmFjdCh0KSkpfXN0YXRpYyB0cmlBcmVhRERGYXN0KHQsZSxuKXtjb25zdCBzPVIudmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpLnNlbGZNdWx0aXBseShSLnZhbHVlT2Yobi55KS5zZWxmU3VidHJhY3QodC55KSksaT1SLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QodC55KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKG4ueCkuc2VsZlN1YnRyYWN0KHQueCkpO3JldHVybiBzLnNlbGZTdWJ0cmFjdChpKX1nZXRDbGFzcygpe3JldHVybiBmb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Zm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBwb3tjb25zdHJ1Y3Rvcigpe3BvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGludGVycG9sYXRlWigpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWUuZGlzdGFuY2UobiksaT10LmRpc3RhbmNlKGUpLHI9bi56LWUuejtyZXR1cm4gZS56K3IqKGkvcyl9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9ZS54LHI9ZS55LG89bi54LWksbD1zLngtaSxhPW4ueS1yLGM9cy55LXIsaD1vKmMtbCphLHU9dC54LWksZz10LnktcixkPShjKnUtbCpnKS9oLF89KC1hKnUrbypnKS9oO3JldHVybiBlLnorZCoobi56LWUueikrXyoocy56LWUueil9fWNpcmNsZUNlbnRlcih0LGUpe2NvbnN0IG49bmV3IHBvKHRoaXMuZ2V0WCgpLHRoaXMuZ2V0WSgpKSxzPXRoaXMuYmlzZWN0b3Iobix0KSxpPXRoaXMuYmlzZWN0b3IodCxlKSxyPW5ldyBiKHMsaSk7bGV0IG89bnVsbDt0cnl7bz1uZXcgcG8oci5nZXRYKCksci5nZXRZKCkpfWNhdGNoKHMpe2lmKCEocyBpbnN0YW5jZW9mIFMpKXRocm93IHM7Ty5lcnIucHJpbnRsbihcImE6IFwiK24rXCIgIGI6IFwiK3QrXCIgIGM6IFwiK2UpLE8uZXJyLnByaW50bG4ocyl9cmV0dXJuIG99ZG90KHQpe3JldHVybiB0aGlzLl9wLngqdC5nZXRYKCkrdGhpcy5fcC55KnQuZ2V0WSgpfW1hZ24oKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3AueCp0aGlzLl9wLngrdGhpcy5fcC55KnRoaXMuX3AueSl9Z2V0Wigpe3JldHVybiB0aGlzLl9wLnp9YmlzZWN0b3IodCxlKXtjb25zdCBuPWUuZ2V0WCgpLXQuZ2V0WCgpLHM9ZS5nZXRZKCktdC5nZXRZKCksaT1uZXcgYih0LmdldFgoKStuLzIsdC5nZXRZKCkrcy8yLDEpLHI9bmV3IGIodC5nZXRYKCktcytuLzIsdC5nZXRZKCkrbitzLzIsMSk7cmV0dXJuIG5ldyBiKGkscil9ZXF1YWxzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9wLng9PT10LmdldFgoKSYmdGhpcy5fcC55PT09dC5nZXRZKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9wLmRpc3RhbmNlKHQuZ2V0Q29vcmRpbmF0ZSgpKTxlfX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B9aXNJbkNpcmNsZSh0LGUsbil7cmV0dXJuIGZvLmlzSW5DaXJjbGVSb2J1c3QodC5fcCxlLl9wLG4uX3AsdGhpcy5fcCl9aW50ZXJwb2xhdGVaVmFsdWUodCxlLG4pe2NvbnN0IHM9dC5nZXRYKCksaT10LmdldFkoKSxyPWUuZ2V0WCgpLXMsbz1uLmdldFgoKS1zLGw9ZS5nZXRZKCktaSxhPW4uZ2V0WSgpLWksYz1yKmEtbypsLGg9dGhpcy5nZXRYKCktcyx1PXRoaXMuZ2V0WSgpLWksZz0oYSpoLW8qdSkvYyxkPSgtbCpoK3IqdSkvYztyZXR1cm4gdC5nZXRaKCkrZyooZS5nZXRaKCktdC5nZXRaKCkpK2QqKG4uZ2V0WigpLXQuZ2V0WigpKX1taWRQb2ludCh0KXtjb25zdCBlPSh0aGlzLl9wLngrdC5nZXRYKCkpLzIsbj0odGhpcy5fcC55K3QuZ2V0WSgpKS8yLHM9KHRoaXMuX3Aueit0LmdldFooKSkvMjtyZXR1cm4gbmV3IHBvKGUsbixzKX1yaWdodE9mKHQpe3JldHVybiB0aGlzLmlzQ0NXKHQuZGVzdCgpLHQub3JpZygpKX1pc0NDVyh0LGUpe3JldHVybih0Ll9wLngtdGhpcy5fcC54KSooZS5fcC55LXRoaXMuX3AueSktKHQuX3AueS10aGlzLl9wLnkpKihlLl9wLngtdGhpcy5fcC54KT4wfWdldFgoKXtyZXR1cm4gdGhpcy5fcC54fWNyb3NzUHJvZHVjdCh0KXtyZXR1cm4gdGhpcy5fcC54KnQuZ2V0WSgpLXRoaXMuX3AueSp0LmdldFgoKX1zZXRaKHQpe3RoaXMuX3Auej10fXRpbWVzKHQpe3JldHVybiBuZXcgcG8odCp0aGlzLl9wLngsdCp0aGlzLl9wLnkpfWNyb3NzKCl7cmV0dXJuIG5ldyBwbyh0aGlzLl9wLnksLXRoaXMuX3AueCl9bGVmdE9mKHQpe3JldHVybiB0aGlzLmlzQ0NXKHQub3JpZygpLHQuZGVzdCgpKX10b1N0cmluZygpe3JldHVyblwiUE9JTlQgKFwiK3RoaXMuX3AueCtcIiBcIit0aGlzLl9wLnkrXCIpXCJ9c3ViKHQpe3JldHVybiBuZXcgcG8odGhpcy5fcC54LXQuZ2V0WCgpLHRoaXMuX3AueS10LmdldFkoKSl9Z2V0WSgpe3JldHVybiB0aGlzLl9wLnl9Y2xhc3NpZnkodCxlKXtjb25zdCBuPWUuc3ViKHQpLHM9dGhpcy5zdWIodCksaT1uLmNyb3NzUHJvZHVjdChzKTtyZXR1cm4gaT4wP3BvLkxFRlQ6aTwwP3BvLlJJR0hUOm4uZ2V0WCgpKnMuZ2V0WCgpPDB8fG4uZ2V0WSgpKnMuZ2V0WSgpPDA/cG8uQkVISU5EOm4ubWFnbigpPHMubWFnbigpP3BvLkJFWU9ORDp0LmVxdWFscyh0aGlzKT9wby5PUklHSU46ZS5lcXVhbHModGhpcyk/cG8uREVTVElOQVRJT046cG8uQkVUV0VFTn1zdW0odCl7cmV0dXJuIG5ldyBwbyh0aGlzLl9wLngrdC5nZXRYKCksdGhpcy5fcC55K3QuZ2V0WSgpKX1kaXN0YW5jZSh0LGUpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZS5nZXRYKCktdC5nZXRYKCksMikrTWF0aC5wb3coZS5nZXRZKCktdC5nZXRZKCksMikpfWNpcmN1bVJhZGl1c1JhdGlvKHQsZSl7Y29uc3Qgbj10aGlzLmNpcmNsZUNlbnRlcih0LGUpLHM9dGhpcy5kaXN0YW5jZShuLHQpO2xldCBpPXRoaXMuZGlzdGFuY2UodGhpcyx0KSxyPXRoaXMuZGlzdGFuY2UodCxlKTtyZXR1cm4gcjxpJiYoaT1yKSxyPXRoaXMuZGlzdGFuY2UoZSx0aGlzKSxyPGkmJihpPXIpLHMvaX1nZXRDbGFzcygpe3JldHVybiBwb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wPW5ldyBnKHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3A9bmV3IGcodCxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wPW5ldyBnKHQsZSxuKX19LHBvLkxFRlQ9MCxwby5SSUdIVD0xLHBvLkJFWU9ORD0yLHBvLkJFSElORD0zLHBvLkJFVFdFRU49NCxwby5PUklHSU49NSxwby5ERVNUSU5BVElPTj02O2NsYXNzIG1vIGV4dGVuZHMgcG97Y29uc3RydWN0b3IoKXtzdXBlcigpLG1vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29uc3RyYWludCgpe3JldHVybiB0aGlzLl9jb25zdHJhaW50fXNldE9uQ29uc3RyYWludCh0KXt0aGlzLl9pc09uQ29uc3RyYWludD10fW1lcmdlKHQpe3QuX2lzT25Db25zdHJhaW50JiYodGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5fY29uc3RyYWludD10Ll9jb25zdHJhaW50KX1pc09uQ29uc3RyYWludCgpe3JldHVybiB0aGlzLl9pc09uQ29uc3RyYWludH1zZXRDb25zdHJhaW50KHQpe3RoaXMuX2lzT25Db25zdHJhaW50PSEwLHRoaXMuX2NvbnN0cmFpbnQ9dH1nZXRDbGFzcygpe3JldHVybiBtb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9bnVsbCx0aGlzLl9jb25zdHJhaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07cG8uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX07Y2xhc3MgeW97Y29uc3RydWN0b3IoKXt5by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtYWtlRWRnZSh0LGUpe2NvbnN0IG49bmV3IHlvLHM9bmV3IHlvLGk9bmV3IHlvLHI9bmV3IHlvO24uX3JvdD1zLHMuX3JvdD1pLGkuX3JvdD1yLHIuX3JvdD1uLG4uc2V0TmV4dChuKSxzLnNldE5leHQociksaS5zZXROZXh0KGkpLHIuc2V0TmV4dChzKTtjb25zdCBvPW47cmV0dXJuIG8uc2V0T3JpZyh0KSxvLnNldERlc3QoZSksb31zdGF0aWMgc3dhcCh0KXtjb25zdCBlPXQub1ByZXYoKSxuPXQuc3ltKCkub1ByZXYoKTt5by5zcGxpY2UodCxlKSx5by5zcGxpY2UodC5zeW0oKSxuKSx5by5zcGxpY2UodCxlLmxOZXh0KCkpLHlvLnNwbGljZSh0LnN5bSgpLG4ubE5leHQoKSksdC5zZXRPcmlnKGUuZGVzdCgpKSx0LnNldERlc3Qobi5kZXN0KCkpfXN0YXRpYyBzcGxpY2UodCxlKXtjb25zdCBuPXQub05leHQoKS5yb3QoKSxzPWUub05leHQoKS5yb3QoKSxpPWUub05leHQoKSxyPXQub05leHQoKSxvPXMub05leHQoKSxsPW4ub05leHQoKTt0LnNldE5leHQoaSksZS5zZXROZXh0KHIpLG4uc2V0TmV4dChvKSxzLnNldE5leHQobCl9c3RhdGljIGNvbm5lY3QodCxlKXtjb25zdCBuPXlvLm1ha2VFZGdlKHQuZGVzdCgpLGUub3JpZygpKTtyZXR1cm4geW8uc3BsaWNlKG4sdC5sTmV4dCgpKSx5by5zcGxpY2Uobi5zeW0oKSxlKSxufWVxdWFsc05vbk9yaWVudGVkKHQpe3JldHVybiEhdGhpcy5lcXVhbHNPcmllbnRlZCh0KXx8ISF0aGlzLmVxdWFsc09yaWVudGVkKHQuc3ltKCkpfXRvTGluZVNlZ21lbnQoKXtyZXR1cm4gbmV3IGVlKHRoaXMuX3ZlcnRleC5nZXRDb29yZGluYXRlKCksdGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX1kZXN0KCl7cmV0dXJuIHRoaXMuc3ltKCkub3JpZygpfW9OZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9ZXF1YWxzT3JpZW50ZWQodCl7cmV0dXJuISghdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSl8fCF0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKSl9ZE5leHQoKXtyZXR1cm4gdGhpcy5zeW0oKS5vTmV4dCgpLnN5bSgpfWxQcmV2KCl7cmV0dXJuIHRoaXMuX25leHQuc3ltKCl9clByZXYoKXtyZXR1cm4gdGhpcy5zeW0oKS5vTmV4dCgpfXJvdCgpe3JldHVybiB0aGlzLl9yb3R9b1ByZXYoKXtyZXR1cm4gdGhpcy5fcm90Ll9uZXh0Ll9yb3R9c3ltKCl7cmV0dXJuIHRoaXMuX3JvdC5fcm90fXNldE9yaWcodCl7dGhpcy5fdmVydGV4PXR9bE5leHQoKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLnJvdCgpfWdldExlbmd0aCgpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2UodGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX1pbnZSb3QoKXtyZXR1cm4gdGhpcy5fcm90LnN5bSgpfXNldERlc3QodCl7dGhpcy5zeW0oKS5zZXRPcmlnKHQpfXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1kZWxldGUoKXt0aGlzLl9yb3Q9bnVsbH1vcmlnKCl7cmV0dXJuIHRoaXMuX3ZlcnRleH1yTmV4dCgpe3JldHVybiB0aGlzLl9yb3QuX25leHQuaW52Um90KCl9dG9TdHJpbmcoKXtjb25zdCB0PXRoaXMuX3ZlcnRleC5nZXRDb29yZGluYXRlKCksZT10aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCk7cmV0dXJuIEp0LnRvTGluZVN0cmluZyh0LGUpfWlzTGl2ZSgpe3JldHVybiBudWxsIT09dGhpcy5fcm90fWdldFByaW1hcnkoKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpPD0wP3RoaXM6dGhpcy5zeW0oKX1kUHJldigpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkuaW52Um90KCl9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9Z2V0Q2xhc3MoKXtyZXR1cm4geW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXlvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3JvdD1udWxsLHRoaXMuX3ZlcnRleD1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9O2NsYXNzIHhve2NvbnN0cnVjdG9yKCl7eG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnRTaXRlKHQpe2xldCBlPXRoaXMuX3N1YmRpdi5sb2NhdGUodCk7aWYodGhpcy5fc3ViZGl2LmlzVmVydGV4T2ZFZGdlKGUsdCkpcmV0dXJuIGU7dGhpcy5fc3ViZGl2LmlzT25FZGdlKGUsdC5nZXRDb29yZGluYXRlKCkpJiYoZT1lLm9QcmV2KCksdGhpcy5fc3ViZGl2LmRlbGV0ZShlLm9OZXh0KCkpKTtsZXQgbj10aGlzLl9zdWJkaXYubWFrZUVkZ2UoZS5vcmlnKCksdCk7eW8uc3BsaWNlKG4sZSk7Y29uc3Qgcz1uO2Rve249dGhpcy5fc3ViZGl2LmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKX13aGlsZShlLmxOZXh0KCkhPT1zKTtmb3IoOzspe2NvbnN0IGk9ZS5vUHJldigpO2lmKGkuZGVzdCgpLnJpZ2h0T2YoZSkmJnQuaXNJbkNpcmNsZShlLm9yaWcoKSxpLmRlc3QoKSxlLmRlc3QoKSkpeW8uc3dhcChlKSxlPWUub1ByZXYoKTtlbHNle2lmKGUub05leHQoKT09PXMpcmV0dXJuIG47ZT1lLm9OZXh0KCkubFByZXYoKX19fWluc2VydFNpdGVzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuaW5zZXJ0U2l0ZSh0KX19Z2V0Q2xhc3MoKXtyZXR1cm4geG99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXhvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2lzVXNpbmdUb2xlcmFuY2U9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3ViZGl2PXQsdGhpcy5faXNVc2luZ1RvbGVyYW5jZT10LmdldFRvbGVyYW5jZSgpPjB9O2NsYXNzIEVve2NvbnN0cnVjdG9yKCl7RW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1sb2NhdGUodCl7fWdldENsYXNzKCl7cmV0dXJuIEVvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Fby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIElve2NvbnN0cnVjdG9yKCl7SW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbml0KCl7dGhpcy5fbGFzdEVkZ2U9dGhpcy5maW5kRWRnZSgpfWxvY2F0ZSh0KXt0aGlzLl9sYXN0RWRnZS5pc0xpdmUoKXx8dGhpcy5pbml0KCk7Y29uc3QgZT10aGlzLl9zdWJkaXYubG9jYXRlRnJvbUVkZ2UodCx0aGlzLl9sYXN0RWRnZSk7cmV0dXJuIHRoaXMuX2xhc3RFZGdlPWUsZX1maW5kRWRnZSgpe3JldHVybiB0aGlzLl9zdWJkaXYuZ2V0RWRnZXMoKS5pdGVyYXRvcigpLm5leHQoKX1nZXRDbGFzcygpe3JldHVybiBJb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRW9dfX1Jby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9sYXN0RWRnZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3N1YmRpdj10LHRoaXMuaW5pdCgpfTtjbGFzcyBObyBleHRlbmRzIGN7Y29uc3RydWN0b3IoKXtzdXBlcigpLE5vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1zZ1dpdGhTcGF0aWFsKHQsZSl7cmV0dXJuIG51bGwhPT1lP3QrXCIgWyBcIitlK1wiIF1cIjp0fWdldFNlZ21lbnQoKXtyZXR1cm4gdGhpcy5fc2VnfWdldENsYXNzKCl7cmV0dXJuIE5vfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Oby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9zZWc9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Yy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Yy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFwiTG9jYXRlIGZhaWxlZCB0byBjb252ZXJnZSAoYXQgZWRnZTogXCIrdCtcIikuICBQb3NzaWJsZSBjYXVzZXMgaW5jbHVkZSBpbnZhbGlkIFN1YmRpdmlzaW9uIHRvcG9sb2d5IG9yIHZlcnkgY2xvc2Ugc2l0ZXNcIiksdGhpcy5fc2VnPW5ldyBlZSh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Yy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLE5vLm1zZ1dpdGhTcGF0aWFsKHQsZSkpLHRoaXMuX3NlZz1uZXcgZWUoZSl9fTtjbGFzcyBDb3tjb25zdHJ1Y3Rvcigpe0NvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXQodCl7fWdldENsYXNzKCl7cmV0dXJuIENvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Dby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFNve2NvbnN0cnVjdG9yKCl7U28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0VHJpYW5nbGVFZGdlcyh0LGUpe2lmKGVbMF09dCxlWzFdPWVbMF0ubE5leHQoKSxlWzJdPWVbMV0ubE5leHQoKSxlWzJdLmxOZXh0KCkhPT1lWzBdKXRocm93IG5ldyBuKFwiRWRnZXMgZG8gbm90IGZvcm0gYSB0cmlhbmdsZVwiKX1nZXRUcmlhbmdsZVZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IFRvO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZVZlcnRpY2VzKCl9aXNGcmFtZVZlcnRleCh0KXtyZXR1cm4hIXQuZXF1YWxzKHRoaXMuX2ZyYW1lVmVydGV4WzBdKXx8KCEhdC5lcXVhbHModGhpcy5fZnJhbWVWZXJ0ZXhbMV0pfHwhIXQuZXF1YWxzKHRoaXMuX2ZyYW1lVmVydGV4WzJdKSl9aXNWZXJ0ZXhPZkVkZ2UodCxlKXtyZXR1cm4hKCFlLmVxdWFscyh0Lm9yaWcoKSx0aGlzLl90b2xlcmFuY2UpJiYhZS5lcXVhbHModC5kZXN0KCksdGhpcy5fdG9sZXJhbmNlKSl9Y29ubmVjdCh0LGUpe2NvbnN0IG49eW8uY29ubmVjdCh0LGUpO3JldHVybiB0aGlzLl9xdWFkRWRnZXMuYWRkKG4pLG59Z2V0Vm9yb25vaUNlbGxQb2x5Z29uKHQsZSl7Y29uc3Qgbj1uZXcgeCxzPXQ7ZG97Y29uc3QgZT10LnJvdCgpLm9yaWcoKS5nZXRDb29yZGluYXRlKCk7bi5hZGQoZSksdD10Lm9QcmV2KCl9d2hpbGUodCE9PXMpO2NvbnN0IGk9bmV3IEk7aS5hZGRBbGwobiwhMSksaS5jbG9zZVJpbmcoKSxpLnNpemUoKTw0JiYoTy5vdXQucHJpbnRsbihpKSxpLmFkZChpLmdldChpLnNpemUoKS0xKSwhMCkpO2NvbnN0IHI9aS50b0Nvb3JkaW5hdGVBcnJheSgpLG89ZS5jcmVhdGVQb2x5Z29uKGUuY3JlYXRlTGluZWFyUmluZyhyKSksbD1zLm9yaWcoKTtyZXR1cm4gby5zZXRVc2VyRGF0YShsLmdldENvb3JkaW5hdGUoKSksb31zZXRMb2NhdG9yKHQpe3RoaXMuX2xvY2F0b3I9dH1pbml0U3ViZGl2KCl7Y29uc3QgdD10aGlzLm1ha2VFZGdlKHRoaXMuX2ZyYW1lVmVydGV4WzBdLHRoaXMuX2ZyYW1lVmVydGV4WzFdKSxlPXRoaXMubWFrZUVkZ2UodGhpcy5fZnJhbWVWZXJ0ZXhbMV0sdGhpcy5fZnJhbWVWZXJ0ZXhbMl0pO3lvLnNwbGljZSh0LnN5bSgpLGUpO2NvbnN0IG49dGhpcy5tYWtlRWRnZSh0aGlzLl9mcmFtZVZlcnRleFsyXSx0aGlzLl9mcmFtZVZlcnRleFswXSk7cmV0dXJuIHlvLnNwbGljZShlLnN5bSgpLG4pLHlvLnNwbGljZShuLnN5bSgpLHQpLHR9aXNGcmFtZUJvcmRlckVkZ2UodCl7Y29uc3QgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtTby5nZXRUcmlhbmdsZUVkZ2VzKHQsZSk7Y29uc3Qgbj1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtTby5nZXRUcmlhbmdsZUVkZ2VzKHQuc3ltKCksbik7Y29uc3Qgcz10LmxOZXh0KCkuZGVzdCgpO2lmKHRoaXMuaXNGcmFtZVZlcnRleChzKSlyZXR1cm4hMDtjb25zdCBpPXQuc3ltKCkubE5leHQoKS5kZXN0KCk7cmV0dXJuISF0aGlzLmlzRnJhbWVWZXJ0ZXgoaSl9bWFrZUVkZ2UodCxlKXtjb25zdCBuPXlvLm1ha2VFZGdlKHQsZSk7cmV0dXJuIHRoaXMuX3F1YWRFZGdlcy5hZGQobiksbn12aXNpdFRyaWFuZ2xlcyh0LGUpe3RoaXMuX3Zpc2l0ZWRLZXkrKztjb25zdCBuPW5ldyBvbjtuLnB1c2godGhpcy5fc3RhcnRpbmdFZGdlKTtjb25zdCBzPW5ldyBKO2Zvcig7IW4uZW1wdHkoKTspe2NvbnN0IGk9bi5wb3AoKTtpZighcy5jb250YWlucyhpKSl7Y29uc3Qgcj10aGlzLmZldGNoVHJpYW5nbGVUb1Zpc2l0KGksbixlLHMpO251bGwhPT1yJiZ0LnZpc2l0KHIpfX19aXNGcmFtZUVkZ2UodCl7cmV0dXJuISghdGhpcy5pc0ZyYW1lVmVydGV4KHQub3JpZygpKSYmIXRoaXMuaXNGcmFtZVZlcnRleCh0LmRlc3QoKSkpfWlzT25FZGdlKHQsZSl7cmV0dXJuIHRoaXMuX3NlZy5zZXRDb29yZGluYXRlcyh0Lm9yaWcoKS5nZXRDb29yZGluYXRlKCksdC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKSx0aGlzLl9zZWcuZGlzdGFuY2UoZSk8dGhpcy5fZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlfWdldEVudmVsb3BlKCl7cmV0dXJuIG5ldyBOKHRoaXMuX2ZyYW1lRW52KX1jcmVhdGVGcmFtZSh0KXtjb25zdCBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCk7bGV0IHM9MDtzPWU+bj8xMCplOjEwKm4sdGhpcy5fZnJhbWVWZXJ0ZXhbMF09bmV3IHBvKCh0LmdldE1heFgoKSt0LmdldE1pblgoKSkvMix0LmdldE1heFkoKStzKSx0aGlzLl9mcmFtZVZlcnRleFsxXT1uZXcgcG8odC5nZXRNaW5YKCktcyx0LmdldE1pblkoKS1zKSx0aGlzLl9mcmFtZVZlcnRleFsyXT1uZXcgcG8odC5nZXRNYXhYKCkrcyx0LmdldE1pblkoKS1zKSx0aGlzLl9mcmFtZUVudj1uZXcgTih0aGlzLl9mcmFtZVZlcnRleFswXS5nZXRDb29yZGluYXRlKCksdGhpcy5fZnJhbWVWZXJ0ZXhbMV0uZ2V0Q29vcmRpbmF0ZSgpKSx0aGlzLl9mcmFtZUVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5fZnJhbWVWZXJ0ZXhbMl0uZ2V0Q29vcmRpbmF0ZSgpKX1nZXRUcmlhbmdsZUNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IFJvO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZXMoKX1nZXRWZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyBKO2ZvcihsZXQgbj10aGlzLl9xdWFkRWRnZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCksaT1zLm9yaWcoKTshdCYmdGhpcy5pc0ZyYW1lVmVydGV4KGkpfHxlLmFkZChpKTtjb25zdCByPXMuZGVzdCgpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocil8fGUuYWRkKHIpfXJldHVybiBlfWZldGNoVHJpYW5nbGVUb1Zpc2l0KHQsZSxuLHMpe2xldCBpPXQscj0wLG89ITE7ZG97dGhpcy5fdHJpRWRnZXNbcl09aSx0aGlzLmlzRnJhbWVFZGdlKGkpJiYobz0hMCk7Y29uc3QgdD1pLnN5bSgpO3MuY29udGFpbnModCl8fGUucHVzaCh0KSxzLmFkZChpKSxyKyssaT1pLmxOZXh0KCl9d2hpbGUoaSE9PXQpO3JldHVybiBvJiYhbj9udWxsOnRoaXMuX3RyaUVkZ2VzfWdldEVkZ2VzKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3F1YWRFZGdlcztpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLmdldFByaW1hcnlFZGdlcyghMSksbj1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7bGV0IHM9MDtmb3IobGV0IGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgZT1pLm5leHQoKTtuW3MrK109dC5jcmVhdGVMaW5lU3RyaW5nKFtlLm9yaWcoKS5nZXRDb29yZGluYXRlKCksZS5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpXSl9cmV0dXJuIHQuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG4pfX1nZXRWZXJ0ZXhVbmlxdWVFZGdlcyh0KXtjb25zdCBlPW5ldyB4LG49bmV3IEo7Zm9yKGxldCBzPXRoaXMuX3F1YWRFZGdlcy5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKSxyPWkub3JpZygpO24uY29udGFpbnMocil8fChuLmFkZChyKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KHIpfHxlLmFkZChpKSk7Y29uc3Qgbz1pLnN5bSgpLGw9by5vcmlnKCk7bi5jb250YWlucyhsKXx8KG4uYWRkKGwpLCF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgobCl8fGUuYWRkKG8pKX1yZXR1cm4gZX1nZXRUcmlhbmdsZUVkZ2VzKHQpe2NvbnN0IGU9bmV3IExvO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZUVkZ2VzKCl9Z2V0UHJpbWFyeUVkZ2VzKHQpe3RoaXMuX3Zpc2l0ZWRLZXkrKztjb25zdCBlPW5ldyB4LG49bmV3IG9uO24ucHVzaCh0aGlzLl9zdGFydGluZ0VkZ2UpO2NvbnN0IHM9bmV3IEo7Zm9yKDshbi5lbXB0eSgpOyl7Y29uc3QgaT1uLnBvcCgpO2lmKCFzLmNvbnRhaW5zKGkpKXtjb25zdCByPWkuZ2V0UHJpbWFyeSgpOyF0JiZ0aGlzLmlzRnJhbWVFZGdlKHIpfHxlLmFkZChyKSxuLnB1c2goaS5vTmV4dCgpKSxuLnB1c2goaS5zeW0oKS5vTmV4dCgpKSxzLmFkZChpKSxzLmFkZChpLnN5bSgpKX19cmV0dXJuIGV9ZGVsZXRlKHQpe3lvLnNwbGljZSh0LHQub1ByZXYoKSkseW8uc3BsaWNlKHQuc3ltKCksdC5zeW0oKS5vUHJldigpKTtjb25zdCBlPXQuc3ltKCksbj10LnJvdCgpLHM9dC5yb3QoKS5zeW0oKTt0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKHQpLHRoaXMuX3F1YWRFZGdlcy5yZW1vdmUoZSksdGhpcy5fcXVhZEVkZ2VzLnJlbW92ZShuKSx0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKHMpLHQuZGVsZXRlKCksZS5kZWxldGUoKSxuLmRlbGV0ZSgpLHMuZGVsZXRlKCl9bG9jYXRlRnJvbUVkZ2UodCxlKXtsZXQgbj0wO2NvbnN0IHM9dGhpcy5fcXVhZEVkZ2VzLnNpemUoKTtsZXQgaT1lO2Zvcig7Oyl7aWYobisrLG4+cyl0aHJvdyBuZXcgTm8oaS50b0xpbmVTZWdtZW50KCkpO2lmKHQuZXF1YWxzKGkub3JpZygpKXx8dC5lcXVhbHMoaS5kZXN0KCkpKWJyZWFrO2lmKHQucmlnaHRPZihpKSlpPWkuc3ltKCk7ZWxzZSBpZih0LnJpZ2h0T2YoaS5vTmV4dCgpKSl7aWYodC5yaWdodE9mKGkuZFByZXYoKSkpYnJlYWs7aT1pLmRQcmV2KCl9ZWxzZSBpPWkub05leHQoKX1yZXR1cm4gaX1nZXRUb2xlcmFuY2UoKXtyZXR1cm4gdGhpcy5fdG9sZXJhbmNlfWdldFZvcm9ub2lDZWxsUG9seWdvbnModCl7dGhpcy52aXNpdFRyaWFuZ2xlcyhuZXcgd28sITApO2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXRoaXMuZ2V0VmVydGV4VW5pcXVlRWRnZXMoITEpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO2UuYWRkKHRoaXMuZ2V0Vm9yb25vaUNlbGxQb2x5Z29uKHMsdCkpfXJldHVybiBlfWdldFZvcm9ub2lEaWFncmFtKHQpe2NvbnN0IGU9dGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb25zKHQpO3JldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihIdC50b0dlb21ldHJ5QXJyYXkoZSkpfWdldFRyaWFuZ2xlcyh0KXtjb25zdCBlPXRoaXMuZ2V0VHJpYW5nbGVDb29yZGluYXRlcyghMSksbj1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7bGV0IHM9MDtmb3IobGV0IGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgZT1pLm5leHQoKTtuW3MrK109dC5jcmVhdGVQb2x5Z29uKHQuY3JlYXRlTGluZWFyUmluZyhlKSl9cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG4pfWluc2VydFNpdGUodCl7bGV0IGU9dGhpcy5sb2NhdGUodCk7aWYodC5lcXVhbHMoZS5vcmlnKCksdGhpcy5fdG9sZXJhbmNlKXx8dC5lcXVhbHMoZS5kZXN0KCksdGhpcy5fdG9sZXJhbmNlKSlyZXR1cm4gZTtsZXQgbj10aGlzLm1ha2VFZGdlKGUub3JpZygpLHQpO3lvLnNwbGljZShuLGUpO2NvbnN0IHM9bjtkb3tuPXRoaXMuY29ubmVjdChlLG4uc3ltKCkpLGU9bi5vUHJldigpfXdoaWxlKGUubE5leHQoKSE9PXMpO3JldHVybiBzfWxvY2F0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHBvKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbG9jYXRvci5sb2NhdGUodCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbG9jYXRvci5sb2NhdGUobmV3IHBvKHQpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9sb2NhdG9yLmxvY2F0ZShuZXcgcG8odCkpO2lmKG51bGw9PT1uKXJldHVybiBudWxsO2xldCBzPW47bi5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQpJiYocz1uLnN5bSgpKTtsZXQgaT1zO2Rve2lmKGkuZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRChlKSlyZXR1cm4gaTtpPWkub05leHQoKX13aGlsZShpIT09cyk7cmV0dXJuIG51bGx9fWdldENsYXNzKCl7cmV0dXJuIFNvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyB3b3tjb25zdHJ1Y3Rvcigpe3dvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXQodCl7Y29uc3QgZT10WzBdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksbj10WzFdLm9yaWcoKS5nZXRDb29yZGluYXRlKCkscz10WzJdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksaT1yZS5jaXJjdW1jZW50cmUoZSxuLHMpLHI9bmV3IHBvKGkpO2ZvcihsZXQgZT0wO2U8MztlKyspdFtlXS5yb3QoKS5zZXRPcmlnKHIpfWdldENsYXNzKCl7cmV0dXJuIHdvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltDb119fXdvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgTG97Y29uc3RydWN0b3IoKXtMby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldFRyaWFuZ2xlRWRnZXMoKXtyZXR1cm4gdGhpcy5fdHJpTGlzdH12aXNpdCh0KXt0aGlzLl90cmlMaXN0LmFkZCh0KX1nZXRDbGFzcygpe3JldHVybiBMb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQ29dfX1Mby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl90cmlMaXN0PW5ldyB4fTtjbGFzcyBUb3tjb25zdHJ1Y3Rvcigpe1RvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXQodCl7dGhpcy5fdHJpTGlzdC5hZGQoW3RbMF0ub3JpZygpLHRbMV0ub3JpZygpLHRbMl0ub3JpZygpXSl9Z2V0VHJpYW5nbGVWZXJ0aWNlcygpe3JldHVybiB0aGlzLl90cmlMaXN0fWdldENsYXNzKCl7cmV0dXJuIFRvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltDb119fVRvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3RyaUxpc3Q9bmV3IHh9O2NsYXNzIFJve2NvbnN0cnVjdG9yKCl7Um8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jaGVja1RyaWFuZ2xlU2l6ZSh0KXtsZXQgZT1cIlwiO3QubGVuZ3RoPj0yP2U9SnQudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSk6dC5sZW5ndGg+PTEmJihlPUp0LnRvUG9pbnQodFswXSkpfXZpc2l0KHQpe3RoaXMuX2Nvb3JkTGlzdC5jbGVhcigpO2ZvcihsZXQgZT0wO2U8MztlKyspe2NvbnN0IG49dFtlXS5vcmlnKCk7dGhpcy5fY29vcmRMaXN0LmFkZChuLmdldENvb3JkaW5hdGUoKSl9aWYodGhpcy5fY29vcmRMaXN0LnNpemUoKT4wKXt0aGlzLl9jb29yZExpc3QuY2xvc2VSaW5nKCk7Y29uc3QgdD10aGlzLl9jb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKTtpZig0IT09dC5sZW5ndGgpcmV0dXJuIG51bGw7dGhpcy5fdHJpQ29vcmRzLmFkZCh0KX19Z2V0VHJpYW5nbGVzKCl7cmV0dXJuIHRoaXMuX3RyaUNvb3Jkc31nZXRDbGFzcygpe3JldHVybiBSb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQ29dfX1Sby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb29yZExpc3Q9bmV3IEksdGhpcy5fdHJpQ29vcmRzPW5ldyB4fSxTby5UcmlhbmdsZUNpcmN1bWNlbnRyZVZpc2l0b3I9d28sU28uVHJpYW5nbGVFZGdlc0xpc3RWaXNpdG9yPUxvLFNvLlRyaWFuZ2xlVmVydGV4TGlzdFZpc2l0b3I9VG8sU28uVHJpYW5nbGVDb29yZGluYXRlc1Zpc2l0b3I9Um8sU28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdmlzaXRlZEtleT0wLHRoaXMuX3F1YWRFZGdlcz1uZXcgeCx0aGlzLl9zdGFydGluZ0VkZ2U9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbCx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9mcmFtZVZlcnRleD1uZXcgQXJyYXkoMykuZmlsbChudWxsKSx0aGlzLl9mcmFtZUVudj1udWxsLHRoaXMuX2xvY2F0b3I9bnVsbCx0aGlzLl9zZWc9bmV3IGVlLHRoaXMuX3RyaUVkZ2VzPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3RvbGVyYW5jZT1lLHRoaXMuX2VkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1lL1NvLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUix0aGlzLmNyZWF0ZUZyYW1lKHQpLHRoaXMuX3N0YXJ0aW5nRWRnZT10aGlzLmluaXRTdWJkaXYoKSx0aGlzLl9sb2NhdG9yPW5ldyBJbyh0aGlzKX0sU28uRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SPTFlMztjbGFzcyBQb3tjb25zdHJ1Y3Rvcigpe1BvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TGluZVNlZ21lbnQoKXtyZXR1cm4gdGhpcy5fbHN9Z2V0RW5kWigpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpLnp9Z2V0U3RhcnRaKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCkuen1pbnRlcnNlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2xzLmludGVyc2VjdGlvbih0LmdldExpbmVTZWdtZW50KCkpfWdldFN0YXJ0KCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCl9Z2V0RW5kKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSl9Z2V0RW5kWSgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpLnl9Z2V0U3RhcnRYKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCkueH1lcXVhbHNUb3BvKHQpe3JldHVybiB0aGlzLl9scy5lcXVhbHNUb3BvKHQuZ2V0TGluZVNlZ21lbnQoKSl9Z2V0U3RhcnRZKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCkueX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9Z2V0RW5kWCgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpLnh9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fbHMudG9TdHJpbmcoKX1nZXRDbGFzcygpe3JldHVybiBQb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbHM9bnVsbCx0aGlzLl9kYXRhPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2xzPW5ldyBlZSh0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2xzPW5ldyBlZSh0LGUpLHRoaXMuX2RhdGE9bn1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtQby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBnKHQsZSxuKSxuZXcgZyhzLGkscikpfWVsc2UgaWYoNz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdLG89YXJndW1lbnRzWzZdO1BvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IGcodCxlLG4pLG5ldyBnKHMsaSxyKSxvKX19O2NsYXNzIHZve2NvbnN0cnVjdG9yKCl7dm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tcHV0ZVZlcnRleEVudmVsb3BlKHQpe2NvbnN0IGU9bmV3IE47Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5leHBhbmRUb0luY2x1ZGUodC5nZXRDb29yZGluYXRlKCkpfXJldHVybiBlfWdldEluaXRpYWxWZXJ0aWNlcygpe3JldHVybiB0aGlzLl9pbml0aWFsVmVydGljZXN9Z2V0S0RUKCl7cmV0dXJuIHRoaXMuX2tkdH1lbmZvcmNlQ29uc3RyYWludHMoKXt0aGlzLmFkZENvbnN0cmFpbnRWZXJ0aWNlcygpO2xldCB0PTAsZT0wO2Rve2U9dGhpcy5lbmZvcmNlR2FicmllbCh0aGlzLl9zZWdtZW50cyksdCsrfXdoaWxlKGU+MCYmdDx2by5NQVhfU1BMSVRfSVRFUil9aW5zZXJ0U2l0ZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKHQpfX1nZXRWZXJ0ZXhGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX3ZlcnRleEZhY3Rvcnl9Z2V0UG9pbnRBcnJheSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2luaXRpYWxWZXJ0aWNlcy5zaXplKCkrdGhpcy5fc2VnVmVydGljZXMuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBlPTA7Zm9yKGxldCBuPXRoaXMuX2luaXRpYWxWZXJ0aWNlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTt0W2UrK109cy5nZXRDb29yZGluYXRlKCl9Zm9yKGxldCBuPXRoaXMuX3NlZ1ZlcnRpY2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3RbZSsrXT1zLmdldENvb3JkaW5hdGUoKX1yZXR1cm4gdH1zZXRDb25zdHJhaW50cyh0LGUpe3RoaXMuX3NlZ21lbnRzPXQsdGhpcy5fc2VnVmVydGljZXM9ZX1jb21wdXRlQ29udmV4SHVsbCgpe2NvbnN0IHQ9bmV3IEh0LGU9dGhpcy5nZXRQb2ludEFycmF5KCksbj1uZXcgYW4oZSx0KTt0aGlzLl9jb252ZXhIdWxsPW4uZ2V0Q29udmV4SHVsbCgpfWFkZENvbnN0cmFpbnRWZXJ0aWNlcygpe3RoaXMuY29tcHV0ZUNvbnZleEh1bGwoKSx0aGlzLmluc2VydFNpdGVzKHRoaXMuX3NlZ1ZlcnRpY2VzKX1maW5kTm9uR2FicmllbFBvaW50KHQpe2NvbnN0IGU9dC5nZXRTdGFydCgpLG49dC5nZXRFbmQoKSxzPW5ldyBnKChlLngrbi54KS8yLChlLnkrbi55KS8yKSxyPWUuZGlzdGFuY2Uocyksbz1uZXcgTihzKTtvLmV4cGFuZEJ5KHIpO2NvbnN0IGw9dGhpcy5fa2R0LnF1ZXJ5KG8pO2xldCBhPW51bGwsYz1pLk1BWF9WQUxVRTtmb3IobGV0IHQ9bC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgaT10Lm5leHQoKS5nZXRDb29yZGluYXRlKCk7aWYoaS5lcXVhbHMyRChlKXx8aS5lcXVhbHMyRChuKSljb250aW51ZTtjb25zdCBvPXMuZGlzdGFuY2UoaSk7aWYobzxyKXtjb25zdCB0PW87KG51bGw9PT1hfHx0PGMpJiYoYT1pLGM9dCl9fXJldHVybiBhfWdldENvbnN0cmFpbnRTZWdtZW50cygpe3JldHVybiB0aGlzLl9zZWdtZW50c31zZXRTcGxpdFBvaW50RmluZGVyKHQpe3RoaXMuX3NwbGl0RmluZGVyPXR9Z2V0Q29udmV4SHVsbCgpe3JldHVybiB0aGlzLl9jb252ZXhIdWxsfWdldFRvbGVyYW5jZSgpe3JldHVybiB0aGlzLl90b2xlcmFuY2V9ZW5mb3JjZUdhYnJpZWwodCl7Y29uc3QgZT1uZXcgeDtsZXQgbj0wO2NvbnN0IHM9bmV3IHg7Zm9yKGxldCBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IHQ9aS5uZXh0KCkscj10aGlzLmZpbmROb25HYWJyaWVsUG9pbnQodCk7aWYobnVsbD09PXIpY29udGludWU7dGhpcy5fc3BsaXRQdD10aGlzLl9zcGxpdEZpbmRlci5maW5kU3BsaXRQb2ludCh0LHIpO2NvbnN0IG89dGhpcy5jcmVhdGVWZXJ0ZXgodGhpcy5fc3BsaXRQdCx0KTt0aGlzLmluc2VydFNpdGUobykuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHRoaXMuX3NwbGl0UHQpO2NvbnN0IGw9bmV3IFBvKHQuZ2V0U3RhcnRYKCksdC5nZXRTdGFydFkoKSx0LmdldFN0YXJ0WigpLG8uZ2V0WCgpLG8uZ2V0WSgpLG8uZ2V0WigpLHQuZ2V0RGF0YSgpKSxhPW5ldyBQbyhvLmdldFgoKSxvLmdldFkoKSxvLmdldFooKSx0LmdldEVuZFgoKSx0LmdldEVuZFkoKSx0LmdldEVuZFooKSx0LmdldERhdGEoKSk7ZS5hZGQobCksZS5hZGQoYSkscy5hZGQodCksbis9MX1yZXR1cm4gdC5yZW1vdmVBbGwocyksdC5hZGRBbGwoZSksbn1jcmVhdGVWZXJ0ZXgoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbDtyZXR1cm4gZT1udWxsIT09dGhpcy5fdmVydGV4RmFjdG9yeT90aGlzLl92ZXJ0ZXhGYWN0b3J5LmNyZWF0ZVZlcnRleCh0LG51bGwpOm5ldyBtbyh0KSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsO3JldHVybiBuPW51bGwhPT10aGlzLl92ZXJ0ZXhGYWN0b3J5P3RoaXMuX3ZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsZSk6bmV3IG1vKHQpLG4uc2V0T25Db25zdHJhaW50KCEwKSxufX1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLl9zdWJkaXZ9Y29tcHV0ZUJvdW5kaW5nQm94KCl7Y29uc3QgdD12by5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5faW5pdGlhbFZlcnRpY2VzKSxlPXZvLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLl9zZWdWZXJ0aWNlcyksbj1uZXcgTih0KTtuLmV4cGFuZFRvSW5jbHVkZShlKTtjb25zdCBzPS4yKm4uZ2V0V2lkdGgoKSxpPS4yKm4uZ2V0SGVpZ2h0KCkscj1NYXRoLm1heChzLGkpO3RoaXMuX2NvbXB1dGVBcmVhRW52PW5ldyBOKG4pLHRoaXMuX2NvbXB1dGVBcmVhRW52LmV4cGFuZEJ5KHIpfXNldFZlcnRleEZhY3RvcnkodCl7dGhpcy5fdmVydGV4RmFjdG9yeT10fWZvcm1Jbml0aWFsRGVsYXVuYXkoKXt0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLHRoaXMuX3N1YmRpdj1uZXcgU28odGhpcy5fY29tcHV0ZUFyZWFFbnYsdGhpcy5fdG9sZXJhbmNlKSx0aGlzLl9zdWJkaXYuc2V0TG9jYXRvcihuZXcgSW8odGhpcy5fc3ViZGl2KSksdGhpcy5faW5jRGVsPW5ldyB4byh0aGlzLl9zdWJkaXYpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5faW5pdGlhbFZlcnRpY2VzKX1pbnNlcnRTaXRlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtbyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLl9rZHQuaW5zZXJ0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpO2lmKGUuaXNSZXBlYXRlZCgpKXtjb25zdCBuPWUuZ2V0RGF0YSgpO3JldHVybiBuLm1lcmdlKHQpLG59cmV0dXJuIHRoaXMuX2luY0RlbC5pbnNlcnRTaXRlKHQpLHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluc2VydFNpdGUodGhpcy5jcmVhdGVWZXJ0ZXgodCkpfX1nZXRDbGFzcygpe3JldHVybiB2b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5pdGlhbFZlcnRpY2VzPW51bGwsdGhpcy5fc2VnVmVydGljZXM9bnVsbCx0aGlzLl9zZWdtZW50cz1uZXcgeCx0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9pbmNEZWw9bnVsbCx0aGlzLl9jb252ZXhIdWxsPW51bGwsdGhpcy5fc3BsaXRGaW5kZXI9bmV3IF9vLHRoaXMuX2tkdD1udWxsLHRoaXMuX3ZlcnRleEZhY3Rvcnk9bnVsbCx0aGlzLl9jb21wdXRlQXJlYUVudj1udWxsLHRoaXMuX3NwbGl0UHQ9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbml0aWFsVmVydGljZXM9bmV3IHgodCksdGhpcy5fdG9sZXJhbmNlPWUsdGhpcy5fa2R0PW5ldyBlcyhlKX0sdm8uTUFYX1NQTElUX0lURVI9OTk7Y2xhc3MgT297Y29uc3RydWN0b3IoKXtPby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBleHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl7aWYobnVsbD09PXQpcmV0dXJuIG5ldyBJO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO3JldHVybiBPby51bmlxdWUoZSl9c3RhdGljIGVudmVsb3BlKHQpe2NvbnN0IGU9bmV3IE47Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5leHBhbmRUb0luY2x1ZGUodCl9cmV0dXJuIGV9c3RhdGljIHVuaXF1ZSh0KXtjb25zdCBlPVguY29weURlZXAodCk7cmV0dXJuIGh0LnNvcnQoZSksbmV3IEkoZSwhMSl9c3RhdGljIHRvVmVydGljZXModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZChuZXcgcG8odCkpfXJldHVybiBlfWNyZWF0ZSgpe2lmKG51bGwhPT10aGlzLl9zdWJkaXYpcmV0dXJuIG51bGw7Y29uc3QgdD1Pby5lbnZlbG9wZSh0aGlzLl9zaXRlQ29vcmRzKSxlPU9vLnRvVmVydGljZXModGhpcy5fc2l0ZUNvb3Jkcyk7dGhpcy5fc3ViZGl2PW5ldyBTbyh0LHRoaXMuX3RvbGVyYW5jZSksbmV3IHhvKHRoaXMuX3N1YmRpdikuaW5zZXJ0U2l0ZXMoZSl9c2V0VG9sZXJhbmNlKHQpe3RoaXMuX3RvbGVyYW5jZT10fXNldFNpdGVzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPU9vLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPU9vLnVuaXF1ZShYLnRvQ29vcmRpbmF0ZUFycmF5KHQpKX19Z2V0RWRnZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldEVkZ2VzKHQpfWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fWdldFRyaWFuZ2xlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfWdldENsYXNzKCl7cmV0dXJuIE9vfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Pby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zaXRlQ29vcmRzPW51bGwsdGhpcy5fdG9sZXJhbmNlPTAsdGhpcy5fc3ViZGl2PW51bGx9O2NsYXNzIGJve2NvbnN0cnVjdG9yKCl7Ym8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9eGUuZ2V0TGluZXModCksbj1uZXcgeDtmb3IobGV0IHQ9ZS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtiby5jcmVhdGVDb25zdHJhaW50U2VnbWVudHMoZSxuKX1yZXR1cm4gbn1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTE7dDxuLmxlbmd0aDt0KyspZS5hZGQobmV3IFBvKG5bdC0xXSxuW3RdKSl9fWNyZWF0ZVNpdGVWZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXAuY29udGFpbnNLZXkodCl8fGUuYWRkKG5ldyBtbyh0KSl9cmV0dXJuIGV9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PU9vLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpO2xldCBlPW5ldyB4O251bGwhPT10aGlzLl9jb25zdHJhaW50TGluZXMmJih0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb25zdHJhaW50TGluZXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSx0aGlzLmNyZWF0ZVZlcnRpY2VzKHRoaXMuX2NvbnN0cmFpbnRMaW5lcyksZT1iby5jcmVhdGVDb25zdHJhaW50U2VnbWVudHModGhpcy5fY29uc3RyYWludExpbmVzKSk7Y29uc3Qgbj10aGlzLmNyZWF0ZVNpdGVWZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKSxzPW5ldyB2byhuLHRoaXMuX3RvbGVyYW5jZSk7cy5zZXRDb25zdHJhaW50cyhlLG5ldyB4KHRoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXAudmFsdWVzKCkpKSxzLmZvcm1Jbml0aWFsRGVsYXVuYXkoKSxzLmVuZm9yY2VDb25zdHJhaW50cygpLHRoaXMuX3N1YmRpdj1zLmdldFN1YmRpdmlzaW9uKCl9c2V0VG9sZXJhbmNlKHQpe3RoaXMuX3RvbGVyYW5jZT10fXNldENvbnN0cmFpbnRzKHQpe3RoaXMuX2NvbnN0cmFpbnRMaW5lcz10fXNldFNpdGVzKHQpe3RoaXMuX3NpdGVDb29yZHM9T28uZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWdldEVkZ2VzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRFZGdlcyh0KX1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdn1nZXRUcmlhbmdsZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldFRyaWFuZ2xlcyh0KX1jcmVhdGVWZXJ0aWNlcyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgbj1uZXcgbW8oZVt0XSk7dGhpcy5fY29uc3RyYWludFZlcnRleE1hcC5wdXQoZVt0XSxuKX19Z2V0Q2xhc3MoKXtyZXR1cm4gYm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWJvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl9jb25zdHJhaW50TGluZXM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwPW5ldyBydH07Y2xhc3MgTW97Y29uc3RydWN0b3IoKXtNby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjbGlwR2VvbWV0cnlDb2xsZWN0aW9uKHQsZSl7Y29uc3Qgbj10LmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KGUpLHM9bmV3IHg7Zm9yKGxldCBpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe2NvbnN0IHI9dC5nZXRHZW9tZXRyeU4oaSk7bGV0IG89bnVsbDtlLmNvbnRhaW5zKHIuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT9vPXI6ZS5pbnRlcnNlY3RzKHIuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKG89bi5pbnRlcnNlY3Rpb24ociksby5zZXRVc2VyRGF0YShyLmdldFVzZXJEYXRhKCkpKSxudWxsPT09b3x8by5pc0VtcHR5KCl8fHMuYWRkKG8pfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oSHQudG9HZW9tZXRyeUFycmF5KHMpKX1jcmVhdGUoKXtpZihudWxsIT09dGhpcy5fc3ViZGl2KXJldHVybiBudWxsO2NvbnN0IHQ9T28uZW52ZWxvcGUodGhpcy5fc2l0ZUNvb3Jkcyk7dGhpcy5fZGlhZ3JhbUVudj10O2NvbnN0IGU9TWF0aC5tYXgodGhpcy5fZGlhZ3JhbUVudi5nZXRXaWR0aCgpLHRoaXMuX2RpYWdyYW1FbnYuZ2V0SGVpZ2h0KCkpO3RoaXMuX2RpYWdyYW1FbnYuZXhwYW5kQnkoZSksbnVsbCE9PXRoaXMuX2NsaXBFbnYmJnRoaXMuX2RpYWdyYW1FbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2NsaXBFbnYpO2NvbnN0IG49T28udG9WZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKTt0aGlzLl9zdWJkaXY9bmV3IFNvKHQsdGhpcy5fdG9sZXJhbmNlKSxuZXcgeG8odGhpcy5fc3ViZGl2KS5pbnNlcnRTaXRlcyhuKX1nZXREaWFncmFtKHQpe3RoaXMuY3JlYXRlKCk7Y29uc3QgZT10aGlzLl9zdWJkaXYuZ2V0Vm9yb25vaURpYWdyYW0odCk7cmV0dXJuIE1vLmNsaXBHZW9tZXRyeUNvbGxlY3Rpb24oZSx0aGlzLl9kaWFncmFtRW52KX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0U2l0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9T28uZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9T28udW5pcXVlKFgudG9Db29yZGluYXRlQXJyYXkodCkpfX1zZXRDbGlwRW52ZWxvcGUodCl7dGhpcy5fY2xpcEVudj10fWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fWdldENsYXNzKCl7cmV0dXJuIE1vfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Nby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zaXRlQ29vcmRzPW51bGwsdGhpcy5fdG9sZXJhbmNlPTAsdGhpcy5fc3ViZGl2PW51bGwsdGhpcy5fY2xpcEVudj1udWxsLHRoaXMuX2RpYWdyYW1FbnY9bnVsbH07dmFyIERvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFZlcnRleDpwb30pLEFvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLENvbmZvcm1pbmdEZWxhdW5heVRyaWFuZ3VsYXRpb25CdWlsZGVyOmJvLERlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6T28sVm9yb25vaURpYWdyYW1CdWlsZGVyOk1vLHF1YWRlZGdlOkRvfSk7Y2xhc3MgRm97Y29uc3RydWN0b3IoKXtGby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRFbmRMb2NhdGlvbih0KXtjb25zdCBlPW5ldyBGbztyZXR1cm4gZS5zZXRUb0VuZCh0KSxlfXN0YXRpYyBwb2ludEFsb25nU2VnbWVudEJ5RnJhY3Rpb24odCxlLG4pe2lmKG48PTApcmV0dXJuIHQ7aWYobj49MSlyZXR1cm4gZTtjb25zdCBzPShlLngtdC54KSpuK3QueCxpPShlLnktdC55KSpuK3QueSxyPShlLnotdC56KSpuK3QuejtyZXR1cm4gbmV3IGcocyxpLHIpfXN0YXRpYyBjb21wYXJlTG9jYXRpb25WYWx1ZXModCxlLG4scyxpLHIpe3JldHVybiB0PHM/LTE6dD5zPzE6ZTxpPy0xOmU+aT8xOm48cj8tMTpuPnI/MTowfWdldFNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLl9zZWdtZW50SW5kZXh9Z2V0Q29tcG9uZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXh9aXNFbmRwb2ludCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KS5nZXROdW1Qb2ludHMoKS0xO3JldHVybiB0aGlzLl9zZWdtZW50SW5kZXg+PWV8fHRoaXMuX3NlZ21lbnRJbmRleD09PWUmJnRoaXMuX3NlZ21lbnRGcmFjdGlvbj49MX1pc1ZhbGlkKHQpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4PDB8fHRoaXMuX2NvbXBvbmVudEluZGV4Pj10LmdldE51bUdlb21ldHJpZXMoKSlyZXR1cm4hMTtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTtyZXR1cm4hKHRoaXMuX3NlZ21lbnRJbmRleDwwfHx0aGlzLl9zZWdtZW50SW5kZXg+ZS5nZXROdW1Qb2ludHMoKSkmJigodGhpcy5fc2VnbWVudEluZGV4IT09ZS5nZXROdW1Qb2ludHMoKXx8MD09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbikmJiEodGhpcy5fc2VnbWVudEZyYWN0aW9uPDB8fHRoaXMuX3NlZ21lbnRGcmFjdGlvbj4xKSl9bm9ybWFsaXplKCl7dGhpcy5fc2VnbWVudEZyYWN0aW9uPDAmJih0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksdGhpcy5fc2VnbWVudEZyYWN0aW9uPjEmJih0aGlzLl9zZWdtZW50RnJhY3Rpb249MSksdGhpcy5fY29tcG9uZW50SW5kZXg8MCYmKHRoaXMuX2NvbXBvbmVudEluZGV4PTAsdGhpcy5fc2VnbWVudEluZGV4PTAsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTApLHRoaXMuX3NlZ21lbnRJbmRleDwwJiYodGhpcy5fc2VnbWVudEluZGV4PTAsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTApLDE9PT10aGlzLl9zZWdtZW50RnJhY3Rpb24mJih0aGlzLl9zZWdtZW50RnJhY3Rpb249MCx0aGlzLl9zZWdtZW50SW5kZXgrPTEpfXRvTG93ZXN0KHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLmdldE51bVBvaW50cygpLTE7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleDxlP3RoaXM6bmV3IEZvKHRoaXMuX2NvbXBvbmVudEluZGV4LGUsMSwhMSl9Z2V0Q29vcmRpbmF0ZSh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KSxuPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KTtpZih0aGlzLl9zZWdtZW50SW5kZXg+PWUuZ2V0TnVtUG9pbnRzKCktMSlyZXR1cm4gbjtjb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KzEpO3JldHVybiBGby5wb2ludEFsb25nU2VnbWVudEJ5RnJhY3Rpb24obixzLHRoaXMuX3NlZ21lbnRGcmFjdGlvbil9Z2V0U2VnbWVudEZyYWN0aW9uKCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRGcmFjdGlvbn1nZXRTZWdtZW50KHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLG49ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgpO2lmKHRoaXMuX3NlZ21lbnRJbmRleD49ZS5nZXROdW1Qb2ludHMoKS0xKXtjb25zdCB0PWUuZ2V0Q29vcmRpbmF0ZU4oZS5nZXROdW1Qb2ludHMoKS0yKTtyZXR1cm4gbmV3IGVlKHQsbil9Y29uc3Qgcz1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCsxKTtyZXR1cm4gbmV3IGVlKG4scyl9Y2xhbXAodCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg+PXQuZ2V0TnVtR2VvbWV0cmllcygpKXJldHVybiB0aGlzLnNldFRvRW5kKHQpLG51bGw7aWYodGhpcy5fc2VnbWVudEluZGV4Pj10LmdldE51bVBvaW50cygpKXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTt0aGlzLl9zZWdtZW50SW5kZXg9ZS5nZXROdW1Qb2ludHMoKS0xLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xfX1zZXRUb0VuZCh0KXt0aGlzLl9jb21wb25lbnRJbmRleD10LmdldE51bUdlb21ldHJpZXMoKS0xO2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3RoaXMuX3NlZ21lbnRJbmRleD1lLmdldE51bVBvaW50cygpLTEsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTF9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXg8ZS5fY29tcG9uZW50SW5kZXg/LTE6dGhpcy5fY29tcG9uZW50SW5kZXg+ZS5fY29tcG9uZW50SW5kZXg/MTp0aGlzLl9zZWdtZW50SW5kZXg8ZS5fc2VnbWVudEluZGV4Py0xOnRoaXMuX3NlZ21lbnRJbmRleD5lLl9zZWdtZW50SW5kZXg/MTp0aGlzLl9zZWdtZW50RnJhY3Rpb248ZS5fc2VnbWVudEZyYWN0aW9uPy0xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbj5lLl9zZWdtZW50RnJhY3Rpb24/MTowfWNvcHkoKXtyZXR1cm4gbmV3IEZvKHRoaXMuX2NvbXBvbmVudEluZGV4LHRoaXMuX3NlZ21lbnRJbmRleCx0aGlzLl9zZWdtZW50RnJhY3Rpb24pfXRvU3RyaW5nKCl7cmV0dXJuXCJMaW5lYXJMb2NbXCIrdGhpcy5fY29tcG9uZW50SW5kZXgrXCIsIFwiK3RoaXMuX3NlZ21lbnRJbmRleCtcIiwgXCIrdGhpcy5fc2VnbWVudEZyYWN0aW9uK1wiXVwifWlzT25TYW1lU2VnbWVudCh0KXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXg9PT10Ll9jb21wb25lbnRJbmRleCYmKHRoaXMuX3NlZ21lbnRJbmRleD09PXQuX3NlZ21lbnRJbmRleHx8KHQuX3NlZ21lbnRJbmRleC10aGlzLl9zZWdtZW50SW5kZXg9PTEmJjA9PT10Ll9zZWdtZW50RnJhY3Rpb258fHRoaXMuX3NlZ21lbnRJbmRleC10Ll9zZWdtZW50SW5kZXg9PTEmJjA9PT10aGlzLl9zZWdtZW50RnJhY3Rpb24pKX1zbmFwVG9WZXJ0ZXgodCxlKXtpZih0aGlzLl9zZWdtZW50RnJhY3Rpb248PTB8fHRoaXMuX3NlZ21lbnRGcmFjdGlvbj49MSlyZXR1cm4gbnVsbDtjb25zdCBuPXRoaXMuZ2V0U2VnbWVudExlbmd0aCh0KSxzPXRoaXMuX3NlZ21lbnRGcmFjdGlvbipuLGk9bi1zO3M8PWkmJnM8ZT90aGlzLl9zZWdtZW50RnJhY3Rpb249MDppPD1zJiZpPGUmJih0aGlzLl9zZWdtZW50RnJhY3Rpb249MSl9Y29tcGFyZUxvY2F0aW9uVmFsdWVzKHQsZSxuKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXg8dD8tMTp0aGlzLl9jb21wb25lbnRJbmRleD50PzE6dGhpcy5fc2VnbWVudEluZGV4PGU/LTE6dGhpcy5fc2VnbWVudEluZGV4PmU/MTp0aGlzLl9zZWdtZW50RnJhY3Rpb248bj8tMTp0aGlzLl9zZWdtZW50RnJhY3Rpb24+bj8xOjB9Z2V0U2VnbWVudExlbmd0aCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTtsZXQgbj10aGlzLl9zZWdtZW50SW5kZXg7dGhpcy5fc2VnbWVudEluZGV4Pj1lLmdldE51bVBvaW50cygpLTEmJihuPWUuZ2V0TnVtUG9pbnRzKCktMik7Y29uc3Qgcz1lLmdldENvb3JkaW5hdGVOKG4pLGk9ZS5nZXRDb29yZGluYXRlTihuKzEpO3JldHVybiBzLmRpc3RhbmNlKGkpfWlzVmVydGV4KCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRGcmFjdGlvbjw9MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xfWdldENsYXNzKCl7cmV0dXJuIEZvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19Rm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29tcG9uZW50SW5kZXg9dC5fY29tcG9uZW50SW5kZXgsdGhpcy5fc2VnbWVudEluZGV4PXQuX3NlZ21lbnRJbmRleCx0aGlzLl9zZWdtZW50RnJhY3Rpb249dC5fc2VnbWVudEZyYWN0aW9ufWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0ZvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCx0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2NvbXBvbmVudEluZGV4PXQsdGhpcy5fc2VnbWVudEluZGV4PWUsdGhpcy5fc2VnbWVudEZyYWN0aW9uPW4sdGhpcy5ub3JtYWxpemUoKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9jb21wb25lbnRJbmRleD10LHRoaXMuX3NlZ21lbnRJbmRleD1lLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj1uLHMmJnRoaXMubm9ybWFsaXplKCl9fTtjbGFzcyBHb3tjb25zdHJ1Y3Rvcigpe0dvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNlZ21lbnRFbmRWZXJ0ZXhJbmRleCh0KXtyZXR1cm4gdC5nZXRTZWdtZW50RnJhY3Rpb24oKT4wP3QuZ2V0U2VnbWVudEluZGV4KCkrMTp0LmdldFNlZ21lbnRJbmRleCgpfWdldENvbXBvbmVudEluZGV4KCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4fWdldExpbmUoKXtyZXR1cm4gdGhpcy5fY3VycmVudExpbmV9Z2V0VmVydGV4SW5kZXgoKXtyZXR1cm4gdGhpcy5fdmVydGV4SW5kZXh9Z2V0U2VnbWVudEVuZCgpe3JldHVybiB0aGlzLl92ZXJ0ZXhJbmRleDx0aGlzLmdldExpbmUoKS5nZXROdW1Qb2ludHMoKS0xP3RoaXMuX2N1cnJlbnRMaW5lLmdldENvb3JkaW5hdGVOKHRoaXMuX3ZlcnRleEluZGV4KzEpOm51bGx9bmV4dCgpe2lmKCF0aGlzLmhhc05leHQoKSlyZXR1cm4gbnVsbDt0aGlzLl92ZXJ0ZXhJbmRleCsrLHRoaXMuX3ZlcnRleEluZGV4Pj10aGlzLl9jdXJyZW50TGluZS5nZXROdW1Qb2ludHMoKSYmKHRoaXMuX2NvbXBvbmVudEluZGV4KyssdGhpcy5sb2FkQ3VycmVudExpbmUoKSx0aGlzLl92ZXJ0ZXhJbmRleD0wKX1sb2FkQ3VycmVudExpbmUoKXtpZih0aGlzLl9jb21wb25lbnRJbmRleD49dGhpcy5fbnVtTGluZXMpcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lPW51bGwsbnVsbDt0aGlzLl9jdXJyZW50TGluZT10aGlzLl9saW5lYXJHZW9tLmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCl9Z2V0U2VnbWVudFN0YXJ0KCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLmdldENvb3JkaW5hdGVOKHRoaXMuX3ZlcnRleEluZGV4KX1pc0VuZE9mTGluZSgpe3JldHVybiEodGhpcy5fY29tcG9uZW50SW5kZXg+PXRoaXMuX251bUxpbmVzKSYmISh0aGlzLl92ZXJ0ZXhJbmRleDx0aGlzLl9jdXJyZW50TGluZS5nZXROdW1Qb2ludHMoKS0xKX1oYXNOZXh0KCl7cmV0dXJuISh0aGlzLl9jb21wb25lbnRJbmRleD49dGhpcy5fbnVtTGluZXMpJiYhKHRoaXMuX2NvbXBvbmVudEluZGV4PT09dGhpcy5fbnVtTGluZXMtMSYmdGhpcy5fdmVydGV4SW5kZXg+PXRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpKX1nZXRDbGFzcygpe3JldHVybiBHb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19R28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbGluZWFyR2VvbT1udWxsLHRoaXMuX251bUxpbmVzPW51bGwsdGhpcy5fY3VycmVudExpbmU9bnVsbCx0aGlzLl9jb21wb25lbnRJbmRleD0wLHRoaXMuX3ZlcnRleEluZGV4PTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0dvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwwLDApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0dvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLmdldENvbXBvbmVudEluZGV4KCksR28uc2VnbWVudEVuZFZlcnRleEluZGV4KGUpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtpZighXyh0LG90KSl0aHJvdyBuZXcgbihcIkxpbmVhbCBnZW9tZXRyeSBpcyByZXF1aXJlZFwiKTt0aGlzLl9saW5lYXJHZW9tPXQsdGhpcy5fbnVtTGluZXM9dC5nZXROdW1HZW9tZXRyaWVzKCksdGhpcy5fY29tcG9uZW50SW5kZXg9ZSx0aGlzLl92ZXJ0ZXhJbmRleD1zLHRoaXMubG9hZEN1cnJlbnRMaW5lKCl9fTtjbGFzcyBxb3tjb25zdHJ1Y3Rvcigpe3FvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGluZGV4T2YodCxlKXtyZXR1cm4gbmV3IHFvKHQpLmluZGV4T2YoZSl9c3RhdGljIGluZGV4T2ZBZnRlcih0LGUsbil7cmV0dXJuIG5ldyBxbyh0KS5pbmRleE9mQWZ0ZXIoZSxuKX1pbmRleE9mKHQpe3JldHVybiB0aGlzLmluZGV4T2ZGcm9tU3RhcnQodCxudWxsKX1pbmRleE9mRnJvbVN0YXJ0KHQsZSl7bGV0IG49aS5NQVhfVkFMVUUscz0wLHI9MCxvPS0xO2NvbnN0IGw9bmV3IGVlO2ZvcihsZXQgaT1uZXcgR28odGhpcy5fbGluZWFyR2VvbSk7aS5oYXNOZXh0KCk7aS5uZXh0KCkpaWYoIWkuaXNFbmRPZkxpbmUoKSl7bC5wMD1pLmdldFNlZ21lbnRTdGFydCgpLGwucDE9aS5nZXRTZWdtZW50RW5kKCk7Y29uc3QgYT1sLmRpc3RhbmNlKHQpLGM9bC5zZWdtZW50RnJhY3Rpb24odCksaD1pLmdldENvbXBvbmVudEluZGV4KCksdT1pLmdldFZlcnRleEluZGV4KCk7YTxuJiYobnVsbD09PWV8fGUuY29tcGFyZUxvY2F0aW9uVmFsdWVzKGgsdSxjKTwwKSYmKHM9aCxyPXUsbz1jLG49YSl9cmV0dXJuIG49PT1pLk1BWF9WQUxVRT9uZXcgRm8oZSk6bmV3IEZvKHMscixvKX1pbmRleE9mQWZ0ZXIodCxlKXtpZihudWxsPT09ZSlyZXR1cm4gdGhpcy5pbmRleE9mKHQpO2NvbnN0IG49Rm8uZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSk7aWYobi5jb21wYXJlVG8oZSk8PTApcmV0dXJuIG47Y29uc3Qgcz10aGlzLmluZGV4T2ZGcm9tU3RhcnQodCxlKTtyZXR1cm4gdS5pc1RydWUocy5jb21wYXJlVG8oZSk+PTAsXCJjb21wdXRlZCBsb2NhdGlvbiBpcyBiZWZvcmUgc3BlY2lmaWVkIG1pbmltdW0gbG9jYXRpb25cIiksc31nZXRDbGFzcygpe3JldHVybiBxb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH07Y2xhc3MgQm97Y29uc3RydWN0b3IoKXtCby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbmRpY2VzT2YodCxlKXtyZXR1cm4gbmV3IEJvKHQpLmluZGljZXNPZihlKX1pbmRpY2VzT2YodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5TigwKS5nZXRDb29yZGluYXRlTigwKSxuPXQuZ2V0R2VvbWV0cnlOKHQuZ2V0TnVtR2VvbWV0cmllcygpLTEpLHM9bi5nZXRDb29yZGluYXRlTihuLmdldE51bVBvaW50cygpLTEpLGk9bmV3IHFvKHRoaXMuX2xpbmVhckdlb20pLHI9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIHJbMF09aS5pbmRleE9mKGUpLDA9PT10LmdldExlbmd0aCgpP3JbMV09clswXS5jb3B5KCk6clsxXT1pLmluZGV4T2ZBZnRlcihzLHJbMF0pLHJ9Z2V0Q2xhc3MoKXtyZXR1cm4gQm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUJvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9O2NsYXNzIFZve2NvbnN0cnVjdG9yKCl7Vm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRHZW9tZXRyeSgpe3JldHVybiB0aGlzLmVuZExpbmUoKSx0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHRoaXMuX2xpbmVzKX1nZXRMYXN0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9sYXN0UHR9ZW5kTGluZSgpe2lmKG51bGw9PT10aGlzLl9jb29yZExpc3QpcmV0dXJuIG51bGw7aWYodGhpcy5faWdub3JlSW52YWxpZExpbmVzJiZ0aGlzLl9jb29yZExpc3Quc2l6ZSgpPDIpcmV0dXJuIHRoaXMuX2Nvb3JkTGlzdD1udWxsLG51bGw7Y29uc3QgdD10aGlzLl9jb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgZT10O3RoaXMuX2ZpeEludmFsaWRMaW5lcyYmKGU9dGhpcy52YWxpZENvb3JkaW5hdGVTZXF1ZW5jZSh0KSksdGhpcy5fY29vcmRMaXN0PW51bGw7bGV0IHM9bnVsbDt0cnl7cz10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lU3RyaW5nKGUpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIG4pKXRocm93IHQ7aWYoIXRoaXMuX2lnbm9yZUludmFsaWRMaW5lcyl0aHJvdyB0fW51bGwhPT1zJiZ0aGlzLl9saW5lcy5hZGQocyl9c2V0Rml4SW52YWxpZExpbmVzKHQpe3RoaXMuX2ZpeEludmFsaWRMaW5lcz10fWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0LCEwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtudWxsPT09dGhpcy5fY29vcmRMaXN0JiYodGhpcy5fY29vcmRMaXN0PW5ldyBJKSx0aGlzLl9jb29yZExpc3QuYWRkKHQsZSksdGhpcy5fbGFzdFB0PXR9fXNldElnbm9yZUludmFsaWRMaW5lcyh0KXt0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXM9dH12YWxpZENvb3JkaW5hdGVTZXF1ZW5jZSh0KXtpZih0Lmxlbmd0aD49MilyZXR1cm4gdDtyZXR1cm5bdFswXSx0WzBdXX1nZXRDbGFzcygpe3JldHVybiBWb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Vm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9saW5lcz1uZXcgeCx0aGlzLl9jb29yZExpc3Q9bnVsbCx0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXM9ITEsdGhpcy5fZml4SW52YWxpZExpbmVzPSExLHRoaXMuX2xhc3RQdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0PXR9O2NsYXNzIHpve2NvbnN0cnVjdG9yKCl7em8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZXh0cmFjdCh0LGUsbil7cmV0dXJuIG5ldyB6byh0KS5leHRyYWN0KGUsbil9Y29tcHV0ZUxpbmVhcih0LGUpe2NvbnN0IG49bmV3IFZvKHRoaXMuX2xpbmUuZ2V0RmFjdG9yeSgpKTtuLnNldEZpeEludmFsaWRMaW5lcyghMCksdC5pc1ZlcnRleCgpfHxuLmFkZCh0LmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpO2ZvcihsZXQgcz1uZXcgR28odGhpcy5fbGluZSx0KTtzLmhhc05leHQoKSYmIShlLmNvbXBhcmVMb2NhdGlvblZhbHVlcyhzLmdldENvbXBvbmVudEluZGV4KCkscy5nZXRWZXJ0ZXhJbmRleCgpLDApPDApO3MubmV4dCgpKXtjb25zdCB0PXMuZ2V0U2VnbWVudFN0YXJ0KCk7bi5hZGQodCkscy5pc0VuZE9mTGluZSgpJiZuLmVuZExpbmUoKX1yZXR1cm4gZS5pc1ZlcnRleCgpfHxuLmFkZChlLmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpLG4uZ2V0R2VvbWV0cnkoKX1jb21wdXRlTGluZSh0LGUpe2NvbnN0IG49dGhpcy5fbGluZS5nZXRDb29yZGluYXRlcygpLHM9bmV3IEk7bGV0IGk9dC5nZXRTZWdtZW50SW5kZXgoKTt0LmdldFNlZ21lbnRGcmFjdGlvbigpPjAmJihpKz0xKTtsZXQgcj1lLmdldFNlZ21lbnRJbmRleCgpOzE9PT1lLmdldFNlZ21lbnRGcmFjdGlvbigpJiYocis9MSkscj49bi5sZW5ndGgmJihyPW4ubGVuZ3RoLTEpLHQuaXNWZXJ0ZXgoKXx8cy5hZGQodC5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKTtmb3IobGV0IHQ9aTt0PD1yO3QrKylzLmFkZChuW3RdKTtlLmlzVmVydGV4KCl8fHMuYWRkKGUuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSkscy5zaXplKCk8PTAmJnMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSk7bGV0IG89cy50b0Nvb3JkaW5hdGVBcnJheSgpO3JldHVybiBvLmxlbmd0aDw9MSYmKG89W29bMF0sb1swXV0pLHRoaXMuX2xpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcobyl9ZXh0cmFjdCh0LGUpe3JldHVybiBlLmNvbXBhcmVUbyh0KTwwP3RoaXMucmV2ZXJzZSh0aGlzLmNvbXB1dGVMaW5lYXIoZSx0KSk6dGhpcy5jb21wdXRlTGluZWFyKHQsZSl9cmV2ZXJzZSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFR0fHx0IGluc3RhbmNlb2YgZnQ/dC5yZXZlcnNlKCk6KHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJub24tbGluZWFyIGdlb21ldHJ5IGVuY291bnRlcmVkXCIpLG51bGwpfWdldENsYXNzKCl7cmV0dXJuIHpvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX16by5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZT10fTtjbGFzcyBZb3tjb25zdHJ1Y3Rvcigpe1lvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2xhbXBJbmRleCh0KXtjb25zdCBlPXQuY29weSgpO3JldHVybiBlLmNsYW1wKHRoaXMuX2xpbmVhckdlb20pLGV9cHJvamVjdCh0KXtyZXR1cm4gcW8uaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfWNoZWNrR2VvbWV0cnlUeXBlKCl7aWYoISh0aGlzLl9saW5lYXJHZW9tIGluc3RhbmNlb2YgVHR8fHRoaXMuX2xpbmVhckdlb20gaW5zdGFuY2VvZiBmdCkpdGhyb3cgbmV3IG4oXCJJbnB1dCBnZW9tZXRyeSBtdXN0IGJlIGxpbmVhclwiKX1leHRyYWN0UG9pbnQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIGFyZ3VtZW50c1swXS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmVhckdlb20pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQudG9Mb3dlc3QodGhpcy5fbGluZWFyR2VvbSk7cmV0dXJuIG4uZ2V0U2VnbWVudCh0aGlzLl9saW5lYXJHZW9tKS5wb2ludEFsb25nT2Zmc2V0KG4uZ2V0U2VnbWVudEZyYWN0aW9uKCksZSl9fWlzVmFsaWRJbmRleCh0KXtyZXR1cm4gdC5pc1ZhbGlkKHRoaXMuX2xpbmVhckdlb20pfWdldEVuZEluZGV4KCl7cmV0dXJuIEZvLmdldEVuZExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20pfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gbmV3IEZvfWluZGV4T2ZBZnRlcih0LGUpe3JldHVybiBxby5pbmRleE9mQWZ0ZXIodGhpcy5fbGluZWFyR2VvbSx0LGUpfWV4dHJhY3RMaW5lKHQsZSl7cmV0dXJuIHpvLmV4dHJhY3QodGhpcy5fbGluZWFyR2VvbSx0LGUpfWluZGV4T2YodCl7cmV0dXJuIHFvLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1pbmRpY2VzT2YodCl7cmV0dXJuIEJvLmluZGljZXNPZih0aGlzLl9saW5lYXJHZW9tLHQpfWdldENsYXNzKCl7cmV0dXJuIFlvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Zby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10LHRoaXMuY2hlY2tHZW9tZXRyeVR5cGUoKX07Y2xhc3MgVW97Y29uc3RydWN0b3IoKXtVby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbmRleE9mKHQsZSl7cmV0dXJuIG5ldyBVbyh0KS5pbmRleE9mKGUpfXN0YXRpYyBpbmRleE9mQWZ0ZXIodCxlLG4pe3JldHVybiBuZXcgVW8odCkuaW5kZXhPZkFmdGVyKGUsbil9aW5kZXhPZih0KXtyZXR1cm4gdGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsLTEpfWluZGV4T2ZGcm9tU3RhcnQodCxlKXtsZXQgbj1pLk1BWF9WQUxVRSxzPWUscj0wO2NvbnN0IG89bmV3IGVlLGw9bmV3IEdvKHRoaXMuX2xpbmVhckdlb20pO2Zvcig7bC5oYXNOZXh0KCk7KXtpZighbC5pc0VuZE9mTGluZSgpKXtvLnAwPWwuZ2V0U2VnbWVudFN0YXJ0KCksby5wMT1sLmdldFNlZ21lbnRFbmQoKTtjb25zdCBpPW8uZGlzdGFuY2UodCksYT10aGlzLnNlZ21lbnROZWFyZXN0TWVhc3VyZShvLHQscik7aTxuJiZhPmUmJihzPWEsbj1pKSxyKz1vLmdldExlbmd0aCgpfWwubmV4dCgpfXJldHVybiBzfWluZGV4T2ZBZnRlcih0LGUpe2lmKGU8MClyZXR1cm4gdGhpcy5pbmRleE9mKHQpO2NvbnN0IG49dGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKTtpZihuPGUpcmV0dXJuIG47Y29uc3Qgcz10aGlzLmluZGV4T2ZGcm9tU3RhcnQodCxlKTtyZXR1cm4gdS5pc1RydWUocz49ZSxcImNvbXB1dGVkIGluZGV4IGlzIGJlZm9yZSBzcGVjaWZpZWQgbWluaW11bSBpbmRleFwiKSxzfXNlZ21lbnROZWFyZXN0TWVhc3VyZSh0LGUsbil7Y29uc3Qgcz10LnByb2plY3Rpb25GYWN0b3IoZSk7cmV0dXJuIHM8PTA/bjpzPD0xP24rcyp0LmdldExlbmd0aCgpOm4rdC5nZXRMZW5ndGgoKX1nZXRDbGFzcygpe3JldHVybiBVb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH07Y2xhc3Mga297Y29uc3RydWN0b3IoKXtrby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRMZW5ndGgodCxlKXtyZXR1cm4gbmV3IGtvKHQpLmdldExlbmd0aChlKX1zdGF0aWMgZ2V0TG9jYXRpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBrbyh0KS5nZXRMb2NhdGlvbihlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG5ldyBrbyh0KS5nZXRMb2NhdGlvbihlLG4pfX1nZXRMZW5ndGgodCl7bGV0IGU9MDtjb25zdCBuPW5ldyBHbyh0aGlzLl9saW5lYXJHZW9tKTtmb3IoO24uaGFzTmV4dCgpOyl7aWYoIW4uaXNFbmRPZkxpbmUoKSl7Y29uc3Qgcz1uLmdldFNlZ21lbnRTdGFydCgpLGk9bi5nZXRTZWdtZW50RW5kKCkuZGlzdGFuY2Uocyk7aWYodC5nZXRDb21wb25lbnRJbmRleCgpPT09bi5nZXRDb21wb25lbnRJbmRleCgpJiZ0LmdldFNlZ21lbnRJbmRleCgpPT09bi5nZXRWZXJ0ZXhJbmRleCgpKXJldHVybiBlK2kqdC5nZXRTZWdtZW50RnJhY3Rpb24oKTtlKz1pfW4ubmV4dCgpfXJldHVybiBlfXJlc29sdmVIaWdoZXIodCl7aWYoIXQuaXNFbmRwb2ludCh0aGlzLl9saW5lYXJHZW9tKSlyZXR1cm4gdDtsZXQgZT10LmdldENvbXBvbmVudEluZGV4KCk7aWYoZT49dGhpcy5fbGluZWFyR2VvbS5nZXROdW1HZW9tZXRyaWVzKCktMSlyZXR1cm4gdDtkb3tlKyt9d2hpbGUoZTx0aGlzLl9saW5lYXJHZW9tLmdldE51bUdlb21ldHJpZXMoKS0xJiYwPT09dGhpcy5fbGluZWFyR2VvbS5nZXRHZW9tZXRyeU4oZSkuZ2V0TGVuZ3RoKCkpO3JldHVybiBuZXcgRm8oZSwwLDApfWdldExvY2F0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmdldExvY2F0aW9uKHQsITApfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj10O2lmKHQ8MCl7bj10aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpK3R9Y29uc3Qgcz10aGlzLmdldExvY2F0aW9uRm9yd2FyZChuKTtyZXR1cm4gZT9zOnRoaXMucmVzb2x2ZUhpZ2hlcihzKX19Z2V0TG9jYXRpb25Gb3J3YXJkKHQpe2lmKHQ8PTApcmV0dXJuIG5ldyBGbztsZXQgZT0wO2NvbnN0IG49bmV3IEdvKHRoaXMuX2xpbmVhckdlb20pO2Zvcig7bi5oYXNOZXh0KCk7KXtpZihuLmlzRW5kT2ZMaW5lKCkpe2lmKGU9PT10KXtjb25zdCB0PW4uZ2V0Q29tcG9uZW50SW5kZXgoKSxlPW4uZ2V0VmVydGV4SW5kZXgoKTtyZXR1cm4gbmV3IEZvKHQsZSwwKX19ZWxzZXtjb25zdCBzPW4uZ2V0U2VnbWVudFN0YXJ0KCksaT1uLmdldFNlZ21lbnRFbmQoKS5kaXN0YW5jZShzKTtpZihlK2k+dCl7Y29uc3Qgcz0odC1lKS9pLHI9bi5nZXRDb21wb25lbnRJbmRleCgpLG89bi5nZXRWZXJ0ZXhJbmRleCgpO3JldHVybiBuZXcgRm8ocixvLHMpfWUrPWl9bi5uZXh0KCl9cmV0dXJuIEZvLmdldEVuZExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20pfWdldENsYXNzKCl7cmV0dXJuIGtvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1rby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fTtjbGFzcyBYb3tjb25zdHJ1Y3Rvcigpe1hvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2xhbXBJbmRleCh0KXtjb25zdCBlPXRoaXMucG9zaXRpdmVJbmRleCh0KSxuPXRoaXMuZ2V0U3RhcnRJbmRleCgpO2lmKGU8bilyZXR1cm4gbjtjb25zdCBzPXRoaXMuZ2V0RW5kSW5kZXgoKTtyZXR1cm4gZT5zP3M6ZX1sb2NhdGlvbk9mKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBrby5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4ga28uZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0LGUpfX1wcm9qZWN0KHQpe3JldHVybiBVby5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9cG9zaXRpdmVJbmRleCh0KXtyZXR1cm4gdD49MD90OnRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCkrdH1leHRyYWN0UG9pbnQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGtvLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCkuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lYXJHZW9tKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1rby5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQpLnRvTG93ZXN0KHRoaXMuX2xpbmVhckdlb20pO3JldHVybiBuLmdldFNlZ21lbnQodGhpcy5fbGluZWFyR2VvbSkucG9pbnRBbG9uZ09mZnNldChuLmdldFNlZ21lbnRGcmFjdGlvbigpLGUpfX1pc1ZhbGlkSW5kZXgodCl7cmV0dXJuIHQ+PXRoaXMuZ2V0U3RhcnRJbmRleCgpJiZ0PD10aGlzLmdldEVuZEluZGV4KCl9Z2V0RW5kSW5kZXgoKXtyZXR1cm4gdGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKX1nZXRTdGFydEluZGV4KCl7cmV0dXJuIDB9aW5kZXhPZkFmdGVyKHQsZSl7cmV0dXJuIFVvLmluZGV4T2ZBZnRlcih0aGlzLl9saW5lYXJHZW9tLHQsZSl9ZXh0cmFjdExpbmUodCxlKXtuZXcgWW8odGhpcy5fbGluZWFyR2VvbSk7Y29uc3Qgbj10aGlzLmNsYW1wSW5kZXgodCkscz10aGlzLmNsYW1wSW5kZXgoZSksaT1uPT09cyxyPXRoaXMubG9jYXRpb25PZihuLGkpLG89dGhpcy5sb2NhdGlvbk9mKHMpO3JldHVybiB6by5leHRyYWN0KHRoaXMuX2xpbmVhckdlb20scixvKX1pbmRleE9mKHQpe3JldHVybiBVby5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9aW5kaWNlc09mKHQpe2NvbnN0IGU9Qm8uaW5kaWNlc09mKHRoaXMuX2xpbmVhckdlb20sdCk7cmV0dXJuW2tvLmdldExlbmd0aCh0aGlzLl9saW5lYXJHZW9tLGVbMF0pLGtvLmdldExlbmd0aCh0aGlzLl9saW5lYXJHZW9tLGVbMV0pXX1nZXRDbGFzcygpe3JldHVybiBYb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19WG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH07dmFyIEhvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLExlbmd0aEluZGV4ZWRMaW5lOlhvLExlbmd0aExvY2F0aW9uTWFwOmtvLExpbmVhckdlb21ldHJ5QnVpbGRlcjpWbyxMaW5lYXJJdGVyYXRvcjpHbyxMaW5lYXJMb2NhdGlvbjpGbyxMb2NhdGlvbkluZGV4ZWRMaW5lOllvfSk7Y2xhc3MgV297Y29uc3RydWN0b3IoKXtXby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0cmFuc2Zvcm0odCxlKXtjb25zdCBuPW5ldyB4O2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KW4uYWRkKGUuZXhlY3V0ZShzLm5leHQoKSkpO3JldHVybiBufXN0YXRpYyBzZWxlY3QodCxlKXtjb25zdCBuPW5ldyB4O2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO0Jvb2xlYW4uVFJVRS5lcXVhbHMoZS5leGVjdXRlKHQpKSYmbi5hZGQodCl9cmV0dXJuIG59c3RhdGljIGFwcGx5KHQsZSl7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZS5leGVjdXRlKG4ubmV4dCgpKX1nZXRDbGFzcygpe3JldHVybiBXb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19V28uRnVuY3Rpb249ZnVuY3Rpb24oKXt9LFdvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3Mgam97Y29uc3RydWN0b3IoKXtqby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt0aGlzLnB0c1t0aGlzLm4rK109dH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLnB0c31nZXRDbGFzcygpe3JldHVybiBqb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQl19fWpvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMucHRzPW51bGwsdGhpcy5uPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wdHM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCl9O2NsYXNzIEtve2NvbnN0cnVjdG9yKCl7S28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7dGhpcy5fbisrfWdldENvdW50KCl7cmV0dXJuIHRoaXMuX259Z2V0Q2xhc3MoKXtyZXR1cm4gS299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0JdfX1Lby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9uPTB9O2NsYXNzIFpve2NvbnN0cnVjdG9yKCl7Wm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb3VudCh0KXtjb25zdCBlPXRoaXMuX2NvdW50cy5nZXQodCk7cmV0dXJuIG51bGw9PT1lPzA6ZS5jb3VudCgpfWFkZCh0KXtjb25zdCBlPXRoaXMuX2NvdW50cy5nZXQodCk7bnVsbD09PWU/dGhpcy5fY291bnRzLnB1dCh0LG5ldyBRbygxKSk6ZS5pbmNyZW1lbnQoKX1nZXRDbGFzcygpe3JldHVybiBab31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgUW97Y29uc3RydWN0b3IoKXtRby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvdW50KCl7cmV0dXJuIHRoaXMuY291bnR9aW5jcmVtZW50KCl7dGhpcy5jb3VudCsrfWdldENsYXNzKCl7cmV0dXJuIFFvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Rby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLmNvdW50PTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY291bnQ9dH19LFpvLkNvdW50ZXI9UW8sWm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY291bnRzPW5ldyBVdH07dmFyIEpvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLENvbGxlY3Rpb25VdGlsOldvLENvb3JkaW5hdGVBcnJheUZpbHRlcjpqbyxDb29yZGluYXRlQ291bnRGaWx0ZXI6S28sR2VvbWV0cmljU2hhcGVGYWN0b3J5OlNlLE51bWJlclV0aWw6ZSxPYmplY3RDb3VudGVyOlpvLFByaW9yaXR5UXVldWU6ZnMsU3RyaW5nVXRpbDpTdCxVbmlxdWVDb29yZGluYXRlQXJyYXlGaWx0ZXI6bG59KTtjbGFzcyAkb3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX1nZXRDbGFzcygpe3JldHVybiAkb31zdGF0aWMgdW5pb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gY3IuY3JlYXRlRW1wdHlSZXN1bHQoY3IuVU5JT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksbHIub3ZlcmxheU9wKHQsZSxjci5VTklPTil9fXEucHJvdG90eXBlLmVxdWFsc1RvcG89ZnVuY3Rpb24odCl7cmV0dXJuISF0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5lcXVhbHModC5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZHci5yZWxhdGUodGhpcyx0KS5pc0VxdWFscyh0aGlzLmdldERpbWVuc2lvbigpLHQuZ2V0RGltZW5zaW9uKCkpfSxxLnByb3RvdHlwZS51bmlvbj1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB6ci51bmlvbih0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuICRvLnVuaW9uKHRoaXMsdCl9fSxxLnByb3RvdHlwZS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuIENyLmlzVmFsaWQodGhpcyl9LHEucHJvdG90eXBlLmludGVyc2VjdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gY3IuaW50ZXJzZWN0aW9uKHRoaXMsdCl9LHEucHJvdG90eXBlLmNvdmVycz1mdW5jdGlvbih0KXtyZXR1cm4gR3IuY292ZXJzKHRoaXMsdCl9LHEucHJvdG90eXBlLmNvdmVyZWRCeT1mdW5jdGlvbih0KXtyZXR1cm4gR3IuY292ZXJzKHQsdGhpcyl9LHEucHJvdG90eXBlLnRvdWNoZXM9ZnVuY3Rpb24odCl7cmV0dXJuIEdyLnRvdWNoZXModGhpcyx0KX0scS5wcm90b3R5cGUuaW50ZXJzZWN0cz1mdW5jdGlvbih0KXtyZXR1cm4gR3IuaW50ZXJzZWN0cyh0aGlzLHQpfSxxLnByb3RvdHlwZS53aXRoaW49ZnVuY3Rpb24odCl7cmV0dXJuIEdyLmNvbnRhaW5zKHQsdGhpcyl9LHEucHJvdG90eXBlLm92ZXJsYXBzPWZ1bmN0aW9uKHQpe3JldHVybiBHci5vdmVybGFwcyh0aGlzLHQpfSxxLnByb3RvdHlwZS5kaXNqb2ludD1mdW5jdGlvbih0KXtyZXR1cm4gR3IuZGlzam9pbnQodGhpcyx0KX0scS5wcm90b3R5cGUuY3Jvc3Nlcz1mdW5jdGlvbih0KXtyZXR1cm4gR3IuY3Jvc3Nlcyh0aGlzLHQpfSxxLnByb3RvdHlwZS5idWZmZXI9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIFNpLmJ1ZmZlck9wKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBTaS5idWZmZXJPcCh0aGlzLHQsZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBTaS5idWZmZXJPcCh0aGlzLHQsZSxuKX19LHEucHJvdG90eXBlLmNvbnZleEh1bGw9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGFuKHRoaXMpLmdldENvbnZleEh1bGwoKX0scS5wcm90b3R5cGUucmVsYXRlPWZ1bmN0aW9uKC4uLnQpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gR3IucmVsYXRlKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBHci5yZWxhdGUodGhpcyx0KS5tYXRjaGVzKGUpfX0scS5wcm90b3R5cGUuZ2V0Q2VudHJvaWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCgpO2NvbnN0IHQ9c24uZ2V0Q2VudHJvaWQodGhpcyk7cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LHRoaXMpfSxxLnByb3RvdHlwZS5nZXRJbnRlcmlvclBvaW50PWZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQoKTtsZXQgdD1udWxsO2NvbnN0IGU9dGhpcy5nZXREaW1lbnNpb24oKTt0PTA9PT1lP25ldyBkbih0aGlzKToxPT09ZT9uZXcgZ24odGhpcyk6bmV3IGhuKHRoaXMpO2NvbnN0IG49dC5nZXRJbnRlcmlvclBvaW50KCk7cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZChuLHRoaXMpfSxxLnByb3RvdHlwZS5zeW1EaWZmZXJlbmNlPWZ1bmN0aW9uKHQpe3JldHVybiBjci5zeW1EaWZmZXJlbmNlKHRoaXMsdCl9LHEucHJvdG90eXBlLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfSxxLnByb3RvdHlwZS50b1RleHQ9ZnVuY3Rpb24oKXtyZXR1cm4obmV3IEp0KS53cml0ZSh0aGlzKX0scS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt0aGlzLnRvVGV4dCgpfSxxLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbih0KXtyZXR1cm4gR3IuY29udGFpbnModGhpcyx0KX0scS5wcm90b3R5cGUuZGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gY3IuZGlmZmVyZW5jZSh0aGlzLHQpfSxxLnByb3RvdHlwZS5pc1NpbXBsZT1mdW5jdGlvbigpe3JldHVybiBuZXcgSHModGhpcykuaXNTaW1wbGUoKX0scS5wcm90b3R5cGUuaXNXaXRoaW5EaXN0YW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiEodGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UodC5nZXRFbnZlbG9wZUludGVybmFsKCkpPmUpJiZSaS5pc1dpdGhpbkRpc3RhbmNlKHRoaXMsdCxlKX0scS5wcm90b3R5cGUuZGlzdGFuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIFJpLmRpc3RhbmNlKHRoaXMsdCl9LHEucHJvdG90eXBlLmlzRXF1aXZhbGVudENsYXNzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldENsYXNzKCk9PT10LmdldENsYXNzKCl9O3QuYWxnb3JpdGhtPW1uLHQuZGVuc2lmeT1Fbix0LmRpc3NvbHZlPVJuLHQuZ2VvbT1SZSx0Lmdlb21ncmFwaD1Kbix0LmluZGV4PUNzLHQuaW89UHMsdC5saW5lYXJyZWY9SG8sdC5ub2Rpbmc9WHMsdC5vcGVyYXRpb249a3IsdC5wcmVjaXNpb249V3IsdC5zaW1wbGlmeT1obyx0LnRyaWFuZ3VsYXRlPUFvLHQudXRpbD1Kbyx0LnZlcnNpb249XCIyLjEuMiAoODNiNWFlZSlcIixPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzdHMubWluLmpzLm1hcCIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgaXNJRSA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSAmJiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZFR5cGUpICYmIChcbiAgICAgICAgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgKTtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgZnVuY3Rpb24gdHJhY2VGb3JJRSgpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVja3MsIGlmIHBvbHlnb24gaXMgc2ltcGxlLiBQb2x5Z29uIGlzIHNpbXBsZSwgd2hlbiBpdHMgZWRnZXMgZG9uJ3QgY3Jvc3MgZWFjaCBvdGhlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIFBvbHlnb24gaXMgc2ltcGxlXG4gKi9cbmZ1bmN0aW9uIElzU2ltcGxlIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG4gPSBwLmxlbmd0aCA+PiAxO1xuICBpZiAobiA8IDQpIHJldHVybiB0cnVlXG4gIHZhciBhMSA9IFBvaW50KCk7XG4gIHZhciBhMiA9IFBvaW50KCk7XG4gIHZhciBiMSA9IFBvaW50KCk7XG4gIHZhciBiMiA9IFBvaW50KCk7XG4gIHZhciBjID0gUG9pbnQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGExLnggPSBwWzIgKiBpXTtcbiAgICBhMS55ID0gcFsyICogaSArIDFdO1xuICAgIGlmIChpID09IG4gLSAxKSB7XG4gICAgICBhMi54ID0gcFswXTtcbiAgICAgIGEyLnkgPSBwWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhMi54ID0gcFsyICogaSArIDJdO1xuICAgICAgYTIueSA9IHBbMiAqIGkgKyAzXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKE1hdGguYWJzKGkgLSBqKSA8IDIpIGNvbnRpbnVlXG4gICAgICBpZiAoaiA9PSBuIC0gMSAmJiBpID09IDApIGNvbnRpbnVlXG4gICAgICBpZiAoaSA9PSBuIC0gMSAmJiBqID09IDApIGNvbnRpbnVlXG5cbiAgICAgIGIxLnggPSBwWzIgKiBqXTtcbiAgICAgIGIxLnkgPSBwWzIgKiBqICsgMV07XG4gICAgICBpZiAoaiA9PSBuIC0gMSkge1xuICAgICAgICBiMi54ID0gcFswXTtcbiAgICAgICAgYjIueSA9IHBbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiMi54ID0gcFsyICogaiArIDJdO1xuICAgICAgICBiMi55ID0gcFsyICogaiArIDNdO1xuICAgICAgfVxuXG4gICAgICBpZiAoR2V0TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYykgIT0gbnVsbCkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5tb2R1bGUuZXhwb3J0cy5Jc1NpbXBsZSA9IElzU2ltcGxlO1xuXG4vKipcbiAqIENoZWNrcywgaWYgcG9seWdvbiBpcyBjb252ZXguIFBvbHlnb24gaXMgY29udmV4LCB3aGVuIGVhY2ggaW5uZXIgYW5nbGUgaXMgPD0gMTgwwrAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gSXNDb252ZXggKHBvbHlnb24pIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICBpZiAocC5sZW5ndGggPCA2KSByZXR1cm4gdHJ1ZVxuICB2YXIgbCA9IHAubGVuZ3RoIC0gNDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICBpZiAoIWNvbnZleChwW2ldLCBwW2kgKyAxXSwgcFtpICsgMl0sIHBbaSArIDNdLCBwW2kgKyA0XSwgcFtpICsgNV0pKSByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoIWNvbnZleChwW2xdLCBwW2wgKyAxXSwgcFtsICsgMl0sIHBbbCArIDNdLCBwWzBdLCBwWzFdKSkgcmV0dXJuIGZhbHNlXG4gIGlmICghY29udmV4KHBbbCArIDJdLCBwW2wgKyAzXSwgcFswXSwgcFsxXSwgcFsyXSwgcFszXSkpIHJldHVybiBmYWxzZVxuICByZXR1cm4gdHJ1ZVxufVxubW9kdWxlLmV4cG9ydHMuSXNDb252ZXggPSBJc0NvbnZleDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcmVhIG9mIHBvbHlnb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBHZXRBcmVhIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgaWYgKHAubGVuZ3RoIDwgNikgcmV0dXJuIDBcbiAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gIHZhciBzdW0gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHN1bSArPSAocFtpICsgMl0gLSBwW2ldKSAqIChwW2kgKyAxXSArIHBbaSArIDNdKTtcbiAgfVxuICBzdW0gKz0gKHBbMF0gLSBwW2xdKSAqIChwW2wgKyAxXSArIHBbMV0pO1xuICByZXR1cm4gLXN1bSAqIDAuNVxufVxubW9kdWxlLmV4cG9ydHMuR2V0QXJlYSA9IEdldEFyZWE7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgQXhpcy1hbGlnbmVkIEJvdW5kaW5nIEJveCBvZiBwb2x5Z29uXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7QUFCQn1cbiAqIEBleGFtcGxlXG4gKiAvLz17eDowLCB5OjAsIHdpZHRoOjAsIGhlaWdodDowfVxuICovXG5mdW5jdGlvbiBHZXRBQUJCIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG1pbnggPSBJbmZpbml0eTtcbiAgdmFyIG1pbnkgPSBJbmZpbml0eTtcbiAgdmFyIG1heHggPSAtbWlueDtcbiAgdmFyIG1heHkgPSAtbWlueTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgbWlueCA9IE1hdGgubWluKG1pbngsIHBbaV0pO1xuICAgIG1heHggPSBNYXRoLm1heChtYXh4LCBwW2ldKTtcbiAgICBtaW55ID0gTWF0aC5taW4obWlueSwgcFtpICsgMV0pO1xuICAgIG1heHkgPSBNYXRoLm1heChtYXh5LCBwW2kgKyAxXSk7XG4gIH1cbiAgcmV0dXJuIHt4OiBtaW54LCB5OiBtaW55LCB3aWR0aDogbWF4eCAtIG1pbngsIGhlaWdodDogbWF4eSAtIG1pbnl9XG59XG5tb2R1bGUuZXhwb3J0cy5HZXRBQUJCID0gR2V0QUFCQjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgdHJpYW5ndWxhdGlvbi4gT3V0cHV0IGFycmF5IGlzIGFycmF5IG9mIHRyaWFuZ2xlcyAodHJpYW5nbGUgPSAzIGluZGljZXMgb2YgcG9seWdvbiB2ZXJ0aWNlcykuXG4gKlxuICogV29ya3Mgd2l0aCBzaW1wbGUgcG9seWdvbnMgb25seS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdHJpYW5nbGVzICh0cmlhbmdsZSA9IDMgaW5kaWNlcyBvZiBwb2x5Z29uIHZlcnRpY2VzKVxuICogQGV4YW1wbGVcbiAqIHZhciBpZHMgPSBQb2x5Sy5Ucmlhbmd1bGF0ZShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pO1xuICogLy89WzAsIDEsIDIsIDAsIDIsIDNdXG4gKi9cbmZ1bmN0aW9uIFRyaWFuZ3VsYXRlIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG4gPSBwLmxlbmd0aCA+PiAxO1xuICBpZiAobiA8IDMpIHJldHVybiBbXVxuICB2YXIgdGdzID0gW107XG4gIHZhciBhdmwgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHsgYXZsLnB1c2goaSk7IH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBhbCA9IG47XG4gIHdoaWxlIChhbCA+IDMpIHtcbiAgICB2YXIgaTAgPSBhdmxbKGkgKyAwKSAlIGFsXTtcbiAgICB2YXIgaTEgPSBhdmxbKGkgKyAxKSAlIGFsXTtcbiAgICB2YXIgaTIgPSBhdmxbKGkgKyAyKSAlIGFsXTtcblxuICAgIHZhciBheCA9IHBbMiAqIGkwXTtcbiAgICB2YXIgYXkgPSBwWzIgKiBpMCArIDFdO1xuICAgIHZhciBieCA9IHBbMiAqIGkxXTtcbiAgICB2YXIgYnkgPSBwWzIgKiBpMSArIDFdO1xuICAgIHZhciBjeCA9IHBbMiAqIGkyXTtcbiAgICB2YXIgY3kgPSBwWzIgKiBpMiArIDFdO1xuXG4gICAgdmFyIGVhckZvdW5kID0gZmFsc2U7XG4gICAgaWYgKGNvbnZleChheCwgYXksIGJ4LCBieSwgY3gsIGN5KSkge1xuICAgICAgZWFyRm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbDsgaisrKSB7XG4gICAgICAgIHZhciB2aSA9IGF2bFtqXTtcbiAgICAgICAgaWYgKHZpID09IGkwIHx8IHZpID09IGkxIHx8IHZpID09IGkyKSBjb250aW51ZVxuICAgICAgICBpZiAoUG9pbnRJblRyaWFuZ2xlKHBbMiAqIHZpXSwgcFsyICogdmkgKyAxXSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpIHtcbiAgICAgICAgICBlYXJGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVhckZvdW5kKSB7XG4gICAgICB0Z3MucHVzaChpMCwgaTEsIGkyKTtcbiAgICAgIGF2bC5zcGxpY2UoKGkgKyAxKSAlIGFsLCAxKTtcbiAgICAgIGFsLS07XG4gICAgICBpID0gMDtcbiAgICB9IGVsc2UgaWYgKGkrKyA+IDMgKiBhbCkgYnJlYWsgICAgLy8gbm8gY29udmV4IGFuZ2xlcyA6KFxuICB9XG4gIHRncy5wdXNoKGF2bFswXSwgYXZsWzFdLCBhdmxbMl0pO1xuICByZXR1cm4gdGdzXG59XG5tb2R1bGUuZXhwb3J0cy5Ucmlhbmd1bGF0ZSA9IFRyaWFuZ3VsYXRlO1xuXG4vKipcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiB3aXRoIGxpbmUgc2VnbWVudCBBLUIsIGRlZmluZWQgYnkgW2F4LGF5XSBhbmQgW2J4LGJ5XS4gQSwgQiBtdXN0IG5vdCBsYXkgaW5zaWRlIGEgcG9seWdvbi4gUmV0dXJucyBhbiBhcnJheSBvZiBwb2x5Z29ucy5cbiAqXG4gKiBXb3JrcyB3aXRoIHNpbXBsZSBwb2x5Z29ucyBvbmx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WCBTdGFydCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WSBTdGFydCBDb29yZGluYXRlIFt5XVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFggRW5kIENvb3JkaW5hdGUgW3hdXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kWSBFbmQgQ29vcmRpbmF0ZSBbeV1cbiAqIEByZXR1cm5zIHtudW1iZXJbXVtdfSBBcnJheSBvZiBQb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIFNsaWNlIChwb2x5Z29uLCBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSkge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBheCA9IHN0YXJ0WDtcbiAgdmFyIGF5ID0gc3RhcnRZO1xuICB2YXIgYnggPSBlbmRYO1xuICB2YXIgYnkgPSBlbmRZO1xuICBpZiAoQ29udGFpbnNQb2ludChwLCBheCwgYXkpIHx8IENvbnRhaW5zUG9pbnQocCwgYngsIGJ5KSkge1xuICAgIHJldHVybiBbcC5zbGljZSgwKV1cbiAgfVxuXG4gIHZhciBhID0gUG9pbnQoYXgsIGF5KTtcbiAgdmFyIGIgPSBQb2ludChieCwgYnkpO1xuICB2YXIgaXNjcyA9IFtdOyAgLy8gaW50ZXJzZWN0aW9uc1xuICB2YXIgcHMgPSBbXTsgIC8vIHBvaW50c1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwcy5wdXNoKFBvaW50KHBbaV0sIHBbaSArIDFdKSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpc2MgPSBQb2ludCgwLCAwKTtcbiAgICBpc2MgPSBHZXRMaW5lSW50ZXJzZWN0aW9uKGEsIGIsIHBzW2ldLCBwc1soaSArIDEpICUgcHMubGVuZ3RoXSwgaXNjKTtcbiAgICB2YXIgZmlzYyA9IGlzY3NbMF07XG4gICAgdmFyIGxpc2MgPSBpc2NzW2lzY3MubGVuZ3RoIC0gMV07XG4gICAgLy8gJiYgKGlzYy54IT1wc1tpXS54IHx8IGlzYy55IT1wc1tpXS55KSApXG4gICAgaWYgKGlzYyAmJiAoZmlzYyA9PSBudWxsIHx8IGRpc3RhbmNlKGlzYywgZmlzYykgPiAxZS0xMCkgJiYgKGxpc2MgPT0gbnVsbCB8fCBkaXN0YW5jZShpc2MsIGxpc2MpID4gMWUtMTApKSB7XG4gICAgICBpc2MuZmxhZyA9IHRydWU7XG4gICAgICBpc2NzLnB1c2goaXNjKTtcbiAgICAgIHBzLnNwbGljZShpICsgMSwgMCwgaXNjKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNjcy5sZW5ndGggPCAyKSByZXR1cm4gW3Auc2xpY2UoMCldXG4gIHZhciBjb21wID0gZnVuY3Rpb24gKHUsIHYpIHsgcmV0dXJuIGRpc3RhbmNlKGEsIHUpIC0gZGlzdGFuY2UoYSwgdikgfTtcbiAgaXNjcy5zb3J0KGNvbXApO1xuXG4gIHZhciBwZ3MgPSBbXTtcbiAgdmFyIGRpciA9IDA7XG4gIHdoaWxlIChpc2NzLmxlbmd0aCA+IDApIHtcbiAgICAvLyB2YXIgbiA9IHBzLmxlbmd0aCAvLyBpcyBhc3NpZ25lZCBhIHZhbHVlIGJ1dCBuZXZlciB1c2VkLiAobm8tdW51c2VkLXZhcnMpXG4gICAgdmFyIGkwID0gaXNjc1swXTtcbiAgICB2YXIgaTEgPSBpc2NzWzFdO1xuICAgIC8vIGlmKGkwLng9PWkxLnggJiYgaTAueT09aTEueSkgeyBpc2NzLnNwbGljZSgwLDIpOyBjb250aW51ZTt9XG4gICAgdmFyIGluZGV4MCA9IHBzLmluZGV4T2YoaTApO1xuICAgIHZhciBpbmRleDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICB2YXIgc29sdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoZmlyc3RXaXRoRmxhZyhwcywgaW5kZXgwKSA9PT0gaW5kZXgxKSB7XG4gICAgICBzb2x2ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpMCA9IGlzY3NbMV07XG4gICAgICBpMSA9IGlzY3NbMF07XG4gICAgICBpbmRleDAgPSBwcy5pbmRleE9mKGkwKTtcbiAgICAgIGluZGV4MSA9IHBzLmluZGV4T2YoaTEpO1xuICAgICAgaWYgKGZpcnN0V2l0aEZsYWcocHMsIGluZGV4MCkgPT09IGluZGV4MSkgc29sdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNvbHZlZCkge1xuICAgICAgZGlyLS07XG4gICAgICB2YXIgcGduID0gZ2V0UG9pbnRzKHBzLCBpbmRleDAsIGluZGV4MSk7XG4gICAgICBwZ3MucHVzaChwZ24pO1xuICAgICAgcHMgPSBnZXRQb2ludHMocHMsIGluZGV4MSwgaW5kZXgwKTtcbiAgICAgIGkwLmZsYWcgPSBpMS5mbGFnID0gZmFsc2U7XG4gICAgICBpc2NzLnNwbGljZSgwLCAyKTtcbiAgICAgIGlmIChpc2NzLmxlbmd0aCA9PSAwKSBwZ3MucHVzaChwcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcisrO1xuICAgICAgaXNjcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGlmIChkaXIgPiAxKSBicmVha1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGcgPSBwZ3NbaV07XG4gICAgdmFyIG5wZyA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGcubGVuZ3RoOyBqKyspIHsgbnBnLnB1c2gocGdbal0ueCwgcGdbal0ueSk7IH1cbiAgICByZXN1bHQucHVzaChucGcpO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbm1vZHVsZS5leHBvcnRzLlNsaWNlID0gU2xpY2U7XG5cbi8qKlxuICogQ2hlY2tzLCBpZiBwb2x5Z29uIGNvbnRhaW5zIFt4LCB5XS5cbiAqXG4gKiBXb3JrcyB3aXRoIHNpbXBsZSBwb2x5Z29ucyBvbmx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHBhcmFtIHtudW1iZXJ9IHBvaW50WCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IHBvaW50WSBDb29yZGluYXRlIFt5XVxuICogQHJldHVybnMge2Jvb2xlYW59IGRlcHRoXG4gKi9cbmZ1bmN0aW9uIENvbnRhaW5zUG9pbnQgKHBvbHlnb24sIHBvaW50WCwgcG9pbnRZKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIHB4ID0gcG9pbnRYO1xuICB2YXIgcHkgPSBwb2ludFk7XG4gIHZhciBuID0gcC5sZW5ndGggPj4gMTtcbiAgdmFyIGF4O1xuICB2YXIgYXkgPSBwWzIgKiBuIC0gM10gLSBweTtcbiAgdmFyIGJ4ID0gcFsyICogbiAtIDJdIC0gcHg7XG4gIHZhciBieSA9IHBbMiAqIG4gLSAxXSAtIHB5O1xuXG4gIC8vIHZhciBsdXAgPSBieSA+IGF5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGF4ID0gYng7XG4gICAgYXkgPSBieTtcbiAgICBieCA9IHBbMiAqIGldIC0gcHg7XG4gICAgYnkgPSBwWzIgKiBpICsgMV0gLSBweTtcbiAgICBpZiAoYXkgPT09IGJ5KSBjb250aW51ZVxuICAgIHZhciBsdXAgPSBieSA+IGF5O1xuICB9XG5cbiAgdmFyIGRlcHRoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBheCA9IGJ4O1xuICAgIGF5ID0gYnk7XG4gICAgYnggPSBwWzIgKiBpXSAtIHB4O1xuICAgIGJ5ID0gcFsyICogaSArIDFdIC0gcHk7XG4gICAgaWYgKGF5IDwgMCAmJiBieSA8IDApIGNvbnRpbnVlICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG93blwiXG4gICAgaWYgKGF5ID4gMCAmJiBieSA+IDApIGNvbnRpbnVlICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG93blwiXG4gICAgaWYgKGF4IDwgMCAmJiBieCA8IDApIGNvbnRpbnVlICAgLy8gYm90aCBwb2ludHMgb24gdGhlIGxlZnRcblxuICAgIGlmIChheSA9PT0gYnkgJiYgTWF0aC5taW4oYXgsIGJ4KSA8PSAwKSByZXR1cm4gdHJ1ZVxuICAgIGlmIChheSA9PT0gYnkpIGNvbnRpbnVlXG5cbiAgICB2YXIgbHggPSBheCArIChieCAtIGF4KSAqICgtYXkpIC8gKGJ5IC0gYXkpO1xuICAgIGlmIChseCA9PT0gMCkgcmV0dXJuIHRydWUgICAgICAvLyBwb2ludCBvbiBlZGdlXG4gICAgaWYgKGx4ID4gMCkgZGVwdGgrKztcbiAgICBpZiAoYXkgPT09IDAgJiYgbHVwICYmIGJ5ID4gYXkpIGRlcHRoLS07ICAvLyBoaXQgdmVydGV4LCBib3RoIHVwXG4gICAgaWYgKGF5ID09PSAwICYmICFsdXAgJiYgYnkgPCBheSkgZGVwdGgtLTsgLy8gaGl0IHZlcnRleCwgYm90aCBkb3duXG4gICAgbHVwID0gYnkgPiBheTtcbiAgfVxuICByZXR1cm4gKGRlcHRoICYgMSkgPT09IDFcbn1cbm1vZHVsZS5leHBvcnRzLkNvbnRhaW5zUG9pbnQgPSBDb250YWluc1BvaW50O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBjbG9zZXN0IHBvaW50IG9mIHBvbHlnb24sIHdoaWNoIGxheXMgb24gcmF5IGRlZmluZWQgYnkgW3gseV0gKG9yaWdpbikgYW5kIFtkeCxkeV0gKGRpcmVjdGlvbikuXG4gKlxuICogXCJkaXN0XCIgaXMgdGhlIGRpc3RhbmNlIG9mIHRoZSBwb2x5Z29uIHBvaW50LCBcImVkZ2VcIiBpcyB0aGUgbnVtYmVyIG9mIHRoZSBlZGdlLCBvbiB3aGljaCBpbnRlcnNlY3Rpb24gb2NjdXJzLCBcIm5vcm1cIiBpcyB0aGUgbm9ybWFsIGluIHRoYXQgcGxhY2UsIFwicmVmbFwiIGlzIHJlZmxlY3RlZCBkaXJlY3Rpb24uXG4gKlxuICogV29ya3Mgd2l0aCBzaW1wbGUgcG9seWdvbnMgb25seS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5YIE9yaWdpbiBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5ZIE9yaWdpbiBbeV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb25YIERpcmVjdGlvbiBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb25ZIERpcmVjdGlvbiBbeV1cbiAqIEByZXR1cm5zIHtSYXljYXN0fVxuICogQGV4YW1wbGVcbiAqIC8vPXtkaXN0OjAsIGVkZ2U6MCwgbm9ybTp7eDowLCB5OjB9LCByZWZsOnt4OjAsIHk6MH19XG4gKi9cbmZ1bmN0aW9uIFJheWNhc3QgKHBvbHlnb24sIG9yaWdpblgsIG9yaWdpblksIGRpcmVjdGlvblgsIGRpcmVjdGlvblksIGlzYykge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciB4ID0gb3JpZ2luWDtcbiAgdmFyIHkgPSBvcmlnaW5ZO1xuICB2YXIgZHggPSBkaXJlY3Rpb25YO1xuICB2YXIgZHkgPSBkaXJlY3Rpb25ZO1xuICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgdmFyIGVtcHR5ID0gZW1wdHlQb2ludHMoKTtcbiAgdmFyIGExID0gZW1wdHlbMF07XG4gIHZhciBhMiA9IGVtcHR5WzFdO1xuICB2YXIgYjEgPSBlbXB0eVsyXTtcbiAgdmFyIGIyID0gZW1wdHlbM107XG4gIHZhciBjID0gZW1wdHlbNF07XG4gIGExLnggPSB4O1xuICBhMS55ID0geTtcbiAgYTIueCA9IHggKyBkeDtcbiAgYTIueSA9IHkgKyBkeTtcblxuICBpZiAoaXNjID09PSBudWxsIHx8IGlzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaXNjID0ge2Rpc3Q6IDAsIGVkZ2U6IDAsIG5vcm06IHt4OiAwLCB5OiAwfSwgcmVmbDoge3g6IDAsIHk6IDB9fTtcbiAgfVxuICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gIHZhciBuaXNjO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIGIxLnggPSBwW2ldO1xuICAgIGIxLnkgPSBwW2kgKyAxXTtcbiAgICBiMi54ID0gcFtpICsgMl07XG4gICAgYjIueSA9IHBbaSArIDNdO1xuICAgIG5pc2MgPSBSYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICBpZiAobmlzYykge1xuICAgICAgaXNjID0gdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgaSAvIDIsIGlzYyk7XG4gICAgfVxuICB9XG4gIGIxLnggPSBiMi54O1xuICBiMS55ID0gYjIueTtcbiAgYjIueCA9IHBbMF07XG4gIGIyLnkgPSBwWzFdO1xuICBuaXNjID0gUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XG4gIGlmIChuaXNjKSB7XG4gICAgaXNjID0gdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgKHAubGVuZ3RoIC8gMikgLSAxLCBpc2MpO1xuICB9XG5cbiAgcmV0dXJuIChpc2MuZGlzdCAhPT0gSW5maW5pdHkpID8gaXNjIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMuUmF5Y2FzdCA9IFJheWNhc3Q7XG5cbi8qKlxuICogRmluZHMgdGhlIHBvaW50IG9uIHBvbHlnb24gZWRnZXMsIHdoaWNoIGlzIGNsb3Nlc3QgdG8gW3gseV0uIFJldHVybnMgYW4gb2JqZWN0IGluIHRoaXMgZm9ybWF0XG4gKlxuICogXCJkaXN0XCIgaXMgdGhlIGRpc3RhbmNlIG9mIHRoZSBwb2x5Z29uIHBvaW50LCBcImVkZ2VcIiBpcyB0aGUgbnVtYmVyIG9mIHRoZSBjbG9zZXN0IGVkZ2UsIFwicG9pbnRcIiBpcyB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGF0IGVkZ2UsIFwibm9ybVwiIGlzIHRoZSBub3JtYWwgZnJvbSBcInBvaW50XCIgdG8gW3gseV0uXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcGFyYW0ge251bWJlcn0geCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IHkgQ29vcmRpbmF0ZSBbeV1cbiAqIEByZXR1cm5zIHtDbG9zZXN0RWRnZX1cbiAqIEBleGFtcGxlXG4gKiAvLz17ZGlzdDowLCBlZGdlOjAsIHBvaW50Ont4OjAsIHk6MH0sIG5vcm06e3g6MCwgeTowfX1cbiAqL1xuZnVuY3Rpb24gQ2xvc2VzdEVkZ2UgKHBvbHlnb24sIHgsIHksIGlzYykge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICB2YXIgZW1wdHkgPSBlbXB0eVBvaW50cygpO1xuICB2YXIgYTEgPSBlbXB0eVswXTtcbiAgdmFyIGIxID0gZW1wdHlbMl07XG4gIHZhciBiMiA9IGVtcHR5WzNdO1xuICAvLyB2YXIgYyA9IHRwWzRdIC8vIGlzIGFzc2lnbmVkIGEgdmFsdWUgYnV0IG5ldmVyIHVzZWQuXG4gIGExLnggPSB4O1xuICBhMS55ID0geTtcblxuICBpZiAoaXNjID09IG51bGwpIHtcbiAgICBpc2MgPSB7ZGlzdDogMCwgZWRnZTogMCwgcG9pbnQ6IHt4OiAwLCB5OiAwfSwgbm9ybToge3g6IDAsIHk6IDB9fTtcbiAgfVxuICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgYjEueCA9IHBbaV07XG4gICAgYjEueSA9IHBbaSArIDFdO1xuICAgIGIyLnggPSBwW2kgKyAyXTtcbiAgICBiMi55ID0gcFtpICsgM107XG4gICAgaXNjID0gcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBpID4+IDEsIGlzYyk7XG4gIH1cbiAgYjEueCA9IGIyLng7XG4gIGIxLnkgPSBiMi55O1xuICBiMi54ID0gcFswXTtcbiAgYjIueSA9IHBbMV07XG4gIGlzYyA9IHBvaW50TGluZURpc3QoYTEsIGIxLCBiMiwgbCA+PiAxLCBpc2MpO1xuXG4gIHZhciBpZHN0ID0gMSAvIGlzYy5kaXN0O1xuICBpc2Mubm9ybS54ID0gKHggLSBpc2MucG9pbnQueCkgKiBpZHN0O1xuICBpc2Mubm9ybS55ID0gKHkgLSBpc2MucG9pbnQueSkgKiBpZHN0O1xuICByZXR1cm4gaXNjXG59XG5tb2R1bGUuZXhwb3J0cy5DbG9zZXN0RWRnZSA9IENsb3Nlc3RFZGdlO1xuXG4vKipcbiAqIFJldmVyc2VcbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqL1xuZnVuY3Rpb24gUmV2ZXJzZSAocG9seWdvbikge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBucCA9IFtdO1xuICBmb3IgKHZhciBqID0gcC5sZW5ndGggLSAyOyBqID49IDA7IGogLT0gMikgeyBucC5wdXNoKHBbal0sIHBbaiArIDFdKTsgfVxuICByZXR1cm4gbnBcbn1cbm1vZHVsZS5leHBvcnRzLlJldmVyc2UgPSBSZXZlcnNlO1xuXG4vKipcbiAqIFBvaW50IExpbmUgRGlzdGFuY2VcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gcFxuICogQHBhcmFtIHtQb2ludH0gYVxuICogQHBhcmFtIHtQb2ludH0gYlxuICogQHBhcmFtIHs/P30gZWRnZVxuICogQHBhcmFtIHs/P30gaXNjXG4gKiBAcmV0dXJucyB7Pz99IElTQ1xuICovXG5mdW5jdGlvbiBwb2ludExpbmVEaXN0IChwLCBhLCBiLCBlZGdlLCBpc2MpIHtcbiAgdmFyIHggPSBwLng7XG4gIHZhciB5ID0gcC55O1xuICB2YXIgeDEgPSBhLng7XG4gIHZhciB5MSA9IGEueTtcbiAgdmFyIHgyID0gYi54O1xuICB2YXIgeTIgPSBiLnk7XG5cbiAgdmFyIEEgPSB4IC0geDE7XG4gIHZhciBCID0geSAtIHkxO1xuICB2YXIgQyA9IHgyIC0geDE7XG4gIHZhciBEID0geTIgLSB5MTtcblxuICB2YXIgZG90ID0gQSAqIEMgKyBCICogRDtcbiAgdmFyIGxlblNxID0gQyAqIEMgKyBEICogRDtcbiAgdmFyIHBhcmFtID0gZG90IC8gbGVuU3E7XG5cbiAgdmFyIHh4O1xuICB2YXIgeXk7XG5cbiAgaWYgKHBhcmFtIDwgMCB8fCAoeDEgPT0geDIgJiYgeTEgPT0geTIpKSB7XG4gICAgeHggPSB4MTtcbiAgICB5eSA9IHkxO1xuICB9IGVsc2UgaWYgKHBhcmFtID4gMSkge1xuICAgIHh4ID0geDI7XG4gICAgeXkgPSB5MjtcbiAgfSBlbHNlIHtcbiAgICB4eCA9IHgxICsgcGFyYW0gKiBDO1xuICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XG4gIH1cblxuICB2YXIgZHggPSB4IC0geHg7XG4gIHZhciBkeSA9IHkgLSB5eTtcbiAgdmFyIGRzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIGlmIChkc3QgPCBpc2MuZGlzdCkge1xuICAgIGlzYy5kaXN0ID0gZHN0O1xuICAgIGlzYy5lZGdlID0gZWRnZTtcbiAgICBpc2MucG9pbnQueCA9IHh4O1xuICAgIGlzYy5wb2ludC55ID0geXk7XG4gIH1cbiAgcmV0dXJuIGlzY1xufVxuXG4vKipcbiAqIFVwZGF0ZSBJU0NcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gKiBAcGFyYW0ge251bWJlcn0gZHlcbiAqIEBwYXJhbSB7UG9pbnR9IGExXG4gKiBAcGFyYW0ge1BvaW50fSBiMVxuICogQHBhcmFtIHtQb2ludH0gYjJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqIEBwYXJhbSB7Pz99IGVkZ2VcbiAqIEBwYXJhbSB7Pz99IGlzY1xuICogQHJldHVybnMgez8/fVxuICovXG5mdW5jdGlvbiB1cGRhdGVJU0MgKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgZWRnZSwgaXNjKSB7XG4gIHZhciBucmwgPSBkaXN0YW5jZShhMSwgYyk7XG4gIGlmIChucmwgPCBpc2MuZGlzdCkge1xuICAgIHZhciBpYmwgPSAxIC8gZGlzdGFuY2UoYjEsIGIyKTtcbiAgICB2YXIgbnggPSAtKGIyLnkgLSBiMS55KSAqIGlibDtcbiAgICB2YXIgbnkgPSAoYjIueCAtIGIxLngpICogaWJsO1xuICAgIHZhciBkZG90ID0gMiAqIChkeCAqIG54ICsgZHkgKiBueSk7XG4gICAgaXNjLmRpc3QgPSBucmw7XG4gICAgaXNjLm5vcm0ueCA9IG54O1xuICAgIGlzYy5ub3JtLnkgPSBueTtcbiAgICBpc2MucmVmbC54ID0gLWRkb3QgKiBueCArIGR4O1xuICAgIGlzYy5yZWZsLnkgPSAtZGRvdCAqIG55ICsgZHk7XG4gICAgaXNjLmVkZ2UgPSBlZGdlO1xuICB9XG4gIHJldHVybiBpc2Ncbn1cblxuLyoqXG4gKiBHZXQgUG9pbnRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MVxuICogQHJldHVybnMge251bWJlcltdfSBwb2ludHNcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRzIChwb2ludHMsIGluZGV4MCwgaW5kZXgxKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoaW5kZXgxIDwgaW5kZXgwKSBpbmRleDEgKz0gbjtcbiAgZm9yICh2YXIgaSA9IGluZGV4MDsgaSA8PSBpbmRleDE7IGkrKykgeyByZXN1bHQucHVzaChwb2ludHNbaSAlIG5dKTsgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogRmlyc3QgV2l0aCBGbGFnXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpcnN0V2l0aEZsYWcgKHBvaW50cywgaW5kZXgpIHtcbiAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGluZGV4ID0gKGluZGV4ICsgMSkgJSBuO1xuICAgIGlmIChwb2ludHNbaW5kZXhdLmZsYWcpIHtcbiAgICAgIHJldHVybiBpbmRleFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFBvaW50IGluIFRyaWFuZ2xlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBweFxuICogQHBhcmFtIHtudW1iZXJ9IHB5XG4gKiBAcGFyYW0ge251bWJlcn0gYXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBheVxuICogQHBhcmFtIHtudW1iZXJ9IGJ4XG4gKiBAcGFyYW0ge251bWJlcn0gYnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBjeFxuICogQHBhcmFtIHtudW1iZXJ9IGN5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gUG9pbnRJblRyaWFuZ2xlIChweCwgcHksIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpIHtcbiAgdmFyIHYweCA9IGN4IC0gYXg7XG4gIHZhciB2MHkgPSBjeSAtIGF5O1xuICB2YXIgdjF4ID0gYnggLSBheDtcbiAgdmFyIHYxeSA9IGJ5IC0gYXk7XG4gIHZhciB2MnggPSBweCAtIGF4O1xuICB2YXIgdjJ5ID0gcHkgLSBheTtcblxuICB2YXIgZG90MDAgPSB2MHggKiB2MHggKyB2MHkgKiB2MHk7XG4gIHZhciBkb3QwMSA9IHYweCAqIHYxeCArIHYweSAqIHYxeTtcbiAgdmFyIGRvdDAyID0gdjB4ICogdjJ4ICsgdjB5ICogdjJ5O1xuICB2YXIgZG90MTEgPSB2MXggKiB2MXggKyB2MXkgKiB2MXk7XG4gIHZhciBkb3QxMiA9IHYxeCAqIHYyeCArIHYxeSAqIHYyeTtcblxuICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gIHZhciB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKVxufVxuXG4vKipcbiAqIFJheUxpbmUgSW50ZXJzZWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IGExXG4gKiBAcGFyYW0ge1BvaW50fSBhMlxuICogQHBhcmFtIHtQb2ludH0gYjFcbiAqIEBwYXJhbSB7UG9pbnR9IGIyXG4gKiBAcGFyYW0ge1BvaW50fSBjXG4gKi9cbmZ1bmN0aW9uIFJheUxpbmVJbnRlcnNlY3Rpb24gKGExLCBhMiwgYjEsIGIyLCBjKSB7XG4gIHZhciBkYXggPSAoYTEueCAtIGEyLngpO1xuICB2YXIgZGJ4ID0gKGIxLnggLSBiMi54KTtcbiAgdmFyIGRheSA9IChhMS55IC0gYTIueSk7XG4gIHZhciBkYnkgPSAoYjEueSAtIGIyLnkpO1xuXG4gIHZhciBEZW4gPSBkYXggKiBkYnkgLSBkYXkgKiBkYng7XG4gIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGwgIC8vIHBhcmFsbGVsXG5cbiAgdmFyIEEgPSAoYTEueCAqIGEyLnkgLSBhMS55ICogYTIueCk7XG4gIHZhciBCID0gKGIxLnggKiBiMi55IC0gYjEueSAqIGIyLngpO1xuXG4gIHZhciBJID0gYztcbiAgdmFyIGlEZW4gPSAxIC8gRGVuO1xuICBJLnggPSAoQSAqIGRieCAtIGRheCAqIEIpICogaURlbjtcbiAgSS55ID0gKEEgKiBkYnkgLSBkYXkgKiBCKSAqIGlEZW47XG5cbiAgaWYgKCFJblJlY3RhbmdsZShJLCBiMSwgYjIpKSByZXR1cm4gbnVsbFxuICBpZiAoKGRheSA+IDAgJiYgSS55ID4gYTEueSkgfHwgKGRheSA8IDAgJiYgSS55IDwgYTEueSkpIHJldHVybiBudWxsXG4gIGlmICgoZGF4ID4gMCAmJiBJLnggPiBhMS54KSB8fCAoZGF4IDwgMCAmJiBJLnggPCBhMS54KSkgcmV0dXJuIG51bGxcbiAgcmV0dXJuIElcbn1cblxuLyoqXG4gKiBHZXQgTGluZSBJbnRlcnNlY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gYTFcbiAqIEBwYXJhbSB7UG9pbnR9IGEyXG4gKiBAcGFyYW0ge1BvaW50fSBiMVxuICogQHBhcmFtIHtQb2ludH0gYjJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gR2V0TGluZUludGVyc2VjdGlvbiAoYTEsIGEyLCBiMSwgYjIsIGMpIHtcbiAgdmFyIGRheCA9IChhMS54IC0gYTIueCk7XG4gIHZhciBkYnggPSAoYjEueCAtIGIyLngpO1xuICB2YXIgZGF5ID0gKGExLnkgLSBhMi55KTtcbiAgdmFyIGRieSA9IChiMS55IC0gYjIueSk7XG5cbiAgdmFyIERlbiA9IGRheCAqIGRieSAtIGRheSAqIGRieDtcblxuICBpZiAoRGVuID09PSAwKSB7IHJldHVybiBudWxsIH0gLy8gcGFyYWxsZWxcblxuICB2YXIgQSA9IChhMS54ICogYTIueSAtIGExLnkgKiBhMi54KTtcbiAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XG5cbiAgdmFyIEkgPSBjO1xuICBJLnggPSAoQSAqIGRieCAtIGRheCAqIEIpIC8gRGVuO1xuICBJLnkgPSAoQSAqIGRieSAtIGRheSAqIEIpIC8gRGVuO1xuXG4gIGlmIChJblJlY3RhbmdsZShJLCBhMSwgYTIpICYmIEluUmVjdGFuZ2xlKEksIGIxLCBiMikpIHtcbiAgICByZXR1cm4gSVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogSW4gUmVjdGFuZ2xlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IGFcbiAqIEBwYXJhbSB7UG9pbnR9IGJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIEluUmVjdGFuZ2xlIChhLCBiLCBjKSB7XG4gIHZhciBtaW54ID0gTWF0aC5taW4oYi54LCBjLngpO1xuICB2YXIgbWF4eCA9IE1hdGgubWF4KGIueCwgYy54KTtcbiAgdmFyIG1pbnkgPSBNYXRoLm1pbihiLnksIGMueSk7XG4gIHZhciBtYXh5ID0gTWF0aC5tYXgoYi55LCBjLnkpO1xuXG4gIGlmIChtaW54ID09PSBtYXh4KSB7IHJldHVybiAobWlueSA8PSBhLnkgJiYgYS55IDw9IG1heHkpIH1cbiAgaWYgKG1pbnkgPT09IG1heHkpIHsgcmV0dXJuIChtaW54IDw9IGEueCAmJiBhLnggPD0gbWF4eCkgfVxuXG4gIC8vIHJldHVybiAobWlueCA8PSBhLnggJiYgYS54IDw9IG1heHggJiYgbWlueSA8PSBhLnkgJiYgYS55IDw9IG1heHkpXG4gIHJldHVybiAobWlueCA8PSBhLnggKyAxZS0xMCAmJiBhLnggLSAxZS0xMCA8PSBtYXh4ICYmIG1pbnkgPD0gYS55ICsgMWUtMTAgJiYgYS55IC0gMWUtMTAgPD0gbWF4eSlcbn1cblxuLyoqXG4gKiBDb252ZXhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gYXhcbiAqIEBwYXJhbSB7UG9pbnR9IGF5XG4gKiBAcGFyYW0ge1BvaW50fSBieFxuICogQHBhcmFtIHtQb2ludH0gYnlcbiAqIEBwYXJhbSB7UG9pbnR9IGN4XG4gKiBAcGFyYW0ge1BvaW50fSBjeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnZleCAoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkge1xuICByZXR1cm4gKGF5IC0gYnkpICogKGN4IC0gYngpICsgKGJ4IC0gYXgpICogKGN5IC0gYnkpID49IDBcbn1cblxuLyoqXG4gKiBQb2ludFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gUG9pbnQgKHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgZmxhZzogZmFsc2UsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdQb2ludCBbJyArIHggKyAnLCAnICsgeSArICddJyB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXN0YW5jZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBhXG4gKiBAcGFyYW0ge1BvaW50fSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSAoYSwgYikge1xuICB2YXIgZHggPSBiLnggLSBhLng7XG4gIHZhciBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVtcHR5IFBvaW50c1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gW251bT0xMF0gTnVtYmVyIG9mIHBvaW50c1xuICogQHJldHVybnMge1BvaW50W119XG4gKi9cbmZ1bmN0aW9uIGVtcHR5UG9pbnRzIChudW0pIHtcbiAgbnVtID0gbnVtIHx8IDEwO1xuICB2YXIgY29udGFpbmVyID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHsgY29udGFpbmVyLnB1c2goUG9pbnQoMCwgMCkpOyB9XG4gIHJldHVybiBjb250YWluZXJcbn1cblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlrLmpzLm1hcFxuIiwidmFyIHJvdWdoPWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCh0LGUscyl7aWYodCYmdC5sZW5ndGgpe2NvbnN0W24sYV09ZSxvPU1hdGguUEkvMTgwKnMsaD1NYXRoLmNvcyhvKSxyPU1hdGguc2luKG8pO3QuZm9yRWFjaCh0PT57Y29uc3RbZSxzXT10O3RbMF09KGUtbikqaC0ocy1hKSpyK24sdFsxXT0oZS1uKSpyKyhzLWEpKmgrYX0pfX1mdW5jdGlvbiBlKHQpe2NvbnN0IGU9dFswXSxzPXRbMV07cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlWzBdLXNbMF0sMikrTWF0aC5wb3coZVsxXS1zWzFdLDIpKX1mdW5jdGlvbiBzKGUscyl7Y29uc3Qgbj1bMCwwXSxhPU1hdGgucm91bmQocy5oYWNodXJlQW5nbGUrOTApO2EmJnQoZSxuLGEpO2NvbnN0IG89ZnVuY3Rpb24odCxlKXtjb25zdCBzPVsuLi50XTtzWzBdLmpvaW4oXCIsXCIpIT09c1tzLmxlbmd0aC0xXS5qb2luKFwiLFwiKSYmcy5wdXNoKFtzWzBdWzBdLHNbMF1bMV1dKTtjb25zdCBuPVtdO2lmKHMmJnMubGVuZ3RoPjIpe2xldCB0PWUuaGFjaHVyZUdhcDt0PDAmJih0PTQqZS5zdHJva2VXaWR0aCksdD1NYXRoLm1heCh0LC4xKTtjb25zdCBhPVtdO2ZvcihsZXQgdD0wO3Q8cy5sZW5ndGgtMTt0Kyspe2NvbnN0IGU9c1t0XSxuPXNbdCsxXTtpZihlWzFdIT09blsxXSl7Y29uc3QgdD1NYXRoLm1pbihlWzFdLG5bMV0pO2EucHVzaCh7eW1pbjp0LHltYXg6TWF0aC5tYXgoZVsxXSxuWzFdKSx4OnQ9PT1lWzFdP2VbMF06blswXSxpc2xvcGU6KG5bMF0tZVswXSkvKG5bMV0tZVsxXSl9KX19aWYoYS5zb3J0KCh0LGUpPT50LnltaW48ZS55bWluPy0xOnQueW1pbj5lLnltaW4/MTp0Lng8ZS54Py0xOnQueD5lLng/MTp0LnltYXg9PT1lLnltYXg/MDoodC55bWF4LWUueW1heCkvTWF0aC5hYnModC55bWF4LWUueW1heCkpLCFhLmxlbmd0aClyZXR1cm4gbjtsZXQgbz1bXSxoPWFbMF0ueW1pbjtmb3IoO28ubGVuZ3RofHxhLmxlbmd0aDspe2lmKGEubGVuZ3RoKXtsZXQgdD0tMTtmb3IobGV0IGU9MDtlPGEubGVuZ3RoJiYhKGFbZV0ueW1pbj5oKTtlKyspdD1lO2Euc3BsaWNlKDAsdCsxKS5mb3JFYWNoKHQ9PntvLnB1c2goe3M6aCxlZGdlOnR9KX0pfWlmKG89by5maWx0ZXIodD0+ISh0LmVkZ2UueW1heDw9aCkpLG8uc29ydCgodCxlKT0+dC5lZGdlLng9PT1lLmVkZ2UueD8wOih0LmVkZ2UueC1lLmVkZ2UueCkvTWF0aC5hYnModC5lZGdlLngtZS5lZGdlLngpKSxvLmxlbmd0aD4xKWZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCs9Mil7Y29uc3QgZT10KzE7aWYoZT49by5sZW5ndGgpYnJlYWs7Y29uc3Qgcz1vW3RdLmVkZ2UsYT1vW2VdLmVkZ2U7bi5wdXNoKFtbTWF0aC5yb3VuZChzLngpLGhdLFtNYXRoLnJvdW5kKGEueCksaF1dKX1oKz10LG8uZm9yRWFjaChlPT57ZS5lZGdlLng9ZS5lZGdlLngrdCplLmVkZ2UuaXNsb3BlfSl9fXJldHVybiBufShlLHMpO3JldHVybiBhJiYodChlLG4sLWEpLGZ1bmN0aW9uKGUscyxuKXtjb25zdCBhPVtdO2UuZm9yRWFjaCh0PT5hLnB1c2goLi4udCkpLHQoYSxzLG4pfShvLG4sLWEpKSxvfWNsYXNzIG57Y29uc3RydWN0b3IodCl7dGhpcy5oZWxwZXI9dH1maWxsUG9seWdvbih0LGUpe3JldHVybiB0aGlzLl9maWxsUG9seWdvbih0LGUpfV9maWxsUG9seWdvbih0LGUsbj0hMSl7Y29uc3QgYT1zKHQsZSk7cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOnRoaXMucmVuZGVyTGluZXMoYSxlLG4pfX1yZW5kZXJMaW5lcyh0LGUscyl7Y29uc3Qgbj1bXTtsZXQgYT1udWxsO2Zvcihjb25zdCBvIG9mIHQpbi5wdXNoKC4uLnRoaXMuaGVscGVyLmRvdWJsZUxpbmVPcHMob1swXVswXSxvWzBdWzFdLG9bMV1bMF0sb1sxXVsxXSxlKSkscyYmYSYmbi5wdXNoKC4uLnRoaXMuaGVscGVyLmRvdWJsZUxpbmVPcHMoYVswXSxhWzFdLG9bMF1bMF0sb1swXVsxXSxlKSksYT1vWzFdO3JldHVybiBufX1jbGFzcyBhIGV4dGVuZHMgbntmaWxsUG9seWdvbih0LGUpe3JldHVybiB0aGlzLl9maWxsUG9seWdvbih0LGUsITApfX1jbGFzcyBvIGV4dGVuZHMgbntmaWxsUG9seWdvbih0LGUpe2NvbnN0IHM9dGhpcy5fZmlsbFBvbHlnb24odCxlKSxuPU9iamVjdC5hc3NpZ24oe30sZSx7aGFjaHVyZUFuZ2xlOmUuaGFjaHVyZUFuZ2xlKzkwfSksYT10aGlzLl9maWxsUG9seWdvbih0LG4pO3JldHVybiBzLm9wcz1zLm9wcy5jb25jYXQoYS5vcHMpLHN9fWNsYXNzIGh7Y29uc3RydWN0b3IodCl7dGhpcy5oZWxwZXI9dH1maWxsUG9seWdvbih0LGUpe2NvbnN0IG49cyh0LGU9T2JqZWN0LmFzc2lnbih7fSxlLHtjdXJ2ZVN0ZXBDb3VudDo0LGhhY2h1cmVBbmdsZTowLHJvdWdobmVzczoxfSkpO3JldHVybiB0aGlzLmRvdHNPbkxpbmVzKG4sZSl9ZG90c09uTGluZXModCxzKXtjb25zdCBuPVtdO2xldCBhPXMuaGFjaHVyZUdhcDthPDAmJihhPTQqcy5zdHJva2VXaWR0aCksYT1NYXRoLm1heChhLC4xKTtsZXQgbz1zLmZpbGxXZWlnaHQ7bzwwJiYobz1zLnN0cm9rZVdpZHRoLzIpO2NvbnN0IGg9YS80O2Zvcihjb25zdCByIG9mIHQpe2NvbnN0IHQ9ZShyKSxpPXQvYSxjPU1hdGguY2VpbChpKS0xLGw9dC1jKmEsdT0oclswXVswXStyWzFdWzBdKS8yLWEvNCxwPU1hdGgubWluKHJbMF1bMV0sclsxXVsxXSk7Zm9yKGxldCB0PTA7dDxjO3QrKyl7Y29uc3QgZT1wK2wrdCphLHI9dGhpcy5oZWxwZXIucmFuZE9mZnNldFdpdGhSYW5nZSh1LWgsdStoLHMpLGk9dGhpcy5oZWxwZXIucmFuZE9mZnNldFdpdGhSYW5nZShlLWgsZStoLHMpLGM9dGhpcy5oZWxwZXIuZWxsaXBzZShyLGksbyxvLHMpO24ucHVzaCguLi5jLm9wcyl9fXJldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczpufX19Y2xhc3Mgcntjb25zdHJ1Y3Rvcih0KXt0aGlzLmhlbHBlcj10fWZpbGxQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zKHQsZSk7cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOnRoaXMuZGFzaGVkTGluZShuLGUpfX1kYXNoZWRMaW5lKHQscyl7Y29uc3Qgbj1zLmRhc2hPZmZzZXQ8MD9zLmhhY2h1cmVHYXA8MD80KnMuc3Ryb2tlV2lkdGg6cy5oYWNodXJlR2FwOnMuZGFzaE9mZnNldCxhPXMuZGFzaEdhcDwwP3MuaGFjaHVyZUdhcDwwPzQqcy5zdHJva2VXaWR0aDpzLmhhY2h1cmVHYXA6cy5kYXNoR2FwLG89W107cmV0dXJuIHQuZm9yRWFjaCh0PT57Y29uc3QgaD1lKHQpLHI9TWF0aC5mbG9vcihoLyhuK2EpKSxpPShoK2EtcioobithKSkvMjtsZXQgYz10WzBdLGw9dFsxXTtjWzBdPmxbMF0mJihjPXRbMV0sbD10WzBdKTtjb25zdCB1PU1hdGguYXRhbigobFsxXS1jWzFdKS8obFswXS1jWzBdKSk7Zm9yKGxldCB0PTA7dDxyO3QrKyl7Y29uc3QgZT10KihuK2EpLGg9ZStuLHI9W2NbMF0rZSpNYXRoLmNvcyh1KStpKk1hdGguY29zKHUpLGNbMV0rZSpNYXRoLnNpbih1KStpKk1hdGguc2luKHUpXSxsPVtjWzBdK2gqTWF0aC5jb3ModSkraSpNYXRoLmNvcyh1KSxjWzFdK2gqTWF0aC5zaW4odSkraSpNYXRoLnNpbih1KV07by5wdXNoKC4uLnRoaXMuaGVscGVyLmRvdWJsZUxpbmVPcHMoclswXSxyWzFdLGxbMF0sbFsxXSxzKSl9fSksb319Y2xhc3MgaXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmhlbHBlcj10fWZpbGxQb2x5Z29uKHQsZSl7Y29uc3Qgbj1lLmhhY2h1cmVHYXA8MD80KmUuc3Ryb2tlV2lkdGg6ZS5oYWNodXJlR2FwLGE9ZS56aWd6YWdPZmZzZXQ8MD9uOmUuemlnemFnT2Zmc2V0LG89cyh0LGU9T2JqZWN0LmFzc2lnbih7fSxlLHtoYWNodXJlR2FwOm4rYX0pKTtyZXR1cm57dHlwZTpcImZpbGxTa2V0Y2hcIixvcHM6dGhpcy56aWd6YWdMaW5lcyhvLGEsZSl9fXppZ3phZ0xpbmVzKHQscyxuKXtjb25zdCBhPVtdO3JldHVybiB0LmZvckVhY2godD0+e2NvbnN0IG89ZSh0KSxoPU1hdGgucm91bmQoby8oMipzKSk7bGV0IHI9dFswXSxpPXRbMV07clswXT5pWzBdJiYocj10WzFdLGk9dFswXSk7Y29uc3QgYz1NYXRoLmF0YW4oKGlbMV0tclsxXSkvKGlbMF0tclswXSkpO2ZvcihsZXQgdD0wO3Q8aDt0Kyspe2NvbnN0IGU9Mip0KnMsbz0yKih0KzEpKnMsaD1NYXRoLnNxcnQoMipNYXRoLnBvdyhzLDIpKSxpPVtyWzBdK2UqTWF0aC5jb3MoYyksclsxXStlKk1hdGguc2luKGMpXSxsPVtyWzBdK28qTWF0aC5jb3MoYyksclsxXStvKk1hdGguc2luKGMpXSx1PVtpWzBdK2gqTWF0aC5jb3MoYytNYXRoLlBJLzQpLGlbMV0raCpNYXRoLnNpbihjK01hdGguUEkvNCldO2EucHVzaCguLi50aGlzLmhlbHBlci5kb3VibGVMaW5lT3BzKGlbMF0saVsxXSx1WzBdLHVbMV0sbiksLi4udGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyh1WzBdLHVbMV0sbFswXSxsWzFdLG4pKX19KSxhfX1jb25zdCBjPXt9O2NsYXNzIGx7Y29uc3RydWN0b3IodCl7dGhpcy5zZWVkPXR9bmV4dCgpe3JldHVybiB0aGlzLnNlZWQ/KDIqKjMxLTEmKHRoaXMuc2VlZD1NYXRoLmltdWwoNDgyNzEsdGhpcy5zZWVkKSkpLzIqKjMxOk1hdGgucmFuZG9tKCl9fWNvbnN0IHU9e0E6NyxhOjcsQzo2LGM6NixIOjEsaDoxLEw6MixsOjIsTToyLG06MixROjQscTo0LFM6NCxzOjQsVDoyLHQ6MixWOjEsdjoxLFo6MCx6OjB9O2Z1bmN0aW9uIHAodCxlKXtyZXR1cm4gdC50eXBlPT09ZX1mdW5jdGlvbiBmKHQpe2NvbnN0IGU9W10scz1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBBcnJheTtmb3IoO1wiXCIhPT10OylpZih0Lm1hdGNoKC9eKFsgXFx0XFxyXFxuLF0rKS8pKXQ9dC5zdWJzdHIoUmVnRXhwLiQxLmxlbmd0aCk7ZWxzZSBpZih0Lm1hdGNoKC9eKFthQWNDaEhsTG1NcVFzU3RUdlZ6Wl0pLykpZVtlLmxlbmd0aF09e3R5cGU6MCx0ZXh0OlJlZ0V4cC4kMX0sdD10LnN1YnN0cihSZWdFeHAuJDEubGVuZ3RoKTtlbHNle2lmKCF0Lm1hdGNoKC9eKChbLStdP1swLTldKyhcXC5bMC05XSopP3xbLStdP1xcLlswLTldKykoW2VFXVstK10/WzAtOV0rKT8pLykpcmV0dXJuW107ZVtlLmxlbmd0aF09e3R5cGU6MSx0ZXh0OlwiXCIrcGFyc2VGbG9hdChSZWdFeHAuJDEpfSx0PXQuc3Vic3RyKFJlZ0V4cC4kMS5sZW5ndGgpfXJldHVybiBlW2UubGVuZ3RoXT17dHlwZToyLHRleHQ6XCJcIn0sZX0odCk7bGV0IG49XCJCT0RcIixhPTAsbz1zW2FdO2Zvcig7IXAobywyKTspe2xldCBoPTA7Y29uc3Qgcj1bXTtpZihcIkJPRFwiPT09bil7aWYoXCJNXCIhPT1vLnRleHQmJlwibVwiIT09by50ZXh0KXJldHVybiBmKFwiTTAsMFwiK3QpO2ErKyxoPXVbby50ZXh0XSxuPW8udGV4dH1lbHNlIHAobywxKT9oPXVbbl06KGErKyxoPXVbby50ZXh0XSxuPW8udGV4dCk7aWYoIShhK2g8cy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIlBhdGggZGF0YSBlbmRlZCBzaG9ydFwiKTtmb3IobGV0IHQ9YTt0PGEraDt0Kyspe2NvbnN0IGU9c1t0XTtpZighcChlLDEpKXRocm93IG5ldyBFcnJvcihcIlBhcmFtIG5vdCBhIG51bWJlcjogXCIrbitcIixcIitlLnRleHQpO3Jbci5sZW5ndGhdPStlLnRleHR9aWYoXCJudW1iZXJcIiE9dHlwZW9mIHVbbl0pdGhyb3cgbmV3IEVycm9yKFwiQmFkIHNlZ21lbnQ6IFwiK24pO3tjb25zdCB0PXtrZXk6bixkYXRhOnJ9O2UucHVzaCh0KSxhKz1oLG89c1thXSxcIk1cIj09PW4mJihuPVwiTFwiKSxcIm1cIj09PW4mJihuPVwibFwiKX19cmV0dXJuIGV9ZnVuY3Rpb24gZCh0KXtsZXQgZT0wLHM9MCxuPTAsYT0wO2NvbnN0IG89W107Zm9yKGNvbnN0e2tleTpoLGRhdGE6cn1vZiB0KXN3aXRjaChoKXtjYXNlXCJNXCI6by5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbLi4ucl19KSxbZSxzXT1yLFtuLGFdPXI7YnJlYWs7Y2FzZVwibVwiOmUrPXJbMF0scys9clsxXSxvLnB1c2goe2tleTpcIk1cIixkYXRhOltlLHNdfSksbj1lLGE9czticmVhaztjYXNlXCJMXCI6by5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbLi4ucl19KSxbZSxzXT1yO2JyZWFrO2Nhc2VcImxcIjplKz1yWzBdLHMrPXJbMV0sby5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbZSxzXX0pO2JyZWFrO2Nhc2VcIkNcIjpvLnB1c2goe2tleTpcIkNcIixkYXRhOlsuLi5yXX0pLGU9cls0XSxzPXJbNV07YnJlYWs7Y2FzZVwiY1wiOntjb25zdCB0PXIubWFwKCh0LG4pPT5uJTI/dCtzOnQrZSk7by5wdXNoKHtrZXk6XCJDXCIsZGF0YTp0fSksZT10WzRdLHM9dFs1XTticmVha31jYXNlXCJRXCI6by5wdXNoKHtrZXk6XCJRXCIsZGF0YTpbLi4ucl19KSxlPXJbMl0scz1yWzNdO2JyZWFrO2Nhc2VcInFcIjp7Y29uc3QgdD1yLm1hcCgodCxuKT0+biUyP3Qrczp0K2UpO28ucHVzaCh7a2V5OlwiUVwiLGRhdGE6dH0pLGU9dFsyXSxzPXRbM107YnJlYWt9Y2FzZVwiQVwiOm8ucHVzaCh7a2V5OlwiQVwiLGRhdGE6Wy4uLnJdfSksZT1yWzVdLHM9cls2XTticmVhaztjYXNlXCJhXCI6ZSs9cls1XSxzKz1yWzZdLG8ucHVzaCh7a2V5OlwiQVwiLGRhdGE6W3JbMF0sclsxXSxyWzJdLHJbM10scls0XSxlLHNdfSk7YnJlYWs7Y2FzZVwiSFwiOm8ucHVzaCh7a2V5OlwiSFwiLGRhdGE6Wy4uLnJdfSksZT1yWzBdO2JyZWFrO2Nhc2VcImhcIjplKz1yWzBdLG8ucHVzaCh7a2V5OlwiSFwiLGRhdGE6W2VdfSk7YnJlYWs7Y2FzZVwiVlwiOm8ucHVzaCh7a2V5OlwiVlwiLGRhdGE6Wy4uLnJdfSkscz1yWzBdO2JyZWFrO2Nhc2VcInZcIjpzKz1yWzBdLG8ucHVzaCh7a2V5OlwiVlwiLGRhdGE6W3NdfSk7YnJlYWs7Y2FzZVwiU1wiOm8ucHVzaCh7a2V5OlwiU1wiLGRhdGE6Wy4uLnJdfSksZT1yWzJdLHM9clszXTticmVhaztjYXNlXCJzXCI6e2NvbnN0IHQ9ci5tYXAoKHQsbik9Pm4lMj90K3M6dCtlKTtvLnB1c2goe2tleTpcIlNcIixkYXRhOnR9KSxlPXRbMl0scz10WzNdO2JyZWFrfWNhc2VcIlRcIjpvLnB1c2goe2tleTpcIlRcIixkYXRhOlsuLi5yXX0pLGU9clswXSxzPXJbMV07YnJlYWs7Y2FzZVwidFwiOmUrPXJbMF0scys9clsxXSxvLnB1c2goe2tleTpcIlRcIixkYXRhOltlLHNdfSk7YnJlYWs7Y2FzZVwiWlwiOmNhc2VcInpcIjpvLnB1c2goe2tleTpcIlpcIixkYXRhOltdfSksZT1uLHM9YX1yZXR1cm4gb31mdW5jdGlvbiBnKHQpe2NvbnN0IGU9W107bGV0IHM9XCJcIixuPTAsYT0wLG89MCxoPTAscj0wLGk9MDtmb3IoY29uc3R7a2V5OmMsZGF0YTpsfW9mIHQpe3N3aXRjaChjKXtjYXNlXCJNXCI6ZS5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbLi4ubF19KSxbbixhXT1sLFtvLGhdPWw7YnJlYWs7Y2FzZVwiQ1wiOmUucHVzaCh7a2V5OlwiQ1wiLGRhdGE6Wy4uLmxdfSksbj1sWzRdLGE9bFs1XSxyPWxbMl0saT1sWzNdO2JyZWFrO2Nhc2VcIkxcIjplLnB1c2goe2tleTpcIkxcIixkYXRhOlsuLi5sXX0pLFtuLGFdPWw7YnJlYWs7Y2FzZVwiSFwiOm49bFswXSxlLnB1c2goe2tleTpcIkxcIixkYXRhOltuLGFdfSk7YnJlYWs7Y2FzZVwiVlwiOmE9bFswXSxlLnB1c2goe2tleTpcIkxcIixkYXRhOltuLGFdfSk7YnJlYWs7Y2FzZVwiU1wiOntsZXQgdD0wLG89MDtcIkNcIj09PXN8fFwiU1wiPT09cz8odD1uKyhuLXIpLG89YSsoYS1pKSk6KHQ9bixvPWEpLGUucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W3QsbywuLi5sXX0pLHI9bFswXSxpPWxbMV0sbj1sWzJdLGE9bFszXTticmVha31jYXNlXCJUXCI6e2NvbnN0W3Qsb109bDtsZXQgaD0wLGM9MDtcIlFcIj09PXN8fFwiVFwiPT09cz8oaD1uKyhuLXIpLGM9YSsoYS1pKSk6KGg9bixjPWEpO2NvbnN0IHU9bisyKihoLW4pLzMscD1hKzIqKGMtYSkvMyxmPXQrMiooaC10KS8zLGQ9bysyKihjLW8pLzM7ZS5wdXNoKHtrZXk6XCJDXCIsZGF0YTpbdSxwLGYsZCx0LG9dfSkscj1oLGk9YyxuPXQsYT1vO2JyZWFrfWNhc2VcIlFcIjp7Y29uc3RbdCxzLG8saF09bCxjPW4rMioodC1uKS8zLHU9YSsyKihzLWEpLzMscD1vKzIqKHQtbykvMyxmPWgrMioocy1oKS8zO2UucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W2MsdSxwLGYsbyxoXX0pLHI9dCxpPXMsbj1vLGE9aDticmVha31jYXNlXCJBXCI6e2NvbnN0IHQ9TWF0aC5hYnMobFswXSkscz1NYXRoLmFicyhsWzFdKSxvPWxbMl0saD1sWzNdLHI9bFs0XSxpPWxbNV0sYz1sWzZdO2lmKDA9PT10fHwwPT09cyllLnB1c2goe2tleTpcIkNcIixkYXRhOltuLGEsaSxjLGksY119KSxuPWksYT1jO2Vsc2UgaWYobiE9PWl8fGEhPT1jKXtrKG4sYSxpLGMsdCxzLG8saCxyKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlLnB1c2goe2tleTpcIkNcIixkYXRhOnR9KX0pKSxuPWksYT1jfWJyZWFrfWNhc2VcIlpcIjplLnB1c2goe2tleTpcIlpcIixkYXRhOltdfSksbj1vLGE9aH1zPWN9cmV0dXJuIGV9ZnVuY3Rpb24gTSh0LGUscyl7cmV0dXJuW3QqTWF0aC5jb3MocyktZSpNYXRoLnNpbihzKSx0Kk1hdGguc2luKHMpK2UqTWF0aC5jb3MocyldfWZ1bmN0aW9uIGsodCxlLHMsbixhLG8saCxyLGksYyl7Y29uc3QgbD0odT1oLE1hdGguUEkqdS8xODApO3ZhciB1O2xldCBwPVtdLGY9MCxkPTAsZz0wLHk9MDtpZihjKVtmLGQsZyx5XT1jO2Vsc2V7W3QsZV09TSh0LGUsLWwpLFtzLG5dPU0ocyxuLC1sKTtjb25zdCBoPSh0LXMpLzIsYz0oZS1uKS8yO2xldCB1PWgqaC8oYSphKStjKmMvKG8qbyk7dT4xJiYodT1NYXRoLnNxcnQodSksYSo9dSxvKj11KTtjb25zdCBwPWEqYSxrPW8qbyxtPXAqay1wKmMqYy1rKmgqaCxiPXAqYypjK2sqaCpoLHc9KHI9PT1pPy0xOjEpKk1hdGguc3FydChNYXRoLmFicyhtL2IpKTtnPXcqYSpjL28rKHQrcykvMix5PXcqLW8qaC9hKyhlK24pLzIsZj1NYXRoLmFzaW4ocGFyc2VGbG9hdCgoKGUteSkvbykudG9GaXhlZCg5KSkpLGQ9TWF0aC5hc2luKHBhcnNlRmxvYXQoKChuLXkpL28pLnRvRml4ZWQoOSkpKSx0PGcmJihmPU1hdGguUEktZiksczxnJiYoZD1NYXRoLlBJLWQpLGY8MCYmKGY9MipNYXRoLlBJK2YpLGQ8MCYmKGQ9MipNYXRoLlBJK2QpLGkmJmY+ZCYmKGYtPTIqTWF0aC5QSSksIWkmJmQ+ZiYmKGQtPTIqTWF0aC5QSSl9bGV0IG09ZC1mO2lmKE1hdGguYWJzKG0pPjEyMCpNYXRoLlBJLzE4MCl7Y29uc3QgdD1kLGU9cyxyPW47ZD1pJiZkPmY/ZisxMjAqTWF0aC5QSS8xODAqMTpmKzEyMCpNYXRoLlBJLzE4MCotMSxwPWsocz1nK2EqTWF0aC5jb3MoZCksbj15K28qTWF0aC5zaW4oZCksZSxyLGEsbyxoLDAsaSxbZCx0LGcseV0pfW09ZC1mO2NvbnN0IGI9TWF0aC5jb3MoZiksdz1NYXRoLnNpbihmKSxQPU1hdGguY29zKGQpLHg9TWF0aC5zaW4oZCksdj1NYXRoLnRhbihtLzQpLFM9NC8zKmEqdixPPTQvMypvKnYsVD1bdCxlXSxDPVt0K1MqdyxlLU8qYl0sVz1bcytTKngsbi1PKlBdLF89W3Msbl07aWYoQ1swXT0yKlRbMF0tQ1swXSxDWzFdPTIqVFsxXS1DWzFdLGMpcmV0dXJuW0MsVyxfXS5jb25jYXQocCk7e3A9W0MsVyxfXS5jb25jYXQocCk7Y29uc3QgdD1bXTtmb3IobGV0IGU9MDtlPHAubGVuZ3RoO2UrPTMpe2NvbnN0IHM9TShwW2VdWzBdLHBbZV1bMV0sbCksbj1NKHBbZSsxXVswXSxwW2UrMV1bMV0sbCksYT1NKHBbZSsyXVswXSxwW2UrMl1bMV0sbCk7dC5wdXNoKFtzWzBdLHNbMV0sblswXSxuWzFdLGFbMF0sYVsxXV0pfXJldHVybiB0fX1jb25zdCB5PXtyYW5kT2Zmc2V0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFcodCxlKX0scmFuZE9mZnNldFdpdGhSYW5nZTpmdW5jdGlvbih0LGUscyl7cmV0dXJuIEModCxlLHMpfSxlbGxpcHNlOmZ1bmN0aW9uKHQsZSxzLG4sYSl7Y29uc3Qgbz1QKHMsbixhKTtyZXR1cm4geCh0LGUsYSxvKS5vcHNldH0sZG91YmxlTGluZU9wczpmdW5jdGlvbih0LGUscyxuLGEpe3JldHVybiBfKHQsZSxzLG4sYSl9fTtmdW5jdGlvbiBtKHQsZSxzLG4sYSl7cmV0dXJue3R5cGU6XCJwYXRoXCIsb3BzOl8odCxlLHMsbixhKX19ZnVuY3Rpb24gYih0LGUscyl7Y29uc3Qgbj0odHx8W10pLmxlbmd0aDtpZihuPjIpe2NvbnN0IGE9W107Zm9yKGxldCBlPTA7ZTxuLTE7ZSsrKWEucHVzaCguLi5fKHRbZV1bMF0sdFtlXVsxXSx0W2UrMV1bMF0sdFtlKzFdWzFdLHMpKTtyZXR1cm4gZSYmYS5wdXNoKC4uLl8odFtuLTFdWzBdLHRbbi0xXVsxXSx0WzBdWzBdLHRbMF1bMV0scykpLHt0eXBlOlwicGF0aFwiLG9wczphfX1yZXR1cm4gMj09PW4/bSh0WzBdWzBdLHRbMF1bMV0sdFsxXVswXSx0WzFdWzFdLHMpOnt0eXBlOlwicGF0aFwiLG9wczpbXX19ZnVuY3Rpb24gdyh0LGUscyxuLGEpe3JldHVybiBmdW5jdGlvbih0LGUpe3JldHVybiBiKHQsITAsZSl9KFtbdCxlXSxbdCtzLGVdLFt0K3MsZStuXSxbdCxlK25dXSxhKX1mdW5jdGlvbiBQKHQsZSxzKXtjb25zdCBuPU1hdGguc3FydCgyKk1hdGguUEkqTWF0aC5zcXJ0KChNYXRoLnBvdyh0LzIsMikrTWF0aC5wb3coZS8yLDIpKS8yKSksYT1NYXRoLm1heChzLmN1cnZlU3RlcENvdW50LHMuY3VydmVTdGVwQ291bnQvTWF0aC5zcXJ0KDIwMCkqbiksbz0yKk1hdGguUEkvYTtsZXQgaD1NYXRoLmFicyh0LzIpLHI9TWF0aC5hYnMoZS8yKTtjb25zdCBpPTEtcy5jdXJ2ZUZpdHRpbmc7cmV0dXJuIGgrPVcoaCppLHMpLHIrPVcocippLHMpLHtpbmNyZW1lbnQ6byxyeDpoLHJ5OnJ9fWZ1bmN0aW9uIHgodCxlLHMsbil7Y29uc3RbYSxvXT16KG4uaW5jcmVtZW50LHQsZSxuLnJ4LG4ucnksMSxuLmluY3JlbWVudCpDKC4xLEMoLjQsMSxzKSxzKSxzKSxbaF09eihuLmluY3JlbWVudCx0LGUsbi5yeCxuLnJ5LDEuNSwwLHMpLHI9RShhLG51bGwscyksaT1FKGgsbnVsbCxzKTtyZXR1cm57ZXN0aW1hdGVkUG9pbnRzOm8sb3BzZXQ6e3R5cGU6XCJwYXRoXCIsb3BzOnIuY29uY2F0KGkpfX19ZnVuY3Rpb24gdih0LGUscyxuLGEsbyxoLHIsaSl7Y29uc3QgYz10LGw9ZTtsZXQgdT1NYXRoLmFicyhzLzIpLHA9TWF0aC5hYnMobi8yKTt1Kz1XKC4wMSp1LGkpLHArPVcoLjAxKnAsaSk7bGV0IGY9YSxkPW87Zm9yKDtmPDA7KWYrPTIqTWF0aC5QSSxkKz0yKk1hdGguUEk7ZC1mPjIqTWF0aC5QSSYmKGY9MCxkPTIqTWF0aC5QSSk7Y29uc3QgZz0yKk1hdGguUEkvaS5jdXJ2ZVN0ZXBDb3VudCxNPU1hdGgubWluKGcvMiwoZC1mKS8yKSxrPVIoTSxjLGwsdSxwLGYsZCwxLGkpLHk9UihNLGMsbCx1LHAsZixkLDEuNSxpKSxtPWsuY29uY2F0KHkpO3JldHVybiBoJiYocj9tLnB1c2goLi4uXyhjLGwsYyt1Kk1hdGguY29zKGYpLGwrcCpNYXRoLnNpbihmKSxpKSwuLi5fKGMsbCxjK3UqTWF0aC5jb3MoZCksbCtwKk1hdGguc2luKGQpLGkpKTptLnB1c2goe29wOlwibGluZVRvXCIsZGF0YTpbYyxsXX0se29wOlwibGluZVRvXCIsZGF0YTpbYyt1Kk1hdGguY29zKGYpLGwrcCpNYXRoLnNpbihmKV19KSkse3R5cGU6XCJwYXRoXCIsb3BzOm19fWZ1bmN0aW9uIFModCxlKXtjb25zdCBzPVtdO2lmKHQubGVuZ3RoKXtjb25zdCBuPWUubWF4UmFuZG9tbmVzc09mZnNldHx8MCxhPXQubGVuZ3RoO2lmKGE+Mil7cy5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0WzBdWzBdK1cobixlKSx0WzBdWzFdK1cobixlKV19KTtmb3IobGV0IG89MTtvPGE7bysrKXMucHVzaCh7b3A6XCJsaW5lVG9cIixkYXRhOlt0W29dWzBdK1cobixlKSx0W29dWzFdK1cobixlKV19KX19cmV0dXJue3R5cGU6XCJmaWxsUGF0aFwiLG9wczpzfX1mdW5jdGlvbiBPKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7bGV0IHM9dC5maWxsU3R5bGV8fFwiaGFjaHVyZVwiO2lmKCFjW3NdKXN3aXRjaChzKXtjYXNlXCJ6aWd6YWdcIjpjW3NdfHwoY1tzXT1uZXcgYShlKSk7YnJlYWs7Y2FzZVwiY3Jvc3MtaGF0Y2hcIjpjW3NdfHwoY1tzXT1uZXcgbyhlKSk7YnJlYWs7Y2FzZVwiZG90c1wiOmNbc118fChjW3NdPW5ldyBoKGUpKTticmVhaztjYXNlXCJkYXNoZWRcIjpjW3NdfHwoY1tzXT1uZXcgcihlKSk7YnJlYWs7Y2FzZVwiemlnemFnLWxpbmVcIjpjW3NdfHwoY1tzXT1uZXcgaShlKSk7YnJlYWs7Y2FzZVwiaGFjaHVyZVwiOmRlZmF1bHQ6cz1cImhhY2h1cmVcIixjW3NdfHwoY1tzXT1uZXcgbihlKSl9cmV0dXJuIGNbc119KGUseSkuZmlsbFBvbHlnb24odCxlKX1mdW5jdGlvbiBUKHQpe3JldHVybiB0LnJhbmRvbWl6ZXJ8fCh0LnJhbmRvbWl6ZXI9bmV3IGwodC5zZWVkfHwwKSksdC5yYW5kb21pemVyLm5leHQoKX1mdW5jdGlvbiBDKHQsZSxzLG49MSl7cmV0dXJuIHMucm91Z2huZXNzKm4qKFQocykqKGUtdCkrdCl9ZnVuY3Rpb24gVyh0LGUscz0xKXtyZXR1cm4gQygtdCx0LGUscyl9ZnVuY3Rpb24gXyh0LGUscyxuLGEpe2NvbnN0IG89SSh0LGUscyxuLGEsITAsITEpLGg9SSh0LGUscyxuLGEsITAsITApO3JldHVybiBvLmNvbmNhdChoKX1mdW5jdGlvbiBJKHQsZSxzLG4sYSxvLGgpe2NvbnN0IHI9TWF0aC5wb3codC1zLDIpK01hdGgucG93KGUtbiwyKSxpPU1hdGguc3FydChyKTtsZXQgYz0xO2M9aTwyMDA/MTppPjUwMD8uNDotLjAwMTY2NjgqaSsxLjIzMzMzNDtsZXQgbD1hLm1heFJhbmRvbW5lc3NPZmZzZXR8fDA7bCpsKjEwMD5yJiYobD1pLzEwKTtjb25zdCB1PWwvMixwPS4yKy4yKlQoYSk7bGV0IGY9YS5ib3dpbmcqYS5tYXhSYW5kb21uZXNzT2Zmc2V0KihuLWUpLzIwMCxkPWEuYm93aW5nKmEubWF4UmFuZG9tbmVzc09mZnNldCoodC1zKS8yMDA7Zj1XKGYsYSxjKSxkPVcoZCxhLGMpO2NvbnN0IGc9W10sTT0oKT0+Vyh1LGEsYyksaz0oKT0+VyhsLGEsYyk7cmV0dXJuIG8mJihoP2cucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdCtNKCksZStNKCldfSk6Zy5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0K1cobCxhLGMpLGUrVyhsLGEsYyldfSkpLGg/Zy5wdXNoKHtvcDpcImJjdXJ2ZVRvXCIsZGF0YTpbZit0KyhzLXQpKnArTSgpLGQrZSsobi1lKSpwK00oKSxmK3QrMioocy10KSpwK00oKSxkK2UrMioobi1lKSpwK00oKSxzK00oKSxuK00oKV19KTpnLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOltmK3QrKHMtdCkqcCtrKCksZCtlKyhuLWUpKnAraygpLGYrdCsyKihzLXQpKnAraygpLGQrZSsyKihuLWUpKnAraygpLHMraygpLG4raygpXX0pLGd9ZnVuY3Rpb24gTCh0LGUscyl7Y29uc3Qgbj1bXTtuLnB1c2goW3RbMF1bMF0rVyhlLHMpLHRbMF1bMV0rVyhlLHMpXSksbi5wdXNoKFt0WzBdWzBdK1coZSxzKSx0WzBdWzFdK1coZSxzKV0pO2ZvcihsZXQgYT0xO2E8dC5sZW5ndGg7YSsrKW4ucHVzaChbdFthXVswXStXKGUscyksdFthXVsxXStXKGUscyldKSxhPT09dC5sZW5ndGgtMSYmbi5wdXNoKFt0W2FdWzBdK1coZSxzKSx0W2FdWzFdK1coZSxzKV0pO3JldHVybiBFKG4sbnVsbCxzKX1mdW5jdGlvbiBFKHQsZSxzKXtjb25zdCBuPXQubGVuZ3RoLGE9W107aWYobj4zKXtjb25zdCBvPVtdLGg9MS1zLmN1cnZlVGlnaHRuZXNzO2EucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdFsxXVswXSx0WzFdWzFdXX0pO2ZvcihsZXQgZT0xO2UrMjxuO2UrKyl7Y29uc3Qgcz10W2VdO29bMF09W3NbMF0sc1sxXV0sb1sxXT1bc1swXSsoaCp0W2UrMV1bMF0taCp0W2UtMV1bMF0pLzYsc1sxXSsoaCp0W2UrMV1bMV0taCp0W2UtMV1bMV0pLzZdLG9bMl09W3RbZSsxXVswXSsoaCp0W2VdWzBdLWgqdFtlKzJdWzBdKS82LHRbZSsxXVsxXSsoaCp0W2VdWzFdLWgqdFtlKzJdWzFdKS82XSxvWzNdPVt0W2UrMV1bMF0sdFtlKzFdWzFdXSxhLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOltvWzFdWzBdLG9bMV1bMV0sb1syXVswXSxvWzJdWzFdLG9bM11bMF0sb1szXVsxXV19KX1pZihlJiYyPT09ZS5sZW5ndGgpe2NvbnN0IHQ9cy5tYXhSYW5kb21uZXNzT2Zmc2V0O2EucHVzaCh7b3A6XCJsaW5lVG9cIixkYXRhOltlWzBdK1codCxzKSxlWzFdK1codCxzKV19KX19ZWxzZSAzPT09bj8oYS5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0WzFdWzBdLHRbMV1bMV1dfSksYS5wdXNoKHtvcDpcImJjdXJ2ZVRvXCIsZGF0YTpbdFsxXVswXSx0WzFdWzFdLHRbMl1bMF0sdFsyXVsxXSx0WzJdWzBdLHRbMl1bMV1dfSkpOjI9PT1uJiZhLnB1c2goLi4uXyh0WzBdWzBdLHRbMF1bMV0sdFsxXVswXSx0WzFdWzFdLHMpKTtyZXR1cm4gYX1mdW5jdGlvbiB6KHQsZSxzLG4sYSxvLGgscil7Y29uc3QgaT1bXSxjPVtdLGw9VyguNSxyKS1NYXRoLlBJLzI7Yy5wdXNoKFtXKG8scikrZSsuOSpuKk1hdGguY29zKGwtdCksVyhvLHIpK3MrLjkqYSpNYXRoLnNpbihsLXQpXSk7Zm9yKGxldCBoPWw7aDwyKk1hdGguUEkrbC0uMDE7aCs9dCl7Y29uc3QgdD1bVyhvLHIpK2UrbipNYXRoLmNvcyhoKSxXKG8scikrcythKk1hdGguc2luKGgpXTtpLnB1c2godCksYy5wdXNoKHQpfXJldHVybiBjLnB1c2goW1cobyxyKStlK24qTWF0aC5jb3MobCsyKk1hdGguUEkrLjUqaCksVyhvLHIpK3MrYSpNYXRoLnNpbihsKzIqTWF0aC5QSSsuNSpoKV0pLGMucHVzaChbVyhvLHIpK2UrLjk4Km4qTWF0aC5jb3MobCtoKSxXKG8scikrcysuOTgqYSpNYXRoLnNpbihsK2gpXSksYy5wdXNoKFtXKG8scikrZSsuOSpuKk1hdGguY29zKGwrLjUqaCksVyhvLHIpK3MrLjkqYSpNYXRoLnNpbihsKy41KmgpXSksW2MsaV19ZnVuY3Rpb24gUih0LGUscyxuLGEsbyxoLHIsaSl7Y29uc3QgYz1vK1coLjEsaSksbD1bXTtsLnB1c2goW1cocixpKStlKy45Km4qTWF0aC5jb3MoYy10KSxXKHIsaSkrcysuOSphKk1hdGguc2luKGMtdCldKTtmb3IobGV0IG89YztvPD1oO28rPXQpbC5wdXNoKFtXKHIsaSkrZStuKk1hdGguY29zKG8pLFcocixpKStzK2EqTWF0aC5zaW4obyldKTtyZXR1cm4gbC5wdXNoKFtlK24qTWF0aC5jb3MoaCkscythKk1hdGguc2luKGgpXSksbC5wdXNoKFtlK24qTWF0aC5jb3MoaCkscythKk1hdGguc2luKGgpXSksRShsLG51bGwsaSl9ZnVuY3Rpb24gQSh0LGUscyxuLGEsbyxoLHIpe2NvbnN0IGk9W10sYz1bci5tYXhSYW5kb21uZXNzT2Zmc2V0fHwxLChyLm1heFJhbmRvbW5lc3NPZmZzZXR8fDEpKy4zXTtsZXQgbD1bMCwwXTtmb3IobGV0IHU9MDt1PDI7dSsrKTA9PT11P2kucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbaFswXSxoWzFdXX0pOmkucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbaFswXStXKGNbMF0sciksaFsxXStXKGNbMF0scildfSksbD1bYStXKGNbdV0sciksbytXKGNbdV0scildLGkucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W3QrVyhjW3VdLHIpLGUrVyhjW3VdLHIpLHMrVyhjW3VdLHIpLG4rVyhjW3VdLHIpLGxbMF0sbFsxXV19KTtyZXR1cm4gaX1mdW5jdGlvbiAkKHQpe3JldHVyblsuLi50XX1mdW5jdGlvbiBxKHQsZSl7cmV0dXJuIE1hdGgucG93KHRbMF0tZVswXSwyKStNYXRoLnBvdyh0WzFdLWVbMV0sMil9ZnVuY3Rpb24gRyh0LGUscyl7Y29uc3Qgbj1xKGUscyk7aWYoMD09PW4pcmV0dXJuIHEodCxlKTtsZXQgYT0oKHRbMF0tZVswXSkqKHNbMF0tZVswXSkrKHRbMV0tZVsxXSkqKHNbMV0tZVsxXSkpL247cmV0dXJuIGE9TWF0aC5tYXgoMCxNYXRoLm1pbigxLGEpKSxxKHQsWihlLHMsYSkpfWZ1bmN0aW9uIFoodCxlLHMpe3JldHVyblt0WzBdKyhlWzBdLXRbMF0pKnMsdFsxXSsoZVsxXS10WzFdKSpzXX1mdW5jdGlvbiBEKHQsZSxzLG4pe2NvbnN0IGE9bnx8W107aWYoZnVuY3Rpb24odCxlKXtjb25zdCBzPXRbZSswXSxuPXRbZSsxXSxhPXRbZSsyXSxvPXRbZSszXTtsZXQgaD0zKm5bMF0tMipzWzBdLW9bMF07aCo9aDtsZXQgcj0zKm5bMV0tMipzWzFdLW9bMV07cio9cjtsZXQgaT0zKmFbMF0tMipvWzBdLXNbMF07aSo9aTtsZXQgYz0zKmFbMV0tMipvWzFdLXNbMV07cmV0dXJuIGMqPWMsaDxpJiYoaD1pKSxyPGMmJihyPWMpLGgrcn0odCxlKTxzKXtjb25zdCBzPXRbZSswXTtpZihhLmxlbmd0aCl7KG89YVthLmxlbmd0aC0xXSxoPXMsTWF0aC5zcXJ0KHEobyxoKSkpPjEmJmEucHVzaChzKX1lbHNlIGEucHVzaChzKTthLnB1c2godFtlKzNdKX1lbHNle2NvbnN0IG49LjUsbz10W2UrMF0saD10W2UrMV0scj10W2UrMl0saT10W2UrM10sYz1aKG8saCxuKSxsPVooaCxyLG4pLHU9WihyLGksbikscD1aKGMsbCxuKSxmPVoobCx1LG4pLGQ9WihwLGYsbik7RChbbyxjLHAsZF0sMCxzLGEpLEQoW2QsZix1LGldLDAscyxhKX12YXIgbyxoO3JldHVybiBhfWZ1bmN0aW9uIEYodCxlKXtyZXR1cm4gUSh0LDAsdC5sZW5ndGgsZSl9ZnVuY3Rpb24gUSh0LGUscyxuLGEpe2NvbnN0IG89YXx8W10saD10W2VdLHI9dFtzLTFdO2xldCBpPTAsYz0xO2ZvcihsZXQgbj1lKzE7bjxzLTE7KytuKXtjb25zdCBlPUcodFtuXSxoLHIpO2U+aSYmKGk9ZSxjPW4pfXJldHVybiBNYXRoLnNxcnQoaSk+bj8oUSh0LGUsYysxLG4sbyksUSh0LGMscyxuLG8pKTooby5sZW5ndGh8fG8ucHVzaChoKSxvLnB1c2gocikpLG99ZnVuY3Rpb24gaih0LGU9LjE1LHMpe2NvbnN0IG49W10sYT0odC5sZW5ndGgtMSkvMztmb3IobGV0IHM9MDtzPGE7cysrKXtEKHQsMypzLGUsbil9cmV0dXJuIHMmJnM+MD9RKG4sMCxuLmxlbmd0aCxzKTpufWNvbnN0IEg9XCJub25lXCI7Y2xhc3MgTntjb25zdHJ1Y3Rvcih0KXt0aGlzLmRlZmF1bHRPcHRpb25zPXttYXhSYW5kb21uZXNzT2Zmc2V0OjIscm91Z2huZXNzOjEsYm93aW5nOjEsc3Ryb2tlOlwiIzAwMFwiLHN0cm9rZVdpZHRoOjEsY3VydmVUaWdodG5lc3M6MCxjdXJ2ZUZpdHRpbmc6Ljk1LGN1cnZlU3RlcENvdW50OjksZmlsbFN0eWxlOlwiaGFjaHVyZVwiLGZpbGxXZWlnaHQ6LTEsaGFjaHVyZUFuZ2xlOi00MSxoYWNodXJlR2FwOi0xLGRhc2hPZmZzZXQ6LTEsZGFzaEdhcDotMSx6aWd6YWdPZmZzZXQ6LTEsc2VlZDowLGNvbWJpbmVOZXN0ZWRTdmdQYXRoczohMX0sdGhpcy5jb25maWc9dHx8e30sdGhpcy5jb25maWcub3B0aW9ucyYmKHRoaXMuZGVmYXVsdE9wdGlvbnM9dGhpcy5fbyh0aGlzLmNvbmZpZy5vcHRpb25zKSl9c3RhdGljIG5ld1NlZWQoKXtyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjIqKjMxKX1fbyh0KXtyZXR1cm4gdD9PYmplY3QuYXNzaWduKHt9LHRoaXMuZGVmYXVsdE9wdGlvbnMsdCk6dGhpcy5kZWZhdWx0T3B0aW9uc31fZCh0LGUscyl7cmV0dXJue3NoYXBlOnQsc2V0czplfHxbXSxvcHRpb25zOnN8fHRoaXMuZGVmYXVsdE9wdGlvbnN9fWxpbmUodCxlLHMsbixhKXtjb25zdCBvPXRoaXMuX28oYSk7cmV0dXJuIHRoaXMuX2QoXCJsaW5lXCIsW20odCxlLHMsbixvKV0sbyl9cmVjdGFuZ2xlKHQsZSxzLG4sYSl7Y29uc3Qgbz10aGlzLl9vKGEpLGg9W10scj13KHQsZSxzLG4sbyk7aWYoby5maWxsKXtjb25zdCBhPVtbdCxlXSxbdCtzLGVdLFt0K3MsZStuXSxbdCxlK25dXTtcInNvbGlkXCI9PT1vLmZpbGxTdHlsZT9oLnB1c2goUyhhLG8pKTpoLnB1c2goTyhhLG8pKX1yZXR1cm4gby5zdHJva2UhPT1IJiZoLnB1c2gociksdGhpcy5fZChcInJlY3RhbmdsZVwiLGgsbyl9ZWxsaXBzZSh0LGUscyxuLGEpe2NvbnN0IG89dGhpcy5fbyhhKSxoPVtdLHI9UChzLG4sbyksaT14KHQsZSxvLHIpO2lmKG8uZmlsbClpZihcInNvbGlkXCI9PT1vLmZpbGxTdHlsZSl7Y29uc3Qgcz14KHQsZSxvLHIpLm9wc2V0O3MudHlwZT1cImZpbGxQYXRoXCIsaC5wdXNoKHMpfWVsc2UgaC5wdXNoKE8oaS5lc3RpbWF0ZWRQb2ludHMsbykpO3JldHVybiBvLnN0cm9rZSE9PUgmJmgucHVzaChpLm9wc2V0KSx0aGlzLl9kKFwiZWxsaXBzZVwiLGgsbyl9Y2lyY2xlKHQsZSxzLG4pe2NvbnN0IGE9dGhpcy5lbGxpcHNlKHQsZSxzLHMsbik7cmV0dXJuIGEuc2hhcGU9XCJjaXJjbGVcIixhfWxpbmVhclBhdGgodCxlKXtjb25zdCBzPXRoaXMuX28oZSk7cmV0dXJuIHRoaXMuX2QoXCJsaW5lYXJQYXRoXCIsW2IodCwhMSxzKV0scyl9YXJjKHQsZSxzLG4sYSxvLGg9ITEscil7Y29uc3QgaT10aGlzLl9vKHIpLGM9W10sbD12KHQsZSxzLG4sYSxvLGgsITAsaSk7aWYoaCYmaS5maWxsKWlmKFwic29saWRcIj09PWkuZmlsbFN0eWxlKXtjb25zdCBoPXYodCxlLHMsbixhLG8sITAsITEsaSk7aC50eXBlPVwiZmlsbFBhdGhcIixjLnB1c2goaCl9ZWxzZSBjLnB1c2goZnVuY3Rpb24odCxlLHMsbixhLG8saCl7Y29uc3Qgcj10LGk9ZTtsZXQgYz1NYXRoLmFicyhzLzIpLGw9TWF0aC5hYnMobi8yKTtjKz1XKC4wMSpjLGgpLGwrPVcoLjAxKmwsaCk7bGV0IHU9YSxwPW87Zm9yKDt1PDA7KXUrPTIqTWF0aC5QSSxwKz0yKk1hdGguUEk7cC11PjIqTWF0aC5QSSYmKHU9MCxwPTIqTWF0aC5QSSk7Y29uc3QgZj0ocC11KS9oLmN1cnZlU3RlcENvdW50LGQ9W107Zm9yKGxldCB0PXU7dDw9cDt0Kz1mKWQucHVzaChbcitjKk1hdGguY29zKHQpLGkrbCpNYXRoLnNpbih0KV0pO3JldHVybiBkLnB1c2goW3IrYypNYXRoLmNvcyhwKSxpK2wqTWF0aC5zaW4ocCldKSxkLnB1c2goW3IsaV0pLE8oZCxoKX0odCxlLHMsbixhLG8saSkpO3JldHVybiBpLnN0cm9rZSE9PUgmJmMucHVzaChsKSx0aGlzLl9kKFwiYXJjXCIsYyxpKX1jdXJ2ZSh0LGUpe2NvbnN0IHM9dGhpcy5fbyhlKSxuPVtdLGE9ZnVuY3Rpb24odCxlKXtjb25zdCBzPUwodCwxKigxKy4yKmUucm91Z2huZXNzKSxlKSxuPUwodCwxLjUqKDErLjIyKmUucm91Z2huZXNzKSxlKTtyZXR1cm57dHlwZTpcInBhdGhcIixvcHM6cy5jb25jYXQobil9fSh0LHMpO2lmKHMuZmlsbCYmcy5maWxsIT09SCYmdC5sZW5ndGg+PTMpe2NvbnN0IGU9aihmdW5jdGlvbih0LGU9MCl7Y29uc3Qgcz10Lmxlbmd0aDtpZihzPDMpdGhyb3cgbmV3IEVycm9yKFwiQSBjdXJ2ZSBtdXN0IGhhdmUgYXQgbGVhc3QgdGhyZWUgcG9pbnRzLlwiKTtjb25zdCBuPVtdO2lmKDM9PT1zKW4ucHVzaCgkKHRbMF0pLCQodFsxXSksJCh0WzJdKSwkKHRbMl0pKTtlbHNle2NvbnN0IHM9W107cy5wdXNoKHRbMF0sdFswXSk7Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDtlKyspcy5wdXNoKHRbZV0pLGU9PT10Lmxlbmd0aC0xJiZzLnB1c2godFtlXSk7Y29uc3QgYT1bXSxvPTEtZTtuLnB1c2goJChzWzBdKSk7Zm9yKGxldCB0PTE7dCsyPHMubGVuZ3RoO3QrKyl7Y29uc3QgZT1zW3RdO2FbMF09W2VbMF0sZVsxXV0sYVsxXT1bZVswXSsobypzW3QrMV1bMF0tbypzW3QtMV1bMF0pLzYsZVsxXSsobypzW3QrMV1bMV0tbypzW3QtMV1bMV0pLzZdLGFbMl09W3NbdCsxXVswXSsobypzW3RdWzBdLW8qc1t0KzJdWzBdKS82LHNbdCsxXVsxXSsobypzW3RdWzFdLW8qc1t0KzJdWzFdKS82XSxhWzNdPVtzW3QrMV1bMF0sc1t0KzFdWzFdXSxuLnB1c2goYVsxXSxhWzJdLGFbM10pfX1yZXR1cm4gbn0odCksMTAsKDErcy5yb3VnaG5lc3MpLzIpO1wic29saWRcIj09PXMuZmlsbFN0eWxlP24ucHVzaChTKGUscykpOm4ucHVzaChPKGUscykpfXJldHVybiBzLnN0cm9rZSE9PUgmJm4ucHVzaChhKSx0aGlzLl9kKFwiY3VydmVcIixuLHMpfXBvbHlnb24odCxlKXtjb25zdCBzPXRoaXMuX28oZSksbj1bXSxhPWIodCwhMCxzKTtyZXR1cm4gcy5maWxsJiYoXCJzb2xpZFwiPT09cy5maWxsU3R5bGU/bi5wdXNoKFModCxzKSk6bi5wdXNoKE8odCxzKSkpLHMuc3Ryb2tlIT09SCYmbi5wdXNoKGEpLHRoaXMuX2QoXCJwb2x5Z29uXCIsbixzKX1wYXRoKHQsZSl7Y29uc3Qgcz10aGlzLl9vKGUpLG49W107aWYoIXQpcmV0dXJuIHRoaXMuX2QoXCJwYXRoXCIsbixzKTt0PSh0fHxcIlwiKS5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSgvKC1cXHMpL2csXCItXCIpLnJlcGxhY2UoXCIvKHNzKS9nXCIsXCIgXCIpO2NvbnN0IGE9cy5maWxsJiZcInRyYW5zcGFyZW50XCIhPT1zLmZpbGwmJnMuZmlsbCE9PUgsbz1zLnN0cm9rZSE9PUgsaD0hIShzLnNpbXBsaWZpY2F0aW9uJiZzLnNpbXBsaWZpY2F0aW9uPDEpLHI9ZnVuY3Rpb24odCxlLHMpe2NvbnN0IG49ZyhkKGYodCkpKSxhPVtdO2xldCBvPVtdLGg9WzAsMF0scj1bXTtjb25zdCBpPSgpPT57ci5sZW5ndGg+PTQmJm8ucHVzaCguLi5qKHIsZSkpLHI9W119LGM9KCk9PntpKCksby5sZW5ndGgmJihhLnB1c2gobyksbz1bXSl9O2Zvcihjb25zdHtrZXk6dCxkYXRhOmV9b2Ygbilzd2l0Y2godCl7Y2FzZVwiTVwiOmMoKSxoPVtlWzBdLGVbMV1dLG8ucHVzaChoKTticmVhaztjYXNlXCJMXCI6aSgpLG8ucHVzaChbZVswXSxlWzFdXSk7YnJlYWs7Y2FzZVwiQ1wiOmlmKCFyLmxlbmd0aCl7Y29uc3QgdD1vLmxlbmd0aD9vW28ubGVuZ3RoLTFdOmg7ci5wdXNoKFt0WzBdLHRbMV1dKX1yLnB1c2goW2VbMF0sZVsxXV0pLHIucHVzaChbZVsyXSxlWzNdXSksci5wdXNoKFtlWzRdLGVbNV1dKTticmVhaztjYXNlXCJaXCI6aSgpLG8ucHVzaChbaFswXSxoWzFdXSl9aWYoYygpLCFzKXJldHVybiBhO2NvbnN0IGw9W107Zm9yKGNvbnN0IHQgb2YgYSl7Y29uc3QgZT1GKHQscyk7ZS5sZW5ndGgmJmwucHVzaChlKX1yZXR1cm4gbH0odCwxLGg/NC00KnMuc2ltcGxpZmljYXRpb246KDErcy5yb3VnaG5lc3MpLzIpO2lmKGEpaWYocy5jb21iaW5lTmVzdGVkU3ZnUGF0aHMpe2NvbnN0IHQ9W107ci5mb3JFYWNoKGU9PnQucHVzaCguLi5lKSksXCJzb2xpZFwiPT09cy5maWxsU3R5bGU/bi5wdXNoKFModCxzKSk6bi5wdXNoKE8odCxzKSl9ZWxzZSByLmZvckVhY2godD0+e1wic29saWRcIj09PXMuZmlsbFN0eWxlP24ucHVzaChTKHQscykpOm4ucHVzaChPKHQscykpfSk7cmV0dXJuIG8mJihoP3IuZm9yRWFjaCh0PT57bi5wdXNoKGIodCwhMSxzKSl9KTpuLnB1c2goZnVuY3Rpb24odCxlKXtjb25zdCBzPWcoZChmKHQpKSksbj1bXTtsZXQgYT1bMCwwXSxvPVswLDBdO2Zvcihjb25zdHtrZXk6dCxkYXRhOmh9b2Ygcylzd2l0Y2godCl7Y2FzZVwiTVwiOntjb25zdCB0PTEqKGUubWF4UmFuZG9tbmVzc09mZnNldHx8MCk7bi5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOmgubWFwKHM9PnMrVyh0LGUpKX0pLG89W2hbMF0saFsxXV0sYT1baFswXSxoWzFdXTticmVha31jYXNlXCJMXCI6bi5wdXNoKC4uLl8ob1swXSxvWzFdLGhbMF0saFsxXSxlKSksbz1baFswXSxoWzFdXTticmVhaztjYXNlXCJDXCI6e2NvbnN0W3QscyxhLHIsaSxjXT1oO24ucHVzaCguLi5BKHQscyxhLHIsaSxjLG8sZSkpLG89W2ksY107YnJlYWt9Y2FzZVwiWlwiOm4ucHVzaCguLi5fKG9bMF0sb1sxXSxhWzBdLGFbMV0sZSkpLG89W2FbMF0sYVsxXV19cmV0dXJue3R5cGU6XCJwYXRoXCIsb3BzOm59fSh0LHMpKSksdGhpcy5fZChcInBhdGhcIixuLHMpfW9wc1RvUGF0aCh0KXtsZXQgZT1cIlwiO2Zvcihjb25zdCBzIG9mIHQub3BzKXtjb25zdCB0PXMuZGF0YTtzd2l0Y2gocy5vcCl7Y2FzZVwibW92ZVwiOmUrPWBNJHt0WzBdfSAke3RbMV19IGA7YnJlYWs7Y2FzZVwiYmN1cnZlVG9cIjplKz1gQyR7dFswXX0gJHt0WzFdfSwgJHt0WzJdfSAke3RbM119LCAke3RbNF19ICR7dFs1XX0gYDticmVhaztjYXNlXCJsaW5lVG9cIjplKz1gTCR7dFswXX0gJHt0WzFdfSBgfX1yZXR1cm4gZS50cmltKCl9dG9QYXRocyh0KXtjb25zdCBlPXQuc2V0c3x8W10scz10Lm9wdGlvbnN8fHRoaXMuZGVmYXVsdE9wdGlvbnMsbj1bXTtmb3IoY29uc3QgdCBvZiBlKXtsZXQgZT1udWxsO3N3aXRjaCh0LnR5cGUpe2Nhc2VcInBhdGhcIjplPXtkOnRoaXMub3BzVG9QYXRoKHQpLHN0cm9rZTpzLnN0cm9rZSxzdHJva2VXaWR0aDpzLnN0cm9rZVdpZHRoLGZpbGw6SH07YnJlYWs7Y2FzZVwiZmlsbFBhdGhcIjplPXtkOnRoaXMub3BzVG9QYXRoKHQpLHN0cm9rZTpILHN0cm9rZVdpZHRoOjAsZmlsbDpzLmZpbGx8fEh9O2JyZWFrO2Nhc2VcImZpbGxTa2V0Y2hcIjplPXRoaXMuZmlsbFNrZXRjaCh0LHMpfWUmJm4ucHVzaChlKX1yZXR1cm4gbn1maWxsU2tldGNoKHQsZSl7bGV0IHM9ZS5maWxsV2VpZ2h0O3JldHVybiBzPDAmJihzPWUuc3Ryb2tlV2lkdGgvMikse2Q6dGhpcy5vcHNUb1BhdGgodCksc3Ryb2tlOmUuZmlsbHx8SCxzdHJva2VXaWR0aDpzLGZpbGw6SH19fWNsYXNzIFZ7Y29uc3RydWN0b3IodCxlKXt0aGlzLmNhbnZhcz10LHRoaXMuY3R4PXRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSx0aGlzLmdlbj1uZXcgTihlKX1kcmF3KHQpe2NvbnN0IGU9dC5zZXRzfHxbXSxzPXQub3B0aW9uc3x8dGhpcy5nZXREZWZhdWx0T3B0aW9ucygpLG49dGhpcy5jdHg7Zm9yKGNvbnN0IGEgb2YgZSlzd2l0Y2goYS50eXBlKXtjYXNlXCJwYXRoXCI6bi5zYXZlKCksbi5zdHJva2VTdHlsZT1cIm5vbmVcIj09PXMuc3Ryb2tlP1widHJhbnNwYXJlbnRcIjpzLnN0cm9rZSxuLmxpbmVXaWR0aD1zLnN0cm9rZVdpZHRoLHRoaXMuX2RyYXdUb0NvbnRleHQobixhKSxuLnJlc3RvcmUoKTticmVhaztjYXNlXCJmaWxsUGF0aFwiOm4uc2F2ZSgpLG4uZmlsbFN0eWxlPXMuZmlsbHx8XCJcIjtjb25zdCBlPVwiY3VydmVcIj09PXQuc2hhcGV8fFwicG9seWdvblwiPT09dC5zaGFwZT9cImV2ZW5vZGRcIjpcIm5vbnplcm9cIjt0aGlzLl9kcmF3VG9Db250ZXh0KG4sYSxlKSxuLnJlc3RvcmUoKTticmVhaztjYXNlXCJmaWxsU2tldGNoXCI6dGhpcy5maWxsU2tldGNoKG4sYSxzKX19ZmlsbFNrZXRjaCh0LGUscyl7bGV0IG49cy5maWxsV2VpZ2h0O248MCYmKG49cy5zdHJva2VXaWR0aC8yKSx0LnNhdmUoKSx0LnN0cm9rZVN0eWxlPXMuZmlsbHx8XCJcIix0LmxpbmVXaWR0aD1uLHRoaXMuX2RyYXdUb0NvbnRleHQodCxlKSx0LnJlc3RvcmUoKX1fZHJhd1RvQ29udGV4dCh0LGUscz1cIm5vbnplcm9cIil7dC5iZWdpblBhdGgoKTtmb3IoY29uc3QgcyBvZiBlLm9wcyl7Y29uc3QgZT1zLmRhdGE7c3dpdGNoKHMub3Ape2Nhc2VcIm1vdmVcIjp0Lm1vdmVUbyhlWzBdLGVbMV0pO2JyZWFrO2Nhc2VcImJjdXJ2ZVRvXCI6dC5iZXppZXJDdXJ2ZVRvKGVbMF0sZVsxXSxlWzJdLGVbM10sZVs0XSxlWzVdKTticmVhaztjYXNlXCJsaW5lVG9cIjp0LmxpbmVUbyhlWzBdLGVbMV0pfX1cImZpbGxQYXRoXCI9PT1lLnR5cGU/dC5maWxsKHMpOnQuc3Ryb2tlKCl9Z2V0IGdlbmVyYXRvcigpe3JldHVybiB0aGlzLmdlbn1nZXREZWZhdWx0T3B0aW9ucygpe3JldHVybiB0aGlzLmdlbi5kZWZhdWx0T3B0aW9uc31saW5lKHQsZSxzLG4sYSl7Y29uc3Qgbz10aGlzLmdlbi5saW5lKHQsZSxzLG4sYSk7cmV0dXJuIHRoaXMuZHJhdyhvKSxvfXJlY3RhbmdsZSh0LGUscyxuLGEpe2NvbnN0IG89dGhpcy5nZW4ucmVjdGFuZ2xlKHQsZSxzLG4sYSk7cmV0dXJuIHRoaXMuZHJhdyhvKSxvfWVsbGlwc2UodCxlLHMsbixhKXtjb25zdCBvPXRoaXMuZ2VuLmVsbGlwc2UodCxlLHMsbixhKTtyZXR1cm4gdGhpcy5kcmF3KG8pLG99Y2lyY2xlKHQsZSxzLG4pe2NvbnN0IGE9dGhpcy5nZW4uY2lyY2xlKHQsZSxzLG4pO3JldHVybiB0aGlzLmRyYXcoYSksYX1saW5lYXJQYXRoKHQsZSl7Y29uc3Qgcz10aGlzLmdlbi5saW5lYXJQYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhzKSxzfXBvbHlnb24odCxlKXtjb25zdCBzPXRoaXMuZ2VuLnBvbHlnb24odCxlKTtyZXR1cm4gdGhpcy5kcmF3KHMpLHN9YXJjKHQsZSxzLG4sYSxvLGg9ITEscil7Y29uc3QgaT10aGlzLmdlbi5hcmModCxlLHMsbixhLG8saCxyKTtyZXR1cm4gdGhpcy5kcmF3KGkpLGl9Y3VydmUodCxlKXtjb25zdCBzPXRoaXMuZ2VuLmN1cnZlKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhzKSxzfXBhdGgodCxlKXtjb25zdCBzPXRoaXMuZ2VuLnBhdGgodCxlKTtyZXR1cm4gdGhpcy5kcmF3KHMpLHN9fWNvbnN0IEI9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2NsYXNzIEp7Y29uc3RydWN0b3IodCxlKXt0aGlzLnN2Zz10LHRoaXMuZ2VuPW5ldyBOKGUpfWRyYXcodCl7Y29uc3QgZT10LnNldHN8fFtdLHM9dC5vcHRpb25zfHx0aGlzLmdldERlZmF1bHRPcHRpb25zKCksbj10aGlzLnN2Zy5vd25lckRvY3VtZW50fHx3aW5kb3cuZG9jdW1lbnQsYT1uLmNyZWF0ZUVsZW1lbnROUyhCLFwiZ1wiKTtmb3IoY29uc3QgdCBvZiBlKXtsZXQgZT1udWxsO3N3aXRjaCh0LnR5cGUpe2Nhc2VcInBhdGhcIjplPW4uY3JlYXRlRWxlbWVudE5TKEIsXCJwYXRoXCIpLGUuc2V0QXR0cmlidXRlKFwiZFwiLHRoaXMub3BzVG9QYXRoKHQpKSxlLnN0eWxlLnN0cm9rZT1zLnN0cm9rZSxlLnN0eWxlLnN0cm9rZVdpZHRoPXMuc3Ryb2tlV2lkdGgrXCJcIixlLnN0eWxlLmZpbGw9XCJub25lXCI7YnJlYWs7Y2FzZVwiZmlsbFBhdGhcIjplPW4uY3JlYXRlRWxlbWVudE5TKEIsXCJwYXRoXCIpLGUuc2V0QXR0cmlidXRlKFwiZFwiLHRoaXMub3BzVG9QYXRoKHQpKSxlLnN0eWxlLnN0cm9rZT1cIm5vbmVcIixlLnN0eWxlLnN0cm9rZVdpZHRoPVwiMFwiLGUuc3R5bGUuZmlsbD1zLmZpbGx8fFwiXCI7YnJlYWs7Y2FzZVwiZmlsbFNrZXRjaFwiOmU9dGhpcy5maWxsU2tldGNoKG4sdCxzKX1lJiZhLmFwcGVuZENoaWxkKGUpfXJldHVybiBhfWZpbGxTa2V0Y2godCxlLHMpe2xldCBuPXMuZmlsbFdlaWdodDtuPDAmJihuPXMuc3Ryb2tlV2lkdGgvMik7Y29uc3QgYT10LmNyZWF0ZUVsZW1lbnROUyhCLFwicGF0aFwiKTtyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoXCJkXCIsdGhpcy5vcHNUb1BhdGgoZSkpLGEuc3R5bGUuc3Ryb2tlPXMuZmlsbHx8XCJcIixhLnN0eWxlLnN0cm9rZVdpZHRoPW4rXCJcIixhLnN0eWxlLmZpbGw9XCJub25lXCIsYX1nZXQgZ2VuZXJhdG9yKCl7cmV0dXJuIHRoaXMuZ2VufWdldERlZmF1bHRPcHRpb25zKCl7cmV0dXJuIHRoaXMuZ2VuLmRlZmF1bHRPcHRpb25zfW9wc1RvUGF0aCh0KXtyZXR1cm4gdGhpcy5nZW4ub3BzVG9QYXRoKHQpfWxpbmUodCxlLHMsbixhKXtjb25zdCBvPXRoaXMuZ2VuLmxpbmUodCxlLHMsbixhKTtyZXR1cm4gdGhpcy5kcmF3KG8pfXJlY3RhbmdsZSh0LGUscyxuLGEpe2NvbnN0IG89dGhpcy5nZW4ucmVjdGFuZ2xlKHQsZSxzLG4sYSk7cmV0dXJuIHRoaXMuZHJhdyhvKX1lbGxpcHNlKHQsZSxzLG4sYSl7Y29uc3Qgbz10aGlzLmdlbi5lbGxpcHNlKHQsZSxzLG4sYSk7cmV0dXJuIHRoaXMuZHJhdyhvKX1jaXJjbGUodCxlLHMsbil7Y29uc3QgYT10aGlzLmdlbi5jaXJjbGUodCxlLHMsbik7cmV0dXJuIHRoaXMuZHJhdyhhKX1saW5lYXJQYXRoKHQsZSl7Y29uc3Qgcz10aGlzLmdlbi5saW5lYXJQYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhzKX1wb2x5Z29uKHQsZSl7Y29uc3Qgcz10aGlzLmdlbi5wb2x5Z29uKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhzKX1hcmModCxlLHMsbixhLG8saD0hMSxyKXtjb25zdCBpPXRoaXMuZ2VuLmFyYyh0LGUscyxuLGEsbyxoLHIpO3JldHVybiB0aGlzLmRyYXcoaSl9Y3VydmUodCxlKXtjb25zdCBzPXRoaXMuZ2VuLmN1cnZlKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhzKX1wYXRoKHQsZSl7Y29uc3Qgcz10aGlzLmdlbi5wYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhzKX19cmV0dXJue2NhbnZhczoodCxlKT0+bmV3IFYodCxlKSxzdmc6KHQsZSk9Pm5ldyBKKHQsZSksZ2VuZXJhdG9yOnQ9Pm5ldyBOKHQpLG5ld1NlZWQ6KCk9Pk4ubmV3U2VlZCgpfX0oKTtcbiIsIi8qXG4gKiBBIGZhc3QgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBzaW1wbGV4IG5vaXNlIGJ5IEpvbmFzIFdhZ25lclxuXG5CYXNlZCBvbiBhIHNwZWVkLWltcHJvdmVkIHNpbXBsZXggbm9pc2UgYWxnb3JpdGhtIGZvciAyRCwgM0QgYW5kIDREIGluIEphdmEuXG5XaGljaCBpcyBiYXNlZCBvbiBleGFtcGxlIGNvZGUgYnkgU3RlZmFuIEd1c3RhdnNvbiAoc3RlZ3VAaXRuLmxpdS5zZSkuXG5XaXRoIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxuQmV0dGVyIHJhbmsgb3JkZXJpbmcgbWV0aG9kIGJ5IFN0ZWZhbiBHdXN0YXZzb24gaW4gMjAxMi5cblxuXG4gQ29weXJpZ2h0IChjKSAyMDE4IEpvbmFzIFdhZ25lclxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBGMiA9IDAuNSAqIChNYXRoLnNxcnQoMy4wKSAtIDEuMCk7XG4gIHZhciBHMiA9ICgzLjAgLSBNYXRoLnNxcnQoMy4wKSkgLyA2LjA7XG4gIHZhciBGMyA9IDEuMCAvIDMuMDtcbiAgdmFyIEczID0gMS4wIC8gNi4wO1xuICB2YXIgRjQgPSAoTWF0aC5zcXJ0KDUuMCkgLSAxLjApIC8gNC4wO1xuICB2YXIgRzQgPSAoNS4wIC0gTWF0aC5zcXJ0KDUuMCkpIC8gMjAuMDtcblxuICBmdW5jdGlvbiBTaW1wbGV4Tm9pc2UocmFuZG9tT3JTZWVkKSB7XG4gICAgdmFyIHJhbmRvbTtcbiAgICBpZiAodHlwZW9mIHJhbmRvbU9yU2VlZCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByYW5kb20gPSByYW5kb21PclNlZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmRvbU9yU2VlZCkge1xuICAgICAgcmFuZG9tID0gYWxlYShyYW5kb21PclNlZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5kb20gPSBNYXRoLnJhbmRvbTtcbiAgICB9XG4gICAgdGhpcy5wID0gYnVpbGRQZXJtdXRhdGlvblRhYmxlKHJhbmRvbSk7XG4gICAgdGhpcy5wZXJtID0gbmV3IFVpbnQ4QXJyYXkoNTEyKTtcbiAgICB0aGlzLnBlcm1Nb2QxMiA9IG5ldyBVaW50OEFycmF5KDUxMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MTI7IGkrKykge1xuICAgICAgdGhpcy5wZXJtW2ldID0gdGhpcy5wW2kgJiAyNTVdO1xuICAgICAgdGhpcy5wZXJtTW9kMTJbaV0gPSB0aGlzLnBlcm1baV0gJSAxMjtcbiAgICB9XG5cbiAgfVxuICBTaW1wbGV4Tm9pc2UucHJvdG90eXBlID0ge1xuICAgIGdyYWQzOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwLFxuICAgICAgLTEsIDEsIDAsXG4gICAgICAxLCAtMSwgMCxcblxuICAgICAgLTEsIC0xLCAwLFxuICAgICAgMSwgMCwgMSxcbiAgICAgIC0xLCAwLCAxLFxuXG4gICAgICAxLCAwLCAtMSxcbiAgICAgIC0xLCAwLCAtMSxcbiAgICAgIDAsIDEsIDEsXG5cbiAgICAgIDAsIC0xLCAxLFxuICAgICAgMCwgMSwgLTEsXG4gICAgICAwLCAtMSwgLTFdKSxcbiAgICBncmFkNDogbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMSwgMSwgMCwgMSwgMSwgLTEsIDAsIDEsIC0xLCAxLCAwLCAxLCAtMSwgLTEsXG4gICAgICAwLCAtMSwgMSwgMSwgMCwgLTEsIDEsIC0xLCAwLCAtMSwgLTEsIDEsIDAsIC0xLCAtMSwgLTEsXG4gICAgICAxLCAwLCAxLCAxLCAxLCAwLCAxLCAtMSwgMSwgMCwgLTEsIDEsIDEsIDAsIC0xLCAtMSxcbiAgICAgIC0xLCAwLCAxLCAxLCAtMSwgMCwgMSwgLTEsIC0xLCAwLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSxcbiAgICAgIDEsIDEsIDAsIDEsIDEsIDEsIDAsIC0xLCAxLCAtMSwgMCwgMSwgMSwgLTEsIDAsIC0xLFxuICAgICAgLTEsIDEsIDAsIDEsIC0xLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIC0xLFxuICAgICAgMSwgMSwgMSwgMCwgMSwgMSwgLTEsIDAsIDEsIC0xLCAxLCAwLCAxLCAtMSwgLTEsIDAsXG4gICAgICAtMSwgMSwgMSwgMCwgLTEsIDEsIC0xLCAwLCAtMSwgLTEsIDEsIDAsIC0xLCAtMSwgLTEsIDBdKSxcbiAgICBub2lzZTJEOiBmdW5jdGlvbih4aW4sIHlpbikge1xuICAgICAgdmFyIHBlcm1Nb2QxMiA9IHRoaXMucGVybU1vZDEyO1xuICAgICAgdmFyIHBlcm0gPSB0aGlzLnBlcm07XG4gICAgICB2YXIgZ3JhZDMgPSB0aGlzLmdyYWQzO1xuICAgICAgdmFyIG4wID0gMDsgLy8gTm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG4gICAgICB2YXIgbjEgPSAwO1xuICAgICAgdmFyIG4yID0gMDtcbiAgICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cbiAgICAgIHZhciBzID0gKHhpbiArIHlpbikgKiBGMjsgLy8gSGFpcnkgZmFjdG9yIGZvciAyRFxuICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xuICAgICAgdmFyIGogPSBNYXRoLmZsb29yKHlpbiArIHMpO1xuICAgICAgdmFyIHQgPSAoaSArIGopICogRzI7XG4gICAgICB2YXIgWDAgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkpIHNwYWNlXG4gICAgICB2YXIgWTAgPSBqIC0gdDtcbiAgICAgIHZhciB4MCA9IHhpbiAtIFgwOyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICAgICAgdmFyIHkwID0geWluIC0gWTA7XG4gICAgICAvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLlxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuICAgICAgdmFyIGkxLCBqMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIChtaWRkbGUpIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGopIGNvb3Jkc1xuICAgICAgaWYgKHgwID4geTApIHtcbiAgICAgICAgaTEgPSAxO1xuICAgICAgICBqMSA9IDA7XG4gICAgICB9IC8vIGxvd2VyIHRyaWFuZ2xlLCBYWSBvcmRlcjogKDAsMCktPigxLDApLT4oMSwxKVxuICAgICAgZWxzZSB7XG4gICAgICAgIGkxID0gMDtcbiAgICAgICAgajEgPSAxO1xuICAgICAgfSAvLyB1cHBlciB0cmlhbmdsZSwgWVggb3JkZXI6ICgwLDApLT4oMCwxKS0+KDEsMSlcbiAgICAgIC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZFxuICAgICAgLy8gYSBzdGVwIG9mICgwLDEpIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jKSBpbiAoeCx5KSwgd2hlcmVcbiAgICAgIC8vIGMgPSAoMy1zcXJ0KDMpKS82XG4gICAgICB2YXIgeDEgPSB4MCAtIGkxICsgRzI7IC8vIE9mZnNldHMgZm9yIG1pZGRsZSBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG4gICAgICB2YXIgeTEgPSB5MCAtIGoxICsgRzI7XG4gICAgICB2YXIgeDIgPSB4MCAtIDEuMCArIDIuMCAqIEcyOyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcbiAgICAgIHZhciB5MiA9IHkwIC0gMS4wICsgMi4wICogRzI7XG4gICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIHRocmVlIHNpbXBsZXggY29ybmVyc1xuICAgICAgdmFyIGlpID0gaSAmIDI1NTtcbiAgICAgIHZhciBqaiA9IGogJiAyNTU7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG4gICAgICB2YXIgdDAgPSAwLjUgLSB4MCAqIHgwIC0geTAgKiB5MDtcbiAgICAgIGlmICh0MCA+PSAwKSB7XG4gICAgICAgIHZhciBnaTAgPSBwZXJtTW9kMTJbaWkgKyBwZXJtW2pqXV0gKiAzO1xuICAgICAgICB0MCAqPSB0MDtcbiAgICAgICAgbjAgPSB0MCAqIHQwICogKGdyYWQzW2dpMF0gKiB4MCArIGdyYWQzW2dpMCArIDFdICogeTApOyAvLyAoeCx5KSBvZiBncmFkMyB1c2VkIGZvciAyRCBncmFkaWVudFxuICAgICAgfVxuICAgICAgdmFyIHQxID0gMC41IC0geDEgKiB4MSAtIHkxICogeTE7XG4gICAgICBpZiAodDEgPj0gMCkge1xuICAgICAgICB2YXIgZ2kxID0gcGVybU1vZDEyW2lpICsgaTEgKyBwZXJtW2pqICsgajFdXSAqIDM7XG4gICAgICAgIHQxICo9IHQxO1xuICAgICAgICBuMSA9IHQxICogdDEgKiAoZ3JhZDNbZ2kxXSAqIHgxICsgZ3JhZDNbZ2kxICsgMV0gKiB5MSk7XG4gICAgICB9XG4gICAgICB2YXIgdDIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MjtcbiAgICAgIGlmICh0MiA+PSAwKSB7XG4gICAgICAgIHZhciBnaTIgPSBwZXJtTW9kMTJbaWkgKyAxICsgcGVybVtqaiArIDFdXSAqIDM7XG4gICAgICAgIHQyICo9IHQyO1xuICAgICAgICBuMiA9IHQyICogdDIgKiAoZ3JhZDNbZ2kyXSAqIHgyICsgZ3JhZDNbZ2kyICsgMV0gKiB5Mik7XG4gICAgICB9XG4gICAgICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXG4gICAgICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byByZXR1cm4gdmFsdWVzIGluIHRoZSBpbnRlcnZhbCBbLTEsMV0uXG4gICAgICByZXR1cm4gNzAuMCAqIChuMCArIG4xICsgbjIpO1xuICAgIH0sXG4gICAgLy8gM0Qgc2ltcGxleCBub2lzZVxuICAgIG5vaXNlM0Q6IGZ1bmN0aW9uKHhpbiwgeWluLCB6aW4pIHtcbiAgICAgIHZhciBwZXJtTW9kMTIgPSB0aGlzLnBlcm1Nb2QxMjtcbiAgICAgIHZhciBwZXJtID0gdGhpcy5wZXJtO1xuICAgICAgdmFyIGdyYWQzID0gdGhpcy5ncmFkMztcbiAgICAgIHZhciBuMCwgbjEsIG4yLCBuMzsgLy8gTm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcbiAgICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cbiAgICAgIHZhciBzID0gKHhpbiArIHlpbiArIHppbikgKiBGMzsgLy8gVmVyeSBuaWNlIGFuZCBzaW1wbGUgc2tldyBmYWN0b3IgZm9yIDNEXG4gICAgICB2YXIgaSA9IE1hdGguZmxvb3IoeGluICsgcyk7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gICAgICB2YXIgayA9IE1hdGguZmxvb3IoemluICsgcyk7XG4gICAgICB2YXIgdCA9IChpICsgaiArIGspICogRzM7XG4gICAgICB2YXIgWDAgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseikgc3BhY2VcbiAgICAgIHZhciBZMCA9IGogLSB0O1xuICAgICAgdmFyIFowID0gayAtIHQ7XG4gICAgICB2YXIgeDAgPSB4aW4gLSBYMDsgLy8gVGhlIHgseSx6IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICAgICAgdmFyIHkwID0geWluIC0gWTA7XG4gICAgICB2YXIgejAgPSB6aW4gLSBaMDtcbiAgICAgIC8vIEZvciB0aGUgM0QgY2FzZSwgdGhlIHNpbXBsZXggc2hhcGUgaXMgYSBzbGlnaHRseSBpcnJlZ3VsYXIgdGV0cmFoZWRyb24uXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG4gICAgICB2YXIgaTEsIGoxLCBrMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXG4gICAgICB2YXIgaTIsIGoyLCBrMjsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcbiAgICAgIGlmICh4MCA+PSB5MCkge1xuICAgICAgICBpZiAoeTAgPj0gejApIHtcbiAgICAgICAgICBpMSA9IDE7XG4gICAgICAgICAgajEgPSAwO1xuICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICBpMiA9IDE7XG4gICAgICAgICAgajIgPSAxO1xuICAgICAgICAgIGsyID0gMDtcbiAgICAgICAgfSAvLyBYIFkgWiBvcmRlclxuICAgICAgICBlbHNlIGlmICh4MCA+PSB6MCkge1xuICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgazEgPSAwO1xuICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICBqMiA9IDA7XG4gICAgICAgICAgazIgPSAxO1xuICAgICAgICB9IC8vIFggWiBZIG9yZGVyXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgazEgPSAxO1xuICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICBqMiA9IDA7XG4gICAgICAgICAgazIgPSAxO1xuICAgICAgICB9IC8vIFogWCBZIG9yZGVyXG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8geDA8eTBcbiAgICAgICAgaWYgKHkwIDwgejApIHtcbiAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgajEgPSAwO1xuICAgICAgICAgIGsxID0gMTtcbiAgICAgICAgICBpMiA9IDA7XG4gICAgICAgICAgajIgPSAxO1xuICAgICAgICAgIGsyID0gMTtcbiAgICAgICAgfSAvLyBaIFkgWCBvcmRlclxuICAgICAgICBlbHNlIGlmICh4MCA8IHowKSB7XG4gICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgIGoxID0gMTtcbiAgICAgICAgICBrMSA9IDA7XG4gICAgICAgICAgaTIgPSAwO1xuICAgICAgICAgIGoyID0gMTtcbiAgICAgICAgICBrMiA9IDE7XG4gICAgICAgIH0gLy8gWSBaIFggb3JkZXJcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgIGoxID0gMTtcbiAgICAgICAgICBrMSA9IDA7XG4gICAgICAgICAgaTIgPSAxO1xuICAgICAgICAgIGoyID0gMTtcbiAgICAgICAgICBrMiA9IDA7XG4gICAgICAgIH0gLy8gWSBYIFogb3JkZXJcbiAgICAgIH1cbiAgICAgIC8vIEEgc3RlcCBvZiAoMSwwLDApIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgxLWMsLWMsLWMpIGluICh4LHkseiksXG4gICAgICAvLyBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmRcbiAgICAgIC8vIGEgc3RlcCBvZiAoMCwwLDEpIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgtYywtYywxLWMpIGluICh4LHkseiksIHdoZXJlXG4gICAgICAvLyBjID0gMS82LlxuICAgICAgdmFyIHgxID0geDAgLSBpMSArIEczOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gICAgICB2YXIgeTEgPSB5MCAtIGoxICsgRzM7XG4gICAgICB2YXIgejEgPSB6MCAtIGsxICsgRzM7XG4gICAgICB2YXIgeDIgPSB4MCAtIGkyICsgMi4wICogRzM7IC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xuICAgICAgdmFyIHkyID0geTAgLSBqMiArIDIuMCAqIEczO1xuICAgICAgdmFyIHoyID0gejAgLSBrMiArIDIuMCAqIEczO1xuICAgICAgdmFyIHgzID0geDAgLSAxLjAgKyAzLjAgKiBHMzsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgICAgIHZhciB5MyA9IHkwIC0gMS4wICsgMy4wICogRzM7XG4gICAgICB2YXIgejMgPSB6MCAtIDEuMCArIDMuMCAqIEczO1xuICAgICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xuICAgICAgdmFyIGlpID0gaSAmIDI1NTtcbiAgICAgIHZhciBqaiA9IGogJiAyNTU7XG4gICAgICB2YXIga2sgPSBrICYgMjU1O1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZm91ciBjb3JuZXJzXG4gICAgICB2YXIgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XG4gICAgICBpZiAodDAgPCAwKSBuMCA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kwID0gcGVybU1vZDEyW2lpICsgcGVybVtqaiArIHBlcm1ba2tdXV0gKiAzO1xuICAgICAgICB0MCAqPSB0MDtcbiAgICAgICAgbjAgPSB0MCAqIHQwICogKGdyYWQzW2dpMF0gKiB4MCArIGdyYWQzW2dpMCArIDFdICogeTAgKyBncmFkM1tnaTAgKyAyXSAqIHowKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MSA9IDAuNiAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MTtcbiAgICAgIGlmICh0MSA8IDApIG4xID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTEgPSBwZXJtTW9kMTJbaWkgKyBpMSArIHBlcm1bamogKyBqMSArIHBlcm1ba2sgKyBrMV1dXSAqIDM7XG4gICAgICAgIHQxICo9IHQxO1xuICAgICAgICBuMSA9IHQxICogdDEgKiAoZ3JhZDNbZ2kxXSAqIHgxICsgZ3JhZDNbZ2kxICsgMV0gKiB5MSArIGdyYWQzW2dpMSArIDJdICogejEpO1xuICAgICAgfVxuICAgICAgdmFyIHQyID0gMC42IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyO1xuICAgICAgaWYgKHQyIDwgMCkgbjIgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMiA9IHBlcm1Nb2QxMltpaSArIGkyICsgcGVybVtqaiArIGoyICsgcGVybVtrayArIGsyXV1dICogMztcbiAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgIG4yID0gdDIgKiB0MiAqIChncmFkM1tnaTJdICogeDIgKyBncmFkM1tnaTIgKyAxXSAqIHkyICsgZ3JhZDNbZ2kyICsgMl0gKiB6Mik7XG4gICAgICB9XG4gICAgICB2YXIgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XG4gICAgICBpZiAodDMgPCAwKSBuMyA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kzID0gcGVybU1vZDEyW2lpICsgMSArIHBlcm1bamogKyAxICsgcGVybVtrayArIDFdXV0gKiAzO1xuICAgICAgICB0MyAqPSB0MztcbiAgICAgICAgbjMgPSB0MyAqIHQzICogKGdyYWQzW2dpM10gKiB4MyArIGdyYWQzW2dpMyArIDFdICogeTMgKyBncmFkM1tnaTMgKyAyXSAqIHozKTtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgICAgIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHN0YXkganVzdCBpbnNpZGUgWy0xLDFdXG4gICAgICByZXR1cm4gMzIuMCAqIChuMCArIG4xICsgbjIgKyBuMyk7XG4gICAgfSxcbiAgICAvLyA0RCBzaW1wbGV4IG5vaXNlLCBiZXR0ZXIgc2ltcGxleCByYW5rIG9yZGVyaW5nIG1ldGhvZCAyMDEyLTAzLTA5XG4gICAgbm9pc2U0RDogZnVuY3Rpb24oeCwgeSwgeiwgdykge1xuICAgICAgdmFyIHBlcm0gPSB0aGlzLnBlcm07XG4gICAgICB2YXIgZ3JhZDQgPSB0aGlzLmdyYWQ0O1xuXG4gICAgICB2YXIgbjAsIG4xLCBuMiwgbjMsIG40OyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZpdmUgY29ybmVyc1xuICAgICAgLy8gU2tldyB0aGUgKHgseSx6LHcpIHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBjZWxsIG9mIDI0IHNpbXBsaWNlcyB3ZSdyZSBpblxuICAgICAgdmFyIHMgPSAoeCArIHkgKyB6ICsgdykgKiBGNDsgLy8gRmFjdG9yIGZvciA0RCBza2V3aW5nXG4gICAgICB2YXIgaSA9IE1hdGguZmxvb3IoeCArIHMpO1xuICAgICAgdmFyIGogPSBNYXRoLmZsb29yKHkgKyBzKTtcbiAgICAgIHZhciBrID0gTWF0aC5mbG9vcih6ICsgcyk7XG4gICAgICB2YXIgbCA9IE1hdGguZmxvb3IodyArIHMpO1xuICAgICAgdmFyIHQgPSAoaSArIGogKyBrICsgbCkgKiBHNDsgLy8gRmFjdG9yIGZvciA0RCB1bnNrZXdpbmdcbiAgICAgIHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6LHcpIHNwYWNlXG4gICAgICB2YXIgWTAgPSBqIC0gdDtcbiAgICAgIHZhciBaMCA9IGsgLSB0O1xuICAgICAgdmFyIFcwID0gbCAtIHQ7XG4gICAgICB2YXIgeDAgPSB4IC0gWDA7IC8vIFRoZSB4LHkseix3IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICAgICAgdmFyIHkwID0geSAtIFkwO1xuICAgICAgdmFyIHowID0geiAtIFowO1xuICAgICAgdmFyIHcwID0gdyAtIFcwO1xuICAgICAgLy8gRm9yIHRoZSA0RCBjYXNlLCB0aGUgc2ltcGxleCBpcyBhIDREIHNoYXBlIEkgd29uJ3QgZXZlbiB0cnkgdG8gZGVzY3JpYmUuXG4gICAgICAvLyBUbyBmaW5kIG91dCB3aGljaCBvZiB0aGUgMjQgcG9zc2libGUgc2ltcGxpY2VzIHdlJ3JlIGluLCB3ZSBuZWVkIHRvXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIG1hZ25pdHVkZSBvcmRlcmluZyBvZiB4MCwgeTAsIHowIGFuZCB3MC5cbiAgICAgIC8vIFNpeCBwYWlyLXdpc2UgY29tcGFyaXNvbnMgYXJlIHBlcmZvcm1lZCBiZXR3ZWVuIGVhY2ggcG9zc2libGUgcGFpclxuICAgICAgLy8gb2YgdGhlIGZvdXIgY29vcmRpbmF0ZXMsIGFuZCB0aGUgcmVzdWx0cyBhcmUgdXNlZCB0byByYW5rIHRoZSBudW1iZXJzLlxuICAgICAgdmFyIHJhbmt4ID0gMDtcbiAgICAgIHZhciByYW5reSA9IDA7XG4gICAgICB2YXIgcmFua3ogPSAwO1xuICAgICAgdmFyIHJhbmt3ID0gMDtcbiAgICAgIGlmICh4MCA+IHkwKSByYW5reCsrO1xuICAgICAgZWxzZSByYW5reSsrO1xuICAgICAgaWYgKHgwID4gejApIHJhbmt4Kys7XG4gICAgICBlbHNlIHJhbmt6Kys7XG4gICAgICBpZiAoeDAgPiB3MCkgcmFua3grKztcbiAgICAgIGVsc2UgcmFua3crKztcbiAgICAgIGlmICh5MCA+IHowKSByYW5reSsrO1xuICAgICAgZWxzZSByYW5reisrO1xuICAgICAgaWYgKHkwID4gdzApIHJhbmt5Kys7XG4gICAgICBlbHNlIHJhbmt3Kys7XG4gICAgICBpZiAoejAgPiB3MCkgcmFua3orKztcbiAgICAgIGVsc2UgcmFua3crKztcbiAgICAgIHZhciBpMSwgajEsIGsxLCBsMTsgLy8gVGhlIGludGVnZXIgb2Zmc2V0cyBmb3IgdGhlIHNlY29uZCBzaW1wbGV4IGNvcm5lclxuICAgICAgdmFyIGkyLCBqMiwgazIsIGwyOyAvLyBUaGUgaW50ZWdlciBvZmZzZXRzIGZvciB0aGUgdGhpcmQgc2ltcGxleCBjb3JuZXJcbiAgICAgIHZhciBpMywgajMsIGszLCBsMzsgLy8gVGhlIGludGVnZXIgb2Zmc2V0cyBmb3IgdGhlIGZvdXJ0aCBzaW1wbGV4IGNvcm5lclxuICAgICAgLy8gc2ltcGxleFtjXSBpcyBhIDQtdmVjdG9yIHdpdGggdGhlIG51bWJlcnMgMCwgMSwgMiBhbmQgMyBpbiBzb21lIG9yZGVyLlxuICAgICAgLy8gTWFueSB2YWx1ZXMgb2YgYyB3aWxsIG5ldmVyIG9jY3VyLCBzaW5jZSBlLmcuIHg+eT56PncgbWFrZXMgeDx6LCB5PHcgYW5kIHg8d1xuICAgICAgLy8gaW1wb3NzaWJsZS4gT25seSB0aGUgMjQgaW5kaWNlcyB3aGljaCBoYXZlIG5vbi16ZXJvIGVudHJpZXMgbWFrZSBhbnkgc2Vuc2UuXG4gICAgICAvLyBXZSB1c2UgYSB0aHJlc2hvbGRpbmcgdG8gc2V0IHRoZSBjb29yZGluYXRlcyBpbiB0dXJuIGZyb20gdGhlIGxhcmdlc3QgbWFnbml0dWRlLlxuICAgICAgLy8gUmFuayAzIGRlbm90ZXMgdGhlIGxhcmdlc3QgY29vcmRpbmF0ZS5cbiAgICAgIGkxID0gcmFua3ggPj0gMyA/IDEgOiAwO1xuICAgICAgajEgPSByYW5reSA+PSAzID8gMSA6IDA7XG4gICAgICBrMSA9IHJhbmt6ID49IDMgPyAxIDogMDtcbiAgICAgIGwxID0gcmFua3cgPj0gMyA/IDEgOiAwO1xuICAgICAgLy8gUmFuayAyIGRlbm90ZXMgdGhlIHNlY29uZCBsYXJnZXN0IGNvb3JkaW5hdGUuXG4gICAgICBpMiA9IHJhbmt4ID49IDIgPyAxIDogMDtcbiAgICAgIGoyID0gcmFua3kgPj0gMiA/IDEgOiAwO1xuICAgICAgazIgPSByYW5reiA+PSAyID8gMSA6IDA7XG4gICAgICBsMiA9IHJhbmt3ID49IDIgPyAxIDogMDtcbiAgICAgIC8vIFJhbmsgMSBkZW5vdGVzIHRoZSBzZWNvbmQgc21hbGxlc3QgY29vcmRpbmF0ZS5cbiAgICAgIGkzID0gcmFua3ggPj0gMSA/IDEgOiAwO1xuICAgICAgajMgPSByYW5reSA+PSAxID8gMSA6IDA7XG4gICAgICBrMyA9IHJhbmt6ID49IDEgPyAxIDogMDtcbiAgICAgIGwzID0gcmFua3cgPj0gMSA/IDEgOiAwO1xuICAgICAgLy8gVGhlIGZpZnRoIGNvcm5lciBoYXMgYWxsIGNvb3JkaW5hdGUgb2Zmc2V0cyA9IDEsIHNvIG5vIG5lZWQgdG8gY29tcHV0ZSB0aGF0LlxuICAgICAgdmFyIHgxID0geDAgLSBpMSArIEc0OyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgIHZhciB5MSA9IHkwIC0gajEgKyBHNDtcbiAgICAgIHZhciB6MSA9IHowIC0gazEgKyBHNDtcbiAgICAgIHZhciB3MSA9IHcwIC0gbDEgKyBHNDtcbiAgICAgIHZhciB4MiA9IHgwIC0gaTIgKyAyLjAgKiBHNDsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgIHZhciB5MiA9IHkwIC0gajIgKyAyLjAgKiBHNDtcbiAgICAgIHZhciB6MiA9IHowIC0gazIgKyAyLjAgKiBHNDtcbiAgICAgIHZhciB3MiA9IHcwIC0gbDIgKyAyLjAgKiBHNDtcbiAgICAgIHZhciB4MyA9IHgwIC0gaTMgKyAzLjAgKiBHNDsgLy8gT2Zmc2V0cyBmb3IgZm91cnRoIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICB2YXIgeTMgPSB5MCAtIGozICsgMy4wICogRzQ7XG4gICAgICB2YXIgejMgPSB6MCAtIGszICsgMy4wICogRzQ7XG4gICAgICB2YXIgdzMgPSB3MCAtIGwzICsgMy4wICogRzQ7XG4gICAgICB2YXIgeDQgPSB4MCAtIDEuMCArIDQuMCAqIEc0OyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICB2YXIgeTQgPSB5MCAtIDEuMCArIDQuMCAqIEc0O1xuICAgICAgdmFyIHo0ID0gejAgLSAxLjAgKyA0LjAgKiBHNDtcbiAgICAgIHZhciB3NCA9IHcwIC0gMS4wICsgNC4wICogRzQ7XG4gICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZpdmUgc2ltcGxleCBjb3JuZXJzXG4gICAgICB2YXIgaWkgPSBpICYgMjU1O1xuICAgICAgdmFyIGpqID0gaiAmIDI1NTtcbiAgICAgIHZhciBrayA9IGsgJiAyNTU7XG4gICAgICB2YXIgbGwgPSBsICYgMjU1O1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZml2ZSBjb3JuZXJzXG4gICAgICB2YXIgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejAgLSB3MCAqIHcwO1xuICAgICAgaWYgKHQwIDwgMCkgbjAgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMCA9IChwZXJtW2lpICsgcGVybVtqaiArIHBlcm1ba2sgKyBwZXJtW2xsXV1dXSAlIDMyKSAqIDQ7XG4gICAgICAgIHQwICo9IHQwO1xuICAgICAgICBuMCA9IHQwICogdDAgKiAoZ3JhZDRbZ2kwXSAqIHgwICsgZ3JhZDRbZ2kwICsgMV0gKiB5MCArIGdyYWQ0W2dpMCArIDJdICogejAgKyBncmFkNFtnaTAgKyAzXSAqIHcwKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MSA9IDAuNiAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MSAtIHcxICogdzE7XG4gICAgICBpZiAodDEgPCAwKSBuMSA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kxID0gKHBlcm1baWkgKyBpMSArIHBlcm1bamogKyBqMSArIHBlcm1ba2sgKyBrMSArIHBlcm1bbGwgKyBsMV1dXV0gJSAzMikgKiA0O1xuICAgICAgICB0MSAqPSB0MTtcbiAgICAgICAgbjEgPSB0MSAqIHQxICogKGdyYWQ0W2dpMV0gKiB4MSArIGdyYWQ0W2dpMSArIDFdICogeTEgKyBncmFkNFtnaTEgKyAyXSAqIHoxICsgZ3JhZDRbZ2kxICsgM10gKiB3MSk7XG4gICAgICB9XG4gICAgICB2YXIgdDIgPSAwLjYgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejIgLSB3MiAqIHcyO1xuICAgICAgaWYgKHQyIDwgMCkgbjIgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMiA9IChwZXJtW2lpICsgaTIgKyBwZXJtW2pqICsgajIgKyBwZXJtW2trICsgazIgKyBwZXJtW2xsICsgbDJdXV1dICUgMzIpICogNDtcbiAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgIG4yID0gdDIgKiB0MiAqIChncmFkNFtnaTJdICogeDIgKyBncmFkNFtnaTIgKyAxXSAqIHkyICsgZ3JhZDRbZ2kyICsgMl0gKiB6MiArIGdyYWQ0W2dpMiArIDNdICogdzIpO1xuICAgICAgfVxuICAgICAgdmFyIHQzID0gMC42IC0geDMgKiB4MyAtIHkzICogeTMgLSB6MyAqIHozIC0gdzMgKiB3MztcbiAgICAgIGlmICh0MyA8IDApIG4zID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTMgPSAocGVybVtpaSArIGkzICsgcGVybVtqaiArIGozICsgcGVybVtrayArIGszICsgcGVybVtsbCArIGwzXV1dXSAlIDMyKSAqIDQ7XG4gICAgICAgIHQzICo9IHQzO1xuICAgICAgICBuMyA9IHQzICogdDMgKiAoZ3JhZDRbZ2kzXSAqIHgzICsgZ3JhZDRbZ2kzICsgMV0gKiB5MyArIGdyYWQ0W2dpMyArIDJdICogejMgKyBncmFkNFtnaTMgKyAzXSAqIHczKTtcbiAgICAgIH1cbiAgICAgIHZhciB0NCA9IDAuNiAtIHg0ICogeDQgLSB5NCAqIHk0IC0gejQgKiB6NCAtIHc0ICogdzQ7XG4gICAgICBpZiAodDQgPCAwKSBuNCA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2k0ID0gKHBlcm1baWkgKyAxICsgcGVybVtqaiArIDEgKyBwZXJtW2trICsgMSArIHBlcm1bbGwgKyAxXV1dXSAlIDMyKSAqIDQ7XG4gICAgICAgIHQ0ICo9IHQ0O1xuICAgICAgICBuNCA9IHQ0ICogdDQgKiAoZ3JhZDRbZ2k0XSAqIHg0ICsgZ3JhZDRbZ2k0ICsgMV0gKiB5NCArIGdyYWQ0W2dpNCArIDJdICogejQgKyBncmFkNFtnaTQgKyAzXSAqIHc0KTtcbiAgICAgIH1cbiAgICAgIC8vIFN1bSB1cCBhbmQgc2NhbGUgdGhlIHJlc3VsdCB0byBjb3ZlciB0aGUgcmFuZ2UgWy0xLDFdXG4gICAgICByZXR1cm4gMjcuMCAqIChuMCArIG4xICsgbjIgKyBuMyArIG40KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gYnVpbGRQZXJtdXRhdGlvblRhYmxlKHJhbmRvbSkge1xuICAgIHZhciBpO1xuICAgIHZhciBwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIHBbaV0gPSBpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU1OyBpKyspIHtcbiAgICAgIHZhciByID0gaSArIH5+KHJhbmRvbSgpICogKDI1NiAtIGkpKTtcbiAgICAgIHZhciBhdXggPSBwW2ldO1xuICAgICAgcFtpXSA9IHBbcl07XG4gICAgICBwW3JdID0gYXV4O1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICBTaW1wbGV4Tm9pc2UuX2J1aWxkUGVybXV0YXRpb25UYWJsZSA9IGJ1aWxkUGVybXV0YXRpb25UYWJsZTtcblxuICBmdW5jdGlvbiBhbGVhKCkge1xuICAgIC8vIEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2UuY29tPiwgMjAxMFxuICAgIHZhciBzMCA9IDA7XG4gICAgdmFyIHMxID0gMDtcbiAgICB2YXIgczIgPSAwO1xuICAgIHZhciBjID0gMTtcblxuICAgIHZhciBtYXNoID0gbWFzaGVyKCk7XG4gICAgczAgPSBtYXNoKCcgJyk7XG4gICAgczEgPSBtYXNoKCcgJyk7XG4gICAgczIgPSBtYXNoKCcgJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgczAgLT0gbWFzaChhcmd1bWVudHNbaV0pO1xuICAgICAgaWYgKHMwIDwgMCkge1xuICAgICAgICBzMCArPSAxO1xuICAgICAgfVxuICAgICAgczEgLT0gbWFzaChhcmd1bWVudHNbaV0pO1xuICAgICAgaWYgKHMxIDwgMCkge1xuICAgICAgICBzMSArPSAxO1xuICAgICAgfVxuICAgICAgczIgLT0gbWFzaChhcmd1bWVudHNbaV0pO1xuICAgICAgaWYgKHMyIDwgMCkge1xuICAgICAgICBzMiArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXNoID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdCA9IDIwOTE2MzkgKiBzMCArIGMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgICAgczAgPSBzMTtcbiAgICAgIHMxID0gczI7XG4gICAgICByZXR1cm4gczIgPSB0IC0gKGMgPSB0IHwgMCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtYXNoZXIoKSB7XG4gICAgdmFyIG4gPSAweGVmYzgyNDlkO1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgICBuID0gaCA+Pj4gMDtcbiAgICAgICAgaCAtPSBuO1xuICAgICAgICBoICo9IG47XG4gICAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgICBoIC09IG47XG4gICAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgICB9XG4gICAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICB9O1xuICB9XG5cbiAgLy8gYW1kXG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZnVuY3Rpb24oKSB7cmV0dXJuIFNpbXBsZXhOb2lzZTt9KTtcbiAgLy8gY29tbW9uIGpzXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIGV4cG9ydHMuU2ltcGxleE5vaXNlID0gU2ltcGxleE5vaXNlO1xuICAvLyBicm93c2VyXG4gIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB3aW5kb3cuU2ltcGxleE5vaXNlID0gU2ltcGxleE5vaXNlO1xuICAvLyBub2RlanNcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTaW1wbGV4Tm9pc2U7XG4gIH1cblxufSkoKTtcbiIsIi8qXG4gKGMpIDIwMTcsIFZsYWRpbWlyIEFnYWZvbmtpblxuIFNpbXBsaWZ5LmpzLCBhIGhpZ2gtcGVyZm9ybWFuY2UgSlMgcG9seWxpbmUgc2ltcGxpZmljYXRpb24gbGlicmFyeVxuIG1vdXJuZXIuZ2l0aHViLmlvL3NpbXBsaWZ5LWpzXG4qL1xuXG4oZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbi8vIHRvIHN1aXQgeW91ciBwb2ludCBmb3JtYXQsIHJ1biBzZWFyY2gvcmVwbGFjZSBmb3IgJy54JyBhbmQgJy55Jztcbi8vIGZvciAzRCB2ZXJzaW9uLCBzZWUgM2QgYnJhbmNoIChjb25maWd1cmFiaWxpdHkgd291bGQgZHJhdyBzaWduaWZpY2FudCBwZXJmb3JtYW5jZSBvdmVyaGVhZClcblxuLy8gc3F1YXJlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbmZ1bmN0aW9uIGdldFNxRGlzdChwMSwgcDIpIHtcblxuICAgIHZhciBkeCA9IHAxLnggLSBwMi54LFxuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudFxuZnVuY3Rpb24gZ2V0U3FTZWdEaXN0KHAsIHAxLCBwMikge1xuXG4gICAgdmFyIHggPSBwMS54LFxuICAgICAgICB5ID0gcDEueSxcbiAgICAgICAgZHggPSBwMi54IC0geCxcbiAgICAgICAgZHkgPSBwMi55IC0geTtcblxuICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuXG4gICAgICAgIHZhciB0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgIHggPSBwMi54O1xuICAgICAgICAgICAgeSA9IHAyLnk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgICAgICAgeCArPSBkeCAqIHQ7XG4gICAgICAgICAgICB5ICs9IGR5ICogdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGR4ID0gcC54IC0geDtcbiAgICBkeSA9IHAueSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG4vLyByZXN0IG9mIHRoZSBjb2RlIGRvZXNuJ3QgY2FyZSBhYm91dCBwb2ludCBmb3JtYXRcblxuLy8gYmFzaWMgZGlzdGFuY2UtYmFzZWQgc2ltcGxpZmljYXRpb25cbmZ1bmN0aW9uIHNpbXBsaWZ5UmFkaWFsRGlzdChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XG5cbiAgICB2YXIgcHJldlBvaW50ID0gcG9pbnRzWzBdLFxuICAgICAgICBuZXdQb2ludHMgPSBbcHJldlBvaW50XSxcbiAgICAgICAgcG9pbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmIChnZXRTcURpc3QocG9pbnQsIHByZXZQb2ludCkgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldlBvaW50ICE9PSBwb2ludCkgbmV3UG9pbnRzLnB1c2gocG9pbnQpO1xuXG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBmaXJzdCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpIHtcbiAgICB2YXIgbWF4U3FEaXN0ID0gc3FUb2xlcmFuY2UsXG4gICAgICAgIGluZGV4O1xuXG4gICAgZm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICB2YXIgc3FEaXN0ID0gZ2V0U3FTZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdKTtcblxuICAgICAgICBpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICBtYXhTcURpc3QgPSBzcURpc3Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgaWYgKGluZGV4IC0gZmlyc3QgPiAxKSBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBpbmRleCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgICAgICBzaW1wbGlmaWVkLnB1c2gocG9pbnRzW2luZGV4XSk7XG4gICAgICAgIGlmIChsYXN0IC0gaW5kZXggPiAxKSBzaW1wbGlmeURQU3RlcChwb2ludHMsIGluZGV4LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgfVxufVxuXG4vLyBzaW1wbGlmaWNhdGlvbiB1c2luZyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXG5mdW5jdGlvbiBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcbiAgICB2YXIgbGFzdCA9IHBvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgdmFyIHNpbXBsaWZpZWQgPSBbcG9pbnRzWzBdXTtcbiAgICBzaW1wbGlmeURQU3RlcChwb2ludHMsIDAsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICBzaW1wbGlmaWVkLnB1c2gocG9pbnRzW2xhc3RdKTtcblxuICAgIHJldHVybiBzaW1wbGlmaWVkO1xufVxuXG4vLyBib3RoIGFsZ29yaXRobXMgY29tYmluZWQgZm9yIGF3ZXNvbWUgcGVyZm9ybWFuY2VcbmZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlLCBoaWdoZXN0UXVhbGl0eSkge1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPD0gMikgcmV0dXJuIHBvaW50cztcblxuICAgIHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID8gdG9sZXJhbmNlICogdG9sZXJhbmNlIDogMTtcblxuICAgIHBvaW50cyA9IGhpZ2hlc3RRdWFsaXR5ID8gcG9pbnRzIDogc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpO1xuICAgIHBvaW50cyA9IHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG5cbiAgICByZXR1cm4gcG9pbnRzO1xufVxuXG4vLyBleHBvcnQgYXMgQU1EIG1vZHVsZSAvIE5vZGUgbW9kdWxlIC8gYnJvd3NlciBvciB3b3JrZXIgdmFyaWFibGVcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNpbXBsaWZ5OyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzaW1wbGlmeTtcbiAgICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gc2ltcGxpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgc2VsZi5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuZWxzZSB3aW5kb3cuc2ltcGxpZnkgPSBzaW1wbGlmeTtcblxufSkoKTtcbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBkYXQgZnJvbSAnZGF0Lmd1aSc7XG5pbXBvcnQgVGVuc29yRmllbGRHVUkgZnJvbSAnLi90cy91aS90ZW5zb3JfZmllbGRfZ3VpJztcbmltcG9ydCB7Tm9pc2VQYXJhbXN9IGZyb20gJy4vdHMvaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IFJvYWRzR1VJIGZyb20gJy4vdHMvdWkvcm9hZHNfZ3VpJztcbmltcG9ydCBDYW52YXNXcmFwcGVyIGZyb20gJy4vdHMvdWkvY2FudmFzX3dyYXBwZXInO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi90cy91dGlsJztcbmltcG9ydCBEcmFnQ29udHJvbGxlciBmcm9tICcuL3RzL3VpL2RyYWdfY29udHJvbGxlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL3RzL3VpL2RvbWFpbl9jb250cm9sbGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBEcmF3YWJsZSB7XG4gICAgZHJhdygpOiB2b2lkO1xufVxuXG5jbGFzcyBNYWluIHtcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG4gICAgcHJpdmF0ZSBjYW52YXM6IENhbnZhc1dyYXBwZXI7XG4gICAgcHJpdmF0ZSBndWk6IGRhdC5HVUkgPSBuZXcgZGF0LkdVSSh7d2lkdGg6IDMwMH0pO1xuICAgIHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkR1VJO1xuICAgIHByaXZhdGUgcm9hZHNHVUk6IFJvYWRzR1VJO1xuICAgIHByaXZhdGUgZHJhZ0NvbnRyb2xsZXIgPSBuZXcgRHJhZ0NvbnRyb2xsZXIodGhpcy5ndWkpO1xuXG4gICAgLy8gT3B0aW9uc1xuICAgIHByaXZhdGUgaW1hZ2VTY2FsZSA9IDM7XG5cbiAgICAvLyBGb2xkZXJzXG4gICAgcHJpdmF0ZSB0ZW5zb3JGb2xkZXI6IGRhdC5HVUk7XG4gICAgcHJpdmF0ZSByb2Fkc0ZvbGRlcjogZGF0LkdVSTtcblxuICAgIC8vIFRvIGZvcmNlIGRyYXcgaWYgbmVlZGVkXG4gICAgcHJpdmF0ZSBwcmV2aW91c0ZyYW1lRHJhd1RlbnNvciA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFV0aWwuQ0FOVkFTX0lEKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzV3JhcHBlcihjKTtcbiAgICAgICAgY29uc3Qgem9vbUNvbnRyb2xsZXIgPSB0aGlzLmd1aS5hZGQodGhpcy5kb21haW5Db250cm9sbGVyLCAnem9vbScpO1xuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuc2V0Wm9vbVVwZGF0ZSgoKSA9PiB6b29tQ29udHJvbGxlci51cGRhdGVEaXNwbGF5KCkpO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgbm9pc2VQYXJhbXM6IE5vaXNlUGFyYW1zID0ge1xuICAgICAgICAgICAgZ2xvYmFsTm9pc2U6IGZhbHNlLFxuICAgICAgICAgICAgbm9pc2VTaXplUGFyazogMjAsXG4gICAgICAgICAgICBub2lzZUFuZ2xlUGFyazogOTAsXG4gICAgICAgICAgICBub2lzZVNpemVHbG9iYWw6IDMwLFxuICAgICAgICAgICAgbm9pc2VBbmdsZUdsb2JhbDogMjBcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRlbnNvckZvbGRlciA9IHRoaXMuZ3VpLmFkZEZvbGRlcignVGVuc29yIEZpZWxkJyk7XG4gICAgICAgIHRoaXMudGVuc29yRmllbGQgPSBuZXcgVGVuc29yRmllbGRHVUkodGhpcy50ZW5zb3JGb2xkZXIsIHRoaXMuZHJhZ0NvbnRyb2xsZXIsIHRydWUsIG5vaXNlUGFyYW1zKTtcbiAgICAgICAgdGhpcy50ZW5zb3JGb2xkZXIub3BlbigpO1xuXG4gICAgICAgIHRoaXMucm9hZHNGb2xkZXIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoJ1JvYWRzJyk7XG4gICAgICAgIHRoaXMucm9hZHNGb2xkZXIub3BlbigpO1xuXG4gICAgICAgIHRoaXMucm9hZHNHVUkgPSBuZXcgUm9hZHNHVUkodGhpcy5yb2Fkc0ZvbGRlciwgdGhpcy50ZW5zb3JGaWVsZCwgKCkgPT4gdGhpcy50ZW5zb3JGb2xkZXIuY2xvc2UoKSk7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9uc0ZvbGRlciA9IHRoaXMuZ3VpLmFkZEZvbGRlcignT3B0aW9ucycpO1xuICAgICAgICBvcHRpb25zRm9sZGVyLmFkZCh0aGlzLnRlbnNvckZpZWxkLCAnZHJhd0NlbnRyZScpO1xuICAgICAgICBvcHRpb25zRm9sZGVyLmFkZCh0aGlzLmNhbnZhcywgJ2NhbnZhc1NjYWxlJyk7XG4gICAgICAgIG9wdGlvbnNGb2xkZXIuYWRkKHRoaXMsICdpbWFnZVNjYWxlJywgMSwgNSk7XG4gICAgICAgIG9wdGlvbnNGb2xkZXIuYWRkKHRoaXMsICdkb3dubG9hZCcpO1xuXG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuc2V0UmVjb21tZW5kZWQoKTtcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGltYWdlIG9mIG1hcFxuICAgICAqIERyYXdzIG9udG8gaGlkZGVuIGNhbnZhcyBhdCByZXF1ZXN0ZWQgcmVzb2x1dGlvblxuICAgICAqL1xuICAgIGRvd25sb2FkKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBjID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVXRpbC5JTUdfQ0FOVkFTX0lEKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgICAgY29uc3QgaW1nQ2FudmFzID0gbmV3IENhbnZhc1dyYXBwZXIoYywgdGhpcy5pbWFnZVNjYWxlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZHJhdyhpbWdDYW52YXMsIHRydWUpO1xuICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBsaW5rLmRvd25sb2FkID0gJ21hcC5wbmcnO1xuICAgICAgICBsaW5rLmhyZWYgPSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVXRpbC5JTUdfQ0FOVkFTX0lEKSBhcyBhbnkpLnRvRGF0YVVSTCgpO1xuICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3VGVuc29yRmllbGQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhdGhpcy50ZW5zb3JGb2xkZXIuY2xvc2VkIHx8IHRoaXMucm9hZHNHVUkucm9hZHNFbXB0eSgpO1xuICAgIH1cblxuICAgIGRyYXcoY2FudmFzOiBDYW52YXNXcmFwcGVyLCBmb3JjZURyYXc9ZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhd1RlbnNvckZpZWxkKCkpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNGcmFtZURyYXdUZW5zb3IgPSB0cnVlO1xuICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSgnYmxhY2snKTtcbiAgICAgICAgICAgIGNhbnZhcy5jbGVhckNhbnZhcygpO1xuICAgICAgICAgICAgdGhpcy5kcmFnQ29udHJvbGxlci5zZXREcmFnRGlzYWJsZWQoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5kcmF3KGNhbnZhcywgZm9yY2VEcmF3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbnRyb2xsZXIuc2V0RHJhZ0Rpc2FibGVkKHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNGcmFtZURyYXdUZW5zb3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSByZWRyYXdcbiAgICAgICAgICAgICAgICB0aGlzLnJvYWRzR1VJLmRyYXcoY2FudmFzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzRnJhbWVEcmF3VGVuc29yID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucm9hZHNHVUkuZHJhdyhjYW52YXMsIGZvcmNlRHJhdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZHJhdyh0aGlzLmNhbnZhcyk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCk6IHZvaWQgPT4ge1xuICAgIG5ldyBNYWluKCk7XG59KTtcbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvciB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHg6IG51bWJlciwgcHVibGljIHk6IG51bWJlcikge31cblxuICAgIHN0YXRpYyB6ZXJvVmVjdG9yKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIDApO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tU2NhbGFyKHM6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHMsIHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIC1waSB0byBwaVxuICAgICAqL1xuICAgIHN0YXRpYyBhbmdsZUJldHdlZW4odjE6IFZlY3RvciwgdjI6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIC8vIC0ycGkgdG8gMnBpXG4gICAgICAgIGxldCBhbmdsZUJldHdlZW4gPSB2MS5hbmdsZSgpIC0gdjIuYW5nbGUoKTtcbiAgICAgICAgaWYgKGFuZ2xlQmV0d2VlbiA+IE1hdGguUEkpIHtcbiAgICAgICAgICAgIGFuZ2xlQmV0d2VlbiAtPSAyICogTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmdsZUJldHdlZW4gPD0gLU1hdGguUEkpIHtcbiAgICAgICAgICAgIGFuZ2xlQmV0d2VlbiArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5nbGVCZXR3ZWVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgYSBwb2ludCBsaWVzIHRvIHRoZSBsZWZ0IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSAge1ZlY3Rvcn0gbGluZVBvaW50ICAgICBQb2ludCBvbiB0aGUgbGluZVxuICAgICAqIEBwYXJhbSAge1ZlY3Rvcn0gbGluZURpcmVjdGlvbiBcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IHBvaW50XG4gICAgICogQHJldHVybiB7VmVjdG9yfSAgICAgICAgICAgICAgIHRydWUgaWYgbGVmdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIGlzTGVmdChsaW5lUG9pbnQ6IFZlY3RvciwgbGluZURpcmVjdGlvbjogVmVjdG9yLCBwb2ludDogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHBlcnBlbmRpY3VsYXJWZWN0b3IgPSBuZXcgVmVjdG9yKGxpbmVEaXJlY3Rpb24ueSwgLWxpbmVEaXJlY3Rpb24ueCk7XG4gICAgICAgIHJldHVybiBwb2ludC5jbG9uZSgpLnN1YihsaW5lUG9pbnQpLmRvdChwZXJwZW5kaWN1bGFyVmVjdG9yKSA8IDA7XG4gICAgfVxuXG4gICAgYWRkKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICAgIHRoaXMueSArPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIGluIHJhZGlhbnMgdG8gcG9zaXRpdmUgeC1heGlzIGJldHdlZW4gLXBpIGFuZCBwaVxuICAgICAqL1xuICAgIGFuZ2xlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuXG4gICAgY29weSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY3Jvc3ModjogVmVjdG9yKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcbiAgICB9XG5cbiAgICBkaXN0YW5jZVRvKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh2KSk7XG4gICAgfVxuXG4gICAgZGlzdGFuY2VUb1NxdWFyZWQgKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy54IC0gdi54XG4gICAgICAgIGNvbnN0IGR5ID0gdGhpcy55IC0gdi55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuXG4gICAgZGl2aWRlKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIGlmICh2LnggPT09IDAgfHwgdi55ID09PSAwKSB7XG4gICAgICAgICAgICBsb2cud2FybihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCAvPSB2Lng7XG4gICAgICAgIHRoaXMueSAvPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRpdmlkZVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHMpO1xuICAgIH1cblxuICAgIGRvdCh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuICAgIH1cblxuICAgIGVxdWFscyh2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICgodi54ID09PSB0aGlzLngpICYmICh2LnkgPT09IHRoaXMueSkpO1xuICAgIH1cblxuICAgIGxlbmd0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSk7XG4gICAgfVxuXG4gICAgbGVuZ3RoU3EoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcbiAgICB9XG5cbiAgICBtdWx0aXBseSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKj0gdi54O1xuICAgICAgICB0aGlzLnkgKj0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtdWx0aXBseVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKj0gcztcbiAgICAgICAgdGhpcy55ICo9IHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG5lZ2F0ZSgpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigtMSk7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplKCk6IFZlY3RvciB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJaZXJvIFZlY3RvclwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgaW4gcmFkaWFuc1xuICAgICAqL1xuICAgIHJvdGF0ZUFyb3VuZChjZW50ZXI6IFZlY3RvciwgYW5nbGU6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKVxuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMueCAtIGNlbnRlci54O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cbiAgICAgICAgdGhpcy54ID0geCAqIGNvcyAtIHkgKiBzaW4gKyBjZW50ZXIueDtcbiAgICAgICAgdGhpcy55ID0geCAqIHNpbiArIHkgKiBjb3MgKyBjZW50ZXIueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0KHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRYKHg6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldFkoeTogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0TGVuZ3RoIChsZW5ndGg6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG4gICAgfVxuXG4gICAgc3ViKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCAtPSB2Lng7XG4gICAgICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbiIsImltcG9ydCBUZW5zb3IgZnJvbSAnLi90ZW5zb3InO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzaXNGaWVsZCB7XG4gICAgYWJzdHJhY3QgcmVhZG9ubHkgRk9MREVSX05BTUU6IHN0cmluZztcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGZvbGRlck5hbWVJbmRleDogbnVtYmVyID0gMDtcbiAgICBwcm90ZWN0ZWQgX2NlbnRyZTogVmVjdG9yO1xuXG4gICAgY29uc3RydWN0b3IoY2VudHJlOiBWZWN0b3IsIHByb3RlY3RlZCBfc2l6ZTogbnVtYmVyLCBwcm90ZWN0ZWQgX2RlY2F5OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fY2VudHJlID0gY2VudHJlLmNsb25lKCk7XG4gICAgfVxuXG4gICAgc2V0IGNlbnRyZShjZW50cmU6IFZlY3Rvcikge1xuICAgICAgICB0aGlzLl9jZW50cmUuY29weShjZW50cmUpO1xuICAgIH1cblxuICAgIGdldCBjZW50cmUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRyZS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHNldCBkZWNheShkZWNheTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2RlY2F5ID0gZGVjYXk7XG4gICAgfVxuXG4gICAgc2V0IHNpemUoc2l6ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIH1cblxuICAgIGRyYWdNb3ZlTGlzdGVuZXIoZGVsdGE6IFZlY3Rvcik6IHZvaWQge1xuICAgICAgICAvLyBEZWx0YSBhc3N1bWVkIHRvIGJlIGluIHdvcmxkIHNwYWNlIChvbmx5IHJlbGV2YW50IHdoZW4gem9vbWVkKVxuICAgICAgICB0aGlzLl9jZW50cmUuYWRkKGRlbHRhKTtcbiAgICB9XG5cbiAgICBhYnN0cmFjdCBnZXRUZW5zb3IocG9pbnQ6IFZlY3Rvcik6IFRlbnNvcjtcblxuICAgIGdldFdlaWdodGVkVGVuc29yKHBvaW50OiBWZWN0b3IpOiBUZW5zb3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUZW5zb3IocG9pbnQpLnNjYWxlKHRoaXMuZ2V0VGVuc29yV2VpZ2h0KHBvaW50KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZvbGRlciBhbmQgYWRkcyBpdCB0byB0aGUgR1VJIHRvIGNvbnRyb2wgcGFyYW1zXG4gICAgICovXG4gICAgc2V0R3VpKGd1aTogZGF0LkdVSSk6IHZvaWQge1xuICAgICAgICBndWkuYWRkKHRoaXMuX2NlbnRyZSwgJ3gnKTtcbiAgICAgICAgZ3VpLmFkZCh0aGlzLl9jZW50cmUsICd5Jyk7XG4gICAgICAgIGd1aS5hZGQodGhpcywgJ19zaXplJyk7XG4gICAgICAgIGd1aS5hZGQodGhpcywgJ19kZWNheScsIDAsIDUwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcnBvbGF0ZXMgYmV0d2VlbiAoMCBhbmQgMSleZGVjYXlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0VGVuc29yV2VpZ2h0KHBvaW50OiBWZWN0b3IpOiBudW1iZXIgeyAgICAgICAgXG4gICAgICAgIGNvbnN0IG5vcm1EaXN0YW5jZVRvQ2VudHJlID0gcG9pbnQuY2xvbmUoKS5zdWIodGhpcy5fY2VudHJlKS5sZW5ndGgoKSAvIHRoaXMuX3NpemU7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9wICgqKiAwKSB0dXJuaW5nIHdlaWdodCBpbnRvIDEsIGZpbGxpbmcgc2NyZWVuIGV2ZW4gd2hlbiBvdXRzaWRlICdzaXplJ1xuICAgICAgICBpZiAodGhpcy5fZGVjYXkgPT09IDAgJiYgbm9ybURpc3RhbmNlVG9DZW50cmUgPj0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICgxIC0gbm9ybURpc3RhbmNlVG9DZW50cmUpKSAqKiB0aGlzLl9kZWNheTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHcmlkIGV4dGVuZHMgQmFzaXNGaWVsZCB7XG4gICAgcmVhZG9ubHkgRk9MREVSX05BTUUgPSBgR3JpZCAke0dyaWQuZm9sZGVyTmFtZUluZGV4Kyt9YDtcblxuICAgIGNvbnN0cnVjdG9yKGNlbnRyZTogVmVjdG9yLCBzaXplOiBudW1iZXIsIGRlY2F5OiBudW1iZXIsIHByaXZhdGUgX3RoZXRhOiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoY2VudHJlLCBzaXplLCBkZWNheSk7XG4gICAgfVxuXG4gICAgc2V0IHRoZXRhKHRoZXRhOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdGhldGEgPSB0aGV0YTtcbiAgICB9XG5cbiAgICBzZXRHdWkoZ3VpOiBkYXQuR1VJKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnNldEd1aShndWkpO1xuXG4gICAgICAgIC8vIEdVSSBpbiBkZWdyZWVzLCBjb252ZXJ0IHRvIHJhZHNcbiAgICAgICAgY29uc3QgdGhldGFQcm9wID0ge3RoZXRhOiB0aGlzLl90aGV0YSAqIDE4MCAvIE1hdGguUEl9O1xuICAgICAgICBjb25zdCB0aGV0YUNvbnRyb2xsZXIgPSBndWkuYWRkKHRoZXRhUHJvcCwgJ3RoZXRhJywgLTkwLCA5MCk7XG4gICAgICAgIHRoZXRhQ29udHJvbGxlci5vbkNoYW5nZSh0aGV0YSA9PiB0aGlzLl90aGV0YSA9IHRoZXRhICogKE1hdGguUEkgLyAxODApKTtcbiAgICB9XG5cbiAgICBnZXRUZW5zb3IocG9pbnQ6IFZlY3Rvcik6IFRlbnNvciB7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKDIgKiB0aGlzLl90aGV0YSk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKDIgKiB0aGlzLl90aGV0YSk7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKDEsIFtjb3MsIHNpbl0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJhZGlhbCBleHRlbmRzIEJhc2lzRmllbGQge1xuICAgIHJlYWRvbmx5IEZPTERFUl9OQU1FID0gYFJhZGlhbCAke1JhZGlhbC5mb2xkZXJOYW1lSW5kZXgrK31gO1xuICAgIGNvbnN0cnVjdG9yKGNlbnRyZTogVmVjdG9yLCBzaXplOiBudW1iZXIsIGRlY2F5OiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoY2VudHJlLCBzaXplLCBkZWNheSk7XG4gICAgfVxuXG4gICAgZ2V0VGVuc29yKHBvaW50OiBWZWN0b3IpOiBUZW5zb3Ige1xuICAgICAgICBjb25zdCB0ID0gcG9pbnQuY2xvbmUoKS5zdWIodGhpcy5fY2VudHJlKTtcbiAgICAgICAgY29uc3QgdDEgPSB0LnkqKjIgLSB0LngqKjI7XG4gICAgICAgIGNvbnN0IHQyID0gLTIgKiB0LnggKiB0Lnk7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKDEsIFt0MSwgdDJdKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0ICogYXMgaXNlY3QgZnJvbSAnaXNlY3QnO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMtcXVhZHRyZWUnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5kZWNsYXJlIG1vZHVsZSAnaXNlY3QnIHtcbiAgICBleHBvcnQgZnVuY3Rpb24gYnVzaChsaW5lczogU2VnbWVudFtdKTogRGV0ZWN0SW50ZXJzZWN0aW9ucztcbn1cblxuaW50ZXJmYWNlIERldGVjdEludGVyc2VjdGlvbnMge1xuICAgIHJ1bjogKCkgPT4gSW50ZXJzZWN0aW9uW107XG59XG5cbmludGVyZmFjZSBTZWdtZW50IHtcbiAgICBmcm9tOiBWZWN0b3I7XG4gICAgdG86IFZlY3Rvcjtcbn1cblxuaW50ZXJmYWNlIEludGVyc2VjdGlvbiB7XG4gICAgcG9pbnQ6IFZlY3RvcjtcbiAgICBzZWdtZW50czogU2VnbWVudFtdO1xufVxuXG5leHBvcnQgY2xhc3MgTm9kZSB7XG4gICAgcHVibGljIHNlZ21lbnRzID0gbmV3IFNldDxTZWdtZW50PigpO1xuICAgIHB1YmxpYyBhZGo6IE5vZGVbXTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB2YWx1ZTogVmVjdG9yLCBwdWJsaWMgbmVpZ2hib3JzPW5ldyBTZXQ8Tm9kZT4oKSkge31cblxuICAgIGFkZFNlZ21lbnQoc2VnbWVudDogU2VnbWVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNlZ21lbnRzLmFkZChzZWdtZW50KTtcbiAgICB9XG5cbiAgICBhZGROZWlnaGJvcihub2RlOiBOb2RlKTogdm9pZCB7XG4gICAgICAgIGlmIChub2RlICE9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLm5laWdoYm9ycy5hZGQobm9kZSk7XG4gICAgICAgICAgICBub2RlLm5laWdoYm9ycy5hZGQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoIHtcbiAgICBwdWJsaWMgbm9kZXM6IE5vZGVbXTtcbiAgICBwdWJsaWMgaW50ZXJzZWN0aW9uczogVmVjdG9yW107XG5cbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1saW5lczogVmVjdG9yW11bXSwgZHN0ZXA6IG51bWJlcikge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gaXNlY3QuYnVzaCh0aGlzLnN0cmVhbWxpbmVzVG9TZWdtZW50KHN0cmVhbWxpbmVzKSkucnVuKCk7XG4gICAgICAgIGNvbnN0IHF1YWR0cmVlID0gKGQzLnF1YWR0cmVlKCkgYXMgZDMuUXVhZHRyZWU8Tm9kZT4pLngobiA9PiBuLnZhbHVlLngpLnkobiA9PiBuLnZhbHVlLnkpO1xuICAgICAgICBjb25zdCBub2RlQWRkUmFkaXVzID0gMC4wMDE7XG5cbiAgICAgICAgLy8gQWRkIGFsbCBzZWdtZW50IHN0YXJ0IGFuZCBlbmRwb2ludHNcbiAgICAgICAgc3RyZWFtbGluZXMuZm9yRWFjaChzdHJlYW1saW5lID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZShzdHJlYW1saW5lW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRTZWdtZW50KHRoaXMudmVjdG9yc1RvU2VnbWVudChzdHJlYW1saW5lW2kgLSAxXSwgc3RyZWFtbGluZVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgc3RyZWFtbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkU2VnbWVudCh0aGlzLnZlY3RvcnNUb1NlZ21lbnQoc3RyZWFtbGluZVtpXSwgc3RyZWFtbGluZVtpICsgMV0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZ1enp5QWRkVG9RdWFkdHJlZShxdWFkdHJlZSwgbm9kZSwgbm9kZUFkZFJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBhbGwgaW50ZXJzZWN0aW9uc1xuICAgICAgICBpbnRlcnNlY3Rpb25zLmZvckVhY2goaW50ZXJzZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZShuZXcgVmVjdG9yKGludGVyc2VjdGlvbi5wb2ludC54LCBpbnRlcnNlY3Rpb24ucG9pbnQueSkpO1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uLnNlZ21lbnRzLmZvckVhY2gocyA9PiBub2RlLmFkZFNlZ21lbnQocykpO1xuICAgICAgICAgICAgdGhpcy5mdXp6eUFkZFRvUXVhZHRyZWUocXVhZHRyZWUsIG5vZGUsIG5vZGVBZGRSYWRpdXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGb3IgZWFjaCBzaW1wbGlmaWVkIHN0cmVhbWxpbmUsIGJ1aWxkIGxpc3Qgb2Ygbm9kZXMgaW4gb3JkZXIgYWxvbmcgc3RyZWFtbGluZVxuICAgICAgICBzdHJlYW1saW5lcy5mb3JFYWNoKHN0cmVhbWxpbmUgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJlYW1saW5lLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzQWxvbmdTZWdtZW50ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXROb2Rlc0Fsb25nU2VnbWVudCh0aGlzLnZlY3RvcnNUb1NlZ21lbnQoc3RyZWFtbGluZVtpXSwgc3RyZWFtbGluZVtpICsgMV0pLCBxdWFkdHJlZSwgbm9kZUFkZFJhZGl1cywgZHN0ZXApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChub2Rlc0Fsb25nU2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZXNBbG9uZ1NlZ21lbnQubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc0Fsb25nU2VnbWVudFtqXS5hZGROZWlnaGJvcihub2Rlc0Fsb25nU2VnbWVudFtqKzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIkVycm9yIEdyYXBoLmpzOiBzZWdtZW50IHdpdGggbGVzcyB0aGFuIDIgbm9kZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm5vZGVzID0gcXVhZHRyZWUuZGF0YSgpO1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gobiA9PiBuLmFkaiA9IEFycmF5LmZyb20obi5uZWlnaGJvcnMpKTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0aW9ucy5tYXAoaSA9PiBuZXcgVmVjdG9yKGkucG9pbnQueCwgaS5wb2ludC55KSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXROb2Rlc0Fsb25nU2VnbWVudChzZWdtZW50OiBTZWdtZW50LCBxdWFkdHJlZTogZDMuUXVhZHRyZWU8Tm9kZT4sIHJhZGl1czogbnVtYmVyLCBzdGVwOiBudW1iZXIpOiBOb2RlW10ge1xuICAgICAgICAvLyBXYWxrIGRzdGVwIGFsb25nIGVhY2ggc3RyZWFtbGluZSwgYWRkaW5nIG5vZGVzIHdpdGhpbiBkc3RlcC8yXG4gICAgICAgIC8vIGFuZCBjb25uZWN0ZWQgdG8gdGhpcyBzdHJlYW1saW5lIChmdXp6eSAtIG5vZGVBZGRSYWRpdXMpIHRvIGxpc3QsIHJlbW92aW5nIGZyb21cbiAgICAgICAgLy8gcXVhZHRyZWUgYW5kIGFkZGluZyB0aGVtIGFsbCBiYWNrIGF0IHRoZSBlbmRcblxuICAgICAgICBjb25zdCBmb3VuZE5vZGVzID0gW107XG4gICAgICAgIGNvbnN0IG5vZGVzQWxvbmdTZWdtZW50OiBOb2RlW10gPSBbXTtcblxuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBWZWN0b3Ioc2VnbWVudC5mcm9tLngsIHNlZ21lbnQuZnJvbS55KTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IFZlY3RvcihzZWdtZW50LnRvLngsIHNlZ21lbnQudG8ueSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkaWZmZXJlbmNlVmVjdG9yID0gZW5kLmNsb25lKCkuc3ViKHN0YXJ0KTtcbiAgICAgICAgc3RlcCA9IE1hdGgubWluKHN0ZXAsIGRpZmZlcmVuY2VWZWN0b3IubGVuZ3RoKCkgLyAyKTsgIC8vIE1pbiBvZiAyIHN0ZXAgYWxvbmcgdmVjdG9yXG4gICAgICAgIGNvbnN0IHN0ZXBzID0gTWF0aC5jZWlsKGRpZmZlcmVuY2VWZWN0b3IubGVuZ3RoKCkgLyBzdGVwKTtcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZVZlY3Rvckxlbmd0aCA9IGRpZmZlcmVuY2VWZWN0b3IubGVuZ3RoKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc3RlcHM7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRQb2ludCA9IHN0YXJ0LmNsb25lKCkuYWRkKGRpZmZlcmVuY2VWZWN0b3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihpIC8gc3RlcHMpKTtcblxuICAgICAgICAgICAgLy8gT3JkZXIgbm9kZXMsIG5vdCBieSAnY2xvc2VuZXNzJywgYnV0IGJ5IGRvdCBwcm9kdWN0XG4gICAgICAgICAgICBsZXQgbm9kZXNUb0FkZCA9IFtdO1xuICAgICAgICAgICAgbGV0IGNsb3Nlc3ROb2RlID0gcXVhZHRyZWUuZmluZChjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnksIHJhZGl1cyArIHN0ZXAvMik7XG5cbiAgICAgICAgICAgIHdoaWxlIChjbG9zZXN0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVhZHRyZWUucmVtb3ZlKGNsb3Nlc3ROb2RlKTtcbiAgICAgICAgICAgICAgICBmb3VuZE5vZGVzLnB1c2goY2xvc2VzdE5vZGUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBub2RlT25TZWdtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcyBvZiBjbG9zZXN0Tm9kZS5zZWdtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mdXp6eVNlZ21lbnRzRXF1YWwocywgc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVPblNlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZU9uU2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvQWRkLnB1c2goY2xvc2VzdE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsb3Nlc3ROb2RlID0gcXVhZHRyZWUuZmluZChjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnksIHJhZGl1cyArIHN0ZXAvMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGVzVG9BZGQuc29ydCgoZmlyc3Q6IE5vZGUsIHNlY29uZDogTm9kZSkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmRvdFByb2R1Y3RUb1NlZ21lbnQoZmlyc3QsIHN0YXJ0LCBkaWZmZXJlbmNlVmVjdG9yKSAtIHRoaXMuZG90UHJvZHVjdFRvU2VnbWVudChzZWNvbmQsIHN0YXJ0LCBkaWZmZXJlbmNlVmVjdG9yKSk7XG4gICAgICAgICAgICBub2Rlc1RvQWRkLmZvckVhY2gobiA9PiBub2Rlc0Fsb25nU2VnbWVudC5wdXNoKG4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1YWR0cmVlLmFkZEFsbChmb3VuZE5vZGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzQWxvbmdTZWdtZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgZnV6enlTZWdtZW50c0VxdWFsKHMxOiBTZWdtZW50LCBzMjogU2VnbWVudCwgdG9sZXJhbmNlPTAuMDAwMSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBGcm9tXG4gICAgICAgIGlmIChzMS5mcm9tLnggLSBzMi5mcm9tLnggPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzMS5mcm9tLnkgLSBzMi5mcm9tLnkgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvXG5cbiAgICAgICAgaWYgKHMxLnRvLnggLSBzMi50by54ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoczEudG8ueSAtIHMyLnRvLnkgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZG90UHJvZHVjdFRvU2VnbWVudChub2RlOiBOb2RlLCBzdGFydDogVmVjdG9yLCBkaWZmZXJlbmNlVmVjdG9yOiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkb3RWZWN0b3IgPSBub2RlLnZhbHVlLmNsb25lKCkuc3ViKHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIGRpZmZlcmVuY2VWZWN0b3IuZG90KGRvdFZlY3Rvcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmdXp6eUFkZFRvUXVhZHRyZWUocXVhZHRyZWU6IGQzLlF1YWR0cmVlPE5vZGU+LCBub2RlOiBOb2RlLCByYWRpdXM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBPbmx5IGFkZCBpZiB0aGVyZSBpc24ndCBhIG5vZGUgd2l0aGluIHJhZGl1c1xuICAgICAgICAvLyBSZW1lbWJlciB0byBjaGVjayBmb3IgZG91YmxlIHJhZGl1cyB3aGVuIHF1ZXJ5aW5nIHRyZWUsIG9yIHBvaW50IG1pZ2h0IGJlIG1pc3NlZFxuICAgICAgICBjb25zdCBleGlzdGluZ05vZGUgPSBxdWFkdHJlZS5maW5kKG5vZGUudmFsdWUueCwgbm9kZS52YWx1ZS55LCByYWRpdXMpO1xuICAgICAgICBpZiAoZXhpc3RpbmdOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHF1YWR0cmVlLmFkZChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUubmVpZ2hib3JzLmZvckVhY2gobmVpZ2hib3IgPT4gZXhpc3RpbmdOb2RlLmFkZE5laWdoYm9yKG5laWdoYm9yKSk7XG4gICAgICAgICAgICBub2RlLnNlZ21lbnRzLmZvckVhY2goc2VnbWVudCA9PiBleGlzdGluZ05vZGUuYWRkU2VnbWVudChzZWdtZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0cmVhbWxpbmVzVG9TZWdtZW50KHN0cmVhbWxpbmVzOiBWZWN0b3JbXVtdKTogU2VnbWVudFtdIHtcbiAgICAgICAgY29uc3Qgb3V0OiBTZWdtZW50W10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHN0cmVhbWxpbmVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2godGhpcy52ZWN0b3JzVG9TZWdtZW50KHNbaV0sIHNbaSArIDFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgdmVjdG9yc1RvU2VnbWVudCh2MTogVmVjdG9yLCB2MjogVmVjdG9yKTogU2VnbWVudCB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiB2MSxcbiAgICAgICAgICAgIHRvOiAgIHYyXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JpZFN0b3JhZ2Uge1xuXG4gICAgcHJpdmF0ZSBncmlkRGltZW5zaW9uczogVmVjdG9yO1xuICAgIHByaXZhdGUgZ3JpZDogVmVjdG9yW11bXVtdO1xuICAgIHByaXZhdGUgZHNlcFNxOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiB3b3JsZERpbWVuc2lvbnMgYXNzdW1lcyBvcmlnaW4gb2YgMCwwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRzZXAgU2VwYXJhdGlvbiBkaXN0YW5jZSBiZXR3ZWVuIHNhbXBsZXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciAocHJpdmF0ZSB3b3JsZERpbWVuc2lvbnM6IFZlY3RvciwgcHJpdmF0ZSBvcmlnaW46IFZlY3RvciwgcHJpdmF0ZSBkc2VwOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5kc2VwU3EgPSB0aGlzLmRzZXAgKiB0aGlzLmRzZXA7XG4gICAgICAgIHRoaXMuZ3JpZERpbWVuc2lvbnMgPSB3b3JsZERpbWVuc2lvbnMuY2xvbmUoKS5kaXZpZGVTY2FsYXIodGhpcy5kc2VwKTtcbiAgICAgICAgdGhpcy5ncmlkID0gW107XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5ncmlkRGltZW5zaW9ucy54OyB4KyspIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5wdXNoKFtdKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5ncmlkRGltZW5zaW9ucy55OyB5KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbeF0ucHVzaChbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYWxsIHNhbXBsZXMgZnJvbSBhbm90aGVyIGdyaWQgdG8gdGhpcyBvbmVcbiAgICAgKi9cbiAgICBhZGRBbGwoZ3JpZFN0b3JhZ2U6IEdyaWRTdG9yYWdlKTogdm9pZCB7XG4gICAgICAgIGdyaWRTdG9yYWdlLmdyaWQuZm9yRWFjaChyb3cgPT4gcm93LmZvckVhY2goY2VsbCA9PiBjZWxsLmZvckVhY2goc2FtcGxlID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2FtcGxlKHNhbXBsZSk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuXG4gICAgYWRkUG9seWxpbmUobGluZTogVmVjdG9yW10pOiB2b2lkIHtcbiAgICAgICAgbGluZS5mb3JFYWNoKHYgPT4gdGhpcy5hZGRTYW1wbGUodikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZm9yY2Ugc2VwYXJhdGlvblxuICAgICAqIERvZXMgbm90IGNsb25lXG4gICAgICovXG4gICAgYWRkU2FtcGxlKHY6IFZlY3RvciwgY29vcmRzPzogVmVjdG9yKTogdm9pZCB7XG4gICAgICAgIGlmICghY29vcmRzKSB7XG4gICAgICAgICAgICBjb29yZHMgPSB0aGlzLmdldFNhbXBsZUNvb3Jkcyh2KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyaWRbY29vcmRzLnhdW2Nvb3Jkcy55XS5wdXNoKHYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgdiBpcyBhdCBsZWFzdCBkIGF3YXkgZnJvbSBzYW1wbGVzXG4gICAgICogUGVyZm9ybWFuY2UgdmVyeSBpbXBvcnRhbnQgLSB0aGlzIGlzIGNhbGxlZCBhdCBldmVyeSBpbnRlZ3JhdGlvbiBzdGVwXG4gICAgICogQHBhcmFtIGRTcT10aGlzLmRzZXBTcSBzcXVhcmVkIHRlc3QgZGlzdGFuY2VcbiAgICAgKiBDb3VsZCBiZSBkdGVzdCBpZiB3ZSBhcmUgaW50ZWdyYXRpbmcgYSBzdHJlYW1saW5lXG4gICAgICovXG4gICAgaXNWYWxpZFNhbXBsZSh2OiBWZWN0b3IsIGRTcT10aGlzLmRzZXBTcSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBDb2RlIGR1cGxpY2F0aW9uIHdpdGggdGhpcy5nZXROZWFyYnlQb2ludHMgYnV0IG11Y2ggc2xvd2VyIHdoZW4gY2FsbGluZ1xuICAgICAgICAvLyB0aGlzLmdldE5lYXJieVBvaW50cyBkdWUgdG8gYXJyYXkgY3JlYXRpb24gaW4gdGhhdCBtZXRob2RcblxuICAgICAgICBjb25zdCBjb29yZHMgPSB0aGlzLmdldFNhbXBsZUNvb3Jkcyh2KTtcblxuICAgICAgICAvLyBDaGVjayBzYW1wbGVzIGluIDkgY2VsbHMgaW4gM3gzIGdyaWRcbiAgICAgICAgZm9yIChsZXQgeCA9IC0xOyB4IDw9IDE7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IC0xOyB5IDw9IDE7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjb29yZHMuY2xvbmUoKS5hZGQobmV3IFZlY3Rvcih4LCB5KSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZlY3Rvck91dE9mQm91bmRzKGNlbGwsIHRoaXMuZ3JpZERpbWVuc2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy52ZWN0b3JGYXJGcm9tVmVjdG9ycyh2LCB0aGlzLmdyaWRbY2VsbC54XVtjZWxsLnldLCBkU3EpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIHYgaXMgYXQgbGVhc3QgZCBhd2F5IGZyb20gdmVjdG9yc1xuICAgICAqIFBlcmZvcm1hbmNlIHZlcnkgaW1wb3J0YW50IC0gdGhpcyBpcyBjYWxsZWQgYXQgZXZlcnkgaW50ZWdyYXRpb24gc3RlcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgIGRTcSAgICAgc3F1YXJlZCB0ZXN0IGRpc3RhbmNlXG4gICAgICovXG4gICAgdmVjdG9yRmFyRnJvbVZlY3RvcnModjogVmVjdG9yLCB2ZWN0b3JzOiBWZWN0b3JbXSwgZFNxOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgdmVjdG9ycykge1xuICAgICAgICAgICAgaWYgKHNhbXBsZSAhPT0gdikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlU3EgPSBzYW1wbGUuZGlzdGFuY2VUb1NxdWFyZWQodik7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPCBkU3EpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcG9pbnRzIGluIGNlbGxzIHN1cnJvdW5kaW5nIHZcbiAgICAgKiBSZXN1bHRzIGluY2x1ZGUgdiwgaWYgaXQgZXhpc3RzIGluIHRoZSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJldHVybnMgc2FtcGxlcyAoa2luZCBvZikgY2xvc2VyIHRoYW4gZGlzdGFuY2UgLSByZXR1cm5zIGFsbCBzYW1wbGVzIGluIFxuICAgICAqIGNlbGxzIHNvIGFwcHJveGltYXRpb24gKHNxdWFyZSB0byBhcHByb3hpbWF0ZSBjaXJjbGUpXG4gICAgICovXG4gICAgZ2V0TmVhcmJ5UG9pbnRzKHY6IFZlY3RvciwgZGlzdGFuY2U6IG51bWJlcik6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5jZWlsKChkaXN0YW5jZS90aGlzLmRzZXApIC0gMC41KTtcbiAgICAgICAgY29uc3QgY29vcmRzID0gdGhpcy5nZXRTYW1wbGVDb29yZHModik7XG4gICAgICAgIGNvbnN0IG91dDogVmVjdG9yW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IC0xICogcmFkaXVzOyB4IDw9IDEgKiByYWRpdXM7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IC0xICogcmFkaXVzOyB5IDw9IDEgKiByYWRpdXM7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjb29yZHMuY2xvbmUoKS5hZGQobmV3IFZlY3Rvcih4LCB5KSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZlY3Rvck91dE9mQm91bmRzKGNlbGwsIHRoaXMuZ3JpZERpbWVuc2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtjZWxsLnhdW2NlbGwueV0uZm9yRWFjaCh2MiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh2Mik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB3b3JsZFRvR3JpZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5jbG9uZSgpLnN1Yih0aGlzLm9yaWdpbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBncmlkVG9Xb3JsZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5jbG9uZSgpLmFkZCh0aGlzLm9yaWdpbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2ZWN0b3JPdXRPZkJvdW5kcyhncmlkVjogVmVjdG9yLCBib3VuZHM6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGdyaWRWLnggPCAwIHx8IGdyaWRWLnkgPCAwIHx8XG4gICAgICAgICAgICBncmlkVi54ID49IGJvdW5kcy54IHx8IGdyaWRWLnkgPj0gYm91bmRzLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gICBDZWxsIGNvb3JkcyBjb3JyZXNwb25kaW5nIHRvIHZlY3RvclxuICAgICAqIFBlcmZvcm1hbmNlIGltcG9ydGFudCAtIGNhbGxlZCBhdCBldmVyeSBpbnRlZ3JhdGlvbiBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTYW1wbGVDb29yZHMod29ybGRWOiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCB2ID0gdGhpcy53b3JsZFRvR3JpZCh3b3JsZFYpO1xuICAgICAgICBpZiAodGhpcy52ZWN0b3JPdXRPZkJvdW5kcyh2LCB0aGlzLndvcmxkRGltZW5zaW9ucykpIHtcbiAgICAgICAgICAgIC8vIGxvZy5lcnJvcihcIlRyaWVkIHRvIGFjY2VzcyBvdXQtb2YtYm91bmRzIHNhbXBsZSBpbiBncmlkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFZlY3Rvci56ZXJvVmVjdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihcbiAgICAgICAgICAgIE1hdGguZmxvb3Iodi54IC8gdGhpcy5kc2VwKSxcbiAgICAgICAgICAgIE1hdGguZmxvb3Iodi55IC8gdGhpcy5kc2VwKVxuICAgICAgICApO1xuICAgIH1cbn1cbiIsImltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4vc3RyZWFtbGluZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBGaWVsZEludGVncmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBmaWVsZDogVGVuc29yRmllbGQpIHt9XG5cbiAgICBhYnN0cmFjdCBpbnRlZ3JhdGUocG9pbnQ6IFZlY3RvciwgbWFqb3I6IGJvb2xlYW4pOiBWZWN0b3I7XG5cbiAgICBwcm90ZWN0ZWQgc2FtcGxlRmllbGRWZWN0b3IocG9pbnQ6IFZlY3RvciwgbWFqb3I6IGJvb2xlYW4pOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCB0ZW5zb3IgPSB0aGlzLmZpZWxkLnNhbXBsZVBvaW50KHBvaW50KTtcbiAgICAgICAgaWYgKG1ham9yKSByZXR1cm4gdGVuc29yLmdldE1ham9yKCk7XG4gICAgICAgIHJldHVybiB0ZW5zb3IuZ2V0TWlub3IoKTtcbiAgICB9XG5cbiAgICBvbkxhbmQocG9pbnQ6IFZlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5vbkxhbmQocG9pbnQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEV1bGVySW50ZWdyYXRvciBleHRlbmRzIEZpZWxkSW50ZWdyYXRvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBzdXBlcihmaWVsZCk7XG4gICAgfVxuXG4gICAgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQsIG1ham9yKS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5kc3RlcCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUks0SW50ZWdyYXRvciBleHRlbmRzIEZpZWxkSW50ZWdyYXRvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBzdXBlcihmaWVsZCk7XG4gICAgfVxuXG4gICAgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yIHtcbiAgICAgICAgY29uc3QgazEgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LCBtYWpvcik7XG4gICAgICAgIGNvbnN0IGsyMyA9IHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQuY2xvbmUoKS5hZGQoVmVjdG9yLmZyb21TY2FsYXIodGhpcy5wYXJhbXMuZHN0ZXAgLyAyKSksIG1ham9yKTtcbiAgICAgICAgY29uc3QgazQgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LmNsb25lKCkuYWRkKFZlY3Rvci5mcm9tU2NhbGFyKHRoaXMucGFyYW1zLmRzdGVwKSksIG1ham9yKTtcblxuICAgICAgICByZXR1cm4gazEuYWRkKGsyMy5tdWx0aXBseVNjYWxhcig0KSkuYWRkKGs0KS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5kc3RlcCAvIDYpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBQb2x5SyBmcm9tICdwb2x5ayc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge05vZGV9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0ICogYXMganN0cyBmcm9tICdqc3RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvbkZpbmRlciB7XG4gICAgcHJpdmF0ZSBfcG9seWdvbnM6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwcml2YXRlIF9zaHJ1bmtQb2x5Z29uczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHByaXZhdGUgX2RpdmlkZWRQb2x5Z29uczogVmVjdG9yW11bXSA9IFtdO1xuXG4gICAgcHJpdmF0ZSBqc3RzUG9seWdvbnM6IGpzdHMuZ2VvbS5Qb2x5Z29uW10gPSBbXTtcbiAgICBwcml2YXRlIGdlb21ldHJ5RmFjdG9yeSA9IG5ldyBqc3RzLmdlb20uR2VvbWV0cnlGYWN0b3J5KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5vZGVzOiBOb2RlW10sIHByaXZhdGUgbWF4TGVuZ3RoPTIwKSB7fVxuXG4gICAgZ2V0IHBvbHlnb25zKCk6IFZlY3RvcltdW10ge1xuICAgICAgICBpZiAodGhpcy5fZGl2aWRlZFBvbHlnb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXZpZGVkUG9seWdvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2hydW5rUG9seWdvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NocnVua1BvbHlnb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zO1xuICAgIH1cblxuICAgIHNocmluayhzcGFjaW5nID0gMik6IHZvaWQge1xuICAgICAgICAvLyB0aGlzLnBvbHlnb25zID0gdGhpcy5wb2x5Z29ucy5tYXAocCA9PiB0aGlzLnNocmlua1BvbHlnb24ocCwgdGhpcy5zaHJpbmtBbW91bnQpKVxuICAgICAgICBpZiAodGhpcy5fcG9seWdvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2x5Z29ucygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9zaHJ1bmtQb2x5Z29ucyA9IHRoaXMuanN0c1BvbHlnb25zLm1hcChwID0+IHRoaXMucmVzaXplUG9seWdvbihwLCAtc3BhY2luZykpXG4gICAgICAgICAgICAuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcbiAgICB9XG5cbiAgICBkaXZpZGUobWluQXJlYSA9IDIwKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9wb2x5Z29ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvbHlnb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcG9seWdvbnMgPSB0aGlzLl9wb2x5Z29ucztcbiAgICAgICAgaWYgKHRoaXMuX3NocnVua1BvbHlnb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBvbHlnb25zID0gdGhpcy5fc2hydW5rUG9seWdvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGl2aWRlZDogVmVjdG9yW11bXSA9IFtdO1xuICAgICAgICBwb2x5Z29ucy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgZGl2aWRlZCA9IGRpdmlkZWQuY29uY2F0KHRoaXMuc3ViZGl2aWRlUG9seWdvbihwLCBtaW5BcmVhKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMgPSBkaXZpZGVkLmZpbHRlcihwID0+IFBvbHlnb25GaW5kZXIuY2FsY1BvbHlnb25BcmVhKHApID4gbWluQXJlYSAqIDAuNCk7XG4gICAgfVxuXG4gICAgZmluZFBvbHlnb25zKCk6IHZvaWQge1xuICAgICAgICAvLyBOb2RlXG4gICAgICAgIC8vIHgsIHksIHZhbHVlIChWZWN0b3IyKSwgYWRqIChsaXN0IG9mIG5vZGUgcmVmcylcbiAgICAgICAgLy8gR29ubmEgZWRpdCBhZGogZm9yIG5vd1xuXG4gICAgICAgIC8vIFdhbGsgYSBjbG9ja3dpc2UgcGF0aCB1bnRpbCBwb2x5Z29uIGZvdW5kIG9yIGxpbWl0IHJlYWNoZWRcbiAgICAgICAgLy8gV2hlbiB3ZSBmaW5kIGEgcG9seWdvbiwgbWFyayBhbGwgZWRnZXMgYXMgdHJhdmVyc2VkIChpbiBwYXJ0aWN1bGFyIGRpcmVjdGlvbilcbiAgICAgICAgLy8gRWFjaCBlZGdlIHNlcGFyYXRlcyB0d28gcG9seWdvbnNcbiAgICAgICAgLy8gSWYgZWRnZSBhbHJlYWR5IHRyYXZlcnNlZCBpbiB0aGlzIGRpcmVjdGlvbiwgdGhpcyBwb2x5Z29uIGhhcyBhbHJlYWR5IGJlZW4gZm91bmRcbiAgICAgICAgdGhpcy5fc2hydW5rUG9seWdvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fZGl2aWRlZFBvbHlnb25zID0gW107XG4gICAgICAgIGNvbnN0IHBvbHlnb25zID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5hZGoubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IG5leHROb2RlIG9mIG5vZGUuYWRqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9seWdvbiA9IHRoaXMucmVjdXJzaXZlV2Fsayhbbm9kZSwgbmV4dE5vZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVBvbHlnb25BZGphY2VuY2llcyhwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uLm1hcChuID0+IG4udmFsdWUuY2xvbmUoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BvbHlnb25zID0gcG9seWdvbnM7XG4gICAgICAgIHRoaXMuanN0c1BvbHlnb25zID0gcG9seWdvbnMubWFwKHAgPT4gdGhpcy5wb2x5Z29uVG9KdHMocCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVtb3ZlUG9seWdvbkFkamFjZW5jaWVzKHBvbHlnb246IE5vZGVbXSk6IHZvaWQge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwb2x5Z29uW2ldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHBvbHlnb25bKGkgKyAxKSAlIHBvbHlnb24ubGVuZ3RoXTtcblxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyZW50LmFkai5pbmRleE9mKG5leHQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmFkai5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJQb2x5Z29uRmluZGVyIC0gbm9kZSBub3QgaW4gYWRqXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZWN1cnNpdmVXYWxrKHZpc2l0ZWQ6IE5vZGVbXSwgY291bnQ9MCk6IE5vZGVbXSB7XG4gICAgICAgIGlmIChjb3VudCA+PSB0aGlzLm1heExlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIFRPRE8gYmFja3RyYWNraW5nIHRvIGZpbmQgcG9seWdvbnMgd2l0aCBkZWFkIGVuZCByb2FkcyBpbnNpZGUgdGhlbVxuICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMuZ2V0UmlnaHRtb3N0Tm9kZSh2aXNpdGVkW3Zpc2l0ZWQubGVuZ3RoIC0gMl0sIHZpc2l0ZWRbdmlzaXRlZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChuZXh0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7ICAvLyBDdXJyZW50bHkgaWdub3JlcyBwb2x5Z29ucyB3aXRoIGRlYWQgZW5kIGluc2lkZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmlzaXRlZEluZGV4ID0gdmlzaXRlZC5pbmRleE9mKG5leHROb2RlKTtcbiAgICAgICAgaWYgKHZpc2l0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRlZC5zbGljZSh2aXNpdGVkSW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaXRlZC5wdXNoKG5leHROb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVdhbGsodmlzaXRlZCwgY291bnQrKyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFJpZ2h0bW9zdE5vZGUobm9kZUZyb206IE5vZGUsIG5vZGVUbzogTm9kZSk6IE5vZGUge1xuICAgICAgICAvLyBXZSB3YW50IHRvIHR1cm4gcmlnaHQgYXQgZXZlcnkganVuY3Rpb25cbiAgICAgICAgaWYgKG5vZGVUby5hZGoubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBiYWNrd2FyZHNEaWZmZXJlbmNlVmVjdG9yID0gbm9kZUZyb20udmFsdWUuY2xvbmUoKS5zdWIobm9kZVRvLnZhbHVlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtQW5nbGUgPSBNYXRoLmF0YW4yKGJhY2t3YXJkc0RpZmZlcmVuY2VWZWN0b3IueSwgYmFja3dhcmRzRGlmZmVyZW5jZVZlY3Rvci54KTtcblxuICAgICAgICBsZXQgcmlnaHRtb3N0Tm9kZSA9IG51bGw7XG4gICAgICAgIGxldCBzbWFsbGVzdFRoZXRhID0gTWF0aC5QSSAqIDI7XG5cbiAgICAgICAgZm9yIChsZXQgbmV4dE5vZGUgb2Ygbm9kZVRvLmFkaikge1xuICAgICAgICAgICAgaWYgKG5leHROb2RlICE9PSBub2RlRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWZWN0b3IgPSBuZXh0Tm9kZS52YWx1ZS5jbG9uZSgpLnN1Yihub2RlVG8udmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0QW5nbGUgPSBNYXRoLmF0YW4yKG5leHRWZWN0b3IueSwgbmV4dFZlY3Rvci54KSAtIHRyYW5zZm9ybUFuZ2xlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0QW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRBbmdsZSArPSBNYXRoLlBJICogMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dEFuZ2xlIDwgc21hbGxlc3RUaGV0YSkge1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdFRoZXRhID0gbmV4dEFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICByaWdodG1vc3ROb2RlID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJpZ2h0bW9zdE5vZGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaHJpbmtQb2x5Z29uKHBvbHlnb246IFZlY3RvcltdLCBhbW91bnQ6IG51bWJlcik6IFZlY3RvcltdIHtcbiAgICAgICAgLy8gUmV0dXJucyBjbG9uZVxuICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhdmVyYWdlUG9pbnQgPSBwb2x5Z29uWzBdLmNsb25lKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXZlcmFnZVBvaW50LmFkZChwb2x5Z29uW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF2ZXJhZ2VQb2ludC5tdWx0aXBseVNjYWxhcigxIC8gcG9seWdvbi5sZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBwb2x5Z29uLm1hcCh2ID0+IHYuY2xvbmUoKS5zdWIoYXZlcmFnZVBvaW50KS5tdWx0aXBseVNjYWxhcihhbW91bnQpLmFkZChhdmVyYWdlUG9pbnQpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBvbHlnb25Ub0p0cyhwb2x5Z29uOiBWZWN0b3JbXSk6IGpzdHMuZ2VvbS5Qb2x5Z29uIHtcbiAgICAgICAgY29uc3QgZ2VvSW5wdXQgPSBwb2x5Z29uLm1hcCh2ID0+IG5ldyBqc3RzLmdlb20uQ29vcmRpbmF0ZSh2LngsIHYueSkpO1xuICAgICAgICBnZW9JbnB1dC5wdXNoKGdlb0lucHV0WzBdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24odGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhnZW9JbnB1dCksIFtdKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc2l6ZVBvbHlnb24ocG9seWdvbjoganN0cy5nZW9tLlBvbHlnb24sIHNwYWNpbmc6IG51bWJlcik6IFZlY3RvcltdIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZWQgPSBwb2x5Z29uLmJ1ZmZlcihzcGFjaW5nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoIXJlc2l6ZWQuaXNTaW1wbGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNpemVkLmdldENvb3JkaW5hdGVzKCkubWFwKGMgPT4gbmV3IFZlY3RvcihjLngsIGMueSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3ViZGl2aWRlUG9seWdvbihwOiBWZWN0b3JbXSwgbWluQXJlYTogbnVtYmVyKTogVmVjdG9yW11bXSB7XG4gICAgICAgIGlmIChQb2x5Z29uRmluZGVyLmNhbGNQb2x5Z29uQXJlYShwKSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiBbcF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGl2aWRlZDogVmVjdG9yW11bXSA9IFtdOyAgLy8gQXJyYXkgb2YgcG9seWdvbnNcblxuICAgICAgICBsZXQgbG9uZ2VzdFNpZGVMZW5ndGggPSAwO1xuICAgICAgICBsZXQgbG9uZ2VzdFNpZGUgPSBbcFswXSwgcFsxXV07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWRlTGVuZ3RoID0gcFtpXS5jbG9uZSgpLnN1YihwWyhpKzEpICUgcC5sZW5ndGhdKS5sZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChzaWRlTGVuZ3RoID4gbG9uZ2VzdFNpZGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb25nZXN0U2lkZUxlbmd0aCA9IHNpZGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgbG9uZ2VzdFNpZGUgPSBbcFtpXSwgcFsoaSsxKSAlIHAubGVuZ3RoXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZXR3ZWVuIDAuNCBhbmQgMC42XG4gICAgICAgIGNvbnN0IGRldmlhdGlvbiA9IChNYXRoLnJhbmRvbSgpICogMC4yKSArIDAuNDtcblxuICAgICAgICBjb25zdCBhdmVyYWdlUG9pbnQgPSBsb25nZXN0U2lkZVswXS5jbG9uZSgpLmFkZChsb25nZXN0U2lkZVsxXSkubXVsdGlwbHlTY2FsYXIoZGV2aWF0aW9uKTtcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZVZlY3RvciA9IGxvbmdlc3RTaWRlWzBdLmNsb25lKCkuc3ViKGxvbmdlc3RTaWRlWzFdKTtcbiAgICAgICAgY29uc3QgcGVycFZlY3RvciA9IChuZXcgVmVjdG9yKGRpZmZlcmVuY2VWZWN0b3IueSwgLTEgKiBkaWZmZXJlbmNlVmVjdG9yLngpKVxuICAgICAgICAgICAgLm5vcm1hbGl6ZSgpXG4gICAgICAgICAgICAubXVsdGlwbHlTY2FsYXIoMTAwKTtcblxuICAgICAgICBjb25zdCBiaXNlY3QgPSBbYXZlcmFnZVBvaW50LmNsb25lKCkuYWRkKHBlcnBWZWN0b3IpLCBhdmVyYWdlUG9pbnQuY2xvbmUoKS5zdWIocGVycFZlY3RvcildO1xuXG4gICAgICAgIC8vIEFycmF5IG9mIHBvbHlnb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZWQgPSBQb2x5Sy5TbGljZShQb2x5Z29uRmluZGVyLnBvbHlnb25Ub1BvbHlnb25BcnJheShwKSwgYmlzZWN0WzBdLngsIGJpc2VjdFswXS55LCBiaXNlY3RbMV0ueCwgYmlzZWN0WzFdLnkpO1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlIGNhbGxcbiAgICAgICAgICAgIHNsaWNlZC5mb3JFYWNoKHMgPT4ge1xuICAgICAgICAgICAgICAgIGRpdmlkZWQgPSBkaXZpZGVkLmNvbmNhdCh0aGlzLnN1YmRpdmlkZVBvbHlnb24oUG9seWdvbkZpbmRlci5wb2x5Z29uQXJyYXlUb1BvbHlnb24ocyksIG1pbkFyZWEpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGl2aWRlZDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY3JlYXRlIHNlYSBwb2x5Z29uXG4gICAgICogUmV0dXJucyBsYXJnZXN0IHBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHNsaWNlUmVjdGFuZ2xlKG9yaWdpbjogVmVjdG9yLCB3b3JsZERpbWVuc2lvbnM6IFZlY3RvciwgcDE6IFZlY3RvciwgcDI6IFZlY3Rvcik6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3QgcmVjdGFuZ2xlID0gW1xuICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55LFxuICAgICAgICAgICAgb3JpZ2luLnggKyB3b3JsZERpbWVuc2lvbnMueCwgb3JpZ2luLnksXG4gICAgICAgICAgICBvcmlnaW4ueCArIHdvcmxkRGltZW5zaW9ucy54LCBvcmlnaW4ueSArIHdvcmxkRGltZW5zaW9ucy55LFxuICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55ICsgd29ybGREaW1lbnNpb25zLnksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHNsaWNlZCA9IFBvbHlLLlNsaWNlKHJlY3RhbmdsZSwgcDEueCwgcDEueSwgcDIueCwgcDIueSkubWFwKHAgPT4gdGhpcy5wb2x5Z29uQXJyYXlUb1BvbHlnb24ocCkpO1xuICAgICAgICBjb25zdCBtaW5BcmVhID0gUG9seWdvbkZpbmRlci5jYWxjUG9seWdvbkFyZWEoc2xpY2VkWzBdKTtcbiAgICAgICAgaWYgKHNsaWNlZC5sZW5ndGggPiAxICYmIFBvbHlnb25GaW5kZXIuY2FsY1BvbHlnb25BcmVhKHNsaWNlZFsxXSkgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICByZXR1cm4gc2xpY2VkWzFdO1xuICAgICAgICB9IFxuICAgICAgICByZXR1cm4gc2xpY2VkWzBdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHBvbHlnb25Ub1BvbHlnb25BcnJheShwOiBWZWN0b3JbXSk6IG51bWJlcltdIHtcbiAgICAgICAgY29uc3Qgb3V0UDogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgcC5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgICAgb3V0UC5wdXNoKHYueCk7XG4gICAgICAgICAgICBvdXRQLnB1c2godi55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRQO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHBvbHlnb25BcnJheVRvUG9seWdvbihwOiBudW1iZXJbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3Qgb3V0UCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRQLnB1c2gobmV3IFZlY3RvcihwWzIqaV0sIHBbMippICsgMV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0UDtcbiAgICB9XG5cbiAgICAvLyBwcml2YXRlIGlzVmFsaWRQb2x5Z29uKHA6IFZlY3RvcltdKTogYm9vbGVhbiB7XG4gICAgLy8gICAgIGlmIChwLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gICAgIGNvbnN0IGFyZWEgPSBQb2x5Z29uRmluZGVyLmNhbGNQb2x5Z29uQXJlYShwKTtcbiAgICAvLyAgICAgaWYgKGFyZWEgPCB0aGlzLm1pbkFyZWEgfHwgYXJlYSA+IDEwMDAwKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgIC8vIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNhbGNQb2x5Z29uQXJlYSh2ZXJ0aWNlczogVmVjdG9yW10pOiBudW1iZXIge1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgYWRkWCA9IHZlcnRpY2VzW2ldLng7XG4gICAgICAgICAgbGV0IGFkZFkgPSB2ZXJ0aWNlc1tpID09IHZlcnRpY2VzLmxlbmd0aCAtIDEgPyAwIDogaSArIDFdLnk7XG4gICAgICAgICAgbGV0IHN1YlggPSB2ZXJ0aWNlc1tpID09IHZlcnRpY2VzLmxlbmd0aCAtIDEgPyAwIDogaSArIDFdLng7XG4gICAgICAgICAgbGV0IHN1YlkgPSB2ZXJ0aWNlc1tpXS55O1xuXG4gICAgICAgICAgdG90YWwgKz0gKGFkZFggKiBhZGRZICogMC41KTtcbiAgICAgICAgICB0b3RhbCAtPSAoc3ViWCAqIHN1YlkgKiAwLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvdGFsKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0ICogYXMgc2ltcGxpZnkgZnJvbSAnc2ltcGxpZnktanMnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IEdyaWRTdG9yYWdlIGZyb20gJy4vZ3JpZF9zdG9yYWdlJztcbmltcG9ydCBGaWVsZEludGVncmF0b3IgZnJvbSAnLi9pbnRlZ3JhdG9yJztcblxuaW50ZXJmYWNlIFN0cmVhbWxpbmVJbnRlZ3JhdGlvbiB7XG4gICAgc2VlZDogVmVjdG9yLFxuICAgIG9yaWdpbmFsRGlyOiBWZWN0b3IsXG4gICAgc3RyZWFtbGluZTogVmVjdG9yW107XG4gICAgcHJldmlvdXNEaXJlY3Rpb246IFZlY3RvcjtcbiAgICBwcmV2aW91c1BvaW50OiBWZWN0b3I7XG4gICAgdmFsaWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtbGluZVBhcmFtcyB7XG4gICAgW3Byb3A6IHN0cmluZ106IG51bWJlcixcbiAgICBkc2VwOiBudW1iZXI7ICAvLyBTdHJlYW1saW5lIHNlZWQgc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgIGR0ZXN0OiBudW1iZXI7ICAvLyBTdHJlYW1saW5lIGludGVncmF0aW9uIHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICBkc3RlcDogbnVtYmVyOyAgLy8gU3RlcCBzaXplXG4gICAgZGNpcmNsZWpvaW46IG51bWJlcjsgIC8vIEhvdyBmYXIgdG8gbG9vayB0byBqb2luIGNpcmNsZXMgLSAoZS5nLiAyIHggZHN0ZXApXG4gICAgZGxvb2thaGVhZDogbnVtYmVyOyAgLy8gSG93IGZhciB0byBsb29rIGFoZWFkIHRvIGpvaW4gdXAgZGFuZ2xpbmdcbiAgICBqb2luYW5nbGU6IG51bWJlcjsgIC8vIEFuZ2xlIHRvIGpvaW4gcm9hZHMgaW4gcmFkaWFuc1xuICAgIHBhdGhJdGVyYXRpb25zOiBudW1iZXI7ICAvLyBQYXRoIGludGVncmF0aW9uIGl0ZXJhdGlvbiBsaW1pdFxuICAgIHNlZWRUcmllczogbnVtYmVyOyAgLy8gTWF4IGZhaWxlZCBzZWVkc1xuICAgIHNpbXBsaWZ5VG9sZXJhbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmVhbWxpbmVHZW5lcmF0b3Ige1xuICAgIHByaXZhdGUgcmVhZG9ubHkgU0VFRF9BVF9FTkRQT0lOVFMgPSBmYWxzZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IE5FQVJfRURHRSA9IDM7ICAvLyBTYW1wbGUgbmVhciBlZGdlXG5cbiAgICBwcml2YXRlIG1ham9yR3JpZDogR3JpZFN0b3JhZ2U7XG4gICAgcHJpdmF0ZSBtaW5vckdyaWQ6IEdyaWRTdG9yYWdlO1xuICAgIHByaXZhdGUgcGFyYW1zU3E6IFN0cmVhbWxpbmVQYXJhbXM7XG5cbiAgICAvLyBIb3cgbWFueSBzYW1wbGVzIHRvIHNraXAgd2hlbiBjaGVja2luZyBzdHJlYW1saW5lIGNvbGxpc2lvbiB3aXRoIGl0c2VsZlxuICAgIHByaXZhdGUgblN0cmVhbWxpbmVTdGVwOiBudW1iZXI7XG4gICAgLy8gSG93IG1hbnkgc2FtcGxlcyB0byBpZ25vcmUgYmFja3dhcmRzIHdoZW4gY2hlY2tpbmcgc3RyZWFtbGluZSBjb2xsaXNpb24gd2l0aCBpdHNlbGZcbiAgICBwcml2YXRlIG5TdHJlYW1saW5lTG9va0JhY2s6IG51bWJlcjtcbiAgICBwcml2YXRlIGRjb2xsaWRlc2VsZlNxOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIGNhbmRpZGF0ZVNlZWRzTWFqb3I6IFZlY3RvcltdID0gW107XG4gICAgcHJpdmF0ZSBjYW5kaWRhdGVTZWVkc01pbm9yOiBWZWN0b3JbXSA9IFtdO1xuXG4gICAgcHJpdmF0ZSBzdHJlYW1saW5lc0RvbmU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHByaXZhdGUgbGFzdFN0cmVhbWxpbmVNYWpvcjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBwdWJsaWMgc3RyZWFtbGluZXNNYWpvcjogVmVjdG9yW11bXSA9IFtdO1xuICAgIHB1YmxpYyBzdHJlYW1saW5lc01pbm9yOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHVibGljIGFsbFN0cmVhbWxpbmVzU2ltcGxlOiBWZWN0b3JbXVtdID0gW107ICAvLyBSZWR1Y2VkIHZlcnRleCBjb3VudFxuXG4gICAgLyoqXG4gICAgICogVXNlcyB3b3JsZC1zcGFjZSBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgb3JpZ2luOiBWZWN0b3IsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB3b3JsZERpbWVuc2lvbnM6IFZlY3RvcixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmRzdGVwID4gcGFyYW1zLmRzZXApIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIlNUUkVBTUxJTkUgU0FNUExFIERJU1RBTkNFIEJJR0dFUiBUSEFOIERTRVBcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmZvcmNlIHRlc3QgPCBzZXBcbiAgICAgICAgcGFyYW1zLmR0ZXN0ID0gTWF0aC5taW4ocGFyYW1zLmR0ZXN0LCBwYXJhbXMuZHNlcCk7XG5cbiAgICAgICAgLy8gTmVlZHMgdG8gYmUgbGVzcyB0aGFuIGNpcmNsZWpvaW5cbiAgICAgICAgdGhpcy5kY29sbGlkZXNlbGZTcSA9IChwYXJhbXMuZGNpcmNsZWpvaW4gLyAyKSAqKiAyO1xuICAgICAgICB0aGlzLm5TdHJlYW1saW5lU3RlcCA9IE1hdGguZmxvb3IocGFyYW1zLmRjaXJjbGVqb2luIC8gcGFyYW1zLmRzdGVwKTtcbiAgICAgICAgdGhpcy5uU3RyZWFtbGluZUxvb2tCYWNrID0gMiAqIHRoaXMublN0cmVhbWxpbmVTdGVwO1xuXG4gICAgICAgIHRoaXMubWFqb3JHcmlkID0gbmV3IEdyaWRTdG9yYWdlKHRoaXMud29ybGREaW1lbnNpb25zLCB0aGlzLm9yaWdpbiwgcGFyYW1zLmRzZXApO1xuICAgICAgICB0aGlzLm1pbm9yR3JpZCA9IG5ldyBHcmlkU3RvcmFnZSh0aGlzLndvcmxkRGltZW5zaW9ucywgdGhpcy5vcmlnaW4sIHBhcmFtcy5kc2VwKTtcblxuICAgICAgICB0aGlzLnNldFBhcmFtc1NxKCk7XG4gICAgfVxuXG4gICAgY2xlYXJTdHJlYW1saW5lcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZSA9IFtdO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzTWFqb3IgPSBbXTtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lc01pbm9yID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgc3RyZWFtbGluZXNcbiAgICAgKi9cbiAgICBqb2luRGFuZ2xpbmdTdHJlYW1saW5lcygpOiB2b2lkIHtcbiAgICAgICAgLy8gVE9ETyBkbyBpbiB1cGRhdGUgbWV0aG9kXG4gICAgICAgIGZvciAobGV0IG1ham9yIG9mIFt0cnVlLCBmYWxzZV0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHN0cmVhbWxpbmUgb2YgdGhpcy5zdHJlYW1saW5lcyhtYWpvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY2lyY2xlc1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW1saW5lWzBdLmVxdWFscyhzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gdGhpcy5nZXRCZXN0TmV4dFBvaW50KHN0cmVhbWxpbmVbMF0sIHN0cmVhbWxpbmVbNF0sIHN0cmVhbWxpbmUpXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzQmV0d2VlbihzdHJlYW1saW5lWzBdLCBuZXdTdGFydCwgdGhpcy5wYXJhbXMuZHN0ZXApLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1saW5lLnVuc2hpZnQocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFNhbXBsZShwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RW5kID0gdGhpcy5nZXRCZXN0TmV4dFBvaW50KHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXSwgc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDRdLCBzdHJlYW1saW5lKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzQmV0d2VlbihzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0sIG5ld0VuZCwgdGhpcy5wYXJhbXMuZHN0ZXApLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1saW5lLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFNhbXBsZShwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgc2ltcGxpZmllZCBzdHJlYW1saW5lc1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlID0gdGhpcy5hbGxTdHJlYW1saW5lcy5tYXAocyA9PiB0aGlzLnNpbXBsaWZ5U3RyZWFtbGluZShzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiBwb2ludHMgZnJvbSB2MSB0byB2MiBzdWNoIHRoYXQgdGhleSBhcmUgc2VwYXJhdGVkIGJ5IGF0IG1vc3QgZHNlcFxuICAgICAqIG5vdCBpbmNsdWRpbmcgdjFcbiAgICAgKi9cbiAgICBwb2ludHNCZXR3ZWVuKHYxOiBWZWN0b3IsIHYyOiBWZWN0b3IsIGRzdGVwOiBudW1iZXIpOiBWZWN0b3JbXSB7XG4gICAgICAgIGNvbnN0IGQgPSB2MS5kaXN0YW5jZVRvKHYyKTtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoZCAvIGRzdGVwKTtcbiAgICAgICAgaWYgKG5Qb2ludHMgPT09IDApIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCBzdGVwVmVjdG9yID0gdjIuY2xvbmUoKS5zdWIodjEpO1xuXG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgIGxldCBuZXh0ID0gdjEuY2xvbmUoKS5hZGQoc3RlcFZlY3Rvci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGkgLyBuUG9pbnRzKSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gblBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlZ3JhdG9yLmludGVncmF0ZShuZXh0LCB0cnVlKS5sZW5ndGhTcSgpID4gMC4wMDEpIHsgIC8vIFRlc3QgZm9yIGRlZ2VuZXJhdGUgcG9pbnRcbiAgICAgICAgICAgICAgICBvdXQucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSB2MS5jbG9uZSgpLmFkZChzdGVwVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoaSAvIG5Qb2ludHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0cyBuZXh0IGJlc3QgcG9pbnQgdG8gam9pbiBzdHJlYW1saW5lXG4gICAgICogcmV0dXJucyBudWxsIGlmIHRoZXJlIGFyZSBubyBnb29kIGNhbmRpZGF0ZXNcbiAgICAgKi9cbiAgICBnZXRCZXN0TmV4dFBvaW50KHBvaW50OiBWZWN0b3IsIHByZXZpb3VzUG9pbnQ6IFZlY3Rvciwgc3RyZWFtbGluZTogVmVjdG9yW10pOiBWZWN0b3Ige1xuICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHBvaW50cyBub3Qgb24gdGhlIGVkZ2VcbiAgICAgICAgaWYgKHBvaW50LnggPCB0aGlzLk5FQVJfRURHRSB8fCBwb2ludC54ID4gdGhpcy53b3JsZERpbWVuc2lvbnMueCAtIHRoaXMuTkVBUl9FREdFKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb2ludC55IDwgdGhpcy5ORUFSX0VER0UgfHwgcG9pbnQueSA+IHRoaXMud29ybGREaW1lbnNpb25zLnkgLSB0aGlzLk5FQVJfRURHRSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZWFyYnlQb2ludHMgPSB0aGlzLm1ham9yR3JpZC5nZXROZWFyYnlQb2ludHMocG9pbnQsIHRoaXMucGFyYW1zLmRsb29rYWhlYWQpXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMubWlub3JHcmlkLmdldE5lYXJieVBvaW50cyhwb2ludCwgdGhpcy5wYXJhbXMuZGxvb2thaGVhZCkpO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBwb2ludC5jbG9uZSgpLnN1YihwcmV2aW91c1BvaW50KTtcblxuICAgICAgICBsZXQgY2xvc2VzdFNhbXBsZSA9IG51bGw7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGxldCBzYW1wbGUgb2YgbmVhcmJ5UG9pbnRzKSB7XG4gICAgICAgICAgICBpZiAoIXNhbXBsZS5lcXVhbHMocG9pbnQpICYmICFzYW1wbGUuZXF1YWxzKHByZXZpb3VzUG9pbnQpICYmICFzdHJlYW1saW5lLmluY2x1ZGVzKHNhbXBsZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlVmVjdG9yID0gc2FtcGxlLmNsb25lKCkuc3ViKHBvaW50KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBBY3V0ZSBhbmdsZSBiZXR3ZWVuIHZlY3RvcnMgKGFnbm9zdGljIG9mIENXLCBBQ1cpXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VUb1NhbXBsZSA9IHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHNhbXBsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlVG9TYW1wbGUgPCAyICogdGhpcy5wYXJhbXNTcS5kc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0U2FtcGxlID0gc2FtcGxlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYW5nbGVCZXR3ZWVuID0gTWF0aC5hYnMoVmVjdG9yLmFuZ2xlQmV0d2VlbihkaXJlY3Rpb24sIGRpZmZlcmVuY2VWZWN0b3IpKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBieSBhbmdsZVxuICAgICAgICAgICAgICAgIGlmIChhbmdsZUJldHdlZW4gPCB0aGlzLnBhcmFtcy5qb2luYW5nbGUgJiYgZGlzdGFuY2VUb1NhbXBsZSA8IGNsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZVRvU2FtcGxlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0U2FtcGxlID0gc2FtcGxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gaXMgcmVpbXBsZW1lbnQgc2ltcGxpZnktanMgdG8gcHJlc2VydmUgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgICAgICAvLyAgLSB0aGlzIGlzIHRoZSBwcmltYXJ5IHJlYXNvbiBwb2x5Z29ucyBhcmVuJ3QgZm91bmRcbiAgICAgICAgLy8gSWYgdHJ5aW5nIHRvIGZpbmQgaW50ZXJzZWN0aW9ucyBpbiB0aGUgc2ltcGxpZmllZCBncmFwaFxuICAgICAgICAvLyBwcmV2ZW50IGVuZHMgZ2V0dGluZyBwdWxsZWQgYXdheSBmcm9tIHNpbXBsaWZpZWQgbGluZXNcbiAgICAgICAgaWYgKGNsb3Nlc3RTYW1wbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RTYW1wbGUgPSBjbG9zZXN0U2FtcGxlLmNsb25lKCkuYWRkKGRpcmVjdGlvbi5zZXRMZW5ndGgodGhpcy5wYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2UgKiAzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvc2VzdFNhbXBsZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFzc3VtZXMgcyBoYXMgYWxyZWFkeSBnZW5lcmF0ZWRcbiAgICAgKi9cbiAgICBhZGRFeGlzdGluZ1N0cmVhbWxpbmVzKHM6IFN0cmVhbWxpbmVHZW5lcmF0b3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYWpvckdyaWQuYWRkQWxsKHMubWFqb3JHcmlkKTtcbiAgICAgICAgdGhpcy5taW5vckdyaWQuYWRkQWxsKHMubWlub3JHcmlkKTtcbiAgICB9XG5cbiAgICBnZXQgYWxsU3RyZWFtbGluZXMoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIC8vIENvbWJpbmVcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXNNYWpvci5jb25jYXQodGhpcy5zdHJlYW1saW5lc01pbm9yKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW1saW5lc0RvbmUpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFN0cmVhbWxpbmVNYWpvciA9ICF0aGlzLmxhc3RTdHJlYW1saW5lTWFqb3I7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3JlYXRlU3RyZWFtbGluZSh0aGlzLmxhc3RTdHJlYW1saW5lTWFqb3IpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1saW5lc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RyZWFtbGluZXMgY3JlYXRlZCBlYWNoIGZyYW1lIChhbmltYXRlZClcbiAgICAgKi9cbiAgICBjcmVhdGVBbGxTdHJlYW1saW5lc0R5bmFtaWMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXNEb25lID0gZmFsc2U7XG4gICAgICAgIC8vIHRoaXMuam9pbkRhbmdsaW5nU3RyZWFtbGluZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYXQgb25jZSAtIHdpbGwgZnJlZXplIGlmIGRzZXAgc21hbGxcbiAgICAgKi9cbiAgICBjcmVhdGVBbGxTdHJlYW1saW5lcygpOiB2b2lkIHtcbiAgICAgICAgbGV0IG1ham9yID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3JlYXRlU3RyZWFtbGluZShtYWpvcikpIHtcbiAgICAgICAgICAgIG1ham9yID0gIW1ham9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlQ29hc3RTdHJlYW1saW5lKCk6IFZlY3RvcltdIHtcbiAgICAgICAgbGV0IHN0cmVhbWxpbmU7XG4gICAgICAgIGxldCBzZWVkO1xuICAgICAgICBsZXQgbWFqb3I7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTAwOyBpKyspIHtcbiAgICAgICAgICAgIG1ham9yID0gTWF0aC5yYW5kb20oKSA8IDAuNTtcbiAgICAgICAgICAgIHNlZWQgPSB0aGlzLmdldFNlZWQobWFqb3IpO1xuICAgICAgICAgICAgc3RyZWFtbGluZSA9IHRoaXMuaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkLCBtYWpvcik7XG4gICAgICAgICAgICBzdHJlYW1saW5lLnVuc2hpZnQoc3RyZWFtbGluZVswXS5jbG9uZSgpLmFkZChcbiAgICAgICAgICAgICAgICBzdHJlYW1saW5lWzBdLmNsb25lKCkuc3ViKHN0cmVhbWxpbmVbMV0pLnNldExlbmd0aCh0aGlzLnBhcmFtcy5kbG9va2FoZWFkKSkpO1xuICAgICAgICAgICAgc3RyZWFtbGluZS5wdXNoKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXS5jbG9uZSgpLmFkZChcbiAgICAgICAgICAgICAgICBzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0uY2xvbmUoKS5zdWIoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDJdKS5zZXRMZW5ndGgodGhpcy5wYXJhbXMuZHN0ZXAgKiA1KSkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy52ZWN0b3JPZmZTY3JlZW4oc3RyZWFtbGluZVswXSkgJiYgdGhpcy52ZWN0b3JPZmZTY3JlZW4oc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RyZWFtbGluZSBpcyBjb2FzdGFsID0gbm9pc3lcbiAgICAgICAgY29uc3Qgcm9hZCA9IHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKHN0cmVhbWxpbmUpO1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnB1c2gocm9hZCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGludGVybWVkaWF0ZSBzYW1wbGVzXG4gICAgICAgIGNvbnN0IGNvbXBsZXggPSB0aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lKHJvYWQpO1xuICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFBvbHlsaW5lKGNvbXBsZXgpO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzKG1ham9yKS5wdXNoKGNvbXBsZXgpO1xuXG4gICAgICAgIHJldHVybiBzdHJlYW1saW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBzYW1wbGVzIGluIHN0cmVhbWxpbmUgdW50aWwgc2VwYXJhdGVkIGJ5IGRzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBjb21wbGV4aWZ5U3RyZWFtbGluZShzOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgbGV0IG91dDogVmVjdG9yW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgb3V0ID0gb3V0LmNvbmNhdCh0aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lUmVjdXJzaXZlKHNbaV0sIHNbaSsxXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb21wbGV4aWZ5U3RyZWFtbGluZVJlY3Vyc2l2ZSh2MTogVmVjdG9yLCB2MjogVmVjdG9yKTogVmVjdG9yW10ge1xuICAgICAgICBpZiAodjEuZGlzdGFuY2VUb1NxdWFyZWQodjIpIDw9IHRoaXMucGFyYW1zU3EuZHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBbdjEsIHYyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gdjIuY2xvbmUoKS5zdWIodjEpO1xuICAgICAgICBjb25zdCBoYWxmd2F5ID0gdjEuY2xvbmUoKS5hZGQoZC5tdWx0aXBseVNjYWxhcigwLjUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxleGlmeVN0cmVhbWxpbmVSZWN1cnNpdmUodjEsIGhhbGZ3YXkpLmNvbmNhdCh0aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lUmVjdXJzaXZlKGhhbGZ3YXksIHYyKSk7XG4gICAgfVxuXG4gICAgdmVjdG9yT2ZmU2NyZWVuKHY6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCB0b09yaWdpbiA9IHYuY2xvbmUoKS5zdWIodGhpcy5vcmlnaW4pO1xuICAgICAgICByZXR1cm4gdG9PcmlnaW4ueCA8PSAwIHx8IHRvT3JpZ2luLnkgPD0gMCB8fFxuICAgICAgICAgICAgdG9PcmlnaW4ueCA+PSB0aGlzLndvcmxkRGltZW5zaW9ucy54IHx8IHRvT3JpZ2luLnkgPj0gdGhpcy53b3JsZERpbWVuc2lvbnMueTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNpbXBsaWZ5U3RyZWFtbGluZShzdHJlYW1saW5lOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsaWZ5KHN0cmVhbWxpbmUsIHRoaXMucGFyYW1zLnNpbXBsaWZ5VG9sZXJhbmNlKS5tYXAocG9pbnQgPT4gbmV3IFZlY3Rvcihwb2ludC54LCBwb2ludC55KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgc2VlZCBhbmQgY3JlYXRlcyBhIHN0cmVhbWxpbmUgZnJvbSB0aGF0IHBvaW50XG4gICAgICogUHVzaGVzIG5ldyBjYW5kaWRhdGUgc2VlZHMgdG8gcXVldWVcbiAgICAgKiBAcmV0dXJuIHtWZWN0b3JbXX0gcmV0dXJucyBmYWxzZSBpZiBzZWVkIGlzbid0IGZvdW5kIHdpdGhpbiBwYXJhbXMuc2VlZFRyaWVzXG4gICAgICovXG4gICAgcHJpdmF0ZSBjcmVhdGVTdHJlYW1saW5lKG1ham9yOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHNlZWQgPSB0aGlzLmdldFNlZWQobWFqb3IpO1xuICAgICAgICBpZiAoc2VlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbWxpbmUgPSB0aGlzLmludGVncmF0ZVN0cmVhbWxpbmUoc2VlZCwgbWFqb3IpO1xuICAgICAgICBpZiAodGhpcy52YWxpZFN0cmVhbWxpbmUoc3RyZWFtbGluZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoc3RyZWFtbGluZSk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzKG1ham9yKS5wdXNoKHN0cmVhbWxpbmUpO1xuXG4gICAgICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnB1c2godGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUoc3RyZWFtbGluZSkpO1xuXG4gICAgICAgICAgICAvLyBBZGQgY2FuZGlkYXRlIHNlZWRzXG4gICAgICAgICAgICBpZiAoIXN0cmVhbWxpbmVbMF0uZXF1YWxzKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmRpZGF0ZVNlZWRzKCFtYWpvcikucHVzaChzdHJlYW1saW5lWzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmRpZGF0ZVNlZWRzKCFtYWpvcikucHVzaChzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZFN0cmVhbWxpbmUoczogVmVjdG9yW10pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHMubGVuZ3RoID4gNTtcbiAgICB9IFxuXG4gICAgcHJpdmF0ZSBzZXRQYXJhbXNTcSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXJhbXNTcSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zKTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiB0aGlzLnBhcmFtc1NxKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtc1NxW3BdICo9IHRoaXMucGFyYW1zU3FbcF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNhbXBsZVBvaW50KCk6IFZlY3RvciB7XG4gICAgICAgIC8vIFRPRE8gYmV0dGVyIHNlZWRpbmcgc2NoZW1lXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKFxuICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIHRoaXMud29ybGREaW1lbnNpb25zLngsXG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogdGhpcy53b3JsZERpbWVuc2lvbnMueSlcbiAgICAgICAgICAgIC5hZGQodGhpcy5vcmlnaW4pO1xuICAgIH1cbiBcbiAgICAvKipcbiAgICAgKiBUcmllcyB0aGlzLmNhbmRpZGF0ZVNlZWRzIGZpcnN0LCB0aGVuIHNhbXBsZXMgdXNpbmcgdGhpcy5zYW1wbGVQb2ludFxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0U2VlZChtYWpvcjogYm9vbGVhbik6IFZlY3RvciB7XG4gICAgICAgIC8vIENhbmRpZGF0ZSBzZWVkcyBmaXJzdFxuICAgICAgICBpZiAodGhpcy5TRUVEX0FUX0VORFBPSU5UUyAmJiB0aGlzLmNhbmRpZGF0ZVNlZWRzKG1ham9yKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5jYW5kaWRhdGVTZWVkcyhtYWpvcikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZWQgPSB0aGlzLmNhbmRpZGF0ZVNlZWRzKG1ham9yKS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkU2FtcGxlKG1ham9yLCBzZWVkLCB0aGlzLnBhcmFtc1NxLmRzZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZWVkID0gdGhpcy5zYW1wbGVQb2ludCgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlICghdGhpcy5pc1ZhbGlkU2FtcGxlKG1ham9yLCBzZWVkLCB0aGlzLnBhcmFtc1NxLmRzZXApKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLnBhcmFtcy5zZWVkVHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZWQgPSB0aGlzLnNhbXBsZVBvaW50KCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VlZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzVmFsaWRTYW1wbGUobWFqb3I6IGJvb2xlYW4sIHBvaW50OiBWZWN0b3IsIGRTcTogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVncmF0b3Iub25MYW5kKHBvaW50KSAmJiB0aGlzLmdyaWQobWFqb3IpLmlzVmFsaWRTYW1wbGUocG9pbnQsIGRTcSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBlbnVtIHRvIHJlbW92ZSB0aGVzZSBmdW5jdGlvbnNcbiAgICBwcml2YXRlIGNhbmRpZGF0ZVNlZWRzKG1ham9yOiBib29sZWFuKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gbWFqb3IgPyB0aGlzLmNhbmRpZGF0ZVNlZWRzTWFqb3IgOiB0aGlzLmNhbmRpZGF0ZVNlZWRzTWlub3I7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdHJlYW1saW5lcyhtYWpvcjogYm9vbGVhbik6IFZlY3RvcltdW10ge1xuICAgICAgICByZXR1cm4gbWFqb3IgPyB0aGlzLnN0cmVhbWxpbmVzTWFqb3IgOiB0aGlzLnN0cmVhbWxpbmVzTWlub3I7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBncmlkKG1ham9yOiBib29sZWFuKTogR3JpZFN0b3JhZ2Uge1xuICAgICAgICByZXR1cm4gbWFqb3IgPyB0aGlzLm1ham9yR3JpZCA6IHRoaXMubWlub3JHcmlkO1xuICAgIH1cblxuICAgIHByaXZhdGUgcG9pbnRJbkJvdW5kcyh2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh2LnggPj0gdGhpcy5vcmlnaW4ueFxuICAgICAgICAgICAgJiYgdi55ID49IHRoaXMub3JpZ2luLnlcbiAgICAgICAgICAgICYmIHYueCA8IHRoaXMud29ybGREaW1lbnNpb25zLnggKyB0aGlzLm9yaWdpbi54XG4gICAgICAgICAgICAmJiB2LnkgPCB0aGlzLndvcmxkRGltZW5zaW9ucy55ICsgdGhpcy5vcmlnaW4ueVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpZG4ndCBlbmQgdXAgdXNpbmcgLSBiaXQgZXhwZW5zaXZlLCB1c2VkIHN0cmVhbWxpbmVUdXJuZWQgaW5zdGVhZFxuICAgICAqIFN0b3BzIHNwaXJhbHMgZnJvbSBmb3JtaW5nXG4gICAgICogdXNlcyAwLjUgZGNpcmNsZWpvaW4gc28gdGhhdCBjaXJjbGVzIGFyZSBzdGlsbCBqb2luZWQgdXBcbiAgICAgKiB0ZXN0U2FtcGxlIGlzIGNhbmRpZGF0ZSB0byBwdXNoZWQgb24gZW5kIG9mIHN0cmVhbWxpbmVGb3J3YXJkc1xuICAgICAqIHJldHVybnMgdHJ1ZSBpZiBzdHJlYW1saW5lIGNvbGxpZGVzIHdpdGggaXRzZWxmXG4gICAgICovXG4gICAgcHJpdmF0ZSBkb2VzU3RyZWFtbGluZUNvbGxpZGVTZWxmKHRlc3RTYW1wbGU6IFZlY3Rvciwgc3RyZWFtbGluZUZvcndhcmRzOiBWZWN0b3JbXSwgc3RyZWFtbGluZUJhY2t3YXJkczogVmVjdG9yW10pOiBib29sZWFuIHtcbiAgICAgICAgLy8gU3RyZWFtbGluZSBsb25nIGVub3VnaFxuICAgICAgICBpZiAoc3RyZWFtbGluZUZvcndhcmRzLmxlbmd0aCA+IHRoaXMublN0cmVhbWxpbmVMb29rQmFjaykge1xuICAgICAgICAgICAgLy8gRm9yd2FyZHMgY2hlY2tcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZUZvcndhcmRzLmxlbmd0aCAtIHRoaXMublN0cmVhbWxpbmVMb29rQmFjazsgaSArPSB0aGlzLm5TdHJlYW1saW5lU3RlcCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0U2FtcGxlLmRpc3RhbmNlVG9TcXVhcmVkKHN0cmVhbWxpbmVGb3J3YXJkc1tpXSkgPCB0aGlzLmRjb2xsaWRlc2VsZlNxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNoZWNrXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmVhbWxpbmVCYWNrd2FyZHMubGVuZ3RoOyBpICs9IHRoaXMublN0cmVhbWxpbmVTdGVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RTYW1wbGUuZGlzdGFuY2VUb1NxdWFyZWQoc3RyZWFtbGluZUJhY2t3YXJkc1tpXSkgPCB0aGlzLmRjb2xsaWRlc2VsZlNxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIHN0cmVhbWxpbmUgaGFzIHR1cm5lZCB0aHJvdWdoIGdyZWF0ZXIgdGhhbiAxODAgZGVncmVlc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RyZWFtbGluZVR1cm5lZChzZWVkOiBWZWN0b3IsIG9yaWdpbmFsRGlyOiBWZWN0b3IsIHBvaW50OiBWZWN0b3IsIGRpcmVjdGlvbjogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChvcmlnaW5hbERpci5kb3QoZGlyZWN0aW9uKSA8IDApIHtcbiAgICAgICAgICAgIC8vIFRPRE8gb3B0aW1pc2VcbiAgICAgICAgICAgIGNvbnN0IHBlcnBlbmRpY3VsYXJWZWN0b3IgPSBuZXcgVmVjdG9yKG9yaWdpbmFsRGlyLnksIC1vcmlnaW5hbERpci54KTtcbiAgICAgICAgICAgIGNvbnN0IGlzTGVmdCA9IHBvaW50LmNsb25lKCkuc3ViKHNlZWQpLmRvdChwZXJwZW5kaWN1bGFyVmVjdG9yKSA8IDA7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25VcCA9IGRpcmVjdGlvbi5kb3QocGVycGVuZGljdWxhclZlY3RvcikgPiAwO1xuICAgICAgICAgICAgcmV0dXJuIGlzTGVmdCA9PT0gZGlyZWN0aW9uVXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogLy8gVE9ETyB0aGlzIGRvZXNuJ3Qgd29yayB3ZWxsIC0gY29uc2lkZXIgc29tZXRoaW5nIGRpc2FsbG93aW5nIG9uZSBkaXJlY3Rpb24gKEYvQikgdG8gdHVybiBtb3JlIHRoYW4gMTgwIGRlZ1xuICAgICAqIE9uZSBzdGVwIG9mIHRoZSBzdHJlYW1saW5lIGludGVncmF0aW9uIHByb2Nlc3NcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0cmVhbWxpbmVJbnRlZ3JhdGlvblN0ZXAocGFyYW1zOiBTdHJlYW1saW5lSW50ZWdyYXRpb24sIG1ham9yOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGlmIChwYXJhbXMudmFsaWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zdHJlYW1saW5lLnB1c2gocGFyYW1zLnByZXZpb3VzUG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgbmV4dERpcmVjdGlvbiA9IHRoaXMuaW50ZWdyYXRvci5pbnRlZ3JhdGUocGFyYW1zLnByZXZpb3VzUG9pbnQsIG1ham9yKTtcblxuICAgICAgICAgICAgLy8gU3RvcCBhdCBkZWdlbmVyYXRlIHBvaW50XG4gICAgICAgICAgICBpZiAobmV4dERpcmVjdGlvbi5sZW5ndGhTcSgpIDwgMC4wMSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyYXZlbCBpbiB0aGUgc2FtZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIGlmIChuZXh0RGlyZWN0aW9uLmRvdChwYXJhbXMucHJldmlvdXNEaXJlY3Rpb24pIDwgMCkge1xuICAgICAgICAgICAgICAgIG5leHREaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5leHRQb2ludCA9IHBhcmFtcy5wcmV2aW91c1BvaW50LmNsb25lKCkuYWRkKG5leHREaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICAvLyBWaXN1YWxpc2Ugc3RvcHBpbmcgcG9pbnRzXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5zdHJlYW1saW5lVHVybmVkKHBhcmFtcy5zZWVkLCBwYXJhbXMub3JpZ2luYWxEaXIsIG5leHRQb2ludCwgbmV4dERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIC8vICAgICBwYXJhbXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vICAgICBwYXJhbXMuc3RyZWFtbGluZS5wdXNoKFZlY3Rvci56ZXJvVmVjdG9yKCkpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludEluQm91bmRzKG5leHRQb2ludClcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmlzVmFsaWRTYW1wbGUobWFqb3IsIG5leHRQb2ludCwgdGhpcy5wYXJhbXNTcS5kdGVzdClcbiAgICAgICAgICAgICAgICAmJiAhdGhpcy5zdHJlYW1saW5lVHVybmVkKHBhcmFtcy5zZWVkLCBwYXJhbXMub3JpZ2luYWxEaXIsIG5leHRQb2ludCwgbmV4dERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHJldmlvdXNQb2ludCA9IG5leHRQb2ludDtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHJldmlvdXNEaXJlY3Rpb24gPSBuZXh0RGlyZWN0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPbmUgbW9yZSBzdGVwXG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0cmVhbWxpbmUucHVzaChuZXh0UG9pbnQpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnkgc2ltdWx0YW5lb3VzbHkgaW50ZWdyYXRpbmcgaW4gYm90aCBkaXJlY3Rpb25zIHdlIHJlZHVjZSB0aGUgaW1wYWN0IG9mIGNpcmNsZXMgbm90IGpvaW5pbmdcbiAgICAgKiB1cCBhcyB0aGUgZXJyb3IgbWF0Y2hlcyBhdCB0aGUgam9pblxuICAgICAqL1xuICAgIHByaXZhdGUgaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkOiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yW10ge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBsZXQgcG9pbnRzRXNjYXBlZCA9IGZhbHNlOyAgLy8gVHJ1ZSBvbmNlIHR3byBpbnRlZ3JhdGlvbiBmcm9udHMgaGF2ZSBtb3ZlZCBkbG9va2FoZWFkIGF3YXlcblxuICAgICAgICBjb25zdCBkID0gdGhpcy5pbnRlZ3JhdG9yLmludGVncmF0ZShzZWVkLCBtYWpvcik7XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZFBhcmFtczogU3RyZWFtbGluZUludGVncmF0aW9uID0ge1xuICAgICAgICAgICAgc2VlZDogc2VlZCxcbiAgICAgICAgICAgIG9yaWdpbmFsRGlyOiBkLFxuICAgICAgICAgICAgc3RyZWFtbGluZTogW3NlZWRdLFxuICAgICAgICAgICAgcHJldmlvdXNEaXJlY3Rpb246IGQsXG4gICAgICAgICAgICBwcmV2aW91c1BvaW50OiBzZWVkLmNsb25lKCkuYWRkKGQpLFxuICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgIH1cblxuICAgICAgICBmb3J3YXJkUGFyYW1zLnZhbGlkID0gdGhpcy5wb2ludEluQm91bmRzKGZvcndhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG5cbiAgICAgICAgY29uc3QgbmVnRCA9IGQuY2xvbmUoKS5uZWdhdGUoKTtcbiAgICAgICAgY29uc3QgYmFja3dhcmRQYXJhbXM6IFN0cmVhbWxpbmVJbnRlZ3JhdGlvbiA9IHtcbiAgICAgICAgICAgIHNlZWQ6IHNlZWQsXG4gICAgICAgICAgICBvcmlnaW5hbERpcjogbmVnRCxcbiAgICAgICAgICAgIHN0cmVhbWxpbmU6IFtdLFxuICAgICAgICAgICAgcHJldmlvdXNEaXJlY3Rpb246IG5lZ0QsXG4gICAgICAgICAgICBwcmV2aW91c1BvaW50OiBzZWVkLmNsb25lKCkuYWRkKG5lZ0QpLFxuICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgIH1cblxuICAgICAgICBiYWNrd2FyZFBhcmFtcy52YWxpZCA9IHRoaXMucG9pbnRJbkJvdW5kcyhiYWNrd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcblxuICAgICAgICB3aGlsZSAoY291bnQgPCB0aGlzLnBhcmFtcy5wYXRoSXRlcmF0aW9ucyAmJiAoZm9yd2FyZFBhcmFtcy52YWxpZCB8fCBiYWNrd2FyZFBhcmFtcy52YWxpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtbGluZUludGVncmF0aW9uU3RlcChmb3J3YXJkUGFyYW1zLCBtYWpvcik7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVJbnRlZ3JhdGlvblN0ZXAoYmFja3dhcmRQYXJhbXMsIG1ham9yKTtcblxuICAgICAgICAgICAgLy8gSm9pbiB1cCBjaXJjbGVzXG4gICAgICAgICAgICBjb25zdCBzcURpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZvcndhcmRQYXJhbXMucHJldmlvdXNQb2ludC5kaXN0YW5jZVRvU3F1YXJlZChiYWNrd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcblxuICAgICAgICAgICAgaWYgKCFwb2ludHNFc2NhcGVkICYmIHNxRGlzdGFuY2VCZXR3ZWVuUG9pbnRzID4gdGhpcy5wYXJhbXNTcS5kY2lyY2xlam9pbikge1xuICAgICAgICAgICAgICAgIHBvaW50c0VzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9pbnRzRXNjYXBlZCAmJiBzcURpc3RhbmNlQmV0d2VlblBvaW50cyA8PSB0aGlzLnBhcmFtc1NxLmRjaXJjbGVqb2luKSB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFBhcmFtcy5zdHJlYW1saW5lLnB1c2goZm9yd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3J3YXJkUGFyYW1zLnN0cmVhbWxpbmUucHVzaChiYWNrd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcbiAgICAgICAgICAgICAgICBiYWNrd2FyZFBhcmFtcy5zdHJlYW1saW5lLnB1c2goYmFja3dhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFja3dhcmRQYXJhbXMuc3RyZWFtbGluZS5yZXZlcnNlKCkuY29uY2F0KGZvcndhcmRQYXJhbXMuc3RyZWFtbGluZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW5zb3Ige1xuICAgIHByaXZhdGUgb2xkVGhldGE6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBfdGhldGE6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcjogbnVtYmVyLCBwcml2YXRlIG1hdHJpeDogbnVtYmVyW10pIHtcbiAgICAgICAgLy8gTWF0cml4IGlzIDIgZWxlbWVudCBsaXN0XG4gICAgICAgIC8vIFsgMCwgMVxuICAgICAgICAvLyAgIDEsIC0wIF1cbiAgICAgICAgdGhpcy5vbGRUaGV0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90aGV0YSA9IHRoaXMuY2FsY3VsYXRlVGhldGEoKTtcbiAgICB9XG5cbiAgICBnZXQgdGhldGEoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMub2xkVGhldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX3RoZXRhID0gdGhpcy5jYWxjdWxhdGVUaGV0YSgpO1xuICAgICAgICAgICAgdGhpcy5vbGRUaGV0YSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZXRhO1xuICAgIH1cblxuICAgIGFkZCh0ZW5zb3I6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgICAgIHRoaXMubWF0cml4ID0gdGhpcy5tYXRyaXgubWFwKCh2LCBpKSA9PiB2ICogdGhpcy5yICsgdGVuc29yLm1hdHJpeFtpXSAqIHRlbnNvci5yKTtcbiAgICAgICAgdGhpcy5yID0gMjtcbiAgICAgICAgdGhpcy5vbGRUaGV0YSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNjYWxlKHM6IG51bWJlcik6IFRlbnNvciB7XG4gICAgICAgIHRoaXMuciAqPSBzO1xuICAgICAgICB0aGlzLm9sZFRoZXRhID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gUmFkaWFuc1xuICAgIHJvdGF0ZSh0aGV0YTogbnVtYmVyKTogVGVuc29yIHtcbiAgICAgICAgaWYgKHRoZXRhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3VGhldGEgPSB0aGlzLnRoZXRhICsgdGhldGE7XG4gICAgICAgIGlmIChuZXdUaGV0YSA8IE1hdGguUEkpIHtcbiAgICAgICAgICAgIG5ld1RoZXRhICs9IE1hdGguUEk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3VGhldGEgPj0gTWF0aC5QSSkge1xuICAgICAgICAgICAgbmV3VGhldGEgLT0gTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF0cml4WzBdID0gTWF0aC5jb3MoMiAqIG5ld1RoZXRhKSAqIHRoaXMucjtcbiAgICAgICAgdGhpcy5tYXRyaXhbMV0gPSBNYXRoLnNpbigyICogbmV3VGhldGEpICogdGhpcy5yO1xuICAgICAgICB0aGlzLl90aGV0YSA9IG5ld1RoZXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXRNYWpvcigpOiBWZWN0b3Ige1xuICAgICAgICAvLyBEZWdlbmVyYXRlIGNhc2VcbiAgICAgICAgaWYgKHRoaXMuciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlY3Rvci56ZXJvVmVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoTWF0aC5jb3ModGhpcy50aGV0YSksIE1hdGguc2luKHRoaXMudGhldGEpKTtcbiAgICB9XG5cbiAgICBnZXRNaW5vcigpOiBWZWN0b3Ige1xuICAgICAgICAvLyBEZWdlbmVyYXRlIGNhc2VcbiAgICAgICAgaWYgKHRoaXMuciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlY3Rvci56ZXJvVmVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLnRoZXRhICsgTWF0aC5QSSAvIDI7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKE1hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbGN1bGF0ZVRoZXRhKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLnIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMubWF0cml4WzFdIC8gdGhpcy5yLCB0aGlzLm1hdHJpeFswXSAvIHRoaXMucikgLyAyO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG4vLyBpbXBvcnQgKiBhcyBub2lzZSBmcm9tICdub2lzZWpzJztcbmltcG9ydCAqIGFzIFNpbXBsZXhOb2lzZSBmcm9tICdzaW1wbGV4LW5vaXNlJztcbmltcG9ydCBUZW5zb3IgZnJvbSAnLi90ZW5zb3InO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IHtHcmlkLCBSYWRpYWwsIEJhc2lzRmllbGR9IGZyb20gJy4vYmFzaXNfZmllbGQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vaXNlUGFyYW1zIHtcbiAgICBnbG9iYWxOb2lzZTogYm9vbGVhbjtcbiAgICBub2lzZVNpemVQYXJrOiBudW1iZXI7XG4gICAgbm9pc2VBbmdsZVBhcms6IG51bWJlcjsgIC8vIERlZ3JlZXNcbiAgICBub2lzZVNpemVHbG9iYWw6IG51bWJlcjtcbiAgICBub2lzZUFuZ2xlR2xvYmFsOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbnNvckZpZWxkIHtcbiAgICBwcml2YXRlIGJhc2lzRmllbGRzOiBCYXNpc0ZpZWxkW10gPSBbXTtcbiAgICBwcml2YXRlIHBhcmtzOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHJpdmF0ZSBzZWE6IFZlY3RvcltdID0gW107XG4gICAgcHJpdmF0ZSBub2lzZTogU2ltcGxleE5vaXNlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIG5vaXNlUGFyYW1zOiBOb2lzZVBhcmFtcykge1xuICAgICAgICB0aGlzLm5vaXNlID0gbmV3IFNpbXBsZXhOb2lzZSgpO1xuICAgIH1cblxuICAgIGFkZEdyaWQoY2VudHJlOiBWZWN0b3IsIHNpemU6IG51bWJlciwgZGVjYXk6IG51bWJlciwgdGhldGE6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBncmlkID0gbmV3IEdyaWQoY2VudHJlLCBzaXplLCBkZWNheSwgdGhldGEpO1xuICAgICAgICB0aGlzLmFkZEZpZWxkKGdyaWQpOyAgICAgICAgXG4gICAgfVxuXG4gICAgYWRkUmFkaWFsKGNlbnRyZTogVmVjdG9yLCBzaXplOiBudW1iZXIsIGRlY2F5OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcmFkaWFsID0gbmV3IFJhZGlhbChjZW50cmUsIHNpemUsIGRlY2F5KTtcbiAgICAgICAgdGhpcy5hZGRGaWVsZChyYWRpYWwpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhZGRGaWVsZChmaWVsZDogQmFzaXNGaWVsZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJhc2lzRmllbGRzLnB1c2goZmllbGQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZW1vdmVGaWVsZChmaWVsZDogQmFzaXNGaWVsZCk6IHZvaWQge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuYmFzaXNGaWVsZHMuaW5kZXhPZihmaWVsZCk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2lzRmllbGRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iYXNpc0ZpZWxkcyA9IFtdO1xuICAgICAgICB0aGlzLnBhcmtzID0gW107XG4gICAgICAgIHRoaXMuc2VhID0gW107XG4gICAgfVxuXG4gICAgZ2V0Q2VudHJlUG9pbnRzKCk6IFZlY3RvcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzaXNGaWVsZHMubWFwKGZpZWxkID0+IGZpZWxkLmNlbnRyZSk7XG4gICAgfVxuXG4gICAgc2V0UGFya3MocDogVmVjdG9yW11bXSk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmtzID0gcDtcbiAgICB9XG5cbiAgICBzZXRTZWEocDogVmVjdG9yW10pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZWEgPSBwO1xuICAgIH1cblxuICAgIHNhbXBsZVBvaW50KHBvaW50OiBWZWN0b3IpOiBUZW5zb3Ige1xuICAgICAgICBpZiAoIXRoaXMub25MYW5kKHBvaW50KSkge1xuICAgICAgICAgICAgLy8gRGVnZW5lcmF0ZSBwb2ludFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoMCwgWzAsMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCBmaWVsZCBpcyBhIGdyaWRcbiAgICAgICAgaWYgKHRoaXMuYmFzaXNGaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigxLCBbMCwgMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVuc29yQWNjID0gbmV3IFRlbnNvcigwLCBbMCwgMF0pO1xuICAgICAgICB0aGlzLmJhc2lzRmllbGRzLmZvckVhY2goZmllbGQgPT4gdGVuc29yQWNjLmFkZChmaWVsZC5nZXRXZWlnaHRlZFRlbnNvcihwb2ludCkpKTtcblxuICAgICAgICAvLyBBZGQgcm90YXRpb25hbCBub2lzZSBmb3IgcGFya3MgLSByYW5nZSAtcGkvMiB0byBwaS8yXG4gICAgICAgIGlmICh0aGlzLnBhcmtzLnNvbWUocCA9PiB0aGlzLmluc2lkZVBvbHlnb24ocG9pbnQsIHApKSkge1xuICAgICAgICAgICAgLy8gVE9ETyBvcHRpbWlzZSBpbnNpZGVQb2x5Z29uIGUuZy4gZGlzdGFuY2VcbiAgICAgICAgICAgIHRlbnNvckFjYy5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbmFsTm9pc2UocG9pbnQsIHRoaXMubm9pc2VQYXJhbXMubm9pc2VTaXplUGFyaywgdGhpcy5ub2lzZVBhcmFtcy5ub2lzZUFuZ2xlUGFyaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubm9pc2VQYXJhbXMuZ2xvYmFsTm9pc2UpIHtcbiAgICAgICAgICAgIHRlbnNvckFjYy5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbmFsTm9pc2UocG9pbnQsIHRoaXMubm9pc2VQYXJhbXMubm9pc2VTaXplR2xvYmFsLCB0aGlzLm5vaXNlUGFyYW1zLm5vaXNlQW5nbGVHbG9iYWwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW5zb3JBY2M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9pc2UgQW5nbGUgaXMgaW4gZGVncmVlc1xuICAgICAqL1xuICAgIGdldFJvdGF0aW9uYWxOb2lzZShwb2ludDogVmVjdG9yLCBub2lzZVNpemU6IG51bWJlciwgbm9pc2VBbmdsZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9pc2Uubm9pc2UyRChwb2ludC54IC8gbm9pc2VTaXplLCBwb2ludC55IC8gbm9pc2VTaXplKSAqIG5vaXNlQW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIH1cblxuICAgIG9uTGFuZChwb2ludDogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pbnNpZGVQb2x5Z29uKHBvaW50LCB0aGlzLnNlYSk7XG4gICAgfVxuXG4gICAgaW5zaWRlUG9seWdvbihwb2ludDogVmVjdG9yLCBwb2x5Z29uOiBWZWN0b3JbXSkge1xuICAgICAgICAvLyByYXktY2FzdGluZyBhbGdvcml0aG0gYmFzZWQgb25cbiAgICAgICAgLy8gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbFxuXG4gICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgaSA8IHBvbHlnb24ubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgICAgICB2YXIgeGkgPSBwb2x5Z29uW2ldLngsIHlpID0gcG9seWdvbltpXS55O1xuICAgICAgICAgICAgdmFyIHhqID0gcG9seWdvbltqXS54LCB5aiA9IHBvbHlnb25bal0ueTtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9ICgoeWkgPiBwb2ludC55KSAhPSAoeWogPiBwb2ludC55KSlcbiAgICAgICAgICAgICAgICAmJiAocG9pbnQueCA8ICh4aiAtIHhpKSAqIChwb2ludC55IC0geWkpIC8gKHlqIC0geWkpICsgeGkpO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdCkgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfTtcbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc1dyYXBwZXIge1xuICAgIHByaXZhdGUgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgcHJvdGVjdGVkIF93aWR0aDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfaGVpZ2h0OiBudW1iZXI7XG4gICAgXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgcHJpdmF0ZSBfc2NhbGU9MSwgcmVzaXplVG9XaW5kb3c9dHJ1ZSkge1xuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuXG4gICAgICAgIGlmIChyZXNpemVUb1dpbmRvdykge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEZpbGxTdHlsZSgnYmxhY2snKTtcbiAgICAgICAgdGhpcy5jbGVhckNhbnZhcygpO1xuICAgIH1cblxuICAgIHNldERpbWVuc2lvbnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2luZG93LmlubmVyV2lkdGggKiB0aGlzLl9zY2FsZTtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICogdGhpcy5fc2NhbGU7XG4gICAgfVxuXG4gICAgZ2V0IHdpZHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG5cbiAgICBnZXQgaGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuXG4gICAgZ2V0IGNhbnZhc1NjYWxlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgICB9XG5cbiAgICBzZXQgY2FudmFzU2NhbGUoczogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gcztcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMucmVzaXplQ2FudmFzKCk7XG4gICAgfSBcblxuICAgIHNldEZpbGxTdHlsZShjb2xvdXI6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvdXI7XG4gICAgfVxuXG4gICAgY2xlYXJDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZSgwLCAwLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB9XG5cbiAgICBkcmF3UmVjdGFuZ2xlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICB5ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgd2lkdGggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICBoZWlnaHQgKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgZHJhd1BvbHlnb24ocG9seWdvbjogVmVjdG9yW10pIHtcbiAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHBvbHlnb24gPSBwb2x5Z29uLm1hcCh2ID0+IHYuY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLl9zY2FsZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhwb2x5Z29uWzBdLngsIHBvbHlnb25bMF0ueSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lVG8ocG9seWdvbltpXS54LCBwb2x5Z29uW2ldLnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyhwb2x5Z29uWzBdLngsIHBvbHlnb25bMF0ueSk7XG5cbiAgICAgICAgdGhpcy5jdHguZmlsbCgpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBkcmF3U3F1YXJlKGNlbnRyZTogVmVjdG9yLCByYWRpdXM6IG51bWJlcikge1xuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoY2VudHJlLnggLSByYWRpdXMsIGNlbnRyZS55IC0gcmFkaXVzLCAyICogcmFkaXVzLCAyICogcmFkaXVzKTtcbiAgICB9XG5cbiAgICBzZXRMaW5lV2lkdGgod2lkdGg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHdpZHRoICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIH1cblxuICAgIHNldFN0cm9rZVN0eWxlKGNvbG91cjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3VyO1xuICAgIH1cblxuICAgIGRyYXdQb2x5bGluZShsaW5lOiBWZWN0b3JbXSk6IHZvaWQge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLm1hcCh2ID0+IHYuY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLl9zY2FsZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhsaW5lWzBdLngsIGxpbmVbMF0ueSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lVG8obGluZVtpXS54LCBsaW5lW2ldLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlc2l6ZUNhbnZhcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdHguY2FudmFzLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBDYW52YXNXcmFwcGVyIGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBGaWVsZEludGVncmF0b3IgZnJvbSAnLi4vaW1wbC9pbnRlZ3JhdG9yJztcbmltcG9ydCB7U3RyZWFtbGluZVBhcmFtc30gZnJvbSAnLi4vaW1wbC9zdHJlYW1saW5lcyc7XG5pbXBvcnQgU3RyZWFtbGluZUdlbmVyYXRvciBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBQb2x5Z29uRmluZGVyIGZyb20gJy4uL2ltcGwvcG9seWdvbl9maW5kZXInO1xuaW1wb3J0IFJvYWRHVUkgZnJvbSAnLi9yb2FkX2d1aSc7XG5pbXBvcnQge05vaXNlUGFyYW1zfSBmcm9tICcuLi9pbXBsL3RlbnNvcl9maWVsZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvYXN0bGluZUdVSSBleHRlbmRzIFJvYWRHVUkge1xuICAgIHByaXZhdGUgX3NlYVBvbHlnb246IFZlY3RvcltdID0gW107XG4gICAgcHJpdmF0ZSBfbm9pc3lSb2FkOiBWZWN0b3JbXSA9IFtdO1xuICAgIHB1YmxpYyBub2lzZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IFN0cmVhbWxpbmVQYXJhbXMsXG4gICAgICAgICAgICAgICAgaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxuICAgICAgICAgICAgICAgIGd1aUZvbGRlcjogZGF0LkdVSSxcbiAgICAgICAgICAgICAgICBjbG9zZVRlbnNvckZvbGRlcjogKCkgPT4gdm9pZCxcbiAgICAgICAgICAgICAgICBmb2xkZXJOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVkcmF3OiAoKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbm9pc2VQYXJhbXM6IE5vaXNlUGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcywgaW50ZWdyYXRvciwgZ3VpRm9sZGVyLCBjbG9zZVRlbnNvckZvbGRlciwgZm9sZGVyTmFtZSwgcmVkcmF3KTtcblxuICAgIH1cblxuICAgIGluaXRGb2xkZXIoKTogQ29hc3RsaW5lR1VJIHtcbiAgICAgICAgY29uc3Qgcm9hZEdVSSA9IHtcbiAgICAgICAgICAgIEdlbmVyYXRlOiB0aGlzLmdlbmVyYXRlUm9hZHMuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmd1aUZvbGRlci5hZGRGb2xkZXIodGhpcy5mb2xkZXJOYW1lKTtcbiAgICAgICAgZm9sZGVyLm9wZW4oKTtcbiAgICAgICAgZm9sZGVyLmFkZChyb2FkR1VJLCAnR2VuZXJhdGUnKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmFtc0ZvbGRlciA9IGZvbGRlci5hZGRGb2xkZXIoJ1BhcmFtcycpO1xuICAgICAgICBwYXJhbXNGb2xkZXIuYWRkKHRoaXMsICdub2lzZScpO1xuICAgICAgICBwYXJhbXNGb2xkZXIuYWRkKHRoaXMubm9pc2VQYXJhbXMsICdub2lzZVNpemVHbG9iYWwnKTtcbiAgICAgICAgcGFyYW1zRm9sZGVyLmFkZCh0aGlzLm5vaXNlUGFyYW1zLCAnbm9pc2VBbmdsZUdsb2JhbCcpO1xuICAgICAgICBwYXJhbXNGb2xkZXIuYWRkKHRoaXMucGFyYW1zLCAnc2ltcGxpZnlUb2xlcmFuY2UnKTtcblxuICAgICAgICBjb25zdCBkZXZQYXJhbXNGb2xkZXIgPSBwYXJhbXNGb2xkZXIuYWRkRm9sZGVyKCdEZXYnKTtcbiAgICAgICAgdGhpcy5hZGREZXZQYXJhbXNUb0ZvbGRlcih0aGlzLnBhcmFtcywgZGV2UGFyYW1zRm9sZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0IHNlYVBvbHlnb24oKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VhUG9seWdvbjtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZVJvYWRzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnByZUdlbmVyYXRlQ2FsbGJhY2soKTtcblxuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tIC8gMS4xO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzID0gbmV3IFN0cmVhbWxpbmVHZW5lcmF0b3IoXG4gICAgICAgICAgICB0aGlzLmludGVncmF0b3IsIHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4sXG4gICAgICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLCBPYmplY3QuYXNzaWduKHt9LHRoaXMucGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID0gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gKiAxLjE7XG5cbiAgICAgICAgaWYgKHRoaXMubm9pc2UpIHtcbiAgICAgICAgICAgIHRoaXMubm9pc2VQYXJhbXMuZ2xvYmFsTm9pc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25vaXN5Um9hZCA9IHRoaXMuc3RyZWFtbGluZXMuY3JlYXRlQ29hc3RTdHJlYW1saW5lKCk7XG4gICAgICAgIHRoaXMuX3NlYVBvbHlnb24gPSB0aGlzLmdldFNlYVBvbHlnb24odGhpcy5hbGxTdHJlYW1saW5lc1swXSk7XG4gICAgICAgIHRoaXMubm9pc2VQYXJhbXMuZ2xvYmFsTm9pc2UgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmNsb3NlVGVuc29yRm9sZGVyKCk7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgIHRoaXMucG9zdEdlbmVyYXRlQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBkcmF3Q29hc3RsaW5lKGNhbnZhczogQ2FudmFzV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBjYW52YXMuZHJhd1BvbHlsaW5lKHRoaXMuX25vaXN5Um9hZC5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKSk7XG4gICAgfVxuXG4gICAgZHJhd1NlYShjYW52YXM6IENhbnZhc1dyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHRoaXMuX3NlYVBvbHlnb24ubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pZ2h0IHJldmVyc2UgaW5wdXQgYXJyYXlcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFNlYVBvbHlnb24ocG9seWxpbmU6IFZlY3RvcltdKTogVmVjdG9yW10ge1xuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tIC8gMS4xO1xuICAgICAgICBjb25zdCBzZWFQb2x5Z29uID0gUG9seWdvbkZpbmRlci5zbGljZVJlY3RhbmdsZSh0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLFxuICAgICAgICAgICAgcG9seWxpbmVbMF0sIHBvbHlsaW5lW3BvbHlsaW5lLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSAqIDEuMTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBsb25nZXN0IHNpZGUgd2l0aCBjb2FzdGxpbmVcbiAgICAgICAgbGV0IGxvbmdlc3RJbmRleCA9IDA7XG4gICAgICAgIGxldCBsb25nZXN0TGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFQb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gKGkgKyAxKSAlIHNlYVBvbHlnb24ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZCA9IHNlYVBvbHlnb25baV0uZGlzdGFuY2VUb1NxdWFyZWQoc2VhUG9seWdvbltuZXh0XSk7XG4gICAgICAgICAgICBpZiAoZCA+IGxvbmdlc3RMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb25nZXN0TGVuZ3RoID0gZDtcbiAgICAgICAgICAgICAgICBsb25nZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5zZXJ0QmFja3dhcmRzID0gc2VhUG9seWdvbltsb25nZXN0SW5kZXhdLmRpc3RhbmNlVG9TcXVhcmVkKHBvbHlsaW5lWzBdKSA+IHNlYVBvbHlnb25bbG9uZ2VzdEluZGV4XS5kaXN0YW5jZVRvU3F1YXJlZChwb2x5bGluZVtwb2x5bGluZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChpbnNlcnRCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHBvbHlsaW5lLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlYVBvbHlnb24uc3BsaWNlKGxvbmdlc3RJbmRleCwgMCwgLi4ucG9seWxpbmUpO1xuICAgICAgICByZXR1cm4gc2VhUG9seWdvbjtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYWRkRGV2UGFyYW1zVG9Gb2xkZXIocGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zLCBmb2xkZXI6IGRhdC5HVUkpOiB2b2lkIHtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkc2VwJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnZHRlc3QnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdwYXRoSXRlcmF0aW9ucycpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ3NlZWRUcmllcycpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2RzdGVwJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnZGxvb2thaGVhZCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2RjaXJjbGVqb2luJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnam9pbmFuZ2xlJyk7XG4gICAgfVxuICAgIFxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIFNpbmdsZXRvblxuICogQ29udHJvbHMgcGFubmluZyBhbmQgem9vbWluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb21haW5Db250cm9sbGVyIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRG9tYWluQ29udHJvbGxlcjtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgWk9PTV9TUEVFRCA9IDAuOTY7XG5cbiAgICAvLyBMb2NhdGlvbiBvZiBzY3JlZW4gb3JpZ2luIGluIHdvcmxkIHNwYWNlXG4gICAgcHJpdmF0ZSBfb3JpZ2luOiBWZWN0b3IgPSBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgIFxuICAgIC8vIFNjcmVlbi1zcGFjZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgcHJpdmF0ZSBfc2NyZWVuRGltZW5zaW9ucyA9IFZlY3Rvci56ZXJvVmVjdG9yKCk7XG5cbiAgICAvLyBSYXRpbyBvZiBzY3JlZW4gcGl4ZWxzIHRvIHdvcmxkIHBpeGVsc1xuICAgIHByaXZhdGUgX3pvb206IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSB6b29tQ2FsbGJhY2s6ICgpID0+IGFueSA9ICgpID0+IHt9O1xuXG4gICAgLy8gU2V0IGFmdGVyIHBhbiBvciB6b29tXG4gICAgcHVibGljIG1vdmVkID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNldFNjcmVlbkRpbWVuc2lvbnMoKTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCk6IHZvaWQgPT4gdGhpcy5zZXRTY3JlZW5EaW1lbnNpb25zKCkpO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChlOiBhbnkpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhOiBudW1iZXIgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIC8vIFRPRE8gc2NhbGUgYnkgdmFsdWUgb2YgZGVsdGFcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSB0aGlzLl96b29tICogdGhpcy5aT09NX1NQRUVEO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSB0aGlzLl96b29tIC8gdGhpcy5aT09NX1NQRUVEO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0U2NyZWVuRGltZW5zaW9ucygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjcmVlbkRpbWVuc2lvbnMuc2V0WCh3aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgICAgIHRoaXMuX3NjcmVlbkRpbWVuc2lvbnMuc2V0WSh3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogRG9tYWluQ29udHJvbGxlciB7XG4gICAgICAgIGlmICghRG9tYWluQ29udHJvbGxlci5pbnN0YW5jZSkge1xuICAgICAgICAgICAgRG9tYWluQ29udHJvbGxlci5pbnN0YW5jZSA9IG5ldyBEb21haW5Db250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERvbWFpbkNvbnRyb2xsZXIuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtWZWN0b3J9IGRlbHRhIGluIHdvcmxkIHNwYWNlXG4gICAgICovXG4gICAgcGFuKGRlbHRhOiBWZWN0b3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX29yaWdpbi5zdWIoZGVsdGEpO1xuICAgIH1cblxuICAgIGdldCBvcmlnaW4oKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbi5jbG9uZSgpO1xuICAgIH1cblxuICAgIGdldCB6b29tKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl96b29tO1xuICAgIH1cblxuICAgIGdldCBzY3JlZW5EaW1lbnNpb25zKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JlZW5EaW1lbnNpb25zLmNsb25lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7VmVjdG9yfSB3b3JsZC1zcGFjZSB3L2ggdmlzaWJsZSBvbiBzY3JlZW5cbiAgICAgKi9cbiAgICBnZXQgd29ybGREaW1lbnNpb25zKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbkRpbWVuc2lvbnMuZGl2aWRlU2NhbGFyKHRoaXMuX3pvb20pO1xuICAgIH1cblxuICAgIHNldCBzY3JlZW5EaW1lbnNpb25zKHY6IFZlY3Rvcikge1xuICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NyZWVuRGltZW5zaW9ucy5jb3B5KHYpO1xuICAgIH1cblxuICAgIHNldCB6b29tKHo6IG51bWJlcikge1xuICAgICAgICBpZiAoeiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgb2xkV29ybGRTcGFjZU1pZHBvaW50ID0gdGhpcy5vcmlnaW4uYWRkKHRoaXMud29ybGREaW1lbnNpb25zLmRpdmlkZVNjYWxhcigyKSk7XG4gICAgICAgICAgICB0aGlzLl96b29tID0gejtcbiAgICAgICAgICAgIGNvbnN0IG5ld1dvcmxkU3BhY2VNaWRwb2ludCA9IHRoaXMub3JpZ2luLmFkZCh0aGlzLndvcmxkRGltZW5zaW9ucy5kaXZpZGVTY2FsYXIoMikpO1xuICAgICAgICAgICAgdGhpcy5wYW4obmV3V29ybGRTcGFjZU1pZHBvaW50LnN1YihvbGRXb3JsZFNwYWNlTWlkcG9pbnQpKTtcbiAgICAgICAgICAgIHRoaXMuem9vbUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRab29tVXBkYXRlKGNhbGxiYWNrOiAoKSA9PiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy56b29tQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0cyB2ZWN0b3JcbiAgICAgKi9cbiAgICB6b29tVG9Xb3JsZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5kaXZpZGVTY2FsYXIodGhpcy5fem9vbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgdmVjdG9yXG4gICAgICovXG4gICAgem9vbVRvU2NyZWVuKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB2Lm11bHRpcGx5U2NhbGFyKHRoaXMuX3pvb20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVkaXRzIHZlY3RvclxuICAgICAqL1xuICAgIHNjcmVlblRvV29ybGQodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbVRvV29ybGQodikuYWRkKHRoaXMuX29yaWdpbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgdmVjdG9yXG4gICAgICovXG4gICAgd29ybGRUb1NjcmVlbih2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy56b29tVG9TY3JlZW4odi5zdWIodGhpcy5fb3JpZ2luKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBpbnRlcmFjdCBmcm9tICdpbnRlcmFjdGpzJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi9WZWN0b3InO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5cbmludGVyZmFjZSBEcmFnZ2FibGUge1xuICAgIGdldENlbnRyZTogKCgpID0+IFZlY3Rvcik7XG4gICAgY2FsbGJhY2tGbjogKCh2OiBWZWN0b3IpID0+IHZvaWQpO1xufVxuXG4vKipcbiogUmVnaXN0ZXIgbXVsdGlwbGUgY2VudHJlIHBvaW50c1xuKiBDbG9zZXN0IG9uZSB0byBtb3VzZSBjbGljayB3aWxsIGJlIHNlbGVjdGVkIHRvIGRyYWdcbiogVXAgdG8gY2FsbGVyIHRvIGFjdHVhbGx5IG1vdmUgdGhlaXIgY2VudHJlIHBvaW50IHZpYSBjYWxsYmFja1xuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyYWdDb250cm9sbGVyIHtcbiAgICAvLyBIb3cgY2xvc2UgdG8gZHJhZyBoYW5kbGUgcG9pbnRlciBuZWVkcyB0byBiZVxuICAgIHByaXZhdGUgcmVhZG9ubHkgTUlOX0RSQUdfRElTVEFOQ0UgPSA1MDtcblxuICAgIHByaXZhdGUgZHJhZ2dhYmxlczogRHJhZ2dhYmxlW10gPSBbXTtcbiAgICBwcml2YXRlIGN1cnJlbnRseURyYWdnaW5nOiBEcmFnZ2FibGUgPSBudWxsO1xuICAgIHByaXZhdGUgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGd1aTogZGF0LkdVSSkge1xuICAgICAgICBpbnRlcmFjdChgIyR7VXRpbC5DQU5WQVNfSUR9YCkuZHJhZ2dhYmxlKHtcbiAgICAgICAgICAgIG9uc3RhcnQ6IHRoaXMuZHJhZ1N0YXJ0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBvbm1vdmU6IHRoaXMuZHJhZ01vdmUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uZW5kOiB0aGlzLmRyYWdFbmQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGN1cnNvckNoZWNrZXI6IHRoaXMuZ2V0Q3Vyc29yLmJpbmQodGhpcyksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldERyYWdEaXNhYmxlZChkaXNhYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlO1xuICAgIH1cblxuICAgIGdldEN1cnNvcihhY3Rpb246IGFueSwgaW50ZXJhY3RhYmxlOiBhbnksIGVsZW1lbnQ6IGFueSwgaW50ZXJhY3Rpbmc6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKGludGVyYWN0aW5nKSByZXR1cm4gJ2dyYWJiaW5nJztcbiAgICAgICAgcmV0dXJuICdncmFiJztcbiAgICB9XG5cbiAgICBkcmFnU3RhcnQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICAvLyBUcmFuc2Zvcm0gc2NyZWVuIHNwYWNlIHRvIHdvcmxkIHNwYWNlXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZG9tYWluQ29udHJvbGxlci5zY3JlZW5Ub1dvcmxkKG5ldyBWZWN0b3IoZXZlbnQueDAsIGV2ZW50LnkwKSk7XG4gICAgICAgIFxuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlcy5mb3JFYWNoKGRyYWdnYWJsZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkID0gZHJhZ2dhYmxlLmdldENlbnRyZSgpLmRpc3RhbmNlVG8ob3JpZ2luKTtcbiAgICAgICAgICAgIGlmIChkIDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZDtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRseURyYWdnaW5nID0gZHJhZ2dhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBab29tIHNjcmVlbiBzaXplIHRvIHdvcmxkIHNpemUgZm9yIGNvbnNpc3RlbnQgZHJhZyBkaXN0YW5jZSB3aGlsZSB6b29tZWQgaW5cbiAgICAgICAgY29uc3Qgc2NhbGVkRHJhZ0Rpc3RhbmNlID0gdGhpcy5NSU5fRFJBR19ESVNUQU5DRSAvIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tO1xuXG4gICAgICAgIGlmIChjbG9zZXN0RGlzdGFuY2UgPiBzY2FsZWREcmFnRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHJhZ01vdmUoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCBkZWx0YSA9IG5ldyBWZWN0b3IoZXZlbnQuZGVsdGEueCwgZXZlbnQuZGVsdGEueSk7XG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tVG9Xb3JsZChkZWx0YSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERyYWcgZmllbGRcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcuY2FsbGJhY2tGbihkZWx0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNb3ZlIG1hcFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnBhbihkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmFnRW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnRseURyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgVXRpbC51cGRhdGVHdWkodGhpcy5ndWkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7KCgpID0+IFZlY3Rvcil9IEdldHMgY2VudHJlIHBvaW50XG4gICAgICogQHBhcmFtIHsoKHY6IFZlY3RvcikgPT4gdm9pZCl9IENhbGxlZCBvbiBtb3ZlIHdpdGggZGVsdGEgdmVjdG9yXG4gICAgICogQHJldHVybnMgeygoKSA9PiB2b2lkKX0gRnVuY3Rpb24gdG8gZGVyZWdpc3RlciBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlZ2lzdGVyKGdldENlbnRyZTogKCgpID0+IFZlY3RvciksXG4gICAgICAgICAgICAgb25Nb3ZlOiAoKHY6IFZlY3RvcikgPT4gdm9pZCkpOiAoKCkgPT4gdm9pZCkge1xuICAgICAgICBjb25zdCBkcmFnZ2FibGU6IERyYWdnYWJsZSA9IHtcbiAgICAgICAgICAgIGdldENlbnRyZTogZ2V0Q2VudHJlLFxuICAgICAgICAgICAgY2FsbGJhY2tGbjogb25Nb3ZlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlcy5wdXNoKGRyYWdnYWJsZSk7XG4gICAgICAgIHJldHVybiAoKCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRyYWdnYWJsZXMuaW5kZXhPZihkcmFnZ2FibGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb2FkR1VJIHtcbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZXM6IFN0cmVhbWxpbmVHZW5lcmF0b3I7XG4gICAgcHJpdmF0ZSBleGlzdGluZ1N0cmVhbWxpbmVzOiBSb2FkR1VJW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBwcm90ZWN0ZWQgcHJlR2VuZXJhdGVDYWxsYmFjazogKCkgPT4gYW55ID0gKCkgPT4ge307XG4gICAgcHJvdGVjdGVkIHBvc3RHZW5lcmF0ZUNhbGxiYWNrOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBwYXJhbXM6IFN0cmVhbWxpbmVQYXJhbXMsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIGludGVncmF0b3I6IEZpZWxkSW50ZWdyYXRvcixcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgZ3VpRm9sZGVyOiBkYXQuR1VJLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBjbG9zZVRlbnNvckZvbGRlcjogKCkgPT4gdm9pZCxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgZm9sZGVyTmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCByZWRyYXc6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyA9IG5ldyBTdHJlYW1saW5lR2VuZXJhdG9yKFxuICAgICAgICAgICAgdGhpcy5pbnRlZ3JhdG9yLCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucywgdGhpcy5wYXJhbXMpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBwYXRoIGl0ZXJhdGlvbnMgYmFzZWQgb24gd2luZG93IHNpemVcbiAgICAgICAgdGhpcy5zZXRQYXRoSXRlcmF0aW9ucygpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCk6IHZvaWQgPT4gdGhpcy5zZXRQYXRoSXRlcmF0aW9ucygpKTtcbiAgICB9XG5cbiAgICBpbml0Rm9sZGVyKCk6IFJvYWRHVUkge1xuICAgICAgICBjb25zdCByb2FkR1VJID0ge1xuICAgICAgICAgICAgR2VuZXJhdGU6IHRoaXMuZ2VuZXJhdGVSb2Fkcy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgSm9pbkRhbmdsaW5nOiAoKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1saW5lcy5qb2luRGFuZ2xpbmdTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZ3VpRm9sZGVyLmFkZEZvbGRlcih0aGlzLmZvbGRlck5hbWUpO1xuICAgICAgICBmb2xkZXIuYWRkKHJvYWRHVUksICdHZW5lcmF0ZScpO1xuICAgICAgICBmb2xkZXIuYWRkKHJvYWRHVUksICdKb2luRGFuZ2xpbmcnKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmFtc0ZvbGRlciA9IGZvbGRlci5hZGRGb2xkZXIoJ1BhcmFtcycpO1xuICAgICAgICBwYXJhbXNGb2xkZXIuYWRkKHRoaXMucGFyYW1zLCAnZHNlcCcpO1xuICAgICAgICBwYXJhbXNGb2xkZXIuYWRkKHRoaXMucGFyYW1zLCAnZHRlc3QnKTtcblxuICAgICAgICBjb25zdCBkZXZQYXJhbXNGb2xkZXIgPSBwYXJhbXNGb2xkZXIuYWRkRm9sZGVyKCdEZXYnKTtcbiAgICAgICAgdGhpcy5hZGREZXZQYXJhbXNUb0ZvbGRlcih0aGlzLnBhcmFtcywgZGV2UGFyYW1zRm9sZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0IGFsbFN0cmVhbWxpbmVzKCk6IFZlY3RvcltdW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5hbGxTdHJlYW1saW5lc1NpbXBsZTtcbiAgICB9XG5cbiAgICBkcmF3KGNhbnZhczogQ2FudmFzV3JhcHBlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLmZvckVhY2gocyA9PiB7XG4gICAgICAgICAgICBjYW52YXMuZHJhd1BvbHlsaW5lKHMubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByb2Fkc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgc2V0RXhpc3RpbmdTdHJlYW1saW5lcyhleGlzdGluZ1N0cmVhbWxpbmVzOiBSb2FkR1VJW10pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5leGlzdGluZ1N0cmVhbWxpbmVzID0gZXhpc3RpbmdTdHJlYW1saW5lcztcbiAgICB9XG5cbiAgICBzZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKGNhbGxiYWNrOiAoKSA9PiBhbnkpIHtcbiAgICAgICAgdGhpcy5wcmVHZW5lcmF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgc2V0UG9zdEdlbmVyYXRlQ2FsbGJhY2soY2FsbGJhY2s6ICgpID0+IGFueSkge1xuICAgICAgICB0aGlzLnBvc3RHZW5lcmF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgY2xlYXJTdHJlYW1saW5lcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVSb2FkcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcmVHZW5lcmF0ZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSAvIDEuMTtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyA9IG5ldyBTdHJlYW1saW5lR2VuZXJhdG9yKFxuICAgICAgICAgICAgdGhpcy5pbnRlZ3JhdG9yLCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucywgT2JqZWN0LmFzc2lnbih7fSx0aGlzLnBhcmFtcykpO1xuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tICogMS4xO1xuXG4gICAgICAgIHRoaXMuZXhpc3RpbmdTdHJlYW1saW5lcy5mb3JFYWNoKHMgPT4gdGhpcy5zdHJlYW1saW5lcy5hZGRFeGlzdGluZ1N0cmVhbWxpbmVzKHMuc3RyZWFtbGluZXMpKTsgICAgICAgIFxuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmNyZWF0ZUFsbFN0cmVhbWxpbmVzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMuam9pbkRhbmdsaW5nU3RyZWFtbGluZXMoKTtcbiAgICAgICAgdGhpcy5jbG9zZVRlbnNvckZvbGRlcigpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB0aGlzLnBvc3RHZW5lcmF0ZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFkZERldlBhcmFtc1RvRm9sZGVyKHBhcmFtczogU3RyZWFtbGluZVBhcmFtcywgZm9sZGVyOiBkYXQuR1VJKTogdm9pZCB7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAncGF0aEl0ZXJhdGlvbnMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdzZWVkVHJpZXMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkc3RlcCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2Rsb29rYWhlYWQnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkY2lyY2xlam9pbicpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2pvaW5hbmdsZScpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ3NpbXBsaWZ5VG9sZXJhbmNlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwYXRoIGl0ZXJhdGlvbnMgc28gdGhhdCBhIHJvYWQgY2FuIGNvdmVyIHRoZSBzY3JlZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFBhdGhJdGVyYXRpb25zKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXggPSAxLjUgKiBNYXRoLm1heCh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy5wYXJhbXMucGF0aEl0ZXJhdGlvbnMgPSBtYXgvdGhpcy5wYXJhbXMuZHN0ZXA7XG4gICAgICAgIFV0aWwudXBkYXRlR3VpKHRoaXMuZ3VpRm9sZGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuLi9pbXBsL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQge1JLNEludGVncmF0b3J9IGZyb20gJy4uL2ltcGwvaW50ZWdyYXRvcic7XG5pbXBvcnQgRmllbGRJbnRlZ3JhdG9yIGZyb20gJy4uL2ltcGwvaW50ZWdyYXRvcic7XG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IEdyYXBoIGZyb20gJy4uL2ltcGwvZ3JhcGgnO1xuaW1wb3J0IFJvYWRHVUkgZnJvbSAnLi9yb2FkX2d1aSc7XG5pbXBvcnQgQ29hc3RsaW5lR1VJIGZyb20gJy4vY29hc3RsaW5lX2d1aSc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgUG9seWdvbkZpbmRlciBmcm9tICcuLi9pbXBsL3BvbHlnb25fZmluZGVyJztcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb2Fkc0dVSSB7XG4gICAgcHJpdmF0ZSBkb21haW5Db250cm9sbGVyID0gRG9tYWluQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xuICAgIHByaXZhdGUgaW50ZXJzZWN0aW9uczogVmVjdG9yW10gPSBbXTtcbiAgICBwdWJsaWMgbnVtUGFya3M6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBwYXJrczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHByaXZhdGUgbG90czogVmVjdG9yW11bXSA9IFtdO1xuXG4gICAgcHJpdmF0ZSBidWlsZGluZ1NpemUgPSA4MDtcbiAgICBwcml2YXRlIGJ1aWxkaW5nTWFyZ2luID0gNDtcblxuICAgIHByaXZhdGUgY29hc3RsaW5lOiBDb2FzdGxpbmVHVUk7XG4gICAgcHJpdmF0ZSBtYWluUm9hZHM6IFJvYWRHVUk7XG4gICAgcHJpdmF0ZSBtYWpvclJvYWRzOiBSb2FkR1VJO1xuICAgIHByaXZhdGUgbWlub3JSb2FkczogUm9hZEdVSTtcblxuICAgIC8vIFBhcmFtc1xuICAgIHByaXZhdGUgY29hc3RsaW5lUGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zO1xuICAgIHByaXZhdGUgbWFpblBhcmFtczogU3RyZWFtbGluZVBhcmFtcztcbiAgICBwcml2YXRlIG1ham9yUGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zO1xuICAgIHByaXZhdGUgbWlub3JQYXJhbXM6IFN0cmVhbWxpbmVQYXJhbXMgPSB7XG4gICAgICAgIGRzZXA6IDIwLFxuICAgICAgICBkdGVzdDogMTAsXG4gICAgICAgIGRzdGVwOiAxLFxuICAgICAgICBkbG9va2FoZWFkOiAxMDAsXG4gICAgICAgIGRjaXJjbGVqb2luOiA1LFxuICAgICAgICBqb2luYW5nbGU6IDAuMSwgIC8vIGFwcHJveCAzMGRlZ1xuICAgICAgICBwYXRoSXRlcmF0aW9uczogMTAwMCxcbiAgICAgICAgc2VlZFRyaWVzOiAzMDAsXG4gICAgICAgIHNpbXBsaWZ5VG9sZXJhbmNlOiAwLjUsXG4gICAgfTtcblxuICAgIHByaXZhdGUgcmVkcmF3OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3VpRm9sZGVyOiBkYXQuR1VJLCB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGQsIHByaXZhdGUgY2xvc2VUZW5zb3JGb2xkZXI6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgY29uc3Qgcm9hZHNQYXJhbXMgPSBndWlGb2xkZXIuYWRkRm9sZGVyKCdQYXJhbXMnKTtcbiAgICAgICAgcm9hZHNQYXJhbXMuYWRkKHRoaXMsICdudW1QYXJrcycpO1xuXG4gICAgICAgIHRoaXMuY29hc3RsaW5lUGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5taW5vclBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29hc3RsaW5lUGFyYW1zLnBhdGhJdGVyYXRpb25zID0gMTAwMDA7XG4gICAgICAgIHRoaXMuY29hc3RsaW5lUGFyYW1zLnNpbXBsaWZ5VG9sZXJhbmNlID0gMTA7XG5cbiAgICAgICAgdGhpcy5tYWpvclBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubWlub3JQYXJhbXMpO1xuICAgICAgICB0aGlzLm1ham9yUGFyYW1zLmRzZXAgPSAxMDA7XG4gICAgICAgIHRoaXMubWFqb3JQYXJhbXMuZHRlc3QgPSAzMDtcbiAgICAgICAgdGhpcy5tYWpvclBhcmFtcy5kbG9va2FoZWFkID0gMjAwO1xuXG4gICAgICAgIHRoaXMubWFpblBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubWlub3JQYXJhbXMpO1xuICAgICAgICB0aGlzLm1haW5QYXJhbXMuZHNlcCA9IDQwMDtcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zLmR0ZXN0ID0gMjAwO1xuICAgICAgICB0aGlzLm1haW5QYXJhbXMuZGxvb2thaGVhZCA9IDMwMDtcblxuICAgICAgICBjb25zdCBpbnRlZ3JhdG9yID0gbmV3IFJLNEludGVncmF0b3IodGVuc29yRmllbGQsIHRoaXMubWlub3JQYXJhbXMpO1xuICAgICAgICBjb25zdCByZWRyYXcgPSAoKSA9PiB0aGlzLnJlZHJhdyA9IHRydWU7XG4gICAgICAgIHRoaXMuY29hc3RsaW5lID0gbmV3IENvYXN0bGluZUdVSSh0aGlzLmNvYXN0bGluZVBhcmFtcywgaW50ZWdyYXRvcixcbiAgICAgICAgICAgIHRoaXMuZ3VpRm9sZGVyLCBjbG9zZVRlbnNvckZvbGRlciwgJ0NvYXN0bGluZScsIHJlZHJhdywgdGVuc29yRmllbGQubm9pc2VQYXJhbXMpLmluaXRGb2xkZXIoKTtcbiAgICAgICAgdGhpcy5tYWluUm9hZHMgPSBuZXcgUm9hZEdVSSh0aGlzLm1haW5QYXJhbXMsIGludGVncmF0b3IsIHRoaXMuZ3VpRm9sZGVyLCBjbG9zZVRlbnNvckZvbGRlciwgJ01haW4nLCByZWRyYXcpLmluaXRGb2xkZXIoKTtcbiAgICAgICAgdGhpcy5tYWpvclJvYWRzID0gbmV3IFJvYWRHVUkodGhpcy5tYWpvclBhcmFtcywgaW50ZWdyYXRvciwgdGhpcy5ndWlGb2xkZXIsIGNsb3NlVGVuc29yRm9sZGVyLCAnTWFqb3InLCByZWRyYXcpLmluaXRGb2xkZXIoKTtcbiAgICAgICAgdGhpcy5taW5vclJvYWRzID0gbmV3IFJvYWRHVUkodGhpcy5taW5vclBhcmFtcywgaW50ZWdyYXRvciwgdGhpcy5ndWlGb2xkZXIsIGNsb3NlVGVuc29yRm9sZGVyLCAnTWlub3InLCByZWRyYXcpLmluaXRGb2xkZXIoKTtcblxuICAgICAgICB0aGlzLm1pbm9yUm9hZHMuc2V0RXhpc3RpbmdTdHJlYW1saW5lcyhbdGhpcy5jb2FzdGxpbmUsIHRoaXMubWFpblJvYWRzLCB0aGlzLm1ham9yUm9hZHNdKTtcbiAgICAgICAgdGhpcy5tYWpvclJvYWRzLnNldEV4aXN0aW5nU3RyZWFtbGluZXMoW3RoaXMuY29hc3RsaW5lLCB0aGlzLm1haW5Sb2Fkc10pO1xuICAgICAgICB0aGlzLm1haW5Sb2Fkcy5zZXRFeGlzdGluZ1N0cmVhbWxpbmVzKFt0aGlzLmNvYXN0bGluZV0pO1xuXG4gICAgICAgIHRoaXMuY29hc3RsaW5lLnNldFByZUdlbmVyYXRlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWluUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgdGhpcy5tYWpvclJvYWRzLmNsZWFyU3RyZWFtbGluZXMoKTtcbiAgICAgICAgICAgIHRoaXMubWlub3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmtzID0gW107XG4gICAgICAgICAgICB0aGlzLmxvdHMgPSBbXTtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnNldFBhcmtzKFtdKTtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnNldFNlYShbXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29hc3RsaW5lLnNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnNldFNlYSh0aGlzLmNvYXN0bGluZS5zZWFQb2x5Z29uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYWluUm9hZHMuc2V0UHJlR2VuZXJhdGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgdGhpcy5taW5vclJvYWRzLmNsZWFyU3RyZWFtbGluZXMoKTtcbiAgICAgICAgICAgIHRoaXMucGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubG90cyA9IFtdO1xuICAgICAgICAgICAgdGVuc29yRmllbGQuc2V0UGFya3MoW10pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1ham9yUm9hZHMuc2V0UHJlR2VuZXJhdGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1pbm9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgdGhpcy5wYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5sb3RzID0gW107XG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5zZXRQYXJrcyh0aGlzLnBhcmtzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYWpvclJvYWRzLnNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBuZXcgR3JhcGgodGhpcy5tYWpvclJvYWRzLmFsbFN0cmVhbWxpbmVzLmNvbmNhdCh0aGlzLm1haW5Sb2Fkcy5hbGxTdHJlYW1saW5lcyksIHRoaXMubWlub3JQYXJhbXMuZHN0ZXApO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25zID0gZy5pbnRlcnNlY3Rpb25zOyBcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUG9seWdvbkZpbmRlcihnLm5vZGVzKTtcbiAgICAgICAgICAgIHAuZmluZFBvbHlnb25zKCk7XG4gICAgICAgICAgICBjb25zdCBwb2x5Z29ucyA9IHAucG9seWdvbnM7XG5cbiAgICAgICAgICAgIGlmIChwb2x5Z29ucy5sZW5ndGggPiB0aGlzLm51bVBhcmtzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFya0luZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHBvbHlnb25zLmxlbmd0aCAtIHRoaXMubnVtUGFya3MpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcGFya0luZGV4OyBpIDwgcGFya0luZGV4ICsgdGhpcy5udW1QYXJrczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFya3MucHVzaChwb2x5Z29uc1tpXSk7ICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwb2x5Z29ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmtzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1pbm9yUm9hZHMuc2V0UHJlR2VuZXJhdGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvdHMgPSBbXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYnVpbGRpbmdzRm9sZGVyID0gZ3VpRm9sZGVyLmFkZEZvbGRlcignQnVpbGRpbmdzJyk7XG4gICAgICAgIGJ1aWxkaW5nc0ZvbGRlci5hZGQodGhpcywgJ2FkZEJ1aWxkaW5ncycpO1xuICAgICAgICBidWlsZGluZ3NGb2xkZXIuYWRkKHRoaXMsICdidWlsZGluZ1NpemUnKTtcbiAgICAgICAgYnVpbGRpbmdzRm9sZGVyLmFkZCh0aGlzLCAnYnVpbGRpbmdNYXJnaW4nKTtcbiAgICB9XG5cbiAgICBhZGRCdWlsZGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IGcgPSBuZXcgR3JhcGgoXG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuYWxsU3RyZWFtbGluZXNcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5tYWluUm9hZHMuYWxsU3RyZWFtbGluZXMpXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMubWlub3JSb2Fkcy5hbGxTdHJlYW1saW5lcylcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5jb2FzdGxpbmUuYWxsU3RyZWFtbGluZXMpLCB0aGlzLm1pbm9yUGFyYW1zLmRzdGVwKTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQb2x5Z29uRmluZGVyKGcubm9kZXMpO1xuICAgICAgICBwLnNocmluayh0aGlzLmJ1aWxkaW5nTWFyZ2luKTtcbiAgICAgICAgcC5kaXZpZGUodGhpcy5idWlsZGluZ1NpemUpO1xuICAgICAgICB0aGlzLmxvdHMgPSBwLnBvbHlnb25zO1xuICAgICAgICB0aGlzLnJlZHJhdyA9IHRydWU7XG4gICAgfVxuXG4gICAgZHJhdyhjYW52YXM6IENhbnZhc1dyYXBwZXIsIGZvcmNlRHJhdz1mYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAoIWZvcmNlRHJhdyAmJiAhdGhpcy5yZWRyYXcgJiYgIXRoaXMuZG9tYWluQ29udHJvbGxlci5tb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLm1vdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVkcmF3ID0gZmFsc2U7XG5cbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSgnI0VDRTVEQicpO1xuICAgICAgICBjYW52YXMuY2xlYXJDYW52YXMoKTtcblxuICAgICAgICAvLyBTZWFcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSgnI2E5ZDlmZScpO1xuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUoJyNhOWQ5ZmUnKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgwLjEpO1xuICAgICAgICBjYW52YXMuZHJhd1BvbHlnb24odGhpcy5jb2FzdGxpbmUuc2VhUG9seWdvbi5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKSk7XG5cbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKCcjRUNFNURCJyk7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgoMzAgKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIHRoaXMuY29hc3RsaW5lLmRyYXdDb2FzdGxpbmUoY2FudmFzKTtcblxuICAgICAgICAvLyBCdWlsZGluZ3NcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSgnI0VDRTVEQicpO1xuICAgICAgICAvLyBjYW52YXMuc2V0RmlsbFN0eWxlKCcjZWJhZTM0Jyk7XG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSgnIzI4MjgyOCcpO1xuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKDAuNSk7XG4gICAgICAgIHRoaXMubG90cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHAubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQYXJrc1xuICAgICAgICBjYW52YXMuc2V0RmlsbFN0eWxlKCcjYzVlOGM1Jyk7XG4gICAgICAgIHRoaXMucGFya3MuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgIGNhbnZhcy5kcmF3UG9seWdvbihwLm1hcCh2ID0+IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSkpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUm9hZCBvdXRsaW5lXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSgnIzAyMDIwMicpO1xuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKDMgKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIHRoaXMubWlub3JSb2Fkcy5kcmF3KGNhbnZhcyk7XG5cbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKCcjMDIwMjAyJyk7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgoNSAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcbiAgICAgICAgdGhpcy5tYWpvclJvYWRzLmRyYXcoY2FudmFzKTtcblxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUoJyMyODI4MjgnKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCg2ICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xuICAgICAgICB0aGlzLm1haW5Sb2Fkcy5kcmF3KGNhbnZhcyk7XG4gICAgICAgIHRoaXMuY29hc3RsaW5lLmRyYXcoY2FudmFzKTtcblxuICAgICAgICAvLyBSb2FkIGlubGluZVxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUoJyNGOEY4RjgnKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgyICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xuICAgICAgICB0aGlzLm1pbm9yUm9hZHMuZHJhdyhjYW52YXMpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSgnI0Y4RjhGOCcpO1xuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKDQgKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIHRoaXMubWFqb3JSb2Fkcy5kcmF3KGNhbnZhcyk7XG5cbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKCcjRkFGQTdBJyk7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgoNSAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcbiAgICAgICAgdGhpcy5tYWluUm9hZHMuZHJhdyhjYW52YXMpO1xuICAgICAgICB0aGlzLmNvYXN0bGluZS5kcmF3KGNhbnZhcyk7XG5cbiAgICAgICAgLy8gQ29hc3RcbiAgICAgICAgLy8gY2FudmFzLnNldFN0cm9rZVN0eWxlKCcjMDIwMjAyJyk7XG4gICAgICAgIC8vIGNhbnZhcy5zZXRMaW5lV2lkdGgoMSk7XG4gICAgICAgIC8vIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5jb2FzdC5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKSk7XG5cbiAgICAgICAgLy8gY2FudmFzLnNldEZpbGxTdHlsZSgncmVkJyk7XG4gICAgICAgIC8vIHRoaXMuaW50ZXJzZWN0aW9ucy5mb3JFYWNoKHYgPT5cbiAgICAgICAgLy8gICAgIGNhbnZhcy5kcmF3U3F1YXJlKHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSksIDIpKTtcbiAgICB9XG5cbiAgICByb2Fkc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWpvclJvYWRzLnJvYWRzRW1wdHkoKVxuICAgICAgICAgICAgJiYgdGhpcy5taW5vclJvYWRzLnJvYWRzRW1wdHkoKVxuICAgICAgICAgICAgJiYgdGhpcy5tYWluUm9hZHMucm9hZHNFbXB0eSgpXG4gICAgICAgICAgICAmJiB0aGlzLmNvYXN0bGluZS5yb2Fkc0VtcHR5KCk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCByb3VnaCBmcm9tICdyb3VnaGpzJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBDYW52YXNXcmFwcGVyIGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3VnaENhbnZhcyBleHRlbmRzIENhbnZhc1dyYXBwZXIge1xuICAgIHByaXZhdGUgcmM6IFJvdWdoQ2FudmFzO1xuXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGU9MSwgcmVzaXplVG9XaW5kb3c9dHJ1ZSkge1xuICAgICAgICBzdXBlcihjYW52YXMsIHNjYWxlLCByZXNpemVUb1dpbmRvdyk7XG4gICAgICAgIGNvbnN0IHJjID0gcm91Z2guY2FudmFzKGNhbnZhcyk7XG4gICAgICAgIC8vIHRoaXMucmMgPSByYztcbiAgICB9XG5cbiAgICBcbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgQ2FudmFzV3JhcHBlciBmcm9tICcuL2NhbnZhc193cmFwcGVyJztcbmltcG9ydCBEb21haW5Db250cm9sbGVyIGZyb20gJy4vZG9tYWluX2NvbnRyb2xsZXInO1xuaW1wb3J0IERyYWdDb250cm9sbGVyIGZyb20gJy4vZHJhZ19jb250cm9sbGVyJztcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuLi9pbXBsL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQge05vaXNlUGFyYW1zfSBmcm9tICcuLi9pbXBsL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQge0Jhc2lzRmllbGR9IGZyb20gJy4uL2ltcGwvYmFzaXNfZmllbGQnO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbnNvckZpZWxkR1VJIGV4dGVuZHMgVGVuc29yRmllbGQge1xuICAgIHByaXZhdGUgVEVOU09SX0xJTkVfRElBTUVURVIgPSAyMDtcbiAgICBwcml2YXRlIFRFTlNPUl9TUEFXTl9TQ0FMRSA9IDAuNzsgIC8vIEhvdyBtdWNoIHRvIHNocmluayB3b3JsZERpbWVuc2lvbnMgdG8gZmluZCBzcGF3biBwb2ludFxuICAgIHByaXZhdGUgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3VpRm9sZGVyOiBkYXQuR1VJLCBwcml2YXRlIGRyYWdDb250cm9sbGVyOiBEcmFnQ29udHJvbGxlcixcbiAgICAgICAgcHVibGljIGRyYXdDZW50cmU6IGJvb2xlYW4sIG5vaXNlUGFyYW1zOiBOb2lzZVBhcmFtcykge1xuICAgICAgICBzdXBlcihub2lzZVBhcmFtcyk7XG4gICAgICAgIC8vIEZvciBjdXN0b20gbmFtaW5nIG9mIGd1aSBidXR0b25zXG4gICAgICAgIGNvbnN0IHRlbnNvckZpZWxkR3VpT2JqID0ge1xuICAgICAgICAgICAgcmVzZXQ6ICgpOiB2b2lkID0+IHRoaXMucmVzZXQoKSxcbiAgICAgICAgICAgIHNldFJlY29tbWVuZGVkOiAoKTogdm9pZCA9PiB0aGlzLnNldFJlY29tbWVuZGVkKCksXG4gICAgICAgICAgICBhZGRSYWRpYWw6ICgpOiB2b2lkID0+IHRoaXMuYWRkUmFkaWFsUmFuZG9tKCksXG4gICAgICAgICAgICBhZGRHcmlkOiAoKTogdm9pZCA9PiB0aGlzLmFkZEdyaWRSYW5kb20oKSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdyZXNldCcpO1xuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdzZXRSZWNvbW1lbmRlZCcpO1xuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdhZGRSYWRpYWwnKTtcbiAgICAgICAgdGhpcy5ndWlGb2xkZXIuYWRkKHRlbnNvckZpZWxkR3VpT2JqLCAnYWRkR3JpZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDQgR3JpZHMsIG9uZSByYWRpYWxcbiAgICAgKi9cbiAgICBzZXRSZWNvbW1lbmRlZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucy5tdWx0aXBseVNjYWxhcih0aGlzLlRFTlNPUl9TUEFXTl9TQ0FMRSk7XG4gICAgICAgIGNvbnN0IG5ld09yaWdpbiA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnNcbiAgICAgICAgICAgIC5tdWx0aXBseVNjYWxhcigoMSAtIHRoaXMuVEVOU09SX1NQQVdOX1NDQUxFKSAvIDIpXG4gICAgICAgICAgICAuYWRkKHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4pO1xuICAgICAgICB0aGlzLmFkZEdyaWRBdExvY2F0aW9uKG5ld09yaWdpbik7XG4gICAgICAgIHRoaXMuYWRkR3JpZEF0TG9jYXRpb24obmV3T3JpZ2luLmNsb25lKCkuYWRkKHNpemUpKTtcbiAgICAgICAgdGhpcy5hZGRHcmlkQXRMb2NhdGlvbihuZXdPcmlnaW4uY2xvbmUoKS5hZGQobmV3IFZlY3RvcihzaXplLngsIDApKSk7XG4gICAgICAgIHRoaXMuYWRkR3JpZEF0TG9jYXRpb24obmV3T3JpZ2luLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IoMCwgc2l6ZS55KSkpO1xuICAgICAgICB0aGlzLmFkZFJhZGlhbFJhbmRvbSgpO1xuICAgIH1cblxuICAgIGFkZFJhZGlhbFJhbmRvbSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLng7XG4gICAgICAgIHRoaXMuYWRkUmFkaWFsKHRoaXMucmFuZG9tTG9jYXRpb24oKSxcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2Uod2lkdGgvMTAsIHdpZHRoLzUpLCAgLy8gU2l6ZVxuICAgICAgICAgICAgVXRpbC5yYW5kb21SYW5nZSg1MCkpOyAgLy8gRGVjYXlcbiAgICB9XG5cbiAgICBhZGRHcmlkUmFuZG9tKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFkZEdyaWRBdExvY2F0aW9uKHRoaXMucmFuZG9tTG9jYXRpb24oKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRHcmlkQXRMb2NhdGlvbihsb2NhdGlvbjogVmVjdG9yKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucy54O1xuICAgICAgICB0aGlzLmFkZEdyaWQobG9jYXRpb24sXG4gICAgICAgICAgICBVdGlsLnJhbmRvbVJhbmdlKHdpZHRoLzQsIHdpZHRoKSwgIC8vIFNpemVcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2UoNTApLCAgLy8gRGVjYXlcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2UoTWF0aC5QSS8yKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV29ybGQtc3BhY2UgcmFuZG9tIGxvY2F0aW9uIGZvciB0ZW5zb3IgZmllbGQgc3Bhd25cbiAgICAgKiBTYW1wbGVkIGZyb20gbWlkZGxlIG9mIHNjcmVlbiAoc2hydW5rIHJlY3RhbmdsZSlcbiAgICAgKi9cbiAgICBwcml2YXRlIHJhbmRvbUxvY2F0aW9uKCk6IFZlY3RvciB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLm11bHRpcGx5U2NhbGFyKHRoaXMuVEVOU09SX1NQQVdOX1NDQUxFKTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBuZXcgVmVjdG9yKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpLm11bHRpcGx5KHNpemUpO1xuICAgICAgICBjb25zdCBuZXdPcmlnaW4gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLm11bHRpcGx5U2NhbGFyKCgxIC0gdGhpcy5URU5TT1JfU1BBV05fU0NBTEUpIC8gMik7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5hZGQodGhpcy5kb21haW5Db250cm9sbGVyLm9yaWdpbikuYWRkKG5ld09yaWdpbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDcm9zc0xvY2F0aW9ucygpOiBWZWN0b3JbXSB7XG4gICAgICAgIC8vIEdldHMgZ3JpZCBvZiBwb2ludHMgZm9yIHZlY3RvciBmaWVsZCB2aXMgaW4gd29ybGQgc3BhY2VcbiAgICAgICAgY29uc3QgZGlhbWV0ZXIgPSB0aGlzLlRFTlNPUl9MSU5FX0RJQU1FVEVSIC8gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb207XG4gICAgICAgIGNvbnN0IHdvcmxkRGltZW5zaW9ucyA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnM7XG4gICAgICAgIGNvbnN0IG5Ib3IgPSBNYXRoLmNlaWwod29ybGREaW1lbnNpb25zLnggLyBkaWFtZXRlcikgKyAxOyAvLyBQcmV2ZW50IHBvcC1pblxuICAgICAgICBjb25zdCBuVmVyID0gTWF0aC5jZWlsKHdvcmxkRGltZW5zaW9ucy55IC8gZGlhbWV0ZXIpICsgMTtcbiAgICAgICAgY29uc3Qgb3JpZ2luWCA9IGRpYW1ldGVyICogTWF0aC5mbG9vcih0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLnggLyBkaWFtZXRlcik7XG4gICAgICAgIGNvbnN0IG9yaWdpblkgPSBkaWFtZXRlciAqIE1hdGguZmxvb3IodGhpcy5kb21haW5Db250cm9sbGVyLm9yaWdpbi55IC8gZGlhbWV0ZXIpO1xuXG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSBuSG9yOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDw9IG5WZXI7IHkrKykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKG5ldyBWZWN0b3Iob3JpZ2luWCArICh4ICogZGlhbWV0ZXIpLCBvcmlnaW5ZICsgKHkgKiBkaWFtZXRlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUZW5zb3JMaW5lKHBvaW50OiBWZWN0b3IsIHRlbnNvclY6IFZlY3Rvcik6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQb2ludCA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHBvaW50LmNsb25lKCkpO1xuXG4gICAgICAgIGNvbnN0IGRpZmYgPSB0ZW5zb3JWLm11bHRpcGx5U2NhbGFyKHRoaXMuVEVOU09SX0xJTkVfRElBTUVURVIgLyAyKTsgIC8vIEFzc3VtZXMgbm9ybWFsaXNlZFxuICAgICAgICBjb25zdCBzdGFydCA9IHRyYW5zZm9ybWVkUG9pbnQuY2xvbmUoKS5zdWIoZGlmZik7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRyYW5zZm9ybWVkUG9pbnQuY2xvbmUoKS5hZGQoZGlmZik7XG4gICAgICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG4gICAgfVxuXG4gICAgZHJhdyhjYW52YXM6IENhbnZhc1dyYXBwZXIsIGZvcmNlRHJhdz1mYWxzZSk6IHZvaWQge1xuICAgICAgICAvLyBEcmF3IHRlbnNvciBmaWVsZFxuICAgICAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKCd3aGl0ZScpO1xuICAgICAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgxKTtcbiAgICAgICAgICAgIGNvbnN0IHRlbnNvclBvaW50cyA9IHRoaXMuZ2V0Q3Jvc3NMb2NhdGlvbnMoKTtcbiAgICAgICAgICAgIHRlbnNvclBvaW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLnNhbXBsZVBvaW50KHApO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5nZXRUZW5zb3JMaW5lKHAsIHQuZ2V0TWFqb3IoKSkpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5nZXRUZW5zb3JMaW5lKHAsIHQuZ2V0TWlub3IoKSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgY2VudHJlIHBvaW50cyBvZiBmaWVsZHNcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYXdDZW50cmUpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuc2V0RmlsbFN0eWxlKCdyZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENlbnRyZVBvaW50cygpLmZvckVhY2godiA9PlxuICAgICAgICAgICAgICAgICAgICBjYW52YXMuZHJhd1NxdWFyZSh0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2KSwgNykpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBhZGRGaWVsZChmaWVsZDogQmFzaXNGaWVsZCk6IHZvaWQge1xuICAgICAgICBzdXBlci5hZGRGaWVsZChmaWVsZCk7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZ3VpRm9sZGVyLmFkZEZvbGRlcihgJHtmaWVsZC5GT0xERVJfTkFNRX1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZ1bmN0aW9uIHRvIGRlcmVnaXN0ZXIgZnJvbSBkcmFnIGNvbnRyb2xsZXJcbiAgICAgICAgY29uc3QgZGVyZWdpc3RlckRyYWcgPSB0aGlzLmRyYWdDb250cm9sbGVyLnJlZ2lzdGVyKFxuICAgICAgICAgICAgKCkgPT4gZmllbGQuY2VudHJlLCBmaWVsZC5kcmFnTW92ZUxpc3RlbmVyLmJpbmQoZmllbGQpKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlRmllbGRPYmogPSB7cmVtb3ZlOiAoKTogdm9pZCA9PiB0aGlzLnJlbW92ZUZpZWxkR1VJLmJpbmQodGhpcykoZmllbGQsIGZvbGRlciwgZGVyZWdpc3RlckRyYWcpfTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdpdmUgZGF0IGd1aSByZW1vdmVGaWVsZCBidXR0b25cbiAgICAgICAgZm9sZGVyLmFkZChyZW1vdmVGaWVsZE9iaiwgJ3JlbW92ZScpO1xuICAgICAgICBmaWVsZC5zZXRHdWkoZm9sZGVyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbW92ZUZpZWxkR1VJKGZpZWxkOiBCYXNpc0ZpZWxkLCBmb2xkZXI6IGRhdC5HVUksIGRlcmVnaXN0ZXJEcmFnOiAoKCkgPT4gdm9pZCkpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlRmllbGQoZmllbGQpO1xuICAgICAgICB0aGlzLmd1aUZvbGRlci5yZW1vdmVGb2xkZXIoZm9sZGVyKTtcbiAgICAgICAgLy8gRGVyZWdpc3RlciBmcm9tIGRyYWcgY29udHJvbGxlclxuICAgICAgICBkZXJlZ2lzdGVyRHJhZygpO1xuICAgIH1cblxuICAgIHJlc2V0KCk6IHZvaWQge1xuICAgICAgICAvLyBUT0RPIGtpbmQgb2YgaGFja3kgLSBjYWxsaW5nIHJlbW92ZSBjYWxsYmFja3MgZnJvbSBndWkgb2JqZWN0LCBzaG91bGQgc3RvcmUgY2FsbGJhY2tzXG4gICAgICAgIC8vIGluIGFkZGZpZWxkIGFuZCBjYWxsIHRoZW0gKHJlcXVpcmVzIG1ha2luZyBzdXJlIHRoZXkncmUgaWRlbXBvdGVudClcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZEZvbGRlck5hbWUgaW4gdGhpcy5ndWlGb2xkZXIuX19mb2xkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEZvbGRlciA9IHRoaXMuZ3VpRm9sZGVyLl9fZm9sZGVyc1tmaWVsZEZvbGRlck5hbWVdO1xuICAgICAgICAgICAgKGZpZWxkRm9sZGVyLl9fY29udHJvbGxlcnNbMF0gYXMgYW55KS5pbml0aWFsVmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLnJlc2V0KCk7XG4gICAgfVxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBSYW5kb21SYW5nZSB7XG4gICAgbWluPzogbnVtYmVyLFxuICAgIG1heDogbnVtYmVyLFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVdGlsIHtcbiAgICAvLyBNdXN0IG1hdGNoIHN0eWxlLmNzc1xuICAgIHN0YXRpYyByZWFkb25seSBDQU5WQVNfSUQgPSAnbWFwLWNhbnZhcyc7XG4gICAgc3RhdGljIHJlYWRvbmx5IElNR19DQU5WQVNfSUQgPSAnaW1nLWNhbnZhcyc7XG5cbiAgICBzdGF0aWMgdXBkYXRlR3VpKGd1aTogZGF0LkdVSSk6IHZvaWQge1xuICAgICAgICBpZiAoZ3VpLl9fY29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgIGd1aS5fX2NvbnRyb2xsZXJzLmZvckVhY2goYyA9PiBjLnVwZGF0ZURpc3BsYXkoKSk7ICAgIFxuICAgICAgICB9XG4gICAgICAgIGlmIChndWkuX19mb2xkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBmb2xkZXJOYW1lIGluIGd1aS5fX2ZvbGRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUd1aShndWkuX19mb2xkZXJzW2ZvbGRlck5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmVBbGxGb2xkZXJzKGd1aTogZGF0LkdVSSkge1xuICAgICAgICBpZiAoZ3VpLl9fZm9sZGVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgZm9sZGVyTmFtZSBpbiBndWkuX19mb2xkZXJzKSB7XG4gICAgICAgICAgICAgICAgZ3VpLnJlbW92ZUZvbGRlcihndWkuX19mb2xkZXJzW2ZvbGRlck5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByYW5kb21SYW5nZShtYXg6IG51bWJlciwgbWluPTApIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvciB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHg6IG51bWJlciwgcHVibGljIHk6IG51bWJlcikge31cblxuICAgIHN0YXRpYyB6ZXJvVmVjdG9yKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIDApO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tU2NhbGFyKHM6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHMsIHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIC1waSB0byBwaVxuICAgICAqL1xuICAgIHN0YXRpYyBhbmdsZUJldHdlZW4odjE6IFZlY3RvciwgdjI6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIC8vIC0ycGkgdG8gMnBpXG4gICAgICAgIGxldCBhbmdsZUJldHdlZW4gPSB2MS5hbmdsZSgpIC0gdjIuYW5nbGUoKTtcbiAgICAgICAgaWYgKGFuZ2xlQmV0d2VlbiA+IE1hdGguUEkpIHtcbiAgICAgICAgICAgIGFuZ2xlQmV0d2VlbiAtPSAyICogTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmdsZUJldHdlZW4gPD0gLU1hdGguUEkpIHtcbiAgICAgICAgICAgIGFuZ2xlQmV0d2VlbiArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5nbGVCZXR3ZWVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgYSBwb2ludCBsaWVzIHRvIHRoZSBsZWZ0IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSAge1ZlY3Rvcn0gbGluZVBvaW50ICAgICBQb2ludCBvbiB0aGUgbGluZVxuICAgICAqIEBwYXJhbSAge1ZlY3Rvcn0gbGluZURpcmVjdGlvbiBcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IHBvaW50XG4gICAgICogQHJldHVybiB7VmVjdG9yfSAgICAgICAgICAgICAgIHRydWUgaWYgbGVmdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIGlzTGVmdChsaW5lUG9pbnQ6IFZlY3RvciwgbGluZURpcmVjdGlvbjogVmVjdG9yLCBwb2ludDogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHBlcnBlbmRpY3VsYXJWZWN0b3IgPSBuZXcgVmVjdG9yKGxpbmVEaXJlY3Rpb24ueSwgLWxpbmVEaXJlY3Rpb24ueCk7XG4gICAgICAgIHJldHVybiBwb2ludC5jbG9uZSgpLnN1YihsaW5lUG9pbnQpLmRvdChwZXJwZW5kaWN1bGFyVmVjdG9yKSA8IDA7XG4gICAgfVxuXG4gICAgYWRkKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICAgIHRoaXMueSArPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIGluIHJhZGlhbnMgdG8gcG9zaXRpdmUgeC1heGlzIGJldHdlZW4gLXBpIGFuZCBwaVxuICAgICAqL1xuICAgIGFuZ2xlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuXG4gICAgY29weSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY3Jvc3ModjogVmVjdG9yKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcbiAgICB9XG5cbiAgICBkaXN0YW5jZVRvKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh2KSk7XG4gICAgfVxuXG4gICAgZGlzdGFuY2VUb1NxdWFyZWQgKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy54IC0gdi54XG4gICAgICAgIGNvbnN0IGR5ID0gdGhpcy55IC0gdi55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuXG4gICAgZGl2aWRlKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIGlmICh2LnggPT09IDAgfHwgdi55ID09PSAwKSB7XG4gICAgICAgICAgICBsb2cud2FybihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCAvPSB2Lng7XG4gICAgICAgIHRoaXMueSAvPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRpdmlkZVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHMpO1xuICAgIH1cblxuICAgIGRvdCh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuICAgIH1cblxuICAgIGVxdWFscyh2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICgodi54ID09PSB0aGlzLngpICYmICh2LnkgPT09IHRoaXMueSkpO1xuICAgIH1cblxuICAgIGxlbmd0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSk7XG4gICAgfVxuXG4gICAgbGVuZ3RoU3EoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcbiAgICB9XG5cbiAgICBtdWx0aXBseSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKj0gdi54O1xuICAgICAgICB0aGlzLnkgKj0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtdWx0aXBseVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKj0gcztcbiAgICAgICAgdGhpcy55ICo9IHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG5lZ2F0ZSgpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigtMSk7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplKCk6IFZlY3RvciB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJaZXJvIFZlY3RvclwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgaW4gcmFkaWFuc1xuICAgICAqL1xuICAgIHJvdGF0ZUFyb3VuZChjZW50ZXI6IFZlY3RvciwgYW5nbGU6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKVxuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMueCAtIGNlbnRlci54O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cbiAgICAgICAgdGhpcy54ID0geCAqIGNvcyAtIHkgKiBzaW4gKyBjZW50ZXIueDtcbiAgICAgICAgdGhpcy55ID0geCAqIHNpbiArIHkgKiBjb3MgKyBjZW50ZXIueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0KHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRYKHg6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldFkoeTogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0TGVuZ3RoIChsZW5ndGg6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG4gICAgfVxuXG4gICAgc3ViKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueCAtPSB2Lng7XG4gICAgICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbiJdfQ==
