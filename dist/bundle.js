(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// https://d3js.org/d3-quadtree/ v1.0.7 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function tree_add(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

exports.quadtree = quadtree;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],2:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.dat = {})));
}(this, (function (exports) { 'use strict';

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (!this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function ()        {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function ()        {
      dom.addClass(this, 'drag').bind(window, 'touchend', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller,                                   {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};

exports.color = color;
exports.controllers = controllers;
exports.dom = dom$1;
exports.gui = gui;
exports.GUI = GUI$1;
exports['default'] = index;

Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],3:[function(require,module,exports){
(function (global){
/* interact.js 1.9.8 | https://raw.github.com/taye/interact.js/master/LICENSE */
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).interact=t()}}(function(){function t(e){var n;return function(t){return n||e(n={exports:{},parent:t},n.exports),n.exports}}var k=t(function(t,e){"use strict";function a(t){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.Interactable=void 0;var u=r(S),l=n(C),s=n(V),c=n(ct),f=r(w),p=n(ft),i=n(bt),d=m({});function n(t){return t&&t.__esModule?t:{default:t}}function v(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return v=function(){return t},t}function r(t){if(t&&t.__esModule)return t;if(null===t||"object"!==a(t)&&"function"!=typeof t)return{default:t};var e=v();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function o(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function y(t,e,n){return e&&o(t.prototype,e),n&&o(t,n),t}function h(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var g=function(){function o(t,e,n,r){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),this._scopeEvents=r,h(this,"options",void 0),h(this,"_actions",void 0),h(this,"target",void 0),h(this,"events",new i.default),h(this,"_context",void 0),h(this,"_win",void 0),h(this,"_doc",void 0),this._actions=e.actions,this.target=t,this._context=e.context||n,this._win=(0,O.getWindow)((0,$.trySelector)(t)?this._context:t),this._doc=this._win.document,this.set(e)}return y(o,[{key:"_defaults",get:function(){return{base:{},perAction:{},actions:{}}}}]),y(o,[{key:"setOnEvents",value:function(t,e){return f.func(e.onstart)&&this.on("".concat(t,"start"),e.onstart),f.func(e.onmove)&&this.on("".concat(t,"move"),e.onmove),f.func(e.onend)&&this.on("".concat(t,"end"),e.onend),f.func(e.oninertiastart)&&this.on("".concat(t,"inertiastart"),e.oninertiastart),this}},{key:"updatePerActionListeners",value:function(t,e,n){(f.array(e)||f.object(e))&&this.off(t,e),(f.array(n)||f.object(n))&&this.on(t,n)}},{key:"setPerAction",value:function(t,e){var n=this._defaults;for(var r in e){var o=r,i=this.options[t],a=e[o];"listeners"===o&&this.updatePerActionListeners(t,i.listeners,a),f.array(a)?i[o]=u.from(a):f.plainObject(a)?(i[o]=(0,c.default)(i[o]||{},(0,s.default)(a)),f.object(n.perAction[o])&&"enabled"in n.perAction[o]&&(i[o].enabled=!1!==a.enabled)):f.bool(a)&&f.object(n.perAction[o])?i[o].enabled=a:i[o]=a}}},{key:"getRect",value:function(t){return t=t||(f.element(this.target)?this.target:null),f.string(this.target)&&(t=t||this._context.querySelector(this.target)),(0,$.getElementRect)(t)}},{key:"rectChecker",value:function(t){return f.func(t)?(this.getRect=t,this):null===t?(delete this.getRect,this):this.getRect}},{key:"_backCompatOption",value:function(t,e){if((0,$.trySelector)(e)||f.object(e)){for(var n in this.options[t]=e,this._actions.map)this.options[n][t]=e;return this}return this.options[t]}},{key:"origin",value:function(t){return this._backCompatOption("origin",t)}},{key:"deltaSource",value:function(t){return"page"===t||"client"===t?(this.options.deltaSource=t,this):this.options.deltaSource}},{key:"context",value:function(){return this._context}},{key:"inContext",value:function(t){return this._context===t.ownerDocument||(0,$.nodeContains)(this._context,t)}},{key:"testIgnoreAllow",value:function(t,e,n){return!this.testIgnore(t.ignoreFrom,e,n)&&this.testAllow(t.allowFrom,e,n)}},{key:"testAllow",value:function(t,e,n){return!t||!!f.element(n)&&(f.string(t)?(0,$.matchesUpTo)(n,t,e):!!f.element(t)&&(0,$.nodeContains)(t,n))}},{key:"testIgnore",value:function(t,e,n){return!(!t||!f.element(n))&&(f.string(t)?(0,$.matchesUpTo)(n,t,e):!!f.element(t)&&(0,$.nodeContains)(t,n))}},{key:"fire",value:function(t){return this.events.fire(t),this}},{key:"_onOff",value:function(t,e,n,r){f.object(e)&&!f.array(e)&&(r=n,n=null);var o="on"===t?"add":"remove",i=(0,p.default)(e,n);for(var a in i){"wheel"===a&&(a=l.default.wheelEvent);for(var u=0;u<i[a].length;u++){var s=i[a][u];(0,d.isNonNativeEvent)(a,this._actions)?this.events[t](a,s):f.string(this.target)?this._scopeEvents["".concat(o,"Delegate")](this.target,this._context,a,s,r):this._scopeEvents[o](this.target,a,s,r)}}return this}},{key:"on",value:function(t,e,n){return this._onOff("on",t,e,n)}},{key:"off",value:function(t,e,n){return this._onOff("off",t,e,n)}},{key:"set",value:function(t){var e=this._defaults;for(var n in f.object(t)||(t={}),this.options=(0,s.default)(e.base),this._actions.methodDict){var r=n,o=this._actions.methodDict[r];this.options[r]={},this.setPerAction(r,(0,c.default)((0,c.default)({},e.perAction),e.actions[r])),this[o](t[r])}for(var i in t)f.func(this[i])&&this[i](t[i]);return this}},{key:"unset",value:function(){if(f.string(this.target))for(var t in this._scopeEvents.delegatedEvents)for(var e=this._scopeEvents.delegatedEvents[t],n=e.length-1;0<=n;n--){var r=e[n],o=r.selector,i=r.context,a=r.listeners;o===this.target&&i===this._context&&e.splice(n,1);for(var u=a.length-1;0<=u;u--)this._scopeEvents.removeDelegate(this.target,this._context,t,a[u][0],a[u][1])}else this._scopeEvents.remove(this.target,"all")}}]),o}(),b=e.Interactable=g;e.default=b}),m=t(function(t,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNonNativeEvent=function(t,e){if(e.phaselessTypes[t])return!0;for(var n in e.map)if(0===t.indexOf(n)&&t.substr(n.length)in e.phases)return!0;return!1},e.initScope=M,e.Scope=e.default=void 0;var n=d(D),r=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==v(t)&&"function"!=typeof t)return{default:t};var e=p();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),o=d(bt),i=d(We),a=d(T({})),u=d(k({})),s=d(Ze),l=d(ze),c=d(cn),f=d(E({}));function p(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return p=function(){return t},t}function d(t){return t&&t.__esModule?t:{default:t}}function v(t){return(v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function y(t,e){return!e||"object"!==v(e)&&"function"!=typeof e?function(t){if(void 0!==t)return t;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(t):e}function h(t,e,n){return(h="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=g(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function g(t){return(g=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function b(t,e){return(b=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function m(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function O(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function w(t,e,n){return e&&O(t.prototype,e),n&&O(t,n),t}function _(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var P=r.win,x=r.browser,S=r.raf,j=function(){function t(){var e=this;m(this,t),_(this,"id","__interact_scope_".concat(Math.floor(100*Math.random()))),_(this,"isInitialized",!1),_(this,"listenerMaps",[]),_(this,"browser",x),_(this,"utils",r),_(this,"defaults",r.clone(l.default)),_(this,"Eventable",o.default),_(this,"actions",{map:{},phases:{start:!0,move:!0,end:!0},methodDict:{},phaselessTypes:{}}),_(this,"interactStatic",new a.default(this)),_(this,"InteractEvent",i.default),_(this,"Interactable",void 0),_(this,"interactables",new s.default(this)),_(this,"_win",void 0),_(this,"document",void 0),_(this,"window",void 0),_(this,"documents",[]),_(this,"_plugins",{list:[],map:{}}),_(this,"onWindowUnload",function(t){return e.removeDocument(t.target)});var n=this;this.Interactable=function(){function e(){return m(this,e),y(this,g(e).apply(this,arguments))}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&b(t,e)}(e,u["default"]),w(e,[{key:"set",value:function(t){return h(g(e.prototype),"set",this).call(this,t),n.fire("interactable:set",{options:t,interactable:this}),this}},{key:"unset",value:function(){h(g(e.prototype),"unset",this).call(this),n.interactables.list.splice(n.interactables.list.indexOf(this),1),n.fire("interactable:unset",{interactable:this})}},{key:"_defaults",get:function(){return n.defaults}}]),e}()}return w(t,[{key:"addListeners",value:function(t,e){this.listenerMaps.push({id:e,map:t})}},{key:"fire",value:function(t,e){for(var n=0;n<this.listenerMaps.length;n++){var r=this.listenerMaps[n].map[t];if(r&&!1===r(e,this,t))return!1}}},{key:"init",value:function(t){return this.isInitialized?this:M(this,t)}},{key:"pluginIsInstalled",value:function(t){return this._plugins.map[t.id]||-1!==this._plugins.list.indexOf(t)}},{key:"usePlugin",value:function(t,e){if(this.pluginIsInstalled(t))return this;if(t.id&&(this._plugins.map[t.id]=t),this._plugins.list.push(t),t.install&&t.install(this,e),t.listeners&&t.before){for(var n=0,r=this.listenerMaps.length,o=t.before.reduce(function(t,e){return t[e]=!0,t},{});n<r;n++){if(o[this.listenerMaps[n].id])break}this.listenerMaps.splice(n,0,{id:t.id,map:t.listeners})}else t.listeners&&this.listenerMaps.push({id:t.id,map:t.listeners});return this}},{key:"addDocument",value:function(t,e){if(-1!==this.getDocIndex(t))return!1;var n=P.getWindow(t);e=e?r.extend({},e):{},this.documents.push({doc:t,options:e}),this.events.documents.push(t),t!==this.document&&this.events.add(n,"unload",this.onWindowUnload),this.fire("scope:add-document",{doc:t,window:n,scope:this,options:e})}},{key:"removeDocument",value:function(t){var e=this.getDocIndex(t),n=P.getWindow(t),r=this.documents[e].options;this.events.remove(n,"unload",this.onWindowUnload),this.documents.splice(e,1),this.events.documents.splice(e,1),this.fire("scope:remove-document",{doc:t,window:n,scope:this,options:r})}},{key:"getDocIndex",value:function(t){for(var e=0;e<this.documents.length;e++)if(this.documents[e].doc===t)return e;return-1}},{key:"getDocOptions",value:function(t){var e=this.getDocIndex(t);return-1===e?null:this.documents[e].options}},{key:"now",value:function(){return(this.window.Date||Date).now()}}]),t}();function M(t,e){return t.isInitialized=!0,P.init(e),n.default.init(e),x.init(e),S.init(e),t.window=e,t.document=e.document,t.usePlugin(f.default),t.usePlugin(c.default),t}e.Scope=e.default=j}),E=t(function(t,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var _=n(C),u=n(D),P=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==c(t)&&"function"!=typeof t)return{default:t};var e=a();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(zt),s=n(En),l=n(Un),o=n(tr);n(m({}));function a(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return a=function(){return t},t}function n(t){return t&&t.__esModule?t:{default:t}}function c(t){return(c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function x(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function f(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function p(t,e){return!e||"object"!==c(e)&&"function"!=typeof e?function(t){if(void 0!==t)return t;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(t):e}function d(t){return(d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function v(t,e){return(v=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var y=["pointerDown","pointerMove","pointerUp","updatePointer","removePointer","windowBlur"];function h(O,w){return function(t){var e=w.interactions.list,n=P.getPointerType(t),r=x(P.getEventTargets(t),2),o=r[0],i=r[1],a=[];if(/^touch/.test(t.type)){w.prevTouchTime=w.now();for(var u=0;u<t.changedTouches.length;u++){s=t.changedTouches[u];var s,l={pointer:s,pointerId:P.getPointerId(s),pointerType:n,eventType:t.type,eventTarget:o,curEventTarget:i,scope:w},c=S(l);a.push([l.pointer,l.eventTarget,l.curEventTarget,c])}}else{var f=!1;if(!_.default.supportsPointerEvent&&/mouse/.test(t.type)){for(var p=0;p<e.length&&!f;p++)f="mouse"!==e[p].pointerType&&e[p].pointerIsDown;f=f||w.now()-w.prevTouchTime<500||0===t.timeStamp}if(!f){var d={pointer:t,pointerId:P.getPointerId(t),pointerType:n,eventType:t.type,curEventTarget:i,eventTarget:o,scope:w},v=S(d);a.push([d.pointer,d.eventTarget,d.curEventTarget,v])}}for(var y=0;y<a.length;y++){var h=x(a[y],4),g=h[0],b=h[1],m=h[2];h[3][O](g,t,b,m)}}}function S(t){var e=t.pointerType,n=t.scope,r={interaction:o.default.search(t),searchDetails:t};return n.fire("interactions:find",r),r.interaction||n.interactions.new({pointerType:e})}function r(t,e){var n=t.doc,r=t.scope,o=t.options,i=r.interactions.docEvents,a=r.events,u=a[e];for(var s in r.browser.isIOS&&!o.events&&(o.events={passive:!1}),a.delegatedEvents)u(n,s,a.delegateListener),u(n,s,a.delegateUseCapture,!0);for(var l=o&&o.events,c=0;c<i.length;c++){var f;f=i[c];u(n,f.type,f.listener,l)}}var i={id:"core/interactions",install:function(o){for(var t={},e=0;e<y.length;e++){var n;n=y[e];t[n]=h(n,o)}var r,i=_.default.pEventTypes;function a(){for(var t=0;t<o.interactions.list.length;t++){var e=o.interactions.list[t];if(e.pointerIsDown&&"touch"===e.pointerType&&!e._interacting)for(var n=function(){var n=e.pointers[r];o.documents.some(function(t){var e=t.doc;return(0,$.nodeContains)(e,n.downTarget)})||e.removePointer(n.pointer,n.event)},r=0;r<e.pointers.length;r++){n()}}}(r=u.default.PointerEvent?[{type:i.down,listener:a},{type:i.down,listener:t.pointerDown},{type:i.move,listener:t.pointerMove},{type:i.up,listener:t.pointerUp},{type:i.cancel,listener:t.pointerUp}]:[{type:"mousedown",listener:t.pointerDown},{type:"mousemove",listener:t.pointerMove},{type:"mouseup",listener:t.pointerUp},{type:"touchstart",listener:a},{type:"touchstart",listener:t.pointerDown},{type:"touchmove",listener:t.pointerMove},{type:"touchend",listener:t.pointerUp},{type:"touchcancel",listener:t.pointerUp}]).push({type:"blur",listener:function(t){for(var e=0;e<o.interactions.list.length;e++){o.interactions.list[e].documentBlur(t)}}}),o.prevTouchTime=0,o.Interaction=function(){function t(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),p(this,d(t).apply(this,arguments))}var e,n,r;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&v(t,e)}(t,s["default"]),e=t,(n=[{key:"_now",value:function(){return o.now()}},{key:"pointerMoveTolerance",get:function(){return o.interactions.pointerMoveTolerance},set:function(t){o.interactions.pointerMoveTolerance=t}}])&&f(e.prototype,n),r&&f(e,r),t}(),o.interactions={list:[],new:function(t){t.scopeFire=function(t,e){return o.fire(t,e)};var e=new o.Interaction(t);return o.interactions.list.push(e),e},listeners:t,docEvents:r,pointerMoveTolerance:1},o.usePlugin(l.default)},listeners:{"scope:add-document":function(t){return r(t,"add")},"scope:remove-document":function(t){return r(t,"remove")},"interactable:unset":function(t,e){for(var n=t.interactable,r=e.interactions.list.length-1;0<=r;r--){var o=e.interactions.list[r];o.interactable===n&&(o.stop(),e.fire("interactions:destroy",{interaction:o}),o.destroy(),2<e.interactions.list.length&&e.interactions.list.splice(r,1))}}},onDocSignal:r,doOnInteractions:h,methodNames:y};e.default=i}),T=t(function(t,e){"use strict";function a(t){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.InteractStatic=void 0;var n,r=(n=C)&&n.__esModule?n:{default:n},u=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==a(t)&&"function"!=typeof t)return{default:t};var e=l();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),s=m({});function l(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return l=function(){return t},t}function o(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function c(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var i=function(){function a(r){var o=this;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,a),this.scope=r,c(this,"getPointerAverage",u.pointer.pointerAverage),c(this,"getTouchBBox",u.pointer.touchBBox),c(this,"getTouchDistance",u.pointer.touchDistance),c(this,"getTouchAngle",u.pointer.touchAngle),c(this,"getElementRect",u.dom.getElementRect),c(this,"getElementClientRect",u.dom.getElementClientRect),c(this,"matchesSelector",u.dom.matchesSelector),c(this,"closest",u.dom.closest),c(this,"globalEvents",{}),c(this,"dynamicDrop",void 0),c(this,"version","1.9.8"),c(this,"interact",void 0);for(var t=this.constructor.prototype,e=function(t,e){var n=r.interactables.get(t,e);return n||((n=r.interactables.new(t,e)).events.global=o.globalEvents),n},n=0;n<Object.getOwnPropertyNames(this.constructor.prototype).length;n++){var i;i=Object.getOwnPropertyNames(this.constructor.prototype)[n];e[i]=t[i]}return u.extend(e,this),e.constructor=this.constructor,this.interact=e}var t,e,n;return t=a,(e=[{key:"use",value:function(t,e){return this.scope.usePlugin(t,e),this}},{key:"isSet",value:function(t,e){return!!this.scope.interactables.get(t,e&&e.context)}},{key:"on",value:function(t,e,n){if(u.is.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),u.is.array(t)){for(var r=0;r<t.length;r++){var o=t[r];this.on(o,e,n)}return this}if(u.is.object(t)){for(var i in t)this.on(i,t[i],e);return this}return(0,s.isNonNativeEvent)(t,this.scope.actions)?this.globalEvents[t]?this.globalEvents[t].push(e):this.globalEvents[t]=[e]:this.scope.events.add(this.scope.document,t,e,{options:n}),this}},{key:"off",value:function(t,e,n){if(u.is.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),u.is.array(t)){for(var r=0;r<t.length;r++){var o=t[r];this.off(o,e,n)}return this}if(u.is.object(t)){for(var i in t)this.off(i,t[i],e);return this}var a;(0,s.isNonNativeEvent)(t,this.scope.actions)?t in this.globalEvents&&-1!==(a=this.globalEvents[t].indexOf(e))&&this.globalEvents[t].splice(a,1):this.scope.events.remove(this.scope.document,t,e,n);return this}},{key:"debug",value:function(){return this.scope}},{key:"supportsTouch",value:function(){return r.default.supportsTouch}},{key:"supportsPointerEvent",value:function(){return r.default.supportsPointerEvent}},{key:"stop",value:function(){for(var t=0;t<this.scope.interactions.list.length;t++){this.scope.interactions.list[t].stop()}return this}},{key:"pointerMoveTolerance",value:function(t){return u.is.number(t)?(this.scope.interactions.pointerMoveTolerance=t,this):this.scope.interactions.pointerMoveTolerance}},{key:"addDocument",value:function(t,e){this.scope.addDocument(t,e)}},{key:"removeDocument",value:function(t){this.scope.removeDocument(t)}}])&&o(t.prototype,e),n&&o(t,n),a}(),f=e.InteractStatic=i;e.default=f}),e={};Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;e.default=function(t){return!(!t||!t.Window)&&t instanceof t.Window};var O={};Object.defineProperty(O,"__esModule",{value:!0}),O.init=i,O.getWindow=a,O.default=void 0;var n,r=(n=e)&&n.__esModule?n:{default:n};var o={realWindow:void 0,window:void 0,getWindow:a,init:i};function i(t){var e=(o.realWindow=t).document.createTextNode("");e.ownerDocument!==t.document&&"function"==typeof t.wrap&&t.wrap(e)===e&&(t=t.wrap(t)),o.window=t}function a(t){return(0,r.default)(t)?t:(t.ownerDocument||t).defaultView||o.window}"undefined"==typeof window?(o.window=void 0,o.realWindow=void 0):i(window),o.init=i;var u=o;O.default=u;var w={};Object.defineProperty(w,"__esModule",{value:!0}),w.array=w.plainObject=w.element=w.string=w.bool=w.number=w.func=w.object=w.docFrag=w.window=void 0;var s=c(e),l=c(O);function c(t){return t&&t.__esModule?t:{default:t}}function f(t){return(f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}w.window=function(t){return t===l.default.window||(0,s.default)(t)};w.docFrag=function(t){return p(t)&&11===t.nodeType};var p=function(t){return!!t&&"object"===f(t)};w.object=p;function d(t){return"function"==typeof t}w.func=d;w.number=function(t){return"number"==typeof t};w.bool=function(t){return"boolean"==typeof t};w.string=function(t){return"string"==typeof t};w.element=function(t){if(!t||"object"!==f(t))return!1;var e=l.default.getWindow(t)||l.default.window;return/object|function/.test(f(e.Element))?t instanceof e.Element:1===t.nodeType&&"string"==typeof t.nodeName};w.plainObject=function(t){return p(t)&&!!t.constructor&&/function Object\b/.test(t.constructor.toString())};w.array=function(t){return p(t)&&void 0!==t.length&&d(t.splice)};var v={};function y(t){return(y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(v,"__esModule",{value:!0}),v.default=void 0;var h=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==y(t)&&"function"!=typeof t)return{default:t};var e=g();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function g(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return g=function(){return t},t}function b(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.prepared.axis;"x"===n?(e.coords.cur.page.y=e.coords.start.page.y,e.coords.cur.client.y=e.coords.start.client.y,e.coords.velocity.client.y=0,e.coords.velocity.page.y=0):"y"===n&&(e.coords.cur.page.x=e.coords.start.page.x,e.coords.cur.client.x=e.coords.start.client.x,e.coords.velocity.client.x=0,e.coords.velocity.page.x=0)}}function _(t){var e=t.iEvent,n=t.interaction;if("drag"===n.prepared.name){var r=n.prepared.axis;if("x"===r||"y"===r){var o="x"===r?"y":"x";e.page[o]=n.coords.start.page[o],e.client[o]=n.coords.start.client[o],e.delta[o]=0}}}var P={id:"actions/drag",install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.draggable=P.draggable,e.map.drag=P,e.methodDict.drag="draggable",r.actions.drag=P.defaults},listeners:{"interactions:before-action-move":b,"interactions:action-resume":b,"interactions:action-move":_,"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.buttons,o=n.options.drag;if(o&&o.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(r&n.options.drag.mouseButtons)))return!(t.action={name:"drag",axis:"start"===o.lockAxis?o.startAxis:o.lockAxis})}},draggable:function(t){return h.object(t)?(this.options.drag.enabled=!1!==t.enabled,this.setPerAction("drag",t),this.setOnEvents("drag",t),/^(xy|x|y|start)$/.test(t.lockAxis)&&(this.options.drag.lockAxis=t.lockAxis),/^(xy|x|y)$/.test(t.startAxis)&&(this.options.drag.startAxis=t.startAxis),this):h.bool(t)?(this.options.drag.enabled=t,this):this.options.drag},beforeMove:b,move:_,defaults:{startAxis:"xy",lockAxis:"xy"},getCursor:function(){return"move"}},x=P;v.default=x;var S={};Object.defineProperty(S,"__esModule",{value:!0}),S.find=S.findIndex=S.from=S.merge=S.remove=S.contains=void 0;S.contains=function(t,e){return-1!==t.indexOf(e)};S.remove=function(t,e){return t.splice(t.indexOf(e),1)};function j(t,e){for(var n=0;n<e.length;n++){var r=e[n];t.push(r)}return t}S.merge=j;S.from=function(t){return j([],t)};function M(t,e){for(var n=0;n<t.length;n++)if(e(t[n],n,t))return n;return-1}S.findIndex=M;S.find=function(t,e){return t[M(t,e)]};var D={};Object.defineProperty(D,"__esModule",{value:!0}),D.default=void 0;var I={init:function(t){var e=t;I.document=e.document,I.DocumentFragment=e.DocumentFragment||z,I.SVGElement=e.SVGElement||z,I.SVGSVGElement=e.SVGSVGElement||z,I.SVGElementInstance=e.SVGElementInstance||z,I.Element=e.Element||z,I.HTMLElement=e.HTMLElement||I.Element,I.Event=e.Event,I.Touch=e.Touch||z,I.PointerEvent=e.PointerEvent||e.MSPointerEvent},document:null,DocumentFragment:null,SVGElement:null,SVGSVGElement:null,SVGElementInstance:null,Element:null,HTMLElement:null,Event:null,Touch:null,PointerEvent:null};function z(){}var A=I;D.default=A;var C={};function W(t){return(W="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(C,"__esModule",{value:!0}),C.default=void 0;var R=N(D),F=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==W(t)&&"function"!=typeof t)return{default:t};var e=Y();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w),X=N(O);function Y(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Y=function(){return t},t}function N(t){return t&&t.__esModule?t:{default:t}}var L={init:function(t){var e=R.default.Element,n=X.default.window.navigator;L.supportsTouch="ontouchstart"in t||F.func(t.DocumentTouch)&&R.default.document instanceof t.DocumentTouch,L.supportsPointerEvent=!1!==n.pointerEnabled&&!!R.default.PointerEvent,L.isIOS=/iP(hone|od|ad)/.test(n.platform),L.isIOS7=/iP(hone|od|ad)/.test(n.platform)&&/OS 7[^\d]/.test(n.appVersion),L.isIe9=/MSIE 9/.test(n.userAgent),L.isOperaMobile="Opera"===n.appName&&L.supportsTouch&&/Presto/.test(n.userAgent),L.prefixedMatchesSelector="matches"in e.prototype?"matches":"webkitMatchesSelector"in e.prototype?"webkitMatchesSelector":"mozMatchesSelector"in e.prototype?"mozMatchesSelector":"oMatchesSelector"in e.prototype?"oMatchesSelector":"msMatchesSelector",L.pEventTypes=L.supportsPointerEvent?R.default.PointerEvent===t.MSPointerEvent?{up:"MSPointerUp",down:"MSPointerDown",over:"mouseover",out:"mouseout",move:"MSPointerMove",cancel:"MSPointerCancel"}:{up:"pointerup",down:"pointerdown",over:"pointerover",out:"pointerout",move:"pointermove",cancel:"pointercancel"}:null,L.wheelEvent="onmousewheel"in R.default.document?"mousewheel":"wheel"},supportsTouch:null,supportsPointerEvent:null,isIOS7:null,isIOS:null,isIe9:null,isOperaMobile:null,prefixedMatchesSelector:null,pEventTypes:null,wheelEvent:null};var B=L;C.default=B;var V={};function q(t){return(q="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(V,"__esModule",{value:!0}),V.default=function t(e){var n={};for(var r in e){var o=e[r];G.plainObject(o)?n[r]=t(o):G.array(o)?n[r]=U.from(o):n[r]=o}return n};var U=K(S),G=K(w);function H(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return H=function(){return t},t}function K(t){if(t&&t.__esModule)return t;if(null===t||"object"!==q(t)&&"function"!=typeof t)return{default:t};var e=H();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}var $={};function Z(t){return(Z="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty($,"__esModule",{value:!0}),$.nodeContains=function(t,e){for(;e;){if(e===t)return!0;e=e.parentNode}return!1},$.closest=function(t,e){for(;tt.element(t);){if(at(t,e))return t;t=it(t)}return null},$.parentNode=it,$.matchesSelector=at,$.indexOfDeepestElement=function(t){var e,n,r=[],o=t[0],i=o?0:-1;for(e=1;e<t.length;e++){var a=t[e];if(a&&a!==o)if(o){if(a.parentNode!==a.ownerDocument)if(o.parentNode!==a.ownerDocument)if(a.parentNode!==o.parentNode){if(!r.length)for(var u=o,s=void 0;(s=ut(u))&&s!==u.ownerDocument;)r.unshift(u),u=s;var l=void 0;if(o instanceof Q.default.HTMLElement&&a instanceof Q.default.SVGElement&&!(a instanceof Q.default.SVGSVGElement)){if(a===o.parentNode)continue;l=a.ownerSVGElement}else l=a;for(var c=[];l.parentNode!==l.ownerDocument;)c.unshift(l),l=ut(l);for(n=0;c[n]&&c[n]===r[n];)n++;for(var f=[c[n-1],c[n],r[n]],p=f[0].lastChild;p;){if(p===f[1]){o=a,i=e,r=c;break}if(p===f[2])break;p=p.previousSibling}}else{var d=parseInt((0,et.getWindow)(o).getComputedStyle(o).zIndex,10)||0,v=parseInt((0,et.getWindow)(a).getComputedStyle(a).zIndex,10)||0;d<=v&&(o=a,i=e)}else o=a,i=e}else o=a,i=e}return i},$.matchesUpTo=function(t,e,n){for(;tt.element(t);){if(at(t,e))return!0;if((t=it(t))===n)return at(t,e)}return!1},$.getActualElement=function(t){return t instanceof Q.default.SVGElementInstance?t.correspondingUseElement:t},$.getScrollXY=st,$.getElementClientRect=lt,$.getElementRect=function(t){var e=lt(t);if(!J.default.isIOS7&&e){var n=st(et.default.getWindow(t));e.left+=n.x,e.right+=n.x,e.top+=n.y,e.bottom+=n.y}return e},$.getPath=function(t){var e=[];for(;t;)e.push(t),t=it(t);return e},$.trySelector=function(t){return!!tt.string(t)&&(Q.default.document.querySelector(t),!0)};var J=ot(C),Q=ot(D),tt=rt(w),et=rt(O);function nt(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return nt=function(){return t},t}function rt(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Z(t)&&"function"!=typeof t)return{default:t};var e=nt();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function ot(t){return t&&t.__esModule?t:{default:t}}function it(t){var e=t.parentNode;if(tt.docFrag(e)){for(;(e=e.host)&&tt.docFrag(e););return e}return e}function at(t,e){return et.default.window!==et.default.realWindow&&(e=e.replace(/\/deep\//g," ")),t[J.default.prefixedMatchesSelector](e)}var ut=function(t){return t.parentNode?t.parentNode:t.host};function st(t){return{x:(t=t||et.default.window).scrollX||t.document.documentElement.scrollLeft,y:t.scrollY||t.document.documentElement.scrollTop}}function lt(t){var e=t instanceof Q.default.SVGElement?t.getBoundingClientRect():t.getClientRects()[0];return e&&{left:e.left,right:e.right,top:e.top,bottom:e.bottom,width:e.width||e.right-e.left,height:e.height||e.bottom-e.top}}var ct={};Object.defineProperty(ct,"__esModule",{value:!0}),ct.default=function(t,e){for(var n in e)t[n]=e[n];return t};var ft={};function pt(t){return(pt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(ft,"__esModule",{value:!0}),ft.default=function n(e,r,o){o=o||{};yt.string(e)&&-1!==e.search(" ")&&(e=gt(e));if(yt.array(e))return e.reduce(function(t,e){return(0,vt.default)(t,n(e,r,o))},o);yt.object(e)&&(r=e,e="");if(yt.func(r))o[e]=o[e]||[],o[e].push(r);else if(yt.array(r))for(var t=0;t<r.length;t++){var i=r[t];n(e,i,o)}else if(yt.object(r))for(var a in r){var u=gt(a).map(function(t){return"".concat(e).concat(t)});n(u,r[a],o)}return o};var dt,vt=(dt=ct)&&dt.__esModule?dt:{default:dt},yt=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==pt(t)&&"function"!=typeof t)return{default:t};var e=ht();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function ht(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ht=function(){return t},t}function gt(t){return t.trim().split(/ +/)}var bt={};function mt(t){return(mt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(bt,"__esModule",{value:!0}),bt.default=void 0;var Ot=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==mt(t)&&"function"!=typeof t)return{default:t};var e=xt();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(S),wt=Pt(ct),_t=Pt(ft);function Pt(t){return t&&t.__esModule?t:{default:t}}function xt(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return xt=function(){return t},t}function St(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function jt(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function Mt(t,e){for(var n=0;n<e.length;n++){var r=e[n];if(t.immediatePropagationStopped)break;r(t)}}var kt=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),jt(this,"options",void 0),jt(this,"types",{}),jt(this,"propagationStopped",!1),jt(this,"immediatePropagationStopped",!1),jt(this,"global",void 0),this.options=(0,wt.default)({},t||{})}var t,n,r;return t=e,(n=[{key:"fire",value:function(t){var e,n=this.global;(e=this.types[t.type])&&Mt(t,e),!t.propagationStopped&&n&&(e=n[t.type])&&Mt(t,e)}},{key:"on",value:function(t,e){var n=(0,_t.default)(t,e);for(t in n)this.types[t]=Ot.merge(this.types[t]||[],n[t])}},{key:"off",value:function(t,e){var n=(0,_t.default)(t,e);for(t in n){var r=this.types[t];if(r&&r.length)for(var o=0;o<n[t].length;o++){var i=n[t][o],a=r.indexOf(i);-1!==a&&r.splice(a,1)}}}},{key:"getRect",value:function(){return null}}])&&St(t.prototype,n),r&&St(t,r),e}();bt.default=kt;var Et={};Object.defineProperty(Et,"__esModule",{value:!0}),Et.default=void 0;Et.default=function(t,e){return Math.sqrt(t*t+e*e)};var Tt={};function Dt(t,e){for(var n in e){var r=Dt.prefixedPropREs,o=!1;for(var i in r)if(0===n.indexOf(i)&&r[i].test(n)){o=!0;break}o||"function"==typeof e[n]||(t[n]=e[n])}return t}Object.defineProperty(Tt,"__esModule",{value:!0}),Tt.default=void 0,Dt.prefixedPropREs={webkit:/(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,moz:/(Pressure)$/};var It=Dt;Tt.default=It;var zt={};function At(t){return(At="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(zt,"__esModule",{value:!0}),zt.copyCoords=function(t,e){t.page=t.page||{},t.page.x=e.page.x,t.page.y=e.page.y,t.client=t.client||{},t.client.x=e.client.x,t.client.y=e.client.y,t.timeStamp=e.timeStamp},zt.setCoordDeltas=function(t,e,n){t.page.x=n.page.x-e.page.x,t.page.y=n.page.y-e.page.y,t.client.x=n.client.x-e.client.x,t.client.y=n.client.y-e.client.y,t.timeStamp=n.timeStamp-e.timeStamp},zt.setCoordVelocity=function(t,e){var n=Math.max(e.timeStamp/1e3,.001);t.page.x=e.page.x/n,t.page.y=e.page.y/n,t.client.x=e.client.x/n,t.client.y=e.client.y/n,t.timeStamp=n},zt.setZeroCoords=function(t){t.page.x=0,t.page.y=0,t.client.x=0,t.client.y=0},zt.isNativePointer=Vt,zt.getXY=qt,zt.getPageXY=Ut,zt.getClientXY=Gt,zt.getPointerId=function(t){return Xt.number(t.pointerId)?t.pointerId:t.identifier},zt.setCoords=function(t,e,n){var r=1<e.length?Kt(e):e[0],o={};Ut(r,o),t.page.x=o.x,t.page.y=o.y,Gt(r,o),t.client.x=o.x,t.client.y=o.y,t.timeStamp=n},zt.getTouchPair=Ht,zt.pointerAverage=Kt,zt.touchBBox=function(t){if(!(t.length||t.touches&&1<t.touches.length))return null;var e=Ht(t),n=Math.min(e[0].pageX,e[1].pageX),r=Math.min(e[0].pageY,e[1].pageY),o=Math.max(e[0].pageX,e[1].pageX),i=Math.max(e[0].pageY,e[1].pageY);return{x:n,y:r,left:n,top:r,right:o,bottom:i,width:o-n,height:i-r}},zt.touchDistance=function(t,e){var n=e+"X",r=e+"Y",o=Ht(t),i=o[0][n]-o[1][n],a=o[0][r]-o[1][r];return(0,Ft.default)(i,a)},zt.touchAngle=function(t,e){var n=e+"X",r=e+"Y",o=Ht(t),i=o[1][n]-o[0][n],a=o[1][r]-o[0][r];return 180*Math.atan2(a,i)/Math.PI},zt.getPointerType=function(t){return Xt.string(t.pointerType)?t.pointerType:Xt.number(t.pointerType)?[void 0,void 0,"touch","pen","mouse"][t.pointerType]:/touch/.test(t.type)||t instanceof Wt.default.Touch?"touch":"mouse"},zt.getEventTargets=function(t){var e=Xt.func(t.composedPath)?t.composedPath():t.path;return[Rt.getActualElement(e?e[0]:t.target),Rt.getActualElement(t.currentTarget)]},zt.newCoords=function(){return{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0}},zt.coordsToEvent=function(t){return{coords:t,get page(){return this.coords.page},get client(){return this.coords.client},get timeStamp(){return this.coords.timeStamp},get pageX(){return this.coords.page.x},get pageY(){return this.coords.page.y},get clientX(){return this.coords.client.x},get clientY(){return this.coords.client.y},get pointerId(){return this.coords.pointerId},get target(){return this.coords.target},get type(){return this.coords.type},get pointerType(){return this.coords.pointerType},get buttons(){return this.coords.buttons},preventDefault:function(){}}},Object.defineProperty(zt,"pointerExtend",{enumerable:!0,get:function(){return Yt.default}});var Ct=Bt(C),Wt=Bt(D),Rt=Lt($),Ft=Bt(Et),Xt=Lt(w),Yt=Bt(Tt);function Nt(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Nt=function(){return t},t}function Lt(t){if(t&&t.__esModule)return t;if(null===t||"object"!==At(t)&&"function"!=typeof t)return{default:t};var e=Nt();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function Bt(t){return t&&t.__esModule?t:{default:t}}function Vt(t){return t instanceof Wt.default.Event||t instanceof Wt.default.Touch}function qt(t,e,n){return(n=n||{}).x=e[(t=t||"page")+"X"],n.y=e[t+"Y"],n}function Ut(t,e){return e=e||{x:0,y:0},Ct.default.isOperaMobile&&Vt(t)?(qt("screen",t,e),e.x+=window.scrollX,e.y+=window.scrollY):qt("page",t,e),e}function Gt(t,e){return e=e||{},Ct.default.isOperaMobile&&Vt(t)?qt("screen",t,e):qt("client",t,e),e}function Ht(t){var e=[];return Xt.array(t)?(e[0]=t[0],e[1]=t[1]):"touchend"===t.type?1===t.touches.length?(e[0]=t.touches[0],e[1]=t.changedTouches[0]):0===t.touches.length&&(e[0]=t.changedTouches[0],e[1]=t.changedTouches[1]):(e[0]=t.touches[0],e[1]=t.touches[1]),e}function Kt(t){for(var e={pageX:0,pageY:0,clientX:0,clientY:0,screenX:0,screenY:0},n=0;n<t.length;n++){var r=t[n];for(var o in e)e[o]+=r[o]}for(var i in e)e[i]/=t.length;return e}var $t={};function Zt(t){return(Zt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty($t,"__esModule",{value:!0}),$t.getStringOptionResult=ne,$t.resolveRectLike=function(t,e,n,r){var o=t;te.string(o)?o=ne(o,e,n):te.func(o)&&(o=o.apply(void 0,function(t){return function(t){if(Array.isArray(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}}(t)||function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}(r)));te.element(o)&&(o=(0,$.getElementRect)(o));return o},$t.rectToXY=function(t){return t&&{x:"x"in t?t.x:t.left,y:"y"in t?t.y:t.top}},$t.xywhToTlbr=function(t){!t||"left"in t&&"top"in t||((t=(0,Qt.default)({},t)).left=t.x||0,t.top=t.y||0,t.right=t.right||t.left+t.width,t.bottom=t.bottom||t.top+t.height);return t},$t.tlbrToXywh=function(t){!t||"x"in t&&"y"in t||((t=(0,Qt.default)({},t)).x=t.left||0,t.y=t.top||0,t.width=t.width||t.right||0-t.x,t.height=t.height||t.bottom||0-t.y);return t},$t.addEdges=function(t,e,n){t.left&&(e.left+=n.x);t.right&&(e.right+=n.x);t.top&&(e.top+=n.y);t.bottom&&(e.bottom+=n.y);e.width=e.right-e.left,e.height=e.bottom-e.top};var Jt,Qt=(Jt=ct)&&Jt.__esModule?Jt:{default:Jt},te=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Zt(t)&&"function"!=typeof t)return{default:t};var e=ee();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function ee(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ee=function(){return t},t}function ne(t,e,n){return"parent"===t?(0,$.parentNode)(n):"self"===t?e.getRect(n):(0,$.closest)(n,t)}var re={};Object.defineProperty(re,"__esModule",{value:!0}),re.default=function(t,e,n){var r=t.options[n],o=r&&r.origin||t.options.origin,i=(0,$t.resolveRectLike)(o,t,e,[t&&e]);return(0,$t.rectToXY)(i)||{x:0,y:0}};var oe={};Object.defineProperty(oe,"__esModule",{value:!0}),oe.default=void 0;var ie,ae,ue=0;var se={request:function(t){return ie(t)},cancel:function(t){return ae(t)},init:function(t){if(ie=t.requestAnimationFrame,ae=t.cancelAnimationFrame,!ie)for(var e=["ms","moz","webkit","o"],n=0;n<e.length;n++){var r=e[n];ie=t["".concat(r,"RequestAnimationFrame")],ae=t["".concat(r,"CancelAnimationFrame")]||t["".concat(r,"CancelRequestAnimationFrame")]}ie||(ie=function(t){var e=Date.now(),n=Math.max(0,16-(e-ue)),r=setTimeout(function(){t(e+n)},n);return ue=e+n,r},ae=function(t){return clearTimeout(t)})}};oe.default=se;var le={};function ce(t){return(ce="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(le,"__esModule",{value:!0}),le.warnOnce=function(t,e){var n=!1;return function(){return n||(he.default.window.console.warn(e),n=!0),t.apply(this,arguments)}},le.copyAction=function(t,e){return t.name=e.name,t.axis=e.axis,t.edges=e.edges,t},Object.defineProperty(le,"win",{enumerable:!0,get:function(){return he.default}}),Object.defineProperty(le,"browser",{enumerable:!0,get:function(){return ge.default}}),Object.defineProperty(le,"clone",{enumerable:!0,get:function(){return be.default}}),Object.defineProperty(le,"extend",{enumerable:!0,get:function(){return me.default}}),Object.defineProperty(le,"getOriginXY",{enumerable:!0,get:function(){return Oe.default}}),Object.defineProperty(le,"hypot",{enumerable:!0,get:function(){return we.default}}),Object.defineProperty(le,"normalizeListeners",{enumerable:!0,get:function(){return _e.default}}),Object.defineProperty(le,"raf",{enumerable:!0,get:function(){return Pe.default}}),le.rect=le.pointer=le.is=le.dom=le.arr=void 0;var fe=je(S);le.arr=fe;var pe=je($);le.dom=pe;var de=je(w);le.is=de;var ve=je(zt);le.pointer=ve;var ye=je($t);le.rect=ye;var he=xe(O),ge=xe(C),be=xe(V),me=xe(ct),Oe=xe(re),we=xe(Et),_e=xe(ft),Pe=xe(oe);function xe(t){return t&&t.__esModule?t:{default:t}}function Se(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Se=function(){return t},t}function je(t){if(t&&t.__esModule)return t;if(null===t||"object"!==ce(t)&&"function"!=typeof t)return{default:t};var e=Se();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}var Me={};function ke(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Ee(t,e,n){return e&&ke(t.prototype,e),n&&ke(t,n),t}function Te(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}Object.defineProperty(Me,"__esModule",{value:!0}),Me.default=Me.BaseEvent=void 0;var De=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Te(this,"type",void 0),Te(this,"target",void 0),Te(this,"currentTarget",void 0),Te(this,"interactable",void 0),Te(this,"_interaction",void 0),Te(this,"timeStamp",void 0),Te(this,"immediatePropagationStopped",!1),Te(this,"propagationStopped",!1),this._interaction=t}return Ee(e,[{key:"interaction",get:function(){return this._interaction._proxy}}]),Ee(e,[{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}]),e}(),Ie=Me.BaseEvent=De;Me.default=Ie;var ze={};Object.defineProperty(ze,"__esModule",{value:!0}),ze.default=ze.defaults=void 0;var Ae={base:{preventDefault:"auto",deltaSource:"page"},perAction:{enabled:!1,origin:{x:0,y:0}},actions:{}},Ce=ze.defaults=Ae;ze.default=Ce;var We={};Object.defineProperty(We,"__esModule",{value:!0}),We.default=We.InteractEvent=void 0;var Re=Le(ct),Fe=Le(re),Xe=Le(Et),Ye=Le(Me),Ne=Le(ze);function Le(t){return t&&t.__esModule?t:{default:t}}function Be(t){return(Be="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Ve(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function qe(t){return(qe=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ue(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ge(t,e){return(Ge=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function He(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Ke=function(){function g(t,e,n,r,o,i,a){var u,s,l;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,g),s=this,u=!(l=qe(g).call(this,t))||"object"!==Be(l)&&"function"!=typeof l?Ue(s):l,He(Ue(u),"target",void 0),He(Ue(u),"currentTarget",void 0),He(Ue(u),"relatedTarget",null),He(Ue(u),"screenX",void 0),He(Ue(u),"screenY",void 0),He(Ue(u),"button",void 0),He(Ue(u),"buttons",void 0),He(Ue(u),"ctrlKey",void 0),He(Ue(u),"shiftKey",void 0),He(Ue(u),"altKey",void 0),He(Ue(u),"metaKey",void 0),He(Ue(u),"page",void 0),He(Ue(u),"client",void 0),He(Ue(u),"delta",void 0),He(Ue(u),"rect",void 0),He(Ue(u),"x0",void 0),He(Ue(u),"y0",void 0),He(Ue(u),"t0",void 0),He(Ue(u),"dt",void 0),He(Ue(u),"duration",void 0),He(Ue(u),"clientX0",void 0),He(Ue(u),"clientY0",void 0),He(Ue(u),"velocity",void 0),He(Ue(u),"speed",void 0),He(Ue(u),"swipe",void 0),He(Ue(u),"timeStamp",void 0),He(Ue(u),"dragEnter",void 0),He(Ue(u),"dragLeave",void 0),He(Ue(u),"axes",void 0),He(Ue(u),"preEnd",void 0),o=o||t.element;var c=t.interactable,f=(c&&c.options||Ne.default).deltaSource,p=(0,Fe.default)(c,o,n),d="start"===r,v="end"===r,y=d?Ue(u):t.prevEvent,h=d?t.coords.start:v?{page:y.page,client:y.client,timeStamp:t.coords.cur.timeStamp}:t.coords.cur;return u.page=(0,Re.default)({},h.page),u.client=(0,Re.default)({},h.client),u.rect=(0,Re.default)({},t.rect),u.timeStamp=h.timeStamp,v||(u.page.x-=p.x,u.page.y-=p.y,u.client.x-=p.x,u.client.y-=p.y),u.ctrlKey=e.ctrlKey,u.altKey=e.altKey,u.shiftKey=e.shiftKey,u.metaKey=e.metaKey,u.button=e.button,u.buttons=e.buttons,u.target=o,u.currentTarget=o,u.preEnd=i,u.type=a||n+(r||""),u.interactable=c,u.t0=d?t.pointers[t.pointers.length-1].downTime:y.t0,u.x0=t.coords.start.page.x-p.x,u.y0=t.coords.start.page.y-p.y,u.clientX0=t.coords.start.client.x-p.x,u.clientY0=t.coords.start.client.y-p.y,u.delta=d||v?{x:0,y:0}:{x:u[f].x-y[f].x,y:u[f].y-y[f].y},u.dt=t.coords.delta.timeStamp,u.duration=u.timeStamp-u.t0,u.velocity=(0,Re.default)({},t.coords.velocity[f]),u.speed=(0,Xe.default)(u.velocity.x,u.velocity.y),u.swipe=v||"inertiastart"===r?u.getSwipe():null,u}var t,e,n;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ge(t,e)}(g,Ye["default"]),t=g,(e=[{key:"getSwipe",value:function(){var t=this._interaction;if(t.prevEvent.speed<600||150<this.timeStamp-t.prevEvent.timeStamp)return null;var e=180*Math.atan2(t.prevEvent.velocityY,t.prevEvent.velocityX)/Math.PI;e<0&&(e+=360);var n=112.5<=e&&e<247.5,r=202.5<=e&&e<337.5;return{up:r,down:!r&&22.5<=e&&e<157.5,left:n,right:!n&&(292.5<=e||e<67.5),angle:e,speed:t.prevEvent.speed,velocity:{x:t.prevEvent.velocityX,y:t.prevEvent.velocityY}}}},{key:"preventDefault",value:function(){}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"pageX",get:function(){return this.page.x},set:function(t){this.page.x=t}},{key:"pageY",get:function(){return this.page.y},set:function(t){this.page.y=t}},{key:"clientX",get:function(){return this.client.x},set:function(t){this.client.x=t}},{key:"clientY",get:function(){return this.client.y},set:function(t){this.client.y=t}},{key:"dx",get:function(){return this.delta.x},set:function(t){this.delta.x=t}},{key:"dy",get:function(){return this.delta.y},set:function(t){this.delta.y=t}},{key:"velocityX",get:function(){return this.velocity.x},set:function(t){this.velocity.x=t}},{key:"velocityY",get:function(){return this.velocity.y},set:function(t){this.velocity.y=t}}])&&Ve(t.prototype,e),n&&Ve(t,n),g}(),$e=We.InteractEvent=Ke;We.default=$e;var Ze={};function Je(t){return(Je="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ze,"__esModule",{value:!0}),Ze.default=void 0;var Qe,tn=an(S),en=an($),nn=(Qe=ct)&&Qe.__esModule?Qe:{default:Qe},rn=an(w);function on(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return on=function(){return t},t}function an(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Je(t)&&"function"!=typeof t)return{default:t};var e=on();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function un(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function sn(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var ln=function(){function e(t){var a=this;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.scope=t,sn(this,"list",[]),sn(this,"selectorMap",{}),t.addListeners({"interactable:unset":function(t){var e=t.interactable,n=e.target,r=e._context,o=rn.string(n)?a.selectorMap[n]:n[a.scope.id],i=o.findIndex(function(t){return t.context===r});o[i]&&(o[i].context=null,o[i].interactable=null),o.splice(i,1)}})}var t,n,r;return t=e,(n=[{key:"new",value:function(t,e){e=(0,nn.default)(e||{},{actions:this.scope.actions});var n=new this.scope.Interactable(t,e,this.scope.document,this.scope.events),r={context:n._context,interactable:n};return this.scope.addDocument(n._doc),this.list.push(n),rn.string(t)?(this.selectorMap[t]||(this.selectorMap[t]=[]),this.selectorMap[t].push(r)):(n.target[this.scope.id]||Object.defineProperty(t,this.scope.id,{value:[],configurable:!0}),t[this.scope.id].push(r)),this.scope.fire("interactable:new",{target:t,options:e,interactable:n,win:this.scope._win}),n}},{key:"get",value:function(e,t){var n=t&&t.context||this.scope.document,r=rn.string(e),o=r?this.selectorMap[e]:e[this.scope.id];if(!o)return null;var i=tn.find(o,function(t){return t.context===n&&(r||t.interactable.inContext(e))});return i&&i.interactable}},{key:"forEachMatch",value:function(t,e){for(var n=0;n<this.list.length;n++){var r=this.list[n],o=void 0;if((rn.string(r.target)?rn.element(t)&&en.matchesSelector(t,r.target):t===r.target)&&r.inContext(t)&&(o=e(r)),void 0!==o)return o}}}])&&un(t.prototype,n),r&&un(t,r),e}();Ze.default=ln;var cn={};function fn(t){return(fn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(cn,"__esModule",{value:!0}),cn.default=cn.FakeEvent=void 0;var pn=On(S),dn=On($),vn=bn(ct),yn=On(w),hn=bn(Tt),gn=On(zt);function bn(t){return t&&t.__esModule?t:{default:t}}function mn(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return mn=function(){return t},t}function On(t){if(t&&t.__esModule)return t;if(null===t||"object"!==fn(t)&&"function"!=typeof t)return{default:t};var e=mn();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function wn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function _n(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var Pn=function(){function o(t){var e,n,r;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),this.originalEvent=t,r=void 0,(n="currentTarget")in(e=this)?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,(0,hn.default)(this,t)}var t,e,n;return t=o,(e=[{key:"preventOriginalDefault",value:function(){this.originalEvent.preventDefault()}},{key:"stopPropagation",value:function(){this.originalEvent.stopPropagation()}},{key:"stopImmediatePropagation",value:function(){this.originalEvent.stopImmediatePropagation()}}])&&wn(t.prototype,e),n&&wn(t,n),o}();function xn(t){if(!yn.object(t))return{capture:!!t,passive:!1};var e=(0,vn.default)({},t);return e.capture=!!t.capture,e.passive=!!t.passive,e}cn.FakeEvent=Pn;var Sn={id:"events",install:function(t){var f=[],b={},c=[],p={add:d,remove:g,addDelegate:function(e,n,t,r,o){var i=xn(o);if(!b[t]){b[t]=[];for(var a=0;a<c.length;a++){var u=c[a];d(u,t,m),d(u,t,O,!0)}}var s=b[t],l=pn.find(s,function(t){return t.selector===e&&t.context===n});l||(l={selector:e,context:n,listeners:[]},s.push(l));l.listeners.push([r,i])},removeDelegate:function(t,e,n,r,o){var i,a=xn(o),u=b[n],s=!1;if(!u)return;for(i=u.length-1;0<=i;i--){var l=u[i];if(l.selector===t&&l.context===e){for(var c=l.listeners,f=c.length-1;0<=f;f--){var p=_n(c[f],2),d=p[0],v=p[1],y=v.capture,h=v.passive;if(d===r&&y===a.capture&&h===a.passive){c.splice(f,1),c.length||(u.splice(i,1),g(e,n,m),g(e,n,O,!0)),s=!0;break}}if(s)break}}},delegateListener:m,delegateUseCapture:O,delegatedEvents:b,documents:c,targets:f,supportsOptions:!1,supportsPassive:!1};function d(e,t,n,r){var o=xn(r),i=pn.find(f,function(t){return t.eventTarget===e});i||(i={eventTarget:e,events:{}},f.push(i)),i.events[t]||(i.events[t]=[]),e.addEventListener&&!pn.contains(i.events[t],n)&&(e.addEventListener(t,n,p.supportsOptions?o:o.capture),i.events[t].push(n))}function g(e,t,n,r){var o=xn(r),i=pn.findIndex(f,function(t){return t.eventTarget===e}),a=f[i];if(a&&a.events)if("all"!==t){var u=!1,s=a.events[t];if(s){if("all"===n){for(var l=s.length-1;0<=l;l--)g(e,t,s[l],o);return}for(var c=0;c<s.length;c++)if(s[c]===n){e.removeEventListener(t,n,p.supportsOptions?o:o.capture),s.splice(c,1),0===s.length&&(delete a.events[t],u=!0);break}}u&&!Object.keys(a.events).length&&f.splice(i,1)}else for(t in a.events)a.events.hasOwnProperty(t)&&g(e,t,"all")}function m(t,e){for(var n=xn(e),r=new Pn(t),o=b[t.type],i=_n(gn.getEventTargets(t),1)[0],a=i;yn.element(a);){for(var u=0;u<o.length;u++){var s=o[u],l=s.selector,c=s.context;if(dn.matchesSelector(a,l)&&dn.nodeContains(c,i)&&dn.nodeContains(c,a)){var f=s.listeners;r.currentTarget=a;for(var p=0;p<f.length;p++){var d=_n(f[p],2),v=d[0],y=d[1],h=y.capture,g=y.passive;h===n.capture&&g===n.passive&&v(r)}}}a=dn.parentNode(a)}}function O(t){return m.call(this,t,!0)}return t.document.createElement("div").addEventListener("test",null,{get capture(){return p.supportsOptions=!0},get passive(){return p.supportsPassive=!0}}),t.events=p}};cn.default=Sn;var jn={};Object.defineProperty(jn,"__esModule",{value:!0}),jn.default=jn.PointerInfo=void 0;function Mn(t,e,n,r,o){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,Mn),this.id=t,this.pointer=e,this.event=n,this.downTime=r,this.downTarget=o}var kn=jn.PointerInfo=Mn;jn.default=kn;var En={};function Tn(t){return(Tn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(En,"__esModule",{value:!0}),Object.defineProperty(En,"PointerInfo",{enumerable:!0,get:function(){return Rn.default}}),En.default=En.Interaction=En._ProxyMethods=En._ProxyValues=void 0;var Dn,In,zn,An,Cn=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Tn(t)&&"function"!=typeof t)return{default:t};var e=Xn();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),Wn=Fn(We),Rn=Fn(jn);function Fn(t){return t&&t.__esModule?t:{default:t}}function Xn(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Xn=function(){return t},t}function Yn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Nn(t,e,n){return e&&Yn(t.prototype,e),n&&Yn(t,n),t}function Ln(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}En._ProxyValues=Dn,(In=Dn||(En._ProxyValues=Dn={})).interactable="",In.element="",In.prepared="",In.pointerIsDown="",In.pointerWasMoved="",In._proxy="",En._ProxyMethods=zn,(An=zn||(En._ProxyMethods=zn={})).start="",An.move="",An.end="",An.stop="",An.interacting="";var Bn=0,Vn=function(){function l(t){var e=this,n=t.pointerType,r=t.scopeFire;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,l),Ln(this,"interactable",null),Ln(this,"element",null),Ln(this,"rect",void 0),Ln(this,"_rects",void 0),Ln(this,"edges",void 0),Ln(this,"_scopeFire",void 0),Ln(this,"prepared",{name:null,axis:null,edges:null}),Ln(this,"pointerType",void 0),Ln(this,"pointers",[]),Ln(this,"downEvent",null),Ln(this,"downPointer",{}),Ln(this,"_latestPointer",{pointer:null,event:null,eventTarget:null}),Ln(this,"prevEvent",null),Ln(this,"pointerIsDown",!1),Ln(this,"pointerWasMoved",!1),Ln(this,"_interacting",!1),Ln(this,"_ending",!1),Ln(this,"_stopped",!0),Ln(this,"_proxy",null),Ln(this,"simulation",null),Ln(this,"doMove",Cn.warnOnce(function(t){this.move(t)},"The interaction.doMove() method has been renamed to interaction.move()")),Ln(this,"coords",{start:Cn.pointer.newCoords(),prev:Cn.pointer.newCoords(),cur:Cn.pointer.newCoords(),delta:Cn.pointer.newCoords(),velocity:Cn.pointer.newCoords()}),Ln(this,"_id",Bn++),this._scopeFire=r,this.pointerType=n;var o=this;this._proxy={};function i(t){Object.defineProperty(e._proxy,t,{get:function(){return o[t]}})}for(var a in Dn)i(a);function u(t){Object.defineProperty(e._proxy,t,{value:function(){return o[t].apply(o,arguments)}})}for(var s in zn)u(s);this._scopeFire("interactions:new",{interaction:this})}return Nn(l,[{key:"pointerMoveTolerance",get:function(){return 1}}]),Nn(l,[{key:"pointerDown",value:function(t,e,n){var r=this.updatePointer(t,e,n,!0),o=this.pointers[r];this._scopeFire("interactions:down",{pointer:t,event:e,eventTarget:n,pointerIndex:r,pointerInfo:o,type:"down",interaction:this})}},{key:"start",value:function(t,e,n){return!(this.interacting()||!this.pointerIsDown||this.pointers.length<("gesture"===t.name?2:1)||!e.options[t.name].enabled)&&(Cn.copyAction(this.prepared,t),this.interactable=e,this.element=n,this.rect=e.getRect(n),this.edges=this.prepared.edges?Cn.extend({},this.prepared.edges):{left:!0,right:!0,top:!0,bottom:!0},this._stopped=!1,this._interacting=this._doPhase({interaction:this,event:this.downEvent,phase:"start"})&&!this._stopped,this._interacting)}},{key:"pointerMove",value:function(t,e,n){this.simulation||this.modification&&this.modification.endResult||this.updatePointer(t,e,n,!1);var r,o,i=this.coords.cur.page.x===this.coords.prev.page.x&&this.coords.cur.page.y===this.coords.prev.page.y&&this.coords.cur.client.x===this.coords.prev.client.x&&this.coords.cur.client.y===this.coords.prev.client.y;this.pointerIsDown&&!this.pointerWasMoved&&(r=this.coords.cur.client.x-this.coords.start.client.x,o=this.coords.cur.client.y-this.coords.start.client.y,this.pointerWasMoved=Cn.hypot(r,o)>this.pointerMoveTolerance);var a=this.getPointerIndex(t),u={pointer:t,pointerIndex:a,pointerInfo:this.pointers[a],event:e,type:"move",eventTarget:n,dx:r,dy:o,duplicate:i,interaction:this};i||Cn.pointer.setCoordVelocity(this.coords.velocity,this.coords.delta),this._scopeFire("interactions:move",u),i||this.simulation||(this.interacting()&&(u.type=null,this.move(u)),this.pointerWasMoved&&Cn.pointer.copyCoords(this.coords.prev,this.coords.cur))}},{key:"move",value:function(t){t&&t.event||Cn.pointer.setZeroCoords(this.coords.delta),(t=Cn.extend({pointer:this._latestPointer.pointer,event:this._latestPointer.event,eventTarget:this._latestPointer.eventTarget,interaction:this},t||{})).phase="move",this._doPhase(t)}},{key:"pointerUp",value:function(t,e,n,r){var o=this.getPointerIndex(t);-1===o&&(o=this.updatePointer(t,e,n,!1));var i=/cancel$/i.test(e.type)?"cancel":"up";this._scopeFire("interactions:".concat(i),{pointer:t,pointerIndex:o,pointerInfo:this.pointers[o],event:e,eventTarget:n,type:i,curEventTarget:r,interaction:this}),this.simulation||this.end(e),this.pointerIsDown=!1,this.removePointer(t,e)}},{key:"documentBlur",value:function(t){this.end(t),this._scopeFire("interactions:blur",{event:t,type:"blur",interaction:this})}},{key:"end",value:function(t){var e;this._ending=!0,t=t||this._latestPointer.event,this.interacting()&&(e=this._doPhase({event:t,interaction:this,phase:"end"})),!(this._ending=!1)===e&&this.stop()}},{key:"currentAction",value:function(){return this._interacting?this.prepared.name:null}},{key:"interacting",value:function(){return this._interacting}},{key:"stop",value:function(){this._scopeFire("interactions:stop",{interaction:this}),this.interactable=this.element=null,this._interacting=!1,this._stopped=!0,this.prepared.name=this.prevEvent=null}},{key:"getPointerIndex",value:function(t){var e=Cn.pointer.getPointerId(t);return"mouse"===this.pointerType||"pen"===this.pointerType?this.pointers.length-1:Cn.arr.findIndex(this.pointers,function(t){return t.id===e})}},{key:"getPointerInfo",value:function(t){return this.pointers[this.getPointerIndex(t)]}},{key:"updatePointer",value:function(t,e,n,r){var o=Cn.pointer.getPointerId(t),i=this.getPointerIndex(t),a=this.pointers[i];return r=!1!==r&&(r||/(down|start)$/i.test(e.type)),a?a.pointer=t:(a=new Rn.default(o,t,e,null,null),i=this.pointers.length,this.pointers.push(a)),Cn.pointer.setCoords(this.coords.cur,this.pointers.map(function(t){return t.pointer}),this._now()),Cn.pointer.setCoordDeltas(this.coords.delta,this.coords.prev,this.coords.cur),r&&(this.pointerIsDown=!0,a.downTime=this.coords.cur.timeStamp,a.downTarget=n,Cn.pointer.pointerExtend(this.downPointer,t),this.interacting()||(Cn.pointer.copyCoords(this.coords.start,this.coords.cur),Cn.pointer.copyCoords(this.coords.prev,this.coords.cur),this.downEvent=e,this.pointerWasMoved=!1)),this._updateLatestPointer(t,e,n),this._scopeFire("interactions:update-pointer",{pointer:t,event:e,eventTarget:n,down:r,pointerInfo:a,pointerIndex:i,interaction:this}),i}},{key:"removePointer",value:function(t,e){var n=this.getPointerIndex(t);if(-1!==n){var r=this.pointers[n];this._scopeFire("interactions:remove-pointer",{pointer:t,event:e,eventTarget:null,pointerIndex:n,pointerInfo:r,interaction:this}),this.pointers.splice(n,1)}}},{key:"_updateLatestPointer",value:function(t,e,n){this._latestPointer.pointer=t,this._latestPointer.event=e,this._latestPointer.eventTarget=n}},{key:"destroy",value:function(){this._latestPointer.pointer=null,this._latestPointer.event=null,this._latestPointer.eventTarget=null}},{key:"_createPreparedEvent",value:function(t,e,n,r){return new Wn.default(this,t,this.prepared.name,e,this.element,n,r)}},{key:"_fireEvent",value:function(t){this.interactable.fire(t),(!this.prevEvent||t.timeStamp>=this.prevEvent.timeStamp)&&(this.prevEvent=t)}},{key:"_doPhase",value:function(t){var e=t.event,n=t.phase,r=t.preEnd,o=t.type,i=this.rect;if(i&&"move"===n&&(Cn.rect.addEdges(this.edges,i,this.coords.delta[this.interactable.options.deltaSource]),i.width=i.right-i.left,i.height=i.bottom-i.top),!1===this._scopeFire("interactions:before-action-".concat(n),t))return!1;var a=t.iEvent=this._createPreparedEvent(e,n,r,o);return this._scopeFire("interactions:action-".concat(n),t),"start"===n&&(this.prevEvent=a),this._fireEvent(a),this._scopeFire("interactions:after-action-".concat(n),t),!0}},{key:"_now",value:function(){return Date.now()}}]),l}(),qn=En.Interaction=Vn;En.default=qn;var Un={};function Gn(t){return(Gn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Un,"__esModule",{value:!0}),Un.install=Jn,Un.default=void 0;var Hn=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Gn(t)&&"function"!=typeof t)return{default:t};var e=Kn();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function Kn(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Kn=function(){return t},t}function $n(t){return/^(always|never|auto)$/.test(t)?(this.options.preventDefault=t,this):Hn.bool(t)?(this.options.preventDefault=t?"always":"never",this):this.options.preventDefault}function Zn(t){var e=t.interaction,n=t.event;e.interactable&&e.interactable.checkAndPreventDefault(n)}function Jn(r){var t=r.Interactable;t.prototype.preventDefault=$n,t.prototype.checkAndPreventDefault=function(t){return function(t,e,n){var r=t.options.preventDefault;if("never"!==r)if("always"!==r){if(e.events.supportsPassive&&/^touch(start|move)$/.test(n.type)){var o=(0,O.getWindow)(n.target).document,i=e.getDocOptions(o);if(!i||!i.events||!1!==i.events.passive)return}/^(mouse|pointer|touch)*(down|start)/i.test(n.type)||Hn.element(n.target)&&(0,$.matchesSelector)(n.target,"input,select,textarea,[contenteditable=true],[contenteditable=true] *")||n.preventDefault()}else n.preventDefault()}(this,r,t)},r.interactions.docEvents.push({type:"dragstart",listener:function(t){for(var e=0;e<r.interactions.list.length;e++){var n=r.interactions.list[e];if(n.element&&(n.element===t.target||(0,$.nodeContains)(n.element,t.target)))return void n.interactable.checkAndPreventDefault(t)}}})}var Qn={id:"core/interactablePreventDefault",install:Jn,listeners:["down","move","up","cancel"].reduce(function(t,e){return t["interactions:".concat(e)]=Zn,t},{})};Un.default=Qn;var tr={};function er(t){return(er="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(tr,"__esModule",{value:!0}),tr.default=void 0;var nr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==er(t)&&"function"!=typeof t)return{default:t};var e=rr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($);function rr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return rr=function(){return t},t}var or={methodOrder:["simulationResume","mouseOrPen","hasPointer","idle"],search:function(t){for(var e=0;e<or.methodOrder.length;e++){var n;n=or.methodOrder[e];var r=or[n](t);if(r)return r}return null},simulationResume:function(t){var e=t.pointerType,n=t.eventType,r=t.eventTarget,o=t.scope;if(!/down|start/i.test(n))return null;for(var i=0;i<o.interactions.list.length;i++){var a=o.interactions.list[i],u=r;if(a.simulation&&a.simulation.allowResume&&a.pointerType===e)for(;u;){if(u===a.element)return a;u=nr.parentNode(u)}}return null},mouseOrPen:function(t){var e,n=t.pointerId,r=t.pointerType,o=t.eventType,i=t.scope;if("mouse"!==r&&"pen"!==r)return null;for(var a=0;a<i.interactions.list.length;a++){var u=i.interactions.list[a];if(u.pointerType===r){if(u.simulation&&!ir(u,n))continue;if(u.interacting())return u;e=e||u}}if(e)return e;for(var s=0;s<i.interactions.list.length;s++){var l=i.interactions.list[s];if(!(l.pointerType!==r||/down/i.test(o)&&l.simulation))return l}return null},hasPointer:function(t){for(var e=t.pointerId,n=t.scope,r=0;r<n.interactions.list.length;r++){var o=n.interactions.list[r];if(ir(o,e))return o}return null},idle:function(t){for(var e=t.pointerType,n=t.scope,r=0;r<n.interactions.list.length;r++){var o=n.interactions.list[r];if(1===o.pointers.length){var i=o.interactable;if(i&&(!i.options.gesture||!i.options.gesture.enabled))continue}else if(2<=o.pointers.length)continue;if(!o.interacting()&&e===o.pointerType)return o}return null}};function ir(t,e){return t.pointers.some(function(t){return t.id===e})}var ar=or;tr.default=ar;var ur={};Object.defineProperty(ur,"__esModule",{value:!0}),ur.default=void 0;var sr,lr=(sr=Me)&&sr.__esModule?sr:{default:sr},cr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==pr(t)&&"function"!=typeof t)return{default:t};var e=fr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(S);function fr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return fr=function(){return t},t}function pr(t){return(pr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function dr(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function vr(t){return(vr=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function yr(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function hr(t,e){return(hr=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function gr(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var br=function(){function l(t,e,n){var r,o,i;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,l),o=this,r=!(i=vr(l).call(this,e._interaction))||"object"!==pr(i)&&"function"!=typeof i?yr(o):i,gr(yr(r),"target",void 0),gr(yr(r),"dropzone",void 0),gr(yr(r),"dragEvent",void 0),gr(yr(r),"relatedTarget",void 0),gr(yr(r),"draggable",void 0),gr(yr(r),"timeStamp",void 0),gr(yr(r),"propagationStopped",!1),gr(yr(r),"immediatePropagationStopped",!1);var a="dragleave"===n?t.prev:t.cur,u=a.element,s=a.dropzone;return r.type=n,r.target=u,r.currentTarget=u,r.dropzone=s,r.dragEvent=e,r.relatedTarget=e.target,r.draggable=e.interactable,r.timeStamp=e.timeStamp,r}var t,e,n;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&hr(t,e)}(l,lr["default"]),t=l,(e=[{key:"reject",value:function(){var r=this,t=this._interaction.dropState;if("dropactivate"===this.type||this.dropzone&&t.cur.dropzone===this.dropzone&&t.cur.element===this.target)if(t.prev.dropzone=this.dropzone,t.prev.element=this.target,t.rejected=!0,t.events.enter=null,this.stopImmediatePropagation(),"dropactivate"===this.type){var e=t.activeDrops,n=cr.findIndex(e,function(t){var e=t.dropzone,n=t.element;return e===r.dropzone&&n===r.target});t.activeDrops.splice(n,1);var o=new l(t,this.dragEvent,"dropdeactivate");o.dropzone=this.dropzone,o.target=this.target,this.dropzone.fire(o)}else this.dropzone.fire(new l(t,this.dragEvent,"dragleave"))}},{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}])&&dr(t.prototype,e),n&&dr(t,n),l}();ur.default=br;var mr={};function Or(t){return(Or="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(mr,"__esModule",{value:!0}),mr.default=void 0;Sr(k({})),Sr(m({}));var wr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Or(t)&&"function"!=typeof t)return{default:t};var e=xr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),_r=Sr(v),Pr=Sr(ur);function xr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return xr=function(){return t},t}function Sr(t){return t&&t.__esModule?t:{default:t}}function jr(t,e){for(var n=0;n<t.slice().length;n++){r=t.slice()[n];var r,o=r.dropzone,i=r.element;e.dropzone=o,e.target=i,o.fire(e),e.propagationStopped=e.immediatePropagationStopped=!1}}function Mr(t,e){for(var n=function(t,e){for(var n=t.interactables,r=[],o=0;o<n.list.length;o++){var i=n.list[o];if(i.options.drop.enabled){var a=i.options.drop.accept;if(!(wr.is.element(a)&&a!==e||wr.is.string(a)&&!wr.dom.matchesSelector(e,a)||wr.is.func(a)&&!a({dropzone:i,draggableElement:e})))for(var u=wr.is.string(i.target)?i._context.querySelectorAll(i.target):wr.is.array(i.target)?i.target:[i.target],s=0;s<u.length;s++){var l;l=u[s];l!==e&&r.push({dropzone:i,element:l})}}}return r}(t,e),r=0;r<n.length;r++){var o;o=n[r];o.rect=o.dropzone.getRect(o.element)}return n}function kr(t,e,n){for(var r=t.dropState,o=t.interactable,i=t.element,a=[],u=0;u<r.activeDrops.length;u++){s=r.activeDrops[u];var s,l=s.dropzone,c=s.element,f=s.rect;a.push(l.dropCheck(e,n,o,i,c,f)?c:null)}var p=wr.dom.indexOfDeepestElement(a);return r.activeDrops[p]||null}function Er(t,e,n){var r=t.dropState,o={enter:null,leave:null,activate:null,deactivate:null,move:null,drop:null};return"dragstart"===n.type&&(o.activate=new Pr.default(r,n,"dropactivate"),o.activate.target=null,o.activate.dropzone=null),"dragend"===n.type&&(o.deactivate=new Pr.default(r,n,"dropdeactivate"),o.deactivate.target=null,o.deactivate.dropzone=null),r.rejected||(r.cur.element!==r.prev.element&&(r.prev.dropzone&&(o.leave=new Pr.default(r,n,"dragleave"),n.dragLeave=o.leave.target=r.prev.element,n.prevDropzone=o.leave.dropzone=r.prev.dropzone),r.cur.dropzone&&(o.enter=new Pr.default(r,n,"dragenter"),n.dragEnter=r.cur.element,n.dropzone=r.cur.dropzone)),"dragend"===n.type&&r.cur.dropzone&&(o.drop=new Pr.default(r,n,"drop"),n.dropzone=r.cur.dropzone,n.relatedTarget=r.cur.element),"dragmove"===n.type&&r.cur.dropzone&&(o.move=new Pr.default(r,n,"dropmove"),(o.move.dragmove=n).dropzone=r.cur.dropzone)),o}function Tr(t,e){var n=t.dropState,r=n.activeDrops,o=n.cur,i=n.prev;e.leave&&i.dropzone.fire(e.leave),e.move&&o.dropzone.fire(e.move),e.enter&&o.dropzone.fire(e.enter),e.drop&&o.dropzone.fire(e.drop),e.deactivate&&jr(r,e.deactivate),n.prev.dropzone=o.dropzone,n.prev.element=o.element}function Dr(t,e){var n=t.interaction,r=t.iEvent,o=t.event;if("dragmove"===r.type||"dragend"===r.type){var i=n.dropState;e.dynamicDrop&&(i.activeDrops=Mr(e,n.element));var a=r,u=kr(n,a,o);i.rejected=i.rejected&&!!u&&u.dropzone===i.cur.dropzone&&u.element===i.cur.element,i.cur.dropzone=u&&u.dropzone,i.cur.element=u&&u.element,i.events=Er(n,0,a)}}var Ir={id:"actions/drop",install:function(e){var t=e.actions,n=e.interactStatic,r=e.Interactable,o=e.defaults;e.usePlugin(_r.default),r.prototype.dropzone=function(t){return function(t,e){if(wr.is.object(e)){if(t.options.drop.enabled=!1!==e.enabled,e.listeners){var n=wr.normalizeListeners(e.listeners),r=Object.keys(n).reduce(function(t,e){return t[/^(enter|leave)/.test(e)?"drag".concat(e):/^(activate|deactivate|move)/.test(e)?"drop".concat(e):e]=n[e],t},{});t.off(t.options.drop.listeners),t.on(r),t.options.drop.listeners=r}return wr.is.func(e.ondrop)&&t.on("drop",e.ondrop),wr.is.func(e.ondropactivate)&&t.on("dropactivate",e.ondropactivate),wr.is.func(e.ondropdeactivate)&&t.on("dropdeactivate",e.ondropdeactivate),wr.is.func(e.ondragenter)&&t.on("dragenter",e.ondragenter),wr.is.func(e.ondragleave)&&t.on("dragleave",e.ondragleave),wr.is.func(e.ondropmove)&&t.on("dropmove",e.ondropmove),/^(pointer|center)$/.test(e.overlap)?t.options.drop.overlap=e.overlap:wr.is.number(e.overlap)&&(t.options.drop.overlap=Math.max(Math.min(1,e.overlap),0)),"accept"in e&&(t.options.drop.accept=e.accept),"checker"in e&&(t.options.drop.checker=e.checker),t}if(wr.is.bool(e))return t.options.drop.enabled=e,t;return t.options.drop}(this,t)},r.prototype.dropCheck=function(t,e,n,r,o,i){return function(t,e,n,r,o,i,a){var u=!1;if(!(a=a||t.getRect(i)))return!!t.options.drop.checker&&t.options.drop.checker(e,n,u,t,i,r,o);var s=t.options.drop.overlap;if("pointer"===s){var l=wr.getOriginXY(r,o,"drag"),c=wr.pointer.getPageXY(e);c.x+=l.x,c.y+=l.y;var f=c.x>a.left&&c.x<a.right,p=c.y>a.top&&c.y<a.bottom;u=f&&p}var d=r.getRect(o);if(d&&"center"===s){var v=d.left+d.width/2,y=d.top+d.height/2;u=v>=a.left&&v<=a.right&&y>=a.top&&y<=a.bottom}if(d&&wr.is.number(s)){var h=Math.max(0,Math.min(a.right,d.right)-Math.max(a.left,d.left))*Math.max(0,Math.min(a.bottom,d.bottom)-Math.max(a.top,d.top))/(d.width*d.height);u=s<=h}t.options.drop.checker&&(u=t.options.drop.checker(e,n,u,t,i,r,o));return u}(this,t,e,n,r,o,i)},n.dynamicDrop=function(t){return wr.is.bool(t)?(e.dynamicDrop=t,n):e.dynamicDrop},wr.extend(t.phaselessTypes,{dragenter:!0,dragleave:!0,dropactivate:!0,dropdeactivate:!0,dropmove:!0,drop:!0}),t.methodDict.drop="dropzone",e.dynamicDrop=!1,o.actions.drop=Ir.defaults},listeners:{"interactions:before-action-start":function(t){var e=t.interaction;"drag"===e.prepared.name&&(e.dropState={cur:{dropzone:null,element:null},prev:{dropzone:null,element:null},rejected:null,events:null,activeDrops:[]})},"interactions:after-action-start":function(t,e){var n=t.interaction,r=(t.event,t.iEvent);if("drag"===n.prepared.name){var o=n.dropState;o.activeDrops=null,o.events=null,o.activeDrops=Mr(e,n.element),o.events=Er(n,0,r),o.events.activate&&(jr(o.activeDrops,o.events.activate),e.fire("actions/drop:start",{interaction:n,dragEvent:r}))}},"interactions:action-move":Dr,"interactions:action-end":Dr,"interactions:after-action-move":function(t,e){var n=t.interaction,r=t.iEvent;"drag"===n.prepared.name&&(Tr(n,n.dropState.events),e.fire("actions/drop:move",{interaction:n,dragEvent:r}),n.dropState.events={})},"interactions:after-action-end":function(t,e){var n=t.interaction,r=t.iEvent;"drag"===n.prepared.name&&(Tr(n,n.dropState.events),e.fire("actions/drop:end",{interaction:n,dragEvent:r}))},"interactions:stop":function(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.dropState;n&&(n.activeDrops=null,n.events=null,n.cur.dropzone=null,n.cur.element=null,n.prev.dropzone=null,n.prev.element=null,n.rejected=!1)}}},getActiveDrops:Mr,getDrop:kr,getDropEvents:Er,fireDropEvents:Tr,defaults:{enabled:!1,accept:null,overlap:"pointer"}},zr=Ir;mr.default=zr;var Ar={};function Cr(t){return(Cr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ar,"__esModule",{value:!0}),Ar.default=void 0;var Wr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Cr(t)&&"function"!=typeof t)return{default:t};var e=Rr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le);function Rr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Rr=function(){return t},t}function Fr(t){var e=t.interaction,n=t.iEvent,r=t.phase;if("gesture"===e.prepared.name){var o=e.pointers.map(function(t){return t.pointer}),i="start"===r,a="end"===r,u=e.interactable.options.deltaSource;if(n.touches=[o[0],o[1]],i)n.distance=Wr.pointer.touchDistance(o,u),n.box=Wr.pointer.touchBBox(o),n.scale=1,n.ds=0,n.angle=Wr.pointer.touchAngle(o,u),n.da=0,e.gesture.startDistance=n.distance,e.gesture.startAngle=n.angle;else if(a){var s=e.prevEvent;n.distance=s.distance,n.box=s.box,n.scale=s.scale,n.ds=0,n.angle=s.angle,n.da=0}else n.distance=Wr.pointer.touchDistance(o,u),n.box=Wr.pointer.touchBBox(o),n.scale=n.distance/e.gesture.startDistance,n.angle=Wr.pointer.touchAngle(o,u),n.ds=n.scale-e.gesture.scale,n.da=n.angle-e.gesture.angle;e.gesture.distance=n.distance,e.gesture.angle=n.angle,Wr.is.number(n.scale)&&n.scale!==1/0&&!isNaN(n.scale)&&(e.gesture.scale=n.scale)}}var Xr={id:"actions/gesture",before:["actions/drag","actions/resize"],install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.gesturable=function(t){return Wr.is.object(t)?(this.options.gesture.enabled=!1!==t.enabled,this.setPerAction("gesture",t),this.setOnEvents("gesture",t),this):Wr.is.bool(t)?(this.options.gesture.enabled=t,this):this.options.gesture},e.map.gesture=Xr,e.methodDict.gesture="gesturable",r.actions.gesture=Xr.defaults},listeners:{"interactions:action-start":Fr,"interactions:action-move":Fr,"interactions:action-end":Fr,"interactions:new":function(t){t.interaction.gesture={angle:0,distance:0,scale:1,startAngle:0,startDistance:0}},"auto-start:check":function(t){if(!(t.interaction.pointers.length<2)){var e=t.interactable.options.gesture;if(e&&e.enabled)return!(t.action={name:"gesture"})}}},defaults:{},getCursor:function(){return""}},Yr=Xr;Ar.default=Yr;var Nr={};function Lr(t){return(Lr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Nr,"__esModule",{value:!0}),Nr.default=void 0;var Br,Vr=Hr($),qr=(Br=ct)&&Br.__esModule?Br:{default:Br},Ur=Hr(w);function Gr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Gr=function(){return t},t}function Hr(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Lr(t)&&"function"!=typeof t)return{default:t};var e=Gr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function Kr(t,e,n,r,o,i,a){if(!e)return!1;if(!0===e){var u=Ur.number(i.width)?i.width:i.right-i.left,s=Ur.number(i.height)?i.height:i.bottom-i.top;if(a=Math.min(a,("left"===t||"right"===t?u:s)/2),u<0&&("left"===t?t="right":"right"===t&&(t="left")),s<0&&("top"===t?t="bottom":"bottom"===t&&(t="top")),"left"===t)return n.x<(0<=u?i.left:i.right)+a;if("top"===t)return n.y<(0<=s?i.top:i.bottom)+a;if("right"===t)return n.x>(0<=u?i.right:i.left)-a;if("bottom"===t)return n.y>(0<=s?i.bottom:i.top)-a}return!!Ur.element(r)&&(Ur.element(e)?e===r:Vr.matchesUpTo(r,e,o))}function $r(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.resizeAxes){var r=e;n.interactable.options.resize.square?("y"===n.resizeAxes?r.delta.x=r.delta.y:r.delta.y=r.delta.x,r.axes="xy"):(r.axes=n.resizeAxes,"x"===n.resizeAxes?r.delta.y=0:"y"===n.resizeAxes&&(r.delta.x=0))}}var Zr={id:"actions/resize",before:["actions/drag"],install:function(e){var t=e.actions,n=e.browser,r=e.Interactable,o=e.defaults;Zr.cursors=n.isIe9?{x:"e-resize",y:"s-resize",xy:"se-resize",top:"n-resize",left:"w-resize",bottom:"s-resize",right:"e-resize",topleft:"se-resize",bottomright:"se-resize",topright:"ne-resize",bottomleft:"ne-resize"}:{x:"ew-resize",y:"ns-resize",xy:"nwse-resize",top:"ns-resize",left:"ew-resize",bottom:"ns-resize",right:"ew-resize",topleft:"nwse-resize",bottomright:"nwse-resize",topright:"nesw-resize",bottomleft:"nesw-resize"},Zr.defaultMargin=n.supportsTouch||n.supportsPointerEvent?20:10,r.prototype.resizable=function(t){return function(t,e,n){if(Ur.object(e))return t.options.resize.enabled=!1!==e.enabled,t.setPerAction("resize",e),t.setOnEvents("resize",e),Ur.string(e.axis)&&/^x$|^y$|^xy$/.test(e.axis)?t.options.resize.axis=e.axis:null===e.axis&&(t.options.resize.axis=n.defaults.actions.resize.axis),Ur.bool(e.preserveAspectRatio)?t.options.resize.preserveAspectRatio=e.preserveAspectRatio:Ur.bool(e.square)&&(t.options.resize.square=e.square),t;if(Ur.bool(e))return t.options.resize.enabled=e,t;return t.options.resize}(this,t,e)},t.map.resize=Zr,t.methodDict.resize="resizable",o.actions.resize=Zr.defaults},listeners:{"interactions:new":function(t){t.interaction.resizeAxes="xy"},"interactions:action-start":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,o=n.rect;n._rects={start:(0,qr.default)({},o),corrected:(0,qr.default)({},o),previous:(0,qr.default)({},o),delta:{left:0,right:0,width:0,top:0,bottom:0,height:0}},r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}}(t),$r(t)},"interactions:action-move":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,o=n.interactable.options.resize.invert,i="reposition"===o||"negate"===o,a=n.rect,u=n._rects,s=u.start,l=u.corrected,c=u.delta,f=u.previous;if((0,qr.default)(f,l),i){if((0,qr.default)(l,a),"reposition"===o){if(l.top>l.bottom){var p=l.top;l.top=l.bottom,l.bottom=p}if(l.left>l.right){var d=l.left;l.left=l.right,l.right=d}}}else l.top=Math.min(a.top,s.bottom),l.bottom=Math.max(a.bottom,s.top),l.left=Math.min(a.left,s.right),l.right=Math.max(a.right,s.left);for(var v in l.width=l.right-l.left,l.height=l.bottom-l.top,l)c[v]=l[v]-f[v];r.edges=n.prepared.edges,r.rect=l,r.deltaRect=c}}(t),$r(t)},"interactions:action-end":function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e;r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}},"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.element,o=t.rect,i=t.buttons;if(o){var a=(0,qr.default)({},e.coords.cur.page),u=n.options.resize;if(u&&u.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(i&u.mouseButtons))){if(Ur.object(u.edges)){var s={left:!1,right:!1,top:!1,bottom:!1};for(var l in s)s[l]=Kr(l,u.edges[l],a,e._latestPointer.eventTarget,r,o,u.margin||Zr.defaultMargin);s.left=s.left&&!s.right,s.top=s.top&&!s.bottom,(s.left||s.right||s.top||s.bottom)&&(t.action={name:"resize",edges:s})}else{var c="y"!==u.axis&&a.x>o.right-Zr.defaultMargin,f="x"!==u.axis&&a.y>o.bottom-Zr.defaultMargin;(c||f)&&(t.action={name:"resize",axes:(c?"x":"")+(f?"y":"")})}return!t.action&&void 0}}}},defaults:{square:!1,preserveAspectRatio:!1,axis:"xy",margin:NaN,edges:null,invert:"none"},cursors:null,getCursor:function(t){var e=t.edges,n=t.axis,r=t.name,o=Zr.cursors,i=null;if(n)i=o[r+n];else if(e){for(var a="",u=["top","bottom","left","right"],s=0;s<u.length;s++){var l=u[s];e[l]&&(a+=l)}i=o[a]}return i},defaultMargin:null},Jr=Zr;Nr.default=Jr;var Qr={};Object.defineProperty(Qr,"__esModule",{value:!0}),Object.defineProperty(Qr,"drag",{enumerable:!0,get:function(){return to.default}}),Object.defineProperty(Qr,"drop",{enumerable:!0,get:function(){return eo.default}}),Object.defineProperty(Qr,"gesture",{enumerable:!0,get:function(){return no.default}}),Object.defineProperty(Qr,"resize",{enumerable:!0,get:function(){return ro.default}}),Qr.default=void 0;var to=oo(v),eo=oo(mr),no=oo(Ar),ro=oo(Nr);function oo(t){return t&&t.__esModule?t:{default:t}}var io={id:"actions",install:function(t){t.usePlugin(no.default),t.usePlugin(ro.default),t.usePlugin(to.default),t.usePlugin(eo.default)}};Qr.default=io;var ao={};Object.defineProperty(ao,"__esModule",{value:!0}),ao.default=void 0;ao.default={};var uo={};function so(t){return(so="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(uo,"__esModule",{value:!0}),uo.getContainer=go,uo.getScroll=bo,uo.getScrollSize=function(t){fo.window(t)&&(t=window.document.body);return{x:t.scrollWidth,y:t.scrollHeight}},uo.getScrollSizeDelta=function(t,e){var n=t.interaction,r=t.element,o=n&&n.interactable.options[n.prepared.name].autoScroll;if(!o||!o.enabled)return e(),{x:0,y:0};var i=go(o.container,n.interactable,r),a=bo(i);e();var u=bo(i);return{x:u.x-a.x,y:u.y-a.y}},uo.default=void 0;var lo,co=yo($),fo=yo(w),po=(lo=oe)&&lo.__esModule?lo:{default:lo};function vo(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return vo=function(){return t},t}function yo(t){if(t&&t.__esModule)return t;if(null===t||"object"!==so(t)&&"function"!=typeof t)return{default:t};var e=vo();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}var ho={defaults:{enabled:!1,margin:60,container:null,speed:300},now:Date.now,interaction:null,i:0,x:0,y:0,isScrolling:!1,prevTime:0,margin:0,speed:0,start:function(t){ho.isScrolling=!0,po.default.cancel(ho.i),(t.autoScroll=ho).interaction=t,ho.prevTime=ho.now(),ho.i=po.default.request(ho.scroll)},stop:function(){ho.isScrolling=!1,ho.interaction&&(ho.interaction.autoScroll=null),po.default.cancel(ho.i)},scroll:function(){var t=ho.interaction,e=t.interactable,n=t.element,r=t.prepared.name,o=e.options[r].autoScroll,i=go(o.container,e,n),a=ho.now(),u=(a-ho.prevTime)/1e3,s=o.speed*u;if(1<=s){var l={x:ho.x*s,y:ho.y*s};if(l.x||l.y){var c=bo(i);fo.window(i)?i.scrollBy(l.x,l.y):i&&(i.scrollLeft+=l.x,i.scrollTop+=l.y);var f=bo(i),p={x:f.x-c.x,y:f.y-c.y};(p.x||p.y)&&e.fire({type:"autoscroll",target:n,interactable:e,delta:p,interaction:t,container:i})}ho.prevTime=a}ho.isScrolling&&(po.default.cancel(ho.i),ho.i=po.default.request(ho.scroll))},check:function(t,e){var n=t.options;return n[e].autoScroll&&n[e].autoScroll.enabled},onInteractionMove:function(t){var e=t.interaction,n=t.pointer;if(e.interacting()&&ho.check(e.interactable,e.prepared.name))if(e.simulation)ho.x=ho.y=0;else{var r,o,i,a,u=e.interactable,s=e.element,l=e.prepared.name,c=u.options[l].autoScroll,f=go(c.container,u,s);if(fo.window(f))a=n.clientX<ho.margin,r=n.clientY<ho.margin,o=n.clientX>f.innerWidth-ho.margin,i=n.clientY>f.innerHeight-ho.margin;else{var p=co.getElementClientRect(f);a=n.clientX<p.left+ho.margin,r=n.clientY<p.top+ho.margin,o=n.clientX>p.right-ho.margin,i=n.clientY>p.bottom-ho.margin}ho.x=o?1:a?-1:0,ho.y=i?1:r?-1:0,ho.isScrolling||(ho.margin=c.margin,ho.speed=c.speed,ho.start(e))}}};function go(t,e,n){return(fo.string(t)?(0,$t.getStringOptionResult)(t,e,n):t)||(0,O.getWindow)(n)}function bo(t){return fo.window(t)&&(t=window.document.body),{x:t.scrollLeft,y:t.scrollTop}}var mo={id:"auto-scroll",install:function(t){var e=t.defaults,n=t.actions;(t.autoScroll=ho).now=function(){return t.now()},n.phaselessTypes.autoscroll=!0,e.perAction.autoScroll=ho.defaults},listeners:{"interactions:new":function(t){t.interaction.autoScroll=null},"interactions:destroy":function(t){t.interaction.autoScroll=null,ho.stop(),ho.interaction&&(ho.interaction=null)},"interactions:stop":ho.stop,"interactions:action-move":function(t){return ho.onInteractionMove(t)}}};uo.default=mo;var Oo={};function wo(t){return(wo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Oo,"__esModule",{value:!0}),Oo.default=void 0;var _o=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==wo(t)&&"function"!=typeof t)return{default:t};var e=Po();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function Po(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Po=function(){return t},t}function xo(t){return _o.bool(t)?(this.options.styleCursor=t,this):null===t?(delete this.options.styleCursor,this):this.options.styleCursor}function So(t){return _o.func(t)?(this.options.actionChecker=t,this):null===t?(delete this.options.actionChecker,this):this.options.actionChecker}var jo={id:"auto-start/interactableMethods",install:function(d){var t=d.Interactable;t.prototype.getAction=function(t,e,n,r){var o,i,a,u,s,l,c,f,p=(i=e,a=n,u=r,s=d,l=(o=this).getRect(u),c=i.buttons||{0:1,1:4,3:8,4:16}[i.button],f={action:null,interactable:o,interaction:a,element:u,rect:l,buttons:c},s.fire("auto-start:check",f),f.action);return this.options.actionChecker?this.options.actionChecker(t,e,p,this,r,n):p},t.prototype.ignoreFrom=(0,le.warnOnce)(function(t){return this._backCompatOption("ignoreFrom",t)},"Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."),t.prototype.allowFrom=(0,le.warnOnce)(function(t){return this._backCompatOption("allowFrom",t)},"Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."),t.prototype.actionChecker=So,t.prototype.styleCursor=xo}};Oo.default=jo;var Mo={};function ko(t){return(ko="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Mo,"__esModule",{value:!0}),Mo.default=void 0;var Eo,To=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==ko(t)&&"function"!=typeof t)return{default:t};var e=Io();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),Do=(Eo=Oo)&&Eo.__esModule?Eo:{default:Eo};function Io(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Io=function(){return t},t}function zo(t,e,n,r,o){return e.testIgnoreAllow(e.options[t.name],n,r)&&e.options[t.name].enabled&&Ro(e,n,t,o)?t:null}function Ao(t,e,n,r,o,i,a){for(var u=0,s=r.length;u<s;u++){var l=r[u],c=o[u],f=l.getAction(e,n,t,c);if(f){var p=zo(f,l,c,i,a);if(p)return{action:p,interactable:l,element:c}}}return{action:null,interactable:null,element:null}}function Co(t,e,n,r,o){var i=[],a=[],u=r;function s(t){i.push(t),a.push(u)}for(;To.is.element(u);){i=[],a=[],o.interactables.forEachMatch(u,s);var l=Ao(t,e,n,i,a,r,o);if(l.action&&!l.interactable.options[l.action.name].manualStart)return l;u=To.dom.parentNode(u)}return{action:null,interactable:null,element:null}}function Wo(t,e,n){var r=e.action,o=e.interactable,i=e.element;r=r||{name:null},t.interactable=o,t.element=i,To.copyAction(t.prepared,r),t.rect=o&&r.name?o.getRect(i):null,Yo(t,n),n.fire("autoStart:prepared",{interaction:t})}function Ro(t,e,n,r){var o=t.options,i=o[n.name].max,a=o[n.name].maxPerElement,u=r.autoStart.maxInteractions,s=0,l=0,c=0;if(!(i&&a&&u))return!1;for(var f=0;f<r.interactions.list.length;f++){var p=r.interactions.list[f],d=p.prepared.name;if(p.interacting()){if(u<=++s)return!1;if(p.interactable===t){if(i<=(l+=d===n.name?1:0))return!1;if(p.element===e&&(c++,d===n.name&&a<=c))return!1}}}return 0<u}function Fo(t,e){return To.is.number(t)?(e.autoStart.maxInteractions=t,this):e.autoStart.maxInteractions}function Xo(t,e,n){var r=n.autoStart.cursorElement;r&&r!==t&&(r.style.cursor=""),t.ownerDocument.documentElement.style.cursor=e,t.style.cursor=e,n.autoStart.cursorElement=e?t:null}function Yo(t,e){var n=t.interactable,r=t.element,o=t.prepared;if("mouse"===t.pointerType&&n&&n.options.styleCursor){var i="";if(o.name){var a=n.options[o.name].cursorChecker;i=To.is.func(a)?a(o,n,r,t._interacting):e.actions.map[o.name].getCursor(o)}Xo(t.element,i||"",e)}else e.autoStart.cursorElement&&Xo(e.autoStart.cursorElement,"",e)}var No={id:"auto-start/base",before:["actions","actions/drag","actions/resize","actions/gesture"],install:function(e){var t=e.interactStatic,n=e.defaults;e.usePlugin(Do.default),n.base.actionChecker=null,n.base.styleCursor=!0,To.extend(n.perAction,{manualStart:!1,max:1/0,maxPerElement:1,allowFrom:null,ignoreFrom:null,mouseButtons:1}),t.maxInteractions=function(t){return Fo(t,e)},e.autoStart={maxInteractions:1/0,withinInteractionLimit:Ro,cursorElement:null}},listeners:{"interactions:down":function(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget;n.interacting()||Wo(n,Co(n,r,o,i,e),e)},"interactions:move":function(t,e){var n,r,o,i,a,u;r=e,o=(n=t).interaction,i=n.pointer,a=n.event,u=n.eventTarget,"mouse"!==o.pointerType||o.pointerIsDown||o.interacting()||Wo(o,Co(o,i,a,u,r),r),function(t,e){var n=t.interaction;if(n.pointerIsDown&&!n.interacting()&&n.pointerWasMoved&&n.prepared.name){e.fire("autoStart:before-start",t);var r=n.interactable,o=n.prepared.name;o&&r&&(r.options[o].manualStart||!Ro(r,n.element,n.prepared,e)?n.stop():(n.start(n.prepared,r,n.element),Yo(n,e)))}}(t,e)},"interactions:stop":function(t,e){var n=t.interaction,r=n.interactable;r&&r.options.styleCursor&&Xo(n.element,"",e)}},maxInteractions:Fo,withinInteractionLimit:Ro,validateAction:zo};Mo.default=No;var Lo={};function Bo(t){return(Bo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Lo,"__esModule",{value:!0}),Lo.default=void 0;var Vo,qo=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Bo(t)&&"function"!=typeof t)return{default:t};var e=Go();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w),Uo=(Vo=Mo)&&Vo.__esModule?Vo:{default:Vo};function Go(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Go=function(){return t},t}var Ho={id:"auto-start/dragAxis",listeners:{"autoStart:before-start":function(t,r){var o=t.interaction,i=t.eventTarget,e=t.dx,n=t.dy;if("drag"===o.prepared.name){var a=Math.abs(e),u=Math.abs(n),s=o.interactable.options.drag,l=s.startAxis,c=u<a?"x":a<u?"y":"xy";if(o.prepared.axis="start"===s.lockAxis?c[0]:s.lockAxis,"xy"!=c&&"xy"!==l&&l!==c){o.prepared.name=null;function f(t){if(t!==o.interactable){var e=o.interactable.options.drag;if(!e.manualStart&&t.testIgnoreAllow(e,p,i)){var n=t.getAction(o.downPointer,o.downEvent,o,p);if(n&&"drag"===n.name&&function(t,e){if(!e)return;var n=e.options.drag.startAxis;return"xy"===t||"xy"===n||n===t}(c,t)&&Uo.default.validateAction(n,t,p,i,r))return t}}}for(var p=i;qo.element(p);){var d=r.interactables.forEachMatch(p,f);if(d){o.prepared.name="drag",o.interactable=d,o.element=p;break}p=(0,$.parentNode)(p)}}}}}};Lo.default=Ho;var Ko={};Object.defineProperty(Ko,"__esModule",{value:!0}),Ko.default=void 0;var $o,Zo=($o=Mo)&&$o.__esModule?$o:{default:$o};function Jo(t){var e=t.prepared&&t.prepared.name;if(!e)return null;var n=t.interactable.options;return n[e].hold||n[e].delay}var Qo={id:"auto-start/hold",install:function(t){var e=t.defaults;t.usePlugin(Zo.default),e.perAction.hold=0,e.perAction.delay=0},listeners:{"interactions:new":function(t){t.interaction.autoStartHoldTimer=null},"autoStart:prepared":function(t){var e=t.interaction,n=Jo(e);0<n&&(e.autoStartHoldTimer=setTimeout(function(){e.start(e.prepared,e.interactable,e.element)},n))},"interactions:move":function(t){var e=t.interaction,n=t.duplicate;e.pointerWasMoved&&!n&&clearTimeout(e.autoStartHoldTimer)},"autoStart:before-start":function(t){var e=t.interaction;0<Jo(e)&&(e.prepared.name=null)}},getHoldDuration:Jo};Ko.default=Qo;var ti={};Object.defineProperty(ti,"__esModule",{value:!0}),Object.defineProperty(ti,"autoStart",{enumerable:!0,get:function(){return ei.default}}),Object.defineProperty(ti,"dragAxis",{enumerable:!0,get:function(){return ni.default}}),Object.defineProperty(ti,"hold",{enumerable:!0,get:function(){return ri.default}}),ti.default=void 0;var ei=oi(Mo),ni=oi(Lo),ri=oi(Ko);function oi(t){return t&&t.__esModule?t:{default:t}}var ii={id:"auto-start",install:function(t){t.usePlugin(ei.default),t.usePlugin(ri.default),t.usePlugin(ni.default)}};ti.default=ii;var ai={};Object.defineProperty(ai,"__esModule",{value:!0}),ai.default=void 0;ai.default={};var ui={};Object.defineProperty(ui,"__esModule",{value:!0}),ui.default=void 0;ui.default={};var si={};function li(t){return(li="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(si,"__esModule",{value:!0}),si.default=void 0;var ci,fi,pi=hi(D),di=(hi(ct),function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==li(t)&&"function"!=typeof t)return{default:t};var e=yi();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w)),vi=hi(O);function yi(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return yi=function(){return t},t}function hi(t){return t&&t.__esModule?t:{default:t}}(fi=ci=ci||{}).touchAction="touchAction",fi.boxSizing="boxSizing",fi.noListeners="noListeners";var gi={touchAction:"https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action",boxSizing:"https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing"};ci.touchAction,ci.boxSizing,ci.noListeners;function bi(t,e,n){return n.test(t.style[e]||vi.default.window.getComputedStyle(t)[e])}var mi="dev-tools",Oi={id:mi,install:function(){}};si.default=Oi;var wi={};Object.defineProperty(wi,"__esModule",{value:!0}),wi.default=void 0;wi.default={};var _i={};function Pi(t){return(Pi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(_i,"__esModule",{value:!0}),_i.getRectOffset=Ai,_i.default=void 0;var xi=ki(V),Si=ki(ct),ji=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Pi(t)&&"function"!=typeof t)return{default:t};var e=Mi();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function Mi(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Mi=function(){return t},t}function ki(t){return t&&t.__esModule?t:{default:t}}function Ei(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function Ti(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Di(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Ii=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.interaction=t,Di(this,"states",[]),Di(this,"startOffset",{left:0,right:0,top:0,bottom:0}),Di(this,"startDelta",null),Di(this,"result",null),Di(this,"endResult",null),Di(this,"edges",void 0),this.result=zi()}var t,n,r;return t=e,(n=[{key:"start",value:function(t,e){var n=t.phase,r=this.interaction,o=function(t){var n=t.interactable.options[t.prepared.name],e=n.modifiers;if(e&&e.length)return e.filter(function(t){return!t.options||!1!==t.options.enabled});return["snap","snapSize","snapEdges","restrict","restrictEdges","restrictSize"].map(function(t){var e=n[t];return e&&e.enabled&&{options:e,methods:e._methods}}).filter(function(t){return!!t})}(r);this.prepareStates(o),this.edges=(0,Si.default)({},r.edges),this.startOffset=Ai(r.rect,e);var i={phase:n,pageCoords:e,preEnd:!(this.startDelta={x:0,y:0})};return this.result=zi(),this.startAll(i),this.result=this.setAll(i)}},{key:"fillArg",value:function(t){var e=this.interaction;t.interaction=e,t.interactable=e.interactable,t.element=e.element,t.rect=t.rect||e.rect,t.edges=this.edges,t.startOffset=this.startOffset}},{key:"startAll",value:function(t){this.fillArg(t);for(var e=0;e<this.states.length;e++){var n=this.states[e];n.methods.start&&(t.state=n).methods.start(t)}}},{key:"setAll",value:function(t){this.fillArg(t);var e=t.phase,n=t.preEnd,r=t.skipModifiers,o=t.rect;t.coords=(0,Si.default)({},t.pageCoords),t.rect=(0,Si.default)({},o);for(var i=r?this.states.slice(r):this.states,a=zi(t.coords,t.rect),u=0;u<i.length;u++){var s=i[u],l=s.options,c=(0,Si.default)({},t.coords),f=null;s.methods.set&&this.shouldDo(l,n,e)&&(f=(t.state=s).methods.set(t),ji.addEdges(this.interaction.edges,t.rect,{x:t.coords.x-c.x,y:t.coords.y-c.y})),a.eventProps.push(f)}a.delta.x=t.coords.x-t.pageCoords.x,a.delta.y=t.coords.y-t.pageCoords.y,a.rectDelta.left=t.rect.left-o.left,a.rectDelta.right=t.rect.right-o.right,a.rectDelta.top=t.rect.top-o.top,a.rectDelta.bottom=t.rect.bottom-o.bottom;var p=this.result.coords,d=this.result.rect;if(p&&d){var v=a.rect.left!==d.left||a.rect.right!==d.right||a.rect.top!==d.top||a.rect.bottom!==d.bottom;a.changed=v||p.x!==a.coords.x||p.y!==a.coords.y}return a}},{key:"applyToInteraction",value:function(t){var e=this.interaction,n=t.phase,r=e.coords.cur,o=e.coords.start,i=this.result,a=this.startDelta,u=i.delta;"start"===n&&(0,Si.default)(this.startDelta,i.delta);for(var s=0;s<[[o,a],[r,u]].length;s++){var l=Ei([[o,a],[r,u]][s],2),c=l[0],f=l[1];c.page.x+=f.x,c.page.y+=f.y,c.client.x+=f.x,c.client.y+=f.y}var p=this.result.rectDelta,d=t.rect||e.rect;d.left+=p.left,d.right+=p.right,d.top+=p.top,d.bottom+=p.bottom,d.width=d.right-d.left,d.height=d.bottom-d.top}},{key:"setAndApply",value:function(t){var e=this.interaction,n=t.phase,r=t.preEnd,o=t.skipModifiers,i=this.setAll({preEnd:r,phase:n,pageCoords:t.modifiedCoords||e.coords.cur.page});if(!(this.result=i).changed&&(!o||o<this.states.length)&&e.interacting())return!1;if(t.modifiedCoords){var a=e.coords.cur.page,u=t.modifiedCoords.x-a.x,s=t.modifiedCoords.y-a.y;i.coords.x+=u,i.coords.y+=s,i.delta.x+=u,i.delta.y+=s}this.applyToInteraction(t)}},{key:"beforeEnd",value:function(t){var e=t.interaction,n=t.event,r=this.states;if(r&&r.length){for(var o=!1,i=0;i<r.length;i++){var a=r[i],u=(t.state=a).options,s=a.methods,l=s.beforeEnd&&s.beforeEnd(t);if(l)return this.endResult=l,!1;o=o||!o&&this.shouldDo(u,!0,t.phase,!0)}o&&e.move({event:n,preEnd:!0})}}},{key:"stop",value:function(t){var e=t.interaction;if(this.states&&this.states.length){var n=(0,Si.default)({states:this.states,interactable:e.interactable,element:e.element,rect:null},t);this.fillArg(n);for(var r=0;r<this.states.length;r++){var o=this.states[r];(n.state=o).methods.stop&&o.methods.stop(n)}this.states=null,this.endResult=null}}},{key:"prepareStates",value:function(t){this.states=[];for(var e=0;e<t.length;e++){var n=t[e],r=n.options,o=n.methods,i=n.name;r&&!1===r.enabled||this.states.push({options:r,methods:o,index:e,name:i})}return this.states}},{key:"restoreInteractionCoords",value:function(t){var e=t.interaction,n=e.coords,r=e.rect,o=e.modification;if(o.result){for(var i=o.startDelta,a=o.result,u=a.delta,s=a.rectDelta,l=[[n.start,i],[n.cur,u]],c=0;c<l.length;c++){var f=Ei(l[c],2),p=f[0],d=f[1];p.page.x-=d.x,p.page.y-=d.y,p.client.x-=d.x,p.client.y-=d.y}r.left-=s.left,r.right-=s.right,r.top-=s.top,r.bottom-=s.bottom}}},{key:"shouldDo",value:function(t,e,n,r){return!(!t||!1===t.enabled||r&&!t.endOnly||t.endOnly&&!e||"start"===n&&!t.setStart)}},{key:"copyFrom",value:function(t){this.startOffset=t.startOffset,this.startDelta=t.startDelta,this.edges=t.edges,this.states=t.states.map(function(t){return(0,xi.default)(t)}),this.result=zi((0,Si.default)({},t.result.coords),(0,Si.default)({},t.result.rect))}},{key:"destroy",value:function(){for(var t in this)this[t]=null}}])&&Ti(t.prototype,n),r&&Ti(t,r),e}();function zi(t,e){return{rect:e,coords:t,delta:{x:0,y:0},rectDelta:{left:0,right:0,top:0,bottom:0},eventProps:[],changed:!0}}function Ai(t,e){return t?{left:e.x-t.left,top:e.y-t.top,right:t.right-e.x,bottom:t.bottom-e.y}:{left:0,top:0,right:0,bottom:0}}_i.default=Ii;var Ci={};Object.defineProperty(Ci,"__esModule",{value:!0}),Ci.makeModifier=function(t,r){function e(t){var e=t||{};for(var n in e.enabled=!1!==e.enabled,o)n in e||(e[n]=o[n]);return{options:e,methods:i,name:r}}var o=t.defaults,i={start:t.start,set:t.set,beforeEnd:t.beforeEnd,stop:t.stop};r&&"string"==typeof r&&(e._defaults=o,e._methods=i);return e},Ci.addEventModifiers=Fi,Ci.default=void 0;var Wi,Ri=(Wi=_i)&&Wi.__esModule?Wi:{default:Wi};function Fi(t){var e=t.iEvent,n=t.interaction.modification.result;n&&(e.modifiers=n.eventProps)}var Xi={id:"modifiers/base",install:function(t){t.defaults.perAction.modifiers=[]},listeners:{"interactions:new":function(t){var e=t.interaction;e.modification=new Ri.default(e)},"interactions:before-action-start":function(t){var e=t.interaction.modification;e.start(t,t.interaction.coords.start.page),t.interaction.edges=e.edges,e.applyToInteraction(t)},"interactions:before-action-move":function(t){return t.interaction.modification.setAndApply(t)},"interactions:before-action-end":function(t){return t.interaction.modification.beforeEnd(t)},"interactions:action-start":Fi,"interactions:action-move":Fi,"interactions:action-end":Fi,"interactions:after-action-start":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-move":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:stop":function(t){return t.interaction.modification.stop(t)}},before:["actions","action/drag","actions/resize","actions/gesture"]};Ci.default=Xi;var Yi={};function Ni(t){return(Ni="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Yi,"__esModule",{value:!0}),Yi.addTotal=Vi,Yi.applyPending=Ui,Yi.default=void 0;var Li=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Ni(t)&&"function"!=typeof t)return{default:t};var e=Bi();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function Bi(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Bi=function(){return t},t}function Vi(t){t.pointerIsDown&&(Hi(t.coords.cur,t.offset.total),t.offset.pending.x=0,t.offset.pending.y=0)}function qi(t){Ui(t.interaction)}function Ui(t){if(!(e=t).offset.pending.x&&!e.offset.pending.y)return!1;var e,n=t.offset.pending;return Hi(t.coords.cur,n),Hi(t.coords.delta,n),Li.addEdges(t.edges,t.rect,n),n.x=0,!(n.y=0)}function Gi(t){var e=t.x,n=t.y;this.offset.pending.x+=e,this.offset.pending.y+=n,this.offset.total.x+=e,this.offset.total.y+=n}function Hi(t,e){var n=t.page,r=t.client,o=e.x,i=e.y;n.x+=o,n.y+=i,r.x+=o,r.y+=i}En._ProxyMethods.offsetBy="";var Ki={id:"offset",install:function(t){t.Interaction.prototype.offsetBy=Gi},listeners:{"interactions:new":function(t){t.interaction.offset={total:{x:0,y:0},pending:{x:0,y:0}}},"interactions:update-pointer":function(t){return Vi(t.interaction)},"interactions:before-action-start":qi,"interactions:before-action-move":qi,"interactions:before-action-end":function(t){var e=t.interaction;if(Ui(e))return e.move({offset:!0}),e.end(),!1},"interactions:stop":function(t){var e=t.interaction;e.offset.total.x=0,e.offset.total.y=0,e.offset.pending.x=0,e.offset.pending.y=0}}};Yi.default=Ki;var $i={};function Zi(t){return(Zi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty($i,"__esModule",{value:!0}),$i.default=$i.InertiaState=void 0;var Ji=ua(_i),Qi=aa(Ci),ta=ua(Yi),ea=aa($),na=ua(Et),ra=aa(w),oa=ua(oe);function ia(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ia=function(){return t},t}function aa(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Zi(t)&&"function"!=typeof t)return{default:t};var e=ia();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function ua(t){return t&&t.__esModule?t:{default:t}}function sa(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function la(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var ca=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.interaction=t,la(this,"active",!1),la(this,"isModified",!1),la(this,"smoothEnd",!1),la(this,"allowResume",!1),la(this,"modification",null),la(this,"modifierCount",0),la(this,"modifierArg",null),la(this,"startCoords",null),la(this,"t0",0),la(this,"v0",0),la(this,"te",0),la(this,"targetOffset",null),la(this,"modifiedOffset",null),la(this,"currentOffset",null),la(this,"lambda_v0",0),la(this,"one_ve_v0",0),la(this,"timeout",null)}var t,n,r;return t=e,(n=[{key:"start",value:function(t){var e=this.interaction,n=fa(e);if(!n||!n.enabled)return!1;var r=e.coords.velocity.client,o=(0,na.default)(r.x,r.y),i=this.modification||(this.modification=new Ji.default(e));if(i.copyFrom(e.modification),this.t0=e._now(),this.allowResume=n.allowResume,this.v0=o,this.currentOffset={x:0,y:0},this.startCoords=e.coords.cur.page,this.modifierArg={interaction:e,interactable:e.interactable,element:e.element,rect:e.rect,edges:e.edges,pageCoords:this.startCoords,preEnd:!0,phase:"inertiastart"},this.t0-e.coords.cur.timeStamp<50&&o>n.minSpeed&&o>n.endSpeed)this.startInertia();else{if(i.result=i.setAll(this.modifierArg),!i.result.changed)return!1;this.startSmoothEnd()}return e.modification.result.rect=null,e.offsetBy(this.targetOffset),e._doPhase({interaction:e,event:t,phase:"inertiastart"}),e.offsetBy({x:-this.targetOffset.x,y:-this.targetOffset.y}),e.modification.result.rect=null,this.active=!0,e.simulation=this,!0}},{key:"startInertia",value:function(){var t=this,e=this.interaction.coords.velocity.client,n=fa(this.interaction),r=n.resistance,o=-Math.log(n.endSpeed/this.v0)/r;this.targetOffset={x:(e.x-o)/r,y:(e.y-o)/r},this.te=o,this.lambda_v0=r/this.v0,this.one_ve_v0=1-n.endSpeed/this.v0;var i=this.modification,a=this.modifierArg;a.pageCoords={x:this.startCoords.x+this.targetOffset.x,y:this.startCoords.y+this.targetOffset.y},i.result=i.setAll(a),i.result.changed&&(this.isModified=!0,this.modifiedOffset={x:this.targetOffset.x+i.result.delta.x,y:this.targetOffset.y+i.result.delta.y}),this.timeout=oa.default.request(function(){return t.inertiaTick()})}},{key:"startSmoothEnd",value:function(){var t=this;this.smoothEnd=!0,this.isModified=!0,this.targetOffset={x:this.modification.result.delta.x,y:this.modification.result.delta.y},this.timeout=oa.default.request(function(){return t.smoothEndTick()})}},{key:"inertiaTick",value:function(){var t,e,n,r,o,i,a,u=this,s=this.interaction,l=fa(s).resistance,c=(s._now()-this.t0)/1e3;if(c<this.te){var f,p=1-(Math.exp(-l*c)-this.lambda_v0)/this.one_ve_v0,d={x:(f=this.isModified?(e=t=0,n=this.targetOffset.x,r=this.targetOffset.y,o=this.modifiedOffset.x,i=this.modifiedOffset.y,{x:pa(a=p,t,n,o),y:pa(a,e,r,i)}):{x:this.targetOffset.x*p,y:this.targetOffset.y*p}).x-this.currentOffset.x,y:f.y-this.currentOffset.y};this.currentOffset.x+=d.x,this.currentOffset.y+=d.y,s.offsetBy(d),s.move(),this.timeout=oa.default.request(function(){return u.inertiaTick()})}else s.offsetBy({x:this.modifiedOffset.x-this.currentOffset.x,y:this.modifiedOffset.y-this.currentOffset.y}),this.end()}},{key:"smoothEndTick",value:function(){var t=this,e=this.interaction,n=e._now()-this.t0,r=fa(e).smoothEndDuration;if(n<r){var o=da(n,0,this.targetOffset.x,r),i=da(n,0,this.targetOffset.y,r),a={x:o-this.currentOffset.x,y:i-this.currentOffset.y};this.currentOffset.x+=a.x,this.currentOffset.y+=a.y,e.offsetBy(a),e.move({skipModifiers:this.modifierCount}),this.timeout=oa.default.request(function(){return t.smoothEndTick()})}else e.offsetBy({x:this.targetOffset.x-this.currentOffset.x,y:this.targetOffset.y-this.currentOffset.y}),this.end()}},{key:"resume",value:function(t){var e=t.pointer,n=t.event,r=t.eventTarget,o=this.interaction;o.offsetBy({x:-this.currentOffset.x,y:-this.currentOffset.y}),o.updatePointer(e,n,r,!0),o._doPhase({interaction:o,event:n,phase:"resume"}),(0,zt.copyCoords)(o.coords.prev,o.coords.cur),this.stop()}},{key:"end",value:function(){this.interaction.move(),this.interaction.end(),this.stop()}},{key:"stop",value:function(){this.active=this.smoothEnd=!1,this.interaction.simulation=null,oa.default.cancel(this.timeout)}}])&&sa(t.prototype,n),r&&sa(t,r),e}();function fa(t){var e=t.interactable,n=t.prepared;return e&&e.options&&n.name&&e.options[n.name].inertia}function pa(t,e,n,r){var o=1-t;return o*o*e+2*o*t*n+t*t*r}function da(t,e,n,r){return-n*(t/=r)*(t-2)+e}$i.InertiaState=ca;var va={id:"inertia",before:["modifiers/base"],install:function(t){var e=t.defaults;t.usePlugin(ta.default),t.usePlugin(Qi.default),t.actions.phases.inertiastart=!0,t.actions.phases.resume=!0,e.perAction.inertia={enabled:!1,resistance:10,minSpeed:100,endSpeed:10,allowResume:!0,smoothEndDuration:300}},listeners:{"interactions:new":function(t){var e=t.interaction;e.inertia=new ca(e)},"interactions:before-action-end":function(t){var e=t.interaction,n=t.event;return(!e._interacting||e.simulation||!e.inertia.start(n))&&null},"interactions:down":function(t){var e=t.interaction,n=t.eventTarget,r=e.inertia;if(r.active)for(var o=n;ra.element(o);){if(o===e.element){r.resume(t);break}o=ea.parentNode(o)}},"interactions:stop":function(t){var e=t.interaction.inertia;e.active&&e.stop()},"interactions:before-action-resume":function(t){var e=t.interaction.modification;e.stop(t),e.start(t,t.interaction.coords.cur.page),e.applyToInteraction(t)},"interactions:before-action-inertiastart":function(t){return t.interaction.modification.setAndApply(t)},"interactions:action-resume":Qi.addEventModifiers,"interactions:action-inertiastart":Qi.addEventModifiers,"interactions:after-action-inertiastart":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-resume":function(t){return t.interaction.modification.restoreInteractionCoords(t)}}};$i.default=va;var ya,ha={};function ga(t){return(ga="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(ha,"__esModule",{value:!0}),ha.init=ha.default=void 0;var ba=new(((ya=m({}))&&ya.__esModule?ya:{default:ya}).default),ma=ba.interactStatic;ha.default=ma;function Oa(t){return ba.init(t)}ha.init=Oa,"object"===("undefined"==typeof window?"undefined":ga(window))&&window&&Oa(window);var wa={};Object.defineProperty(wa,"__esModule",{value:!0}),wa.default=void 0;wa.default={};var _a={};Object.defineProperty(_a,"__esModule",{value:!0}),_a.default=void 0;_a.default={};var Pa={};function xa(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}Object.defineProperty(Pa,"__esModule",{value:!0}),Pa.default=void 0;Pa.default=function(v){function t(t,e){for(var n=v.range,r=v.limits,o=void 0===r?{left:-1/0,right:1/0,top:-1/0,bottom:1/0}:r,i=v.offset,a=void 0===i?{x:0,y:0}:i,u={range:n,grid:v,x:null,y:null},s=0;s<y.length;s++){var l=xa(y[s],2),c=l[0],f=l[1],p=Math.round((t-a.x)/v[c]),d=Math.round((e-a.y)/v[f]);u[c]=Math.max(o.left,Math.min(o.right,p*v[c]+a.x)),u[f]=Math.max(o.top,Math.min(o.bottom,d*v[f]+a.y))}return u}var y=[["x","y"],["left","top"],["right","bottom"],["width","height"]].filter(function(t){var e=xa(t,2),n=e[0],r=e[1];return n in v||r in v});return t.grid=v,t.coordFields=y,t};var Sa={};Object.defineProperty(Sa,"__esModule",{value:!0}),Object.defineProperty(Sa,"edgeTarget",{enumerable:!0,get:function(){return ja.default}}),Object.defineProperty(Sa,"elements",{enumerable:!0,get:function(){return Ma.default}}),Object.defineProperty(Sa,"grid",{enumerable:!0,get:function(){return ka.default}});var ja=Ea(wa),Ma=Ea(_a),ka=Ea(Pa);function Ea(t){return t&&t.__esModule?t:{default:t}}var Ta={};function Da(t){return(Da="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ta,"__esModule",{value:!0}),Ta.default=void 0;var Ia,za=(Ia=ct)&&Ia.__esModule?Ia:{default:Ia},Aa=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Da(t)&&"function"!=typeof t)return{default:t};var e=Ca();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(Sa);function Ca(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Ca=function(){return t},t}var Wa={id:"snappers",install:function(t){var e=t.interactStatic;e.snappers=(0,za.default)(e.snappers||{},Aa),e.createSnapGrid=e.snappers.grid}};Ta.default=Wa;var Ra={};Object.defineProperty(Ra,"__esModule",{value:!0}),Ra.aspectRatio=Ra.default=void 0;var Fa=Ya(ct),Xa=Ya(_i);function Ya(t){return t&&t.__esModule?t:{default:t}}function Na(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function La(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Na(Object(n),!0).forEach(function(t){Ba(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Na(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function Ba(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Va={start:function(t){var e=t.state,n=t.rect,r=t.edges,o=t.pageCoords,i=e.options.ratio,a=e.options,u=a.equalDelta,s=a.modifiers;"preserve"===i&&(i=n.width/n.height),e.startCoords=(0,Fa.default)({},o),e.startRect=(0,Fa.default)({},n),e.ratio=i,e.equalDelta=u;var l=e.linkedEdges={top:r.top||r.left&&!r.bottom,left:r.left||r.top&&!r.right,bottom:r.bottom||r.right&&!r.top,right:r.right||r.bottom&&!r.left};if(e.xIsPrimaryAxis=!(!r.left&&!r.right),e.equalDelta)e.edgeSign=(l.left?1:-1)*(l.top?1:-1);else{var c=e.xIsPrimaryAxis?l.top:l.left;e.edgeSign=c?-1:1}if((0,Fa.default)(t.edges,l),s&&s.length){var f=new Xa.default(t.interaction);f.copyFrom(t.interaction.modification),f.prepareStates(s),(e.subModification=f).startAll(La({},t))}},set:function(t){var e=t.state,n=t.rect,r=t.coords,o=(0,Fa.default)({},r),i=e.equalDelta?qa:Ua;if(i(e,e.xIsPrimaryAxis,r,n),!e.subModification)return null;var a=(0,Fa.default)({},n);(0,$t.addEdges)(e.linkedEdges,a,{x:r.x-o.x,y:r.y-o.y});var u=e.subModification.setAll(La({},t,{rect:a,edges:e.linkedEdges,pageCoords:r,prevCoords:r,prevRect:a})),s=u.delta;u.changed&&(i(e,Math.abs(s.x)>Math.abs(s.y),u.coords,u.rect),(0,Fa.default)(r,u.coords));return u.eventProps},defaults:{ratio:"preserve",equalDelta:!1,modifiers:[],enabled:!1}};function qa(t,e,n){var r=t.startCoords,o=t.edgeSign;e?n.y=r.y+(n.x-r.x)*o:n.x=r.x+(n.y-r.y)*o}function Ua(t,e,n,r){var o=t.startRect,i=t.startCoords,a=t.ratio,u=t.edgeSign;if(e){var s=r.width/a;n.y=i.y+(s-o.height)*u}else{var l=r.height*a;n.x=i.x+(l-o.width)*u}}Ra.aspectRatio=Va;var Ga=(0,Ci.makeModifier)(Va,"aspectRatio");Ra.default=Ga;var Ha={};Object.defineProperty(Ha,"__esModule",{value:!0}),Ha.default=void 0;function Ka(){}Ka._defaults={};var $a=Ka;Ha.default=$a;var Za={};function Ja(t){return(Ja="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Za,"__esModule",{value:!0}),Za.getRestrictionRect=iu,Za.restrict=Za.default=void 0;var Qa,tu=(Qa=ct)&&Qa.__esModule?Qa:{default:Qa},eu=ou(w),nu=ou($t);function ru(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ru=function(){return t},t}function ou(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Ja(t)&&"function"!=typeof t)return{default:t};var e=ru();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function iu(t,e,n){return eu.func(t)?nu.resolveRectLike(t,e.interactable,e.element,[n.x,n.y,e]):nu.resolveRectLike(t,e.interactable,e.element)}var au={start:function(t){var e=t.rect,n=t.startOffset,r=t.state,o=t.interaction,i=t.pageCoords,a=r.options,u=a.elementRect,s=(0,tu.default)({left:0,top:0,right:0,bottom:0},a.offset||{});if(e&&u){var l=iu(a.restriction,o,i);if(l){var c=l.right-l.left-e.width,f=l.bottom-l.top-e.height;c<0&&(s.left+=c,s.right+=c),f<0&&(s.top+=f,s.bottom+=f)}s.left+=n.left-e.width*u.left,s.top+=n.top-e.height*u.top,s.right+=n.right-e.width*(1-u.right),s.bottom+=n.bottom-e.height*(1-u.bottom)}r.offset=s},set:function(t){var e=t.coords,n=t.interaction,r=t.state,o=r.options,i=r.offset,a=iu(o.restriction,n,e);if(a){var u=nu.xywhToTlbr(a);e.x=Math.max(Math.min(u.right-i.right,e.x),u.left+i.left),e.y=Math.max(Math.min(u.bottom-i.bottom,e.y),u.top+i.top)}},defaults:{restriction:null,elementRect:null,offset:null,endOnly:!1,enabled:!1}};Za.restrict=au;var uu=(0,Ci.makeModifier)(au,"restrict");Za.default=uu;var su={};function lu(t){return(lu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(su,"__esModule",{value:!0}),su.restrictEdges=su.default=void 0;var cu,fu=(cu=ct)&&cu.__esModule?cu:{default:cu},pu=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==lu(t)&&"function"!=typeof t)return{default:t};var e=du();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function du(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return du=function(){return t},t}var vu={top:1/0,left:1/0,bottom:-1/0,right:-1/0},yu={top:-1/0,left:-1/0,bottom:1/0,right:1/0};function hu(t,e){for(var n=["top","left","bottom","right"],r=0;r<n.length;r++){var o=n[r];o in t||(t[o]=e[o])}return t}var gu={noInner:vu,noOuter:yu,start:function(t){var e,n=t.interaction,r=t.startOffset,o=t.state,i=o.options;if(i){var a=(0,Za.getRestrictionRect)(i.offset,n,n.coords.start.page);e=pu.rectToXY(a)}e=e||{x:0,y:0},o.offset={top:e.y+r.top,left:e.x+r.left,bottom:e.y-r.bottom,right:e.x-r.right}},set:function(t){var e=t.coords,n=t.edges,r=t.interaction,o=t.state,i=o.offset,a=o.options;if(n){var u=(0,fu.default)({},e),s=(0,Za.getRestrictionRect)(a.inner,r,u)||{},l=(0,Za.getRestrictionRect)(a.outer,r,u)||{};hu(s,vu),hu(l,yu),n.top?e.y=Math.min(Math.max(l.top+i.top,u.y),s.top+i.top):n.bottom&&(e.y=Math.max(Math.min(l.bottom+i.bottom,u.y),s.bottom+i.bottom)),n.left?e.x=Math.min(Math.max(l.left+i.left,u.x),s.left+i.left):n.right&&(e.x=Math.max(Math.min(l.right+i.right,u.x),s.right+i.right))}},defaults:{inner:null,outer:null,offset:null,endOnly:!1,enabled:!1}};su.restrictEdges=gu;var bu=(0,Ci.makeModifier)(gu,"restrictEdges");su.default=bu;var mu,Ou={};Object.defineProperty(Ou,"__esModule",{value:!0}),Ou.restrictRect=Ou.default=void 0;var wu=(0,((mu=ct)&&mu.__esModule?mu:{default:mu}).default)({get elementRect(){return{top:0,left:0,bottom:1,right:1}},set elementRect(t){}},Za.restrict.defaults),_u={start:Za.restrict.start,set:Za.restrict.set,defaults:wu};Ou.restrictRect=_u;var Pu=(0,Ci.makeModifier)(_u,"restrictRect");Ou.default=Pu;var xu={};function Su(t){return(Su="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(xu,"__esModule",{value:!0}),xu.restrictSize=xu.default=void 0;var ju,Mu=(ju=ct)&&ju.__esModule?ju:{default:ju},ku=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Su(t)&&"function"!=typeof t)return{default:t};var e=Eu();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function Eu(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Eu=function(){return t},t}var Tu={width:-1/0,height:-1/0},Du={width:1/0,height:1/0};var Iu={start:function(t){return su.restrictEdges.start(t)},set:function(t){var e=t.interaction,n=t.state,r=t.rect,o=t.edges,i=n.options;if(o){var a=ku.tlbrToXywh((0,Za.getRestrictionRect)(i.min,e,t.coords))||Tu,u=ku.tlbrToXywh((0,Za.getRestrictionRect)(i.max,e,t.coords))||Du;n.options={endOnly:i.endOnly,inner:(0,Mu.default)({},su.restrictEdges.noInner),outer:(0,Mu.default)({},su.restrictEdges.noOuter)},o.top?(n.options.inner.top=r.bottom-a.height,n.options.outer.top=r.bottom-u.height):o.bottom&&(n.options.inner.bottom=r.top+a.height,n.options.outer.bottom=r.top+u.height),o.left?(n.options.inner.left=r.right-a.width,n.options.outer.left=r.right-u.width):o.right&&(n.options.inner.right=r.left+a.width,n.options.outer.right=r.left+u.width),su.restrictEdges.set(t),n.options=i}},defaults:{min:null,max:null,endOnly:!1,enabled:!1}};xu.restrictSize=Iu;var zu=(0,Ci.makeModifier)(Iu,"restrictSize");xu.default=zu;var Au={};Object.defineProperty(Au,"__esModule",{value:!0}),Au.default=void 0;function Cu(){}Cu._defaults={};var Wu=Cu;Au.default=Wu;var Ru={};function Fu(t){return(Fu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ru,"__esModule",{value:!0}),Ru.snap=Ru.default=void 0;var Xu=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Fu(t)&&"function"!=typeof t)return{default:t};var e=Yu();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le);function Yu(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Yu=function(){return t},t}var Nu={start:function(t){var e,n,r,o=t.interaction,i=t.interactable,a=t.element,u=t.rect,s=t.state,l=t.startOffset,c=s.options,f=c.offsetWithOrigin?(n=(e=t).interaction.element,Xu.rect.rectToXY(Xu.rect.resolveRectLike(e.state.options.origin,null,null,[n]))||Xu.getOriginXY(e.interactable,n,e.interaction.prepared.name)):{x:0,y:0};if("startCoords"===c.offset)r={x:o.coords.start.page.x,y:o.coords.start.page.y};else{var p=Xu.rect.resolveRectLike(c.offset,i,a,[o]);(r=Xu.rect.rectToXY(p)||{x:0,y:0}).x+=f.x,r.y+=f.y}var d=c.relativePoints;s.offsets=u&&d&&d.length?d.map(function(t,e){return{index:e,relativePoint:t,x:l.left-u.width*t.x+r.x,y:l.top-u.height*t.y+r.y}}):[Xu.extend({index:0,relativePoint:null},r)]},set:function(t){var e=t.interaction,n=t.coords,r=t.state,o=r.options,i=r.offsets,a=Xu.getOriginXY(e.interactable,e.element,e.prepared.name),u=Xu.extend({},n),s=[];o.offsetWithOrigin||(u.x-=a.x,u.y-=a.y);for(var l=0;l<i.length;l++)for(var c=i[l],f=u.x-c.x,p=u.y-c.y,d=0,v=o.targets.length;d<v;d++){var y=o.targets[d],h=void 0;(h=Xu.is.func(y)?y(f,p,e,c,d):y)&&s.push({x:(Xu.is.number(h.x)?h.x:f)+c.x,y:(Xu.is.number(h.y)?h.y:p)+c.y,range:Xu.is.number(h.range)?h.range:o.range,source:y,index:d,offset:c})}for(var g={target:null,inRange:!1,distance:0,range:0,delta:{x:0,y:0}},b=0;b<s.length;b++){var m=s[b],O=m.range,w=m.x-u.x,_=m.y-u.y,P=Xu.hypot(w,_),x=P<=O;O===1/0&&g.inRange&&g.range!==1/0&&(x=!1),g.target&&!(x?g.inRange&&O!==1/0?P/O<g.distance/g.range:O===1/0&&g.range!==1/0||P<g.distance:!g.inRange&&P<g.distance)||(g.target=m,g.distance=P,g.range=O,g.inRange=x,g.delta.x=w,g.delta.y=_)}return g.inRange&&(n.x=g.target.x,n.y=g.target.y),r.closest=g},defaults:{range:1/0,targets:null,offset:null,offsetWithOrigin:!0,origin:null,relativePoints:null,endOnly:!1,enabled:!1}};Ru.snap=Nu;var Lu=(0,Ci.makeModifier)(Nu,"snap");Ru.default=Lu;var Bu={};function Vu(t){return(Vu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Bu,"__esModule",{value:!0}),Bu.snapSize=Bu.default=void 0;var qu,Uu=(qu=ct)&&qu.__esModule?qu:{default:qu},Gu=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Vu(t)&&"function"!=typeof t)return{default:t};var e=Hu();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function Hu(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Hu=function(){return t},t}function Ku(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var $u={start:function(t){var e=t.state,n=t.edges,r=e.options;if(!n)return null;t.state={options:{targets:null,relativePoints:[{x:n.left?0:1,y:n.top?0:1}],offset:r.offset||"self",origin:{x:0,y:0},range:r.range}},e.targetFields=e.targetFields||[["width","height"],["x","y"]],Ru.snap.start(t),e.offsets=t.state.offsets,t.state=e},set:function(t){var e=t.interaction,n=t.state,r=t.coords,o=n.options,i=n.offsets,a={x:r.x-i[0].x,y:r.y-i[0].y};n.options=(0,Uu.default)({},o),n.options.targets=[];for(var u=0;u<(o.targets||[]).length;u++){var s=(o.targets||[])[u],l=void 0;if(l=Gu.func(s)?s(a.x,a.y,e):s){for(var c=0;c<n.targetFields.length;c++){var f=Ku(n.targetFields[c],2),p=f[0],d=f[1];if(p in l||d in l){l.x=l[p],l.y=l[d];break}}n.options.targets.push(l)}}var v=Ru.snap.set(t);return n.options=o,v},defaults:{range:1/0,targets:null,offset:null,endOnly:!1,enabled:!1}};Bu.snapSize=$u;var Zu=(0,Ci.makeModifier)($u,"snapSize");Bu.default=Zu;var Ju={};Object.defineProperty(Ju,"__esModule",{value:!0}),Ju.snapEdges=Ju.default=void 0;var Qu=es(V),ts=es(ct);function es(t){return t&&t.__esModule?t:{default:t}}var ns={start:function(t){var e=t.edges;return e?(t.state.targetFields=t.state.targetFields||[[e.left?"left":"right",e.top?"top":"bottom"]],Bu.snapSize.start(t)):null},set:Bu.snapSize.set,defaults:(0,ts.default)((0,Qu.default)(Bu.snapSize.defaults),{targets:null,range:null,offset:{x:0,y:0}})};Ju.snapEdges=ns;var rs=(0,Ci.makeModifier)(ns,"snapEdges");Ju.default=rs;var os={};Object.defineProperty(os,"__esModule",{value:!0}),os.default=void 0;function is(){}is._defaults={};var as=is;os.default=as;var us={};Object.defineProperty(us,"__esModule",{value:!0}),us.default=void 0;function ss(){}ss._defaults={};var ls=ss;us.default=ls;var cs={};Object.defineProperty(cs,"__esModule",{value:!0}),cs.default=void 0;var fs=Ps(Ra),ps=Ps(Ha),ds=Ps(su),vs=Ps(Za),ys=Ps(Ou),hs=Ps(xu),gs=Ps(Au),bs=Ps(Ju),ms=Ps(Ru),Os=Ps(Bu),ws=Ps(os),_s=Ps(us);function Ps(t){return t&&t.__esModule?t:{default:t}}var xs={aspectRatio:fs.default,restrictEdges:ds.default,restrict:vs.default,restrictRect:ys.default,restrictSize:hs.default,snapEdges:bs.default,snap:ms.default,snapSize:Os.default,spring:ws.default,avoid:ps.default,transform:_s.default,rubberband:gs.default};cs.default=xs;var Ss={};Object.defineProperty(Ss,"__esModule",{value:!0}),Ss.default=void 0;var js=Es(Ta),Ms=Es(cs),ks=Es(Ci);function Es(t){return t&&t.__esModule?t:{default:t}}var Ts={id:"modifiers",install:function(t){var e=t.interactStatic;for(var n in t.usePlugin(ks.default),t.usePlugin(js.default),e.modifiers=Ms.default,Ms.default){var r=Ms.default[n],o=r._defaults,i=r._methods;o._methods=i,t.defaults.perAction[n]=o}}};Ss.default=Ts;var Ds={};Object.defineProperty(Ds,"__esModule",{value:!0}),Ds.default=void 0;Ds.default={};var Is={};Object.defineProperty(Is,"__esModule",{value:!0}),Is.PointerEvent=Is.default=void 0;var zs,As=(zs=Me)&&zs.__esModule?zs:{default:zs},Cs=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Rs(t)&&"function"!=typeof t)return{default:t};var e=Ws();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(zt);function Ws(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Ws=function(){return t},t}function Rs(t){return(Rs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Fs(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Xs(t){return(Xs=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ys(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ns(t,e){return(Ns=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Ls(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Bs=function(){function f(t,e,n,r,o,i){var a,u,s;if(!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,f),u=this,a=!(s=Xs(f).call(this,o))||"object"!==Rs(s)&&"function"!=typeof s?Ys(u):s,Ls(Ys(a),"type",void 0),Ls(Ys(a),"originalEvent",void 0),Ls(Ys(a),"pointerId",void 0),Ls(Ys(a),"pointerType",void 0),Ls(Ys(a),"double",void 0),Ls(Ys(a),"pageX",void 0),Ls(Ys(a),"pageY",void 0),Ls(Ys(a),"clientX",void 0),Ls(Ys(a),"clientY",void 0),Ls(Ys(a),"dt",void 0),Ls(Ys(a),"eventable",void 0),Cs.pointerExtend(Ys(a),n),n!==e&&Cs.pointerExtend(Ys(a),e),a.timeStamp=i,a.originalEvent=n,a.type=t,a.pointerId=Cs.getPointerId(e),a.pointerType=Cs.getPointerType(e),a.target=r,a.currentTarget=null,"tap"===t){var l=o.getPointerIndex(e);a.dt=a.timeStamp-o.pointers[l].downTime;var c=a.timeStamp-o.tapTime;a.double=!!(o.prevTap&&"doubletap"!==o.prevTap.type&&o.prevTap.target===a.target&&c<500)}else"doubletap"===t&&(a.dt=e.timeStamp-o.tapTime);return a}var t,e,n;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ns(t,e)}(f,As["default"]),t=f,(e=[{key:"_subtractOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX-=e,this.pageY-=n,this.clientX-=e,this.clientY-=n,this}},{key:"_addOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX+=e,this.pageY+=n,this.clientX+=e,this.clientY+=n,this}},{key:"preventDefault",value:function(){this.originalEvent.preventDefault()}}])&&Fs(t.prototype,e),n&&Fs(t,n),f}();Is.PointerEvent=Is.default=Bs;var Vs={};function qs(t){return(qs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Vs,"__esModule",{value:!0}),Vs.default=void 0;Ks(En),Ks(m({}));var Us=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==qs(t)&&"function"!=typeof t)return{default:t};var e=Hs();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),Gs=Ks(Is);function Hs(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Hs=function(){return t},t}function Ks(t){return t&&t.__esModule?t:{default:t}}var $s={id:"pointer-events/base",install:function(t){t.pointerEvents=$s,t.defaults.actions.pointerEvents=$s.defaults,Us.extend(t.actions.phaselessTypes,$s.types)},listeners:{"interactions:new":function(t){var e=t.interaction;e.prevTap=null,e.tapTime=0},"interactions:update-pointer":function(t){var e=t.down,n=t.pointerInfo;if(!e&&n.hold)return;n.hold={duration:1/0,timeout:null}},"interactions:move":function(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.duplicate,u=n.getPointerIndex(r);a||n.pointerIsDown&&!n.pointerWasMoved||(n.pointerIsDown&&clearTimeout(n.pointers[u].hold.timeout),Zs({interaction:n,pointer:r,event:o,eventTarget:i,type:"move"},e))},"interactions:down":function(t,e){!function(t,e){for(var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.pointerIndex,u=n.pointers[a].hold,s=Us.dom.getPath(i),l={interaction:n,pointer:r,event:o,eventTarget:i,type:"hold",targets:[],path:s,node:null},c=0;c<s.length;c++){var f=s[c];l.node=f,e.fire("pointerEvents:collect-targets",l)}if(!l.targets.length)return;for(var p=1/0,d=0;d<l.targets.length;d++){var v=l.targets[d].eventable.options.holdDuration;v<p&&(p=v)}u.duration=p,u.timeout=setTimeout(function(){Zs({interaction:n,eventTarget:i,pointer:r,event:o,type:"hold"},e)},p)}(t,e),Zs(t,e)},"interactions:up":function(t,e){var n,r,o,i,a,u;Qs(t),Zs(t,e),r=e,o=(n=t).interaction,i=n.pointer,a=n.event,u=n.eventTarget,o.pointerWasMoved||Zs({interaction:o,eventTarget:u,pointer:i,event:a,type:"tap"},r)},"interactions:cancel":function(t,e){Qs(t),Zs(t,e)}},PointerEvent:Gs.default,fire:Zs,collectEventTargets:Js,defaults:{holdDuration:600,ignoreFrom:null,allowFrom:null,origin:{x:0,y:0}},types:{down:!0,move:!0,up:!0,cancel:!0,tap:!0,doubletap:!0,hold:!0}};function Zs(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.type,u=t.targets,s=void 0===u?Js(t,e):u,l=new Gs.default(a,r,o,i,n,e.now());e.fire("pointerEvents:new",{pointerEvent:l});for(var c={interaction:n,pointer:r,event:o,eventTarget:i,targets:s,type:a,pointerEvent:l},f=0;f<s.length;f++){var p=s[f];for(var d in p.props||{})l[d]=p.props[d];var v=Us.getOriginXY(p.eventable,p.node);if(l._subtractOrigin(v),l.eventable=p.eventable,l.currentTarget=p.node,p.eventable.fire(l),l._addOrigin(v),l.immediatePropagationStopped||l.propagationStopped&&f+1<s.length&&s[f+1].node!==l.currentTarget)break}if(e.fire("pointerEvents:fired",c),"tap"===a){var y=l.double?Zs({interaction:n,pointer:r,event:o,eventTarget:i,type:"doubletap"},e):l;n.prevTap=y,n.tapTime=y.timeStamp}return l}function Js(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.type,u=n.getPointerIndex(r),s=n.pointers[u];if("tap"===a&&(n.pointerWasMoved||!s||s.downTarget!==i))return[];for(var l=Us.dom.getPath(i),c={interaction:n,pointer:r,event:o,eventTarget:i,type:a,path:l,targets:[],node:null},f=0;f<l.length;f++){var p=l[f];c.node=p,e.fire("pointerEvents:collect-targets",c)}return"hold"===a&&(c.targets=c.targets.filter(function(t){return t.eventable.options.holdDuration===n.pointers[u].hold.duration})),c.targets}function Qs(t){var e=t.interaction,n=t.pointerIndex;e.pointers[n].hold&&clearTimeout(e.pointers[n].hold.timeout)}var tl=$s;Vs.default=tl;var el={};Object.defineProperty(el,"__esModule",{value:!0}),el.default=void 0;rl(Is);var nl=rl(Vs);function rl(t){return t&&t.__esModule?t:{default:t}}function ol(t){var e=t.interaction;e.holdIntervalHandle&&(clearInterval(e.holdIntervalHandle),e.holdIntervalHandle=null)}var il={id:"pointer-events/holdRepeat",install:function(t){t.usePlugin(nl.default);var e=t.pointerEvents;e.defaults.holdRepeatInterval=0,e.types.holdrepeat=t.actions.phaselessTypes.holdrepeat=!0},listeners:["move","up","cancel","endall"].reduce(function(t,e){return t["pointerEvents:".concat(e)]=ol,t},{"pointerEvents:new":function(t){var e=t.pointerEvent;"hold"===e.type&&(e.count=(e.count||0)+1)},"pointerEvents:fired":function(t,e){var n=t.interaction,r=t.pointerEvent,o=t.eventTarget,i=t.targets;if("hold"===r.type&&i.length){var a=i[0].eventable.options.holdRepeatInterval;a<=0||(n.holdIntervalHandle=setTimeout(function(){e.pointerEvents.fire({interaction:n,eventTarget:o,type:"hold",pointer:r,event:r},e)},a))}}})};el.default=il;var al={};Object.defineProperty(al,"__esModule",{value:!0}),al.default=void 0;var ul,sl=(ul=ct)&&ul.__esModule?ul:{default:ul};function ll(t){return(0,sl.default)(this.events.options,t),this}var cl={id:"pointer-events/interactableTargets",install:function(t){var e=t.Interactable;e.prototype.pointerEvents=ll;var r=e.prototype._backCompatOption;e.prototype._backCompatOption=function(t,e){var n=r.call(this,t,e);return n===this&&(this.events.options[t]=e),n}},listeners:{"pointerEvents:collect-targets":function(t,e){var r=t.targets,o=t.node,i=t.type,a=t.eventTarget;e.interactables.forEachMatch(o,function(t){var e=t.events,n=e.options;e.types[i]&&e.types[i].length&&t.testIgnoreAllow(n,o,a)&&r.push({node:o,eventable:e,props:{interactable:t}})})},"interactable:new":function(t){var e=t.interactable;e.events.getRect=function(t){return e.getRect(t)}},"interactable:set":function(t,e){var n=t.interactable,r=t.options;(0,sl.default)(n.events.options,e.pointerEvents.defaults),(0,sl.default)(n.events.options,r.pointerEvents||{})}}};al.default=cl;var fl={};function pl(t){return(pl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(fl,"__esModule",{value:!0}),Object.defineProperty(fl,"holdRepeat",{enumerable:!0,get:function(){return vl.default}}),Object.defineProperty(fl,"interactableTargets",{enumerable:!0,get:function(){return yl.default}}),fl.pointerEvents=fl.default=void 0;var dl=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==pl(t)&&"function"!=typeof t)return{default:t};var e=gl();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(Vs);fl.pointerEvents=dl;var vl=hl(el),yl=hl(al);function hl(t){return t&&t.__esModule?t:{default:t}}function gl(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return gl=function(){return t},t}var bl={id:"pointer-events",install:function(t){t.usePlugin(dl),t.usePlugin(vl.default),t.usePlugin(yl.default)}};fl.default=bl;var ml={};Object.defineProperty(ml,"__esModule",{value:!0}),ml.install=wl,ml.default=void 0;var Ol;(Ol=k({}))&&Ol.__esModule;function wl(e){var t=e.Interactable;e.actions.phases.reflow=!0,t.prototype.reflow=function(t){return function(u,s,l){function t(){var e=c[d],t=u.getRect(e);if(!t)return"break";var n=le.arr.find(l.interactions.list,function(t){return t.interacting()&&t.interactable===u&&t.element===e&&t.prepared.name===s.name}),r=void 0;if(n)n.move(),p&&(r=n._reflowPromise||new f(function(t){n._reflowResolve=t}));else{var o=le.rect.tlbrToXywh(t),i={page:{x:o.x,y:o.y},client:{x:o.x,y:o.y},timeStamp:l.now()},a=le.pointer.coordsToEvent(i);r=function(t,e,n,r,o){var i=t.interactions.new({pointerType:"reflow"}),a={interaction:i,event:o,pointer:o,eventTarget:n,phase:"reflow"};i.interactable=e,i.element=n,i.prepared=(0,le.extend)({},r),i.prevEvent=o,i.updatePointer(o,o,n,!0),i._doPhase(a);var u=le.win.window.Promise?new le.win.window.Promise(function(t){i._reflowResolve=t}):null;i._reflowPromise=u,i.start(r,e,n),i._interacting?(i.move(a),i.end(o)):i.stop();return i.removePointer(o,o),i.pointerIsDown=!1,u}(l,u,e,s,a)}p&&p.push(r)}for(var c=le.is.string(u.target)?le.arr.from(u._context.querySelectorAll(u.target)):[u.target],f=le.win.window.Promise,p=f?[]:null,d=0;d<c.length;d++){if("break"===t())break}return p&&f.all(p).then(function(){return u})}(this,t,e)}}var _l={id:"reflow",install:wl,listeners:{"interactions:stop":function(t,e){var n=t.interaction;"reflow"===n.pointerType&&(n._reflowResolve&&n._reflowResolve(),le.arr.remove(e.interactions.list,n))}}};ml.default=_l;var Pl={};Object.defineProperty(Pl,"__esModule",{value:!0}),Pl.default=void 0;Pl.default={};var xl={};Object.defineProperty(xl,"__esModule",{value:!0}),xl.exchange=void 0;xl.exchange={};var Sl={};Object.defineProperty(Sl,"__esModule",{value:!0}),Sl.default=void 0;Sl.default={};var jl={};function Ml(t){return(Ml="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(jl,"__esModule",{value:!0}),jl.default=void 0;var kl=Hl(Qr),El=Hl(ao),Tl=Hl(uo),Dl=Hl(ti),Il=Hl(ai),zl=Hl(ui),Al=Hl(Un),Cl=(Hl(si),Gl(wi)),Wl=Hl($i),Rl=Hl(ha),Fl=Hl(Ss),Xl=Hl(Ds),Yl=Hl(Yi),Nl=Hl(fl),Ll=Hl(ml),Bl=Gl(Pl),Vl=Gl(zt),ql=Gl(Sl);function Ul(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Ul=function(){return t},t}function Gl(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Ml(t)&&"function"!=typeof t)return{default:t};var e=Ul();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function Hl(t){return t&&t.__esModule?t:{default:t}}Rl.default.use(Xl.default),Rl.default.use(Al.default),Rl.default.use(Yl.default),Rl.default.use(Il.default),Rl.default.use(El.default),Rl.default.use(Nl.default),Rl.default.use(Wl.default),Rl.default.use(Fl.default),Rl.default.use(Dl.default),Rl.default.use(kl.default),Rl.default.use(Tl.default),Rl.default.use(Ll.default),Rl.default.feedback=Cl,Rl.default.use(zl.default),Rl.default.vue={components:ql},Rl.default.__utils={exchange:xl.exchange,displace:Bl,pointer:Vl};var Kl=Rl.default;jl.default=Kl;var $l={exports:{}};Object.defineProperty($l.exports,"__esModule",{value:!0}),$l.exports.default=void 0;var Zl,Jl=(Zl=jl)&&Zl.__esModule?Zl:{default:Zl};function Ql(t){return(Ql="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}if("object"===Ql($l)&&$l)try{$l.exports=Jl.default}catch(t){}Jl.default.default=Jl.default;var tc=Jl.default;return $l.exports.default=tc,$l=$l.exports});



}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],4:[function(require,module,exports){
/*!
 * isect v3.0.0
 * (c) 2018 Andrei Kashcha.
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.isect = {})));
}(this, (function (exports) { 'use strict';

  /* follows "An implementation of top-down splaying"
   * by D. Sleator <sleator@cs.cmu.edu> March 1992
   */

  /**
   * @typedef {*} Key
   */


  /**
   * @typedef {*} Value
   */


  /**
   * @typedef {function(node:Node):void} Visitor
   */


  /**
   * @typedef {function(a:Key, b:Key):number} Comparator
   */


  /**
   * @param {function(node:Node):string} NodePrinter
   */


  /**
   * @typedef {Object}  Node
   * @property {Key}    Key
   * @property {Value=} data
   * @property {Node}   left
   * @property {Node}   right
   */

  var Node = function Node (key, data) {
    this.key  = key;
    this.data = data;
    this.left = null;
    this.right= null;
  };

  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }


  /**
   * Simple top down splay, not requiring i to be in the tree t.
   * @param {Key} i
   * @param {Node?} t
   * @param {Comparator} comparator
   */
  function splay (i, t, comparator) {
    if (t === null) { return t; }
    var l, r, y;
    var N = new Node();
    l = r = N;

    while (true) {
      var cmp = comparator(i, t.key);
      //if (i < t.key) {
      if (cmp < 0) {
        if (t.left === null) { break; }
        //if (i < t.left.key) {
        if (comparator(i, t.left.key) < 0) {
          y = t.left;                           /* rotate right */
          t.left = y.right;
          y.right = t;
          t = y;
          if (t.left === null) { break; }
        }
        r.left = t;                               /* link right */
        r = t;
        t = t.left;
      //} else if (i > t.key) {
      } else if (cmp > 0) {
        if (t.right === null) { break; }
        //if (i > t.right.key) {
        if (comparator(i, t.right.key) > 0) {
          y = t.right;                          /* rotate left */
          t.right = y.left;
          y.left = t;
          t = y;
          if (t.right === null) { break; }
        }
        l.right = t;                              /* link left */
        l = t;
        t = t.right;
      } else {
        break;
      }
    }
    /* assemble */
    l.right = t.left;
    r.left = t.right;
    t.left = N.right;
    t.right = N.left;
    return t;
  }


  /**
   * @param  {Key}        i
   * @param  {Value}      data
   * @param  {Comparator} comparator
   * @param  {Tree}       tree
   * @return {Node}      root
   */
  function insert (i, data, t, comparator, tree) {
    var node = new Node(i, data);

    tree._size++;

    if (t === null) {
      node.left = node.right = null;
      return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp < 0) {
      node.left = t.left;
      node.right = t;
      t.left = null;
    } else if (cmp >= 0) {
      node.right = t.right;
      node.left = t;
      t.right = null;
    }
    return node;
  }


  /**
   * Insert i into the tree t, unless it's already there.
   * @param  {Key}        i
   * @param  {Value}      data
   * @param  {Comparator} comparator
   * @param  {Tree}       tree
   * @return {Node}       root
   */
  function add (i, data, t, comparator, tree) {
    var node = new Node(i, data);

    if (t === null) {
      node.left = node.right = null;
      tree._size++;
      return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp === 0) { return t; }
    else {
      if (cmp < 0) {
        node.left = t.left;
        node.right = t;
        t.left = null;
      } else if (cmp > 0) {
        node.right = t.right;
        node.left = t;
        t.right = null;
      }
      tree._size++;
      return node;
    }
  }


  /**
   * Deletes i from the tree if it's there
   * @param {Key}        i
   * @param {Tree}       tree
   * @param {Comparator} comparator
   * @param {Tree}       tree
   * @return {Node}      new root
   */
  function remove (i, t, comparator, tree) {
    var x;
    if (t === null) { return null; }
    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp === 0) {               /* found it */
      if (t.left === null) {
        x = t.right;
      } else {
        x = splay(i, t.left, comparator);
        x.right = t.right;
      }
      tree._size--;
      return x;
    }
    return t;                         /* It wasn't there */
  }


  function split (key, v, comparator) {
    var left, right;
    if (v === null) {
      left = right = null;
    } else {
      v = splay(key, v, comparator);

      var cmp = comparator(v.key, key);
      if (cmp === 0) {
        left  = v.left;
        right = v.right;
      } else if (cmp < 0) {
        right   = v.right;
        v.right = null;
        left    = v;
      } else {
        left   = v.left;
        v.left = null;
        right  = v;
      }
    }
    return { left: left, right: right };
  }


  function merge (left, right, comparator) {
    if (right === null) { return left; }
    if (left  === null) { return right; }

    right = splay(left.key, right, comparator);
    right.left = left;
    return right;
  }


  /**
   * Prints level of the tree
   * @param  {Node}                        root
   * @param  {String}                      prefix
   * @param  {Boolean}                     isTail
   * @param  {Array<string>}               out
   * @param  {Function(node:Node):String}  printNode
   */
  function printRow (root, prefix, isTail, out, printNode) {
    if (root) {
      out(("" + prefix + (isTail ? '└── ' : '├── ') + (printNode(root)) + "\n"));
      var indent = prefix + (isTail ? '    ' : '│   ');
      if (root.left)  { printRow(root.left,  indent, false, out, printNode); }
      if (root.right) { printRow(root.right, indent, true,  out, printNode); }
    }
  }


  var Tree = function Tree (comparator) {
    if ( comparator === void 0 ) comparator = DEFAULT_COMPARE;

    this._comparator = comparator;
    this._root = null;
    this._size = 0;
  };

  var prototypeAccessors = { size: { configurable: true } };


  /**
   * Inserts a key, allows duplicates
   * @param{Key}  key
   * @param{Value=} data
   * @return {Node|null}
   */
  Tree.prototype.insert = function insert$1 (key, data) {
    return this._root = insert(key, data, this._root, this._comparator, this);
  };


  /**
   * Adds a key, if it is not present in the tree
   * @param{Key}  key
   * @param{Value=} data
   * @return {Node|null}
   */
  Tree.prototype.add = function add$1 (key, data) {
    return this._root = add(key, data, this._root, this._comparator, this);
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.remove = function remove$1 (key) {
    this._root = remove(key, this._root, this._comparator, this);
  };


  /**
   * Removes and returns the node with smallest key
   * @return {?Node}
   */
  Tree.prototype.pop = function pop () {
    var node = this._root;
    if (node) {
      while (node.left) { node = node.left; }
      this._root = splay(node.key,this._root, this._comparator);
      this._root = remove(node.key, this._root, this._comparator, this);
      return { key: node.key, data: node.data };
    }
    return null;
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.findStatic = function findStatic (key) {
    var current = this._root;
    var compare = this._comparator;
    while (current) {
      var cmp = compare(key, current.key);
      if (cmp === 0)  { return current; }
      else if (cmp < 0) { current = current.left; }
      else            { current = current.right; }
    }
    return null;
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.find = function find (key) {
    if (this._root) {
      this._root = splay(key, this._root, this._comparator);
      if (this._comparator(key, this._root.key) !== 0) { return null; }
    }
    return this._root;
  };


  /**
   * @param{Key} key
   * @return {Boolean}
   */
  Tree.prototype.contains = function contains (key) {
    var current = this._root;
    var compare = this._comparator;
    while (current) {
      var cmp = compare(key, current.key);
      if (cmp === 0)  { return true; }
      else if (cmp < 0) { current = current.left; }
      else            { current = current.right; }
    }
    return false;
  };


  /**
   * @param{Visitor} visitor
   * @param{*=}    ctx
   * @return {SplayTree}
   */
  Tree.prototype.forEach = function forEach (visitor, ctx) {
    var current = this._root;
    var Q = [];/* Initialize stack s */
    var done = false;

    while (!done) {
      if (current !==null) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length !== 0) {
          current = Q.pop();
          visitor.call(ctx, current);

          current = current.right;
        } else { done = true; }
      }
    }
    return this;
  };


  /**
   * Walk key range from `low` to `high`. Stops if `fn` returns a value.
   * @param{Key}    low
   * @param{Key}    high
   * @param{Function} fn
   * @param{*?}     ctx
   * @return {SplayTree}
   */
  Tree.prototype.range = function range (low, high, fn, ctx) {
      var this$1 = this;

    var Q = [];
    var compare = this._comparator;
    var node = this._root, cmp;

    while (Q.length !== 0 || node) {
      if (node) {
        Q.push(node);
        node = node.left;
      } else {
        node = Q.pop();
        cmp = compare(node.key, high);
        if (cmp > 0) {
          break;
        } else if (compare(node.key, low) >= 0) {
          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned
        }
        node = node.right;
      }
    }
    return this;
  };


  /**
   * Returns array of keys
   * @return {Array<Key>}
   */
  Tree.prototype.keys = function keys () {
    var keys = [];
    this.forEach(function (ref) {
        var key = ref.key;

        return keys.push(key);
      });
    return keys;
  };


  /**
   * Returns array of all the data in the nodes
   * @return {Array<Value>}
   */
  Tree.prototype.values = function values () {
    var values = [];
    this.forEach(function (ref) {
        var data = ref.data;

        return values.push(data);
      });
    return values;
  };


  /**
   * @return {Key|null}
   */
  Tree.prototype.min = function min () {
    if (this._root) { return this.minNode(this._root).key; }
    return null;
  };


  /**
   * @return {Key|null}
   */
  Tree.prototype.max = function max () {
    if (this._root) { return this.maxNode(this._root).key; }
    return null;
  };


  /**
   * @return {Node|null}
   */
  Tree.prototype.minNode = function minNode (t) {
      if ( t === void 0 ) t = this._root;

    if (t) { while (t.left) { t = t.left; } }
    return t;
  };


  /**
   * @return {Node|null}
   */
  Tree.prototype.maxNode = function maxNode (t) {
      if ( t === void 0 ) t = this._root;

    if (t) { while (t.right) { t = t.right; } }
    return t;
  };


  /**
   * Returns node at given index
   * @param{number} index
   * @return {?Node}
   */
  Tree.prototype.at = function at (index) {
    var current = this._root, done = false, i = 0;
    var Q = [];

    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = Q.pop();
          if (i === index) { return current; }
          i++;
          current = current.right;
        } else { done = true; }
      }
    }
    return null;
  };


  /**
   * @param{Node} d
   * @return {Node|null}
   */
  Tree.prototype.next = function next (d) {
    var root = this._root;
    var successor = null;

    if (d.right) {
      successor = d.right;
      while (successor.left) { successor = successor.left; }
      return successor;
    }

    var comparator = this._comparator;
    while (root) {
      var cmp = comparator(d.key, root.key);
      if (cmp === 0) { break; }
      else if (cmp < 0) {
        successor = root;
        root = root.left;
      } else { root = root.right; }
    }

    return successor;
  };


  /**
   * @param{Node} d
   * @return {Node|null}
   */
  Tree.prototype.prev = function prev (d) {
    var root = this._root;
    var predecessor = null;

    if (d.left !== null) {
      predecessor = d.left;
      while (predecessor.right) { predecessor = predecessor.right; }
      return predecessor;
    }

    var comparator = this._comparator;
    while (root) {
      var cmp = comparator(d.key, root.key);
      if (cmp === 0) { break; }
      else if (cmp < 0) { root = root.left; }
      else {
        predecessor = root;
        root = root.right;
      }
    }
    return predecessor;
  };


  /**
   * @return {SplayTree}
   */
  Tree.prototype.clear = function clear () {
    this._root = null;
    this._size = 0;
    return this;
  };


  /**
   * @return {NodeList}
   */
  Tree.prototype.toList = function toList$1 () {
    return toList(this._root);
  };


  /**
   * Bulk-load items. Both array have to be same size
   * @param{Array<Key>}  keys
   * @param{Array<Value>}[values]
   * @param{Boolean}     [presort=false] Pre-sort keys and values, using
   *                                       tree's comparator. Sorting is done
   *                                       in-place
   * @return {AVLTree}
   */
  Tree.prototype.load = function load (keys, values, presort) {
      if ( keys === void 0 ) keys = [];
      if ( values === void 0 ) values = [];
      if ( presort === void 0 ) presort = false;

    var size = keys.length;
    var comparator = this._comparator;

    // sort if needed
    if (presort) { sort(keys, values, 0, size - 1, comparator); }

    if (this._root === null) { // empty tree
      this._root = loadRecursive(this._root, keys, values, 0, size);
      this._size = size;
    } else { // that re-builds the whole tree from two in-order traversals
      var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
      size = this._size + size;
      this._root = sortedListToBST({ head: mergedList }, 0, size);
    }
    return this;
  };


  /**
   * @return {Boolean}
   */
  Tree.prototype.isEmpty = function isEmpty () { return this._root === null; };

  prototypeAccessors.size.get = function () { return this._size; };


  /**
   * @param{NodePrinter=} printNode
   * @return {String}
   */
  Tree.prototype.toString = function toString (printNode) {
      if ( printNode === void 0 ) printNode = function (n) { return n.key; };

    var out = [];
    printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);
    return out.join('');
  };


  Tree.prototype.update = function update (key, newKey, newData) {
    var comparator = this._comparator;
    var ref = split(key, this._root, comparator);
      var left = ref.left;
      var right = ref.right;
    this._size--;
    if (comparator(key, newKey) < 0) {
      right = insert(newKey, newData, right, comparator, this);
    } else {
      left = insert(newKey, newData, left, comparator, this);
    }
    this._root = merge(left, right, comparator);
  };


  Tree.prototype.split = function split$1 (key) {
    return split(key, this._root, this._comparator);
  };

  Object.defineProperties( Tree.prototype, prototypeAccessors );


  function loadRecursive (parent, keys, values, start, end) {
    var size = end - start;
    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var key    = keys[middle];
      var data   = values[middle];
      var node   = { key: key, data: data, parent: parent };
      node.left    = loadRecursive(node, keys, values, start, middle);
      node.right   = loadRecursive(node, keys, values, middle + 1, end);
      return node;
    }
    return null;
  }


  function createList(keys, values) {
    var head = { next: null };
    var p = head;
    for (var i = 0; i < keys.length; i++) {
      p = p.next = { key: keys[i], data: values[i] };
    }
    p.next = null;
    return head.next;
  }


  function toList (root) {
    var current = root;
    var Q = [], done = false;

    var head = { next: null };
    var p = head;

    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = p = p.next = Q.pop();
          current = current.right;
        } else { done = true; }
      }
    }
    p.next = null; // that'll work even if the tree was empty
    return head.next;
  }


  function sortedListToBST(list, start, end) {
    var size = end - start;
    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var left = sortedListToBST(list, start, middle);

      var root = list.head;
      root.left = left;

      list.head = list.head.next;

      root.right = sortedListToBST(list, middle + 1, end);
      return root;
    }
    return null;
  }


  function mergeLists (l1, l2, compare) {
    if ( compare === void 0 ) compare = function (a, b) { return a - b; };

    var head = {}; // dummy
    var p = head;

    var p1 = l1;
    var p2 = l2;

    while (p1 !== null && p2 !== null) {
      if (compare(p1.key, p2.key) < 0) {
        p.next = p1;
        p1 = p1.next;
      } else {
        p.next = p2;
        p2 = p2.next;
      }
      p = p.next;
    }

    if (p1 !== null)      { p.next = p1; }
    else if (p2 !== null) { p.next = p2; }

    return head.next;
  }


  function sort(keys, values, left, right, compare) {
    if (left >= right) { return; }

    var pivot = keys[(left + right) >> 1];
    var i = left - 1;
    var j = right + 1;

    while (true) {
      do { i++; } while (compare(keys[i], pivot) < 0);
      do { j--; } while (compare(keys[j], pivot) > 0);
      if (i >= j) { break; }

      var tmp = keys[i];
      keys[i] = keys[j];
      keys[j] = tmp;

      tmp = values[i];
      values[i] = values[j];
      values[j] = tmp;
    }

    sort(keys, values,  left,     j, compare);
    sort(keys, values, j + 1, right, compare);
  }

  function createEventQueue(byY) {
    var q = new Tree(byY);

    return {
      isEmpty: isEmpty,
      size: size,
      pop: pop,
      find: find,
      insert: insert
    }

    function find(p) {
      return q.find(p);
    }

    function size() {
      return q.size;
    }

    function isEmpty() {
      return q.isEmpty();
    }

    function insert(event) {
      // debugger;
      q.add(event.point, event);
    }

    function pop() {
      var node = q.pop();
      return node && node.data;
    }
  }

  /**
   * Just a collection of geometry related utilities
   */

  // This is used for precision checking (e.g. two numbers are equal
  // if their difference is smaller than this number). The value is 
  // chosen empirically. We still may run into precision related issues.
  // TODO: we should allow consumers to configure this.
  var EPS = 1e-9;//10;

  function getIntersectionXPoint(segment, xPos, yPos) {
    var dy1 = segment.from.y - yPos;
    var dy2 = yPos - segment.to.y;
    var dy = segment.to.y - segment.from.y;
    if (Math.abs(dy1) < EPS) {
      // The segment starts on the sweep line
      if (Math.abs(dy) < EPS) {
        // the segment is horizontal. Intersection is at the point
        if (xPos <= segment.from.x) { return segment.from.x; }
        if (xPos > segment.to.x) { return segment.to.x; }
        return xPos;
      }
      return segment.from.x;
    }
    
    var dx = (segment.to.x - segment.from.x); 
    var xOffset; 
    if (dy1 >= dy2) {
      xOffset = dy1 * (dx / dy); 
      return (segment.from.x - xOffset);
    } 
    xOffset = dy2 * (dx / dy);
    return (segment.to.x + xOffset);
  }

  function angle(dx, dy) {
    // https://stackoverflow.com/questions/16542042/fastest-way-to-sort-vectors-by-angle-without-actually-computing-that-angle
    var p = dx/(Math.abs(dx) + Math.abs(dy)); // -1 .. 1 increasing with x

    if (dy < 0) { return p - 1; }  // -2 .. 0 increasing with x
    return 1 - p               //  0 .. 2 decreasing with x
  }

  function intersectSegments(a, b) {
    //  https://stackoverflow.com/a/1968345/125351
    var aStart = a.from, bStart = b.from;
    var p0_x = aStart.x, p0_y = aStart.y,
        p2_x = bStart.x, p2_y = bStart.y;

    var s1_x = a.dx, s1_y = a.dy, s2_x = b.dx, s2_y = b.dy;
    var div = s1_x * s2_y - s2_x * s1_y;

    var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
    if (s < 0 || s > 1) { return; }

    var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

    if (t >= 0 && t <= 1) {
      return {
        x: p0_x - (t * s1_x),
        y: p0_y - (t * s1_y)
      }
    }
  }

  function samePoint(a, b) {
    return Math.abs(a.x - b.x) < EPS && Math.abs(a.y - b.y) < EPS;
  }

  /**
   * Creates a new sweep status data structure.
   */
  function createSweepStatus(onError, EPS$$1) {
    var lastPointY, prevY;
    var lastPointX, prevX;
    var useBelow = false;
    var status = new Tree(compareSegments);

    // To save on GC we return mutable object.
    var currentBoundary = {
      beforeLeft: null,
      left: null,
      right: null,
      afterRight: null,
    };

    var currentLeftRight = {left: null, right: null};

    return {
      /**
       * Add new segments into the status tree.
       */
      insertSegments: insertSegments,

      /**
       * Remove segments from the status tree.
       */
      deleteSegments: deleteSegments,

      /**
       * Returns segments that are to the left and right from a given point.
       */
      getLeftRightPoint: getLeftRightPoint,

      /**
       * For a given collections of segments finds the most left and the most right
       * segments. Also returns segments immediately before left, and after right segments.
       */
      getBoundarySegments: getBoundarySegments,

      findSegmentsWithPoint: findSegmentsWithPoint,

      /**
       * Current binary search tree with segments
       */
      status: status,

      /**
       * Introspection method that verifies if there are duplicates in the segment tree.
       * If there are - `onError()` is called.
       */
      checkDuplicate: checkDuplicate,

      /**
       * Prints current segments in order of their intersection with sweep line. Introspection method.
       */
      printStatus: printStatus,

      /**
       * Returns current position of the sweep line.
       */
      getLastPoint: function getLastPoint() {
        return {x: lastPointX, y: lastPointY};
      }
    }

    function compareSegments(a, b) {
      if (a === b) { return 0; }

      var ak = getIntersectionXPoint(a, lastPointX, lastPointY);
      var bk = getIntersectionXPoint(b, lastPointX, lastPointY);

      var res = ak - bk;
      if (Math.abs(res) >= EPS$$1) {
        // We are okay fine. Intersection distance between two segments
        // is good to give conclusive answer
        return res;
      }

      var aIsHorizontal = Math.abs(a.dy) < EPS$$1;
      var bIsHorizontal = Math.abs(b.dy) < EPS$$1;
      if (aIsHorizontal && bIsHorizontal) {
        return b.to.x - a.to.x;
      }
      // TODO: What if both a and b is horizontal?
      // move horizontal to end
      if (aIsHorizontal) { 
        return useBelow ? -1 : 1;
      }

      if (bIsHorizontal) {
        if (useBelow) {
          return (b.from.x >= lastPointX) ? -1 : 1
        }
        return -1;
        // return useBelow ? 1 : -1;
      }
      var pa = a.angle;
      var pb = b.angle;
      if (Math.abs(pa - pb) >= EPS$$1) {
        return useBelow ? pa - pb : pb - pa;
      }

      var segDist = a.from.y - b.from.y;
      if (Math.abs(segDist) >= EPS$$1) {
        return -segDist;
      }
      segDist = a.to.y - b.to.y;
      if (Math.abs(segDist) >= EPS$$1) {
        // TODO: Is this accurate?
        return -segDist;
      }

      return 0;
      // Could also use:
      // var aAngle = Math.atan2(a.from.y - a.to.y, a.from.x - a.to.x);
      // var bAngle = Math.atan2(b.from.y - b.to.y, b.from.x - b.to.x);
      // return useBelow ? bAngle - aAngle : aAngle - bAngle;
    }

    function getBoundarySegments(upper, interior) {
      var leftMost, rightMost, i;
      var uLength = upper.length;

      if (uLength > 0) {
        leftMost = rightMost = upper[0];
      } else {
        leftMost = rightMost = interior[0];
      }

      for (i = 1; i < uLength; ++i) {
        var s = upper[i];
        var cmp = compareSegments(leftMost, s);
        if (cmp > 0) { leftMost = s; }

        cmp = compareSegments(rightMost, s);
        if (cmp < 0) { rightMost = s; }
      }

      var startFrom = uLength > 0 ? 0 : 1;
      for (i = startFrom; i < interior.length; ++i) {
        s = interior[i];
        cmp = compareSegments(leftMost, s);
        if (cmp > 0) { leftMost = s; }

        cmp = compareSegments(rightMost, s);
        if (cmp < 0) { rightMost = s; }
      }

      // at this point we have our left/right segments in the status.
      // Let's find their prev/next elements and report them back:
      var left = status.find(leftMost);
      if (!left) {
        onError('Left is missing. Precision error?');
      }

      var right = status.find(rightMost);
      if (!right) {
        onError('Right is missing. Precision error?');
      }

      var beforeLeft = left && status.prev(left);
      var afterRight = right && status.next(right);

      while (afterRight && right.key.dy === 0 && afterRight.key.dy === 0) {
        // horizontal segments are special :(
        afterRight = status.next(afterRight);
      }

      currentBoundary.beforeLeft = beforeLeft && beforeLeft.key;
      currentBoundary.left = left && left.key;
      currentBoundary.right = right && right.key;
      currentBoundary.afterRight = afterRight && afterRight.key;

      return currentBoundary;
    }

    function getLeftRightPoint(p) {
      // We are trying to find left and right segments that are nearest to the
      // point p. For this we traverse the binary search tree, and remember
      // node with the shortest distance to p.
      var lastLeft;
      var current = status._root;
      var minX = Number.POSITIVE_INFINITY;
      while (current) {
        var x = getIntersectionXPoint(current.key, p.x, p.y);
        var dx = p.x - x;
        if (dx >= 0) {
          if (dx < minX) {
            minX = dx;
            lastLeft = current;
            current = current.left;
          } else {
            break;
          }
        } else {
          if (-dx < minX) {
            minX = -dx;
            lastLeft = current;
            current = current.right;
          } else {
            break;
          }
        }
      }

      currentLeftRight.left = lastLeft && lastLeft.key;
      var next = lastLeft && status.next(lastLeft);
      currentLeftRight.right = next && next.key;
      return currentLeftRight;

      // Conceptually, the code above should be equivalent to the code below;
      // The code below is easier to understand, but intuitively, the code above
      // should have better performance (as we do not traverse the entire status
      // tree)

      // var right, left,  x;
      // var all = status.keys()
      // for (var i = 0; i < all.length; ++i) {
      //   var segment = all[i];
      //   x = getIntersectionXPoint(segment, p.x, p.y);
      //   if (x > p.x && !right) {
      //     right = segment;
      //     break;
      //   } else if (x < p.x) {
      //     left = segment;
      //   }
      // }

      // currentLeftRight.left = left;
      // currentLeftRight.right = right;

      // return currentLeftRight;
    }

    function findSegmentsWithPoint(p, onFound) {
      // Option 1.
      // var arrResults = [];
      // status.forEach(current => {
      //   var x = getIntersectionXPoint(current.key, p.x, p.y);
      //   var dx = p.x - x;
      //   if (Math.abs(dx) < EPS) {
      //     onFound(current.key);
      //    // arrResults.push(current.key)
      //   }
      // });
      // return arrResults;

      // Option 2.

      // let current = status._root;
      // const Q = [];  /* Initialize stack s */
      // let done = false;
      // var res = [];
      // var breakEarly = false;

      // while (!done) {
      //   if (current !==  null) {
      //     Q.push(current);
      //     current = current.left;
      //   } else {
      //     if (Q.length !== 0) {
      //       current = Q.pop();

      //       var x = getIntersectionXPoint(current.key, p.x, p.y);
      //       var dx = p.x - x;
      //       if (Math.abs(dx) < EPS) {
      //         res.push(current.key)
      //         breakEarly = true;
      //       } else if (breakEarly) {
      //         done = true;
      //       }

      //       current = current.right;
      //     } else done = true;
      //   }
      // }

      // return res;

      // option 3.
      var current = status._root;

      while (current) {
        var x = getIntersectionXPoint(current.key, p.x, p.y);
        var dx = p.x - x;
        if (Math.abs(dx) < EPS$$1) {
          collectAdjacentNodes(current, p, onFound);
          break;
        } else if (dx < 0) {
          current = current.left;
        } else {
          current = current.right;
        }
      }
    }

    function collectAdjacentNodes(root, p, onFound) {
      onFound(root.key);
      goOverPredecessors(root.left, p, onFound);
      goOverSuccessors(root.right, p, onFound);
    }

    function goOverPredecessors(root, p, res) {
      if (!root) { return; }
      var x = getIntersectionXPoint(root.key, p.x, p.y);
      var dx = p.x - x;
      if (Math.abs(dx) < EPS$$1) {
        collectAdjacentNodes(root, p, res);
      } else {
        goOverPredecessors(root.right, p, res);
      }
    }

    function goOverSuccessors(root, p, res) {
      if (!root) { return; }
      var x = getIntersectionXPoint(root.key, p.x, p.y);
      var dx = p.x - x;
      if (Math.abs(dx) < EPS$$1) {
        collectAdjacentNodes(root, p, res);
      } else {
        goOverSuccessors(root.left, p, res);
      }
    }

    function checkDuplicate() {
      var prev;
      status.forEach(function (node) {
        var current = node.key;

        if (prev) {
          if (samePoint(prev.from, current.from) && samePoint(prev.to, current.to)) {
            // Likely you have received error before during segment removal.
            onError('Duplicate key in the status! This may be caused by Floating Point rounding error');
          }
        }
        prev = current;
      });
    }

    function printStatus(prefix) {
      if ( prefix === void 0 ) prefix = '';

      // eslint-disable-next-line
      console.log(prefix, 'status line: ', lastPointX, lastPointY);
      status.forEach(function (node) {
        var x = getIntersectionXPoint(node.key, lastPointX, lastPointY);
        // eslint-disable-next-line
        console.log(x + ' ' + node.key.name);
      });
    }

    function insertSegments(interior, upper, sweepLinePos) {
      lastPointY = sweepLinePos.y;
      lastPointX = sweepLinePos.x;
      var key;

      for (var i = 0; i < interior.length; ++i) {
        key = interior[i];
        status.add(key);
      }
      for (i = 0; i < upper.length; ++i) {
        key = upper[i];
        status.add(key);
      }
    }

    function deleteSegments(lower, interior, sweepLinePos) {
      // I spent most of the time debugging this method. Depending on the
      // algorithm state we can run into situation when dynamic keys of the
      // `status` tree predict wrong branch, and thus we are not able to find
      // the segment that needs to be deleted. If that happens I'm trying to
      // use previous point and repeat the process. This may result in 
      // incorrect state. In that case I report an error. 
      var i;
      var prevCount = status._size;
      prevX = lastPointX;
      prevY = lastPointY;
      lastPointY = sweepLinePos.y;
      lastPointX = sweepLinePos.x;

      useBelow = true;
      for(i = 0; i < lower.length; ++i) {
        removeSegment(lower[i], sweepLinePos);
      }
      for(i = 0; i < interior.length; ++i) {
        removeSegment(interior[i], sweepLinePos);
      }
      useBelow = false;

      if (status._size !== prevCount - interior.length - lower.length) {
        // This can happen when rounding error occurs. You can try scaling your input
        onError('Segments were not removed from a tree properly. Precision error?');
      }
    }

    function removeSegment(key, sweepLinePos) {
      if (status.find(key)) {
        status.remove(key);
      } else {
        lastPointX = prevX;
        lastPointY = prevY;
        if (status.find(key)) {
          status.remove(key);
        }
        lastPointY = sweepLinePos.y;
        lastPointX = sweepLinePos.x;
      }
    }
  }

  /**
   * Represents a single event in the sweep-line algorithm
   */
  var SweepEvent = function SweepEvent(point, segment) {
    this.point = point;
    if (segment) { this.from = [segment]; }
  };

  /**
   * A point on a line
   * 
   * @typedef {Object} Point
   * @property {number} x coordinate
   * @property {number} y coordinate
   */


  /**
   * @typedef {Object} Segment 
   * @property {Point} from start of the segment
   * @property {Point} to end of the segment
   */

  /**
   * @typedef {function(point : Point, interior : Segment[], lower : Segment[], upper : Segment[])} ReportIntersectionCallback
   */

  /**
   * @typedef {Object} ISectOptions 
   * @property {ReportIntersectionCallback} onFound 
   */

   /**
    * @typedef {Object} ISectResult
    */

  // We use EMPTY array to avoid pressure on garbage collector. Need to be
  // very cautious to not mutate this array.
  var EMPTY = [];

  /**
   * Finds all intersections among given segments.
   * 
   * The algorithm follows "Computation Geometry, Algorithms and Applications" book
   * by Mark de Berg, Otfried Cheong, Marc van Kreveld, and Mark Overmars.
   * 
   * Line is swept top-down
   * 
   * @param {Segment[]} segments
   * @param {ISectOptions=} options
   * @returns {ISectResult}
   */
  function isect(segments, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || defaultIntersectionReporter;

    var onError = (options && options.onError) || defaultErrorReporter;

    var eventQueue = createEventQueue(byY);
    var sweepStatus = createSweepStatus(onError, EPS);
    var lower, interior, lastPoint;

    segments.forEach(addSegment);

    return {
      /**
       * Find all intersections synchronously.
       * 
       * @returns array of found intersections.
       */
      run: run,

      /**
       * Performs a single step in the sweep line algorithm
       * 
       * @returns true if there was something to process; False if no more work to do
       */
      step: step,

      // Methods below are low level API for fine-grained control.
      // Don't use it unless you understand this code thoroughly

      /**
       * Add segment into the 
       */
      addSegment: addSegment,

      /**
       * Direct access to event queue. Queue contains segment endpoints and
       * pending detected intersections.
       */
      eventQueue: eventQueue, 

      /**
       * Direct access to sweep line status. "Status" holds information about
       * all intersected segments.
       */
      sweepStatus: sweepStatus,

      /**
       * Access to results array. Works only when you use default onFound() handler
       */
      results: results
    }

    function run() {
      while (!eventQueue.isEmpty()) {
        var eventPoint = eventQueue.pop();
        if (handleEventPoint(eventPoint)) {
          // they decided to stop.
          return;
        }    }

      return results;
    }

    function step() {
      if (!eventQueue.isEmpty()) {
        var eventPoint = eventQueue.pop();
        handleEventPoint(eventPoint);
        // Note: we don't check results of `handleEventPoint()`
        // assumption is that client controls `step()` and thus they 
        // know better if they want to stop.
        return true;
      }
      return false;
    }

    function handleEventPoint(p) {
      lastPoint = p.point;
      var upper = p.from || EMPTY;

      lower = interior = undefined;
      // TODO: move lower/interior into sweep status method?

      sweepStatus.findSegmentsWithPoint(lastPoint, addLowerOrInterior);
      // if (segmentsWithPoint) {
      //   segmentsWithPoint.forEach()
      // } 

      if (!lower) { lower = EMPTY; }
      if (!interior) { interior = EMPTY; }

      var uLength = upper.length;
      var iLength = interior.length;
      var lLength = lower.length;
      var hasIntersection = uLength + iLength + lLength > 1;
      var hasPointIntersection = !hasIntersection && (uLength === 0 && lLength === 0 && iLength > 0);

      if (hasIntersection || hasPointIntersection) {
        p.isReported = true;
        if (reportIntersection(lastPoint, union(interior, union(lower, upper)))) {
          return true;
        }
      }

      sweepStatus.deleteSegments(lower, interior, lastPoint);
      sweepStatus.insertSegments(interior, upper, lastPoint);

      var sLeft, sRight;

      var hasNoCrossing = (uLength + iLength === 0);

      if (hasNoCrossing) {
        var leftRight = sweepStatus.getLeftRightPoint(lastPoint);
        sLeft = leftRight.left;
        if (!sLeft) { return; }

        sRight = leftRight.right;
        if (!sRight) { return; }

        findNewEvent(sLeft, sRight, p);
      } else {
        var boundarySegments = sweepStatus.getBoundarySegments(upper, interior);

        findNewEvent(boundarySegments.beforeLeft, boundarySegments.left, p);
        findNewEvent(boundarySegments.right, boundarySegments.afterRight, p);
      }

      return false;
    }

    function addLowerOrInterior(s) {
      if (samePoint(s.to, lastPoint)) {
        if (!lower) { lower = [s]; }
        else { lower.push(s); }
      } else if (!samePoint(s.from, lastPoint)) {
        if (!interior) { interior = [s]; }
        else { interior.push(s); }
      }
    }

    function findNewEvent(left, right, p) {
      if (!left || !right) { return; }

      var intersection = intersectSegments(left, right);
      if (!intersection) {
          return;
      }

      var dy = p.point.y - intersection.y;
      // TODO: should I add dy to intersection.y?
      if (dy < -EPS) {
        // this means intersection happened after the sweep line. 
        // We already processed it.
        return;
      }
      if (Math.abs(dy) < EPS && intersection.x <= p.point.x) {
        return;
      }

      // Need to adjust floating point for this special case,
      // since otherwise it gives rounding errors:
      roundNearZero(intersection);

      var current = eventQueue.find(intersection);

      if (current && current.isReported) {
        // We already reported this event. No need to add it one more time
        // TODO: Is this case even possible?
        onError('We already reported this event.');
        return;
      }

      if (!current) {
        var event = new SweepEvent(intersection);
        eventQueue.insert(event);
      }
    }

    function defaultIntersectionReporter(p, segments) {
      results.push({
        point: p, 
        segments: segments
      });
    }

    function addSegment(segment) {
      var from = segment.from;
      var to = segment.to;

      // Small numbers give more precision errors. Rounding them to 0.
      roundNearZero(from);
      roundNearZero(to);

      var dy = from.y - to.y;

      // Note: dy is much smaller then EPS on purpose. I found that higher
      // precision here does less good - getting way more rounding errors.
      if (Math.abs(dy) < 1e-5) {
        from.y = to.y;
        segment.dy = 0;
      }
      if ((from.y < to.y) || (
          (from.y === to.y) && (from.x > to.x))
        ) {
        var temp = from;
        from = segment.from = to; 
        to = segment.to = temp;
      }

      // We pre-compute some immutable properties of the segment
      // They are used quite often in the tree traversal, and pre-computation
      // gives significant boost:
      segment.dy = from.y - to.y;
      segment.dx = from.x - to.x;
      segment.angle = angle(segment.dy, segment.dx);

      var isPoint = segment.dy === segment.dx && segment.dy === 0;
      var prev = eventQueue.find(from);
      if (prev && !isPoint) {
        // this detects identical segments early. Without this check
        // the algorithm would break since sweep line has no means to
        // detect identical segments.
        var prevFrom = prev.data.from;
        if (prevFrom) {
          for (var i = 0; i < prevFrom.length; ++i) {
            var s = prevFrom[i];
            if (samePoint(s.to, to)) {
              reportIntersection(s.from, [s.from, s.to]);
              reportIntersection(s.to, [s.from, s.to]);
              return;
            }
          }
        }
      }

      if (!isPoint) {
        if (prev) {
          if (prev.data.from) { prev.data.from.push(segment); }
          else { prev.data.from = [segment]; }
        } else {
          var e = new SweepEvent(from, segment);
          eventQueue.insert(e);
        }
        var event = new SweepEvent(to);
        eventQueue.insert(event);
      } else {
        var event = new SweepEvent(to);
        eventQueue.insert(event);
      }
    } 
  }

  function roundNearZero(point) {
    if (Math.abs(point.x) < EPS) { point.x = 0; }
    if (Math.abs(point.y) < EPS) { point.y = 0; }
  }

  function defaultErrorReporter(errorMessage) {
    throw new Error(errorMessage);
  }

  function union(a, b) {
    if (!a) { return b; }
    if (!b) { return a; }

    return a.concat(b);
  }

  function byY(a, b) {
    // decreasing Y 
    var res = b.y - a.y;
    // TODO: This might mess up the status tree.
    if (Math.abs(res) < EPS) {
      // increasing x.
      res = a.x - b.x;
      if (Math.abs(res) < EPS) { res = 0; }
    }

    return res;
  }

  function intersectSegments$1(a, b) {
    // Note: this is almost the same as geom.intersectSegments()
    // The main difference is that we don't have a pre-computed
    // value for dx/dy on the segments.
    //  https://stackoverflow.com/a/1968345/125351
    var aStart = a.from, bStart = b.from;
    var p0_x = aStart.x, p0_y = aStart.y,
        p2_x = bStart.x, p2_y = bStart.y;

    var s1_x = a.from.x - a.to.x, s1_y = a.from.y - a.to.y, s2_x = b.from.x - b.to.x, s2_y = b.from.y - b.to.y;
    var div = s1_x * s2_y - s2_x * s1_y;

    var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
    if (s < 0 || s > 1) { return; }

    var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

    if (t >= 0 && t <= 1) {
      return {
        x: p0_x - (t * s1_x),
        y: p0_y - (t * s1_y)
      }
    }
  }

  /**
   * This is a brute force solution with O(n^2) performance.
   * (`n` is number of segments).
   * 
   * Use this when number of lines is low, and number of intersections
   * is high.
   */
  function brute(lines, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || 
                              defaultIntersectionReporter;
    var asyncState;

    return {
      /**
       * Execute brute force of the segment intersection search
       */
      run: run,
      /**
       * Access to results array. Works only when you use default onFound() handler
       */
      results: results,

      /**
       * Performs a single step in the brute force algorithm ()
       */
      step: step
    }

    function step() {
      if (!asyncState) {
        asyncState = {
          i: 0
        };
      }
      var test = lines[asyncState.i];
      for (var j = asyncState.i + 1; j < lines.length; ++j) {
        var other = lines[j];
        var pt = intersectSegments$1(test, other);
        if (pt) {
          if (reportIntersection(pt, [test, other])) {
            return;
          }
        }
      }
      asyncState.i += 1;
      return asyncState.i < lines.length;
    }

    function run() {
      for(var i = 0; i < lines.length; ++i) {
        var test = lines[i];
        for (var j = i + 1; j < lines.length; ++j) {
          var other = lines[j];
          var pt = intersectSegments$1(test, other);
          if (pt) {
            if (reportIntersection(pt, [test, other])) {
              return;
            }
          }
        }
      }
      return results;
    }

    function defaultIntersectionReporter(p, interior) {
      results.push({
        point: p, 
        segments: interior
      });
    }
  }

  var ARRAY_TYPES = [
      Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
      Int32Array, Uint32Array, Float32Array, Float64Array
  ];

  var VERSION = 3; // serialized format version

  var Flatbush = function Flatbush(numItems, nodeSize, ArrayType, data) {
      var this$1 = this;

      if (numItems === undefined) { throw new Error('Missing required argument: numItems.'); }
      if (isNaN(numItems) || numItems <= 0) { throw new Error(("Unpexpected numItems value: " + numItems + ".")); }

      this.numItems = +numItems;
      this.nodeSize = Math.min(Math.max(+nodeSize || 16, 2), 65535);

      // calculate the total number of nodes in the R-tree to allocate space for
      // and the index of each tree level (used in search later)
      var n = numItems;
      var numNodes = n;
      this._levelBounds = [n * 4];
      do {
          n = Math.ceil(n / this$1.nodeSize);
          numNodes += n;
          this$1._levelBounds.push(numNodes * 4);
      } while (n !== 1);

      this.ArrayType = ArrayType || Float64Array;
      this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;

      var arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
      var nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;

      if (arrayTypeIndex < 0) {
          throw new Error(("Unexpected typed array class: " + ArrayType + "."));
      }

      if (data && (data instanceof ArrayBuffer)) {
          this.data = data;
          this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
          this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);

          this._pos = numNodes * 4;
          this.minX = this._boxes[this._pos - 4];
          this.minY = this._boxes[this._pos - 3];
          this.maxX = this._boxes[this._pos - 2];
          this.maxY = this._boxes[this._pos - 1];

      } else {
          this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
          this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
          this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
          this._pos = 0;
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;

          new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);
          new Uint16Array(this.data, 2, 1)[0] = nodeSize;
          new Uint32Array(this.data, 4, 1)[0] = numItems;
      }
  };

  Flatbush.from = function from (data) {
      if (!(data instanceof ArrayBuffer)) {
          throw new Error('Data must be an instance of ArrayBuffer.');
      }
      var ref = new Uint8Array(data, 0, 2);
          var magic = ref[0];
          var versionAndType = ref[1];
      if (magic !== 0xfb) {
          throw new Error('Data does not appear to be in a Flatbush format.');
      }
      if (versionAndType >> 4 !== VERSION) {
          throw new Error(("Got v" + (versionAndType >> 4) + " data when expected v" + VERSION + "."));
      }
      var ref$1 = new Uint16Array(data, 2, 1);
          var nodeSize = ref$1[0];
      var ref$2 = new Uint32Array(data, 4, 1);
          var numItems = ref$2[0];

      return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);
  };

  Flatbush.prototype.add = function add (minX, minY, maxX, maxY) {
      var index = this._pos >> 2;
      this._indices[index] = index;
      this._boxes[this._pos++] = minX;
      this._boxes[this._pos++] = minY;
      this._boxes[this._pos++] = maxX;
      this._boxes[this._pos++] = maxY;

      if (minX < this.minX) { this.minX = minX; }
      if (minY < this.minY) { this.minY = minY; }
      if (maxX > this.maxX) { this.maxX = maxX; }
      if (maxY > this.maxY) { this.maxY = maxY; }
  };

  Flatbush.prototype.finish = function finish () {
          var this$1 = this;

      if (this._pos >> 2 !== this.numItems) {
          throw new Error(("Added " + (this._pos >> 2) + " items when expected " + (this.numItems) + "."));
      }

      var width = this.maxX - this.minX;
      var height = this.maxY - this.minY;
      var hilbertValues = new Uint32Array(this.numItems);
      var hilbertMax = (1 << 16) - 1;

      // map item centers into Hilbert coordinate space and calculate Hilbert values
      for (var i = 0; i < this.numItems; i++) {
          var pos = 4 * i;
          var minX = this$1._boxes[pos++];
          var minY = this$1._boxes[pos++];
          var maxX = this$1._boxes[pos++];
          var maxY = this$1._boxes[pos++];
          var x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this$1.minX) / width);
          var y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this$1.minY) / height);
          hilbertValues[i] = hilbert(x, y);
      }

      // sort items by their Hilbert value (for packing later)
      sort$1(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1);

      // generate nodes at each tree level, bottom-up
      for (var i$1 = 0, pos$1 = 0; i$1 < this._levelBounds.length - 1; i$1++) {
          var end = this$1._levelBounds[i$1];

          // generate a parent node for each block of consecutive <nodeSize> nodes
          while (pos$1 < end) {
              var nodeMinX = Infinity;
              var nodeMinY = Infinity;
              var nodeMaxX = -Infinity;
              var nodeMaxY = -Infinity;
              var nodeIndex = pos$1;

              // calculate bbox for the new node
              for (var i$2 = 0; i$2 < this.nodeSize && pos$1 < end; i$2++) {
                  var minX$1 = this$1._boxes[pos$1++];
                  var minY$1 = this$1._boxes[pos$1++];
                  var maxX$1 = this$1._boxes[pos$1++];
                  var maxY$1 = this$1._boxes[pos$1++];
                  if (minX$1 < nodeMinX) { nodeMinX = minX$1; }
                  if (minY$1 < nodeMinY) { nodeMinY = minY$1; }
                  if (maxX$1 > nodeMaxX) { nodeMaxX = maxX$1; }
                  if (maxY$1 > nodeMaxY) { nodeMaxY = maxY$1; }
              }

              // add the new node to the tree data
              this$1._indices[this$1._pos >> 2] = nodeIndex;
              this$1._boxes[this$1._pos++] = nodeMinX;
              this$1._boxes[this$1._pos++] = nodeMinY;
              this$1._boxes[this$1._pos++] = nodeMaxX;
              this$1._boxes[this$1._pos++] = nodeMaxY;
          }
      }
  };

  Flatbush.prototype.search = function search (minX, minY, maxX, maxY, filterFn) {
          var this$1 = this;

      if (this._pos !== this._boxes.length) {
          throw new Error('Data not yet indexed - call index.finish().');
      }

      var nodeIndex = this._boxes.length - 4;
      var level = this._levelBounds.length - 1;
      var queue = [];
      var results = [];

      while (nodeIndex !== undefined) {
          // find the end index of the node
          var end = Math.min(nodeIndex + this$1.nodeSize * 4, this$1._levelBounds[level]);

          // search through child nodes
          for (var pos = nodeIndex; pos < end; pos += 4) {
              var index = this$1._indices[pos >> 2];

              // check if node bbox intersects with query bbox
              if (maxX < this$1._boxes[pos]) { continue; } // maxX < nodeMinX
              if (maxY < this$1._boxes[pos + 1]) { continue; } // maxY < nodeMinY
              if (minX > this$1._boxes[pos + 2]) { continue; } // minX > nodeMaxX
              if (minY > this$1._boxes[pos + 3]) { continue; } // minY > nodeMaxY

              if (nodeIndex < this$1.numItems * 4) {
                  if (filterFn === undefined || filterFn(index)) {
                      results.push(index); // leaf item
                  }

              } else {
                  queue.push(index); // node; add it to the search queue
                  queue.push(level - 1);
              }
          }

          level = queue.pop();
          nodeIndex = queue.pop();
      }

      return results;
  };

  // custom quicksort that sorts bbox data alongside the hilbert values
  function sort$1(values, boxes, indices, left, right) {
      if (left >= right) { return; }

      var pivot = values[(left + right) >> 1];
      var i = left - 1;
      var j = right + 1;

      while (true) {
          do { i++; } while (values[i] < pivot);
          do { j--; } while (values[j] > pivot);
          if (i >= j) { break; }
          swap(values, boxes, indices, i, j);
      }

      sort$1(values, boxes, indices, left, j);
      sort$1(values, boxes, indices, j + 1, right);
  }

  // swap two values and two corresponding boxes
  function swap(values, boxes, indices, i, j) {
      var temp = values[i];
      values[i] = values[j];
      values[j] = temp;

      var k = 4 * i;
      var m = 4 * j;

      var a = boxes[k];
      var b = boxes[k + 1];
      var c = boxes[k + 2];
      var d = boxes[k + 3];
      boxes[k] = boxes[m];
      boxes[k + 1] = boxes[m + 1];
      boxes[k + 2] = boxes[m + 2];
      boxes[k + 3] = boxes[m + 3];
      boxes[m] = a;
      boxes[m + 1] = b;
      boxes[m + 2] = c;
      boxes[m + 3] = d;

      var e = indices[i];
      indices[i] = indices[j];
      indices[j] = e;
  }

  // Fast Hilbert curve algorithm by http://threadlocalmutex.com/
  // Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)
  function hilbert(x, y) {
      var a = x ^ y;
      var b = 0xFFFF ^ a;
      var c = 0xFFFF ^ (x | y);
      var d = x & (y ^ 0xFFFF);

      var A = a | (b >> 1);
      var B = (a >> 1) ^ a;
      var C = ((c >> 1) ^ (b & (d >> 1))) ^ c;
      var D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;

      a = A; b = B; c = C; d = D;
      A = ((a & (a >> 2)) ^ (b & (b >> 2)));
      B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));
      C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));
      D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));

      a = A; b = B; c = C; d = D;
      A = ((a & (a >> 4)) ^ (b & (b >> 4)));
      B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));
      C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));
      D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));

      a = A; b = B; c = C; d = D;
      C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));
      D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));

      a = C ^ (C >> 1);
      b = D ^ (D >> 1);

      var i0 = x ^ y;
      var i1 = b | (0xFFFF ^ (i0 | a));

      i0 = (i0 | (i0 << 8)) & 0x00FF00FF;
      i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;
      i0 = (i0 | (i0 << 2)) & 0x33333333;
      i0 = (i0 | (i0 << 1)) & 0x55555555;

      i1 = (i1 | (i1 << 8)) & 0x00FF00FF;
      i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;
      i1 = (i1 | (i1 << 2)) & 0x33333333;
      i1 = (i1 | (i1 << 1)) & 0x55555555;

      return ((i1 << 1) | i0) >>> 0;
  }

  /**
   * This implementation is inspired by discussion here 
   * https://twitter.com/mourner/status/1049325199617921024 and 
   * here https://github.com/anvaka/isect/issues/1
   * 
   * It builds an index of all segments using static spatial index
   * and then for each segment it queries overlapping rectangles.
   */
  function bush(lines, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || 
                              defaultIntersectionReporter;
    var asyncState;

    var index = new Flatbush(lines.length);
    lines.forEach(addToIndex);
    index.finish();

    return {
      run: run,
      step: step,
      results: results,

      // undocumented, don't use unless you know what you are doing:
      checkIntersection: checkIntersection
    }

    function run() {
      for (var i = 0; i < lines.length; ++i) {
        if (checkIntersection(lines[i], i)) {
          return; // stop early
        }
      }
      return results;
    }

    function checkIntersection(currentSegment, currentId) {
      // sorry about code duplication.
      var minX = currentSegment.from.x; var maxX = currentSegment.to.x;
      var minY = currentSegment.from.y; var maxY = currentSegment.to.y;
      var t;
      if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
      if (minY > maxY) { t = minY; minY = maxY; maxY = t; }

      var ids = index.search(minX, minY, maxX, maxY);

      for (var i = 0; i < ids.length; ++i) {
        var segmentIndex = ids[i];
        if (segmentIndex <= currentId) { continue; } // we have either reported it, or it is current.

        var otherSegment = lines[segmentIndex];
        var point = intersectSegments$1(otherSegment, currentSegment);

        if (point) {
          if (reportIntersection(point, [currentSegment, otherSegment])) {
            // stop early
            return true;
          }
        }
      }
    }

    function step() {
      if (!asyncState) {
        asyncState = {i: 0};
      }
      var test = lines[asyncState.i];
      checkIntersection(test, asyncState.i);
      asyncState.i += 1;
      return asyncState.i < lines.length;
    }


    function addToIndex(line) {
      var minX = line.from.x; var maxX = line.to.x;
      var minY = line.from.y; var maxY = line.to.y;
      var t;
      if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
      if (minY > maxY) { t = minY; minY = maxY; maxY = t; }
      index.add(minX, minY, maxX, maxY);
    }

    function defaultIntersectionReporter(p, interior) {
      results.push({
        point: p, 
        segments: interior
      });
    }
  }

  exports.sweep = isect;
  exports.brute = brute;
  exports.bush = bush;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],5:[function(require,module,exports){
/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
 * @license
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).jsts={})}(this,(function(t){"use strict";class e{constructor(){e.constructor_.apply(this,arguments)}static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}getClass(){return e}get interfaces_(){return[]}}function n(t){this.message=t}function s(t,e){this.low=0|e,this.high=0|t}function i(){}function r(){}function o(){}function l(){}function a(){}function c(t){this.name="RuntimeException",this.message=t,this.stack=(new Error).stack,Error.call(this,t)}e.constructor_=function(){},s.toBinaryString=function(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n},i.isNaN=t=>Number.isNaN(t),i.isInfinite=t=>!Number.isFinite(t),i.MAX_VALUE=Number.MAX_VALUE,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=new Float64Array(1),e=new Int32Array(t.buffer);i.doubleToLongBits=function(n){t[0]=n;let i=0|e[0],r=0|e[1];return 2146435072==(2146435072&r)&&0!=(1048575&r)&&0!==i&&(i=0,r=2146959360),new s(r,i)},i.longBitsToDouble=function(n){return e[0]=n.low,e[1]=n.high,t[0]}}():function(){const t=Math.log2,e=Math.floor,n=Math.pow,r=function(){for(let s=53;s>0;s--){const i=n(2,s)-1;if(e(t(i))+1===s)return i}return 0}();i.doubleToLongBits=function(i){let o,l,a,c,h,u,g,d,_;if(i<0||1/i===Number.NEGATIVE_INFINITY?(u=1<<31,i=-i):u=0,0===i)return _=0,d=u,new s(d,_);if(i===1/0)return _=0,d=2146435072|u,new s(d,_);if(i!=i)return _=0,d=2146959360,new s(d,_);if(c=0,_=0,o=e(i),o>1)if(o<=r)c=e(t(o)),c<=20?(_=0,d=o<<20-c&1048575):(a=c-20,l=n(2,a),_=o%l<<32-a,d=o/l&1048575);else for(a=o,_=0;l=a/2,a=e(l),0!==a;)c++,_>>>=1,_|=(1&d)<<31,d>>>=1,l!==a&&(d|=524288);if(g=c+1023,h=0===o,o=i-o,c<52&&0!==o)for(a=0;;){if(l=2*o,l>=1?(o=l-1,h?(g--,h=!1):(a<<=1,a|=1,c++)):(o=l,h?0==--g&&(c++,h=!1):(a<<=1,c++)),20===c)d|=a,a=0;else if(52===c){_|=a;break}if(1===l){c<20?d|=a<<20-c:c<52&&(_|=a<<52-c);break}}return d|=g<<20,d|=u,new s(d,_)},i.longBitsToDouble=function(t){let e,s,i,r,o;const l=t.high,a=t.low;for(i=l&1<<31?-1:1,r=((2146435072&l)>>20)-1023,o=0,s=1<<19,e=1;e<=20;e++)l&s&&(o+=n(2,-e)),s>>>=1;for(s=1<<31,e=21;e<=52;e++)a&s&&(o+=n(2,-e)),s>>>=1;if(-1023===r){if(0===o)return 0*i;r=-1022}else{if(1024===r)return 0===o?i/0:NaN;o+=1}return i*o*n(2,r)}}(),c.prototype=Object.create(Error.prototype),c.prototype.constructor=Error;class h extends c{constructor(){super(),h.constructor_.apply(this,arguments)}getClass(){return h}get interfaces_(){return[]}}h.constructor_=function(){if(0===arguments.length)c.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];c.constructor_.call(this,t)}};class u{constructor(){u.constructor_.apply(this,arguments)}static shouldNeverReachHere(){if(0===arguments.length)u.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new h("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];u.isTrue(t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(!t)throw null===e?new h:new h(e)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];u.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new h("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}getClass(){return u}get interfaces_(){return[]}}u.constructor_=function(){};class g{constructor(){g.constructor_.apply(this,arguments)}static hashCode(){if(1===arguments.length&&"number"==typeof arguments[0]){const t=arguments[0],e=i.doubleToLongBits(t);return Math.trunc(e^e>>>32)}}setOrdinate(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new n("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}getOrdinate(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new n("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||i.isNaN(this.z)&&i.isNaN(t.z))}equals(t){return t instanceof g&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.z,t.z,n)}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return u.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new g(this)}toString(){return"("+this.x+", "+this.y+", "+this.z+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,s=this.z-t.z;return Math.sqrt(e*e+n*n+s*s)}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.z}getClass(){return g}get interfaces_(){return[r,o,a]}}class d{constructor(){d.constructor_.apply(this,arguments)}static compare(t,e){return t<e?-1:t>e?1:i.isNaN(t)?i.isNaN(e)?0:-1:i.isNaN(e)?1:0}compare(t,e){const n=t,s=e,i=d.compare(n.x,s.x);if(0!==i)return i;const r=d.compare(n.y,s.y);return 0!==r?r:this._dimensionsToTest<=2?0:d.compare(n.z,s.z)}getClass(){return d}get interfaces_(){return[l]}}function _(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}function f(){}function p(t){this.message=t||""}function m(){}function y(t){this.message=t||""}function x(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}d.constructor_=function(){if(this._dimensionsToTest=2,0===arguments.length)d.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new n("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}},g.DimensionalComparator=d,g.constructor_=function(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];g.constructor_.call(this,t.x,t.y,t.z)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];g.constructor_.call(this,t,e,g.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}},g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=i.NaN,g.X=0,g.Y=1,g.Z=2,f.prototype.add=function(){},f.prototype.addAll=function(){},f.prototype.isEmpty=function(){},f.prototype.iterator=function(){},f.prototype.size=function(){},f.prototype.toArray=function(){},f.prototype.remove=function(){},p.prototype=new Error,p.prototype.name="IndexOutOfBoundsException",m.prototype=Object.create(f.prototype),m.prototype.constructor=m,m.prototype.get=function(){},m.prototype.set=function(){},m.prototype.isEmpty=function(){},y.prototype=new Error,y.prototype.name="NoSuchElementException",x.prototype=Object.create(m.prototype),x.prototype.constructor=x,x.prototype.ensureCapacity=function(){},x.prototype.interfaces_=[m,f],x.prototype.add=function(t){return 1===arguments.length?this.array_.push(t):this.array_.splice(arguments[0],0,arguments[1]),!0},x.prototype.clear=function(){this.array_=[]},x.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},x.prototype.set=function(t,e){const n=this.array_[t];return this.array_[t]=e,n},x.prototype.iterator=function(){return new E(this)},x.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},x.prototype.isEmpty=function(){return 0===this.array_.length},x.prototype.size=function(){return this.array_.length},x.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},x.prototype.remove=function(t){let e=!1;for(let n=0,s=this.array_.length;n<s;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e},x.prototype.removeAll=function(t){for(let e=t.iterator();e.hasNext();)this.remove(e.next());return!0};const E=function(t){this.arrayList_=t,this.position_=0};E.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new y;return this.arrayList_.get(this.position_++)},E.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},E.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},E.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))};class I extends x{constructor(){super(),I.constructor_.apply(this,arguments)}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&_(arguments[0],f)){const t=arguments[0],e=arguments[1];let n=!1;for(let s=t.iterator();s.hasNext();)this.add(s.next(),e),n=!0;return n}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){return this.toArray(I.coordArrayType)}add(){if(1===arguments.length){const t=arguments[0];super.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=1;n>s&&(i=-1);for(let r=n;r!==s;r+=i)this.add(t[r],e);return!0}}closeRing(){this.size()>0&&this.add(new g(this.get(0)),!1)}getClass(){return I}get interfaces_(){return[]}}I.constructor_=function(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}},I.coordArrayType=new Array(0).fill(null);class N{constructor(){N.constructor_.apply(this,arguments)}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<i)&&(i=Math.min(n.y,s.y),r=Math.max(n.y,s.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<i)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof N))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new N;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,s=this._maxx<t._maxx?this._maxx:t._maxx,i=this._maxy<t._maxy?this._maxy:t._maxy;return new N(e,s,n,i)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof N){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof N){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof g){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];return!this.isNull()&&(!((t.x<e.x?t.x:e.x)>this._maxx)&&(!((t.x>e.x?t.x:e.x)<this._minx)&&(!((t.y<e.y?t.y:e.y)>this._maxy)&&!((t.y>e.y?t.y:e.y)<this._miny))))}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof N){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<s?(this._miny=n,this._maxy=s):(this._miny=s,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+g.hashCode(this._minx),t=37*t+g.hashCode(this._maxx),t=37*t+g.hashCode(this._miny),t=37*t+g.hashCode(this._maxy),t}getClass(){return N}get interfaces_(){return[r,a]}}function C(){}N.constructor_=function(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.init(t,e,n,s)}},N.serialVersionUID=0x51845cd552189800;class S extends C{constructor(){super(),S.constructor_.apply(this,arguments)}getClass(){return S}get interfaces_(){return[]}}function w(t){this.str=t}function L(t){this.value=t}function T(){}S.constructor_=function(){C.constructor_.call(this,"Projective point not representable on the Cartesian plane.")},w.prototype.append=function(t){this.str+=t},w.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},w.prototype.toString=function(t){return this.str},L.prototype.intValue=function(){return this.value},L.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},L.isNaN=t=>Number.isNaN(t),T.isWhitespace=t=>t<=32&&t>=0||127===t,T.toUpperCase=t=>t.toUpperCase();class R{constructor(){R.constructor_.apply(this,arguments)}static sqr(t){return R.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return R.parse(t)}if("number"==typeof arguments[0]){const t=arguments[0];return new R(t)}}static sqrt(t){return R.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;T.isWhitespace(t.charAt(e));)e++;let s=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(s=!0))}const i=new R;let r=0,o=0,l=0;for(;!(e>=n);){const n=t.charAt(e);if(e++,T.isDigit(n)){const t=n-"0";i.selfMultiply(R.TEN),i.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=L.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r}}let a=i;const c=r-o-l;if(0===c)a=i;else if(c>0){const t=R.TEN.pow(c);a=i.divide(t)}else if(c<0){const t=R.TEN.pow(-c);a=i.multiply(t)}return s?a.negate():a}static createNaN(){return new R(i.NaN,i.NaN)}static copy(t){return new R(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let s=Math.trunc(Math.floor(n));return 10*Math.pow(10,s)<=e&&(s+=1),s}static stringOfChar(t,e){const n=new w;for(let s=0;s<e;s++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),s=R.magnitude(n._hi);const i=R.TEN.pow(s);n=n.divide(i),n.gt(R.TEN)?(n=n.divide(R.TEN),s+=1):n.lt(R.ONE)&&(n=n.multiply(R.TEN),s-=1);const r=s+1,o=new w,l=R.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const s=Math.trunc(n._hi);if(s<0)break;let i=!1,a=0;s>9?(i=!0,a="9"):a="0"+s,o.append(a),n=n.subtract(R.valueOf(s)).multiply(R.TEN),i&&n.selfAdd(R.TEN);let c=!0;const h=R.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=s,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof R){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof R){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof R){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=R.SPLIT*o,n=l-o,c=R.SPLIT*t,n=l-n,s=o-n,i=c-t,a=o*t,i=c-i,r=t-i,c=n*i-a+n*r+s*i+s*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof R){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null,l=null,a=null;return r=this._hi/t._hi,o=R.SPLIT*r,e=o-r,a=R.SPLIT*t._hi,e=o-e,n=r-e,s=a-t._hi,l=r*t._hi,s=a-s,i=t._hi-s,a=e*s-l+e*i+n*s+n*i,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o,new R(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return R.valueOf(1);let e=new R(this),n=R.valueOf(1),s=Math.abs(t);if(s>1)for(;s>0;)s%2==1&&n.selfMultiply(e),s/=2,s>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return R.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new R(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof R){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return R.valueOf(0);if(this.isNegative())return R.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=R.valueOf(e),s=this.subtract(n.sqr())._hi*(.5*t);return n.add(s)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null;return s=this._hi+t,r=s-this._hi,i=s-r,i=t-r+(this._hi-i),o=i+this._lo,e=s+o,n=o+(s-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,i=this._lo+e,a=o-this._hi,c=i-this._lo,l=o-a,r=i-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+i,n=o+a,s=a+(o-n),a=r+s;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null;o=R.SPLIT*this._hi,n=o-this._hi,l=R.SPLIT*t,n=o-n,s=this._hi-n,i=l-t,o=this._hi*t,i=l-i,r=t-i,l=n*i-o+n*r+s*i+s*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return R.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new R(t,e)}negate(){return this.isNaN()?this:new R(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof R){const t=arguments[0];return t.isNaN()?R.createNaN():R.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfMultiply(t,0)}}isNaN(){return i.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=R.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),s=e[0]+1;let i=n;if("."===n.charAt(0))i="0"+n;else if(s<0)i="0."+R.stringOfChar("0",-s)+n;else if(-1===n.indexOf(".")){const t=s-n.length;i=n+R.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+i:i}reciprocal(){let t=null,e=null,n=null,s=null,i=null,r=null,o=null,l=null;i=1/this._hi,r=R.SPLIT*i,t=r-i,l=R.SPLIT*this._hi,t=r-t,e=i-t,n=l-this._hi,o=i*this._hi,n=l-n,s=this._hi-n,l=t*n-o+t*s+e*n+e*s,r=(1-o-l-i*this._lo)/this._hi;const a=i+r;return new R(a,i-a+r)}toSciNotation(){if(this.isZero())return R.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),s=R.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);let i="";n.length>1&&(i=n.substring(1));const r=n.charAt(0)+"."+i;return this.isNegative()?"-"+r+s:r+s}abs(){return this.isNaN()?R.NaN:this.isNegative()?this.negate():new R(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof R){const t=arguments[0];return R.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return R.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof R){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?R.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}getClass(){return R}get interfaces_(){return[a,r,o]}}R.constructor_=function(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof R){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];R.constructor_.call(this,R.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}},R.PI=new R(3.141592653589793,12246467991473532e-32),R.TWO_PI=new R(6.283185307179586,24492935982947064e-32),R.PI_2=new R(1.5707963267948966,6123233995736766e-32),R.E=new R(2.718281828459045,14456468917292502e-32),R.NaN=new R(i.NaN,i.NaN),R.EPS=123259516440783e-46,R.SPLIT=134217729,R.MAX_PRINT_DIGITS=32,R.TEN=R.valueOf(10),R.ONE=R.valueOf(1),R.SCI_NOT_EXPONENT_CHAR="E",R.SCI_NOT_ZERO="0.0E0";class P{constructor(){P.constructor_.apply(this,arguments)}static orientationIndex(t,e,n){const s=P.orientationIndexFilter(t,e,n);if(s<=1)return s;const i=R.valueOf(e.x).selfAdd(-t.x),r=R.valueOf(e.y).selfAdd(-t.y),o=R.valueOf(n.x).selfAdd(-e.x),l=R.valueOf(n.y).selfAdd(-e.y);return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof R&&arguments[2]instanceof R&&arguments[0]instanceof R&&arguments[1]instanceof R){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return t.multiply(s).selfSubtract(e.multiply(n)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=R.valueOf(t),r=R.valueOf(e),o=R.valueOf(n),l=R.valueOf(s);return i.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,s){const i=R.valueOf(s.y).selfSubtract(n.y).selfMultiply(R.valueOf(e.x).selfSubtract(t.x)),r=R.valueOf(s.x).selfSubtract(n.x).selfMultiply(R.valueOf(e.y).selfSubtract(t.y)),o=i.subtract(r),l=R.valueOf(s.x).selfSubtract(n.x).selfMultiply(R.valueOf(t.y).selfSubtract(n.y)),a=R.valueOf(s.y).selfSubtract(n.y).selfMultiply(R.valueOf(t.x).selfSubtract(n.x)),c=l.subtract(a).selfDivide(o).doubleValue(),h=R.valueOf(t.x).selfAdd(R.valueOf(e.x).selfSubtract(t.x).selfMultiply(c)).doubleValue(),u=R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(t.y).selfSubtract(n.y)),d=R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(t.x).selfSubtract(n.x)),_=u.subtract(d).selfDivide(o).doubleValue(),f=R.valueOf(n.y).selfAdd(R.valueOf(s.y).selfSubtract(n.y).selfMultiply(_)).doubleValue();return new g(h,f)}static orientationIndexFilter(t,e,n){let s=null;const i=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=i-r;if(i>0){if(r<=0)return P.signum(o);s=i+r}else{if(!(i<0))return P.signum(o);if(r>=0)return P.signum(o);s=-i-r}const l=P.DP_SAFE_EPSILON*s;return o>=l||-o>=l?P.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}getClass(){return P}get interfaces_(){return[]}}P.constructor_=function(){},P.DP_SAFE_EPSILON=1e-15;class v{constructor(){v.constructor_.apply(this,arguments)}static index(t,e,n){return P.orientationIndex(t,e,n)}static isCCW(t){const e=t.length-1;if(e<3)throw new n("Ring has fewer than 4 points, so orientation cannot be determined");let s=t[0],i=0;for(let n=1;n<=e;n++){const e=t[n];e.y>s.y&&(s=e,i=n)}let r=i;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(s)&&r!==i);let o=i;do{o=(o+1)%e}while(t[o].equals2D(s)&&o!==i);const l=t[r],a=t[o];if(l.equals2D(s)||a.equals2D(s)||l.equals2D(a))return!1;const c=v.index(l,s,a);let h=null;return h=0===c?l.x>a.x:c>0,h}getClass(){return v}get interfaces_(){return[]}}function O(){}v.constructor_=function(){},v.CLOCKWISE=-1,v.RIGHT=v.CLOCKWISE,v.COUNTERCLOCKWISE=1,v.LEFT=v.COUNTERCLOCKWISE,v.COLLINEAR=0,v.STRAIGHT=v.COLLINEAR,O.arraycopy=(t,e,n,s,i)=>{let r=0;for(let o=e;o<e+i;o++)n[s+r]=t[o],r++},O.getProperty=t=>({"line.separator":"\n"}[t]);class b{constructor(){b.constructor_.apply(this,arguments)}static intersection(t,e,n,s){const r=t.y-e.y,o=e.x-t.x,l=t.x*e.y-e.x*t.y,a=n.y-s.y,c=s.x-n.x,h=n.x*s.y-s.x*n.y,u=r*c-a*o,d=(o*h-c*l)/u,_=(a*l-r*h)/u;if(i.isNaN(d)||i.isInfinite(d)||i.isNaN(_)||i.isInfinite(_))throw new S;return new g(d,_)}getY(){const t=this.y/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getX(){const t=this.x/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getCoordinate(){const t=new g;return t.x=this.getX(),t.y=this.getY(),t}getClass(){return b}get interfaces_(){return[]}}b.constructor_=function(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){const t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this.x=t,this.y=e,this.w=1}else if(arguments[0]instanceof b&&arguments[1]instanceof b){const t=arguments[0],e=arguments[1];this.x=t.y*e.w-e.y*t.w,this.y=e.x*t.w-t.x*e.w,this.w=t.x*e.y-e.x*t.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];this.x=t.y-e.y,this.y=e.x-t.x,this.w=t.x*e.y-e.x*t.y}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.w=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.y-e.y,r=e.x-t.x,o=t.x*e.y-e.x*t.y,l=n.y-s.y,a=s.x-n.x,c=n.x*s.y-s.x*n.y;this.x=r*c-a*o,this.y=l*o-i*c,this.w=i*a-l*r}};class M{constructor(){M.constructor_.apply(this,arguments)}static log10(t){const e=Math.log(t);return i.isInfinite(e)||i.isNaN(e)?e:e/M.LOG_10}static min(t,e,n,s){let i=t;return e<i&&(i=e),n<i&&(i=n),s<i&&(i=s),i}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=t;return e>s&&(s=e),n>s&&(s=n),s}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=t;return e>i&&(i=e),n>i&&(i=n),s>i&&(i=s),i}}static average(t,e){return(t+e)/2}getClass(){return M}get interfaces_(){return[]}}M.constructor_=function(){},M.LOG_10=Math.log(10);class D{constructor(){D.constructor_.apply(this,arguments)}static segmentToSegment(t,e,n,s){if(t.equals(e))return D.pointToSegment(t,n,s);if(n.equals(s))return D.pointToSegment(s,t,e);let i=!1;if(N.intersects(t,e,n,s)){const r=(e.x-t.x)*(s.y-n.y)-(e.y-t.y)*(s.x-n.x);if(0===r)i=!0;else{const o=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(i=!0)}}else i=!0;return i?M.min(D.pointToSegment(t,n,s),D.pointToSegment(e,n,s),D.pointToSegment(n,t,e),D.pointToSegment(s,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/s;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(r)*Math.sqrt(s)}static pointToLinePerpendicular(t,e,n){const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(i)*Math.sqrt(s)}static pointToSegmentString(t,e){if(0===e.length)throw new n("Line array must contain at least one vertex");let s=t.distance(e[0]);for(let n=0;n<e.length-1;n++){const i=D.pointToSegment(t,e[n],e[n+1]);i<s&&(s=i)}return s}getClass(){return D}get interfaces_(){return[]}}D.constructor_=function(){};class A{constructor(){A.constructor_.apply(this,arguments)}setOrdinate(t,e,n){}size(){}getOrdinate(t,e){}getCoordinate(){}getCoordinateCopy(t){}getDimension(){}getX(t){}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}getClass(){return A}get interfaces_(){return[o]}}A.constructor_=function(){},A.X=0,A.Y=1,A.Z=2,A.M=3;class F{constructor(){F.constructor_.apply(this,arguments)}create(){1===arguments.length&&(arguments[0]instanceof Array||_(arguments[0],A))}getClass(){return F}get interfaces_(){return[]}}F.constructor_=function(){};class G{constructor(){G.constructor_.apply(this,arguments)}filter(t){}getClass(){return G}get interfaces_(){return[]}}G.constructor_=function(){};class q{constructor(){q.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equals(){if(arguments[0]instanceof q){const t=arguments[0];return null!==t&&this.equalsTopo(t)}if(arguments[0]instanceof Object){const t=arguments[0];if(!(t instanceof q))return!1;const e=t;return this.equalsExact(e)}}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(q.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}checkNotGeometryCollection(t){if(t.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION)throw new n("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new N(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),s=e.iterator();for(;n.hasNext()&&s.hasNext();){const t=n.next(),e=s.next(),i=t.compareTo(e);if(0!==i)return i}return n.hasNext()?1:s.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isGeometryCollectionOrDerived(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION||this.getTypeCode()===q.TYPECODE_MULTIPOINT||this.getTypeCode()===q.TYPECODE_MULTILINESTRING||this.getTypeCode()===q.TYPECODE_MULTIPOLYGON}get interfaces_(){return[o,r,a]}getClass(){return q}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}q.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},q.serialVersionUID=0x799ea46522854c00,q.TYPECODE_POINT=0,q.TYPECODE_MULTIPOINT=1,q.TYPECODE_LINESTRING=2,q.TYPECODE_LINEARRING=3,q.TYPECODE_MULTILINESTRING=4,q.TYPECODE_POLYGON=5,q.TYPECODE_MULTIPOLYGON=6,q.TYPECODE_GEOMETRYCOLLECTION=7,q.TYPENAME_POINT="Point",q.TYPENAME_MULTIPOINT="MultiPoint",q.TYPENAME_LINESTRING="LineString",q.TYPENAME_LINEARRING="LinearRing",q.TYPENAME_MULTILINESTRING="MultiLineString",q.TYPENAME_POLYGON="Polygon",q.TYPENAME_MULTIPOLYGON="MultiPolygon",q.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",q.geometryChangedFilter={get interfaces_(){return[G]},filter(t){t.geometryChangedAction()}};class B{constructor(){B.constructor_.apply(this,arguments)}filter(t){}getClass(){return B}get interfaces_(){return[]}}B.constructor_=function(){};class V{constructor(){V.constructor_.apply(this,arguments)}isInBoundary(t){}getClass(){return V}get interfaces_(){return[]}}class z{constructor(){z.constructor_.apply(this,arguments)}isInBoundary(t){return t%2==1}getClass(){return z}get interfaces_(){return[V]}}z.constructor_=function(){};class Y{constructor(){Y.constructor_.apply(this,arguments)}isInBoundary(t){return t>0}getClass(){return Y}get interfaces_(){return[V]}}Y.constructor_=function(){};class U{constructor(){U.constructor_.apply(this,arguments)}isInBoundary(t){return t>1}getClass(){return U}get interfaces_(){return[V]}}U.constructor_=function(){};class k{constructor(){k.constructor_.apply(this,arguments)}isInBoundary(t){return 1===t}getClass(){return k}get interfaces_(){return[V]}}k.constructor_=function(){},V.Mod2BoundaryNodeRule=z,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=k,V.constructor_=function(){},V.MOD2_BOUNDARY_RULE=new z,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new k,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE;class X{constructor(){X.constructor_.apply(this,arguments)}static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(X.indexOf(s,e)<0)return s}return null}static scroll(t,e){const n=X.indexOf(e,t);if(n<0)return null;const s=new Array(t.length).fill(null);O.arraycopy(t,n,s,0,t.length-n),O.arraycopy(t,0,s,t.length-n,n),O.arraycopy(s,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(0!==n.compare(t[s],e[s]))return!1;return!0}}static intersection(t,e){const n=new I;for(let s=0;s<t.length;s++)e.intersects(t[s])&&n.add(t[s],!0);return n.toCoordinateArray()}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!X.hasRepeatedPoints(t))return t;return new I(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++){const n=t[s];t[s]=t[e-s],t[e-s]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let s=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[s++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4];for(let r=0;r<i;r++)n[s+r]=new g(t[e+r])}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const s=t[n],i=e[t.length-n-1];if(0!==s.compareTo(i))return!1}return!0}static envelope(t){const e=new N;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(X.coordArrayType)}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,s=t[e].compareTo(t[n]);if(0!==s)return s}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=t[n].compareTo(e[n]);if(0!==s)return s;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=M.clamp(e,0,t.length);let s=(n=M.clamp(n,-1,t.length))-e+1;n<0&&(s=0),e>=t.length&&(s=0),n<e&&(s=0);const i=new Array(s).fill(null);if(0===s)return i;let r=0;for(let s=e;s<=n;s++)i[r++]=t[s];return i}getClass(){return X}get interfaces_(){return[]}}class H{constructor(){H.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e;return X.compare(n,s)}getClass(){return H}get interfaces_(){return[l]}}H.constructor_=function(){};class W{constructor(){W.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=X.compare(n,s);return X.isEqualReversed(n,s)?0:i}OLDcompare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=X.increasingDirection(n),r=X.increasingDirection(s);let o=i>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(s[l]);if(0!==t)return t;o+=i,l+=r}return 0}getClass(){return W}get interfaces_(){return[l]}}function j(){}function K(){}function Z(t){this.message=t||""}function Q(){}function J(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}W.constructor_=function(){},X.ForwardComparator=H,X.BidirectionalComparator=W,X.constructor_=function(){},X.coordArrayType=new Array(0).fill(null),j.prototype.get=function(){},j.prototype.put=function(){},j.prototype.size=function(){},j.prototype.values=function(){},j.prototype.entrySet=function(){},K.prototype=new j,Z.prototype=new Error,Z.prototype.name="OperationNotSupported",Q.prototype=new f,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(let e=0,n=this.array_.length;e<n;e++){if(this.array_[e]===t)return!0}return!1},J.prototype.add=function(t){return!this.contains(t)&&(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new Z},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new $(this)};const $=function(t){this.hashSet_=t,this.position_=0};$.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new y;return this.hashSet_.array_[this.position_++]},$.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},$.prototype.remove=function(){throw new Z};function tt(t){return null==t?0:t.color}function et(t){return null==t?null:t.parent}function nt(t,e){null!==t&&(t.color=e)}function st(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}rt.prototype=new K,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;var n,s,i=this.root_;do{if(n=i,(s=t.compareTo(i.key))<0)i=i.left;else{if(!(s>0)){var r=i.value;return i.value=e,r}i=i.right}}while(null!==i);var o={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return s<0?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)et(t)===st(et(et(t)))?(e=it(et(et(t))),1===tt(e)?(nt(et(t),0),nt(e,0),nt(et(et(t)),1),t=et(et(t))):(t===it(et(t))&&(t=et(t),this.rotateLeft(t)),nt(et(t),0),nt(et(et(t)),1),this.rotateRight(et(et(t))))):(e=st(et(et(t))),1===tt(e)?(nt(et(t),0),nt(e,0),nt(et(et(t)),1),t=et(et(t))):(t===st(et(t))&&(t=et(t),this.rotateRight(t)),nt(et(t),0),nt(et(et(t)),1),this.rotateLeft(et(et(t)))));this.root_.color=0},rt.prototype.values=function(){var t=new x,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}e=t.parent;for(var n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},rt.prototype.containsKey=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1};class ot{constructor(){ot.constructor_.apply(this,arguments)}getClass(){return ot}get interfaces_(){return[]}}function lt(){}function at(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}ot.constructor_=function(){},lt.prototype=new Q,at.prototype=new lt,at.prototype.contains=function(t){for(let e=0,n=this.array_.length;e<n;e++){if(0===this.array_[e].compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(let e=0,n=this.array_.length;e<n;e++){if(1===this.array_[e].compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new Z},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new ct(this)};const ct=function(t){this.treeSet_=t,this.position_=0};function ht(){}ct.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new y;return this.treeSet_.array_[this.position_++]},ct.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},ct.prototype.remove=function(){throw new Z},ht.sort=function(){const t=arguments[0];let e,n,s,i;if(1===arguments.length)i=function(t,e){return t.compareTo(e)},t.sort(i);else if(2===arguments.length)s=arguments[1],i=function(t,e){return s.compare(t,e)},t.sort(i);else if(3===arguments.length){n=t.slice(arguments[1],arguments[2]),n.sort();const s=t.slice(0,arguments[1]).concat(n,t.slice(arguments[2],t.length));for(t.splice(0,t.length),e=0;e<s.length;e++)t.push(s[e])}else if(4===arguments.length){n=t.slice(arguments[1],arguments[2]),s=arguments[3],i=function(t,e){return s.compare(t,e)},n.sort(i);const r=t.slice(0,arguments[1]).concat(n,t.slice(arguments[2],t.length));for(t.splice(0,t.length),e=0;e<r.length;e++)t.push(r[e])}},ht.asList=function(t){const e=new x;for(let n=0,s=t.length;n<s;n++)e.add(t[n]);return e};class ut{constructor(){ut.constructor_.apply(this,arguments)}static toDimensionSymbol(t){switch(t){case ut.FALSE:return ut.SYM_FALSE;case ut.TRUE:return ut.SYM_TRUE;case ut.DONTCARE:return ut.SYM_DONTCARE;case ut.P:return ut.SYM_P;case ut.L:return ut.SYM_L;case ut.A:return ut.SYM_A}throw new n("Unknown dimension value: "+t)}static toDimensionValue(t){switch(T.toUpperCase(t)){case ut.SYM_FALSE:return ut.FALSE;case ut.SYM_TRUE:return ut.TRUE;case ut.SYM_DONTCARE:return ut.DONTCARE;case ut.SYM_P:return ut.P;case ut.SYM_L:return ut.L;case ut.SYM_A:return ut.A}throw new n("Unknown dimension symbol: "+t)}getClass(){return ut}get interfaces_(){return[]}}ut.constructor_=function(){},ut.P=0,ut.L=1,ut.A=2,ut.FALSE=-1,ut.TRUE=-2,ut.DONTCARE=-3,ut.SYM_FALSE="F",ut.SYM_TRUE="T",ut.SYM_DONTCARE="*",ut.SYM_P="0",ut.SYM_L="1",ut.SYM_A="2";class gt{constructor(){gt.constructor_.apply(this,arguments)}filter(t){}getClass(){return gt}get interfaces_(){return[]}}gt.constructor_=function(){};class dt{constructor(){dt.constructor_.apply(this,arguments)}filter(t,e){}isDone(){}isGeometryChanged(){}getClass(){return dt}get interfaces_(){return[]}}dt.constructor_=function(){};class _t extends q{constructor(){super(),_t.constructor_.apply(this,arguments)}computeEnvelopeInternal(){const t=new N;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const s=this._geometries[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();ht.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=ut.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}getTypeCode(){return q.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=ut.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)e[t]=this._geometries[t].reverse();return this.getFactory().createGeometryCollection(e)}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new at(ht.asList(this._geometries)),n=new at(ht.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t,s=this.getNumGeometries(),i=n.getNumGeometries();let r=0;for(;r<s&&r<i;){const t=this.getGeometryN(r),s=n.getGeometryN(r),i=t.compareToSameClass(s,e);if(0!==i)return i;r++}return r<s?1:r<i?-1:0}}apply(){if(_(arguments[0],B)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(_(arguments[0],dt)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(_(arguments[0],G)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return this.checkNotGeometryCollection(this),u.shouldNeverReachHere(),null}getGeometryType(){return q.TYPENAME_GEOMETRYCOLLECTION}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new _t(t,this._factory)}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}getClass(){return _t}get interfaces_(){return[]}}_t.constructor_=function(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0];const e=arguments[1];if(q.constructor_.call(this,e),null===t&&(t=[]),q.hasNullElements(t))throw new n("geometries must not contain null elements");this._geometries=t}},_t.serialVersionUID=-0x4f07bcb1f857d800;class ft extends _t{constructor(){super(),ft.constructor_.apply(this,arguments)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?ut.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return q.TYPECODE_MULTILINESTRING}getDimension(){return 1}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let n=0;n<this._geometries.length;n++)e[t-1-n]=this._geometries[n].reverse();return this.getFactory().createMultiLineString(e)}getBoundary(){return new pt(this).getBoundary()}getGeometryType(){return q.TYPENAME_MULTILINESTRING}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ft(t,this._factory)}getClass(){return ft}get interfaces_(){return[ot]}}ft.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},ft.serialVersionUID=0x7155d2ab4afa8000;class pt{constructor(){pt.constructor_.apply(this,arguments)}static getBoundary(){if(1===arguments.length){const t=arguments[0];return new pt(t).getBoundary()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new pt(t,e).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();const e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)}getBoundary(){return this._geom instanceof Tt?this.boundaryLineString(this._geom):this._geom instanceof ft?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){const e=new x;this._endpointMap=new rt;for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);0!==n.getNumPoints()&&(this.addEndpoint(n.getCoordinateN(0)),this.addEndpoint(n.getCoordinateN(n.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){const n=t.next(),s=n.getValue().count;this._bnRule.isInBoundary(s)&&e.add(n.getKey())}return X.toCoordinateArray(e)}addEndpoint(t){let e=this._endpointMap.get(t);null===e&&(e=new mt,this._endpointMap.put(t,e)),e.count++}getClass(){return pt}get interfaces_(){return[]}}pt.constructor_=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){const t=arguments[0];pt.constructor_.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}};class mt{constructor(){mt.constructor_.apply(this,arguments)}getClass(){return mt}get interfaces_(){return[]}}mt.constructor_=function(){this.count=null};class yt{constructor(){yt.constructor_.apply(this,arguments)}static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const s=new g;t.getCoordinate(0,s);let i=s.x,r=s.y;for(let o=1;o<e;o++){t.getCoordinate(o,s);const e=s.x,l=s.y,a=e-i,c=l-r;n+=Math.sqrt(a*a+c*c),i=e,r=l}return n}getClass(){return yt}get interfaces_(){return[]}}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}yt.constructor_=function(){};class St{constructor(){St.constructor_.apply(this,arguments)}static chars(t,e){const n=new Array(e).fill(null);for(let s=0;s<e;s++)n[s]=t;return new String(n)}static getStackTrace(){if(1===arguments.length){const t=arguments[0],e=new It,n=new xt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n="";const s=new Ct(new Et(St.getStackTrace(t)));for(let t=0;t<e;t++)try{n+=s.readLine()+St.NEWLINE}catch(t){if(!(t instanceof Nt))throw t;u.shouldNeverReachHere()}return n}}static split(t,e){const n=e.length,s=new x;let i=""+t,r=i.indexOf(e);for(;r>=0;){const t=i.substring(0,r);s.add(t),i=i.substring(r+n),r=i.indexOf(e)}i.length>0&&s.add(i);const o=new Array(s.size()).fill(null);for(let t=0;t<o.length;t++)o[t]=s.get(t);return o}static toString(){if(1===arguments.length&&"number"==typeof arguments[0]){const t=arguments[0];return St.SIMPLE_ORDINATE_FORMAT.format(t)}}static spaces(t){return St.chars(" ",t)}getClass(){return St}get interfaces_(){return[]}}function wt(t){this.str=t}St.constructor_=function(){},St.NEWLINE=O.getProperty("line.separator"),St.SIMPLE_ORDINATE_FORMAT=new function(){}("0.#"),wt.prototype.append=function(t){this.str+=t},wt.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},wt.prototype.toString=function(t){return this.str};class Lt{constructor(){Lt.constructor_.apply(this,arguments)}static copyCoord(t,e,n,s){const i=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<i;r++)n.setOrdinate(s,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,A.X)===t.getOrdinate(e-1,A.X)&&t.getOrdinate(0,A.Y)===t.getOrdinate(e-1,A.Y))}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const s=Math.min(t.getDimension(),e.getDimension());for(let r=0;r<n;r++)for(let n=0;n<s;n++){const s=t.getOrdinate(r,n),o=e.getOrdinate(r,n);if(t.getOrdinate(r,n)!==e.getOrdinate(r,n)&&(!i.isNaN(s)||!i.isNaN(o)))return!1}return!0}static extend(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();if(Lt.copy(e,0,s,0,i),i>0)for(let t=i;t<n;t++)Lt.copy(e,i-1,s,t,1);return s}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++)Lt.swap(t,s,e-s)}static swap(t,e,n){if(e===n)return null;for(let s=0;s<t.getDimension();s++){const i=t.getOrdinate(e,s);t.setOrdinate(e,s,t.getOrdinate(n,s)),t.setOrdinate(n,s,i)}}static copy(t,e,n,s,i){for(let r=0;r<i;r++)Lt.copyCoord(t,e+r,n,s+r)}static toString(){if(1===arguments.length&&_(arguments[0],A)){const t=arguments[0],e=t.size();if(0===e)return"()";const n=t.getDimension(),s=new wt;s.append("(");for(let i=0;i<e;i++){i>0&&s.append(" ");for(let e=0;e<n;e++)e>0&&s.append(","),s.append(St.toString(t.getOrdinate(i,e)))}return s.append(")"),s.toString()}}static ensureValidRing(t,e){const n=e.size();return 0===n?e:n<=3?Lt.createClosedRing(t,e,4):e.getOrdinate(0,A.X)===e.getOrdinate(n-1,A.X)&&e.getOrdinate(0,A.Y)===e.getOrdinate(n-1,A.Y)?e:Lt.createClosedRing(t,e,n+1)}static createClosedRing(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();Lt.copy(e,0,s,0,i);for(let t=i;t<n;t++)Lt.copy(e,0,s,t,1);return s}getClass(){return Lt}get interfaces_(){return[]}}Lt.constructor_=function(){};class Tt extends q{constructor(){super(),Tt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this.isEmpty()?new N:this._points.expandEnvelope(new N)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();Lt.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?ut.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return q.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return yt.ofLine(this._points)}getNumPoints(){return this._points.size()}reverse(){const t=this._points.copy();return Lt.reverse(t),this.getFactory().createLineString(t)}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const s=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==s)return s;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(_(arguments[0],B)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(_(arguments[0],dt)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){arguments[0].filter(this)}}getBoundary(){return new pt(this).getBoundary()}isEquivalentClass(t){return t instanceof Tt}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return q.TYPENAME_LINESTRING}copy(){return new Tt(this._points.copy(),this._factory)}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new n("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}getClass(){return Tt}get interfaces_(){return[ot]}}Tt.constructor_=function(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];q.constructor_.call(this,e),this.init(t)}},Tt.serialVersionUID=0x2b2b51ba435c8e00;class Rt{constructor(){Rt.constructor_.apply(this,arguments)}getClass(){return Rt}get interfaces_(){return[]}}Rt.constructor_=function(){};class Pt extends q{constructor(){super(),Pt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){if(this.isEmpty())return new N;const t=new N;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return ut.FALSE}getTypeCode(){return q.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}reverse(){return this.copy()}getX(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(_(arguments[0],B)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(_(arguments[0],dt)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_POINT}copy(){return new Pt(this._coordinates.copy(),this._factory)}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),u.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}getClass(){return Pt}get interfaces_(){return[Rt]}}Pt.constructor_=function(){this._coordinates=null;const t=arguments[0],e=arguments[1];q.constructor_.call(this,e),this.init(t)},Pt.serialVersionUID=0x44077bad161cbc00;class vt{constructor(){vt.constructor_.apply(this,arguments)}static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(vt.ofRingSigned(t))}if(_(arguments[0],A)){const t=arguments[0];return Math.abs(vt.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let s=1;s<t.length-1;s++){const i=t[s].x-n,r=t[s+1].y;e+=i*(t[s-1].y-r)}return e/2}if(_(arguments[0],A)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new g,s=new g,i=new g;t.getCoordinate(0,s),t.getCoordinate(1,i);const r=s.x;i.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=s.y,s.x=i.x,s.y=i.y,t.getCoordinate(l+1,i),i.x-=r,o+=s.x*(n.y-i.y);return o/2}}getClass(){return vt}get interfaces_(){return[]}}vt.constructor_=function(){};class Ot{constructor(){Ot.constructor_.apply(this,arguments)}getClass(){return Ot}get interfaces_(){return[]}}Ot.constructor_=function(){};class bt extends q{constructor(){super(),bt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let s=0;s<n.length;s++)e++,t[e]=n[s];for(let n=0;n<this._holes.length;n++){const s=this._holes[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;t+=vt.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=vt.ofRing(this._holes[e].getCoordinateSequence());return t}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const s=t.getX(n);if(s!==e.getMinX()&&s!==e.getMaxX())return!1;const i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}let n=t.getX(0),s=t.getY(0);for(let e=1;e<=4;e++){const i=t.getX(e),r=t.getY(e);if(i!==n===(r!==s))return!1;n=i,s=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,s=this._shell,i=n._shell;if(!s.equalsExact(i,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this.normalize(this._shell,!0);for(let t=0;t<this._holes.length;t++)this.normalize(this._holes[t],!1);ht.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=new Array(t.getCoordinates().length-1).fill(null);O.arraycopy(t.getCoordinates(),0,n,0,n.length);const s=X.minCoordinate(t.getCoordinates());X.scroll(n,s),O.arraycopy(n,0,t.getCoordinates(),0,n.length),t.getCoordinates()[n.length]=n[0],v.isCCW(t.getCoordinates())===e&&X.reverse(t.getCoordinates())}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}reverse(){const t=this.copy();t._shell=this._shell.copy().reverse(),t._holes=new Array(this._holes.length).fill(null);for(let e=0;e<this._holes.length;e++)t._holes[e]=this._holes[e].copy().reverse();return t}convexHull(){return this.getExteriorRing().convexHull()}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t,s=this._shell,i=n._shell,r=s.compareToSameClass(i,e);if(0!==r)return r;const o=this.getNumInteriorRing(),l=n.getNumInteriorRing();let a=0;for(;a<o&&a<l;){const t=this.getInteriorRingN(a),s=n.getInteriorRingN(a),i=t.compareToSameClass(s,e);if(0!==i)return i;a++}return a<o?1:a<l?-1:0}}apply(){if(_(arguments[0],B)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(_(arguments[0],dt)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return q.TYPENAME_POLYGON}copy(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new bt(t,e,this._factory)}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}getClass(){return bt}get interfaces_(){return[Ot]}}bt.constructor_=function(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1];const s=arguments[2];if(q.constructor_.call(this,s),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),q.hasNullElements(e))throw new n("holes must not contain null elements");if(t.isEmpty()&&q.hasNonEmptyElements(e))throw new n("shell is empty but holes are not");this._shell=t,this._holes=e},bt.serialVersionUID=-0x307ffefd8dc97200;class Mt extends _t{constructor(){super(),Mt.constructor_.apply(this,arguments)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return ut.FALSE}getTypeCode(){return q.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_MULTIPOINT}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Mt(t,this._factory)}getClass(){return Mt}get interfaces_(){return[Rt]}}Mt.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},Mt.serialVersionUID=-0x6fb1ed4162e0fc00;class Dt extends Tt{constructor(){super(),Dt.constructor_.apply(this,arguments)}getBoundaryDimension(){return ut.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}getTypeCode(){return q.TYPECODE_LINEARRING}reverse(){const t=this._points.copy();return Lt.reverse(t),this.getFactory().createLinearRing(t)}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new n("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<Dt.MINIMUM_VALID_SIZE)throw new n("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return q.TYPENAME_LINEARRING}copy(){return new Dt(this._points.copy(),this._factory)}getClass(){return Dt}get interfaces_(){return[]}}Dt.constructor_=function(){if(arguments[0]instanceof Array&&arguments[1]instanceof Ht){const t=arguments[0],e=arguments[1];Dt.constructor_.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(_(arguments[0],A)&&arguments[1]instanceof Ht){const t=arguments[0],e=arguments[1];Tt.constructor_.call(this,t,e),this.validateConstruction()}},Dt.MINIMUM_VALID_SIZE=4,Dt.serialVersionUID=-0x3b229e262367a600;class At extends _t{constructor(){super(),At.constructor_.apply(this,arguments)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_MULTIPOLYGON}getDimension(){return 2}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)e[t]=this._geometries[t].reverse();return this.getFactory().createMultiPolygon(e)}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new x;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return q.TYPENAME_MULTIPOLYGON}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new At(t,this._factory)}getClass(){return At}get interfaces_(){return[Ot]}}At.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},At.serialVersionUID=-0x7a5aa1369171980;class Ft{constructor(){Ft.constructor_.apply(this,arguments)}setCopyUserData(t){this._isUserDataCopied=t}edit(t,e){if(null===t)return null;const n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n}editInternal(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof _t?this.editGeometryCollection(t,e):t instanceof bt?this.editPolygon(t,e):t instanceof Pt||t instanceof Tt?e.edit(t,this._factory):(u.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)}editGeometryCollection(t,e){const n=e.edit(t,this._factory),s=new x;for(let t=0;t<n.getNumGeometries();t++){const i=this.edit(n.getGeometryN(t),e);null===i||i.isEmpty()||s.add(i)}return n.getClass()===Mt?this._factory.createMultiPoint(s.toArray([])):n.getClass()===ft?this._factory.createMultiLineString(s.toArray([])):n.getClass()===At?this._factory.createMultiPolygon(s.toArray([])):this._factory.createGeometryCollection(s.toArray([]))}editPolygon(t,e){let n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon()),n.isEmpty())return n;const s=this.edit(n.getExteriorRing(),e);if(null===s||s.isEmpty())return this._factory.createPolygon();const i=new x;for(let t=0;t<n.getNumInteriorRing();t++){const s=this.edit(n.getInteriorRingN(t),e);null===s||s.isEmpty()||i.add(s)}return this._factory.createPolygon(s,i.toArray([]))}getClass(){return Ft}get interfaces_(){return[]}}function Gt(){}Ft.GeometryEditorOperation=Gt;class qt{constructor(){qt.constructor_.apply(this,arguments)}edit(t,e){return t}getClass(){return qt}get interfaces_(){return[Gt]}}qt.constructor_=function(){};class Bt{constructor(){Bt.constructor_.apply(this,arguments)}edit(t,e){const n=this.edit(t.getCoordinates(),t);return t instanceof Dt?null===n?e.createLinearRing():e.createLinearRing(n):t instanceof Tt?null===n?e.createLineString():e.createLineString(n):t instanceof Pt?null===n||0===n.length?e.createPoint():e.createPoint(n[0]):t}getClass(){return Bt}get interfaces_(){return[Gt]}}Bt.constructor_=function(){};class Vt{constructor(){Vt.constructor_.apply(this,arguments)}edit(t,e){return t instanceof Dt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof Tt?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Pt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t}getClass(){return Vt}get interfaces_(){return[Gt]}}Vt.constructor_=function(){},Ft.NoOpGeometryOperation=qt,Ft.CoordinateOperation=Bt,Ft.CoordinateSequenceOperation=Vt,Ft.constructor_=function(){if(this._factory=null,this._isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._factory=t}};class zt{constructor(){zt.constructor_.apply(this,arguments)}setOrdinate(t,e,s){switch(e){case A.X:this._coordinates[t].x=s;break;case A.Y:this._coordinates[t].y=s;break;case A.Z:this._coordinates[t].z=s;break;default:throw new n("invalid ordinateIndex")}}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case A.X:return this._coordinates[t].x;case A.Y:return this._coordinates[t].y;case A.Z:return this._coordinates[t].z}return i.NaN}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0],e=arguments[1];e.x=this._coordinates[t].x,e.y=this._coordinates[t].y,e.z=this._coordinates[t].z}}getCoordinateCopy(t){return new g(this._coordinates[t])}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)t[e]=this._coordinates[e].copy();return new zt(t,this._dimension)}toString(){if(this._coordinates.length>0){const t=new wt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}getClass(){return zt}get interfaces_(){return[A,a]}}zt.constructor_=function(){if(this._dimension=3,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];zt.constructor_.call(this,t,3)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new g}else if(_(arguments[0],A)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=t,this._dimension=e,null===t&&(this._coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let e=0;e<t;e++)this._coordinates[e]=new g}},zt.serialVersionUID=-0xcb44a778db18e00;class Yt{constructor(){Yt.constructor_.apply(this,arguments)}static instance(){return Yt.instanceObject}readResolve(){return Yt.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return new zt(t)}if(_(arguments[0],A)){const t=arguments[0];return new zt(t)}}else if(2===arguments.length){const t=arguments[0];let e=arguments[1];return e>3&&(e=3),e<2?new zt(t):new zt(t,e)}}getClass(){return Yt}get interfaces_(){return[F,a]}}function Ut(){this.map_=new Map}Yt.constructor_=function(){},Yt.serialVersionUID=-0x38e49fa6cf6f2e00,Yt.instanceObject=new Yt,Ut.prototype=new j,Ut.prototype.get=function(t){return this.map_.get(t)||null},Ut.prototype.put=function(t,e){return this.map_.set(t,e),e},Ut.prototype.values=function(){const t=new x,e=this.map_.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t},Ut.prototype.entrySet=function(){const t=new J;return this.map_.entries().forEach(e=>t.add(e)),t},Ut.prototype.size=function(){return this.map_.size()};class kt{constructor(){kt.constructor_.apply(this,arguments)}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof kt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),s=e.getMaximumSignificantDigits();return new L(n).compareTo(new L(s))}getScale(){return this._scale}isFloating(){return this._modelType===kt.FLOATING||this._modelType===kt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===kt.FLOATING?t="Floating":this._modelType===kt.FLOATING_SINGLE?t="Floating-Single":this._modelType===kt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(i.isNaN(t))return t;if(this._modelType===kt.FLOATING_SINGLE){return t}return this._modelType===kt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof g){const t=arguments[0];if(this._modelType===kt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===kt.FLOATING?t=16:this._modelType===kt.FLOATING_SINGLE?t=6:this._modelType===kt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}getClass(){return kt}get interfaces_(){return[a,r]}}class Xt{constructor(){Xt.constructor_.apply(this,arguments)}readResolve(){return Xt.nameToTypeMap.get(this._name)}toString(){return this._name}getClass(){return Xt}get interfaces_(){return[a]}}Xt.constructor_=function(){this._name=null;const t=arguments[0];this._name=t,Xt.nameToTypeMap.put(t,this)},Xt.serialVersionUID=-552860263173159e4,Xt.nameToTypeMap=new Ut,kt.Type=Xt,kt.constructor_=function(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=kt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof Xt){const t=arguments[0];this._modelType=t,t===kt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=kt.FIXED,this.setScale(t)}else if(arguments[0]instanceof kt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}},kt.serialVersionUID=0x6bee6404e9a25c00,kt.FIXED=new Xt("FIXED"),kt.FLOATING=new Xt("FLOATING"),kt.FLOATING_SINGLE=new Xt("FLOATING SINGLE"),kt.maximumPreciseValue=9007199254740992;class Ht{constructor(){Ht.constructor_.apply(this,arguments)}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return Yt.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){const t=arguments[0];return new Tt(t,this)}}}createMultiLineString(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){const t=arguments[0];return new ft(t,this)}}buildGeometry(t){let e=null,n=!1,s=!1;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=t.getClass();null===e&&(e=r),r!==e&&(n=!0),t instanceof _t&&(s=!0)}if(null===e)return this.createGeometryCollection();if(n||s)return this.createGeometryCollection(Ht.toGeometryArray(t));const i=t.iterator().next();if(t.size()>1){if(i instanceof bt)return this.createMultiPolygon(Ht.toPolygonArray(t));if(i instanceof Tt)return this.createMultiLineString(Ht.toLineStringArray(t));if(i instanceof Pt)return this.createMultiPoint(Ht.toPointArray(t));u.shouldNeverReachHere("Unhandled class: "+i.getClass().getName())}return i}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(_(arguments[0],A)){const t=arguments[0];return new Pt(t,this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(_(arguments[0],A)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Dt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return new bt(t,e,this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new _t(null,this);if(1===arguments.length){const t=arguments[0];return new _t(t,this)}}createGeometry(t){return new Ft(this).edit(t,new Wt(this._coordinateSequenceFactory))}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){const t=arguments[0];return new Dt(t,this)}}}createMultiPolygon(){if(0===arguments.length)return new At(null,this);if(1===arguments.length){const t=arguments[0];return new At(t,this)}}createMultiPoint(){if(0===arguments.length)return new Mt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return new Mt(t,this)}if(_(arguments[0],A)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=this.getCoordinateSequenceFactory().create(1,t.getDimension());Lt.copy(t,n,s,0,1),e[n]=this.createPoint(s)}return this.createMultiPoint(e)}}}getClass(){return Ht}get interfaces_(){return[a]}}class Wt extends Ft.CoordinateSequenceOperation{constructor(){super(),Wt.constructor_.apply(this,arguments)}edit(){if(2===arguments.length&&arguments[1]instanceof q&&_(arguments[0],A)){const t=arguments[0];return this.coordinateSequenceFactory.create(t)}return super.edit.apply(this,arguments)}getClass(){return Wt}get interfaces_(){return[]}}Wt.constructor_=function(){this.coordinateSequenceFactory=null;const t=arguments[0];this.coordinateSequenceFactory=t},Ht.CloneOp=Wt,Ht.constructor_=function(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Ht.constructor_.call(this,new kt,0);else if(1===arguments.length){if(_(arguments[0],F)){const t=arguments[0];Ht.constructor_.call(this,new kt,0,t)}else if(arguments[0]instanceof kt){const t=arguments[0];Ht.constructor_.call(this,t,0,Ht.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Ht.constructor_.call(this,t,e,Ht.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}},Ht.serialVersionUID=-0x5ea75f2051eeb400;const jt={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};class Kt{constructor(t){this.geometryFactory=t||new Ht,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){var e,n,s;t=t.replace(/[\n\r]/g," ");var i=jt.typeStr.exec(t);if(-1!==t.search("EMPTY")&&((i=jt.emptyTypeStr.exec(t))[2]=void 0),i&&(n=i[1].toLowerCase(),s=i[2],Qt[n]&&(e=Qt[n].call(this,s))),void 0===e)throw new Error("Could not parse WKT "+t);return e}write(t){return this.extractGeometry(t)}extractGeometry(t){var e=t.getGeometryType().toLowerCase();if(!Zt[e])return null;var n=e.toUpperCase();return t.isEmpty()?n+" EMPTY":n+"("+Zt[e].call(this,t)+")"}}const Zt={coordinate(t){return this.precisionModel.makePrecise(t),t.x+" "+t.y},point(t){return Zt.coordinate.call(this,t._coordinates._coordinates[0])},multipoint(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.point.call(this,t._geometries[n])+")");return e.join(",")},linestring(t){var e=[];for(let n=0,s=t._points._coordinates.length;n<s;++n)e.push(Zt.coordinate.call(this,t._points._coordinates[n]));return e.join(",")},linearring(t){var e=[];for(let n=0,s=t._points._coordinates.length;n<s;++n)e.push(Zt.coordinate.call(this,t._points._coordinates[n]));return e.join(",")},multilinestring(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.linestring.call(this,t._geometries[n])+")");return e.join(",")},polygon(t){var e=[];e.push("("+Zt.linestring.call(this,t._shell)+")");for(let n=0,s=t._holes.length;n<s;++n)e.push("("+Zt.linestring.call(this,t._holes[n])+")");return e.join(",")},multipolygon(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.polygon.call(this,t._geometries[n])+")");return e.join(",")},geometrycollection(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push(this.extractGeometry(t._geometries[n]));return e.join(",")}},Qt={coord(t){var e=t.trim().split(jt.spaces),n=new g(Number.parseFloat(e[0]),Number.parseFloat(e[1]));return this.precisionModel.makePrecise(n),n},point(t){return void 0===t?this.geometryFactory.createPoint():this.geometryFactory.createPoint(Qt.coord.call(this,t))},multipoint(t){if(void 0===t)return this.geometryFactory.createMultiPoint();var e,n=t.trim().split(","),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.point.call(this,e));return this.geometryFactory.createMultiPoint(s)},linestring(t){if(void 0===t)return this.geometryFactory.createLineString();var e=t.trim().split(","),n=[];for(let t=0,s=e.length;t<s;++t)n.push(Qt.coord.call(this,e[t]));return this.geometryFactory.createLineString(n)},linearring(t){if(void 0===t)return this.geometryFactory.createLinearRing();var e=t.trim().split(","),n=[];for(let t=0,s=e.length;t<s;++t)n.push(Qt.coord.call(this,e[t]));return this.geometryFactory.createLinearRing(n)},multilinestring(t){if(void 0===t)return this.geometryFactory.createMultiLineString();var e,n=t.trim().split(jt.parenComma),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.linestring.call(this,e));return this.geometryFactory.createMultiLineString(s)},polygon(t){if(void 0===t)return this.geometryFactory.createPolygon();var e,n,s,i,r=t.trim().split(jt.parenComma),o=[];for(let t=0,l=r.length;t<l;++t)e=r[t].replace(jt.trimParens,"$1"),n=Qt.linestring.call(this,e),s=this.geometryFactory.createLinearRing(n._points),0===t?i=s:o.push(s);return this.geometryFactory.createPolygon(i,o)},multipolygon(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();var e,n=t.trim().split(jt.doubleParenComma),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.polygon.call(this,e));return this.geometryFactory.createMultiPolygon(s)},geometrycollection(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();var e=(t=t.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),n=[];for(let t=0,s=e.length;t<s;++t)n.push(this.read(e[t]));return this.geometryFactory.createGeometryCollection(n)}};class Jt{constructor(t){this.parser=new Kt(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class $t{constructor(){$t.constructor_.apply(this,arguments)}static computeEdgeDistance(t,e,n){const s=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=s>i?s:i;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=s>i?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return u.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const s=t.x-e.x,i=t.y-e.y,r=Math.sqrt(s*s+i*i);return u.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new wt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,s){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=s,this._result=this.computeIntersect(t,e,n,s)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(()=>Array(2)),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==$t.NO_INTERSECTION}getEdgeDistance(t,e){return $t.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===$t.COLLINEAR_INTERSECTION}toString(){return Jt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Jt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}getClass(){return $t}get interfaces_(){return[]}}$t.constructor_=function(){this._result=null,this._inputLines=Array(2).fill().map(()=>Array(2)),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new g,this._intPt[1]=new g,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0},$t.DONT_INTERSECT=0,$t.DO_INTERSECT=1,$t.COLLINEAR=2,$t.NO_INTERSECTION=0,$t.POINT_INTERSECTION=1,$t.COLLINEAR_INTERSECTION=2;class te extends $t{constructor(){super(),te.constructor_.apply(this,arguments)}static nearestEndpoint(t,e,n,s){let i=t,r=D.pointToSegment(t,n,s),o=D.pointToSegment(e,n,s);return o<r&&(r=o,i=e),o=D.pointToSegment(n,t,e),o<r&&(r=o,i=n),o=D.pointToSegment(s,t,e),o<r&&(r=o,i=s),i}isInSegmentEnvelopes(t){const e=new N(this._inputLines[0][0],this._inputLines[0][1]),n=new N(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,N.intersects(e,n,t)&&0===v.index(e,n,t)&&0===v.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=$t.POINT_INTERSECTION,null;this._result=$t.NO_INTERSECTION}}normalizeToMinimum(t,e,n,s,i){i.x=this.smallestInAbsValue(t.x,e.x,n.x,s.x),i.y=this.smallestInAbsValue(t.y,e.y,n.y,s.y),t.x-=i.x,t.y-=i.y,e.x-=i.x,e.y-=i.y,n.x-=i.x,n.y-=i.y,s.x-=i.x,s.y-=i.y}safeHCoordinateIntersection(t,e,n,s){let i=null;try{i=b.intersection(t,e,n,s)}catch(r){if(!(r instanceof S))throw r;i=te.nearestEndpoint(t,e,n,s)}return i}intersection(t,e,n,s){let i=this.intersectionWithNormalization(t,e,n,s);return this.isInSegmentEnvelopes(i)||(i=new g(te.nearestEndpoint(t,e,n,s))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}smallestInAbsValue(t,e,n,s){let i=t,r=Math.abs(i);return Math.abs(e)<r&&(i=e,r=Math.abs(e)),Math.abs(n)<r&&(i=n,r=Math.abs(n)),Math.abs(s)<r&&(i=s),i}checkDD(t,e,n,s,i){const r=P.intersection(t,e,n,s),o=this.isInSegmentEnvelopes(r);O.out.println("DD in env = "+o+"  --------------------- "+r),i.distance(r)>1e-4&&O.out.println("Distance = "+i.distance(r))}intersectionWithNormalization(t,e,n,s){const i=new g(t),r=new g(e),o=new g(n),l=new g(s),a=new g;this.normalizeToEnvCentre(i,r,o,l,a);const c=this.safeHCoordinateIntersection(i,r,o,l);return c.x+=a.x,c.y+=a.y,c}computeCollinearIntersection(t,e,n,s){const i=N.intersects(t,e,n),r=N.intersects(t,e,s),o=N.intersects(n,s,t),l=N.intersects(n,s,e);return i&&r?(this._intPt[0]=n,this._intPt[1]=s,$t.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,$t.COLLINEAR_INTERSECTION):i&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):i&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):r&&o?(this._intPt[0]=s,this._intPt[1]=t,!s.equals(t)||i||l?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):r&&l?(this._intPt[0]=s,this._intPt[1]=e,!s.equals(e)||i||o?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):$t.NO_INTERSECTION}normalizeToEnvCentre(t,e,n,s,i){const r=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,l=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,c=n.x<s.x?n.x:s.x,h=n.y<s.y?n.y:s.y,u=n.x>s.x?n.x:s.x,g=n.y>s.y?n.y:s.y,d=((r>c?r:c)+(l<u?l:u))/2,_=((o>h?o:h)+(a<g?a:g))/2;i.x=d,i.y=_,t.x-=i.x,t.y-=i.y,e.x-=i.x,e.y-=i.y,n.x-=i.x,n.y-=i.y,s.x-=i.x,s.y-=i.y}computeIntersect(t,e,n,s){if(this._isProper=!1,!N.intersects(t,e,n,s))return $t.NO_INTERSECTION;const i=v.index(t,e,n),r=v.index(t,e,s);if(i>0&&r>0||i<0&&r<0)return $t.NO_INTERSECTION;const o=v.index(n,s,t),l=v.index(n,s,e);return o>0&&l>0||o<0&&l<0?$t.NO_INTERSECTION:0===i&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,s):(0===i||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(s)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(s)?this._intPt[0]=e:0===i?this._intPt[0]=new g(n):0===r?this._intPt[0]=new g(s):0===o?this._intPt[0]=new g(t):0===l&&(this._intPt[0]=new g(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,s)),$t.POINT_INTERSECTION)}getClass(){return te}get interfaces_(){return[]}}te.constructor_=function(){};class ee{constructor(){ee.constructor_.apply(this,arguments)}static midPoint(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof ee){const t=arguments[0],e=v.index(this.p0,this.p1,t.p0),n=v.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof g){const t=arguments[0];return v.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof ee))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new te;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof g){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);const e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ee){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let s=this.project(t.p0);e<0&&(s=this.p0),e>1&&(s=this.p1);let i=this.project(t.p1);return n<0&&(i=this.p0),n>1&&(i=this.p1),new ee(s,i)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return D.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return ee.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,s=e*e+n*n;return s<=0?i.NaN:((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/s}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let s=i.MAX_VALUE,r=null;const o=this.closestPoint(t.p0);s=o.distance(t.p0),n[0]=o,n[1]=t.p0;const l=this.closestPoint(t.p1);r=l.distance(t.p1),r<s&&(s=r,n[0]=l,n[1]=t.p1);const a=t.closestPoint(this.p0);r=a.distance(this.p0),r<s&&(s=r,n[0]=this.p0,n[1]=a);const c=t.closestPoint(this.p1);return r=c.distance(this.p1),r<s&&(s=r,n[0]=this.p1,n[1]=c),n}closestPoint(t){const e=this.projectionFactor(t);return e>0&&e<1?this.project(t):this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){try{return b.intersection(this.p0,this.p1,t.p0,t.p1)}catch(t){if(!(t instanceof S))throw t}return null}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),s=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(i*i+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new IllegalStateException("Cannot compute offset from zero-length line segment");l=e*i/o,a=e*r/o}return new g(n-a,s+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||i.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}distance(){if(arguments[0]instanceof ee){const t=arguments[0];return D.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){const t=arguments[0];return D.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=java.lang.Double.doubleToLongBits(this.p1.x);return n^=31*java.lang.Double.doubleToLongBits(this.p1.y),e^(Math.trunc(n)^Math.trunc(n>>32))}getClass(){return ee}get interfaces_(){return[r,a]}}ee.constructor_=function(){if(this.p0=null,this.p1=null,0===arguments.length)ee.constructor_.call(this,new g,new g);else if(1===arguments.length){const t=arguments[0];ee.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ee.constructor_.call(this,new g(t,e),new g(n,s))}},ee.serialVersionUID=0x2d2172135f411c00;class ne{constructor(){ne.constructor_.apply(this,arguments)}static toLocationSymbol(t){switch(t){case ne.EXTERIOR:return"e";case ne.BOUNDARY:return"b";case ne.INTERIOR:return"i";case ne.NONE:return"-"}throw new n("Unknown location value: "+t)}getClass(){return ne}get interfaces_(){return[]}}ne.constructor_=function(){},ne.INTERIOR=0,ne.BOUNDARY=1,ne.EXTERIOR=2,ne.NONE=-1;class se{constructor(){se.constructor_.apply(this,arguments)}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===ut.SYM_DONTCARE||(e===ut.SYM_TRUE&&(t>=0||t===ut.TRUE)||(e===ut.SYM_FALSE&&t===ut.FALSE||(e===ut.SYM_P&&t===ut.P||(e===ut.SYM_L&&t===ut.L||e===ut.SYM_A&&t===ut.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return new se(t).matches(e)}}static isTrue(t){return t>=0||t===ut.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])||se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY]))&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE}isCoveredBy(){return(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])||se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY]))&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this._matrix[n][s]=ut.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this.setAtLeast(n,s,ut.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===ut.A&&e===ut.A||t===ut.L&&e===ut.L||t===ut.L&&e===ut.A||t===ut.P&&e===ut.A||t===ut.P&&e===ut.L)&&(this._matrix[ne.INTERIOR][ne.INTERIOR]===ut.FALSE&&(se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY])))}isOverlaps(t,e){return t===ut.P&&e===ut.P||t===ut.A&&e===ut.A?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]):t===ut.L&&e===ut.L&&(1===this._matrix[ne.INTERIOR][ne.INTERIOR]&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]))}isEquals(t,e){return t===e&&(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE)}toString(){const t=new wt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,ut.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new n("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!se.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[ne.INTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.INTERIOR][ne.BOUNDARY]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.BOUNDARY]===ut.FALSE}isCrosses(t,e){return t===ut.P&&e===ut.L||t===ut.P&&e===ut.A||t===ut.L&&e===ut.A?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR]):t===ut.L&&e===ut.P||t===ut.A&&e===ut.P||t===ut.A&&e===ut.L?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]):t===ut.L&&e===ut.L&&0===this._matrix[ne.INTERIOR][ne.INTERIOR]}getClass(){return se}get interfaces_(){return[o]}}se.constructor_=function(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map(()=>Array(3)),this.setAll(ut.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];se.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof se){const t=arguments[0];se.constructor_.call(this),this._matrix[ne.INTERIOR][ne.INTERIOR]=t._matrix[ne.INTERIOR][ne.INTERIOR],this._matrix[ne.INTERIOR][ne.BOUNDARY]=t._matrix[ne.INTERIOR][ne.BOUNDARY],this._matrix[ne.INTERIOR][ne.EXTERIOR]=t._matrix[ne.INTERIOR][ne.EXTERIOR],this._matrix[ne.BOUNDARY][ne.INTERIOR]=t._matrix[ne.BOUNDARY][ne.INTERIOR],this._matrix[ne.BOUNDARY][ne.BOUNDARY]=t._matrix[ne.BOUNDARY][ne.BOUNDARY],this._matrix[ne.BOUNDARY][ne.EXTERIOR]=t._matrix[ne.BOUNDARY][ne.EXTERIOR],this._matrix[ne.EXTERIOR][ne.INTERIOR]=t._matrix[ne.EXTERIOR][ne.INTERIOR],this._matrix[ne.EXTERIOR][ne.BOUNDARY]=t._matrix[ne.EXTERIOR][ne.BOUNDARY],this._matrix[ne.EXTERIOR][ne.EXTERIOR]=t._matrix[ne.EXTERIOR][ne.EXTERIOR]}};class ie{constructor(){ie.constructor_.apply(this,arguments)}static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=ie.PI_TIMES_2;for(;t<=-Math.PI;)t+=ie.PI_TIMES_2;return t}static angle(){if(1===arguments.length){const t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return Math.atan2(s,n)}}static isAcute(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)>0}static isObtuse(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)<0}static interiorAngle(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n);return Math.abs(i-s)}static normalizePositive(t){if(t<0){for(;t<0;)t+=ie.PI_TIMES_2;t>=ie.PI_TIMES_2&&(t=0)}else{for(;t>=ie.PI_TIMES_2;)t-=ie.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n);return ie.diff(s,i)}static diff(t,e){let n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n}static toRadians(t){return t*Math.PI/180}static getTurn(t,e){const n=Math.sin(e-t);return n>0?ie.COUNTERCLOCKWISE:n<0?ie.CLOCKWISE:ie.NONE}static angleBetweenOriented(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n)-s;return i<=-Math.PI?i+ie.PI_TIMES_2:i>Math.PI?i-ie.PI_TIMES_2:i}getClass(){return ie}get interfaces_(){return[]}}ie.constructor_=function(){},ie.PI_TIMES_2=2*Math.PI,ie.PI_OVER_2=Math.PI/2,ie.PI_OVER_4=Math.PI/4,ie.COUNTERCLOCKWISE=v.COUNTERCLOCKWISE,ie.CLOCKWISE=v.CLOCKWISE,ie.NONE=v.COLLINEAR;class re{constructor(){re.constructor_.apply(this,arguments)}static area(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}static signedArea(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}static det(t,e,n,s){return t*s-e*n}static interpolateZ(t,e,n,s){const i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.z+d*(n.z-e.z)+_*(s.z-e.z)}static longestSideLength(t,e,n){const s=t.distance(e),i=e.distance(n),r=n.distance(t);let o=s;return i>o&&(o=i),r>o&&(o=r),o}static isAcute(t,e,n){return!!ie.isAcute(t,e,n)&&(!!ie.isAcute(e,n,t)&&!!ie.isAcute(n,t,e))}static circumcentre(t,e,n){const s=n.x,i=n.y,r=t.x-s,o=t.y-i,l=e.x-s,a=e.y-i,c=2*re.det(r,o,l,a),h=re.det(o,r*r+o*o,a,l*l+a*a),u=re.det(r,r*r+o*o,l,l*l+a*a);return new g(s-h/c,i+u/c)}static perpendicularBisector(t,e){const n=e.x-t.x,s=e.y-t.y,i=new b(t.x+n/2,t.y+s/2,1),r=new b(t.x-s+n/2,t.y+n+s/2,1);return new b(i,r)}static angleBisector(t,e,n){const s=e.distance(t),i=s/(s+e.distance(n)),r=n.x-t.x,o=n.y-t.y;return new g(t.x+i*r,t.y+i*o)}static area3D(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=e.z-t.z,o=n.x-t.x,l=n.y-t.y,a=n.z-t.z,c=i*a-r*l,h=r*o-s*a,u=s*l-i*o,g=c*c+h*h+u*u;return Math.sqrt(g)/2}static centroid(t,e,n){const s=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new g(s,i)}static inCentre(t,e,n){const s=e.distance(n),i=t.distance(n),r=t.distance(e),o=s+i+r,l=(s*t.x+i*e.x+r*n.x)/o,a=(s*t.y+i*e.y+r*n.y)/o;return new g(l,a)}area(){return re.area(this.p0,this.p1,this.p2)}signedArea(){return re.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new n("Supplied point is null.");return re.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return re.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return re.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return re.circumcentre(this.p0,this.p1,this.p2)}area3D(){return re.area3D(this.p0,this.p1,this.p2)}centroid(){return re.centroid(this.p0,this.p1,this.p2)}inCentre(){return re.inCentre(this.p0,this.p1,this.p2)}getClass(){return re}get interfaces_(){return[]}}re.constructor_=function(){this.p0=null,this.p1=null,this.p2=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n};class oe extends C{constructor(){super(),oe.constructor_.apply(this,arguments)}getClass(){return oe}get interfaces_(){return[]}}oe.constructor_=function(){if(0===arguments.length)C.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];C.constructor_.call(this,t)}};class le{constructor(){le.constructor_.apply(this,arguments)}static translationInstance(t,e){const n=new le;return n.setToTranslation(t,e),n}static shearInstance(t,e){const n=new le;return n.setToShear(t,e),n}static reflectionInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToReflection(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.setToReflection(t,e,n,s),i}}static rotationInstance(){if(1===arguments.length){const t=arguments[0];return le.rotationInstance(Math.sin(t),Math.cos(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToRotation(t,e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return le.rotationInstance(Math.sin(t),Math.cos(t),e,n)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.setToRotation(t,e,n,s),i}}static scaleInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToScale(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.translate(-n,-s),i.scale(t,e),i.translate(n,s),i}}setToReflectionBasic(t,e,s,i){if(t===s&&e===i)throw new n("Reflection line points must be distinct");const r=s-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l,h=2*a*c,u=c*c-a*a;return this._m00=u,this._m01=h,this._m02=0,this._m10=h,this._m11=-u,this._m12=0,this}getInverse(){const t=this.getDeterminant();if(0===t)throw new oe("Transformation is non-invertible");const e=this._m11/t,n=-this._m10/t,s=-this._m01/t,i=this._m00/t,r=(this._m01*this._m12-this._m02*this._m11)/t,o=(-this._m00*this._m12+this._m10*this._m02)/t;return new le(e,s,r,n,i,o)}compose(t){const e=t._m00*this._m00+t._m01*this._m10,n=t._m00*this._m01+t._m01*this._m11,s=t._m00*this._m02+t._m01*this._m12+t._m02,i=t._m10*this._m00+t._m11*this._m10,r=t._m10*this._m01+t._m11*this._m11,o=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}equals(t){if(null===t)return!1;if(!(t instanceof le))return!1;const e=t;return this._m00===e._m00&&this._m01===e._m01&&this._m02===e._m02&&this._m10===e._m10&&this._m11===e._m11&&this._m12===e._m12}setToScale(t,e){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=e,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,e){return this.compose(le.scaleInstance(t,e)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1===arguments.length){const t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return this._m00=t,this._m01=e,this._m02=n,this._m10=s,this._m11=i,this._m12=r,this}}setToRotation(){if(1===arguments.length){const t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._m00=e,this._m01=-t,this._m02=0,this._m10=t,this._m11=e,this._m12=0,this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),e,n),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this._m00=e,this._m01=-t,this._m02=n-n*e+s*t,this._m10=t,this._m11=e,this._m12=s-n*t-s*e,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,e){this.transform(t,e)}rotate(){if(1===arguments.length){const t=arguments[0];return this.compose(le.rotationInstance(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.rotationInstance(t,e)),this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.compose(le.rotationInstance(t,e,n)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.rotationInstance(t,e)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){const e=this._m00*t._m00+this._m01*t._m10,n=this._m00*t._m01+this._m01*t._m11,s=this._m00*t._m02+this._m01*t._m12+this._m02,i=this._m10*t._m00+this._m11*t._m10,r=this._m10*t._m01+this._m11*t._m11,o=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}setToShear(t,e){return this._m00=1,this._m01=t,this._m02=0,this._m10=e,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){try{return null}catch(t){if(!(t instanceof C))throw t;u.shouldNeverReachHere()}return null}translate(t,e){return this.compose(le.translationInstance(t,e)),this}setToReflection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Reflection vector must be non-zero");if(t===e)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;const s=Math.sqrt(t*t+e*e),i=e/s,r=t/s;return this.rotate(-i,r),this.scale(1,-1),this.rotate(i,r),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],s=arguments[2],i=arguments[3];if(t===s&&e===i)throw new n("Reflection line points must be distinct");this.setToTranslation(-t,-e);const r=s-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l;return this.rotate(-a,c),this.scale(1,-1),this.rotate(a,c),this.translate(t,e),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,e){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=e,this}shear(t,e){return this.compose(le.shearInstance(t,e)),this}transform(){if(1===arguments.length){const t=arguments[0].copy();return t.apply(this),t}if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=this._m00*t.x+this._m01*t.y+this._m02,s=this._m10*t.x+this._m11*t.y+this._m12;return e.x=n,e.y=s,e}if(_(arguments[0],A)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=this._m00*t.getOrdinate(e,0)+this._m01*t.getOrdinate(e,1)+this._m02,s=this._m10*t.getOrdinate(e,0)+this._m11*t.getOrdinate(e,1)+this._m12;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}}}reflect(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.reflectionInstance(t,e)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(le.reflectionInstance(t,e,n,s)),this}}getClass(){return le}get interfaces_(){return[o,dt]}}le.constructor_=function(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0===arguments.length)this.setToIdentity();else if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof le){const t=arguments[0];this.setTransformation(t)}}else if(6===arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this.setTransformation(t,e,n,s,i,r)}};class ae{constructor(){ae.constructor_.apply(this,arguments)}static solve(t,e){const s=e.length;if(t.length!==s||t[0].length!==s)throw new n("Matrix A is incorrectly sized");for(let n=0;n<s;n++){let i=n;for(let e=n+1;e<s;e++)Math.abs(t[e][n])>Math.abs(t[i][n])&&(i=e);if(0===t[i][n])return null;ae.swapRows(t,n,i),ae.swapRows(e,n,i);for(let i=n+1;i<s;i++){const r=t[i][n]/t[n][n];for(let e=s-1;e>=n;e--)t[i][e]-=t[n][e]*r;e[i]-=e[n]*r}}const i=new Array(s).fill(null);for(let n=s-1;n>=0;n--){let r=0;for(let e=n+1;e<s;e++)r+=t[n][e]*i[e];i[n]=(e[n]-r)/t[n][n]}return i}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;for(let s=0;s<t[0].length;s++){const i=t[e][s];t[e][s]=t[n][s],t[n][s]=i}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;const s=t[e];t[e]=t[n],t[n]=s}}getClass(){return ae}get interfaces_(){return[]}}ae.constructor_=function(){};class ce{constructor(){ce.constructor_.apply(this,arguments)}solve(t){const e=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return ae.solve(e,t)}compute(){const t=[this._dest0.x,this._dest1.x,this._dest2.x],e=this.solve(t);if(null===e)return!1;this._m00=e[0],this._m01=e[1],this._m02=e[2];const n=[this._dest0.y,this._dest1.y,this._dest2.y],s=this.solve(n);return null!==s&&(this._m10=s[0],this._m11=s[1],this._m12=s[2],!0)}getTransformation(){return this.compute()?new le(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}getClass(){return ce}get interfaces_(){return[]}}ce.constructor_=function(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this._src0=t,this._src1=e,this._src2=n,this._dest0=s,this._dest1=i,this._dest2=r};class he{constructor(){he.constructor_.apply(this,arguments)}static createFromBaseLines(t,e,n,s){const i=new g(t.x+s.x-n.x,t.y+s.y-n.y),r=ie.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return new le;const a=l/o,c=le.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}static createFromControlVectors(){if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return le.translationInstance(n,s)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1];if(t.length!==e.length)throw new n("Src and Dest arrays are not the same length");if(t.length<=0)throw new n("Too few control points");if(t.length>3)throw new n("Too many control points");return 1===t.length?he.createFromControlVectors(t[0],e[0]):2===t.length?he.createFromControlVectors(t[0],t[1],e[0],e[1]):he.createFromControlVectors(t[0],t[1],t[2],e[0],e[1],e[2])}}else{if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new g(s.x-n.x,s.y-n.y),r=ie.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return null;const a=l/o,c=le.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return new ce(t,e,n,s,i,r).getTransformation()}}}getClass(){return he}get interfaces_(){return[]}}he.constructor_=function(){};class ue{constructor(){ue.constructor_.apply(this,arguments)}static getCoordinates(t){const e=new x;return t.apply(new ue(e)),e}filter(t){(t instanceof Tt||t instanceof Pt)&&this._coords.add(t.getCoordinate())}getClass(){return ue}get interfaces_(){return[G]}}ue.constructor_=function(){this._coords=null;const t=arguments[0];this._coords=t};class ge{constructor(){ge.constructor_.apply(this,arguments)}static map(t,e){return new ge(e).map(t)}map(t){const e=new x;for(let n=0;n<t.getNumGeometries();n++){const s=this._mapOp.map(t.getGeometryN(n));s.isEmpty()||e.add(s)}return t.getFactory().createGeometryCollection(Ht.toGeometryArray(e))}getClass(){return ge}get interfaces_(){return[]}}ge.constructor_=function(){this._mapOp=null;const t=arguments[0];this._mapOp=t};class de{constructor(){de.constructor_.apply(this,arguments)}static combine(){if(1===arguments.length){const t=arguments[0];return new de(t).combine()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new de(de.createList(t,e)).combine()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new de(de.createList(t,e,n)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new x;return n.add(t),n.add(e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new x;return s.add(t),s.add(e),s.add(n),s}}extractElements(t,e){if(null===t)return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);this._skipEmpty&&s.isEmpty()||e.add(s)}}combine(){const t=new x;for(let e=this._inputGeoms.iterator();e.hasNext();){const n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}getClass(){return de}get interfaces_(){return[]}}de.constructor_=function(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;const t=arguments[0];this._geomFactory=de.extractFactory(t),this._inputGeoms=t};class _e{constructor(){_e.constructor_.apply(this,arguments)}static isOfType(t,e){return t.getGeometryType()===e||e===q.TYPENAME_LINESTRING&&t.getGeometryType()===q.TYPENAME_LINEARRING}static extract(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return _e.extract(t,e,new x)}if(3===arguments.length){if(_(arguments[2],m)&&arguments[0]instanceof q&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t.getGeometryType()===e?n.add(t):t instanceof _t&&t.apply(new _e(e,n)),n}if(_(arguments[2],m)&&arguments[0]instanceof q&&arguments[1]instanceof Class){const t=arguments[0],e=arguments[1],n=arguments[2];return _e.extract(t,_e.toGeometryType(e),n)}}}filter(t){(null===this._geometryType||_e.isOfType(t,this._geometryType))&&this._comps.add(t)}getClass(){return _e}get interfaces_(){return[gt]}}_e.constructor_=function(){this._geometryType=null,this._comps=null;const t=arguments[0],e=arguments[1];this._geometryType=t,this._comps=e};class fe{constructor(){fe.constructor_.apply(this,arguments)}map(t){}getClass(){return fe}get interfaces_(){return[]}}fe.constructor_=function(){};class pe{constructor(){pe.constructor_.apply(this,arguments)}static map(){if(arguments[0]instanceof q&&_(arguments[1],fe)){const t=arguments[0],e=arguments[1],n=new x;for(let s=0;s<t.getNumGeometries();s++){const i=e.map(t.getGeometryN(s));null!==i&&n.add(i)}return t.getFactory().buildGeometry(n)}if(_(arguments[0],f)&&_(arguments[1],fe)){const t=arguments[0],e=arguments[1],n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e.map(t);null!==i&&n.add(i)}return n}}getClass(){return pe}get interfaces_(){return[]}}pe.constructor_=function(){};class me{constructor(){me.constructor_.apply(this,arguments)}transformPoint(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,e){let n=!0;const s=this.transformLinearRing(t.getExteriorRing(),t);null!==s&&s instanceof Dt&&!s.isEmpty()||(n=!1);const i=new x;for(let e=0;e<t.getNumInteriorRing();e++){const s=this.transformLinearRing(t.getInteriorRingN(e),t);null===s||s.isEmpty()||(s instanceof Dt||(n=!1),i.add(s))}if(n)return this._factory.createPolygon(s,i.toArray([]));{const t=new x;return null!==s&&t.add(s),t.addAll(i),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformLineString(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformCoordinates(t,e){return this.copy(t)}transformLineString(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPoint(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformMultiPolygon(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPolygon(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}copy(t){return t.copy()}transformGeometryCollection(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transform(t.getGeometryN(e));null!==s&&(this._pruneEmptyGeometry&&s.isEmpty()||n.add(s))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Ht.toGeometryArray(n)):this._factory.buildGeometry(n)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof Pt)return this.transformPoint(t,null);if(t instanceof Mt)return this.transformMultiPoint(t,null);if(t instanceof Dt)return this.transformLinearRing(t,null);if(t instanceof Tt)return this.transformLineString(t,null);if(t instanceof ft)return this.transformMultiLineString(t,null);if(t instanceof bt)return this.transformPolygon(t,null);if(t instanceof At)return this.transformMultiPolygon(t,null);if(t instanceof _t)return this.transformGeometryCollection(t,null);throw new n("Unknown Geometry subtype: "+t.getClass().getName())}transformLinearRing(t,e){const n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);const s=n.size();return s>0&&s<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)}getClass(){return me}get interfaces_(){return[]}}me.constructor_=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1};class ye{constructor(){ye.constructor_.apply(this,arguments)}static getGeometry(t){return t.getFactory().buildGeometry(ye.getLines(t))}static getLines(){if(1===arguments.length){const t=arguments[0];return ye.getLines(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof Tt?e.add(t):t instanceof _t&&t.apply(new ye(e)),e}}filter(t){t instanceof Tt&&this._comps.add(t)}getClass(){return ye}get interfaces_(){return[gt]}}ye.constructor_=function(){this._comps=null;const t=arguments[0];this._comps=t};class xe{constructor(){xe.constructor_.apply(this,arguments)}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(xe.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(xe.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return xe.getLines(t,!1)}if(2===arguments.length){if(_(arguments[0],f)&&_(arguments[1],f)){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){const t=n.next();xe.getLines(t,e)}return e}if(arguments[0]instanceof q&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new x;return t.apply(new xe(n,e)),n}if(arguments[0]instanceof q&&_(arguments[1],f)){const t=arguments[0],e=arguments[1];return t instanceof Tt?e.add(t):t.apply(new xe(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&_(arguments[0],f)&&_(arguments[1],f)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=t.iterator();s.hasNext();){const t=s.next();xe.getLines(t,e,n)}return e}if("boolean"==typeof arguments[2]&&arguments[0]instanceof q&&_(arguments[1],f)){const t=arguments[0],e=arguments[1],n=arguments[2];return t.apply(new xe(e,n)),e}}}filter(t){if(this._isForcedToLineString&&t instanceof Dt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof Tt&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}getClass(){return xe}get interfaces_(){return[G]}}xe.constructor_=function(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}};const Ee={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return Ee.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?ht.sort(n,e):ht.sort(n);const s=t.iterator();for(let t=0,e=n.length;t<e;t++)s.next(),s.set(n[t])},singletonList:function(t){const e=new x;return e.add(t),e}};class Ie{constructor(){Ie.constructor_.apply(this,arguments)}static getPoints(){if(1===arguments.length){const t=arguments[0];return t instanceof Pt?Ee.singletonList(t):Ie.getPoints(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof Pt?e.add(t):t instanceof _t&&t.apply(new Ie(e)),e}}filter(t){t instanceof Pt&&this._pts.add(t)}getClass(){return Ie}get interfaces_(){return[gt]}}Ie.constructor_=function(){this._pts=null;const t=arguments[0];this._pts=t};class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static getPolygons(){if(1===arguments.length){const t=arguments[0];return Ne.getPolygons(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof bt?e.add(t):t instanceof _t&&t.apply(new Ne(e)),e}}filter(t){t instanceof bt&&this._comps.add(t)}getClass(){return Ne}get interfaces_(){return[gt]}}Ne.constructor_=function(){this._comps=null;const t=arguments[0];this._comps=t};class Ce{constructor(){Ce.constructor_.apply(this,arguments)}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof _t)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}getClass(){return Ce}get interfaces_(){return[]}}Ce.constructor_=function(){this._isDone=!1};class Se{constructor(){Se.constructor_.apply(this,arguments)}createSupercircle(t){const e=1/t,n=this._dim.getMinSize()/2,s=this._dim.getCentre(),i=Math.pow(n,t),r=n,o=Math.pow(i/2,e),l=Math.trunc(this._nPts/8),a=new Array(8*l+1).fill(null),c=o/l;for(let n=0;n<=l;n++){let o=0,h=r;if(0!==n){o=c*n;const s=Math.pow(o,t);h=Math.pow(i-s,e)}a[n]=this.coordTrans(o,h,s),a[2*l-n]=this.coordTrans(h,o,s),a[2*l+n]=this.coordTrans(h,-o,s),a[4*l-n]=this.coordTrans(o,-h,s),a[4*l+n]=this.coordTrans(-o,-h,s),a[6*l-n]=this.coordTrans(-h,-o,s),a[6*l+n]=this.coordTrans(-h,o,s),a[8*l-n]=this.coordTrans(-o,h,s)}a[a.length-1]=new g(a[0]);const h=this._geomFact.createLinearRing(a),u=this._geomFact.createPolygon(h);return this.rotate(u)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){const t=this._dim.getEnvelope(),e=t.getWidth()/2,n=t.getHeight()/2,s=t.getMinX()+e,i=t.getMinY()+n,r=new Array(this._nPts+1).fill(null);let o=0;for(let t=0;t<this._nPts;t++){const l=t*(2*Math.PI/this._nPts),a=e*Math.cos(l)+s,c=n*Math.sin(l)+i;r[o++]=this.coord(a,c)}r[o]=new g(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}coordTrans(t,e,n){return this.coord(t+n.x,e+n.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts).fill(null);let h=0;for(let e=0;e<this._nPts;e++){const n=t+e*a,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}const u=this._geomFact.createLineString(c);return this.rotate(u)}rotate(t){if(0!==this._rotationAngle){const e=le.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(e)}return t}coord(t,e){const n=new g(t,e);return this._precModel.makePrecise(n),n}createArcPolygon(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts+2).fill(null);let h=0;c[h++]=this.coord(r,o);for(let e=0;e<this._nPts;e++){const n=t+a*e,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}c[h++]=this.coord(r,o);const u=this._geomFact.createLinearRing(c),g=this._geomFact.createPolygon(u);return this.rotate(g)}createRectangle(){let t=null,e=0,n=Math.trunc(this._nPts/4);n<1&&(n=1);const s=this._dim.getEnvelope().getWidth()/n,i=this._dim.getEnvelope().getHeight()/n,r=new Array(4*n+1).fill(null),o=this._dim.getEnvelope();for(t=0;t<n;t++){const n=o.getMinX()+t*s,i=o.getMinY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMaxX(),s=o.getMinY()+t*i;r[e++]=this.coord(n,s)}for(t=0;t<n;t++){const n=o.getMaxX()-t*s,i=o.getMaxY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMinX(),s=o.getMaxY()-t*i;r[e++]=this.coord(n,s)}r[e++]=new g(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}getClass(){return Se}get interfaces_(){return[]}}class we{constructor(){we.constructor_.apply(this,arguments)}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new g(t.getMinX(),t.getMinY()),this.centre=new g(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new N(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new N(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new N(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new g(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}getClass(){return we}get interfaces_(){return[]}}we.constructor_=function(){this.base=null,this.centre=null,this.width=null,this.height=null},Se.Dimensions=we,Se.constructor_=function(){if(this._geomFact=null,this._precModel=null,this._dim=new we,this._nPts=100,this._rotationAngle=0,0===arguments.length)Se.constructor_.call(this,new Ht);else if(1===arguments.length){const t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}};class Le extends Se{constructor(){super(),Le.constructor_.apply(this,arguments)}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){const t=this._dim.getEnvelope(),e=t.getWidth()/2;let n=this._armLengthRatio;n<0&&(n=0),n>1&&(n=1);const s=n*e,i=(1-n)*e,r=t.getMinX()+e,o=t.getMinY()+e,l=new Array(this._nPts+1).fill(null);let a=0;for(let t=0;t<this._nPts;t++){const e=t/this._nPts*this._numArms,n=e-Math.floor(e),c=2*Math.PI*n,h=i+s*((Math.cos(c)+1)/2),u=t*(2*Math.PI/this._nPts),g=h*Math.cos(u)+r,d=h*Math.sin(u)+o;l[a++]=this.coord(g,d)}l[a]=new g(l[0]);const c=this._geomFact.createLinearRing(l);return this._geomFact.createPolygon(c)}getClass(){return Le}get interfaces_(){return[]}}Le.constructor_=function(){if(this._numArms=8,this._armLengthRatio=.5,0===arguments.length)Se.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];Se.constructor_.call(this,t)}};var Te=Object.freeze({__proto__:null,AffineTransformation:le,AffineTransformationBuilder:ce,AffineTransformationFactory:he,ComponentCoordinateExtracter:ue,GeometryCollectionMapper:ge,GeometryCombiner:de,GeometryEditor:Ft,GeometryExtracter:_e,GeometryMapper:pe,GeometryTransformer:me,LineStringExtracter:ye,LinearComponentExtracter:xe,MapOp:fe,PointExtracter:Ie,PolygonExtracter:Ne,ShortCircuitedGeometryVisitor:Ce,SineStarFactory:Le}),Re=Object.freeze({__proto__:null,Coordinate:g,CoordinateList:I,Envelope:N,LineSegment:ee,GeometryFactory:Ht,Geometry:q,Point:Pt,LineString:Tt,LinearRing:Dt,Polygon:bt,GeometryCollection:_t,MultiPoint:Mt,MultiLineString:ft,MultiPolygon:At,Dimension:ut,IntersectionMatrix:se,PrecisionModel:kt,Location:ne,Triangle:re,util:Te});class Pe{constructor(){Pe.constructor_.apply(this,arguments)}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1===arguments.length){const t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n<this._distance&&this.initialize(t,e,n)}}initialize(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=n,this._isNull=!1}}toString(){return Jt.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1===arguments.length){const t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n>this._distance&&this.initialize(t,e,n)}}getClass(){return Pe}get interfaces_(){return[]}}Pe.constructor_=function(){this._pt=[new g,new g],this._distance=i.NaN,this._isNull=!0};class ve{constructor(){ve.constructor_.apply(this,arguments)}static computeDistance(){if(arguments[2]instanceof Pe&&arguments[0]instanceof Tt&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2],s=new ee,i=t.getCoordinates();for(let t=0;t<i.length-1;t++){s.setCoordinates(i[t],i[t+1]);const r=s.closestPoint(e);n.setMinimum(r,e)}}else if(arguments[2]instanceof Pe&&arguments[0]instanceof bt&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2];ve.computeDistance(t.getExteriorRing(),e,n);for(let s=0;s<t.getNumInteriorRing();s++)ve.computeDistance(t.getInteriorRingN(s),e,n)}else if(arguments[2]instanceof Pe&&arguments[0]instanceof q&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2];if(t instanceof Tt)ve.computeDistance(t,e,n);else if(t instanceof bt)ve.computeDistance(t,e,n);else if(t instanceof _t){const s=t;for(let t=0;t<s.getNumGeometries();t++){const i=s.getGeometryN(t);ve.computeDistance(i,e,n)}}else n.setMinimum(t.getCoordinate(),e)}else if(arguments[2]instanceof Pe&&arguments[0]instanceof ee&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.closestPoint(e);n.setMinimum(s,e)}}getClass(){return ve}get interfaces_(){return[]}}ve.constructor_=function(){};class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static distance(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Oe(t,e).distance()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Oe(t,e);return s.setDensifyFraction(n),s.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new n("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,e,n){const s=new be(e);if(t.apply(s),n.setMaximum(s.getMaxPointDistance()),this._densifyFrac>0){const s=new Me(e,this._densifyFrac);t.apply(s),n.setMaximum(s.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}getClass(){return Oe}get interfaces_(){return[]}}class be{constructor(){be.constructor_.apply(this,arguments)}filter(t){this._minPtDist.initialize(),ve.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}getClass(){return be}get interfaces_(){return[B]}}be.constructor_=function(){this._maxPtDist=new Pe,this._minPtDist=new Pe,this._euclideanDist=new ve,this._geom=null;const t=arguments[0];this._geom=t};class Me{constructor(){Me.constructor_.apply(this,arguments)}filter(t,e){if(0===e)return null;const n=t.getCoordinate(e-1),s=t.getCoordinate(e),i=(s.x-n.x)/this._numSubSegs,r=(s.y-n.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){const e=n.x+t*i,s=n.y+t*r,o=new g(e,s);this._minPtDist.initialize(),ve.computeDistance(this._geom,o,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}getClass(){return Me}get interfaces_(){return[dt]}}Me.constructor_=function(){this._maxPtDist=new Pe,this._minPtDist=new Pe,this._geom=null,this._numSubSegs=0;const t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))},Oe.MaxPointDistanceFilter=be,Oe.MaxDensifiedByFractionDistanceFilter=Me,Oe.constructor_=function(){this._g0=null,this._g1=null,this._ptDist=new Pe,this._densifyFrac=0;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e};var De=Object.freeze({__proto__:null,DiscreteHausdorffDistance:Oe,DistanceToPoint:ve,PointPairDistance:Pe});class Ae{constructor(){Ae.constructor_.apply(this,arguments)}visitItem(t){}getClass(){return Ae}get interfaces_(){return[]}}Ae.constructor_=function(){};class Fe{constructor(){Fe.constructor_.apply(this,arguments)}locate(t){}getClass(){return Fe}get interfaces_(){return[]}}Fe.constructor_=function(){};class Ge{constructor(){Ge.constructor_.apply(this,arguments)}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Jt.toLineString(new g(this._min,0),new g(this._max,0))}getClass(){return Ge}get interfaces_(){return[]}}class qe{constructor(){qe.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e,i=(n._min+n._max)/2,r=(s._min+s._max)/2;return i<r?-1:i>r?1:0}getClass(){return qe}get interfaces_(){return[l]}}qe.constructor_=function(){},Ge.NodeComparator=qe,Ge.constructor_=function(){this._min=i.POSITIVE_INFINITY,this._max=i.NEGATIVE_INFINITY};class Be extends Ge{constructor(){super(),Be.constructor_.apply(this,arguments)}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}getClass(){return Be}get interfaces_(){return[]}}Be.constructor_=function(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n};class Ve extends Ge{constructor(){super(),Ve.constructor_.apply(this,arguments)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}getClass(){return Ve}get interfaces_(){return[]}}Ve.constructor_=function(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)};class ze{constructor(){ze.constructor_.apply(this,arguments)}buildTree(){Ee.sort(this._leaves,new Ge.NodeComparator);let t=this._leaves,e=null,n=new x;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new IllegalStateException("Index cannot be added to once it has been queried");this._leaves.add(new Be(t,e,n))}query(t,e,n){this.init(),this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){O.out.println(Jt.toLineString(new g(t._min,this._level),new g(t._max,this._level)))}init(){if(null!==this._root)return null;this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const s=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(s);else{const s=new Ve(t.get(n),t.get(n+1));e.add(s)}}}getClass(){return ze}get interfaces_(){return[]}}ze.constructor_=function(){this._leaves=new x,this._root=null,this._level=0};class Ye{constructor(){Ye.constructor_.apply(this,arguments)}visitItem(t){this._items.add(t)}getItems(){return this._items}getClass(){return Ye}get interfaces_(){return[Ae]}}Ye.constructor_=function(){this._items=new x};class Ue{constructor(){Ue.constructor_.apply(this,arguments)}static locatePointInRing(){if(arguments[0]instanceof g&&_(arguments[1],A)){const t=arguments[0],e=arguments[1],n=new Ue(t),s=new g,i=new g;for(let t=1;t<e.size();t++)if(e.getCoordinate(t,s),e.getCoordinate(t-1,i),n.countSegment(s,i),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new Ue(t);for(let t=1;t<e.length;t++){const s=e[t],i=e[t-1];if(n.countSegment(s,i),n.isOnSegment())return n.getLocation()}return n.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,s=e.x;return n>s&&(n=e.x,s=t.x),this._p.x>=n&&this._p.x<=s&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=v.index(t,e,this._p);if(n===v.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===v.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==ne.EXTERIOR}getLocation(){return this._isPointOnSegment?ne.BOUNDARY:this._crossingCount%2==1?ne.INTERIOR:ne.EXTERIOR}isOnSegment(){return this._isPointOnSegment}getClass(){return Ue}get interfaces_(){return[]}}Ue.constructor_=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t};class ke{constructor(){ke.constructor_.apply(this,arguments)}locate(t){const e=new Ue(t),n=new Xe(e);return this._index.query(t.y,t.y,n),e.getLocation()}getClass(){return ke}get interfaces_(){return[Fe]}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}getClass(){return Xe}get interfaces_(){return[Ae]}}Xe.constructor_=function(){this._counter=null;const t=arguments[0];this._counter=t};class He{constructor(){He.constructor_.apply(this,arguments)}init(t){for(let e=xe.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new ee(t[e-1],t[e]),s=Math.min(n.p0.y,n.p1.y),i=Math.max(n.p0.y,n.p1.y);this._index.insert(s,i,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new Ye;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._index.query(t,e,n)}}getClass(){return He}get interfaces_(){return[]}}He.constructor_=function(){this._index=new ze;const t=arguments[0];this.init(t)},ke.SegmentVisitor=Xe,ke.IntervalIndexedGeometry=He,ke.constructor_=function(){this._index=null;const t=arguments[0];if(!(_(t,Ot)||t instanceof Dt))throw new n("Argument must be Polygonal or LinearRing");this._index=new He(t)};class We{constructor(){We.constructor_.apply(this,arguments)}static isOnLine(){if(arguments[0]instanceof g&&_(arguments[1],A)){const t=arguments[0],e=arguments[1],n=new te,s=new g,i=new g,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,s),e.getCoordinate(o,i),n.computeIntersection(t,s,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof g&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new te;for(let s=1;s<e.length;s++){const i=e[s-1],r=e[s];if(n.computeIntersection(t,i,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Ue.locatePointInRing(t,e)}static isInRing(t,e){return We.locateInRing(t,e)!==ne.EXTERIOR}getClass(){return We}get interfaces_(){return[]}}function je(){}We.constructor_=function(){},je.prototype.hasNext=function(){},je.prototype.next=function(){},je.prototype.remove=function(){};class Ke{constructor(){Ke.constructor_.apply(this,arguments)}static isAtomic(t){return!(t instanceof _t)}next(){if(this._atStart)return this._atStart=!1,Ke.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new y;const t=this._parent.getGeometryN(this._index++);return t instanceof _t?(this._subcollectionIterator=new Ke(t),this._subcollectionIterator.next()):t}remove(){throw new Z(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}getClass(){return Ke}get interfaces_(){return[je]}}Ke.constructor_=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()};class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static locatePointInPolygon(t,e){if(e.isEmpty())return ne.EXTERIOR;const n=e.getExteriorRing(),s=Ze.locatePointInRing(t,n);if(s!==ne.INTERIOR)return s;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=Ze.locatePointInRing(t,s);if(i===ne.BOUNDARY)return ne.BOUNDARY;if(i===ne.INTERIOR)return ne.EXTERIOR}return ne.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?We.locateInRing(t,e.getCoordinates()):ne.EXTERIOR}static containsPointInPolygon(t,e){return ne.EXTERIOR!==Ze.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof bt)return Ze.locatePointInPolygon(t,e);if(e instanceof _t){const n=new Ke(e);for(;n.hasNext();){const s=n.next();if(s!==e){const e=Ze.locateInGeometry(t,s);if(e!==ne.EXTERIOR)return e}}}return ne.EXTERIOR}static locate(t,e){return e.isEmpty()?ne.EXTERIOR:Ze.locateInGeometry(t,e)}locate(t){return Ze.locate(t,this._geom)}getClass(){return Ze}get interfaces_(){return[Fe]}}Ze.constructor_=function(){this._geom=null;const t=arguments[0];this._geom=t};var Qe=Object.freeze({__proto__:null,IndexedPointInAreaLocator:ke,PointOnGeometryLocator:Fe,SimplePointInAreaLocator:Ze});class Je{constructor(){Je.constructor_.apply(this,arguments)}measure(t,e){}getClass(){return Je}get interfaces_(){return[]}}Je.constructor_=function(){};class $e{constructor(){$e.constructor_.apply(this,arguments)}measure(t,e){return t.intersection(e).getArea()/t.union(e).getArea()}getClass(){return $e}get interfaces_(){return[Je]}}$e.constructor_=function(){};class tn{constructor(){tn.constructor_.apply(this,arguments)}static diagonalSize(t){if(t.isNull())return 0;const e=t.getWidth(),n=t.getHeight();return Math.sqrt(e*e+n*n)}measure(t,e){const n=Oe.distance(t,e,tn.DENSIFY_FRACTION),s=new N(t.getEnvelopeInternal());return s.expandToInclude(e.getEnvelopeInternal()),1-n/tn.diagonalSize(s)}getClass(){return tn}get interfaces_(){return[Je]}}tn.constructor_=function(){},tn.DENSIFY_FRACTION=.25;class en{constructor(){en.constructor_.apply(this,arguments)}static combine(t,e){return Math.min(t,e)}getClass(){return en}get interfaces_(){return[]}}en.constructor_=function(){};var nn=Object.freeze({__proto__:null,AreaSimilarityMeasure:$e,HausdorffSimilarityMeasure:tn,SimilarityMeasure:Je,SimilarityMeasureCombiner:en});class sn{constructor(){sn.constructor_.apply(this,arguments)}static area2(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}static centroid3(t,e,n,s){return s.x=t.x+e.x+n.x,s.y=t.y+e.y+n.y,null}static getCentroid(t){return new sn(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let e=0;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);if(0===s)continue;e+=s;const i=(t[n].x+t[n+1].x)/2;this._lineCentSum.x+=s*i;const r=(t[n].y+t[n+1].y)/2;this._lineCentSum.y+=s*r}this._totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])}addHole(t){const e=v.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}getCentroid(){const t=new g;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);const e=!v.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}addTriangle(t,e,n,s){const i=s?1:-1;sn.centroid3(t,e,n,this._triangleCent3);const r=sn.area2(t,e,n);this._cg3.x+=i*r*this._triangleCent3.x,this._cg3.y+=i*r*this._triangleCent3.y,this._areasum2+=i*r}add(){if(arguments[0]instanceof bt){const t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof q){const t=arguments[0];if(t.isEmpty())return null;if(t instanceof Pt)this.addPoint(t.getCoordinate());else if(t instanceof Tt)this.addLineSegments(t.getCoordinates());else if(t instanceof bt){const e=t;this.add(e)}else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}}getClass(){return sn}get interfaces_(){return[]}}function rn(t){this.message=t||""}function on(){this.array_=[]}sn.constructor_=function(){this._areaBasePt=null,this._triangleCent3=new g,this._areasum2=0,this._cg3=new g,this._lineCentSum=new g,this._totalLength=0,this._ptCount=0,this._ptCentSum=new g;const t=arguments[0];this._areaBasePt=null,this.add(t)},rn.prototype=new Error,rn.prototype.name="EmptyStackException",on.prototype=new m,on.prototype.add=function(t){return this.array_.push(t),!0},on.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},on.prototype.push=function(t){return this.array_.push(t),t},on.prototype.pop=function(t){if(0===this.array_.length)throw new rn;return this.array_.pop()},on.prototype.peek=function(){if(0===this.array_.length)throw new rn;return this.array_[this.array_.length-1]},on.prototype.empty=function(){return 0===this.array_.length},on.prototype.isEmpty=function(){return this.empty()},on.prototype.search=function(t){return this.array_.indexOf(t)},on.prototype.size=function(){return this.array_.length},on.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t};class ln{constructor(){ln.constructor_.apply(this,arguments)}static filterCoordinates(t){const e=new ln;for(let n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()}filter(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))}getCoordinates(){const t=new Array(this.list.size()).fill(null);return this.list.toArray(t)}getClass(){return ln}get interfaces_(){return[B]}}ln.constructor_=function(){this.treeSet=new at,this.list=new x};class an{constructor(){an.constructor_.apply(this,arguments)}static extractCoordinates(t){const e=new ln;return t.apply(e),e.getCoordinates()}preSort(t){let e=null;for(let n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ht.sort(t,1,t.length,new cn(t[0])),t}computeOctRing(t){const e=this.computeOctPts(t),n=new I;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);const e=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(e)}cleanRing(t){u.equals(t[0],t[t.length-1]);const e=new x;let n=null;for(let s=0;s<=t.length-2;s++){const i=t[s],r=t[s+1];i.equals(r)||(null!==n&&this.isBetween(n,i,r)||(e.add(i),n=i))}e.add(t[t.length-1]);const s=new Array(e.size()).fill(null);return e.toArray(s)}isBetween(t,e,n){if(0!==v.index(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1}reduce(t){const e=this.computeOctRing(t);if(null===e)return t;const n=new at;for(let t=0;t<e.length;t++)n.add(e[t]);for(let s=0;s<t.length;s++)We.isInRing(t[s],e)||n.add(t[s]);const s=X.toCoordinateArray(n);return s.length<3?this.padArray3(s):s}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));const e=this.preSort(t),n=this.grahamScan(e),s=this.toCoordinateArray(n);return this.lineOrPolygon(s)}padArray3(t){const e=new Array(3).fill(null);for(let n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e}computeOctPts(t){const e=new Array(8).fill(null);for(let n=0;n<e.length;n++)e[n]=t[0];for(let n=1;n<t.length;n++)t[n].x<e[0].x&&(e[0]=t[n]),t[n].x-t[n].y<e[1].x-e[1].y&&(e[1]=t[n]),t[n].y>e[2].y&&(e[2]=t[n]),t[n].x+t[n].y>e[3].x+e[3].y&&(e[3]=t[n]),t[n].x>e[4].x&&(e[4]=t[n]),t[n].x-t[n].y>e[5].x-e[5].y&&(e[5]=t[n]),t[n].y<e[6].y&&(e[6]=t[n]),t[n].x+t[n].y<e[7].x+e[7].y&&(e[7]=t[n]);return e}toCoordinateArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=t.get(n);e[n]=s}return e}grahamScan(t){let e=null;const n=new on;n.push(t[0]),n.push(t[1]),n.push(t[2]);for(let s=3;s<t.length;s++){for(e=n.pop();!n.empty()&&v.index(n.peek(),e,t[s])>0;)e=n.pop();n.push(e),n.push(t[s])}return n.push(t[0]),n}getClass(){return an}get interfaces_(){return[]}}class cn{constructor(){cn.constructor_.apply(this,arguments)}static polarCompare(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=n.x-t.x,o=n.y-t.y,l=v.index(t,e,n);if(l===v.COUNTERCLOCKWISE)return 1;if(l===v.CLOCKWISE)return-1;const a=s*s+i*i,c=r*r+o*o;return a<c?-1:a>c?1:0}compare(t,e){const n=t,s=e;return cn.polarCompare(this._origin,n,s)}getClass(){return cn}get interfaces_(){return[l]}}cn.constructor_=function(){this._origin=null;const t=arguments[0];this._origin=t},an.RadialComparator=cn,an.constructor_=function(){if(this._geomFactory=null,this._inputPts=null,1===arguments.length){const t=arguments[0];an.constructor_.call(this,an.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputPts=ln.filterCoordinates(t),this._geomFactory=e}};class hn{constructor(){hn.constructor_.apply(this,arguments)}static centre(t){return new g(hn.avg(t.getMinX(),t.getMaxX()),hn.avg(t.getMinY(),t.getMaxY()))}static avg(t,e){return(t+e)/2}addPolygon(t){if(t.isEmpty())return null;let e=null,n=null;const s=this.horizontalBisector(t);if(0===s.getLength())n=0,e=s.getCoordinate();else{const i=s.intersection(t),r=this.widestGeometry(i);n=r.getEnvelopeInternal().getWidth(),e=hn.centre(r.getEnvelopeInternal())}(null===this._interiorPoint||n>this._maxWidth)&&(this._interiorPoint=e,this._maxWidth=n)}getInteriorPoint(){return this._interiorPoint}widestGeometry(){if(arguments[0]instanceof _t){const t=arguments[0];if(t.isEmpty())return t;let e=t.getGeometryN(0);for(let n=1;n<t.getNumGeometries();n++)t.getGeometryN(n).getEnvelopeInternal().getWidth()>e.getEnvelopeInternal().getWidth()&&(e=t.getGeometryN(n));return e}if(arguments[0]instanceof q){const t=arguments[0];return t instanceof _t?this.widestGeometry(t):t}}horizontalBisector(t){const e=t.getEnvelopeInternal(),n=un.getBisectorY(t);return this._factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])}add(t){if(t instanceof bt)this.addPolygon(t);else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}getClass(){return hn}get interfaces_(){return[]}}class un{constructor(){un.constructor_.apply(this,arguments)}static getBisectorY(t){return new un(t).getBisectorY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getBisectorY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return hn.avg(this._hiY,this._loY)}process(t){const e=t.getCoordinateSequence();for(let t=0;t<e.size();t++){const n=e.getY(t);this.updateInterval(n)}}getClass(){return un}get interfaces_(){return[]}}un.constructor_=function(){this._poly=null,this._centreY=null,this._hiY=i.MAX_VALUE,this._loY=-i.MAX_VALUE;const t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=hn.avg(this._loY,this._hiY)},hn.SafeBisectorFinder=un,hn.constructor_=function(){this._factory=null,this._interiorPoint=null,this._maxWidth=0;const t=arguments[0];this._factory=t.getFactory(),this.add(t)};class gn{constructor(){gn.constructor_.apply(this,arguments)}addEndpoints(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Tt)this.addEndpoints(t.getCoordinates());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addEndpoints(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Tt)this.addInterior(t.getCoordinates());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addInterior(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=1;e<t.length-1;e++)this.add(t[e])}}add(t){const e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=e)}getClass(){return gn}get interfaces_(){return[]}}gn.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];t.isEmpty()?this._centroid=new g:this._centroid=sn.getCentroid(t),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)};class dn{constructor(){dn.constructor_.apply(this,arguments)}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Pt)this.add(t.getCoordinate());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}else if(arguments[0]instanceof g){const t=arguments[0],e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=e)}}getClass(){return dn}get interfaces_(){return[]}}dn.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];this._centroid=t.getCentroid().getCoordinate(),this.add(t)};class _n{constructor(){_n.constructor_.apply(this,arguments)}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?We.locateInRing(t,e.getCoordinates()):ne.EXTERIOR}intersects(t,e){return this.locate(t,e)!==ne.EXTERIOR}updateLocationInfo(t){t===ne.INTERIOR&&(this._isIn=!0),t===ne.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof Pt&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof Tt)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof bt)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof ft){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,s))}}else if(e instanceof At){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,s))}}else if(e instanceof _t){const n=new Ke(e);for(;n.hasNext();){const s=n.next();s!==e&&this.computeLocation(t,s)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?ne.INTERIOR:ne.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return ne.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?We.isOnLine(t,n)?ne.INTERIOR:ne.EXTERIOR:ne.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return ne.EXTERIOR;const n=e.getExteriorRing(),s=this.locateInPolygonRing(t,n);if(s===ne.EXTERIOR)return ne.EXTERIOR;if(s===ne.BOUNDARY)return ne.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=this.locateInPolygonRing(t,s);if(i===ne.INTERIOR)return ne.EXTERIOR;if(i===ne.BOUNDARY)return ne.BOUNDARY}return ne.INTERIOR}locate(t,e){return e.isEmpty()?ne.EXTERIOR:e instanceof Tt?this.locateOnLineString(t,e):e instanceof bt?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?ne.BOUNDARY:this._numBoundaries>0||this._isIn?ne.INTERIOR:ne.EXTERIOR)}getClass(){return _n}get interfaces_(){return[]}}_n.constructor_=function(){if(this._boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new n("Rule must be non-null");this._boundaryRule=t}};class fn{constructor(){fn.constructor_.apply(this,arguments)}static pointWitMinAngleWithX(t,e){let n=i.MAX_VALUE,s=null;for(let i=0;i<t.length;i++){const r=t[i];if(r===e)continue;const o=r.x-e.x;let l=r.y-e.y;l<0&&(l=-l);const a=l/Math.sqrt(o*o+l*l);a<n&&(n=a,s=r)}return s}static lowestPoint(t){let e=t[0];for(let n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e}static pointWithMinAngleWithSegment(t,e,n){let s=i.MAX_VALUE,r=null;for(let i=0;i<t.length;i++){const o=t[i];if(o===e)continue;if(o===n)continue;const l=ie.angleBetween(e,o,n);l<s&&(s=l,r=o)}return r}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[1];return this._input.getFactory().createLineString([t,e])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=new Array(0).fill(null),null;if(1===this._input.getNumPoints()){const t=this._input.getCoordinates();return this._extremalPts=[new g(t[0])],null}const t=this._input.convexHull().getCoordinates();let e=t;if(t[0].equals2D(t[t.length-1])&&(e=new Array(t.length-1).fill(null),X.copyDeep(t,0,e,0,t.length-1)),e.length<=2)return this._extremalPts=X.copyDeep(e),null;let n=fn.lowestPoint(e),s=fn.pointWitMinAngleWithX(e,n);for(let t=0;t<e.length;t++){const t=fn.pointWithMinAngleWithSegment(e,n,s);if(ie.isObtuse(n,t,s))return this._extremalPts=[new g(n),new g(s)],null;if(ie.isObtuse(t,n,s))n=t;else{if(!ie.isObtuse(t,s,n))return this._extremalPts=[new g(n),new g(s),new g(t)],null;s=t}}u.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getFarthestPoints(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[this._extremalPts.length-1];return this._input.getFactory().createLineString([t,e])}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();const t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new g((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=re.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}getClass(){return fn}get interfaces_(){return[]}}fn.constructor_=function(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;const t=arguments[0];this._input=t};class pn{constructor(){pn.constructor_.apply(this,arguments)}static nextIndex(t,e){return++e>=t.length&&(e=0),e}static computeC(t,e,n){return t*n.y-e*n.x}static getMinimumDiameter(t){return new pn(t).getDiameter()}static getMinimumRectangle(t){return new pn(t).getMinimumRectangle()}static computeSegmentForLine(t,e,n){let s=null,i=null;return Math.abs(e)>Math.abs(t)?(s=new g(0,n/e),i=new g(1,n/e-t/e)):(s=new g(n/t,0),i=new g(n/t-e/t,1)),new ee(s,i)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();const t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof bt?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=i.MAX_VALUE;let e=1;const n=new ee;for(let s=0;s<t.length-1;s++)n.p0=t[s],n.p1=t[s+1],e=this.findMaxPerpDistance(t,n,e)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{const t=new an(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,e,n){let s=e.distancePerpendicular(t[n]),i=s,r=n,o=r;for(;i>=s;)s=i,r=o,o=pn.nextIndex(t,r),i=e.distancePerpendicular(t[o]);return s<this._minWidth&&(this._minPtIndex=r,this._minWidth=s,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new ee(e)),r}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());const t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,e=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y;let n=i.MAX_VALUE,s=-i.MAX_VALUE,r=i.MAX_VALUE,o=-i.MAX_VALUE;for(let i=0;i<this._convexHullPts.length;i++){const l=pn.computeC(t,e,this._convexHullPts[i]);l>s&&(s=l),l<n&&(n=l);const a=pn.computeC(-e,t,this._convexHullPts[i]);a>o&&(o=a),a<r&&(r=a)}const l=pn.computeSegmentForLine(-t,-e,o),a=pn.computeSegmentForLine(-t,-e,r),c=pn.computeSegmentForLine(-e,t,s),h=pn.computeSegmentForLine(-e,t,n),u=c.lineIntersection(l),g=h.lineIntersection(l),d=h.lineIntersection(a),_=c.lineIntersection(a),f=this._inputGeom.getFactory().createLinearRing([u,g,d,_,u]);return this._inputGeom.getFactory().createPolygon(f)}getClass(){return pn}get interfaces_(){return[]}}pn.constructor_=function(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new ee,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1===arguments.length){const t=arguments[0];pn.constructor_.call(this,t,!1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isConvex=e}};var mn=Object.freeze({__proto__:null,distance:De,locate:Qe,match:nn,Angle:ie,Area:vt,Centroid:sn,ConvexHull:an,Distance:D,InteriorPointArea:hn,InteriorPointLine:gn,InteriorPointPoint:dn,Length:yt,Orientation:v,PointLocation:We,PointLocator:_n,RobustLineIntersector:te,MinimumBoundingCircle:fn,MinimumDiameter:pn});class yn{constructor(){yn.constructor_.apply(this,arguments)}static densifyPoints(t,e,n){const s=new ee,i=new I;for(let r=0;r<t.length-1;r++){s.p0=t[r],s.p1=t[r+1],i.add(s.p0,!1);const o=s.getLength(),l=Math.trunc(o/e)+1;if(l>1){const t=o/l;for(let e=1;e<l;e++){const r=e*t/o,l=s.pointAlong(r);n.makePrecise(l),i.add(l,!1)}}}return i.add(t[t.length-1],!1),i.toCoordinateArray()}static densify(t,e){const n=new yn(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){return new xn(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new n("Tolerance must be positive");this._distanceTolerance=t}getClass(){return yn}get interfaces_(){return[]}}class xn extends me{constructor(){super(),xn.constructor_.apply(this,arguments)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformPolygon(t,e){const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=yn.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof Tt&&1===s.length&&(s=new Array(0).fill(null)),this._factory.getCoordinateSequenceFactory().create(s)}createValidArea(t){return t.buffer(0)}getClass(){return xn}get interfaces_(){return[]}}xn.constructor_=function(){this.distanceTolerance=null;const t=arguments[0];this.distanceTolerance=t},yn.DensifyTransformer=xn,yn.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null;const t=arguments[0];this._inputGeom=t};var En=Object.freeze({__proto__:null,Densifier:yn});class In{constructor(){In.constructor_.apply(this,arguments)}static isNorthern(t){return t===In.NE||t===In.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===In.SE?t===In.SE||t===In.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?In.NE:In.SE:e>=0?In.NW:In.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new n("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?In.NE:In.SE:e.y>=t.y?In.NW:In.SW}}getClass(){return In}get interfaces_(){return[]}}In.constructor_=function(){},In.NE=0,In.NW=1,In.SW=2,In.SE=3;class Nn{constructor(){Nn.constructor_.apply(this,arguments)}static init(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t}static create(t,e){const n=new Nn(t),s=new Nn(e);return n.init(s),n}find(t){let e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null}dest(){return this._sym._orig}oNext(){return this._sym._next}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;const e=this.compareTo(t);let n=this;do{const s=n.oNext();if(s.compareTo(t)!==e||s===this)return n.insertAfter(t),null;n=s}while(n!==this);u.shouldNeverReachHere()}insertAfter(t){u.equals(this._orig,t.orig());const e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)}degree(){let t=0,e=this;do{t++,e=e.oNext()}while(e!==this);return t}equals(){if(2===arguments.length&&arguments[1]instanceof g&&arguments[0]instanceof g){const t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}}deltaY(){return this._sym._orig.y-this._orig.y}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){const e=this.deltaX(),n=this.deltaY(),s=t.deltaX(),i=t.deltaY();if(e===s&&n===i)return 0;const r=In.quadrant(e,n),o=In.quadrant(s,i);return r>o?1:r<o?-1:v.index(t._orig,t.dest(),this.dest())}prevNode(){let t=this;for(;2===t.degree();)if(t=t.prev(),t===this)return null;return t}compareTo(t){const e=t;return this.compareAngularDirection(e)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}setNext(t){this._next=t}init(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}deltaX(){return this._sym._orig.x-this._orig.x}getClass(){return Nn}get interfaces_(){return[]}}Nn.constructor_=function(){this._orig=null,this._sym=null,this._next=null;const t=arguments[0];this._orig=t};class Cn extends Nn{constructor(){super(),Cn.constructor_.apply(this,arguments)}static setMarkBoth(t,e){t.setMark(e),t.sym().setMark(e)}static isMarked(t){return t.isMarked()}static setMark(t,e){t.setMark(e)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}getClass(){return Cn}get interfaces_(){return[]}}Cn.constructor_=function(){this._isMarked=!1;const t=arguments[0];Nn.constructor_.call(this,t)};class Sn{constructor(){Sn.constructor_.apply(this,arguments)}static isValidEdge(t,e){return 0!==e.compareTo(t)}insert(t,e,n){const s=this.create(t,e);null!==n?n.insert(s):this._vertexMap.put(t,s);const i=this._vertexMap.get(e);return null!==i?i.insert(s.sym()):this._vertexMap.put(e,s.sym()),s}create(t,e){const n=this.createEdge(t),s=this.createEdge(e);return Nn.init(n,s),n}createEdge(t){return new Nn(t)}addEdge(t,e){if(!Sn.isValidEdge(t,e))return null;const n=this._vertexMap.get(t);let s=null;if(null!==n&&(s=n.find(e)),null!==s)return s;return this.insert(t,e,n)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,e){const n=this._vertexMap.get(t);return null===n?null:n.find(e)}getClass(){return Sn}get interfaces_(){return[]}}Sn.constructor_=function(){this._vertexMap=new Ut};class wn extends Cn{constructor(){super(),wn.constructor_.apply(this,arguments)}setStart(){this._isStart=!0}isStart(){return this._isStart}getClass(){return wn}get interfaces_(){return[]}}wn.constructor_=function(){this._isStart=!1;const t=arguments[0];Cn.constructor_.call(this,t)};class Ln extends Sn{constructor(){super(),Ln.constructor_.apply(this,arguments)}createEdge(t){return new wn(t)}getClass(){return Ln}get interfaces_(){return[]}}Ln.constructor_=function(){};class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static dissolve(t){const e=new Tn;return e.add(t),e.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(t.orig().compareTo(this._ringStartEdge.orig())<0&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()}buildRing(t){const e=new I;let n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){const s=n.next();if(s===t)break;e.add(s.orig().copy(),!1),n=s}e.add(n.dest().copy(),!1),this.addLine(e)}buildLine(t){const e=new I;let n=t;for(this._ringStartEdge=null,Cn.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);const s=n.next();if(s===t)return this.buildRing(this._ringStartEdge),null;e.add(s.orig().copy(),!1),n=s,Cn.markBoth(n)}e.add(n.dest().clone(),!1),this.stackEdges(n.sym()),this.addLine(e)}stackEdges(t){let e=t;do{Cn.isMarked(e)||this._nodeEdgeStack.add(e),e=e.oNext()}while(e!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){const e=t.next();Cn.isMarked(e)||this.process(e)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){const t=this._nodeEdgeStack.pop();Cn.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof q){arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Tt&&this.add(t)}})}else if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof Tt){const t=arguments[0];null===this._factory&&(this._factory=t.getFactory());const e=t.getCoordinateSequence();let n=!1;for(let t=1;t<e.size();t++){const s=this._graph.addEdge(e.getCoordinate(t-1),e.getCoordinate(t));null!==s&&(n||(s.setStart(),n=!0))}}}getClass(){return Tn}get interfaces_(){return[]}}Tn.constructor_=function(){this._result=null,this._factory=null,this._graph=null,this._lines=new x,this._nodeEdgeStack=new on,this._ringStartEdge=null,this._graph=new Ln};var Rn=Object.freeze({__proto__:null,LineDissolver:Tn});class Pn{constructor(){Pn.constructor_.apply(this,arguments)}static opposite(t){return t===Pn.LEFT?Pn.RIGHT:t===Pn.RIGHT?Pn.LEFT:t}getClass(){return Pn}get interfaces_(){return[]}}Pn.constructor_=function(){},Pn.ON=0,Pn.LEFT=1,Pn.RIGHT=2;class vn{constructor(){vn.constructor_.apply(this,arguments)}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}getClass(){return vn}get interfaces_(){return[]}}vn.constructor_=function(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e};class On{constructor(){On.constructor_.apply(this,arguments)}isDelete(){return this._eventType===On.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===On.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}getClass(){return On}get interfaces_(){return[r]}}On.constructor_=function(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=On.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=On.INSERT,this._label=t,this._xValue=e,this._obj=n}},On.INSERT=1,On.DELETE=2;class bn{constructor(){bn.constructor_.apply(this,arguments)}getClass(){return bn}get interfaces_(){return[]}}bn.constructor_=function(){};class Mn{constructor(){Mn.constructor_.apply(this,arguments)}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Mn.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}getClass(){return Mn}get interfaces_(){return[]}}Mn.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n};class Dn extends bn{constructor(){super(),Dn.constructor_.apply(this,arguments)}prepareEvents(){Ee.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof Mn&&_(arguments[0],m)&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&_(arguments[0],m)&&arguments[1]instanceof Mn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),s=n.getStartIndexes();for(let t=0;t<s.length-1;t++){const s=new vn(n,t),i=new On(e,n.getMinX(t),s);this.events.add(i),this.events.add(new On(n.getMaxX(t),i))}}processOverlaps(t,e,n,s){const i=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(i.computeIntersections(e,s),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){const t=n.next();this.addEdge(t,e)}}}getClass(){return Dn}get interfaces_(){return[]}}Dn.constructor_=function(){this.events=new x,this.nOverlaps=null};class An{constructor(){An.constructor_.apply(this,arguments)}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==ne.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===ne.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[Pn.ON]=this.location[Pn.ON],t[Pn.LEFT]=ne.NONE,t[Pn.RIGHT]=ne.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===ne.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[Pn.LEFT];this.location[Pn.LEFT]=this.location[Pn.RIGHT],this.location[Pn.RIGHT]=t}toString(){const t=new w;return this.location.length>1&&t.append(ne.toLocationSymbol(this.location[Pn.LEFT])),t.append(ne.toLocationSymbol(this.location[Pn.ON])),this.location.length>1&&t.append(ne.toLocationSymbol(this.location[Pn.RIGHT])),t.toString()}setLocations(t,e,n){this.location[Pn.ON]=t,this.location[Pn.LEFT]=e,this.location[Pn.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:ne.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===ne.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(Pn.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(ne.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}getClass(){return An}get interfaces_(){return[]}}An.constructor_=function(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[Pn.ON]=t}else if(arguments[0]instanceof An){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[Pn.ON]=t,this.location[Pn.LEFT]=e,this.location[Pn.RIGHT]=n}};class Fn{constructor(){Fn.constructor_.apply(this,arguments)}static toLineLabel(t){const e=new Fn(ne.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new An(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(Pn.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new w;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(Pn.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new An(this.elt[t].location[0]))}getClass(){return Fn}get interfaces_(){return[]}}Fn.constructor_=function(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new An(t),this.elt[1]=new An(t)}else if(arguments[0]instanceof Fn){const t=arguments[0];this.elt[0]=new An(t.elt[0]),this.elt[1]=new An(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new An(ne.NONE),this.elt[1]=new An(ne.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new An(t,e,n),this.elt[1]=new An(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.elt[0]=new An(ne.NONE,ne.NONE,ne.NONE),this.elt[1]=new An(ne.NONE,ne.NONE,ne.NONE),this.elt[t].setLocations(e,n,s)}};class Gn{constructor(){Gn.constructor_.apply(this,arguments)}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}getClass(){return Gn}get interfaces_(){return[r]}}Gn.constructor_=function(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n};class qn{constructor(){qn.constructor_.apply(this,arguments)}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new g(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return i&&(r[o]=e.coord),new Un(r,new Fn(this.edge._label))}add(t,e,n){const s=new Gn(t,e,n),i=this._nodeMap.get(s);return null!==i?i:(this._nodeMap.put(s,s),s)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}getClass(){return qn}get interfaces_(){return[]}}qn.constructor_=function(){this._nodeMap=new rt,this.edge=null;const t=arguments[0];this.edge=t};class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new x;n.add(new L(e));do{const s=this.findChainEnd(t,e);n.add(new L(s)),e=s}while(e<t.length-1);return Bn.toIntArray(n)}findChainEnd(t,e){const n=In.quadrant(t[e],t[e+1]);let s=e+1;for(;s<t.length;){if(In.quadrant(t[s-1],t[s])!==n)break;s++}return s-1}getClass(){return Bn}get interfaces_(){return[]}}Bn.constructor_=function(){};class Vn{constructor(){Vn.constructor_.apply(this,arguments)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],s)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.addIntersections(this.e,t,n.e,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeIntersectsForChain(t,o,n,s,l,r),l<i&&this.computeIntersectsForChain(t,o,n,l,i,r)),o<e&&(s<l&&this.computeIntersectsForChain(o,e,n,s,l,r),l<i&&this.computeIntersectsForChain(o,e,n,l,i,r))}}overlaps(t,e,n,s,i){return N.intersects(this.pts[t],this.pts[e],n.pts[s],n.pts[i])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let s=0;s<t.startIndex.length-1;s++)this.computeIntersectsForChain(n,t,s,e)}getClass(){return Vn}get interfaces_(){return[]}}Vn.constructor_=function(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new Bn;this.startIndex=e.getChainStartIndices(this.pts)};class zn{constructor(){zn.constructor_.apply(this,arguments)}static depthAtLocation(t){return t===ne.EXTERIOR?0:t===ne.INTERIOR?1:zn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==zn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===zn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===zn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let s=0;this._depth[t][n]>e&&(s=1),this._depth[t][n]=s}}}getDelta(t){return this._depth[t][Pn.RIGHT]-this._depth[t][Pn.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?ne.EXTERIOR:ne.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const s=t.getLocation(e,n);s!==ne.EXTERIOR&&s!==ne.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=zn.depthAtLocation(s):this._depth[e][n]+=zn.depthAtLocation(s))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===ne.INTERIOR&&this._depth[t][e]++}}getClass(){return zn}get interfaces_(){return[]}}zn.constructor_=function(){this._depth=Array(2).fill().map(()=>Array(3));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=zn.NULL_VALUE},zn.NULL_VALUE=-1;class Yn{constructor(){Yn.constructor_.apply(this,arguments)}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){u.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}getClass(){return Yn}get interfaces_(){return[]}}Yn.constructor_=function(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}};class Un extends Yn{constructor(){super(),Un.constructor_.apply(this,arguments)}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof se&&arguments[0]instanceof Fn))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,Pn.ON),t.getLocation(1,Pn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,Pn.LEFT),t.getLocation(1,Pn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,Pn.RIGHT),t.getLocation(1,Pn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);return t[0]=this.pts[0],t[1]=this.pts[1],new Un(t,Fn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof Un))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,s=!0,i=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--i])||(s=!1),!n&&!s)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){Un.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Vn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new N;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,s){const i=new g(t.getIntersection(s));let r=e,o=t.getEdgeDistance(n,s);const l=r+1;if(l<this.pts.length){const t=this.pts[l];i.equals2D(t)&&(r=l,o=0)}this.eiList.add(i,r,o)}toString(){const t=new wt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}getClass(){return Un}get interfaces_(){return[]}}Un.constructor_=function(){if(this.pts=null,this._env=null,this.eiList=new qn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new zn,this._depthDelta=0,1===arguments.length){const t=arguments[0];Un.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}};class kn extends Yn{constructor(){super(),kn.constructor_.apply(this,arguments)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=ne.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const s=t.getLocation(e);n!==ne.BOUNDARY&&(n=s)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Fn(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof kn){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Fn){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===ne.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=ne.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case ne.BOUNDARY:n=ne.INTERIOR;break;case ne.INTERIOR:default:n=ne.BOUNDARY}this._label.setLocation(t,n)}getClass(){return kn}get interfaces_(){return[]}}kn.constructor_=function(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Fn(0,ne.NONE)};class Xn{constructor(){Xn.constructor_.apply(this,arguments)}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof g){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof kn){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new x;for(let n=this.iterator();n.hasNext();){const s=n.next();s.getLabel().getLocation(t)===ne.BOUNDARY&&e.add(s)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}getClass(){return Xn}get interfaces_(){return[]}}Xn.constructor_=function(){this.nodeMap=new rt,this.nodeFact=null;const t=arguments[0];this.nodeFact=t};class Hn{constructor(){Hn.constructor_.apply(this,arguments)}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),s=n.lastIndexOf("."),i=n.substring(s+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=In.quadrant(this._dx,this._dy),u.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}getClass(){return Hn}get interfaces_(){return[r]}}Hn.constructor_=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Hn.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hn.constructor_.call(this,t),this.init(e,n),this._label=s}};class Wn extends c{constructor(){if(1===arguments.length){const t=arguments[0];super(t),c.call(this,t)}else{if(2!==arguments.length)throw Error();{const t=arguments[0],e=arguments[1];super(Wn.msgWithCoord(t,e)),this.name="TopologyException",this.pt=new g(e)}}}getCoordinate(){return this.pt}get interfaces_(){return[]}getClass(){return Wn}static msgWithCoord(t,e){return null!==e?t+" [ "+e+" ]":t}}class jn extends Hn{constructor(){super(),jn.constructor_.apply(this,arguments)}static depthFactor(t,e){return t===ne.EXTERIOR&&e===ne.INTERIOR?1:t===ne.INTERIOR&&e===ne.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new Fn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new Wn("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,Pn.LEFT)===ne.INTERIOR&&this._label.getLocation(e,Pn.RIGHT)===ne.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[Pn.LEFT]+"/"+this._depth[Pn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,ne.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,ne.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let s=1;t===Pn.LEFT&&(s=-1);const i=Pn.opposite(t),r=e+n*s;this.setDepth(t,e),this.setDepth(i,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}getClass(){return jn}get interfaces_(){return[]}}jn.constructor_=function(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(Hn.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()};class Kn{constructor(){Kn.constructor_.apply(this,arguments)}createNode(t){return new kn(t,null)}getClass(){return Kn}get interfaces_(){return[]}}Kn.constructor_=function(){};class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof kn){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof g){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){O.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const s=n.getLabel();return null!==s&&s.getLocation(t)===ne.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,s){return!!t.equals(n)&&(v.index(t,e,s)===v.COLLINEAR&&In.quadrant(t,e)===In.quadrant(n,s))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){O.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return s;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return s}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new jn(t,!0),s=new jn(t,!1);n.setSym(s),s.setSym(n),this.add(n),this.add(s)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return s}return null}getClass(){return Zn}get interfaces_(){return[]}}Zn.constructor_=function(){if(this._edges=new x,this._nodes=null,this._edgeEndList=new x,0===arguments.length)this._nodes=new Xn(new Kn);else if(1===arguments.length){const t=arguments[0];this._nodes=new Xn(t)}};class Qn extends Zn{constructor(){super(),Qn.constructor_.apply(this,arguments)}static determineBoundary(t,e){return t.isInBoundary(e)?ne.BOUNDARY:ne.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let s=1,i=ne.NONE;i=n.getLocation(t,Pn.ON),i===ne.BOUNDARY&&s++;const r=Qn.determineBoundary(this._boundaryNodeRule,s);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Mn(t,!0,!1);s.setIsDoneIfProperInt(n);const i=this.createEdgeSetIntersector(),r=this._parentGeom instanceof Dt||this._parentGeom instanceof bt||this._parentGeom instanceof At,o=e||!r;return i.computeIntersections(this._edges,s,o),this.addSelfIntersectionNodes(this._argIndex),s}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const s=new Mn(e,n,!0);return s.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,s),s}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof Pt){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,ne.INTERIOR)}else if(arguments[0]instanceof g){const t=arguments[0];this.insertPoint(this._argIndex,t,ne.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),ne.EXTERIOR,ne.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,ne.INTERIOR,ne.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],ne.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],ne.BOUNDARY)}addLineString(t){const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new Un(e,new Fn(this._argIndex,ne.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),u.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let s=t.iterator();s.hasNext();){const t=s.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===ne.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const s=X.removeRepeatedPoints(t.getCoordinates());if(s.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=s[0],null;let i=e,r=n;v.isCCW(s)&&(i=n,r=e);const o=new Un(s,new Fn(this._argIndex,ne.BOUNDARY,i,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,s[0],ne.BOUNDARY)}insertPoint(t,e,n){const s=this._nodes.addNode(e),i=s.getLabel();null===i?s._label=new Fn(t,n):i.setLocation(t,n)}createEdgeSetIntersector(){return new Dn}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,s)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof q))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof At&&(this._useBoundaryDeterminationRule=!1),t instanceof bt)this.addPolygon(t);else if(t instanceof Tt)this.addLineString(t);else if(t instanceof Pt)this.addPoint(t);else if(t instanceof Mt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else if(t instanceof At)this.addCollection(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return _(this._parentGeom,Ot)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new ke(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof Tt){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}getClass(){return Qn}get interfaces_(){return[]}}Qn.constructor_=function(){if(this._parentGeom=null,this._lineEdgeMap=new Ut,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new _n,2===arguments.length){const t=arguments[0],e=arguments[1];Qn.constructor_.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}};var Jn=Object.freeze({__proto__:null,GeometryGraph:Qn});class $n{constructor(){$n.constructor_.apply(this,arguments)}visit(t){}getClass(){return $n}get interfaces_(){return[]}}$n.constructor_=function(){};class ts{constructor(){ts.constructor_.apply(this,arguments)}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}getClass(){return ts}get interfaces_(){return[]}}ts.constructor_=function(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new g(t),this._left=null,this._right=null,this._count=1,this._data=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new g(t,e),this._left=null,this._right=null,this._count=1,this._data=n}};class es{constructor(){es.constructor_.apply(this,arguments)}static toCoordinates(){if(1===arguments.length){const t=arguments[0];return es.toCoordinates(t,!1)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new I;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e?t.getCount():1;for(let e=0;e<i;e++)n.add(t.getCoordinate(),!0)}return n.toCoordinateArray()}}insert(){if(1===arguments.length){const t=arguments[0];return this.insert(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(null===this._root)return this._root=new ts(t,e),this._root;if(this._tolerance>0){const e=this.findBestMatchNode(t);if(null!==e)return e.increment(),e}return this.insertExact(t,e)}}query(){if(1===arguments.length){const t=arguments[0],e=new x;return this.query(t,e),e}if(2===arguments.length)if(arguments[0]instanceof N&&_(arguments[1],m)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[$n]}visit(t){e.add(t)}})}else if(arguments[0]instanceof N&&_(arguments[1],$n)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,e)}}queryNode(t,e,n,s){if(null===t)return null;let i=null,r=null,o=null;n?(i=e.getMinX(),r=e.getMaxX(),o=t.getX()):(i=e.getMinY(),r=e.getMaxY(),o=t.getY());const l=o<=r;i<o&&this.queryNode(t.getLeft(),e,!n,s),e.contains(t.getCoordinate())&&s.visit(t),l&&this.queryNode(t.getRight(),e,!n,s)}findBestMatchNode(t){const e=new ns(t,this._tolerance);return this.query(e.queryEnvelope(),e),e.getNode()}isEmpty(){return null===this._root}insertExact(t,e){let n=this._root,s=this._root,i=!0,r=!0;for(;null!==n;){if(null!==n){if(t.distance(n.getCoordinate())<=this._tolerance)return n.increment(),n}r=i?t.x<n.getX():t.y<n.getY(),s=n,n=r?n.getLeft():n.getRight(),i=!i}this._numberOfNodes=this._numberOfNodes+1;const o=new ts(t,e);return r?s.setLeft(o):s.setRight(o),o}getClass(){return es}get interfaces_(){return[]}}class ns{constructor(){ns.constructor_.apply(this,arguments)}visit(t){const e=this._p.distance(t.getCoordinate());if(!(e<=this._tolerance))return null;let n=!1;(null===this._matchNode||e<this._matchDist||null!==this._matchNode&&e===this._matchDist&&t.getCoordinate().compareTo(this._matchNode.getCoordinate())<1)&&(n=!0),n&&(this._matchNode=t,this._matchDist=e)}queryEnvelope(){const t=new N(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}getClass(){return ns}get interfaces_(){return[$n]}}ns.constructor_=function(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;const t=arguments[0],e=arguments[1];this._p=t,this._tolerance=e},es.BestMatchVisitor=ns,es.constructor_=function(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0===arguments.length)es.constructor_.call(this,0);else if(1===arguments.length){const t=arguments[0];this._tolerance=t}};var ss=Object.freeze({__proto__:null,KdTree:es});class is{constructor(){is.constructor_.apply(this,arguments)}static getSubnodeIndex(t,e,n){let s=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(s=3),t.getMaxY()<=n&&(s=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(s=2),t.getMaxY()<=n&&(s=0)),s}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let e=0;e<4;e++)null!==this._subnode[e]&&this._subnode[e].addAllItems(t);return t}getNodeCount(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+1}size(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+this._items.size()}addAllItemsFromOverlapping(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this._items);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].addAllItemsFromOverlapping(t,e)}visitItems(t,e){for(let t=this._items.iterator();t.hasNext();)e.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,e){if(!this.isSearchMatch(t))return!1;let n=!1;for(let s=0;s<4;s++)if(null!==this._subnode[s]&&(n=this._subnode[s].remove(t,e),n)){this._subnode[s].isPrunable()&&(this._subnode[s]=null);break}return n||(n=this._items.remove(e),n)}visit(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].visit(t,e)}getItems(){return this._items}depth(){let t=0;for(let e=0;e<4;e++)if(null!==this._subnode[e]){const n=this._subnode[e].depth();n>t&&(t=n)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let e=0;e<4;e++)if(null!==this._subnode[e]&&!this._subnode[e].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}getClass(){return is}get interfaces_(){return[a]}}function rs(){}is.constructor_=function(){this._items=new x,this._subnode=new Array(4).fill(null)},rs.exponent=function(t){return function(t,e){let n,s,i,r;const o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},l={32:8,64:11}[t];r||(n=e<0||1/e<0,isFinite(e)||(r=o[t],n&&(r.d+=1<<t/4-1),s=Math.pow(2,l)-1,i=0));if(!r){for(s={32:127,64:1023}[t],i=Math.abs(e);i>=2;)s++,i/=2;for(;i<1&&s>0;)s--,i*=2;s<=0&&(i/=2),32===t&&s>254&&(r={d:n?255:127,c:128,b:0,a:0},s=Math.pow(2,l)-1,i=0)}return s}(64,t)-1023},rs.powerOf2=function(t){return Math.pow(2,t)};class os{constructor(){os.constructor_.apply(this,arguments)}static computeQuadLevel(t){const e=t.getWidth(),n=t.getHeight(),s=e>n?e:n;return rs.exponent(s)+1}getLevel(){return this._level}computeKey(){if(1===arguments.length){const t=arguments[0];for(this._level=os.computeQuadLevel(t),this._env=new N,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=rs.powerOf2(t);this._pt.x=Math.floor(e.getMinX()/n)*n,this._pt.y=Math.floor(e.getMinY()/n)*n,this._env.init(this._pt.x,this._pt.x+n,this._pt.y,this._pt.y+n)}}getEnvelope(){return this._env}getCentre(){return new g((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}getClass(){return os}get interfaces_(){return[]}}os.constructor_=function(){this._pt=new g,this._level=0,this._env=null;const t=arguments[0];this.computeKey(t)};class ls extends is{constructor(){super(),ls.constructor_.apply(this,arguments)}static createNode(t){const e=new os(t);return new ls(e.getEnvelope(),e.getLevel())}static createExpanded(t,e){const n=new N(e);null!==t&&n.expandToInclude(t._env);const s=ls.createNode(n);return null!==t&&s.insertNode(t),s}find(t){const e=is.getSubnodeIndex(t,this._centrex,this._centrey);if(-1===e)return this;if(null!==this._subnode[e]){return this._subnode[e].find(t)}return this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){const e=is.getSubnodeIndex(t,this._centrex,this._centrey);if(-1!==e){return this.getSubnode(e).getNode(t)}return this}createSubnode(t){let e=0,n=0,s=0,i=0;switch(t){case 0:e=this._env.getMinX(),n=this._centrex,s=this._env.getMinY(),i=this._centrey;break;case 1:e=this._centrex,n=this._env.getMaxX(),s=this._env.getMinY(),i=this._centrey;break;case 2:e=this._env.getMinX(),n=this._centrex,s=this._centrey,i=this._env.getMaxY();break;case 3:e=this._centrex,n=this._env.getMaxX(),s=this._centrey,i=this._env.getMaxY()}const r=new N(e,n,s,i);return new ls(r,this._level-1)}insertNode(t){u.isTrue(null===this._env||this._env.contains(t._env));const e=is.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[e]=t;else{const n=this.createSubnode(e);n.insertNode(t),this._subnode[e]=n}}getClass(){return ls}get interfaces_(){return[]}}ls.constructor_=function(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;const t=arguments[0],e=arguments[1];this._env=t,this._level=e,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2};class as{constructor(){as.constructor_.apply(this,arguments)}static isZeroWidth(t,e){const n=e-t;if(0===n)return!0;const s=n/Math.max(Math.abs(t),Math.abs(e));return rs.exponent(s)<=as.MIN_BINARY_EXPONENT}getClass(){return as}get interfaces_(){return[]}}as.constructor_=function(){},as.MIN_BINARY_EXPONENT=-50;class cs extends is{constructor(){super(),cs.constructor_.apply(this,arguments)}insert(t,e){const n=is.getSubnodeIndex(t,cs.origin.x,cs.origin.y);if(-1===n)return this.add(e),null;const s=this._subnode[n];if(null===s||!s.getEnvelope().contains(t)){const e=ls.createExpanded(s,t);this._subnode[n]=e}this.insertContained(this._subnode[n],t,e)}isSearchMatch(t){return!0}insertContained(t,e,n){u.isTrue(t.getEnvelope().contains(e));const s=as.isZeroWidth(e.getMinX(),e.getMaxX()),i=as.isZeroWidth(e.getMinY(),e.getMaxY());let r=null;r=s||i?t.find(e):t.getNode(e),r.add(n)}getClass(){return cs}get interfaces_(){return[]}}cs.constructor_=function(){},cs.origin=new g(0,0);class hs{constructor(){hs.constructor_.apply(this,arguments)}insert(t,e){}remove(t,e){}query(){}getClass(){return hs}get interfaces_(){return[]}}hs.constructor_=function(){};class us{constructor(){us.constructor_.apply(this,arguments)}static ensureExtent(t,e){let n=t.getMinX(),s=t.getMaxX(),i=t.getMinY(),r=t.getMaxY();return n!==s&&i!==r?t:(n===s&&(n-=e/2,s=n+e/2),i===r&&(i-=e/2,r=i+e/2),new N(n,s,i,r))}size(){return null!==this._root?this._root.size():0}insert(t,e){this.collectStats(t);const n=us.ensureExtent(t,this._minExtent);this._root.insert(n,e)}query(){if(1===arguments.length){const t=arguments[0],e=new Ye;return this.query(t,e),e.getItems()}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._root.visit(t,e)}}queryAll(){const t=new x;return this._root.addAllItems(t),t}remove(t,e){const n=us.ensureExtent(t,this._minExtent);return this._root.remove(n,e)}collectStats(t){const e=t.getWidth();e<this._minExtent&&e>0&&(this._minExtent=e);const n=t.getHeight();n<this._minExtent&&n>0&&(this._minExtent=n)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}getClass(){return us}get interfaces_(){return[hs,a]}}us.constructor_=function(){this._root=null,this._minExtent=1,this._root=new cs},us.serialVersionUID=-0x678b60c967a25400;var gs=Object.freeze({__proto__:null,Quadtree:us});class ds{constructor(){ds.constructor_.apply(this,arguments)}getBounds(){}getClass(){return ds}get interfaces_(){return[]}}ds.constructor_=function(){};class _s{constructor(){_s.constructor_.apply(this,arguments)}getItem(){return this._item}getBounds(){return this._bounds}getClass(){return _s}get interfaces_(){return[ds,a]}}_s.constructor_=function(){this._bounds=null,this._item=null;const t=arguments[0],e=arguments[1];this._bounds=t,this._item=e};class fs{constructor(){fs.constructor_.apply(this,arguments)}poll(){if(this.isEmpty())return null;const t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let e=null;const n=this._items.get(t);for(;2*t<=this._size&&(e=2*t,e!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}clear(){this._size=0,this._items.clear()}peek(){if(this.isEmpty())return null;return this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}getClass(){return fs}get interfaces_(){return[]}}fs.constructor_=function(){this._size=null,this._items=null,this._size=0,this._items=new x,this._items.add(null)};class ps{constructor(){ps.constructor_.apply(this,arguments)}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){u.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}getClass(){return ps}get interfaces_(){return[ds,a]}}ps.constructor_=function(){if(this._childBoundables=new x,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._level=t}},ps.serialVersionUID=0x5a1e55ec41369800;class ms{constructor(){ms.constructor_.apply(this,arguments)}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof ps}expandToQueue(t,e){const s=ms.isComposite(this._boundable1),i=ms.isComposite(this._boundable2);if(s&&i)return ms.area(this._boundable1)>ms.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,t,e),null):(this.expand(this._boundable2,this._boundable1,t,e),null);if(s)return this.expand(this._boundable1,this._boundable2,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,t,e),null;throw new n("neither boundable is composite")}isLeaves(){return!(ms.isComposite(this._boundable1)||ms.isComposite(this._boundable2))}compareTo(t){const e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}expand(t,e,n,s){for(let i=t.getChildBoundables().iterator();i.hasNext();){const t=i.next(),r=new ms(t,e,this._itemDistance);r.getDistance()<s&&n.add(r)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}getClass(){return ms}get interfaces_(){return[r]}}ms.constructor_=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()};class ys{constructor(){ys.constructor_.apply(this,arguments)}static compareDoubles(t,e){return t>e?1:t<e?-1:0}queryInternal(){if(_(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof ps){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getChildBoundables();for(let e=0;e<s.size();e++){const i=s.get(e);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof ps?this.queryInternal(t,i,n):i instanceof _s?n.visitItem(i.getItem()):u.shouldNeverReachHere())}}else if(_(arguments[2],m)&&arguments[0]instanceof Object&&arguments[1]instanceof ps){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getChildBoundables();for(let e=0;e<s.size();e++){const i=s.get(e);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof ps?this.queryInternal(t,i,n):i instanceof _s?n.add(i.getItem()):u.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();n instanceof ps?t+=this.size(n):n instanceof _s&&(t+=1)}return t}}removeItem(t,e){let n=null;for(let s=t.getChildBoundables().iterator();s.hasNext();){const t=s.next();t instanceof _s&&t.getItem()===e&&(n=t)}return null!==n&&(t.getChildBoundables().remove(n),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this._root);return null===t?new x:t}if(1===arguments.length){const t=arguments[0],e=new x;for(let n=t.getChildBoundables().iterator();n.hasNext();){const t=n.next();if(t instanceof ps){const n=this.itemsTree(t);null!==n&&e.add(n)}else t instanceof _s?e.add(t.getItem()):u.shouldNeverReachHere()}return e.size()<=0?null:e}}insert(t,e){u.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new _s(t,e))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],e=new x;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(u.isTrue(t>-2),e.getLevel()===t)return n.add(e),null;for(let s=e.getChildBoundables().iterator();s.hasNext();){const e=s.next();e instanceof ps?this.boundablesAtLevel(t,e,n):(u.isTrue(e instanceof _s),-1===t&&n.add(e))}return null}}query(){if(1===arguments.length){const t=arguments[0];this.build();const e=new x;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=this.removeItem(e,n);if(s)return!0;let i=null;for(let r=e.getChildBoundables().iterator();r.hasNext();){const e=r.next();if(this.getIntersectsOp().intersects(e.getBounds(),t)&&(e instanceof ps&&(s=this.remove(t,e,n),s))){i=e;break}}return null!==i&&i.getChildBoundables().isEmpty()&&e.getChildBoundables().remove(i),s}}createHigherLevels(t,e){u.isTrue(!t.isEmpty());const n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();if(n instanceof ps){const e=this.depth(n);e>t&&(t=e)}}return t+1}}createParentBoundables(t,e){u.isTrue(!t.isEmpty());const n=new x;n.add(this.createNode(e));const s=new x(t);Ee.sort(s,this.getComparator());for(let t=s.iterator();t.hasNext();){const s=t.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}getClass(){return ys}get interfaces_(){return[a]}}ys.IntersectsOp=function(){},ys.constructor_=function(){if(this._root=null,this._built=!1,this._itemBoundables=new x,this._nodeCapacity=null,0===arguments.length)ys.constructor_.call(this,ys.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];u.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}},ys.serialVersionUID=-0x35ef64c82d4c5400,ys.DEFAULT_NODE_CAPACITY=10;class xs{constructor(){xs.constructor_.apply(this,arguments)}distance(t,e){}getClass(){return xs}get interfaces_(){return[]}}xs.constructor_=function(){};class Es extends ys{constructor(){super(),Es.constructor_.apply(this,arguments)}static centreX(t){return Es.avg(t.getMinX(),t.getMaxX())}static avg(t,e){return(t+e)/2}static getItems(t){const e=new Array(t.size()).fill(null);let n=0;for(;!t.isEmpty();){const s=t.poll();e[n]=s.getBoundable(0).getItem(),n++}return e}static centreY(t){return Es.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,e){u.isTrue(t.length>0);const n=new x;for(let s=0;s<t.length;s++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[s],e));return n}createNode(t){return new Is(t)}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N))return super.insert.apply(this,arguments);{const t=arguments[0],e=arguments[1];if(t.isNull())return null;super.insert.call(this,t,e)}}getIntersectsOp(){return Es.intersectsOp}verticalSlices(t,e){const n=Math.trunc(Math.ceil(t.size()/e)),s=new Array(e).fill(null),i=t.iterator();for(let t=0;t<e;t++){s[t]=new x;let e=0;for(;i.hasNext()&&e<n;){const n=i.next();s[t].add(n),e++}}return s}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];super.query.call(this,t,e)}}getComparator(){return Es.yComparator}createParentBoundablesFromVerticalSlice(t,e){return super.createParentBoundables.call(this,t,e)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N){const t=arguments[0],e=arguments[1];return super.remove.call(this,t,e)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,e){u.isTrue(!t.isEmpty());const n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),s=new x(t);Ee.sort(s,Es.xComparator);const i=this.verticalSlices(s,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}nearestNeighbour(){if(1===arguments.length){if(_(arguments[0],xs)){const t=arguments[0],e=new ms(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof ms){const t=arguments[0];return this.nearestNeighbour(t,i.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof Es&&_(arguments[1],xs)){const t=arguments[0],e=arguments[1],n=new ms(this.getRoot(),t.getRoot(),e);return this.nearestNeighbour(n)}if(arguments[0]instanceof ms&&"number"==typeof arguments[1]){const t=arguments[0];let e=arguments[1],n=null;const s=new fs;for(s.add(t);!s.isEmpty()&&e>0;){const t=s.poll(),i=t.getDistance();if(i>=e)break;t.isLeaves()?(e=i,n=t):t.expandToQueue(s,e)}return[n.getBoundable(0).getItem(),n.getBoundable(1).getItem()]}if(arguments[0]instanceof ms&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];return this.nearestNeighbour(t,i.POSITIVE_INFINITY,e)}}else if(3===arguments.length){if(_(arguments[2],xs)&&arguments[0]instanceof N&&arguments[1]instanceof Object){const t=arguments[0],e=arguments[1],n=arguments[2],s=new _s(t,e),i=new ms(this.getRoot(),s,n);return this.nearestNeighbour(i)[0]}if(Number.isInteger(arguments[2])&&arguments[0]instanceof ms&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];let s=e;const i=new fs;i.add(t);const r=new fs;for(;!i.isEmpty()&&s>=0;){const t=i.poll(),e=t.getDistance();if(e>=s)break;if(t.isLeaves())if(r.size()<n)r.add(t);else{r.peek().getDistance()>e&&(r.poll(),r.add(t)),s=r.peek().getDistance()}else t.expandToQueue(i,s)}return Es.getItems(r)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new _s(t,e),r=new ms(this.getRoot(),i,n);return this.nearestNeighbour(r,s)}}getClass(){return Es}get interfaces_(){return[hs,a]}}class Is extends ps{constructor(){super(),Is.constructor_.apply(this,arguments)}computeBounds(){let t=null;for(let e=this.getChildBoundables().iterator();e.hasNext();){const n=e.next();null===t?t=new N(n.getBounds()):t.expandToInclude(n.getBounds())}return t}getClass(){return Is}get interfaces_(){return[]}}Is.constructor_=function(){const t=arguments[0];ps.constructor_.call(this,t)},Es.STRtreeNode=Is,Es.constructor_=function(){if(0===arguments.length)Es.constructor_.call(this,Es.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];ys.constructor_.call(this,t)}},Es.serialVersionUID=0x39920f7d5f261e0,Es.xComparator=new class{get interfaces_(){return[l]}compare(t,e){return ys.compareDoubles(Es.centreX(t.getBounds()),Es.centreX(e.getBounds()))}},Es.yComparator=new class{get interfaces_(){return[l]}compare(t,e){return ys.compareDoubles(Es.centreY(t.getBounds()),Es.centreY(e.getBounds()))}},Es.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,e){return t.intersects(e)}},Es.DEFAULT_NODE_CAPACITY=10;var Ns=Object.freeze({__proto__:null,STRtree:Es}),Cs=Object.freeze({__proto__:null,kdtree:ss,quadtree:gs,strtree:Ns});const Ss=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class ws{constructor(t){this.geometryFactory=t||new Ht}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!Ls[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==Ss.indexOf(n)?Ls[n].call(this,e.coordinates):"GeometryCollection"===n?Ls[n].call(this,e.geometries):Ls[n].call(this,e)}write(t){const e=t.getGeometryType();if(!Ts[e])throw new Error("Geometry is not supported");return Ts[e].call(this,t)}}const Ls={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!Ls[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Ls.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(new g(s[0],s[1]))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){const e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Ls.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=Ls.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Ls.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=Ls.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),s=[];for(let e=1;e<t.length;++e){const n=t[e],i=Ls.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(i);s.push(r)}return this.geometryFactory.createPolygon(n,s)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(Ls.Polygon.call(this,s))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(this.read(s))}return this.geometryFactory.createGeometryCollection(e)}},Ts={coordinate:function(t){return[t.x,t.y]},Point:function(t){return{type:"Point",coordinates:Ts.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.Point.call(this,s);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const s=n[t];e.push(Ts.coordinate.call(this,s))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.LineString.call(this,s);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=Ts.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const s=t._holes[n],i=Ts.LineString.call(this,s);e.push(i.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.Polygon.call(this,s);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=s.getGeometryType();e.push(Ts[i].call(this,s))}return{type:"GeometryCollection",geometries:e}}};function Rs(t){return[t.x,t.y]}var Ps=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new ws(t||new Ht)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new ws(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,e){this.geometryFactory=t||new Ht,this.ol=e||"undefined"!=typeof ol&&ol}inject(t,e,n,s,i,r,o,l){this.ol={geom:{Point:t,LineString:e,LinearRing:n,Polygon:s,MultiPoint:i,MultiLineString:r,MultiPolygon:o,GeometryCollection:l}}}read(t){const e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){const e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map((function(t){return new g(t[0],t[1])})))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t){return new g(t[0],t[1])})))}convertFromPolygon(t){const e=t.getLinearRings();let n=null;const s=[];for(let t=0;t<e.length;t++){const i=this.convertFromLinearRing(e[t]);0===t?n=i:s.push(i)}return this.geometryFactory.createPolygon(n,s)}convertFromMultiPoint(t){const e=t.getPoints().map((function(t){return this.convertFromPoint(t)}),this);return this.geometryFactory.createMultiPoint(e)}convertFromMultiLineString(t){const e=t.getLineStrings().map((function(t){return this.convertFromLineString(t)}),this);return this.geometryFactory.createMultiLineString(e)}convertFromMultiPolygon(t){const e=t.getPolygons().map((function(t){return this.convertFromPolygon(t)}),this);return this.geometryFactory.createMultiPolygon(e)}convertFromCollection(t){const e=t.getGeometries().map((function(t){return this.read(t)}),this);return this.geometryFactory.createGeometryCollection(e)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){const e=t._points._coordinates.map(Rs);return new this.ol.geom.LineString(e)}convertToLinearRing(t){const e=t._points._coordinates.map(Rs);return new this.ol.geom.LinearRing(e)}convertToPolygon(t){const e=[t._shell._points._coordinates.map(Rs)];for(let n=0;n<t._holes.length;n++)e.push(t._holes[n]._points._coordinates.map(Rs));return new this.ol.geom.Polygon(e)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Rs))}convertToMultiLineString(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)}convertToMultiPolygon(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)}convertToCollection(t){const e=[];for(let n=0;n<t._geometries.length;n++){const s=t._geometries[n];e.push(this.write(s))}return new this.ol.geom.GeometryCollection(e)}},WKTReader:class{constructor(t){this.parser=new Kt(t||new Ht)}read(t){return this.parser.read(t)}},WKTWriter:Jt});class vs{constructor(){vs.constructor_.apply(this,arguments)}static relativeSign(t,e){return t<e?-1:t>e?1:0}static compare(t,e,n){if(e.equals2D(n))return 0;const s=vs.relativeSign(e.x,n.x),i=vs.relativeSign(e.y,n.y);switch(t){case 0:return vs.compareValue(s,i);case 1:return vs.compareValue(i,s);case 2:return vs.compareValue(i,-s);case 3:return vs.compareValue(-s,i);case 4:return vs.compareValue(-s,-i);case 5:return vs.compareValue(-i,-s);case 6:return vs.compareValue(-i,s);case 7:return vs.compareValue(s,-i)}return u.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}getClass(){return vs}get interfaces_(){return[]}}vs.constructor_=function(){};class Os{constructor(){Os.constructor_.apply(this,arguments)}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){const e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:vs.compare(this._segmentOctant,this.coord,e.coord)}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}isInterior(){return this._isInterior}getClass(){return Os}get interfaces_(){return[r]}}Os.constructor_=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._segString=t,this.coord=new g(e),this.segmentIndex=n,this._segmentOctant=s,this._isInterior=!e.equals2D(t.getCoordinate(n))};class bs{constructor(){bs.constructor_.apply(this,arguments)}getSplitCoordinates(){const t=new I;this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next();this.addEdgeCoordinates(n,s,t),n=s}return t.toCoordinateArray()}addCollapsedNodes(){const t=new x;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let e=t.iterator();e.hasNext();){const t=e.next().intValue();this.add(this._edge.getCoordinate(t),t)}}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}findCollapsesFromExistingVertices(t){for(let e=0;e<this._edge.size()-2;e++){const n=this._edge.getCoordinate(e),s=(this._edge.getCoordinate(e+1),this._edge.getCoordinate(e+2));n.equals2D(s)&&t.add(new L(e+1))}}addEdgeCoordinates(t,e,n){e.segmentIndex,t.segmentIndex;const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);n.add(new g(t.coord),!1);for(let s=t.segmentIndex+1;s<=e.segmentIndex;s++)n.add(this._edge.getCoordinate(s));i&&n.add(new g(e.coord))}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}findCollapseIndex(t,e,n){if(!t.coord.equals2D(e.coord))return!1;let s=e.segmentIndex-t.segmentIndex;return e.isInterior()||s--,1===s&&(n[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){const e=new Array(1).fill(null),n=this.iterator();let s=n.next();for(;n.hasNext();){const i=n.next();this.findCollapseIndex(s,i,e)&&t.add(new L(e[0])),s=i}}getEdge(){return this._edge}addEndpoints(){const t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new g(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this._edge.getCoordinate(n);return i&&(r[o]=new g(e.coord)),new Fs(r,this._edge.getData())}add(t,e){const n=new Os(this._edge,t,e,this._edge.getSegmentOctant(e)),s=this._nodeMap.get(n);return null!==s?(u.isTrue(s.coord.equals2D(t),"Found equal nodes with different coordinates"),s):(this._nodeMap.put(n,n),n)}checkSplitEdgesCorrectness(t){const e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new c("bad split edge start point at "+n);const s=t.get(t.size()-1).getCoordinates(),i=s[s.length-1];if(!i.equals2D(e[e.length-1]))throw new c("bad split edge end point at "+i)}getClass(){return bs}get interfaces_(){return[]}}bs.constructor_=function(){this._nodeMap=new rt,this._edge=null;const t=arguments[0];this._edge=t};class Ms{constructor(){Ms.constructor_.apply(this,arguments)}static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Cannot compute the octant for point ( "+t+", "+e+" )");const s=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?s>=i?0:1:s>=i?7:6:e>=0?s>=i?3:2:s>=i?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],s=e.x-t.x,i=e.y-t.y;if(0===s&&0===i)throw new n("Cannot compute the octant for two identical points "+t);return Ms.octant(s,i)}}getClass(){return Ms}get interfaces_(){return[]}}Ms.constructor_=function(){};class Ds{constructor(){Ds.constructor_.apply(this,arguments)}getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}getClass(){return Ds}get interfaces_(){return[]}}Ds.constructor_=function(){};class As{constructor(){As.constructor_.apply(this,arguments)}addIntersection(t,e){}getClass(){return As}get interfaces_(){return[Ds]}}As.constructor_=function(){};class Fs{constructor(){Fs.constructor_.apply(this,arguments)}static getNodedSubstrings(){if(1===arguments.length){const t=arguments[0],e=new x;return Fs.getNodedSubstrings(t,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){n.next().getNodeList().addSplitEdges(e)}}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,e){return t.equals2D(e)?0:Ms.octant(t,e)}getData(){return this._data}addIntersection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[3],s=new g(t.getIntersection(n));this.addIntersection(s,e)}}toString(){return Jt.toLineString(new zt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,e){let n=e;const s=n+1;if(s<this._pts.length){const e=this._pts[s];t.equals2D(e)&&(n=s)}return this._nodeList.add(t,n)}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}getClass(){return Fs}get interfaces_(){return[As]}}Fs.constructor_=function(){this._nodeList=new bs(this),this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e};class Gs{constructor(){Gs.constructor_.apply(this,arguments)}overlap(){if(2===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t.getLineSegment(e,this._overlapSeg1),n.getLineSegment(s,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}getClass(){return Gs}get interfaces_(){return[]}}Gs.constructor_=function(){this._overlapSeg1=new ee,this._overlapSeg2=new ee};class qs{constructor(){qs.constructor_.apply(this,arguments)}getLineSegment(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}computeSelect(t,e,n,s){const i=this._pts[e],r=this._pts[n];if(n-e==1)return s.select(this,e),null;if(!t.intersects(i,r))return null;const o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,s),o<n&&this.computeSelect(t,o,n,s)}getCoordinates(){const t=new Array(this._end-this._start+1).fill(null);let e=0;for(let n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}computeOverlaps(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.overlap(this,t,n,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeOverlaps(t,o,n,s,l,r),l<i&&this.computeOverlaps(t,o,n,l,i,r)),o<e&&(s<l&&this.computeOverlaps(o,e,n,s,l,r),l<i&&this.computeOverlaps(o,e,n,l,i,r))}}setId(t){this._id=t}select(t,e){this.computeSelect(t,this._start,this._end,e)}getEnvelope(){if(null===this._env){const t=this._pts[this._start],e=this._pts[this._end];this._env=new N(t,e)}return this._env}overlaps(t,e,n,s,i){return N.intersects(this._pts[t],this._pts[e],n._pts[s],n._pts[i])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}getClass(){return qs}get interfaces_(){return[]}}qs.constructor_=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=s};class Bs{constructor(){Bs.constructor_.apply(this,arguments)}static getChainStartIndices(t){let e=0;const n=new x;n.add(new L(e));do{const s=Bs.findChainEnd(t,e);n.add(new L(s)),e=s}while(e<t.length-1);return Bs.toIntArray(n)}static findChainEnd(t,e){let n=e;for(;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;const s=In.quadrant(t[n],t[n+1]);let i=e+1;for(;i<t.length;){if(!t[i-1].equals2D(t[i])){if(In.quadrant(t[i-1],t[i])!==s)break}i++}return i-1}static getChains(){if(1===arguments.length){const t=arguments[0];return Bs.getChains(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new x,s=Bs.getChainStartIndices(t);for(let i=0;i<s.length-1;i++){const r=new qs(t,s[i],s[i+1],e);n.add(r)}return n}}static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getClass(){return Bs}get interfaces_(){return[]}}Bs.constructor_=function(){};class Vs{constructor(){Vs.constructor_.apply(this,arguments)}computeNodes(t){}getNodedSubstrings(){}getClass(){return Vs}get interfaces_(){return[]}}Vs.constructor_=function(){};class zs{constructor(){zs.constructor_.apply(this,arguments)}setSegmentIntersector(t){this._segInt=t}getClass(){return zs}get interfaces_(){return[Vs]}}zs.constructor_=function(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setSegmentIntersector(t)}};class Ys extends zs{constructor(){super(),Ys.constructor_.apply(this,arguments)}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Fs.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let e=Bs.getChains(t.getCoordinates(),t).iterator();e.hasNext();){const t=e.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}intersectChains(){const t=new Us(this._segInt);for(let e=this._monoChains.iterator();e.hasNext();){const n=e.next();for(let e=this._index.query(n.getEnvelope()).iterator();e.hasNext();){const s=e.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this._nOverlaps++),this._segInt.isDone())return null}}}getClass(){return Ys}get interfaces_(){return[]}}class Us extends Gs{constructor(){super(),Us.constructor_.apply(this,arguments)}overlap(){if(4!==arguments.length)return super.overlap.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.getContext(),r=n.getContext();this._si.processIntersections(i,e,r,s)}}getClass(){return Us}get interfaces_(){return[]}}Us.constructor_=function(){this._si=null;const t=arguments[0];this._si=t},Ys.SegmentOverlapAction=Us,Ys.constructor_=function(){if(this._monoChains=new x,this._index=new Es,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];zs.constructor_.call(this,t)}};class ks{constructor(){ks.constructor_.apply(this,arguments)}rescale(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.rescale(e.getCoordinates())}}else if(arguments[0]instanceof Array){const t=arguments[0];let e=null,n=null;2===t.length&&(e=new g(t[0]),n=new g(t[1]));for(let e=0;e<t.length;e++)t[e].x=t[e].x/this._scaleFactor+this._offsetX,t[e].y=t[e].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&O.out.println(t)}}scale(){if(_(arguments[0],f)){const t=arguments[0],e=new x(t.size());for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Fs(this.scale(t.getCoordinates()),t.getData()))}return e}if(arguments[0]instanceof Array){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new g(Math.round((t[n].x-this._offsetX)*this._scaleFactor),Math.round((t[n].y-this._offsetY)*this._scaleFactor),t[n].z);return X.removeRepeatedPoints(e)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){const t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}getClass(){return ks}get interfaces_(){return[Vs]}}ks.constructor_=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){const t=arguments[0],e=arguments[1];ks.constructor_.call(this,t,e,0,0)}else if(4===arguments.length){const t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._isScaled=!this.isIntegerPrecision()}};var Xs=Object.freeze({__proto__:null,MCIndexNoder:Ys,ScaledNoder:ks,SegmentString:Ds});class Hs{constructor(){Hs.constructor_.apply(this,arguments)}static isSimple(){if(1===arguments.length){const t=arguments[0];return new Hs(t).isSimple()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Hs(t,e).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;const e=new at;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getCoordinate();if(e.contains(s))return this._nonSimpleLocation=s,!1;e.add(s)}return!0}isSimplePolygonal(t){for(let e=xe.getLines(t).iterator();e.hasNext();){const t=e.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){const e=new rt;for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=(t.getMaximumSegmentIndex(),t.isClosed()),i=t.getCoordinate(0);this.addEndpoint(e,i,s);const r=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(e,r,s)}for(let t=e.values().iterator();t.hasNext();){const e=t.next();if(e.isClosed&&2!==e.degree)return this._nonSimpleLocation=e.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;const e=new Qn(0,t),n=new te,s=e.computeSelfNodes(n,!0);return!s.hasIntersection()||(s.hasProperIntersection()?(this._nonSimpleLocation=s.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))}hasNonEndpointIntersection(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next(),n=t.getMaximumSegmentIndex();for(let e=t.getEdgeIntersectionList().iterator();e.hasNext();){const t=e.next();if(!t.isEndPoint(n))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,e,n){let s=t.get(e);null===s&&(s=new Ws(e),t.put(e,s)),s.addEndpoint(n)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof Tt||t instanceof ft?this.isSimpleLinearGeometry(t):t instanceof Mt?this.isSimpleMultiPoint(t):_(t,Ot)?this.isSimplePolygonal(t):!(t instanceof _t)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0}getClass(){return Hs}get interfaces_(){return[]}}class Ws{constructor(){Ws.constructor_.apply(this,arguments)}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}getClass(){return Ws}get interfaces_(){return[]}}Ws.constructor_=function(){this.pt=null,this.isClosed=null,this.degree=null;const t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0},Hs.EndpointInfo=Ws,Hs.constructor_=function(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1===arguments.length){const t=arguments[0];this._inputGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!e.isInBoundary(2)}};class js{constructor(){js.constructor_.apply(this,arguments)}static bufferDistanceError(t){const e=Math.PI/2/t;return 1-Math.cos(e/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=js.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=js.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==js.JOIN_ROUND&&(this._quadrantSegments=js.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}getClass(){return js}get interfaces_(){return[]}}js.constructor_=function(){if(this._quadrantSegments=js.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=js.CAP_ROUND,this._joinStyle=js.JOIN_ROUND,this._mitreLimit=js.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=js.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(e),this.setJoinStyle(n),this.setMitreLimit(s)}},js.CAP_ROUND=1,js.CAP_FLAT=2,js.CAP_SQUARE=3,js.JOIN_ROUND=1,js.JOIN_MITRE=2,js.JOIN_BEVEL=3,js.DEFAULT_QUADRANT_SEGMENTS=8,js.DEFAULT_MITRE_LIMIT=5,js.DEFAULT_SIMPLIFY_FACTOR=.01;class Ks{constructor(){Ks.constructor_.apply(this,arguments)}getCoordinate(){return this._minCoord}getRightmostSide(t,e){let n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}findRightmostEdgeAtVertex(){const t=this._minDe.getEdge().getCoordinates();u.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");const e=t[this._minIndex-1],n=t[this._minIndex+1],s=v.index(this._minCoord,n,e);let i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&s===v.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&s===v.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,e){const n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;let s=Pn.LEFT;return n[e].y<n[e+1].y&&(s=Pn.RIGHT),s}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){const e=t.getEdge().getCoordinates();for(let n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}findRightmostEdgeAtNode(){const t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let e=t.iterator();e.hasNext();){const t=e.next();t.isForward()&&this.checkForRightmostCoordinate(t)}u.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe,this.getRightmostSide(this._minDe,this._minIndex)===Pn.LEFT&&(this._orientedDe=this._minDe.getSym())}getClass(){return Ks}get interfaces_(){return[]}}function Zs(){this.array_=[]}Ks.constructor_=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null},Zs.prototype.addLast=function(t){this.array_.push(t)},Zs.prototype.removeFirst=function(){return this.array_.shift()},Zs.prototype.isEmpty=function(){return 0===this.array_.length};class Qs{constructor(){Qs.constructor_.apply(this,arguments)}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let e=null;for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();if(t.isVisited()||t.getSym().isVisited()){e=t;break}}if(null===e)throw new Wn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(let e=t.getEdges().iterator();e.hasNext();){const t=e.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();const e=this._finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(Pn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){const e=t.next();e.getDepth(Pn.RIGHT)>=1&&e.getDepth(Pn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}computeDepths(t){const e=new J,n=new Zs,s=t.getNode();for(n.addLast(s),e.add(s),t.setVisited(!0);!n.isEmpty();){const t=n.removeFirst();e.add(t),this.computeNodeDepth(t);for(let s=t.getEdges().iterator();s.hasNext();){const t=s.next().getSym();if(t.isVisited())continue;const i=t.getNode();e.contains(i)||(n.addLast(i),e.add(i))}}}compareTo(t){const e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){const t=new N;for(let e=this._dirEdgeList.iterator();e.hasNext();){const n=e.next().getEdge().getCoordinates();for(let e=0;e<n.length-1;e++)t.expandToInclude(n[e])}this._env=t}return this._env}addReachable(t){const e=new on;for(e.add(t);!e.empty();){const t=e.pop();this.add(t,e)}}copySymDepths(t){const e=t.getSym();e.setDepth(Pn.LEFT,t.getDepth(Pn.RIGHT)),e.setDepth(Pn.RIGHT,t.getDepth(Pn.LEFT))}add(t,e){t.setVisited(!0),this._nodes.add(t);for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();this._dirEdgeList.add(t);const s=t.getSym().getNode();s.isVisited()||e.push(s)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}getClass(){return Qs}get interfaces_(){return[r]}}Qs.constructor_=function(){this._finder=null,this._dirEdgeList=new x,this._nodes=new x,this._rightMostCoord=null,this._env=null,this._finder=new Ks};class Js{constructor(){Js.constructor_.apply(this,arguments)}computeRing(){if(null!==this._ring)return null;const t=new Array(this._pts.size()).fill(null);for(let e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=v.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let e=t,n=!0;do{if(null===e)throw new Wn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new Wn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);const t=e.getLabel();u.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{const e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,e,n){const s=t.getCoordinates();if(e){let t=1;n&&(t=0);for(let e=t;e<s.length;e++)this._pts.add(s[e])}else{let t=s.length-2;n&&(t=s.length-1);for(let e=t;e>=0;e--)this._pts.add(s[e])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}containsPoint(t){const e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!We.isInRing(t,e.getCoordinates()))return!1;for(let e=this._holes.iterator();e.hasNext();){if(e.next().containsPoint(t))return!1}return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(e,Pn.RIGHT);if(n===ne.NONE)return null;if(this._label.getLocation(e)===ne.NONE)return this._label.setLocation(e,n),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){const e=new Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)e[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}getClass(){return Js}get interfaces_(){return[]}}Js.constructor_=function(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new x,this._pts=new x,this._label=new Fn(ne.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new x,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}};class $s extends Js{constructor(){super(),$s.constructor_.apply(this,arguments)}setEdgeRing(t,e){t.setMinEdgeRing(e)}getNext(t){return t.getNextMin()}getClass(){return $s}get interfaces_(){return[]}}$s.constructor_=function(){const t=arguments[0],e=arguments[1];Js.constructor_.call(this,t,e)};class ti extends Js{constructor(){super(),ti.constructor_.apply(this,arguments)}buildMinimalRings(){const t=new x;let e=this._startDe;do{if(null===e.getMinEdgeRing()){const n=new $s(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}setEdgeRing(t,e){t.setEdgeRing(e)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}getNext(t){return t.getNext()}getClass(){return ti}get interfaces_(){return[]}}ti.constructor_=function(){const t=arguments[0],e=arguments[1];Js.constructor_.call(this,t,e)};class ei{constructor(){ei.constructor_.apply(this,arguments)}sortShellsAndHoles(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()?n.add(t):e.add(t)}}computePolygons(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next().toPolygon(this._geometryFactory);e.add(t)}return e}placeFreeHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(null===e.getShell()){const n=this.findEdgeRingContaining(e,t);if(null===n)throw new Wn("unable to assign hole to a shell",e.getCoordinate(0));e.setShell(n)}}}buildMinimalEdgeRings(t,e,n){const s=new x;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();const s=t.buildMinimalRings(),i=this.findShell(s);null!==i?(this.placePolygonHoles(i,s),e.add(i)):n.addAll(s)}else s.add(t)}return s}containsPoint(t){for(let e=this._shellList.iterator();e.hasNext();){if(e.next().containsPoint(t))return!0}return!1}buildMaximalEdgeRings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){const n=new ti(t,this._geometryFactory);e.add(n),n.setInResult()}}return e}placePolygonHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();e.isHole()&&e.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findEdgeRingContaining(t,e){const n=t.getLinearRing(),s=n.getEnvelopeInternal(),i=n.getCoordinateN(0);let r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),n=e.getLinearRing(),l=n.getEnvelopeInternal();null!==r&&(o=r.getLinearRing().getEnvelopeInternal());let a=!1;l.contains(s)&&We.isInRing(i,n.getCoordinates())&&(a=!0),a&&(null===r||o.contains(l))&&(r=e)}return r}findShell(t){let e=0,n=null;for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()||(n=t,e++)}return u.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}add(){if(1===arguments.length){const t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Zn.linkResultDirectedEdges(e);const n=this.buildMaximalEdgeRings(t),s=new x,i=this.buildMinimalEdgeRings(n,this._shellList,s);this.sortShellsAndHoles(i,this._shellList,s),this.placeFreeHoles(this._shellList,s)}}getClass(){return ei}get interfaces_(){return[]}}ei.constructor_=function(){this._geometryFactory=null,this._shellList=new x;const t=arguments[0];this._geometryFactory=t};class ni{constructor(){ni.constructor_.apply(this,arguments)}static simplify(t,e){return new ni(t).simplify(e)}isDeletable(t,e,n,s){const i=this._inputLine[t],r=this._inputLine[e],o=this._inputLine[n];return!!this.isConcave(i,r,o)&&(!!this.isShallow(i,r,o,s)&&this.isShallowSampled(i,r,t,n,s))}deleteShallowConcavities(){let t=1;this._inputLine.length;let e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),s=!1;for(;n<this._inputLine.length;){let i=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=ni.DELETE,i=!0,s=!0),t=i?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return s}isShallowConcavity(t,e,n,s){return v.index(t,e,n)===this._angleOrientation&&D.pointToSegment(e,t,n)<s}isShallowSampled(t,e,n,s,i){let r=Math.trunc((s-n)/ni.NUM_PTS_TO_CHECK);r<=0&&(r=1);for(let o=n;o<s;o+=r)if(!this.isShallow(t,e,this._inputLine[o],i))return!1;return!0}isConcave(t,e,n){return v.index(t,e,n)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=v.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);let e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}findNextNonDeletedIndex(t){let e=t+1;for(;e<this._inputLine.length&&this._isDeleted[e]===ni.DELETE;)e++;return e}isShallow(t,e,n,s){return D.pointToSegment(e,t,n)<s}collapseLine(){const t=new I;for(let e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==ni.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()}getClass(){return ni}get interfaces_(){return[]}}ni.constructor_=function(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=v.COUNTERCLOCKWISE;const t=arguments[0];this._inputLine=t},ni.INIT=0,ni.DELETE=1,ni.KEEP=1,ni.NUM_PTS_TO_CHECK=10;class si{constructor(){si.constructor_.apply(this,arguments)}getCoordinates(){return this._ptList.toArray(si.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){const e=new g(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}reverse(){}addPts(t,e){if(e)for(let e=0;e<t.length;e++)this.addPt(t[e]);else for(let e=t.length-1;e>=0;e--)this.addPt(t[e])}isRedundant(t){if(this._ptList.size()<1)return!1;const e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}toString(){return(new Ht).createLineString(this.getCoordinates()).toString()}closeRing(){if(this._ptList.size()<1)return null;const t=new g(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);let n=null;if(this._ptList.size()>=2&&this._ptList.get(this._ptList.size()-2),t.equals(e))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}getClass(){return si}get interfaces_(){return[]}}si.constructor_=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new x},si.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);class ii{constructor(){ii.constructor_.apply(this,arguments)}addNextSegment(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;const n=v.index(this._s0,this._s1,this._s2),s=n===v.CLOCKWISE&&this._side===Pn.LEFT||n===v.COUNTERCLOCKWISE&&this._side===Pn.RIGHT;0===n?this.addCollinear(e):s?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}addLineEndCap(t,e){const n=new ee(t,e),s=new ee;this.computeOffsetSegment(n,Pn.LEFT,this._distance,s);const i=new ee;this.computeOffsetSegment(n,Pn.RIGHT,this._distance,i);const r=e.x-t.x,o=e.y-t.y,l=Math.atan2(o,r);switch(this._bufParams.getEndCapStyle()){case js.CAP_ROUND:this._segList.addPt(s.p1),this.addDirectedFillet(e,l+Math.PI/2,l-Math.PI/2,v.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case js.CAP_FLAT:this._segList.addPt(s.p1),this._segList.addPt(i.p1);break;case js.CAP_SQUARE:const t=new g;t.x=Math.abs(this._distance)*Math.cos(l),t.y=Math.abs(this._distance)*Math.sin(l);const n=new g(s.p1.x+t.x,s.p1.y+t.y),r=new g(i.p1.x+t.x,i.p1.y+t.y);this._segList.addPt(n),this._segList.addPt(r)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,e,n,s){let i=!0,r=null;try{r=b.intersection(e.p0,e.p1,n.p0,n.p1),(s<=0?1:r.distance(t)/Math.abs(s))>this._bufParams.getMitreLimit()&&(i=!1)}catch(t){if(!(t instanceof S))throw t;r=new g(0,0),i=!1}i?this._segList.addPt(r):this.addLimitedMitreJoin(e,n,s,this._bufParams.getMitreLimit())}addOutsideTurn(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*ii.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===js.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===js.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new g(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new g(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,e){this._segList.addPts(t,e)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,e,n,s,i){const r=e.x-t.x,o=e.y-t.y;let l=Math.atan2(o,r);const a=n.x-t.x,c=n.y-t.y,h=Math.atan2(c,a);s===v.CLOCKWISE?l<=h&&(l+=2*Math.PI):l>=h&&(l-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,l,h,s,i),this._segList.addPt(n)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}addLimitedMitreJoin(t,e,n,s){const i=this._seg0.p1,r=ie.angle(i,this._seg0.p0),o=(ie.angle(i,this._seg1.p1),ie.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2),l=ie.normalize(r+o),a=ie.normalize(l+Math.PI),c=s*n,h=n-c*Math.abs(Math.sin(o)),u=i.x+c*Math.cos(a),d=i.y+c*Math.sin(a),_=new g(u,d),f=new ee(i,_),p=f.pointAlongOffset(1,h),m=f.pointAlongOffset(1,-h);this._side===Pn.LEFT?(this._segList.addPt(p),this._segList.addPt(m)):(this._segList.addPt(m),this._segList.addPt(p))}addDirectedFillet(t,e,n,s,i){const r=s===v.CLOCKWISE?-1:1,o=Math.abs(e-n),l=Math.trunc(o/this._filletAngleQuantum+.5);if(l<1)return null;let a=null,c=null;a=0,c=o/l;let h=0;const u=new g;for(;h<o;){const n=e+r*h;u.x=t.x+i*Math.cos(n),u.y=t.y+i*Math.sin(n),this._segList.addPt(u),h+=c}}computeOffsetSegment(t,e,n,s){const i=e===Pn.LEFT?1:-1,r=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,l=Math.sqrt(r*r+o*o),a=i*n*r/l,c=i*n*o/l;s.p0.x=t.p0.x-c,s.p0.y=t.p0.y+a,s.p1.x=t.p1.x-c,s.p1.y=t.p1.y+a}addInsideTurn(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*ii.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){const t=new g((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);const e=new g((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(e)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){const e=new g(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new si,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*ii.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2),this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===js.JOIN_BEVEL||this._bufParams.getJoinStyle()===js.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,v.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}getClass(){return ii}get interfaces_(){return[]}}ii.constructor_=function(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new ee,this._seg1=new ee,this._offset0=new ee,this._offset1=new ee,this._side=0,this._hasNarrowConcaveAngle=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._bufParams=e,this._li=new te,this._filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===js.JOIN_ROUND&&(this._closingSegLengthFactor=ii.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)},ii.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,ii.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,ii.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,ii.MAX_CLOSING_SEG_LEN_FACTOR=80;class ri{constructor(){ri.constructor_.apply(this,arguments)}static copyCoordinates(t){const e=new Array(t.length).fill(null);for(let n=0;n<e.length;n++)e[n]=new g(t[n]);return e}getOffsetCurve(t,e){if(this._distance=e,0===e)return null;const n=e<0,s=Math.abs(e),i=this.getSegGen(s);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);const r=i.getCoordinates();return n&&X.reverse(r),r}computeSingleSidedBufferCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);const e=ni.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Pn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{n.addSegments(t,!1);const e=ni.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Pn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment(),n.closeRing()}computeRingBufferCurve(t,e,n){let s=this.simplifyTolerance(this._distance);e===Pn.RIGHT&&(s=-s);const i=ni.simplify(t,s),r=i.length-1;n.initSideSegments(i[r-1],i[0],e);for(let t=1;t<=r;t++){const e=1!==t;n.addNextSegment(i[t],e)}n.closeRing()}computeLineBufferCurve(t,e){const n=this.simplifyTolerance(this._distance),s=ni.simplify(t,n),i=s.length-1;e.initSideSegments(s[0],s[1],Pn.LEFT);for(let t=2;t<=i;t++)e.addNextSegment(s[t],!0);e.addLastSegment(),e.addLineEndCap(s[i-1],s[i]);const r=ni.simplify(t,-n),o=r.length-1;e.initSideSegments(r[o],r[o-1],Pn.LEFT);for(let t=o-2;t>=0;t--)e.addNextSegment(r[t],!0);e.addLastSegment(),e.addLineEndCap(r[1],r[0]),e.closeRing()}computePointCurve(t,e){switch(this._bufParams.getEndCapStyle()){case js.CAP_ROUND:e.createCircle(t);break;case js.CAP_SQUARE:e.createSquare(t)}}getLineCurve(t,e){if(this._distance=e,e<0&&!this._bufParams.isSingleSided())return null;if(0===e)return null;const n=Math.abs(e),s=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],s);else if(this._bufParams.isSingleSided()){const n=e<0;this.computeSingleSidedBufferCurve(t,n,s)}else this.computeLineBufferCurve(t,s);return s.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return ri.copyCoordinates(t);const s=this.getSegGen(n);return this.computeRingBufferCurve(t,e,s),s.getCoordinates()}computeOffsetCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){const e=ni.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Pn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{const e=ni.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Pn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment()}getSegGen(t){return new ii(this._precisionModel,this._bufParams,t)}getClass(){return ri}get interfaces_(){return[]}}ri.constructor_=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;const t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e};class oi{constructor(){oi.constructor_.apply(this,arguments)}findStabbedSegments(){if(1===arguments.length){const t=arguments[0],e=new x;for(let n=this._subgraphs.iterator();n.hasNext();){const s=n.next(),i=s.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,s.getDirectedEdges(),e)}return e}if(3===arguments.length)if(_(arguments[2],m)&&arguments[0]instanceof g&&arguments[1]instanceof jn){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getEdge().getCoordinates();for(let i=0;i<s.length-1;i++){if(this._seg.p0=s[i],this._seg.p1=s[i+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse(),Math.max(this._seg.p0.x,this._seg.p1.x)<t.x)continue;if(this._seg.isHorizontal())continue;if(t.y<this._seg.p0.y||t.y>this._seg.p1.y)continue;if(v.index(this._seg.p0,this._seg.p1,t)===v.RIGHT)continue;let r=e.getDepth(Pn.LEFT);this._seg.p0.equals(s[i])||(r=e.getDepth(Pn.RIGHT));const o=new li(this._seg,r);n.add(o)}}else if(_(arguments[2],m)&&arguments[0]instanceof g&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=e.iterator();s.hasNext();){const e=s.next();e.isForward()&&this.findStabbedSegments(t,e,n)}}}getDepth(t){const e=this.findStabbedSegments(t);return 0===e.size()?0:Ee.min(e)._leftDepth}getClass(){return oi}get interfaces_(){return[]}}class li{constructor(){li.constructor_.apply(this,arguments)}compareTo(t){const e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;let n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg),0!==n?n:this._upwardSeg.compareTo(e._upwardSeg))}compareX(t,e){const n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}toString(){return this._upwardSeg.toString()}getClass(){return li}get interfaces_(){return[r]}}li.constructor_=function(){this._upwardSeg=null,this._leftDepth=null;const t=arguments[0],e=arguments[1];this._upwardSeg=new ee(t),this._leftDepth=e},oi.DepthSegment=li,oi.constructor_=function(){this._subgraphs=null,this._seg=new ee;const t=arguments[0];this._subgraphs=t};class ai{constructor(){ai.constructor_.apply(this,arguments)}addPoint(t){if(this._distance<=0)return null;const e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,ne.EXTERIOR,ne.INTERIOR)}addPolygon(t){let e=this._distance,n=Pn.LEFT;this._distance<0&&(e=-this._distance,n=Pn.RIGHT);const s=t.getExteriorRing(),i=X.removeRepeatedPoints(s.getCoordinates());if(this._distance<0&&this.isErodedCompletely(s,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addPolygonRing(i,e,n,ne.EXTERIOR,ne.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s),r=X.removeRepeatedPoints(i.getCoordinates());this._distance>0&&this.isErodedCompletely(i,-this._distance)||this.addPolygonRing(r,e,Pn.opposite(n),ne.INTERIOR,ne.EXTERIOR)}}isTriangleErodedCompletely(t,e){const n=new re(t[0],t[1],t[2]),s=n.inCentre();return D.pointToSegment(s,n.p0,n.p1)<Math.abs(e)}addLineString(t){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;const e=X.removeRepeatedPoints(t.getCoordinates()),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,ne.EXTERIOR,ne.INTERIOR)}addCurve(t,e,n){if(null===t||t.length<2)return null;const s=new Fs(t,new Fn(0,ne.BOUNDARY,e,n));this._curveList.add(s)}getCurves(){return this.add(this._inputGeom),this._curveList}addPolygonRing(t,e,n,s,i){if(0===e&&t.length<Dt.MINIMUM_VALID_SIZE)return null;let r=s,o=i;t.length>=Dt.MINIMUM_VALID_SIZE&&v.isCCW(t)&&(r=i,o=s,n=Pn.opposite(n));const l=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(l,r,o)}add(t){if(t.isEmpty())return null;if(t instanceof bt)this.addPolygon(t);else if(t instanceof Tt)this.addLineString(t);else if(t instanceof Pt)this.addPoint(t);else if(t instanceof Mt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else if(t instanceof At)this.addCollection(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.addCollection(t)}}isErodedCompletely(t,e){const n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);const s=t.getEnvelopeInternal(),i=Math.min(s.getHeight(),s.getWidth());return e<0&&2*Math.abs(e)>i}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}getClass(){return ai}get interfaces_(){return[]}}ai.constructor_=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new x;const t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n};class ci{constructor(){ci.constructor_.apply(this,arguments)}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=ne.NONE;for(let n=this.iterator();n.hasNext();){const s=n.next().getLabel();s.isArea(t)&&s.getLocation(t,Pn.LEFT)!==ne.NONE&&(e=s.getLocation(t,Pn.LEFT))}if(e===ne.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const s=e.next(),i=s.getLabel();if(i.getLocation(t,Pn.ON)===ne.NONE&&i.setLocation(t,Pn.ON,n),i.isArea(t)){const e=i.getLocation(t,Pn.LEFT),r=i.getLocation(t,Pn.RIGHT);if(r!==ne.NONE){if(r!==n)throw new Wn("side location conflict",s.getCoordinate());e===ne.NONE&&u.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),n=e}else u.isTrue(i.getLocation(t,Pn.LEFT)===ne.NONE,"found single null side"),i.setLocation(t,Pn.RIGHT,n),i.setLocation(t,Pn.LEFT,n)}}}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}print(t){O.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,s=e.get(n).getLabel().getLocation(t,Pn.LEFT);u.isTrue(s!==ne.NONE,"Found unlabelled area edge");let i=s;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();u.isTrue(n.isArea(t),"Found non-area edge");const s=n.getLocation(t,Pn.LEFT),r=n.getLocation(t,Pn.RIGHT);if(s===r)return!1;if(r!==i)return!1;i=s}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new x(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===ne.NONE&&(this._ptInAreaLocation[t]=Ze.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new w;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===ne.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const s=n.next(),i=s.getLabel();for(let n=0;n<2;n++)if(i.isAnyNull(n)){let r=ne.NONE;if(e[n])r=ne.EXTERIOR;else{const e=s.getCoordinate();r=this.getLocation(n,e,t)}i.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}getClass(){return ci}get interfaces_(){return[]}}ci.constructor_=function(){this._edgeMap=new rt,this._edgeList=null,this._ptInAreaLocation=[ne.NONE,ne.NONE]};class hi extends ci{constructor(){super(),hi.constructor_.apply(this,arguments)}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,e=null,n=this._SCANNING_FOR_INCOMING;for(let s=0;s<this._resultAreaEdgeList.size();s++){const i=this._resultAreaEdgeList.get(s),r=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!r.isInResult())continue;e=r,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new Wn("no outgoing dirEdge found",this.getCoordinate());u.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}insert(t){const e=t;this.insertEdgeEnd(e,e)}getRightmostEdge(){const t=this.getEdges(),e=t.size();if(e<1)return null;const n=t.get(0);if(1===e)return n;const s=t.get(e-1),i=n.getQuadrant(),r=s.getQuadrant();return In.isNorthern(i)&&In.isNorthern(r)?n:In.isNorthern(i)||In.isNorthern(r)?0!==n.getDy()?n:0!==s.getDy()?s:(u.shouldNeverReachHere("found two horizontal edges incident on node"),null):s}print(t){O.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){const n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new x;for(let t=this.iterator();t.hasNext();){const e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}updateLabelling(t){for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,e=null;for(let n=this._edgeList.size()-1;n>=0;n--){const s=this._edgeList.get(n),i=s.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=s}e.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],e=this.findIndex(t),n=t.getDepth(Pn.LEFT),s=t.getDepth(Pn.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==s)throw new Wn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[0],e=arguments[1];let n=arguments[2];for(let s=t;s<e;s++){const t=this._edgeList.get(s);t.setEdgeDepths(Pn.RIGHT,n),n=t.getDepth(Pn.LEFT)}return n}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const e=t.next();e.getLabel().merge(e.getSym().getLabel())}}linkMinimalDirectedEdges(t){let e=null,n=null,s=this._SCANNING_FOR_INCOMING;for(let i=this._resultAreaEdgeList.size()-1;i>=0;i--){const r=this._resultAreaEdgeList.get(i),o=r.getSym();switch(null===e&&r.getEdgeRing()===t&&(e=r),s){case this._SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,s=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(r.getEdgeRing()!==t)continue;n.setNextMin(r),s=this._SCANNING_FOR_INCOMING}}s===this._LINKING_TO_OUTGOING&&(u.isTrue(null!==e,"found null for first outgoing dirEdge"),u.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){const t=arguments[0];let e=0;for(let n=this.iterator();n.hasNext();){n.next().getEdgeRing()===t&&e++}return e}}getLabel(){return this._label}findCoveredLineEdges(){let t=ne.NONE;for(let e=this.iterator();e.hasNext();){const n=e.next(),s=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=ne.INTERIOR;break}if(s.isInResult()){t=ne.EXTERIOR;break}}}if(t===ne.NONE)return null;let e=t;for(let t=this.iterator();t.hasNext();){const n=t.next(),s=n.getSym();n.isLineEdge()?n.getEdge().setCovered(e===ne.INTERIOR):(n.isInResult()&&(e=ne.EXTERIOR),s.isInResult()&&(e=ne.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new Fn(ne.NONE);for(let t=this.iterator();t.hasNext();){const e=t.next().getEdge().getLabel();for(let t=0;t<2;t++){const n=e.getLocation(t);n!==ne.INTERIOR&&n!==ne.BOUNDARY||this._label.setLocation(t,ne.INTERIOR)}}}getClass(){return hi}get interfaces_(){return[]}}hi.constructor_=function(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2};class ui extends Kn{constructor(){super(),ui.constructor_.apply(this,arguments)}createNode(t){return new kn(t,new hi)}getClass(){return ui}get interfaces_(){return[]}}ui.constructor_=function(){};class gi{constructor(){gi.constructor_.apply(this,arguments)}static orientation(t){return 1===X.increasingDirection(t)}static compareOriented(t,e,n,s){const i=e?1:-1,r=s?1:-1,o=e?t.length:-1,l=s?n.length:-1;let a=e?0:t.length-1,c=s?0:n.length-1;for(;;){const e=t[a].compareTo(n[c]);if(0!==e)return e;a+=i,c+=r;const s=a===o,h=c===l;if(s&&!h)return-1;if(!s&&h)return 1;if(s&&h)return 0}}compareTo(t){const e=t;return gi.compareOriented(this._pts,this._orientation,e._pts,e._orientation)}getClass(){return gi}get interfaces_(){return[r]}}gi.constructor_=function(){this._pts=null,this._orientation=null;const t=arguments[0];this._pts=t,this._orientation=gi.orientation(t)};class di{constructor(){di.constructor_.apply(this,arguments)}print(t){t.print("MULTILINESTRING ( ");for(let e=0;e<this._edges.size();e++){const n=this._edges.get(e);e>0&&t.print(","),t.print("(");const s=n.getCoordinates();for(let e=0;e<s.length;e++)e>0&&t.print(","),t.print(s[e].x+" "+s[e].y);t.println(")")}t.print(")  ")}addAll(t){for(let e=t.iterator();e.hasNext();)this.add(e.next())}findEdgeIndex(t){for(let e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){const e=new gi(t.getCoordinates());return this._ocaMap.get(e)}add(t){this._edges.add(t);const e=new gi(t.getCoordinates());this._ocaMap.put(e,t)}getClass(){return di}get interfaces_(){return[]}}di.constructor_=function(){this._edges=new x,this._ocaMap=new rt};class _i{constructor(){_i.constructor_.apply(this,arguments)}processIntersections(t,e,n,s){}isDone(){}getClass(){return _i}get interfaces_(){return[]}}_i.constructor_=function(){};class fi{constructor(){fi.constructor_.apply(this,arguments)}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(fi.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.size()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}getClass(){return fi}get interfaces_(){return[_i]}}fi.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;const t=arguments[0];this._li=t};class pi{constructor(){pi.constructor_.apply(this,arguments)}static depthDelta(t){const e=t.getLocation(0,Pn.LEFT),n=t.getLocation(0,Pn.RIGHT);return e===ne.INTERIOR&&n===ne.EXTERIOR?1:e===ne.EXTERIOR&&n===ne.INTERIOR?-1:0}static convertSegStrings(t){const e=new Ht,n=new x;for(;t.hasNext();){const s=t.next(),i=e.createLineString(s.getCoordinates());n.add(i)}return e.buildGeometry(n)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Fn(t.getLabel()),s.flip()),n.merge(s);const i=pi.depthDelta(s),r=e.getDepthDelta()+i;e.setDepthDelta(r)}else this._edgeList.add(t),t.setDepthDelta(pi.depthDelta(t.getLabel()))}buildSubgraphs(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=t.getRightmostCoordinate(),r=new oi(n).getDepth(i);t.computeDepth(r),t.findResultEdges(),n.add(t),e.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){const e=new x;for(let n=t.getNodes().iterator();n.hasNext();){const t=n.next();if(!t.isVisited()){const n=new Qs;n.create(t),e.add(n)}}return Ee.sort(e,Ee.reverseOrder()),e}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;const e=new Ys,n=new te;return n.setPrecisionModel(t),e.setSegmentIntersector(new fi(n)),e}buffer(t,e){let n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();const s=new ri(n,this._bufParams),i=new ai(t,e,s).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new Zn(new ui),this._graph.addEdges(this._edgeList.getEdges());const r=this.createSubgraphs(this._graph),o=new ei(this._geomFact);this.buildSubgraphs(r,o);const l=o.getPolygons();return l.size()<=0?this.createEmptyResultGeometry():this._geomFact.buildGeometry(l)}computeNodedEdges(t,e){const n=this.getNoder(e);n.computeNodes(t);for(let t=n.getNodedSubstrings().iterator();t.hasNext();){const e=t.next(),n=e.getCoordinates();if(2===n.length&&n[0].equals2D(n[1]))continue;const s=e.getData(),i=new Un(e.getCoordinates(),new Fn(s));this.insertUniqueEdge(i)}}setNoder(t){this._workingNoder=t}getClass(){return pi}get interfaces_(){return[]}}pi.constructor_=function(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new di;const t=arguments[0];this._bufParams=t};class mi{constructor(){mi.constructor_.apply(this,arguments)}checkEndPtVertexIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length){const t=arguments[0];for(let e=arguments[1].iterator();e.hasNext();){const n=e.next().getCoordinates();for(let e=1;e<n.length-1;e++)if(n[e].equals(t))throw new c("found endpt/interior pt intersection at index "+e+" :pt "+t)}}}checkInteriorIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();for(let t=this._segStrings.iterator();t.hasNext();){const n=t.next();this.checkInteriorIntersections(e,n)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates(),s=e.getCoordinates();for(let i=0;i<n.length-1;i++)for(let n=0;n<s.length-1;n++)this.checkInteriorIntersections(t,i,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,i,r)||this.hasInteriorIntersection(this._li,o,l)))throw new c("found non-noded intersection at "+i+"-"+r+" and "+o+"-"+l)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();this.checkCollapses(e)}else if(1===arguments.length){const t=arguments[0].getCoordinates();for(let e=0;e<t.length-2;e++)this.checkCollapse(t[e],t[e+1],t[e+2])}}hasInteriorIntersection(t,e,n){for(let s=0;s<t.getIntersectionNum();s++){const i=t.getIntersection(s);if(!i.equals(e)&&!i.equals(n))return!0}return!1}checkCollapse(t,e,n){if(t.equals(n))throw new c("found non-noded collapse at "+mi.fact.createLineString([t,e,n]))}getClass(){return mi}get interfaces_(){return[]}}mi.constructor_=function(){this._li=new te,this._segStrings=null;const t=arguments[0];this._segStrings=t},mi.fact=new Ht;class yi{constructor(){yi.constructor_.apply(this,arguments)}intersectsScaled(t,e){const n=Math.min(t.x,e.x),s=Math.max(t.x,e.x),i=Math.min(t.y,e.y),r=Math.max(t.y,e.y),o=this._maxx<n||this._minx>s||this._maxy<i||this._miny>r;if(o)return!1;const l=this.intersectsToleranceSquare(t,e);return u.isTrue(!(o&&l),"Found bad envelope test"),l}initCorners(t){this._minx=t.x-.5,this._maxx=t.x+.5,this._miny=t.y-.5,this._maxy=t.y+.5,this._corner[0]=new g(this._maxx,this._maxy),this._corner[1]=new g(this._minx,this._maxy),this._corner[2]=new g(this._minx,this._miny),this._corner[3]=new g(this._maxx,this._miny)}intersects(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){const t=yi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new N(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,e){let n=!1,s=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(s=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!s)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))}addSnappedNode(t,e){const n=t.getCoordinate(e),s=t.getCoordinate(e+1);return!!this.intersects(n,s)&&(t.addIntersection(this.getCoordinate(),e),!0)}getClass(){return yi}get interfaces_(){return[]}}yi.constructor_=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;const t=arguments[0],e=arguments[1],s=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=s,e<=0)throw new n("Scale factor must be non-zero");1!==e&&(this._pt=new g(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new g,this._p1Scaled=new g),this.initCorners(this._pt)},yi.SAFE_ENV_EXPANSION_FACTOR=.75;class xi{constructor(){xi.constructor_.apply(this,arguments)}select(){if(1===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}}getClass(){return xi}get interfaces_(){return[]}}xi.constructor_=function(){this.selectedSegment=new ee};class Ei{constructor(){Ei.constructor_.apply(this,arguments)}snap(){if(1===arguments.length){const t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getSafeEnvelope(),i=new Ii(t,e,n);return this._index.query(s,new class{get interfaces_(){return[Ae]}visitItem(t){t.select(s,i)}}),i.isNodeAdded()}}getClass(){return Ei}get interfaces_(){return[]}}class Ii extends xi{constructor(){super(),Ii.constructor_.apply(this,arguments)}isNodeAdded(){return this._isNodeAdded}select(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof qs))return super.select.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=t.getContext();if(null!==this._parentEdge&&n===this._parentEdge&&e===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(n,e)}}getClass(){return Ii}get interfaces_(){return[]}}Ii.constructor_=function(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n},Ei.HotPixelSnapAction=Ii,Ei.constructor_=function(){this._index=null;const t=arguments[0];this._index=t};class Ni{constructor(){Ni.constructor_.apply(this,arguments)}processIntersections(t,e,n,s){if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}getClass(){return Ni}get interfaces_(){return[_i]}}Ni.constructor_=function(){this._li=null,this._interiorIntersections=null;const t=arguments[0];this._li=t,this._interiorIntersections=new x};class Ci{constructor(){Ci.constructor_.apply(this,arguments)}checkCorrectness(t){const e=Fs.getNodedSubstrings(t),n=new mi(e);try{n.checkValid()}catch(t){if(!(t instanceof C))throw t;t.printStackTrace()}}getNodedSubstrings(){return Fs.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,e){const n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}findInteriorIntersections(t,e){const n=new Ni(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}computeVertexSnaps(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.computeVertexSnaps(e)}}else if(arguments[0]instanceof Fs){const t=arguments[0],e=t.getCoordinates();for(let n=0;n<e.length;n++){const s=new yi(e[n],this._scaleFactor,this._li);this._pointSnapper.snap(s,t,n)&&t.addIntersection(e[n],n)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new Ys,this._pointSnapper=new Ei(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=new yi(t,this._scaleFactor,this._li);this._pointSnapper.snap(n)}}getClass(){return Ci}get interfaces_(){return[Vs]}}Ci.constructor_=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;const t=arguments[0];this._pm=t,this._li=new te,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()};class Si{constructor(){Si.constructor_.apply(this,arguments)}static bufferOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Si(t).getResultGeometry(e)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof q&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Si(t);return s.setQuadrantSegments(n),s.getResultGeometry(e)}if(arguments[2]instanceof js&&arguments[0]instanceof q&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return new Si(t,n).getResultGeometry(e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new Si(t);return i.setQuadrantSegments(n),i.setEndCapStyle(s),i.getResultGeometry(e)}}static precisionScaleFactor(t,e,n){const s=t.getEnvelopeInternal(),i=M.max(Math.abs(s.getMaxX()),Math.abs(s.getMaxY()),Math.abs(s.getMinX()),Math.abs(s.getMinY()))+2*(e>0?e:0),r=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,r)}bufferFixedPrecision(t){const e=new ks(new Ci(new kt(1)),t.getScale()),n=new pi(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0===arguments.length){for(let t=Si.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof Wn))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){const t=arguments[0],e=Si.precisionScaleFactor(this._argGeom,this._distance,t),n=new kt(e);this.bufferFixedPrecision(n)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;const t=this._argGeom.getFactory().getPrecisionModel();t.getType()===kt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{const t=new pi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof c))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}getClass(){return Si}get interfaces_(){return[]}}Si.constructor_=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new js,this._resultGeometry=null,this._saveException=null,1===arguments.length){const t=arguments[0];this._argGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._argGeom=t,this._bufParams=e}},Si.CAP_ROUND=js.CAP_ROUND,Si.CAP_BUTT=js.CAP_FLAT,Si.CAP_FLAT=js.CAP_FLAT,Si.CAP_SQUARE=js.CAP_SQUARE,Si.MAX_PRECISION_DIGITS=12;var wi=Object.freeze({__proto__:null,BufferOp:Si,BufferParameters:js});class Li{constructor(){Li.constructor_.apply(this,arguments)}isInsideArea(){return this._segIndex===Li.INSIDE_AREA}getCoordinate(){return this._pt}getGeometryComponent(){return this._component}getSegmentIndex(){return this._segIndex}getClass(){return Li}get interfaces_(){return[]}}Li.constructor_=function(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){const t=arguments[0],e=arguments[1];Li.constructor_.call(this,t,Li.INSIDE_AREA,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._component=t,this._segIndex=e,this._pt=n}},Li.INSIDE_AREA=-1;class Ti{constructor(){Ti.constructor_.apply(this,arguments)}static getLocations(t){const e=new x;return t.apply(new Ti(e)),e}filter(t){(t instanceof Pt||t instanceof Tt||t instanceof bt)&&this._locations.add(new Li(t,0,t.getCoordinate()))}getClass(){return Ti}get interfaces_(){return[gt]}}Ti.constructor_=function(){this._locations=null;const t=arguments[0];this._locations=t};class Ri{constructor(){Ri.constructor_.apply(this,arguments)}static distance(t,e){return new Ri(t,e).distance()}static isWithinDistance(t,e,n){return!(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>n)&&new Ri(t,e,n).distance()<=n}static nearestPoints(t,e){return new Ri(t,e).nearestPoints()}computeContainmentDistance(){if(0===arguments.length){const t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._geom[t];if(n.getDimension()<2)return null;const s=1-t,i=Ne.getPolygons(n);if(i.size()>0){const n=Ti.getLocations(this._geom[s]);if(this.computeContainmentDistance(n,i,e),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[s]=e[0],this._minDistanceLocation[t]=e[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&_(arguments[0],m)&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++)if(this.computeContainmentDistance(i,e.get(t),n),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Li&&arguments[1]instanceof bt){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getCoordinate();if(ne.EXTERIOR!==this._ptLocator.locate(s,e))return this._minDistance=0,n[0]=t,n[1]=new Li(e,s),null}}computeMinDistanceLinesPoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){const t=new Array(2).fill(null),e=xe.getLines(this._geom[0]),n=xe.getLines(this._geom[1]),s=Ie.getPoints(this._geom[0]),i=Ie.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,i,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,s,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(s,i,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){return this.computeMinDistance(),[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof Tt&&arguments[1]instanceof Pt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinate();for(let r=0;r<s.length-1;r++){const o=D.pointToSegment(i,s[r],s[r+1]);if(o<this._minDistance){this._minDistance=o;const l=new ee(s[r],s[r+1]).closestPoint(i);n[0]=new Li(t,r,l),n[1]=new Li(e,0,i)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Tt&&arguments[1]instanceof Tt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinates();for(let r=0;r<s.length-1;r++)for(let o=0;o<i.length-1;o++){const l=D.segmentToSegment(s[r],s[r+1],i[o],i[o+1]);if(l<this._minDistance){this._minDistance=l;const a=new ee(s[r],s[r+1]),c=new ee(i[o],i[o+1]),h=a.closestPoints(c);n[0]=new Li(t,r,h[0]),n[1]=new Li(e,o,h[1])}if(this._minDistance<=this._terminateDistance)return null}}}computeMinDistancePoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t),r=i.getCoordinate().distance(s.getCoordinate());if(r<this._minDistance&&(this._minDistance=r,n[0]=new Li(i,0,i.getCoordinate()),n[1]=new Li(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new n("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}getClass(){return Ri}get interfaces_(){return[]}}Ri.constructor_=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new _n,this._minDistanceLocation=null,this._minDistance=i.MAX_VALUE,2===arguments.length){const t=arguments[0],e=arguments[1];Ri.constructor_.call(this,t,e,0)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e,this._terminateDistance=n}};var Pi=Object.freeze({__proto__:null,DistanceOp:Ri});class vi{constructor(){vi.constructor_.apply(this,arguments)}getCoordinates(){if(null===this._coordinates){let t=0,e=0;const n=new I;for(let s=this._directedEdges.iterator();s.hasNext();){const i=s.next();i.getEdgeDirection()?t++:e++,n.add(i.getEdge().getLine().getCoordinates(),!1,i.getEdgeDirection())}this._coordinates=n.toCoordinateArray(),e>t&&X.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}getClass(){return vi}get interfaces_(){return[]}}vi.constructor_=function(){this._factory=null,this._directedEdges=new x,this._coordinates=null;const t=arguments[0];this._factory=t};class Oi{constructor(){Oi.constructor_.apply(this,arguments)}static getComponentWithVisitedState(t,e){for(;t.hasNext();){const n=t.next();if(n.isVisited()===e)return n}return null}static setVisited(t,e){for(;t.hasNext();){t.next().setVisited(e)}}static setMarked(t,e){for(;t.hasNext();){t.next().setMarked(e)}}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}getClass(){return Oi}get interfaces_(){return[]}}Oi.constructor_=function(){this._isMarked=!1,this._isVisited=!1,this._data=null};class bi extends Oi{constructor(){super(),bi.constructor_.apply(this,arguments)}static toEdges(t){const e=new x;for(let n=t.iterator();n.hasNext();)e.add(n.next()._parentEdge);return e}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){const e=this.getClass().getName(),n=e.lastIndexOf("."),s=e.substring(n+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){const e=t;return this.compareDirection(e)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}getClass(){return bi}get interfaces_(){return[r]}}bi.constructor_=function(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._from=t,this._to=e,this._edgeDirection=s,this._p0=t.getCoordinate(),this._p1=n;const i=this._p1.x-this._p0.x,r=this._p1.y-this._p0.y;this._quadrant=In.quadrant(i,r),this._angle=Math.atan2(r,i)}};class Mi extends bi{constructor(){super(),Mi.constructor_.apply(this,arguments)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(u.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}getClass(){return Mi}get interfaces_(){return[]}}Mi.constructor_=function(){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];bi.constructor_.call(this,t,e,n,s)};class Di extends Oi{constructor(){super(),Di.constructor_.apply(this,arguments)}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,e){this._dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)}getDirEdge(){if(Number.isInteger(arguments[0])){const t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof Fi){const t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}getClass(){return Di}get interfaces_(){return[]}}Di.constructor_=function(){if(this._dirEdge=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}};class Ai{constructor(){Ai.constructor_.apply(this,arguments)}getNextEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e+1))}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(Ee.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e-1))}getIndex(){if(arguments[0]instanceof Di){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e).getEdge()===t)return e}return-1}if(arguments[0]instanceof bi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e)===t)return e}return-1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}getClass(){return Ai}get interfaces_(){return[]}}Ai.constructor_=function(){this._outEdges=new x,this._sorted=!1};class Fi extends Oi{constructor(){super(),Fi.constructor_.apply(this,arguments)}static getEdgesBetween(t,e){const n=new J(bi.toEdges(t.getOutEdges().getEdges())),s=bi.toEdges(e.getOutEdges().getEdges());return n.retainAll(s),n}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0===arguments.length)this._pt=null;else if(1===arguments.length){const t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}getClass(){return Fi}get interfaces_(){return[]}}Fi.constructor_=function(){if(this._pt=null,this._deStar=null,1===arguments.length){const t=arguments[0];Fi.constructor_.call(this,t,new Ai)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt=t,this._deStar=e}};class Gi extends Di{constructor(){super(),Gi.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return Gi}get interfaces_(){return[]}}Gi.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class qi{constructor(){qi.constructor_.apply(this,arguments)}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}getClass(){return qi}get interfaces_(){return[]}}qi.constructor_=function(){this._nodeMap=new rt};class Bi{constructor(){Bi.constructor_.apply(this,arguments)}findNodesOfDegree(t){const e=new x;for(let n=this.nodeIterator();n.hasNext();){const s=n.next();s.getDegree()===t&&e.add(s)}return e}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Di){const t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof bi){const t=arguments[0],e=t.getSym();null!==e&&e.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof Fi){const t=arguments[0];for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next(),n=t.getSym();null!==n&&this.remove(n),this._dirEdges.remove(t);const s=t.getEdge();null!==s&&this._edges.remove(s)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Di){const t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof bi){const t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof Fi){const t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Di){const t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof bi){const t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}getClass(){return Bi}get interfaces_(){return[]}}Bi.constructor_=function(){this._edges=new J,this._dirEdges=new J,this._nodeMap=new qi};class Vi extends Bi{constructor(){super(),Vi.constructor_.apply(this,arguments)}addEdge(t){if(t.isEmpty())return null;const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Mi(i,r,e[1],!0),l=new Mi(r,i,e[e.length-2],!1),a=new Gi(t);a.setDirectedEdges(o,l),this.add(a)}getNode(t){let e=this.findNode(t);return null===e&&(e=new Fi(t),this.add(e)),e}getClass(){return Vi}get interfaces_(){return[]}}Vi.constructor_=function(){};class zi{constructor(){zi.constructor_.apply(this,arguments)}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();e.isMarked()||(u.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let e=t.getOutEdges().iterator();e.hasNext();){const t=e.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;Oi.setMarked(this._graph.nodeIterator(),!1),Oi.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new x,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new x;for(let t=this._edgeStrings.iterator();t.hasNext();){const e=t.next();this._mergedLineStrings.add(e.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){const e=new vi(this._factory);let n=t;do{e.add(n),n.getEdge().setMarked(!0),n=n.getNext()}while(null!==n&&n!==t);return e}add(){if(arguments[0]instanceof q){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);n instanceof Tt&&this.addLineString(n)}}else if(_(arguments[0],f)){const t=arguments[0];this._mergedLineStrings=null;for(let e=t.iterator();e.hasNext();){const t=e.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}getClass(){return zi}get interfaces_(){return[]}}zi.constructor_=function(){this._graph=new Vi,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null};class Yi{constructor(){Yi.constructor_.apply(this,arguments)}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}getClass(){return Yi}get interfaces_(){return[]}}Yi.constructor_=function(){this._parentGraph=null,this._edges=new J,this._dirEdges=new x,this._nodeMap=new qi;const t=arguments[0];this._parentGraph=t};class Ui{constructor(){Ui.constructor_.apply(this,arguments)}addReachable(t,e){const n=new on;for(n.add(t);!n.empty();){const t=n.pop();this.addEdges(t,n,e)}}findSubgraph(t){const e=new Yi(this._graph);return this.addReachable(t,e),e}getConnectedSubgraphs(){const t=new x;Oi.setVisited(this._graph.nodeIterator(),!1);for(let e=this._graph.edgeIterator();e.hasNext();){const n=e.next().getDirEdge(0).getFromNode();n.isVisited()||t.add(this.findSubgraph(n))}return t}addEdges(t,e,n){t.setVisited(!0);for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();n.add(t.getEdge());const i=t.getToNode();i.isVisited()||e.push(i)}}getClass(){return Ui}get interfaces_(){return[]}}Ui.constructor_=function(){this._graph=null;const t=arguments[0];this._graph=t};class ki{constructor(){ki.constructor_.apply(this,arguments)}static findUnvisitedBestOrientedDE(t){let e=null,n=null;for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();t.getEdge().isVisited()||(n=t,t.getEdgeDirection()&&(e=t))}return null!==e?e:n}static findLowestDegreeNode(t){let e=L.MAX_VALUE,n=null;for(let s=t.nodeIterator();s.hasNext();){const t=s.next();(null===n||t.getDegree()<e)&&(e=t.getDegree(),n=t)}return n}static isSequenced(t){if(!(t instanceof ft))return!0;const e=t,n=new at;let s=null;const i=new x;for(let t=0;t<e.getNumGeometries();t++){const r=e.getGeometryN(t),o=r.getCoordinateN(0),l=r.getCoordinateN(r.getNumPoints()-1);if(n.contains(o))return!1;if(n.contains(l))return!1;null!==s&&(o.equals(s)||(n.addAll(i),i.clear())),i.add(o),i.add(l),s=l}return!0}static reverse(t){const e=t.getCoordinates(),n=new Array(e.length).fill(null),s=e.length;for(let t=0;t<s;t++)n[s-1-t]=new g(e[t]);return t.getFactory().createLineString(n)}static sequence(t){const e=new ki;return e.add(t),e.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let e=0;for(let n=t.nodeIterator();n.hasNext();){n.next().getDegree()%2==1&&e++}return e<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;const t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;const e=this._sequencedGeometry.getNumGeometries();u.isTrue(this._lineCount===e,"Lines were missing from result"),u.isTrue(this._sequencedGeometry instanceof Tt||this._sequencedGeometry instanceof ft,"Result is not lineal")}findSequences(){const t=new x;for(let e=new Ui(this._graph).getConnectedSubgraphs().iterator();e.hasNext();){const n=e.next();if(!this.hasSequence(n))return null;{const e=this.findSequence(n);t.add(e)}}return t}addReverseSubpath(t,e,n){const s=t.getToNode();let i=null;for(;;){e.add(t.getSym()),t.getEdge().setVisited(!0),i=t.getFromNode();const n=ki.findUnvisitedBestOrientedDE(i);if(null===n)break;t=n.getSym()}n&&u.isTrue(i===s,"path not contiguous")}findSequence(t){Oi.setVisited(t.edgeIterator(),!1);const e=ki.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),n=new Zs,s=n.listIterator();for(this.addReverseSubpath(e,s,!1);s.hasPrevious();){const t=s.previous(),e=ki.findUnvisitedBestOrientedDE(t.getFromNode());null!==e&&this.addReverseSubpath(e.getSym(),s,!0)}return this.orient(n)}reverse(t){const e=new Zs;for(let n=t.iterator();n.hasNext();){const t=n.next();e.addFirst(t.getSym())}return e}orient(t){const e=t.get(0),n=t.get(t.size()-1),s=e.getFromNode(),i=n.getToNode();let r=!1;if(1===s.getDegree()||1===i.getDegree()){let t=!1;1===n.getToNode().getDegree()&&!1===n.getEdgeDirection()&&(t=!0,r=!0),1===e.getFromNode().getDegree()&&!0===e.getEdgeDirection()&&(t=!0,r=!1),t||1===e.getFromNode().getDegree()&&(r=!0)}return r?this.reverse(t):t}buildSequencedGeometry(t){const e=new x;for(let n=t.iterator();n.hasNext();){for(let t=n.next().iterator();t.hasNext();){const n=t.next(),s=n.getEdge().getLine();let i=s;n.getEdgeDirection()||s.isClosed()||(i=ki.reverse(s)),e.add(i)}}return 0===e.size()?this._factory.createMultiLineString(new Array(0).fill(null)):this._factory.buildGeometry(e)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof q){arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Tt&&this.addLine(t)}})}}getClass(){return ki}get interfaces_(){return[]}}ki.constructor_=function(){this._graph=new Vi,this._factory=new Ht,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1};var Xi=Object.freeze({__proto__:null,LineMerger:zi,LineSequencer:ki});class Hi{constructor(){Hi.constructor_.apply(this,arguments)}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,e){const n=this._isClosed?t.size()-1:t.size();for(let s=0;s<n;s++){const n=t.get(s),i=this.findSnapForVertex(n,e);null!==i&&(t.set(s,new g(i)),0===s&&this._isClosed&&t.set(t.size()-1,new g(i)))}}findSnapForVertex(t,e){for(let n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null}snapTo(t){const e=new I(this._srcPts);return this.snapVertices(e,t),this.snapSegments(e,t),e.toCoordinateArray()}snapSegments(t,e){if(0===e.length)return null;let n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(let s=0;s<n;s++){const n=e[s],i=this.findSegmentIndexToSnap(n,t);i>=0&&t.add(i+1,new g(n),!1)}}findSegmentIndexToSnap(t,e){let n=i.MAX_VALUE,s=-1;for(let i=0;i<e.size()-1;i++){if(this._seg.p0=e.get(i),this._seg.p1=e.get(i+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}const r=this._seg.distance(t);r<this._snapTolerance&&r<n&&(n=r,s=i)}return s}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}getClass(){return Hi}get interfaces_(){return[]}}Hi.constructor_=function(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new ee,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Tt&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];Hi.constructor_.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this._srcPts=t,this._isClosed=Hi.isClosed(t),this._snapTolerance=e}};class Wi{constructor(){Wi.constructor_.apply(this,arguments)}static snap(t,e,n){const s=new Array(2).fill(null),i=new Wi(t);s[0]=i.snapTo(e,n);const r=new Wi(e);return s[1]=r.snapTo(s[0],n),s}static computeOverlaySnapTolerance(){if(1===arguments.length){const t=arguments[0];let e=Wi.computeSizeBasedSnapTolerance(t);const n=t.getPrecisionModel();if(n.getType()===kt.FIXED){const t=1/n.getScale()*2/1.415;t>e&&(e=t)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Math.min(Wi.computeOverlaySnapTolerance(t),Wi.computeOverlaySnapTolerance(e))}}static computeSizeBasedSnapTolerance(t){const e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*Wi.SNAP_PRECISION_FACTOR}static snapToSelf(t,e,n){return new Wi(t).snapToSelf(e,n)}snapTo(t,e){const n=this.extractTargetCoordinates(t);return new ji(e,n).transform(this._srcGeom)}snapToSelf(t,e){const n=this.extractTargetCoordinates(this._srcGeom),s=new ji(t,n,!0).transform(this._srcGeom);let i=s;return e&&_(i,Ot)&&(i=s.buffer(0)),i}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){const e=new at,n=t.getCoordinates();for(let t=0;t<n.length;t++)e.add(n[t]);return e.toArray(new Array(0).fill(null))}computeMinimumSegmentLength(t){let e=i.MAX_VALUE;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);s<e&&(e=s)}return e}getClass(){return Wi}get interfaces_(){return[]}}Wi.constructor_=function(){this._srcGeom=null;const t=arguments[0];this._srcGeom=t},Wi.SNAP_PRECISION_FACTOR=1e-9;class ji extends me{constructor(){super(),ji.constructor_.apply(this,arguments)}snapLine(t,e){const n=new Hi(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)}transformCoordinates(t,e){const n=t.toCoordinateArray(),s=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(s)}getClass(){return ji}get interfaces_(){return[]}}ji.constructor_=function(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2===arguments.length){const t=arguments[0],e=arguments[1];this._snapTolerance=t,this._snapPts=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._snapTolerance=t,this._snapPts=e,this._isSelfSnap=n}};var Ki=Object.freeze({__proto__:null,GeometrySnapper:Wi,LineStringSnapper:Hi});class Zi{constructor(){Zi.constructor_.apply(this,arguments)}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Ms.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return Jt.toLineString(new zt(this._pts))}getClass(){return Zi}get interfaces_(){return[Ds]}}Zi.constructor_=function(){this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e};class Qi{constructor(){Qi.constructor_.apply(this,arguments)}static createAllIntersectionsFinder(t){const e=new Qi(t);return e.setFindAllIntersections(!0),e}static createAnyIntersectionFinder(t){return new Qi(t)}static createIntersectionCounter(t){const e=new Qi(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}getInteriorIntersection(){return this._interiorIntersection}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}processIntersections(t,e,n,s){if(!this._findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===s)return null;if(this._isCheckEndSegmentsOnly){if(!(this.isEndSegment(t,e)||this.isEndSegment(n,s)))return null}const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=i,this._intSegments[1]=r,this._intSegments[2]=o,this._intSegments[3]=l,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}isEndSegment(t,e){return 0===e||e>=t.size()-2}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}getClass(){return Qi}get interfaces_(){return[_i]}}Qi.constructor_=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new x,this._intersectionCount=0,this._keepIntersections=!0;const t=arguments[0];this._li=t,this._interiorIntersection=null};class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static computeIntersections(t){const e=new Ji(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new Qi(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);const t=new Ys;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new Wn(this.getErrorMessage(),this._segInt.getInteriorIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";const t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Jt.toLineString(t[0],t[1])+" and "+Jt.toLineString(t[2],t[3])}getClass(){return Ji}get interfaces_(){return[]}}Ji.constructor_=function(){this._li=new te,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;const t=arguments[0];this._segStrings=t};class $i{constructor(){$i.constructor_.apply(this,arguments)}static toSegmentStrings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Zi(t.getCoordinates(),t))}return e}static checkValid(t){new $i(t).checkValid()}checkValid(){this._nv.checkValid()}getClass(){return $i}get interfaces_(){return[]}}$i.constructor_=function(){this._nv=null;const t=arguments[0];this._nv=new Ji($i.toSegmentStrings(t))};class tr{constructor(){tr.constructor_.apply(this,arguments)}collectLines(t){for(let e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){const n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}}labelIsolatedLine(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,e,n){const s=t.getLabel(),i=t.getEdge();t.isLineEdge()&&(t.isVisited()||!cr.isResultOfOp(s,e)||i.isCovered()||(n.add(i),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getEdge();if(e.isLineEdge()&&!n.isCoveredSet()){const t=this._op.isCoveredByA(e.getCoordinate());n.setCovered(t)}}}labelIsolatedLines(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel();t.isIsolated()&&(n.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){const e=t.next(),n=(e.getLabel(),this._geometryFactory.createLineString(e.getCoordinates()));this._resultLineList.add(n),e.setInResult(!0)}}collectBoundaryTouchEdge(t,e,n){const s=t.getLabel();return t.isLineEdge()||t.isVisited()||t.isInteriorAreaEdge()||t.getEdge().isInResult()?null:(u.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(cr.isResultOfOp(s,e)&&e===cr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))}getClass(){return tr}get interfaces_(){return[]}}tr.constructor_=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new x,this._resultLineList=new x;const t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n};class er{constructor(){er.constructor_.apply(this,arguments)}filterCoveredNodeToPoint(t){const e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){const t=this._geometryFactory.createPoint(e);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let e=this._op.getGraph().getNodes().iterator();e.hasNext();){const n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===cr.INTERSECTION))){const e=n.getLabel();cr.isResultOfOp(e,t)&&this.filterCoveredNodeToPoint(n)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}getClass(){return er}get interfaces_(){return[]}}er.constructor_=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new x;const t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e};class nr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new s,this._commonSignExp=null}getCommon(){return i.longBitsToDouble(this._commonBits)}add(t){const e=i.doubleToLongBits(t);return this._isFirst?(this._commonBits=e,this._commonSignExp=nr.signExpBits(this._commonBits),this._isFirst=!1,null):nr.signExpBits(e)!==this._commonSignExp?(this._commonBits.high=0,this._commonBits.low=0,null):(this._commonMantissaBitsCount=nr.numCommonMostSigMantissaBits(this._commonBits,e),void(this._commonBits=nr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))))}toString(){if(1===arguments.length){const t=arguments[0],e=i.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+s.toBinaryString(t),r=n.substring(n.length-64);return r.substring(0,1)+"  "+r.substring(1,12)+"(exp) "+r.substring(12)+" [ "+e+" ]"}}getClass(){return nr}get interfaces_(){return[]}static getBit(t,e){const n=1<<e%32;return e<32?0!=(t.low&n)?1:0:0!=(t.high&n)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,e){let n="low";if(e>32&&(t.low=0,e%=32,n="high"),e>0){const s=e<32?~((1<<e)-1):0;t[n]&=s}return t}static numCommonMostSigMantissaBits(t,e){let n=0;for(let s=52;s>=0;s--){if(nr.getBit(t,s)!==nr.getBit(e,s))return n;n++}return 52}}class sr{constructor(){sr.constructor_.apply(this,arguments)}addCommonBits(t){const e=new rr(this._commonCoord);t.apply(e),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;const e=new g(this._commonCoord);e.x=-e.x,e.y=-e.y;const n=new rr(e);return t.apply(n),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}getClass(){return sr}get interfaces_(){return[]}}class ir{constructor(){ir.constructor_.apply(this,arguments)}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new g(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}getClass(){return ir}get interfaces_(){return[B]}}ir.constructor_=function(){this._commonBitsX=new nr,this._commonBitsY=new nr};class rr{constructor(){rr.constructor_.apply(this,arguments)}filter(t,e){const n=t.getOrdinate(e,0)+this.trans.x,s=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}isDone(){return!1}isGeometryChanged(){return!0}getClass(){return rr}get interfaces_(){return[dt]}}rr.constructor_=function(){this.trans=null;const t=arguments[0];this.trans=t},sr.CommonCoordinateFilter=ir,sr.Translater=rr,sr.constructor_=function(){this._commonCoord=null,this._ccFilter=new ir};class or{constructor(){or.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new or(t,e).getResultGeometry(n)}static union(t,e){return or.overlayOp(t,e,cr.UNION)}static intersection(t,e){return or.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){return or.overlayOp(t,e,cr.SYMDIFFERENCE)}static difference(t,e){return or.overlayOp(t,e,cr.DIFFERENCE)}selfSnap(t){return new Wi(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new sr,this._cbr.add(t[0]),this._cbr.add(t[1]);const e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){const e=this.snap(this._geom),n=cr.overlayOp(e[0],e[1],t);return this.prepareResult(n)}checkValid(t){t.isValid()||O.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=Wi.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){const e=this.removeCommonBits(t);return Wi.snap(e[0],e[1],this._snapTolerance)}getClass(){return or}get interfaces_(){return[]}}or.constructor_=function(){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null;const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()};class lr{constructor(){lr.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new lr(t,e).getResultGeometry(n)}static union(t,e){return lr.overlayOp(t,e,cr.UNION)}static intersection(t,e){return lr.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){return lr.overlayOp(t,e,cr.SYMDIFFERENCE)}static difference(t,e){return lr.overlayOp(t,e,cr.DIFFERENCE)}getResultGeometry(t){let e=null,n=!1,s=null;try{e=cr.overlayOp(this._geom[0],this._geom[1],t),!0&&(n=!0)}catch(t){if(!(t instanceof c))throw t;s=t}if(!n)try{e=or.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof c?s:t}return e}getClass(){return lr}get interfaces_(){return[]}}lr.constructor_=function(){this._geom=new Array(2).fill(null);const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e};class ar{constructor(){ar.constructor_.apply(this,arguments)}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}getClass(){return ar}get interfaces_(){return[]}}ar.constructor_=function(){if(this._li=new te,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Qn(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Qn(0,t,n),this._arg[1]=new Qn(1,e,n)}};class cr extends ar{constructor(){super(),cr.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new cr(t,e).getResultGeometry(n)}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.UNION)}static intersection(t,e){if(t.isEmpty()||e.isEmpty())return cr.createEmptyResult(cr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){const n=e;return ge.map(t,new class{get interfaces_(){return[fe]}map(t){return cr.intersection(t,n)}})}return lr.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.SYMDIFFERENCE)}static resultDimension(t,e,n){const s=e.getDimension(),i=n.getDimension();let r=-1;switch(t){case cr.INTERSECTION:r=Math.min(s,i);break;case cr.UNION:r=Math.max(s,i);break;case cr.DIFFERENCE:r=s;break;case cr.SYMDIFFERENCE:r=Math.max(s,i)}return r}static createEmptyResult(t,e,n,s){let i=null;switch(cr.resultDimension(t,e,n)){case-1:i=s.createGeometryCollection();break;case 0:i=s.createPoint();break;case 1:i=s.createLineString();break;case 2:i=s.createPolygon()}return i}static difference(t,e){if(t.isEmpty())return cr.createEmptyResult(cr.DIFFERENCE,t,e,t.getFactory());if(e.isEmpty())return t.copy();if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.DIFFERENCE)}static isResultOfOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(0),s=t.getLocation(1);return cr.isResultOfOp(n,s,e)}if(3===arguments.length){let t=arguments[0],e=arguments[1];const n=arguments[2];switch(t===ne.BOUNDARY&&(t=ne.INTERIOR),e===ne.BOUNDARY&&(e=ne.INTERIOR),n){case cr.INTERSECTION:return t===ne.INTERIOR&&e===ne.INTERIOR;case cr.UNION:return t===ne.INTERIOR||e===ne.INTERIOR;case cr.DIFFERENCE:return t===ne.INTERIOR&&e!==ne.INTERIOR;case cr.SYMDIFFERENCE:return t===ne.INTERIOR&&e!==ne.INTERIOR||t!==ne.INTERIOR&&e===ne.INTERIOR}return!1}}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Fn(t.getLabel()),s.flip());const i=e.getDepth();i.isNull()&&i.add(n),i.add(s),n.merge(s)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,e,n,s){const i=new x;return i.addAll(t),i.addAll(e),i.addAll(n),i.isEmpty()?cr.createEmptyResult(s,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(i)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}}isCovered(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(this._ptLocator.locate(t,e)!==ne.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){const t=new x;for(let e=this._edgeList.iterator();e.hasNext();){const n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);const e=new x;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),$i.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();const n=new ei(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();const s=new tr(this,this._geomFact,this._ptLocator);this._resultLineList=s.build(t);const i=new er(this,this._geomFact,this._ptLocator);this._resultPointList=i.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)}copyPoints(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let e=this._graph.getEdgeEnds().iterator();e.hasNext();){const n=e.next(),s=n.getLabel();s.isArea()&&!n.isInteriorAreaEdge()&&cr.isResultOfOp(s.getLocation(0,Pn.RIGHT),s.getLocation(1,Pn.RIGHT),t)&&n.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){const e=t.next(),n=e.getLabel(),s=e.getDepth();if(!s.isNull()){s.normalize();for(let t=0;t<2;t++)n.isNull(t)||!n.isArea()||s.isNull(t)||(0===s.getDelta(t)?n.toLine(t):(u.isTrue(!s.isNull(t,Pn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(t,Pn.LEFT,s.getLocation(t,Pn.LEFT)),u.isTrue(!s.isNull(t,Pn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(t,Pn.RIGHT,s.getLocation(t,Pn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}getClass(){return cr}get interfaces_(){return[]}}cr.constructor_=function(){this._ptLocator=new _n,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new di,this._resultPolyList=new x,this._resultLineList=new x,this._resultPointList=new x;const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e),this._graph=new Zn(new ui),this._geomFact=t.getFactory()},cr.INTERSECTION=1,cr.UNION=2,cr.DIFFERENCE=3,cr.SYMDIFFERENCE=4;var hr=Object.freeze({__proto__:null,snap:Ki,OverlayOp:cr});class ur extends bi{constructor(){super(),ur.constructor_.apply(this,arguments)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}getClass(){return ur}get interfaces_(){return[]}}ur.constructor_=function(){this._edgeRing=null,this._next=null,this._label=-1;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];bi.constructor_.call(this,t,e,n,s)};class gr extends Di{constructor(){super(),gr.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return gr}get interfaces_(){return[]}}gr.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class dr{constructor(){dr.constructor_.apply(this,arguments)}static findDifferentPoint(t,e){for(let n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null}visitInteriorRing(t,e){const n=t.getCoordinates(),s=n[0],i=dr.findDifferentPoint(n,s),r=e.findEdgeInSameDirection(s,i),o=e.findEdgeEnd(r);let l=null;o.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR?l=o:o.getSym().getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR&&(l=o.getSym()),u.isTrue(null!==l,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(l)}visitShellInteriors(t,e){if(t instanceof bt){const n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof At){const n=t;for(let t=0;t<n.getNumGeometries();t++){const s=n.getGeometryN(t);this.visitInteriorRing(s.getExteriorRing(),e)}}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let e=t.getEdgeEnds().iterator();e.hasNext();){const t=e.next();t.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const e=t;let n=t;do{u.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext()}while(n!==e)}buildEdgeRings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&null===t.getEdgeRing()){const n=new ti(t,this._geometryFactory);n.linkDirectedEdgesForMinimalEdgeRings();const s=n.buildMinimalRings();e.addAll(s)}}return e}hasUnvisitedShellEdge(t){for(let e=0;e<t.size();e++){const n=t.get(e);if(n.isHole())continue;const s=n.getEdges();let i=s.get(0);if(i.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR)for(let t=0;t<s.size();t++)if(i=s.get(t),!i.isVisited())return this._disconnectedRingcoord=i.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new x;this._geomGraph.computeSplitEdges(t);const e=new Zn(new ui);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();const n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)}getClass(){return dr}get interfaces_(){return[]}}dr.constructor_=function(){this._geometryFactory=new Ht,this._geomGraph=null,this._disconnectedRingcoord=null;const t=arguments[0];this._geomGraph=t};class _r{constructor(){_r.constructor_.apply(this,arguments)}createEdgeEndForNext(t,e,n,s){const i=n.segmentIndex+1;if(i>=t.getNumPoints()&&null===s)return null;let r=t.getCoordinate(i);null!==s&&s.segmentIndex===n.segmentIndex&&(r=s.coord);const o=new Hn(t,n.coord,r,new Fn(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,s){let i=n.segmentIndex;if(0===n.dist){if(0===i)return null;i--}let r=t.getCoordinate(i);null!==s&&s.segmentIndex>=i&&(r=s.coord);const o=new Fn(t.getLabel());o.flip();const l=new Hn(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new x;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const s=n.iterator();let i=null,r=null;if(!s.hasNext())return null;let o=s.next();do{i=r,r=o,o=null,s.hasNext()&&(o=s.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,i),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}getClass(){return _r}get interfaces_(){return[]}}_r.constructor_=function(){};class fr extends Hn{constructor(){super(),fr.constructor_.apply(this,arguments)}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,s=!1;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel().getLocation(t);i===ne.BOUNDARY&&n++,i===ne.INTERIOR&&(s=!0)}let i=ne.NONE;s&&(i=ne.INTERIOR),n>0&&(i=Qn.determineBoundary(e,n)),this._label.setLocation(t,i)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const s=n.next();if(s.getLabel().isArea()){const n=s.getLabel().getLocation(t,e);if(n===ne.INTERIOR)return this._label.setLocation(t,e,ne.INTERIOR),null;n===ne.EXTERIOR&&this._label.setLocation(t,e,ne.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,Pn.LEFT),this.computeLabelSide(t,Pn.RIGHT)}updateIM(t){Un.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new Fn(ne.NONE,ne.NONE,ne.NONE):new Fn(ne.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}getClass(){return fr}get interfaces_(){return[]}}fr.constructor_=function(){if(this._edgeEnds=new x,1===arguments.length){const t=arguments[0];fr.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];Hn.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Fn(t.getLabel())),this.insert(t)}};class pr extends ci{constructor(){super(),pr.constructor_.apply(this,arguments)}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new fr(t),this.insertEdgeEnd(t,e)):e.insert(t)}getClass(){return pr}get interfaces_(){return[]}}pr.constructor_=function(){};class mr extends kn{constructor(){super(),mr.constructor_.apply(this,arguments)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}getClass(){return mr}get interfaces_(){return[]}}mr.constructor_=function(){const t=arguments[0],e=arguments[1];kn.constructor_.call(this,t,e)};class yr extends Kn{constructor(){super(),yr.constructor_.apply(this,arguments)}createNode(t){return new mr(t,new pr)}getClass(){return yr}get interfaces_(){return[]}}yr.constructor_=function(){};class xr{constructor(){xr.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,e){for(let n=t.getNodeIterator();n.hasNext();){const t=n.next();this._nodes.addNode(t.getCoordinate()).setLabel(e,t.getLabel().getLocation(e))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const e=(new _r).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(e)}computeIntersectionNodes(t,e){for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.getLabel().getLocation(e);for(let n=t.getEdgeIntersectionList().iterator();n.hasNext();){const t=n.next(),i=this._nodes.addNode(t.coord);s===ne.BOUNDARY?i.setLabelBoundary(e):i.getLabel().isNull(e)&&i.setLabel(e,ne.INTERIOR)}}}getClass(){return xr}get interfaces_(){return[]}}xr.constructor_=function(){this._nodes=new Xn(new yr)};class Er{constructor(){Er.constructor_.apply(this,arguments)}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){const e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=e.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){for(let e=t.next().getEdges().iterator();e.hasNext();){const t=e.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}}return!1}isNodeConsistentArea(){const t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}getClass(){return Er}get interfaces_(){return[]}}Er.constructor_=function(){this._li=new te,this._geomGraph=null,this._nodeGraph=new xr,this._invalidPoint=null;const t=arguments[0];this._geomGraph=t};class Ir{constructor(){Ir.constructor_.apply(this,arguments)}buildIndex(){this._index=new Es;for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getEnvelopeInternal();this._index.insert(n,e)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getCoordinates(),s=this._index.query(e.getEnvelopeInternal());for(let t=0;t<s.size();t++){const i=s.get(t),r=i.getCoordinates();if(e===i)continue;if(!e.getEnvelopeInternal().intersects(i.getEnvelopeInternal()))continue;const o=Cr.findPtNotNode(n,i,this._graph);if(null!==o&&We.isInRing(o,r))return this._nestedPt=o,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}getClass(){return Ir}get interfaces_(){return[]}}Ir.constructor_=function(){this._graph=null,this._rings=new x,this._totalEnv=new N,this._index=null,this._nestedPt=null;const t=arguments[0];this._graph=t};class Nr{constructor(){Nr.constructor_.apply(this,arguments)}getErrorType(){return this._errorType}getMessage(){return Nr.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}getClass(){return Nr}get interfaces_(){return[]}}Nr.constructor_=function(){if(this._errorType=null,this._pt=null,1===arguments.length){const t=arguments[0];Nr.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._errorType=t,null!==e&&(this._pt=e.copy())}},Nr.ERROR=0,Nr.REPEATED_POINT=1,Nr.HOLE_OUTSIDE_SHELL=2,Nr.NESTED_HOLES=3,Nr.DISCONNECTED_INTERIOR=4,Nr.SELF_INTERSECTION=5,Nr.RING_SELF_INTERSECTION=6,Nr.NESTED_SHELLS=7,Nr.DUPLICATE_RINGS=8,Nr.TOO_FEW_POINTS=9,Nr.INVALID_COORDINATE=10,Nr.RING_NOT_CLOSED=11,Nr.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class Cr{constructor(){Cr.constructor_.apply(this,arguments)}static findPtNotNode(t,e,n){const s=n.findEdge(e).getEdgeIntersectionList();for(let e=0;e<t.length;e++){const n=t[e];if(!s.isIntersection(n))return n}return null}static isValid(){if(arguments[0]instanceof q){const t=arguments[0];return new Cr(t).isValid()}if(arguments[0]instanceof g){const t=arguments[0];return!i.isNaN(t.x)&&(!i.isInfinite(t.x)&&(!i.isNaN(t.y)&&!i.isInfinite(t.y)))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)if(!Cr.isValid(t[e]))return this._validErr=new Nr(Nr.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof bt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,e){const n=new Ir(e);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);n.add(s)}n.isNonNested()||(this._validErr=new Nr(Nr.NESTED_HOLES,n.getNestedPoint()))}checkConsistentArea(t){const e=new Er(t);if(!e.isNodeConsistentArea())return this._validErr=new Nr(Nr.SELF_INTERSECTION,e.getInvalidPoint()),null;e.hasDuplicateRings()&&(this._validErr=new Nr(Nr.DUPLICATE_RINGS,e.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,e,n){const s=t.getCoordinates(),i=e.getCoordinates(),r=Cr.findPtNotNode(s,e,n);if(null!==r){if(!We.isInRing(r,i))return r}const o=Cr.findPtNotNode(i,t,n);if(null!==o){return We.isInRing(o,s)?o:null}return u.shouldNeverReachHere("points in shell and hole appear to be equal"),null}checkNoSelfIntersectingRings(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){const e=new dr(t);e.isInteriorsConnected()||(this._validErr=new Nr(Nr.DISCONNECTED_INTERIOR,e.getCoordinate()))}checkNoSelfIntersectingRing(t){const e=new at;let n=!0;for(let s=t.iterator();s.hasNext();){const t=s.next();if(n)n=!1;else{if(e.contains(t.coord))return this._validErr=new Nr(Nr.RING_SELF_INTERSECTION,t.coord),null;e.add(t.coord)}}}checkHolesInShell(t,e){const n=t.getExteriorRing(),s=new ke(n);for(let i=0;i<t.getNumInteriorRing();i++){const r=t.getInteriorRingN(i),o=Cr.findPtNotNode(r.getCoordinates(),n,e);if(null===o)return null;if(ne.EXTERIOR===s.locate(o))return this._validErr=new Nr(Nr.HOLE_OUTSIDE_SHELL,o),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Nr(Nr.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof Pt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Mt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Dt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;if(this.checkClosedRing(t),null!==this._validErr)return null;const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;const n=new te;e.computeSelfNodes(n,!0,!0),this.checkNoSelfIntersectingRings(e)}else if(arguments[0]instanceof Tt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;const e=new Qn(0,t);this.checkTooFewPoints(e)}else if(arguments[0]instanceof bt){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr)return null;if(this.checkClosedRings(t),null!==this._validErr)return null;const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;if(this.checkHolesInShell(t,e),null!==this._validErr)return null;if(this.checkHolesNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof At){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkInvalidCoordinates(n),null!==this._validErr)return null;if(this.checkClosedRings(n),null!==this._validErr)return null}const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesInShell(s,e),null!==this._validErr)return null}for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesNotNested(s,e),null!==this._validErr)return null}if(this.checkShellsNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof _t){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkValid(n),null!==this._validErr)return null}}else if(arguments[0]instanceof q){const t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof Pt)this.checkValid(t);else if(t instanceof Mt)this.checkValid(t);else if(t instanceof Dt)this.checkValid(t);else if(t instanceof Tt)this.checkValid(t);else if(t instanceof bt)this.checkValid(t);else if(t instanceof At)this.checkValid(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,e,n){const s=t.getCoordinates(),i=e.getExteriorRing(),r=i.getCoordinates(),o=Cr.findPtNotNode(s,i,n);if(null===o)return null;if(!We.isInRing(o,r))return null;if(e.getNumInteriorRing()<=0)return this._validErr=new Nr(Nr.NESTED_SHELLS,o),null;let l=null;for(let s=0;s<e.getNumInteriorRing();s++){const i=e.getInteriorRingN(s);if(l=this.checkShellInsideHole(t,i,n),null===l)return null}this._validErr=new Nr(Nr.NESTED_SHELLS,l)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this._validErr)return null}checkClosedRing(t){if(!t.isClosed()){let e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this._validErr=new Nr(Nr.RING_NOT_CLOSED,e)}}checkShellsNotNested(t,e){for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getExteriorRing();for(let i=0;i<t.getNumGeometries();i++){if(n===i)continue;const r=t.getGeometryN(i);if(this.checkShellNotNested(s,r,e),null!==this._validErr)return null}}}getClass(){return Cr}get interfaces_(){return[]}}Cr.constructor_=function(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;const t=arguments[0];this._parentGeometry=t};class Sr{constructor(){Sr.constructor_.apply(this,arguments)}static findDirEdgesInRing(t){let e=t;const n=new x;do{n.add(e),e=e.getNext(),u.isTrue(null!==e,"found null DE in ring"),u.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t);return n}static addEdge(t,e,n){if(e)for(let e=0;e<t.length;e++)n.add(t[e],!1);else for(let e=t.length-1;e>=0;e--)n.add(t[e],!1)}static findEdgeRingContaining(t,e){const n=t.getRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getRing(),a=l.getEnvelopeInternal();if(a.equals(s))continue;if(!a.contains(s))continue;i=X.ptNotInList(n.getCoordinates(),l.getCoordinates());let c=!1;We.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===r||o.contains(a))&&(r=e,o=r.getRing().getEnvelopeInternal())}return r}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){const t=new I;for(let e=this._deList.iterator();e.hasNext();){const n=e.next(),s=n.getEdge();Sr.addEdge(s.getLine().getCoordinates(),n.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Cr.isValid(this._ring))}build(t){let e=t;do{this.add(e),e.setRing(this),e=e.getNext(),u.isTrue(null!==e,"found null DE in ring"),u.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=new Array(this._holes.size()).fill(null);for(let e=0;e<this._holes.size();e++)t[e]=this._holes.get(e)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof Dt){const t=arguments[0];null===this._holes&&(this._holes=new x),this._holes.add(t)}else if(arguments[0]instanceof Sr){const t=arguments[0];t.setShell(this);const e=t.getRing();null===this._holes&&(this._holes=new x),this._holes.add(e)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing();if(e.isOuterHole())return e}return null}computeHole(){const t=this.getRing();this._isHole=v.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return Jt.toLineString(new zt(this.getCoordinates()))}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&O.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof C))throw t;O.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing().getShell();if(null!==e&&e.isIncludedSet())return this.setIncluded(!e.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}getClass(){return Sr}get interfaces_(){return[]}}class wr{constructor(){wr.constructor_.apply(this,arguments)}compare(t,e){const n=e;return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())}getClass(){return wr}get interfaces_(){return[l]}}wr.constructor_=function(){},Sr.EnvelopeComparator=wr,Sr.constructor_=function(){this._factory=null,this._deList=new x,this._lowestEdge=null,this._ring=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;const t=arguments[0];this._factory=t};class Lr extends Bi{constructor(){super(),Lr.constructor_.apply(this,arguments)}static findLabeledEdgeRings(t){const e=new x;let n=1;for(let s=t.iterator();s.hasNext();){const t=s.next();if(t.isMarked())continue;if(t.getLabel()>=0)continue;e.add(t);const i=Sr.findDirEdgesInRing(t);Lr.label(i,n),n++}return e}static getDegreeNonDeleted(t){let e=0;for(let n=t.getOutEdges().getEdges().iterator();n.hasNext();){n.next().isMarked()||e++}return e}static deleteAllEdges(t){for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next();t.setMarked(!0);const n=t.getSym();null!==n&&n.setMarked(!0)}}static label(t,e){for(let n=t.iterator();n.hasNext();){n.next().setLabel(e)}}static computeNextCWEdges(t){let e=null,n=null;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();if(!t.isMarked()){if(null===e&&(e=t),null!==n){n.getSym().setNext(t)}n=t}}if(null!==n){n.getSym().setNext(e)}}static computeNextCCWEdges(t,e){let n=null,s=null;const i=t.getOutEdges().getEdges();for(let t=i.size()-1;t>=0;t--){const r=i.get(t),o=r.getSym();let l=null;r.getLabel()===e&&(l=r);let a=null;o.getLabel()===e&&(a=o),null===l&&null===a||(null!==a&&(s=a),null!==l&&(null!==s&&(s.setNext(l),s=null),null===n&&(n=l)))}null!==s&&(u.isTrue(null!==n),s.setNext(n))}static getDegree(t,e){let n=0;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){s.next().getLabel()===e&&n++}return n}static findIntersectionNodes(t,e){let n=t,s=null;do{const i=n.getFromNode();Lr.getDegree(i,e)>1&&(null===s&&(s=new x),s.add(i)),n=n.getNext(),u.isTrue(null!==n,"found null DE in ring"),u.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return s}findEdgeRing(t){const e=new Sr(this._factory);return e.build(t),e}computeDepthParity(){if(0===arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){const e=t.next();Lr.computeNextCWEdges(e)}}addEdge(t){if(t.isEmpty())return null;const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new ur(i,r,e[1],!0),l=new ur(r,i,e[e.length-2],!1),a=new gr(t);a.setDirectedEdges(o,l),this.add(a)}deleteCutEdges(){this.computeNextCWEdges(),Lr.findLabeledEdgeRings(this._dirEdges);const t=new x;for(let e=this._dirEdges.iterator();e.hasNext();){const n=e.next();if(n.isMarked())continue;const s=n.getSym();if(n.getLabel()===s.getLabel()){n.setMarked(!0),s.setMarked(!0);const e=n.getEdge();t.add(e.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),Lr.label(this._dirEdges,-1);const t=Lr.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);const e=new x;for(let t=this._dirEdges.iterator();t.hasNext();){const n=t.next();if(n.isMarked())continue;if(n.isInRing())continue;const s=this.findEdgeRing(n);e.add(s)}return e}getNode(t){let e=this.findNode(t);return null===e&&(e=new Fi(t),this.add(e)),e}convertMaximalToMinimalEdgeRings(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel(),s=Lr.findIntersectionNodes(t,n);if(null!==s)for(let t=s.iterator();t.hasNext();){const e=t.next();Lr.computeNextCCWEdges(e,n)}}}deleteDangles(){const t=this.findNodesOfDegree(1),e=new J,n=new on;for(let e=t.iterator();e.hasNext();)n.push(e.next());for(;!n.isEmpty();){const t=n.pop();Lr.deleteAllEdges(t);for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();t.setMarked(!0);const i=t.getSym();null!==i&&i.setMarked(!0);const r=t.getEdge();e.add(r.getLine());const o=t.getToNode();1===Lr.getDegreeNonDeleted(o)&&n.push(o)}}return e}getClass(){return Lr}get interfaces_(){return[]}}Lr.constructor_=function(){this._factory=null;const t=arguments[0];this._factory=t};class Tr{constructor(){Tr.constructor_.apply(this,arguments)}static findOuterShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getOuterHole();null===n||n.isProcessed()||(t.setIncluded(!0),n.setProcessed(!0))}}static extractPolygons(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next();(e||t.isIncluded())&&n.add(t.getPolygon())}return n}static assignHolesToShells(t,e){for(let n=t.iterator();n.hasNext();){const t=n.next();Tr.assignHoleToShell(t,e)}}static assignHoleToShell(t,e){const n=Sr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)}static findDisjointShells(t){Tr.findOuterShells(t);let e=null;do{e=!1;for(let n=t.iterator();n.hasNext();){const t=n.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(e=!0))}}while(e)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Ht),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Ht.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isValid()?e.add(t):n.add(t.getLineString())}}polygonize(){if(null!==this._polyList)return null;if(this._polyList=new x,null===this._graph)return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();const t=this._graph.getEdgeRings();let e=new x;this._invalidRingLines=new x,this._isCheckingRingsValid?this.findValidRings(t,e,this._invalidRingLines):e=t,this.findShellsAndHoles(e),Tr.assignHolesToShells(this._holeList,this._shellList),Ee.sort(this._shellList,new Sr.EnvelopeComparator);let n=!0;this._extractOnlyPolygonal&&(Tr.findDisjointShells(this._shellList),n=!1),this._polyList=Tr.extractPolygons(this._shellList,n)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof Tt){const t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new Lr(this._geomFactory)),this._graph.addEdge(t)}else if(arguments[0]instanceof q){arguments[0].apply(this._lineStringAdder)}}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new x,this._shellList=new x;for(let e=t.iterator();e.hasNext();){const t=e.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}getClass(){return Tr}get interfaces_(){return[]}}class Rr{constructor(){Rr.constructor_.apply(this,arguments)}filter(t){t instanceof Tt&&this.p.add(t)}getClass(){return Rr}get interfaces_(){return[G]}}Rr.constructor_=function(){this.p=null;const t=arguments[0];this.p=t},Tr.LineStringAdder=Rr,Tr.constructor_=function(){if(this._lineStringAdder=new Rr(this),this._graph=null,this._dangles=new x,this._cutEdges=new x,this._invalidRingLines=new x,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0===arguments.length)Tr.constructor_.call(this,!1);else if(1===arguments.length){const t=arguments[0];this._extractOnlyPolygonal=t}};var Pr=Object.freeze({__proto__:null,Polygonizer:Tr});class vr{constructor(){vr.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),s=this._arg[1].getGeometry().getDimension(),i=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===s?i&&e.setAtLeast("212101212"):2===n&&1===s?(i&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===s?(i&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===s&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const s=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,s)}else t.getLabel().setAllLocations(e,ne.EXTERIOR)}computeIM(){const t=new se;if(t.set(ne.EXTERIOR,ne.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new _r,s=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(s);const i=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(i),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.find(n.coord);i.getLabel().isNull(t)&&(s===ne.BOUNDARY?i.setLabelBoundary(t):i.setLabel(t,ne.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.addNode(n.coord);s===ne.BOUNDARY?i.setLabelBoundary(t):i.getLabel().isNull(t)&&i.setLabel(t,ne.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();u.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(ne.INTERIOR,ne.EXTERIOR,e.getDimension()),t.set(ne.BOUNDARY,ne.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(ne.EXTERIOR,ne.INTERIOR,n.getDimension()),t.set(ne.EXTERIOR,ne.BOUNDARY,n.getBoundaryDimension()))}getClass(){return vr}get interfaces_(){return[]}}vr.constructor_=function(){this._li=new te,this._ptLocator=new _n,this._arg=null,this._nodes=new Xn(new yr),this._im=null,this._isolatedEdges=new x,this._invalidPoint=null;const t=arguments[0];this._arg=t};class Or{constructor(){Or.constructor_.apply(this,arguments)}static contains(t,e){return new Or(t).contains(e)}isContainedInBoundary(t){if(t instanceof bt)return!1;if(t instanceof Pt)return this.isPointContainedInBoundary(t);if(t instanceof Tt)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new g,s=new g;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,s),!this.isLineSegmentContainedInBoundary(n,s))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof Pt){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}getClass(){return Or}get interfaces_(){return[]}}Or.constructor_=function(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()};class br{constructor(){br.constructor_.apply(this,arguments)}intersects(t,e){const n=new N(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let s=!1;return e.y>t.y&&(s=!0),s?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}getClass(){return br}get interfaces_(){return[]}}br.constructor_=function(){this._li=new te,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new g(t.getMinX(),t.getMinY()),this._diagUp1=new g(t.getMaxX(),t.getMaxY()),this._diagDown0=new g(t.getMinX(),t.getMaxY()),this._diagDown1=new g(t.getMaxX(),t.getMinY())};class Mr{constructor(){Mr.constructor_.apply(this,arguments)}static intersects(t,e){return new Mr(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Dr(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new Ar(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const s=new Fr(this._rectangle);return s.applyTo(t),!!s.intersects()}getClass(){return Mr}get interfaces_(){return[]}}Mr.constructor_=function(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()};class Dr extends Ce{constructor(){super(),Dr.constructor_.apply(this,arguments)}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}getClass(){return Dr}get interfaces_(){return[]}}Dr.constructor_=function(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t};class Ar extends Ce{constructor(){super(),Ar.constructor_.apply(this,arguments)}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof bt))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new g;for(let s=0;s<4;s++)if(this._rectSeq.getCoordinate(s,n),e.contains(n)&&Ze.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}getClass(){return Ar}get interfaces_(){return[]}}Ar.constructor_=function(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()};class Fr extends Ce{constructor(){super(),Fr.constructor_.apply(this,arguments)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=xe.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}getClass(){return Fr}get interfaces_(){return[]}}Fr.constructor_=function(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new g,this._p1=new g;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new br(this._rectEnv)};class Gr extends ar{constructor(){super(),Gr.constructor_.apply(this,arguments)}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Gr(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Mr.intersects(t,e);if(e.isRectangle())return Mr.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let s=0;s<e.getNumGeometries();s++)if(t.getGeometryN(n).intersects(e.getGeometryN(s)))return!0;return!1}return new Gr(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Gr.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Gr(t,e).getIntersectionMatrix()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new Gr(t,e,n).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Or.contains(t,e):new Gr(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}getClass(){return Gr}get interfaces_(){return[]}}Gr.constructor_=function(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e),this._relate=new vr(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];ar.constructor_.call(this,t,e,n),this._relate=new vr(this._arg)}};var qr=Object.freeze({__proto__:null,RelateOp:Gr});class Br{constructor(){Br.constructor_.apply(this,arguments)}static union(t,e){return new Br(t,e).union()}union(){const t=new _n,e=new at;for(let n=0;n<this._pointGeom.getNumGeometries();n++){const s=this._pointGeom.getGeometryN(n).getCoordinate();t.locate(s,this._otherGeom)===ne.EXTERIOR&&e.add(s)}if(0===e.size())return this._otherGeom;let n=null;const s=X.toCoordinateArray(e);return n=1===s.length?this._geomFact.createPoint(s[0]):this._geomFact.createMultiPointFromCoords(s),de.combine(n,this._otherGeom)}getClass(){return Br}get interfaces_(){return[]}}Br.constructor_=function(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;const t=arguments[0],e=arguments[1];this._pointGeom=t,this._otherGeom=e,this._geomFact=e.getFactory()};class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static restrictToPolygons(t){if(_(t,Ot))return t;const e=Ne.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(Ht.toPolygonArray(e))}static getGeometry(t,e){return e>=t.size()?null:t.get(e)}static union(t){return new Vr(t).union()}reduceToGeometries(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();let s=null;_(t,m)?s=this.unionTree(t):t instanceof q&&(s=t),e.add(s)}return e}extractByEnvelope(t,e,n){const s=new x;for(let i=0;i<e.getNumGeometries();i++){const r=e.getGeometryN(i);r.getEnvelopeInternal().intersects(t)?s.add(r):n.add(r)}return this._geomFactory.buildGeometry(s)}unionOptimized(t,e){const n=t.getEnvelopeInternal(),s=e.getEnvelopeInternal();if(!n.intersects(s)){return de.combine(t,e)}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);const i=n.intersection(s);return this.unionUsingEnvelopeIntersection(t,e,i)}union(){if(null===this._inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();const t=new Es(Vr.STRTREE_NODE_CAPACITY);for(let e=this._inputPolys.iterator();e.hasNext();){const n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;const e=t.itemsTree();return this.unionTree(e)}binaryUnion(){if(1===arguments.length){const t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(n-e<=1){const n=Vr.getGeometry(t,e);return this.unionSafe(n,null)}if(n-e==2)return this.unionSafe(Vr.getGeometry(t,e),Vr.getGeometry(t,e+1));{const s=Math.trunc((n+e)/2),i=this.binaryUnion(t,e,s),r=this.binaryUnion(t,s,n);return this.unionSafe(i,r)}}}repeatedUnion(t){let e=null;for(let n=t.iterator();n.hasNext();){const t=n.next();e=null===e?t.copy():e.union(t)}return e}unionSafe(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)}unionActual(t,e){return Vr.restrictToPolygons(t.union(e))}unionTree(t){const e=this.reduceToGeometries(t);return this.binaryUnion(e)}unionUsingEnvelopeIntersection(t,e,n){const s=new x,i=this.extractByEnvelope(n,t,s),r=this.extractByEnvelope(n,e,s),o=this.unionActual(i,r);return s.add(o),de.combine(s)}bufferUnion(){if(1===arguments.length){const t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().createGeometryCollection([t,e]).buffer(0)}}getClass(){return Vr}get interfaces_(){return[]}}Vr.constructor_=function(){this._inputPolys=null,this._geomFactory=null;const t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new x)},Vr.STRTREE_NODE_CAPACITY=4;class zr{constructor(){zr.constructor_.apply(this,arguments)}static union(){if(1===arguments.length){if(_(arguments[0],f)){const t=arguments[0];return new zr(t).union()}if(arguments[0]instanceof q){const t=arguments[0];return new zr(t).union()}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return new zr(t,e).union()}}unionNoOpt(t){const e=this._geomFact.createPoint();return lr.overlayOp(t,e,cr.UNION)}unionWithNull(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)}extract(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.extract(e)}}else if(arguments[0]instanceof q){const t=arguments[0];null===this._geomFact&&(this._geomFact=t.getFactory()),_e.extract(t,q.TYPENAME_POLYGON,this._polygons),_e.extract(t,q.TYPENAME_LINESTRING,this._lines),_e.extract(t,q.TYPENAME_POINT,this._points)}}union(){if(null===this._geomFact)return null;let t=null;if(this._points.size()>0){const e=this._geomFact.buildGeometry(this._points);t=this.unionNoOpt(e)}let e=null;if(this._lines.size()>0){const t=this._geomFact.buildGeometry(this._lines);e=this.unionNoOpt(t)}let n=null;this._polygons.size()>0&&(n=Vr.union(this._polygons));const s=this.unionWithNull(e,n);let i=null;return i=null===t?s:null===s?t:Br.union(t,s),null===i?this._geomFact.createGeometryCollection():i}getClass(){return zr}get interfaces_(){return[]}}zr.constructor_=function(){if(this._polygons=new x,this._lines=new x,this._points=new x,this._geomFact=null,1===arguments.length){if(_(arguments[0],f)){const t=arguments[0];this.extract(t)}else if(arguments[0]instanceof q){const t=arguments[0];this.extract(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geomFact=e,this.extract(t)}};var Yr=Object.freeze({__proto__:null,UnaryUnionOp:zr}),Ur=Object.freeze({__proto__:null,IsValidOp:Cr,ConsistentAreaTester:Er}),kr=Object.freeze({__proto__:null,BoundaryOp:pt,IsSimpleOp:Hs,buffer:wi,distance:Pi,linemerge:Xi,overlay:hr,polygonize:Pr,relate:qr,union:Yr,valid:Ur});class Xr extends Ft.CoordinateOperation{constructor(){super(),Xr.constructor_.apply(this,arguments)}edit(){if(2===arguments.length&&arguments[1]instanceof q&&arguments[0]instanceof Array){const t=arguments[0],e=arguments[1];if(0===t.length)return null;const n=new Array(t.length).fill(null);for(let e=0;e<t.length;e++){const s=new g(t[e]);this._targetPM.makePrecise(s),n[e]=s}const s=new I(n,!1).toCoordinateArray();let i=0;e instanceof Tt&&(i=2),e instanceof Dt&&(i=4);let r=n;return this._removeCollapsed&&(r=null),s.length<i?r:s}return super.edit.apply(this,arguments)}getClass(){return Xr}get interfaces_(){return[]}}Xr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0;const t=arguments[0],e=arguments[1];this._targetPM=t,this._removeCollapsed=e};class Hr{constructor(){Hr.constructor_.apply(this,arguments)}static reduce(t,e){return new Hr(e).reduce(t)}static reducePointwise(t,e){const n=new Hr(e);return n.setPointwise(!0),n.reduce(t)}fixPolygonalTopology(t){let e=t;this._changePrecisionModel||(e=this.changePM(t,this._targetPM));const n=Si.bufferOp(e,0);let s=n;return this._changePrecisionModel||(s=t.getFactory().createGeometry(n)),s}reducePointwise(t){let e=null;if(this._changePrecisionModel){const n=this.createFactory(t.getFactory(),this._targetPM);e=new Ft(n)}else e=new Ft;let n=this._removeCollapsed;return t.getDimension()>=2&&(n=!0),e.edit(t,new Xr(this._targetPM,n))}changePM(t,e){return this.createEditor(t.getFactory(),e).edit(t,new Ft.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,e){return new Ht(e,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){const e=this.reducePointwise(t);return this._isPointwise?e:_(e,Ot)?Cr.isValid(e)?e:this.fixPolygonalTopology(e):e}setPointwise(t){this._isPointwise=t}createEditor(t,e){if(t.getPrecisionModel()===e)return new Ft;const n=this.createFactory(t,e);return new Ft(n)}getClass(){return Hr}get interfaces_(){return[]}}Hr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;const t=arguments[0];this._targetPM=t};var Wr=Object.freeze({__proto__:null,GeometryPrecisionReducer:Hr});class jr{constructor(){jr.constructor_.apply(this,arguments)}static simplify(t,e){const n=new jr(t);return n.setDistanceTolerance(e),n.simplify()}simplifySection(t,e){if(t+1===e)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[e];let n=-1,s=t;for(let i=t+1;i<e;i++){const t=this._seg.distance(this._pts[i]);t>n&&(n=t,s=i)}if(n<=this._distanceTolerance)for(let n=t+1;n<e;n++)this._usePt[n]=!1;else this.simplifySection(t,s),this.simplifySection(s,e)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=new Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);const t=new I;for(let e=0;e<this._pts.length;e++)this._usePt[e]&&t.add(new g(this._pts[e]));return t.toCoordinateArray()}getClass(){return jr}get interfaces_(){return[]}}jr.constructor_=function(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new ee;const t=arguments[0];this._pts=t};class Kr{constructor(){Kr.constructor_.apply(this,arguments)}static simplify(t,e){const n=new Kr(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Zr(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return Kr}get interfaces_(){return[]}}class Zr extends me{constructor(){super(),Zr.constructor_.apply(this,arguments)}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):jr.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof bt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof Dt?s:null}getClass(){return Zr}get interfaces_(){return[]}}Zr.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e},Kr.DPTransformer=Zr,Kr.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t};class Qr extends ee{constructor(){super(),Qr.constructor_.apply(this,arguments)}getIndex(){return this._index}getParent(){return this._parent}getClass(){return Qr}get interfaces_(){return[]}}Qr.constructor_=function(){if(this._parent=null,this._index=null,2===arguments.length){const t=arguments[0],e=arguments[1];Qr.constructor_.call(this,t,e,null,-1)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ee.constructor_.call(this,t,e),this._parent=n,this._index=s}};class Jr{constructor(){Jr.constructor_.apply(this,arguments)}static extractCoordinates(t){const e=new Array(t.size()+1).fill(null);let n=null;for(let s=0;s<t.size();s++)n=t.get(s),e[s]=n.p0;return e[e.length-1]=n.p1,e}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString(Jr.extractCoordinates(this._resultSegs))}getResultSize(){const t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing(Jr.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){const t=this._parentLine.getCoordinates();this._segs=new Array(t.length-1).fill(null);for(let e=0;e<t.length-1;e++){const n=new Qr(t[e],t[e+1],this._parentLine,e);this._segs[e]=n}}getResultCoordinates(){return Jr.extractCoordinates(this._resultSegs)}getClass(){return Jr}get interfaces_(){return[]}}Jr.constructor_=function(){if(this._parentLine=null,this._segs=null,this._resultSegs=new x,this._minimumSize=null,1===arguments.length){const t=arguments[0];Jr.constructor_.call(this,t,2)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._parentLine=t,this._minimumSize=e,this.init()}};class $r{constructor(){$r.constructor_.apply(this,arguments)}remove(t){this._index.remove(new N(t.p0,t.p1),t)}add(){if(arguments[0]instanceof Jr){const t=arguments[0].getSegments();for(let e=0;e<t.length;e++){const n=t[e];this.add(n)}}else if(arguments[0]instanceof ee){const t=arguments[0];this._index.insert(new N(t.p0,t.p1),t)}}query(t){const e=new N(t.p0,t.p1),n=new to(t);return this._index.query(e,n),n.getItems()}getClass(){return $r}get interfaces_(){return[]}}$r.constructor_=function(){this._index=new us};class to{constructor(){to.constructor_.apply(this,arguments)}visitItem(t){const e=t;N.intersects(e.p0,e.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}getClass(){return to}get interfaces_(){return[Ae]}}to.constructor_=function(){this._querySeg=null,this._items=new x;const t=arguments[0];this._querySeg=t};class eo{constructor(){eo.constructor_.apply(this,arguments)}static isInLineSection(t,e,n){if(n.getParent()!==t.getParent())return!1;const s=n.getIndex();return s>=e[0]&&s<e[1]}flatten(t,e){const n=this._linePts[t],s=this._linePts[e],i=new ee(n,s);return this.remove(this._line,t,e),this._outputIndex.add(i),i}hasBadIntersection(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,e,n){n+=1;const s=new Array(2).fill(null);if(t+1===e){const e=this._line.getSegment(t);return this._line.addToResult(e),null}let i=!0;if(this._line.getResultSize()<this._line.getMinimumSize()){n+1<this._line.getMinimumSize()&&(i=!1)}const r=new Array(1).fill(null),o=this.findFurthestPoint(this._linePts,t,e,r);r[0]>this._distanceTolerance&&(i=!1);const l=new ee;if(l.p0=this._linePts[t],l.p1=this._linePts[e],s[0]=t,s[1]=e,this.hasBadIntersection(this._line,s,l)&&(i=!1),i){const n=this.flatten(t,e);return this._line.addToResult(n),null}this.simplifySection(t,o,n),this.simplifySection(o,e,n)}hasBadOutputIntersection(t){for(let e=this._outputIndex.query(t).iterator();e.hasNext();){const n=e.next();if(this.hasInteriorIntersection(n,t))return!0}return!1}findFurthestPoint(t,e,n,s){const i=new ee;i.p0=t[e],i.p1=t[n];let r=-1,o=e;for(let s=e+1;s<n;s++){const e=t[s],n=i.distance(e);n>r&&(r=n,o=s)}return s[0]=r,o}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,e,n){for(let s=e;s<n;s++){const e=t.getSegment(s);this._inputIndex.remove(e)}}hasInteriorIntersection(t,e){return this._li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,e,n){for(let s=this._inputIndex.query(n).iterator();s.hasNext();){const i=s.next();if(this.hasInteriorIntersection(i,n)){if(eo.isInLineSection(t,e,i))continue;return!0}}return!1}getClass(){return eo}get interfaces_(){return[]}}eo.constructor_=function(){this._li=new te,this._inputIndex=new $r,this._outputIndex=new $r,this._line=null,this._linePts=null,this._distanceTolerance=0;const t=arguments[0],e=arguments[1];this._inputIndex=t,this._outputIndex=e};class no{constructor(){no.constructor_.apply(this,arguments)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let e=t.iterator();e.hasNext();)this._inputIndex.add(e.next());for(let e=t.iterator();e.hasNext();){const t=new eo(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(e.next())}}getClass(){return no}get interfaces_(){return[]}}no.constructor_=function(){this._inputIndex=new $r,this._outputIndex=new $r,this._distanceTolerance=0};class so{constructor(){so.constructor_.apply(this,arguments)}static simplify(t,e){const n=new so(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){if(this._inputGeom.isEmpty())return this._inputGeom.copy();return this._linestringMap=new Ut,this._inputGeom.apply(new ro(this)),this._lineSimplifier.simplify(this._linestringMap.values()),new io(this._linestringMap).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}getClass(){return so}get interfaces_(){return[]}}class io extends me{constructor(){super(),io.constructor_.apply(this,arguments)}transformCoordinates(t,e){if(0===t.size())return null;if(e instanceof Tt){const t=this._linestringMap.get(e);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,e)}getClass(){return io}get interfaces_(){return[]}}io.constructor_=function(){this._linestringMap=null;const t=arguments[0];this._linestringMap=t};class ro{constructor(){ro.constructor_.apply(this,arguments)}filter(t){if(t instanceof Tt){const e=t;if(e.isEmpty())return null;const n=e.isClosed()?4:2,s=new Jr(e,n);this.tps._linestringMap.put(e,s)}}getClass(){return ro}get interfaces_(){return[G]}}ro.constructor_=function(){this.tps=null;const t=arguments[0];this.tps=t},so.LineStringTransformer=io,so.LineStringMapBuilderFilter=ro,so.constructor_=function(){this._inputGeom=null,this._lineSimplifier=new no,this._linestringMap=null;const t=arguments[0];this._inputGeom=t};class oo{constructor(){oo.constructor_.apply(this,arguments)}static simplify(t,e){return new oo(t,e).simplify()}simplifyVertex(t){let e=t,n=e.getArea(),s=null;for(;null!==e;){const t=e.getArea();t<n&&(n=t,s=e),e=e._next}return null!==s&&n<this._tolerance&&s.remove(),t.isLive()?n:-1}simplify(){const t=lo.buildLine(this._pts);let e=this._tolerance;do{e=this.simplifyVertex(t)}while(e<this._tolerance);const n=t.getCoordinates();return n.length<2?[n[0],new g(n[0])]:n}getClass(){return oo}get interfaces_(){return[]}}class lo{constructor(){lo.constructor_.apply(this,arguments)}static buildLine(t){let e=null,n=null;for(let s=0;s<t.length;s++){const i=new lo(t[s]);null===e&&(e=i),i.setPrev(n),null!==n&&(n.setNext(i),n.updateArea()),n=i}return e}getCoordinates(){const t=new I;let e=this;do{t.add(e._pt,!1),e=e._next}while(null!==e);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=lo.MAX_AREA,null;this._area=Math.abs(re.area(this._prev._pt,this._pt,this._next._pt))}remove(){const t=this._prev,e=this._next;let n=null;return null!==this._prev&&(this._prev.setNext(e),this._prev.updateArea(),n=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===n&&(n=this._next)),this._isLive=!1,n}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}getClass(){return lo}get interfaces_(){return[]}}lo.constructor_=function(){this._pt=null,this._prev=null,this._next=null,this._area=lo.MAX_AREA,this._isLive=!0;const t=arguments[0];this._pt=t},lo.MAX_AREA=i.MAX_VALUE,oo.VWVertex=lo,oo.constructor_=function(){this._pts=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._pts=t,this._tolerance=e*e};class ao{constructor(){ao.constructor_.apply(this,arguments)}static simplify(t,e){const n=new ao(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new co(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return ao}get interfaces_(){return[]}}class co extends me{constructor(){super(),co.constructor_.apply(this,arguments)}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):oo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof bt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof Dt?s:null}getClass(){return co}get interfaces_(){return[]}}co.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e},ao.VWTransformer=co,ao.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t};var ho=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:Kr,TopologyPreservingSimplifier:so,VWSimplifier:ao});class uo{constructor(){uo.constructor_.apply(this,arguments)}static pointAlongReverse(t,e){const n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n}splitAt(){if(1===arguments.length){const t=arguments[0],e=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(e),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=uo.pointAlongReverse(this._seg,e),null;this._splitPt=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this.getConstrainedLength(t)/this._segLen;e.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(n):this._splitPt=uo.pointAlongReverse(this._seg,n)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}getClass(){return uo}get interfaces_(){return[]}}uo.constructor_=function(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;const t=arguments[0];this._seg=t,this._segLen=t.getLength()};class go{constructor(){go.constructor_.apply(this,arguments)}findSplitPoint(t,e){}getClass(){return go}get interfaces_(){return[]}}go.constructor_=function(){};class _o{constructor(){_o.constructor_.apply(this,arguments)}static projectedSplitPoint(t,e){return t.getLineSegment().project(e)}findSplitPoint(t,e){const n=t.getLineSegment(),s=n.getLength()/2,i=new uo(n),r=_o.projectedSplitPoint(t,e);let o=2*r.distance(e)*.8;return o>s&&(o=s),i.setMinimumLength(o),i.splitAt(r),i.getSplitPoint()}getClass(){return _o}get interfaces_(){return[go]}}_o.constructor_=function(){};class fo{constructor(){fo.constructor_.apply(this,arguments)}static triArea(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static isInCircleDDNormalized(t,e,n,s){const i=R.valueOf(t.x).selfSubtract(s.x),r=R.valueOf(t.y).selfSubtract(s.y),o=R.valueOf(e.x).selfSubtract(s.x),l=R.valueOf(e.y).selfSubtract(s.y),a=R.valueOf(n.x).selfSubtract(s.x),c=R.valueOf(n.y).selfSubtract(s.y),h=i.multiply(l).selfSubtract(o.multiply(r)),u=o.multiply(c).selfSubtract(a.multiply(l)),g=a.multiply(r).selfSubtract(i.multiply(c)),d=i.multiply(i).selfAdd(r.multiply(r)),_=o.multiply(o).selfAdd(l.multiply(l)),f=a.multiply(a).selfAdd(c.multiply(c));return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(f.selfMultiply(h)).doubleValue()>0}static checkRobustInCircle(t,e,n,s){const i=fo.isInCircleNonRobust(t,e,n,s),r=fo.isInCircleDDSlow(t,e,n,s),o=fo.isInCircleCC(t,e,n,s),l=re.circumcentre(t,e,n);O.out.println("p radius diff a = "+Math.abs(s.distance(l)-t.distance(l))/t.distance(l)),i===r&&i===o||(O.out.println("inCircle robustness failure (double result = "+i+", DD result = "+r+", CC result = "+o+")"),O.out.println(Jt.toLineString(new zt([t,e,n,s]))),O.out.println("Circumcentre = "+Jt.toPoint(l)+" radius = "+t.distance(l)),O.out.println("p radius diff a = "+Math.abs(s.distance(l)/t.distance(l)-1)),O.out.println("p radius diff b = "+Math.abs(s.distance(l)/e.distance(l)-1)),O.out.println("p radius diff c = "+Math.abs(s.distance(l)/n.distance(l)-1)),O.out.println())}static isInCircleDDFast(t,e,n,s){const i=R.sqr(t.x).selfAdd(R.sqr(t.y)).selfMultiply(fo.triAreaDDFast(e,n,s)),r=R.sqr(e.x).selfAdd(R.sqr(e.y)).selfMultiply(fo.triAreaDDFast(t,n,s)),o=R.sqr(n.x).selfAdd(R.sqr(n.y)).selfMultiply(fo.triAreaDDFast(t,e,s)),l=R.sqr(s.x).selfAdd(R.sqr(s.y)).selfMultiply(fo.triAreaDDFast(t,e,n));return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue()>0}static isInCircleCC(t,e,n,s){const i=re.circumcentre(t,e,n),r=t.distance(i);return s.distance(i)-r<=0}static isInCircleNormalized(t,e,n,s){const i=t.x-s.x,r=t.y-s.y,o=e.x-s.x,l=e.y-s.y,a=n.x-s.x,c=n.y-s.y;return(i*i+r*r)*(o*c-a*l)+(o*o+l*l)*(a*r-i*c)+(a*a+c*c)*(i*l-o*r)>0}static isInCircleDDSlow(t,e,n,s){const i=R.valueOf(s.x),r=R.valueOf(s.y),o=R.valueOf(t.x),l=R.valueOf(t.y),a=R.valueOf(e.x),c=R.valueOf(e.y),h=R.valueOf(n.x),u=R.valueOf(n.y),g=o.multiply(o).add(l.multiply(l)).multiply(fo.triAreaDDSlow(a,c,h,u,i,r)),d=a.multiply(a).add(c.multiply(c)).multiply(fo.triAreaDDSlow(o,l,h,u,i,r)),_=h.multiply(h).add(u.multiply(u)).multiply(fo.triAreaDDSlow(o,l,a,c,i,r)),f=i.multiply(i).add(r.multiply(r)).multiply(fo.triAreaDDSlow(o,l,a,c,h,u));return g.subtract(d).add(_).subtract(f).doubleValue()>0}static isInCircleNonRobust(t,e,n,s){return(t.x*t.x+t.y*t.y)*fo.triArea(e,n,s)-(e.x*e.x+e.y*e.y)*fo.triArea(t,n,s)+(n.x*n.x+n.y*n.y)*fo.triArea(t,e,s)-(s.x*s.x+s.y*s.y)*fo.triArea(t,e,n)>0}static isInCircleRobust(t,e,n,s){return fo.isInCircleNormalized(t,e,n,s)}static triAreaDDSlow(t,e,n,s,i,r){return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)))}static triAreaDDFast(t,e,n){const s=R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(n.y).selfSubtract(t.y)),i=R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(n.x).selfSubtract(t.x));return s.selfSubtract(i)}getClass(){return fo}get interfaces_(){return[]}}fo.constructor_=function(){};class po{constructor(){po.constructor_.apply(this,arguments)}static interpolateZ(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.distance(n),i=t.distance(e),r=n.z-e.z;return e.z+r*(i/s)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.z+d*(n.z-e.z)+_*(s.z-e.z)}}circleCenter(t,e){const n=new po(this.getX(),this.getY()),s=this.bisector(n,t),i=this.bisector(t,e),r=new b(s,i);let o=null;try{o=new po(r.getX(),r.getY())}catch(s){if(!(s instanceof S))throw s;O.err.println("a: "+n+"  b: "+t+"  c: "+e),O.err.println(s)}return o}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.z}bisector(t,e){const n=e.getX()-t.getX(),s=e.getY()-t.getY(),i=new b(t.getX()+n/2,t.getY()+s/2,1),r=new b(t.getX()-s+n/2,t.getY()+n+s/2,1);return new b(i,r)}equals(){if(1===arguments.length){const t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._p.distance(t.getCoordinate())<e}}getCoordinate(){return this._p}isInCircle(t,e,n){return fo.isInCircleRobust(t._p,e._p,n._p,this._p)}interpolateZValue(t,e,n){const s=t.getX(),i=t.getY(),r=e.getX()-s,o=n.getX()-s,l=e.getY()-i,a=n.getY()-i,c=r*a-o*l,h=this.getX()-s,u=this.getY()-i,g=(a*h-o*u)/c,d=(-l*h+r*u)/c;return t.getZ()+g*(e.getZ()-t.getZ())+d*(n.getZ()-t.getZ())}midPoint(t){const e=(this._p.x+t.getX())/2,n=(this._p.y+t.getY())/2,s=(this._p.z+t.getZ())/2;return new po(e,n,s)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,e){return(t._p.x-this._p.x)*(e._p.y-this._p.y)-(t._p.y-this._p.y)*(e._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.z=t}times(t){return new po(t*this._p.x,t*this._p.y)}cross(){return new po(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new po(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,e){const n=e.sub(t),s=this.sub(t),i=n.crossProduct(s);return i>0?po.LEFT:i<0?po.RIGHT:n.getX()*s.getX()<0||n.getY()*s.getY()<0?po.BEHIND:n.magn()<s.magn()?po.BEYOND:t.equals(this)?po.ORIGIN:e.equals(this)?po.DESTINATION:po.BETWEEN}sum(t){return new po(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))}circumRadiusRatio(t,e){const n=this.circleCenter(t,e),s=this.distance(n,t);let i=this.distance(this,t),r=this.distance(t,e);return r<i&&(i=r),r=this.distance(e,this),r<i&&(i=r),s/i}getClass(){return po}get interfaces_(){return[]}}po.constructor_=function(){if(this._p=null,1===arguments.length){const t=arguments[0];this._p=new g(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new g(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new g(t,e,n)}},po.LEFT=0,po.RIGHT=1,po.BEYOND=2,po.BEHIND=3,po.BETWEEN=4,po.ORIGIN=5,po.DESTINATION=6;class mo extends po{constructor(){super(),mo.constructor_.apply(this,arguments)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}getClass(){return mo}get interfaces_(){return[]}}mo.constructor_=function(){this._isOnConstraint=null,this._constraint=null;const t=arguments[0];po.constructor_.call(this,t)};class yo{constructor(){yo.constructor_.apply(this,arguments)}static makeEdge(t,e){const n=new yo,s=new yo,i=new yo,r=new yo;n._rot=s,s._rot=i,i._rot=r,r._rot=n,n.setNext(n),s.setNext(r),i.setNext(i),r.setNext(s);const o=n;return o.setOrig(t),o.setDest(e),o}static swap(t){const e=t.oPrev(),n=t.sym().oPrev();yo.splice(t,e),yo.splice(t.sym(),n),yo.splice(t,e.lNext()),yo.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())}static splice(t,e){const n=t.oNext().rot(),s=e.oNext().rot(),i=e.oNext(),r=t.oNext(),o=s.oNext(),l=n.oNext();t.setNext(i),e.setNext(r),n.setNext(o),s.setNext(l)}static connect(t,e){const n=yo.makeEdge(t.dest(),e.orig());return yo.splice(n,t.lNext()),yo.splice(n.sym(),e),n}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new ee(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){const t=this._vertex.getCoordinate(),e=this.dest().getCoordinate();return Jt.toLineString(t,e)}isLive(){return null!==this._rot}getPrimary(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}getClass(){return yo}get interfaces_(){return[]}}yo.constructor_=function(){this._rot=null,this._vertex=null,this._next=null,this._data=null};class xo{constructor(){xo.constructor_.apply(this,arguments)}insertSite(t){let e=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(e,t))return e;this._subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this._subdiv.delete(e.oNext()));let n=this._subdiv.makeEdge(e.orig(),t);yo.splice(n,e);const s=n;do{n=this._subdiv.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);for(;;){const i=e.oPrev();if(i.dest().rightOf(e)&&t.isInCircle(e.orig(),i.dest(),e.dest()))yo.swap(e),e=e.oPrev();else{if(e.oNext()===s)return n;e=e.oNext().lPrev()}}}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getClass(){return xo}get interfaces_(){return[]}}xo.constructor_=function(){this._subdiv=null,this._isUsingTolerance=!1;const t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0};class Eo{constructor(){Eo.constructor_.apply(this,arguments)}locate(t){}getClass(){return Eo}get interfaces_(){return[]}}Eo.constructor_=function(){};class Io{constructor(){Io.constructor_.apply(this,arguments)}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();const e=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=e,e}findEdge(){return this._subdiv.getEdges().iterator().next()}getClass(){return Io}get interfaces_(){return[Eo]}}Io.constructor_=function(){this._subdiv=null,this._lastEdge=null;const t=arguments[0];this._subdiv=t,this.init()};class No extends c{constructor(){super(),No.constructor_.apply(this,arguments)}static msgWithSpatial(t,e){return null!==e?t+" [ "+e+" ]":t}getSegment(){return this._seg}getClass(){return No}get interfaces_(){return[]}}No.constructor_=function(){if(this._seg=null,1===arguments.length){if("string"==typeof arguments[0]){const t=arguments[0];c.constructor_.call(this,t)}else if(arguments[0]instanceof ee){const t=arguments[0];c.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new ee(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];c.constructor_.call(this,No.msgWithSpatial(t,e)),this._seg=new ee(e)}};class Co{constructor(){Co.constructor_.apply(this,arguments)}visit(t){}getClass(){return Co}get interfaces_(){return[]}}Co.constructor_=function(){};class So{constructor(){So.constructor_.apply(this,arguments)}static getTriangleEdges(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new n("Edges do not form a triangle")}getTriangleVertices(t){const e=new To;return this.visitTriangles(e,t),e.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||(!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2]))}isVertexOfEdge(t,e){return!(!e.equals(t.orig(),this._tolerance)&&!e.equals(t.dest(),this._tolerance))}connect(t,e){const n=yo.connect(t,e);return this._quadEdges.add(n),n}getVoronoiCellPolygon(t,e){const n=new x,s=t;do{const e=t.rot().orig().getCoordinate();n.add(e),t=t.oPrev()}while(t!==s);const i=new I;i.addAll(n,!1),i.closeRing(),i.size()<4&&(O.out.println(i),i.add(i.get(i.size()-1),!0));const r=i.toCoordinateArray(),o=e.createPolygon(e.createLinearRing(r)),l=s.orig();return o.setUserData(l.getCoordinate()),o}setLocator(t){this._locator=t}initSubdiv(){const t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),e=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);yo.splice(t.sym(),e);const n=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return yo.splice(e.sym(),n),yo.splice(n.sym(),t),t}isFrameBorderEdge(t){const e=new Array(3).fill(null);So.getTriangleEdges(t,e);const n=new Array(3).fill(null);So.getTriangleEdges(t.sym(),n);const s=t.lNext().dest();if(this.isFrameVertex(s))return!0;const i=t.sym().lNext().dest();return!!this.isFrameVertex(i)}makeEdge(t,e){const n=yo.makeEdge(t,e);return this._quadEdges.add(n),n}visitTriangles(t,e){this._visitedKey++;const n=new on;n.push(this._startingEdge);const s=new J;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=this.fetchTriangleToVisit(i,n,e,s);null!==r&&t.visit(r)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,e){return this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate()),this._seg.distance(e)<this._edgeCoincidenceTolerance}getEnvelope(){return new N(this._frameEnv)}createFrame(t){const e=t.getWidth(),n=t.getHeight();let s=0;s=e>n?10*e:10*n,this._frameVertex[0]=new po((t.getMaxX()+t.getMinX())/2,t.getMaxY()+s),this._frameVertex[1]=new po(t.getMinX()-s,t.getMinY()-s),this._frameVertex[2]=new po(t.getMaxX()+s,t.getMinY()-s),this._frameEnv=new N(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){const e=new Ro;return this.visitTriangles(e,t),e.getTriangles()}getVertices(t){const e=new J;for(let n=this._quadEdges.iterator();n.hasNext();){const s=n.next(),i=s.orig();!t&&this.isFrameVertex(i)||e.add(i);const r=s.dest();!t&&this.isFrameVertex(r)||e.add(r)}return e}fetchTriangleToVisit(t,e,n,s){let i=t,r=0,o=!1;do{this._triEdges[r]=i,this.isFrameEdge(i)&&(o=!0);const t=i.sym();s.contains(t)||e.push(t),s.add(i),r++,i=i.lNext()}while(i!==t);return o&&!n?null:this._triEdges}getEdges(){if(0===arguments.length)return this._quadEdges;if(1===arguments.length){const t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createLineString([e.orig().getCoordinate(),e.dest().getCoordinate()])}return t.createMultiLineString(n)}}getVertexUniqueEdges(t){const e=new x,n=new J;for(let s=this._quadEdges.iterator();s.hasNext();){const i=s.next(),r=i.orig();n.contains(r)||(n.add(r),!t&&this.isFrameVertex(r)||e.add(i));const o=i.sym(),l=o.orig();n.contains(l)||(n.add(l),!t&&this.isFrameVertex(l)||e.add(o))}return e}getTriangleEdges(t){const e=new Lo;return this.visitTriangles(e,t),e.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;const e=new x,n=new on;n.push(this._startingEdge);const s=new J;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=i.getPrimary();!t&&this.isFrameEdge(r)||e.add(r),n.push(i.oNext()),n.push(i.sym().oNext()),s.add(i),s.add(i.sym())}}return e}delete(t){yo.splice(t,t.oPrev()),yo.splice(t.sym(),t.sym().oPrev());const e=t.sym(),n=t.rot(),s=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(e),this._quadEdges.remove(n),this._quadEdges.remove(s),t.delete(),e.delete(),n.delete(),s.delete()}locateFromEdge(t,e){let n=0;const s=this._quadEdges.size();let i=e;for(;;){if(n++,n>s)throw new No(i.toLineSegment());if(t.equals(i.orig())||t.equals(i.dest()))break;if(t.rightOf(i))i=i.sym();else if(t.rightOf(i.oNext())){if(t.rightOf(i.dPrev()))break;i=i.dPrev()}else i=i.oNext()}return i}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new wo,!0);const e=new x;for(let n=this.getVertexUniqueEdges(!1).iterator();n.hasNext();){const s=n.next();e.add(this.getVoronoiCellPolygon(s,t))}return e}getVoronoiDiagram(t){const e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Ht.toGeometryArray(e))}getTriangles(t){const e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createPolygon(t.createLinearRing(e))}return t.createGeometryCollection(n)}insertSite(t){let e=this.locate(t);if(t.equals(e.orig(),this._tolerance)||t.equals(e.dest(),this._tolerance))return e;let n=this.makeEdge(e.orig(),t);yo.splice(n,e);const s=n;do{n=this.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);return s}locate(){if(1===arguments.length){if(arguments[0]instanceof po){const t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof g){const t=arguments[0];return this._locator.locate(new po(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._locator.locate(new po(t));if(null===n)return null;let s=n;n.dest().getCoordinate().equals2D(t)&&(s=n.sym());let i=s;do{if(i.dest().getCoordinate().equals2D(e))return i;i=i.oNext()}while(i!==s);return null}}getClass(){return So}get interfaces_(){return[]}}class wo{constructor(){wo.constructor_.apply(this,arguments)}visit(t){const e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),s=t[2].orig().getCoordinate(),i=re.circumcentre(e,n,s),r=new po(i);for(let e=0;e<3;e++)t[e].rot().setOrig(r)}getClass(){return wo}get interfaces_(){return[Co]}}wo.constructor_=function(){};class Lo{constructor(){Lo.constructor_.apply(this,arguments)}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}getClass(){return Lo}get interfaces_(){return[Co]}}Lo.constructor_=function(){this._triList=new x};class To{constructor(){To.constructor_.apply(this,arguments)}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}getClass(){return To}get interfaces_(){return[Co]}}To.constructor_=function(){this._triList=new x};class Ro{constructor(){Ro.constructor_.apply(this,arguments)}checkTriangleSize(t){let e="";t.length>=2?e=Jt.toLineString(t[0],t[1]):t.length>=1&&(e=Jt.toPoint(t[0]))}visit(t){this._coordList.clear();for(let e=0;e<3;e++){const n=t[e].orig();this._coordList.add(n.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();const t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}getClass(){return Ro}get interfaces_(){return[Co]}}Ro.constructor_=function(){this._coordList=new I,this._triCoords=new x},So.TriangleCircumcentreVisitor=wo,So.TriangleEdgesListVisitor=Lo,So.TriangleVertexListVisitor=To,So.TriangleCoordinatesVisitor=Ro,So.constructor_=function(){this._visitedKey=0,this._quadEdges=new x,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=new Array(3).fill(null),this._frameEnv=null,this._locator=null,this._seg=new ee,this._triEdges=new Array(3).fill(null);const t=arguments[0],e=arguments[1];this._tolerance=e,this._edgeCoincidenceTolerance=e/So.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new Io(this)},So.EDGE_COINCIDENCE_TOL_FACTOR=1e3;class Po{constructor(){Po.constructor_.apply(this,arguments)}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).z}getStartZ(){return this._ls.getCoordinate(0).z}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}getClass(){return Po}get interfaces_(){return[]}}Po.constructor_=function(){if(this._ls=null,this._data=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._ls=new ee(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._ls=new ee(t,e),this._data=n}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];Po.constructor_.call(this,new g(t,e,n),new g(s,i,r))}else if(7===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6];Po.constructor_.call(this,new g(t,e,n),new g(s,i,r),o)}};class vo{constructor(){vo.constructor_.apply(this,arguments)}static computeVertexEnvelope(t){const e=new N;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t.getCoordinate())}return e}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,e=0;do{e=this.enforceGabriel(this._segments),t++}while(e>0&&t<vo.MAX_SPLIT_ITER)}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){const t=new Array(this._initialVertices.size()+this._segVertices.size()).fill(null);let e=0;for(let n=this._initialVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}for(let n=this._segVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}return t}setConstraints(t,e){this._segments=t,this._segVertices=e}computeConvexHull(){const t=new Ht,e=this.getPointArray(),n=new an(e,t);this._convexHull=n.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){const e=t.getStart(),n=t.getEnd(),s=new g((e.x+n.x)/2,(e.y+n.y)/2),r=e.distance(s),o=new N(s);o.expandBy(r);const l=this._kdt.query(o);let a=null,c=i.MAX_VALUE;for(let t=l.iterator();t.hasNext();){const i=t.next().getCoordinate();if(i.equals2D(e)||i.equals2D(n))continue;const o=s.distance(i);if(o<r){const t=o;(null===a||t<c)&&(a=i,c=t)}}return a}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){const e=new x;let n=0;const s=new x;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=this.findNonGabrielPoint(t);if(null===r)continue;this._splitPt=this._splitFinder.findSplitPoint(t,r);const o=this.createVertex(this._splitPt,t);this.insertSite(o).getCoordinate().equals2D(this._splitPt);const l=new Po(t.getStartX(),t.getStartY(),t.getStartZ(),o.getX(),o.getY(),o.getZ(),t.getData()),a=new Po(o.getX(),o.getY(),o.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());e.add(l),e.add(a),s.add(t),n+=1}return t.removeAll(s),t.addAll(e),n}createVertex(){if(1===arguments.length){const t=arguments[0];let e=null;return e=null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new mo(t),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null;return n=null!==this._vertexFactory?this._vertexFactory.createVertex(t,e):new mo(t),n.setOnConstraint(!0),n}}getSubdivision(){return this._subdiv}computeBoundingBox(){const t=vo.computeVertexEnvelope(this._initialVertices),e=vo.computeVertexEnvelope(this._segVertices),n=new N(t);n.expandToInclude(e);const s=.2*n.getWidth(),i=.2*n.getHeight(),r=Math.max(s,i);this._computeAreaEnv=new N(n),this._computeAreaEnv.expandBy(r)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new So(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new Io(this._subdiv)),this._incDel=new xo(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof mo){const t=arguments[0],e=this._kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){const n=e.getData();return n.merge(t),n}return this._incDel.insertSite(t),t}if(arguments[0]instanceof g){const t=arguments[0];this.insertSite(this.createVertex(t))}}getClass(){return vo}get interfaces_(){return[]}}vo.constructor_=function(){this._initialVertices=null,this._segVertices=null,this._segments=new x,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new _o,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._initialVertices=new x(t),this._tolerance=e,this._kdt=new es(e)},vo.MAX_SPLIT_ITER=99;class Oo{constructor(){Oo.constructor_.apply(this,arguments)}static extractUniqueCoordinates(t){if(null===t)return new I;const e=t.getCoordinates();return Oo.unique(e)}static envelope(t){const e=new N;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t)}return e}static unique(t){const e=X.copyDeep(t);return ht.sort(e),new I(e,!1)}static toVertices(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new po(t))}return e}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords),e=Oo.toVertices(this._siteCoords);this._subdiv=new So(t,this._tolerance),new xo(this._subdiv).insertSites(e)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){const t=arguments[0];this._siteCoords=Oo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){const t=arguments[0];this._siteCoords=Oo.unique(X.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}getClass(){return Oo}get interfaces_(){return[]}}Oo.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null};class bo{constructor(){bo.constructor_.apply(this,arguments)}static createConstraintSegments(){if(1===arguments.length){const t=arguments[0],e=xe.getLines(t),n=new x;for(let t=e.iterator();t.hasNext();){const e=t.next();bo.createConstraintSegments(e,n)}return n}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates();for(let t=1;t<n.length;t++)e.add(new Po(n[t-1],n[t]))}}createSiteVertices(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();this._constraintVertexMap.containsKey(t)||e.add(new mo(t))}return e}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords);let e=new x;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),e=bo.createConstraintSegments(this._constraintLines));const n=this.createSiteVertices(this._siteCoords),s=new vo(n,this._tolerance);s.setConstraints(e,new x(this._constraintVertexMap.values())),s.formInitialDelaunay(),s.enforceConstraints(),this._subdiv=s.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=Oo.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){const e=t.getCoordinates();for(let t=0;t<e.length;t++){const n=new mo(e[t]);this._constraintVertexMap.put(e[t],n)}}getClass(){return bo}get interfaces_(){return[]}}bo.constructor_=function(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new rt};class Mo{constructor(){Mo.constructor_.apply(this,arguments)}static clipGeometryCollection(t,e){const n=t.getFactory().toGeometry(e),s=new x;for(let i=0;i<t.getNumGeometries();i++){const r=t.getGeometryN(i);let o=null;e.contains(r.getEnvelopeInternal())?o=r:e.intersects(r.getEnvelopeInternal())&&(o=n.intersection(r),o.setUserData(r.getUserData())),null===o||o.isEmpty()||s.add(o)}return t.getFactory().createGeometryCollection(Ht.toGeometryArray(s))}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords);this._diagramEnv=t;const e=Math.max(this._diagramEnv.getWidth(),this._diagramEnv.getHeight());this._diagramEnv.expandBy(e),null!==this._clipEnv&&this._diagramEnv.expandToInclude(this._clipEnv);const n=Oo.toVertices(this._siteCoords);this._subdiv=new So(t,this._tolerance),new xo(this._subdiv).insertSites(n)}getDiagram(t){this.create();const e=this._subdiv.getVoronoiDiagram(t);return Mo.clipGeometryCollection(e,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){const t=arguments[0];this._siteCoords=Oo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){const t=arguments[0];this._siteCoords=Oo.unique(X.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}getClass(){return Mo}get interfaces_(){return[]}}Mo.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null};var Do=Object.freeze({__proto__:null,Vertex:po}),Ao=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:bo,DelaunayTriangulationBuilder:Oo,VoronoiDiagramBuilder:Mo,quadedge:Do});class Fo{constructor(){Fo.constructor_.apply(this,arguments)}static getEndLocation(t){const e=new Fo;return e.setToEnd(t),e}static pointAlongSegmentByFraction(t,e,n){if(n<=0)return t;if(n>=1)return e;const s=(e.x-t.x)*n+t.x,i=(e.y-t.y)*n+t.y,r=(e.z-t.z)*n+t.z;return new g(s,i,r)}static compareLocationValues(t,e,n,s,i,r){return t<s?-1:t>s?1:e<i?-1:e>i?1:n<r?-1:n>r?1:0}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){const e=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex>=e||this._segmentIndex===e&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;const e=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>e.getNumPoints())&&((this._segmentIndex!==e.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1))}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){const e=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex<e?this:new Fo(this._componentIndex,e,1,!1)}getCoordinate(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=e.getNumPoints()-1)return n;const s=e.getCoordinateN(this._segmentIndex+1);return Fo.pointAlongSegmentByFraction(n,s,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=e.getNumPoints()-1){const t=e.getCoordinateN(e.getNumPoints()-2);return new ee(t,n)}const s=e.getCoordinateN(this._segmentIndex+1);return new ee(n,s)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){const e=t.getGeometryN(this._componentIndex);this._segmentIndex=e.getNumPoints()-1,this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;const e=t.getGeometryN(this._componentIndex);this._segmentIndex=e.getNumPoints()-1,this._segmentFraction=1}compareTo(t){const e=t;return this._componentIndex<e._componentIndex?-1:this._componentIndex>e._componentIndex?1:this._segmentIndex<e._segmentIndex?-1:this._segmentIndex>e._segmentIndex?1:this._segmentFraction<e._segmentFraction?-1:this._segmentFraction>e._segmentFraction?1:0}copy(){return new Fo(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||(t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction))}snapToVertex(t,e){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;const n=this.getSegmentLength(t),s=this._segmentFraction*n,i=n-s;s<=i&&s<e?this._segmentFraction=0:i<=s&&i<e&&(this._segmentFraction=1)}compareLocationValues(t,e,n){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<e?-1:this._segmentIndex>e?1:this._segmentFraction<n?-1:this._segmentFraction>n?1:0}getSegmentLength(t){const e=t.getGeometryN(this._componentIndex);let n=this._segmentIndex;this._segmentIndex>=e.getNumPoints()-1&&(n=e.getNumPoints()-2);const s=e.getCoordinateN(n),i=e.getCoordinateN(n+1);return s.distance(i)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}getClass(){return Fo}get interfaces_(){return[r]}}Fo.constructor_=function(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Fo.constructor_.call(this,0,t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,this.normalize()}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,s&&this.normalize()}};class Go{constructor(){Go.constructor_.apply(this,arguments)}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}getClass(){return Go}get interfaces_(){return[]}}Go.constructor_=function(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1===arguments.length){const t=arguments[0];Go.constructor_.call(this,t,0,0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Go.constructor_.call(this,t,e.getComponentIndex(),Go.segmentEndVertexIndex(e))}else if(3===arguments.length){const t=arguments[0],e=arguments[1],s=arguments[2];if(!_(t,ot))throw new n("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=e,this._vertexIndex=s,this.loadCurrentLine()}};class qo{constructor(){qo.constructor_.apply(this,arguments)}static indexOf(t,e){return new qo(t).indexOf(e)}static indexOfAfter(t,e,n){return new qo(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,e){let n=i.MAX_VALUE,s=0,r=0,o=-1;const l=new ee;for(let i=new Go(this._linearGeom);i.hasNext();i.next())if(!i.isEndOfLine()){l.p0=i.getSegmentStart(),l.p1=i.getSegmentEnd();const a=l.distance(t),c=l.segmentFraction(t),h=i.getComponentIndex(),u=i.getVertexIndex();a<n&&(null===e||e.compareLocationValues(h,u,c)<0)&&(s=h,r=u,o=c,n=a)}return n===i.MAX_VALUE?new Fo(e):new Fo(s,r,o)}indexOfAfter(t,e){if(null===e)return this.indexOf(t);const n=Fo.getEndLocation(this._linearGeom);if(n.compareTo(e)<=0)return n;const s=this.indexOfFromStart(t,e);return u.isTrue(s.compareTo(e)>=0,"computed location is before specified minimum location"),s}getClass(){return qo}get interfaces_(){return[]}}qo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Bo{constructor(){Bo.constructor_.apply(this,arguments)}static indicesOf(t,e){return new Bo(t).indicesOf(e)}indicesOf(t){const e=t.getGeometryN(0).getCoordinateN(0),n=t.getGeometryN(t.getNumGeometries()-1),s=n.getCoordinateN(n.getNumPoints()-1),i=new qo(this._linearGeom),r=new Array(2).fill(null);return r[0]=i.indexOf(e),0===t.getLength()?r[1]=r[0].copy():r[1]=i.indexOfAfter(s,r[0]),r}getClass(){return Bo}get interfaces_(){return[]}}Bo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Vo{constructor(){Vo.constructor_.apply(this,arguments)}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&this._coordList.size()<2)return this._coordList=null,null;const t=this._coordList.toCoordinateArray();let e=t;this._fixInvalidLines&&(e=this.validCoordinateSequence(t)),this._coordList=null;let s=null;try{s=this._geomFact.createLineString(e)}catch(t){if(!(t instanceof n))throw t;if(!this._ignoreInvalidLines)throw t}null!==s&&this._lines.add(s)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1===arguments.length){const t=arguments[0];this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];null===this._coordList&&(this._coordList=new I),this._coordList.add(t,e),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){if(t.length>=2)return t;return[t[0],t[0]]}getClass(){return Vo}get interfaces_(){return[]}}Vo.constructor_=function(){this._geomFact=null,this._lines=new x,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;const t=arguments[0];this._geomFact=t};class zo{constructor(){zo.constructor_.apply(this,arguments)}static extract(t,e,n){return new zo(t).extract(e,n)}computeLinear(t,e){const n=new Vo(this._line.getFactory());n.setFixInvalidLines(!0),t.isVertex()||n.add(t.getCoordinate(this._line));for(let s=new Go(this._line,t);s.hasNext()&&!(e.compareLocationValues(s.getComponentIndex(),s.getVertexIndex(),0)<0);s.next()){const t=s.getSegmentStart();n.add(t),s.isEndOfLine()&&n.endLine()}return e.isVertex()||n.add(e.getCoordinate(this._line)),n.getGeometry()}computeLine(t,e){const n=this._line.getCoordinates(),s=new I;let i=t.getSegmentIndex();t.getSegmentFraction()>0&&(i+=1);let r=e.getSegmentIndex();1===e.getSegmentFraction()&&(r+=1),r>=n.length&&(r=n.length-1),t.isVertex()||s.add(t.getCoordinate(this._line));for(let t=i;t<=r;t++)s.add(n[t]);e.isVertex()||s.add(e.getCoordinate(this._line)),s.size()<=0&&s.add(t.getCoordinate(this._line));let o=s.toCoordinateArray();return o.length<=1&&(o=[o[0],o[0]]),this._line.getFactory().createLineString(o)}extract(t,e){return e.compareTo(t)<0?this.reverse(this.computeLinear(e,t)):this.computeLinear(t,e)}reverse(t){return t instanceof Tt||t instanceof ft?t.reverse():(u.shouldNeverReachHere("non-linear geometry encountered"),null)}getClass(){return zo}get interfaces_(){return[]}}zo.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class Yo{constructor(){Yo.constructor_.apply(this,arguments)}clampIndex(t){const e=t.copy();return e.clamp(this._linearGeom),e}project(t){return qo.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof Tt||this._linearGeom instanceof ft))throw new n("Input geometry must be linear")}extractPoint(){if(1===arguments.length){return arguments[0].getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return Fo.getEndLocation(this._linearGeom)}getStartIndex(){return new Fo}indexOfAfter(t,e){return qo.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){return zo.extract(this._linearGeom,t,e)}indexOf(t){return qo.indexOf(this._linearGeom,t)}indicesOf(t){return Bo.indicesOf(this._linearGeom,t)}getClass(){return Yo}get interfaces_(){return[]}}Yo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t,this.checkGeometryType()};class Uo{constructor(){Uo.constructor_.apply(this,arguments)}static indexOf(t,e){return new Uo(t).indexOf(e)}static indexOfAfter(t,e,n){return new Uo(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,e){let n=i.MAX_VALUE,s=e,r=0;const o=new ee,l=new Go(this._linearGeom);for(;l.hasNext();){if(!l.isEndOfLine()){o.p0=l.getSegmentStart(),o.p1=l.getSegmentEnd();const i=o.distance(t),a=this.segmentNearestMeasure(o,t,r);i<n&&a>e&&(s=a,n=i),r+=o.getLength()}l.next()}return s}indexOfAfter(t,e){if(e<0)return this.indexOf(t);const n=this._linearGeom.getLength();if(n<e)return n;const s=this.indexOfFromStart(t,e);return u.isTrue(s>=e,"computed index is before specified minimum index"),s}segmentNearestMeasure(t,e,n){const s=t.projectionFactor(e);return s<=0?n:s<=1?n+s*t.getLength():n+t.getLength()}getClass(){return Uo}get interfaces_(){return[]}}Uo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class ko{constructor(){ko.constructor_.apply(this,arguments)}static getLength(t,e){return new ko(t).getLength(e)}static getLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new ko(t).getLocation(e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new ko(t).getLocation(e,n)}}getLength(t){let e=0;const n=new Go(this._linearGeom);for(;n.hasNext();){if(!n.isEndOfLine()){const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(t.getComponentIndex()===n.getComponentIndex()&&t.getSegmentIndex()===n.getVertexIndex())return e+i*t.getSegmentFraction();e+=i}n.next()}return e}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let e=t.getComponentIndex();if(e>=this._linearGeom.getNumGeometries()-1)return t;do{e++}while(e<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(e).getLength());return new Fo(e,0,0)}getLocation(){if(1===arguments.length){const t=arguments[0];return this.getLocation(t,!0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=t;if(t<0){n=this._linearGeom.getLength()+t}const s=this.getLocationForward(n);return e?s:this.resolveHigher(s)}}getLocationForward(t){if(t<=0)return new Fo;let e=0;const n=new Go(this._linearGeom);for(;n.hasNext();){if(n.isEndOfLine()){if(e===t){const t=n.getComponentIndex(),e=n.getVertexIndex();return new Fo(t,e,0)}}else{const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(e+i>t){const s=(t-e)/i,r=n.getComponentIndex(),o=n.getVertexIndex();return new Fo(r,o,s)}e+=i}n.next()}return Fo.getEndLocation(this._linearGeom)}getClass(){return ko}get interfaces_(){return[]}}ko.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Xo{constructor(){Xo.constructor_.apply(this,arguments)}clampIndex(t){const e=this.positiveIndex(t),n=this.getStartIndex();if(e<n)return n;const s=this.getEndIndex();return e>s?s:e}locationOf(){if(1===arguments.length){const t=arguments[0];return ko.getLocation(this._linearGeom,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return ko.getLocation(this._linearGeom,t,e)}}project(t){return Uo.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1===arguments.length){const t=arguments[0];return ko.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=ko.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,e){return Uo.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){new Yo(this._linearGeom);const n=this.clampIndex(t),s=this.clampIndex(e),i=n===s,r=this.locationOf(n,i),o=this.locationOf(s);return zo.extract(this._linearGeom,r,o)}indexOf(t){return Uo.indexOf(this._linearGeom,t)}indicesOf(t){const e=Bo.indicesOf(this._linearGeom,t);return[ko.getLength(this._linearGeom,e[0]),ko.getLength(this._linearGeom,e[1])]}getClass(){return Xo}get interfaces_(){return[]}}Xo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};var Ho=Object.freeze({__proto__:null,LengthIndexedLine:Xo,LengthLocationMap:ko,LinearGeometryBuilder:Vo,LinearIterator:Go,LinearLocation:Fo,LocationIndexedLine:Yo});class Wo{constructor(){Wo.constructor_.apply(this,arguments)}static transform(t,e){const n=new x;for(let s=t.iterator();s.hasNext();)n.add(e.execute(s.next()));return n}static select(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next();Boolean.TRUE.equals(e.execute(t))&&n.add(t)}return n}static apply(t,e){for(let n=t.iterator();n.hasNext();)e.execute(n.next())}getClass(){return Wo}get interfaces_(){return[]}}Wo.Function=function(){},Wo.constructor_=function(){};class jo{constructor(){jo.constructor_.apply(this,arguments)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}getClass(){return jo}get interfaces_(){return[B]}}jo.constructor_=function(){this.pts=null,this.n=0;const t=arguments[0];this.pts=new Array(t).fill(null)};class Ko{constructor(){Ko.constructor_.apply(this,arguments)}filter(t){this._n++}getCount(){return this._n}getClass(){return Ko}get interfaces_(){return[B]}}Ko.constructor_=function(){this._n=0};class Zo{constructor(){Zo.constructor_.apply(this,arguments)}count(t){const e=this._counts.get(t);return null===e?0:e.count()}add(t){const e=this._counts.get(t);null===e?this._counts.put(t,new Qo(1)):e.increment()}getClass(){return Zo}get interfaces_(){return[]}}class Qo{constructor(){Qo.constructor_.apply(this,arguments)}count(){return this.count}increment(){this.count++}getClass(){return Qo}get interfaces_(){return[]}}Qo.constructor_=function(){if(this.count=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.count=t}},Zo.Counter=Qo,Zo.constructor_=function(){this._counts=new Ut};var Jo=Object.freeze({__proto__:null,CollectionUtil:Wo,CoordinateArrayFilter:jo,CoordinateCountFilter:Ko,GeometricShapeFactory:Se,NumberUtil:e,ObjectCounter:Zo,PriorityQueue:fs,StringUtil:St,UniqueCoordinateArrayFilter:ln});class $o{get interfaces_(){return[]}getClass(){return $o}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),lr.overlayOp(t,e,cr.UNION)}}q.prototype.equalsTopo=function(t){return!!this.getEnvelopeInternal().equals(t.getEnvelopeInternal())&&Gr.relate(this,t).isEquals(this.getDimension(),t.getDimension())},q.prototype.union=function(){if(0===arguments.length)return zr.union(this);if(1===arguments.length){const t=arguments[0];return $o.union(this,t)}},q.prototype.isValid=function(){return Cr.isValid(this)},q.prototype.intersection=function(t){return cr.intersection(this,t)},q.prototype.covers=function(t){return Gr.covers(this,t)},q.prototype.coveredBy=function(t){return Gr.covers(t,this)},q.prototype.touches=function(t){return Gr.touches(this,t)},q.prototype.intersects=function(t){return Gr.intersects(this,t)},q.prototype.within=function(t){return Gr.contains(t,this)},q.prototype.overlaps=function(t){return Gr.overlaps(this,t)},q.prototype.disjoint=function(t){return Gr.disjoint(this,t)},q.prototype.crosses=function(t){return Gr.crosses(this,t)},q.prototype.buffer=function(){if(1===arguments.length){const t=arguments[0];return Si.bufferOp(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Si.bufferOp(this,t,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return Si.bufferOp(this,t,e,n)}},q.prototype.convexHull=function(){return new an(this).getConvexHull()},q.prototype.relate=function(...t){if(1===arguments.length){const t=arguments[0];return Gr.relate(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Gr.relate(this,t).matches(e)}},q.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();const t=sn.getCentroid(this);return this.createPointFromInternalCoord(t,this)},q.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=null;const e=this.getDimension();t=0===e?new dn(this):1===e?new gn(this):new hn(this);const n=t.getInteriorPoint();return this.createPointFromInternalCoord(n,this)},q.prototype.symDifference=function(t){return cr.symDifference(this,t)},q.prototype.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},q.prototype.toText=function(){return(new Jt).write(this)},q.prototype.toString=function(){this.toText()},q.prototype.contains=function(t){return Gr.contains(this,t)},q.prototype.difference=function(t){return cr.difference(this,t)},q.prototype.isSimple=function(){return new Hs(this).isSimple()},q.prototype.isWithinDistance=function(t,e){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>e)&&Ri.isWithinDistance(this,t,e)},q.prototype.distance=function(t){return Ri.distance(this,t)},q.prototype.isEquivalentClass=function(t){return this.getClass()===t.getClass()};t.algorithm=mn,t.densify=En,t.dissolve=Rn,t.geom=Re,t.geomgraph=Jn,t.index=Cs,t.io=Ps,t.linearref=Ho,t.noding=Xs,t.operation=kr,t.precision=Wr,t.simplify=ho,t.triangulate=Ao,t.util=Jo,t.version="2.1.2 (83b5aee)",Object.defineProperty(t,"__esModule",{value:!0})}));

},{}],6:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],7:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

/**
 * Checks, if polygon is simple. Polygon is simple, when its edges don't cross each other.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean} true if Polygon is simple
 */
function IsSimple (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 4) return true
  var a1 = Point();
  var a2 = Point();
  var b1 = Point();
  var b2 = Point();
  var c = Point();

  for (var i = 0; i < n; i++) {
    a1.x = p[2 * i];
    a1.y = p[2 * i + 1];
    if (i == n - 1) {
      a2.x = p[0];
      a2.y = p[1];
    } else {
      a2.x = p[2 * i + 2];
      a2.y = p[2 * i + 3];
    }

    for (var j = 0; j < n; j++) {
      if (Math.abs(i - j) < 2) continue
      if (j == n - 1 && i == 0) continue
      if (i == n - 1 && j == 0) continue

      b1.x = p[2 * j];
      b1.y = p[2 * j + 1];
      if (j == n - 1) {
        b2.x = p[0];
        b2.y = p[1];
      } else {
        b2.x = p[2 * j + 2];
        b2.y = p[2 * j + 3];
      }

      if (GetLineIntersection(a1, a2, b1, b2, c) != null) return false
    }
  }
  return true
}
module.exports.IsSimple = IsSimple;

/**
 * Checks, if polygon is convex. Polygon is convex, when each inner angle is <= 180°.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean}
 */
function IsConvex (polygon) {
  var p = polygon;
  if (p.length < 6) return true
  var l = p.length - 4;
  for (var i = 0; i < l; i += 2) {
    if (!convex(p[i], p[i + 1], p[i + 2], p[i + 3], p[i + 4], p[i + 5])) return false
  }
  if (!convex(p[l], p[l + 1], p[l + 2], p[l + 3], p[0], p[1])) return false
  if (!convex(p[l + 2], p[l + 3], p[0], p[1], p[2], p[3])) return false
  return true
}
module.exports.IsConvex = IsConvex;

/**
 * Returns the area of polygon.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number}
 */
function GetArea (polygon) {
  var p = polygon;
  if (p.length < 6) return 0
  var l = p.length - 2;
  var sum = 0;
  for (var i = 0; i < l; i += 2) {
    sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
  }
  sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
  return -sum * 0.5
}
module.exports.GetArea = GetArea;

/**
 * Returns the Axis-aligned Bounding Box of polygon
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {AABB}
 * @example
 * //={x:0, y:0, width:0, height:0}
 */
function GetAABB (polygon) {
  var p = polygon;
  var minx = Infinity;
  var miny = Infinity;
  var maxx = -minx;
  var maxy = -miny;
  for (var i = 0; i < p.length; i += 2) {
    minx = Math.min(minx, p[i]);
    maxx = Math.max(maxx, p[i]);
    miny = Math.min(miny, p[i + 1]);
    maxy = Math.max(maxy, p[i + 1]);
  }
  return {x: minx, y: miny, width: maxx - minx, height: maxy - miny}
}
module.exports.GetAABB = GetAABB;

/**
 * Computes the triangulation. Output array is array of triangles (triangle = 3 indices of polygon vertices).
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number[]} array of triangles (triangle = 3 indices of polygon vertices)
 * @example
 * var ids = PolyK.Triangulate([0, 0, 1, 0, 1, 1, 0, 1]);
 * //=[0, 1, 2, 0, 2, 3]
 */
function Triangulate (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 3) return []
  var tgs = [];
  var avl = [];
  for (var i = 0; i < n; i++) { avl.push(i); }

  var i = 0;
  var al = n;
  while (al > 3) {
    var i0 = avl[(i + 0) % al];
    var i1 = avl[(i + 1) % al];
    var i2 = avl[(i + 2) % al];

    var ax = p[2 * i0];
    var ay = p[2 * i0 + 1];
    var bx = p[2 * i1];
    var by = p[2 * i1 + 1];
    var cx = p[2 * i2];
    var cy = p[2 * i2 + 1];

    var earFound = false;
    if (convex(ax, ay, bx, by, cx, cy)) {
      earFound = true;
      for (var j = 0; j < al; j++) {
        var vi = avl[j];
        if (vi == i0 || vi == i1 || vi == i2) continue
        if (PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
          earFound = false;
          break
        }
      }
    }
    if (earFound) {
      tgs.push(i0, i1, i2);
      avl.splice((i + 1) % al, 1);
      al--;
      i = 0;
    } else if (i++ > 3 * al) break    // no convex angles :(
  }
  tgs.push(avl[0], avl[1], avl[2]);
  return tgs
}
module.exports.Triangulate = Triangulate;

/**
 * Slices the polygon with line segment A-B, defined by [ax,ay] and [bx,by]. A, B must not lay inside a polygon. Returns an array of polygons.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} startX Start Coordinate [x]
 * @param {number} startY Start Coordinate [y]
 * @param {number} endX End Coordinate [x]
 * @param {number} endY End Coordinate [y]
 * @returns {number[][]} Array of Polygon
 */
function Slice (polygon, startX, startY, endX, endY) {
  var p = polygon;
  var ax = startX;
  var ay = startY;
  var bx = endX;
  var by = endY;
  if (ContainsPoint(p, ax, ay) || ContainsPoint(p, bx, by)) {
    return [p.slice(0)]
  }

  var a = Point(ax, ay);
  var b = Point(bx, by);
  var iscs = [];  // intersections
  var ps = [];  // points
  for (var i = 0; i < p.length; i += 2) {
    ps.push(Point(p[i], p[i + 1]));
  }
  for (var i = 0; i < ps.length; i++) {
    var isc = Point(0, 0);
    isc = GetLineIntersection(a, b, ps[i], ps[(i + 1) % ps.length], isc);
    var fisc = iscs[0];
    var lisc = iscs[iscs.length - 1];
    // && (isc.x!=ps[i].x || isc.y!=ps[i].y) )
    if (isc && (fisc == null || distance(isc, fisc) > 1e-10) && (lisc == null || distance(isc, lisc) > 1e-10)) {
      isc.flag = true;
      iscs.push(isc);
      ps.splice(i + 1, 0, isc);
      i++;
    }
  }

  if (iscs.length < 2) return [p.slice(0)]
  var comp = function (u, v) { return distance(a, u) - distance(a, v) };
  iscs.sort(comp);

  var pgs = [];
  var dir = 0;
  while (iscs.length > 0) {
    // var n = ps.length // is assigned a value but never used. (no-unused-vars)
    var i0 = iscs[0];
    var i1 = iscs[1];
    // if(i0.x==i1.x && i0.y==i1.y) { iscs.splice(0,2); continue;}
    var index0 = ps.indexOf(i0);
    var index1 = ps.indexOf(i1);
    var solved = false;

    if (firstWithFlag(ps, index0) === index1) {
      solved = true;
    } else {
      i0 = iscs[1];
      i1 = iscs[0];
      index0 = ps.indexOf(i0);
      index1 = ps.indexOf(i1);
      if (firstWithFlag(ps, index0) === index1) solved = true;
    }
    if (solved) {
      dir--;
      var pgn = getPoints(ps, index0, index1);
      pgs.push(pgn);
      ps = getPoints(ps, index1, index0);
      i0.flag = i1.flag = false;
      iscs.splice(0, 2);
      if (iscs.length == 0) pgs.push(ps);
    } else {
      dir++;
      iscs.reverse();
    }
    if (dir > 1) break
  }
  var result = [];
  for (var i = 0; i < pgs.length; i++) {
    var pg = pgs[i];
    var npg = [];
    for (var j = 0; j < pg.length; j++) { npg.push(pg[j].x, pg[j].y); }
    result.push(npg);
  }
  return result
}
module.exports.Slice = Slice;

/**
 * Checks, if polygon contains [x, y].
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} pointX Coordinate [x]
 * @param {number} pointY Coordinate [y]
 * @returns {boolean} depth
 */
function ContainsPoint (polygon, pointX, pointY) {
  var p = polygon;
  var px = pointX;
  var py = pointY;
  var n = p.length >> 1;
  var ax;
  var ay = p[2 * n - 3] - py;
  var bx = p[2 * n - 2] - px;
  var by = p[2 * n - 1] - py;

  // var lup = by > ay;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay === by) continue
    var lup = by > ay;
  }

  var depth = 0;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay < 0 && by < 0) continue  // both "up" or both "down"
    if (ay > 0 && by > 0) continue  // both "up" or both "down"
    if (ax < 0 && bx < 0) continue   // both points on the left

    if (ay === by && Math.min(ax, bx) <= 0) return true
    if (ay === by) continue

    var lx = ax + (bx - ax) * (-ay) / (by - ay);
    if (lx === 0) return true      // point on edge
    if (lx > 0) depth++;
    if (ay === 0 && lup && by > ay) depth--;  // hit vertex, both up
    if (ay === 0 && !lup && by < ay) depth--; // hit vertex, both down
    lup = by > ay;
  }
  return (depth & 1) === 1
}
module.exports.ContainsPoint = ContainsPoint;

/**
 * Finds the closest point of polygon, which lays on ray defined by [x,y] (origin) and [dx,dy] (direction).
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the edge, on which intersection occurs, "norm" is the normal in that place, "refl" is reflected direction.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} originX Origin [x]
 * @param {number} originY Origin [y]
 * @param {number} directionX Direction [x]
 * @param {number} directionY Direction [y]
 * @returns {Raycast}
 * @example
 * //={dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}}
 */
function Raycast (polygon, originX, originY, directionX, directionY, isc) {
  var p = polygon;
  var x = originX;
  var y = originY;
  var dx = directionX;
  var dy = directionY;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var a2 = empty[1];
  var b1 = empty[2];
  var b2 = empty[3];
  var c = empty[4];
  a1.x = x;
  a1.y = y;
  a2.x = x + dx;
  a2.y = y + dy;

  if (isc === null || isc === undefined) {
    isc = {dist: 0, edge: 0, norm: {x: 0, y: 0}, refl: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  var nisc;
  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    nisc = RayLineIntersection(a1, a2, b1, b2, c);
    if (nisc) {
      isc = updateISC(dx, dy, a1, b1, b2, c, i / 2, isc);
    }
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  nisc = RayLineIntersection(a1, a2, b1, b2, c);
  if (nisc) {
    isc = updateISC(dx, dy, a1, b1, b2, c, (p.length / 2) - 1, isc);
  }

  return (isc.dist !== Infinity) ? isc : null
}
module.exports.Raycast = Raycast;

/**
 * Finds the point on polygon edges, which is closest to [x,y]. Returns an object in this format
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the closest edge, "point" is the closest point on that edge, "norm" is the normal from "point" to [x,y].
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} x Coordinate [x]
 * @param {number} y Coordinate [y]
 * @returns {ClosestEdge}
 * @example
 * //={dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}}
 */
function ClosestEdge (polygon, x, y, isc) {
  var p = polygon;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var b1 = empty[2];
  var b2 = empty[3];
  // var c = tp[4] // is assigned a value but never used.
  a1.x = x;
  a1.y = y;

  if (isc == null) {
    isc = {dist: 0, edge: 0, point: {x: 0, y: 0}, norm: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    isc = pointLineDist(a1, b1, b2, i >> 1, isc);
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  isc = pointLineDist(a1, b1, b2, l >> 1, isc);

  var idst = 1 / isc.dist;
  isc.norm.x = (x - isc.point.x) * idst;
  isc.norm.y = (y - isc.point.y) * idst;
  return isc
}
module.exports.ClosestEdge = ClosestEdge;

/**
 * Reverse
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 */
function Reverse (polygon) {
  var p = polygon;
  var np = [];
  for (var j = p.length - 2; j >= 0; j -= 2) { np.push(p[j], p[j + 1]); }
  return np
}
module.exports.Reverse = Reverse;

/**
 * Point Line Distance
 *
 * @private
 * @param {Point} p
 * @param {Point} a
 * @param {Point} b
 * @param {??} edge
 * @param {??} isc
 * @returns {??} ISC
 */
function pointLineDist (p, a, b, edge, isc) {
  var x = p.x;
  var y = p.y;
  var x1 = a.x;
  var y1 = a.y;
  var x2 = b.x;
  var y2 = b.y;

  var A = x - x1;
  var B = y - y1;
  var C = x2 - x1;
  var D = y2 - y1;

  var dot = A * C + B * D;
  var lenSq = C * C + D * D;
  var param = dot / lenSq;

  var xx;
  var yy;

  if (param < 0 || (x1 == x2 && y1 == y2)) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  var dx = x - xx;
  var dy = y - yy;
  var dst = Math.sqrt(dx * dx + dy * dy);
  if (dst < isc.dist) {
    isc.dist = dst;
    isc.edge = edge;
    isc.point.x = xx;
    isc.point.y = yy;
  }
  return isc
}

/**
 * Update ISC
 *
 * @private
 * @param {number} dx
 * @param {number} dy
 * @param {Point} a1
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @param {??} edge
 * @param {??} isc
 * @returns {??}
 */
function updateISC (dx, dy, a1, b1, b2, c, edge, isc) {
  var nrl = distance(a1, c);
  if (nrl < isc.dist) {
    var ibl = 1 / distance(b1, b2);
    var nx = -(b2.y - b1.y) * ibl;
    var ny = (b2.x - b1.x) * ibl;
    var ddot = 2 * (dx * nx + dy * ny);
    isc.dist = nrl;
    isc.norm.x = nx;
    isc.norm.y = ny;
    isc.refl.x = -ddot * nx + dx;
    isc.refl.y = -ddot * ny + dy;
    isc.edge = edge;
  }
  return isc
}

/**
 * Get Points
 *
 * @private
 * @param {number[]} points
 * @param {number} index0
 * @param {number} index1
 * @returns {number[]} points
 */
function getPoints (points, index0, index1) {
  var n = points.length;
  var result = [];
  if (index1 < index0) index1 += n;
  for (var i = index0; i <= index1; i++) { result.push(points[i % n]); }
  return result
}

/**
 * First With Flag
 *
 * @private
 * @param {Point[]} points
 * @param {number} index
 * @returns {number}
 */
function firstWithFlag (points, index) {
  var n = points.length;
  while (true) {
    index = (index + 1) % n;
    if (points[index].flag) {
      return index
    }
  }
}

/**
 * Point in Triangle
 *
 * @private
 * @param {number} px
 * @param {number} py
 * @param {number} ax
 * @param {number} ay
 * @param {number} bx
 * @param {number} by
 * @param {number} cx
 * @param {number} cy
 * @returns {boolean}
 */
function PointInTriangle (px, py, ax, ay, bx, by, cx, cy) {
  var v0x = cx - ax;
  var v0y = cy - ay;
  var v1x = bx - ax;
  var v1y = by - ay;
  var v2x = px - ax;
  var v2y = py - ay;

  var dot00 = v0x * v0x + v0y * v0y;
  var dot01 = v0x * v1x + v0y * v1y;
  var dot02 = v0x * v2x + v0y * v2y;
  var dot11 = v1x * v1x + v1y * v1y;
  var dot12 = v1x * v2x + v1y * v2y;

  var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
  var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

  // Check if point is in triangle
  return (u >= 0) && (v >= 0) && (u + v < 1)
}

/**
 * RayLine Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 */
function RayLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;
  if (Den == 0) return null  // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  var iDen = 1 / Den;
  I.x = (A * dbx - dax * B) * iDen;
  I.y = (A * dby - day * B) * iDen;

  if (!InRectangle(I, b1, b2)) return null
  if ((day > 0 && I.y > a1.y) || (day < 0 && I.y < a1.y)) return null
  if ((dax > 0 && I.x > a1.x) || (dax < 0 && I.x < a1.x)) return null
  return I
}

/**
 * Get Line Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @returns {Point}
 */
function GetLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;

  if (Den === 0) { return null } // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  I.x = (A * dbx - dax * B) / Den;
  I.y = (A * dby - day * B) / Den;

  if (InRectangle(I, a1, a2) && InRectangle(I, b1, b2)) {
    return I
  }
  return null
}

/**
 * In Rectangle
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @param {Point} c
 * @return {boolean}
 */
function InRectangle (a, b, c) {
  var minx = Math.min(b.x, c.x);
  var maxx = Math.max(b.x, c.x);
  var miny = Math.min(b.y, c.y);
  var maxy = Math.max(b.y, c.y);

  if (minx === maxx) { return (miny <= a.y && a.y <= maxy) }
  if (miny === maxy) { return (minx <= a.x && a.x <= maxx) }

  // return (minx <= a.x && a.x <= maxx && miny <= a.y && a.y <= maxy)
  return (minx <= a.x + 1e-10 && a.x - 1e-10 <= maxx && miny <= a.y + 1e-10 && a.y - 1e-10 <= maxy)
}

/**
 * Convex
 *
 * @private
 * @param {Point} ax
 * @param {Point} ay
 * @param {Point} bx
 * @param {Point} by
 * @param {Point} cx
 * @param {Point} cy
 * @returns {boolean}
 */
function convex (ax, ay, bx, by, cx, cy) {
  return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0
}

/**
 * Point
 *
 * @private
 * @param {number} x
 * @param {number} y
 * @returns {Point}
 */
function Point (x, y) {
  return {
    x: x,
    y: y,
    flag: false,
    toString: function () { return 'Point [' + x + ', ' + y + ']' }
  }
}

/**
 * Distance
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @returns {number}
 */
function distance (a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy)
}

/**
 * Creates an array of empty Points
 *
 * @private
 * @param {number} [num=10] Number of points
 * @returns {Point[]}
 */
function emptyPoints (num) {
  num = num || 10;
  var container = [];
  for (var i = 0; i < num; i++) { container.push(Point(0, 0)); }
  return container
}

})));


},{}],8:[function(require,module,exports){
"use strict";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(e,n)};function e(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}function n(){for(var t=0,e=0,n=arguments.length;e<n;e++)t+=arguments[e].length;var r=Array(t),a=0;for(e=0;e<n;e++)for(var o=arguments[e],s=0,h=o.length;s<h;s++,a++)r[a]=o[s];return r}function r(t,e,n){if(t&&t.length){var r=e[0],a=e[1],o=Math.PI/180*n,s=Math.cos(o),h=Math.sin(o);t.forEach((function(t){var e=t[0],n=t[1];t[0]=(e-r)*s-(n-a)*h+r,t[1]=(e-r)*h+(n-a)*s+a}))}}function a(t){var e=t[0],n=t[1];return Math.sqrt(Math.pow(e[0]-n[0],2)+Math.pow(e[1]-n[1],2))}function o(t,e){var a=[0,0],o=Math.round(e.hachureAngle+90);o&&r(t,a,o);var s=function(t,e){var r=n(t);r[0].join(",")!==r[r.length-1].join(",")&&r.push([r[0][0],r[0][1]]);var a=[];if(r&&r.length>2){var o=e.hachureGap;o<0&&(o=4*e.strokeWidth),o=Math.max(o,.1);for(var s=[],h=0;h<r.length-1;h++){var i=r[h],u=r[h+1];if(i[1]!==u[1]){var p=Math.min(i[1],u[1]);s.push({ymin:p,ymax:Math.max(i[1],u[1]),x:p===i[1]?i[0]:u[0],islope:(u[0]-i[0])/(u[1]-i[1])})}}if(s.sort((function(t,e){return t.ymin<e.ymin?-1:t.ymin>e.ymin?1:t.x<e.x?-1:t.x>e.x?1:t.ymax===e.ymax?0:(t.ymax-e.ymax)/Math.abs(t.ymax-e.ymax)})),!s.length)return a;for(var c=[],l=s[0].ymin;c.length||s.length;){if(s.length){var f=-1;for(h=0;h<s.length&&!(s[h].ymin>l);h++)f=h;s.splice(0,f+1).forEach((function(t){c.push({s:l,edge:t})}))}if((c=c.filter((function(t){return!(t.edge.ymax<=l)}))).sort((function(t,e){return t.edge.x===e.edge.x?0:(t.edge.x-e.edge.x)/Math.abs(t.edge.x-e.edge.x)})),c.length>1)for(h=0;h<c.length;h+=2){var d=h+1;if(d>=c.length)break;var g=c[h].edge,y=c[d].edge;a.push([[Math.round(g.x),l],[Math.round(y.x),l]])}l+=o,c.forEach((function(t){t.edge.x=t.edge.x+o*t.edge.islope}))}}return a}(t,e);return o&&(r(t,a,-o),function(t,e,n){var a=[];t.forEach((function(t){return a.push.apply(a,t)})),r(a,e,n)}(s,a,-o)),s}var s=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){return this._fillPolygon(t,e)},t.prototype._fillPolygon=function(t,e,n){void 0===n&&(n=!1);var r=o(t,e);return{type:"fillSketch",ops:this.renderLines(r,e,n)}},t.prototype.renderLines=function(t,e,n){for(var r=[],a=null,o=0,s=t;o<s.length;o++){var h=s[o];r.push.apply(r,this.helper.doubleLineOps(h[0][0],h[0][1],h[1][0],h[1][1],e)),n&&a&&r.push.apply(r,this.helper.doubleLineOps(a[0],a[1],h[0][0],h[0][1],e)),a=h[1]}return r},t}(),h=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.fillPolygon=function(t,e){return this._fillPolygon(t,e,!0)},n}(s),i=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.fillPolygon=function(t,e){var n=this._fillPolygon(t,e),r=Object.assign({},e,{hachureAngle:e.hachureAngle+90}),a=this._fillPolygon(t,r);return n.ops=n.ops.concat(a.ops),n},n}(s),u=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){var n=o(t,e=Object.assign({},e,{curveStepCount:4,hachureAngle:0,roughness:1}));return this.dotsOnLines(n,e)},t.prototype.dotsOnLines=function(t,e){var n=[],r=e.hachureGap;r<0&&(r=4*e.strokeWidth),r=Math.max(r,.1);var o=e.fillWeight;o<0&&(o=e.strokeWidth/2);for(var s=r/4,h=0,i=t;h<i.length;h++)for(var u=i[h],p=a(u),c=p/r,l=Math.ceil(c)-1,f=p-l*r,d=(u[0][0]+u[1][0])/2-r/4,g=Math.min(u[0][1],u[1][1]),y=0;y<l;y++){var v=g+f+y*r,M=this.helper.randOffsetWithRange(d-s,d+s,e),k=this.helper.randOffsetWithRange(v-s,v+s,e),b=this.helper.ellipse(M,k,o,o,e);n.push.apply(n,b.ops)}return{type:"fillSketch",ops:n}},t}(),p=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){var n=o(t,e);return{type:"fillSketch",ops:this.dashedLine(n,e)}},t.prototype.dashedLine=function(t,e){var n=this,r=e.dashOffset<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashOffset,o=e.dashGap<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashGap,s=[];return t.forEach((function(t){var h=a(t),i=Math.floor(h/(r+o)),u=(h+o-i*(r+o))/2,p=t[0],c=t[1];p[0]>c[0]&&(p=t[1],c=t[0]);for(var l=Math.atan((c[1]-p[1])/(c[0]-p[0])),f=0;f<i;f++){var d=f*(r+o),g=d+r,y=[p[0]+d*Math.cos(l)+u*Math.cos(l),p[1]+d*Math.sin(l)+u*Math.sin(l)],v=[p[0]+g*Math.cos(l)+u*Math.cos(l),p[1]+g*Math.sin(l)+u*Math.sin(l)];s.push.apply(s,n.helper.doubleLineOps(y[0],y[1],v[0],v[1],e))}})),s},t}(),c=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){var n=e.hachureGap<0?4*e.strokeWidth:e.hachureGap,r=e.zigzagOffset<0?n:e.zigzagOffset,a=o(t,e=Object.assign({},e,{hachureGap:n+r}));return{type:"fillSketch",ops:this.zigzagLines(a,r,e)}},t.prototype.zigzagLines=function(t,e,r){var o=this,s=[];return t.forEach((function(t){var h=a(t),i=Math.round(h/(2*e)),u=t[0],p=t[1];u[0]>p[0]&&(u=t[1],p=t[0]);for(var c=Math.atan((p[1]-u[1])/(p[0]-u[0])),l=0;l<i;l++){var f=2*l*e,d=2*(l+1)*e,g=Math.sqrt(2*Math.pow(e,2)),y=[u[0]+f*Math.cos(c),u[1]+f*Math.sin(c)],v=[u[0]+d*Math.cos(c),u[1]+d*Math.sin(c)],M=[y[0]+g*Math.cos(c+Math.PI/4),y[1]+g*Math.sin(c+Math.PI/4)];s.push.apply(s,n(o.helper.doubleLineOps(y[0],y[1],M[0],M[1],r),o.helper.doubleLineOps(M[0],M[1],v[0],v[1],r)))}})),s},t}(),l={};var f=function(){function t(t){this.seed=t}return t.prototype.next=function(){return this.seed?(Math.pow(2,31)-1&(this.seed=Math.imul(48271,this.seed)))/Math.pow(2,31):Math.random()},t}();const d={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function g(t,e){return t.type===e}function y(t){const e=[],n=function(t){const e=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:0,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];e[e.length]={type:1,text:""+parseFloat(RegExp.$1)},t=t.substr(RegExp.$1.length)}return e[e.length]={type:2,text:""},e}(t);let r="BOD",a=0,o=n[a];for(;!g(o,2);){let s=0;const h=[];if("BOD"===r){if("M"!==o.text&&"m"!==o.text)return y("M0,0"+t);a++,s=d[o.text],r=o.text}else g(o,1)?s=d[r]:(a++,s=d[o.text],r=o.text);if(!(a+s<n.length))throw new Error("Path data ended short");for(let t=a;t<a+s;t++){const e=n[t];if(!g(e,1))throw new Error("Param not a number: "+r+","+e.text);h[h.length]=+e.text}if("number"!=typeof d[r])throw new Error("Bad segment: "+r);{const t={key:r,data:h};e.push(t),a+=s,o=n[a],"M"===r&&(r="L"),"m"===r&&(r="l")}}return e}function v(t){let e=0,n=0,r=0,a=0;const o=[];for(const{key:s,data:h}of t)switch(s){case"M":o.push({key:"M",data:[...h]}),[e,n]=h,[r,a]=h;break;case"m":e+=h[0],n+=h[1],o.push({key:"M",data:[e,n]}),r=e,a=n;break;case"L":o.push({key:"L",data:[...h]}),[e,n]=h;break;case"l":e+=h[0],n+=h[1],o.push({key:"L",data:[e,n]});break;case"C":o.push({key:"C",data:[...h]}),e=h[4],n=h[5];break;case"c":{const t=h.map((t,r)=>r%2?t+n:t+e);o.push({key:"C",data:t}),e=t[4],n=t[5];break}case"Q":o.push({key:"Q",data:[...h]}),e=h[2],n=h[3];break;case"q":{const t=h.map((t,r)=>r%2?t+n:t+e);o.push({key:"Q",data:t}),e=t[2],n=t[3];break}case"A":o.push({key:"A",data:[...h]}),e=h[5],n=h[6];break;case"a":e+=h[5],n+=h[6],o.push({key:"A",data:[h[0],h[1],h[2],h[3],h[4],e,n]});break;case"H":o.push({key:"H",data:[...h]}),e=h[0];break;case"h":e+=h[0],o.push({key:"H",data:[e]});break;case"V":o.push({key:"V",data:[...h]}),n=h[0];break;case"v":n+=h[0],o.push({key:"V",data:[n]});break;case"S":o.push({key:"S",data:[...h]}),e=h[2],n=h[3];break;case"s":{const t=h.map((t,r)=>r%2?t+n:t+e);o.push({key:"S",data:t}),e=t[2],n=t[3];break}case"T":o.push({key:"T",data:[...h]}),e=h[0],n=h[1];break;case"t":e+=h[0],n+=h[1],o.push({key:"T",data:[e,n]});break;case"Z":case"z":o.push({key:"Z",data:[]}),e=r,n=a}return o}function M(t){const e=[];let n="",r=0,a=0,o=0,s=0,h=0,i=0;for(const{key:u,data:p}of t){switch(u){case"M":e.push({key:"M",data:[...p]}),[r,a]=p,[o,s]=p;break;case"C":e.push({key:"C",data:[...p]}),r=p[4],a=p[5],h=p[2],i=p[3];break;case"L":e.push({key:"L",data:[...p]}),[r,a]=p;break;case"H":r=p[0],e.push({key:"L",data:[r,a]});break;case"V":a=p[0],e.push({key:"L",data:[r,a]});break;case"S":{let t=0,o=0;"C"===n||"S"===n?(t=r+(r-h),o=a+(a-i)):(t=r,o=a),e.push({key:"C",data:[t,o,...p]}),h=p[0],i=p[1],r=p[2],a=p[3];break}case"T":{const[t,o]=p;let s=0,u=0;"Q"===n||"T"===n?(s=r+(r-h),u=a+(a-i)):(s=r,u=a);const c=r+2*(s-r)/3,l=a+2*(u-a)/3,f=t+2*(s-t)/3,d=o+2*(u-o)/3;e.push({key:"C",data:[c,l,f,d,t,o]}),h=s,i=u,r=t,a=o;break}case"Q":{const[t,n,o,s]=p,u=r+2*(t-r)/3,c=a+2*(n-a)/3,l=o+2*(t-o)/3,f=s+2*(n-s)/3;e.push({key:"C",data:[u,c,l,f,o,s]}),h=t,i=n,r=o,a=s;break}case"A":{const t=Math.abs(p[0]),n=Math.abs(p[1]),o=p[2],s=p[3],h=p[4],i=p[5],u=p[6];if(0===t||0===n)e.push({key:"C",data:[r,a,i,u,i,u]}),r=i,a=u;else if(r!==i||a!==u){b(r,a,i,u,t,n,o,s,h).forEach((function(t){e.push({key:"C",data:t})})),r=i,a=u}break}case"Z":e.push({key:"Z",data:[]}),r=o,a=s}n=u}return e}function k(t,e,n){return[t*Math.cos(n)-e*Math.sin(n),t*Math.sin(n)+e*Math.cos(n)]}function b(t,e,n,r,a,o,s,h,i,u){const p=(c=s,Math.PI*c/180);var c;let l=[],f=0,d=0,g=0,y=0;if(u)[f,d,g,y]=u;else{[t,e]=k(t,e,-p),[n,r]=k(n,r,-p);const s=(t-n)/2,u=(e-r)/2;let c=s*s/(a*a)+u*u/(o*o);c>1&&(c=Math.sqrt(c),a*=c,o*=c);const l=a*a,v=o*o,M=l*v-l*u*u-v*s*s,b=l*u*u+v*s*s,m=(h===i?-1:1)*Math.sqrt(Math.abs(M/b));g=m*a*u/o+(t+n)/2,y=m*-o*s/a+(e+r)/2,f=Math.asin(parseFloat(((e-y)/o).toFixed(9))),d=Math.asin(parseFloat(((r-y)/o).toFixed(9))),t<g&&(f=Math.PI-f),n<g&&(d=Math.PI-d),f<0&&(f=2*Math.PI+f),d<0&&(d=2*Math.PI+d),i&&f>d&&(f-=2*Math.PI),!i&&d>f&&(d-=2*Math.PI)}let v=d-f;if(Math.abs(v)>120*Math.PI/180){const t=d,e=n,h=r;d=i&&d>f?f+120*Math.PI/180*1:f+120*Math.PI/180*-1,l=b(n=g+a*Math.cos(d),r=y+o*Math.sin(d),e,h,a,o,s,0,i,[d,t,g,y])}v=d-f;const M=Math.cos(f),m=Math.sin(f),w=Math.cos(d),P=Math.sin(d),x=Math.tan(v/4),O=4/3*a*x,S=4/3*o*x,T=[t,e],_=[t+O*m,e-S*M],C=[n+O*P,r-S*w],W=[n,r];if(_[0]=2*T[0]-_[0],_[1]=2*T[1]-_[1],u)return[_,C,W].concat(l);{l=[_,C,W].concat(l);const t=[];for(let e=0;e<l.length;e+=3){const n=k(l[e][0],l[e][1],p),r=k(l[e+1][0],l[e+1][1],p),a=k(l[e+2][0],l[e+2][1],p);t.push([n[0],n[1],r[0],r[1],a[0],a[1]])}return t}}var m={randOffset:function(t,e){return E(t,e)},randOffsetWithRange:function(t,e,n){return L(t,e,n)},ellipse:function(t,e,n,r,a){var o=O(n,r,a);return S(t,e,a,o).opset},doubleLineOps:function(t,e,n,r,a){return z(t,e,n,r,a)}};function w(t,e,n,r,a){return{type:"path",ops:z(t,e,n,r,a)}}function P(t,e,n){var r=(t||[]).length;if(r>2){for(var a=[],o=0;o<r-1;o++)a.push.apply(a,z(t[o][0],t[o][1],t[o+1][0],t[o+1][1],n));return e&&a.push.apply(a,z(t[r-1][0],t[r-1][1],t[0][0],t[0][1],n)),{type:"path",ops:a}}return 2===r?w(t[0][0],t[0][1],t[1][0],t[1][1],n):{type:"path",ops:[]}}function x(t,e,n,r,a){return function(t,e){return P(t,!0,e)}([[t,e],[t+n,e],[t+n,e+r],[t,e+r]],a)}function O(t,e,n){var r=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),a=Math.max(n.curveStepCount,n.curveStepCount/Math.sqrt(200)*r),o=2*Math.PI/a,s=Math.abs(t/2),h=Math.abs(e/2),i=1-n.curveFitting;return{increment:o,rx:s+=E(s*i,n),ry:h+=E(h*i,n)}}function S(t,e,n,r){var a=G(r.increment,t,e,r.rx,r.ry,1,r.increment*L(.1,L(.4,1,n),n),n),o=a[0],s=a[1],h=G(r.increment,t,e,r.rx,r.ry,1.5,0,n)[0],i=q(o,null,n),u=q(h,null,n);return{estimatedPoints:s,opset:{type:"path",ops:i.concat(u)}}}function T(t,e,r,a,o,s,h,i,u){var p=t,c=e,l=Math.abs(r/2),f=Math.abs(a/2);l+=E(.01*l,u),f+=E(.01*f,u);for(var d=o,g=s;d<0;)d+=2*Math.PI,g+=2*Math.PI;g-d>2*Math.PI&&(d=0,g=2*Math.PI);var y=2*Math.PI/u.curveStepCount,v=Math.min(y/2,(g-d)/2),M=j(v,p,c,l,f,d,g,1,u),k=j(v,p,c,l,f,d,g,1.5,u),b=M.concat(k);return h&&(i?b.push.apply(b,n(z(p,c,p+l*Math.cos(d),c+f*Math.sin(d),u),z(p,c,p+l*Math.cos(g),c+f*Math.sin(g),u))):b.push({op:"lineTo",data:[p,c]},{op:"lineTo",data:[p+l*Math.cos(d),c+f*Math.sin(d)]})),{type:"path",ops:b}}function _(t,e){for(var n=M(v(y(t))),r=[],a=[0,0],o=[0,0],s=function(t,n){switch(t){case"M":var s=1*(e.maxRandomnessOffset||0);r.push({op:"move",data:n.map((function(t){return t+E(s,e)}))}),o=[n[0],n[1]],a=[n[0],n[1]];break;case"L":r.push.apply(r,z(o[0],o[1],n[0],n[1],e)),o=[n[0],n[1]];break;case"C":var h=n[0],i=n[1],u=n[2],p=n[3],c=n[4],l=n[5];r.push.apply(r,function(t,e,n,r,a,o,s,h){for(var i=[],u=[h.maxRandomnessOffset||1,(h.maxRandomnessOffset||1)+.3],p=[0,0],c=0;c<2;c++)0===c?i.push({op:"move",data:[s[0],s[1]]}):i.push({op:"move",data:[s[0]+E(u[0],h),s[1]+E(u[0],h)]}),p=[a+E(u[c],h),o+E(u[c],h)],i.push({op:"bcurveTo",data:[t+E(u[c],h),e+E(u[c],h),n+E(u[c],h),r+E(u[c],h),p[0],p[1]]});return i}(h,i,u,p,c,l,o,e)),o=[c,l];break;case"Z":r.push.apply(r,z(o[0],o[1],a[0],a[1],e)),o=[a[0],a[1]]}},h=0,i=n;h<i.length;h++){var u=i[h];s(u.key,u.data)}return{type:"path",ops:r}}function C(t,e){var n=[];if(t.length){var r=e.maxRandomnessOffset||0,a=t.length;if(a>2){n.push({op:"move",data:[t[0][0]+E(r,e),t[0][1]+E(r,e)]});for(var o=1;o<a;o++)n.push({op:"lineTo",data:[t[o][0]+E(r,e),t[o][1]+E(r,e)]})}}return{type:"fillPath",ops:n}}function W(t,e){return function(t,e){var n=t.fillStyle||"hachure";if(!l[n])switch(n){case"zigzag":l[n]||(l[n]=new h(e));break;case"cross-hatch":l[n]||(l[n]=new i(e));break;case"dots":l[n]||(l[n]=new u(e));break;case"dashed":l[n]||(l[n]=new p(e));break;case"zigzag-line":l[n]||(l[n]=new c(e));break;case"hachure":default:l[n="hachure"]||(l[n]=new s(e))}return l[n]}(e,m).fillPolygon(t,e)}function I(t){return t.randomizer||(t.randomizer=new f(t.seed||0)),t.randomizer.next()}function L(t,e,n,r){return void 0===r&&(r=1),n.roughness*r*(I(n)*(e-t)+t)}function E(t,e,n){return void 0===n&&(n=1),L(-t,t,e,n)}function z(t,e,n,r,a){var o=A(t,e,n,r,a,!0,!1),s=A(t,e,n,r,a,!0,!0);return o.concat(s)}function A(t,e,n,r,a,o,s){var h=Math.pow(t-n,2)+Math.pow(e-r,2),i=Math.sqrt(h),u=1;u=i<200?1:i>500?.4:-.0016668*i+1.233334;var p=a.maxRandomnessOffset||0;p*p*100>h&&(p=i/10);var c=p/2,l=.2+.2*I(a),f=a.bowing*a.maxRandomnessOffset*(r-e)/200,d=a.bowing*a.maxRandomnessOffset*(t-n)/200;f=E(f,a,u),d=E(d,a,u);var g=[],y=function(){return E(c,a,u)},v=function(){return E(p,a,u)};return o&&(s?g.push({op:"move",data:[t+y(),e+y()]}):g.push({op:"move",data:[t+E(p,a,u),e+E(p,a,u)]})),s?g.push({op:"bcurveTo",data:[f+t+(n-t)*l+y(),d+e+(r-e)*l+y(),f+t+2*(n-t)*l+y(),d+e+2*(r-e)*l+y(),n+y(),r+y()]}):g.push({op:"bcurveTo",data:[f+t+(n-t)*l+v(),d+e+(r-e)*l+v(),f+t+2*(n-t)*l+v(),d+e+2*(r-e)*l+v(),n+v(),r+v()]}),g}function R(t,e,n){var r=[];r.push([t[0][0]+E(e,n),t[0][1]+E(e,n)]),r.push([t[0][0]+E(e,n),t[0][1]+E(e,n)]);for(var a=1;a<t.length;a++)r.push([t[a][0]+E(e,n),t[a][1]+E(e,n)]),a===t.length-1&&r.push([t[a][0]+E(e,n),t[a][1]+E(e,n)]);return q(r,null,n)}function q(t,e,n){var r=t.length,a=[];if(r>3){var o=[],s=1-n.curveTightness;a.push({op:"move",data:[t[1][0],t[1][1]]});for(var h=1;h+2<r;h++){var i=t[h];o[0]=[i[0],i[1]],o[1]=[i[0]+(s*t[h+1][0]-s*t[h-1][0])/6,i[1]+(s*t[h+1][1]-s*t[h-1][1])/6],o[2]=[t[h+1][0]+(s*t[h][0]-s*t[h+2][0])/6,t[h+1][1]+(s*t[h][1]-s*t[h+2][1])/6],o[3]=[t[h+1][0],t[h+1][1]],a.push({op:"bcurveTo",data:[o[1][0],o[1][1],o[2][0],o[2][1],o[3][0],o[3][1]]})}if(e&&2===e.length){var u=n.maxRandomnessOffset;a.push({op:"lineTo",data:[e[0]+E(u,n),e[1]+E(u,n)]})}}else 3===r?(a.push({op:"move",data:[t[1][0],t[1][1]]}),a.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===r&&a.push.apply(a,z(t[0][0],t[0][1],t[1][0],t[1][1],n));return a}function G(t,e,n,r,a,o,s,h){var i=[],u=[],p=E(.5,h)-Math.PI/2;u.push([E(o,h)+e+.9*r*Math.cos(p-t),E(o,h)+n+.9*a*Math.sin(p-t)]);for(var c=p;c<2*Math.PI+p-.01;c+=t){var l=[E(o,h)+e+r*Math.cos(c),E(o,h)+n+a*Math.sin(c)];i.push(l),u.push(l)}return u.push([E(o,h)+e+r*Math.cos(p+2*Math.PI+.5*s),E(o,h)+n+a*Math.sin(p+2*Math.PI+.5*s)]),u.push([E(o,h)+e+.98*r*Math.cos(p+s),E(o,h)+n+.98*a*Math.sin(p+s)]),u.push([E(o,h)+e+.9*r*Math.cos(p+.5*s),E(o,h)+n+.9*a*Math.sin(p+.5*s)]),[u,i]}function j(t,e,n,r,a,o,s,h,i){var u=o+E(.1,i),p=[];p.push([E(h,i)+e+.9*r*Math.cos(u-t),E(h,i)+n+.9*a*Math.sin(u-t)]);for(var c=u;c<=s;c+=t)p.push([E(h,i)+e+r*Math.cos(c),E(h,i)+n+a*Math.sin(c)]);return p.push([e+r*Math.cos(s),n+a*Math.sin(s)]),p.push([e+r*Math.cos(s),n+a*Math.sin(s)]),q(p,null,i)}function Z(t){return[...t]}function D(t,e){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function F(t,e,n){const r=D(e,n);if(0===r)return D(t,e);let a=((t[0]-e[0])*(n[0]-e[0])+(t[1]-e[1])*(n[1]-e[1]))/r;return a=Math.max(0,Math.min(1,a)),D(t,Q(e,n,a))}function Q(t,e,n){return[t[0]+(e[0]-t[0])*n,t[1]+(e[1]-t[1])*n]}function H(t,e,n,r){const a=r||[];if(function(t,e){const n=t[e+0],r=t[e+1],a=t[e+2],o=t[e+3];let s=3*r[0]-2*n[0]-o[0];s*=s;let h=3*r[1]-2*n[1]-o[1];h*=h;let i=3*a[0]-2*o[0]-n[0];i*=i;let u=3*a[1]-2*o[1]-n[1];return u*=u,s<i&&(s=i),h<u&&(h=u),s+h}(t,e)<n){const n=t[e+0];if(a.length){(o=a[a.length-1],s=n,Math.sqrt(D(o,s)))>1&&a.push(n)}else a.push(n);a.push(t[e+3])}else{const r=.5,o=t[e+0],s=t[e+1],h=t[e+2],i=t[e+3],u=Q(o,s,r),p=Q(s,h,r),c=Q(h,i,r),l=Q(u,p,r),f=Q(p,c,r),d=Q(l,f,r);H([o,u,l,d],0,n,a),H([d,f,c,i],0,n,a)}var o,s;return a}function N(t,e){return V(t,0,t.length,e)}function V(t,e,n,r,a){const o=a||[],s=t[e],h=t[n-1];let i=0,u=1;for(let r=e+1;r<n-1;++r){const e=F(t[r],s,h);e>i&&(i=e,u=r)}return Math.sqrt(i)>r?(V(t,e,u+1,r,o),V(t,u,n,r,o)):(o.length||o.push(s),o.push(h)),o}function $(t,e=.15,n){const r=[],a=(t.length-1)/3;for(let n=0;n<a;n++){H(t,3*n,e,r)}return n&&n>0?V(r,0,r.length,n):r}var B="none",J=function(){function t(t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,combineNestedSvgPaths:!1},this.config=t||{},this.config.options&&(this.defaultOptions=this._o(this.config.options))}return t.newSeed=function(){return Math.floor(Math.random()*Math.pow(2,31))},t.prototype._o=function(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions},t.prototype._d=function(t,e,n){return{shape:t,sets:e||[],options:n||this.defaultOptions}},t.prototype.line=function(t,e,n,r,a){var o=this._o(a);return this._d("line",[w(t,e,n,r,o)],o)},t.prototype.rectangle=function(t,e,n,r,a){var o=this._o(a),s=[],h=x(t,e,n,r,o);if(o.fill){var i=[[t,e],[t+n,e],[t+n,e+r],[t,e+r]];"solid"===o.fillStyle?s.push(C(i,o)):s.push(W(i,o))}return o.stroke!==B&&s.push(h),this._d("rectangle",s,o)},t.prototype.ellipse=function(t,e,n,r,a){var o=this._o(a),s=[],h=O(n,r,o),i=S(t,e,o,h);if(o.fill)if("solid"===o.fillStyle){var u=S(t,e,o,h).opset;u.type="fillPath",s.push(u)}else s.push(W(i.estimatedPoints,o));return o.stroke!==B&&s.push(i.opset),this._d("ellipse",s,o)},t.prototype.circle=function(t,e,n,r){var a=this.ellipse(t,e,n,n,r);return a.shape="circle",a},t.prototype.linearPath=function(t,e){var n=this._o(e);return this._d("linearPath",[P(t,!1,n)],n)},t.prototype.arc=function(t,e,n,r,a,o,s,h){void 0===s&&(s=!1);var i=this._o(h),u=[],p=T(t,e,n,r,a,o,s,!0,i);if(s&&i.fill)if("solid"===i.fillStyle){var c=T(t,e,n,r,a,o,!0,!1,i);c.type="fillPath",u.push(c)}else u.push(function(t,e,n,r,a,o,s){var h=t,i=e,u=Math.abs(n/2),p=Math.abs(r/2);u+=E(.01*u,s),p+=E(.01*p,s);for(var c=a,l=o;c<0;)c+=2*Math.PI,l+=2*Math.PI;l-c>2*Math.PI&&(c=0,l=2*Math.PI);for(var f=(l-c)/s.curveStepCount,d=[],g=c;g<=l;g+=f)d.push([h+u*Math.cos(g),i+p*Math.sin(g)]);return d.push([h+u*Math.cos(l),i+p*Math.sin(l)]),d.push([h,i]),W(d,s)}(t,e,n,r,a,o,i));return i.stroke!==B&&u.push(p),this._d("arc",u,i)},t.prototype.curve=function(t,e){var n=this._o(e),r=[],a=function(t,e){var n=R(t,1*(1+.2*e.roughness),e),r=R(t,1.5*(1+.22*e.roughness),e);return{type:"path",ops:n.concat(r)}}(t,n);if(n.fill&&n.fill!==B&&t.length>=3){var o=$(function(t,e=0){const n=t.length;if(n<3)throw new Error("A curve must have at least three points.");const r=[];if(3===n)r.push(Z(t[0]),Z(t[1]),Z(t[2]),Z(t[2]));else{const n=[];n.push(t[0],t[0]);for(let e=1;e<t.length;e++)n.push(t[e]),e===t.length-1&&n.push(t[e]);const a=[],o=1-e;r.push(Z(n[0]));for(let t=1;t+2<n.length;t++){const e=n[t];a[0]=[e[0],e[1]],a[1]=[e[0]+(o*n[t+1][0]-o*n[t-1][0])/6,e[1]+(o*n[t+1][1]-o*n[t-1][1])/6],a[2]=[n[t+1][0]+(o*n[t][0]-o*n[t+2][0])/6,n[t+1][1]+(o*n[t][1]-o*n[t+2][1])/6],a[3]=[n[t+1][0],n[t+1][1]],r.push(a[1],a[2],a[3])}}return r}(t),10,(1+n.roughness)/2);"solid"===n.fillStyle?r.push(C(o,n)):r.push(W(o,n))}return n.stroke!==B&&r.push(a),this._d("curve",r,n)},t.prototype.polygon=function(t,e){var n=this._o(e),r=[],a=P(t,!0,n);return n.fill&&("solid"===n.fillStyle?r.push(C(t,n)):r.push(W(t,n))),n.stroke!==B&&r.push(a),this._d("polygon",r,n)},t.prototype.path=function(t,e){var n=this._o(e),r=[];if(!t)return this._d("path",r,n);t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");var a=n.fill&&"transparent"!==n.fill&&n.fill!==B,o=n.stroke!==B,s=!!(n.simplification&&n.simplification<1),h=function(t,e,n){const r=M(v(y(t))),a=[];let o=[],s=[0,0],h=[];const i=()=>{h.length>=4&&o.push(...$(h,e)),h=[]},u=()=>{i(),o.length&&(a.push(o),o=[])};for(const{key:t,data:e}of r)switch(t){case"M":u(),s=[e[0],e[1]],o.push(s);break;case"L":i(),o.push([e[0],e[1]]);break;case"C":if(!h.length){const t=o.length?o[o.length-1]:s;h.push([t[0],t[1]])}h.push([e[0],e[1]]),h.push([e[2],e[3]]),h.push([e[4],e[5]]);break;case"Z":i(),o.push([s[0],s[1]])}if(u(),!n)return a;const p=[];for(const t of a){const e=N(t,n);e.length&&p.push(e)}return p}(t,1,s?4-4*n.simplification:(1+n.roughness)/2);if(a)if(n.combineNestedSvgPaths){var i=[];h.forEach((function(t){return i.push.apply(i,t)})),"solid"===n.fillStyle?r.push(C(i,n)):r.push(W(i,n))}else h.forEach((function(t){"solid"===n.fillStyle?r.push(C(t,n)):r.push(W(t,n))}));return o&&(s?h.forEach((function(t){r.push(P(t,!1,n))})):r.push(_(t,n))),this._d("path",r,n)},t.prototype.opsToPath=function(t){for(var e="",n=0,r=t.ops;n<r.length;n++){var a=r[n],o=a.data;switch(a.op){case"move":e+="M"+o[0]+" "+o[1]+" ";break;case"bcurveTo":e+="C"+o[0]+" "+o[1]+", "+o[2]+" "+o[3]+", "+o[4]+" "+o[5]+" ";break;case"lineTo":e+="L"+o[0]+" "+o[1]+" "}}return e.trim()},t.prototype.toPaths=function(t){for(var e=t.sets||[],n=t.options||this.defaultOptions,r=[],a=0,o=e;a<o.length;a++){var s=o[a],h=null;switch(s.type){case"path":h={d:this.opsToPath(s),stroke:n.stroke,strokeWidth:n.strokeWidth,fill:B};break;case"fillPath":h={d:this.opsToPath(s),stroke:B,strokeWidth:0,fill:n.fill||B};break;case"fillSketch":h=this.fillSketch(s,n)}h&&r.push(h)}return r},t.prototype.fillSketch=function(t,e){var n=e.fillWeight;return n<0&&(n=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill||B,strokeWidth:n,fill:B}},t}(),K=function(){function t(t,e){this.canvas=t,this.ctx=this.canvas.getContext("2d"),this.gen=new J(e)}return t.prototype.draw=function(t){for(var e=t.sets||[],n=t.options||this.getDefaultOptions(),r=this.ctx,a=0,o=e;a<o.length;a++){var s=o[a];switch(s.type){case"path":r.save(),r.strokeStyle="none"===n.stroke?"transparent":n.stroke,r.lineWidth=n.strokeWidth,this._drawToContext(r,s),r.restore();break;case"fillPath":r.save(),r.fillStyle=n.fill||"";var h="curve"===t.shape||"polygon"===t.shape?"evenodd":"nonzero";this._drawToContext(r,s,h),r.restore();break;case"fillSketch":this.fillSketch(r,s,n)}}},t.prototype.fillSketch=function(t,e,n){var r=n.fillWeight;r<0&&(r=n.strokeWidth/2),t.save(),t.strokeStyle=n.fill||"",t.lineWidth=r,this._drawToContext(t,e),t.restore()},t.prototype._drawToContext=function(t,e,n){void 0===n&&(n="nonzero"),t.beginPath();for(var r=0,a=e.ops;r<a.length;r++){var o=a[r],s=o.data;switch(o.op){case"move":t.moveTo(s[0],s[1]);break;case"bcurveTo":t.bezierCurveTo(s[0],s[1],s[2],s[3],s[4],s[5]);break;case"lineTo":t.lineTo(s[0],s[1])}}"fillPath"===e.type?t.fill(n):t.stroke()},Object.defineProperty(t.prototype,"generator",{get:function(){return this.gen},enumerable:!0,configurable:!0}),t.prototype.getDefaultOptions=function(){return this.gen.defaultOptions},t.prototype.line=function(t,e,n,r,a){var o=this.gen.line(t,e,n,r,a);return this.draw(o),o},t.prototype.rectangle=function(t,e,n,r,a){var o=this.gen.rectangle(t,e,n,r,a);return this.draw(o),o},t.prototype.ellipse=function(t,e,n,r,a){var o=this.gen.ellipse(t,e,n,r,a);return this.draw(o),o},t.prototype.circle=function(t,e,n,r){var a=this.gen.circle(t,e,n,r);return this.draw(a),a},t.prototype.linearPath=function(t,e){var n=this.gen.linearPath(t,e);return this.draw(n),n},t.prototype.polygon=function(t,e){var n=this.gen.polygon(t,e);return this.draw(n),n},t.prototype.arc=function(t,e,n,r,a,o,s,h){void 0===s&&(s=!1);var i=this.gen.arc(t,e,n,r,a,o,s,h);return this.draw(i),i},t.prototype.curve=function(t,e){var n=this.gen.curve(t,e);return this.draw(n),n},t.prototype.path=function(t,e){var n=this.gen.path(t,e);return this.draw(n),n},t}(),U="http://www.w3.org/2000/svg",X=function(){function t(t,e){this.svg=t,this.gen=new J(e)}return t.prototype.draw=function(t){for(var e=t.sets||[],n=t.options||this.getDefaultOptions(),r=this.svg.ownerDocument||window.document,a=r.createElementNS(U,"g"),o=0,s=e;o<s.length;o++){var h=s[o],i=null;switch(h.type){case"path":(i=r.createElementNS(U,"path")).setAttribute("d",this.opsToPath(h)),i.style.stroke=n.stroke,i.style.strokeWidth=n.strokeWidth+"",i.style.fill="none";break;case"fillPath":(i=r.createElementNS(U,"path")).setAttribute("d",this.opsToPath(h)),i.style.stroke="none",i.style.strokeWidth="0",i.style.fill=n.fill||"";break;case"fillSketch":i=this.fillSketch(r,h,n)}i&&a.appendChild(i)}return a},t.prototype.fillSketch=function(t,e,n){var r=n.fillWeight;r<0&&(r=n.strokeWidth/2);var a=t.createElementNS(U,"path");return a.setAttribute("d",this.opsToPath(e)),a.style.stroke=n.fill||"",a.style.strokeWidth=r+"",a.style.fill="none",a},Object.defineProperty(t.prototype,"generator",{get:function(){return this.gen},enumerable:!0,configurable:!0}),t.prototype.getDefaultOptions=function(){return this.gen.defaultOptions},t.prototype.opsToPath=function(t){return this.gen.opsToPath(t)},t.prototype.line=function(t,e,n,r,a){var o=this.gen.line(t,e,n,r,a);return this.draw(o)},t.prototype.rectangle=function(t,e,n,r,a){var o=this.gen.rectangle(t,e,n,r,a);return this.draw(o)},t.prototype.ellipse=function(t,e,n,r,a){var o=this.gen.ellipse(t,e,n,r,a);return this.draw(o)},t.prototype.circle=function(t,e,n,r){var a=this.gen.circle(t,e,n,r);return this.draw(a)},t.prototype.linearPath=function(t,e){var n=this.gen.linearPath(t,e);return this.draw(n)},t.prototype.polygon=function(t,e){var n=this.gen.polygon(t,e);return this.draw(n)},t.prototype.arc=function(t,e,n,r,a,o,s,h){void 0===s&&(s=!1);var i=this.gen.arc(t,e,n,r,a,o,s,h);return this.draw(i)},t.prototype.curve=function(t,e){var n=this.gen.curve(t,e);return this.draw(n)},t.prototype.path=function(t,e){var n=this.gen.path(t,e);return this.draw(n)},t}(),Y={canvas:function(t,e){return new K(t,e)},svg:function(t,e){return new X(t,e)},generator:function(t){return new J(t)},newSeed:function(){return J.newSeed()}};module.exports=Y;

},{}],9:[function(require,module,exports){
/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.


 Copyright (c) 2018 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
(function() {
  'use strict';

  var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
  var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
  var F3 = 1.0 / 3.0;
  var G3 = 1.0 / 6.0;
  var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
  var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;

  function SimplexNoise(randomOrSeed) {
    var random;
    if (typeof randomOrSeed == 'function') {
      random = randomOrSeed;
    }
    else if (randomOrSeed) {
      random = alea(randomOrSeed);
    } else {
      random = Math.random;
    }
    this.p = buildPermutationTable(random);
    this.perm = new Uint8Array(512);
    this.permMod12 = new Uint8Array(512);
    for (var i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }

  }
  SimplexNoise.prototype = {
    grad3: new Float32Array([1, 1, 0,
      -1, 1, 0,
      1, -1, 0,

      -1, -1, 0,
      1, 0, 1,
      -1, 0, 1,

      1, 0, -1,
      -1, 0, -1,
      0, 1, 1,

      0, -1, 1,
      0, 1, -1,
      0, -1, -1]),
    grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,
      0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,
      1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,
      -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,
      1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,
      -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,
      1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,
      -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
    noise2D: function(xin, yin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0 = 0; // Noise contributions from the three corners
      var n1 = 0;
      var n2 = 0;
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin) * F2; // Hairy factor for 2D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var t = (i + j) * G2;
      var X0 = i - t; // Unskew the cell origin back to (x,y) space
      var Y0 = j - t;
      var x0 = xin - X0; // The x,y distances from the cell origin
      var y0 = yin - Y0;
      // For the 2D case, the simplex shape is an equilateral triangle.
      // Determine which simplex we are in.
      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      else {
        i1 = 0;
        j1 = 1;
      } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
      // c = (3-sqrt(3))/6
      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
      var y1 = y0 - j1 + G2;
      var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
      var y2 = y0 - 1.0 + 2.0 * G2;
      // Work out the hashed gradient indices of the three simplex corners
      var ii = i & 255;
      var jj = j & 255;
      // Calculate the contribution from the three corners
      var t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 >= 0) {
        var gi0 = permMod12[ii + perm[jj]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 >= 0) {
        var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
      }
      var t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 >= 0) {
        var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 70.0 * (n0 + n1 + n2);
    },
    // 3D simplex noise
    noise3D: function(xin, yin, zin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0, n1, n2, n3; // Noise contributions from the four corners
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var k = Math.floor(zin + s);
      var t = (i + j + k) * G3;
      var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
      var Y0 = j - t;
      var Z0 = k - t;
      var x0 = xin - X0; // The x,y,z distances from the cell origin
      var y0 = yin - Y0;
      var z0 = zin - Z0;
      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
      // Determine which simplex we are in.
      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // X Y Z order
        else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // X Z Y order
        else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // Z X Y order
      }
      else { // x0<y0
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Z Y X order
        else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Y Z X order
        else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // Y X Z order
      }
      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
      // c = 1/6.
      var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;
      var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
      var y2 = y0 - j2 + 2.0 * G3;
      var z2 = z0 - k2 + 2.0 * G3;
      var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
      var y3 = y0 - 1.0 + 3.0 * G3;
      var z3 = z0 - 1.0 + 3.0 * G3;
      // Work out the hashed gradient indices of the four simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      // Calculate the contribution from the four corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
        t3 *= t3;
        n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to stay just inside [-1,1]
      return 32.0 * (n0 + n1 + n2 + n3);
    },
    // 4D simplex noise, better simplex rank ordering method 2012-03-09
    noise4D: function(x, y, z, w) {
      var perm = this.perm;
      var grad4 = this.grad4;

      var n0, n1, n2, n3, n4; // Noise contributions from the five corners
      // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
      var s = (x + y + z + w) * F4; // Factor for 4D skewing
      var i = Math.floor(x + s);
      var j = Math.floor(y + s);
      var k = Math.floor(z + s);
      var l = Math.floor(w + s);
      var t = (i + j + k + l) * G4; // Factor for 4D unskewing
      var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
      var Y0 = j - t;
      var Z0 = k - t;
      var W0 = l - t;
      var x0 = x - X0; // The x,y,z,w distances from the cell origin
      var y0 = y - Y0;
      var z0 = z - Z0;
      var w0 = w - W0;
      // For the 4D case, the simplex is a 4D shape I won't even try to describe.
      // To find out which of the 24 possible simplices we're in, we need to
      // determine the magnitude ordering of x0, y0, z0 and w0.
      // Six pair-wise comparisons are performed between each possible pair
      // of the four coordinates, and the results are used to rank the numbers.
      var rankx = 0;
      var ranky = 0;
      var rankz = 0;
      var rankw = 0;
      if (x0 > y0) rankx++;
      else ranky++;
      if (x0 > z0) rankx++;
      else rankz++;
      if (x0 > w0) rankx++;
      else rankw++;
      if (y0 > z0) ranky++;
      else rankz++;
      if (y0 > w0) ranky++;
      else rankw++;
      if (z0 > w0) rankz++;
      else rankw++;
      var i1, j1, k1, l1; // The integer offsets for the second simplex corner
      var i2, j2, k2, l2; // The integer offsets for the third simplex corner
      var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
      // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
      // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
      // impossible. Only the 24 indices which have non-zero entries make any sense.
      // We use a thresholding to set the coordinates in turn from the largest magnitude.
      // Rank 3 denotes the largest coordinate.
      i1 = rankx >= 3 ? 1 : 0;
      j1 = ranky >= 3 ? 1 : 0;
      k1 = rankz >= 3 ? 1 : 0;
      l1 = rankw >= 3 ? 1 : 0;
      // Rank 2 denotes the second largest coordinate.
      i2 = rankx >= 2 ? 1 : 0;
      j2 = ranky >= 2 ? 1 : 0;
      k2 = rankz >= 2 ? 1 : 0;
      l2 = rankw >= 2 ? 1 : 0;
      // Rank 1 denotes the second smallest coordinate.
      i3 = rankx >= 1 ? 1 : 0;
      j3 = ranky >= 1 ? 1 : 0;
      k3 = rankz >= 1 ? 1 : 0;
      l3 = rankw >= 1 ? 1 : 0;
      // The fifth corner has all coordinate offsets = 1, so no need to compute that.
      var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
      var y1 = y0 - j1 + G4;
      var z1 = z0 - k1 + G4;
      var w1 = w0 - l1 + G4;
      var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
      var y2 = y0 - j2 + 2.0 * G4;
      var z2 = z0 - k2 + 2.0 * G4;
      var w2 = w0 - l2 + 2.0 * G4;
      var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
      var y3 = y0 - j3 + 3.0 * G4;
      var z3 = z0 - k3 + 3.0 * G4;
      var w3 = w0 - l3 + 3.0 * G4;
      var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
      var y4 = y0 - 1.0 + 4.0 * G4;
      var z4 = z0 - 1.0 + 4.0 * G4;
      var w4 = w0 - 1.0 + 4.0 * G4;
      // Work out the hashed gradient indices of the five simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      var ll = l & 255;
      // Calculate the contribution from the five corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;
        t0 *= t0;
        n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;
        t1 *= t1;
        n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;
        t2 *= t2;
        n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;
        t3 *= t3;
        n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
      }
      var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0) n4 = 0.0;
      else {
        var gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;
        t4 *= t4;
        n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
      }
      // Sum up and scale the result to cover the range [-1,1]
      return 27.0 * (n0 + n1 + n2 + n3 + n4);
    }
  };

  function buildPermutationTable(random) {
    var i;
    var p = new Uint8Array(256);
    for (i = 0; i < 256; i++) {
      p[i] = i;
    }
    for (i = 0; i < 255; i++) {
      var r = i + ~~(random() * (256 - i));
      var aux = p[i];
      p[i] = p[r];
      p[r] = aux;
    }
    return p;
  }
  SimplexNoise._buildPermutationTable = buildPermutationTable;

  function alea() {
    // Johannes Baagøe <baagoe@baagoe.com>, 2010
    var s0 = 0;
    var s1 = 0;
    var s2 = 0;
    var c = 1;

    var mash = masher();
    s0 = mash(' ');
    s1 = mash(' ');
    s2 = mash(' ');

    for (var i = 0; i < arguments.length; i++) {
      s0 -= mash(arguments[i]);
      if (s0 < 0) {
        s0 += 1;
      }
      s1 -= mash(arguments[i]);
      if (s1 < 0) {
        s1 += 1;
      }
      s2 -= mash(arguments[i]);
      if (s2 < 0) {
        s2 += 1;
      }
    }
    mash = null;
    return function() {
      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
      s0 = s1;
      s1 = s2;
      return s2 = t - (c = t | 0);
    };
  }
  function masher() {
    var n = 0xefc8249d;
    return function(data) {
      data = data.toString();
      for (var i = 0; i < data.length; i++) {
        n += data.charCodeAt(i);
        var h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000; // 2^32
      }
      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    };
  }

  // amd
  if (typeof define !== 'undefined' && define.amd) define(function() {return SimplexNoise;});
  // common js
  if (typeof exports !== 'undefined') exports.SimplexNoise = SimplexNoise;
  // browser
  else if (typeof window !== 'undefined') window.SimplexNoise = SimplexNoise;
  // nodejs
  if (typeof module !== 'undefined') {
    module.exports = SimplexNoise;
  }

})();

},{}],10:[function(require,module,exports){
/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') {
    module.exports = simplify;
    module.exports.default = simplify;
} else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],11:[function(require,module,exports){
module.exports=// bgColour: string;
// bgColourIn?: string;
// buildingColour?: string;
// buildingStroke?: string;
// seaColour: string;
// grassColour?: string;
// minorRoadColour: string;
// minorRoadOutline?: string;
// majorRoadColour?: string;
// majorRoadOutline?: string;
// mainRoadColour?: string;
// mainRoadOutline?: string;  // Be careful, inherits majorRoadOutline, not mainRoadColour
// outlineSize?: number;      // Cascade semantics in style.ts
// zoomBuildings?: boolean;

{
    "Default": {
        "bgColour": "rgb(236,229,219)",
        "buildingStroke": "#282828",
        // "buildingColour": "red",
        "seaColour": "#a9d9fe",
        "grassColour": "#c5e8c5",
        "minorRoadOutline": "#020202",
        "minorRoadColour": "#F8F8F8",
        "mainRoadOutline": "#282828",
        "mainRoadColour": "#FAFA7A",
    },
    "Apple": {
        "bgColour": "rgb(248,245,238)",
        "buildingColour": "rgb(239,236,229)",
        "buildingStroke": "rgb(235,234,224)",
        "seaColour": "rgb(184,224,243)",
        "grassColour": "rgb(224,237,205)",
        "minorRoadColour": "rgb(255,255,255)",
        "minorRoadOutline": "rgb(215,208,198)",
        "majorRoadColour": "rgb(252,252,224)",
        "majorRoadOutline": "rgb(240,210,152)",
        "mainRoadColour": "rgb(250,224,98)",
        "mainRoadOutline": "rgb(238,199,132)",
        "zoomBuildings": true,
        "outlineSize": 2,
    },
    "AppleDark": {
        "bgColour": "rgb(43,45,47)",
        "buildingColour": "rgb(52,54,56)",
        "buildingStroke": "rgb(47,49,51)",
        "seaColour": "rgb(55,68,100)",
        "grassColour": "rgb(40,56,56)",
        "minorRoadColour": "rgb(65,68,71)",
        "minorRoadOutline": "rgb(43,45,47)",
        "majorRoadColour": "rgb(78,81,84)",
        "majorRoadOutline": "rgb(43,45,47)",
        "mainRoadColour": "rgb(149,108,62)",
        "mainRoadOutline": "rgb(51,51,51)",
        "zoomBuildings": true,
        "outlineSize": 1,
    },
    "Assassin": {
        "bgColour": "rgb(77,96,89)",
        "buildingStroke": "rgb(72,91,84)",
        "seaColour": "rgb(36,40,43)",
        "minorRoadColour": "rgb(127,141,137)",
        "mainRoadColour": "rgb(149,161,157)",
        "mainRoadOutline": "rgb(149,161,157)",
    },
    "Drawn": {},  // Special canvas
    "Google": {
        "bgColour": "rgb(248,249,250)",
        "bgColourIn": "rgb(241,242,243)",
        "buildingColour": "rgb(240,240,240)",
        "buildingStroke": "rgb(220,220,220)",
        "seaColour": "rgb(166,213,249)",
        "grassColour": "rgb(198,232,198)",
        "minorRoadColour": "rgb(255,255,255)",
        "minorRoadOutline": "rgb(193,197,214)",
        "mainRoadColour": "rgb(255,242,175)",
        "mainRoadOutline": "rgb(246,207,101)",
        "zoomBuildings": true,
    },
    "Paper": {
        "bgColour": "white",
        "seaColour": "rgb(233,240,255)",
        "grassColour": "rgb(197,232,197)",
        "minorRoadColour": "white",
        "minorRoadOutline": "rgb(222,223,227)",
        "outlineSize": 2,
    },
    "SubtleGrey": {
        "bgColour": "rgb(247,247,247)",
        "buildingColour": "rgb(251,251,251)",
        "buildingStroke": "rgb(243,243,243)",
        "seaColour": "rgb(162,162,157)",
        "grassColour": "rgb(239,239,239)",
        "minorRoadOutline": "white",
        "minorRoadColour": "rgb(212,212,212)",
        "mainRoadOutline": "rgb(208,208,208)",
        "mainRoadColour": "rgb(208,208,208)",
        "frameTextColour": "rgb(162,162,157)",
    },
    "UltraLight": {
        "bgColour": "rgb(247,247,247)",
        "seaColour": "rgb(237,237,237)",
        "buildingStroke": "rgb(238,238,238)",
        "grassColour": "rgb(229,229,229)",
        "minorRoadColour": "white",
    },
    "Wy": {
        "bgColour": "white",
        "seaColour": "rgb(200,215,212)",
        "buildingStroke": "rgb(238,238,238)",
        "minorRoadOutline": "rgb(190,190,190)",
        "minorRoadColour": "rgb(238,238,238)",
    }
}

},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var dat = require("dat.gui");
var tensor_field_gui_1 = require("./ts/ui/tensor_field_gui");
var roads_gui_1 = require("./ts/ui/roads_gui");
var canvas_wrapper_1 = require("./ts/ui/canvas_wrapper");
var util_1 = require("./ts/util");
var drag_controller_1 = require("./ts/ui/drag_controller");
var domain_controller_1 = require("./ts/ui/domain_controller");
var style_1 = require("./ts/ui/style");
var ColourSchemes = require("./colour_schemes.json");
var Main = /** @class */ (function () {
    function Main() {
        var _this = this;
        this.domainController = domain_controller_1.default.getInstance();
        this.gui = new dat.GUI({ width: 300 });
        this.dragController = new drag_controller_1.default(this.gui);
        // Options
        this.imageScale = 3;
        // To force draw if needed
        this.previousFrameDrawTensor = true;
        this.colourScheme = "Default";
        this.zoomBuildings = false;
        this.showFrame = false;
        this.highDPI = false;
        this.canvas = document.getElementById(util_1.default.CANVAS_ID);
        this.tensorCanvas = new canvas_wrapper_1.DefaultCanvasWrapper(this.canvas);
        var zoomController = this.gui.add(this.domainController, 'zoom');
        this.domainController.setZoomUpdate(function () { return zoomController.updateDisplay(); });
        var noiseParams = {
            globalNoise: false,
            noiseSizePark: 20,
            noiseAnglePark: 90,
            noiseSizeGlobal: 30,
            noiseAngleGlobal: 20
        };
        this.tensorFolder = this.gui.addFolder('Tensor Field');
        this.tensorField = new tensor_field_gui_1.default(this.tensorFolder, this.dragController, true, noiseParams);
        this.tensorFolder.open();
        this.roadsFolder = this.gui.addFolder('Map');
        this.roadsFolder.open();
        this.roadsGUI = new roads_gui_1.default(this.roadsFolder, this.tensorField, function () { return _this.tensorFolder.close(); });
        var optionsFolder = this.gui.addFolder('Options');
        optionsFolder.add(this.tensorField, 'drawCentre');
        var canvasScaleController = optionsFolder.add(this, 'highDPI');
        canvasScaleController.onChange(function (high) { return _this.changeCanvasScale(high); });
        optionsFolder.add(this, 'imageScale', 1, 5).step(1);
        optionsFolder.add(this, 'download');
        // Style
        this.styleFolder = this.gui.addFolder('Style');
        var styleController = this.styleFolder.add(this, 'colourScheme', Object.keys(ColourSchemes));
        this.styleFolder.add(this, 'zoomBuildings').onChange(function (val) {
            if (_this._style instanceof style_1.DefaultStyle) {
                // Force redraw
                _this.previousFrameDrawTensor = true;
                _this._style.zoomBuildings = val;
            }
        });
        this.styleFolder.add(this, 'showFrame').onChange(function (val) {
            _this.previousFrameDrawTensor = true;
            _this._style.showFrame = val;
        });
        styleController.onChange(function (val) { return _this.changeColourScheme(val); });
        this.changeColourScheme(this.colourScheme);
        this.tensorField.setRecommended();
        requestAnimationFrame(this.update.bind(this));
    }
    Main.prototype.changeColourScheme = function (scheme) {
        if (scheme === "Drawn") {
            this._style = new style_1.RoughStyle(this.canvas);
        }
        else {
            var colourScheme = ColourSchemes[scheme];
            this.zoomBuildings = colourScheme.zoomBuildings;
            util_1.default.updateGui(this.styleFolder);
            this._style = new style_1.DefaultStyle(this.canvas, Object.assign({}, colourScheme));
        }
        this._style.showFrame = this.showFrame;
        this.changeCanvasScale(this.highDPI);
    };
    Main.prototype.changeCanvasScale = function (high) {
        var value = high ? 2 : 1;
        this._style.canvasScale = value;
        this.tensorCanvas.canvasScale = value;
    };
    /**
     * Downloads image of map
     * Draws onto hidden canvas at requested resolution
     */
    Main.prototype.download = function () {
        var c = document.getElementById(util_1.default.IMG_CANVAS_ID);
        // Draw
        if (this.showTensorField()) {
            this.tensorField.draw(new canvas_wrapper_1.DefaultCanvasWrapper(c, this.imageScale, false));
        }
        else {
            var imgCanvas = this._style.createCanvasWrapper(c, this.imageScale, false);
            this.roadsGUI.draw(this._style, true, imgCanvas);
        }
        var link = document.createElement('a');
        link.download = 'map.png';
        link.href = document.getElementById(util_1.default.IMG_CANVAS_ID).toDataURL();
        link.click();
    };
    Main.prototype.showTensorField = function () {
        return !this.tensorFolder.closed || this.roadsGUI.roadsEmpty();
    };
    Main.prototype.draw = function () {
        if (this.showTensorField()) {
            this.previousFrameDrawTensor = true;
            this.dragController.setDragDisabled(false);
            this.tensorField.draw(this.tensorCanvas);
        }
        else {
            // Disable field drag and drop
            this.dragController.setDragDisabled(true);
            if (this.previousFrameDrawTensor === true) {
                this.previousFrameDrawTensor = false;
                // Force redraw if switching from tensor field
                this.roadsGUI.draw(this._style, true);
            }
            else {
                this.roadsGUI.draw(this._style);
            }
        }
    };
    Main.prototype.update = function () {
        this.roadsGUI.update();
        this.draw();
        requestAnimationFrame(this.update.bind(this));
    };
    return Main;
}());
window.log = log;
window.addEventListener('load', function () {
    new Main();
});

},{"./colour_schemes.json":11,"./ts/ui/canvas_wrapper":24,"./ts/ui/domain_controller":25,"./ts/ui/drag_controller":26,"./ts/ui/roads_gui":28,"./ts/ui/style":29,"./ts/ui/tensor_field_gui":30,"./ts/util":32,"dat.gui":2,"loglevel":6}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var Vector = /** @class */ (function () {
    function Vector(x, y) {
        this.x = x;
        this.y = y;
    }
    Vector.zeroVector = function () {
        return new Vector(0, 0);
    };
    Vector.fromScalar = function (s) {
        return new Vector(s, s);
    };
    /**
     * -pi to pi
     */
    Vector.angleBetween = function (v1, v2) {
        // -2pi to 2pi
        var angleBetween = v1.angle() - v2.angle();
        if (angleBetween > Math.PI) {
            angleBetween -= 2 * Math.PI;
        }
        else if (angleBetween <= -Math.PI) {
            angleBetween += 2 * Math.PI;
        }
        return angleBetween;
    };
    /**
     * Tests whether a point lies to the left of a line
     * @param  {Vector} linePoint     Point on the line
     * @param  {Vector} lineDirection
     * @param  {Vector} point
     * @return {Vector}               true if left, false otherwise
     */
    Vector.isLeft = function (linePoint, lineDirection, point) {
        var perpendicularVector = new Vector(lineDirection.y, -lineDirection.x);
        return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
    };
    Vector.prototype.add = function (v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    };
    /**
     * Angle in radians to positive x-axis between -pi and pi
     */
    Vector.prototype.angle = function () {
        return Math.atan2(this.y, this.x);
    };
    Vector.prototype.clone = function () {
        return new Vector(this.x, this.y);
    };
    Vector.prototype.copy = function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    };
    Vector.prototype.cross = function (v) {
        return this.x * v.y - this.y * v.x;
    };
    Vector.prototype.distanceTo = function (v) {
        return Math.sqrt(this.distanceToSquared(v));
    };
    Vector.prototype.distanceToSquared = function (v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        return dx * dx + dy * dy;
    };
    Vector.prototype.divide = function (v) {
        if (v.x === 0 || v.y === 0) {
            log.warn("Division by zero");
            return this;
        }
        this.x /= v.x;
        this.y /= v.y;
        return this;
    };
    Vector.prototype.divideScalar = function (s) {
        if (s === 0) {
            log.warn("Division by zero");
            return this;
        }
        return this.multiplyScalar(1 / s);
    };
    Vector.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y;
    };
    Vector.prototype.equals = function (v) {
        return ((v.x === this.x) && (v.y === this.y));
    };
    Vector.prototype.length = function () {
        return Math.sqrt(this.lengthSq());
    };
    Vector.prototype.lengthSq = function () {
        return this.x * this.x + this.y * this.y;
    };
    Vector.prototype.multiply = function (v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    };
    Vector.prototype.multiplyScalar = function (s) {
        this.x *= s;
        this.y *= s;
        return this;
    };
    Vector.prototype.negate = function () {
        return this.multiplyScalar(-1);
    };
    Vector.prototype.normalize = function () {
        var l = this.length();
        if (l === 0) {
            log.warn("Zero Vector");
            return this;
        }
        return this.divideScalar(this.length());
    };
    /**
     * Angle in radians
     */
    Vector.prototype.rotateAround = function (center, angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * cos - y * sin + center.x;
        this.y = x * sin + y * cos + center.y;
        return this;
    };
    Vector.prototype.set = function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    };
    Vector.prototype.setX = function (x) {
        this.x = x;
        return this;
    };
    Vector.prototype.setY = function (y) {
        this.y = y;
        return this;
    };
    Vector.prototype.setLength = function (length) {
        return this.normalize().multiplyScalar(length);
    };
    Vector.prototype.sub = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    };
    return Vector;
}());
exports.default = Vector;

},{"loglevel":6}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("./tensor");
var BasisField = /** @class */ (function () {
    function BasisField(centre, _size, _decay) {
        this._size = _size;
        this._decay = _decay;
        this._centre = centre.clone();
    }
    Object.defineProperty(BasisField.prototype, "centre", {
        get: function () {
            return this._centre.clone();
        },
        set: function (centre) {
            this._centre.copy(centre);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BasisField.prototype, "decay", {
        set: function (decay) {
            this._decay = decay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BasisField.prototype, "size", {
        set: function (size) {
            this._size = size;
        },
        enumerable: true,
        configurable: true
    });
    BasisField.prototype.dragMoveListener = function (delta) {
        // Delta assumed to be in world space (only relevant when zoomed)
        this._centre.add(delta);
    };
    BasisField.prototype.getWeightedTensor = function (point) {
        return this.getTensor(point).scale(this.getTensorWeight(point));
    };
    /**
     * Creates a folder and adds it to the GUI to control params
     */
    BasisField.prototype.setGui = function (gui) {
        gui.add(this._centre, 'x');
        gui.add(this._centre, 'y');
        gui.add(this, '_size');
        gui.add(this, '_decay', 0, 50);
    };
    /**
     * Interpolates between (0 and 1)^decay
     */
    BasisField.prototype.getTensorWeight = function (point) {
        var normDistanceToCentre = point.clone().sub(this._centre).length() / this._size;
        // Stop (** 0) turning weight into 1, filling screen even when outside 'size'
        if (this._decay === 0 && normDistanceToCentre >= 1) {
            return 0;
        }
        return Math.pow(Math.max(0, (1 - normDistanceToCentre)), this._decay);
    };
    BasisField.folderNameIndex = 0;
    return BasisField;
}());
exports.BasisField = BasisField;
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid(centre, size, decay, _theta) {
        var _this = _super.call(this, centre, size, decay) || this;
        _this._theta = _theta;
        _this.FOLDER_NAME = "Grid " + Grid.folderNameIndex++;
        return _this;
    }
    Object.defineProperty(Grid.prototype, "theta", {
        set: function (theta) {
            this._theta = theta;
        },
        enumerable: true,
        configurable: true
    });
    Grid.prototype.setGui = function (gui) {
        var _this = this;
        _super.prototype.setGui.call(this, gui);
        // GUI in degrees, convert to rads
        var thetaProp = { theta: this._theta * 180 / Math.PI };
        var thetaController = gui.add(thetaProp, 'theta', -90, 90);
        thetaController.onChange(function (theta) { return _this._theta = theta * (Math.PI / 180); });
    };
    Grid.prototype.getTensor = function (point) {
        var cos = Math.cos(2 * this._theta);
        var sin = Math.sin(2 * this._theta);
        return new tensor_1.default(1, [cos, sin]);
    };
    return Grid;
}(BasisField));
exports.Grid = Grid;
var Radial = /** @class */ (function (_super) {
    __extends(Radial, _super);
    function Radial(centre, size, decay) {
        var _this = _super.call(this, centre, size, decay) || this;
        _this.FOLDER_NAME = "Radial " + Radial.folderNameIndex++;
        return _this;
    }
    Radial.prototype.getTensor = function (point) {
        var t = point.clone().sub(this._centre);
        var t1 = Math.pow(t.y, 2) - Math.pow(t.x, 2);
        var t2 = -2 * t.x * t.y;
        return new tensor_1.default(1, [t1, t2]);
    };
    return Radial;
}(BasisField));
exports.Radial = Radial;

},{"./tensor":21}],15:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var isect = require("isect");
var d3 = require("d3-quadtree");
var vector_1 = require("../vector");
var Node = /** @class */ (function () {
    function Node(value, neighbors) {
        if (neighbors === void 0) { neighbors = new Set(); }
        this.value = value;
        this.neighbors = neighbors;
        this.segments = new Set();
    }
    Node.prototype.addSegment = function (segment) {
        this.segments.add(segment);
    };
    Node.prototype.addNeighbor = function (node) {
        if (node !== this) {
            this.neighbors.add(node);
            node.neighbors.add(this);
        }
    };
    return Node;
}());
exports.Node = Node;
var Graph = /** @class */ (function () {
    function Graph(streamlines, dstep, deleteDangling) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e, e_6, _f;
        if (deleteDangling === void 0) { deleteDangling = false; }
        var intersections = isect.bush(this.streamlinesToSegment(streamlines)).run();
        var quadtree = d3.quadtree().x(function (n) { return n.value.x; }).y(function (n) { return n.value.y; });
        var nodeAddRadius = 0.001;
        try {
            // Add all segment start and endpoints
            for (var streamlines_1 = __values(streamlines), streamlines_1_1 = streamlines_1.next(); !streamlines_1_1.done; streamlines_1_1 = streamlines_1.next()) {
                var streamline = streamlines_1_1.value;
                for (var i = 0; i < streamline.length; i++) {
                    var node = new Node(streamline[i]);
                    if (i > 0) {
                        node.addSegment(this.vectorsToSegment(streamline[i - 1], streamline[i]));
                    }
                    if (i < streamline.length - 1) {
                        node.addSegment(this.vectorsToSegment(streamline[i], streamline[i + 1]));
                    }
                    this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (streamlines_1_1 && !streamlines_1_1.done && (_a = streamlines_1.return)) _a.call(streamlines_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            // Add all intersections
            for (var intersections_1 = __values(intersections), intersections_1_1 = intersections_1.next(); !intersections_1_1.done; intersections_1_1 = intersections_1.next()) {
                var intersection = intersections_1_1.value;
                var node = new Node(new vector_1.default(intersection.point.x, intersection.point.y));
                try {
                    for (var _g = (e_3 = void 0, __values(intersection.segments)), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var s = _h.value;
                        node.addSegment(s);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (intersections_1_1 && !intersections_1_1.done && (_b = intersections_1.return)) _b.call(intersections_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            // For each simplified streamline, build list of nodes in order along streamline
            for (var streamlines_2 = __values(streamlines), streamlines_2_1 = streamlines_2.next(); !streamlines_2_1.done; streamlines_2_1 = streamlines_2.next()) {
                var streamline = streamlines_2_1.value;
                for (var i = 0; i < streamline.length - 1; i++) {
                    var nodesAlongSegment = this.getNodesAlongSegment(this.vectorsToSegment(streamline[i], streamline[i + 1]), quadtree, nodeAddRadius, dstep);
                    if (nodesAlongSegment.length > 1) {
                        for (var j = 0; j < nodesAlongSegment.length - 1; j++) {
                            nodesAlongSegment[j].addNeighbor(nodesAlongSegment[j + 1]);
                        }
                    }
                    else {
                        log.error("Error Graph.js: segment with less than 2 nodes");
                    }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (streamlines_2_1 && !streamlines_2_1.done && (_d = streamlines_2.return)) _d.call(streamlines_2);
            }
            finally { if (e_4) throw e_4.error; }
        }
        try {
            for (var _j = __values(quadtree.data()), _k = _j.next(); !_k.done; _k = _j.next()) {
                var n = _k.value;
                if (deleteDangling) {
                    this.deleteDanglingNodes(n, quadtree);
                }
                n.adj = Array.from(n.neighbors);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_e = _j.return)) _e.call(_j);
            }
            finally { if (e_5) throw e_5.error; }
        }
        this.nodes = quadtree.data();
        this.intersections = [];
        try {
            for (var intersections_2 = __values(intersections), intersections_2_1 = intersections_2.next(); !intersections_2_1.done; intersections_2_1 = intersections_2.next()) {
                var i = intersections_2_1.value;
                this.intersections.push(new vector_1.default(i.point.x, i.point.y));
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (intersections_2_1 && !intersections_2_1.done && (_f = intersections_2.return)) _f.call(intersections_2);
            }
            finally { if (e_6) throw e_6.error; }
        }
    }
    Graph.prototype.deleteDanglingNodes = function (n, quadtree) {
        var e_7, _a;
        if (n.neighbors.size === 1) {
            quadtree.remove(n);
            try {
                for (var _b = __values(n.neighbors), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var neighbor = _c.value;
                    neighbor.neighbors.delete(n);
                    this.deleteDanglingNodes(neighbor, quadtree);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
    };
    Graph.prototype.getNodesAlongSegment = function (segment, quadtree, radius, step) {
        // Walk dstep along each streamline, adding nodes within dstep/2
        // and connected to this streamline (fuzzy - nodeAddRadius) to list, removing from
        // quadtree and adding them all back at the end
        var e_8, _a;
        var _this = this;
        var foundNodes = [];
        var nodesAlongSegment = [];
        var start = new vector_1.default(segment.from.x, segment.from.y);
        var end = new vector_1.default(segment.to.x, segment.to.y);
        var differenceVector = end.clone().sub(start);
        step = Math.min(step, differenceVector.length() / 2); // Min of 2 step along vector
        var steps = Math.ceil(differenceVector.length() / step);
        var differenceVectorLength = differenceVector.length();
        for (var i = 0; i <= steps; i++) {
            var currentPoint = start.clone().add(differenceVector.clone().multiplyScalar(i / steps));
            // Order nodes, not by 'closeness', but by dot product
            var nodesToAdd = [];
            var closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);
            while (closestNode !== undefined) {
                quadtree.remove(closestNode);
                foundNodes.push(closestNode);
                var nodeOnSegment = false;
                try {
                    for (var _b = (e_8 = void 0, __values(closestNode.segments)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var s = _c.value;
                        if (this.fuzzySegmentsEqual(s, segment)) {
                            nodeOnSegment = true;
                            break;
                        }
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
                if (nodeOnSegment) {
                    nodesToAdd.push(closestNode);
                }
                closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);
            }
            nodesToAdd.sort(function (first, second) {
                return _this.dotProductToSegment(first, start, differenceVector) - _this.dotProductToSegment(second, start, differenceVector);
            });
            nodesAlongSegment.push.apply(nodesAlongSegment, __spread(nodesToAdd));
        }
        quadtree.addAll(foundNodes);
        return nodesAlongSegment;
    };
    Graph.prototype.fuzzySegmentsEqual = function (s1, s2, tolerance) {
        if (tolerance === void 0) { tolerance = 0.0001; }
        // From
        if (s1.from.x - s2.from.x > tolerance) {
            return false;
        }
        if (s1.from.y - s2.from.y > tolerance) {
            return false;
        }
        // To
        if (s1.to.x - s2.to.x > tolerance) {
            return false;
        }
        if (s1.to.y - s2.to.y > tolerance) {
            return false;
        }
        return true;
    };
    Graph.prototype.dotProductToSegment = function (node, start, differenceVector) {
        var dotVector = node.value.clone().sub(start);
        return differenceVector.dot(dotVector);
    };
    Graph.prototype.fuzzyAddToQuadtree = function (quadtree, node, radius) {
        var e_9, _a, e_10, _b;
        // Only add if there isn't a node within radius
        // Remember to check for double radius when querying tree, or point might be missed
        var existingNode = quadtree.find(node.value.x, node.value.y, radius);
        if (existingNode === undefined) {
            quadtree.add(node);
        }
        else {
            try {
                for (var _c = __values(node.neighbors), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var neighbor = _d.value;
                    existingNode.addNeighbor(neighbor);
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_9) throw e_9.error; }
            }
            try {
                for (var _e = __values(node.segments), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var segment = _f.value;
                    existingNode.addSegment(segment);
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_10) throw e_10.error; }
            }
        }
    };
    Graph.prototype.streamlinesToSegment = function (streamlines) {
        var e_11, _a;
        var out = [];
        try {
            for (var streamlines_3 = __values(streamlines), streamlines_3_1 = streamlines_3.next(); !streamlines_3_1.done; streamlines_3_1 = streamlines_3.next()) {
                var s = streamlines_3_1.value;
                for (var i = 0; i < s.length - 1; i++) {
                    out.push(this.vectorsToSegment(s[i], s[i + 1]));
                }
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (streamlines_3_1 && !streamlines_3_1.done && (_a = streamlines_3.return)) _a.call(streamlines_3);
            }
            finally { if (e_11) throw e_11.error; }
        }
        return out;
    };
    Graph.prototype.vectorsToSegment = function (v1, v2) {
        return {
            from: v1,
            to: v2
        };
    };
    return Graph;
}());
exports.default = Graph;

},{"../vector":33,"d3-quadtree":1,"isect":4,"loglevel":6}],16:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = require("../vector");
var GridStorage = /** @class */ (function () {
    /**
     * worldDimensions assumes origin of 0,0
     * @param {number} dsep Separation distance between samples
     */
    function GridStorage(worldDimensions, origin, dsep) {
        this.worldDimensions = worldDimensions;
        this.origin = origin;
        this.dsep = dsep;
        this.dsepSq = this.dsep * this.dsep;
        this.gridDimensions = worldDimensions.clone().divideScalar(this.dsep);
        this.grid = [];
        for (var x = 0; x < this.gridDimensions.x; x++) {
            this.grid.push([]);
            for (var y = 0; y < this.gridDimensions.y; y++) {
                this.grid[x].push([]);
            }
        }
    }
    /**
     * Add all samples from another grid to this one
     */
    GridStorage.prototype.addAll = function (gridStorage) {
        var e_1, _a, e_2, _b, e_3, _c;
        try {
            for (var _d = __values(gridStorage.grid), _e = _d.next(); !_e.done; _e = _d.next()) {
                var row = _e.value;
                try {
                    for (var row_1 = (e_2 = void 0, __values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                        var cell = row_1_1.value;
                        try {
                            for (var cell_1 = (e_3 = void 0, __values(cell)), cell_1_1 = cell_1.next(); !cell_1_1.done; cell_1_1 = cell_1.next()) {
                                var sample = cell_1_1.value;
                                this.addSample(sample);
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (cell_1_1 && !cell_1_1.done && (_c = cell_1.return)) _c.call(cell_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (row_1_1 && !row_1_1.done && (_b = row_1.return)) _b.call(row_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    GridStorage.prototype.addPolyline = function (line) {
        var e_4, _a;
        try {
            for (var line_1 = __values(line), line_1_1 = line_1.next(); !line_1_1.done; line_1_1 = line_1.next()) {
                var v = line_1_1.value;
                this.addSample(v);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (line_1_1 && !line_1_1.done && (_a = line_1.return)) _a.call(line_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    /**
     * Does not enforce separation
     * Does not clone
     */
    GridStorage.prototype.addSample = function (v, coords) {
        if (!coords) {
            coords = this.getSampleCoords(v);
        }
        this.grid[coords.x][coords.y].push(v);
    };
    /**
     * Tests whether v is at least d away from samples
     * Performance very important - this is called at every integration step
     * @param dSq=this.dsepSq squared test distance
     * Could be dtest if we are integrating a streamline
     */
    GridStorage.prototype.isValidSample = function (v, dSq) {
        // Code duplication with this.getNearbyPoints but much slower when calling
        // this.getNearbyPoints due to array creation in that method
        if (dSq === void 0) { dSq = this.dsepSq; }
        var coords = this.getSampleCoords(v);
        // Check samples in 9 cells in 3x3 grid
        for (var x = -1; x <= 1; x++) {
            for (var y = -1; y <= 1; y++) {
                var cell = coords.clone().add(new vector_1.default(x, y));
                if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
                    if (!this.vectorFarFromVectors(v, this.grid[cell.x][cell.y], dSq)) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    /**
     * Test whether v is at least d away from vectors
     * Performance very important - this is called at every integration step
     * @param {number}   dSq     squared test distance
     */
    GridStorage.prototype.vectorFarFromVectors = function (v, vectors, dSq) {
        var e_5, _a;
        try {
            for (var vectors_1 = __values(vectors), vectors_1_1 = vectors_1.next(); !vectors_1_1.done; vectors_1_1 = vectors_1.next()) {
                var sample = vectors_1_1.value;
                if (sample !== v) {
                    var distanceSq = sample.distanceToSquared(v);
                    if (distanceSq < dSq) {
                        return false;
                    }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (vectors_1_1 && !vectors_1_1.done && (_a = vectors_1.return)) _a.call(vectors_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return true;
    };
    /**
     * Returns points in cells surrounding v
     * Results include v, if it exists in the grid
     * @param {number} returns samples (kind of) closer than distance - returns all samples in
     * cells so approximation (square to approximate circle)
     */
    GridStorage.prototype.getNearbyPoints = function (v, distance) {
        var e_6, _a;
        var radius = Math.ceil((distance / this.dsep) - 0.5);
        var coords = this.getSampleCoords(v);
        var out = [];
        for (var x = -1 * radius; x <= 1 * radius; x++) {
            for (var y = -1 * radius; y <= 1 * radius; y++) {
                var cell = coords.clone().add(new vector_1.default(x, y));
                if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
                    try {
                        for (var _b = (e_6 = void 0, __values(this.grid[cell.x][cell.y])), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var v2 = _c.value;
                            out.push(v2);
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            }
        }
        return out;
    };
    GridStorage.prototype.worldToGrid = function (v) {
        return v.clone().sub(this.origin);
    };
    GridStorage.prototype.gridToWorld = function (v) {
        return v.clone().add(this.origin);
    };
    GridStorage.prototype.vectorOutOfBounds = function (gridV, bounds) {
        return (gridV.x < 0 || gridV.y < 0 ||
            gridV.x >= bounds.x || gridV.y >= bounds.y);
    };
    /**
     * @return {Vector}   Cell coords corresponding to vector
     * Performance important - called at every integration step
     */
    GridStorage.prototype.getSampleCoords = function (worldV) {
        var v = this.worldToGrid(worldV);
        if (this.vectorOutOfBounds(v, this.worldDimensions)) {
            // log.error("Tried to access out-of-bounds sample in grid");
            return vector_1.default.zeroVector();
        }
        return new vector_1.default(Math.floor(v.x / this.dsep), Math.floor(v.y / this.dsep));
    };
    return GridStorage;
}());
exports.default = GridStorage;

},{"../vector":33}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = require("../vector");
var FieldIntegrator = /** @class */ (function () {
    function FieldIntegrator(field) {
        this.field = field;
    }
    FieldIntegrator.prototype.sampleFieldVector = function (point, major) {
        var tensor = this.field.samplePoint(point);
        if (major)
            return tensor.getMajor();
        return tensor.getMinor();
    };
    FieldIntegrator.prototype.onLand = function (point) {
        return this.field.onLand(point);
    };
    return FieldIntegrator;
}());
exports.default = FieldIntegrator;
var EulerIntegrator = /** @class */ (function (_super) {
    __extends(EulerIntegrator, _super);
    function EulerIntegrator(field, params) {
        var _this = _super.call(this, field) || this;
        _this.params = params;
        return _this;
    }
    EulerIntegrator.prototype.integrate = function (point, major) {
        return this.sampleFieldVector(point, major).multiplyScalar(this.params.dstep);
    };
    return EulerIntegrator;
}(FieldIntegrator));
exports.EulerIntegrator = EulerIntegrator;
var RK4Integrator = /** @class */ (function (_super) {
    __extends(RK4Integrator, _super);
    function RK4Integrator(field, params) {
        var _this = _super.call(this, field) || this;
        _this.params = params;
        return _this;
    }
    RK4Integrator.prototype.integrate = function (point, major) {
        var k1 = this.sampleFieldVector(point, major);
        var k23 = this.sampleFieldVector(point.clone().add(vector_1.default.fromScalar(this.params.dstep / 2)), major);
        var k4 = this.sampleFieldVector(point.clone().add(vector_1.default.fromScalar(this.params.dstep)), major);
        return k1.add(k23.multiplyScalar(4)).add(k4).multiplyScalar(this.params.dstep / 6);
    };
    return RK4Integrator;
}(FieldIntegrator));
exports.RK4Integrator = RK4Integrator;

},{"../vector":33}],18:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var polygon_util_1 = require("./polygon_util");
var PolygonFinder = /** @class */ (function () {
    function PolygonFinder(nodes, params) {
        this.nodes = nodes;
        this.params = params;
        this._polygons = [];
        this._shrunkPolygons = [];
        this._dividedPolygons = [];
        this.toShrink = [];
        this.toDivide = [];
    }
    Object.defineProperty(PolygonFinder.prototype, "polygons", {
        get: function () {
            if (this._dividedPolygons.length > 0) {
                return this._dividedPolygons;
            }
            if (this._shrunkPolygons.length > 0) {
                return this._shrunkPolygons;
            }
            return this._polygons;
        },
        enumerable: true,
        configurable: true
    });
    PolygonFinder.prototype.reset = function () {
        this.toShrink = [];
        this.toDivide = [];
        this._polygons = [];
        this._shrunkPolygons = [];
        this._dividedPolygons = [];
    };
    PolygonFinder.prototype.update = function () {
        var e_1, _a, _b;
        var change = false;
        if (this.toShrink.length > 0) {
            var resolve = this.toShrink.length === 1;
            var shrunk = polygon_util_1.default.resizeGeometry(this.toShrink.pop(), -this.params.shrinkSpacing);
            if (shrunk.length > 0) {
                this._shrunkPolygons.push(shrunk);
                change = true;
            }
            ;
            if (resolve)
                this.resolveShrink();
        }
        if (this.toDivide.length > 0) {
            var resolve = this.toDivide.length === 1;
            var divided = [];
            try {
                for (var _c = __values(polygon_util_1.default.subdividePolygon(this.toDivide.pop(), this.params.minArea, this.params.minArea)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var p = _d.value;
                    if (polygon_util_1.default.calcPolygonArea(p) > this.params.minArea * 0.4)
                        divided.push(p);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (divided.length > 0) {
                (_b = this._dividedPolygons).push.apply(_b, __spread(divided));
                change = true;
            }
            if (resolve)
                this.resolveDivide();
        }
        return change;
    };
    PolygonFinder.prototype.shrink = function (animate) {
        if (animate === void 0) { animate = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        var e_2, _a;
                        if (_this._polygons.length === 0) {
                            _this.findPolygons();
                        }
                        if (animate) {
                            if (_this._polygons.length === 0) {
                                resolve();
                                return;
                            }
                            _this.toShrink = _this._polygons.slice();
                            _this.resolveShrink = resolve;
                        }
                        else {
                            _this._shrunkPolygons = [];
                            try {
                                for (var _b = __values(_this._polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                                    var p = _c.value;
                                    var shrunk = polygon_util_1.default.resizeGeometry(p, -_this.params.shrinkSpacing);
                                    if (shrunk.length > 0) {
                                        _this._shrunkPolygons.push(shrunk);
                                    }
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                            resolve();
                        }
                    })];
            });
        });
    };
    PolygonFinder.prototype.divide = function (animate) {
        if (animate === void 0) { animate = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        var e_3, _a, e_4, _b;
                        if (_this._polygons.length === 0) {
                            _this.findPolygons();
                        }
                        var polygons = _this._polygons;
                        if (_this._shrunkPolygons.length > 0) {
                            polygons = _this._shrunkPolygons;
                        }
                        if (animate) {
                            if (polygons.length === 0) {
                                resolve();
                                return;
                            }
                            _this.toDivide = polygons.slice();
                            _this.resolveDivide = resolve;
                        }
                        else {
                            var divided = [];
                            try {
                                for (var polygons_1 = __values(polygons), polygons_1_1 = polygons_1.next(); !polygons_1_1.done; polygons_1_1 = polygons_1.next()) {
                                    var p = polygons_1_1.value;
                                    divided.push.apply(divided, __spread(polygon_util_1.default.subdividePolygon(p, _this.params.minArea, _this.params.minArea)));
                                }
                            }
                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
                            finally {
                                try {
                                    if (polygons_1_1 && !polygons_1_1.done && (_a = polygons_1.return)) _a.call(polygons_1);
                                }
                                finally { if (e_3) throw e_3.error; }
                            }
                            _this._dividedPolygons = [];
                            try {
                                for (var divided_1 = __values(divided), divided_1_1 = divided_1.next(); !divided_1_1.done; divided_1_1 = divided_1.next()) {
                                    var p = divided_1_1.value;
                                    if (polygon_util_1.default.calcPolygonArea(p) > _this.params.minArea * 0.4) {
                                        _this._dividedPolygons.push(p);
                                    }
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (divided_1_1 && !divided_1_1.done && (_b = divided_1.return)) _b.call(divided_1);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                            resolve();
                        }
                    })];
            });
        });
    };
    PolygonFinder.prototype.findPolygons = function () {
        // Node
        // x, y, value (Vector2), adj (list of node refs)
        // Gonna edit adj for now
        var e_5, _a, e_6, _b;
        // Walk a clockwise path until polygon found or limit reached
        // When we find a polygon, mark all edges as traversed (in particular direction)
        // Each edge separates two polygons
        // If edge already traversed in this direction, this polygon has already been found
        this._shrunkPolygons = [];
        this._dividedPolygons = [];
        var polygons = [];
        try {
            for (var _c = __values(this.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                var node = _d.value;
                if (node.adj.length < 2)
                    continue;
                try {
                    for (var _e = (e_6 = void 0, __values(node.adj)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var nextNode = _f.value;
                        var polygon = this.recursiveWalk([node, nextNode]);
                        if (polygon !== null && polygon.length < this.params.maxLength) {
                            this.removePolygonAdjacencies(polygon);
                            polygons.push(polygon.map(function (n) { return n.value.clone(); }));
                        }
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_5) throw e_5.error; }
        }
        this._polygons = polygons;
    };
    PolygonFinder.prototype.removePolygonAdjacencies = function (polygon) {
        for (var i = 0; i < polygon.length; i++) {
            var current = polygon[i];
            var next = polygon[(i + 1) % polygon.length];
            var index = current.adj.indexOf(next);
            if (index >= 0) {
                current.adj.splice(index, 1);
            }
            else {
                log.error("PolygonFinder - node not in adj");
            }
        }
    };
    PolygonFinder.prototype.recursiveWalk = function (visited, count) {
        if (count === void 0) { count = 0; }
        if (count >= this.params.maxLength)
            return null;
        // TODO backtracking to find polygons with dead end roads inside them
        var nextNode = this.getRightmostNode(visited[visited.length - 2], visited[visited.length - 1]);
        if (nextNode === null) {
            return null; // Currently ignores polygons with dead end inside
        }
        var visitedIndex = visited.indexOf(nextNode);
        if (visitedIndex >= 0) {
            return visited.slice(visitedIndex);
        }
        else {
            visited.push(nextNode);
            return this.recursiveWalk(visited, count++);
        }
    };
    PolygonFinder.prototype.getRightmostNode = function (nodeFrom, nodeTo) {
        var e_7, _a;
        // We want to turn right at every junction
        if (nodeTo.adj.length === 0)
            return null;
        var backwardsDifferenceVector = nodeFrom.value.clone().sub(nodeTo.value);
        var transformAngle = Math.atan2(backwardsDifferenceVector.y, backwardsDifferenceVector.x);
        var rightmostNode = null;
        var smallestTheta = Math.PI * 2;
        try {
            for (var _b = __values(nodeTo.adj), _c = _b.next(); !_c.done; _c = _b.next()) {
                var nextNode = _c.value;
                if (nextNode !== nodeFrom) {
                    var nextVector = nextNode.value.clone().sub(nodeTo.value);
                    var nextAngle = Math.atan2(nextVector.y, nextVector.x) - transformAngle;
                    if (nextAngle < 0) {
                        nextAngle += Math.PI * 2;
                    }
                    if (nextAngle < smallestTheta) {
                        smallestTheta = nextAngle;
                        rightmostNode = nextNode;
                    }
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return rightmostNode;
    };
    return PolygonFinder;
}());
exports.default = PolygonFinder;

},{"./polygon_util":19,"loglevel":6}],19:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var PolyK = require("polyk");
var vector_1 = require("../vector");
var jsts = require("jsts");
var PolygonUtil = /** @class */ (function () {
    function PolygonUtil() {
    }
    /**
     * Slices rectangle by line, returning largest polygon
     */
    PolygonUtil.sliceRectangle = function (origin, worldDimensions, p1, p2) {
        var rectangle = [
            origin.x, origin.y,
            origin.x + worldDimensions.x, origin.y,
            origin.x + worldDimensions.x, origin.y + worldDimensions.y,
            origin.x, origin.y + worldDimensions.y,
        ];
        var sliced = PolyK.Slice(rectangle, p1.x, p1.y, p2.x, p2.y).map(function (p) { return PolygonUtil.polygonArrayToPolygon(p); });
        var minArea = PolygonUtil.calcPolygonArea(sliced[0]);
        if (sliced.length > 1 && PolygonUtil.calcPolygonArea(sliced[1]) < minArea) {
            return sliced[1];
        }
        return sliced[0];
    };
    PolygonUtil.calcPolygonArea = function (polygon) {
        var total = 0;
        for (var i = 0; i < polygon.length; i++) {
            var addX = polygon[i].x;
            var addY = polygon[i == polygon.length - 1 ? 0 : i + 1].y;
            var subX = polygon[i == polygon.length - 1 ? 0 : i + 1].x;
            var subY = polygon[i].y;
            total += (addX * addY * 0.5);
            total -= (subX * subY * 0.5);
        }
        return Math.abs(total);
    };
    PolygonUtil.subdividePolygon = function (p, minArea, maxAspectRatio) {
        var e_1, _a;
        var area = PolygonUtil.calcPolygonArea(p);
        if (area < minArea) {
            return [p];
        }
        var divided = []; // Array of polygons
        var longestSideLengthSq = 0;
        var longestSide = [p[0], p[1]];
        for (var i = 0; i < p.length; i++) {
            var sideLength = p[i].clone().sub(p[(i + 1) % p.length]).lengthSq(); // TODO squared
            if (sideLength > longestSideLengthSq) {
                longestSideLengthSq = sideLength;
                longestSide = [p[i], p[(i + 1) % p.length]];
            }
        }
        // Aspect ratio approximation
        // if (longestSideLengthSq / area >= maxAspectRatio) {  // Approximation
        //     return [];
        // }
        // Between 0.4 and 0.6
        var deviation = (Math.random() * 0.2) + 0.4;
        var averagePoint = longestSide[0].clone().add(longestSide[1]).multiplyScalar(deviation);
        var differenceVector = longestSide[0].clone().sub(longestSide[1]);
        var perpVector = (new vector_1.default(differenceVector.y, -1 * differenceVector.x))
            .normalize()
            .multiplyScalar(100);
        var bisect = [averagePoint.clone().add(perpVector), averagePoint.clone().sub(perpVector)];
        // Array of polygons
        try {
            var sliced = PolyK.Slice(PolygonUtil.polygonToPolygonArray(p), bisect[0].x, bisect[0].y, bisect[1].x, bisect[1].y);
            try {
                // Recursive call
                for (var sliced_1 = __values(sliced), sliced_1_1 = sliced_1.next(); !sliced_1_1.done; sliced_1_1 = sliced_1.next()) {
                    var s = sliced_1_1.value;
                    divided.push.apply(divided, __spread(PolygonUtil.subdividePolygon(PolygonUtil.polygonArrayToPolygon(s), minArea, maxAspectRatio)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (sliced_1_1 && !sliced_1_1.done && (_a = sliced_1.return)) _a.call(sliced_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return divided;
        }
        catch (error) {
            log.error(error);
            return [];
        }
    };
    PolygonUtil.resizeGeometry = function (geometry, spacing, isPolygon) {
        if (isPolygon === void 0) { isPolygon = true; }
        try {
            var jstsGeometry = isPolygon ? PolygonUtil.polygonToJts(geometry) : PolygonUtil.lineToJts(geometry);
            var resized = jstsGeometry.buffer(spacing, undefined, undefined);
            if (!resized.isSimple()) {
                return [];
            }
            return resized.getCoordinates().map(function (c) { return new vector_1.default(c.x, c.y); });
        }
        catch (error) {
            log.error(error);
            return [];
        }
    };
    PolygonUtil.insidePolygon = function (point, polygon) {
        // ray-casting algorithm based on
        // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
        if (polygon.length === 0) {
            return false;
        }
        var inside = false;
        for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            var xi = polygon[i].x, yi = polygon[i].y;
            var xj = polygon[j].x, yj = polygon[j].y;
            var intersect = ((yi > point.y) != (yj > point.y))
                && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
            if (intersect)
                inside = !inside;
        }
        return inside;
    };
    PolygonUtil.lineToJts = function (line) {
        var coords = line.map(function (v) { return new jsts.geom.Coordinate(v.x, v.y); });
        return PolygonUtil.geometryFactory.createLineString(coords);
    };
    PolygonUtil.polygonToJts = function (polygon) {
        var geoInput = polygon.map(function (v) { return new jsts.geom.Coordinate(v.x, v.y); });
        geoInput.push(geoInput[0]); // Create loop
        return PolygonUtil.geometryFactory.createPolygon(PolygonUtil.geometryFactory.createLinearRing(geoInput), []);
    };
    /**
     * [ v.x, v.y, v.x, v.y ]...
     */
    PolygonUtil.polygonToPolygonArray = function (p) {
        var e_2, _a;
        var outP = [];
        try {
            for (var p_1 = __values(p), p_1_1 = p_1.next(); !p_1_1.done; p_1_1 = p_1.next()) {
                var v = p_1_1.value;
                outP.push(v.x);
                outP.push(v.y);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (p_1_1 && !p_1_1.done && (_a = p_1.return)) _a.call(p_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return outP;
    };
    /**
     * [ v.x, v.y, v.x, v.y ]...
     */
    PolygonUtil.polygonArrayToPolygon = function (p) {
        var outP = [];
        for (var i = 0; i < p.length / 2; i++) {
            outP.push(new vector_1.default(p[2 * i], p[2 * i + 1]));
        }
        return outP;
    };
    PolygonUtil.geometryFactory = new jsts.geom.GeometryFactory();
    return PolygonUtil;
}());
exports.default = PolygonUtil;

},{"../vector":33,"jsts":5,"loglevel":6,"polyk":7}],20:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var simplify = require("simplify-js");
var vector_1 = require("../vector");
var grid_storage_1 = require("./grid_storage");
var StreamlineGenerator = /** @class */ (function () {
    /**
     * Uses world-space coordinates
     */
    function StreamlineGenerator(integrator, origin, worldDimensions, params) {
        this.integrator = integrator;
        this.origin = origin;
        this.worldDimensions = worldDimensions;
        this.params = params;
        this.SEED_AT_ENDPOINTS = false;
        this.NEAR_EDGE = 3; // Sample near edge
        this.candidateSeedsMajor = [];
        this.candidateSeedsMinor = [];
        this.streamlinesDone = true;
        this.lastStreamlineMajor = true;
        this.allStreamlines = [];
        this.streamlinesMajor = [];
        this.streamlinesMinor = [];
        this.allStreamlinesSimple = []; // Reduced vertex count
        if (params.dstep > params.dsep) {
            log.error("STREAMLINE SAMPLE DISTANCE BIGGER THAN DSEP");
        }
        // Enforce test < sep
        params.dtest = Math.min(params.dtest, params.dsep);
        // Needs to be less than circlejoin
        this.dcollideselfSq = Math.pow((params.dcirclejoin / 2), 2);
        this.nStreamlineStep = Math.floor(params.dcirclejoin / params.dstep);
        this.nStreamlineLookBack = 2 * this.nStreamlineStep;
        this.majorGrid = new grid_storage_1.default(this.worldDimensions, this.origin, params.dsep);
        this.minorGrid = new grid_storage_1.default(this.worldDimensions, this.origin, params.dsep);
        this.setParamsSq();
    }
    StreamlineGenerator.prototype.clearStreamlines = function () {
        this.allStreamlinesSimple = [];
        this.streamlinesMajor = [];
        this.streamlinesMinor = [];
        this.allStreamlines = [];
    };
    /**
     * Edits streamlines
     */
    StreamlineGenerator.prototype.joinDanglingStreamlines = function () {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;
        try {
            // TODO do in update method
            for (var _f = __values([true, false]), _g = _f.next(); !_g.done; _g = _f.next()) {
                var major = _g.value;
                try {
                    for (var _h = (e_2 = void 0, __values(this.streamlines(major))), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var streamline = _j.value;
                        // Ignore circles
                        if (streamline[0].equals(streamline[streamline.length - 1])) {
                            continue;
                        }
                        var newStart = this.getBestNextPoint(streamline[0], streamline[4], streamline);
                        if (newStart !== null) {
                            try {
                                for (var _k = (e_3 = void 0, __values(this.pointsBetween(streamline[0], newStart, this.params.dstep))), _l = _k.next(); !_l.done; _l = _k.next()) {
                                    var p = _l.value;
                                    streamline.unshift(p);
                                    this.grid(major).addSample(p);
                                }
                            }
                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
                            finally {
                                try {
                                    if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                                }
                                finally { if (e_3) throw e_3.error; }
                            }
                        }
                        var newEnd = this.getBestNextPoint(streamline[streamline.length - 1], streamline[streamline.length - 4], streamline);
                        if (newEnd !== null) {
                            try {
                                for (var _m = (e_4 = void 0, __values(this.pointsBetween(streamline[streamline.length - 1], newEnd, this.params.dstep))), _o = _m.next(); !_o.done; _o = _m.next()) {
                                    var p = _o.value;
                                    streamline.push(p);
                                    this.grid(major).addSample(p);
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Reset simplified streamlines
        this.allStreamlinesSimple = [];
        try {
            for (var _p = __values(this.allStreamlines), _q = _p.next(); !_q.done; _q = _p.next()) {
                var s = _q.value;
                this.allStreamlinesSimple.push(this.simplifyStreamline(s));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    /**
     * Returns array of points from v1 to v2 such that they are separated by at most dsep
     * not including v1
     */
    StreamlineGenerator.prototype.pointsBetween = function (v1, v2, dstep) {
        var d = v1.distanceTo(v2);
        var nPoints = Math.floor(d / dstep);
        if (nPoints === 0)
            return [];
        var stepVector = v2.clone().sub(v1);
        var out = [];
        var i = 1;
        var next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));
        for (i = 1; i <= nPoints; i++) {
            if (this.integrator.integrate(next, true).lengthSq() > 0.001) { // Test for degenerate point
                out.push(next);
            }
            else {
                return out;
            }
            next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));
        }
        return out;
    };
    /**
     * Gets next best point to join streamline
     * returns null if there are no good candidates
     */
    StreamlineGenerator.prototype.getBestNextPoint = function (point, previousPoint, streamline) {
        var e_6, _a;
        var nearbyPoints = this.majorGrid.getNearbyPoints(point, this.params.dlookahead);
        nearbyPoints.push.apply(nearbyPoints, __spread(this.minorGrid.getNearbyPoints(point, this.params.dlookahead)));
        var direction = point.clone().sub(previousPoint);
        var closestSample = null;
        var closestDistance = Infinity;
        try {
            for (var nearbyPoints_1 = __values(nearbyPoints), nearbyPoints_1_1 = nearbyPoints_1.next(); !nearbyPoints_1_1.done; nearbyPoints_1_1 = nearbyPoints_1.next()) {
                var sample = nearbyPoints_1_1.value;
                if (!sample.equals(point) && !sample.equals(previousPoint)) { // && !streamline.includes(sample)) {
                    var differenceVector = sample.clone().sub(point);
                    if (differenceVector.dot(direction) < 0) {
                        // Backwards
                        continue;
                    }
                    // Acute angle between vectors (agnostic of CW, ACW)
                    var distanceToSample = point.distanceToSquared(sample);
                    if (distanceToSample < 2 * this.paramsSq.dstep) {
                        closestSample = sample;
                        break;
                    }
                    var angleBetween = Math.abs(vector_1.default.angleBetween(direction, differenceVector));
                    // Filter by angle
                    if (angleBetween < this.params.joinangle && distanceToSample < closestDistance) {
                        closestDistance = distanceToSample;
                        closestSample = sample;
                    }
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (nearbyPoints_1_1 && !nearbyPoints_1_1.done && (_a = nearbyPoints_1.return)) _a.call(nearbyPoints_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
        // TODO is reimplement simplify-js to preserve intersection points
        //  - this is the primary reason polygons aren't found
        // If trying to find intersections in the simplified graph
        // prevent ends getting pulled away from simplified lines
        if (closestSample !== null) {
            closestSample = closestSample.clone().add(direction.setLength(this.params.simplifyTolerance * 4));
        }
        return closestSample;
    };
    /**
     * Assumes s has already generated
     */
    StreamlineGenerator.prototype.addExistingStreamlines = function (s) {
        this.majorGrid.addAll(s.majorGrid);
        this.minorGrid.addAll(s.minorGrid);
    };
    StreamlineGenerator.prototype.setGrid = function (s) {
        this.majorGrid = s.majorGrid;
        this.minorGrid = s.minorGrid;
    };
    /**
     * returns true if state updates
     */
    StreamlineGenerator.prototype.update = function () {
        if (!this.streamlinesDone) {
            this.lastStreamlineMajor = !this.lastStreamlineMajor;
            if (!this.createStreamline(this.lastStreamlineMajor)) {
                this.streamlinesDone = true;
                this.resolve();
            }
            return true;
        }
        return false;
    };
    /**
     * All at once - will freeze if dsep small
     */
    StreamlineGenerator.prototype.createAllStreamlines = function (animate) {
        if (animate === void 0) { animate = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        _this.resolve = resolve;
                        _this.streamlinesDone = false;
                        if (!animate) {
                            var major = true;
                            while (_this.createStreamline(major)) {
                                major = !major;
                            }
                        }
                    }).then(function () { return _this.joinDanglingStreamlines(); })];
            });
        });
    };
    StreamlineGenerator.prototype.simplifyStreamline = function (streamline) {
        var e_7, _a;
        var simplified = [];
        try {
            for (var _b = __values(simplify(streamline, this.params.simplifyTolerance)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                simplified.push(new vector_1.default(point.x, point.y));
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return simplified;
    };
    /**
     * Finds seed and creates a streamline from that point
     * Pushes new candidate seeds to queue
     * @return {Vector[]} returns false if seed isn't found within params.seedTries
     */
    StreamlineGenerator.prototype.createStreamline = function (major) {
        var seed = this.getSeed(major);
        if (seed === null) {
            return false;
        }
        var streamline = this.integrateStreamline(seed, major);
        if (this.validStreamline(streamline)) {
            this.grid(major).addPolyline(streamline);
            this.streamlines(major).push(streamline);
            this.allStreamlines.push(streamline);
            this.allStreamlinesSimple.push(this.simplifyStreamline(streamline));
            // Add candidate seeds
            if (!streamline[0].equals(streamline[streamline.length - 1])) {
                this.candidateSeeds(!major).push(streamline[0]);
                this.candidateSeeds(!major).push(streamline[streamline.length - 1]);
            }
        }
        return true;
    };
    StreamlineGenerator.prototype.validStreamline = function (s) {
        return s.length > 5;
    };
    StreamlineGenerator.prototype.setParamsSq = function () {
        this.paramsSq = Object.assign({}, this.params);
        for (var p in this.paramsSq) {
            if (typeof this.paramsSq[p] === "number") {
                this.paramsSq[p] *= this.paramsSq[p];
            }
        }
    };
    StreamlineGenerator.prototype.samplePoint = function () {
        // TODO better seeding scheme
        return new vector_1.default(Math.random() * this.worldDimensions.x, Math.random() * this.worldDimensions.y)
            .add(this.origin);
    };
    /**
     * Tries this.candidateSeeds first, then samples using this.samplePoint
     */
    StreamlineGenerator.prototype.getSeed = function (major) {
        // Candidate seeds first
        if (this.SEED_AT_ENDPOINTS && this.candidateSeeds(major).length > 0) {
            while (this.candidateSeeds(major).length > 0) {
                var seed_1 = this.candidateSeeds(major).pop();
                if (this.isValidSample(major, seed_1, this.paramsSq.dsep)) {
                    return seed_1;
                }
            }
        }
        var seed = this.samplePoint();
        var i = 0;
        while (!this.isValidSample(major, seed, this.paramsSq.dsep)) {
            if (i >= this.params.seedTries) {
                return null;
            }
            seed = this.samplePoint();
            i++;
        }
        return seed;
    };
    StreamlineGenerator.prototype.isValidSample = function (major, point, dSq, bothGrids) {
        if (bothGrids === void 0) { bothGrids = false; }
        // dSq = dSq * point.distanceToSquared(Vector.zeroVector());
        var gridValid = this.grid(major).isValidSample(point, dSq);
        if (bothGrids) {
            gridValid = gridValid && this.grid(!major).isValidSample(point, dSq);
        }
        return this.integrator.onLand(point) && gridValid;
    };
    StreamlineGenerator.prototype.candidateSeeds = function (major) {
        return major ? this.candidateSeedsMajor : this.candidateSeedsMinor;
    };
    StreamlineGenerator.prototype.streamlines = function (major) {
        return major ? this.streamlinesMajor : this.streamlinesMinor;
    };
    StreamlineGenerator.prototype.grid = function (major) {
        return major ? this.majorGrid : this.minorGrid;
    };
    StreamlineGenerator.prototype.pointInBounds = function (v) {
        return (v.x >= this.origin.x
            && v.y >= this.origin.y
            && v.x < this.worldDimensions.x + this.origin.x
            && v.y < this.worldDimensions.y + this.origin.y);
    };
    /**
     * Didn't end up using - bit expensive, used streamlineTurned instead
     * Stops spirals from forming
     * uses 0.5 dcirclejoin so that circles are still joined up
     * testSample is candidate to pushed on end of streamlineForwards
     * returns true if streamline collides with itself
     */
    StreamlineGenerator.prototype.doesStreamlineCollideSelf = function (testSample, streamlineForwards, streamlineBackwards) {
        // Streamline long enough
        if (streamlineForwards.length > this.nStreamlineLookBack) {
            // Forwards check
            for (var i = 0; i < streamlineForwards.length - this.nStreamlineLookBack; i += this.nStreamlineStep) {
                if (testSample.distanceToSquared(streamlineForwards[i]) < this.dcollideselfSq) {
                    return true;
                }
            }
            // Backwards check
            for (var i = 0; i < streamlineBackwards.length; i += this.nStreamlineStep) {
                if (testSample.distanceToSquared(streamlineBackwards[i]) < this.dcollideselfSq) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Tests whether streamline has turned through greater than 180 degrees
     */
    StreamlineGenerator.prototype.streamlineTurned = function (seed, originalDir, point, direction) {
        if (originalDir.dot(direction) < 0) {
            // TODO optimise
            var perpendicularVector = new vector_1.default(originalDir.y, -originalDir.x);
            var isLeft = point.clone().sub(seed).dot(perpendicularVector) < 0;
            var directionUp = direction.dot(perpendicularVector) > 0;
            return isLeft === directionUp;
        }
        return false;
    };
    /**
     * // TODO this doesn't work well - consider something disallowing one direction (F/B) to turn more than 180 deg
     * One step of the streamline integration process
     */
    StreamlineGenerator.prototype.streamlineIntegrationStep = function (params, major, collideBoth) {
        if (params.valid) {
            params.streamline.push(params.previousPoint);
            var nextDirection = this.integrator.integrate(params.previousPoint, major);
            // Stop at degenerate point
            if (nextDirection.lengthSq() < 0.01) {
                params.valid = false;
                return;
            }
            // Make sure we travel in the same direction
            if (nextDirection.dot(params.previousDirection) < 0) {
                nextDirection.negate();
            }
            var nextPoint = params.previousPoint.clone().add(nextDirection);
            // Visualise stopping points
            // if (this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
            //     params.valid = false;
            //     params.streamline.push(Vector.zeroVector());
            // }
            if (this.pointInBounds(nextPoint)
                && this.isValidSample(major, nextPoint, this.paramsSq.dtest, collideBoth)
                && !this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
                params.previousPoint = nextPoint;
                params.previousDirection = nextDirection;
            }
            else {
                // One more step
                params.streamline.push(nextPoint);
                params.valid = false;
            }
        }
    };
    /**
     * By simultaneously integrating in both directions we reduce the impact of circles not joining
     * up as the error matches at the join
     */
    StreamlineGenerator.prototype.integrateStreamline = function (seed, major) {
        var _a;
        var count = 0;
        var pointsEscaped = false; // True once two integration fronts have moved dlookahead away
        // Whether or not to test validity using both grid storages
        // (Collide with both major and minor)
        var collideBoth = Math.random() < this.params.collideEarly;
        var d = this.integrator.integrate(seed, major);
        var forwardParams = {
            seed: seed,
            originalDir: d,
            streamline: [seed],
            previousDirection: d,
            previousPoint: seed.clone().add(d),
            valid: true,
        };
        forwardParams.valid = this.pointInBounds(forwardParams.previousPoint);
        var negD = d.clone().negate();
        var backwardParams = {
            seed: seed,
            originalDir: negD,
            streamline: [],
            previousDirection: negD,
            previousPoint: seed.clone().add(negD),
            valid: true,
        };
        backwardParams.valid = this.pointInBounds(backwardParams.previousPoint);
        while (count < this.params.pathIterations && (forwardParams.valid || backwardParams.valid)) {
            this.streamlineIntegrationStep(forwardParams, major, collideBoth);
            this.streamlineIntegrationStep(backwardParams, major, collideBoth);
            // Join up circles
            var sqDistanceBetweenPoints = forwardParams.previousPoint.distanceToSquared(backwardParams.previousPoint);
            if (!pointsEscaped && sqDistanceBetweenPoints > this.paramsSq.dcirclejoin) {
                pointsEscaped = true;
            }
            if (pointsEscaped && sqDistanceBetweenPoints <= this.paramsSq.dcirclejoin) {
                forwardParams.streamline.push(forwardParams.previousPoint);
                forwardParams.streamline.push(backwardParams.previousPoint);
                backwardParams.streamline.push(backwardParams.previousPoint);
                break;
            }
            count++;
        }
        (_a = backwardParams.streamline.reverse()).push.apply(_a, __spread(forwardParams.streamline));
        return backwardParams.streamline;
    };
    return StreamlineGenerator;
}());
exports.default = StreamlineGenerator;

},{"../vector":33,"./grid_storage":16,"loglevel":6,"simplify-js":10}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = require("../vector");
var Tensor = /** @class */ (function () {
    function Tensor(r, matrix) {
        this.r = r;
        this.matrix = matrix;
        // Matrix is 2 element list
        // [ 0, 1
        //   1, -0 ]
        this.oldTheta = false;
        this._theta = this.calculateTheta();
    }
    Object.defineProperty(Tensor.prototype, "theta", {
        get: function () {
            if (this.oldTheta) {
                this._theta = this.calculateTheta();
                this.oldTheta = false;
            }
            return this._theta;
        },
        enumerable: true,
        configurable: true
    });
    Tensor.prototype.add = function (tensor) {
        var _this = this;
        this.matrix = this.matrix.map(function (v, i) { return v * _this.r + tensor.matrix[i] * tensor.r; });
        this.r = 2;
        this.oldTheta = true;
        return this;
    };
    Tensor.prototype.scale = function (s) {
        this.r *= s;
        this.oldTheta = true;
        return this;
    };
    // Radians
    Tensor.prototype.rotate = function (theta) {
        if (theta === 0) {
            return this;
        }
        var newTheta = this.theta + theta;
        if (newTheta < Math.PI) {
            newTheta += Math.PI;
        }
        if (newTheta >= Math.PI) {
            newTheta -= Math.PI;
        }
        this.matrix[0] = Math.cos(2 * newTheta) * this.r;
        this.matrix[1] = Math.sin(2 * newTheta) * this.r;
        this._theta = newTheta;
        return this;
    };
    Tensor.prototype.getMajor = function () {
        // Degenerate case
        if (this.r === 0) {
            return vector_1.default.zeroVector();
        }
        return new vector_1.default(Math.cos(this.theta), Math.sin(this.theta));
    };
    Tensor.prototype.getMinor = function () {
        // Degenerate case
        if (this.r === 0) {
            return vector_1.default.zeroVector();
        }
        var angle = this.theta + Math.PI / 2;
        return new vector_1.default(Math.cos(angle), Math.sin(angle));
    };
    Tensor.prototype.calculateTheta = function () {
        if (this.r === 0) {
            return 0;
        }
        return Math.atan2(this.matrix[1] / this.r, this.matrix[0] / this.r) / 2;
    };
    return Tensor;
}());
exports.default = Tensor;

},{"../vector":33}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// import * as noise from 'noisejs';
var SimplexNoise = require("simplex-noise");
var tensor_1 = require("./tensor");
var basis_field_1 = require("./basis_field");
var polygon_util_1 = require("./polygon_util");
var TensorField = /** @class */ (function () {
    function TensorField(noiseParams) {
        this.noiseParams = noiseParams;
        this.basisFields = [];
        this.parks = [];
        this.sea = [];
        this.river = [];
        this.ignoreRiver = false;
        this.noise = new SimplexNoise();
    }
    TensorField.prototype.enableGlobalNoise = function (angle, size) {
        this.noiseParams.globalNoise = true;
        this.noiseParams.noiseAngleGlobal = angle;
        this.noiseParams.noiseSizeGlobal = size;
    };
    TensorField.prototype.disableGlobalNoise = function () {
        this.noiseParams.globalNoise = false;
    };
    TensorField.prototype.addGrid = function (centre, size, decay, theta) {
        var grid = new basis_field_1.Grid(centre, size, decay, theta);
        this.addField(grid);
    };
    TensorField.prototype.addRadial = function (centre, size, decay) {
        var radial = new basis_field_1.Radial(centre, size, decay);
        this.addField(radial);
    };
    TensorField.prototype.addField = function (field) {
        this.basisFields.push(field);
    };
    TensorField.prototype.removeField = function (field) {
        var index = this.basisFields.indexOf(field);
        if (index > -1) {
            this.basisFields.splice(index, 1);
        }
    };
    TensorField.prototype.reset = function () {
        this.basisFields = [];
        this.parks = [];
        this.sea = [];
        this.river = [];
    };
    TensorField.prototype.getCentrePoints = function () {
        return this.basisFields.map(function (field) { return field.centre; });
    };
    TensorField.prototype.samplePoint = function (point) {
        if (!this.onLand(point)) {
            // Degenerate point
            return new tensor_1.default(0, [0, 0]);
        }
        // Default field is a grid
        if (this.basisFields.length === 0) {
            return new tensor_1.default(1, [0, 0]);
        }
        var tensorAcc = new tensor_1.default(0, [0, 0]);
        this.basisFields.forEach(function (field) { return tensorAcc.add(field.getWeightedTensor(point)); });
        // Add rotational noise for parks - range -pi/2 to pi/2
        if (this.parks.some(function (p) { return polygon_util_1.default.insidePolygon(point, p); })) {
            // TODO optimise insidePolygon e.g. distance
            tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizePark, this.noiseParams.noiseAnglePark));
        }
        if (this.noiseParams.globalNoise) {
            tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizeGlobal, this.noiseParams.noiseAngleGlobal));
        }
        return tensorAcc;
    };
    /**
     * Noise Angle is in degrees
     */
    TensorField.prototype.getRotationalNoise = function (point, noiseSize, noiseAngle) {
        return this.noise.noise2D(point.x / noiseSize, point.y / noiseSize) * noiseAngle * Math.PI / 180;
    };
    TensorField.prototype.onLand = function (point) {
        var inSea = polygon_util_1.default.insidePolygon(point, this.sea);
        if (this.ignoreRiver) {
            return !inSea;
        }
        return !inSea && !polygon_util_1.default.insidePolygon(point, this.river);
    };
    return TensorField;
}());
exports.default = TensorField;

},{"./basis_field":14,"./polygon_util":19,"./tensor":21,"simplex-noise":9}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var streamlines_1 = require("./streamlines");
var polygon_util_1 = require("./polygon_util");
var WaterGenerator = /** @class */ (function (_super) {
    __extends(WaterGenerator, _super);
    function WaterGenerator(integrator, origin, worldDimensions, params, tensorField) {
        var _this = _super.call(this, integrator, origin, worldDimensions, params) || this;
        _this.params = params;
        _this.tensorField = tensorField;
        _this.TRIES = 100;
        _this.coastlineMajor = true;
        _this._coastline = []; // Noisy line
        _this._seaPolygon = []; // Uses screen rectangle and simplified road
        _this._riverPolygon = []; // Simplified
        _this._riverSecondaryRoad = [];
        return _this;
    }
    Object.defineProperty(WaterGenerator.prototype, "coastline", {
        get: function () {
            return this._coastline;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaterGenerator.prototype, "seaPolygon", {
        get: function () {
            return this._seaPolygon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaterGenerator.prototype, "riverPolygon", {
        get: function () {
            return this._riverPolygon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaterGenerator.prototype, "riverSecondaryRoad", {
        get: function () {
            return this._riverSecondaryRoad;
        },
        enumerable: true,
        configurable: true
    });
    WaterGenerator.prototype.createCoast = function () {
        var coastStreamline;
        var seed;
        var major;
        if (this.params.coastNoise.noiseEnabled) {
            this.tensorField.enableGlobalNoise(this.params.coastNoise.noiseAngle, this.params.coastNoise.noiseSize);
        }
        for (var i = 0; i < this.TRIES; i++) {
            major = Math.random() < 0.5;
            seed = this.getSeed(major);
            coastStreamline = this.extendStreamline(this.integrateStreamline(seed, major));
            if (this.reachesEdges(coastStreamline)) {
                break;
            }
        }
        this.tensorField.disableGlobalNoise();
        this._coastline = coastStreamline;
        this.coastlineMajor = major;
        var road = this.simplifyStreamline(coastStreamline);
        this._seaPolygon = this.getSeaPolygon(road);
        this.allStreamlinesSimple.push(road);
        this.tensorField.sea = (this._seaPolygon);
        // Create intermediate samples
        var complex = this.complexifyStreamline(road);
        this.grid(major).addPolyline(complex);
        this.streamlines(major).push(complex);
        this.allStreamlines.push(complex);
    };
    WaterGenerator.prototype.createRiver = function () {
        var _this = this;
        var riverStreamline;
        var seed;
        // Need to ignore sea when integrating for edge check
        var oldSea = this.tensorField.sea;
        this.tensorField.sea = [];
        if (this.params.riverNoise.noiseEnabled) {
            this.tensorField.enableGlobalNoise(this.params.riverNoise.noiseAngle, this.params.riverNoise.noiseSize);
        }
        for (var i = 0; i < this.TRIES; i++) {
            seed = this.getSeed(!this.coastlineMajor);
            riverStreamline = this.extendStreamline(this.integrateStreamline(seed, !this.coastlineMajor));
            if (this.reachesEdges(riverStreamline)) {
                break;
            }
            else if (i === this.TRIES - 1) {
                log.error('Failed to find river reaching edge');
            }
        }
        this.tensorField.sea = oldSea;
        this.tensorField.disableGlobalNoise();
        // Create river roads
        var expandedNoisy = this.complexifyStreamline(polygon_util_1.default.resizeGeometry(riverStreamline, this.params.riverSize, false));
        this._riverPolygon = polygon_util_1.default.resizeGeometry(riverStreamline, this.params.riverSize - this.params.riverBankSize, false);
        // Make sure riverPolygon[0] is off screen
        var firstOffScreen = expandedNoisy.findIndex(function (v) { return _this.vectorOffScreen(v); });
        for (var i = 0; i < firstOffScreen; i++) {
            expandedNoisy.push(expandedNoisy.shift());
        }
        // Create river roads
        var riverSplitPoly = this.getSeaPolygon(riverStreamline);
        var road1 = expandedNoisy.filter(function (v) {
            return !polygon_util_1.default.insidePolygon(v, _this._seaPolygon)
                && !_this.vectorOffScreen(v)
                && polygon_util_1.default.insidePolygon(v, riverSplitPoly);
        });
        var road1Simple = this.simplifyStreamline(road1);
        var road2 = expandedNoisy.filter(function (v) {
            return !polygon_util_1.default.insidePolygon(v, _this._seaPolygon)
                && !_this.vectorOffScreen(v)
                && !polygon_util_1.default.insidePolygon(v, riverSplitPoly);
        });
        var road2Simple = this.simplifyStreamline(road2);
        if (road1.length === 0 || road2.length === 0)
            return;
        if (road1[0].distanceToSquared(road2[0]) < road1[0].distanceToSquared(road2[road2.length - 1])) {
            road2Simple.reverse();
        }
        this.tensorField.river = road1Simple.concat(road2Simple);
        // Road 1
        this.allStreamlinesSimple.push(road1Simple);
        this._riverSecondaryRoad = road2Simple;
        this.grid(!this.coastlineMajor).addPolyline(road1);
        this.grid(!this.coastlineMajor).addPolyline(road2);
        this.streamlines(!this.coastlineMajor).push(road1);
        this.streamlines(!this.coastlineMajor).push(road2);
        this.allStreamlines.push(road1);
        this.allStreamlines.push(road2);
    };
    /**
     * Assumes simplified
     * Used for adding river roads
     */
    WaterGenerator.prototype.manuallyAddStreamline = function (s, major) {
        this.allStreamlinesSimple.push(s);
        // Create intermediate samples
        var complex = this.complexifyStreamline(s);
        this.grid(major).addPolyline(complex);
        this.streamlines(major).push(complex);
        this.allStreamlines.push(complex);
    };
    /**
     * Might reverse input array
     */
    WaterGenerator.prototype.getSeaPolygon = function (polyline) {
        var seaPolygon = polygon_util_1.default.sliceRectangle(this.origin, this.worldDimensions, polyline[0], polyline[polyline.length - 1]);
        // Replace the longest side with coastline
        var longestIndex = 0;
        var longestLength = 0;
        for (var i = 0; i < seaPolygon.length; i++) {
            var next = (i + 1) % seaPolygon.length;
            var d = seaPolygon[i].distanceToSquared(seaPolygon[next]);
            if (d > longestLength) {
                longestLength = d;
                longestIndex = i;
            }
        }
        var insertBackwards = seaPolygon[longestIndex].distanceToSquared(polyline[0]) > seaPolygon[longestIndex].distanceToSquared(polyline[polyline.length - 1]);
        if (insertBackwards) {
            polyline.reverse();
        }
        seaPolygon.splice.apply(seaPolygon, __spread([(longestIndex + 1) % seaPolygon.length, 0], polyline));
        return seaPolygon;
    };
    /**
     * Insert samples in streamline until separated by dstep
     */
    WaterGenerator.prototype.complexifyStreamline = function (s) {
        var out = [];
        for (var i = 0; i < s.length - 1; i++) {
            out.push.apply(out, __spread(this.complexifyStreamlineRecursive(s[i], s[i + 1])));
        }
        return out;
    };
    WaterGenerator.prototype.complexifyStreamlineRecursive = function (v1, v2) {
        if (v1.distanceToSquared(v2) <= this.paramsSq.dstep) {
            return [v1, v2];
        }
        var d = v2.clone().sub(v1);
        var halfway = v1.clone().add(d.multiplyScalar(0.5));
        var complex = this.complexifyStreamlineRecursive(v1, halfway);
        complex.push.apply(complex, __spread(this.complexifyStreamlineRecursive(halfway, v2)));
        return complex;
    };
    /**
     * Mutates streamline
     */
    WaterGenerator.prototype.extendStreamline = function (streamline) {
        streamline.unshift(streamline[0].clone().add(streamline[0].clone().sub(streamline[1]).setLength(this.params.dstep * 5)));
        streamline.push(streamline[streamline.length - 1].clone().add(streamline[streamline.length - 1].clone().sub(streamline[streamline.length - 2]).setLength(this.params.dstep * 5)));
        return streamline;
    };
    WaterGenerator.prototype.reachesEdges = function (streamline) {
        return this.vectorOffScreen(streamline[0]) && this.vectorOffScreen(streamline[streamline.length - 1]);
    };
    WaterGenerator.prototype.vectorOffScreen = function (v) {
        var toOrigin = v.clone().sub(this.origin);
        return toOrigin.x <= 0 || toOrigin.y <= 0 ||
            toOrigin.x >= this.worldDimensions.x || toOrigin.y >= this.worldDimensions.y;
    };
    return WaterGenerator;
}(streamlines_1.default));
exports.default = WaterGenerator;
// createCoastStreamline(): Vector[][] {
//         let coastStreamline;
//         let riverStreamline;
//         let seed;
//         let major;
//         const extendStreamline = (streamline: Vector[]) => {
//             streamline.unshift(streamline[0].clone().add(
//                 streamline[0].clone().sub(streamline[1]).setLength(this.params.dstep * 5)));
//             streamline.push(streamline[streamline.length - 1].clone().add(
//                 streamline[streamline.length - 1].clone().sub(streamline[streamline.length - 2]).setLength(this.params.dstep * 5)));
//             return streamline;
//         }
//         const reachesEdges = (streamline: Vector[]) => {
//             return this.vectorOffScreen(streamline[0]) && this.vectorOffScreen(streamline[streamline.length - 1]);
//         }
//         for (let i = 0; i < 100; i++) {
//             // TODO
//             major = true;
//             // major = Math.random() < 0.5;
//             seed = this.getSeed(major);
//             coastStreamline = extendStreamline(this.integrateStreamline(seed, major));
//             riverStreamline = extendStreamline(this.integrateStreamline(seed, !major));
//             if (reachesEdges(coastStreamline) && reachesEdges(riverStreamline)) {
//                 break;
//             }
//         }
//         // Streamline is coastal = noisy
//         const road = this.simplifyStreamline(coastStreamline);
//         this.allStreamlinesSimple.push(road);
//         // Create intermediate samples
//         const complex = this.complexifyStreamline(road);
//         this.grid(major).addPolyline(complex);
//         this.streamlines(major).push(complex);
//         this.allStreamlines.push(complex);
//         this.tensorField.addWater(this.getSeaPolygon(road));
//         // Return unsimplified streamlines
//         return [coastStreamline, riverStreamline];
//     }

},{"./polygon_util":19,"./streamlines":20,"loglevel":6}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var CanvasWrapper = /** @class */ (function () {
    function CanvasWrapper(canvas, _scale, resizeToWindow) {
        var _this = this;
        if (_scale === void 0) { _scale = 1; }
        if (resizeToWindow === void 0) { resizeToWindow = true; }
        this.canvas = canvas;
        this._scale = _scale;
        this.needsUpdate = false;
        this.setDimensions();
        this.resizeCanvas();
        if (resizeToWindow) {
            window.addEventListener('resize', function () {
                _this.setDimensions();
                _this.resizeCanvas();
            });
        }
    }
    CanvasWrapper.prototype.setDimensions = function () {
        this._width = window.innerWidth * this._scale;
        this._height = window.innerHeight * this._scale;
    };
    Object.defineProperty(CanvasWrapper.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasWrapper.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasWrapper.prototype, "canvasScale", {
        get: function () {
            return this._scale;
        },
        set: function (s) {
            this._scale = s;
            this.setDimensions();
            this.resizeCanvas();
        },
        enumerable: true,
        configurable: true
    });
    CanvasWrapper.prototype.zoomVectors = function (vs) {
        if (this._scale !== 1) {
            for (var i = 0, len = vs.length; i < len; i++) {
                vs[i] = vs[i].clone().multiplyScalar(this._scale);
            }
        }
    };
    CanvasWrapper.prototype.resizeCanvas = function () {
        this.canvas.width = this._width;
        this.canvas.height = this._height;
        this.needsUpdate = true;
    };
    return CanvasWrapper;
}());
exports.default = CanvasWrapper;
var DefaultCanvasWrapper = /** @class */ (function (_super) {
    __extends(DefaultCanvasWrapper, _super);
    function DefaultCanvasWrapper(canvas, scale, resizeToWindow) {
        if (scale === void 0) { scale = 1; }
        if (resizeToWindow === void 0) { resizeToWindow = true; }
        var _this = _super.call(this, canvas, scale, resizeToWindow) || this;
        _this.ctx = canvas.getContext("2d");
        _this.ctx.fillStyle = 'black';
        _this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        return _this;
    }
    DefaultCanvasWrapper.prototype.setFillStyle = function (colour) {
        this.ctx.fillStyle = colour;
    };
    DefaultCanvasWrapper.prototype.clearCanvas = function () {
        this.drawRectangle(0, 0, window.innerWidth, window.innerHeight);
    };
    DefaultCanvasWrapper.prototype.drawFrame = function (left, right, up, down) {
        this.drawRectangle(0, 0, this._width / this._scale, up);
        this.drawRectangle(0, 0, left, this._height / this._scale);
        this.drawRectangle(this._width / this._scale - right, 0, right, this._height / this._scale);
        this.drawRectangle(0, this._height / this._scale - down, this._width / this._scale, down);
    };
    DefaultCanvasWrapper.prototype.drawCityName = function () {
        var fontSize = 50 * this._scale;
        this.ctx.font = "small-caps " + fontSize + "px Verdana";
        this.ctx.textAlign = "center";
        this.ctx.fillText("san francisco", this._width / 2, this._height - (80 * this._scale - fontSize));
    };
    DefaultCanvasWrapper.prototype.drawRectangle = function (x, y, width, height) {
        if (this._scale !== 1) {
            x *= this._scale;
            y *= this._scale;
            width *= this._scale;
            height *= this._scale;
        }
        this.ctx.fillRect(x, y, width, height);
    };
    DefaultCanvasWrapper.prototype.drawPolygon = function (polygon) {
        if (polygon.length === 0) {
            return;
        }
        this.zoomVectors(polygon);
        this.ctx.beginPath();
        this.ctx.moveTo(polygon[0].x, polygon[0].y);
        for (var i = 1; i < polygon.length; i++) {
            this.ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        this.ctx.lineTo(polygon[0].x, polygon[0].y);
        this.ctx.fill();
        this.ctx.stroke();
    };
    DefaultCanvasWrapper.prototype.drawSquare = function (centre, radius) {
        this.drawRectangle(centre.x - radius, centre.y - radius, 2 * radius, 2 * radius);
    };
    DefaultCanvasWrapper.prototype.setLineWidth = function (width) {
        if (this._scale !== 1) {
            width *= this._scale;
        }
        this.ctx.lineWidth = width;
    };
    DefaultCanvasWrapper.prototype.setStrokeStyle = function (colour) {
        this.ctx.strokeStyle = colour;
    };
    DefaultCanvasWrapper.prototype.drawPolyline = function (line) {
        if (line.length < 2) {
            return;
        }
        this.zoomVectors(line);
        this.ctx.beginPath();
        this.ctx.moveTo(line[0].x, line[0].y);
        for (var i = 1; i < line.length; i++) {
            this.ctx.lineTo(line[i].x, line[i].y);
        }
        this.ctx.stroke();
    };
    return DefaultCanvasWrapper;
}(CanvasWrapper));
exports.DefaultCanvasWrapper = DefaultCanvasWrapper;
var RoughCanvasWrapper = /** @class */ (function (_super) {
    __extends(RoughCanvasWrapper, _super);
    function RoughCanvasWrapper(canvas, scale, resizeToWindow) {
        if (scale === void 0) { scale = 1; }
        if (resizeToWindow === void 0) { resizeToWindow = true; }
        var _this = _super.call(this, canvas, scale, resizeToWindow) || this;
        _this.options = {
            roughness: 1,
            bowing: 1,
            stroke: '#000000',
            strokeWidth: 1,
            fill: '#000000',
            fillStyle: 'solid',
        };
        var r = require('roughjs/bundled/rough.cjs');
        _this.rc = r.canvas(canvas);
        return _this;
    }
    RoughCanvasWrapper.prototype.drawFrame = function (left, right, up, down) {
    };
    RoughCanvasWrapper.prototype.setOptions = function (options) {
        if (options.strokeWidth) {
            options.strokeWidth *= this._scale;
        }
        Object.assign(this.options, options);
    };
    RoughCanvasWrapper.prototype.clearCanvas = function () {
        this.drawRectangle(0, 0, window.innerWidth, window.innerHeight);
    };
    RoughCanvasWrapper.prototype.drawRectangle = function (x, y, width, height) {
        if (this._scale !== 1) {
            x *= this._scale;
            y *= this._scale;
            width *= this._scale;
            height *= this._scale;
        }
        this.rc.rectangle(x, y, width, height, this.options);
    };
    RoughCanvasWrapper.prototype.drawPolygon = function (polygon) {
        var _this = this;
        if (polygon.length === 0) {
            return;
        }
        if (this._scale !== 1) {
            polygon = polygon.map(function (v) { return v.clone().multiplyScalar(_this._scale); });
        }
        this.rc.polygon(polygon.map(function (v) { return [v.x, v.y]; }), this.options);
    };
    RoughCanvasWrapper.prototype.drawSquare = function (centre, radius) {
        var prevStroke = this.options.stroke;
        this.options.stroke = 'none';
        this.drawRectangle(centre.x - radius, centre.y - radius, 2 * radius, 2 * radius);
        this.options.stroke = prevStroke;
    };
    RoughCanvasWrapper.prototype.drawPolyline = function (line) {
        var _this = this;
        if (line.length < 2) {
            return;
        }
        if (this._scale !== 1) {
            line = line.map(function (v) { return v.clone().multiplyScalar(_this._scale); });
        }
        this.rc.linearPath(line.map(function (v) { return [v.x, v.y]; }), this.options);
    };
    return RoughCanvasWrapper;
}(CanvasWrapper));
exports.RoughCanvasWrapper = RoughCanvasWrapper;

},{"roughjs/bundled/rough.cjs":8}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = require("../vector");
/**
 * Singleton
 * Controls panning and zooming
 */
var DomainController = /** @class */ (function () {
    function DomainController() {
        var _this = this;
        this.ZOOM_SPEED = 0.96;
        // Location of screen origin in world space
        this._origin = vector_1.default.zeroVector();
        // Screen-space width and height
        this._screenDimensions = vector_1.default.zeroVector();
        // Ratio of screen pixels to world pixels
        this._zoom = 1;
        this.zoomCallback = function () { };
        // Set after pan or zoom
        this.moved = false;
        this.setScreenDimensions();
        window.addEventListener('resize', function () { return _this.setScreenDimensions(); });
        window.addEventListener('wheel', function (e) {
            var delta = e.deltaY;
            // TODO scale by value of delta
            if (delta > 0) {
                _this.zoom = _this._zoom * _this.ZOOM_SPEED;
            }
            else {
                _this.zoom = _this._zoom / _this.ZOOM_SPEED;
            }
        });
    }
    DomainController.prototype.setScreenDimensions = function () {
        this.moved = true;
        this._screenDimensions.setX(window.innerWidth);
        this._screenDimensions.setY(window.innerHeight);
    };
    DomainController.getInstance = function () {
        if (!DomainController.instance) {
            DomainController.instance = new DomainController();
        }
        return DomainController.instance;
    };
    /**
     * @param {Vector} delta in world space
     */
    DomainController.prototype.pan = function (delta) {
        this.moved = true;
        this._origin.sub(delta);
    };
    Object.defineProperty(DomainController.prototype, "origin", {
        get: function () {
            return this._origin.clone();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomainController.prototype, "zoom", {
        get: function () {
            return this._zoom;
        },
        set: function (z) {
            if (z > 0) {
                this.moved = true;
                var oldWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
                this._zoom = z;
                var newWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
                this.pan(newWorldSpaceMidpoint.sub(oldWorldSpaceMidpoint));
                this.zoomCallback();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomainController.prototype, "screenDimensions", {
        get: function () {
            return this._screenDimensions.clone();
        },
        set: function (v) {
            this.moved = true;
            this._screenDimensions.copy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomainController.prototype, "worldDimensions", {
        /**
         * @return {Vector} world-space w/h visible on screen
         */
        get: function () {
            return this.screenDimensions.divideScalar(this._zoom);
        },
        enumerable: true,
        configurable: true
    });
    DomainController.prototype.onScreen = function (v) {
        var screenSpace = this.worldToScreen(v.clone());
        return screenSpace.x >= 0 && screenSpace.y >= 0
            && screenSpace.x <= this.screenDimensions.x && screenSpace.y <= this.screenDimensions.y;
    };
    DomainController.prototype.setZoomUpdate = function (callback) {
        this.zoomCallback = callback;
    };
    /**
     * Edits vector
     */
    DomainController.prototype.zoomToWorld = function (v) {
        return v.divideScalar(this._zoom);
    };
    /**
     * Edits vector
     */
    DomainController.prototype.zoomToScreen = function (v) {
        return v.multiplyScalar(this._zoom);
    };
    /**
     * Edits vector
     */
    DomainController.prototype.screenToWorld = function (v) {
        return this.zoomToWorld(v).add(this._origin);
    };
    /**
     * Edits vector
     */
    DomainController.prototype.worldToScreen = function (v) {
        return this.zoomToScreen(v.sub(this._origin));
    };
    return DomainController;
}());
exports.default = DomainController;

},{"../vector":33}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var interactjs_1 = require("interactjs");
var util_1 = require("../util");
var Vector_1 = require("../Vector");
var domain_controller_1 = require("./domain_controller");
/**
* Register multiple centre points
* Closest one to mouse click will be selected to drag
* Up to caller to actually move their centre point via callback
*/
var DragController = /** @class */ (function () {
    function DragController(gui) {
        this.gui = gui;
        // How close to drag handle pointer needs to be
        this.MIN_DRAG_DISTANCE = 50;
        this.draggables = [];
        this.currentlyDragging = null;
        this.disabled = false;
        this.domainController = domain_controller_1.default.getInstance();
        interactjs_1.default("#" + util_1.default.CANVAS_ID).draggable({
            onstart: this.dragStart.bind(this),
            onmove: this.dragMove.bind(this),
            onend: this.dragEnd.bind(this),
            cursorChecker: this.getCursor.bind(this),
        });
    }
    DragController.prototype.setDragDisabled = function (disable) {
        this.disabled = disable;
    };
    DragController.prototype.getCursor = function (action, interactable, element, interacting) {
        if (interacting)
            return 'grabbing';
        return 'grab';
    };
    DragController.prototype.dragStart = function (event) {
        var _this = this;
        // Transform screen space to world space
        var origin = this.domainController.screenToWorld(new Vector_1.default(event.x0, event.y0));
        var closestDistance = Infinity;
        this.draggables.forEach(function (draggable) {
            var d = draggable.getCentre().distanceTo(origin);
            if (d < closestDistance) {
                closestDistance = d;
                _this.currentlyDragging = draggable;
            }
        });
        // Zoom screen size to world size for consistent drag distance while zoomed in
        var scaledDragDistance = this.MIN_DRAG_DISTANCE / this.domainController.zoom;
        if (closestDistance > scaledDragDistance) {
            this.currentlyDragging = null;
        }
    };
    DragController.prototype.dragMove = function (event) {
        var delta = new Vector_1.default(event.delta.x, event.delta.y);
        this.domainController.zoomToWorld(delta);
        if (!this.disabled && this.currentlyDragging !== null) {
            // Drag field
            this.currentlyDragging.callbackFn(delta);
        }
        else {
            // Move map
            this.domainController.pan(delta);
        }
    };
    DragController.prototype.dragEnd = function () {
        this.currentlyDragging = null;
        util_1.default.updateGui(this.gui);
    };
    /**
     * @param {(() => Vector)} Gets centre point
     * @param {((v: Vector) => void)} Called on move with delta vector
     * @returns {(() => void)} Function to deregister callback
     */
    DragController.prototype.register = function (getCentre, onMove) {
        var _this = this;
        var draggable = {
            getCentre: getCentre,
            callbackFn: onMove,
        };
        this.draggables.push(draggable);
        return (function () {
            var index = _this.draggables.indexOf(draggable);
            if (index >= 0) {
                _this.draggables.splice(index, 1);
            }
        }).bind(this);
    };
    return DragController;
}());
exports.default = DragController;

},{"../Vector":13,"../util":32,"./domain_controller":25,"interactjs":3}],27:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var domain_controller_1 = require("./domain_controller");
var util_1 = require("../util");
var streamlines_1 = require("../impl/streamlines");
var RoadGUI = /** @class */ (function () {
    function RoadGUI(params, integrator, guiFolder, closeTensorFolder, folderName, redraw, _animate) {
        var _this = this;
        if (_animate === void 0) { _animate = false; }
        this.params = params;
        this.integrator = integrator;
        this.guiFolder = guiFolder;
        this.closeTensorFolder = closeTensorFolder;
        this.folderName = folderName;
        this.redraw = redraw;
        this._animate = _animate;
        this.existingStreamlines = [];
        this.domainController = domain_controller_1.default.getInstance();
        this.preGenerateCallback = function () { };
        this.postGenerateCallback = function () { };
        this.streamlinesInProgress = false;
        this.streamlines = new streamlines_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, this.params);
        // Update path iterations based on window size
        this.setPathIterations();
        window.addEventListener('resize', function () { return _this.setPathIterations(); });
    }
    RoadGUI.prototype.initFolder = function () {
        var _this = this;
        var roadGUI = {
            Generate: function () { return _this.generateRoads(_this._animate).then(function () { return _this.redraw(); }); },
            JoinDangling: function () {
                _this.streamlines.joinDanglingStreamlines();
                _this.redraw();
            },
        };
        var folder = this.guiFolder.addFolder(this.folderName);
        folder.add(roadGUI, 'Generate');
        folder.add(roadGUI, 'JoinDangling');
        var paramsFolder = folder.addFolder('Params');
        paramsFolder.add(this.params, 'dsep');
        paramsFolder.add(this.params, 'dtest');
        var devParamsFolder = paramsFolder.addFolder('Dev');
        this.addDevParamsToFolder(this.params, devParamsFolder);
        return this;
    };
    Object.defineProperty(RoadGUI.prototype, "animate", {
        set: function (b) {
            this._animate = b;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RoadGUI.prototype, "allStreamlines", {
        get: function () {
            return this.streamlines.allStreamlinesSimple;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RoadGUI.prototype, "roads", {
        get: function () {
            var _this = this;
            // For drawing not generation, probably fine to leave map
            return this.streamlines.allStreamlinesSimple.map(function (s) {
                return s.map(function (v) { return _this.domainController.worldToScreen(v.clone()); });
            });
        },
        enumerable: true,
        configurable: true
    });
    RoadGUI.prototype.roadsEmpty = function () {
        return this.streamlines.allStreamlinesSimple.length === 0;
    };
    RoadGUI.prototype.setExistingStreamlines = function (existingStreamlines) {
        this.existingStreamlines = existingStreamlines;
    };
    RoadGUI.prototype.setPreGenerateCallback = function (callback) {
        this.preGenerateCallback = callback;
    };
    RoadGUI.prototype.setPostGenerateCallback = function (callback) {
        this.postGenerateCallback = callback;
    };
    RoadGUI.prototype.clearStreamlines = function () {
        this.streamlines.clearStreamlines();
    };
    RoadGUI.prototype.generateRoads = function (animate) {
        if (animate === void 0) { animate = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, s;
            var e_1, _c;
            var _this = this;
            return __generator(this, function (_d) {
                this.preGenerateCallback();
                this.domainController.zoom = this.domainController.zoom / 1.2;
                this.streamlines = new streamlines_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params));
                this.domainController.zoom = this.domainController.zoom * 1.2;
                try {
                    for (_a = __values(this.existingStreamlines), _b = _a.next(); !_b.done; _b = _a.next()) {
                        s = _b.value;
                        this.streamlines.addExistingStreamlines(s.streamlines);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                this.closeTensorFolder();
                this.redraw();
                return [2 /*return*/, this.streamlines.createAllStreamlines(animate).then(function () { return _this.postGenerateCallback(); })];
            });
        });
    };
    /**
     * Returns true if streamlines changes
     */
    RoadGUI.prototype.update = function () {
        return this.streamlines.update();
    };
    RoadGUI.prototype.addDevParamsToFolder = function (params, folder) {
        folder.add(params, 'pathIterations');
        folder.add(params, 'seedTries');
        folder.add(params, 'dstep');
        folder.add(params, 'dlookahead');
        folder.add(params, 'dcirclejoin');
        folder.add(params, 'joinangle');
        folder.add(params, 'simplifyTolerance');
        folder.add(params, 'collideEarly');
    };
    /**
     * Sets path iterations so that a road can cover the screen
     */
    RoadGUI.prototype.setPathIterations = function () {
        var max = 1.5 * Math.max(window.innerWidth, window.innerHeight);
        this.params.pathIterations = max / this.params.dstep;
        util_1.default.updateGui(this.guiFolder);
    };
    return RoadGUI;
}());
exports.default = RoadGUI;

},{"../impl/streamlines":20,"../util":32,"./domain_controller":25}],28:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var domain_controller_1 = require("./domain_controller");
var integrator_1 = require("../impl/integrator");
var graph_1 = require("../impl/graph");
var road_gui_1 = require("./road_gui");
var water_gui_1 = require("./water_gui");
var polygon_finder_1 = require("../impl/polygon_finder");
var RoadsGUI = /** @class */ (function () {
    function RoadsGUI(guiFolder, tensorField, closeTensorFolder) {
        var _this = this;
        this.guiFolder = guiFolder;
        this.closeTensorFolder = closeTensorFolder;
        this.numParks = 2;
        this.domainController = domain_controller_1.default.getInstance();
        this.intersections = [];
        this.parks = [];
        this.animate = true;
        this.animationSpeed = 30;
        this.minorParams = {
            dsep: 20,
            dtest: 15,
            dstep: 1,
            dlookahead: 40,
            dcirclejoin: 5,
            joinangle: 0.1,
            pathIterations: 1000,
            seedTries: 300,
            simplifyTolerance: 0.5,
            collideEarly: 0.7,
        };
        this.buildingParams = {
            maxLength: 20,
            minArea: 80,
            shrinkSpacing: 4,
            maxAspectRatio: 5,
        };
        this.redraw = true;
        guiFolder.add(this, 'generateEverything');
        guiFolder.add(this, 'simpleBenchMark');
        var animateController = guiFolder.add(this, 'animate');
        guiFolder.add(this, 'animationSpeed');
        var roadsParams = guiFolder.addFolder('Params');
        roadsParams.add(this, 'numParks');
        this.coastlineParams = Object.assign({
            coastNoise: {
                noiseEnabled: true,
                noiseSize: 30,
                noiseAngle: 20,
            },
            riverNoise: {
                noiseEnabled: true,
                noiseSize: 30,
                noiseAngle: 20,
            },
            riverBankSize: 10,
            riverSize: 30,
        }, this.minorParams);
        this.coastlineParams.pathIterations = 10000;
        this.coastlineParams.simplifyTolerance = 10;
        this.majorParams = Object.assign({}, this.minorParams);
        this.majorParams.dsep = 100;
        this.majorParams.dtest = 30;
        this.majorParams.dlookahead = 200;
        this.majorParams.collideEarly = 0;
        this.mainParams = Object.assign({}, this.minorParams);
        this.mainParams.dsep = 400;
        this.mainParams.dtest = 200;
        this.mainParams.dlookahead = 500;
        this.mainParams.collideEarly = 0;
        var integrator = new integrator_1.RK4Integrator(tensorField, this.minorParams);
        var redraw = function () { return _this.redraw = true; };
        this.coastline = new water_gui_1.default(tensorField, this.coastlineParams, integrator, this.guiFolder, closeTensorFolder, 'Water', redraw).initFolder();
        this.mainRoads = new road_gui_1.default(this.mainParams, integrator, this.guiFolder, closeTensorFolder, 'Main', redraw).initFolder();
        this.majorRoads = new road_gui_1.default(this.majorParams, integrator, this.guiFolder, closeTensorFolder, 'Major', redraw, this.animate).initFolder();
        this.minorRoads = new road_gui_1.default(this.minorParams, integrator, this.guiFolder, closeTensorFolder, 'Minor', redraw, this.animate).initFolder();
        this.buildings = new polygon_finder_1.default([], this.buildingParams);
        animateController.onChange(function (b) {
            _this.majorRoads.animate = b;
            _this.minorRoads.animate = b;
        });
        this.minorRoads.setExistingStreamlines([this.coastline, this.mainRoads, this.majorRoads]);
        this.majorRoads.setExistingStreamlines([this.coastline, this.mainRoads]);
        this.mainRoads.setExistingStreamlines([this.coastline]);
        this.coastline.setPreGenerateCallback(function () {
            _this.mainRoads.clearStreamlines();
            _this.majorRoads.clearStreamlines();
            _this.minorRoads.clearStreamlines();
            _this.parks = [];
            _this.buildings.reset();
            tensorField.parks = [];
            tensorField.sea = [];
            tensorField.river = [];
        });
        this.mainRoads.setPreGenerateCallback(function () {
            _this.majorRoads.clearStreamlines();
            _this.minorRoads.clearStreamlines();
            _this.parks = [];
            _this.buildings.reset();
            tensorField.parks = [];
            tensorField.ignoreRiver = true;
        });
        this.mainRoads.setPostGenerateCallback(function () {
            tensorField.ignoreRiver = false;
        });
        this.majorRoads.setPreGenerateCallback(function () {
            _this.minorRoads.clearStreamlines();
            _this.parks = [];
            _this.buildings.reset();
            tensorField.parks = [];
            tensorField.ignoreRiver = true;
        });
        this.majorRoads.setPostGenerateCallback(function () {
            var e_1, _a;
            var g = new graph_1.default(_this.majorRoads.allStreamlines.concat(_this.mainRoads.allStreamlines), _this.minorParams.dstep);
            _this.intersections = g.intersections;
            var p = new polygon_finder_1.default(g.nodes, _this.buildingParams);
            p.findPolygons();
            var polygons = p.polygons;
            if (polygons.length > _this.numParks) {
                var parkIndex = Math.floor(Math.random() * (polygons.length - _this.numParks));
                for (var i = parkIndex; i < parkIndex + _this.numParks; i++) {
                    _this.parks.push(polygons[i]);
                }
            }
            else {
                try {
                    for (var polygons_1 = __values(polygons), polygons_1_1 = polygons_1.next(); !polygons_1_1.done; polygons_1_1 = polygons_1.next()) {
                        var p_1 = polygons_1_1.value;
                        _this.parks.push(p_1);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (polygons_1_1 && !polygons_1_1.done && (_a = polygons_1.return)) _a.call(polygons_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            tensorField.parks = _this.parks;
            tensorField.ignoreRiver = false;
            _this.redraw = true;
        });
        this.minorRoads.setPreGenerateCallback(function () {
            _this.buildings.reset();
        });
        var buildingsFolder = guiFolder.addFolder('Buildings');
        buildingsFolder.add({ 'AddBuildings': function () { return _this.addBuildings(_this.animate); } }, 'AddBuildings');
        buildingsFolder.add(this.buildingParams, 'minArea');
        buildingsFolder.add(this.buildingParams, 'maxAspectRatio');
        buildingsFolder.add(this.buildingParams, 'shrinkSpacing');
    }
    RoadsGUI.prototype.simpleBenchMark = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tries, sum, i, start;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log.info("Starting Benchmark...");
                        tries = 10;
                        sum = 0;
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < tries)) return [3 /*break*/, 7];
                        start = performance.now();
                        return [4 /*yield*/, this.mainRoads.generateRoads()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.majorRoads.generateRoads()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.minorRoads.generateRoads()];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, this.addBuildings()];
                    case 5:
                        _a.sent();
                        sum += performance.now() - start;
                        _a.label = 6;
                    case 6:
                        i++;
                        return [3 /*break*/, 1];
                    case 7:
                        log.info("Generated " + tries + " cities with average " + sum / tries + "ms");
                        return [2 /*return*/];
                }
            });
        });
    };
    RoadsGUI.prototype.generateEverything = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.coastline.generateRoads();
                        return [4 /*yield*/, this.mainRoads.generateRoads()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.majorRoads.generateRoads(this.animate)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.minorRoads.generateRoads(this.animate)];
                    case 3:
                        _a.sent();
                        this.redraw = true;
                        return [4 /*yield*/, this.addBuildings(this.animate)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    RoadsGUI.prototype.addBuildings = function (animate) {
        if (animate === void 0) { animate = false; }
        return __awaiter(this, void 0, void 0, function () {
            var allStreamlines, g;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        allStreamlines = [];
                        allStreamlines.push.apply(allStreamlines, __spread(this.mainRoads.allStreamlines));
                        allStreamlines.push.apply(allStreamlines, __spread(this.majorRoads.allStreamlines));
                        allStreamlines.push.apply(allStreamlines, __spread(this.minorRoads.allStreamlines));
                        allStreamlines.push.apply(allStreamlines, __spread(this.coastline.streamlinesWithSecondaryRoad));
                        g = new graph_1.default(allStreamlines, this.minorParams.dstep, true);
                        this.buildings = new polygon_finder_1.default(g.nodes, this.buildingParams);
                        this.buildings.findPolygons();
                        return [4 /*yield*/, this.buildings.shrink(animate)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.buildings.divide(animate)];
                    case 2:
                        _a.sent();
                        this.redraw = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    RoadsGUI.prototype.update = function () {
        var continueUpdate = true;
        var start = performance.now();
        while (continueUpdate && performance.now() - start < this.animationSpeed) {
            var minorChanged = this.minorRoads.update();
            var majorChanged = this.majorRoads.update();
            var mainChanged = this.mainRoads.update();
            var buildingsChanged = this.buildings.update();
            continueUpdate = minorChanged || majorChanged || mainChanged || buildingsChanged;
        }
        this.redraw = this.redraw || continueUpdate;
    };
    RoadsGUI.prototype.draw = function (style, forceDraw, customCanvas) {
        var _this = this;
        if (forceDraw === void 0) { forceDraw = false; }
        if (!style.needsUpdate && !forceDraw && !this.redraw && !this.domainController.moved) {
            return;
        }
        style.needsUpdate = false;
        this.domainController.moved = false;
        this.redraw = false;
        style.seaPolygon = this.coastline.seaPolygon;
        style.coastline = this.coastline.coastline;
        style.river = this.coastline.river;
        // style.riverRoads = this.coastline.riverRoads;
        style.buildings = this.buildings.polygons.map(function (l) { return l.map(function (v) { return _this.domainController.worldToScreen(v.clone()); }); });
        style.parks = this.parks.map(function (p) { return p.map(function (v) { return _this.domainController.worldToScreen(v.clone()); }); });
        style.minorRoads = this.minorRoads.roads;
        style.majorRoads = this.majorRoads.roads;
        style.mainRoads = this.mainRoads.roads;
        style.coastlineRoads = this.coastline.roads;
        style.secondaryRiver = this.coastline.secondaryRiver;
        style.draw(customCanvas);
    };
    RoadsGUI.prototype.roadsEmpty = function () {
        return this.majorRoads.roadsEmpty()
            && this.minorRoads.roadsEmpty()
            && this.mainRoads.roadsEmpty()
            && this.coastline.roadsEmpty();
    };
    return RoadsGUI;
}());
exports.default = RoadsGUI;

},{"../impl/graph":15,"../impl/integrator":17,"../impl/polygon_finder":18,"./domain_controller":25,"./road_gui":27,"./water_gui":31,"loglevel":6}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var canvas_wrapper_1 = require("./canvas_wrapper");
var domain_controller_1 = require("./domain_controller");
var Style = /** @class */ (function () {
    function Style() {
        this.domainController = domain_controller_1.default.getInstance();
    }
    Object.defineProperty(Style.prototype, "canvasScale", {
        set: function (scale) {
            this.canvas.canvasScale = scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "needsUpdate", {
        get: function () {
            return this.canvas.needsUpdate;
        },
        set: function (n) {
            this.canvas.needsUpdate = n;
        },
        enumerable: true,
        configurable: true
    });
    return Style;
}());
exports.default = Style;
var DefaultStyle = /** @class */ (function (_super) {
    __extends(DefaultStyle, _super);
    function DefaultStyle(c, colourScheme) {
        var _this = _super.call(this) || this;
        _this.colourScheme = colourScheme;
        // Default cascade
        if (!colourScheme.bgColourIn)
            colourScheme.bgColourIn = colourScheme.bgColour;
        if (!colourScheme.buildingColour)
            colourScheme.buildingColour = colourScheme.bgColour;
        if (!colourScheme.buildingStroke)
            colourScheme.buildingStroke = colourScheme.bgColour;
        if (!colourScheme.grassColour)
            colourScheme.grassColour = colourScheme.bgColour;
        if (!colourScheme.minorRoadOutline)
            colourScheme.minorRoadOutline = colourScheme.minorRoadColour;
        if (!colourScheme.majorRoadColour)
            colourScheme.majorRoadColour = colourScheme.minorRoadColour;
        if (!colourScheme.majorRoadOutline)
            colourScheme.majorRoadOutline = colourScheme.minorRoadOutline;
        if (!colourScheme.mainRoadColour)
            colourScheme.mainRoadColour = colourScheme.majorRoadColour;
        if (!colourScheme.mainRoadOutline)
            colourScheme.mainRoadOutline = colourScheme.majorRoadOutline;
        if (!colourScheme.outlineSize)
            colourScheme.outlineSize = 1;
        if (!colourScheme.zoomBuildings)
            colourScheme.zoomBuildings = false;
        if (!colourScheme.minorWidth)
            colourScheme.minorWidth = 2;
        if (!colourScheme.majorWidth)
            colourScheme.majorWidth = 4;
        if (!colourScheme.mainWidth)
            colourScheme.mainWidth = 5;
        if (!colourScheme.mainWidth)
            colourScheme.mainWidth = 5;
        if (!colourScheme.frameColour)
            colourScheme.frameColour = colourScheme.bgColour;
        if (!colourScheme.frameTextColour)
            colourScheme.frameTextColour = colourScheme.minorRoadOutline;
        _this.canvas = _this.createCanvasWrapper(c, 1, true);
        return _this;
    }
    Object.defineProperty(DefaultStyle.prototype, "zoomBuildings", {
        set: function (b) {
            this.colourScheme.zoomBuildings = b;
        },
        enumerable: true,
        configurable: true
    });
    DefaultStyle.prototype.createCanvasWrapper = function (c, scale, resizeToWindow) {
        if (scale === void 0) { scale = 1; }
        if (resizeToWindow === void 0) { resizeToWindow = true; }
        return new canvas_wrapper_1.DefaultCanvasWrapper(c, scale, resizeToWindow);
    };
    DefaultStyle.prototype.draw = function (canvas) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e, e_6, _f, e_7, _g, e_8, _h, e_9, _j, e_10, _k;
        if (canvas === void 0) { canvas = this.canvas; }
        var bgColour;
        if (this.colourScheme.zoomBuildings) {
            bgColour = this.domainController.zoom >= 2 ? this.colourScheme.bgColour : this.colourScheme.bgColourIn;
        }
        else {
            bgColour = this.colourScheme.bgColour;
        }
        canvas.setFillStyle(bgColour);
        canvas.clearCanvas();
        // Sea
        canvas.setFillStyle(this.colourScheme.seaColour);
        canvas.setStrokeStyle(this.colourScheme.seaColour);
        canvas.setLineWidth(0.1);
        canvas.drawPolygon(this.seaPolygon);
        // Coastline
        canvas.setStrokeStyle(bgColour);
        canvas.setLineWidth(30 * this.domainController.zoom);
        canvas.drawPolyline(this.coastline);
        canvas.setLineWidth(1);
        // Buildings
        if (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2) {
            canvas.setFillStyle(this.colourScheme.buildingColour);
            canvas.setStrokeStyle(this.colourScheme.buildingStroke);
            try {
                for (var _l = __values(this.buildings), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var b = _m.value;
                    canvas.drawPolygon(b);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_a = _l.return)) _a.call(_l);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        // Parks
        canvas.setFillStyle(this.colourScheme.grassColour);
        try {
            for (var _o = __values(this.parks), _p = _o.next(); !_p.done; _p = _o.next()) {
                var p = _p.value;
                canvas.drawPolygon(p);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_p && !_p.done && (_b = _o.return)) _b.call(_o);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // River
        canvas.setFillStyle(this.colourScheme.seaColour);
        canvas.setStrokeStyle(this.colourScheme.seaColour);
        canvas.setLineWidth(0.1);
        canvas.drawPolygon(this.river);
        // Road outline
        canvas.setStrokeStyle(this.colourScheme.minorRoadOutline);
        canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.minorWidth * this.domainController.zoom);
        try {
            for (var _q = __values(this.minorRoads), _r = _q.next(); !_r.done; _r = _q.next()) {
                var s = _r.value;
                canvas.drawPolyline(s);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_r && !_r.done && (_c = _q.return)) _c.call(_q);
            }
            finally { if (e_3) throw e_3.error; }
        }
        canvas.setStrokeStyle(this.colourScheme.majorRoadOutline);
        canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.majorWidth * this.domainController.zoom);
        try {
            for (var _s = __values(this.majorRoads), _t = _s.next(); !_t.done; _t = _s.next()) {
                var s = _t.value;
                canvas.drawPolyline(s);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_t && !_t.done && (_d = _s.return)) _d.call(_s);
            }
            finally { if (e_4) throw e_4.error; }
        }
        canvas.drawPolyline(this.secondaryRiver);
        canvas.setStrokeStyle(this.colourScheme.mainRoadOutline);
        canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.mainWidth * this.domainController.zoom);
        try {
            for (var _u = __values(this.mainRoads), _v = _u.next(); !_v.done; _v = _u.next()) {
                var s = _v.value;
                canvas.drawPolyline(s);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_v && !_v.done && (_e = _u.return)) _e.call(_u);
            }
            finally { if (e_5) throw e_5.error; }
        }
        try {
            for (var _w = __values(this.coastlineRoads), _x = _w.next(); !_x.done; _x = _w.next()) {
                var s = _x.value;
                canvas.drawPolyline(s);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_x && !_x.done && (_f = _w.return)) _f.call(_w);
            }
            finally { if (e_6) throw e_6.error; }
        }
        // Road inline
        canvas.setStrokeStyle(this.colourScheme.minorRoadColour);
        canvas.setLineWidth(this.colourScheme.minorWidth * this.domainController.zoom);
        try {
            for (var _y = __values(this.minorRoads), _z = _y.next(); !_z.done; _z = _y.next()) {
                var s = _z.value;
                canvas.drawPolyline(s);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_z && !_z.done && (_g = _y.return)) _g.call(_y);
            }
            finally { if (e_7) throw e_7.error; }
        }
        canvas.setStrokeStyle(this.colourScheme.majorRoadColour);
        canvas.setLineWidth(this.colourScheme.majorWidth * this.domainController.zoom);
        try {
            for (var _0 = __values(this.majorRoads), _1 = _0.next(); !_1.done; _1 = _0.next()) {
                var s = _1.value;
                canvas.drawPolyline(s);
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_1 && !_1.done && (_h = _0.return)) _h.call(_0);
            }
            finally { if (e_8) throw e_8.error; }
        }
        canvas.drawPolyline(this.secondaryRiver);
        canvas.setStrokeStyle(this.colourScheme.mainRoadColour);
        canvas.setLineWidth(this.colourScheme.mainWidth * this.domainController.zoom);
        try {
            for (var _2 = __values(this.mainRoads), _3 = _2.next(); !_3.done; _3 = _2.next()) {
                var s = _3.value;
                canvas.drawPolyline(s);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_3 && !_3.done && (_j = _2.return)) _j.call(_2);
            }
            finally { if (e_9) throw e_9.error; }
        }
        try {
            for (var _4 = __values(this.coastlineRoads), _5 = _4.next(); !_5.done; _5 = _4.next()) {
                var s = _5.value;
                canvas.drawPolyline(s);
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_5 && !_5.done && (_k = _4.return)) _k.call(_4);
            }
            finally { if (e_10) throw e_10.error; }
        }
        if (this.showFrame) {
            canvas.setFillStyle(this.colourScheme.frameColour);
            canvas.setStrokeStyle(this.colourScheme.frameColour);
            canvas.drawFrame(30, 30, 30, 80);
            canvas.setFillStyle(this.colourScheme.frameTextColour);
            canvas.drawCityName();
        }
    };
    return DefaultStyle;
}(Style));
exports.DefaultStyle = DefaultStyle;
var RoughStyle = /** @class */ (function (_super) {
    __extends(RoughStyle, _super);
    function RoughStyle(c) {
        var _this = _super.call(this) || this;
        _this.canvas = _this.createCanvasWrapper(c, 1, true);
        return _this;
    }
    RoughStyle.prototype.createCanvasWrapper = function (c, scale, resizeToWindow) {
        if (scale === void 0) { scale = 1; }
        if (resizeToWindow === void 0) { resizeToWindow = true; }
        return new canvas_wrapper_1.RoughCanvasWrapper(c, scale, resizeToWindow);
    };
    RoughStyle.prototype.draw = function (canvas) {
        if (canvas === void 0) { canvas = this.canvas; }
        canvas.setOptions({
            roughness: 1,
            bowing: 1,
            stroke: '#000000',
            strokeWidth: 1,
            fill: '#000000',
            fillStyle: 'solid',
        });
        canvas.setOptions({
            fill: "rgb(242,236,222)",
            roughness: 1,
            bowing: 1,
            fillStyle: 'solid',
            stroke: "none",
        });
        canvas.clearCanvas();
        // Sea
        canvas.setOptions({
            roughness: 0,
            fillWeight: 1,
            fill: "#dbd2bd",
            fillStyle: 'solid',
            stroke: "none",
            strokeWidth: 1,
        });
        canvas.drawPolygon(this.seaPolygon);
        canvas.setOptions({
            stroke: "rgb(242,236,222)",
            strokeWidth: 30,
        });
        canvas.drawPolyline(this.coastline);
        // Buildings
        canvas.setOptions({
            roughness: 1.2,
            stroke: '#333333',
            strokeWidth: 1,
            fill: '',
        });
        this.buildings.forEach(function (b) { return canvas.drawPolygon(b); });
        // Parks
        canvas.setOptions({
            fill: "rgb(242,236,222)",
        });
        this.parks.forEach(function (p) { return canvas.drawPolygon(p); });
        // Road inline
        canvas.setOptions({
            stroke: '#666666',
            strokeWidth: 1,
            fill: 'none',
        });
        this.minorRoads.forEach(function (s) { return canvas.drawPolyline(s); });
        canvas.setOptions({
            strokeWidth: 2,
            stroke: '#444444',
        });
        this.majorRoads.forEach(function (s) { return canvas.drawPolyline(s); });
        canvas.setOptions({
            strokeWidth: 3,
            stroke: '#222222',
        });
        this.mainRoads.forEach(function (s) { return canvas.drawPolyline(s); });
        this.coastlineRoads.forEach(function (s) { return canvas.drawPolyline(s); });
    };
    return RoughStyle;
}(Style));
exports.RoughStyle = RoughStyle;

},{"./canvas_wrapper":24,"./domain_controller":25}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var domain_controller_1 = require("./domain_controller");
var tensor_field_1 = require("../impl/tensor_field");
var util_1 = require("../util");
var vector_1 = require("../vector");
var TensorFieldGUI = /** @class */ (function (_super) {
    __extends(TensorFieldGUI, _super);
    function TensorFieldGUI(guiFolder, dragController, drawCentre, noiseParams) {
        var _this = _super.call(this, noiseParams) || this;
        _this.guiFolder = guiFolder;
        _this.dragController = dragController;
        _this.drawCentre = drawCentre;
        _this.TENSOR_LINE_DIAMETER = 20;
        _this.TENSOR_SPAWN_SCALE = 0.7; // How much to shrink worldDimensions to find spawn point
        _this.domainController = domain_controller_1.default.getInstance();
        // For custom naming of gui buttons
        var tensorFieldGuiObj = {
            reset: function () { return _this.reset(); },
            setRecommended: function () { return _this.setRecommended(); },
            addRadial: function () { return _this.addRadialRandom(); },
            addGrid: function () { return _this.addGridRandom(); },
        };
        _this.guiFolder.add(tensorFieldGuiObj, 'reset');
        _this.guiFolder.add(tensorFieldGuiObj, 'setRecommended');
        _this.guiFolder.add(tensorFieldGuiObj, 'addRadial');
        _this.guiFolder.add(tensorFieldGuiObj, 'addGrid');
        return _this;
    }
    /**
     * 4 Grids, one radial
     */
    TensorFieldGUI.prototype.setRecommended = function () {
        this.reset();
        var size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
        var newOrigin = this.domainController.worldDimensions
            .multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2)
            .add(this.domainController.origin);
        this.addGridAtLocation(newOrigin);
        this.addGridAtLocation(newOrigin.clone().add(size));
        this.addGridAtLocation(newOrigin.clone().add(new vector_1.default(size.x, 0)));
        this.addGridAtLocation(newOrigin.clone().add(new vector_1.default(0, size.y)));
        this.addRadialRandom();
    };
    TensorFieldGUI.prototype.addRadialRandom = function () {
        var width = this.domainController.worldDimensions.x;
        this.addRadial(this.randomLocation(), util_1.default.randomRange(width / 10, width / 5), // Size
        util_1.default.randomRange(50)); // Decay
    };
    TensorFieldGUI.prototype.addGridRandom = function () {
        this.addGridAtLocation(this.randomLocation());
    };
    TensorFieldGUI.prototype.addGridAtLocation = function (location) {
        var width = this.domainController.worldDimensions.x;
        this.addGrid(location, util_1.default.randomRange(width / 4, width), // Size
        util_1.default.randomRange(50), // Decay
        util_1.default.randomRange(Math.PI / 2));
    };
    /**
     * World-space random location for tensor field spawn
     * Sampled from middle of screen (shrunk rectangle)
     */
    TensorFieldGUI.prototype.randomLocation = function () {
        var size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
        var location = new vector_1.default(Math.random(), Math.random()).multiply(size);
        var newOrigin = this.domainController.worldDimensions.multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2);
        return location.add(this.domainController.origin).add(newOrigin);
    };
    TensorFieldGUI.prototype.getCrossLocations = function () {
        // Gets grid of points for vector field vis in world space
        var diameter = this.TENSOR_LINE_DIAMETER / this.domainController.zoom;
        var worldDimensions = this.domainController.worldDimensions;
        var nHor = Math.ceil(worldDimensions.x / diameter) + 1; // Prevent pop-in
        var nVer = Math.ceil(worldDimensions.y / diameter) + 1;
        var originX = diameter * Math.floor(this.domainController.origin.x / diameter);
        var originY = diameter * Math.floor(this.domainController.origin.y / diameter);
        var out = [];
        for (var x = 0; x <= nHor; x++) {
            for (var y = 0; y <= nVer; y++) {
                out.push(new vector_1.default(originX + (x * diameter), originY + (y * diameter)));
            }
        }
        return out;
    };
    TensorFieldGUI.prototype.getTensorLine = function (point, tensorV) {
        var transformedPoint = this.domainController.worldToScreen(point.clone());
        var diff = tensorV.multiplyScalar(this.TENSOR_LINE_DIAMETER / 2); // Assumes normalised
        var start = transformedPoint.clone().sub(diff);
        var end = transformedPoint.clone().add(diff);
        return [start, end];
    };
    TensorFieldGUI.prototype.draw = function (canvas) {
        var _this = this;
        // Draw tensor field
        canvas.setFillStyle('black');
        canvas.clearCanvas();
        canvas.setStrokeStyle('white');
        canvas.setLineWidth(1);
        var tensorPoints = this.getCrossLocations();
        tensorPoints.forEach(function (p) {
            var t = _this.samplePoint(p);
            canvas.drawPolyline(_this.getTensorLine(p, t.getMajor()));
            canvas.drawPolyline(_this.getTensorLine(p, t.getMinor()));
        });
        // Draw centre points of fields
        if (this.drawCentre) {
            canvas.setFillStyle('red');
            this.getCentrePoints().forEach(function (v) {
                return canvas.drawSquare(_this.domainController.worldToScreen(v), 7);
            });
        }
    };
    TensorFieldGUI.prototype.addField = function (field) {
        var _this = this;
        _super.prototype.addField.call(this, field);
        var folder = this.guiFolder.addFolder("" + field.FOLDER_NAME);
        // Function to deregister from drag controller
        var deregisterDrag = this.dragController.register(function () { return field.centre; }, field.dragMoveListener.bind(field));
        var removeFieldObj = { remove: function () { return _this.removeFieldGUI.bind(_this)(field, folder, deregisterDrag); } };
        // Give dat gui removeField button
        folder.add(removeFieldObj, 'remove');
        field.setGui(folder);
    };
    TensorFieldGUI.prototype.removeFieldGUI = function (field, folder, deregisterDrag) {
        _super.prototype.removeField.call(this, field);
        this.guiFolder.removeFolder(folder);
        // Deregister from drag controller
        deregisterDrag();
    };
    TensorFieldGUI.prototype.reset = function () {
        // TODO kind of hacky - calling remove callbacks from gui object, should store callbacks
        // in addfield and call them (requires making sure they're idempotent)
        for (var fieldFolderName in this.guiFolder.__folders) {
            var fieldFolder = this.guiFolder.__folders[fieldFolderName];
            fieldFolder.__controllers[0].initialValue();
        }
        _super.prototype.reset.call(this);
    };
    return TensorFieldGUI;
}(tensor_field_1.default));
exports.default = TensorFieldGUI;

},{"../impl/tensor_field":22,"../util":32,"../vector":33,"./domain_controller":25}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var water_generator_1 = require("../impl/water_generator");
var road_gui_1 = require("./road_gui");
var WaterGUI = /** @class */ (function (_super) {
    __extends(WaterGUI, _super);
    function WaterGUI(tensorField, params, integrator, guiFolder, closeTensorFolder, folderName, redraw) {
        var _this = _super.call(this, params, integrator, guiFolder, closeTensorFolder, folderName, redraw) || this;
        _this.tensorField = tensorField;
        _this.params = params;
        return _this;
    }
    WaterGUI.prototype.initFolder = function () {
        var _this = this;
        var folder = this.guiFolder.addFolder(this.folderName);
        folder.open();
        folder.add({ Generate: function () { return _this.generateRoads(); } }, 'Generate');
        var coastParamsFolder = folder.addFolder('CoastParams');
        coastParamsFolder.add(this.params.coastNoise, 'noiseEnabled');
        coastParamsFolder.add(this.params.coastNoise, 'noiseSize');
        coastParamsFolder.add(this.params.coastNoise, 'noiseAngle');
        var riverParamsFolder = folder.addFolder('RiverParams');
        riverParamsFolder.add(this.params.coastNoise, 'noiseEnabled');
        riverParamsFolder.add(this.params.coastNoise, 'noiseSize');
        riverParamsFolder.add(this.params.coastNoise, 'noiseAngle');
        folder.add(this.params, 'simplifyTolerance');
        var devParamsFolder = folder.addFolder('Dev');
        this.addDevParamsToFolder(this.params, devParamsFolder);
        return this;
    };
    WaterGUI.prototype.generateRoads = function () {
        this.preGenerateCallback();
        this.domainController.zoom = this.domainController.zoom / 1.2;
        this.streamlines = new water_generator_1.default(this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params), this.tensorField);
        this.domainController.zoom = this.domainController.zoom * 1.2;
        this.streamlines.createCoast();
        this.streamlines.createRiver();
        this.closeTensorFolder();
        this.redraw();
        this.postGenerateCallback();
        return new Promise(function (resolve) { return resolve(); });
    };
    Object.defineProperty(WaterGUI.prototype, "streamlinesWithSecondaryRoad", {
        get: function () {
            var withSecondary = this.streamlines.allStreamlinesSimple.slice();
            withSecondary.push(this.streamlines.riverSecondaryRoad);
            return withSecondary;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaterGUI.prototype, "river", {
        get: function () {
            var _this = this;
            return this.streamlines.riverPolygon.map(function (v) { return _this.domainController.worldToScreen(v.clone()); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaterGUI.prototype, "secondaryRiver", {
        get: function () {
            var _this = this;
            return this.streamlines.riverSecondaryRoad.map(function (v) { return _this.domainController.worldToScreen(v.clone()); });
            ;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaterGUI.prototype, "coastline", {
        get: function () {
            var _this = this;
            // Use unsimplified noisy streamline as coastline
            // Visual only, no road logic performed using this
            return this.streamlines.coastline.map(function (v) { return _this.domainController.worldToScreen(v.clone()); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaterGUI.prototype, "seaPolygon", {
        get: function () {
            var _this = this;
            return this.streamlines.seaPolygon.map(function (v) { return _this.domainController.worldToScreen(v.clone()); });
        },
        enumerable: true,
        configurable: true
    });
    WaterGUI.prototype.addDevParamsToFolder = function (params, folder) {
        folder.add(params, 'dsep');
        folder.add(params, 'dtest');
        folder.add(params, 'pathIterations');
        folder.add(params, 'seedTries');
        folder.add(params, 'dstep');
        folder.add(params, 'dlookahead');
        folder.add(params, 'dcirclejoin');
        folder.add(params, 'joinangle');
    };
    return WaterGUI;
}(road_gui_1.default));
exports.default = WaterGUI;

},{"../impl/water_generator":23,"./road_gui":27}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Util = /** @class */ (function () {
    function Util() {
    }
    Util.updateGui = function (gui) {
        if (gui.__controllers) {
            gui.__controllers.forEach(function (c) { return c.updateDisplay(); });
        }
        if (gui.__folders) {
            for (var folderName in gui.__folders) {
                this.updateGui(gui.__folders[folderName]);
            }
        }
    };
    Util.removeAllFolders = function (gui) {
        if (gui.__folders) {
            for (var folderName in gui.__folders) {
                gui.removeFolder(gui.__folders[folderName]);
            }
        }
    };
    Util.randomRange = function (max, min) {
        if (min === void 0) { min = 0; }
        return (Math.random() * (max - min)) + min;
    };
    // Must match style.css
    Util.CANVAS_ID = 'map-canvas';
    Util.IMG_CANVAS_ID = 'img-canvas';
    return Util;
}());
exports.default = Util;

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("loglevel");
var Vector = /** @class */ (function () {
    function Vector(x, y) {
        this.x = x;
        this.y = y;
    }
    Vector.zeroVector = function () {
        return new Vector(0, 0);
    };
    Vector.fromScalar = function (s) {
        return new Vector(s, s);
    };
    /**
     * -pi to pi
     */
    Vector.angleBetween = function (v1, v2) {
        // -2pi to 2pi
        var angleBetween = v1.angle() - v2.angle();
        if (angleBetween > Math.PI) {
            angleBetween -= 2 * Math.PI;
        }
        else if (angleBetween <= -Math.PI) {
            angleBetween += 2 * Math.PI;
        }
        return angleBetween;
    };
    /**
     * Tests whether a point lies to the left of a line
     * @param  {Vector} linePoint     Point on the line
     * @param  {Vector} lineDirection
     * @param  {Vector} point
     * @return {Vector}               true if left, false otherwise
     */
    Vector.isLeft = function (linePoint, lineDirection, point) {
        var perpendicularVector = new Vector(lineDirection.y, -lineDirection.x);
        return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
    };
    Vector.prototype.add = function (v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    };
    /**
     * Angle in radians to positive x-axis between -pi and pi
     */
    Vector.prototype.angle = function () {
        return Math.atan2(this.y, this.x);
    };
    Vector.prototype.clone = function () {
        return new Vector(this.x, this.y);
    };
    Vector.prototype.copy = function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    };
    Vector.prototype.cross = function (v) {
        return this.x * v.y - this.y * v.x;
    };
    Vector.prototype.distanceTo = function (v) {
        return Math.sqrt(this.distanceToSquared(v));
    };
    Vector.prototype.distanceToSquared = function (v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        return dx * dx + dy * dy;
    };
    Vector.prototype.divide = function (v) {
        if (v.x === 0 || v.y === 0) {
            log.warn("Division by zero");
            return this;
        }
        this.x /= v.x;
        this.y /= v.y;
        return this;
    };
    Vector.prototype.divideScalar = function (s) {
        if (s === 0) {
            log.warn("Division by zero");
            return this;
        }
        return this.multiplyScalar(1 / s);
    };
    Vector.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y;
    };
    Vector.prototype.equals = function (v) {
        return ((v.x === this.x) && (v.y === this.y));
    };
    Vector.prototype.length = function () {
        return Math.sqrt(this.lengthSq());
    };
    Vector.prototype.lengthSq = function () {
        return this.x * this.x + this.y * this.y;
    };
    Vector.prototype.multiply = function (v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    };
    Vector.prototype.multiplyScalar = function (s) {
        this.x *= s;
        this.y *= s;
        return this;
    };
    Vector.prototype.negate = function () {
        return this.multiplyScalar(-1);
    };
    Vector.prototype.normalize = function () {
        var l = this.length();
        if (l === 0) {
            log.warn("Zero Vector");
            return this;
        }
        return this.divideScalar(this.length());
    };
    /**
     * Angle in radians
     */
    Vector.prototype.rotateAround = function (center, angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * cos - y * sin + center.x;
        this.y = x * sin + y * cos + center.y;
        return this;
    };
    Vector.prototype.set = function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    };
    Vector.prototype.setX = function (x) {
        this.x = x;
        return this;
    };
    Vector.prototype.setY = function (y) {
        this.y = y;
        return this;
    };
    Vector.prototype.setLength = function (length) {
        return this.normalize().multiplyScalar(length);
    };
    Vector.prototype.sub = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    };
    return Vector;
}());
exports.default = Vector;

},{"loglevel":6}]},{},[12,14,15,16,17,18,19,20,22,21,23,24,25,26,27,28,29,30,31,32,33])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvZGlzdC9kMy1xdWFkdHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXQuZ3VpL2J1aWxkL2RhdC5ndWkuanMiLCJub2RlX21vZHVsZXMvaW50ZXJhY3Rqcy9kaXN0L2ludGVyYWN0Lm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9pc2VjdC9idWlsZC9pc2VjdC5qcyIsIm5vZGVfbW9kdWxlcy9qc3RzL2Rpc3QvanN0cy5taW4uanMiLCJub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzL3BvbHlrL2Rpc3QvcG9seWsuanMiLCJub2RlX21vZHVsZXMvcm91Z2hqcy9idW5kbGVkL3JvdWdoLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGV4LW5vaXNlL3NpbXBsZXgtbm9pc2UuanMiLCJub2RlX21vZHVsZXMvc2ltcGxpZnktanMvc2ltcGxpZnkuanMiLCJzcmMvY29sb3VyX3NjaGVtZXMuanNvbiIsInNyYy9tYWluLnRzIiwic3JjL3RzL1ZlY3Rvci50cyIsInNyYy90cy9pbXBsL2Jhc2lzX2ZpZWxkLnRzIiwic3JjL3RzL2ltcGwvZ3JhcGgudHMiLCJzcmMvdHMvaW1wbC9ncmlkX3N0b3JhZ2UudHMiLCJzcmMvdHMvaW1wbC9pbnRlZ3JhdG9yLnRzIiwic3JjL3RzL2ltcGwvcG9seWdvbl9maW5kZXIudHMiLCJzcmMvdHMvaW1wbC9wb2x5Z29uX3V0aWwudHMiLCJzcmMvdHMvaW1wbC9zdHJlYW1saW5lcy50cyIsInNyYy90cy9pbXBsL3RlbnNvci50cyIsInNyYy90cy9pbXBsL3RlbnNvcl9maWVsZC50cyIsInNyYy90cy9pbXBsL3dhdGVyX2dlbmVyYXRvci50cyIsInNyYy90cy91aS9jYW52YXNfd3JhcHBlci50cyIsInNyYy90cy91aS9kb21haW5fY29udHJvbGxlci50cyIsInNyYy90cy91aS9kcmFnX2NvbnRyb2xsZXIudHMiLCJzcmMvdHMvdWkvcm9hZF9ndWkudHMiLCJzcmMvdHMvdWkvcm9hZHNfZ3VpLnRzIiwic3JjL3RzL3VpL3N0eWxlLnRzIiwic3JjL3RzL3VpL3RlbnNvcl9maWVsZF9ndWkudHMiLCJzcmMvdHMvdWkvd2F0ZXJfZ3VpLnRzIiwic3JjL3RzL3V0aWwudHMiLCJzcmMvdHMvdmVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3orRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNodkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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ZCxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDZCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBQ0wsYUFBQztBQUFELENBL0tBLEFBK0tDLElBQUEiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBodHRwczovL2QzanMub3JnL2QzLXF1YWR0cmVlLyB2MS4wLjcgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiB0cmVlX2FkZChkKSB7XG4gIHZhciB4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSxcbiAgICAgIHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpO1xuICByZXR1cm4gYWRkKHRoaXMuY292ZXIoeCwgeSksIHgsIHksIGQpO1xufVxuXG5mdW5jdGlvbiBhZGQodHJlZSwgeCwgeSwgZCkge1xuICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiB0cmVlOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRyZWUuX3Jvb3QsXG4gICAgICBsZWFmID0ge2RhdGE6IGR9LFxuICAgICAgeDAgPSB0cmVlLl94MCxcbiAgICAgIHkwID0gdHJlZS5feTAsXG4gICAgICB4MSA9IHRyZWUuX3gxLFxuICAgICAgeTEgPSB0cmVlLl95MSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICB4cCxcbiAgICAgIHlwLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIEZpbmQgdGhlIGV4aXN0aW5nIGxlYWYgZm9yIHRoZSBuZXcgcG9pbnQsIG9yIGFkZCBpdC5cbiAgd2hpbGUgKG5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKHBhcmVudCA9IG5vZGUsICEobm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG4gIH1cblxuICAvLyBJcyB0aGUgbmV3IHBvaW50IGlzIGV4YWN0bHkgY29pbmNpZGVudCB3aXRoIHRoZSBleGlzdGluZyBwb2ludD9cbiAgeHAgPSArdHJlZS5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIHlwID0gK3RyZWUuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICBpZiAoeCA9PT0geHAgJiYgeSA9PT0geXApIHJldHVybiBsZWFmLm5leHQgPSBub2RlLCBwYXJlbnQgPyBwYXJlbnRbaV0gPSBsZWFmIDogdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxuICBkbyB7XG4gICAgcGFyZW50ID0gcGFyZW50ID8gcGFyZW50W2ldID0gbmV3IEFycmF5KDQpIDogdHJlZS5fcm9vdCA9IG5ldyBBcnJheSg0KTtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgfSB3aGlsZSAoKGkgPSBib3R0b20gPDwgMSB8IHJpZ2h0KSA9PT0gKGogPSAoeXAgPj0geW0pIDw8IDEgfCAoeHAgPj0geG0pKSk7XG4gIHJldHVybiBwYXJlbnRbal0gPSBub2RlLCBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xufVxuXG5mdW5jdGlvbiBhZGRBbGwoZGF0YSkge1xuICB2YXIgZCwgaSwgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHl6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeDAgPSBJbmZpbml0eSxcbiAgICAgIHkwID0gSW5maW5pdHksXG4gICAgICB4MSA9IC1JbmZpbml0eSxcbiAgICAgIHkxID0gLUluZmluaXR5O1xuXG4gIC8vIENvbXB1dGUgdGhlIHBvaW50cyBhbmQgdGhlaXIgZXh0ZW50LlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQgPSBkYXRhW2ldKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSBjb250aW51ZTtcbiAgICB4eltpXSA9IHg7XG4gICAgeXpbaV0gPSB5O1xuICAgIGlmICh4IDwgeDApIHgwID0geDtcbiAgICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gICAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICAgIGlmICh5ID4geTEpIHkxID0geTtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIHdlcmUgbm8gKHZhbGlkKSBwb2ludHMsIGFib3J0LlxuICBpZiAoeDAgPiB4MSB8fCB5MCA+IHkxKSByZXR1cm4gdGhpcztcblxuICAvLyBFeHBhbmQgdGhlIHRyZWUgdG8gY292ZXIgdGhlIG5ldyBwb2ludHMuXG4gIHRoaXMuY292ZXIoeDAsIHkwKS5jb3Zlcih4MSwgeTEpO1xuXG4gIC8vIEFkZCB0aGUgbmV3IHBvaW50cy5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGFkZCh0aGlzLCB4eltpXSwgeXpbaV0sIGRhdGFbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRyZWVfY292ZXIoeCwgeSkge1xuICBpZiAoaXNOYU4oeCA9ICt4KSB8fCBpc05hTih5ID0gK3kpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTE7XG5cbiAgLy8gSWYgdGhlIHF1YWR0cmVlIGhhcyBubyBleHRlbnQsIGluaXRpYWxpemUgdGhlbS5cbiAgLy8gSW50ZWdlciBleHRlbnQgYXJlIG5lY2Vzc2FyeSBzbyB0aGF0IGlmIHdlIGxhdGVyIGRvdWJsZSB0aGUgZXh0ZW50LFxuICAvLyB0aGUgZXhpc3RpbmcgcXVhZHJhbnQgYm91bmRhcmllcyBkb27igJl0IGNoYW5nZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3IhXG4gIGlmIChpc05hTih4MCkpIHtcbiAgICB4MSA9ICh4MCA9IE1hdGguZmxvb3IoeCkpICsgMTtcbiAgICB5MSA9ICh5MCA9IE1hdGguZmxvb3IoeSkpICsgMTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZG91YmxlIHJlcGVhdGVkbHkgdG8gY292ZXIuXG4gIGVsc2Uge1xuICAgIHZhciB6ID0geDEgLSB4MCxcbiAgICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgaTtcblxuICAgIHdoaWxlICh4MCA+IHggfHwgeCA+PSB4MSB8fCB5MCA+IHkgfHwgeSA+PSB5MSkge1xuICAgICAgaSA9ICh5IDwgeTApIDw8IDEgfCAoeCA8IHgwKTtcbiAgICAgIHBhcmVudCA9IG5ldyBBcnJheSg0KSwgcGFyZW50W2ldID0gbm9kZSwgbm9kZSA9IHBhcmVudCwgeiAqPSAyO1xuICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGNhc2UgMDogeDEgPSB4MCArIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAxOiB4MCA9IHgxIC0geiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHgxID0geDAgKyB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogeDAgPSB4MSAtIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcm9vdCAmJiB0aGlzLl9yb290Lmxlbmd0aCkgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdHJlZV9kYXRhKCkge1xuICB2YXIgZGF0YSA9IFtdO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyBkYXRhLnB1c2gobm9kZS5kYXRhKTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gdHJlZV9leHRlbnQoXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdLCArX1swXVsxXSkuY292ZXIoK19bMV1bMF0sICtfWzFdWzFdKVxuICAgICAgOiBpc05hTih0aGlzLl94MCkgPyB1bmRlZmluZWQgOiBbW3RoaXMuX3gwLCB0aGlzLl95MF0sIFt0aGlzLl94MSwgdGhpcy5feTFdXTtcbn1cblxuZnVuY3Rpb24gUXVhZChub2RlLCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLngwID0geDA7XG4gIHRoaXMueTAgPSB5MDtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG59XG5cbmZ1bmN0aW9uIHRyZWVfZmluZCh4LCB5LCByYWRpdXMpIHtcbiAgdmFyIGRhdGEsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgeDMgPSB0aGlzLl94MSxcbiAgICAgIHkzID0gdGhpcy5feTEsXG4gICAgICBxdWFkcyA9IFtdLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBxLFxuICAgICAgaTtcblxuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB4MCwgeTAsIHgzLCB5MykpO1xuICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICBlbHNlIHtcbiAgICB4MCA9IHggLSByYWRpdXMsIHkwID0geSAtIHJhZGl1cztcbiAgICB4MyA9IHggKyByYWRpdXMsIHkzID0geSArIHJhZGl1cztcbiAgICByYWRpdXMgKj0gcmFkaXVzO1xuICB9XG5cbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuXG4gICAgLy8gU3RvcCBzZWFyY2hpbmcgaWYgdGhpcyBxdWFkcmFudCBjYW7igJl0IGNvbnRhaW4gYSBjbG9zZXIgbm9kZS5cbiAgICBpZiAoIShub2RlID0gcS5ub2RlKVxuICAgICAgICB8fCAoeDEgPSBxLngwKSA+IHgzXG4gICAgICAgIHx8ICh5MSA9IHEueTApID4geTNcbiAgICAgICAgfHwgKHgyID0gcS54MSkgPCB4MFxuICAgICAgICB8fCAoeTIgPSBxLnkxKSA8IHkwKSBjb250aW51ZTtcblxuICAgIC8vIEJpc2VjdCB0aGUgY3VycmVudCBxdWFkcmFudC5cbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgeW0gPSAoeTEgKyB5MikgLyAyO1xuXG4gICAgICBxdWFkcy5wdXNoKFxuICAgICAgICBuZXcgUXVhZChub2RlWzNdLCB4bSwgeW0sIHgyLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMl0sIHgxLCB5bSwgeG0sIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsxXSwgeG0sIHkxLCB4MiwgeW0pLFxuICAgICAgICBuZXcgUXVhZChub2RlWzBdLCB4MSwgeTEsIHhtLCB5bSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFZpc2l0IHRoZSBjbG9zZXN0IHF1YWRyYW50IGZpcnN0LlxuICAgICAgaWYgKGkgPSAoeSA+PSB5bSkgPDwgMSB8ICh4ID49IHhtKSkge1xuICAgICAgICBxID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV0gPSBxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZpc2l0IHRoaXMgcG9pbnQuIChWaXNpdGluZyBjb2luY2lkZW50IHBvaW50cyBpc27igJl0IG5lY2Vzc2FyeSEpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZHggPSB4IC0gK3RoaXMuX3guY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGR5ID0geSAtICt0aGlzLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGQyIDwgcmFkaXVzKSB7XG4gICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHJhZGl1cyA9IGQyKTtcbiAgICAgICAgeDAgPSB4IC0gZCwgeTAgPSB5IC0gZDtcbiAgICAgICAgeDMgPSB4ICsgZCwgeTMgPSB5ICsgZDtcbiAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gdHJlZV9yZW1vdmUoZCkge1xuICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHJldGFpbmVyLFxuICAgICAgcHJldmlvdXMsXG4gICAgICBuZXh0LFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0aGlzO1xuXG4gIC8vIEZpbmQgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIHBvaW50LlxuICAvLyBXaGlsZSBkZXNjZW5kaW5nLCBhbHNvIHJldGFpbiB0aGUgZGVlcGVzdCBwYXJlbnQgd2l0aCBhIG5vbi1yZW1vdmVkIHNpYmxpbmcuXG4gIGlmIChub2RlLmxlbmd0aCkgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAoIShwYXJlbnQgPSBub2RlLCBub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBicmVhaztcbiAgICBpZiAocGFyZW50WyhpICsgMSkgJiAzXSB8fCBwYXJlbnRbKGkgKyAyKSAmIDNdIHx8IHBhcmVudFsoaSArIDMpICYgM10pIHJldGFpbmVyID0gcGFyZW50LCBqID0gaTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHBvaW50IHRvIHJlbW92ZS5cbiAgd2hpbGUgKG5vZGUuZGF0YSAhPT0gZCkgaWYgKCEocHJldmlvdXMgPSBub2RlLCBub2RlID0gbm9kZS5uZXh0KSkgcmV0dXJuIHRoaXM7XG4gIGlmIChuZXh0ID0gbm9kZS5uZXh0KSBkZWxldGUgbm9kZS5uZXh0O1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb2luY2lkZW50IHBvaW50cywgcmVtb3ZlIGp1c3QgdGhlIHBvaW50LlxuICBpZiAocHJldmlvdXMpIHJldHVybiAobmV4dCA/IHByZXZpb3VzLm5leHQgPSBuZXh0IDogZGVsZXRlIHByZXZpb3VzLm5leHQpLCB0aGlzO1xuXG4gIC8vIElmIHRoaXMgaXMgdGhlIHJvb3QgcG9pbnQsIHJlbW92ZSBpdC5cbiAgaWYgKCFwYXJlbnQpIHJldHVybiB0aGlzLl9yb290ID0gbmV4dCwgdGhpcztcblxuICAvLyBSZW1vdmUgdGhpcyBsZWFmLlxuICBuZXh0ID8gcGFyZW50W2ldID0gbmV4dCA6IGRlbGV0ZSBwYXJlbnRbaV07XG5cbiAgLy8gSWYgdGhlIHBhcmVudCBub3cgY29udGFpbnMgZXhhY3RseSBvbmUgbGVhZiwgY29sbGFwc2Ugc3VwZXJmbHVvdXMgcGFyZW50cy5cbiAgaWYgKChub2RlID0gcGFyZW50WzBdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzNdKVxuICAgICAgJiYgbm9kZSA9PT0gKHBhcmVudFszXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFswXSlcbiAgICAgICYmICFub2RlLmxlbmd0aCkge1xuICAgIGlmIChyZXRhaW5lcikgcmV0YWluZXJbal0gPSBub2RlO1xuICAgIGVsc2UgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQWxsKGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkgdGhpcy5yZW1vdmUoZGF0YVtpXSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0cmVlX3Jvb3QoKSB7XG4gIHJldHVybiB0aGlzLl9yb290O1xufVxuXG5mdW5jdGlvbiB0cmVlX3NpemUoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gKytzaXplOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiB0cmVlX3Zpc2l0KGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBxLCBub2RlID0gdGhpcy5fcm9vdCwgY2hpbGQsIHgwLCB5MCwgeDEsIHkxO1xuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgaWYgKCFjYWxsYmFjayhub2RlID0gcS5ub2RlLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEpICYmIG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdHJlZV92aXNpdEFmdGVyKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBuZXh0ID0gW10sIHE7XG4gIGlmICh0aGlzLl9yb290KSBxdWFkcy5wdXNoKG5ldyBRdWFkKHRoaXMuX3Jvb3QsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICB2YXIgbm9kZSA9IHEubm9kZTtcbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxLCB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgfVxuICAgIG5leHQucHVzaChxKTtcbiAgfVxuICB3aGlsZSAocSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjayhxLm5vZGUsIHEueDAsIHEueTAsIHEueDEsIHEueTEpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0WChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG5mdW5jdGlvbiB0cmVlX3goXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl94ID0gXywgdGhpcykgOiB0aGlzLl94O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0WShkKSB7XG4gIHJldHVybiBkWzFdO1xufVxuXG5mdW5jdGlvbiB0cmVlX3koXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl95ID0gXywgdGhpcykgOiB0aGlzLl95O1xufVxuXG5mdW5jdGlvbiBxdWFkdHJlZShub2RlcywgeCwgeSkge1xuICB2YXIgdHJlZSA9IG5ldyBRdWFkdHJlZSh4ID09IG51bGwgPyBkZWZhdWx0WCA6IHgsIHkgPT0gbnVsbCA/IGRlZmF1bHRZIDogeSwgTmFOLCBOYU4sIE5hTiwgTmFOKTtcbiAgcmV0dXJuIG5vZGVzID09IG51bGwgPyB0cmVlIDogdHJlZS5hZGRBbGwobm9kZXMpO1xufVxuXG5mdW5jdGlvbiBRdWFkdHJlZSh4LCB5LCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLl94ID0geDtcbiAgdGhpcy5feSA9IHk7XG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHRoaXMuX3Jvb3QgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGxlYWZfY29weShsZWFmKSB7XG4gIHZhciBjb3B5ID0ge2RhdGE6IGxlYWYuZGF0YX0sIG5leHQgPSBjb3B5O1xuICB3aGlsZSAobGVhZiA9IGxlYWYubmV4dCkgbmV4dCA9IG5leHQubmV4dCA9IHtkYXRhOiBsZWFmLmRhdGF9O1xuICByZXR1cm4gY29weTtcbn1cblxudmFyIHRyZWVQcm90byA9IHF1YWR0cmVlLnByb3RvdHlwZSA9IFF1YWR0cmVlLnByb3RvdHlwZTtcblxudHJlZVByb3RvLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvcHkgPSBuZXcgUXVhZHRyZWUodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBub2RlcyxcbiAgICAgIGNoaWxkO1xuXG4gIGlmICghbm9kZSkgcmV0dXJuIGNvcHk7XG5cbiAgaWYgKCFub2RlLmxlbmd0aCkgcmV0dXJuIGNvcHkuX3Jvb3QgPSBsZWFmX2NvcHkobm9kZSksIGNvcHk7XG5cbiAgbm9kZXMgPSBbe3NvdXJjZTogbm9kZSwgdGFyZ2V0OiBjb3B5Ll9yb290ID0gbmV3IEFycmF5KDQpfV07XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKGNoaWxkID0gbm9kZS5zb3VyY2VbaV0pIHtcbiAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCkgbm9kZXMucHVzaCh7c291cmNlOiBjaGlsZCwgdGFyZ2V0OiBub2RlLnRhcmdldFtpXSA9IG5ldyBBcnJheSg0KX0pO1xuICAgICAgICBlbHNlIG5vZGUudGFyZ2V0W2ldID0gbGVhZl9jb3B5KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn07XG5cbnRyZWVQcm90by5hZGQgPSB0cmVlX2FkZDtcbnRyZWVQcm90by5hZGRBbGwgPSBhZGRBbGw7XG50cmVlUHJvdG8uY292ZXIgPSB0cmVlX2NvdmVyO1xudHJlZVByb3RvLmRhdGEgPSB0cmVlX2RhdGE7XG50cmVlUHJvdG8uZXh0ZW50ID0gdHJlZV9leHRlbnQ7XG50cmVlUHJvdG8uZmluZCA9IHRyZWVfZmluZDtcbnRyZWVQcm90by5yZW1vdmUgPSB0cmVlX3JlbW92ZTtcbnRyZWVQcm90by5yZW1vdmVBbGwgPSByZW1vdmVBbGw7XG50cmVlUHJvdG8ucm9vdCA9IHRyZWVfcm9vdDtcbnRyZWVQcm90by5zaXplID0gdHJlZV9zaXplO1xudHJlZVByb3RvLnZpc2l0ID0gdHJlZV92aXNpdDtcbnRyZWVQcm90by52aXNpdEFmdGVyID0gdHJlZV92aXNpdEFmdGVyO1xudHJlZVByb3RvLnggPSB0cmVlX3g7XG50cmVlUHJvdG8ueSA9IHRyZWVfeTtcblxuZXhwb3J0cy5xdWFkdHJlZSA9IHF1YWR0cmVlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvKipcbiAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmRhdCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfX18kaW5zZXJ0U3R5bGUoY3NzKSB7XG4gIGlmICghY3NzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gIHN0eWxlLmlubmVySFRNTCA9IGNzcztcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cbiAgcmV0dXJuIGNzcztcbn1cblxuZnVuY3Rpb24gY29sb3JUb1N0cmluZyAoY29sb3IsIGZvcmNlQ1NTSGV4KSB7XG4gIHZhciBjb2xvckZvcm1hdCA9IGNvbG9yLl9fc3RhdGUuY29udmVyc2lvbk5hbWUudG9TdHJpbmcoKTtcbiAgdmFyIHIgPSBNYXRoLnJvdW5kKGNvbG9yLnIpO1xuICB2YXIgZyA9IE1hdGgucm91bmQoY29sb3IuZyk7XG4gIHZhciBiID0gTWF0aC5yb3VuZChjb2xvci5iKTtcbiAgdmFyIGEgPSBjb2xvci5hO1xuICB2YXIgaCA9IE1hdGgucm91bmQoY29sb3IuaCk7XG4gIHZhciBzID0gY29sb3Iucy50b0ZpeGVkKDEpO1xuICB2YXIgdiA9IGNvbG9yLnYudG9GaXhlZCgxKTtcbiAgaWYgKGZvcmNlQ1NTSGV4IHx8IGNvbG9yRm9ybWF0ID09PSAnVEhSRUVfQ0hBUl9IRVgnIHx8IGNvbG9yRm9ybWF0ID09PSAnU0lYX0NIQVJfSEVYJykge1xuICAgIHZhciBzdHIgPSBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgNikge1xuICAgICAgc3RyID0gJzAnICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gJyMnICsgc3RyO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnQ1NTX1JHQicpIHtcbiAgICByZXR1cm4gJ3JnYignICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJyknO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnQ1NTX1JHQkEnKSB7XG4gICAgcmV0dXJuICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnSEVYJykge1xuICAgIHJldHVybiAnMHgnICsgY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQl9BUlJBWScpIHtcbiAgICByZXR1cm4gJ1snICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJ10nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCQV9BUlJBWScpIHtcbiAgICByZXR1cm4gJ1snICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICddJztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQl9PQkonKSB7XG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQkFfT0JKJykge1xuICAgIHJldHVybiAne3I6JyArIHIgKyAnLGc6JyArIGcgKyAnLGI6JyArIGIgKyAnLGE6JyArIGEgKyAnfSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIU1ZfT0JKJykge1xuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnfSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIU1ZBX09CSicpIHtcbiAgICByZXR1cm4gJ3toOicgKyBoICsgJyxzOicgKyBzICsgJyx2OicgKyB2ICsgJyxhOicgKyBhICsgJ30nO1xuICB9XG4gIHJldHVybiAndW5rbm93biBmb3JtYXQnO1xufVxuXG52YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbnZhciBBUlJfU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgQ29tbW9uID0ge1xuICBCUkVBSzoge30sXG4gIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1xuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG4gIGRlZmF1bHRzOiBmdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQpIHtcbiAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIGtleXMgPSB0aGlzLmlzT2JqZWN0KG9iaikgPyBPYmplY3Qua2V5cyhvYmopIDogW107XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG4gIGNvbXBvc2U6IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJncyA9IFt0b0NhbGxbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfSxcbiAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGl0ciwgc2NvcGUpIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQVJSX0VBQ0ggJiYgb2JqLmZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IEFSUl9FQUNIKSB7XG4gICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7XG4gICAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgICAgdmFyIGwgPSB2b2lkIDA7XG4gICAgICBmb3IgKGtleSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKykge1xuICAgICAgICBpZiAoa2V5IGluIG9iaiAmJiBpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpbX2tleV0sIF9rZXkpID09PSB0aGlzLkJSRUFLKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWZlcjogZnVuY3Rpb24gZGVmZXIoZm5jKSB7XG4gICAgc2V0VGltZW91dChmbmMsIDApO1xuICB9LFxuICBkZWJvdW5jZTogZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgdGhyZXNob2xkLCBjYWxsSW1tZWRpYXRlbHkpIHtcbiAgICB2YXIgdGltZW91dCA9IHZvaWQgMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWNhbGxJbW1lZGlhdGVseSkgZnVuYy5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfVxuICAgICAgdmFyIGNhbGxOb3cgPSBjYWxsSW1tZWRpYXRlbHkgfHwgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChkZWxheWVkLCB0aHJlc2hvbGQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgZnVuYy5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgaWYgKG9iai50b0FycmF5KSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgfSxcbiAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbiBpc051bGwob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOYU46IGZ1bmN0aW9uIChfaXNOYU4pIHtcbiAgICBmdW5jdGlvbiBpc05hTihfeCkge1xuICAgICAgcmV0dXJuIF9pc05hTi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpc05hTi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaXNOYU4udG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBpc05hTjtcbiAgfShmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIGlzTmFOKG9iaik7XG4gIH0pLFxuICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICB9LFxuICBpc051bWJlcjogZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgMDtcbiAgfSxcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG9iaiArICcnO1xuICB9LFxuICBpc0Jvb2xlYW46IGZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBmYWxzZSB8fCBvYmogPT09IHRydWU7XG4gIH0sXG4gIGlzRnVuY3Rpb246IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9XG59O1xuXG52YXIgSU5URVJQUkVUQVRJT05TID0gW1xue1xuICBsaXRtdXM6IENvbW1vbi5pc1N0cmluZyxcbiAgY29udmVyc2lvbnM6IHtcbiAgICBUSFJFRV9DSEFSX0hFWDoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XSkoW0EtRjAtOV0pKFtBLUYwLTldKSQvaSk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSwgMClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH0sXG4gICAgU0lYX0NIQVJfSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSwgMClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH0sXG4gICAgQ1NTX1JHQjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH0sXG4gICAgQ1NTX1JHQkE6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSksXG4gICAgICAgICAgYTogcGFyc2VGbG9hdCh0ZXN0WzRdKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc051bWJlcixcbiAgY29udmVyc2lvbnM6IHtcbiAgICBIRVg6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBvcmlnaW5hbCxcbiAgICAgICAgICBjb252ZXJzaW9uTmFtZTogJ0hFWCdcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yLmhleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzQXJyYXksXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgUkdCX0FSUkFZOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgYjogb3JpZ2luYWxbMl1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFJHQkFfQVJSQVk6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPT0gNCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICBiOiBvcmlnaW5hbFsyXSxcbiAgICAgICAgICBhOiBvcmlnaW5hbFszXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNPYmplY3QsXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgUkdCQV9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgIGI6IG9yaWdpbmFsLmIsXG4gICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgUkdCX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICBiOiBvcmlnaW5hbC5iXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgIGI6IGNvbG9yLmJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEhTVkFfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICB2OiBjb2xvci52LFxuICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEhTVl9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgdjogb3JpZ2luYWwudlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICB2OiBjb2xvci52XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XTtcbnZhciByZXN1bHQgPSB2b2lkIDA7XG52YXIgdG9SZXR1cm4gPSB2b2lkIDA7XG52YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24gaW50ZXJwcmV0KCkge1xuICB0b1JldHVybiA9IGZhbHNlO1xuICB2YXIgb3JpZ2luYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IENvbW1vbi50b0FycmF5KGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF07XG4gIENvbW1vbi5lYWNoKElOVEVSUFJFVEFUSU9OUywgZnVuY3Rpb24gKGZhbWlseSkge1xuICAgIGlmIChmYW1pbHkubGl0bXVzKG9yaWdpbmFsKSkge1xuICAgICAgQ29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbiAoY29udmVyc2lvbiwgY29udmVyc2lvbk5hbWUpIHtcbiAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcbiAgICAgICAgaWYgKHRvUmV0dXJuID09PSBmYWxzZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb25OYW1lID0gY29udmVyc2lvbk5hbWU7XG4gICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb24gPSBjb252ZXJzaW9uO1xuICAgICAgICAgIHJldHVybiBDb21tb24uQlJFQUs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbW1vbi5CUkVBSztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59O1xuXG52YXIgdG1wQ29tcG9uZW50ID0gdm9pZCAwO1xudmFyIENvbG9yTWF0aCA9IHtcbiAgaHN2X3RvX3JnYjogZnVuY3Rpb24gaHN2X3RvX3JnYihoLCBzLCB2KSB7XG4gICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcbiAgICB2YXIgZiA9IGggLyA2MCAtIE1hdGguZmxvb3IoaCAvIDYwKTtcbiAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG4gICAgdmFyIHEgPSB2ICogKDEuMCAtIGYgKiBzKTtcbiAgICB2YXIgdCA9IHYgKiAoMS4wIC0gKDEuMCAtIGYpICogcyk7XG4gICAgdmFyIGMgPSBbW3YsIHQsIHBdLCBbcSwgdiwgcF0sIFtwLCB2LCB0XSwgW3AsIHEsIHZdLCBbdCwgcCwgdl0sIFt2LCBwLCBxXV1baGldO1xuICAgIHJldHVybiB7XG4gICAgICByOiBjWzBdICogMjU1LFxuICAgICAgZzogY1sxXSAqIDI1NSxcbiAgICAgIGI6IGNbMl0gKiAyNTVcbiAgICB9O1xuICB9LFxuICByZ2JfdG9faHN2OiBmdW5jdGlvbiByZ2JfdG9faHN2KHIsIGcsIGIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgICB2YXIgaCA9IHZvaWQgMDtcbiAgICB2YXIgcyA9IHZvaWQgMDtcbiAgICBpZiAobWF4ICE9PSAwKSB7XG4gICAgICBzID0gZGVsdGEgLyBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGg6IE5hTixcbiAgICAgICAgczogMCxcbiAgICAgICAgdjogMFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHIgPT09IG1heCkge1xuICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICB9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgIH1cbiAgICBoIC89IDY7XG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBoOiBoICogMzYwLFxuICAgICAgczogcyxcbiAgICAgIHY6IG1heCAvIDI1NVxuICAgIH07XG4gIH0sXG4gIHJnYl90b19oZXg6IGZ1bmN0aW9uIHJnYl90b19oZXgociwgZywgYikge1xuICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcbiAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDEsIGcpO1xuICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMCwgYik7XG4gICAgcmV0dXJuIGhleDtcbiAgfSxcbiAgY29tcG9uZW50X2Zyb21faGV4OiBmdW5jdGlvbiBjb21wb25lbnRfZnJvbV9oZXgoaGV4LCBjb21wb25lbnRJbmRleCkge1xuICAgIHJldHVybiBoZXggPj4gY29tcG9uZW50SW5kZXggKiA4ICYgMHhGRjtcbiAgfSxcbiAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbiBoZXhfd2l0aF9jb21wb25lbnQoaGV4LCBjb21wb25lbnRJbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPDwgKHRtcENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ICogOCkgfCBoZXggJiB+KDB4RkYgPDwgdG1wQ29tcG9uZW50KTtcbiAgfVxufTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxudmFyIGdldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gIH1cbn07XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29sb3IoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3IpO1xuICAgIHRoaXMuX19zdGF0ZSA9IGludGVycHJldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbnRlcnByZXQgY29sb3IgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIHRoaXMuX19zdGF0ZS5hID0gdGhpcy5fX3N0YXRlLmEgfHwgMTtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb2xvciwgW3tcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGNvbG9yVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9IZXhTdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleFN0cmluZygpIHtcbiAgICAgIHJldHVybiBjb2xvclRvU3RyaW5nKHRoaXMsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvT3JpZ2luYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09yaWdpbmFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5jb252ZXJzaW9uLndyaXRlKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3I7XG59KCk7XG5mdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ1JHQicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgfVxuICAgICAgQ29sb3IucmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnUkdCJykge1xuICAgICAgICBDb2xvci5yZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ1JHQic7XG4gICAgICB9XG4gICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGRlZmluZUhTVkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgIH1cbiAgICAgIENvbG9yLnJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hTVicpIHtcbiAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIU1YnO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuICAgIH1cbiAgfSk7XG59XG5Db2xvci5yZWNhbGN1bGF0ZVJHQiA9IGZ1bmN0aW9uIChjb2xvciwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcbiAgICBjb2xvci5fX3N0YXRlW2NvbXBvbmVudF0gPSBDb2xvck1hdGguY29tcG9uZW50X2Zyb21faGV4KGNvbG9yLl9fc3RhdGUuaGV4LCBjb21wb25lbnRIZXhJbmRleCk7XG4gIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcbiAgICBDb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIENvbG9yTWF0aC5oc3ZfdG9fcmdiKGNvbG9yLl9fc3RhdGUuaCwgY29sb3IuX19zdGF0ZS5zLCBjb2xvci5fX3N0YXRlLnYpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZScpO1xuICB9XG59O1xuQ29sb3IucmVjYWxjdWxhdGVIU1YgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgdmFyIHJlc3VsdCA9IENvbG9yTWF0aC5yZ2JfdG9faHN2KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICBDb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIHtcbiAgICBzOiByZXN1bHQucyxcbiAgICB2OiByZXN1bHQudlxuICB9KTtcbiAgaWYgKCFDb21tb24uaXNOYU4ocmVzdWx0LmgpKSB7XG4gICAgY29sb3IuX19zdGF0ZS5oID0gcmVzdWx0Lmg7XG4gIH0gZWxzZSBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcbiAgICBjb2xvci5fX3N0YXRlLmggPSAwO1xuICB9XG59O1xuQ29sb3IuQ09NUE9ORU5UUyA9IFsncicsICdnJywgJ2InLCAnaCcsICdzJywgJ3YnLCAnaGV4JywgJ2EnXTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdyJywgMik7XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2InLCAwKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdoJyk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncycpO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3YnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdhJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmE7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICB0aGlzLl9fc3RhdGUuYSA9IHY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2hleCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgaWYgKCF0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gQ29sb3JNYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgdGhpcy5fX3N0YXRlLmhleCA9IHY7XG4gIH1cbn0pO1xuXG52YXIgQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udHJvbGxlcik7XG4gICAgdGhpcy5pbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB0aGlzLl9fb25DaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gdW5kZWZpbmVkO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnb25DaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZShmbmMpIHtcbiAgICAgIHRoaXMuX19vbkNoYW5nZSA9IGZuYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRmluaXNoQ2hhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GaW5pc2hDaGFuZ2UoZm5jKSB7XG4gICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSBmbmM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzLCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc01vZGlmaWVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNNb2RpZmllZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29udHJvbGxlcjtcbn0oKTtcblxudmFyIEVWRU5UX01BUCA9IHtcbiAgSFRNTEV2ZW50czogWydjaGFuZ2UnXSxcbiAgTW91c2VFdmVudHM6IFsnY2xpY2snLCAnbW91c2Vtb3ZlJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlb3ZlciddLFxuICBLZXlib2FyZEV2ZW50czogWydrZXlkb3duJ11cbn07XG52YXIgRVZFTlRfTUFQX0lOViA9IHt9O1xuQ29tbW9uLmVhY2goRVZFTlRfTUFQLCBmdW5jdGlvbiAodiwgaykge1xuICBDb21tb24uZWFjaCh2LCBmdW5jdGlvbiAoZSkge1xuICAgIEVWRU5UX01BUF9JTlZbZV0gPSBrO1xuICB9KTtcbn0pO1xudmFyIENTU19WQUxVRV9QSVhFTFMgPSAvKFxcZCsoXFwuXFxkKyk/KXB4LztcbmZ1bmN0aW9uIGNzc1ZhbHVlVG9QaXhlbHModmFsKSB7XG4gIGlmICh2YWwgPT09ICcwJyB8fCBDb21tb24uaXNVbmRlZmluZWQodmFsKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBtYXRjaCA9IHZhbC5tYXRjaChDU1NfVkFMVUVfUElYRUxTKTtcbiAgaWYgKCFDb21tb24uaXNOdWxsKG1hdGNoKSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBkb20gPSB7XG4gIG1ha2VTZWxlY3RhYmxlOiBmdW5jdGlvbiBtYWtlU2VsZWN0YWJsZShlbGVtLCBzZWxlY3RhYmxlKSB7XG4gICAgaWYgKGVsZW0gPT09IHVuZGVmaW5lZCB8fCBlbGVtLnN0eWxlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBlbGVtLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICBlbGVtLnN0eWxlLk1velVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIGVsZW0uc3R5bGUuS2h0bWxVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICBlbGVtLnVuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGUgPyAnb24nIDogJ29mZic7XG4gIH0sXG4gIG1ha2VGdWxsc2NyZWVuOiBmdW5jdGlvbiBtYWtlRnVsbHNjcmVlbihlbGVtLCBob3IsIHZlcnQpIHtcbiAgICB2YXIgdmVydGljYWwgPSB2ZXJ0O1xuICAgIHZhciBob3Jpem9udGFsID0gaG9yO1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoaG9yaXpvbnRhbCkpIHtcbiAgICAgIGhvcml6b250YWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHZlcnRpY2FsKSkge1xuICAgICAgdmVydGljYWwgPSB0cnVlO1xuICAgIH1cbiAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSAwO1xuICAgIH1cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGVsZW0uc3R5bGUudG9wID0gMDtcbiAgICAgIGVsZW0uc3R5bGUuYm90dG9tID0gMDtcbiAgICB9XG4gIH0sXG4gIGZha2VFdmVudDogZnVuY3Rpb24gZmFrZUV2ZW50KGVsZW0sIGV2ZW50VHlwZSwgcGFycywgYXV4KSB7XG4gICAgdmFyIHBhcmFtcyA9IHBhcnMgfHwge307XG4gICAgdmFyIGNsYXNzTmFtZSA9IEVWRU5UX01BUF9JTlZbZXZlbnRUeXBlXTtcbiAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0eXBlICcgKyBldmVudFR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChjbGFzc05hbWUpO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICBjYXNlICdNb3VzZUV2ZW50cyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY2xpZW50WCA9IHBhcmFtcy54IHx8IHBhcmFtcy5jbGllbnRYIHx8IDA7XG4gICAgICAgICAgdmFyIGNsaWVudFkgPSBwYXJhbXMueSB8fCBwYXJhbXMuY2xpZW50WSB8fCAwO1xuICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlLCB3aW5kb3csIHBhcmFtcy5jbGlja0NvdW50IHx8IDEsIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBjbGllbnRYLFxuICAgICAgICAgIGNsaWVudFksXG4gICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdLZXlib2FyZEV2ZW50cyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGV2dC5pbml0S2V5Ym9hcmRFdmVudCB8fCBldnQuaW5pdEtleUV2ZW50O1xuICAgICAgICAgIENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGtleUNvZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYXJDb2RlOiB1bmRlZmluZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbml0KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlLCB3aW5kb3csIHBhcmFtcy5jdHJsS2V5LCBwYXJhbXMuYWx0S2V5LCBwYXJhbXMuc2hpZnRLZXksIHBhcmFtcy5tZXRhS2V5LCBwYXJhbXMua2V5Q29kZSwgcGFyYW1zLmNoYXJDb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29tbW9uLmRlZmF1bHRzKGV2dCwgYXV4KTtcbiAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfSxcbiAgYmluZDogZnVuY3Rpb24gYmluZChlbGVtLCBldmVudCwgZnVuYywgbmV3Qm9vbCkge1xuICAgIHZhciBib29sID0gbmV3Qm9vbCB8fCBmYWxzZTtcbiAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkge1xuICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChlbGVtLCBldmVudCwgZnVuYywgbmV3Qm9vbCkge1xuICAgIHZhciBib29sID0gbmV3Qm9vbCB8fCBmYWxzZTtcbiAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudCkge1xuICAgICAgZWxlbS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGNsYXNzTmFtZSkge1xuICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IGNsYXNzTmFtZSkge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5jbGFzc05hbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnxcXFxccyspJyArIGNsYXNzTmFtZSArICcoPzpcXFxccyt8JCknKS50ZXN0KGVsZW0uY2xhc3NOYW1lKSB8fCBmYWxzZTtcbiAgfSxcbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uIGdldFdpZHRoKGVsZW0pIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItbGVmdC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1yaWdodC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctbGVmdCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlLndpZHRoKTtcbiAgfSxcbiAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiBnZXRIZWlnaHQoZWxlbSkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci10b3Atd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItYm90dG9tLXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy10b3AnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWJvdHRvbSddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUuaGVpZ2h0KTtcbiAgfSxcbiAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiBnZXRPZmZzZXQoZWwpIHtcbiAgICB2YXIgZWxlbSA9IGVsO1xuICAgIHZhciBvZmZzZXQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgIGlmIChlbGVtLm9mZnNldFBhcmVudCkge1xuICAgICAgZG8ge1xuICAgICAgICBvZmZzZXQubGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG4gICAgICAgIG9mZnNldC50b3AgKz0gZWxlbS5vZmZzZXRUb3A7XG4gICAgICAgIGVsZW0gPSBlbGVtLm9mZnNldFBhcmVudDtcbiAgICAgIH0gd2hpbGUgKGVsZW0pO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9LFxuICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoZWxlbSkge1xuICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIChlbGVtLnR5cGUgfHwgZWxlbS5ocmVmKTtcbiAgfVxufTtcblxudmFyIEJvb2xlYW5Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKEJvb2xlYW5Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIEJvb2xlYW5Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCb29sZWFuQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJvb2xlYW5Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fcHJldiA9IF90aGlzMi5nZXRWYWx1ZSgpO1xuICAgIF90aGlzMi5fX2NoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKCFfdGhpcy5fX3ByZXYpO1xuICAgIH1cbiAgICBkb20uYmluZChfdGhpczIuX19jaGVja2JveCwgJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fY2hlY2tib3gpO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhCb29sZWFuQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHYpIHtcbiAgICAgIHZhciB0b1JldHVybiA9IGdldChCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIHYpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAodGhpcy5nZXRWYWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX19wcmV2ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19wcmV2ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJvb2xlYW5Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIE9wdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoT3B0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIG9wdHMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb25Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoT3B0aW9uQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHM7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgIGlmIChDb21tb24uaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgQ29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgbWFwW2VsZW1lbnRdID0gZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgb3B0aW9ucyA9IG1hcDtcbiAgICB9XG4gICAgQ29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBrZXk7XG4gICAgICBvcHQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgICAgIF90aGlzLl9fc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG4gICAgfSk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVzaXJlZFZhbHVlID0gdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShkZXNpcmVkVmFsdWUpO1xuICAgIH0pO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhPcHRpb25Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIHRvUmV0dXJuID0gZ2V0KE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIHYpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgaWYgKGRvbS5pc0FjdGl2ZSh0aGlzLl9fc2VsZWN0KSkgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLl9fc2VsZWN0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgcmV0dXJuIGdldChPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT3B0aW9uQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbnZhciBTdHJpbmdDb250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKFN0cmluZ0NvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaW5nQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN0cmluZ0NvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5dXAnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhTdHJpbmdDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgaWYgKCFkb20uaXNBY3RpdmUodGhpcy5fX2lucHV0KSkge1xuICAgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KFN0cmluZ0NvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdHJpbmdDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gbnVtRGVjaW1hbHMoeCkge1xuICB2YXIgX3ggPSB4LnRvU3RyaW5nKCk7XG4gIGlmIChfeC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgIHJldHVybiBfeC5sZW5ndGggLSBfeC5pbmRleE9mKCcuJykgLSAxO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIE51bWJlckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF9wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgX3RoaXMuX19taW4gPSBfcGFyYW1zLm1pbjtcbiAgICBfdGhpcy5fX21heCA9IF9wYXJhbXMubWF4O1xuICAgIF90aGlzLl9fc3RlcCA9IF9wYXJhbXMuc3RlcDtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKF90aGlzLl9fc3RlcCkpIHtcbiAgICAgIGlmIChfdGhpcy5pbml0aWFsVmFsdWUgPT09IDApIHtcbiAgICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnMoX3RoaXMuaW5pdGlhbFZhbHVlKSkgLyBNYXRoLkxOMTApKSAvIDEwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gX3RoaXMuX19zdGVwO1xuICAgIH1cbiAgICBfdGhpcy5fX3ByZWNpc2lvbiA9IG51bURlY2ltYWxzKF90aGlzLl9faW1wbGllZFN0ZXApO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIF92ID0gdjtcbiAgICAgIGlmICh0aGlzLl9fbWluICE9PSB1bmRlZmluZWQgJiYgX3YgPCB0aGlzLl9fbWluKSB7XG4gICAgICAgIF92ID0gdGhpcy5fX21pbjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX21heCAhPT0gdW5kZWZpbmVkICYmIF92ID4gdGhpcy5fX21heCkge1xuICAgICAgICBfdiA9IHRoaXMuX19tYXg7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX3N0ZXAgIT09IHVuZGVmaW5lZCAmJiBfdiAlIHRoaXMuX19zdGVwICE9PSAwKSB7XG4gICAgICAgIF92ID0gTWF0aC5yb3VuZChfdiAvIHRoaXMuX19zdGVwKSAqIHRoaXMuX19zdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldChOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3NldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBfdik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWluJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluKG1pblZhbHVlKSB7XG4gICAgICB0aGlzLl9fbWluID0gbWluVmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgobWF4VmFsdWUpIHtcbiAgICAgIHRoaXMuX19tYXggPSBtYXhWYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0ZXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGVwKHN0ZXBWYWx1ZSkge1xuICAgICAgdGhpcy5fX3N0ZXAgPSBzdGVwVmFsdWU7XG4gICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSBzdGVwVmFsdWU7XG4gICAgICB0aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHMoc3RlcFZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbmZ1bmN0aW9uIHJvdW5kVG9EZWNpbWFsKHZhbHVlLCBkZWNpbWFscykge1xuICB2YXIgdGVuVG8gPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHRlblRvKSAvIHRlblRvO1xufVxudmFyIE51bWJlckNvbnRyb2xsZXJCb3ggPSBmdW5jdGlvbiAoX051bWJlckNvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlckJveCwgX051bWJlckNvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbnRyb2xsZXJCb3gpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOdW1iZXJDb250cm9sbGVyQm94Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlckJveCkpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSk7XG4gICAgX3RoaXMyLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICB2YXIgcHJldlkgPSB2b2lkIDA7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICB2YXIgYXR0ZW1wdGVkID0gcGFyc2VGbG9hdChfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICAgIGlmICghQ29tbW9uLmlzTmFOKGF0dGVtcHRlZCkpIHtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoYXR0ZW1wdGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG4gICAgICB2YXIgZGlmZiA9IHByZXZZIC0gZS5jbGllbnRZO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuZ2V0VmFsdWUoKSArIGRpZmYgKiBfdGhpcy5fX2ltcGxpZWRTdGVwKTtcbiAgICAgIHByZXZZID0gZS5jbGllbnRZO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIHByZXZZID0gZS5jbGllbnRZO1xuICAgIH1cbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgICAgIG9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyQm94LCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPyB0aGlzLmdldFZhbHVlKCkgOiByb3VuZFRvRGVjaW1hbCh0aGlzLmdldFZhbHVlKCksIHRoaXMuX19wcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIGdldChOdW1iZXJDb250cm9sbGVyQm94LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveDtcbn0oTnVtYmVyQ29udHJvbGxlcik7XG5cbmZ1bmN0aW9uIG1hcCh2LCBpMSwgaTIsIG8xLCBvMikge1xuICByZXR1cm4gbzEgKyAobzIgLSBvMSkgKiAoKHYgLSBpMSkgLyAoaTIgLSBpMSkpO1xufVxudmFyIE51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBmdW5jdGlvbiAoX051bWJlckNvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlclNsaWRlciwgX051bWJlckNvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIG1pbiwgbWF4LCBzdGVwKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlclNsaWRlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXJTbGlkZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyU2xpZGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogc3RlcCB9KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX2JhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19mb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19iYWNrZ3JvdW5kLCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2JhY2tncm91bmQsICdzbGlkZXInKTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fZm9yZWdyb3VuZCwgJ3NsaWRlci1mZycpO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBvbk1vdXNlRHJhZyhlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGJnUmVjdCA9IF90aGlzLl9fYmFja2dyb3VuZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIF90aGlzLnNldFZhbHVlKG1hcChlLmNsaWVudFgsIGJnUmVjdC5sZWZ0LCBiZ1JlY3QucmlnaHQsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcbiAgICAgIG9uVG91Y2hNb3ZlKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGUudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgdmFyIGJnUmVjdCA9IF90aGlzLl9fYmFja2dyb3VuZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIF90aGlzLnNldFZhbHVlKG1hcChjbGllbnRYLCBiZ1JlY3QubGVmdCwgYmdSZWN0LnJpZ2h0LCBfdGhpcy5fX21pbiwgX3RoaXMuX19tYXgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBfdGhpczIuX19iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKF90aGlzMi5fX2ZvcmVncm91bmQpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2JhY2tncm91bmQpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoTnVtYmVyQ29udHJvbGxlclNsaWRlciwgW3tcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHZhciBwY3QgPSAodGhpcy5nZXRWYWx1ZSgpIC0gdGhpcy5fX21pbikgLyAodGhpcy5fX21heCAtIHRoaXMuX19taW4pO1xuICAgICAgdGhpcy5fX2ZvcmVncm91bmQuc3R5bGUud2lkdGggPSBwY3QgKiAxMDAgKyAnJSc7XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXJTbGlkZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyU2xpZGVyO1xufShOdW1iZXJDb250cm9sbGVyKTtcblxudmFyIEZ1bmN0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhGdW5jdGlvbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIHRleHQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBGdW5jdGlvbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGdW5jdGlvbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGdW5jdGlvbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fYnV0dG9uLmlubmVySFRNTCA9IHRleHQgPT09IHVuZGVmaW5lZCA/ICdGaXJlJyA6IHRleHQ7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgX3RoaXMuZmlyZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19idXR0b24sICdidXR0b24nKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19idXR0b24pO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoRnVuY3Rpb25Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ2ZpcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlKCkge1xuICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0VmFsdWUoKS5jYWxsKHRoaXMub2JqZWN0KTtcbiAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZ1bmN0aW9uQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbnZhciBDb2xvckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoQ29sb3JDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29sb3JDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29sb3JDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgX3RoaXMyLl9fY29sb3IgPSBuZXcgQ29sb3IoX3RoaXMyLmdldFZhbHVlKCkpO1xuICAgIF90aGlzMi5fX3RlbXAgPSBuZXcgQ29sb3IoMCk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLm1ha2VTZWxlY3RhYmxlKF90aGlzMi5kb21FbGVtZW50LCBmYWxzZSk7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5jbGFzc05hbWUgPSAnc2VsZWN0b3InO1xuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLmNsYXNzTmFtZSA9ICdzYXR1cmF0aW9uLWZpZWxkJztcbiAgICBfdGhpczIuX19maWVsZF9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fZmllbGRfa25vYi5jbGFzc05hbWUgPSAnZmllbGQta25vYic7XG4gICAgX3RoaXMyLl9fZmllbGRfa25vYl9ib3JkZXIgPSAnMnB4IHNvbGlkICc7XG4gICAgX3RoaXMyLl9faHVlX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19odWVfa25vYi5jbGFzc05hbWUgPSAnaHVlLWtub2InO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5jbGFzc05hbWUgPSAnaHVlLWZpZWxkJztcbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9faW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ID0gJzAgMXB4IDFweCAnO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBvbkJsdXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdG9yLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCkgICAgICAgIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLCAnZHJhZycpLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uICgpICAgICAgICB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkgICAgICAgIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLCAnZHJhZycpLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmdW5jdGlvbiAoKSAgICAgICAge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX19zZWxlY3RvciwgJ2RyYWcnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciB2YWx1ZUZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19zZWxlY3Rvci5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMjJweCcsXG4gICAgICBoZWlnaHQ6ICcxMDJweCcsXG4gICAgICBwYWRkaW5nOiAnM3B4JyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyMyMjInLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjMpJ1xuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzEycHgnLFxuICAgICAgaGVpZ2h0OiAnMTJweCcsXG4gICAgICBib3JkZXI6IF90aGlzMi5fX2ZpZWxkX2tub2JfYm9yZGVyICsgKF90aGlzMi5fX2NvbG9yLnYgPCAwLjUgPyAnI2ZmZicgOiAnIzAwMCcpLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19odWVfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMnB4JyxcbiAgICAgIGJvcmRlclJpZ2h0OiAnNHB4IHNvbGlkICNmZmYnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMHB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnM3B4JyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKHZhbHVlRmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGJhY2tncm91bmQ6ICdub25lJ1xuICAgIH0pO1xuICAgIGxpbmVhckdyYWRpZW50KHZhbHVlRmllbGQsICd0b3AnLCAncmdiYSgwLDAsMCwwKScsICcjMDAwJyk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19odWVfZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBjdXJzb3I6ICducy1yZXNpemUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6ICczcHgnLFxuICAgICAgcmlnaHQ6ICczcHgnXG4gICAgfSk7XG4gICAgaHVlR3JhZGllbnQoX3RoaXMyLl9faHVlX2ZpZWxkKTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2lucHV0LnN0eWxlLCB7XG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIGJvcmRlcjogMCxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIHRleHRTaGFkb3c6IF90aGlzMi5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgwLDAsMCwwLjcpJ1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQsICd0b3VjaHN0YXJ0JywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19maWVsZF9rbm9iLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19maWVsZF9rbm9iLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faHVlX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duSCk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faHVlX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bkgpO1xuICAgIGZ1bmN0aW9uIGZpZWxkRG93bihlKSB7XG4gICAgICBzZXRTVihlKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwU1YpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwU1YpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaWVsZERvd25IKGUpIHtcbiAgICAgIHNldEgoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldEgpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcEgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaWVsZFVwU1YoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwU1YpO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGRVcEgoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwSCk7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuICAgICAgICBfdGhpcy5fX2NvbG9yLl9fc3RhdGUgPSBpO1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gX3RoaXMuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkZpbmlzaCgpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLmFwcGVuZENoaWxkKHZhbHVlRmllbGQpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKF90aGlzMi5fX2ZpZWxkX2tub2IpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKF90aGlzMi5fX2h1ZV9maWVsZCk7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkLmFwcGVuZENoaWxkKF90aGlzMi5fX2h1ZV9rbm9iKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2VsZWN0b3IpO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgZnVuY3Rpb24gc2V0U1YoZSkge1xuICAgICAgaWYgKGUudHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAtMSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICB2YXIgZmllbGRSZWN0ID0gX3RoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIF9yZWYgPSBlLnRvdWNoZXMgJiYgZS50b3VjaGVzWzBdIHx8IGUsXG4gICAgICAgICAgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZi5jbGllbnRZO1xuICAgICAgdmFyIHMgPSAoY2xpZW50WCAtIGZpZWxkUmVjdC5sZWZ0KSAvIChmaWVsZFJlY3QucmlnaHQgLSBmaWVsZFJlY3QubGVmdCk7XG4gICAgICB2YXIgdiA9IDEgLSAoY2xpZW50WSAtIGZpZWxkUmVjdC50b3ApIC8gKGZpZWxkUmVjdC5ib3R0b20gLSBmaWVsZFJlY3QudG9wKTtcbiAgICAgIGlmICh2ID4gMSkge1xuICAgICAgICB2ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAodiA8IDApIHtcbiAgICAgICAgdiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocyA+IDEpIHtcbiAgICAgICAgcyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMgPCAwKSB7XG4gICAgICAgIHMgPSAwO1xuICAgICAgfVxuICAgICAgX3RoaXMuX19jb2xvci52ID0gdjtcbiAgICAgIF90aGlzLl9fY29sb3IucyA9IHM7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEgoZSkge1xuICAgICAgaWYgKGUudHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAtMSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICB2YXIgZmllbGRSZWN0ID0gX3RoaXMuX19odWVfZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgX3JlZjIgPSBlLnRvdWNoZXMgJiYgZS50b3VjaGVzWzBdIHx8IGUsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWYyLmNsaWVudFk7XG4gICAgICB2YXIgaCA9IDEgLSAoY2xpZW50WSAtIGZpZWxkUmVjdC50b3ApIC8gKGZpZWxkUmVjdC5ib3R0b20gLSBmaWVsZFJlY3QudG9wKTtcbiAgICAgIGlmIChoID4gMSkge1xuICAgICAgICBoID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoaCA8IDApIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9XG4gICAgICBfdGhpcy5fX2NvbG9yLmggPSBoICogMzYwO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENvbG9yQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIG1pc21hdGNoID0gZmFsc2U7XG4gICAgICAgIENvbW1vbi5lYWNoKENvbG9yLkNPTVBPTkVOVFMsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICBpZiAoIUNvbW1vbi5pc1VuZGVmaW5lZChpW2NvbXBvbmVudF0pICYmICFDb21tb24uaXNVbmRlZmluZWQodGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkgJiYgaVtjb21wb25lbnRdICE9PSB0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSB7XG4gICAgICAgICAgICBtaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgaWYgKG1pc21hdGNoKSB7XG4gICAgICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fY29sb3IuX19zdGF0ZSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX3RlbXAuX19zdGF0ZSwgdGhpcy5fX2NvbG9yLl9fc3RhdGUpO1xuICAgICAgdGhpcy5fX3RlbXAuYSA9IDE7XG4gICAgICB2YXIgZmxpcCA9IHRoaXMuX19jb2xvci52IDwgMC41IHx8IHRoaXMuX19jb2xvci5zID4gMC41ID8gMjU1IDogMDtcbiAgICAgIHZhciBfZmxpcCA9IDI1NSAtIGZsaXA7XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IDEwMCAqIHRoaXMuX19jb2xvci5zIC0gNyArICdweCcsXG4gICAgICAgIG1hcmdpblRvcDogMTAwICogKDEgLSB0aGlzLl9fY29sb3IudikgLSA3ICsgJ3B4JyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9fdGVtcC50b0hleFN0cmluZygpLFxuICAgICAgICBib3JkZXI6IHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciArICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArICcpJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9faHVlX2tub2Iuc3R5bGUubWFyZ2luVG9wID0gKDEgLSB0aGlzLl9fY29sb3IuaCAvIDM2MCkgKiAxMDAgKyAncHgnO1xuICAgICAgdGhpcy5fX3RlbXAucyA9IDE7XG4gICAgICB0aGlzLl9fdGVtcC52ID0gMTtcbiAgICAgIGxpbmVhckdyYWRpZW50KHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbGVmdCcsICcjZmZmJywgdGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSk7XG4gICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLCB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX2NvbG9yLnRvSGV4U3RyaW5nKCksXG4gICAgICAgIGNvbG9yOiAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKScsXG4gICAgICAgIHRleHRTaGFkb3c6IHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArICcsLjcpJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb2xvckNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xudmFyIHZlbmRvcnMgPSBbJy1tb3otJywgJy1vLScsICctd2Via2l0LScsICctbXMtJywgJyddO1xuZnVuY3Rpb24gbGluZWFyR3JhZGllbnQoZWxlbSwgeCwgYSwgYikge1xuICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgQ29tbW9uLmVhY2godmVuZG9ycywgZnVuY3Rpb24gKHZlbmRvcikge1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogJyArIHZlbmRvciArICdsaW5lYXItZ3JhZGllbnQoJyArIHggKyAnLCAnICsgYSArICcgMCUsICcgKyBiICsgJyAxMDAlKTsgJztcbiAgfSk7XG59XG5mdW5jdGlvbiBodWVHcmFkaWVudChlbGVtKSB7XG4gIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsICNmZjAwZmYgMTclLCAjMDAwMGZmIDM0JSwgIzAwZmZmZiA1MCUsICMwMGZmMDAgNjclLCAjZmZmZjAwIDg0JSwgI2ZmMDAwMCAxMDAlKTsnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7Jztcbn1cblxudmFyIGNzcyA9IHtcbiAgbG9hZDogZnVuY3Rpb24gbG9hZCh1cmwsIGluZG9jKSB7XG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xuICAgIHZhciBsaW5rID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICBsaW5rLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgfSxcbiAgaW5qZWN0OiBmdW5jdGlvbiBpbmplY3QoY3NzQ29udGVudCwgaW5kb2MpIHtcbiAgICB2YXIgZG9jID0gaW5kb2MgfHwgZG9jdW1lbnQ7XG4gICAgdmFyIGluamVjdGVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBpbmplY3RlZC50eXBlID0gJ3RleHQvY3NzJztcbiAgICBpbmplY3RlZC5pbm5lckhUTUwgPSBjc3NDb250ZW50O1xuICAgIHZhciBoZWFkID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgdHJ5IHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoaW5qZWN0ZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzYXZlRGlhbG9nQ29udGVudHMgPSBcIjxkaXYgaWQ9XFxcImRnLXNhdmVcXFwiIGNsYXNzPVxcXCJkZyBkaWFsb2d1ZVxcXCI+XFxuXFxuICBIZXJlJ3MgdGhlIG5ldyBsb2FkIHBhcmFtZXRlciBmb3IgeW91ciA8Y29kZT5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3I6XFxuXFxuICA8dGV4dGFyZWEgaWQ9XFxcImRnLW5ldy1jb25zdHJ1Y3RvclxcXCI+PC90ZXh0YXJlYT5cXG5cXG4gIDxkaXYgaWQ9XFxcImRnLXNhdmUtbG9jYWxseVxcXCI+XFxuXFxuICAgIDxpbnB1dCBpZD1cXFwiZGctbG9jYWwtc3RvcmFnZVxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiLz4gQXV0b21hdGljYWxseSBzYXZlXFxuICAgIHZhbHVlcyB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IG9uIGV4aXQuXFxuXFxuICAgIDxkaXYgaWQ9XFxcImRnLWxvY2FsLWV4cGxhaW5cXFwiPlRoZSB2YWx1ZXMgc2F2ZWQgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiB3aWxsXFxuICAgICAgb3ZlcnJpZGUgdGhvc2UgcGFzc2VkIHRvIDxjb2RlPmRhdC5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3IuIFRoaXMgbWFrZXMgaXRcXG4gICAgICBlYXNpZXIgdG8gd29yayBpbmNyZW1lbnRhbGx5LCBidXQgPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBpcyBmcmFnaWxlLFxcbiAgICAgIGFuZCB5b3VyIGZyaWVuZHMgbWF5IG5vdCBzZWUgdGhlIHNhbWUgdmFsdWVzIHlvdSBkby5cXG5cXG4gICAgPC9kaXY+XFxuXFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cIjtcblxudmFyIENvbnRyb2xsZXJGYWN0b3J5ID0gZnVuY3Rpb24gQ29udHJvbGxlckZhY3Rvcnkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB2YXIgaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgaWYgKENvbW1vbi5pc0FycmF5KGFyZ3VtZW50c1syXSkgfHwgQ29tbW9uLmlzT2JqZWN0KGFyZ3VtZW50c1syXSkpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdKTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzTnVtYmVyKGluaXRpYWxWYWx1ZSkpIHtcbiAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1syXSkgJiYgQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1szXSkpIHtcbiAgICAgIGlmIChDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzRdKSkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgIH1cbiAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcbiAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSwgc3RlcDogYXJndW1lbnRzWzRdIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10gfSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc1N0cmluZyhpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9XG4gIGlmIChDb21tb24uaXNGdW5jdGlvbihpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgJycpO1xuICB9XG4gIGlmIChDb21tb24uaXNCb29sZWFuKGluaXRpYWxWYWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xlYW5Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG59XG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG52YXIgQ2VudGVyZWREaXYgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENlbnRlcmVkRGl2KCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENlbnRlcmVkRGl2KTtcbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLCB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDAnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICdvcGFjaXR5IDAuMnMgbGluZWFyJyxcbiAgICAgIHRyYW5zaXRpb246ICdvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuICAgIGRvbS5tYWtlRnVsbHNjcmVlbih0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBDb21tb24uZXh0ZW5kKHRoaXMuZG9tRWxlbWVudC5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAxJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnLXdlYmtpdC10cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGxpbmVhcicsXG4gICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBkb20uYmluZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ2VudGVyZWREaXYsIFt7XG4gICAga2V5OiAnc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG4gICAgICB0aGlzLmxheW91dCgpO1xuICAgICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hpZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBoaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIH07XG4gICAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGF5b3V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0KCkge1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmxlZnQgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSBkb20uZ2V0V2lkdGgodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDIgLSBkb20uZ2V0SGVpZ2h0KHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENlbnRlcmVkRGl2O1xufSgpO1xuXG52YXIgc3R5bGVTaGVldCA9IF9fXyRpbnNlcnRTdHlsZShcIi5kZyB1bHtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO3dpZHRoOjEwMCU7Y2xlYXI6Ym90aH0uZGcuYWN7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjA7ei1pbmRleDowfS5kZzpub3QoLmFjKSAubWFpbntvdmVyZmxvdzpoaWRkZW59LmRnLm1haW57LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvd3tvdmVyZmxvdy15OmF1dG99LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93IC5jbG9zZS1idXR0b257b3BhY2l0eToxO21hcmdpbi10b3A6LTFweDtib3JkZXItdG9wOjFweCBzb2xpZCAjMmMyYzJjfS5kZy5tYWluIHVsLmNsb3NlZCAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MSAhaW1wb3J0YW50fS5kZy5tYWluOmhvdmVyIC5jbG9zZS1idXR0b24sLmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5kcmFne29wYWNpdHk6MX0uZGcubWFpbiAuY2xvc2UtYnV0dG9uey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjtib3JkZXI6MDtsaW5lLWhlaWdodDoxOXB4O2hlaWdodDoyMHB4O2N1cnNvcjpwb2ludGVyO3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6IzAwMH0uZGcubWFpbiAuY2xvc2UtYnV0dG9uLmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcubWFpbiAuY2xvc2UtYnV0dG9uLmNsb3NlLWJvdHRvbXtwb3NpdGlvbjphYnNvbHV0ZX0uZGcubWFpbiAuY2xvc2UtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzExMX0uZGcuYXtmbG9hdDpyaWdodDttYXJnaW4tcmlnaHQ6MTVweDtvdmVyZmxvdy15OnZpc2libGV9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtdG9we21hcmdpbi10b3A6MH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZS1ib3R0b217bWFyZ2luLXRvcDoyN3B4fS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlZHttYXJnaW4tdG9wOjB9LmRnLmEgLnNhdmUtcm93e3RvcDowO3otaW5kZXg6MTAwMn0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtdG9we3Bvc2l0aW9uOnJlbGF0aXZlfS5kZy5hIC5zYXZlLXJvdy5jbG9zZS1ib3R0b217cG9zaXRpb246Zml4ZWR9LmRnIGxpey13ZWJraXQtdHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy1vLXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstbW96LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDt0cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LXdlYmtpdC10cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyO3RyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcn0uZGcgbGk6bm90KC5mb2xkZXIpe2N1cnNvcjphdXRvO2hlaWdodDoyN3B4O2xpbmUtaGVpZ2h0OjI3cHg7cGFkZGluZzowIDRweCAwIDVweH0uZGcgbGkuZm9sZGVye3BhZGRpbmc6MDtib3JkZXItbGVmdDo0cHggc29saWQgcmdiYSgwLDAsMCwwKX0uZGcgbGkudGl0bGV7Y3Vyc29yOnBvaW50ZXI7bWFyZ2luLWxlZnQ6LTRweH0uZGcgLmNsb3NlZCBsaTpub3QoLnRpdGxlKSwuZGcgLmNsb3NlZCB1bCBsaSwuZGcgLmNsb3NlZCB1bCBsaT4qe2hlaWdodDowO292ZXJmbG93OmhpZGRlbjtib3JkZXI6MH0uZGcgLmNye2NsZWFyOmJvdGg7cGFkZGluZy1sZWZ0OjNweDtoZWlnaHQ6MjdweDtvdmVyZmxvdzpoaWRkZW59LmRnIC5wcm9wZXJ0eS1uYW1le2N1cnNvcjpkZWZhdWx0O2Zsb2F0OmxlZnQ7Y2xlYXI6bGVmdDt3aWR0aDo0MCU7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9LmRnIC5je2Zsb2F0OmxlZnQ7d2lkdGg6NjAlO3Bvc2l0aW9uOnJlbGF0aXZlfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JvcmRlcjowO21hcmdpbi10b3A6NHB4O3BhZGRpbmc6M3B4O3dpZHRoOjEwMCU7ZmxvYXQ6cmlnaHR9LmRnIC5oYXMtc2xpZGVyIGlucHV0W3R5cGU9dGV4dF17d2lkdGg6MzAlO21hcmdpbi1sZWZ0OjB9LmRnIC5zbGlkZXJ7ZmxvYXQ6bGVmdDt3aWR0aDo2NiU7bWFyZ2luLWxlZnQ6LTVweDttYXJnaW4tcmlnaHQ6MDtoZWlnaHQ6MTlweDttYXJnaW4tdG9wOjRweH0uZGcgLnNsaWRlci1mZ3toZWlnaHQ6MTAwJX0uZGcgLmMgaW5wdXRbdHlwZT1jaGVja2JveF17bWFyZ2luLXRvcDo3cHh9LmRnIC5jIHNlbGVjdHttYXJnaW4tdG9wOjVweH0uZGcgLmNyLmZ1bmN0aW9uLC5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWUsLmRnIC5jci5mdW5jdGlvbiAqLC5kZyAuY3IuYm9vbGVhbiwuZGcgLmNyLmJvb2xlYW4gKntjdXJzb3I6cG9pbnRlcn0uZGcgLmNyLmNvbG9ye292ZXJmbG93OnZpc2libGV9LmRnIC5zZWxlY3RvcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLWxlZnQ6LTlweDttYXJnaW4tdG9wOjIzcHg7ei1pbmRleDoxMH0uZGcgLmM6aG92ZXIgLnNlbGVjdG9yLC5kZyAuc2VsZWN0b3IuZHJhZ3tkaXNwbGF5OmJsb2NrfS5kZyBsaS5zYXZlLXJvd3twYWRkaW5nOjB9LmRnIGxpLnNhdmUtcm93IC5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzowcHggNnB4fS5kZy5kaWFsb2d1ZXtiYWNrZ3JvdW5kLWNvbG9yOiMyMjI7d2lkdGg6NDYwcHg7cGFkZGluZzoxNXB4O2ZvbnQtc2l6ZToxM3B4O2xpbmUtaGVpZ2h0OjE1cHh9I2RnLW5ldy1jb25zdHJ1Y3RvcntwYWRkaW5nOjEwcHg7Y29sb3I6IzIyMjtmb250LWZhbWlseTpNb25hY28sIG1vbm9zcGFjZTtmb250LXNpemU6MTBweDtib3JkZXI6MDtyZXNpemU6bm9uZTtib3gtc2hhZG93Omluc2V0IDFweCAxcHggMXB4ICM4ODg7d29yZC13cmFwOmJyZWFrLXdvcmQ7bWFyZ2luOjEycHggMDtkaXNwbGF5OmJsb2NrO3dpZHRoOjQ0MHB4O292ZXJmbG93LXk6c2Nyb2xsO2hlaWdodDoxMDBweDtwb3NpdGlvbjpyZWxhdGl2ZX0jZGctbG9jYWwtZXhwbGFpbntkaXNwbGF5Om5vbmU7Zm9udC1zaXplOjExcHg7bGluZS1oZWlnaHQ6MTdweDtib3JkZXItcmFkaXVzOjNweDtiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7cGFkZGluZzo4cHg7bWFyZ2luLXRvcDoxMHB4fSNkZy1sb2NhbC1leHBsYWluIGNvZGV7Zm9udC1zaXplOjEwcHh9I2RhdC1ndWktc2F2ZS1sb2NhbGx5e2Rpc3BsYXk6bm9uZX0uZGd7Y29sb3I6I2VlZTtmb250OjExcHggJ0x1Y2lkYSBHcmFuZGUnLCBzYW5zLXNlcmlmO3RleHQtc2hhZG93OjAgLTFweCAwICMxMTF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjVweDtiYWNrZ3JvdW5kOiMxYTFhMWF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lcntoZWlnaHQ6MDtkaXNwbGF5Om5vbmV9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1ie2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6IzY3Njc2N30uZGcgbGk6bm90KC5mb2xkZXIpe2JhY2tncm91bmQ6IzFhMWExYTtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjMmMyYzJjfS5kZyBsaS5zYXZlLXJvd3tsaW5lLWhlaWdodDoyNXB4O2JhY2tncm91bmQ6I2RhZDVjYjtib3JkZXI6MH0uZGcgbGkuc2F2ZS1yb3cgc2VsZWN0e21hcmdpbi1sZWZ0OjVweDt3aWR0aDoxMDhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbnttYXJnaW4tbGVmdDo1cHg7bWFyZ2luLXRvcDoxcHg7Ym9yZGVyLXJhZGl1czoycHg7Zm9udC1zaXplOjlweDtsaW5lLWhlaWdodDo3cHg7cGFkZGluZzo0cHggNHB4IDVweCA0cHg7YmFja2dyb3VuZDojYzViZGFkO2NvbG9yOiNmZmY7dGV4dC1zaGFkb3c6MCAxcHggMCAjYjBhNThmO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4ZjtjdXJzb3I6cG9pbnRlcn0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbi5nZWFyc3tiYWNrZ3JvdW5kOiNjNWJkYWQgdXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXNBQUFBTkNBWUFBQUIvOVpRN0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBUUpKUkVGVWVOcGlZS0FVL1AvL1B3R0lDL0FwQ0FCaUJTQVcrSThBQ2xBY2dLeFE0VDlob01BRVVyeHgyUVNHTjYrZWdEWCsvdldUNGU3TjgyQU1Zb1BBeC9ldndXb1lvU1liQUNYMnM3S3hDeHpjc2V6RGgzZXZGb0RFQllURUVxeWNnZ1dBekE5QXVVU1FRZ2VZUGE5ZlB2Ni9ZV20vQWN4NUlQYjd0eS9mdytRWmJsdzY3dkRzOFIwWUh5UWhnT2J4K3lBSmtCcW1HNWRQUERoMWFQT0dSL2V1Z1cwRzR2bElvVElmeUZjQStRZWtoaEhKaFBkUXhiaUFJZ3VNQlRRWnJQRDcxMDhNNnJvV1lERlFpSUFBdjZBb3cvMWJGd1hnaXMrZjJMVUF5bndvSWFOY3o4WE54M0RsN01FSlVER1FweDlndFE4WUN1ZUIrRDI2T0VDQUFRRGFkdDdlNDZENDJRQUFBQUJKUlU1RXJrSmdnZz09KSAycHggMXB4IG5vLXJlcGVhdDtoZWlnaHQ6N3B4O3dpZHRoOjhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNiYWIxOWU7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmfS5kZyBsaS5mb2xkZXJ7Ym9yZGVyLWJvdHRvbTowfS5kZyBsaS50aXRsZXtwYWRkaW5nLWxlZnQ6MTZweDtiYWNrZ3JvdW5kOiMwMDAgdXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsSStoS2dGeG9DZ0FPdz09KSA2cHggMTBweCBuby1yZXBlYXQ7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpfS5kZyAuY2xvc2VkIGxpLnRpdGxle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsR0lXcU1DYldBRUFPdz09KX0uZGcgLmNyLmJvb2xlYW57Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICM4MDY3ODd9LmRnIC5jci5jb2xvcntib3JkZXItbGVmdDozcHggc29saWR9LmRnIC5jci5mdW5jdGlvbntib3JkZXItbGVmdDozcHggc29saWQgI2U2MWQ1Zn0uZGcgLmNyLm51bWJlcntib3JkZXItbGVmdDozcHggc29saWQgIzJGQTFENn0uZGcgLmNyLm51bWJlciBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMyRkExRDZ9LmRnIC5jci5zdHJpbmd7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMxZWQzNmZ9LmRnIC5jci5zdHJpbmcgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMWVkMzZmfS5kZyAuY3IuZnVuY3Rpb246aG92ZXIsLmRnIC5jci5ib29sZWFuOmhvdmVye2JhY2tncm91bmQ6IzExMX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtiYWNrZ3JvdW5kOiMzMDMwMzA7b3V0bGluZTpub25lfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpmb2N1c3tiYWNrZ3JvdW5kOiM0OTQ5NDk7Y29sb3I6I2ZmZn0uZGcgLmMgLnNsaWRlcntiYWNrZ3JvdW5kOiMzMDMwMzA7Y3Vyc29yOmV3LXJlc2l6ZX0uZGcgLmMgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiMyRkExRDY7bWF4LXdpZHRoOjEwMCV9LmRnIC5jIC5zbGlkZXI6aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyAuc2xpZGVyOmhvdmVyIC5zbGlkZXItZmd7YmFja2dyb3VuZDojNDRhYmRhfVxcblwiKTtcblxuY3NzLmluamVjdChzdHlsZVNoZWV0KTtcbnZhciBDU1NfTkFNRVNQQUNFID0gJ2RnJztcbnZhciBISURFX0tFWV9DT0RFID0gNzI7XG52YXIgQ0xPU0VfQlVUVE9OX0hFSUdIVCA9IDIwO1xudmFyIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSA9ICdEZWZhdWx0JztcbnZhciBTVVBQT1JUU19MT0NBTF9TVE9SQUdFID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiAhIXdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0oKTtcbnZhciBTQVZFX0RJQUxPR1VFID0gdm9pZCAwO1xudmFyIGF1dG9QbGFjZVZpcmdpbiA9IHRydWU7XG52YXIgYXV0b1BsYWNlQ29udGFpbmVyID0gdm9pZCAwO1xudmFyIGhpZGUgPSBmYWxzZTtcbnZhciBoaWRlYWJsZUd1aXMgPSBbXTtcbnZhciBHVUkgPSBmdW5jdGlvbiBHVUkocGFycykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgcGFyYW1zID0gcGFycyB8fCB7fTtcbiAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuX191bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fdWwpO1xuICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBDU1NfTkFNRVNQQUNFKTtcbiAgdGhpcy5fX2ZvbGRlcnMgPSB7fTtcbiAgdGhpcy5fX2NvbnRyb2xsZXJzID0gW107XG4gIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cyA9IFtdO1xuICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzID0gW107XG4gIHRoaXMuX19saXN0ZW5pbmcgPSBbXTtcbiAgcGFyYW1zID0gQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgIGNsb3NlT25Ub3A6IGZhbHNlLFxuICAgIGF1dG9QbGFjZTogdHJ1ZSxcbiAgICB3aWR0aDogR1VJLkRFRkFVTFRfV0lEVEhcbiAgfSk7XG4gIHBhcmFtcyA9IENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICByZXNpemFibGU6IHBhcmFtcy5hdXRvUGxhY2UsXG4gICAgaGlkZWFibGU6IHBhcmFtcy5hdXRvUGxhY2VcbiAgfSk7XG4gIGlmICghQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5sb2FkKSkge1xuICAgIGlmIChwYXJhbXMucHJlc2V0KSB7XG4gICAgICBwYXJhbXMubG9hZC5wcmVzZXQgPSBwYXJhbXMucHJlc2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMubG9hZCA9IHsgcHJlc2V0OiBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgfTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5oaWRlYWJsZSkge1xuICAgIGhpZGVhYmxlR3Vpcy5wdXNoKHRoaXMpO1xuICB9XG4gIHBhcmFtcy5yZXNpemFibGUgPSBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnJlc2l6YWJsZTtcbiAgaWYgKHBhcmFtcy5hdXRvUGxhY2UgJiYgQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5zY3JvbGxhYmxlKSkge1xuICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gdHJ1ZTtcbiAgfVxuICB2YXIgdXNlTG9jYWxTdG9yYWdlID0gU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdpc0xvY2FsJykpID09PSAndHJ1ZSc7XG4gIHZhciBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSB2b2lkIDA7XG4gIHZhciB0aXRsZVJvdyA9IHZvaWQgMDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyxcbiAge1xuICAgIHBhcmVudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMucGFyZW50O1xuICAgICAgfVxuICAgIH0sXG4gICAgc2Nyb2xsYWJsZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuc2Nyb2xsYWJsZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF1dG9QbGFjZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuYXV0b1BsYWNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VPblRvcDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuY2xvc2VPblRvcDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByZXNldDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0Um9vdCgpLnByZXNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQucHJlc2V0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgIF90aGlzLmdldFJvb3QoKS5wcmVzZXQgPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJlc2V0U2VsZWN0SW5kZXgodGhpcyk7XG4gICAgICAgIF90aGlzLnJldmVydCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLndpZHRoO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLndpZHRoID0gdjtcbiAgICAgICAgc2V0V2lkdGgoX3RoaXMsIHYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMubmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICAgIHBhcmFtcy5uYW1lID0gdjtcbiAgICAgICAgaWYgKHRpdGxlUm93KSB7XG4gICAgICAgICAgdGl0bGVSb3cuaW5uZXJIVE1MID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb3NlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuY2xvc2VkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLmNsb3NlZCA9IHY7XG4gICAgICAgIGlmIChwYXJhbXMuY2xvc2VkKSB7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgIGlmIChfdGhpcy5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgX3RoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSB2ID8gR1VJLlRFWFRfT1BFTiA6IEdVSS5URVhUX0NMT1NFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbG9hZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMubG9hZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZUxvY2FsU3RvcmFnZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB1c2VMb2NhbFN0b3JhZ2U7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoYm9vbCkge1xuICAgICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZSA9IGJvb2w7XG4gICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSwgYm9vbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG4gICAgdGhpcy5jbG9zZWQgPSBwYXJhbXMuY2xvc2VkIHx8IGZhbHNlO1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19NQUlOKTtcbiAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICAgIGlmICh1c2VMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgX3RoaXMudXNlTG9jYWxTdG9yYWdlID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNhdmVkR3VpID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnZ3VpJykpO1xuICAgICAgICBpZiAoc2F2ZWRHdWkpIHtcbiAgICAgICAgICBwYXJhbXMubG9hZCA9IEpTT04ucGFyc2Uoc2F2ZWRHdWkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX19jbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTik7XG4gICAgaWYgKHBhcmFtcy5jbG9zZU9uVG9wKSB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfVE9QKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5fX2Nsb3NlQnV0dG9uLCB0aGlzLmRvbUVsZW1lbnQuY2hpbGROb2Rlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9CT1RUT00pO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jbG9zZUJ1dHRvbik7XG4gICAgfVxuICAgIGRvbS5iaW5kKHRoaXMuX19jbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGFyYW1zLmNsb3NlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHRpdGxlUm93TmFtZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhcmFtcy5uYW1lKTtcbiAgICBkb20uYWRkQ2xhc3ModGl0bGVSb3dOYW1lLCAnY29udHJvbGxlci1uYW1lJyk7XG4gICAgdGl0bGVSb3cgPSBhZGRSb3coX3RoaXMsIHRpdGxlUm93TmFtZSk7XG4gICAgdmFyIG9uQ2xpY2tUaXRsZSA9IGZ1bmN0aW9uIG9uQ2xpY2tUaXRsZShlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgZG9tLmFkZENsYXNzKHRpdGxlUm93LCAndGl0bGUnKTtcbiAgICBkb20uYmluZCh0aXRsZVJvdywgJ2NsaWNrJywgb25DbGlja1RpdGxlKTtcbiAgICBpZiAoIXBhcmFtcy5jbG9zZWQpIHtcbiAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChwYXJhbXMuYXV0b1BsYWNlKSB7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuICAgICAgaWYgKGF1dG9QbGFjZVZpcmdpbikge1xuICAgICAgICBhdXRvUGxhY2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9QbGFjZUNvbnRhaW5lciwgQ1NTX05BTUVTUEFDRSk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvUGxhY2VDb250YWluZXIsIEdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXV0b1BsYWNlQ29udGFpbmVyKTtcbiAgICAgICAgYXV0b1BsYWNlVmlyZ2luID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBhdXRvUGxhY2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19BVVRPX1BMQUNFKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgc2V0V2lkdGgoX3RoaXMsIHBhcmFtcy53aWR0aCk7XG4gICAgfVxuICB9XG4gIHRoaXMuX19yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLm9uUmVzaXplRGVib3VuY2VkKCk7XG4gIH07XG4gIGRvbS5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAnb1RyYW5zaXRpb25FbmQnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gIHRoaXMub25SZXNpemUoKTtcbiAgaWYgKHBhcmFtcy5yZXNpemFibGUpIHtcbiAgICBhZGRSZXNpemVIYW5kbGUodGhpcyk7XG4gIH1cbiAgc2F2ZVRvTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24gc2F2ZVRvTG9jYWxTdG9yYWdlKCkge1xuICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdpc0xvY2FsJykpID09PSAndHJ1ZScpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdndWknKSwgSlNPTi5zdHJpbmdpZnkoX3RoaXMuZ2V0U2F2ZU9iamVjdCgpKSk7XG4gICAgfVxuICB9O1xuICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUgPSBzYXZlVG9Mb2NhbFN0b3JhZ2U7XG4gIGZ1bmN0aW9uIHJlc2V0V2lkdGgoKSB7XG4gICAgdmFyIHJvb3QgPSBfdGhpcy5nZXRSb290KCk7XG4gICAgcm9vdC53aWR0aCArPSAxO1xuICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICByb290LndpZHRoIC09IDE7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFwYXJhbXMucGFyZW50KSB7XG4gICAgcmVzZXRXaWR0aCgpO1xuICB9XG59O1xuR1VJLnRvZ2dsZUhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGhpZGUgPSAhaGlkZTtcbiAgQ29tbW9uLmVhY2goaGlkZWFibGVHdWlzLCBmdW5jdGlvbiAoZ3VpKSB7XG4gICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGhpZGUgPyAnbm9uZScgOiAnJztcbiAgfSk7XG59O1xuR1VJLkNMQVNTX0FVVE9fUExBQ0UgPSAnYSc7XG5HVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIgPSAnYWMnO1xuR1VJLkNMQVNTX01BSU4gPSAnbWFpbic7XG5HVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cgPSAnY3InO1xuR1VJLkNMQVNTX1RPT19UQUxMID0gJ3RhbGxlci10aGFuLXdpbmRvdyc7XG5HVUkuQ0xBU1NfQ0xPU0VEID0gJ2Nsb3NlZCc7XG5HVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OID0gJ2Nsb3NlLWJ1dHRvbic7XG5HVUkuQ0xBU1NfQ0xPU0VfVE9QID0gJ2Nsb3NlLXRvcCc7XG5HVUkuQ0xBU1NfQ0xPU0VfQk9UVE9NID0gJ2Nsb3NlLWJvdHRvbSc7XG5HVUkuQ0xBU1NfRFJBRyA9ICdkcmFnJztcbkdVSS5ERUZBVUxUX1dJRFRIID0gMjQ1O1xuR1VJLlRFWFRfQ0xPU0VEID0gJ0Nsb3NlIENvbnRyb2xzJztcbkdVSS5URVhUX09QRU4gPSAnT3BlbiBDb250cm9scyc7XG5HVUkuX2tleWRvd25IYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudHlwZSAhPT0gJ3RleHQnICYmIChlLndoaWNoID09PSBISURFX0tFWV9DT0RFIHx8IGUua2V5Q29kZSA9PT0gSElERV9LRVlfQ09ERSkpIHtcbiAgICBHVUkudG9nZ2xlSGlkZSgpO1xuICB9XG59O1xuZG9tLmJpbmQod2luZG93LCAna2V5ZG93bicsIEdVSS5fa2V5ZG93bkhhbmRsZXIsIGZhbHNlKTtcbkNvbW1vbi5leHRlbmQoR1VJLnByb3RvdHlwZSxcbntcbiAgYWRkOiBmdW5jdGlvbiBhZGQob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBfYWRkKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgIGZhY3RvcnlBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXG4gICAgfSk7XG4gIH0sXG4gIGFkZENvbG9yOiBmdW5jdGlvbiBhZGRDb2xvcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIF9hZGQodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgY29sb3I6IHRydWVcbiAgICB9KTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY29udHJvbGxlcikge1xuICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChjb250cm9sbGVyLl9fbGkpO1xuICAgIHRoaXMuX19jb250cm9sbGVycy5zcGxpY2UodGhpcy5fX2NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlciksIDEpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgfSk7XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgdGhlIHJvb3QgR1VJIHNob3VsZCBiZSByZW1vdmVkIHdpdGggLmRlc3Ryb3koKS4gJyArICdGb3Igc3ViZm9sZGVycywgdXNlIGd1aS5yZW1vdmVGb2xkZXIoZm9sZGVyKSBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIH1cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoc3ViZm9sZGVyKSB7XG4gICAgICBfdGhpcy5yZW1vdmVGb2xkZXIoc3ViZm9sZGVyKTtcbiAgICB9KTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBHVUkuX2tleWRvd25IYW5kbGVyLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKHRoaXMpO1xuICB9LFxuICBhZGRGb2xkZXI6IGZ1bmN0aW9uIGFkZEZvbGRlcihuYW1lKSB7XG4gICAgaWYgKHRoaXMuX19mb2xkZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFscmVhZHkgaGF2ZSBhIGZvbGRlciBpbiB0aGlzIEdVSSBieSB0aGUnICsgJyBuYW1lIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG4gICAgdmFyIG5ld0d1aVBhcmFtcyA9IHsgbmFtZTogbmFtZSwgcGFyZW50OiB0aGlzIH07XG4gICAgbmV3R3VpUGFyYW1zLmF1dG9QbGFjZSA9IHRoaXMuYXV0b1BsYWNlO1xuICAgIGlmICh0aGlzLmxvYWQgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVycyAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzW25hbWVdKSB7XG4gICAgICBuZXdHdWlQYXJhbXMuY2xvc2VkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0uY2xvc2VkO1xuICAgICAgbmV3R3VpUGFyYW1zLmxvYWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXTtcbiAgICB9XG4gICAgdmFyIGd1aSA9IG5ldyBHVUkobmV3R3VpUGFyYW1zKTtcbiAgICB0aGlzLl9fZm9sZGVyc1tuYW1lXSA9IGd1aTtcbiAgICB2YXIgbGkgPSBhZGRSb3codGhpcywgZ3VpLmRvbUVsZW1lbnQpO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2ZvbGRlcicpO1xuICAgIHJldHVybiBndWk7XG4gIH0sXG4gIHJlbW92ZUZvbGRlcjogZnVuY3Rpb24gcmVtb3ZlRm9sZGVyKGZvbGRlcikge1xuICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChmb2xkZXIuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICBkZWxldGUgdGhpcy5fX2ZvbGRlcnNbZm9sZGVyLm5hbWVdO1xuICAgIGlmICh0aGlzLmxvYWQgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVycyAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzW2ZvbGRlci5uYW1lXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZC5mb2xkZXJzW2ZvbGRlci5uYW1lXTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXJzKGZvbGRlcik7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZWFjaChmb2xkZXIuX19mb2xkZXJzLCBmdW5jdGlvbiAoc3ViZm9sZGVyKSB7XG4gICAgICBmb2xkZXIucmVtb3ZlRm9sZGVyKHN1YmZvbGRlcik7XG4gICAgfSk7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgfSk7XG4gIH0sXG4gIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgfSxcbiAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfSxcbiAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICB9LFxuICBvblJlc2l6ZTogZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLmdldFJvb3QoKTtcbiAgICBpZiAocm9vdC5zY3JvbGxhYmxlKSB7XG4gICAgICB2YXIgdG9wID0gZG9tLmdldE9mZnNldChyb290Ll9fdWwpLnRvcDtcbiAgICAgIHZhciBoID0gMDtcbiAgICAgIENvbW1vbi5lYWNoKHJvb3QuX191bC5jaGlsZE5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIShyb290LmF1dG9QbGFjZSAmJiBub2RlID09PSByb290Ll9fc2F2ZV9yb3cpKSB7XG4gICAgICAgICAgaCArPSBkb20uZ2V0SGVpZ2h0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUIDwgaCkge1xuICAgICAgICBkb20uYWRkQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm9vdC5fX3Jlc2l6ZV9oYW5kbGUpIHtcbiAgICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuX19yZXNpemVfaGFuZGxlLnN0eWxlLmhlaWdodCA9IHJvb3QuX191bC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyb290Ll9fY2xvc2VCdXR0b24pIHtcbiAgICAgIHJvb3QuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHJvb3Qud2lkdGggKyAncHgnO1xuICAgIH1cbiAgfSxcbiAgb25SZXNpemVEZWJvdW5jZWQ6IENvbW1vbi5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICB9LCA1MCksXG4gIHJlbWVtYmVyOiBmdW5jdGlvbiByZW1lbWJlcigpIHtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKFNBVkVfRElBTE9HVUUpKSB7XG4gICAgICBTQVZFX0RJQUxPR1VFID0gbmV3IENlbnRlcmVkRGl2KCk7XG4gICAgICBTQVZFX0RJQUxPR1VFLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gc2F2ZURpYWxvZ0NvbnRlbnRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbiBvbmx5IGNhbGwgcmVtZW1iZXIgb24gYSB0b3AgbGV2ZWwgR1VJLicpO1xuICAgIH1cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhZGRTYXZlTWVudShfdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT09IC0xKSB7XG4gICAgICAgIF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgc2V0V2lkdGgodGhpcywgdGhpcy53aWR0aCk7XG4gICAgfVxuICB9LFxuICBnZXRSb290OiBmdW5jdGlvbiBnZXRSb290KCkge1xuICAgIHZhciBndWkgPSB0aGlzO1xuICAgIHdoaWxlIChndWkucGFyZW50KSB7XG4gICAgICBndWkgPSBndWkucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZ3VpO1xuICB9LFxuICBnZXRTYXZlT2JqZWN0OiBmdW5jdGlvbiBnZXRTYXZlT2JqZWN0KCkge1xuICAgIHZhciB0b1JldHVybiA9IHRoaXMubG9hZDtcbiAgICB0b1JldHVybi5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcbiAgICBpZiAodGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRvUmV0dXJuLnByZXNldCA9IHRoaXMucHJlc2V0O1xuICAgICAgaWYgKCF0b1JldHVybi5yZW1lbWJlcmVkKSB7XG4gICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICB9XG4gICAgdG9SZXR1cm4uZm9sZGVycyA9IHt9O1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZWxlbWVudCwga2V5KSB7XG4gICAgICB0b1JldHVybi5mb2xkZXJzW2tleV0gPSBlbGVtZW50LmdldFNhdmVPYmplY3QoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9SZXR1cm47XG4gIH0sXG4gIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcywgZmFsc2UpO1xuICAgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpO1xuICB9LFxuICBzYXZlQXM6IGZ1bmN0aW9uIHNhdmVBcyhwcmVzZXROYW1lKSB7XG4gICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtwcmVzZXROYW1lXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgdGhpcy5wcmVzZXQgPSBwcmVzZXROYW1lO1xuICAgIGFkZFByZXNldE9wdGlvbih0aGlzLCBwcmVzZXROYW1lLCB0cnVlKTtcbiAgICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUoKTtcbiAgfSxcbiAgcmV2ZXJ0OiBmdW5jdGlvbiByZXZlcnQoZ3VpKSB7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLCBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgaWYgKCF0aGlzLmdldFJvb3QoKS5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZShjb250cm9sbGVyLmluaXRpYWxWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNhbGxTYXZlZFZhbHVlKGd1aSB8fCB0aGlzLmdldFJvb3QoKSwgY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgICBpZiAoY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19vbkZpbmlzaENoYW5nZS5jYWxsKGNvbnRyb2xsZXIsIGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChmb2xkZXIpIHtcbiAgICAgIGZvbGRlci5yZXZlcnQoZm9sZGVyKTtcbiAgICB9KTtcbiAgICBpZiAoIWd1aSkge1xuICAgICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMuZ2V0Um9vdCgpLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbihjb250cm9sbGVyKSB7XG4gICAgdmFyIGluaXQgPSB0aGlzLl9fbGlzdGVuaW5nLmxlbmd0aCA9PT0gMDtcbiAgICB0aGlzLl9fbGlzdGVuaW5nLnB1c2goY29udHJvbGxlcik7XG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHVwZGF0ZURpc3BsYXlzKHRoaXMuX19saXN0ZW5pbmcpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xuICAgICAgZm9sZGVyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KTtcbiAgfVxufSk7XG5mdW5jdGlvbiBhZGRSb3coZ3VpLCBuZXdEb20sIGxpQmVmb3JlKSB7XG4gIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gIGlmIChuZXdEb20pIHtcbiAgICBsaS5hcHBlbmRDaGlsZChuZXdEb20pO1xuICB9XG4gIGlmIChsaUJlZm9yZSkge1xuICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShsaSwgbGlCZWZvcmUpO1xuICB9IGVsc2Uge1xuICAgIGd1aS5fX3VsLmFwcGVuZENoaWxkKGxpKTtcbiAgfVxuICBndWkub25SZXNpemUoKTtcbiAgcmV0dXJuIGxpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGd1aSkge1xuICBkb20udW5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIGd1aS5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBpZiAoZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpIHtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIGd1aS5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1ByZXNldE1vZGlmaWVkKGd1aSwgbW9kaWZpZWQpIHtcbiAgdmFyIG9wdCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4XTtcbiAgaWYgKG1vZGlmaWVkKSB7XG4gICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZSArICcqJztcbiAgfSBlbHNlIHtcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKSB7XG4gIGNvbnRyb2xsZXIuX19saSA9IGxpO1xuICBjb250cm9sbGVyLl9fZ3VpID0gZ3VpO1xuICBDb21tb24uZXh0ZW5kKGNvbnRyb2xsZXIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucyhfb3B0aW9ucykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IG5leHRTaWJsaW5nLFxuICAgICAgICAgIGZhY3RvcnlBcmdzOiBbQ29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoQ29tbW9uLmlzQXJyYXkoX29wdGlvbnMpIHx8IENvbW1vbi5pc09iamVjdChfb3B0aW9ucykpIHtcbiAgICAgICAgdmFyIF9uZXh0U2libGluZyA9IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IF9uZXh0U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW19vcHRpb25zXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUoX25hbWUpIHtcbiAgICAgIGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUwgPSBfbmFtZTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH0sXG4gICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gICAgICBjb250cm9sbGVyLl9fZ3VpLmxpc3Rlbihjb250cm9sbGVyKTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBjb250cm9sbGVyLl9fZ3VpLnJlbW92ZShjb250cm9sbGVyKTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlclNsaWRlcikge1xuICAgIHZhciBib3ggPSBuZXcgTnVtYmVyQ29udHJvbGxlckJveChjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwgeyBtaW46IGNvbnRyb2xsZXIuX19taW4sIG1heDogY29udHJvbGxlci5fX21heCwgc3RlcDogY29udHJvbGxlci5fX3N0ZXAgfSk7XG4gICAgQ29tbW9uLmVhY2goWyd1cGRhdGVEaXNwbGF5JywgJ29uQ2hhbmdlJywgJ29uRmluaXNoQ2hhbmdlJywgJ3N0ZXAnLCAnbWluJywgJ21heCddLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICB2YXIgcGMgPSBjb250cm9sbGVyW21ldGhvZF07XG4gICAgICB2YXIgcGIgPSBib3hbbWV0aG9kXTtcbiAgICAgIGNvbnRyb2xsZXJbbWV0aG9kXSA9IGJveFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHBiLmFwcGx5KGJveCwgYXJncyk7XG4gICAgICAgIHJldHVybiBwYy5hcHBseShjb250cm9sbGVyLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnaGFzLXNsaWRlcicpO1xuICAgIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoYm94LmRvbUVsZW1lbnQsIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJCb3gpIHtcbiAgICB2YXIgciA9IGZ1bmN0aW9uIHIocmV0dXJuZWQpIHtcbiAgICAgIGlmIChDb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21pbikgJiYgQ29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19tYXgpKSB7XG4gICAgICAgIHZhciBvbGROYW1lID0gY29udHJvbGxlci5fX2xpLmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLmlubmVySFRNTDtcbiAgICAgICAgdmFyIHdhc0xpc3RlbmluZyA9IGNvbnRyb2xsZXIuX19ndWkuX19saXN0ZW5pbmcuaW5kZXhPZihjb250cm9sbGVyKSA+IC0xO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICB2YXIgbmV3Q29udHJvbGxlciA9IF9hZGQoZ3VpLCBjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwge1xuICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbnRyb2xsZXIuX19taW4sIGNvbnRyb2xsZXIuX19tYXgsIGNvbnRyb2xsZXIuX19zdGVwXVxuICAgICAgICB9KTtcbiAgICAgICAgbmV3Q29udHJvbGxlci5uYW1lKG9sZE5hbWUpO1xuICAgICAgICBpZiAod2FzTGlzdGVuaW5nKSBuZXdDb250cm9sbGVyLmxpc3RlbigpO1xuICAgICAgICByZXR1cm4gbmV3Q29udHJvbGxlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5lZDtcbiAgICB9O1xuICAgIGNvbnRyb2xsZXIubWluID0gQ29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5taW4pO1xuICAgIGNvbnRyb2xsZXIubWF4ID0gQ29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5tYXgpO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBCb29sZWFuQ29udHJvbGxlcikge1xuICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJyk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRnVuY3Rpb25Db250cm9sbGVyKSB7XG4gICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2J1dHRvbiwgJ2NsaWNrJyk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQobGksICdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQobGksICdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQ29sb3JDb250cm9sbGVyKSB7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnY29sb3InKTtcbiAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkgPSBDb21tb24uY29tcG9zZShmdW5jdGlvbiAodmFsKSB7XG4gICAgICBsaS5zdHlsZS5ib3JkZXJMZWZ0Q29sb3IgPSBjb250cm9sbGVyLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSwgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KTtcbiAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKTtcbiAgfVxuICBjb250cm9sbGVyLnNldFZhbHVlID0gQ29tbW9uLmNvbXBvc2UoZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmIChndWkuZ2V0Um9vdCgpLl9fcHJlc2V0X3NlbGVjdCAmJiBjb250cm9sbGVyLmlzTW9kaWZpZWQoKSkge1xuICAgICAgbWFya1ByZXNldE1vZGlmaWVkKGd1aS5nZXRSb290KCksIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9LCBjb250cm9sbGVyLnNldFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKSB7XG4gIHZhciByb290ID0gZ3VpLmdldFJvb3QoKTtcbiAgdmFyIG1hdGNoZWRJbmRleCA9IHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKGNvbnRyb2xsZXIub2JqZWN0KTtcbiAgaWYgKG1hdGNoZWRJbmRleCAhPT0gLTEpIHtcbiAgICB2YXIgY29udHJvbGxlck1hcCA9IHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZEluZGV4XTtcbiAgICBpZiAoY29udHJvbGxlck1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250cm9sbGVyTWFwID0ge307XG4gICAgICByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRJbmRleF0gPSBjb250cm9sbGVyTWFwO1xuICAgIH1cbiAgICBjb250cm9sbGVyTWFwW2NvbnRyb2xsZXIucHJvcGVydHldID0gY29udHJvbGxlcjtcbiAgICBpZiAocm9vdC5sb2FkICYmIHJvb3QubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB2YXIgcHJlc2V0TWFwID0gcm9vdC5sb2FkLnJlbWVtYmVyZWQ7XG4gICAgICB2YXIgcHJlc2V0ID0gdm9pZCAwO1xuICAgICAgaWYgKHByZXNldE1hcFtndWkucHJlc2V0XSkge1xuICAgICAgICBwcmVzZXQgPSBwcmVzZXRNYXBbZ3VpLnByZXNldF07XG4gICAgICB9IGVsc2UgaWYgKHByZXNldE1hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdKSB7XG4gICAgICAgIHByZXNldCA9IHByZXNldE1hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldFttYXRjaGVkSW5kZXhdICYmIHByZXNldFttYXRjaGVkSW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcHJlc2V0W21hdGNoZWRJbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV07XG4gICAgICAgIGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2FkZChndWksIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuICBpZiAob2JqZWN0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgXCInICsgb2JqZWN0ICsgJ1wiIGhhcyBubyBwcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eSArICdcIicpO1xuICB9XG4gIHZhciBjb250cm9sbGVyID0gdm9pZCAwO1xuICBpZiAocGFyYW1zLmNvbG9yKSB7XG4gICAgY29udHJvbGxlciA9IG5ldyBDb2xvckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZhY3RvcnlBcmdzID0gW29iamVjdCwgcHJvcGVydHldLmNvbmNhdChwYXJhbXMuZmFjdG9yeUFyZ3MpO1xuICAgIGNvbnRyb2xsZXIgPSBDb250cm9sbGVyRmFjdG9yeS5hcHBseShndWksIGZhY3RvcnlBcmdzKTtcbiAgfVxuICBpZiAocGFyYW1zLmJlZm9yZSBpbnN0YW5jZW9mIENvbnRyb2xsZXIpIHtcbiAgICBwYXJhbXMuYmVmb3JlID0gcGFyYW1zLmJlZm9yZS5fX2xpO1xuICB9XG4gIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKTtcbiAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuZG9tRWxlbWVudCwgJ2MnKTtcbiAgdmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGRvbS5hZGRDbGFzcyhuYW1lLCAncHJvcGVydHktbmFtZScpO1xuICBuYW1lLmlubmVySFRNTCA9IGNvbnRyb2xsZXIucHJvcGVydHk7XG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKG5hbWUpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udHJvbGxlci5kb21FbGVtZW50KTtcbiAgdmFyIGxpID0gYWRkUm93KGd1aSwgY29udGFpbmVyLCBwYXJhbXMuYmVmb3JlKTtcbiAgZG9tLmFkZENsYXNzKGxpLCBHVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cpO1xuICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gIH0gZWxzZSB7XG4gICAgZG9tLmFkZENsYXNzKGxpLCBfdHlwZW9mKGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSkpO1xuICB9XG4gIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpO1xuICBndWkuX19jb250cm9sbGVycy5wdXNoKGNvbnRyb2xsZXIpO1xuICByZXR1cm4gY29udHJvbGxlcjtcbn1cbmZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCBrZXkpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgKyAnLicgKyBrZXk7XG59XG5mdW5jdGlvbiBhZGRQcmVzZXRPcHRpb24oZ3VpLCBuYW1lLCBzZXRTZWxlY3RlZCkge1xuICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gIG9wdC5pbm5lckhUTUwgPSBuYW1lO1xuICBvcHQudmFsdWUgPSBuYW1lO1xuICBndWkuX19wcmVzZXRfc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG4gIGlmIChzZXRTZWxlY3RlZCkge1xuICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoIC0gMTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvd0hpZGVFeHBsYWluKGd1aSwgZXhwbGFpbikge1xuICBleHBsYWluLnN0eWxlLmRpc3BsYXkgPSBndWkudXNlTG9jYWxTdG9yYWdlID8gJ2Jsb2NrJyA6ICdub25lJztcbn1cbmZ1bmN0aW9uIGFkZFNhdmVNZW51KGd1aSkge1xuICB2YXIgZGl2ID0gZ3VpLl9fc2F2ZV9yb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBkb20uYWRkQ2xhc3MoZ3VpLmRvbUVsZW1lbnQsICdoYXMtc2F2ZScpO1xuICBndWkuX191bC5pbnNlcnRCZWZvcmUoZGl2LCBndWkuX191bC5maXJzdENoaWxkKTtcbiAgZG9tLmFkZENsYXNzKGRpdiwgJ3NhdmUtcm93Jyk7XG4gIHZhciBnZWFycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgZ2VhcnMuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gIGRvbS5hZGRDbGFzcyhnZWFycywgJ2J1dHRvbiBnZWFycycpO1xuICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24uaW5uZXJIVE1MID0gJ1NhdmUnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnYnV0dG9uJyk7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24sICdzYXZlJyk7XG4gIHZhciBidXR0b24yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24yLmlubmVySFRNTCA9ICdOZXcnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ3NhdmUtYXMnKTtcbiAgdmFyIGJ1dHRvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGJ1dHRvbjMuaW5uZXJIVE1MID0gJ1JldmVydCc7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24zLCAnYnV0dG9uJyk7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24zLCAncmV2ZXJ0Jyk7XG4gIHZhciBzZWxlY3QgPSBndWkuX19wcmVzZXRfc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gIGlmIChndWkubG9hZCAmJiBndWkubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgQ29tbW9uLmVhY2goZ3VpLmxvYWQucmVtZW1iZXJlZCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGFkZFByZXNldE9wdGlvbihndWksIGtleSwga2V5ID09PSBndWkucHJlc2V0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUsIGZhbHNlKTtcbiAgfVxuICBkb20uYmluZChzZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS5pbm5lckhUTUwgPSBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZTtcbiAgICB9XG4gICAgZ3VpLnByZXNldCA9IHRoaXMudmFsdWU7XG4gIH0pO1xuICBkaXYuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcbiAgZGl2LmFwcGVuZENoaWxkKGdlYXJzKTtcbiAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24yKTtcbiAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjMpO1xuICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgIHZhciBleHBsYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLWV4cGxhaW4nKTtcbiAgICB2YXIgbG9jYWxTdG9yYWdlQ2hlY2tCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtc3RvcmFnZScpO1xuICAgIHZhciBzYXZlTG9jYWxseSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1zYXZlLWxvY2FsbHknKTtcbiAgICBzYXZlTG9jYWxseS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksICdpc0xvY2FsJykpID09PSAndHJ1ZScpIHtcbiAgICAgIGxvY2FsU3RvcmFnZUNoZWNrQm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgfVxuICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuICAgIGRvbS5iaW5kKGxvY2FsU3RvcmFnZUNoZWNrQm94LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgZ3VpLnVzZUxvY2FsU3RvcmFnZSA9ICFndWkudXNlTG9jYWxTdG9yYWdlO1xuICAgICAgc2hvd0hpZGVFeHBsYWluKGd1aSwgZXhwbGFpbik7XG4gICAgfSk7XG4gIH1cbiAgdmFyIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbmV3LWNvbnN0cnVjdG9yJyk7XG4gIGRvbS5iaW5kKG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5tZXRhS2V5ICYmIChlLndoaWNoID09PSA2NyB8fCBlLmtleUNvZGUgPT09IDY3KSkge1xuICAgICAgU0FWRV9ESUFMT0dVRS5oaWRlKCk7XG4gICAgfVxuICB9KTtcbiAgZG9tLmJpbmQoZ2VhcnMsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KGd1aS5nZXRTYXZlT2JqZWN0KCksIHVuZGVmaW5lZCwgMik7XG4gICAgU0FWRV9ESUFMT0dVRS5zaG93KCk7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5mb2N1cygpO1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuc2VsZWN0KCk7XG4gIH0pO1xuICBkb20uYmluZChidXR0b24sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBndWkuc2F2ZSgpO1xuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uMiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmVzZXROYW1lID0gcHJvbXB0KCdFbnRlciBhIG5ldyBwcmVzZXQgbmFtZS4nKTtcbiAgICBpZiAocHJlc2V0TmFtZSkge1xuICAgICAgZ3VpLnNhdmVBcyhwcmVzZXROYW1lKTtcbiAgICB9XG4gIH0pO1xuICBkb20uYmluZChidXR0b24zLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgZ3VpLnJldmVydCgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZFJlc2l6ZUhhbmRsZShndWkpIHtcbiAgdmFyIHBtb3VzZVggPSB2b2lkIDA7XG4gIGd1aS5fX3Jlc2l6ZV9oYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgQ29tbW9uLmV4dGVuZChndWkuX19yZXNpemVfaGFuZGxlLnN0eWxlLCB7XG4gICAgd2lkdGg6ICc2cHgnLFxuICAgIG1hcmdpbkxlZnQ6ICctM3B4JyxcbiAgICBoZWlnaHQ6ICcyMDBweCcsXG4gICAgY3Vyc29yOiAnZXctcmVzaXplJyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICB9KTtcbiAgZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGd1aS53aWR0aCArPSBwbW91c2VYIC0gZS5jbGllbnRYO1xuICAgIGd1aS5vblJlc2l6ZSgpO1xuICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGRyYWdTdG9wKCkge1xuICAgIGRvbS5yZW1vdmVDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuICB9XG4gIGZ1bmN0aW9uIGRyYWdTdGFydChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgZG9tLmFkZENsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZG9tLmJpbmQoZ3VpLl9fcmVzaXplX2hhbmRsZSwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gIGRvbS5iaW5kKGd1aS5fX2Nsb3NlQnV0dG9uLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcbiAgZ3VpLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsIGd1aS5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcbn1cbmZ1bmN0aW9uIHNldFdpZHRoKGd1aSwgdykge1xuICBndWkuZG9tRWxlbWVudC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICBpZiAoZ3VpLl9fc2F2ZV9yb3cgJiYgZ3VpLmF1dG9QbGFjZSkge1xuICAgIGd1aS5fX3NhdmVfcm93LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIH1cbiAgaWYgKGd1aS5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgZ3VpLl9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFByZXNldChndWksIHVzZUluaXRpYWxWYWx1ZXMpIHtcbiAgdmFyIHRvUmV0dXJuID0ge307XG4gIENvbW1vbi5lYWNoKGd1aS5fX3JlbWVtYmVyZWRPYmplY3RzLCBmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgIHZhciBzYXZlZFZhbHVlcyA9IHt9O1xuICAgIHZhciBjb250cm9sbGVyTWFwID0gZ3VpLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW2luZGV4XTtcbiAgICBDb21tb24uZWFjaChjb250cm9sbGVyTWFwLCBmdW5jdGlvbiAoY29udHJvbGxlciwgcHJvcGVydHkpIHtcbiAgICAgIHNhdmVkVmFsdWVzW3Byb3BlcnR5XSA9IHVzZUluaXRpYWxWYWx1ZXMgPyBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA6IGNvbnRyb2xsZXIuZ2V0VmFsdWUoKTtcbiAgICB9KTtcbiAgICB0b1JldHVybltpbmRleF0gPSBzYXZlZFZhbHVlcztcbiAgfSk7XG4gIHJldHVybiB0b1JldHVybjtcbn1cbmZ1bmN0aW9uIHNldFByZXNldFNlbGVjdEluZGV4KGd1aSkge1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWUgPT09IGd1aS5wcmVzZXQpIHtcbiAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KSB7XG4gIGlmIChjb250cm9sbGVyQXJyYXkubGVuZ3RoICE9PSAwKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSk7XG4gICAgfSk7XG4gIH1cbiAgQ29tbW9uLmVhY2goY29udHJvbGxlckFycmF5LCBmdW5jdGlvbiAoYykge1xuICAgIGMudXBkYXRlRGlzcGxheSgpO1xuICB9KTtcbn1cblxudmFyIGNvbG9yID0ge1xuICBDb2xvcjogQ29sb3IsXG4gIG1hdGg6IENvbG9yTWF0aCxcbiAgaW50ZXJwcmV0OiBpbnRlcnByZXRcbn07XG52YXIgY29udHJvbGxlcnMgPSB7XG4gIENvbnRyb2xsZXI6IENvbnRyb2xsZXIsXG4gIEJvb2xlYW5Db250cm9sbGVyOiBCb29sZWFuQ29udHJvbGxlcixcbiAgT3B0aW9uQ29udHJvbGxlcjogT3B0aW9uQ29udHJvbGxlcixcbiAgU3RyaW5nQ29udHJvbGxlcjogU3RyaW5nQ29udHJvbGxlcixcbiAgTnVtYmVyQ29udHJvbGxlcjogTnVtYmVyQ29udHJvbGxlcixcbiAgTnVtYmVyQ29udHJvbGxlckJveDogTnVtYmVyQ29udHJvbGxlckJveCxcbiAgTnVtYmVyQ29udHJvbGxlclNsaWRlcjogTnVtYmVyQ29udHJvbGxlclNsaWRlcixcbiAgRnVuY3Rpb25Db250cm9sbGVyOiBGdW5jdGlvbkNvbnRyb2xsZXIsXG4gIENvbG9yQ29udHJvbGxlcjogQ29sb3JDb250cm9sbGVyXG59O1xudmFyIGRvbSQxID0geyBkb206IGRvbSB9O1xudmFyIGd1aSA9IHsgR1VJOiBHVUkgfTtcbnZhciBHVUkkMSA9IEdVSTtcbnZhciBpbmRleCA9IHtcbiAgY29sb3I6IGNvbG9yLFxuICBjb250cm9sbGVyczogY29udHJvbGxlcnMsXG4gIGRvbTogZG9tJDEsXG4gIGd1aTogZ3VpLFxuICBHVUk6IEdVSSQxXG59O1xuXG5leHBvcnRzLmNvbG9yID0gY29sb3I7XG5leHBvcnRzLmNvbnRyb2xsZXJzID0gY29udHJvbGxlcnM7XG5leHBvcnRzLmRvbSA9IGRvbSQxO1xuZXhwb3J0cy5ndWkgPSBndWk7XG5leHBvcnRzLkdVSSA9IEdVSSQxO1xuZXhwb3J0c1snZGVmYXVsdCddID0gaW5kZXg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXQuZ3VpLmpzLm1hcFxuIiwiLyogaW50ZXJhY3QuanMgMS45LjggfCBodHRwczovL3Jhdy5naXRodWIuY29tL3RheWUvaW50ZXJhY3QuanMvbWFzdGVyL0xJQ0VOU0UgKi9cbiFmdW5jdGlvbih0KXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz10KCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLHQpO2Vsc2V7KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcykuaW50ZXJhY3Q9dCgpfX0oZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe3ZhciBuO3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gbnx8ZShuPXtleHBvcnRzOnt9LHBhcmVudDp0fSxuLmV4cG9ydHMpLG4uZXhwb3J0c319dmFyIGs9dChmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGEodCl7cmV0dXJuKGE9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD1lLkludGVyYWN0YWJsZT12b2lkIDA7dmFyIHU9cihTKSxsPW4oQykscz1uKFYpLGM9bihjdCksZj1yKHcpLHA9bihmdCksaT1uKGJ0KSxkPW0oe30pO2Z1bmN0aW9uIG4odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIHYoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiB2PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gcih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1hKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPXYoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn1mdW5jdGlvbiBvKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiB5KHQsZSxuKXtyZXR1cm4gZSYmbyh0LnByb3RvdHlwZSxlKSxuJiZvKHQsbiksdH1mdW5jdGlvbiBoKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgZz1mdW5jdGlvbigpe2Z1bmN0aW9uIG8odCxlLG4scil7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxvKSx0aGlzLl9zY29wZUV2ZW50cz1yLGgodGhpcyxcIm9wdGlvbnNcIix2b2lkIDApLGgodGhpcyxcIl9hY3Rpb25zXCIsdm9pZCAwKSxoKHRoaXMsXCJ0YXJnZXRcIix2b2lkIDApLGgodGhpcyxcImV2ZW50c1wiLG5ldyBpLmRlZmF1bHQpLGgodGhpcyxcIl9jb250ZXh0XCIsdm9pZCAwKSxoKHRoaXMsXCJfd2luXCIsdm9pZCAwKSxoKHRoaXMsXCJfZG9jXCIsdm9pZCAwKSx0aGlzLl9hY3Rpb25zPWUuYWN0aW9ucyx0aGlzLnRhcmdldD10LHRoaXMuX2NvbnRleHQ9ZS5jb250ZXh0fHxuLHRoaXMuX3dpbj0oMCxPLmdldFdpbmRvdykoKDAsJC50cnlTZWxlY3RvcikodCk/dGhpcy5fY29udGV4dDp0KSx0aGlzLl9kb2M9dGhpcy5fd2luLmRvY3VtZW50LHRoaXMuc2V0KGUpfXJldHVybiB5KG8sW3trZXk6XCJfZGVmYXVsdHNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm57YmFzZTp7fSxwZXJBY3Rpb246e30sYWN0aW9uczp7fX19fV0pLHkobyxbe2tleTpcInNldE9uRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZi5mdW5jKGUub25zdGFydCkmJnRoaXMub24oXCJcIi5jb25jYXQodCxcInN0YXJ0XCIpLGUub25zdGFydCksZi5mdW5jKGUub25tb3ZlKSYmdGhpcy5vbihcIlwiLmNvbmNhdCh0LFwibW92ZVwiKSxlLm9ubW92ZSksZi5mdW5jKGUub25lbmQpJiZ0aGlzLm9uKFwiXCIuY29uY2F0KHQsXCJlbmRcIiksZS5vbmVuZCksZi5mdW5jKGUub25pbmVydGlhc3RhcnQpJiZ0aGlzLm9uKFwiXCIuY29uY2F0KHQsXCJpbmVydGlhc3RhcnRcIiksZS5vbmluZXJ0aWFzdGFydCksdGhpc319LHtrZXk6XCJ1cGRhdGVQZXJBY3Rpb25MaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7KGYuYXJyYXkoZSl8fGYub2JqZWN0KGUpKSYmdGhpcy5vZmYodCxlKSwoZi5hcnJheShuKXx8Zi5vYmplY3QobikpJiZ0aGlzLm9uKHQsbil9fSx7a2V5Olwic2V0UGVyQWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9kZWZhdWx0cztmb3IodmFyIHIgaW4gZSl7dmFyIG89cixpPXRoaXMub3B0aW9uc1t0XSxhPWVbb107XCJsaXN0ZW5lcnNcIj09PW8mJnRoaXMudXBkYXRlUGVyQWN0aW9uTGlzdGVuZXJzKHQsaS5saXN0ZW5lcnMsYSksZi5hcnJheShhKT9pW29dPXUuZnJvbShhKTpmLnBsYWluT2JqZWN0KGEpPyhpW29dPSgwLGMuZGVmYXVsdCkoaVtvXXx8e30sKDAscy5kZWZhdWx0KShhKSksZi5vYmplY3Qobi5wZXJBY3Rpb25bb10pJiZcImVuYWJsZWRcImluIG4ucGVyQWN0aW9uW29dJiYoaVtvXS5lbmFibGVkPSExIT09YS5lbmFibGVkKSk6Zi5ib29sKGEpJiZmLm9iamVjdChuLnBlckFjdGlvbltvXSk/aVtvXS5lbmFibGVkPWE6aVtvXT1hfX19LHtrZXk6XCJnZXRSZWN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9dHx8KGYuZWxlbWVudCh0aGlzLnRhcmdldCk/dGhpcy50YXJnZXQ6bnVsbCksZi5zdHJpbmcodGhpcy50YXJnZXQpJiYodD10fHx0aGlzLl9jb250ZXh0LnF1ZXJ5U2VsZWN0b3IodGhpcy50YXJnZXQpKSwoMCwkLmdldEVsZW1lbnRSZWN0KSh0KX19LHtrZXk6XCJyZWN0Q2hlY2tlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBmLmZ1bmModCk/KHRoaXMuZ2V0UmVjdD10LHRoaXMpOm51bGw9PT10PyhkZWxldGUgdGhpcy5nZXRSZWN0LHRoaXMpOnRoaXMuZ2V0UmVjdH19LHtrZXk6XCJfYmFja0NvbXBhdE9wdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoKDAsJC50cnlTZWxlY3RvcikoZSl8fGYub2JqZWN0KGUpKXtmb3IodmFyIG4gaW4gdGhpcy5vcHRpb25zW3RdPWUsdGhpcy5fYWN0aW9ucy5tYXApdGhpcy5vcHRpb25zW25dW3RdPWU7cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMub3B0aW9uc1t0XX19LHtrZXk6XCJvcmlnaW5cIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYmFja0NvbXBhdE9wdGlvbihcIm9yaWdpblwiLHQpfX0se2tleTpcImRlbHRhU291cmNlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuXCJwYWdlXCI9PT10fHxcImNsaWVudFwiPT09dD8odGhpcy5vcHRpb25zLmRlbHRhU291cmNlPXQsdGhpcyk6dGhpcy5vcHRpb25zLmRlbHRhU291cmNlfX0se2tleTpcImNvbnRleHRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250ZXh0fX0se2tleTpcImluQ29udGV4dFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jb250ZXh0PT09dC5vd25lckRvY3VtZW50fHwoMCwkLm5vZGVDb250YWlucykodGhpcy5fY29udGV4dCx0KX19LHtrZXk6XCJ0ZXN0SWdub3JlQWxsb3dcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIXRoaXMudGVzdElnbm9yZSh0Lmlnbm9yZUZyb20sZSxuKSYmdGhpcy50ZXN0QWxsb3codC5hbGxvd0Zyb20sZSxuKX19LHtrZXk6XCJ0ZXN0QWxsb3dcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIXR8fCEhZi5lbGVtZW50KG4pJiYoZi5zdHJpbmcodCk/KDAsJC5tYXRjaGVzVXBUbykobix0LGUpOiEhZi5lbGVtZW50KHQpJiYoMCwkLm5vZGVDb250YWlucykodCxuKSl9fSx7a2V5OlwidGVzdElnbm9yZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4hKCF0fHwhZi5lbGVtZW50KG4pKSYmKGYuc3RyaW5nKHQpPygwLCQubWF0Y2hlc1VwVG8pKG4sdCxlKTohIWYuZWxlbWVudCh0KSYmKDAsJC5ub2RlQ29udGFpbnMpKHQsbikpfX0se2tleTpcImZpcmVcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ldmVudHMuZmlyZSh0KSx0aGlzfX0se2tleTpcIl9vbk9mZlwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIpe2Yub2JqZWN0KGUpJiYhZi5hcnJheShlKSYmKHI9bixuPW51bGwpO3ZhciBvPVwib25cIj09PXQ/XCJhZGRcIjpcInJlbW92ZVwiLGk9KDAscC5kZWZhdWx0KShlLG4pO2Zvcih2YXIgYSBpbiBpKXtcIndoZWVsXCI9PT1hJiYoYT1sLmRlZmF1bHQud2hlZWxFdmVudCk7Zm9yKHZhciB1PTA7dTxpW2FdLmxlbmd0aDt1Kyspe3ZhciBzPWlbYV1bdV07KDAsZC5pc05vbk5hdGl2ZUV2ZW50KShhLHRoaXMuX2FjdGlvbnMpP3RoaXMuZXZlbnRzW3RdKGEscyk6Zi5zdHJpbmcodGhpcy50YXJnZXQpP3RoaXMuX3Njb3BlRXZlbnRzW1wiXCIuY29uY2F0KG8sXCJEZWxlZ2F0ZVwiKV0odGhpcy50YXJnZXQsdGhpcy5fY29udGV4dCxhLHMscik6dGhpcy5fc2NvcGVFdmVudHNbb10odGhpcy50YXJnZXQsYSxzLHIpfX1yZXR1cm4gdGhpc319LHtrZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5fb25PZmYoXCJvblwiLHQsZSxuKX19LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuX29uT2ZmKFwib2ZmXCIsdCxlLG4pfX0se2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2RlZmF1bHRzO2Zvcih2YXIgbiBpbiBmLm9iamVjdCh0KXx8KHQ9e30pLHRoaXMub3B0aW9ucz0oMCxzLmRlZmF1bHQpKGUuYmFzZSksdGhpcy5fYWN0aW9ucy5tZXRob2REaWN0KXt2YXIgcj1uLG89dGhpcy5fYWN0aW9ucy5tZXRob2REaWN0W3JdO3RoaXMub3B0aW9uc1tyXT17fSx0aGlzLnNldFBlckFjdGlvbihyLCgwLGMuZGVmYXVsdCkoKDAsYy5kZWZhdWx0KSh7fSxlLnBlckFjdGlvbiksZS5hY3Rpb25zW3JdKSksdGhpc1tvXSh0W3JdKX1mb3IodmFyIGkgaW4gdClmLmZ1bmModGhpc1tpXSkmJnRoaXNbaV0odFtpXSk7cmV0dXJuIHRoaXN9fSx7a2V5OlwidW5zZXRcIix2YWx1ZTpmdW5jdGlvbigpe2lmKGYuc3RyaW5nKHRoaXMudGFyZ2V0KSlmb3IodmFyIHQgaW4gdGhpcy5fc2NvcGVFdmVudHMuZGVsZWdhdGVkRXZlbnRzKWZvcih2YXIgZT10aGlzLl9zY29wZUV2ZW50cy5kZWxlZ2F0ZWRFdmVudHNbdF0sbj1lLmxlbmd0aC0xOzA8PW47bi0tKXt2YXIgcj1lW25dLG89ci5zZWxlY3RvcixpPXIuY29udGV4dCxhPXIubGlzdGVuZXJzO289PT10aGlzLnRhcmdldCYmaT09PXRoaXMuX2NvbnRleHQmJmUuc3BsaWNlKG4sMSk7Zm9yKHZhciB1PWEubGVuZ3RoLTE7MDw9dTt1LS0pdGhpcy5fc2NvcGVFdmVudHMucmVtb3ZlRGVsZWdhdGUodGhpcy50YXJnZXQsdGhpcy5fY29udGV4dCx0LGFbdV1bMF0sYVt1XVsxXSl9ZWxzZSB0aGlzLl9zY29wZUV2ZW50cy5yZW1vdmUodGhpcy50YXJnZXQsXCJhbGxcIil9fV0pLG99KCksYj1lLkludGVyYWN0YWJsZT1nO2UuZGVmYXVsdD1ifSksbT10KGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5pc05vbk5hdGl2ZUV2ZW50PWZ1bmN0aW9uKHQsZSl7aWYoZS5waGFzZWxlc3NUeXBlc1t0XSlyZXR1cm4hMDtmb3IodmFyIG4gaW4gZS5tYXApaWYoMD09PXQuaW5kZXhPZihuKSYmdC5zdWJzdHIobi5sZW5ndGgpaW4gZS5waGFzZXMpcmV0dXJuITA7cmV0dXJuITF9LGUuaW5pdFNjb3BlPU0sZS5TY29wZT1lLmRlZmF1bHQ9dm9pZCAwO3ZhciBuPWQoRCkscj1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT12KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPXAoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0obGUpLG89ZChidCksaT1kKFdlKSxhPWQoVCh7fSkpLHU9ZChrKHt9KSkscz1kKFplKSxsPWQoemUpLGM9ZChjbiksZj1kKEUoe30pKTtmdW5jdGlvbiBwKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gcD1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIGQodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIHYodCl7cmV0dXJuKHY9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIHkodCxlKXtyZXR1cm4hZXx8XCJvYmplY3RcIiE9PXYoZSkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dClyZXR1cm4gdDt0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIil9KHQpOmV9ZnVuY3Rpb24gaCh0LGUsbil7cmV0dXJuKGg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuZ2V0P1JlZmxlY3QuZ2V0OmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1mdW5jdGlvbih0LGUpe2Zvcig7IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpJiZudWxsIT09KHQ9Zyh0KSk7KTtyZXR1cm4gdH0odCxlKTtpZihyKXt2YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7cmV0dXJuIG8uZ2V0P28uZ2V0LmNhbGwobik6by52YWx1ZX19KSh0LGUsbnx8dCl9ZnVuY3Rpb24gZyh0KXtyZXR1cm4oZz1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSkodCl9ZnVuY3Rpb24gYih0LGUpe3JldHVybihiPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX1mdW5jdGlvbiBtKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBPKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiB3KHQsZSxuKXtyZXR1cm4gZSYmTyh0LnByb3RvdHlwZSxlKSxuJiZPKHQsbiksdH1mdW5jdGlvbiBfKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgUD1yLndpbix4PXIuYnJvd3NlcixTPXIucmFmLGo9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dmFyIGU9dGhpczttKHRoaXMsdCksXyh0aGlzLFwiaWRcIixcIl9faW50ZXJhY3Rfc2NvcGVfXCIuY29uY2F0KE1hdGguZmxvb3IoMTAwKk1hdGgucmFuZG9tKCkpKSksXyh0aGlzLFwiaXNJbml0aWFsaXplZFwiLCExKSxfKHRoaXMsXCJsaXN0ZW5lck1hcHNcIixbXSksXyh0aGlzLFwiYnJvd3NlclwiLHgpLF8odGhpcyxcInV0aWxzXCIsciksXyh0aGlzLFwiZGVmYXVsdHNcIixyLmNsb25lKGwuZGVmYXVsdCkpLF8odGhpcyxcIkV2ZW50YWJsZVwiLG8uZGVmYXVsdCksXyh0aGlzLFwiYWN0aW9uc1wiLHttYXA6e30scGhhc2VzOntzdGFydDohMCxtb3ZlOiEwLGVuZDohMH0sbWV0aG9kRGljdDp7fSxwaGFzZWxlc3NUeXBlczp7fX0pLF8odGhpcyxcImludGVyYWN0U3RhdGljXCIsbmV3IGEuZGVmYXVsdCh0aGlzKSksXyh0aGlzLFwiSW50ZXJhY3RFdmVudFwiLGkuZGVmYXVsdCksXyh0aGlzLFwiSW50ZXJhY3RhYmxlXCIsdm9pZCAwKSxfKHRoaXMsXCJpbnRlcmFjdGFibGVzXCIsbmV3IHMuZGVmYXVsdCh0aGlzKSksXyh0aGlzLFwiX3dpblwiLHZvaWQgMCksXyh0aGlzLFwiZG9jdW1lbnRcIix2b2lkIDApLF8odGhpcyxcIndpbmRvd1wiLHZvaWQgMCksXyh0aGlzLFwiZG9jdW1lbnRzXCIsW10pLF8odGhpcyxcIl9wbHVnaW5zXCIse2xpc3Q6W10sbWFwOnt9fSksXyh0aGlzLFwib25XaW5kb3dVbmxvYWRcIixmdW5jdGlvbih0KXtyZXR1cm4gZS5yZW1vdmVEb2N1bWVudCh0LnRhcmdldCl9KTt2YXIgbj10aGlzO3RoaXMuSW50ZXJhY3RhYmxlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3JldHVybiBtKHRoaXMsZSkseSh0aGlzLGcoZSkuYXBwbHkodGhpcyxhcmd1bWVudHMpKX1yZXR1cm4gZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJmIodCxlKX0oZSx1W1wiZGVmYXVsdFwiXSksdyhlLFt7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGgoZyhlLnByb3RvdHlwZSksXCJzZXRcIix0aGlzKS5jYWxsKHRoaXMsdCksbi5maXJlKFwiaW50ZXJhY3RhYmxlOnNldFwiLHtvcHRpb25zOnQsaW50ZXJhY3RhYmxlOnRoaXN9KSx0aGlzfX0se2tleTpcInVuc2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtoKGcoZS5wcm90b3R5cGUpLFwidW5zZXRcIix0aGlzKS5jYWxsKHRoaXMpLG4uaW50ZXJhY3RhYmxlcy5saXN0LnNwbGljZShuLmludGVyYWN0YWJsZXMubGlzdC5pbmRleE9mKHRoaXMpLDEpLG4uZmlyZShcImludGVyYWN0YWJsZTp1bnNldFwiLHtpbnRlcmFjdGFibGU6dGhpc30pfX0se2tleTpcIl9kZWZhdWx0c1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBuLmRlZmF1bHRzfX1dKSxlfSgpfXJldHVybiB3KHQsW3trZXk6XCJhZGRMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3RoaXMubGlzdGVuZXJNYXBzLnB1c2goe2lkOmUsbWFwOnR9KX19LHtrZXk6XCJmaXJlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHRoaXMubGlzdGVuZXJNYXBzLmxlbmd0aDtuKyspe3ZhciByPXRoaXMubGlzdGVuZXJNYXBzW25dLm1hcFt0XTtpZihyJiYhMT09PXIoZSx0aGlzLHQpKXJldHVybiExfX19LHtrZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNJbml0aWFsaXplZD90aGlzOk0odGhpcyx0KX19LHtrZXk6XCJwbHVnaW5Jc0luc3RhbGxlZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wbHVnaW5zLm1hcFt0LmlkXXx8LTEhPT10aGlzLl9wbHVnaW5zLmxpc3QuaW5kZXhPZih0KX19LHtrZXk6XCJ1c2VQbHVnaW5cIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKHRoaXMucGx1Z2luSXNJbnN0YWxsZWQodCkpcmV0dXJuIHRoaXM7aWYodC5pZCYmKHRoaXMuX3BsdWdpbnMubWFwW3QuaWRdPXQpLHRoaXMuX3BsdWdpbnMubGlzdC5wdXNoKHQpLHQuaW5zdGFsbCYmdC5pbnN0YWxsKHRoaXMsZSksdC5saXN0ZW5lcnMmJnQuYmVmb3JlKXtmb3IodmFyIG49MCxyPXRoaXMubGlzdGVuZXJNYXBzLmxlbmd0aCxvPXQuYmVmb3JlLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0W2VdPSEwLHR9LHt9KTtuPHI7bisrKXtpZihvW3RoaXMubGlzdGVuZXJNYXBzW25dLmlkXSlicmVha310aGlzLmxpc3RlbmVyTWFwcy5zcGxpY2UobiwwLHtpZDp0LmlkLG1hcDp0Lmxpc3RlbmVyc30pfWVsc2UgdC5saXN0ZW5lcnMmJnRoaXMubGlzdGVuZXJNYXBzLnB1c2goe2lkOnQuaWQsbWFwOnQubGlzdGVuZXJzfSk7cmV0dXJuIHRoaXN9fSx7a2V5OlwiYWRkRG9jdW1lbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKC0xIT09dGhpcy5nZXREb2NJbmRleCh0KSlyZXR1cm4hMTt2YXIgbj1QLmdldFdpbmRvdyh0KTtlPWU/ci5leHRlbmQoe30sZSk6e30sdGhpcy5kb2N1bWVudHMucHVzaCh7ZG9jOnQsb3B0aW9uczplfSksdGhpcy5ldmVudHMuZG9jdW1lbnRzLnB1c2godCksdCE9PXRoaXMuZG9jdW1lbnQmJnRoaXMuZXZlbnRzLmFkZChuLFwidW5sb2FkXCIsdGhpcy5vbldpbmRvd1VubG9hZCksdGhpcy5maXJlKFwic2NvcGU6YWRkLWRvY3VtZW50XCIse2RvYzp0LHdpbmRvdzpuLHNjb3BlOnRoaXMsb3B0aW9uczplfSl9fSx7a2V5OlwicmVtb3ZlRG9jdW1lbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldERvY0luZGV4KHQpLG49UC5nZXRXaW5kb3codCkscj10aGlzLmRvY3VtZW50c1tlXS5vcHRpb25zO3RoaXMuZXZlbnRzLnJlbW92ZShuLFwidW5sb2FkXCIsdGhpcy5vbldpbmRvd1VubG9hZCksdGhpcy5kb2N1bWVudHMuc3BsaWNlKGUsMSksdGhpcy5ldmVudHMuZG9jdW1lbnRzLnNwbGljZShlLDEpLHRoaXMuZmlyZShcInNjb3BlOnJlbW92ZS1kb2N1bWVudFwiLHtkb2M6dCx3aW5kb3c6bixzY29wZTp0aGlzLG9wdGlvbnM6cn0pfX0se2tleTpcImdldERvY0luZGV4XCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmRvY3VtZW50cy5sZW5ndGg7ZSsrKWlmKHRoaXMuZG9jdW1lbnRzW2VdLmRvYz09PXQpcmV0dXJuIGU7cmV0dXJuLTF9fSx7a2V5OlwiZ2V0RG9jT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0RG9jSW5kZXgodCk7cmV0dXJuLTE9PT1lP251bGw6dGhpcy5kb2N1bWVudHNbZV0ub3B0aW9uc319LHtrZXk6XCJub3dcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybih0aGlzLndpbmRvdy5EYXRlfHxEYXRlKS5ub3coKX19XSksdH0oKTtmdW5jdGlvbiBNKHQsZSl7cmV0dXJuIHQuaXNJbml0aWFsaXplZD0hMCxQLmluaXQoZSksbi5kZWZhdWx0LmluaXQoZSkseC5pbml0KGUpLFMuaW5pdChlKSx0LndpbmRvdz1lLHQuZG9jdW1lbnQ9ZS5kb2N1bWVudCx0LnVzZVBsdWdpbihmLmRlZmF1bHQpLHQudXNlUGx1Z2luKGMuZGVmYXVsdCksdH1lLlNjb3BlPWUuZGVmYXVsdD1qfSksRT10KGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PXZvaWQgMDt2YXIgXz1uKEMpLHU9bihEKSxQPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWModCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9YSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh6dCkscz1uKEVuKSxsPW4oVW4pLG89bih0cik7bihtKHt9KSk7ZnVuY3Rpb24gYSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIGE9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBuKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBjKHQpe3JldHVybihjPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiB4KHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHR9KHQpfHxmdW5jdGlvbih0LGUpe2lmKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkpcmV0dXJuO3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHU9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7cnx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufSh0LGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfWZ1bmN0aW9uIGYodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIHAodCxlKXtyZXR1cm4hZXx8XCJvYmplY3RcIiE9PWMoZSkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dClyZXR1cm4gdDt0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIil9KHQpOmV9ZnVuY3Rpb24gZCh0KXtyZXR1cm4oZD1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSkodCl9ZnVuY3Rpb24gdih0LGUpe3JldHVybih2PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX12YXIgeT1bXCJwb2ludGVyRG93blwiLFwicG9pbnRlck1vdmVcIixcInBvaW50ZXJVcFwiLFwidXBkYXRlUG9pbnRlclwiLFwicmVtb3ZlUG9pbnRlclwiLFwid2luZG93Qmx1clwiXTtmdW5jdGlvbiBoKE8sdyl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXcuaW50ZXJhY3Rpb25zLmxpc3Qsbj1QLmdldFBvaW50ZXJUeXBlKHQpLHI9eChQLmdldEV2ZW50VGFyZ2V0cyh0KSwyKSxvPXJbMF0saT1yWzFdLGE9W107aWYoL150b3VjaC8udGVzdCh0LnR5cGUpKXt3LnByZXZUb3VjaFRpbWU9dy5ub3coKTtmb3IodmFyIHU9MDt1PHQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoO3UrKyl7cz10LmNoYW5nZWRUb3VjaGVzW3VdO3ZhciBzLGw9e3BvaW50ZXI6cyxwb2ludGVySWQ6UC5nZXRQb2ludGVySWQocykscG9pbnRlclR5cGU6bixldmVudFR5cGU6dC50eXBlLGV2ZW50VGFyZ2V0Om8sY3VyRXZlbnRUYXJnZXQ6aSxzY29wZTp3fSxjPVMobCk7YS5wdXNoKFtsLnBvaW50ZXIsbC5ldmVudFRhcmdldCxsLmN1ckV2ZW50VGFyZ2V0LGNdKX19ZWxzZXt2YXIgZj0hMTtpZighXy5kZWZhdWx0LnN1cHBvcnRzUG9pbnRlckV2ZW50JiYvbW91c2UvLnRlc3QodC50eXBlKSl7Zm9yKHZhciBwPTA7cDxlLmxlbmd0aCYmIWY7cCsrKWY9XCJtb3VzZVwiIT09ZVtwXS5wb2ludGVyVHlwZSYmZVtwXS5wb2ludGVySXNEb3duO2Y9Znx8dy5ub3coKS13LnByZXZUb3VjaFRpbWU8NTAwfHwwPT09dC50aW1lU3RhbXB9aWYoIWYpe3ZhciBkPXtwb2ludGVyOnQscG9pbnRlcklkOlAuZ2V0UG9pbnRlcklkKHQpLHBvaW50ZXJUeXBlOm4sZXZlbnRUeXBlOnQudHlwZSxjdXJFdmVudFRhcmdldDppLGV2ZW50VGFyZ2V0Om8sc2NvcGU6d30sdj1TKGQpO2EucHVzaChbZC5wb2ludGVyLGQuZXZlbnRUYXJnZXQsZC5jdXJFdmVudFRhcmdldCx2XSl9fWZvcih2YXIgeT0wO3k8YS5sZW5ndGg7eSsrKXt2YXIgaD14KGFbeV0sNCksZz1oWzBdLGI9aFsxXSxtPWhbMl07aFszXVtPXShnLHQsYixtKX19fWZ1bmN0aW9uIFModCl7dmFyIGU9dC5wb2ludGVyVHlwZSxuPXQuc2NvcGUscj17aW50ZXJhY3Rpb246by5kZWZhdWx0LnNlYXJjaCh0KSxzZWFyY2hEZXRhaWxzOnR9O3JldHVybiBuLmZpcmUoXCJpbnRlcmFjdGlvbnM6ZmluZFwiLHIpLHIuaW50ZXJhY3Rpb258fG4uaW50ZXJhY3Rpb25zLm5ldyh7cG9pbnRlclR5cGU6ZX0pfWZ1bmN0aW9uIHIodCxlKXt2YXIgbj10LmRvYyxyPXQuc2NvcGUsbz10Lm9wdGlvbnMsaT1yLmludGVyYWN0aW9ucy5kb2NFdmVudHMsYT1yLmV2ZW50cyx1PWFbZV07Zm9yKHZhciBzIGluIHIuYnJvd3Nlci5pc0lPUyYmIW8uZXZlbnRzJiYoby5ldmVudHM9e3Bhc3NpdmU6ITF9KSxhLmRlbGVnYXRlZEV2ZW50cyl1KG4scyxhLmRlbGVnYXRlTGlzdGVuZXIpLHUobixzLGEuZGVsZWdhdGVVc2VDYXB0dXJlLCEwKTtmb3IodmFyIGw9byYmby5ldmVudHMsYz0wO2M8aS5sZW5ndGg7YysrKXt2YXIgZjtmPWlbY107dShuLGYudHlwZSxmLmxpc3RlbmVyLGwpfX12YXIgaT17aWQ6XCJjb3JlL2ludGVyYWN0aW9uc1wiLGluc3RhbGw6ZnVuY3Rpb24obyl7Zm9yKHZhciB0PXt9LGU9MDtlPHkubGVuZ3RoO2UrKyl7dmFyIG47bj15W2VdO3Rbbl09aChuLG8pfXZhciByLGk9Xy5kZWZhdWx0LnBFdmVudFR5cGVzO2Z1bmN0aW9uIGEoKXtmb3IodmFyIHQ9MDt0PG8uaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO3QrKyl7dmFyIGU9by5pbnRlcmFjdGlvbnMubGlzdFt0XTtpZihlLnBvaW50ZXJJc0Rvd24mJlwidG91Y2hcIj09PWUucG9pbnRlclR5cGUmJiFlLl9pbnRlcmFjdGluZylmb3IodmFyIG49ZnVuY3Rpb24oKXt2YXIgbj1lLnBvaW50ZXJzW3JdO28uZG9jdW1lbnRzLnNvbWUoZnVuY3Rpb24odCl7dmFyIGU9dC5kb2M7cmV0dXJuKDAsJC5ub2RlQ29udGFpbnMpKGUsbi5kb3duVGFyZ2V0KX0pfHxlLnJlbW92ZVBvaW50ZXIobi5wb2ludGVyLG4uZXZlbnQpfSxyPTA7cjxlLnBvaW50ZXJzLmxlbmd0aDtyKyspe24oKX19fShyPXUuZGVmYXVsdC5Qb2ludGVyRXZlbnQ/W3t0eXBlOmkuZG93bixsaXN0ZW5lcjphfSx7dHlwZTppLmRvd24sbGlzdGVuZXI6dC5wb2ludGVyRG93bn0se3R5cGU6aS5tb3ZlLGxpc3RlbmVyOnQucG9pbnRlck1vdmV9LHt0eXBlOmkudXAsbGlzdGVuZXI6dC5wb2ludGVyVXB9LHt0eXBlOmkuY2FuY2VsLGxpc3RlbmVyOnQucG9pbnRlclVwfV06W3t0eXBlOlwibW91c2Vkb3duXCIsbGlzdGVuZXI6dC5wb2ludGVyRG93bn0se3R5cGU6XCJtb3VzZW1vdmVcIixsaXN0ZW5lcjp0LnBvaW50ZXJNb3ZlfSx7dHlwZTpcIm1vdXNldXBcIixsaXN0ZW5lcjp0LnBvaW50ZXJVcH0se3R5cGU6XCJ0b3VjaHN0YXJ0XCIsbGlzdGVuZXI6YX0se3R5cGU6XCJ0b3VjaHN0YXJ0XCIsbGlzdGVuZXI6dC5wb2ludGVyRG93bn0se3R5cGU6XCJ0b3VjaG1vdmVcIixsaXN0ZW5lcjp0LnBvaW50ZXJNb3ZlfSx7dHlwZTpcInRvdWNoZW5kXCIsbGlzdGVuZXI6dC5wb2ludGVyVXB9LHt0eXBlOlwidG91Y2hjYW5jZWxcIixsaXN0ZW5lcjp0LnBvaW50ZXJVcH1dKS5wdXNoKHt0eXBlOlwiYmx1clwiLGxpc3RlbmVyOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8by5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7ZSsrKXtvLmludGVyYWN0aW9ucy5saXN0W2VdLmRvY3VtZW50Qmx1cih0KX19fSksby5wcmV2VG91Y2hUaW1lPTAsby5JbnRlcmFjdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHQpLHAodGhpcyxkKHQpLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9dmFyIGUsbixyO3JldHVybiBmdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmdih0LGUpfSh0LHNbXCJkZWZhdWx0XCJdKSxlPXQsKG49W3trZXk6XCJfbm93XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gby5ub3coKX19LHtrZXk6XCJwb2ludGVyTW92ZVRvbGVyYW5jZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBvLmludGVyYWN0aW9ucy5wb2ludGVyTW92ZVRvbGVyYW5jZX0sc2V0OmZ1bmN0aW9uKHQpe28uaW50ZXJhY3Rpb25zLnBvaW50ZXJNb3ZlVG9sZXJhbmNlPXR9fV0pJiZmKGUucHJvdG90eXBlLG4pLHImJmYoZSxyKSx0fSgpLG8uaW50ZXJhY3Rpb25zPXtsaXN0OltdLG5ldzpmdW5jdGlvbih0KXt0LnNjb3BlRmlyZT1mdW5jdGlvbih0LGUpe3JldHVybiBvLmZpcmUodCxlKX07dmFyIGU9bmV3IG8uSW50ZXJhY3Rpb24odCk7cmV0dXJuIG8uaW50ZXJhY3Rpb25zLmxpc3QucHVzaChlKSxlfSxsaXN0ZW5lcnM6dCxkb2NFdmVudHM6cixwb2ludGVyTW92ZVRvbGVyYW5jZToxfSxvLnVzZVBsdWdpbihsLmRlZmF1bHQpfSxsaXN0ZW5lcnM6e1wic2NvcGU6YWRkLWRvY3VtZW50XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHIodCxcImFkZFwiKX0sXCJzY29wZTpyZW1vdmUtZG9jdW1lbnRcIjpmdW5jdGlvbih0KXtyZXR1cm4gcih0LFwicmVtb3ZlXCIpfSxcImludGVyYWN0YWJsZTp1bnNldFwiOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuaW50ZXJhY3RhYmxlLHI9ZS5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGgtMTswPD1yO3ItLSl7dmFyIG89ZS5pbnRlcmFjdGlvbnMubGlzdFtyXTtvLmludGVyYWN0YWJsZT09PW4mJihvLnN0b3AoKSxlLmZpcmUoXCJpbnRlcmFjdGlvbnM6ZGVzdHJveVwiLHtpbnRlcmFjdGlvbjpvfSksby5kZXN0cm95KCksMjxlLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aCYmZS5pbnRlcmFjdGlvbnMubGlzdC5zcGxpY2UociwxKSl9fX0sb25Eb2NTaWduYWw6cixkb09uSW50ZXJhY3Rpb25zOmgsbWV0aG9kTmFtZXM6eX07ZS5kZWZhdWx0PWl9KSxUPXQoZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBhKHQpe3JldHVybihhPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9ZS5JbnRlcmFjdFN0YXRpYz12b2lkIDA7dmFyIG4scj0obj1DKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0sdT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1hKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPWwoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0obGUpLHM9bSh7fSk7ZnVuY3Rpb24gbCgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIGw9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBvKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBjKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEocil7dmFyIG89dGhpczshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGEpLHRoaXMuc2NvcGU9cixjKHRoaXMsXCJnZXRQb2ludGVyQXZlcmFnZVwiLHUucG9pbnRlci5wb2ludGVyQXZlcmFnZSksYyh0aGlzLFwiZ2V0VG91Y2hCQm94XCIsdS5wb2ludGVyLnRvdWNoQkJveCksYyh0aGlzLFwiZ2V0VG91Y2hEaXN0YW5jZVwiLHUucG9pbnRlci50b3VjaERpc3RhbmNlKSxjKHRoaXMsXCJnZXRUb3VjaEFuZ2xlXCIsdS5wb2ludGVyLnRvdWNoQW5nbGUpLGModGhpcyxcImdldEVsZW1lbnRSZWN0XCIsdS5kb20uZ2V0RWxlbWVudFJlY3QpLGModGhpcyxcImdldEVsZW1lbnRDbGllbnRSZWN0XCIsdS5kb20uZ2V0RWxlbWVudENsaWVudFJlY3QpLGModGhpcyxcIm1hdGNoZXNTZWxlY3RvclwiLHUuZG9tLm1hdGNoZXNTZWxlY3RvciksYyh0aGlzLFwiY2xvc2VzdFwiLHUuZG9tLmNsb3Nlc3QpLGModGhpcyxcImdsb2JhbEV2ZW50c1wiLHt9KSxjKHRoaXMsXCJkeW5hbWljRHJvcFwiLHZvaWQgMCksYyh0aGlzLFwidmVyc2lvblwiLFwiMS45LjhcIiksYyh0aGlzLFwiaW50ZXJhY3RcIix2b2lkIDApO2Zvcih2YXIgdD10aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxlPWZ1bmN0aW9uKHQsZSl7dmFyIG49ci5pbnRlcmFjdGFibGVzLmdldCh0LGUpO3JldHVybiBufHwoKG49ci5pbnRlcmFjdGFibGVzLm5ldyh0LGUpKS5ldmVudHMuZ2xvYmFsPW8uZ2xvYmFsRXZlbnRzKSxufSxuPTA7bjxPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSkubGVuZ3RoO24rKyl7dmFyIGk7aT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSlbbl07ZVtpXT10W2ldfXJldHVybiB1LmV4dGVuZChlLHRoaXMpLGUuY29uc3RydWN0b3I9dGhpcy5jb25zdHJ1Y3Rvcix0aGlzLmludGVyYWN0PWV9dmFyIHQsZSxuO3JldHVybiB0PWEsKGU9W3trZXk6XCJ1c2VcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnNjb3BlLnVzZVBsdWdpbih0LGUpLHRoaXN9fSx7a2V5OlwiaXNTZXRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiEhdGhpcy5zY29wZS5pbnRlcmFjdGFibGVzLmdldCh0LGUmJmUuY29udGV4dCl9fSx7a2V5Olwib25cIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7aWYodS5pcy5zdHJpbmcodCkmJi0xIT09dC5zZWFyY2goXCIgXCIpJiYodD10LnRyaW0oKS5zcGxpdCgvICsvKSksdS5pcy5hcnJheSh0KSl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBvPXRbcl07dGhpcy5vbihvLGUsbil9cmV0dXJuIHRoaXN9aWYodS5pcy5vYmplY3QodCkpe2Zvcih2YXIgaSBpbiB0KXRoaXMub24oaSx0W2ldLGUpO3JldHVybiB0aGlzfXJldHVybigwLHMuaXNOb25OYXRpdmVFdmVudCkodCx0aGlzLnNjb3BlLmFjdGlvbnMpP3RoaXMuZ2xvYmFsRXZlbnRzW3RdP3RoaXMuZ2xvYmFsRXZlbnRzW3RdLnB1c2goZSk6dGhpcy5nbG9iYWxFdmVudHNbdF09W2VdOnRoaXMuc2NvcGUuZXZlbnRzLmFkZCh0aGlzLnNjb3BlLmRvY3VtZW50LHQsZSx7b3B0aW9uczpufSksdGhpc319LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7aWYodS5pcy5zdHJpbmcodCkmJi0xIT09dC5zZWFyY2goXCIgXCIpJiYodD10LnRyaW0oKS5zcGxpdCgvICsvKSksdS5pcy5hcnJheSh0KSl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBvPXRbcl07dGhpcy5vZmYobyxlLG4pfXJldHVybiB0aGlzfWlmKHUuaXMub2JqZWN0KHQpKXtmb3IodmFyIGkgaW4gdCl0aGlzLm9mZihpLHRbaV0sZSk7cmV0dXJuIHRoaXN9dmFyIGE7KDAscy5pc05vbk5hdGl2ZUV2ZW50KSh0LHRoaXMuc2NvcGUuYWN0aW9ucyk/dCBpbiB0aGlzLmdsb2JhbEV2ZW50cyYmLTEhPT0oYT10aGlzLmdsb2JhbEV2ZW50c1t0XS5pbmRleE9mKGUpKSYmdGhpcy5nbG9iYWxFdmVudHNbdF0uc3BsaWNlKGEsMSk6dGhpcy5zY29wZS5ldmVudHMucmVtb3ZlKHRoaXMuc2NvcGUuZG9jdW1lbnQsdCxlLG4pO3JldHVybiB0aGlzfX0se2tleTpcImRlYnVnXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zY29wZX19LHtrZXk6XCJzdXBwb3J0c1RvdWNoXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0LnN1cHBvcnRzVG91Y2h9fSx7a2V5Olwic3VwcG9ydHNQb2ludGVyRXZlbnRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuc3VwcG9ydHNQb2ludGVyRXZlbnR9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLnNjb3BlLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDt0Kyspe3RoaXMuc2NvcGUuaW50ZXJhY3Rpb25zLmxpc3RbdF0uc3RvcCgpfXJldHVybiB0aGlzfX0se2tleTpcInBvaW50ZXJNb3ZlVG9sZXJhbmNlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHUuaXMubnVtYmVyKHQpPyh0aGlzLnNjb3BlLmludGVyYWN0aW9ucy5wb2ludGVyTW92ZVRvbGVyYW5jZT10LHRoaXMpOnRoaXMuc2NvcGUuaW50ZXJhY3Rpb25zLnBvaW50ZXJNb3ZlVG9sZXJhbmNlfX0se2tleTpcImFkZERvY3VtZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLnNjb3BlLmFkZERvY3VtZW50KHQsZSl9fSx7a2V5OlwicmVtb3ZlRG9jdW1lbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnNjb3BlLnJlbW92ZURvY3VtZW50KHQpfX1dKSYmbyh0LnByb3RvdHlwZSxlKSxuJiZvKHQsbiksYX0oKSxmPWUuSW50ZXJhY3RTdGF0aWM9aTtlLmRlZmF1bHQ9Zn0pLGU9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PXZvaWQgMDtlLmRlZmF1bHQ9ZnVuY3Rpb24odCl7cmV0dXJuISghdHx8IXQuV2luZG93KSYmdCBpbnN0YW5jZW9mIHQuV2luZG93fTt2YXIgTz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPLmluaXQ9aSxPLmdldFdpbmRvdz1hLE8uZGVmYXVsdD12b2lkIDA7dmFyIG4scj0obj1lKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07dmFyIG89e3JlYWxXaW5kb3c6dm9pZCAwLHdpbmRvdzp2b2lkIDAsZ2V0V2luZG93OmEsaW5pdDppfTtmdW5jdGlvbiBpKHQpe3ZhciBlPShvLnJlYWxXaW5kb3c9dCkuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7ZS5vd25lckRvY3VtZW50IT09dC5kb2N1bWVudCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC53cmFwJiZ0LndyYXAoZSk9PT1lJiYodD10LndyYXAodCkpLG8ud2luZG93PXR9ZnVuY3Rpb24gYSh0KXtyZXR1cm4oMCxyLmRlZmF1bHQpKHQpP3Q6KHQub3duZXJEb2N1bWVudHx8dCkuZGVmYXVsdFZpZXd8fG8ud2luZG93fVwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3c/KG8ud2luZG93PXZvaWQgMCxvLnJlYWxXaW5kb3c9dm9pZCAwKTppKHdpbmRvdyksby5pbml0PWk7dmFyIHU9bztPLmRlZmF1bHQ9dTt2YXIgdz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx3LmFycmF5PXcucGxhaW5PYmplY3Q9dy5lbGVtZW50PXcuc3RyaW5nPXcuYm9vbD13Lm51bWJlcj13LmZ1bmM9dy5vYmplY3Q9dy5kb2NGcmFnPXcud2luZG93PXZvaWQgMDt2YXIgcz1jKGUpLGw9YyhPKTtmdW5jdGlvbiBjKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBmKHQpe3JldHVybihmPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX13LndpbmRvdz1mdW5jdGlvbih0KXtyZXR1cm4gdD09PWwuZGVmYXVsdC53aW5kb3d8fCgwLHMuZGVmYXVsdCkodCl9O3cuZG9jRnJhZz1mdW5jdGlvbih0KXtyZXR1cm4gcCh0KSYmMTE9PT10Lm5vZGVUeXBlfTt2YXIgcD1mdW5jdGlvbih0KXtyZXR1cm4hIXQmJlwib2JqZWN0XCI9PT1mKHQpfTt3Lm9iamVjdD1wO2Z1bmN0aW9uIGQodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH13LmZ1bmM9ZDt3Lm51bWJlcj1mdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdH07dy5ib29sPWZ1bmN0aW9uKHQpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgdH07dy5zdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR9O3cuZWxlbWVudD1mdW5jdGlvbih0KXtpZighdHx8XCJvYmplY3RcIiE9PWYodCkpcmV0dXJuITE7dmFyIGU9bC5kZWZhdWx0LmdldFdpbmRvdyh0KXx8bC5kZWZhdWx0LndpbmRvdztyZXR1cm4vb2JqZWN0fGZ1bmN0aW9uLy50ZXN0KGYoZS5FbGVtZW50KSk/dCBpbnN0YW5jZW9mIGUuRWxlbWVudDoxPT09dC5ub2RlVHlwZSYmXCJzdHJpbmdcIj09dHlwZW9mIHQubm9kZU5hbWV9O3cucGxhaW5PYmplY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHAodCkmJiEhdC5jb25zdHJ1Y3RvciYmL2Z1bmN0aW9uIE9iamVjdFxcYi8udGVzdCh0LmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkpfTt3LmFycmF5PWZ1bmN0aW9uKHQpe3JldHVybiBwKHQpJiZ2b2lkIDAhPT10Lmxlbmd0aCYmZCh0LnNwbGljZSl9O3ZhciB2PXt9O2Z1bmN0aW9uIHkodCl7cmV0dXJuKHk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHYuZGVmYXVsdD12b2lkIDA7dmFyIGg9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09eSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1nKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHcpO2Z1bmN0aW9uIGcoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBnPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gYih0KXt2YXIgZT10LmludGVyYWN0aW9uO2lmKFwiZHJhZ1wiPT09ZS5wcmVwYXJlZC5uYW1lKXt2YXIgbj1lLnByZXBhcmVkLmF4aXM7XCJ4XCI9PT1uPyhlLmNvb3Jkcy5jdXIucGFnZS55PWUuY29vcmRzLnN0YXJ0LnBhZ2UueSxlLmNvb3Jkcy5jdXIuY2xpZW50Lnk9ZS5jb29yZHMuc3RhcnQuY2xpZW50LnksZS5jb29yZHMudmVsb2NpdHkuY2xpZW50Lnk9MCxlLmNvb3Jkcy52ZWxvY2l0eS5wYWdlLnk9MCk6XCJ5XCI9PT1uJiYoZS5jb29yZHMuY3VyLnBhZ2UueD1lLmNvb3Jkcy5zdGFydC5wYWdlLngsZS5jb29yZHMuY3VyLmNsaWVudC54PWUuY29vcmRzLnN0YXJ0LmNsaWVudC54LGUuY29vcmRzLnZlbG9jaXR5LmNsaWVudC54PTAsZS5jb29yZHMudmVsb2NpdHkucGFnZS54PTApfX1mdW5jdGlvbiBfKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbjtpZihcImRyYWdcIj09PW4ucHJlcGFyZWQubmFtZSl7dmFyIHI9bi5wcmVwYXJlZC5heGlzO2lmKFwieFwiPT09cnx8XCJ5XCI9PT1yKXt2YXIgbz1cInhcIj09PXI/XCJ5XCI6XCJ4XCI7ZS5wYWdlW29dPW4uY29vcmRzLnN0YXJ0LnBhZ2Vbb10sZS5jbGllbnRbb109bi5jb29yZHMuc3RhcnQuY2xpZW50W29dLGUuZGVsdGFbb109MH19fXZhciBQPXtpZDpcImFjdGlvbnMvZHJhZ1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5hY3Rpb25zLG49dC5JbnRlcmFjdGFibGUscj10LmRlZmF1bHRzO24ucHJvdG90eXBlLmRyYWdnYWJsZT1QLmRyYWdnYWJsZSxlLm1hcC5kcmFnPVAsZS5tZXRob2REaWN0LmRyYWc9XCJkcmFnZ2FibGVcIixyLmFjdGlvbnMuZHJhZz1QLmRlZmF1bHRzfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tbW92ZVwiOmIsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLXJlc3VtZVwiOmIsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpfLFwiYXV0by1zdGFydDpjaGVja1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmludGVyYWN0YWJsZSxyPXQuYnV0dG9ucyxvPW4ub3B0aW9ucy5kcmFnO2lmKG8mJm8uZW5hYmxlZCYmKCFlLnBvaW50ZXJJc0Rvd258fCEvbW91c2V8cG9pbnRlci8udGVzdChlLnBvaW50ZXJUeXBlKXx8MCE9KHImbi5vcHRpb25zLmRyYWcubW91c2VCdXR0b25zKSkpcmV0dXJuISh0LmFjdGlvbj17bmFtZTpcImRyYWdcIixheGlzOlwic3RhcnRcIj09PW8ubG9ja0F4aXM/by5zdGFydEF4aXM6by5sb2NrQXhpc30pfX0sZHJhZ2dhYmxlOmZ1bmN0aW9uKHQpe3JldHVybiBoLm9iamVjdCh0KT8odGhpcy5vcHRpb25zLmRyYWcuZW5hYmxlZD0hMSE9PXQuZW5hYmxlZCx0aGlzLnNldFBlckFjdGlvbihcImRyYWdcIix0KSx0aGlzLnNldE9uRXZlbnRzKFwiZHJhZ1wiLHQpLC9eKHh5fHh8eXxzdGFydCkkLy50ZXN0KHQubG9ja0F4aXMpJiYodGhpcy5vcHRpb25zLmRyYWcubG9ja0F4aXM9dC5sb2NrQXhpcyksL14oeHl8eHx5KSQvLnRlc3QodC5zdGFydEF4aXMpJiYodGhpcy5vcHRpb25zLmRyYWcuc3RhcnRBeGlzPXQuc3RhcnRBeGlzKSx0aGlzKTpoLmJvb2wodCk/KHRoaXMub3B0aW9ucy5kcmFnLmVuYWJsZWQ9dCx0aGlzKTp0aGlzLm9wdGlvbnMuZHJhZ30sYmVmb3JlTW92ZTpiLG1vdmU6XyxkZWZhdWx0czp7c3RhcnRBeGlzOlwieHlcIixsb2NrQXhpczpcInh5XCJ9LGdldEN1cnNvcjpmdW5jdGlvbigpe3JldHVyblwibW92ZVwifX0seD1QO3YuZGVmYXVsdD14O3ZhciBTPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShTLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFMuZmluZD1TLmZpbmRJbmRleD1TLmZyb209Uy5tZXJnZT1TLnJlbW92ZT1TLmNvbnRhaW5zPXZvaWQgMDtTLmNvbnRhaW5zPWZ1bmN0aW9uKHQsZSl7cmV0dXJuLTEhPT10LmluZGV4T2YoZSl9O1MucmVtb3ZlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuc3BsaWNlKHQuaW5kZXhPZihlKSwxKX07ZnVuY3Rpb24gaih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3QucHVzaChyKX1yZXR1cm4gdH1TLm1lcmdlPWo7Uy5mcm9tPWZ1bmN0aW9uKHQpe3JldHVybiBqKFtdLHQpfTtmdW5jdGlvbiBNKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoZSh0W25dLG4sdCkpcmV0dXJuIG47cmV0dXJuLTF9Uy5maW5kSW5kZXg9TTtTLmZpbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtNKHQsZSldfTt2YXIgRD17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxELmRlZmF1bHQ9dm9pZCAwO3ZhciBJPXtpbml0OmZ1bmN0aW9uKHQpe3ZhciBlPXQ7SS5kb2N1bWVudD1lLmRvY3VtZW50LEkuRG9jdW1lbnRGcmFnbWVudD1lLkRvY3VtZW50RnJhZ21lbnR8fHosSS5TVkdFbGVtZW50PWUuU1ZHRWxlbWVudHx8eixJLlNWR1NWR0VsZW1lbnQ9ZS5TVkdTVkdFbGVtZW50fHx6LEkuU1ZHRWxlbWVudEluc3RhbmNlPWUuU1ZHRWxlbWVudEluc3RhbmNlfHx6LEkuRWxlbWVudD1lLkVsZW1lbnR8fHosSS5IVE1MRWxlbWVudD1lLkhUTUxFbGVtZW50fHxJLkVsZW1lbnQsSS5FdmVudD1lLkV2ZW50LEkuVG91Y2g9ZS5Ub3VjaHx8eixJLlBvaW50ZXJFdmVudD1lLlBvaW50ZXJFdmVudHx8ZS5NU1BvaW50ZXJFdmVudH0sZG9jdW1lbnQ6bnVsbCxEb2N1bWVudEZyYWdtZW50Om51bGwsU1ZHRWxlbWVudDpudWxsLFNWR1NWR0VsZW1lbnQ6bnVsbCxTVkdFbGVtZW50SW5zdGFuY2U6bnVsbCxFbGVtZW50Om51bGwsSFRNTEVsZW1lbnQ6bnVsbCxFdmVudDpudWxsLFRvdWNoOm51bGwsUG9pbnRlckV2ZW50Om51bGx9O2Z1bmN0aW9uIHooKXt9dmFyIEE9STtELmRlZmF1bHQ9QTt2YXIgQz17fTtmdW5jdGlvbiBXKHQpe3JldHVybihXPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxDLmRlZmF1bHQ9dm9pZCAwO3ZhciBSPU4oRCksRj1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1XKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPVkoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0odyksWD1OKE8pO2Z1bmN0aW9uIFkoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBZPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gTih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19dmFyIEw9e2luaXQ6ZnVuY3Rpb24odCl7dmFyIGU9Ui5kZWZhdWx0LkVsZW1lbnQsbj1YLmRlZmF1bHQud2luZG93Lm5hdmlnYXRvcjtMLnN1cHBvcnRzVG91Y2g9XCJvbnRvdWNoc3RhcnRcImluIHR8fEYuZnVuYyh0LkRvY3VtZW50VG91Y2gpJiZSLmRlZmF1bHQuZG9jdW1lbnQgaW5zdGFuY2VvZiB0LkRvY3VtZW50VG91Y2gsTC5zdXBwb3J0c1BvaW50ZXJFdmVudD0hMSE9PW4ucG9pbnRlckVuYWJsZWQmJiEhUi5kZWZhdWx0LlBvaW50ZXJFdmVudCxMLmlzSU9TPS9pUChob25lfG9kfGFkKS8udGVzdChuLnBsYXRmb3JtKSxMLmlzSU9TNz0vaVAoaG9uZXxvZHxhZCkvLnRlc3Qobi5wbGF0Zm9ybSkmJi9PUyA3W15cXGRdLy50ZXN0KG4uYXBwVmVyc2lvbiksTC5pc0llOT0vTVNJRSA5Ly50ZXN0KG4udXNlckFnZW50KSxMLmlzT3BlcmFNb2JpbGU9XCJPcGVyYVwiPT09bi5hcHBOYW1lJiZMLnN1cHBvcnRzVG91Y2gmJi9QcmVzdG8vLnRlc3Qobi51c2VyQWdlbnQpLEwucHJlZml4ZWRNYXRjaGVzU2VsZWN0b3I9XCJtYXRjaGVzXCJpbiBlLnByb3RvdHlwZT9cIm1hdGNoZXNcIjpcIndlYmtpdE1hdGNoZXNTZWxlY3RvclwiaW4gZS5wcm90b3R5cGU/XCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3JcIjpcIm1vek1hdGNoZXNTZWxlY3RvclwiaW4gZS5wcm90b3R5cGU/XCJtb3pNYXRjaGVzU2VsZWN0b3JcIjpcIm9NYXRjaGVzU2VsZWN0b3JcImluIGUucHJvdG90eXBlP1wib01hdGNoZXNTZWxlY3RvclwiOlwibXNNYXRjaGVzU2VsZWN0b3JcIixMLnBFdmVudFR5cGVzPUwuc3VwcG9ydHNQb2ludGVyRXZlbnQ/Ui5kZWZhdWx0LlBvaW50ZXJFdmVudD09PXQuTVNQb2ludGVyRXZlbnQ/e3VwOlwiTVNQb2ludGVyVXBcIixkb3duOlwiTVNQb2ludGVyRG93blwiLG92ZXI6XCJtb3VzZW92ZXJcIixvdXQ6XCJtb3VzZW91dFwiLG1vdmU6XCJNU1BvaW50ZXJNb3ZlXCIsY2FuY2VsOlwiTVNQb2ludGVyQ2FuY2VsXCJ9Ont1cDpcInBvaW50ZXJ1cFwiLGRvd246XCJwb2ludGVyZG93blwiLG92ZXI6XCJwb2ludGVyb3ZlclwiLG91dDpcInBvaW50ZXJvdXRcIixtb3ZlOlwicG9pbnRlcm1vdmVcIixjYW5jZWw6XCJwb2ludGVyY2FuY2VsXCJ9Om51bGwsTC53aGVlbEV2ZW50PVwib25tb3VzZXdoZWVsXCJpbiBSLmRlZmF1bHQuZG9jdW1lbnQ/XCJtb3VzZXdoZWVsXCI6XCJ3aGVlbFwifSxzdXBwb3J0c1RvdWNoOm51bGwsc3VwcG9ydHNQb2ludGVyRXZlbnQ6bnVsbCxpc0lPUzc6bnVsbCxpc0lPUzpudWxsLGlzSWU5Om51bGwsaXNPcGVyYU1vYmlsZTpudWxsLHByZWZpeGVkTWF0Y2hlc1NlbGVjdG9yOm51bGwscEV2ZW50VHlwZXM6bnVsbCx3aGVlbEV2ZW50Om51bGx9O3ZhciBCPUw7Qy5kZWZhdWx0PUI7dmFyIFY9e307ZnVuY3Rpb24gcSh0KXtyZXR1cm4ocT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KFYsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksVi5kZWZhdWx0PWZ1bmN0aW9uIHQoZSl7dmFyIG49e307Zm9yKHZhciByIGluIGUpe3ZhciBvPWVbcl07Ry5wbGFpbk9iamVjdChvKT9uW3JdPXQobyk6Ry5hcnJheShvKT9uW3JdPVUuZnJvbShvKTpuW3JdPW99cmV0dXJuIG59O3ZhciBVPUsoUyksRz1LKHcpO2Z1bmN0aW9uIEgoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBIPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gSyh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1xKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUgoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn12YXIgJD17fTtmdW5jdGlvbiBaKHQpe3JldHVybihaPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoJCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSwkLm5vZGVDb250YWlucz1mdW5jdGlvbih0LGUpe2Zvcig7ZTspe2lmKGU9PT10KXJldHVybiEwO2U9ZS5wYXJlbnROb2RlfXJldHVybiExfSwkLmNsb3Nlc3Q9ZnVuY3Rpb24odCxlKXtmb3IoO3R0LmVsZW1lbnQodCk7KXtpZihhdCh0LGUpKXJldHVybiB0O3Q9aXQodCl9cmV0dXJuIG51bGx9LCQucGFyZW50Tm9kZT1pdCwkLm1hdGNoZXNTZWxlY3Rvcj1hdCwkLmluZGV4T2ZEZWVwZXN0RWxlbWVudD1mdW5jdGlvbih0KXt2YXIgZSxuLHI9W10sbz10WzBdLGk9bz8wOi0xO2ZvcihlPTE7ZTx0Lmxlbmd0aDtlKyspe3ZhciBhPXRbZV07aWYoYSYmYSE9PW8paWYobyl7aWYoYS5wYXJlbnROb2RlIT09YS5vd25lckRvY3VtZW50KWlmKG8ucGFyZW50Tm9kZSE9PWEub3duZXJEb2N1bWVudClpZihhLnBhcmVudE5vZGUhPT1vLnBhcmVudE5vZGUpe2lmKCFyLmxlbmd0aClmb3IodmFyIHU9byxzPXZvaWQgMDsocz11dCh1KSkmJnMhPT11Lm93bmVyRG9jdW1lbnQ7KXIudW5zaGlmdCh1KSx1PXM7dmFyIGw9dm9pZCAwO2lmKG8gaW5zdGFuY2VvZiBRLmRlZmF1bHQuSFRNTEVsZW1lbnQmJmEgaW5zdGFuY2VvZiBRLmRlZmF1bHQuU1ZHRWxlbWVudCYmIShhIGluc3RhbmNlb2YgUS5kZWZhdWx0LlNWR1NWR0VsZW1lbnQpKXtpZihhPT09by5wYXJlbnROb2RlKWNvbnRpbnVlO2w9YS5vd25lclNWR0VsZW1lbnR9ZWxzZSBsPWE7Zm9yKHZhciBjPVtdO2wucGFyZW50Tm9kZSE9PWwub3duZXJEb2N1bWVudDspYy51bnNoaWZ0KGwpLGw9dXQobCk7Zm9yKG49MDtjW25dJiZjW25dPT09cltuXTspbisrO2Zvcih2YXIgZj1bY1tuLTFdLGNbbl0scltuXV0scD1mWzBdLmxhc3RDaGlsZDtwOyl7aWYocD09PWZbMV0pe289YSxpPWUscj1jO2JyZWFrfWlmKHA9PT1mWzJdKWJyZWFrO3A9cC5wcmV2aW91c1NpYmxpbmd9fWVsc2V7dmFyIGQ9cGFyc2VJbnQoKDAsZXQuZ2V0V2luZG93KShvKS5nZXRDb21wdXRlZFN0eWxlKG8pLnpJbmRleCwxMCl8fDAsdj1wYXJzZUludCgoMCxldC5nZXRXaW5kb3cpKGEpLmdldENvbXB1dGVkU3R5bGUoYSkuekluZGV4LDEwKXx8MDtkPD12JiYobz1hLGk9ZSl9ZWxzZSBvPWEsaT1lfWVsc2Ugbz1hLGk9ZX1yZXR1cm4gaX0sJC5tYXRjaGVzVXBUbz1mdW5jdGlvbih0LGUsbil7Zm9yKDt0dC5lbGVtZW50KHQpOyl7aWYoYXQodCxlKSlyZXR1cm4hMDtpZigodD1pdCh0KSk9PT1uKXJldHVybiBhdCh0LGUpfXJldHVybiExfSwkLmdldEFjdHVhbEVsZW1lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBRLmRlZmF1bHQuU1ZHRWxlbWVudEluc3RhbmNlP3QuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ6dH0sJC5nZXRTY3JvbGxYWT1zdCwkLmdldEVsZW1lbnRDbGllbnRSZWN0PWx0LCQuZ2V0RWxlbWVudFJlY3Q9ZnVuY3Rpb24odCl7dmFyIGU9bHQodCk7aWYoIUouZGVmYXVsdC5pc0lPUzcmJmUpe3ZhciBuPXN0KGV0LmRlZmF1bHQuZ2V0V2luZG93KHQpKTtlLmxlZnQrPW4ueCxlLnJpZ2h0Kz1uLngsZS50b3ArPW4ueSxlLmJvdHRvbSs9bi55fXJldHVybiBlfSwkLmdldFBhdGg9ZnVuY3Rpb24odCl7dmFyIGU9W107Zm9yKDt0OyllLnB1c2godCksdD1pdCh0KTtyZXR1cm4gZX0sJC50cnlTZWxlY3Rvcj1mdW5jdGlvbih0KXtyZXR1cm4hIXR0LnN0cmluZyh0KSYmKFEuZGVmYXVsdC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpLCEwKX07dmFyIEo9b3QoQyksUT1vdChEKSx0dD1ydCh3KSxldD1ydChPKTtmdW5jdGlvbiBudCgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIG50PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gcnQodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09Wih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1udCgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufWZ1bmN0aW9uIG90KHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBpdCh0KXt2YXIgZT10LnBhcmVudE5vZGU7aWYodHQuZG9jRnJhZyhlKSl7Zm9yKDsoZT1lLmhvc3QpJiZ0dC5kb2NGcmFnKGUpOyk7cmV0dXJuIGV9cmV0dXJuIGV9ZnVuY3Rpb24gYXQodCxlKXtyZXR1cm4gZXQuZGVmYXVsdC53aW5kb3chPT1ldC5kZWZhdWx0LnJlYWxXaW5kb3cmJihlPWUucmVwbGFjZSgvXFwvZGVlcFxcLy9nLFwiIFwiKSksdFtKLmRlZmF1bHQucHJlZml4ZWRNYXRjaGVzU2VsZWN0b3JdKGUpfXZhciB1dD1mdW5jdGlvbih0KXtyZXR1cm4gdC5wYXJlbnROb2RlP3QucGFyZW50Tm9kZTp0Lmhvc3R9O2Z1bmN0aW9uIHN0KHQpe3JldHVybnt4Oih0PXR8fGV0LmRlZmF1bHQud2luZG93KS5zY3JvbGxYfHx0LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LHk6dC5zY3JvbGxZfHx0LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B9fWZ1bmN0aW9uIGx0KHQpe3ZhciBlPXQgaW5zdGFuY2VvZiBRLmRlZmF1bHQuU1ZHRWxlbWVudD90LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOnQuZ2V0Q2xpZW50UmVjdHMoKVswXTtyZXR1cm4gZSYme2xlZnQ6ZS5sZWZ0LHJpZ2h0OmUucmlnaHQsdG9wOmUudG9wLGJvdHRvbTplLmJvdHRvbSx3aWR0aDplLndpZHRofHxlLnJpZ2h0LWUubGVmdCxoZWlnaHQ6ZS5oZWlnaHR8fGUuYm90dG9tLWUudG9wfX12YXIgY3Q9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KGN0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGN0LmRlZmF1bHQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSl0W25dPWVbbl07cmV0dXJuIHR9O3ZhciBmdD17fTtmdW5jdGlvbiBwdCh0KXtyZXR1cm4ocHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxmdC5kZWZhdWx0PWZ1bmN0aW9uIG4oZSxyLG8pe289b3x8e307eXQuc3RyaW5nKGUpJiYtMSE9PWUuc2VhcmNoKFwiIFwiKSYmKGU9Z3QoZSkpO2lmKHl0LmFycmF5KGUpKXJldHVybiBlLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybigwLHZ0LmRlZmF1bHQpKHQsbihlLHIsbykpfSxvKTt5dC5vYmplY3QoZSkmJihyPWUsZT1cIlwiKTtpZih5dC5mdW5jKHIpKW9bZV09b1tlXXx8W10sb1tlXS5wdXNoKHIpO2Vsc2UgaWYoeXQuYXJyYXkocikpZm9yKHZhciB0PTA7dDxyLmxlbmd0aDt0Kyspe3ZhciBpPXJbdF07bihlLGksbyl9ZWxzZSBpZih5dC5vYmplY3QocikpZm9yKHZhciBhIGluIHIpe3ZhciB1PWd0KGEpLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cIlwiLmNvbmNhdChlKS5jb25jYXQodCl9KTtuKHUsclthXSxvKX1yZXR1cm4gb307dmFyIGR0LHZ0PShkdD1jdCkmJmR0Ll9fZXNNb2R1bGU/ZHQ6e2RlZmF1bHQ6ZHR9LHl0PWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PXB0KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPWh0KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHcpO2Z1bmN0aW9uIGh0KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBndCh0KXtyZXR1cm4gdC50cmltKCkuc3BsaXQoLyArLyl9dmFyIGJ0PXt9O2Z1bmN0aW9uIG10KHQpe3JldHVybihtdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGJ0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGJ0LmRlZmF1bHQ9dm9pZCAwO3ZhciBPdD1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1tdCh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT14dCgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShTKSx3dD1QdChjdCksX3Q9UHQoZnQpO2Z1bmN0aW9uIFB0KHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiB4dCgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIHh0PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gU3QodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIGp0KHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH1mdW5jdGlvbiBNdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO2lmKHQuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKWJyZWFrO3IodCl9fXZhciBrdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSxqdCh0aGlzLFwib3B0aW9uc1wiLHZvaWQgMCksanQodGhpcyxcInR5cGVzXCIse30pLGp0KHRoaXMsXCJwcm9wYWdhdGlvblN0b3BwZWRcIiwhMSksanQodGhpcyxcImltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwiLCExKSxqdCh0aGlzLFwiZ2xvYmFsXCIsdm9pZCAwKSx0aGlzLm9wdGlvbnM9KDAsd3QuZGVmYXVsdCkoe30sdHx8e30pfXZhciB0LG4scjtyZXR1cm4gdD1lLChuPVt7a2V5OlwiZmlyZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcy5nbG9iYWw7KGU9dGhpcy50eXBlc1t0LnR5cGVdKSYmTXQodCxlKSwhdC5wcm9wYWdhdGlvblN0b3BwZWQmJm4mJihlPW5bdC50eXBlXSkmJk10KHQsZSl9fSx7a2V5Olwib25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPSgwLF90LmRlZmF1bHQpKHQsZSk7Zm9yKHQgaW4gbil0aGlzLnR5cGVzW3RdPU90Lm1lcmdlKHRoaXMudHlwZXNbdF18fFtdLG5bdF0pfX0se2tleTpcIm9mZlwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49KDAsX3QuZGVmYXVsdCkodCxlKTtmb3IodCBpbiBuKXt2YXIgcj10aGlzLnR5cGVzW3RdO2lmKHImJnIubGVuZ3RoKWZvcih2YXIgbz0wO288blt0XS5sZW5ndGg7bysrKXt2YXIgaT1uW3RdW29dLGE9ci5pbmRleE9mKGkpOy0xIT09YSYmci5zcGxpY2UoYSwxKX19fX0se2tleTpcImdldFJlY3RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBudWxsfX1dKSYmU3QodC5wcm90b3R5cGUsbiksciYmU3QodCxyKSxlfSgpO2J0LmRlZmF1bHQ9a3Q7dmFyIEV0PXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShFdCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxFdC5kZWZhdWx0PXZvaWQgMDtFdC5kZWZhdWx0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGguc3FydCh0KnQrZSplKX07dmFyIFR0PXt9O2Z1bmN0aW9uIER0KHQsZSl7Zm9yKHZhciBuIGluIGUpe3ZhciByPUR0LnByZWZpeGVkUHJvcFJFcyxvPSExO2Zvcih2YXIgaSBpbiByKWlmKDA9PT1uLmluZGV4T2YoaSkmJnJbaV0udGVzdChuKSl7bz0hMDticmVha31vfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlW25dfHwodFtuXT1lW25dKX1yZXR1cm4gdH1PYmplY3QuZGVmaW5lUHJvcGVydHkoVHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksVHQuZGVmYXVsdD12b2lkIDAsRHQucHJlZml4ZWRQcm9wUkVzPXt3ZWJraXQ6LyhNb3ZlbWVudFtYWV18UmFkaXVzW1hZXXxSb3RhdGlvbkFuZ2xlfEZvcmNlKSQvLG1vejovKFByZXNzdXJlKSQvfTt2YXIgSXQ9RHQ7VHQuZGVmYXVsdD1JdDt2YXIgenQ9e307ZnVuY3Rpb24gQXQodCl7cmV0dXJuKEF0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoenQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksenQuY29weUNvb3Jkcz1mdW5jdGlvbih0LGUpe3QucGFnZT10LnBhZ2V8fHt9LHQucGFnZS54PWUucGFnZS54LHQucGFnZS55PWUucGFnZS55LHQuY2xpZW50PXQuY2xpZW50fHx7fSx0LmNsaWVudC54PWUuY2xpZW50LngsdC5jbGllbnQueT1lLmNsaWVudC55LHQudGltZVN0YW1wPWUudGltZVN0YW1wfSx6dC5zZXRDb29yZERlbHRhcz1mdW5jdGlvbih0LGUsbil7dC5wYWdlLng9bi5wYWdlLngtZS5wYWdlLngsdC5wYWdlLnk9bi5wYWdlLnktZS5wYWdlLnksdC5jbGllbnQueD1uLmNsaWVudC54LWUuY2xpZW50LngsdC5jbGllbnQueT1uLmNsaWVudC55LWUuY2xpZW50LnksdC50aW1lU3RhbXA9bi50aW1lU3RhbXAtZS50aW1lU3RhbXB9LHp0LnNldENvb3JkVmVsb2NpdHk9ZnVuY3Rpb24odCxlKXt2YXIgbj1NYXRoLm1heChlLnRpbWVTdGFtcC8xZTMsLjAwMSk7dC5wYWdlLng9ZS5wYWdlLngvbix0LnBhZ2UueT1lLnBhZ2UueS9uLHQuY2xpZW50Lng9ZS5jbGllbnQueC9uLHQuY2xpZW50Lnk9ZS5jbGllbnQueS9uLHQudGltZVN0YW1wPW59LHp0LnNldFplcm9Db29yZHM9ZnVuY3Rpb24odCl7dC5wYWdlLng9MCx0LnBhZ2UueT0wLHQuY2xpZW50Lng9MCx0LmNsaWVudC55PTB9LHp0LmlzTmF0aXZlUG9pbnRlcj1WdCx6dC5nZXRYWT1xdCx6dC5nZXRQYWdlWFk9VXQsenQuZ2V0Q2xpZW50WFk9R3QsenQuZ2V0UG9pbnRlcklkPWZ1bmN0aW9uKHQpe3JldHVybiBYdC5udW1iZXIodC5wb2ludGVySWQpP3QucG9pbnRlcklkOnQuaWRlbnRpZmllcn0senQuc2V0Q29vcmRzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj0xPGUubGVuZ3RoP0t0KGUpOmVbMF0sbz17fTtVdChyLG8pLHQucGFnZS54PW8ueCx0LnBhZ2UueT1vLnksR3QocixvKSx0LmNsaWVudC54PW8ueCx0LmNsaWVudC55PW8ueSx0LnRpbWVTdGFtcD1ufSx6dC5nZXRUb3VjaFBhaXI9SHQsenQucG9pbnRlckF2ZXJhZ2U9S3QsenQudG91Y2hCQm94PWZ1bmN0aW9uKHQpe2lmKCEodC5sZW5ndGh8fHQudG91Y2hlcyYmMTx0LnRvdWNoZXMubGVuZ3RoKSlyZXR1cm4gbnVsbDt2YXIgZT1IdCh0KSxuPU1hdGgubWluKGVbMF0ucGFnZVgsZVsxXS5wYWdlWCkscj1NYXRoLm1pbihlWzBdLnBhZ2VZLGVbMV0ucGFnZVkpLG89TWF0aC5tYXgoZVswXS5wYWdlWCxlWzFdLnBhZ2VYKSxpPU1hdGgubWF4KGVbMF0ucGFnZVksZVsxXS5wYWdlWSk7cmV0dXJue3g6bix5OnIsbGVmdDpuLHRvcDpyLHJpZ2h0Om8sYm90dG9tOmksd2lkdGg6by1uLGhlaWdodDppLXJ9fSx6dC50b3VjaERpc3RhbmNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZStcIlhcIixyPWUrXCJZXCIsbz1IdCh0KSxpPW9bMF1bbl0tb1sxXVtuXSxhPW9bMF1bcl0tb1sxXVtyXTtyZXR1cm4oMCxGdC5kZWZhdWx0KShpLGEpfSx6dC50b3VjaEFuZ2xlPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZStcIlhcIixyPWUrXCJZXCIsbz1IdCh0KSxpPW9bMV1bbl0tb1swXVtuXSxhPW9bMV1bcl0tb1swXVtyXTtyZXR1cm4gMTgwKk1hdGguYXRhbjIoYSxpKS9NYXRoLlBJfSx6dC5nZXRQb2ludGVyVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4gWHQuc3RyaW5nKHQucG9pbnRlclR5cGUpP3QucG9pbnRlclR5cGU6WHQubnVtYmVyKHQucG9pbnRlclR5cGUpP1t2b2lkIDAsdm9pZCAwLFwidG91Y2hcIixcInBlblwiLFwibW91c2VcIl1bdC5wb2ludGVyVHlwZV06L3RvdWNoLy50ZXN0KHQudHlwZSl8fHQgaW5zdGFuY2VvZiBXdC5kZWZhdWx0LlRvdWNoP1widG91Y2hcIjpcIm1vdXNlXCJ9LHp0LmdldEV2ZW50VGFyZ2V0cz1mdW5jdGlvbih0KXt2YXIgZT1YdC5mdW5jKHQuY29tcG9zZWRQYXRoKT90LmNvbXBvc2VkUGF0aCgpOnQucGF0aDtyZXR1cm5bUnQuZ2V0QWN0dWFsRWxlbWVudChlP2VbMF06dC50YXJnZXQpLFJ0LmdldEFjdHVhbEVsZW1lbnQodC5jdXJyZW50VGFyZ2V0KV19LHp0Lm5ld0Nvb3Jkcz1mdW5jdGlvbigpe3JldHVybntwYWdlOnt4OjAseTowfSxjbGllbnQ6e3g6MCx5OjB9LHRpbWVTdGFtcDowfX0senQuY29vcmRzVG9FdmVudD1mdW5jdGlvbih0KXtyZXR1cm57Y29vcmRzOnQsZ2V0IHBhZ2UoKXtyZXR1cm4gdGhpcy5jb29yZHMucGFnZX0sZ2V0IGNsaWVudCgpe3JldHVybiB0aGlzLmNvb3Jkcy5jbGllbnR9LGdldCB0aW1lU3RhbXAoKXtyZXR1cm4gdGhpcy5jb29yZHMudGltZVN0YW1wfSxnZXQgcGFnZVgoKXtyZXR1cm4gdGhpcy5jb29yZHMucGFnZS54fSxnZXQgcGFnZVkoKXtyZXR1cm4gdGhpcy5jb29yZHMucGFnZS55fSxnZXQgY2xpZW50WCgpe3JldHVybiB0aGlzLmNvb3Jkcy5jbGllbnQueH0sZ2V0IGNsaWVudFkoKXtyZXR1cm4gdGhpcy5jb29yZHMuY2xpZW50Lnl9LGdldCBwb2ludGVySWQoKXtyZXR1cm4gdGhpcy5jb29yZHMucG9pbnRlcklkfSxnZXQgdGFyZ2V0KCl7cmV0dXJuIHRoaXMuY29vcmRzLnRhcmdldH0sZ2V0IHR5cGUoKXtyZXR1cm4gdGhpcy5jb29yZHMudHlwZX0sZ2V0IHBvaW50ZXJUeXBlKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBvaW50ZXJUeXBlfSxnZXQgYnV0dG9ucygpe3JldHVybiB0aGlzLmNvb3Jkcy5idXR0b25zfSxwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe319fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoenQsXCJwb2ludGVyRXh0ZW5kXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFl0LmRlZmF1bHR9fSk7dmFyIEN0PUJ0KEMpLFd0PUJ0KEQpLFJ0PUx0KCQpLEZ0PUJ0KEV0KSxYdD1MdCh3KSxZdD1CdChUdCk7ZnVuY3Rpb24gTnQoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBOdD1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIEx0KHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PUF0KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPU50KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59ZnVuY3Rpb24gQnQodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIFZ0KHQpe3JldHVybiB0IGluc3RhbmNlb2YgV3QuZGVmYXVsdC5FdmVudHx8dCBpbnN0YW5jZW9mIFd0LmRlZmF1bHQuVG91Y2h9ZnVuY3Rpb24gcXQodCxlLG4pe3JldHVybihuPW58fHt9KS54PWVbKHQ9dHx8XCJwYWdlXCIpK1wiWFwiXSxuLnk9ZVt0K1wiWVwiXSxufWZ1bmN0aW9uIFV0KHQsZSl7cmV0dXJuIGU9ZXx8e3g6MCx5OjB9LEN0LmRlZmF1bHQuaXNPcGVyYU1vYmlsZSYmVnQodCk/KHF0KFwic2NyZWVuXCIsdCxlKSxlLngrPXdpbmRvdy5zY3JvbGxYLGUueSs9d2luZG93LnNjcm9sbFkpOnF0KFwicGFnZVwiLHQsZSksZX1mdW5jdGlvbiBHdCh0LGUpe3JldHVybiBlPWV8fHt9LEN0LmRlZmF1bHQuaXNPcGVyYU1vYmlsZSYmVnQodCk/cXQoXCJzY3JlZW5cIix0LGUpOnF0KFwiY2xpZW50XCIsdCxlKSxlfWZ1bmN0aW9uIEh0KHQpe3ZhciBlPVtdO3JldHVybiBYdC5hcnJheSh0KT8oZVswXT10WzBdLGVbMV09dFsxXSk6XCJ0b3VjaGVuZFwiPT09dC50eXBlPzE9PT10LnRvdWNoZXMubGVuZ3RoPyhlWzBdPXQudG91Y2hlc1swXSxlWzFdPXQuY2hhbmdlZFRvdWNoZXNbMF0pOjA9PT10LnRvdWNoZXMubGVuZ3RoJiYoZVswXT10LmNoYW5nZWRUb3VjaGVzWzBdLGVbMV09dC5jaGFuZ2VkVG91Y2hlc1sxXSk6KGVbMF09dC50b3VjaGVzWzBdLGVbMV09dC50b3VjaGVzWzFdKSxlfWZ1bmN0aW9uIEt0KHQpe2Zvcih2YXIgZT17cGFnZVg6MCxwYWdlWTowLGNsaWVudFg6MCxjbGllbnRZOjAsc2NyZWVuWDowLHNjcmVlblk6MH0sbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO2Zvcih2YXIgbyBpbiBlKWVbb10rPXJbb119Zm9yKHZhciBpIGluIGUpZVtpXS89dC5sZW5ndGg7cmV0dXJuIGV9dmFyICR0PXt9O2Z1bmN0aW9uIFp0KHQpe3JldHVybihadD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KCR0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLCR0LmdldFN0cmluZ09wdGlvblJlc3VsdD1uZSwkdC5yZXNvbHZlUmVjdExpa2U9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dDt0ZS5zdHJpbmcobyk/bz1uZShvLGUsbik6dGUuZnVuYyhvKSYmKG89by5hcHBseSh2b2lkIDAsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpe2Zvcih2YXIgZT0wLG49bmV3IEFycmF5KHQubGVuZ3RoKTtlPHQubGVuZ3RoO2UrKyluW2VdPXRbZV07cmV0dXJuIG59fSh0KXx8ZnVuY3Rpb24odCl7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSlyZXR1cm4gQXJyYXkuZnJvbSh0KX0odCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfShyKSkpO3RlLmVsZW1lbnQobykmJihvPSgwLCQuZ2V0RWxlbWVudFJlY3QpKG8pKTtyZXR1cm4gb30sJHQucmVjdFRvWFk9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnt4OlwieFwiaW4gdD90Lng6dC5sZWZ0LHk6XCJ5XCJpbiB0P3QueTp0LnRvcH19LCR0Lnh5d2hUb1RsYnI9ZnVuY3Rpb24odCl7IXR8fFwibGVmdFwiaW4gdCYmXCJ0b3BcImluIHR8fCgodD0oMCxRdC5kZWZhdWx0KSh7fSx0KSkubGVmdD10Lnh8fDAsdC50b3A9dC55fHwwLHQucmlnaHQ9dC5yaWdodHx8dC5sZWZ0K3Qud2lkdGgsdC5ib3R0b209dC5ib3R0b218fHQudG9wK3QuaGVpZ2h0KTtyZXR1cm4gdH0sJHQudGxiclRvWHl3aD1mdW5jdGlvbih0KXshdHx8XCJ4XCJpbiB0JiZcInlcImluIHR8fCgodD0oMCxRdC5kZWZhdWx0KSh7fSx0KSkueD10LmxlZnR8fDAsdC55PXQudG9wfHwwLHQud2lkdGg9dC53aWR0aHx8dC5yaWdodHx8MC10LngsdC5oZWlnaHQ9dC5oZWlnaHR8fHQuYm90dG9tfHwwLXQueSk7cmV0dXJuIHR9LCR0LmFkZEVkZ2VzPWZ1bmN0aW9uKHQsZSxuKXt0LmxlZnQmJihlLmxlZnQrPW4ueCk7dC5yaWdodCYmKGUucmlnaHQrPW4ueCk7dC50b3AmJihlLnRvcCs9bi55KTt0LmJvdHRvbSYmKGUuYm90dG9tKz1uLnkpO2Uud2lkdGg9ZS5yaWdodC1lLmxlZnQsZS5oZWlnaHQ9ZS5ib3R0b20tZS50b3B9O3ZhciBKdCxRdD0oSnQ9Y3QpJiZKdC5fX2VzTW9kdWxlP0p0OntkZWZhdWx0Okp0fSx0ZT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1adCh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1lZSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh3KTtmdW5jdGlvbiBlZSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIGVlPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gbmUodCxlLG4pe3JldHVyblwicGFyZW50XCI9PT10PygwLCQucGFyZW50Tm9kZSkobik6XCJzZWxmXCI9PT10P2UuZ2V0UmVjdChuKTooMCwkLmNsb3Nlc3QpKG4sdCl9dmFyIHJlPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyZS5kZWZhdWx0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10Lm9wdGlvbnNbbl0sbz1yJiZyLm9yaWdpbnx8dC5vcHRpb25zLm9yaWdpbixpPSgwLCR0LnJlc29sdmVSZWN0TGlrZSkobyx0LGUsW3QmJmVdKTtyZXR1cm4oMCwkdC5yZWN0VG9YWSkoaSl8fHt4OjAseTowfX07dmFyIG9lPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShvZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxvZS5kZWZhdWx0PXZvaWQgMDt2YXIgaWUsYWUsdWU9MDt2YXIgc2U9e3JlcXVlc3Q6ZnVuY3Rpb24odCl7cmV0dXJuIGllKHQpfSxjYW5jZWw6ZnVuY3Rpb24odCl7cmV0dXJuIGFlKHQpfSxpbml0OmZ1bmN0aW9uKHQpe2lmKGllPXQucmVxdWVzdEFuaW1hdGlvbkZyYW1lLGFlPXQuY2FuY2VsQW5pbWF0aW9uRnJhbWUsIWllKWZvcih2YXIgZT1bXCJtc1wiLFwibW96XCIsXCJ3ZWJraXRcIixcIm9cIl0sbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO2llPXRbXCJcIi5jb25jYXQocixcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiKV0sYWU9dFtcIlwiLmNvbmNhdChyLFwiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcIildfHx0W1wiXCIuY29uY2F0KHIsXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIildfWllfHwoaWU9ZnVuY3Rpb24odCl7dmFyIGU9RGF0ZS5ub3coKSxuPU1hdGgubWF4KDAsMTYtKGUtdWUpKSxyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0KGUrbil9LG4pO3JldHVybiB1ZT1lK24scn0sYWU9ZnVuY3Rpb24odCl7cmV0dXJuIGNsZWFyVGltZW91dCh0KX0pfX07b2UuZGVmYXVsdD1zZTt2YXIgbGU9e307ZnVuY3Rpb24gY2UodCl7cmV0dXJuKGNlPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbGUud2Fybk9uY2U9ZnVuY3Rpb24odCxlKXt2YXIgbj0hMTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbnx8KGhlLmRlZmF1bHQud2luZG93LmNvbnNvbGUud2FybihlKSxuPSEwKSx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19LGxlLmNvcHlBY3Rpb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5uYW1lPWUubmFtZSx0LmF4aXM9ZS5heGlzLHQuZWRnZXM9ZS5lZGdlcyx0fSxPYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJ3aW5cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaGUuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJicm93c2VyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGdlLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwiY2xvbmVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYmUuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJleHRlbmRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbWUuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJnZXRPcmlnaW5YWVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBPZS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsZSxcImh5cG90XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHdlLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwibm9ybWFsaXplTGlzdGVuZXJzXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIF9lLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwicmFmXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFBlLmRlZmF1bHR9fSksbGUucmVjdD1sZS5wb2ludGVyPWxlLmlzPWxlLmRvbT1sZS5hcnI9dm9pZCAwO3ZhciBmZT1qZShTKTtsZS5hcnI9ZmU7dmFyIHBlPWplKCQpO2xlLmRvbT1wZTt2YXIgZGU9amUodyk7bGUuaXM9ZGU7dmFyIHZlPWplKHp0KTtsZS5wb2ludGVyPXZlO3ZhciB5ZT1qZSgkdCk7bGUucmVjdD15ZTt2YXIgaGU9eGUoTyksZ2U9eGUoQyksYmU9eGUoViksbWU9eGUoY3QpLE9lPXhlKHJlKSx3ZT14ZShFdCksX2U9eGUoZnQpLFBlPXhlKG9lKTtmdW5jdGlvbiB4ZSh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gU2UoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBTZT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIGplKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWNlKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPVNlKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59dmFyIE1lPXt9O2Z1bmN0aW9uIGtlKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBFZSh0LGUsbil7cmV0dXJuIGUmJmtlKHQucHJvdG90eXBlLGUpLG4mJmtlKHQsbiksdH1mdW5jdGlvbiBUZSh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9T2JqZWN0LmRlZmluZVByb3BlcnR5KE1lLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE1lLmRlZmF1bHQ9TWUuQmFzZUV2ZW50PXZvaWQgMDt2YXIgRGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpeyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksVGUodGhpcyxcInR5cGVcIix2b2lkIDApLFRlKHRoaXMsXCJ0YXJnZXRcIix2b2lkIDApLFRlKHRoaXMsXCJjdXJyZW50VGFyZ2V0XCIsdm9pZCAwKSxUZSh0aGlzLFwiaW50ZXJhY3RhYmxlXCIsdm9pZCAwKSxUZSh0aGlzLFwiX2ludGVyYWN0aW9uXCIsdm9pZCAwKSxUZSh0aGlzLFwidGltZVN0YW1wXCIsdm9pZCAwKSxUZSh0aGlzLFwiaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCIsITEpLFRlKHRoaXMsXCJwcm9wYWdhdGlvblN0b3BwZWRcIiwhMSksdGhpcy5faW50ZXJhY3Rpb249dH1yZXR1cm4gRWUoZSxbe2tleTpcImludGVyYWN0aW9uXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyYWN0aW9uLl9wcm94eX19XSksRWUoZSxbe2tleTpcInByZXZlbnREZWZhdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwic3RvcFByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19LHtrZXk6XCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPXRoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX1dKSxlfSgpLEllPU1lLkJhc2VFdmVudD1EZTtNZS5kZWZhdWx0PUllO3ZhciB6ZT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoemUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksemUuZGVmYXVsdD16ZS5kZWZhdWx0cz12b2lkIDA7dmFyIEFlPXtiYXNlOntwcmV2ZW50RGVmYXVsdDpcImF1dG9cIixkZWx0YVNvdXJjZTpcInBhZ2VcIn0scGVyQWN0aW9uOntlbmFibGVkOiExLG9yaWdpbjp7eDowLHk6MH19LGFjdGlvbnM6e319LENlPXplLmRlZmF1bHRzPUFlO3plLmRlZmF1bHQ9Q2U7dmFyIFdlPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShXZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxXZS5kZWZhdWx0PVdlLkludGVyYWN0RXZlbnQ9dm9pZCAwO3ZhciBSZT1MZShjdCksRmU9TGUocmUpLFhlPUxlKEV0KSxZZT1MZShNZSksTmU9TGUoemUpO2Z1bmN0aW9uIExlKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBCZSh0KXtyZXR1cm4oQmU9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIFZlKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBxZSh0KXtyZXR1cm4ocWU9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KX0pKHQpfWZ1bmN0aW9uIFVlKHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiB0fWZ1bmN0aW9uIEdlKHQsZSl7cmV0dXJuKEdlPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX1mdW5jdGlvbiBIZSh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIEtlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyh0LGUsbixyLG8saSxhKXt2YXIgdSxzLGw7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxnKSxzPXRoaXMsdT0hKGw9cWUoZykuY2FsbCh0aGlzLHQpKXx8XCJvYmplY3RcIiE9PUJlKGwpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBsP1VlKHMpOmwsSGUoVWUodSksXCJ0YXJnZXRcIix2b2lkIDApLEhlKFVlKHUpLFwiY3VycmVudFRhcmdldFwiLHZvaWQgMCksSGUoVWUodSksXCJyZWxhdGVkVGFyZ2V0XCIsbnVsbCksSGUoVWUodSksXCJzY3JlZW5YXCIsdm9pZCAwKSxIZShVZSh1KSxcInNjcmVlbllcIix2b2lkIDApLEhlKFVlKHUpLFwiYnV0dG9uXCIsdm9pZCAwKSxIZShVZSh1KSxcImJ1dHRvbnNcIix2b2lkIDApLEhlKFVlKHUpLFwiY3RybEtleVwiLHZvaWQgMCksSGUoVWUodSksXCJzaGlmdEtleVwiLHZvaWQgMCksSGUoVWUodSksXCJhbHRLZXlcIix2b2lkIDApLEhlKFVlKHUpLFwibWV0YUtleVwiLHZvaWQgMCksSGUoVWUodSksXCJwYWdlXCIsdm9pZCAwKSxIZShVZSh1KSxcImNsaWVudFwiLHZvaWQgMCksSGUoVWUodSksXCJkZWx0YVwiLHZvaWQgMCksSGUoVWUodSksXCJyZWN0XCIsdm9pZCAwKSxIZShVZSh1KSxcIngwXCIsdm9pZCAwKSxIZShVZSh1KSxcInkwXCIsdm9pZCAwKSxIZShVZSh1KSxcInQwXCIsdm9pZCAwKSxIZShVZSh1KSxcImR0XCIsdm9pZCAwKSxIZShVZSh1KSxcImR1cmF0aW9uXCIsdm9pZCAwKSxIZShVZSh1KSxcImNsaWVudFgwXCIsdm9pZCAwKSxIZShVZSh1KSxcImNsaWVudFkwXCIsdm9pZCAwKSxIZShVZSh1KSxcInZlbG9jaXR5XCIsdm9pZCAwKSxIZShVZSh1KSxcInNwZWVkXCIsdm9pZCAwKSxIZShVZSh1KSxcInN3aXBlXCIsdm9pZCAwKSxIZShVZSh1KSxcInRpbWVTdGFtcFwiLHZvaWQgMCksSGUoVWUodSksXCJkcmFnRW50ZXJcIix2b2lkIDApLEhlKFVlKHUpLFwiZHJhZ0xlYXZlXCIsdm9pZCAwKSxIZShVZSh1KSxcImF4ZXNcIix2b2lkIDApLEhlKFVlKHUpLFwicHJlRW5kXCIsdm9pZCAwKSxvPW98fHQuZWxlbWVudDt2YXIgYz10LmludGVyYWN0YWJsZSxmPShjJiZjLm9wdGlvbnN8fE5lLmRlZmF1bHQpLmRlbHRhU291cmNlLHA9KDAsRmUuZGVmYXVsdCkoYyxvLG4pLGQ9XCJzdGFydFwiPT09cix2PVwiZW5kXCI9PT1yLHk9ZD9VZSh1KTp0LnByZXZFdmVudCxoPWQ/dC5jb29yZHMuc3RhcnQ6dj97cGFnZTp5LnBhZ2UsY2xpZW50OnkuY2xpZW50LHRpbWVTdGFtcDp0LmNvb3Jkcy5jdXIudGltZVN0YW1wfTp0LmNvb3Jkcy5jdXI7cmV0dXJuIHUucGFnZT0oMCxSZS5kZWZhdWx0KSh7fSxoLnBhZ2UpLHUuY2xpZW50PSgwLFJlLmRlZmF1bHQpKHt9LGguY2xpZW50KSx1LnJlY3Q9KDAsUmUuZGVmYXVsdCkoe30sdC5yZWN0KSx1LnRpbWVTdGFtcD1oLnRpbWVTdGFtcCx2fHwodS5wYWdlLngtPXAueCx1LnBhZ2UueS09cC55LHUuY2xpZW50LngtPXAueCx1LmNsaWVudC55LT1wLnkpLHUuY3RybEtleT1lLmN0cmxLZXksdS5hbHRLZXk9ZS5hbHRLZXksdS5zaGlmdEtleT1lLnNoaWZ0S2V5LHUubWV0YUtleT1lLm1ldGFLZXksdS5idXR0b249ZS5idXR0b24sdS5idXR0b25zPWUuYnV0dG9ucyx1LnRhcmdldD1vLHUuY3VycmVudFRhcmdldD1vLHUucHJlRW5kPWksdS50eXBlPWF8fG4rKHJ8fFwiXCIpLHUuaW50ZXJhY3RhYmxlPWMsdS50MD1kP3QucG9pbnRlcnNbdC5wb2ludGVycy5sZW5ndGgtMV0uZG93blRpbWU6eS50MCx1LngwPXQuY29vcmRzLnN0YXJ0LnBhZ2UueC1wLngsdS55MD10LmNvb3Jkcy5zdGFydC5wYWdlLnktcC55LHUuY2xpZW50WDA9dC5jb29yZHMuc3RhcnQuY2xpZW50LngtcC54LHUuY2xpZW50WTA9dC5jb29yZHMuc3RhcnQuY2xpZW50LnktcC55LHUuZGVsdGE9ZHx8dj97eDowLHk6MH06e3g6dVtmXS54LXlbZl0ueCx5OnVbZl0ueS15W2ZdLnl9LHUuZHQ9dC5jb29yZHMuZGVsdGEudGltZVN0YW1wLHUuZHVyYXRpb249dS50aW1lU3RhbXAtdS50MCx1LnZlbG9jaXR5PSgwLFJlLmRlZmF1bHQpKHt9LHQuY29vcmRzLnZlbG9jaXR5W2ZdKSx1LnNwZWVkPSgwLFhlLmRlZmF1bHQpKHUudmVsb2NpdHkueCx1LnZlbG9jaXR5LnkpLHUuc3dpcGU9dnx8XCJpbmVydGlhc3RhcnRcIj09PXI/dS5nZXRTd2lwZSgpOm51bGwsdX12YXIgdCxlLG47cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiZHZSh0LGUpfShnLFllW1wiZGVmYXVsdFwiXSksdD1nLChlPVt7a2V5OlwiZ2V0U3dpcGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2ludGVyYWN0aW9uO2lmKHQucHJldkV2ZW50LnNwZWVkPDYwMHx8MTUwPHRoaXMudGltZVN0YW1wLXQucHJldkV2ZW50LnRpbWVTdGFtcClyZXR1cm4gbnVsbDt2YXIgZT0xODAqTWF0aC5hdGFuMih0LnByZXZFdmVudC52ZWxvY2l0eVksdC5wcmV2RXZlbnQudmVsb2NpdHlYKS9NYXRoLlBJO2U8MCYmKGUrPTM2MCk7dmFyIG49MTEyLjU8PWUmJmU8MjQ3LjUscj0yMDIuNTw9ZSYmZTwzMzcuNTtyZXR1cm57dXA6cixkb3duOiFyJiYyMi41PD1lJiZlPDE1Ny41LGxlZnQ6bixyaWdodDohbiYmKDI5Mi41PD1lfHxlPDY3LjUpLGFuZ2xlOmUsc3BlZWQ6dC5wcmV2RXZlbnQuc3BlZWQsdmVsb2NpdHk6e3g6dC5wcmV2RXZlbnQudmVsb2NpdHlYLHk6dC5wcmV2RXZlbnQudmVsb2NpdHlZfX19fSx7a2V5OlwicHJldmVudERlZmF1bHRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPXRoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX0se2tleTpcInN0b3BQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fSx7a2V5OlwicGFnZVhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYWdlLnh9LHNldDpmdW5jdGlvbih0KXt0aGlzLnBhZ2UueD10fX0se2tleTpcInBhZ2VZXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFnZS55fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5wYWdlLnk9dH19LHtrZXk6XCJjbGllbnRYXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xpZW50Lnh9LHNldDpmdW5jdGlvbih0KXt0aGlzLmNsaWVudC54PXR9fSx7a2V5OlwiY2xpZW50WVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsaWVudC55fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5jbGllbnQueT10fX0se2tleTpcImR4XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsdGEueH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuZGVsdGEueD10fX0se2tleTpcImR5XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsdGEueX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuZGVsdGEueT10fX0se2tleTpcInZlbG9jaXR5WFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlbG9jaXR5Lnh9LHNldDpmdW5jdGlvbih0KXt0aGlzLnZlbG9jaXR5Lng9dH19LHtrZXk6XCJ2ZWxvY2l0eVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZWxvY2l0eS55fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy52ZWxvY2l0eS55PXR9fV0pJiZWZSh0LnByb3RvdHlwZSxlKSxuJiZWZSh0LG4pLGd9KCksJGU9V2UuSW50ZXJhY3RFdmVudD1LZTtXZS5kZWZhdWx0PSRlO3ZhciBaZT17fTtmdW5jdGlvbiBKZSh0KXtyZXR1cm4oSmU9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShaZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxaZS5kZWZhdWx0PXZvaWQgMDt2YXIgUWUsdG49YW4oUyksZW49YW4oJCksbm49KFFlPWN0KSYmUWUuX19lc01vZHVsZT9RZTp7ZGVmYXVsdDpRZX0scm49YW4odyk7ZnVuY3Rpb24gb24oKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBvbj1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIGFuKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PUplKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPW9uKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59ZnVuY3Rpb24gdW4odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIHNuKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgbG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciBhPXRoaXM7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0aGlzLnNjb3BlPXQsc24odGhpcyxcImxpc3RcIixbXSksc24odGhpcyxcInNlbGVjdG9yTWFwXCIse30pLHQuYWRkTGlzdGVuZXJzKHtcImludGVyYWN0YWJsZTp1bnNldFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3RhYmxlLG49ZS50YXJnZXQscj1lLl9jb250ZXh0LG89cm4uc3RyaW5nKG4pP2Euc2VsZWN0b3JNYXBbbl06blthLnNjb3BlLmlkXSxpPW8uZmluZEluZGV4KGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnRleHQ9PT1yfSk7b1tpXSYmKG9baV0uY29udGV4dD1udWxsLG9baV0uaW50ZXJhY3RhYmxlPW51bGwpLG8uc3BsaWNlKGksMSl9fSl9dmFyIHQsbixyO3JldHVybiB0PWUsKG49W3trZXk6XCJuZXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2U9KDAsbm4uZGVmYXVsdCkoZXx8e30se2FjdGlvbnM6dGhpcy5zY29wZS5hY3Rpb25zfSk7dmFyIG49bmV3IHRoaXMuc2NvcGUuSW50ZXJhY3RhYmxlKHQsZSx0aGlzLnNjb3BlLmRvY3VtZW50LHRoaXMuc2NvcGUuZXZlbnRzKSxyPXtjb250ZXh0Om4uX2NvbnRleHQsaW50ZXJhY3RhYmxlOm59O3JldHVybiB0aGlzLnNjb3BlLmFkZERvY3VtZW50KG4uX2RvYyksdGhpcy5saXN0LnB1c2gobikscm4uc3RyaW5nKHQpPyh0aGlzLnNlbGVjdG9yTWFwW3RdfHwodGhpcy5zZWxlY3Rvck1hcFt0XT1bXSksdGhpcy5zZWxlY3Rvck1hcFt0XS5wdXNoKHIpKToobi50YXJnZXRbdGhpcy5zY29wZS5pZF18fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHRoaXMuc2NvcGUuaWQse3ZhbHVlOltdLGNvbmZpZ3VyYWJsZTohMH0pLHRbdGhpcy5zY29wZS5pZF0ucHVzaChyKSksdGhpcy5zY29wZS5maXJlKFwiaW50ZXJhY3RhYmxlOm5ld1wiLHt0YXJnZXQ6dCxvcHRpb25zOmUsaW50ZXJhY3RhYmxlOm4sd2luOnRoaXMuc2NvcGUuX3dpbn0pLG59fSx7a2V5OlwiZ2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10JiZ0LmNvbnRleHR8fHRoaXMuc2NvcGUuZG9jdW1lbnQscj1ybi5zdHJpbmcoZSksbz1yP3RoaXMuc2VsZWN0b3JNYXBbZV06ZVt0aGlzLnNjb3BlLmlkXTtpZighbylyZXR1cm4gbnVsbDt2YXIgaT10bi5maW5kKG8sZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udGV4dD09PW4mJihyfHx0LmludGVyYWN0YWJsZS5pbkNvbnRleHQoZSkpfSk7cmV0dXJuIGkmJmkuaW50ZXJhY3RhYmxlfX0se2tleTpcImZvckVhY2hNYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0aGlzLmxpc3QubGVuZ3RoO24rKyl7dmFyIHI9dGhpcy5saXN0W25dLG89dm9pZCAwO2lmKChybi5zdHJpbmcoci50YXJnZXQpP3JuLmVsZW1lbnQodCkmJmVuLm1hdGNoZXNTZWxlY3Rvcih0LHIudGFyZ2V0KTp0PT09ci50YXJnZXQpJiZyLmluQ29udGV4dCh0KSYmKG89ZShyKSksdm9pZCAwIT09bylyZXR1cm4gb319fV0pJiZ1bih0LnByb3RvdHlwZSxuKSxyJiZ1bih0LHIpLGV9KCk7WmUuZGVmYXVsdD1sbjt2YXIgY249e307ZnVuY3Rpb24gZm4odCl7cmV0dXJuKGZuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoY24sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksY24uZGVmYXVsdD1jbi5GYWtlRXZlbnQ9dm9pZCAwO3ZhciBwbj1PbihTKSxkbj1PbigkKSx2bj1ibihjdCkseW49T24odyksaG49Ym4oVHQpLGduPU9uKHp0KTtmdW5jdGlvbiBibih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbW4oKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBtbj1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIE9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWZuKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPW1uKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59ZnVuY3Rpb24gd24odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIF9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHR9KHQpfHxmdW5jdGlvbih0LGUpe2lmKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkpcmV0dXJuO3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHU9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7cnx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufSh0LGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfXZhciBQbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG8odCl7dmFyIGUsbixyOyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbyksdGhpcy5vcmlnaW5hbEV2ZW50PXQscj12b2lkIDAsKG49XCJjdXJyZW50VGFyZ2V0XCIpaW4oZT10aGlzKT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVtuXT1yLCgwLGhuLmRlZmF1bHQpKHRoaXMsdCl9dmFyIHQsZSxuO3JldHVybiB0PW8sKGU9W3trZXk6XCJwcmV2ZW50T3JpZ2luYWxEZWZhdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKX19LHtrZXk6XCJzdG9wUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKX19LHtrZXk6XCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3JpZ2luYWxFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKX19XSkmJnduKHQucHJvdG90eXBlLGUpLG4mJnduKHQsbiksb30oKTtmdW5jdGlvbiB4bih0KXtpZigheW4ub2JqZWN0KHQpKXJldHVybntjYXB0dXJlOiEhdCxwYXNzaXZlOiExfTt2YXIgZT0oMCx2bi5kZWZhdWx0KSh7fSx0KTtyZXR1cm4gZS5jYXB0dXJlPSEhdC5jYXB0dXJlLGUucGFzc2l2ZT0hIXQucGFzc2l2ZSxlfWNuLkZha2VFdmVudD1Qbjt2YXIgU249e2lkOlwiZXZlbnRzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZj1bXSxiPXt9LGM9W10scD17YWRkOmQscmVtb3ZlOmcsYWRkRGVsZWdhdGU6ZnVuY3Rpb24oZSxuLHQscixvKXt2YXIgaT14bihvKTtpZighYlt0XSl7Ylt0XT1bXTtmb3IodmFyIGE9MDthPGMubGVuZ3RoO2ErKyl7dmFyIHU9Y1thXTtkKHUsdCxtKSxkKHUsdCxPLCEwKX19dmFyIHM9Ylt0XSxsPXBuLmZpbmQocyxmdW5jdGlvbih0KXtyZXR1cm4gdC5zZWxlY3Rvcj09PWUmJnQuY29udGV4dD09PW59KTtsfHwobD17c2VsZWN0b3I6ZSxjb250ZXh0Om4sbGlzdGVuZXJzOltdfSxzLnB1c2gobCkpO2wubGlzdGVuZXJzLnB1c2goW3IsaV0pfSxyZW1vdmVEZWxlZ2F0ZTpmdW5jdGlvbih0LGUsbixyLG8pe3ZhciBpLGE9eG4obyksdT1iW25dLHM9ITE7aWYoIXUpcmV0dXJuO2ZvcihpPXUubGVuZ3RoLTE7MDw9aTtpLS0pe3ZhciBsPXVbaV07aWYobC5zZWxlY3Rvcj09PXQmJmwuY29udGV4dD09PWUpe2Zvcih2YXIgYz1sLmxpc3RlbmVycyxmPWMubGVuZ3RoLTE7MDw9ZjtmLS0pe3ZhciBwPV9uKGNbZl0sMiksZD1wWzBdLHY9cFsxXSx5PXYuY2FwdHVyZSxoPXYucGFzc2l2ZTtpZihkPT09ciYmeT09PWEuY2FwdHVyZSYmaD09PWEucGFzc2l2ZSl7Yy5zcGxpY2UoZiwxKSxjLmxlbmd0aHx8KHUuc3BsaWNlKGksMSksZyhlLG4sbSksZyhlLG4sTywhMCkpLHM9ITA7YnJlYWt9fWlmKHMpYnJlYWt9fX0sZGVsZWdhdGVMaXN0ZW5lcjptLGRlbGVnYXRlVXNlQ2FwdHVyZTpPLGRlbGVnYXRlZEV2ZW50czpiLGRvY3VtZW50czpjLHRhcmdldHM6ZixzdXBwb3J0c09wdGlvbnM6ITEsc3VwcG9ydHNQYXNzaXZlOiExfTtmdW5jdGlvbiBkKGUsdCxuLHIpe3ZhciBvPXhuKHIpLGk9cG4uZmluZChmLGZ1bmN0aW9uKHQpe3JldHVybiB0LmV2ZW50VGFyZ2V0PT09ZX0pO2l8fChpPXtldmVudFRhcmdldDplLGV2ZW50czp7fX0sZi5wdXNoKGkpKSxpLmV2ZW50c1t0XXx8KGkuZXZlbnRzW3RdPVtdKSxlLmFkZEV2ZW50TGlzdGVuZXImJiFwbi5jb250YWlucyhpLmV2ZW50c1t0XSxuKSYmKGUuYWRkRXZlbnRMaXN0ZW5lcih0LG4scC5zdXBwb3J0c09wdGlvbnM/bzpvLmNhcHR1cmUpLGkuZXZlbnRzW3RdLnB1c2gobikpfWZ1bmN0aW9uIGcoZSx0LG4scil7dmFyIG89eG4ociksaT1wbi5maW5kSW5kZXgoZixmdW5jdGlvbih0KXtyZXR1cm4gdC5ldmVudFRhcmdldD09PWV9KSxhPWZbaV07aWYoYSYmYS5ldmVudHMpaWYoXCJhbGxcIiE9PXQpe3ZhciB1PSExLHM9YS5ldmVudHNbdF07aWYocyl7aWYoXCJhbGxcIj09PW4pe2Zvcih2YXIgbD1zLmxlbmd0aC0xOzA8PWw7bC0tKWcoZSx0LHNbbF0sbyk7cmV0dXJufWZvcih2YXIgYz0wO2M8cy5sZW5ndGg7YysrKWlmKHNbY109PT1uKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxuLHAuc3VwcG9ydHNPcHRpb25zP286by5jYXB0dXJlKSxzLnNwbGljZShjLDEpLDA9PT1zLmxlbmd0aCYmKGRlbGV0ZSBhLmV2ZW50c1t0XSx1PSEwKTticmVha319dSYmIU9iamVjdC5rZXlzKGEuZXZlbnRzKS5sZW5ndGgmJmYuc3BsaWNlKGksMSl9ZWxzZSBmb3IodCBpbiBhLmV2ZW50cylhLmV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0KSYmZyhlLHQsXCJhbGxcIil9ZnVuY3Rpb24gbSh0LGUpe2Zvcih2YXIgbj14bihlKSxyPW5ldyBQbih0KSxvPWJbdC50eXBlXSxpPV9uKGduLmdldEV2ZW50VGFyZ2V0cyh0KSwxKVswXSxhPWk7eW4uZWxlbWVudChhKTspe2Zvcih2YXIgdT0wO3U8by5sZW5ndGg7dSsrKXt2YXIgcz1vW3VdLGw9cy5zZWxlY3RvcixjPXMuY29udGV4dDtpZihkbi5tYXRjaGVzU2VsZWN0b3IoYSxsKSYmZG4ubm9kZUNvbnRhaW5zKGMsaSkmJmRuLm5vZGVDb250YWlucyhjLGEpKXt2YXIgZj1zLmxpc3RlbmVycztyLmN1cnJlbnRUYXJnZXQ9YTtmb3IodmFyIHA9MDtwPGYubGVuZ3RoO3ArKyl7dmFyIGQ9X24oZltwXSwyKSx2PWRbMF0seT1kWzFdLGg9eS5jYXB0dXJlLGc9eS5wYXNzaXZlO2g9PT1uLmNhcHR1cmUmJmc9PT1uLnBhc3NpdmUmJnYocil9fX1hPWRuLnBhcmVudE5vZGUoYSl9fWZ1bmN0aW9uIE8odCl7cmV0dXJuIG0uY2FsbCh0aGlzLHQsITApfXJldHVybiB0LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIixudWxsLHtnZXQgY2FwdHVyZSgpe3JldHVybiBwLnN1cHBvcnRzT3B0aW9ucz0hMH0sZ2V0IHBhc3NpdmUoKXtyZXR1cm4gcC5zdXBwb3J0c1Bhc3NpdmU9ITB9fSksdC5ldmVudHM9cH19O2NuLmRlZmF1bHQ9U247dmFyIGpuPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShqbixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxqbi5kZWZhdWx0PWpuLlBvaW50ZXJJbmZvPXZvaWQgMDtmdW5jdGlvbiBNbih0LGUsbixyLG8peyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsTW4pLHRoaXMuaWQ9dCx0aGlzLnBvaW50ZXI9ZSx0aGlzLmV2ZW50PW4sdGhpcy5kb3duVGltZT1yLHRoaXMuZG93blRhcmdldD1vfXZhciBrbj1qbi5Qb2ludGVySW5mbz1Nbjtqbi5kZWZhdWx0PWtuO3ZhciBFbj17fTtmdW5jdGlvbiBUbih0KXtyZXR1cm4oVG49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoRW4sXCJQb2ludGVySW5mb1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBSbi5kZWZhdWx0fX0pLEVuLmRlZmF1bHQ9RW4uSW50ZXJhY3Rpb249RW4uX1Byb3h5TWV0aG9kcz1Fbi5fUHJveHlWYWx1ZXM9dm9pZCAwO3ZhciBEbixJbix6bixBbixDbj1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1Ubih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1YbigpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShsZSksV249Rm4oV2UpLFJuPUZuKGpuKTtmdW5jdGlvbiBGbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gWG4oKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBYbj1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIFluKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBObih0LGUsbil7cmV0dXJuIGUmJlluKHQucHJvdG90eXBlLGUpLG4mJlluKHQsbiksdH1mdW5jdGlvbiBMbih0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9RW4uX1Byb3h5VmFsdWVzPURuLChJbj1Ebnx8KEVuLl9Qcm94eVZhbHVlcz1Ebj17fSkpLmludGVyYWN0YWJsZT1cIlwiLEluLmVsZW1lbnQ9XCJcIixJbi5wcmVwYXJlZD1cIlwiLEluLnBvaW50ZXJJc0Rvd249XCJcIixJbi5wb2ludGVyV2FzTW92ZWQ9XCJcIixJbi5fcHJveHk9XCJcIixFbi5fUHJveHlNZXRob2RzPXpuLChBbj16bnx8KEVuLl9Qcm94eU1ldGhvZHM9em49e30pKS5zdGFydD1cIlwiLEFuLm1vdmU9XCJcIixBbi5lbmQ9XCJcIixBbi5zdG9wPVwiXCIsQW4uaW50ZXJhY3Rpbmc9XCJcIjt2YXIgQm49MCxWbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGwodCl7dmFyIGU9dGhpcyxuPXQucG9pbnRlclR5cGUscj10LnNjb3BlRmlyZTshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGwpLExuKHRoaXMsXCJpbnRlcmFjdGFibGVcIixudWxsKSxMbih0aGlzLFwiZWxlbWVudFwiLG51bGwpLExuKHRoaXMsXCJyZWN0XCIsdm9pZCAwKSxMbih0aGlzLFwiX3JlY3RzXCIsdm9pZCAwKSxMbih0aGlzLFwiZWRnZXNcIix2b2lkIDApLExuKHRoaXMsXCJfc2NvcGVGaXJlXCIsdm9pZCAwKSxMbih0aGlzLFwicHJlcGFyZWRcIix7bmFtZTpudWxsLGF4aXM6bnVsbCxlZGdlczpudWxsfSksTG4odGhpcyxcInBvaW50ZXJUeXBlXCIsdm9pZCAwKSxMbih0aGlzLFwicG9pbnRlcnNcIixbXSksTG4odGhpcyxcImRvd25FdmVudFwiLG51bGwpLExuKHRoaXMsXCJkb3duUG9pbnRlclwiLHt9KSxMbih0aGlzLFwiX2xhdGVzdFBvaW50ZXJcIix7cG9pbnRlcjpudWxsLGV2ZW50Om51bGwsZXZlbnRUYXJnZXQ6bnVsbH0pLExuKHRoaXMsXCJwcmV2RXZlbnRcIixudWxsKSxMbih0aGlzLFwicG9pbnRlcklzRG93blwiLCExKSxMbih0aGlzLFwicG9pbnRlcldhc01vdmVkXCIsITEpLExuKHRoaXMsXCJfaW50ZXJhY3RpbmdcIiwhMSksTG4odGhpcyxcIl9lbmRpbmdcIiwhMSksTG4odGhpcyxcIl9zdG9wcGVkXCIsITApLExuKHRoaXMsXCJfcHJveHlcIixudWxsKSxMbih0aGlzLFwic2ltdWxhdGlvblwiLG51bGwpLExuKHRoaXMsXCJkb01vdmVcIixDbi53YXJuT25jZShmdW5jdGlvbih0KXt0aGlzLm1vdmUodCl9LFwiVGhlIGludGVyYWN0aW9uLmRvTW92ZSgpIG1ldGhvZCBoYXMgYmVlbiByZW5hbWVkIHRvIGludGVyYWN0aW9uLm1vdmUoKVwiKSksTG4odGhpcyxcImNvb3Jkc1wiLHtzdGFydDpDbi5wb2ludGVyLm5ld0Nvb3JkcygpLHByZXY6Q24ucG9pbnRlci5uZXdDb29yZHMoKSxjdXI6Q24ucG9pbnRlci5uZXdDb29yZHMoKSxkZWx0YTpDbi5wb2ludGVyLm5ld0Nvb3JkcygpLHZlbG9jaXR5OkNuLnBvaW50ZXIubmV3Q29vcmRzKCl9KSxMbih0aGlzLFwiX2lkXCIsQm4rKyksdGhpcy5fc2NvcGVGaXJlPXIsdGhpcy5wb2ludGVyVHlwZT1uO3ZhciBvPXRoaXM7dGhpcy5fcHJveHk9e307ZnVuY3Rpb24gaSh0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5fcHJveHksdCx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG9bdF19fSl9Zm9yKHZhciBhIGluIERuKWkoYSk7ZnVuY3Rpb24gdSh0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5fcHJveHksdCx7dmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gb1t0XS5hcHBseShvLGFyZ3VtZW50cyl9fSl9Zm9yKHZhciBzIGluIHpuKXUocyk7dGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOm5ld1wiLHtpbnRlcmFjdGlvbjp0aGlzfSl9cmV0dXJuIE5uKGwsW3trZXk6XCJwb2ludGVyTW92ZVRvbGVyYW5jZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiAxfX1dKSxObihsLFt7a2V5OlwicG9pbnRlckRvd25cIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy51cGRhdGVQb2ludGVyKHQsZSxuLCEwKSxvPXRoaXMucG9pbnRlcnNbcl07dGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOmRvd25cIix7cG9pbnRlcjp0LGV2ZW50OmUsZXZlbnRUYXJnZXQ6bixwb2ludGVySW5kZXg6cixwb2ludGVySW5mbzpvLHR5cGU6XCJkb3duXCIsaW50ZXJhY3Rpb246dGhpc30pfX0se2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiEodGhpcy5pbnRlcmFjdGluZygpfHwhdGhpcy5wb2ludGVySXNEb3dufHx0aGlzLnBvaW50ZXJzLmxlbmd0aDwoXCJnZXN0dXJlXCI9PT10Lm5hbWU/MjoxKXx8IWUub3B0aW9uc1t0Lm5hbWVdLmVuYWJsZWQpJiYoQ24uY29weUFjdGlvbih0aGlzLnByZXBhcmVkLHQpLHRoaXMuaW50ZXJhY3RhYmxlPWUsdGhpcy5lbGVtZW50PW4sdGhpcy5yZWN0PWUuZ2V0UmVjdChuKSx0aGlzLmVkZ2VzPXRoaXMucHJlcGFyZWQuZWRnZXM/Q24uZXh0ZW5kKHt9LHRoaXMucHJlcGFyZWQuZWRnZXMpOntsZWZ0OiEwLHJpZ2h0OiEwLHRvcDohMCxib3R0b206ITB9LHRoaXMuX3N0b3BwZWQ9ITEsdGhpcy5faW50ZXJhY3Rpbmc9dGhpcy5fZG9QaGFzZSh7aW50ZXJhY3Rpb246dGhpcyxldmVudDp0aGlzLmRvd25FdmVudCxwaGFzZTpcInN0YXJ0XCJ9KSYmIXRoaXMuX3N0b3BwZWQsdGhpcy5faW50ZXJhY3RpbmcpfX0se2tleTpcInBvaW50ZXJNb3ZlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3RoaXMuc2ltdWxhdGlvbnx8dGhpcy5tb2RpZmljYXRpb24mJnRoaXMubW9kaWZpY2F0aW9uLmVuZFJlc3VsdHx8dGhpcy51cGRhdGVQb2ludGVyKHQsZSxuLCExKTt2YXIgcixvLGk9dGhpcy5jb29yZHMuY3VyLnBhZ2UueD09PXRoaXMuY29vcmRzLnByZXYucGFnZS54JiZ0aGlzLmNvb3Jkcy5jdXIucGFnZS55PT09dGhpcy5jb29yZHMucHJldi5wYWdlLnkmJnRoaXMuY29vcmRzLmN1ci5jbGllbnQueD09PXRoaXMuY29vcmRzLnByZXYuY2xpZW50LngmJnRoaXMuY29vcmRzLmN1ci5jbGllbnQueT09PXRoaXMuY29vcmRzLnByZXYuY2xpZW50Lnk7dGhpcy5wb2ludGVySXNEb3duJiYhdGhpcy5wb2ludGVyV2FzTW92ZWQmJihyPXRoaXMuY29vcmRzLmN1ci5jbGllbnQueC10aGlzLmNvb3Jkcy5zdGFydC5jbGllbnQueCxvPXRoaXMuY29vcmRzLmN1ci5jbGllbnQueS10aGlzLmNvb3Jkcy5zdGFydC5jbGllbnQueSx0aGlzLnBvaW50ZXJXYXNNb3ZlZD1Dbi5oeXBvdChyLG8pPnRoaXMucG9pbnRlck1vdmVUb2xlcmFuY2UpO3ZhciBhPXRoaXMuZ2V0UG9pbnRlckluZGV4KHQpLHU9e3BvaW50ZXI6dCxwb2ludGVySW5kZXg6YSxwb2ludGVySW5mbzp0aGlzLnBvaW50ZXJzW2FdLGV2ZW50OmUsdHlwZTpcIm1vdmVcIixldmVudFRhcmdldDpuLGR4OnIsZHk6byxkdXBsaWNhdGU6aSxpbnRlcmFjdGlvbjp0aGlzfTtpfHxDbi5wb2ludGVyLnNldENvb3JkVmVsb2NpdHkodGhpcy5jb29yZHMudmVsb2NpdHksdGhpcy5jb29yZHMuZGVsdGEpLHRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczptb3ZlXCIsdSksaXx8dGhpcy5zaW11bGF0aW9ufHwodGhpcy5pbnRlcmFjdGluZygpJiYodS50eXBlPW51bGwsdGhpcy5tb3ZlKHUpKSx0aGlzLnBvaW50ZXJXYXNNb3ZlZCYmQ24ucG9pbnRlci5jb3B5Q29vcmRzKHRoaXMuY29vcmRzLnByZXYsdGhpcy5jb29yZHMuY3VyKSl9fSx7a2V5OlwibW92ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3QmJnQuZXZlbnR8fENuLnBvaW50ZXIuc2V0WmVyb0Nvb3Jkcyh0aGlzLmNvb3Jkcy5kZWx0YSksKHQ9Q24uZXh0ZW5kKHtwb2ludGVyOnRoaXMuX2xhdGVzdFBvaW50ZXIucG9pbnRlcixldmVudDp0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50LGV2ZW50VGFyZ2V0OnRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQsaW50ZXJhY3Rpb246dGhpc30sdHx8e30pKS5waGFzZT1cIm1vdmVcIix0aGlzLl9kb1BoYXNlKHQpfX0se2tleTpcInBvaW50ZXJVcFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXRoaXMuZ2V0UG9pbnRlckluZGV4KHQpOy0xPT09byYmKG89dGhpcy51cGRhdGVQb2ludGVyKHQsZSxuLCExKSk7dmFyIGk9L2NhbmNlbCQvaS50ZXN0KGUudHlwZSk/XCJjYW5jZWxcIjpcInVwXCI7dGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOlwiLmNvbmNhdChpKSx7cG9pbnRlcjp0LHBvaW50ZXJJbmRleDpvLHBvaW50ZXJJbmZvOnRoaXMucG9pbnRlcnNbb10sZXZlbnQ6ZSxldmVudFRhcmdldDpuLHR5cGU6aSxjdXJFdmVudFRhcmdldDpyLGludGVyYWN0aW9uOnRoaXN9KSx0aGlzLnNpbXVsYXRpb258fHRoaXMuZW5kKGUpLHRoaXMucG9pbnRlcklzRG93bj0hMSx0aGlzLnJlbW92ZVBvaW50ZXIodCxlKX19LHtrZXk6XCJkb2N1bWVudEJsdXJcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmVuZCh0KSx0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6Ymx1clwiLHtldmVudDp0LHR5cGU6XCJibHVyXCIsaW50ZXJhY3Rpb246dGhpc30pfX0se2tleTpcImVuZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlO3RoaXMuX2VuZGluZz0hMCx0PXR8fHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnQsdGhpcy5pbnRlcmFjdGluZygpJiYoZT10aGlzLl9kb1BoYXNlKHtldmVudDp0LGludGVyYWN0aW9uOnRoaXMscGhhc2U6XCJlbmRcIn0pKSwhKHRoaXMuX2VuZGluZz0hMSk9PT1lJiZ0aGlzLnN0b3AoKX19LHtrZXk6XCJjdXJyZW50QWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJhY3Rpbmc/dGhpcy5wcmVwYXJlZC5uYW1lOm51bGx9fSx7a2V5OlwiaW50ZXJhY3RpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcmFjdGluZ319LHtrZXk6XCJzdG9wXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6c3RvcFwiLHtpbnRlcmFjdGlvbjp0aGlzfSksdGhpcy5pbnRlcmFjdGFibGU9dGhpcy5lbGVtZW50PW51bGwsdGhpcy5faW50ZXJhY3Rpbmc9ITEsdGhpcy5fc3RvcHBlZD0hMCx0aGlzLnByZXBhcmVkLm5hbWU9dGhpcy5wcmV2RXZlbnQ9bnVsbH19LHtrZXk6XCJnZXRQb2ludGVySW5kZXhcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1Dbi5wb2ludGVyLmdldFBvaW50ZXJJZCh0KTtyZXR1cm5cIm1vdXNlXCI9PT10aGlzLnBvaW50ZXJUeXBlfHxcInBlblwiPT09dGhpcy5wb2ludGVyVHlwZT90aGlzLnBvaW50ZXJzLmxlbmd0aC0xOkNuLmFyci5maW5kSW5kZXgodGhpcy5wb2ludGVycyxmdW5jdGlvbih0KXtyZXR1cm4gdC5pZD09PWV9KX19LHtrZXk6XCJnZXRQb2ludGVySW5mb1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBvaW50ZXJzW3RoaXMuZ2V0UG9pbnRlckluZGV4KHQpXX19LHtrZXk6XCJ1cGRhdGVQb2ludGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4scil7dmFyIG89Q24ucG9pbnRlci5nZXRQb2ludGVySWQodCksaT10aGlzLmdldFBvaW50ZXJJbmRleCh0KSxhPXRoaXMucG9pbnRlcnNbaV07cmV0dXJuIHI9ITEhPT1yJiYocnx8Lyhkb3dufHN0YXJ0KSQvaS50ZXN0KGUudHlwZSkpLGE/YS5wb2ludGVyPXQ6KGE9bmV3IFJuLmRlZmF1bHQobyx0LGUsbnVsbCxudWxsKSxpPXRoaXMucG9pbnRlcnMubGVuZ3RoLHRoaXMucG9pbnRlcnMucHVzaChhKSksQ24ucG9pbnRlci5zZXRDb29yZHModGhpcy5jb29yZHMuY3VyLHRoaXMucG9pbnRlcnMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnBvaW50ZXJ9KSx0aGlzLl9ub3coKSksQ24ucG9pbnRlci5zZXRDb29yZERlbHRhcyh0aGlzLmNvb3Jkcy5kZWx0YSx0aGlzLmNvb3Jkcy5wcmV2LHRoaXMuY29vcmRzLmN1ciksciYmKHRoaXMucG9pbnRlcklzRG93bj0hMCxhLmRvd25UaW1lPXRoaXMuY29vcmRzLmN1ci50aW1lU3RhbXAsYS5kb3duVGFyZ2V0PW4sQ24ucG9pbnRlci5wb2ludGVyRXh0ZW5kKHRoaXMuZG93blBvaW50ZXIsdCksdGhpcy5pbnRlcmFjdGluZygpfHwoQ24ucG9pbnRlci5jb3B5Q29vcmRzKHRoaXMuY29vcmRzLnN0YXJ0LHRoaXMuY29vcmRzLmN1ciksQ24ucG9pbnRlci5jb3B5Q29vcmRzKHRoaXMuY29vcmRzLnByZXYsdGhpcy5jb29yZHMuY3VyKSx0aGlzLmRvd25FdmVudD1lLHRoaXMucG9pbnRlcldhc01vdmVkPSExKSksdGhpcy5fdXBkYXRlTGF0ZXN0UG9pbnRlcih0LGUsbiksdGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOnVwZGF0ZS1wb2ludGVyXCIse3BvaW50ZXI6dCxldmVudDplLGV2ZW50VGFyZ2V0Om4sZG93bjpyLHBvaW50ZXJJbmZvOmEscG9pbnRlckluZGV4OmksaW50ZXJhY3Rpb246dGhpc30pLGl9fSx7a2V5OlwicmVtb3ZlUG9pbnRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRQb2ludGVySW5kZXgodCk7aWYoLTEhPT1uKXt2YXIgcj10aGlzLnBvaW50ZXJzW25dO3RoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpyZW1vdmUtcG9pbnRlclwiLHtwb2ludGVyOnQsZXZlbnQ6ZSxldmVudFRhcmdldDpudWxsLHBvaW50ZXJJbmRleDpuLHBvaW50ZXJJbmZvOnIsaW50ZXJhY3Rpb246dGhpc30pLHRoaXMucG9pbnRlcnMuc3BsaWNlKG4sMSl9fX0se2tleTpcIl91cGRhdGVMYXRlc3RQb2ludGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3RoaXMuX2xhdGVzdFBvaW50ZXIucG9pbnRlcj10LHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnQ9ZSx0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50VGFyZ2V0PW59fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fbGF0ZXN0UG9pbnRlci5wb2ludGVyPW51bGwsdGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudD1udWxsLHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQ9bnVsbH19LHtrZXk6XCJfY3JlYXRlUHJlcGFyZWRFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBuZXcgV24uZGVmYXVsdCh0aGlzLHQsdGhpcy5wcmVwYXJlZC5uYW1lLGUsdGhpcy5lbGVtZW50LG4scil9fSx7a2V5OlwiX2ZpcmVFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuaW50ZXJhY3RhYmxlLmZpcmUodCksKCF0aGlzLnByZXZFdmVudHx8dC50aW1lU3RhbXA+PXRoaXMucHJldkV2ZW50LnRpbWVTdGFtcCkmJih0aGlzLnByZXZFdmVudD10KX19LHtrZXk6XCJfZG9QaGFzZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZXZlbnQsbj10LnBoYXNlLHI9dC5wcmVFbmQsbz10LnR5cGUsaT10aGlzLnJlY3Q7aWYoaSYmXCJtb3ZlXCI9PT1uJiYoQ24ucmVjdC5hZGRFZGdlcyh0aGlzLmVkZ2VzLGksdGhpcy5jb29yZHMuZGVsdGFbdGhpcy5pbnRlcmFjdGFibGUub3B0aW9ucy5kZWx0YVNvdXJjZV0pLGkud2lkdGg9aS5yaWdodC1pLmxlZnQsaS5oZWlnaHQ9aS5ib3R0b20taS50b3ApLCExPT09dGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tXCIuY29uY2F0KG4pLHQpKXJldHVybiExO3ZhciBhPXQuaUV2ZW50PXRoaXMuX2NyZWF0ZVByZXBhcmVkRXZlbnQoZSxuLHIsbyk7cmV0dXJuIHRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczphY3Rpb24tXCIuY29uY2F0KG4pLHQpLFwic3RhcnRcIj09PW4mJih0aGlzLnByZXZFdmVudD1hKSx0aGlzLl9maXJlRXZlbnQoYSksdGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1cIi5jb25jYXQobiksdCksITB9fSx7a2V5OlwiX25vd1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9fV0pLGx9KCkscW49RW4uSW50ZXJhY3Rpb249Vm47RW4uZGVmYXVsdD1xbjt2YXIgVW49e307ZnVuY3Rpb24gR24odCl7cmV0dXJuKEduPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoVW4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksVW4uaW5zdGFsbD1KbixVbi5kZWZhdWx0PXZvaWQgMDt2YXIgSG49ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09R24odCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9S24oKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0odyk7ZnVuY3Rpb24gS24oKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBLbj1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uICRuKHQpe3JldHVybi9eKGFsd2F5c3xuZXZlcnxhdXRvKSQvLnRlc3QodCk/KHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdD10LHRoaXMpOkhuLmJvb2wodCk/KHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdD10P1wiYWx3YXlzXCI6XCJuZXZlclwiLHRoaXMpOnRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdH1mdW5jdGlvbiBabih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5ldmVudDtlLmludGVyYWN0YWJsZSYmZS5pbnRlcmFjdGFibGUuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdChuKX1mdW5jdGlvbiBKbihyKXt2YXIgdD1yLkludGVyYWN0YWJsZTt0LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdD0kbix0LnByb3RvdHlwZS5jaGVja0FuZFByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dmFyIHI9dC5vcHRpb25zLnByZXZlbnREZWZhdWx0O2lmKFwibmV2ZXJcIiE9PXIpaWYoXCJhbHdheXNcIiE9PXIpe2lmKGUuZXZlbnRzLnN1cHBvcnRzUGFzc2l2ZSYmL150b3VjaChzdGFydHxtb3ZlKSQvLnRlc3Qobi50eXBlKSl7dmFyIG89KDAsTy5nZXRXaW5kb3cpKG4udGFyZ2V0KS5kb2N1bWVudCxpPWUuZ2V0RG9jT3B0aW9ucyhvKTtpZighaXx8IWkuZXZlbnRzfHwhMSE9PWkuZXZlbnRzLnBhc3NpdmUpcmV0dXJufS9eKG1vdXNlfHBvaW50ZXJ8dG91Y2gpKihkb3dufHN0YXJ0KS9pLnRlc3Qobi50eXBlKXx8SG4uZWxlbWVudChuLnRhcmdldCkmJigwLCQubWF0Y2hlc1NlbGVjdG9yKShuLnRhcmdldCxcImlucHV0LHNlbGVjdCx0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlPXRydWVdLFtjb250ZW50ZWRpdGFibGU9dHJ1ZV0gKlwiKXx8bi5wcmV2ZW50RGVmYXVsdCgpfWVsc2Ugbi5wcmV2ZW50RGVmYXVsdCgpfSh0aGlzLHIsdCl9LHIuaW50ZXJhY3Rpb25zLmRvY0V2ZW50cy5wdXNoKHt0eXBlOlwiZHJhZ3N0YXJ0XCIsbGlzdGVuZXI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTxyLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDtlKyspe3ZhciBuPXIuaW50ZXJhY3Rpb25zLmxpc3RbZV07aWYobi5lbGVtZW50JiYobi5lbGVtZW50PT09dC50YXJnZXR8fCgwLCQubm9kZUNvbnRhaW5zKShuLmVsZW1lbnQsdC50YXJnZXQpKSlyZXR1cm4gdm9pZCBuLmludGVyYWN0YWJsZS5jaGVja0FuZFByZXZlbnREZWZhdWx0KHQpfX19KX12YXIgUW49e2lkOlwiY29yZS9pbnRlcmFjdGFibGVQcmV2ZW50RGVmYXVsdFwiLGluc3RhbGw6Sm4sbGlzdGVuZXJzOltcImRvd25cIixcIm1vdmVcIixcInVwXCIsXCJjYW5jZWxcIl0ucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbXCJpbnRlcmFjdGlvbnM6XCIuY29uY2F0KGUpXT1abix0fSx7fSl9O1VuLmRlZmF1bHQ9UW47dmFyIHRyPXt9O2Z1bmN0aW9uIGVyKHQpe3JldHVybihlcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHRyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHRyLmRlZmF1bHQ9dm9pZCAwO3ZhciBucj1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1lcih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1ycigpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSgkKTtmdW5jdGlvbiBycigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIHJyPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9dmFyIG9yPXttZXRob2RPcmRlcjpbXCJzaW11bGF0aW9uUmVzdW1lXCIsXCJtb3VzZU9yUGVuXCIsXCJoYXNQb2ludGVyXCIsXCJpZGxlXCJdLHNlYXJjaDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPG9yLm1ldGhvZE9yZGVyLmxlbmd0aDtlKyspe3ZhciBuO249b3IubWV0aG9kT3JkZXJbZV07dmFyIHI9b3Jbbl0odCk7aWYocilyZXR1cm4gcn1yZXR1cm4gbnVsbH0sc2ltdWxhdGlvblJlc3VtZTpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50ZXJUeXBlLG49dC5ldmVudFR5cGUscj10LmV2ZW50VGFyZ2V0LG89dC5zY29wZTtpZighL2Rvd258c3RhcnQvaS50ZXN0KG4pKXJldHVybiBudWxsO2Zvcih2YXIgaT0wO2k8by5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7aSsrKXt2YXIgYT1vLmludGVyYWN0aW9ucy5saXN0W2ldLHU9cjtpZihhLnNpbXVsYXRpb24mJmEuc2ltdWxhdGlvbi5hbGxvd1Jlc3VtZSYmYS5wb2ludGVyVHlwZT09PWUpZm9yKDt1Oyl7aWYodT09PWEuZWxlbWVudClyZXR1cm4gYTt1PW5yLnBhcmVudE5vZGUodSl9fXJldHVybiBudWxsfSxtb3VzZU9yUGVuOmZ1bmN0aW9uKHQpe3ZhciBlLG49dC5wb2ludGVySWQscj10LnBvaW50ZXJUeXBlLG89dC5ldmVudFR5cGUsaT10LnNjb3BlO2lmKFwibW91c2VcIiE9PXImJlwicGVuXCIhPT1yKXJldHVybiBudWxsO2Zvcih2YXIgYT0wO2E8aS5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7YSsrKXt2YXIgdT1pLmludGVyYWN0aW9ucy5saXN0W2FdO2lmKHUucG9pbnRlclR5cGU9PT1yKXtpZih1LnNpbXVsYXRpb24mJiFpcih1LG4pKWNvbnRpbnVlO2lmKHUuaW50ZXJhY3RpbmcoKSlyZXR1cm4gdTtlPWV8fHV9fWlmKGUpcmV0dXJuIGU7Zm9yKHZhciBzPTA7czxpLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDtzKyspe3ZhciBsPWkuaW50ZXJhY3Rpb25zLmxpc3Rbc107aWYoIShsLnBvaW50ZXJUeXBlIT09cnx8L2Rvd24vaS50ZXN0KG8pJiZsLnNpbXVsYXRpb24pKXJldHVybiBsfXJldHVybiBudWxsfSxoYXNQb2ludGVyOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnBvaW50ZXJJZCxuPXQuc2NvcGUscj0wO3I8bi5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7cisrKXt2YXIgbz1uLmludGVyYWN0aW9ucy5saXN0W3JdO2lmKGlyKG8sZSkpcmV0dXJuIG99cmV0dXJuIG51bGx9LGlkbGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQucG9pbnRlclR5cGUsbj10LnNjb3BlLHI9MDtyPG4uaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO3IrKyl7dmFyIG89bi5pbnRlcmFjdGlvbnMubGlzdFtyXTtpZigxPT09by5wb2ludGVycy5sZW5ndGgpe3ZhciBpPW8uaW50ZXJhY3RhYmxlO2lmKGkmJighaS5vcHRpb25zLmdlc3R1cmV8fCFpLm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkKSljb250aW51ZX1lbHNlIGlmKDI8PW8ucG9pbnRlcnMubGVuZ3RoKWNvbnRpbnVlO2lmKCFvLmludGVyYWN0aW5nKCkmJmU9PT1vLnBvaW50ZXJUeXBlKXJldHVybiBvfXJldHVybiBudWxsfX07ZnVuY3Rpb24gaXIodCxlKXtyZXR1cm4gdC5wb2ludGVycy5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkPT09ZX0pfXZhciBhcj1vcjt0ci5kZWZhdWx0PWFyO3ZhciB1cj17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodXIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdXIuZGVmYXVsdD12b2lkIDA7dmFyIHNyLGxyPShzcj1NZSkmJnNyLl9fZXNNb2R1bGU/c3I6e2RlZmF1bHQ6c3J9LGNyPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PXByKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPWZyKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KFMpO2Z1bmN0aW9uIGZyKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gZnI9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBwcih0KXtyZXR1cm4ocHI9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIGRyKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiB2cih0KXtyZXR1cm4odnI9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KX0pKHQpfWZ1bmN0aW9uIHlyKHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiB0fWZ1bmN0aW9uIGhyKHQsZSl7cmV0dXJuKGhyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX1mdW5jdGlvbiBncih0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIGJyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbCh0LGUsbil7dmFyIHIsbyxpOyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbCksbz10aGlzLHI9IShpPXZyKGwpLmNhbGwodGhpcyxlLl9pbnRlcmFjdGlvbikpfHxcIm9iamVjdFwiIT09cHIoaSkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGk/eXIobyk6aSxncih5cihyKSxcInRhcmdldFwiLHZvaWQgMCksZ3IoeXIociksXCJkcm9wem9uZVwiLHZvaWQgMCksZ3IoeXIociksXCJkcmFnRXZlbnRcIix2b2lkIDApLGdyKHlyKHIpLFwicmVsYXRlZFRhcmdldFwiLHZvaWQgMCksZ3IoeXIociksXCJkcmFnZ2FibGVcIix2b2lkIDApLGdyKHlyKHIpLFwidGltZVN0YW1wXCIsdm9pZCAwKSxncih5cihyKSxcInByb3BhZ2F0aW9uU3RvcHBlZFwiLCExKSxncih5cihyKSxcImltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwiLCExKTt2YXIgYT1cImRyYWdsZWF2ZVwiPT09bj90LnByZXY6dC5jdXIsdT1hLmVsZW1lbnQscz1hLmRyb3B6b25lO3JldHVybiByLnR5cGU9bixyLnRhcmdldD11LHIuY3VycmVudFRhcmdldD11LHIuZHJvcHpvbmU9cyxyLmRyYWdFdmVudD1lLHIucmVsYXRlZFRhcmdldD1lLnRhcmdldCxyLmRyYWdnYWJsZT1lLmludGVyYWN0YWJsZSxyLnRpbWVTdGFtcD1lLnRpbWVTdGFtcCxyfXZhciB0LGUsbjtyZXR1cm4gZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJmhyKHQsZSl9KGwsbHJbXCJkZWZhdWx0XCJdKSx0PWwsKGU9W3trZXk6XCJyZWplY3RcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciByPXRoaXMsdD10aGlzLl9pbnRlcmFjdGlvbi5kcm9wU3RhdGU7aWYoXCJkcm9wYWN0aXZhdGVcIj09PXRoaXMudHlwZXx8dGhpcy5kcm9wem9uZSYmdC5jdXIuZHJvcHpvbmU9PT10aGlzLmRyb3B6b25lJiZ0LmN1ci5lbGVtZW50PT09dGhpcy50YXJnZXQpaWYodC5wcmV2LmRyb3B6b25lPXRoaXMuZHJvcHpvbmUsdC5wcmV2LmVsZW1lbnQ9dGhpcy50YXJnZXQsdC5yZWplY3RlZD0hMCx0LmV2ZW50cy5lbnRlcj1udWxsLHRoaXMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksXCJkcm9wYWN0aXZhdGVcIj09PXRoaXMudHlwZSl7dmFyIGU9dC5hY3RpdmVEcm9wcyxuPWNyLmZpbmRJbmRleChlLGZ1bmN0aW9uKHQpe3ZhciBlPXQuZHJvcHpvbmUsbj10LmVsZW1lbnQ7cmV0dXJuIGU9PT1yLmRyb3B6b25lJiZuPT09ci50YXJnZXR9KTt0LmFjdGl2ZURyb3BzLnNwbGljZShuLDEpO3ZhciBvPW5ldyBsKHQsdGhpcy5kcmFnRXZlbnQsXCJkcm9wZGVhY3RpdmF0ZVwiKTtvLmRyb3B6b25lPXRoaXMuZHJvcHpvbmUsby50YXJnZXQ9dGhpcy50YXJnZXQsdGhpcy5kcm9wem9uZS5maXJlKG8pfWVsc2UgdGhpcy5kcm9wem9uZS5maXJlKG5ldyBsKHQsdGhpcy5kcmFnRXZlbnQsXCJkcmFnbGVhdmVcIikpfX0se2tleTpcInByZXZlbnREZWZhdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwic3RvcFByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19LHtrZXk6XCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPXRoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX1dKSYmZHIodC5wcm90b3R5cGUsZSksbiYmZHIodCxuKSxsfSgpO3VyLmRlZmF1bHQ9YnI7dmFyIG1yPXt9O2Z1bmN0aW9uIE9yKHQpe3JldHVybihPcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KG1yLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG1yLmRlZmF1bHQ9dm9pZCAwO1NyKGsoe30pKSxTcihtKHt9KSk7dmFyIHdyPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PU9yKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPXhyKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KGxlKSxfcj1Tcih2KSxQcj1Tcih1cik7ZnVuY3Rpb24geHIoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiB4cj1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIFNyKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBqcih0LGUpe2Zvcih2YXIgbj0wO248dC5zbGljZSgpLmxlbmd0aDtuKyspe3I9dC5zbGljZSgpW25dO3ZhciByLG89ci5kcm9wem9uZSxpPXIuZWxlbWVudDtlLmRyb3B6b25lPW8sZS50YXJnZXQ9aSxvLmZpcmUoZSksZS5wcm9wYWdhdGlvblN0b3BwZWQ9ZS5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9ITF9fWZ1bmN0aW9uIE1yKHQsZSl7Zm9yKHZhciBuPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuaW50ZXJhY3RhYmxlcyxyPVtdLG89MDtvPG4ubGlzdC5sZW5ndGg7bysrKXt2YXIgaT1uLmxpc3Rbb107aWYoaS5vcHRpb25zLmRyb3AuZW5hYmxlZCl7dmFyIGE9aS5vcHRpb25zLmRyb3AuYWNjZXB0O2lmKCEod3IuaXMuZWxlbWVudChhKSYmYSE9PWV8fHdyLmlzLnN0cmluZyhhKSYmIXdyLmRvbS5tYXRjaGVzU2VsZWN0b3IoZSxhKXx8d3IuaXMuZnVuYyhhKSYmIWEoe2Ryb3B6b25lOmksZHJhZ2dhYmxlRWxlbWVudDplfSkpKWZvcih2YXIgdT13ci5pcy5zdHJpbmcoaS50YXJnZXQpP2kuX2NvbnRleHQucXVlcnlTZWxlY3RvckFsbChpLnRhcmdldCk6d3IuaXMuYXJyYXkoaS50YXJnZXQpP2kudGFyZ2V0OltpLnRhcmdldF0scz0wO3M8dS5sZW5ndGg7cysrKXt2YXIgbDtsPXVbc107bCE9PWUmJnIucHVzaCh7ZHJvcHpvbmU6aSxlbGVtZW50Omx9KX19fXJldHVybiByfSh0LGUpLHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIG87bz1uW3JdO28ucmVjdD1vLmRyb3B6b25lLmdldFJlY3Qoby5lbGVtZW50KX1yZXR1cm4gbn1mdW5jdGlvbiBrcih0LGUsbil7Zm9yKHZhciByPXQuZHJvcFN0YXRlLG89dC5pbnRlcmFjdGFibGUsaT10LmVsZW1lbnQsYT1bXSx1PTA7dTxyLmFjdGl2ZURyb3BzLmxlbmd0aDt1Kyspe3M9ci5hY3RpdmVEcm9wc1t1XTt2YXIgcyxsPXMuZHJvcHpvbmUsYz1zLmVsZW1lbnQsZj1zLnJlY3Q7YS5wdXNoKGwuZHJvcENoZWNrKGUsbixvLGksYyxmKT9jOm51bGwpfXZhciBwPXdyLmRvbS5pbmRleE9mRGVlcGVzdEVsZW1lbnQoYSk7cmV0dXJuIHIuYWN0aXZlRHJvcHNbcF18fG51bGx9ZnVuY3Rpb24gRXIodCxlLG4pe3ZhciByPXQuZHJvcFN0YXRlLG89e2VudGVyOm51bGwsbGVhdmU6bnVsbCxhY3RpdmF0ZTpudWxsLGRlYWN0aXZhdGU6bnVsbCxtb3ZlOm51bGwsZHJvcDpudWxsfTtyZXR1cm5cImRyYWdzdGFydFwiPT09bi50eXBlJiYoby5hY3RpdmF0ZT1uZXcgUHIuZGVmYXVsdChyLG4sXCJkcm9wYWN0aXZhdGVcIiksby5hY3RpdmF0ZS50YXJnZXQ9bnVsbCxvLmFjdGl2YXRlLmRyb3B6b25lPW51bGwpLFwiZHJhZ2VuZFwiPT09bi50eXBlJiYoby5kZWFjdGl2YXRlPW5ldyBQci5kZWZhdWx0KHIsbixcImRyb3BkZWFjdGl2YXRlXCIpLG8uZGVhY3RpdmF0ZS50YXJnZXQ9bnVsbCxvLmRlYWN0aXZhdGUuZHJvcHpvbmU9bnVsbCksci5yZWplY3RlZHx8KHIuY3VyLmVsZW1lbnQhPT1yLnByZXYuZWxlbWVudCYmKHIucHJldi5kcm9wem9uZSYmKG8ubGVhdmU9bmV3IFByLmRlZmF1bHQocixuLFwiZHJhZ2xlYXZlXCIpLG4uZHJhZ0xlYXZlPW8ubGVhdmUudGFyZ2V0PXIucHJldi5lbGVtZW50LG4ucHJldkRyb3B6b25lPW8ubGVhdmUuZHJvcHpvbmU9ci5wcmV2LmRyb3B6b25lKSxyLmN1ci5kcm9wem9uZSYmKG8uZW50ZXI9bmV3IFByLmRlZmF1bHQocixuLFwiZHJhZ2VudGVyXCIpLG4uZHJhZ0VudGVyPXIuY3VyLmVsZW1lbnQsbi5kcm9wem9uZT1yLmN1ci5kcm9wem9uZSkpLFwiZHJhZ2VuZFwiPT09bi50eXBlJiZyLmN1ci5kcm9wem9uZSYmKG8uZHJvcD1uZXcgUHIuZGVmYXVsdChyLG4sXCJkcm9wXCIpLG4uZHJvcHpvbmU9ci5jdXIuZHJvcHpvbmUsbi5yZWxhdGVkVGFyZ2V0PXIuY3VyLmVsZW1lbnQpLFwiZHJhZ21vdmVcIj09PW4udHlwZSYmci5jdXIuZHJvcHpvbmUmJihvLm1vdmU9bmV3IFByLmRlZmF1bHQocixuLFwiZHJvcG1vdmVcIiksKG8ubW92ZS5kcmFnbW92ZT1uKS5kcm9wem9uZT1yLmN1ci5kcm9wem9uZSkpLG99ZnVuY3Rpb24gVHIodCxlKXt2YXIgbj10LmRyb3BTdGF0ZSxyPW4uYWN0aXZlRHJvcHMsbz1uLmN1cixpPW4ucHJldjtlLmxlYXZlJiZpLmRyb3B6b25lLmZpcmUoZS5sZWF2ZSksZS5tb3ZlJiZvLmRyb3B6b25lLmZpcmUoZS5tb3ZlKSxlLmVudGVyJiZvLmRyb3B6b25lLmZpcmUoZS5lbnRlciksZS5kcm9wJiZvLmRyb3B6b25lLmZpcmUoZS5kcm9wKSxlLmRlYWN0aXZhdGUmJmpyKHIsZS5kZWFjdGl2YXRlKSxuLnByZXYuZHJvcHpvbmU9by5kcm9wem9uZSxuLnByZXYuZWxlbWVudD1vLmVsZW1lbnR9ZnVuY3Rpb24gRHIodCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5pRXZlbnQsbz10LmV2ZW50O2lmKFwiZHJhZ21vdmVcIj09PXIudHlwZXx8XCJkcmFnZW5kXCI9PT1yLnR5cGUpe3ZhciBpPW4uZHJvcFN0YXRlO2UuZHluYW1pY0Ryb3AmJihpLmFjdGl2ZURyb3BzPU1yKGUsbi5lbGVtZW50KSk7dmFyIGE9cix1PWtyKG4sYSxvKTtpLnJlamVjdGVkPWkucmVqZWN0ZWQmJiEhdSYmdS5kcm9wem9uZT09PWkuY3VyLmRyb3B6b25lJiZ1LmVsZW1lbnQ9PT1pLmN1ci5lbGVtZW50LGkuY3VyLmRyb3B6b25lPXUmJnUuZHJvcHpvbmUsaS5jdXIuZWxlbWVudD11JiZ1LmVsZW1lbnQsaS5ldmVudHM9RXIobiwwLGEpfX12YXIgSXI9e2lkOlwiYWN0aW9ucy9kcm9wXCIsaW5zdGFsbDpmdW5jdGlvbihlKXt2YXIgdD1lLmFjdGlvbnMsbj1lLmludGVyYWN0U3RhdGljLHI9ZS5JbnRlcmFjdGFibGUsbz1lLmRlZmF1bHRzO2UudXNlUGx1Z2luKF9yLmRlZmF1bHQpLHIucHJvdG90eXBlLmRyb3B6b25lPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUpe2lmKHdyLmlzLm9iamVjdChlKSl7aWYodC5vcHRpb25zLmRyb3AuZW5hYmxlZD0hMSE9PWUuZW5hYmxlZCxlLmxpc3RlbmVycyl7dmFyIG49d3Iubm9ybWFsaXplTGlzdGVuZXJzKGUubGlzdGVuZXJzKSxyPU9iamVjdC5rZXlzKG4pLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0Wy9eKGVudGVyfGxlYXZlKS8udGVzdChlKT9cImRyYWdcIi5jb25jYXQoZSk6L14oYWN0aXZhdGV8ZGVhY3RpdmF0ZXxtb3ZlKS8udGVzdChlKT9cImRyb3BcIi5jb25jYXQoZSk6ZV09bltlXSx0fSx7fSk7dC5vZmYodC5vcHRpb25zLmRyb3AubGlzdGVuZXJzKSx0Lm9uKHIpLHQub3B0aW9ucy5kcm9wLmxpc3RlbmVycz1yfXJldHVybiB3ci5pcy5mdW5jKGUub25kcm9wKSYmdC5vbihcImRyb3BcIixlLm9uZHJvcCksd3IuaXMuZnVuYyhlLm9uZHJvcGFjdGl2YXRlKSYmdC5vbihcImRyb3BhY3RpdmF0ZVwiLGUub25kcm9wYWN0aXZhdGUpLHdyLmlzLmZ1bmMoZS5vbmRyb3BkZWFjdGl2YXRlKSYmdC5vbihcImRyb3BkZWFjdGl2YXRlXCIsZS5vbmRyb3BkZWFjdGl2YXRlKSx3ci5pcy5mdW5jKGUub25kcmFnZW50ZXIpJiZ0Lm9uKFwiZHJhZ2VudGVyXCIsZS5vbmRyYWdlbnRlciksd3IuaXMuZnVuYyhlLm9uZHJhZ2xlYXZlKSYmdC5vbihcImRyYWdsZWF2ZVwiLGUub25kcmFnbGVhdmUpLHdyLmlzLmZ1bmMoZS5vbmRyb3Btb3ZlKSYmdC5vbihcImRyb3Btb3ZlXCIsZS5vbmRyb3Btb3ZlKSwvXihwb2ludGVyfGNlbnRlcikkLy50ZXN0KGUub3ZlcmxhcCk/dC5vcHRpb25zLmRyb3Aub3ZlcmxhcD1lLm92ZXJsYXA6d3IuaXMubnVtYmVyKGUub3ZlcmxhcCkmJih0Lm9wdGlvbnMuZHJvcC5vdmVybGFwPU1hdGgubWF4KE1hdGgubWluKDEsZS5vdmVybGFwKSwwKSksXCJhY2NlcHRcImluIGUmJih0Lm9wdGlvbnMuZHJvcC5hY2NlcHQ9ZS5hY2NlcHQpLFwiY2hlY2tlclwiaW4gZSYmKHQub3B0aW9ucy5kcm9wLmNoZWNrZXI9ZS5jaGVja2VyKSx0fWlmKHdyLmlzLmJvb2woZSkpcmV0dXJuIHQub3B0aW9ucy5kcm9wLmVuYWJsZWQ9ZSx0O3JldHVybiB0Lm9wdGlvbnMuZHJvcH0odGhpcyx0KX0sci5wcm90b3R5cGUuZHJvcENoZWNrPWZ1bmN0aW9uKHQsZSxuLHIsbyxpKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGksYSl7dmFyIHU9ITE7aWYoIShhPWF8fHQuZ2V0UmVjdChpKSkpcmV0dXJuISF0Lm9wdGlvbnMuZHJvcC5jaGVja2VyJiZ0Lm9wdGlvbnMuZHJvcC5jaGVja2VyKGUsbix1LHQsaSxyLG8pO3ZhciBzPXQub3B0aW9ucy5kcm9wLm92ZXJsYXA7aWYoXCJwb2ludGVyXCI9PT1zKXt2YXIgbD13ci5nZXRPcmlnaW5YWShyLG8sXCJkcmFnXCIpLGM9d3IucG9pbnRlci5nZXRQYWdlWFkoZSk7Yy54Kz1sLngsYy55Kz1sLnk7dmFyIGY9Yy54PmEubGVmdCYmYy54PGEucmlnaHQscD1jLnk+YS50b3AmJmMueTxhLmJvdHRvbTt1PWYmJnB9dmFyIGQ9ci5nZXRSZWN0KG8pO2lmKGQmJlwiY2VudGVyXCI9PT1zKXt2YXIgdj1kLmxlZnQrZC53aWR0aC8yLHk9ZC50b3ArZC5oZWlnaHQvMjt1PXY+PWEubGVmdCYmdjw9YS5yaWdodCYmeT49YS50b3AmJnk8PWEuYm90dG9tfWlmKGQmJndyLmlzLm51bWJlcihzKSl7dmFyIGg9TWF0aC5tYXgoMCxNYXRoLm1pbihhLnJpZ2h0LGQucmlnaHQpLU1hdGgubWF4KGEubGVmdCxkLmxlZnQpKSpNYXRoLm1heCgwLE1hdGgubWluKGEuYm90dG9tLGQuYm90dG9tKS1NYXRoLm1heChhLnRvcCxkLnRvcCkpLyhkLndpZHRoKmQuaGVpZ2h0KTt1PXM8PWh9dC5vcHRpb25zLmRyb3AuY2hlY2tlciYmKHU9dC5vcHRpb25zLmRyb3AuY2hlY2tlcihlLG4sdSx0LGkscixvKSk7cmV0dXJuIHV9KHRoaXMsdCxlLG4scixvLGkpfSxuLmR5bmFtaWNEcm9wPWZ1bmN0aW9uKHQpe3JldHVybiB3ci5pcy5ib29sKHQpPyhlLmR5bmFtaWNEcm9wPXQsbik6ZS5keW5hbWljRHJvcH0sd3IuZXh0ZW5kKHQucGhhc2VsZXNzVHlwZXMse2RyYWdlbnRlcjohMCxkcmFnbGVhdmU6ITAsZHJvcGFjdGl2YXRlOiEwLGRyb3BkZWFjdGl2YXRlOiEwLGRyb3Btb3ZlOiEwLGRyb3A6ITB9KSx0Lm1ldGhvZERpY3QuZHJvcD1cImRyb3B6b25lXCIsZS5keW5hbWljRHJvcD0hMSxvLmFjdGlvbnMuZHJvcD1Jci5kZWZhdWx0c30sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLXN0YXJ0XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtcImRyYWdcIj09PWUucHJlcGFyZWQubmFtZSYmKGUuZHJvcFN0YXRlPXtjdXI6e2Ryb3B6b25lOm51bGwsZWxlbWVudDpudWxsfSxwcmV2Ontkcm9wem9uZTpudWxsLGVsZW1lbnQ6bnVsbH0scmVqZWN0ZWQ6bnVsbCxldmVudHM6bnVsbCxhY3RpdmVEcm9wczpbXX0pfSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tc3RhcnRcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj0odC5ldmVudCx0LmlFdmVudCk7aWYoXCJkcmFnXCI9PT1uLnByZXBhcmVkLm5hbWUpe3ZhciBvPW4uZHJvcFN0YXRlO28uYWN0aXZlRHJvcHM9bnVsbCxvLmV2ZW50cz1udWxsLG8uYWN0aXZlRHJvcHM9TXIoZSxuLmVsZW1lbnQpLG8uZXZlbnRzPUVyKG4sMCxyKSxvLmV2ZW50cy5hY3RpdmF0ZSYmKGpyKG8uYWN0aXZlRHJvcHMsby5ldmVudHMuYWN0aXZhdGUpLGUuZmlyZShcImFjdGlvbnMvZHJvcDpzdGFydFwiLHtpbnRlcmFjdGlvbjpuLGRyYWdFdmVudDpyfSkpfX0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpEcixcImludGVyYWN0aW9uczphY3Rpb24tZW5kXCI6RHIsXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LmlFdmVudDtcImRyYWdcIj09PW4ucHJlcGFyZWQubmFtZSYmKFRyKG4sbi5kcm9wU3RhdGUuZXZlbnRzKSxlLmZpcmUoXCJhY3Rpb25zL2Ryb3A6bW92ZVwiLHtpbnRlcmFjdGlvbjpuLGRyYWdFdmVudDpyfSksbi5kcm9wU3RhdGUuZXZlbnRzPXt9KX0sXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLWVuZFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQuaUV2ZW50O1wiZHJhZ1wiPT09bi5wcmVwYXJlZC5uYW1lJiYoVHIobixuLmRyb3BTdGF0ZS5ldmVudHMpLGUuZmlyZShcImFjdGlvbnMvZHJvcDplbmRcIix7aW50ZXJhY3Rpb246bixkcmFnRXZlbnQ6cn0pKX0sXCJpbnRlcmFjdGlvbnM6c3RvcFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247aWYoXCJkcmFnXCI9PT1lLnByZXBhcmVkLm5hbWUpe3ZhciBuPWUuZHJvcFN0YXRlO24mJihuLmFjdGl2ZURyb3BzPW51bGwsbi5ldmVudHM9bnVsbCxuLmN1ci5kcm9wem9uZT1udWxsLG4uY3VyLmVsZW1lbnQ9bnVsbCxuLnByZXYuZHJvcHpvbmU9bnVsbCxuLnByZXYuZWxlbWVudD1udWxsLG4ucmVqZWN0ZWQ9ITEpfX19LGdldEFjdGl2ZURyb3BzOk1yLGdldERyb3A6a3IsZ2V0RHJvcEV2ZW50czpFcixmaXJlRHJvcEV2ZW50czpUcixkZWZhdWx0czp7ZW5hYmxlZDohMSxhY2NlcHQ6bnVsbCxvdmVybGFwOlwicG9pbnRlclwifX0senI9SXI7bXIuZGVmYXVsdD16cjt2YXIgQXI9e307ZnVuY3Rpb24gQ3IodCl7cmV0dXJuKENyPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQXIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksQXIuZGVmYXVsdD12b2lkIDA7dmFyIFdyPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PUNyKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPVJyKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KGxlKTtmdW5jdGlvbiBScigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIFJyPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gRnIodCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuaUV2ZW50LHI9dC5waGFzZTtpZihcImdlc3R1cmVcIj09PWUucHJlcGFyZWQubmFtZSl7dmFyIG89ZS5wb2ludGVycy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucG9pbnRlcn0pLGk9XCJzdGFydFwiPT09cixhPVwiZW5kXCI9PT1yLHU9ZS5pbnRlcmFjdGFibGUub3B0aW9ucy5kZWx0YVNvdXJjZTtpZihuLnRvdWNoZXM9W29bMF0sb1sxXV0saSluLmRpc3RhbmNlPVdyLnBvaW50ZXIudG91Y2hEaXN0YW5jZShvLHUpLG4uYm94PVdyLnBvaW50ZXIudG91Y2hCQm94KG8pLG4uc2NhbGU9MSxuLmRzPTAsbi5hbmdsZT1Xci5wb2ludGVyLnRvdWNoQW5nbGUobyx1KSxuLmRhPTAsZS5nZXN0dXJlLnN0YXJ0RGlzdGFuY2U9bi5kaXN0YW5jZSxlLmdlc3R1cmUuc3RhcnRBbmdsZT1uLmFuZ2xlO2Vsc2UgaWYoYSl7dmFyIHM9ZS5wcmV2RXZlbnQ7bi5kaXN0YW5jZT1zLmRpc3RhbmNlLG4uYm94PXMuYm94LG4uc2NhbGU9cy5zY2FsZSxuLmRzPTAsbi5hbmdsZT1zLmFuZ2xlLG4uZGE9MH1lbHNlIG4uZGlzdGFuY2U9V3IucG9pbnRlci50b3VjaERpc3RhbmNlKG8sdSksbi5ib3g9V3IucG9pbnRlci50b3VjaEJCb3gobyksbi5zY2FsZT1uLmRpc3RhbmNlL2UuZ2VzdHVyZS5zdGFydERpc3RhbmNlLG4uYW5nbGU9V3IucG9pbnRlci50b3VjaEFuZ2xlKG8sdSksbi5kcz1uLnNjYWxlLWUuZ2VzdHVyZS5zY2FsZSxuLmRhPW4uYW5nbGUtZS5nZXN0dXJlLmFuZ2xlO2UuZ2VzdHVyZS5kaXN0YW5jZT1uLmRpc3RhbmNlLGUuZ2VzdHVyZS5hbmdsZT1uLmFuZ2xlLFdyLmlzLm51bWJlcihuLnNjYWxlKSYmbi5zY2FsZSE9PTEvMCYmIWlzTmFOKG4uc2NhbGUpJiYoZS5nZXN0dXJlLnNjYWxlPW4uc2NhbGUpfX12YXIgWHI9e2lkOlwiYWN0aW9ucy9nZXN0dXJlXCIsYmVmb3JlOltcImFjdGlvbnMvZHJhZ1wiLFwiYWN0aW9ucy9yZXNpemVcIl0saW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmFjdGlvbnMsbj10LkludGVyYWN0YWJsZSxyPXQuZGVmYXVsdHM7bi5wcm90b3R5cGUuZ2VzdHVyYWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gV3IuaXMub2JqZWN0KHQpPyh0aGlzLm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkPSExIT09dC5lbmFibGVkLHRoaXMuc2V0UGVyQWN0aW9uKFwiZ2VzdHVyZVwiLHQpLHRoaXMuc2V0T25FdmVudHMoXCJnZXN0dXJlXCIsdCksdGhpcyk6V3IuaXMuYm9vbCh0KT8odGhpcy5vcHRpb25zLmdlc3R1cmUuZW5hYmxlZD10LHRoaXMpOnRoaXMub3B0aW9ucy5nZXN0dXJlfSxlLm1hcC5nZXN0dXJlPVhyLGUubWV0aG9kRGljdC5nZXN0dXJlPVwiZ2VzdHVyYWJsZVwiLHIuYWN0aW9ucy5nZXN0dXJlPVhyLmRlZmF1bHRzfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOmFjdGlvbi1zdGFydFwiOkZyLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlXCI6RnIsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLWVuZFwiOkZyLFwiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3QuaW50ZXJhY3Rpb24uZ2VzdHVyZT17YW5nbGU6MCxkaXN0YW5jZTowLHNjYWxlOjEsc3RhcnRBbmdsZTowLHN0YXJ0RGlzdGFuY2U6MH19LFwiYXV0by1zdGFydDpjaGVja1wiOmZ1bmN0aW9uKHQpe2lmKCEodC5pbnRlcmFjdGlvbi5wb2ludGVycy5sZW5ndGg8Mikpe3ZhciBlPXQuaW50ZXJhY3RhYmxlLm9wdGlvbnMuZ2VzdHVyZTtpZihlJiZlLmVuYWJsZWQpcmV0dXJuISh0LmFjdGlvbj17bmFtZTpcImdlc3R1cmVcIn0pfX19LGRlZmF1bHRzOnt9LGdldEN1cnNvcjpmdW5jdGlvbigpe3JldHVyblwiXCJ9fSxZcj1YcjtBci5kZWZhdWx0PVlyO3ZhciBOcj17fTtmdW5jdGlvbiBMcih0KXtyZXR1cm4oTHI9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShOcixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxOci5kZWZhdWx0PXZvaWQgMDt2YXIgQnIsVnI9SHIoJCkscXI9KEJyPWN0KSYmQnIuX19lc01vZHVsZT9Ccjp7ZGVmYXVsdDpCcn0sVXI9SHIodyk7ZnVuY3Rpb24gR3IoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBHcj1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIEhyKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PUxyKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUdyKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59ZnVuY3Rpb24gS3IodCxlLG4scixvLGksYSl7aWYoIWUpcmV0dXJuITE7aWYoITA9PT1lKXt2YXIgdT1Vci5udW1iZXIoaS53aWR0aCk/aS53aWR0aDppLnJpZ2h0LWkubGVmdCxzPVVyLm51bWJlcihpLmhlaWdodCk/aS5oZWlnaHQ6aS5ib3R0b20taS50b3A7aWYoYT1NYXRoLm1pbihhLChcImxlZnRcIj09PXR8fFwicmlnaHRcIj09PXQ/dTpzKS8yKSx1PDAmJihcImxlZnRcIj09PXQ/dD1cInJpZ2h0XCI6XCJyaWdodFwiPT09dCYmKHQ9XCJsZWZ0XCIpKSxzPDAmJihcInRvcFwiPT09dD90PVwiYm90dG9tXCI6XCJib3R0b21cIj09PXQmJih0PVwidG9wXCIpKSxcImxlZnRcIj09PXQpcmV0dXJuIG4ueDwoMDw9dT9pLmxlZnQ6aS5yaWdodCkrYTtpZihcInRvcFwiPT09dClyZXR1cm4gbi55PCgwPD1zP2kudG9wOmkuYm90dG9tKSthO2lmKFwicmlnaHRcIj09PXQpcmV0dXJuIG4ueD4oMDw9dT9pLnJpZ2h0OmkubGVmdCktYTtpZihcImJvdHRvbVwiPT09dClyZXR1cm4gbi55PigwPD1zP2kuYm90dG9tOmkudG9wKS1hfXJldHVybiEhVXIuZWxlbWVudChyKSYmKFVyLmVsZW1lbnQoZSk/ZT09PXI6VnIubWF0Y2hlc1VwVG8ocixlLG8pKX1mdW5jdGlvbiAkcih0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb247aWYoXCJyZXNpemVcIj09PW4ucHJlcGFyZWQubmFtZSYmbi5yZXNpemVBeGVzKXt2YXIgcj1lO24uaW50ZXJhY3RhYmxlLm9wdGlvbnMucmVzaXplLnNxdWFyZT8oXCJ5XCI9PT1uLnJlc2l6ZUF4ZXM/ci5kZWx0YS54PXIuZGVsdGEueTpyLmRlbHRhLnk9ci5kZWx0YS54LHIuYXhlcz1cInh5XCIpOihyLmF4ZXM9bi5yZXNpemVBeGVzLFwieFwiPT09bi5yZXNpemVBeGVzP3IuZGVsdGEueT0wOlwieVwiPT09bi5yZXNpemVBeGVzJiYoci5kZWx0YS54PTApKX19dmFyIFpyPXtpZDpcImFjdGlvbnMvcmVzaXplXCIsYmVmb3JlOltcImFjdGlvbnMvZHJhZ1wiXSxpbnN0YWxsOmZ1bmN0aW9uKGUpe3ZhciB0PWUuYWN0aW9ucyxuPWUuYnJvd3NlcixyPWUuSW50ZXJhY3RhYmxlLG89ZS5kZWZhdWx0cztaci5jdXJzb3JzPW4uaXNJZTk/e3g6XCJlLXJlc2l6ZVwiLHk6XCJzLXJlc2l6ZVwiLHh5Olwic2UtcmVzaXplXCIsdG9wOlwibi1yZXNpemVcIixsZWZ0Olwidy1yZXNpemVcIixib3R0b206XCJzLXJlc2l6ZVwiLHJpZ2h0OlwiZS1yZXNpemVcIix0b3BsZWZ0Olwic2UtcmVzaXplXCIsYm90dG9tcmlnaHQ6XCJzZS1yZXNpemVcIix0b3ByaWdodDpcIm5lLXJlc2l6ZVwiLGJvdHRvbWxlZnQ6XCJuZS1yZXNpemVcIn06e3g6XCJldy1yZXNpemVcIix5OlwibnMtcmVzaXplXCIseHk6XCJud3NlLXJlc2l6ZVwiLHRvcDpcIm5zLXJlc2l6ZVwiLGxlZnQ6XCJldy1yZXNpemVcIixib3R0b206XCJucy1yZXNpemVcIixyaWdodDpcImV3LXJlc2l6ZVwiLHRvcGxlZnQ6XCJud3NlLXJlc2l6ZVwiLGJvdHRvbXJpZ2h0OlwibndzZS1yZXNpemVcIix0b3ByaWdodDpcIm5lc3ctcmVzaXplXCIsYm90dG9tbGVmdDpcIm5lc3ctcmVzaXplXCJ9LFpyLmRlZmF1bHRNYXJnaW49bi5zdXBwb3J0c1RvdWNofHxuLnN1cHBvcnRzUG9pbnRlckV2ZW50PzIwOjEwLHIucHJvdG90eXBlLnJlc2l6YWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe2lmKFVyLm9iamVjdChlKSlyZXR1cm4gdC5vcHRpb25zLnJlc2l6ZS5lbmFibGVkPSExIT09ZS5lbmFibGVkLHQuc2V0UGVyQWN0aW9uKFwicmVzaXplXCIsZSksdC5zZXRPbkV2ZW50cyhcInJlc2l6ZVwiLGUpLFVyLnN0cmluZyhlLmF4aXMpJiYvXngkfF55JHxeeHkkLy50ZXN0KGUuYXhpcyk/dC5vcHRpb25zLnJlc2l6ZS5heGlzPWUuYXhpczpudWxsPT09ZS5heGlzJiYodC5vcHRpb25zLnJlc2l6ZS5heGlzPW4uZGVmYXVsdHMuYWN0aW9ucy5yZXNpemUuYXhpcyksVXIuYm9vbChlLnByZXNlcnZlQXNwZWN0UmF0aW8pP3Qub3B0aW9ucy5yZXNpemUucHJlc2VydmVBc3BlY3RSYXRpbz1lLnByZXNlcnZlQXNwZWN0UmF0aW86VXIuYm9vbChlLnNxdWFyZSkmJih0Lm9wdGlvbnMucmVzaXplLnNxdWFyZT1lLnNxdWFyZSksdDtpZihVci5ib29sKGUpKXJldHVybiB0Lm9wdGlvbnMucmVzaXplLmVuYWJsZWQ9ZSx0O3JldHVybiB0Lm9wdGlvbnMucmVzaXplfSh0aGlzLHQsZSl9LHQubWFwLnJlc2l6ZT1acix0Lm1ldGhvZERpY3QucmVzaXplPVwicmVzaXphYmxlXCIsby5hY3Rpb25zLnJlc2l6ZT1aci5kZWZhdWx0c30sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLnJlc2l6ZUF4ZXM9XCJ4eVwifSxcImludGVyYWN0aW9uczphY3Rpb24tc3RhcnRcIjpmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7dmFyIGU9dC5pRXZlbnQsbj10LmludGVyYWN0aW9uO2lmKFwicmVzaXplXCI9PT1uLnByZXBhcmVkLm5hbWUmJm4ucHJlcGFyZWQuZWRnZXMpe3ZhciByPWUsbz1uLnJlY3Q7bi5fcmVjdHM9e3N0YXJ0OigwLHFyLmRlZmF1bHQpKHt9LG8pLGNvcnJlY3RlZDooMCxxci5kZWZhdWx0KSh7fSxvKSxwcmV2aW91czooMCxxci5kZWZhdWx0KSh7fSxvKSxkZWx0YTp7bGVmdDowLHJpZ2h0OjAsd2lkdGg6MCx0b3A6MCxib3R0b206MCxoZWlnaHQ6MH19LHIuZWRnZXM9bi5wcmVwYXJlZC5lZGdlcyxyLnJlY3Q9bi5fcmVjdHMuY29ycmVjdGVkLHIuZGVsdGFSZWN0PW4uX3JlY3RzLmRlbHRhfX0odCksJHIodCl9LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlXCI6ZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbjtpZihcInJlc2l6ZVwiPT09bi5wcmVwYXJlZC5uYW1lJiZuLnByZXBhcmVkLmVkZ2VzKXt2YXIgcj1lLG89bi5pbnRlcmFjdGFibGUub3B0aW9ucy5yZXNpemUuaW52ZXJ0LGk9XCJyZXBvc2l0aW9uXCI9PT1vfHxcIm5lZ2F0ZVwiPT09byxhPW4ucmVjdCx1PW4uX3JlY3RzLHM9dS5zdGFydCxsPXUuY29ycmVjdGVkLGM9dS5kZWx0YSxmPXUucHJldmlvdXM7aWYoKDAscXIuZGVmYXVsdCkoZixsKSxpKXtpZigoMCxxci5kZWZhdWx0KShsLGEpLFwicmVwb3NpdGlvblwiPT09byl7aWYobC50b3A+bC5ib3R0b20pe3ZhciBwPWwudG9wO2wudG9wPWwuYm90dG9tLGwuYm90dG9tPXB9aWYobC5sZWZ0PmwucmlnaHQpe3ZhciBkPWwubGVmdDtsLmxlZnQ9bC5yaWdodCxsLnJpZ2h0PWR9fX1lbHNlIGwudG9wPU1hdGgubWluKGEudG9wLHMuYm90dG9tKSxsLmJvdHRvbT1NYXRoLm1heChhLmJvdHRvbSxzLnRvcCksbC5sZWZ0PU1hdGgubWluKGEubGVmdCxzLnJpZ2h0KSxsLnJpZ2h0PU1hdGgubWF4KGEucmlnaHQscy5sZWZ0KTtmb3IodmFyIHYgaW4gbC53aWR0aD1sLnJpZ2h0LWwubGVmdCxsLmhlaWdodD1sLmJvdHRvbS1sLnRvcCxsKWNbdl09bFt2XS1mW3ZdO3IuZWRnZXM9bi5wcmVwYXJlZC5lZGdlcyxyLnJlY3Q9bCxyLmRlbHRhUmVjdD1jfX0odCksJHIodCl9LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1lbmRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb247aWYoXCJyZXNpemVcIj09PW4ucHJlcGFyZWQubmFtZSYmbi5wcmVwYXJlZC5lZGdlcyl7dmFyIHI9ZTtyLmVkZ2VzPW4ucHJlcGFyZWQuZWRnZXMsci5yZWN0PW4uX3JlY3RzLmNvcnJlY3RlZCxyLmRlbHRhUmVjdD1uLl9yZWN0cy5kZWx0YX19LFwiYXV0by1zdGFydDpjaGVja1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmludGVyYWN0YWJsZSxyPXQuZWxlbWVudCxvPXQucmVjdCxpPXQuYnV0dG9ucztpZihvKXt2YXIgYT0oMCxxci5kZWZhdWx0KSh7fSxlLmNvb3Jkcy5jdXIucGFnZSksdT1uLm9wdGlvbnMucmVzaXplO2lmKHUmJnUuZW5hYmxlZCYmKCFlLnBvaW50ZXJJc0Rvd258fCEvbW91c2V8cG9pbnRlci8udGVzdChlLnBvaW50ZXJUeXBlKXx8MCE9KGkmdS5tb3VzZUJ1dHRvbnMpKSl7aWYoVXIub2JqZWN0KHUuZWRnZXMpKXt2YXIgcz17bGVmdDohMSxyaWdodDohMSx0b3A6ITEsYm90dG9tOiExfTtmb3IodmFyIGwgaW4gcylzW2xdPUtyKGwsdS5lZGdlc1tsXSxhLGUuX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQscixvLHUubWFyZ2lufHxaci5kZWZhdWx0TWFyZ2luKTtzLmxlZnQ9cy5sZWZ0JiYhcy5yaWdodCxzLnRvcD1zLnRvcCYmIXMuYm90dG9tLChzLmxlZnR8fHMucmlnaHR8fHMudG9wfHxzLmJvdHRvbSkmJih0LmFjdGlvbj17bmFtZTpcInJlc2l6ZVwiLGVkZ2VzOnN9KX1lbHNle3ZhciBjPVwieVwiIT09dS5heGlzJiZhLng+by5yaWdodC1aci5kZWZhdWx0TWFyZ2luLGY9XCJ4XCIhPT11LmF4aXMmJmEueT5vLmJvdHRvbS1aci5kZWZhdWx0TWFyZ2luOyhjfHxmKSYmKHQuYWN0aW9uPXtuYW1lOlwicmVzaXplXCIsYXhlczooYz9cInhcIjpcIlwiKSsoZj9cInlcIjpcIlwiKX0pfXJldHVybiF0LmFjdGlvbiYmdm9pZCAwfX19fSxkZWZhdWx0czp7c3F1YXJlOiExLHByZXNlcnZlQXNwZWN0UmF0aW86ITEsYXhpczpcInh5XCIsbWFyZ2luOk5hTixlZGdlczpudWxsLGludmVydDpcIm5vbmVcIn0sY3Vyc29yczpudWxsLGdldEN1cnNvcjpmdW5jdGlvbih0KXt2YXIgZT10LmVkZ2VzLG49dC5heGlzLHI9dC5uYW1lLG89WnIuY3Vyc29ycyxpPW51bGw7aWYobilpPW9bcituXTtlbHNlIGlmKGUpe2Zvcih2YXIgYT1cIlwiLHU9W1widG9wXCIsXCJib3R0b21cIixcImxlZnRcIixcInJpZ2h0XCJdLHM9MDtzPHUubGVuZ3RoO3MrKyl7dmFyIGw9dVtzXTtlW2xdJiYoYSs9bCl9aT1vW2FdfXJldHVybiBpfSxkZWZhdWx0TWFyZ2luOm51bGx9LEpyPVpyO05yLmRlZmF1bHQ9SnI7dmFyIFFyPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShRcixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoUXIsXCJkcmFnXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRvLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFFyLFwiZHJvcFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlby5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRcixcImdlc3R1cmVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbm8uZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoUXIsXCJyZXNpemVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcm8uZGVmYXVsdH19KSxRci5kZWZhdWx0PXZvaWQgMDt2YXIgdG89b28odiksZW89b28obXIpLG5vPW9vKEFyKSxybz1vbyhOcik7ZnVuY3Rpb24gb28odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fXZhciBpbz17aWQ6XCJhY3Rpb25zXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LnVzZVBsdWdpbihuby5kZWZhdWx0KSx0LnVzZVBsdWdpbihyby5kZWZhdWx0KSx0LnVzZVBsdWdpbih0by5kZWZhdWx0KSx0LnVzZVBsdWdpbihlby5kZWZhdWx0KX19O1FyLmRlZmF1bHQ9aW87dmFyIGFvPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShhbyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxhby5kZWZhdWx0PXZvaWQgMDthby5kZWZhdWx0PXt9O3ZhciB1bz17fTtmdW5jdGlvbiBzbyh0KXtyZXR1cm4oc289XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1byxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx1by5nZXRDb250YWluZXI9Z28sdW8uZ2V0U2Nyb2xsPWJvLHVvLmdldFNjcm9sbFNpemU9ZnVuY3Rpb24odCl7Zm8ud2luZG93KHQpJiYodD13aW5kb3cuZG9jdW1lbnQuYm9keSk7cmV0dXJue3g6dC5zY3JvbGxXaWR0aCx5OnQuc2Nyb2xsSGVpZ2h0fX0sdW8uZ2V0U2Nyb2xsU2l6ZURlbHRhPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQuZWxlbWVudCxvPW4mJm4uaW50ZXJhY3RhYmxlLm9wdGlvbnNbbi5wcmVwYXJlZC5uYW1lXS5hdXRvU2Nyb2xsO2lmKCFvfHwhby5lbmFibGVkKXJldHVybiBlKCkse3g6MCx5OjB9O3ZhciBpPWdvKG8uY29udGFpbmVyLG4uaW50ZXJhY3RhYmxlLHIpLGE9Ym8oaSk7ZSgpO3ZhciB1PWJvKGkpO3JldHVybnt4OnUueC1hLngseTp1LnktYS55fX0sdW8uZGVmYXVsdD12b2lkIDA7dmFyIGxvLGNvPXlvKCQpLGZvPXlvKHcpLHBvPShsbz1vZSkmJmxvLl9fZXNNb2R1bGU/bG86e2RlZmF1bHQ6bG99O2Z1bmN0aW9uIHZvKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gdm89ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiB5byh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1zbyh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT12bygpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufXZhciBobz17ZGVmYXVsdHM6e2VuYWJsZWQ6ITEsbWFyZ2luOjYwLGNvbnRhaW5lcjpudWxsLHNwZWVkOjMwMH0sbm93OkRhdGUubm93LGludGVyYWN0aW9uOm51bGwsaTowLHg6MCx5OjAsaXNTY3JvbGxpbmc6ITEscHJldlRpbWU6MCxtYXJnaW46MCxzcGVlZDowLHN0YXJ0OmZ1bmN0aW9uKHQpe2hvLmlzU2Nyb2xsaW5nPSEwLHBvLmRlZmF1bHQuY2FuY2VsKGhvLmkpLCh0LmF1dG9TY3JvbGw9aG8pLmludGVyYWN0aW9uPXQsaG8ucHJldlRpbWU9aG8ubm93KCksaG8uaT1wby5kZWZhdWx0LnJlcXVlc3QoaG8uc2Nyb2xsKX0sc3RvcDpmdW5jdGlvbigpe2hvLmlzU2Nyb2xsaW5nPSExLGhvLmludGVyYWN0aW9uJiYoaG8uaW50ZXJhY3Rpb24uYXV0b1Njcm9sbD1udWxsKSxwby5kZWZhdWx0LmNhbmNlbChoby5pKX0sc2Nyb2xsOmZ1bmN0aW9uKCl7dmFyIHQ9aG8uaW50ZXJhY3Rpb24sZT10LmludGVyYWN0YWJsZSxuPXQuZWxlbWVudCxyPXQucHJlcGFyZWQubmFtZSxvPWUub3B0aW9uc1tyXS5hdXRvU2Nyb2xsLGk9Z28oby5jb250YWluZXIsZSxuKSxhPWhvLm5vdygpLHU9KGEtaG8ucHJldlRpbWUpLzFlMyxzPW8uc3BlZWQqdTtpZigxPD1zKXt2YXIgbD17eDpoby54KnMseTpoby55KnN9O2lmKGwueHx8bC55KXt2YXIgYz1ibyhpKTtmby53aW5kb3coaSk/aS5zY3JvbGxCeShsLngsbC55KTppJiYoaS5zY3JvbGxMZWZ0Kz1sLngsaS5zY3JvbGxUb3ArPWwueSk7dmFyIGY9Ym8oaSkscD17eDpmLngtYy54LHk6Zi55LWMueX07KHAueHx8cC55KSYmZS5maXJlKHt0eXBlOlwiYXV0b3Njcm9sbFwiLHRhcmdldDpuLGludGVyYWN0YWJsZTplLGRlbHRhOnAsaW50ZXJhY3Rpb246dCxjb250YWluZXI6aX0pfWhvLnByZXZUaW1lPWF9aG8uaXNTY3JvbGxpbmcmJihwby5kZWZhdWx0LmNhbmNlbChoby5pKSxoby5pPXBvLmRlZmF1bHQucmVxdWVzdChoby5zY3JvbGwpKX0sY2hlY2s6ZnVuY3Rpb24odCxlKXt2YXIgbj10Lm9wdGlvbnM7cmV0dXJuIG5bZV0uYXV0b1Njcm9sbCYmbltlXS5hdXRvU2Nyb2xsLmVuYWJsZWR9LG9uSW50ZXJhY3Rpb25Nb3ZlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LnBvaW50ZXI7aWYoZS5pbnRlcmFjdGluZygpJiZoby5jaGVjayhlLmludGVyYWN0YWJsZSxlLnByZXBhcmVkLm5hbWUpKWlmKGUuc2ltdWxhdGlvbiloby54PWhvLnk9MDtlbHNle3ZhciByLG8saSxhLHU9ZS5pbnRlcmFjdGFibGUscz1lLmVsZW1lbnQsbD1lLnByZXBhcmVkLm5hbWUsYz11Lm9wdGlvbnNbbF0uYXV0b1Njcm9sbCxmPWdvKGMuY29udGFpbmVyLHUscyk7aWYoZm8ud2luZG93KGYpKWE9bi5jbGllbnRYPGhvLm1hcmdpbixyPW4uY2xpZW50WTxoby5tYXJnaW4sbz1uLmNsaWVudFg+Zi5pbm5lcldpZHRoLWhvLm1hcmdpbixpPW4uY2xpZW50WT5mLmlubmVySGVpZ2h0LWhvLm1hcmdpbjtlbHNle3ZhciBwPWNvLmdldEVsZW1lbnRDbGllbnRSZWN0KGYpO2E9bi5jbGllbnRYPHAubGVmdCtoby5tYXJnaW4scj1uLmNsaWVudFk8cC50b3AraG8ubWFyZ2luLG89bi5jbGllbnRYPnAucmlnaHQtaG8ubWFyZ2luLGk9bi5jbGllbnRZPnAuYm90dG9tLWhvLm1hcmdpbn1oby54PW8/MTphPy0xOjAsaG8ueT1pPzE6cj8tMTowLGhvLmlzU2Nyb2xsaW5nfHwoaG8ubWFyZ2luPWMubWFyZ2luLGhvLnNwZWVkPWMuc3BlZWQsaG8uc3RhcnQoZSkpfX19O2Z1bmN0aW9uIGdvKHQsZSxuKXtyZXR1cm4oZm8uc3RyaW5nKHQpPygwLCR0LmdldFN0cmluZ09wdGlvblJlc3VsdCkodCxlLG4pOnQpfHwoMCxPLmdldFdpbmRvdykobil9ZnVuY3Rpb24gYm8odCl7cmV0dXJuIGZvLndpbmRvdyh0KSYmKHQ9d2luZG93LmRvY3VtZW50LmJvZHkpLHt4OnQuc2Nyb2xsTGVmdCx5OnQuc2Nyb2xsVG9wfX12YXIgbW89e2lkOlwiYXV0by1zY3JvbGxcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZGVmYXVsdHMsbj10LmFjdGlvbnM7KHQuYXV0b1Njcm9sbD1obykubm93PWZ1bmN0aW9uKCl7cmV0dXJuIHQubm93KCl9LG4ucGhhc2VsZXNzVHlwZXMuYXV0b3Njcm9sbD0hMCxlLnBlckFjdGlvbi5hdXRvU2Nyb2xsPWhvLmRlZmF1bHRzfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3QuaW50ZXJhY3Rpb24uYXV0b1Njcm9sbD1udWxsfSxcImludGVyYWN0aW9uczpkZXN0cm95XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5hdXRvU2Nyb2xsPW51bGwsaG8uc3RvcCgpLGhvLmludGVyYWN0aW9uJiYoaG8uaW50ZXJhY3Rpb249bnVsbCl9LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpoby5zdG9wLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGhvLm9uSW50ZXJhY3Rpb25Nb3ZlKHQpfX19O3VvLmRlZmF1bHQ9bW87dmFyIE9vPXt9O2Z1bmN0aW9uIHdvKHQpe3JldHVybih3bz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KE9vLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE9vLmRlZmF1bHQ9dm9pZCAwO3ZhciBfbz1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT13byh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1QbygpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh3KTtmdW5jdGlvbiBQbygpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIFBvPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24geG8odCl7cmV0dXJuIF9vLmJvb2wodCk/KHRoaXMub3B0aW9ucy5zdHlsZUN1cnNvcj10LHRoaXMpOm51bGw9PT10PyhkZWxldGUgdGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yLHRoaXMpOnRoaXMub3B0aW9ucy5zdHlsZUN1cnNvcn1mdW5jdGlvbiBTbyh0KXtyZXR1cm4gX28uZnVuYyh0KT8odGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXI9dCx0aGlzKTpudWxsPT09dD8oZGVsZXRlIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyLHRoaXMpOnRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyfXZhciBqbz17aWQ6XCJhdXRvLXN0YXJ0L2ludGVyYWN0YWJsZU1ldGhvZHNcIixpbnN0YWxsOmZ1bmN0aW9uKGQpe3ZhciB0PWQuSW50ZXJhY3RhYmxlO3QucHJvdG90eXBlLmdldEFjdGlvbj1mdW5jdGlvbih0LGUsbixyKXt2YXIgbyxpLGEsdSxzLGwsYyxmLHA9KGk9ZSxhPW4sdT1yLHM9ZCxsPShvPXRoaXMpLmdldFJlY3QodSksYz1pLmJ1dHRvbnN8fHswOjEsMTo0LDM6OCw0OjE2fVtpLmJ1dHRvbl0sZj17YWN0aW9uOm51bGwsaW50ZXJhY3RhYmxlOm8saW50ZXJhY3Rpb246YSxlbGVtZW50OnUscmVjdDpsLGJ1dHRvbnM6Y30scy5maXJlKFwiYXV0by1zdGFydDpjaGVja1wiLGYpLGYuYWN0aW9uKTtyZXR1cm4gdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXI/dGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXIodCxlLHAsdGhpcyxyLG4pOnB9LHQucHJvdG90eXBlLmlnbm9yZUZyb209KDAsbGUud2Fybk9uY2UpKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9iYWNrQ29tcGF0T3B0aW9uKFwiaWdub3JlRnJvbVwiLHQpfSxcIkludGVyYWN0YWJsZS5pZ25vcmVGcm9tKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIEludGVyYWN0YmxlLmRyYWdnYWJsZSh7aWdub3JlRnJvbTogbmV3VmFsdWV9KS5cIiksdC5wcm90b3R5cGUuYWxsb3dGcm9tPSgwLGxlLndhcm5PbmNlKShmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYmFja0NvbXBhdE9wdGlvbihcImFsbG93RnJvbVwiLHQpfSxcIkludGVyYWN0YWJsZS5hbGxvd0Zyb20oKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgSW50ZXJhY3RibGUuZHJhZ2dhYmxlKHthbGxvd0Zyb206IG5ld1ZhbHVlfSkuXCIpLHQucHJvdG90eXBlLmFjdGlvbkNoZWNrZXI9U28sdC5wcm90b3R5cGUuc3R5bGVDdXJzb3I9eG99fTtPby5kZWZhdWx0PWpvO3ZhciBNbz17fTtmdW5jdGlvbiBrbyh0KXtyZXR1cm4oa289XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShNbyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxNby5kZWZhdWx0PXZvaWQgMDt2YXIgRW8sVG89ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09a28odCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9SW8oKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0obGUpLERvPShFbz1PbykmJkVvLl9fZXNNb2R1bGU/RW86e2RlZmF1bHQ6RW99O2Z1bmN0aW9uIElvKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gSW89ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiB6byh0LGUsbixyLG8pe3JldHVybiBlLnRlc3RJZ25vcmVBbGxvdyhlLm9wdGlvbnNbdC5uYW1lXSxuLHIpJiZlLm9wdGlvbnNbdC5uYW1lXS5lbmFibGVkJiZSbyhlLG4sdCxvKT90Om51bGx9ZnVuY3Rpb24gQW8odCxlLG4scixvLGksYSl7Zm9yKHZhciB1PTAscz1yLmxlbmd0aDt1PHM7dSsrKXt2YXIgbD1yW3VdLGM9b1t1XSxmPWwuZ2V0QWN0aW9uKGUsbix0LGMpO2lmKGYpe3ZhciBwPXpvKGYsbCxjLGksYSk7aWYocClyZXR1cm57YWN0aW9uOnAsaW50ZXJhY3RhYmxlOmwsZWxlbWVudDpjfX19cmV0dXJue2FjdGlvbjpudWxsLGludGVyYWN0YWJsZTpudWxsLGVsZW1lbnQ6bnVsbH19ZnVuY3Rpb24gQ28odCxlLG4scixvKXt2YXIgaT1bXSxhPVtdLHU9cjtmdW5jdGlvbiBzKHQpe2kucHVzaCh0KSxhLnB1c2godSl9Zm9yKDtUby5pcy5lbGVtZW50KHUpOyl7aT1bXSxhPVtdLG8uaW50ZXJhY3RhYmxlcy5mb3JFYWNoTWF0Y2godSxzKTt2YXIgbD1Bbyh0LGUsbixpLGEscixvKTtpZihsLmFjdGlvbiYmIWwuaW50ZXJhY3RhYmxlLm9wdGlvbnNbbC5hY3Rpb24ubmFtZV0ubWFudWFsU3RhcnQpcmV0dXJuIGw7dT1Uby5kb20ucGFyZW50Tm9kZSh1KX1yZXR1cm57YWN0aW9uOm51bGwsaW50ZXJhY3RhYmxlOm51bGwsZWxlbWVudDpudWxsfX1mdW5jdGlvbiBXbyh0LGUsbil7dmFyIHI9ZS5hY3Rpb24sbz1lLmludGVyYWN0YWJsZSxpPWUuZWxlbWVudDtyPXJ8fHtuYW1lOm51bGx9LHQuaW50ZXJhY3RhYmxlPW8sdC5lbGVtZW50PWksVG8uY29weUFjdGlvbih0LnByZXBhcmVkLHIpLHQucmVjdD1vJiZyLm5hbWU/by5nZXRSZWN0KGkpOm51bGwsWW8odCxuKSxuLmZpcmUoXCJhdXRvU3RhcnQ6cHJlcGFyZWRcIix7aW50ZXJhY3Rpb246dH0pfWZ1bmN0aW9uIFJvKHQsZSxuLHIpe3ZhciBvPXQub3B0aW9ucyxpPW9bbi5uYW1lXS5tYXgsYT1vW24ubmFtZV0ubWF4UGVyRWxlbWVudCx1PXIuYXV0b1N0YXJ0Lm1heEludGVyYWN0aW9ucyxzPTAsbD0wLGM9MDtpZighKGkmJmEmJnUpKXJldHVybiExO2Zvcih2YXIgZj0wO2Y8ci5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7ZisrKXt2YXIgcD1yLmludGVyYWN0aW9ucy5saXN0W2ZdLGQ9cC5wcmVwYXJlZC5uYW1lO2lmKHAuaW50ZXJhY3RpbmcoKSl7aWYodTw9KytzKXJldHVybiExO2lmKHAuaW50ZXJhY3RhYmxlPT09dCl7aWYoaTw9KGwrPWQ9PT1uLm5hbWU/MTowKSlyZXR1cm4hMTtpZihwLmVsZW1lbnQ9PT1lJiYoYysrLGQ9PT1uLm5hbWUmJmE8PWMpKXJldHVybiExfX19cmV0dXJuIDA8dX1mdW5jdGlvbiBGbyh0LGUpe3JldHVybiBUby5pcy5udW1iZXIodCk/KGUuYXV0b1N0YXJ0Lm1heEludGVyYWN0aW9ucz10LHRoaXMpOmUuYXV0b1N0YXJ0Lm1heEludGVyYWN0aW9uc31mdW5jdGlvbiBYbyh0LGUsbil7dmFyIHI9bi5hdXRvU3RhcnQuY3Vyc29yRWxlbWVudDtyJiZyIT09dCYmKHIuc3R5bGUuY3Vyc29yPVwiXCIpLHQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3Vyc29yPWUsdC5zdHlsZS5jdXJzb3I9ZSxuLmF1dG9TdGFydC5jdXJzb3JFbGVtZW50PWU/dDpudWxsfWZ1bmN0aW9uIFlvKHQsZSl7dmFyIG49dC5pbnRlcmFjdGFibGUscj10LmVsZW1lbnQsbz10LnByZXBhcmVkO2lmKFwibW91c2VcIj09PXQucG9pbnRlclR5cGUmJm4mJm4ub3B0aW9ucy5zdHlsZUN1cnNvcil7dmFyIGk9XCJcIjtpZihvLm5hbWUpe3ZhciBhPW4ub3B0aW9uc1tvLm5hbWVdLmN1cnNvckNoZWNrZXI7aT1Uby5pcy5mdW5jKGEpP2EobyxuLHIsdC5faW50ZXJhY3RpbmcpOmUuYWN0aW9ucy5tYXBbby5uYW1lXS5nZXRDdXJzb3Iobyl9WG8odC5lbGVtZW50LGl8fFwiXCIsZSl9ZWxzZSBlLmF1dG9TdGFydC5jdXJzb3JFbGVtZW50JiZYbyhlLmF1dG9TdGFydC5jdXJzb3JFbGVtZW50LFwiXCIsZSl9dmFyIE5vPXtpZDpcImF1dG8tc3RhcnQvYmFzZVwiLGJlZm9yZTpbXCJhY3Rpb25zXCIsXCJhY3Rpb25zL2RyYWdcIixcImFjdGlvbnMvcmVzaXplXCIsXCJhY3Rpb25zL2dlc3R1cmVcIl0saW5zdGFsbDpmdW5jdGlvbihlKXt2YXIgdD1lLmludGVyYWN0U3RhdGljLG49ZS5kZWZhdWx0cztlLnVzZVBsdWdpbihEby5kZWZhdWx0KSxuLmJhc2UuYWN0aW9uQ2hlY2tlcj1udWxsLG4uYmFzZS5zdHlsZUN1cnNvcj0hMCxUby5leHRlbmQobi5wZXJBY3Rpb24se21hbnVhbFN0YXJ0OiExLG1heDoxLzAsbWF4UGVyRWxlbWVudDoxLGFsbG93RnJvbTpudWxsLGlnbm9yZUZyb206bnVsbCxtb3VzZUJ1dHRvbnM6MX0pLHQubWF4SW50ZXJhY3Rpb25zPWZ1bmN0aW9uKHQpe3JldHVybiBGbyh0LGUpfSxlLmF1dG9TdGFydD17bWF4SW50ZXJhY3Rpb25zOjEvMCx3aXRoaW5JbnRlcmFjdGlvbkxpbWl0OlJvLGN1cnNvckVsZW1lbnQ6bnVsbH19LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6ZG93blwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixvPXQuZXZlbnQsaT10LmV2ZW50VGFyZ2V0O24uaW50ZXJhY3RpbmcoKXx8V28obixDbyhuLHIsbyxpLGUpLGUpfSxcImludGVyYWN0aW9uczptb3ZlXCI6ZnVuY3Rpb24odCxlKXt2YXIgbixyLG8saSxhLHU7cj1lLG89KG49dCkuaW50ZXJhY3Rpb24saT1uLnBvaW50ZXIsYT1uLmV2ZW50LHU9bi5ldmVudFRhcmdldCxcIm1vdXNlXCIhPT1vLnBvaW50ZXJUeXBlfHxvLnBvaW50ZXJJc0Rvd258fG8uaW50ZXJhY3RpbmcoKXx8V28obyxDbyhvLGksYSx1LHIpLHIpLGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbjtpZihuLnBvaW50ZXJJc0Rvd24mJiFuLmludGVyYWN0aW5nKCkmJm4ucG9pbnRlcldhc01vdmVkJiZuLnByZXBhcmVkLm5hbWUpe2UuZmlyZShcImF1dG9TdGFydDpiZWZvcmUtc3RhcnRcIix0KTt2YXIgcj1uLmludGVyYWN0YWJsZSxvPW4ucHJlcGFyZWQubmFtZTtvJiZyJiYoci5vcHRpb25zW29dLm1hbnVhbFN0YXJ0fHwhUm8ocixuLmVsZW1lbnQsbi5wcmVwYXJlZCxlKT9uLnN0b3AoKToobi5zdGFydChuLnByZXBhcmVkLHIsbi5lbGVtZW50KSxZbyhuLGUpKSl9fSh0LGUpfSxcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9bi5pbnRlcmFjdGFibGU7ciYmci5vcHRpb25zLnN0eWxlQ3Vyc29yJiZYbyhuLmVsZW1lbnQsXCJcIixlKX19LG1heEludGVyYWN0aW9uczpGbyx3aXRoaW5JbnRlcmFjdGlvbkxpbWl0OlJvLHZhbGlkYXRlQWN0aW9uOnpvfTtNby5kZWZhdWx0PU5vO3ZhciBMbz17fTtmdW5jdGlvbiBCbyh0KXtyZXR1cm4oQm89XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShMbyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxMby5kZWZhdWx0PXZvaWQgMDt2YXIgVm8scW89ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09Qm8odCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9R28oKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0odyksVW89KFZvPU1vKSYmVm8uX19lc01vZHVsZT9Wbzp7ZGVmYXVsdDpWb307ZnVuY3Rpb24gR28oKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBHbz1mdW5jdGlvbigpe3JldHVybiB0fSx0fXZhciBIbz17aWQ6XCJhdXRvLXN0YXJ0L2RyYWdBeGlzXCIsbGlzdGVuZXJzOntcImF1dG9TdGFydDpiZWZvcmUtc3RhcnRcIjpmdW5jdGlvbih0LHIpe3ZhciBvPXQuaW50ZXJhY3Rpb24saT10LmV2ZW50VGFyZ2V0LGU9dC5keCxuPXQuZHk7aWYoXCJkcmFnXCI9PT1vLnByZXBhcmVkLm5hbWUpe3ZhciBhPU1hdGguYWJzKGUpLHU9TWF0aC5hYnMobikscz1vLmludGVyYWN0YWJsZS5vcHRpb25zLmRyYWcsbD1zLnN0YXJ0QXhpcyxjPXU8YT9cInhcIjphPHU/XCJ5XCI6XCJ4eVwiO2lmKG8ucHJlcGFyZWQuYXhpcz1cInN0YXJ0XCI9PT1zLmxvY2tBeGlzP2NbMF06cy5sb2NrQXhpcyxcInh5XCIhPWMmJlwieHlcIiE9PWwmJmwhPT1jKXtvLnByZXBhcmVkLm5hbWU9bnVsbDtmdW5jdGlvbiBmKHQpe2lmKHQhPT1vLmludGVyYWN0YWJsZSl7dmFyIGU9by5pbnRlcmFjdGFibGUub3B0aW9ucy5kcmFnO2lmKCFlLm1hbnVhbFN0YXJ0JiZ0LnRlc3RJZ25vcmVBbGxvdyhlLHAsaSkpe3ZhciBuPXQuZ2V0QWN0aW9uKG8uZG93blBvaW50ZXIsby5kb3duRXZlbnQsbyxwKTtpZihuJiZcImRyYWdcIj09PW4ubmFtZSYmZnVuY3Rpb24odCxlKXtpZighZSlyZXR1cm47dmFyIG49ZS5vcHRpb25zLmRyYWcuc3RhcnRBeGlzO3JldHVyblwieHlcIj09PXR8fFwieHlcIj09PW58fG49PT10fShjLHQpJiZVby5kZWZhdWx0LnZhbGlkYXRlQWN0aW9uKG4sdCxwLGkscikpcmV0dXJuIHR9fX1mb3IodmFyIHA9aTtxby5lbGVtZW50KHApOyl7dmFyIGQ9ci5pbnRlcmFjdGFibGVzLmZvckVhY2hNYXRjaChwLGYpO2lmKGQpe28ucHJlcGFyZWQubmFtZT1cImRyYWdcIixvLmludGVyYWN0YWJsZT1kLG8uZWxlbWVudD1wO2JyZWFrfXA9KDAsJC5wYXJlbnROb2RlKShwKX19fX19fTtMby5kZWZhdWx0PUhvO3ZhciBLbz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoS28sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksS28uZGVmYXVsdD12b2lkIDA7dmFyICRvLFpvPSgkbz1NbykmJiRvLl9fZXNNb2R1bGU/JG86e2RlZmF1bHQ6JG99O2Z1bmN0aW9uIEpvKHQpe3ZhciBlPXQucHJlcGFyZWQmJnQucHJlcGFyZWQubmFtZTtpZighZSlyZXR1cm4gbnVsbDt2YXIgbj10LmludGVyYWN0YWJsZS5vcHRpb25zO3JldHVybiBuW2VdLmhvbGR8fG5bZV0uZGVsYXl9dmFyIFFvPXtpZDpcImF1dG8tc3RhcnQvaG9sZFwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5kZWZhdWx0czt0LnVzZVBsdWdpbihaby5kZWZhdWx0KSxlLnBlckFjdGlvbi5ob2xkPTAsZS5wZXJBY3Rpb24uZGVsYXk9MH0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLmF1dG9TdGFydEhvbGRUaW1lcj1udWxsfSxcImF1dG9TdGFydDpwcmVwYXJlZFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj1KbyhlKTswPG4mJihlLmF1dG9TdGFydEhvbGRUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5zdGFydChlLnByZXBhcmVkLGUuaW50ZXJhY3RhYmxlLGUuZWxlbWVudCl9LG4pKX0sXCJpbnRlcmFjdGlvbnM6bW92ZVwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmR1cGxpY2F0ZTtlLnBvaW50ZXJXYXNNb3ZlZCYmIW4mJmNsZWFyVGltZW91dChlLmF1dG9TdGFydEhvbGRUaW1lcil9LFwiYXV0b1N0YXJ0OmJlZm9yZS1zdGFydFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247MDxKbyhlKSYmKGUucHJlcGFyZWQubmFtZT1udWxsKX19LGdldEhvbGREdXJhdGlvbjpKb307S28uZGVmYXVsdD1Rbzt2YXIgdGk9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHRpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aSxcImF1dG9TdGFydFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlaS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aSxcImRyYWdBeGlzXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5pLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRpLFwiaG9sZFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByaS5kZWZhdWx0fX0pLHRpLmRlZmF1bHQ9dm9pZCAwO3ZhciBlaT1vaShNbyksbmk9b2koTG8pLHJpPW9pKEtvKTtmdW5jdGlvbiBvaSh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19dmFyIGlpPXtpZDpcImF1dG8tc3RhcnRcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3QudXNlUGx1Z2luKGVpLmRlZmF1bHQpLHQudXNlUGx1Z2luKHJpLmRlZmF1bHQpLHQudXNlUGx1Z2luKG5pLmRlZmF1bHQpfX07dGkuZGVmYXVsdD1paTt2YXIgYWk9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KGFpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGFpLmRlZmF1bHQ9dm9pZCAwO2FpLmRlZmF1bHQ9e307dmFyIHVpPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1aSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx1aS5kZWZhdWx0PXZvaWQgMDt1aS5kZWZhdWx0PXt9O3ZhciBzaT17fTtmdW5jdGlvbiBsaSh0KXtyZXR1cm4obGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxzaS5kZWZhdWx0PXZvaWQgMDt2YXIgY2ksZmkscGk9aGkoRCksZGk9KGhpKGN0KSxmdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1saSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT15aSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh3KSksdmk9aGkoTyk7ZnVuY3Rpb24geWkoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiB5aT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIGhpKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX0oZmk9Y2k9Y2l8fHt9KS50b3VjaEFjdGlvbj1cInRvdWNoQWN0aW9uXCIsZmkuYm94U2l6aW5nPVwiYm94U2l6aW5nXCIsZmkubm9MaXN0ZW5lcnM9XCJub0xpc3RlbmVyc1wiO3ZhciBnaT17dG91Y2hBY3Rpb246XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdG91Y2gtYWN0aW9uXCIsYm94U2l6aW5nOlwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2JveC1zaXppbmdcIn07Y2kudG91Y2hBY3Rpb24sY2kuYm94U2l6aW5nLGNpLm5vTGlzdGVuZXJzO2Z1bmN0aW9uIGJpKHQsZSxuKXtyZXR1cm4gbi50ZXN0KHQuc3R5bGVbZV18fHZpLmRlZmF1bHQud2luZG93LmdldENvbXB1dGVkU3R5bGUodClbZV0pfXZhciBtaT1cImRldi10b29sc1wiLE9pPXtpZDptaSxpbnN0YWxsOmZ1bmN0aW9uKCl7fX07c2kuZGVmYXVsdD1PaTt2YXIgd2k9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHdpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHdpLmRlZmF1bHQ9dm9pZCAwO3dpLmRlZmF1bHQ9e307dmFyIF9pPXt9O2Z1bmN0aW9uIFBpKHQpe3JldHVybihQaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KF9pLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLF9pLmdldFJlY3RPZmZzZXQ9QWksX2kuZGVmYXVsdD12b2lkIDA7dmFyIHhpPWtpKFYpLFNpPWtpKGN0KSxqaT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1QaSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1NaSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSgkdCk7ZnVuY3Rpb24gTWkoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBNaT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIGtpKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBFaSh0LGUpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0fSh0KXx8ZnVuY3Rpb24odCxlKXtpZighKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpKXJldHVybjt2YXIgbj1bXSxyPSEwLG89ITEsaT12b2lkIDA7dHJ5e2Zvcih2YXIgYSx1PXRbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0oYT11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goYS52YWx1ZSksIWV8fG4ubGVuZ3RoIT09ZSk7cj0hMCk7fWNhdGNoKHQpe289ITAsaT10fWZpbmFsbHl7dHJ5e3J8fG51bGw9PXUucmV0dXJufHx1LnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn0odCxlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX1mdW5jdGlvbiBUaSh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gRGkodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBJaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0aGlzLmludGVyYWN0aW9uPXQsRGkodGhpcyxcInN0YXRlc1wiLFtdKSxEaSh0aGlzLFwic3RhcnRPZmZzZXRcIix7bGVmdDowLHJpZ2h0OjAsdG9wOjAsYm90dG9tOjB9KSxEaSh0aGlzLFwic3RhcnREZWx0YVwiLG51bGwpLERpKHRoaXMsXCJyZXN1bHRcIixudWxsKSxEaSh0aGlzLFwiZW5kUmVzdWx0XCIsbnVsbCksRGkodGhpcyxcImVkZ2VzXCIsdm9pZCAwKSx0aGlzLnJlc3VsdD16aSgpfXZhciB0LG4scjtyZXR1cm4gdD1lLChuPVt7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQucGhhc2Uscj10aGlzLmludGVyYWN0aW9uLG89ZnVuY3Rpb24odCl7dmFyIG49dC5pbnRlcmFjdGFibGUub3B0aW9uc1t0LnByZXBhcmVkLm5hbWVdLGU9bi5tb2RpZmllcnM7aWYoZSYmZS5sZW5ndGgpcmV0dXJuIGUuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiF0Lm9wdGlvbnN8fCExIT09dC5vcHRpb25zLmVuYWJsZWR9KTtyZXR1cm5bXCJzbmFwXCIsXCJzbmFwU2l6ZVwiLFwic25hcEVkZ2VzXCIsXCJyZXN0cmljdFwiLFwicmVzdHJpY3RFZGdlc1wiLFwicmVzdHJpY3RTaXplXCJdLm1hcChmdW5jdGlvbih0KXt2YXIgZT1uW3RdO3JldHVybiBlJiZlLmVuYWJsZWQmJntvcHRpb25zOmUsbWV0aG9kczplLl9tZXRob2RzfX0pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hIXR9KX0ocik7dGhpcy5wcmVwYXJlU3RhdGVzKG8pLHRoaXMuZWRnZXM9KDAsU2kuZGVmYXVsdCkoe30sci5lZGdlcyksdGhpcy5zdGFydE9mZnNldD1BaShyLnJlY3QsZSk7dmFyIGk9e3BoYXNlOm4scGFnZUNvb3JkczplLHByZUVuZDohKHRoaXMuc3RhcnREZWx0YT17eDowLHk6MH0pfTtyZXR1cm4gdGhpcy5yZXN1bHQ9emkoKSx0aGlzLnN0YXJ0QWxsKGkpLHRoaXMucmVzdWx0PXRoaXMuc2V0QWxsKGkpfX0se2tleTpcImZpbGxBcmdcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyYWN0aW9uO3QuaW50ZXJhY3Rpb249ZSx0LmludGVyYWN0YWJsZT1lLmludGVyYWN0YWJsZSx0LmVsZW1lbnQ9ZS5lbGVtZW50LHQucmVjdD10LnJlY3R8fGUucmVjdCx0LmVkZ2VzPXRoaXMuZWRnZXMsdC5zdGFydE9mZnNldD10aGlzLnN0YXJ0T2Zmc2V0fX0se2tleTpcInN0YXJ0QWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5maWxsQXJnKHQpO2Zvcih2YXIgZT0wO2U8dGhpcy5zdGF0ZXMubGVuZ3RoO2UrKyl7dmFyIG49dGhpcy5zdGF0ZXNbZV07bi5tZXRob2RzLnN0YXJ0JiYodC5zdGF0ZT1uKS5tZXRob2RzLnN0YXJ0KHQpfX19LHtrZXk6XCJzZXRBbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmZpbGxBcmcodCk7dmFyIGU9dC5waGFzZSxuPXQucHJlRW5kLHI9dC5za2lwTW9kaWZpZXJzLG89dC5yZWN0O3QuY29vcmRzPSgwLFNpLmRlZmF1bHQpKHt9LHQucGFnZUNvb3JkcyksdC5yZWN0PSgwLFNpLmRlZmF1bHQpKHt9LG8pO2Zvcih2YXIgaT1yP3RoaXMuc3RhdGVzLnNsaWNlKHIpOnRoaXMuc3RhdGVzLGE9emkodC5jb29yZHMsdC5yZWN0KSx1PTA7dTxpLmxlbmd0aDt1Kyspe3ZhciBzPWlbdV0sbD1zLm9wdGlvbnMsYz0oMCxTaS5kZWZhdWx0KSh7fSx0LmNvb3JkcyksZj1udWxsO3MubWV0aG9kcy5zZXQmJnRoaXMuc2hvdWxkRG8obCxuLGUpJiYoZj0odC5zdGF0ZT1zKS5tZXRob2RzLnNldCh0KSxqaS5hZGRFZGdlcyh0aGlzLmludGVyYWN0aW9uLmVkZ2VzLHQucmVjdCx7eDp0LmNvb3Jkcy54LWMueCx5OnQuY29vcmRzLnktYy55fSkpLGEuZXZlbnRQcm9wcy5wdXNoKGYpfWEuZGVsdGEueD10LmNvb3Jkcy54LXQucGFnZUNvb3Jkcy54LGEuZGVsdGEueT10LmNvb3Jkcy55LXQucGFnZUNvb3Jkcy55LGEucmVjdERlbHRhLmxlZnQ9dC5yZWN0LmxlZnQtby5sZWZ0LGEucmVjdERlbHRhLnJpZ2h0PXQucmVjdC5yaWdodC1vLnJpZ2h0LGEucmVjdERlbHRhLnRvcD10LnJlY3QudG9wLW8udG9wLGEucmVjdERlbHRhLmJvdHRvbT10LnJlY3QuYm90dG9tLW8uYm90dG9tO3ZhciBwPXRoaXMucmVzdWx0LmNvb3JkcyxkPXRoaXMucmVzdWx0LnJlY3Q7aWYocCYmZCl7dmFyIHY9YS5yZWN0LmxlZnQhPT1kLmxlZnR8fGEucmVjdC5yaWdodCE9PWQucmlnaHR8fGEucmVjdC50b3AhPT1kLnRvcHx8YS5yZWN0LmJvdHRvbSE9PWQuYm90dG9tO2EuY2hhbmdlZD12fHxwLnghPT1hLmNvb3Jkcy54fHxwLnkhPT1hLmNvb3Jkcy55fXJldHVybiBhfX0se2tleTpcImFwcGx5VG9JbnRlcmFjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaW50ZXJhY3Rpb24sbj10LnBoYXNlLHI9ZS5jb29yZHMuY3VyLG89ZS5jb29yZHMuc3RhcnQsaT10aGlzLnJlc3VsdCxhPXRoaXMuc3RhcnREZWx0YSx1PWkuZGVsdGE7XCJzdGFydFwiPT09biYmKDAsU2kuZGVmYXVsdCkodGhpcy5zdGFydERlbHRhLGkuZGVsdGEpO2Zvcih2YXIgcz0wO3M8W1tvLGFdLFtyLHVdXS5sZW5ndGg7cysrKXt2YXIgbD1FaShbW28sYV0sW3IsdV1dW3NdLDIpLGM9bFswXSxmPWxbMV07Yy5wYWdlLngrPWYueCxjLnBhZ2UueSs9Zi55LGMuY2xpZW50LngrPWYueCxjLmNsaWVudC55Kz1mLnl9dmFyIHA9dGhpcy5yZXN1bHQucmVjdERlbHRhLGQ9dC5yZWN0fHxlLnJlY3Q7ZC5sZWZ0Kz1wLmxlZnQsZC5yaWdodCs9cC5yaWdodCxkLnRvcCs9cC50b3AsZC5ib3R0b20rPXAuYm90dG9tLGQud2lkdGg9ZC5yaWdodC1kLmxlZnQsZC5oZWlnaHQ9ZC5ib3R0b20tZC50b3B9fSx7a2V5Olwic2V0QW5kQXBwbHlcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyYWN0aW9uLG49dC5waGFzZSxyPXQucHJlRW5kLG89dC5za2lwTW9kaWZpZXJzLGk9dGhpcy5zZXRBbGwoe3ByZUVuZDpyLHBoYXNlOm4scGFnZUNvb3Jkczp0Lm1vZGlmaWVkQ29vcmRzfHxlLmNvb3Jkcy5jdXIucGFnZX0pO2lmKCEodGhpcy5yZXN1bHQ9aSkuY2hhbmdlZCYmKCFvfHxvPHRoaXMuc3RhdGVzLmxlbmd0aCkmJmUuaW50ZXJhY3RpbmcoKSlyZXR1cm4hMTtpZih0Lm1vZGlmaWVkQ29vcmRzKXt2YXIgYT1lLmNvb3Jkcy5jdXIucGFnZSx1PXQubW9kaWZpZWRDb29yZHMueC1hLngscz10Lm1vZGlmaWVkQ29vcmRzLnktYS55O2kuY29vcmRzLngrPXUsaS5jb29yZHMueSs9cyxpLmRlbHRhLngrPXUsaS5kZWx0YS55Kz1zfXRoaXMuYXBwbHlUb0ludGVyYWN0aW9uKHQpfX0se2tleTpcImJlZm9yZUVuZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmV2ZW50LHI9dGhpcy5zdGF0ZXM7aWYociYmci5sZW5ndGgpe2Zvcih2YXIgbz0hMSxpPTA7aTxyLmxlbmd0aDtpKyspe3ZhciBhPXJbaV0sdT0odC5zdGF0ZT1hKS5vcHRpb25zLHM9YS5tZXRob2RzLGw9cy5iZWZvcmVFbmQmJnMuYmVmb3JlRW5kKHQpO2lmKGwpcmV0dXJuIHRoaXMuZW5kUmVzdWx0PWwsITE7bz1vfHwhbyYmdGhpcy5zaG91bGREbyh1LCEwLHQucGhhc2UsITApfW8mJmUubW92ZSh7ZXZlbnQ6bixwcmVFbmQ6ITB9KX19fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247aWYodGhpcy5zdGF0ZXMmJnRoaXMuc3RhdGVzLmxlbmd0aCl7dmFyIG49KDAsU2kuZGVmYXVsdCkoe3N0YXRlczp0aGlzLnN0YXRlcyxpbnRlcmFjdGFibGU6ZS5pbnRlcmFjdGFibGUsZWxlbWVudDplLmVsZW1lbnQscmVjdDpudWxsfSx0KTt0aGlzLmZpbGxBcmcobik7Zm9yKHZhciByPTA7cjx0aGlzLnN0YXRlcy5sZW5ndGg7cisrKXt2YXIgbz10aGlzLnN0YXRlc1tyXTsobi5zdGF0ZT1vKS5tZXRob2RzLnN0b3AmJm8ubWV0aG9kcy5zdG9wKG4pfXRoaXMuc3RhdGVzPW51bGwsdGhpcy5lbmRSZXN1bHQ9bnVsbH19fSx7a2V5OlwicHJlcGFyZVN0YXRlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuc3RhdGVzPVtdO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj10W2VdLHI9bi5vcHRpb25zLG89bi5tZXRob2RzLGk9bi5uYW1lO3ImJiExPT09ci5lbmFibGVkfHx0aGlzLnN0YXRlcy5wdXNoKHtvcHRpb25zOnIsbWV0aG9kczpvLGluZGV4OmUsbmFtZTppfSl9cmV0dXJuIHRoaXMuc3RhdGVzfX0se2tleTpcInJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj1lLmNvb3JkcyxyPWUucmVjdCxvPWUubW9kaWZpY2F0aW9uO2lmKG8ucmVzdWx0KXtmb3IodmFyIGk9by5zdGFydERlbHRhLGE9by5yZXN1bHQsdT1hLmRlbHRhLHM9YS5yZWN0RGVsdGEsbD1bW24uc3RhcnQsaV0sW24uY3VyLHVdXSxjPTA7YzxsLmxlbmd0aDtjKyspe3ZhciBmPUVpKGxbY10sMikscD1mWzBdLGQ9ZlsxXTtwLnBhZ2UueC09ZC54LHAucGFnZS55LT1kLnkscC5jbGllbnQueC09ZC54LHAuY2xpZW50LnktPWQueX1yLmxlZnQtPXMubGVmdCxyLnJpZ2h0LT1zLnJpZ2h0LHIudG9wLT1zLnRvcCxyLmJvdHRvbS09cy5ib3R0b219fX0se2tleTpcInNob3VsZERvXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuISghdHx8ITE9PT10LmVuYWJsZWR8fHImJiF0LmVuZE9ubHl8fHQuZW5kT25seSYmIWV8fFwic3RhcnRcIj09PW4mJiF0LnNldFN0YXJ0KX19LHtrZXk6XCJjb3B5RnJvbVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuc3RhcnRPZmZzZXQ9dC5zdGFydE9mZnNldCx0aGlzLnN0YXJ0RGVsdGE9dC5zdGFydERlbHRhLHRoaXMuZWRnZXM9dC5lZGdlcyx0aGlzLnN0YXRlcz10LnN0YXRlcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuKDAseGkuZGVmYXVsdCkodCl9KSx0aGlzLnJlc3VsdD16aSgoMCxTaS5kZWZhdWx0KSh7fSx0LnJlc3VsdC5jb29yZHMpLCgwLFNpLmRlZmF1bHQpKHt9LHQucmVzdWx0LnJlY3QpKX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcyl0aGlzW3RdPW51bGx9fV0pJiZUaSh0LnByb3RvdHlwZSxuKSxyJiZUaSh0LHIpLGV9KCk7ZnVuY3Rpb24gemkodCxlKXtyZXR1cm57cmVjdDplLGNvb3Jkczp0LGRlbHRhOnt4OjAseTowfSxyZWN0RGVsdGE6e2xlZnQ6MCxyaWdodDowLHRvcDowLGJvdHRvbTowfSxldmVudFByb3BzOltdLGNoYW5nZWQ6ITB9fWZ1bmN0aW9uIEFpKHQsZSl7cmV0dXJuIHQ/e2xlZnQ6ZS54LXQubGVmdCx0b3A6ZS55LXQudG9wLHJpZ2h0OnQucmlnaHQtZS54LGJvdHRvbTp0LmJvdHRvbS1lLnl9OntsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH19X2kuZGVmYXVsdD1JaTt2YXIgQ2k9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KENpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLENpLm1ha2VNb2RpZmllcj1mdW5jdGlvbih0LHIpe2Z1bmN0aW9uIGUodCl7dmFyIGU9dHx8e307Zm9yKHZhciBuIGluIGUuZW5hYmxlZD0hMSE9PWUuZW5hYmxlZCxvKW4gaW4gZXx8KGVbbl09b1tuXSk7cmV0dXJue29wdGlvbnM6ZSxtZXRob2RzOmksbmFtZTpyfX12YXIgbz10LmRlZmF1bHRzLGk9e3N0YXJ0OnQuc3RhcnQsc2V0OnQuc2V0LGJlZm9yZUVuZDp0LmJlZm9yZUVuZCxzdG9wOnQuc3RvcH07ciYmXCJzdHJpbmdcIj09dHlwZW9mIHImJihlLl9kZWZhdWx0cz1vLGUuX21ldGhvZHM9aSk7cmV0dXJuIGV9LENpLmFkZEV2ZW50TW9kaWZpZXJzPUZpLENpLmRlZmF1bHQ9dm9pZCAwO3ZhciBXaSxSaT0oV2k9X2kpJiZXaS5fX2VzTW9kdWxlP1dpOntkZWZhdWx0OldpfTtmdW5jdGlvbiBGaSh0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnJlc3VsdDtuJiYoZS5tb2RpZmllcnM9bi5ldmVudFByb3BzKX12YXIgWGk9e2lkOlwibW9kaWZpZXJzL2Jhc2VcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3QuZGVmYXVsdHMucGVyQWN0aW9uLm1vZGlmaWVycz1bXX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2UubW9kaWZpY2F0aW9uPW5ldyBSaS5kZWZhdWx0KGUpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLXN0YXJ0XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb247ZS5zdGFydCh0LHQuaW50ZXJhY3Rpb24uY29vcmRzLnN0YXJ0LnBhZ2UpLHQuaW50ZXJhY3Rpb24uZWRnZXM9ZS5lZGdlcyxlLmFwcGx5VG9JbnRlcmFjdGlvbih0KX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1tb3ZlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnNldEFuZEFwcGx5KHQpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLWVuZFwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5iZWZvcmVFbmQodCl9LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1zdGFydFwiOkZpLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlXCI6RmksXCJpbnRlcmFjdGlvbnM6YWN0aW9uLWVuZFwiOkZpLFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1zdGFydFwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5yZXN0b3JlSW50ZXJhY3Rpb25Db29yZHModCl9LFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1tb3ZlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkcyh0KX0sXCJpbnRlcmFjdGlvbnM6c3RvcFwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5zdG9wKHQpfX0sYmVmb3JlOltcImFjdGlvbnNcIixcImFjdGlvbi9kcmFnXCIsXCJhY3Rpb25zL3Jlc2l6ZVwiLFwiYWN0aW9ucy9nZXN0dXJlXCJdfTtDaS5kZWZhdWx0PVhpO3ZhciBZaT17fTtmdW5jdGlvbiBOaSh0KXtyZXR1cm4oTmk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShZaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxZaS5hZGRUb3RhbD1WaSxZaS5hcHBseVBlbmRpbmc9VWksWWkuZGVmYXVsdD12b2lkIDA7dmFyIExpPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PU5pKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUJpKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KCR0KTtmdW5jdGlvbiBCaSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIEJpPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gVmkodCl7dC5wb2ludGVySXNEb3duJiYoSGkodC5jb29yZHMuY3VyLHQub2Zmc2V0LnRvdGFsKSx0Lm9mZnNldC5wZW5kaW5nLng9MCx0Lm9mZnNldC5wZW5kaW5nLnk9MCl9ZnVuY3Rpb24gcWkodCl7VWkodC5pbnRlcmFjdGlvbil9ZnVuY3Rpb24gVWkodCl7aWYoIShlPXQpLm9mZnNldC5wZW5kaW5nLngmJiFlLm9mZnNldC5wZW5kaW5nLnkpcmV0dXJuITE7dmFyIGUsbj10Lm9mZnNldC5wZW5kaW5nO3JldHVybiBIaSh0LmNvb3Jkcy5jdXIsbiksSGkodC5jb29yZHMuZGVsdGEsbiksTGkuYWRkRWRnZXModC5lZGdlcyx0LnJlY3Qsbiksbi54PTAsIShuLnk9MCl9ZnVuY3Rpb24gR2kodCl7dmFyIGU9dC54LG49dC55O3RoaXMub2Zmc2V0LnBlbmRpbmcueCs9ZSx0aGlzLm9mZnNldC5wZW5kaW5nLnkrPW4sdGhpcy5vZmZzZXQudG90YWwueCs9ZSx0aGlzLm9mZnNldC50b3RhbC55Kz1ufWZ1bmN0aW9uIEhpKHQsZSl7dmFyIG49dC5wYWdlLHI9dC5jbGllbnQsbz1lLngsaT1lLnk7bi54Kz1vLG4ueSs9aSxyLngrPW8sci55Kz1pfUVuLl9Qcm94eU1ldGhvZHMub2Zmc2V0Qnk9XCJcIjt2YXIgS2k9e2lkOlwib2Zmc2V0XCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LkludGVyYWN0aW9uLnByb3RvdHlwZS5vZmZzZXRCeT1HaX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLm9mZnNldD17dG90YWw6e3g6MCx5OjB9LHBlbmRpbmc6e3g6MCx5OjB9fX0sXCJpbnRlcmFjdGlvbnM6dXBkYXRlLXBvaW50ZXJcIjpmdW5jdGlvbih0KXtyZXR1cm4gVmkodC5pbnRlcmFjdGlvbil9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tc3RhcnRcIjpxaSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLW1vdmVcIjpxaSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLWVuZFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247aWYoVWkoZSkpcmV0dXJuIGUubW92ZSh7b2Zmc2V0OiEwfSksZS5lbmQoKSwhMX0sXCJpbnRlcmFjdGlvbnM6c3RvcFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247ZS5vZmZzZXQudG90YWwueD0wLGUub2Zmc2V0LnRvdGFsLnk9MCxlLm9mZnNldC5wZW5kaW5nLng9MCxlLm9mZnNldC5wZW5kaW5nLnk9MH19fTtZaS5kZWZhdWx0PUtpO3ZhciAkaT17fTtmdW5jdGlvbiBaaSh0KXtyZXR1cm4oWmk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSwkaS5kZWZhdWx0PSRpLkluZXJ0aWFTdGF0ZT12b2lkIDA7dmFyIEppPXVhKF9pKSxRaT1hYShDaSksdGE9dWEoWWkpLGVhPWFhKCQpLG5hPXVhKEV0KSxyYT1hYSh3KSxvYT11YShvZSk7ZnVuY3Rpb24gaWEoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBpYT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIGFhKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PVppKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPWlhKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59ZnVuY3Rpb24gdWEodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIHNhKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBsYSh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIGNhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMuaW50ZXJhY3Rpb249dCxsYSh0aGlzLFwiYWN0aXZlXCIsITEpLGxhKHRoaXMsXCJpc01vZGlmaWVkXCIsITEpLGxhKHRoaXMsXCJzbW9vdGhFbmRcIiwhMSksbGEodGhpcyxcImFsbG93UmVzdW1lXCIsITEpLGxhKHRoaXMsXCJtb2RpZmljYXRpb25cIixudWxsKSxsYSh0aGlzLFwibW9kaWZpZXJDb3VudFwiLDApLGxhKHRoaXMsXCJtb2RpZmllckFyZ1wiLG51bGwpLGxhKHRoaXMsXCJzdGFydENvb3Jkc1wiLG51bGwpLGxhKHRoaXMsXCJ0MFwiLDApLGxhKHRoaXMsXCJ2MFwiLDApLGxhKHRoaXMsXCJ0ZVwiLDApLGxhKHRoaXMsXCJ0YXJnZXRPZmZzZXRcIixudWxsKSxsYSh0aGlzLFwibW9kaWZpZWRPZmZzZXRcIixudWxsKSxsYSh0aGlzLFwiY3VycmVudE9mZnNldFwiLG51bGwpLGxhKHRoaXMsXCJsYW1iZGFfdjBcIiwwKSxsYSh0aGlzLFwib25lX3ZlX3YwXCIsMCksbGEodGhpcyxcInRpbWVvdXRcIixudWxsKX12YXIgdCxuLHI7cmV0dXJuIHQ9ZSwobj1be2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pbnRlcmFjdGlvbixuPWZhKGUpO2lmKCFufHwhbi5lbmFibGVkKXJldHVybiExO3ZhciByPWUuY29vcmRzLnZlbG9jaXR5LmNsaWVudCxvPSgwLG5hLmRlZmF1bHQpKHIueCxyLnkpLGk9dGhpcy5tb2RpZmljYXRpb258fCh0aGlzLm1vZGlmaWNhdGlvbj1uZXcgSmkuZGVmYXVsdChlKSk7aWYoaS5jb3B5RnJvbShlLm1vZGlmaWNhdGlvbiksdGhpcy50MD1lLl9ub3coKSx0aGlzLmFsbG93UmVzdW1lPW4uYWxsb3dSZXN1bWUsdGhpcy52MD1vLHRoaXMuY3VycmVudE9mZnNldD17eDowLHk6MH0sdGhpcy5zdGFydENvb3Jkcz1lLmNvb3Jkcy5jdXIucGFnZSx0aGlzLm1vZGlmaWVyQXJnPXtpbnRlcmFjdGlvbjplLGludGVyYWN0YWJsZTplLmludGVyYWN0YWJsZSxlbGVtZW50OmUuZWxlbWVudCxyZWN0OmUucmVjdCxlZGdlczplLmVkZ2VzLHBhZ2VDb29yZHM6dGhpcy5zdGFydENvb3JkcyxwcmVFbmQ6ITAscGhhc2U6XCJpbmVydGlhc3RhcnRcIn0sdGhpcy50MC1lLmNvb3Jkcy5jdXIudGltZVN0YW1wPDUwJiZvPm4ubWluU3BlZWQmJm8+bi5lbmRTcGVlZCl0aGlzLnN0YXJ0SW5lcnRpYSgpO2Vsc2V7aWYoaS5yZXN1bHQ9aS5zZXRBbGwodGhpcy5tb2RpZmllckFyZyksIWkucmVzdWx0LmNoYW5nZWQpcmV0dXJuITE7dGhpcy5zdGFydFNtb290aEVuZCgpfXJldHVybiBlLm1vZGlmaWNhdGlvbi5yZXN1bHQucmVjdD1udWxsLGUub2Zmc2V0QnkodGhpcy50YXJnZXRPZmZzZXQpLGUuX2RvUGhhc2Uoe2ludGVyYWN0aW9uOmUsZXZlbnQ6dCxwaGFzZTpcImluZXJ0aWFzdGFydFwifSksZS5vZmZzZXRCeSh7eDotdGhpcy50YXJnZXRPZmZzZXQueCx5Oi10aGlzLnRhcmdldE9mZnNldC55fSksZS5tb2RpZmljYXRpb24ucmVzdWx0LnJlY3Q9bnVsbCx0aGlzLmFjdGl2ZT0hMCxlLnNpbXVsYXRpb249dGhpcywhMH19LHtrZXk6XCJzdGFydEluZXJ0aWFcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLmludGVyYWN0aW9uLmNvb3Jkcy52ZWxvY2l0eS5jbGllbnQsbj1mYSh0aGlzLmludGVyYWN0aW9uKSxyPW4ucmVzaXN0YW5jZSxvPS1NYXRoLmxvZyhuLmVuZFNwZWVkL3RoaXMudjApL3I7dGhpcy50YXJnZXRPZmZzZXQ9e3g6KGUueC1vKS9yLHk6KGUueS1vKS9yfSx0aGlzLnRlPW8sdGhpcy5sYW1iZGFfdjA9ci90aGlzLnYwLHRoaXMub25lX3ZlX3YwPTEtbi5lbmRTcGVlZC90aGlzLnYwO3ZhciBpPXRoaXMubW9kaWZpY2F0aW9uLGE9dGhpcy5tb2RpZmllckFyZzthLnBhZ2VDb29yZHM9e3g6dGhpcy5zdGFydENvb3Jkcy54K3RoaXMudGFyZ2V0T2Zmc2V0LngseTp0aGlzLnN0YXJ0Q29vcmRzLnkrdGhpcy50YXJnZXRPZmZzZXQueX0saS5yZXN1bHQ9aS5zZXRBbGwoYSksaS5yZXN1bHQuY2hhbmdlZCYmKHRoaXMuaXNNb2RpZmllZD0hMCx0aGlzLm1vZGlmaWVkT2Zmc2V0PXt4OnRoaXMudGFyZ2V0T2Zmc2V0LngraS5yZXN1bHQuZGVsdGEueCx5OnRoaXMudGFyZ2V0T2Zmc2V0LnkraS5yZXN1bHQuZGVsdGEueX0pLHRoaXMudGltZW91dD1vYS5kZWZhdWx0LnJlcXVlc3QoZnVuY3Rpb24oKXtyZXR1cm4gdC5pbmVydGlhVGljaygpfSl9fSx7a2V5Olwic3RhcnRTbW9vdGhFbmRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5zbW9vdGhFbmQ9ITAsdGhpcy5pc01vZGlmaWVkPSEwLHRoaXMudGFyZ2V0T2Zmc2V0PXt4OnRoaXMubW9kaWZpY2F0aW9uLnJlc3VsdC5kZWx0YS54LHk6dGhpcy5tb2RpZmljYXRpb24ucmVzdWx0LmRlbHRhLnl9LHRoaXMudGltZW91dD1vYS5kZWZhdWx0LnJlcXVlc3QoZnVuY3Rpb24oKXtyZXR1cm4gdC5zbW9vdGhFbmRUaWNrKCl9KX19LHtrZXk6XCJpbmVydGlhVGlja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxuLHIsbyxpLGEsdT10aGlzLHM9dGhpcy5pbnRlcmFjdGlvbixsPWZhKHMpLnJlc2lzdGFuY2UsYz0ocy5fbm93KCktdGhpcy50MCkvMWUzO2lmKGM8dGhpcy50ZSl7dmFyIGYscD0xLShNYXRoLmV4cCgtbCpjKS10aGlzLmxhbWJkYV92MCkvdGhpcy5vbmVfdmVfdjAsZD17eDooZj10aGlzLmlzTW9kaWZpZWQ/KGU9dD0wLG49dGhpcy50YXJnZXRPZmZzZXQueCxyPXRoaXMudGFyZ2V0T2Zmc2V0Lnksbz10aGlzLm1vZGlmaWVkT2Zmc2V0LngsaT10aGlzLm1vZGlmaWVkT2Zmc2V0Lnkse3g6cGEoYT1wLHQsbixvKSx5OnBhKGEsZSxyLGkpfSk6e3g6dGhpcy50YXJnZXRPZmZzZXQueCpwLHk6dGhpcy50YXJnZXRPZmZzZXQueSpwfSkueC10aGlzLmN1cnJlbnRPZmZzZXQueCx5OmYueS10aGlzLmN1cnJlbnRPZmZzZXQueX07dGhpcy5jdXJyZW50T2Zmc2V0LngrPWQueCx0aGlzLmN1cnJlbnRPZmZzZXQueSs9ZC55LHMub2Zmc2V0QnkoZCkscy5tb3ZlKCksdGhpcy50aW1lb3V0PW9hLmRlZmF1bHQucmVxdWVzdChmdW5jdGlvbigpe3JldHVybiB1LmluZXJ0aWFUaWNrKCl9KX1lbHNlIHMub2Zmc2V0Qnkoe3g6dGhpcy5tb2RpZmllZE9mZnNldC54LXRoaXMuY3VycmVudE9mZnNldC54LHk6dGhpcy5tb2RpZmllZE9mZnNldC55LXRoaXMuY3VycmVudE9mZnNldC55fSksdGhpcy5lbmQoKX19LHtrZXk6XCJzbW9vdGhFbmRUaWNrXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5pbnRlcmFjdGlvbixuPWUuX25vdygpLXRoaXMudDAscj1mYShlKS5zbW9vdGhFbmREdXJhdGlvbjtpZihuPHIpe3ZhciBvPWRhKG4sMCx0aGlzLnRhcmdldE9mZnNldC54LHIpLGk9ZGEobiwwLHRoaXMudGFyZ2V0T2Zmc2V0LnksciksYT17eDpvLXRoaXMuY3VycmVudE9mZnNldC54LHk6aS10aGlzLmN1cnJlbnRPZmZzZXQueX07dGhpcy5jdXJyZW50T2Zmc2V0LngrPWEueCx0aGlzLmN1cnJlbnRPZmZzZXQueSs9YS55LGUub2Zmc2V0QnkoYSksZS5tb3ZlKHtza2lwTW9kaWZpZXJzOnRoaXMubW9kaWZpZXJDb3VudH0pLHRoaXMudGltZW91dD1vYS5kZWZhdWx0LnJlcXVlc3QoZnVuY3Rpb24oKXtyZXR1cm4gdC5zbW9vdGhFbmRUaWNrKCl9KX1lbHNlIGUub2Zmc2V0Qnkoe3g6dGhpcy50YXJnZXRPZmZzZXQueC10aGlzLmN1cnJlbnRPZmZzZXQueCx5OnRoaXMudGFyZ2V0T2Zmc2V0LnktdGhpcy5jdXJyZW50T2Zmc2V0Lnl9KSx0aGlzLmVuZCgpfX0se2tleTpcInJlc3VtZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQucG9pbnRlcixuPXQuZXZlbnQscj10LmV2ZW50VGFyZ2V0LG89dGhpcy5pbnRlcmFjdGlvbjtvLm9mZnNldEJ5KHt4Oi10aGlzLmN1cnJlbnRPZmZzZXQueCx5Oi10aGlzLmN1cnJlbnRPZmZzZXQueX0pLG8udXBkYXRlUG9pbnRlcihlLG4sciwhMCksby5fZG9QaGFzZSh7aW50ZXJhY3Rpb246byxldmVudDpuLHBoYXNlOlwicmVzdW1lXCJ9KSwoMCx6dC5jb3B5Q29vcmRzKShvLmNvb3Jkcy5wcmV2LG8uY29vcmRzLmN1ciksdGhpcy5zdG9wKCl9fSx7a2V5OlwiZW5kXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmludGVyYWN0aW9uLm1vdmUoKSx0aGlzLmludGVyYWN0aW9uLmVuZCgpLHRoaXMuc3RvcCgpfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuYWN0aXZlPXRoaXMuc21vb3RoRW5kPSExLHRoaXMuaW50ZXJhY3Rpb24uc2ltdWxhdGlvbj1udWxsLG9hLmRlZmF1bHQuY2FuY2VsKHRoaXMudGltZW91dCl9fV0pJiZzYSh0LnByb3RvdHlwZSxuKSxyJiZzYSh0LHIpLGV9KCk7ZnVuY3Rpb24gZmEodCl7dmFyIGU9dC5pbnRlcmFjdGFibGUsbj10LnByZXBhcmVkO3JldHVybiBlJiZlLm9wdGlvbnMmJm4ubmFtZSYmZS5vcHRpb25zW24ubmFtZV0uaW5lcnRpYX1mdW5jdGlvbiBwYSh0LGUsbixyKXt2YXIgbz0xLXQ7cmV0dXJuIG8qbyplKzIqbyp0Km4rdCp0KnJ9ZnVuY3Rpb24gZGEodCxlLG4scil7cmV0dXJuLW4qKHQvPXIpKih0LTIpK2V9JGkuSW5lcnRpYVN0YXRlPWNhO3ZhciB2YT17aWQ6XCJpbmVydGlhXCIsYmVmb3JlOltcIm1vZGlmaWVycy9iYXNlXCJdLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5kZWZhdWx0czt0LnVzZVBsdWdpbih0YS5kZWZhdWx0KSx0LnVzZVBsdWdpbihRaS5kZWZhdWx0KSx0LmFjdGlvbnMucGhhc2VzLmluZXJ0aWFzdGFydD0hMCx0LmFjdGlvbnMucGhhc2VzLnJlc3VtZT0hMCxlLnBlckFjdGlvbi5pbmVydGlhPXtlbmFibGVkOiExLHJlc2lzdGFuY2U6MTAsbWluU3BlZWQ6MTAwLGVuZFNwZWVkOjEwLGFsbG93UmVzdW1lOiEwLHNtb290aEVuZER1cmF0aW9uOjMwMH19LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtlLmluZXJ0aWE9bmV3IGNhKGUpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLWVuZFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmV2ZW50O3JldHVybighZS5faW50ZXJhY3Rpbmd8fGUuc2ltdWxhdGlvbnx8IWUuaW5lcnRpYS5zdGFydChuKSkmJm51bGx9LFwiaW50ZXJhY3Rpb25zOmRvd25cIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5ldmVudFRhcmdldCxyPWUuaW5lcnRpYTtpZihyLmFjdGl2ZSlmb3IodmFyIG89bjtyYS5lbGVtZW50KG8pOyl7aWYobz09PWUuZWxlbWVudCl7ci5yZXN1bWUodCk7YnJlYWt9bz1lYS5wYXJlbnROb2RlKG8pfX0sXCJpbnRlcmFjdGlvbnM6c3RvcFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24uaW5lcnRpYTtlLmFjdGl2ZSYmZS5zdG9wKCl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tcmVzdW1lXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb247ZS5zdG9wKHQpLGUuc3RhcnQodCx0LmludGVyYWN0aW9uLmNvb3Jkcy5jdXIucGFnZSksZS5hcHBseVRvSW50ZXJhY3Rpb24odCl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24taW5lcnRpYXN0YXJ0XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnNldEFuZEFwcGx5KHQpfSxcImludGVyYWN0aW9uczphY3Rpb24tcmVzdW1lXCI6UWkuYWRkRXZlbnRNb2RpZmllcnMsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLWluZXJ0aWFzdGFydFwiOlFpLmFkZEV2ZW50TW9kaWZpZXJzLFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1pbmVydGlhc3RhcnRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdG9yZUludGVyYWN0aW9uQ29vcmRzKHQpfSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tcmVzdW1lXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkcyh0KX19fTskaS5kZWZhdWx0PXZhO3ZhciB5YSxoYT17fTtmdW5jdGlvbiBnYSh0KXtyZXR1cm4oZ2E9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShoYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxoYS5pbml0PWhhLmRlZmF1bHQ9dm9pZCAwO3ZhciBiYT1uZXcoKCh5YT1tKHt9KSkmJnlhLl9fZXNNb2R1bGU/eWE6e2RlZmF1bHQ6eWF9KS5kZWZhdWx0KSxtYT1iYS5pbnRlcmFjdFN0YXRpYztoYS5kZWZhdWx0PW1hO2Z1bmN0aW9uIE9hKHQpe3JldHVybiBiYS5pbml0KHQpfWhhLmluaXQ9T2EsXCJvYmplY3RcIj09PShcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P1widW5kZWZpbmVkXCI6Z2Eod2luZG93KSkmJndpbmRvdyYmT2Eod2luZG93KTt2YXIgd2E9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHdhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHdhLmRlZmF1bHQ9dm9pZCAwO3dhLmRlZmF1bHQ9e307dmFyIF9hPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShfYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxfYS5kZWZhdWx0PXZvaWQgMDtfYS5kZWZhdWx0PXt9O3ZhciBQYT17fTtmdW5jdGlvbiB4YSh0LGUpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0fSh0KXx8ZnVuY3Rpb24odCxlKXtpZighKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpKXJldHVybjt2YXIgbj1bXSxyPSEwLG89ITEsaT12b2lkIDA7dHJ5e2Zvcih2YXIgYSx1PXRbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0oYT11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goYS52YWx1ZSksIWV8fG4ubGVuZ3RoIT09ZSk7cj0hMCk7fWNhdGNoKHQpe289ITAsaT10fWZpbmFsbHl7dHJ5e3J8fG51bGw9PXUucmV0dXJufHx1LnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn0odCxlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoUGEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksUGEuZGVmYXVsdD12b2lkIDA7UGEuZGVmYXVsdD1mdW5jdGlvbih2KXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPXYucmFuZ2Uscj12LmxpbWl0cyxvPXZvaWQgMD09PXI/e2xlZnQ6LTEvMCxyaWdodDoxLzAsdG9wOi0xLzAsYm90dG9tOjEvMH06cixpPXYub2Zmc2V0LGE9dm9pZCAwPT09aT97eDowLHk6MH06aSx1PXtyYW5nZTpuLGdyaWQ6dix4Om51bGwseTpudWxsfSxzPTA7czx5Lmxlbmd0aDtzKyspe3ZhciBsPXhhKHlbc10sMiksYz1sWzBdLGY9bFsxXSxwPU1hdGgucm91bmQoKHQtYS54KS92W2NdKSxkPU1hdGgucm91bmQoKGUtYS55KS92W2ZdKTt1W2NdPU1hdGgubWF4KG8ubGVmdCxNYXRoLm1pbihvLnJpZ2h0LHAqdltjXSthLngpKSx1W2ZdPU1hdGgubWF4KG8udG9wLE1hdGgubWluKG8uYm90dG9tLGQqdltmXSthLnkpKX1yZXR1cm4gdX12YXIgeT1bW1wieFwiLFwieVwiXSxbXCJsZWZ0XCIsXCJ0b3BcIl0sW1wicmlnaHRcIixcImJvdHRvbVwiXSxbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdXS5maWx0ZXIoZnVuY3Rpb24odCl7dmFyIGU9eGEodCwyKSxuPWVbMF0scj1lWzFdO3JldHVybiBuIGluIHZ8fHIgaW4gdn0pO3JldHVybiB0LmdyaWQ9dix0LmNvb3JkRmllbGRzPXksdH07dmFyIFNhPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShTYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoU2EsXCJlZGdlVGFyZ2V0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGphLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFNhLFwiZWxlbWVudHNcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTWEuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoU2EsXCJncmlkXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGthLmRlZmF1bHR9fSk7dmFyIGphPUVhKHdhKSxNYT1FYShfYSksa2E9RWEoUGEpO2Z1bmN0aW9uIEVhKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX12YXIgVGE9e307ZnVuY3Rpb24gRGEodCl7cmV0dXJuKERhPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoVGEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksVGEuZGVmYXVsdD12b2lkIDA7dmFyIElhLHphPShJYT1jdCkmJklhLl9fZXNNb2R1bGU/SWE6e2RlZmF1bHQ6SWF9LEFhPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PURhKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUNhKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KFNhKTtmdW5jdGlvbiBDYSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIENhPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9dmFyIFdhPXtpZDpcInNuYXBwZXJzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0U3RhdGljO2Uuc25hcHBlcnM9KDAsemEuZGVmYXVsdCkoZS5zbmFwcGVyc3x8e30sQWEpLGUuY3JlYXRlU25hcEdyaWQ9ZS5zbmFwcGVycy5ncmlkfX07VGEuZGVmYXVsdD1XYTt2YXIgUmE9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KFJhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFJhLmFzcGVjdFJhdGlvPVJhLmRlZmF1bHQ9dm9pZCAwO3ZhciBGYT1ZYShjdCksWGE9WWEoX2kpO2Z1bmN0aW9uIFlhKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBOYShlLHQpe3ZhciBuPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciByPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKHI9ci5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpLG4ucHVzaC5hcHBseShuLHIpfXJldHVybiBufWZ1bmN0aW9uIExhKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP05hKE9iamVjdChuKSwhMCkuZm9yRWFjaChmdW5jdGlvbih0KXtCYShlLHQsblt0XSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKTpOYShPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCkpfSl9cmV0dXJuIGV9ZnVuY3Rpb24gQmEodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBWYT17c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0ZSxuPXQucmVjdCxyPXQuZWRnZXMsbz10LnBhZ2VDb29yZHMsaT1lLm9wdGlvbnMucmF0aW8sYT1lLm9wdGlvbnMsdT1hLmVxdWFsRGVsdGEscz1hLm1vZGlmaWVycztcInByZXNlcnZlXCI9PT1pJiYoaT1uLndpZHRoL24uaGVpZ2h0KSxlLnN0YXJ0Q29vcmRzPSgwLEZhLmRlZmF1bHQpKHt9LG8pLGUuc3RhcnRSZWN0PSgwLEZhLmRlZmF1bHQpKHt9LG4pLGUucmF0aW89aSxlLmVxdWFsRGVsdGE9dTt2YXIgbD1lLmxpbmtlZEVkZ2VzPXt0b3A6ci50b3B8fHIubGVmdCYmIXIuYm90dG9tLGxlZnQ6ci5sZWZ0fHxyLnRvcCYmIXIucmlnaHQsYm90dG9tOnIuYm90dG9tfHxyLnJpZ2h0JiYhci50b3AscmlnaHQ6ci5yaWdodHx8ci5ib3R0b20mJiFyLmxlZnR9O2lmKGUueElzUHJpbWFyeUF4aXM9ISghci5sZWZ0JiYhci5yaWdodCksZS5lcXVhbERlbHRhKWUuZWRnZVNpZ249KGwubGVmdD8xOi0xKSoobC50b3A/MTotMSk7ZWxzZXt2YXIgYz1lLnhJc1ByaW1hcnlBeGlzP2wudG9wOmwubGVmdDtlLmVkZ2VTaWduPWM/LTE6MX1pZigoMCxGYS5kZWZhdWx0KSh0LmVkZ2VzLGwpLHMmJnMubGVuZ3RoKXt2YXIgZj1uZXcgWGEuZGVmYXVsdCh0LmludGVyYWN0aW9uKTtmLmNvcHlGcm9tKHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uKSxmLnByZXBhcmVTdGF0ZXMocyksKGUuc3ViTW9kaWZpY2F0aW9uPWYpLnN0YXJ0QWxsKExhKHt9LHQpKX19LHNldDpmdW5jdGlvbih0KXt2YXIgZT10LnN0YXRlLG49dC5yZWN0LHI9dC5jb29yZHMsbz0oMCxGYS5kZWZhdWx0KSh7fSxyKSxpPWUuZXF1YWxEZWx0YT9xYTpVYTtpZihpKGUsZS54SXNQcmltYXJ5QXhpcyxyLG4pLCFlLnN1Yk1vZGlmaWNhdGlvbilyZXR1cm4gbnVsbDt2YXIgYT0oMCxGYS5kZWZhdWx0KSh7fSxuKTsoMCwkdC5hZGRFZGdlcykoZS5saW5rZWRFZGdlcyxhLHt4OnIueC1vLngseTpyLnktby55fSk7dmFyIHU9ZS5zdWJNb2RpZmljYXRpb24uc2V0QWxsKExhKHt9LHQse3JlY3Q6YSxlZGdlczplLmxpbmtlZEVkZ2VzLHBhZ2VDb29yZHM6cixwcmV2Q29vcmRzOnIscHJldlJlY3Q6YX0pKSxzPXUuZGVsdGE7dS5jaGFuZ2VkJiYoaShlLE1hdGguYWJzKHMueCk+TWF0aC5hYnMocy55KSx1LmNvb3Jkcyx1LnJlY3QpLCgwLEZhLmRlZmF1bHQpKHIsdS5jb29yZHMpKTtyZXR1cm4gdS5ldmVudFByb3BzfSxkZWZhdWx0czp7cmF0aW86XCJwcmVzZXJ2ZVwiLGVxdWFsRGVsdGE6ITEsbW9kaWZpZXJzOltdLGVuYWJsZWQ6ITF9fTtmdW5jdGlvbiBxYSh0LGUsbil7dmFyIHI9dC5zdGFydENvb3JkcyxvPXQuZWRnZVNpZ247ZT9uLnk9ci55KyhuLngtci54KSpvOm4ueD1yLngrKG4ueS1yLnkpKm99ZnVuY3Rpb24gVWEodCxlLG4scil7dmFyIG89dC5zdGFydFJlY3QsaT10LnN0YXJ0Q29vcmRzLGE9dC5yYXRpbyx1PXQuZWRnZVNpZ247aWYoZSl7dmFyIHM9ci53aWR0aC9hO24ueT1pLnkrKHMtby5oZWlnaHQpKnV9ZWxzZXt2YXIgbD1yLmhlaWdodCphO24ueD1pLngrKGwtby53aWR0aCkqdX19UmEuYXNwZWN0UmF0aW89VmE7dmFyIEdhPSgwLENpLm1ha2VNb2RpZmllcikoVmEsXCJhc3BlY3RSYXRpb1wiKTtSYS5kZWZhdWx0PUdhO3ZhciBIYT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSGEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSGEuZGVmYXVsdD12b2lkIDA7ZnVuY3Rpb24gS2EoKXt9S2EuX2RlZmF1bHRzPXt9O3ZhciAkYT1LYTtIYS5kZWZhdWx0PSRhO3ZhciBaYT17fTtmdW5jdGlvbiBKYSh0KXtyZXR1cm4oSmE9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShaYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxaYS5nZXRSZXN0cmljdGlvblJlY3Q9aXUsWmEucmVzdHJpY3Q9WmEuZGVmYXVsdD12b2lkIDA7dmFyIFFhLHR1PShRYT1jdCkmJlFhLl9fZXNNb2R1bGU/UWE6e2RlZmF1bHQ6UWF9LGV1PW91KHcpLG51PW91KCR0KTtmdW5jdGlvbiBydSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIHJ1PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gb3UodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09SmEodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9cnUoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn1mdW5jdGlvbiBpdSh0LGUsbil7cmV0dXJuIGV1LmZ1bmModCk/bnUucmVzb2x2ZVJlY3RMaWtlKHQsZS5pbnRlcmFjdGFibGUsZS5lbGVtZW50LFtuLngsbi55LGVdKTpudS5yZXNvbHZlUmVjdExpa2UodCxlLmludGVyYWN0YWJsZSxlLmVsZW1lbnQpfXZhciBhdT17c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5yZWN0LG49dC5zdGFydE9mZnNldCxyPXQuc3RhdGUsbz10LmludGVyYWN0aW9uLGk9dC5wYWdlQ29vcmRzLGE9ci5vcHRpb25zLHU9YS5lbGVtZW50UmVjdCxzPSgwLHR1LmRlZmF1bHQpKHtsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH0sYS5vZmZzZXR8fHt9KTtpZihlJiZ1KXt2YXIgbD1pdShhLnJlc3RyaWN0aW9uLG8saSk7aWYobCl7dmFyIGM9bC5yaWdodC1sLmxlZnQtZS53aWR0aCxmPWwuYm90dG9tLWwudG9wLWUuaGVpZ2h0O2M8MCYmKHMubGVmdCs9YyxzLnJpZ2h0Kz1jKSxmPDAmJihzLnRvcCs9ZixzLmJvdHRvbSs9Zil9cy5sZWZ0Kz1uLmxlZnQtZS53aWR0aCp1LmxlZnQscy50b3ArPW4udG9wLWUuaGVpZ2h0KnUudG9wLHMucmlnaHQrPW4ucmlnaHQtZS53aWR0aCooMS11LnJpZ2h0KSxzLmJvdHRvbSs9bi5ib3R0b20tZS5oZWlnaHQqKDEtdS5ib3R0b20pfXIub2Zmc2V0PXN9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10LmNvb3JkcyxuPXQuaW50ZXJhY3Rpb24scj10LnN0YXRlLG89ci5vcHRpb25zLGk9ci5vZmZzZXQsYT1pdShvLnJlc3RyaWN0aW9uLG4sZSk7aWYoYSl7dmFyIHU9bnUueHl3aFRvVGxicihhKTtlLng9TWF0aC5tYXgoTWF0aC5taW4odS5yaWdodC1pLnJpZ2h0LGUueCksdS5sZWZ0K2kubGVmdCksZS55PU1hdGgubWF4KE1hdGgubWluKHUuYm90dG9tLWkuYm90dG9tLGUueSksdS50b3AraS50b3ApfX0sZGVmYXVsdHM6e3Jlc3RyaWN0aW9uOm51bGwsZWxlbWVudFJlY3Q6bnVsbCxvZmZzZXQ6bnVsbCxlbmRPbmx5OiExLGVuYWJsZWQ6ITF9fTtaYS5yZXN0cmljdD1hdTt2YXIgdXU9KDAsQ2kubWFrZU1vZGlmaWVyKShhdSxcInJlc3RyaWN0XCIpO1phLmRlZmF1bHQ9dXU7dmFyIHN1PXt9O2Z1bmN0aW9uIGx1KHQpe3JldHVybihsdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHN1LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHN1LnJlc3RyaWN0RWRnZXM9c3UuZGVmYXVsdD12b2lkIDA7dmFyIGN1LGZ1PShjdT1jdCkmJmN1Ll9fZXNNb2R1bGU/Y3U6e2RlZmF1bHQ6Y3V9LHB1PWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWx1KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPWR1KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KCR0KTtmdW5jdGlvbiBkdSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIGR1PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9dmFyIHZ1PXt0b3A6MS8wLGxlZnQ6MS8wLGJvdHRvbTotMS8wLHJpZ2h0Oi0xLzB9LHl1PXt0b3A6LTEvMCxsZWZ0Oi0xLzAsYm90dG9tOjEvMCxyaWdodDoxLzB9O2Z1bmN0aW9uIGh1KHQsZSl7Zm9yKHZhciBuPVtcInRvcFwiLFwibGVmdFwiLFwiYm90dG9tXCIsXCJyaWdodFwiXSxyPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBvPW5bcl07byBpbiB0fHwodFtvXT1lW29dKX1yZXR1cm4gdH12YXIgZ3U9e25vSW5uZXI6dnUsbm9PdXRlcjp5dSxzdGFydDpmdW5jdGlvbih0KXt2YXIgZSxuPXQuaW50ZXJhY3Rpb24scj10LnN0YXJ0T2Zmc2V0LG89dC5zdGF0ZSxpPW8ub3B0aW9ucztpZihpKXt2YXIgYT0oMCxaYS5nZXRSZXN0cmljdGlvblJlY3QpKGkub2Zmc2V0LG4sbi5jb29yZHMuc3RhcnQucGFnZSk7ZT1wdS5yZWN0VG9YWShhKX1lPWV8fHt4OjAseTowfSxvLm9mZnNldD17dG9wOmUueStyLnRvcCxsZWZ0OmUueCtyLmxlZnQsYm90dG9tOmUueS1yLmJvdHRvbSxyaWdodDplLngtci5yaWdodH19LHNldDpmdW5jdGlvbih0KXt2YXIgZT10LmNvb3JkcyxuPXQuZWRnZXMscj10LmludGVyYWN0aW9uLG89dC5zdGF0ZSxpPW8ub2Zmc2V0LGE9by5vcHRpb25zO2lmKG4pe3ZhciB1PSgwLGZ1LmRlZmF1bHQpKHt9LGUpLHM9KDAsWmEuZ2V0UmVzdHJpY3Rpb25SZWN0KShhLmlubmVyLHIsdSl8fHt9LGw9KDAsWmEuZ2V0UmVzdHJpY3Rpb25SZWN0KShhLm91dGVyLHIsdSl8fHt9O2h1KHMsdnUpLGh1KGwseXUpLG4udG9wP2UueT1NYXRoLm1pbihNYXRoLm1heChsLnRvcCtpLnRvcCx1LnkpLHMudG9wK2kudG9wKTpuLmJvdHRvbSYmKGUueT1NYXRoLm1heChNYXRoLm1pbihsLmJvdHRvbStpLmJvdHRvbSx1LnkpLHMuYm90dG9tK2kuYm90dG9tKSksbi5sZWZ0P2UueD1NYXRoLm1pbihNYXRoLm1heChsLmxlZnQraS5sZWZ0LHUueCkscy5sZWZ0K2kubGVmdCk6bi5yaWdodCYmKGUueD1NYXRoLm1heChNYXRoLm1pbihsLnJpZ2h0K2kucmlnaHQsdS54KSxzLnJpZ2h0K2kucmlnaHQpKX19LGRlZmF1bHRzOntpbm5lcjpudWxsLG91dGVyOm51bGwsb2Zmc2V0Om51bGwsZW5kT25seTohMSxlbmFibGVkOiExfX07c3UucmVzdHJpY3RFZGdlcz1ndTt2YXIgYnU9KDAsQ2kubWFrZU1vZGlmaWVyKShndSxcInJlc3RyaWN0RWRnZXNcIik7c3UuZGVmYXVsdD1idTt2YXIgbXUsT3U9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KE91LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE91LnJlc3RyaWN0UmVjdD1PdS5kZWZhdWx0PXZvaWQgMDt2YXIgd3U9KDAsKChtdT1jdCkmJm11Ll9fZXNNb2R1bGU/bXU6e2RlZmF1bHQ6bXV9KS5kZWZhdWx0KSh7Z2V0IGVsZW1lbnRSZWN0KCl7cmV0dXJue3RvcDowLGxlZnQ6MCxib3R0b206MSxyaWdodDoxfX0sc2V0IGVsZW1lbnRSZWN0KHQpe319LFphLnJlc3RyaWN0LmRlZmF1bHRzKSxfdT17c3RhcnQ6WmEucmVzdHJpY3Quc3RhcnQsc2V0OlphLnJlc3RyaWN0LnNldCxkZWZhdWx0czp3dX07T3UucmVzdHJpY3RSZWN0PV91O3ZhciBQdT0oMCxDaS5tYWtlTW9kaWZpZXIpKF91LFwicmVzdHJpY3RSZWN0XCIpO091LmRlZmF1bHQ9UHU7dmFyIHh1PXt9O2Z1bmN0aW9uIFN1KHQpe3JldHVybihTdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHh1LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHh1LnJlc3RyaWN0U2l6ZT14dS5kZWZhdWx0PXZvaWQgMDt2YXIganUsTXU9KGp1PWN0KSYmanUuX19lc01vZHVsZT9qdTp7ZGVmYXVsdDpqdX0sa3U9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09U3UodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9RXUoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oJHQpO2Z1bmN0aW9uIEV1KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gRXU9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH12YXIgVHU9e3dpZHRoOi0xLzAsaGVpZ2h0Oi0xLzB9LER1PXt3aWR0aDoxLzAsaGVpZ2h0OjEvMH07dmFyIEl1PXtzdGFydDpmdW5jdGlvbih0KXtyZXR1cm4gc3UucmVzdHJpY3RFZGdlcy5zdGFydCh0KX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LnN0YXRlLHI9dC5yZWN0LG89dC5lZGdlcyxpPW4ub3B0aW9ucztpZihvKXt2YXIgYT1rdS50bGJyVG9YeXdoKCgwLFphLmdldFJlc3RyaWN0aW9uUmVjdCkoaS5taW4sZSx0LmNvb3JkcykpfHxUdSx1PWt1LnRsYnJUb1h5d2goKDAsWmEuZ2V0UmVzdHJpY3Rpb25SZWN0KShpLm1heCxlLHQuY29vcmRzKSl8fER1O24ub3B0aW9ucz17ZW5kT25seTppLmVuZE9ubHksaW5uZXI6KDAsTXUuZGVmYXVsdCkoe30sc3UucmVzdHJpY3RFZGdlcy5ub0lubmVyKSxvdXRlcjooMCxNdS5kZWZhdWx0KSh7fSxzdS5yZXN0cmljdEVkZ2VzLm5vT3V0ZXIpfSxvLnRvcD8obi5vcHRpb25zLmlubmVyLnRvcD1yLmJvdHRvbS1hLmhlaWdodCxuLm9wdGlvbnMub3V0ZXIudG9wPXIuYm90dG9tLXUuaGVpZ2h0KTpvLmJvdHRvbSYmKG4ub3B0aW9ucy5pbm5lci5ib3R0b209ci50b3ArYS5oZWlnaHQsbi5vcHRpb25zLm91dGVyLmJvdHRvbT1yLnRvcCt1LmhlaWdodCksby5sZWZ0PyhuLm9wdGlvbnMuaW5uZXIubGVmdD1yLnJpZ2h0LWEud2lkdGgsbi5vcHRpb25zLm91dGVyLmxlZnQ9ci5yaWdodC11LndpZHRoKTpvLnJpZ2h0JiYobi5vcHRpb25zLmlubmVyLnJpZ2h0PXIubGVmdCthLndpZHRoLG4ub3B0aW9ucy5vdXRlci5yaWdodD1yLmxlZnQrdS53aWR0aCksc3UucmVzdHJpY3RFZGdlcy5zZXQodCksbi5vcHRpb25zPWl9fSxkZWZhdWx0czp7bWluOm51bGwsbWF4Om51bGwsZW5kT25seTohMSxlbmFibGVkOiExfX07eHUucmVzdHJpY3RTaXplPUl1O3ZhciB6dT0oMCxDaS5tYWtlTW9kaWZpZXIpKEl1LFwicmVzdHJpY3RTaXplXCIpO3h1LmRlZmF1bHQ9enU7dmFyIEF1PXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShBdSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxBdS5kZWZhdWx0PXZvaWQgMDtmdW5jdGlvbiBDdSgpe31DdS5fZGVmYXVsdHM9e307dmFyIFd1PUN1O0F1LmRlZmF1bHQ9V3U7dmFyIFJ1PXt9O2Z1bmN0aW9uIEZ1KHQpe3JldHVybihGdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFJ1LnNuYXA9UnUuZGVmYXVsdD12b2lkIDA7dmFyIFh1PWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PUZ1KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPVl1KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KGxlKTtmdW5jdGlvbiBZdSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIFl1PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9dmFyIE51PXtzdGFydDpmdW5jdGlvbih0KXt2YXIgZSxuLHIsbz10LmludGVyYWN0aW9uLGk9dC5pbnRlcmFjdGFibGUsYT10LmVsZW1lbnQsdT10LnJlY3Qscz10LnN0YXRlLGw9dC5zdGFydE9mZnNldCxjPXMub3B0aW9ucyxmPWMub2Zmc2V0V2l0aE9yaWdpbj8obj0oZT10KS5pbnRlcmFjdGlvbi5lbGVtZW50LFh1LnJlY3QucmVjdFRvWFkoWHUucmVjdC5yZXNvbHZlUmVjdExpa2UoZS5zdGF0ZS5vcHRpb25zLm9yaWdpbixudWxsLG51bGwsW25dKSl8fFh1LmdldE9yaWdpblhZKGUuaW50ZXJhY3RhYmxlLG4sZS5pbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lKSk6e3g6MCx5OjB9O2lmKFwic3RhcnRDb29yZHNcIj09PWMub2Zmc2V0KXI9e3g6by5jb29yZHMuc3RhcnQucGFnZS54LHk6by5jb29yZHMuc3RhcnQucGFnZS55fTtlbHNle3ZhciBwPVh1LnJlY3QucmVzb2x2ZVJlY3RMaWtlKGMub2Zmc2V0LGksYSxbb10pOyhyPVh1LnJlY3QucmVjdFRvWFkocCl8fHt4OjAseTowfSkueCs9Zi54LHIueSs9Zi55fXZhciBkPWMucmVsYXRpdmVQb2ludHM7cy5vZmZzZXRzPXUmJmQmJmQubGVuZ3RoP2QubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJue2luZGV4OmUscmVsYXRpdmVQb2ludDp0LHg6bC5sZWZ0LXUud2lkdGgqdC54K3IueCx5OmwudG9wLXUuaGVpZ2h0KnQueStyLnl9fSk6W1h1LmV4dGVuZCh7aW5kZXg6MCxyZWxhdGl2ZVBvaW50Om51bGx9LHIpXX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmNvb3JkcyxyPXQuc3RhdGUsbz1yLm9wdGlvbnMsaT1yLm9mZnNldHMsYT1YdS5nZXRPcmlnaW5YWShlLmludGVyYWN0YWJsZSxlLmVsZW1lbnQsZS5wcmVwYXJlZC5uYW1lKSx1PVh1LmV4dGVuZCh7fSxuKSxzPVtdO28ub2Zmc2V0V2l0aE9yaWdpbnx8KHUueC09YS54LHUueS09YS55KTtmb3IodmFyIGw9MDtsPGkubGVuZ3RoO2wrKylmb3IodmFyIGM9aVtsXSxmPXUueC1jLngscD11LnktYy55LGQ9MCx2PW8udGFyZ2V0cy5sZW5ndGg7ZDx2O2QrKyl7dmFyIHk9by50YXJnZXRzW2RdLGg9dm9pZCAwOyhoPVh1LmlzLmZ1bmMoeSk/eShmLHAsZSxjLGQpOnkpJiZzLnB1c2goe3g6KFh1LmlzLm51bWJlcihoLngpP2gueDpmKStjLngseTooWHUuaXMubnVtYmVyKGgueSk/aC55OnApK2MueSxyYW5nZTpYdS5pcy5udW1iZXIoaC5yYW5nZSk/aC5yYW5nZTpvLnJhbmdlLHNvdXJjZTp5LGluZGV4OmQsb2Zmc2V0OmN9KX1mb3IodmFyIGc9e3RhcmdldDpudWxsLGluUmFuZ2U6ITEsZGlzdGFuY2U6MCxyYW5nZTowLGRlbHRhOnt4OjAseTowfX0sYj0wO2I8cy5sZW5ndGg7YisrKXt2YXIgbT1zW2JdLE89bS5yYW5nZSx3PW0ueC11LngsXz1tLnktdS55LFA9WHUuaHlwb3QodyxfKSx4PVA8PU87Tz09PTEvMCYmZy5pblJhbmdlJiZnLnJhbmdlIT09MS8wJiYoeD0hMSksZy50YXJnZXQmJiEoeD9nLmluUmFuZ2UmJk8hPT0xLzA/UC9PPGcuZGlzdGFuY2UvZy5yYW5nZTpPPT09MS8wJiZnLnJhbmdlIT09MS8wfHxQPGcuZGlzdGFuY2U6IWcuaW5SYW5nZSYmUDxnLmRpc3RhbmNlKXx8KGcudGFyZ2V0PW0sZy5kaXN0YW5jZT1QLGcucmFuZ2U9TyxnLmluUmFuZ2U9eCxnLmRlbHRhLng9dyxnLmRlbHRhLnk9Xyl9cmV0dXJuIGcuaW5SYW5nZSYmKG4ueD1nLnRhcmdldC54LG4ueT1nLnRhcmdldC55KSxyLmNsb3Nlc3Q9Z30sZGVmYXVsdHM6e3JhbmdlOjEvMCx0YXJnZXRzOm51bGwsb2Zmc2V0Om51bGwsb2Zmc2V0V2l0aE9yaWdpbjohMCxvcmlnaW46bnVsbCxyZWxhdGl2ZVBvaW50czpudWxsLGVuZE9ubHk6ITEsZW5hYmxlZDohMX19O1J1LnNuYXA9TnU7dmFyIEx1PSgwLENpLm1ha2VNb2RpZmllcikoTnUsXCJzbmFwXCIpO1J1LmRlZmF1bHQ9THU7dmFyIEJ1PXt9O2Z1bmN0aW9uIFZ1KHQpe3JldHVybihWdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEJ1LnNuYXBTaXplPUJ1LmRlZmF1bHQ9dm9pZCAwO3ZhciBxdSxVdT0ocXU9Y3QpJiZxdS5fX2VzTW9kdWxlP3F1OntkZWZhdWx0OnF1fSxHdT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1WdSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1IdSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh3KTtmdW5jdGlvbiBIdSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIEh1PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gS3UodCxlKXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKSlyZXR1cm47dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEsdT10W1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO3I9ITApO31jYXRjaCh0KXtvPSEwLGk9dH1maW5hbGx5e3RyeXtyfHxudWxsPT11LnJldHVybnx8dS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgaX19cmV0dXJuIG59KHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9dmFyICR1PXtzdGFydDpmdW5jdGlvbih0KXt2YXIgZT10LnN0YXRlLG49dC5lZGdlcyxyPWUub3B0aW9ucztpZighbilyZXR1cm4gbnVsbDt0LnN0YXRlPXtvcHRpb25zOnt0YXJnZXRzOm51bGwscmVsYXRpdmVQb2ludHM6W3t4Om4ubGVmdD8wOjEseTpuLnRvcD8wOjF9XSxvZmZzZXQ6ci5vZmZzZXR8fFwic2VsZlwiLG9yaWdpbjp7eDowLHk6MH0scmFuZ2U6ci5yYW5nZX19LGUudGFyZ2V0RmllbGRzPWUudGFyZ2V0RmllbGRzfHxbW1wid2lkdGhcIixcImhlaWdodFwiXSxbXCJ4XCIsXCJ5XCJdXSxSdS5zbmFwLnN0YXJ0KHQpLGUub2Zmc2V0cz10LnN0YXRlLm9mZnNldHMsdC5zdGF0ZT1lfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuc3RhdGUscj10LmNvb3JkcyxvPW4ub3B0aW9ucyxpPW4ub2Zmc2V0cyxhPXt4OnIueC1pWzBdLngseTpyLnktaVswXS55fTtuLm9wdGlvbnM9KDAsVXUuZGVmYXVsdCkoe30sbyksbi5vcHRpb25zLnRhcmdldHM9W107Zm9yKHZhciB1PTA7dTwoby50YXJnZXRzfHxbXSkubGVuZ3RoO3UrKyl7dmFyIHM9KG8udGFyZ2V0c3x8W10pW3VdLGw9dm9pZCAwO2lmKGw9R3UuZnVuYyhzKT9zKGEueCxhLnksZSk6cyl7Zm9yKHZhciBjPTA7YzxuLnRhcmdldEZpZWxkcy5sZW5ndGg7YysrKXt2YXIgZj1LdShuLnRhcmdldEZpZWxkc1tjXSwyKSxwPWZbMF0sZD1mWzFdO2lmKHAgaW4gbHx8ZCBpbiBsKXtsLng9bFtwXSxsLnk9bFtkXTticmVha319bi5vcHRpb25zLnRhcmdldHMucHVzaChsKX19dmFyIHY9UnUuc25hcC5zZXQodCk7cmV0dXJuIG4ub3B0aW9ucz1vLHZ9LGRlZmF1bHRzOntyYW5nZToxLzAsdGFyZ2V0czpudWxsLG9mZnNldDpudWxsLGVuZE9ubHk6ITEsZW5hYmxlZDohMX19O0J1LnNuYXBTaXplPSR1O3ZhciBadT0oMCxDaS5tYWtlTW9kaWZpZXIpKCR1LFwic25hcFNpemVcIik7QnUuZGVmYXVsdD1adTt2YXIgSnU9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KEp1LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEp1LnNuYXBFZGdlcz1KdS5kZWZhdWx0PXZvaWQgMDt2YXIgUXU9ZXMoViksdHM9ZXMoY3QpO2Z1bmN0aW9uIGVzKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX12YXIgbnM9e3N0YXJ0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZWRnZXM7cmV0dXJuIGU/KHQuc3RhdGUudGFyZ2V0RmllbGRzPXQuc3RhdGUudGFyZ2V0RmllbGRzfHxbW2UubGVmdD9cImxlZnRcIjpcInJpZ2h0XCIsZS50b3A/XCJ0b3BcIjpcImJvdHRvbVwiXV0sQnUuc25hcFNpemUuc3RhcnQodCkpOm51bGx9LHNldDpCdS5zbmFwU2l6ZS5zZXQsZGVmYXVsdHM6KDAsdHMuZGVmYXVsdCkoKDAsUXUuZGVmYXVsdCkoQnUuc25hcFNpemUuZGVmYXVsdHMpLHt0YXJnZXRzOm51bGwscmFuZ2U6bnVsbCxvZmZzZXQ6e3g6MCx5OjB9fSl9O0p1LnNuYXBFZGdlcz1uczt2YXIgcnM9KDAsQ2kubWFrZU1vZGlmaWVyKShucyxcInNuYXBFZGdlc1wiKTtKdS5kZWZhdWx0PXJzO3ZhciBvcz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkob3MsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksb3MuZGVmYXVsdD12b2lkIDA7ZnVuY3Rpb24gaXMoKXt9aXMuX2RlZmF1bHRzPXt9O3ZhciBhcz1pcztvcy5kZWZhdWx0PWFzO3ZhciB1cz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodXMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdXMuZGVmYXVsdD12b2lkIDA7ZnVuY3Rpb24gc3MoKXt9c3MuX2RlZmF1bHRzPXt9O3ZhciBscz1zczt1cy5kZWZhdWx0PWxzO3ZhciBjcz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoY3MsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksY3MuZGVmYXVsdD12b2lkIDA7dmFyIGZzPVBzKFJhKSxwcz1QcyhIYSksZHM9UHMoc3UpLHZzPVBzKFphKSx5cz1QcyhPdSksaHM9UHMoeHUpLGdzPVBzKEF1KSxicz1QcyhKdSksbXM9UHMoUnUpLE9zPVBzKEJ1KSx3cz1QcyhvcyksX3M9UHModXMpO2Z1bmN0aW9uIFBzKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX12YXIgeHM9e2FzcGVjdFJhdGlvOmZzLmRlZmF1bHQscmVzdHJpY3RFZGdlczpkcy5kZWZhdWx0LHJlc3RyaWN0OnZzLmRlZmF1bHQscmVzdHJpY3RSZWN0OnlzLmRlZmF1bHQscmVzdHJpY3RTaXplOmhzLmRlZmF1bHQsc25hcEVkZ2VzOmJzLmRlZmF1bHQsc25hcDptcy5kZWZhdWx0LHNuYXBTaXplOk9zLmRlZmF1bHQsc3ByaW5nOndzLmRlZmF1bHQsYXZvaWQ6cHMuZGVmYXVsdCx0cmFuc2Zvcm06X3MuZGVmYXVsdCxydWJiZXJiYW5kOmdzLmRlZmF1bHR9O2NzLmRlZmF1bHQ9eHM7dmFyIFNzPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShTcyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxTcy5kZWZhdWx0PXZvaWQgMDt2YXIganM9RXMoVGEpLE1zPUVzKGNzKSxrcz1FcyhDaSk7ZnVuY3Rpb24gRXModCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fXZhciBUcz17aWQ6XCJtb2RpZmllcnNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3RTdGF0aWM7Zm9yKHZhciBuIGluIHQudXNlUGx1Z2luKGtzLmRlZmF1bHQpLHQudXNlUGx1Z2luKGpzLmRlZmF1bHQpLGUubW9kaWZpZXJzPU1zLmRlZmF1bHQsTXMuZGVmYXVsdCl7dmFyIHI9TXMuZGVmYXVsdFtuXSxvPXIuX2RlZmF1bHRzLGk9ci5fbWV0aG9kcztvLl9tZXRob2RzPWksdC5kZWZhdWx0cy5wZXJBY3Rpb25bbl09b319fTtTcy5kZWZhdWx0PVRzO3ZhciBEcz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksRHMuZGVmYXVsdD12b2lkIDA7RHMuZGVmYXVsdD17fTt2YXIgSXM9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KElzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLElzLlBvaW50ZXJFdmVudD1Jcy5kZWZhdWx0PXZvaWQgMDt2YXIgenMsQXM9KHpzPU1lKSYmenMuX19lc01vZHVsZT96czp7ZGVmYXVsdDp6c30sQ3M9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09UnModCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9V3MoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oenQpO2Z1bmN0aW9uIFdzKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gV3M9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBScyh0KXtyZXR1cm4oUnM9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIEZzKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBYcyh0KXtyZXR1cm4oWHM9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KX0pKHQpfWZ1bmN0aW9uIFlzKHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiB0fWZ1bmN0aW9uIE5zKHQsZSl7cmV0dXJuKE5zPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX1mdW5jdGlvbiBMcyh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIEJzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZih0LGUsbixyLG8saSl7dmFyIGEsdSxzO2lmKCFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZiksdT10aGlzLGE9IShzPVhzKGYpLmNhbGwodGhpcyxvKSl8fFwib2JqZWN0XCIhPT1ScyhzKSYmXCJmdW5jdGlvblwiIT10eXBlb2Ygcz9Zcyh1KTpzLExzKFlzKGEpLFwidHlwZVwiLHZvaWQgMCksTHMoWXMoYSksXCJvcmlnaW5hbEV2ZW50XCIsdm9pZCAwKSxMcyhZcyhhKSxcInBvaW50ZXJJZFwiLHZvaWQgMCksTHMoWXMoYSksXCJwb2ludGVyVHlwZVwiLHZvaWQgMCksTHMoWXMoYSksXCJkb3VibGVcIix2b2lkIDApLExzKFlzKGEpLFwicGFnZVhcIix2b2lkIDApLExzKFlzKGEpLFwicGFnZVlcIix2b2lkIDApLExzKFlzKGEpLFwiY2xpZW50WFwiLHZvaWQgMCksTHMoWXMoYSksXCJjbGllbnRZXCIsdm9pZCAwKSxMcyhZcyhhKSxcImR0XCIsdm9pZCAwKSxMcyhZcyhhKSxcImV2ZW50YWJsZVwiLHZvaWQgMCksQ3MucG9pbnRlckV4dGVuZChZcyhhKSxuKSxuIT09ZSYmQ3MucG9pbnRlckV4dGVuZChZcyhhKSxlKSxhLnRpbWVTdGFtcD1pLGEub3JpZ2luYWxFdmVudD1uLGEudHlwZT10LGEucG9pbnRlcklkPUNzLmdldFBvaW50ZXJJZChlKSxhLnBvaW50ZXJUeXBlPUNzLmdldFBvaW50ZXJUeXBlKGUpLGEudGFyZ2V0PXIsYS5jdXJyZW50VGFyZ2V0PW51bGwsXCJ0YXBcIj09PXQpe3ZhciBsPW8uZ2V0UG9pbnRlckluZGV4KGUpO2EuZHQ9YS50aW1lU3RhbXAtby5wb2ludGVyc1tsXS5kb3duVGltZTt2YXIgYz1hLnRpbWVTdGFtcC1vLnRhcFRpbWU7YS5kb3VibGU9ISEoby5wcmV2VGFwJiZcImRvdWJsZXRhcFwiIT09by5wcmV2VGFwLnR5cGUmJm8ucHJldlRhcC50YXJnZXQ9PT1hLnRhcmdldCYmYzw1MDApfWVsc2VcImRvdWJsZXRhcFwiPT09dCYmKGEuZHQ9ZS50aW1lU3RhbXAtby50YXBUaW1lKTtyZXR1cm4gYX12YXIgdCxlLG47cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiZOcyh0LGUpfShmLEFzW1wiZGVmYXVsdFwiXSksdD1mLChlPVt7a2V5OlwiX3N1YnRyYWN0T3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC54LG49dC55O3JldHVybiB0aGlzLnBhZ2VYLT1lLHRoaXMucGFnZVktPW4sdGhpcy5jbGllbnRYLT1lLHRoaXMuY2xpZW50WS09bix0aGlzfX0se2tleTpcIl9hZGRPcmlnaW5cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10Lngsbj10Lnk7cmV0dXJuIHRoaXMucGFnZVgrPWUsdGhpcy5wYWdlWSs9bix0aGlzLmNsaWVudFgrPWUsdGhpcy5jbGllbnRZKz1uLHRoaXN9fSx7a2V5OlwicHJldmVudERlZmF1bHRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpfX1dKSYmRnModC5wcm90b3R5cGUsZSksbiYmRnModCxuKSxmfSgpO0lzLlBvaW50ZXJFdmVudD1Jcy5kZWZhdWx0PUJzO3ZhciBWcz17fTtmdW5jdGlvbiBxcyh0KXtyZXR1cm4ocXM9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShWcyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxWcy5kZWZhdWx0PXZvaWQgMDtLcyhFbiksS3MobSh7fSkpO3ZhciBVcz1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1xcyh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1IcygpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShsZSksR3M9S3MoSXMpO2Z1bmN0aW9uIEhzKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gSHM9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBLcyh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19dmFyICRzPXtpZDpcInBvaW50ZXItZXZlbnRzL2Jhc2VcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3QucG9pbnRlckV2ZW50cz0kcyx0LmRlZmF1bHRzLmFjdGlvbnMucG9pbnRlckV2ZW50cz0kcy5kZWZhdWx0cyxVcy5leHRlbmQodC5hY3Rpb25zLnBoYXNlbGVzc1R5cGVzLCRzLnR5cGVzKX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2UucHJldlRhcD1udWxsLGUudGFwVGltZT0wfSxcImludGVyYWN0aW9uczp1cGRhdGUtcG9pbnRlclwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZG93bixuPXQucG9pbnRlckluZm87aWYoIWUmJm4uaG9sZClyZXR1cm47bi5ob2xkPXtkdXJhdGlvbjoxLzAsdGltZW91dDpudWxsfX0sXCJpbnRlcmFjdGlvbnM6bW92ZVwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixvPXQuZXZlbnQsaT10LmV2ZW50VGFyZ2V0LGE9dC5kdXBsaWNhdGUsdT1uLmdldFBvaW50ZXJJbmRleChyKTthfHxuLnBvaW50ZXJJc0Rvd24mJiFuLnBvaW50ZXJXYXNNb3ZlZHx8KG4ucG9pbnRlcklzRG93biYmY2xlYXJUaW1lb3V0KG4ucG9pbnRlcnNbdV0uaG9sZC50aW1lb3V0KSxacyh7aW50ZXJhY3Rpb246bixwb2ludGVyOnIsZXZlbnQ6byxldmVudFRhcmdldDppLHR5cGU6XCJtb3ZlXCJ9LGUpKX0sXCJpbnRlcmFjdGlvbnM6ZG93blwiOmZ1bmN0aW9uKHQsZSl7IWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsbz10LmV2ZW50LGk9dC5ldmVudFRhcmdldCxhPXQucG9pbnRlckluZGV4LHU9bi5wb2ludGVyc1thXS5ob2xkLHM9VXMuZG9tLmdldFBhdGgoaSksbD17aW50ZXJhY3Rpb246bixwb2ludGVyOnIsZXZlbnQ6byxldmVudFRhcmdldDppLHR5cGU6XCJob2xkXCIsdGFyZ2V0czpbXSxwYXRoOnMsbm9kZTpudWxsfSxjPTA7YzxzLmxlbmd0aDtjKyspe3ZhciBmPXNbY107bC5ub2RlPWYsZS5maXJlKFwicG9pbnRlckV2ZW50czpjb2xsZWN0LXRhcmdldHNcIixsKX1pZighbC50YXJnZXRzLmxlbmd0aClyZXR1cm47Zm9yKHZhciBwPTEvMCxkPTA7ZDxsLnRhcmdldHMubGVuZ3RoO2QrKyl7dmFyIHY9bC50YXJnZXRzW2RdLmV2ZW50YWJsZS5vcHRpb25zLmhvbGREdXJhdGlvbjt2PHAmJihwPXYpfXUuZHVyYXRpb249cCx1LnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe1pzKHtpbnRlcmFjdGlvbjpuLGV2ZW50VGFyZ2V0OmkscG9pbnRlcjpyLGV2ZW50Om8sdHlwZTpcImhvbGRcIn0sZSl9LHApfSh0LGUpLFpzKHQsZSl9LFwiaW50ZXJhY3Rpb25zOnVwXCI6ZnVuY3Rpb24odCxlKXt2YXIgbixyLG8saSxhLHU7UXModCksWnModCxlKSxyPWUsbz0obj10KS5pbnRlcmFjdGlvbixpPW4ucG9pbnRlcixhPW4uZXZlbnQsdT1uLmV2ZW50VGFyZ2V0LG8ucG9pbnRlcldhc01vdmVkfHxacyh7aW50ZXJhY3Rpb246byxldmVudFRhcmdldDp1LHBvaW50ZXI6aSxldmVudDphLHR5cGU6XCJ0YXBcIn0scil9LFwiaW50ZXJhY3Rpb25zOmNhbmNlbFwiOmZ1bmN0aW9uKHQsZSl7UXModCksWnModCxlKX19LFBvaW50ZXJFdmVudDpHcy5kZWZhdWx0LGZpcmU6WnMsY29sbGVjdEV2ZW50VGFyZ2V0czpKcyxkZWZhdWx0czp7aG9sZER1cmF0aW9uOjYwMCxpZ25vcmVGcm9tOm51bGwsYWxsb3dGcm9tOm51bGwsb3JpZ2luOnt4OjAseTowfX0sdHlwZXM6e2Rvd246ITAsbW92ZTohMCx1cDohMCxjYW5jZWw6ITAsdGFwOiEwLGRvdWJsZXRhcDohMCxob2xkOiEwfX07ZnVuY3Rpb24gWnModCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyLG89dC5ldmVudCxpPXQuZXZlbnRUYXJnZXQsYT10LnR5cGUsdT10LnRhcmdldHMscz12b2lkIDA9PT11P0pzKHQsZSk6dSxsPW5ldyBHcy5kZWZhdWx0KGEscixvLGksbixlLm5vdygpKTtlLmZpcmUoXCJwb2ludGVyRXZlbnRzOm5ld1wiLHtwb2ludGVyRXZlbnQ6bH0pO2Zvcih2YXIgYz17aW50ZXJhY3Rpb246bixwb2ludGVyOnIsZXZlbnQ6byxldmVudFRhcmdldDppLHRhcmdldHM6cyx0eXBlOmEscG9pbnRlckV2ZW50Omx9LGY9MDtmPHMubGVuZ3RoO2YrKyl7dmFyIHA9c1tmXTtmb3IodmFyIGQgaW4gcC5wcm9wc3x8e30pbFtkXT1wLnByb3BzW2RdO3ZhciB2PVVzLmdldE9yaWdpblhZKHAuZXZlbnRhYmxlLHAubm9kZSk7aWYobC5fc3VidHJhY3RPcmlnaW4odiksbC5ldmVudGFibGU9cC5ldmVudGFibGUsbC5jdXJyZW50VGFyZ2V0PXAubm9kZSxwLmV2ZW50YWJsZS5maXJlKGwpLGwuX2FkZE9yaWdpbih2KSxsLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZHx8bC5wcm9wYWdhdGlvblN0b3BwZWQmJmYrMTxzLmxlbmd0aCYmc1tmKzFdLm5vZGUhPT1sLmN1cnJlbnRUYXJnZXQpYnJlYWt9aWYoZS5maXJlKFwicG9pbnRlckV2ZW50czpmaXJlZFwiLGMpLFwidGFwXCI9PT1hKXt2YXIgeT1sLmRvdWJsZT9acyh7aW50ZXJhY3Rpb246bixwb2ludGVyOnIsZXZlbnQ6byxldmVudFRhcmdldDppLHR5cGU6XCJkb3VibGV0YXBcIn0sZSk6bDtuLnByZXZUYXA9eSxuLnRhcFRpbWU9eS50aW1lU3RhbXB9cmV0dXJuIGx9ZnVuY3Rpb24gSnModCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyLG89dC5ldmVudCxpPXQuZXZlbnRUYXJnZXQsYT10LnR5cGUsdT1uLmdldFBvaW50ZXJJbmRleChyKSxzPW4ucG9pbnRlcnNbdV07aWYoXCJ0YXBcIj09PWEmJihuLnBvaW50ZXJXYXNNb3ZlZHx8IXN8fHMuZG93blRhcmdldCE9PWkpKXJldHVybltdO2Zvcih2YXIgbD1Vcy5kb20uZ2V0UGF0aChpKSxjPXtpbnRlcmFjdGlvbjpuLHBvaW50ZXI6cixldmVudDpvLGV2ZW50VGFyZ2V0OmksdHlwZTphLHBhdGg6bCx0YXJnZXRzOltdLG5vZGU6bnVsbH0sZj0wO2Y8bC5sZW5ndGg7ZisrKXt2YXIgcD1sW2ZdO2Mubm9kZT1wLGUuZmlyZShcInBvaW50ZXJFdmVudHM6Y29sbGVjdC10YXJnZXRzXCIsYyl9cmV0dXJuXCJob2xkXCI9PT1hJiYoYy50YXJnZXRzPWMudGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQuZXZlbnRhYmxlLm9wdGlvbnMuaG9sZER1cmF0aW9uPT09bi5wb2ludGVyc1t1XS5ob2xkLmR1cmF0aW9ufSkpLGMudGFyZ2V0c31mdW5jdGlvbiBRcyh0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5wb2ludGVySW5kZXg7ZS5wb2ludGVyc1tuXS5ob2xkJiZjbGVhclRpbWVvdXQoZS5wb2ludGVyc1tuXS5ob2xkLnRpbWVvdXQpfXZhciB0bD0kcztWcy5kZWZhdWx0PXRsO3ZhciBlbD17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZWwuZGVmYXVsdD12b2lkIDA7cmwoSXMpO3ZhciBubD1ybChWcyk7ZnVuY3Rpb24gcmwodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG9sKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247ZS5ob2xkSW50ZXJ2YWxIYW5kbGUmJihjbGVhckludGVydmFsKGUuaG9sZEludGVydmFsSGFuZGxlKSxlLmhvbGRJbnRlcnZhbEhhbmRsZT1udWxsKX12YXIgaWw9e2lkOlwicG9pbnRlci1ldmVudHMvaG9sZFJlcGVhdFwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC51c2VQbHVnaW4obmwuZGVmYXVsdCk7dmFyIGU9dC5wb2ludGVyRXZlbnRzO2UuZGVmYXVsdHMuaG9sZFJlcGVhdEludGVydmFsPTAsZS50eXBlcy5ob2xkcmVwZWF0PXQuYWN0aW9ucy5waGFzZWxlc3NUeXBlcy5ob2xkcmVwZWF0PSEwfSxsaXN0ZW5lcnM6W1wibW92ZVwiLFwidXBcIixcImNhbmNlbFwiLFwiZW5kYWxsXCJdLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0W1wicG9pbnRlckV2ZW50czpcIi5jb25jYXQoZSldPW9sLHR9LHtcInBvaW50ZXJFdmVudHM6bmV3XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5wb2ludGVyRXZlbnQ7XCJob2xkXCI9PT1lLnR5cGUmJihlLmNvdW50PShlLmNvdW50fHwwKSsxKX0sXCJwb2ludGVyRXZlbnRzOmZpcmVkXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyRXZlbnQsbz10LmV2ZW50VGFyZ2V0LGk9dC50YXJnZXRzO2lmKFwiaG9sZFwiPT09ci50eXBlJiZpLmxlbmd0aCl7dmFyIGE9aVswXS5ldmVudGFibGUub3B0aW9ucy5ob2xkUmVwZWF0SW50ZXJ2YWw7YTw9MHx8KG4uaG9sZEludGVydmFsSGFuZGxlPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLnBvaW50ZXJFdmVudHMuZmlyZSh7aW50ZXJhY3Rpb246bixldmVudFRhcmdldDpvLHR5cGU6XCJob2xkXCIscG9pbnRlcjpyLGV2ZW50OnJ9LGUpfSxhKSl9fX0pfTtlbC5kZWZhdWx0PWlsO3ZhciBhbD17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYWwsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksYWwuZGVmYXVsdD12b2lkIDA7dmFyIHVsLHNsPSh1bD1jdCkmJnVsLl9fZXNNb2R1bGU/dWw6e2RlZmF1bHQ6dWx9O2Z1bmN0aW9uIGxsKHQpe3JldHVybigwLHNsLmRlZmF1bHQpKHRoaXMuZXZlbnRzLm9wdGlvbnMsdCksdGhpc312YXIgY2w9e2lkOlwicG9pbnRlci1ldmVudHMvaW50ZXJhY3RhYmxlVGFyZ2V0c1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5JbnRlcmFjdGFibGU7ZS5wcm90b3R5cGUucG9pbnRlckV2ZW50cz1sbDt2YXIgcj1lLnByb3RvdHlwZS5fYmFja0NvbXBhdE9wdGlvbjtlLnByb3RvdHlwZS5fYmFja0NvbXBhdE9wdGlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXIuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIG49PT10aGlzJiYodGhpcy5ldmVudHMub3B0aW9uc1t0XT1lKSxufX0sbGlzdGVuZXJzOntcInBvaW50ZXJFdmVudHM6Y29sbGVjdC10YXJnZXRzXCI6ZnVuY3Rpb24odCxlKXt2YXIgcj10LnRhcmdldHMsbz10Lm5vZGUsaT10LnR5cGUsYT10LmV2ZW50VGFyZ2V0O2UuaW50ZXJhY3RhYmxlcy5mb3JFYWNoTWF0Y2gobyxmdW5jdGlvbih0KXt2YXIgZT10LmV2ZW50cyxuPWUub3B0aW9ucztlLnR5cGVzW2ldJiZlLnR5cGVzW2ldLmxlbmd0aCYmdC50ZXN0SWdub3JlQWxsb3cobixvLGEpJiZyLnB1c2goe25vZGU6byxldmVudGFibGU6ZSxwcm9wczp7aW50ZXJhY3RhYmxlOnR9fSl9KX0sXCJpbnRlcmFjdGFibGU6bmV3XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGFibGU7ZS5ldmVudHMuZ2V0UmVjdD1mdW5jdGlvbih0KXtyZXR1cm4gZS5nZXRSZWN0KHQpfX0sXCJpbnRlcmFjdGFibGU6c2V0XCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0YWJsZSxyPXQub3B0aW9uczsoMCxzbC5kZWZhdWx0KShuLmV2ZW50cy5vcHRpb25zLGUucG9pbnRlckV2ZW50cy5kZWZhdWx0cyksKDAsc2wuZGVmYXVsdCkobi5ldmVudHMub3B0aW9ucyxyLnBvaW50ZXJFdmVudHN8fHt9KX19fTthbC5kZWZhdWx0PWNsO3ZhciBmbD17fTtmdW5jdGlvbiBwbCh0KXtyZXR1cm4ocGw9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZmwsXCJob2xkUmVwZWF0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZsLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGZsLFwiaW50ZXJhY3RhYmxlVGFyZ2V0c1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB5bC5kZWZhdWx0fX0pLGZsLnBvaW50ZXJFdmVudHM9ZmwuZGVmYXVsdD12b2lkIDA7dmFyIGRsPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PXBsKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPWdsKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KFZzKTtmbC5wb2ludGVyRXZlbnRzPWRsO3ZhciB2bD1obChlbCkseWw9aGwoYWwpO2Z1bmN0aW9uIGhsKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBnbCgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIGdsPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9dmFyIGJsPXtpZDpcInBvaW50ZXItZXZlbnRzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LnVzZVBsdWdpbihkbCksdC51c2VQbHVnaW4odmwuZGVmYXVsdCksdC51c2VQbHVnaW4oeWwuZGVmYXVsdCl9fTtmbC5kZWZhdWx0PWJsO3ZhciBtbD17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkobWwsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbWwuaW5zdGFsbD13bCxtbC5kZWZhdWx0PXZvaWQgMDt2YXIgT2w7KE9sPWsoe30pKSYmT2wuX19lc01vZHVsZTtmdW5jdGlvbiB3bChlKXt2YXIgdD1lLkludGVyYWN0YWJsZTtlLmFjdGlvbnMucGhhc2VzLnJlZmxvdz0hMCx0LnByb3RvdHlwZS5yZWZsb3c9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHUscyxsKXtmdW5jdGlvbiB0KCl7dmFyIGU9Y1tkXSx0PXUuZ2V0UmVjdChlKTtpZighdClyZXR1cm5cImJyZWFrXCI7dmFyIG49bGUuYXJyLmZpbmQobC5pbnRlcmFjdGlvbnMubGlzdCxmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGluZygpJiZ0LmludGVyYWN0YWJsZT09PXUmJnQuZWxlbWVudD09PWUmJnQucHJlcGFyZWQubmFtZT09PXMubmFtZX0pLHI9dm9pZCAwO2lmKG4pbi5tb3ZlKCkscCYmKHI9bi5fcmVmbG93UHJvbWlzZXx8bmV3IGYoZnVuY3Rpb24odCl7bi5fcmVmbG93UmVzb2x2ZT10fSkpO2Vsc2V7dmFyIG89bGUucmVjdC50bGJyVG9YeXdoKHQpLGk9e3BhZ2U6e3g6by54LHk6by55fSxjbGllbnQ6e3g6by54LHk6by55fSx0aW1lU3RhbXA6bC5ub3coKX0sYT1sZS5wb2ludGVyLmNvb3Jkc1RvRXZlbnQoaSk7cj1mdW5jdGlvbih0LGUsbixyLG8pe3ZhciBpPXQuaW50ZXJhY3Rpb25zLm5ldyh7cG9pbnRlclR5cGU6XCJyZWZsb3dcIn0pLGE9e2ludGVyYWN0aW9uOmksZXZlbnQ6byxwb2ludGVyOm8sZXZlbnRUYXJnZXQ6bixwaGFzZTpcInJlZmxvd1wifTtpLmludGVyYWN0YWJsZT1lLGkuZWxlbWVudD1uLGkucHJlcGFyZWQ9KDAsbGUuZXh0ZW5kKSh7fSxyKSxpLnByZXZFdmVudD1vLGkudXBkYXRlUG9pbnRlcihvLG8sbiwhMCksaS5fZG9QaGFzZShhKTt2YXIgdT1sZS53aW4ud2luZG93LlByb21pc2U/bmV3IGxlLndpbi53aW5kb3cuUHJvbWlzZShmdW5jdGlvbih0KXtpLl9yZWZsb3dSZXNvbHZlPXR9KTpudWxsO2kuX3JlZmxvd1Byb21pc2U9dSxpLnN0YXJ0KHIsZSxuKSxpLl9pbnRlcmFjdGluZz8oaS5tb3ZlKGEpLGkuZW5kKG8pKTppLnN0b3AoKTtyZXR1cm4gaS5yZW1vdmVQb2ludGVyKG8sbyksaS5wb2ludGVySXNEb3duPSExLHV9KGwsdSxlLHMsYSl9cCYmcC5wdXNoKHIpfWZvcih2YXIgYz1sZS5pcy5zdHJpbmcodS50YXJnZXQpP2xlLmFyci5mcm9tKHUuX2NvbnRleHQucXVlcnlTZWxlY3RvckFsbCh1LnRhcmdldCkpOlt1LnRhcmdldF0sZj1sZS53aW4ud2luZG93LlByb21pc2UscD1mP1tdOm51bGwsZD0wO2Q8Yy5sZW5ndGg7ZCsrKXtpZihcImJyZWFrXCI9PT10KCkpYnJlYWt9cmV0dXJuIHAmJmYuYWxsKHApLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdX0pfSh0aGlzLHQsZSl9fXZhciBfbD17aWQ6XCJyZWZsb3dcIixpbnN0YWxsOndsLGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6c3RvcFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbjtcInJlZmxvd1wiPT09bi5wb2ludGVyVHlwZSYmKG4uX3JlZmxvd1Jlc29sdmUmJm4uX3JlZmxvd1Jlc29sdmUoKSxsZS5hcnIucmVtb3ZlKGUuaW50ZXJhY3Rpb25zLmxpc3QsbikpfX19O21sLmRlZmF1bHQ9X2w7dmFyIFBsPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShQbCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxQbC5kZWZhdWx0PXZvaWQgMDtQbC5kZWZhdWx0PXt9O3ZhciB4bD17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeGwsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkseGwuZXhjaGFuZ2U9dm9pZCAwO3hsLmV4Y2hhbmdlPXt9O3ZhciBTbD17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoU2wsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksU2wuZGVmYXVsdD12b2lkIDA7U2wuZGVmYXVsdD17fTt2YXIgamw9e307ZnVuY3Rpb24gTWwodCl7cmV0dXJuKE1sPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoamwsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksamwuZGVmYXVsdD12b2lkIDA7dmFyIGtsPUhsKFFyKSxFbD1IbChhbyksVGw9SGwodW8pLERsPUhsKHRpKSxJbD1IbChhaSksemw9SGwodWkpLEFsPUhsKFVuKSxDbD0oSGwoc2kpLEdsKHdpKSksV2w9SGwoJGkpLFJsPUhsKGhhKSxGbD1IbChTcyksWGw9SGwoRHMpLFlsPUhsKFlpKSxObD1IbChmbCksTGw9SGwobWwpLEJsPUdsKFBsKSxWbD1HbCh6dCkscWw9R2woU2wpO2Z1bmN0aW9uIFVsKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gVWw9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBHbCh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1NbCh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1VbCgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufWZ1bmN0aW9uIEhsKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1SbC5kZWZhdWx0LnVzZShYbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShBbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShZbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShJbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShFbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShObC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShXbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShGbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShEbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShrbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShUbC5kZWZhdWx0KSxSbC5kZWZhdWx0LnVzZShMbC5kZWZhdWx0KSxSbC5kZWZhdWx0LmZlZWRiYWNrPUNsLFJsLmRlZmF1bHQudXNlKHpsLmRlZmF1bHQpLFJsLmRlZmF1bHQudnVlPXtjb21wb25lbnRzOnFsfSxSbC5kZWZhdWx0Ll9fdXRpbHM9e2V4Y2hhbmdlOnhsLmV4Y2hhbmdlLGRpc3BsYWNlOkJsLHBvaW50ZXI6Vmx9O3ZhciBLbD1SbC5kZWZhdWx0O2psLmRlZmF1bHQ9S2w7dmFyICRsPXtleHBvcnRzOnt9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoJGwuZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSwkbC5leHBvcnRzLmRlZmF1bHQ9dm9pZCAwO3ZhciBabCxKbD0oWmw9amwpJiZabC5fX2VzTW9kdWxlP1psOntkZWZhdWx0OlpsfTtmdW5jdGlvbiBRbCh0KXtyZXR1cm4oUWw9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWlmKFwib2JqZWN0XCI9PT1RbCgkbCkmJiRsKXRyeXskbC5leHBvcnRzPUpsLmRlZmF1bHR9Y2F0Y2godCl7fUpsLmRlZmF1bHQuZGVmYXVsdD1KbC5kZWZhdWx0O3ZhciB0Yz1KbC5kZWZhdWx0O3JldHVybiAkbC5leHBvcnRzLmRlZmF1bHQ9dGMsJGw9JGwuZXhwb3J0c30pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmFjdC5taW4uanMubWFwXG4iLCIvKiFcbiAqIGlzZWN0IHYzLjAuMFxuICogKGMpIDIwMTggQW5kcmVpIEthc2hjaGEuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5pc2VjdCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGZvbGxvd3MgXCJBbiBpbXBsZW1lbnRhdGlvbiBvZiB0b3AtZG93biBzcGxheWluZ1wiXG4gICAqIGJ5IEQuIFNsZWF0b3IgPHNsZWF0b3JAY3MuY211LmVkdT4gTWFyY2ggMTk5MlxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYgeyp9IEtleVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7Kn0gVmFsdWVcbiAgICovXG5cblxuICAvKipcbiAgICogQHR5cGVkZWYge2Z1bmN0aW9uKG5vZGU6Tm9kZSk6dm9pZH0gVmlzaXRvclxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7ZnVuY3Rpb24oYTpLZXksIGI6S2V5KTpudW1iZXJ9IENvbXBhcmF0b3JcbiAgICovXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihub2RlOk5vZGUpOnN0cmluZ30gTm9kZVByaW50ZXJcbiAgICovXG5cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gIE5vZGVcbiAgICogQHByb3BlcnR5IHtLZXl9ICAgIEtleVxuICAgKiBAcHJvcGVydHkge1ZhbHVlPX0gZGF0YVxuICAgKiBAcHJvcGVydHkge05vZGV9ICAgbGVmdFxuICAgKiBAcHJvcGVydHkge05vZGV9ICAgcmlnaHRcbiAgICovXG5cbiAgdmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlIChrZXksIGRhdGEpIHtcbiAgICB0aGlzLmtleSAgPSBrZXk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgIHRoaXMucmlnaHQ9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gREVGQVVMVF9DT01QQVJFIChhLCBiKSB7IHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDsgfVxuXG5cbiAgLyoqXG4gICAqIFNpbXBsZSB0b3AgZG93biBzcGxheSwgbm90IHJlcXVpcmluZyBpIHRvIGJlIGluIHRoZSB0cmVlIHQuXG4gICAqIEBwYXJhbSB7S2V5fSBpXG4gICAqIEBwYXJhbSB7Tm9kZT99IHRcbiAgICogQHBhcmFtIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yXG4gICAqL1xuICBmdW5jdGlvbiBzcGxheSAoaSwgdCwgY29tcGFyYXRvcikge1xuICAgIGlmICh0ID09PSBudWxsKSB7IHJldHVybiB0OyB9XG4gICAgdmFyIGwsIHIsIHk7XG4gICAgdmFyIE4gPSBuZXcgTm9kZSgpO1xuICAgIGwgPSByID0gTjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XG4gICAgICAvL2lmIChpIDwgdC5rZXkpIHtcbiAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgIGlmICh0LmxlZnQgPT09IG51bGwpIHsgYnJlYWs7IH1cbiAgICAgICAgLy9pZiAoaSA8IHQubGVmdC5rZXkpIHtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaSwgdC5sZWZ0LmtleSkgPCAwKSB7XG4gICAgICAgICAgeSA9IHQubGVmdDsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiByb3RhdGUgcmlnaHQgKi9cbiAgICAgICAgICB0LmxlZnQgPSB5LnJpZ2h0O1xuICAgICAgICAgIHkucmlnaHQgPSB0O1xuICAgICAgICAgIHQgPSB5O1xuICAgICAgICAgIGlmICh0LmxlZnQgPT09IG51bGwpIHsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICByLmxlZnQgPSB0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaW5rIHJpZ2h0ICovXG4gICAgICAgIHIgPSB0O1xuICAgICAgICB0ID0gdC5sZWZ0O1xuICAgICAgLy99IGVsc2UgaWYgKGkgPiB0LmtleSkge1xuICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgIGlmICh0LnJpZ2h0ID09PSBudWxsKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vaWYgKGkgPiB0LnJpZ2h0LmtleSkge1xuICAgICAgICBpZiAoY29tcGFyYXRvcihpLCB0LnJpZ2h0LmtleSkgPiAwKSB7XG4gICAgICAgICAgeSA9IHQucmlnaHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiByb3RhdGUgbGVmdCAqL1xuICAgICAgICAgIHQucmlnaHQgPSB5LmxlZnQ7XG4gICAgICAgICAgeS5sZWZ0ID0gdDtcbiAgICAgICAgICB0ID0geTtcbiAgICAgICAgICBpZiAodC5yaWdodCA9PT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGwucmlnaHQgPSB0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpbmsgbGVmdCAqL1xuICAgICAgICBsID0gdDtcbiAgICAgICAgdCA9IHQucmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyogYXNzZW1ibGUgKi9cbiAgICBsLnJpZ2h0ID0gdC5sZWZ0O1xuICAgIHIubGVmdCA9IHQucmlnaHQ7XG4gICAgdC5sZWZ0ID0gTi5yaWdodDtcbiAgICB0LnJpZ2h0ID0gTi5sZWZ0O1xuICAgIHJldHVybiB0O1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtICB7S2V5fSAgICAgICAgaVxuICAgKiBAcGFyYW0gIHtWYWx1ZX0gICAgICBkYXRhXG4gICAqIEBwYXJhbSAge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3JcbiAgICogQHBhcmFtICB7VHJlZX0gICAgICAgdHJlZVxuICAgKiBAcmV0dXJuIHtOb2RlfSAgICAgIHJvb3RcbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydCAoaSwgZGF0YSwgdCwgY29tcGFyYXRvciwgdHJlZSkge1xuICAgIHZhciBub2RlID0gbmV3IE5vZGUoaSwgZGF0YSk7XG5cbiAgICB0cmVlLl9zaXplKys7XG5cbiAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgbm9kZS5sZWZ0ID0gbm9kZS5yaWdodCA9IG51bGw7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICB0ID0gc3BsYXkoaSwgdCwgY29tcGFyYXRvcik7XG4gICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICBub2RlLmxlZnQgPSB0LmxlZnQ7XG4gICAgICBub2RlLnJpZ2h0ID0gdDtcbiAgICAgIHQubGVmdCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChjbXAgPj0gMCkge1xuICAgICAgbm9kZS5yaWdodCA9IHQucmlnaHQ7XG4gICAgICBub2RlLmxlZnQgPSB0O1xuICAgICAgdC5yaWdodCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cblxuICAvKipcbiAgICogSW5zZXJ0IGkgaW50byB0aGUgdHJlZSB0LCB1bmxlc3MgaXQncyBhbHJlYWR5IHRoZXJlLlxuICAgKiBAcGFyYW0gIHtLZXl9ICAgICAgICBpXG4gICAqIEBwYXJhbSAge1ZhbHVlfSAgICAgIGRhdGFcbiAgICogQHBhcmFtICB7Q29tcGFyYXRvcn0gY29tcGFyYXRvclxuICAgKiBAcGFyYW0gIHtUcmVlfSAgICAgICB0cmVlXG4gICAqIEByZXR1cm4ge05vZGV9ICAgICAgIHJvb3RcbiAgICovXG4gIGZ1bmN0aW9uIGFkZCAoaSwgZGF0YSwgdCwgY29tcGFyYXRvciwgdHJlZSkge1xuICAgIHZhciBub2RlID0gbmV3IE5vZGUoaSwgZGF0YSk7XG5cbiAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgbm9kZS5sZWZ0ID0gbm9kZS5yaWdodCA9IG51bGw7XG4gICAgICB0cmVlLl9zaXplKys7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICB0ID0gc3BsYXkoaSwgdCwgY29tcGFyYXRvcik7XG4gICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xuICAgIGlmIChjbXAgPT09IDApIHsgcmV0dXJuIHQ7IH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgIG5vZGUubGVmdCA9IHQubGVmdDtcbiAgICAgICAgbm9kZS5yaWdodCA9IHQ7XG4gICAgICAgIHQubGVmdCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgbm9kZS5yaWdodCA9IHQucmlnaHQ7XG4gICAgICAgIG5vZGUubGVmdCA9IHQ7XG4gICAgICAgIHQucmlnaHQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdHJlZS5fc2l6ZSsrO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogRGVsZXRlcyBpIGZyb20gdGhlIHRyZWUgaWYgaXQncyB0aGVyZVxuICAgKiBAcGFyYW0ge0tleX0gICAgICAgIGlcbiAgICogQHBhcmFtIHtUcmVlfSAgICAgICB0cmVlXG4gICAqIEBwYXJhbSB7Q29tcGFyYXRvcn0gY29tcGFyYXRvclxuICAgKiBAcGFyYW0ge1RyZWV9ICAgICAgIHRyZWVcbiAgICogQHJldHVybiB7Tm9kZX0gICAgICBuZXcgcm9vdFxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlIChpLCB0LCBjb21wYXJhdG9yLCB0cmVlKSB7XG4gICAgdmFyIHg7XG4gICAgaWYgKHQgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0ID0gc3BsYXkoaSwgdCwgY29tcGFyYXRvcik7XG4gICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xuICAgIGlmIChjbXAgPT09IDApIHsgICAgICAgICAgICAgICAvKiBmb3VuZCBpdCAqL1xuICAgICAgaWYgKHQubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gdC5yaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBzcGxheShpLCB0LmxlZnQsIGNvbXBhcmF0b3IpO1xuICAgICAgICB4LnJpZ2h0ID0gdC5yaWdodDtcbiAgICAgIH1cbiAgICAgIHRyZWUuX3NpemUtLTtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICByZXR1cm4gdDsgICAgICAgICAgICAgICAgICAgICAgICAgLyogSXQgd2Fzbid0IHRoZXJlICovXG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNwbGl0IChrZXksIHYsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgbGVmdCwgcmlnaHQ7XG4gICAgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgIGxlZnQgPSByaWdodCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSBzcGxheShrZXksIHYsIGNvbXBhcmF0b3IpO1xuXG4gICAgICB2YXIgY21wID0gY29tcGFyYXRvcih2LmtleSwga2V5KTtcbiAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgbGVmdCAgPSB2LmxlZnQ7XG4gICAgICAgIHJpZ2h0ID0gdi5yaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICByaWdodCAgID0gdi5yaWdodDtcbiAgICAgICAgdi5yaWdodCA9IG51bGw7XG4gICAgICAgIGxlZnQgICAgPSB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCAgID0gdi5sZWZ0O1xuICAgICAgICB2LmxlZnQgPSBudWxsO1xuICAgICAgICByaWdodCAgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQgfTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gbWVyZ2UgKGxlZnQsIHJpZ2h0LCBjb21wYXJhdG9yKSB7XG4gICAgaWYgKHJpZ2h0ID09PSBudWxsKSB7IHJldHVybiBsZWZ0OyB9XG4gICAgaWYgKGxlZnQgID09PSBudWxsKSB7IHJldHVybiByaWdodDsgfVxuXG4gICAgcmlnaHQgPSBzcGxheShsZWZ0LmtleSwgcmlnaHQsIGNvbXBhcmF0b3IpO1xuICAgIHJpZ2h0LmxlZnQgPSBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFByaW50cyBsZXZlbCBvZiB0aGUgdHJlZVxuICAgKiBAcGFyYW0gIHtOb2RlfSAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICBwcmVmaXhcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICBpc1RhaWxcbiAgICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgICAgICBvdXRcbiAgICogQHBhcmFtICB7RnVuY3Rpb24obm9kZTpOb2RlKTpTdHJpbmd9ICBwcmludE5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIHByaW50Um93IChyb290LCBwcmVmaXgsIGlzVGFpbCwgb3V0LCBwcmludE5vZGUpIHtcbiAgICBpZiAocm9vdCkge1xuICAgICAgb3V0KChcIlwiICsgcHJlZml4ICsgKGlzVGFpbCA/ICfilJTilIDilIAgJyA6ICfilJzilIDilIAgJykgKyAocHJpbnROb2RlKHJvb3QpKSArIFwiXFxuXCIpKTtcbiAgICAgIHZhciBpbmRlbnQgPSBwcmVmaXggKyAoaXNUYWlsID8gJyAgICAnIDogJ+KUgiAgICcpO1xuICAgICAgaWYgKHJvb3QubGVmdCkgIHsgcHJpbnRSb3cocm9vdC5sZWZ0LCAgaW5kZW50LCBmYWxzZSwgb3V0LCBwcmludE5vZGUpOyB9XG4gICAgICBpZiAocm9vdC5yaWdodCkgeyBwcmludFJvdyhyb290LnJpZ2h0LCBpbmRlbnQsIHRydWUsICBvdXQsIHByaW50Tm9kZSk7IH1cbiAgICB9XG4gIH1cblxuXG4gIHZhciBUcmVlID0gZnVuY3Rpb24gVHJlZSAoY29tcGFyYXRvcikge1xuICAgIGlmICggY29tcGFyYXRvciA9PT0gdm9pZCAwICkgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSRTtcblxuICAgIHRoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHNpemU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEga2V5LCBhbGxvd3MgZHVwbGljYXRlc1xuICAgKiBAcGFyYW17S2V5fSAga2V5XG4gICAqIEBwYXJhbXtWYWx1ZT19IGRhdGFcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0JDEgKGtleSwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9yb290ID0gaW5zZXJ0KGtleSwgZGF0YSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvciwgdGhpcyk7XG4gIH07XG5cblxuICAvKipcbiAgICogQWRkcyBhIGtleSwgaWYgaXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIHRyZWVcbiAgICogQHBhcmFte0tleX0gIGtleVxuICAgKiBAcGFyYW17VmFsdWU9fSBkYXRhXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCQxIChrZXksIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdCA9IGFkZChrZXksIGRhdGEsIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IsIHRoaXMpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtLZXl9IGtleVxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUkMSAoa2V5KSB7XG4gICAgdGhpcy5fcm9vdCA9IHJlbW92ZShrZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IsIHRoaXMpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIG5vZGUgd2l0aCBzbWFsbGVzdCBrZXlcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgd2hpbGUgKG5vZGUubGVmdCkgeyBub2RlID0gbm9kZS5sZWZ0OyB9XG4gICAgICB0aGlzLl9yb290ID0gc3BsYXkobm9kZS5rZXksdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XG4gICAgICB0aGlzLl9yb290ID0gcmVtb3ZlKG5vZGUua2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yLCB0aGlzKTtcbiAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIGRhdGE6IG5vZGUuZGF0YSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17S2V5fSBrZXlcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuZmluZFN0YXRpYyA9IGZ1bmN0aW9uIGZpbmRTdGF0aWMgKGtleSkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJlKGtleSwgY3VycmVudC5rZXkpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkgIHsgcmV0dXJuIGN1cnJlbnQ7IH1cbiAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHsgY3VycmVudCA9IGN1cnJlbnQubGVmdDsgfVxuICAgICAgZWxzZSAgICAgICAgICAgIHsgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte0tleX0ga2V5XG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kIChrZXkpIHtcbiAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgdGhpcy5fcm9vdCA9IHNwbGF5KGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XG4gICAgICBpZiAodGhpcy5fY29tcGFyYXRvcihrZXksIHRoaXMuX3Jvb3Qua2V5KSAhPT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17S2V5fSBrZXlcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMgKGtleSkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJlKGtleSwgY3VycmVudC5rZXkpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkgIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHsgY3VycmVudCA9IGN1cnJlbnQubGVmdDsgfVxuICAgICAgZWxzZSAgICAgICAgICAgIHsgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtWaXNpdG9yfSB2aXNpdG9yXG4gICAqIEBwYXJhbXsqPX0gICAgY3R4XG4gICAqIEByZXR1cm4ge1NwbGF5VHJlZX1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoICh2aXNpdG9yLCBjdHgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIFEgPSBbXTsvKiBJbml0aWFsaXplIHN0YWNrIHMgKi9cbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICBpZiAoY3VycmVudCAhPT1udWxsKSB7XG4gICAgICAgIFEucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xuICAgICAgICAgIHZpc2l0b3IuY2FsbChjdHgsIGN1cnJlbnQpO1xuXG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7IGRvbmUgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFdhbGsga2V5IHJhbmdlIGZyb20gYGxvd2AgdG8gYGhpZ2hgLiBTdG9wcyBpZiBgZm5gIHJldHVybnMgYSB2YWx1ZS5cbiAgICogQHBhcmFte0tleX0gICAgbG93XG4gICAqIEBwYXJhbXtLZXl9ICAgIGhpZ2hcbiAgICogQHBhcmFte0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW17Kj99ICAgICBjdHhcbiAgICogQHJldHVybiB7U3BsYXlUcmVlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSAobG93LCBoaWdoLCBmbiwgY3R4KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBRID0gW107XG4gICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgIHZhciBub2RlID0gdGhpcy5fcm9vdCwgY21wO1xuXG4gICAgd2hpbGUgKFEubGVuZ3RoICE9PSAwIHx8IG5vZGUpIHtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIFEucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBRLnBvcCgpO1xuICAgICAgICBjbXAgPSBjb21wYXJlKG5vZGUua2V5LCBoaWdoKTtcbiAgICAgICAgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlKG5vZGUua2V5LCBsb3cpID49IDApIHtcbiAgICAgICAgICBpZiAoZm4uY2FsbChjdHgsIG5vZGUpKSB7IHJldHVybiB0aGlzJDE7IH0gLy8gc3RvcCBpZiBzbXRoIGlzIHJldHVybmVkXG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgb2Yga2V5c1xuICAgKiBAcmV0dXJuIHtBcnJheTxLZXk+fVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uIGtleXMgKCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGtleSA9IHJlZi5rZXk7XG5cbiAgICAgICAgcmV0dXJuIGtleXMucHVzaChrZXkpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSBvZiBhbGwgdGhlIGRhdGEgaW4gdGhlIG5vZGVzXG4gICAqIEByZXR1cm4ge0FycmF5PFZhbHVlPn1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcyAoKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcy5wdXNoKGRhdGEpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtLZXl8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QpIHsgcmV0dXJuIHRoaXMubWluTm9kZSh0aGlzLl9yb290KS5rZXk7IH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtLZXl8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSh0aGlzLl9yb290KS5rZXk7IH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5taW5Ob2RlID0gZnVuY3Rpb24gbWluTm9kZSAodCkge1xuICAgICAgaWYgKCB0ID09PSB2b2lkIDAgKSB0ID0gdGhpcy5fcm9vdDtcblxuICAgIGlmICh0KSB7IHdoaWxlICh0LmxlZnQpIHsgdCA9IHQubGVmdDsgfSB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUubWF4Tm9kZSA9IGZ1bmN0aW9uIG1heE5vZGUgKHQpIHtcbiAgICAgIGlmICggdCA9PT0gdm9pZCAwICkgdCA9IHRoaXMuX3Jvb3Q7XG5cbiAgICBpZiAodCkgeyB3aGlsZSAodC5yaWdodCkgeyB0ID0gdC5yaWdodDsgfSB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyBub2RlIGF0IGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbXtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaW5kZXgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3QsIGRvbmUgPSBmYWxzZSwgaSA9IDA7XG4gICAgdmFyIFEgPSBbXTtcblxuICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xuICAgICAgICAgIGlmIChpID09PSBpbmRleCkgeyByZXR1cm4gY3VycmVudDsgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfSBlbHNlIHsgZG9uZSA9IHRydWU7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte05vZGV9IGRcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKGQpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHN1Y2Nlc3NvciA9IG51bGw7XG5cbiAgICBpZiAoZC5yaWdodCkge1xuICAgICAgc3VjY2Vzc29yID0gZC5yaWdodDtcbiAgICAgIHdoaWxlIChzdWNjZXNzb3IubGVmdCkgeyBzdWNjZXNzb3IgPSBzdWNjZXNzb3IubGVmdDsgfVxuICAgICAgcmV0dXJuIHN1Y2Nlc3NvcjtcbiAgICB9XG5cbiAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgd2hpbGUgKHJvb3QpIHtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGQua2V5LCByb290LmtleSk7XG4gICAgICBpZiAoY21wID09PSAwKSB7IGJyZWFrOyB9XG4gICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgIHN1Y2Nlc3NvciA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSByb290LmxlZnQ7XG4gICAgICB9IGVsc2UgeyByb290ID0gcm9vdC5yaWdodDsgfVxuICAgIH1cblxuICAgIHJldHVybiBzdWNjZXNzb3I7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte05vZGV9IGRcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uIHByZXYgKGQpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHByZWRlY2Vzc29yID0gbnVsbDtcblxuICAgIGlmIChkLmxlZnQgIT09IG51bGwpIHtcbiAgICAgIHByZWRlY2Vzc29yID0gZC5sZWZ0O1xuICAgICAgd2hpbGUgKHByZWRlY2Vzc29yLnJpZ2h0KSB7IHByZWRlY2Vzc29yID0gcHJlZGVjZXNzb3IucmlnaHQ7IH1cbiAgICAgIHJldHVybiBwcmVkZWNlc3NvcjtcbiAgICB9XG5cbiAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgd2hpbGUgKHJvb3QpIHtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGQua2V5LCByb290LmtleSk7XG4gICAgICBpZiAoY21wID09PSAwKSB7IGJyZWFrOyB9XG4gICAgICBlbHNlIGlmIChjbXAgPCAwKSB7IHJvb3QgPSByb290LmxlZnQ7IH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwcmVkZWNlc3NvciA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSByb290LnJpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJlZGVjZXNzb3I7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7U3BsYXlUcmVlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Tm9kZUxpc3R9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS50b0xpc3QgPSBmdW5jdGlvbiB0b0xpc3QkMSAoKSB7XG4gICAgcmV0dXJuIHRvTGlzdCh0aGlzLl9yb290KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBCdWxrLWxvYWQgaXRlbXMuIEJvdGggYXJyYXkgaGF2ZSB0byBiZSBzYW1lIHNpemVcbiAgICogQHBhcmFte0FycmF5PEtleT59ICBrZXlzXG4gICAqIEBwYXJhbXtBcnJheTxWYWx1ZT59W3ZhbHVlc11cbiAgICogQHBhcmFte0Jvb2xlYW59ICAgICBbcHJlc29ydD1mYWxzZV0gUHJlLXNvcnQga2V5cyBhbmQgdmFsdWVzLCB1c2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUncyBjb21wYXJhdG9yLiBTb3J0aW5nIGlzIGRvbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbi1wbGFjZVxuICAgKiBAcmV0dXJuIHtBVkxUcmVlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQgKGtleXMsIHZhbHVlcywgcHJlc29ydCkge1xuICAgICAgaWYgKCBrZXlzID09PSB2b2lkIDAgKSBrZXlzID0gW107XG4gICAgICBpZiAoIHZhbHVlcyA9PT0gdm9pZCAwICkgdmFsdWVzID0gW107XG4gICAgICBpZiAoIHByZXNvcnQgPT09IHZvaWQgMCApIHByZXNvcnQgPSBmYWxzZTtcblxuICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xuXG4gICAgLy8gc29ydCBpZiBuZWVkZWRcbiAgICBpZiAocHJlc29ydCkgeyBzb3J0KGtleXMsIHZhbHVlcywgMCwgc2l6ZSAtIDEsIGNvbXBhcmF0b3IpOyB9XG5cbiAgICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkgeyAvLyBlbXB0eSB0cmVlXG4gICAgICB0aGlzLl9yb290ID0gbG9hZFJlY3Vyc2l2ZSh0aGlzLl9yb290LCBrZXlzLCB2YWx1ZXMsIDAsIHNpemUpO1xuICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgfSBlbHNlIHsgLy8gdGhhdCByZS1idWlsZHMgdGhlIHdob2xlIHRyZWUgZnJvbSB0d28gaW4tb3JkZXIgdHJhdmVyc2Fsc1xuICAgICAgdmFyIG1lcmdlZExpc3QgPSBtZXJnZUxpc3RzKHRoaXMudG9MaXN0KCksIGNyZWF0ZUxpc3Qoa2V5cywgdmFsdWVzKSwgY29tcGFyYXRvcik7XG4gICAgICBzaXplID0gdGhpcy5fc2l6ZSArIHNpemU7XG4gICAgICB0aGlzLl9yb290ID0gc29ydGVkTGlzdFRvQlNUKHsgaGVhZDogbWVyZ2VkTGlzdCB9LCAwLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3QgPT09IG51bGw7IH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLnNpemUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2l6ZTsgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17Tm9kZVByaW50ZXI9fSBwcmludE5vZGVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAocHJpbnROb2RlKSB7XG4gICAgICBpZiAoIHByaW50Tm9kZSA9PT0gdm9pZCAwICkgcHJpbnROb2RlID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ua2V5OyB9O1xuXG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHByaW50Um93KHRoaXMuX3Jvb3QsICcnLCB0cnVlLCBmdW5jdGlvbiAodikgeyByZXR1cm4gb3V0LnB1c2godik7IH0sIHByaW50Tm9kZSk7XG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgfTtcblxuXG4gIFRyZWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoa2V5LCBuZXdLZXksIG5ld0RhdGEpIHtcbiAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgdmFyIHJlZiA9IHNwbGl0KGtleSwgdGhpcy5fcm9vdCwgY29tcGFyYXRvcik7XG4gICAgICB2YXIgbGVmdCA9IHJlZi5sZWZ0O1xuICAgICAgdmFyIHJpZ2h0ID0gcmVmLnJpZ2h0O1xuICAgIHRoaXMuX3NpemUtLTtcbiAgICBpZiAoY29tcGFyYXRvcihrZXksIG5ld0tleSkgPCAwKSB7XG4gICAgICByaWdodCA9IGluc2VydChuZXdLZXksIG5ld0RhdGEsIHJpZ2h0LCBjb21wYXJhdG9yLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IGluc2VydChuZXdLZXksIG5ld0RhdGEsIGxlZnQsIGNvbXBhcmF0b3IsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9yb290ID0gbWVyZ2UobGVmdCwgcmlnaHQsIGNvbXBhcmF0b3IpO1xuICB9O1xuXG5cbiAgVHJlZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCQxIChrZXkpIHtcbiAgICByZXR1cm4gc3BsaXQoa2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVHJlZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5cbiAgZnVuY3Rpb24gbG9hZFJlY3Vyc2l2ZSAocGFyZW50LCBrZXlzLCB2YWx1ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xuICAgIGlmIChzaXplID4gMCkge1xuICAgICAgdmFyIG1pZGRsZSA9IHN0YXJ0ICsgTWF0aC5mbG9vcihzaXplIC8gMik7XG4gICAgICB2YXIga2V5ICAgID0ga2V5c1ttaWRkbGVdO1xuICAgICAgdmFyIGRhdGEgICA9IHZhbHVlc1ttaWRkbGVdO1xuICAgICAgdmFyIG5vZGUgICA9IHsga2V5OiBrZXksIGRhdGE6IGRhdGEsIHBhcmVudDogcGFyZW50IH07XG4gICAgICBub2RlLmxlZnQgICAgPSBsb2FkUmVjdXJzaXZlKG5vZGUsIGtleXMsIHZhbHVlcywgc3RhcnQsIG1pZGRsZSk7XG4gICAgICBub2RlLnJpZ2h0ICAgPSBsb2FkUmVjdXJzaXZlKG5vZGUsIGtleXMsIHZhbHVlcywgbWlkZGxlICsgMSwgZW5kKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gY3JlYXRlTGlzdChrZXlzLCB2YWx1ZXMpIHtcbiAgICB2YXIgaGVhZCA9IHsgbmV4dDogbnVsbCB9O1xuICAgIHZhciBwID0gaGVhZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHAgPSBwLm5leHQgPSB7IGtleToga2V5c1tpXSwgZGF0YTogdmFsdWVzW2ldIH07XG4gICAgfVxuICAgIHAubmV4dCA9IG51bGw7XG4gICAgcmV0dXJuIGhlYWQubmV4dDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdG9MaXN0IChyb290KSB7XG4gICAgdmFyIGN1cnJlbnQgPSByb290O1xuICAgIHZhciBRID0gW10sIGRvbmUgPSBmYWxzZTtcblxuICAgIHZhciBoZWFkID0geyBuZXh0OiBudWxsIH07XG4gICAgdmFyIHAgPSBoZWFkO1xuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBRLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoUS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IHAgPSBwLm5leHQgPSBRLnBvcCgpO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgeyBkb25lID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBwLm5leHQgPSBudWxsOyAvLyB0aGF0J2xsIHdvcmsgZXZlbiBpZiB0aGUgdHJlZSB3YXMgZW1wdHlcbiAgICByZXR1cm4gaGVhZC5uZXh0O1xuICB9XG5cblxuICBmdW5jdGlvbiBzb3J0ZWRMaXN0VG9CU1QobGlzdCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzaXplID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICB2YXIgbWlkZGxlID0gc3RhcnQgKyBNYXRoLmZsb29yKHNpemUgLyAyKTtcbiAgICAgIHZhciBsZWZ0ID0gc29ydGVkTGlzdFRvQlNUKGxpc3QsIHN0YXJ0LCBtaWRkbGUpO1xuXG4gICAgICB2YXIgcm9vdCA9IGxpc3QuaGVhZDtcbiAgICAgIHJvb3QubGVmdCA9IGxlZnQ7XG5cbiAgICAgIGxpc3QuaGVhZCA9IGxpc3QuaGVhZC5uZXh0O1xuXG4gICAgICByb290LnJpZ2h0ID0gc29ydGVkTGlzdFRvQlNUKGxpc3QsIG1pZGRsZSArIDEsIGVuZCk7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG1lcmdlTGlzdHMgKGwxLCBsMiwgY29tcGFyZSkge1xuICAgIGlmICggY29tcGFyZSA9PT0gdm9pZCAwICkgY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxuICAgIHZhciBoZWFkID0ge307IC8vIGR1bW15XG4gICAgdmFyIHAgPSBoZWFkO1xuXG4gICAgdmFyIHAxID0gbDE7XG4gICAgdmFyIHAyID0gbDI7XG5cbiAgICB3aGlsZSAocDEgIT09IG51bGwgJiYgcDIgIT09IG51bGwpIHtcbiAgICAgIGlmIChjb21wYXJlKHAxLmtleSwgcDIua2V5KSA8IDApIHtcbiAgICAgICAgcC5uZXh0ID0gcDE7XG4gICAgICAgIHAxID0gcDEubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAubmV4dCA9IHAyO1xuICAgICAgICBwMiA9IHAyLm5leHQ7XG4gICAgICB9XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIGlmIChwMSAhPT0gbnVsbCkgICAgICB7IHAubmV4dCA9IHAxOyB9XG4gICAgZWxzZSBpZiAocDIgIT09IG51bGwpIHsgcC5uZXh0ID0gcDI7IH1cblxuICAgIHJldHVybiBoZWFkLm5leHQ7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNvcnQoa2V5cywgdmFsdWVzLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuICAgIGlmIChsZWZ0ID49IHJpZ2h0KSB7IHJldHVybjsgfVxuXG4gICAgdmFyIHBpdm90ID0ga2V5c1sobGVmdCArIHJpZ2h0KSA+PiAxXTtcbiAgICB2YXIgaSA9IGxlZnQgLSAxO1xuICAgIHZhciBqID0gcmlnaHQgKyAxO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGRvIHsgaSsrOyB9IHdoaWxlIChjb21wYXJlKGtleXNbaV0sIHBpdm90KSA8IDApO1xuICAgICAgZG8geyBqLS07IH0gd2hpbGUgKGNvbXBhcmUoa2V5c1tqXSwgcGl2b3QpID4gMCk7XG4gICAgICBpZiAoaSA+PSBqKSB7IGJyZWFrOyB9XG5cbiAgICAgIHZhciB0bXAgPSBrZXlzW2ldO1xuICAgICAga2V5c1tpXSA9IGtleXNbal07XG4gICAgICBrZXlzW2pdID0gdG1wO1xuXG4gICAgICB0bXAgPSB2YWx1ZXNbaV07XG4gICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbal07XG4gICAgICB2YWx1ZXNbal0gPSB0bXA7XG4gICAgfVxuXG4gICAgc29ydChrZXlzLCB2YWx1ZXMsICBsZWZ0LCAgICAgaiwgY29tcGFyZSk7XG4gICAgc29ydChrZXlzLCB2YWx1ZXMsIGogKyAxLCByaWdodCwgY29tcGFyZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFdmVudFF1ZXVlKGJ5WSkge1xuICAgIHZhciBxID0gbmV3IFRyZWUoYnlZKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgIHBvcDogcG9wLFxuICAgICAgZmluZDogZmluZCxcbiAgICAgIGluc2VydDogaW5zZXJ0XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZChwKSB7XG4gICAgICByZXR1cm4gcS5maW5kKHApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICByZXR1cm4gcS5zaXplO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gcS5pc0VtcHR5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0KGV2ZW50KSB7XG4gICAgICAvLyBkZWJ1Z2dlcjtcbiAgICAgIHEuYWRkKGV2ZW50LnBvaW50LCBldmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wKCkge1xuICAgICAgdmFyIG5vZGUgPSBxLnBvcCgpO1xuICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5kYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBKdXN0IGEgY29sbGVjdGlvbiBvZiBnZW9tZXRyeSByZWxhdGVkIHV0aWxpdGllc1xuICAgKi9cblxuICAvLyBUaGlzIGlzIHVzZWQgZm9yIHByZWNpc2lvbiBjaGVja2luZyAoZS5nLiB0d28gbnVtYmVycyBhcmUgZXF1YWxcbiAgLy8gaWYgdGhlaXIgZGlmZmVyZW5jZSBpcyBzbWFsbGVyIHRoYW4gdGhpcyBudW1iZXIpLiBUaGUgdmFsdWUgaXMgXG4gIC8vIGNob3NlbiBlbXBpcmljYWxseS4gV2Ugc3RpbGwgbWF5IHJ1biBpbnRvIHByZWNpc2lvbiByZWxhdGVkIGlzc3Vlcy5cbiAgLy8gVE9ETzogd2Ugc2hvdWxkIGFsbG93IGNvbnN1bWVycyB0byBjb25maWd1cmUgdGhpcy5cbiAgdmFyIEVQUyA9IDFlLTk7Ly8xMDtcblxuICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoc2VnbWVudCwgeFBvcywgeVBvcykge1xuICAgIHZhciBkeTEgPSBzZWdtZW50LmZyb20ueSAtIHlQb3M7XG4gICAgdmFyIGR5MiA9IHlQb3MgLSBzZWdtZW50LnRvLnk7XG4gICAgdmFyIGR5ID0gc2VnbWVudC50by55IC0gc2VnbWVudC5mcm9tLnk7XG4gICAgaWYgKE1hdGguYWJzKGR5MSkgPCBFUFMpIHtcbiAgICAgIC8vIFRoZSBzZWdtZW50IHN0YXJ0cyBvbiB0aGUgc3dlZXAgbGluZVxuICAgICAgaWYgKE1hdGguYWJzKGR5KSA8IEVQUykge1xuICAgICAgICAvLyB0aGUgc2VnbWVudCBpcyBob3Jpem9udGFsLiBJbnRlcnNlY3Rpb24gaXMgYXQgdGhlIHBvaW50XG4gICAgICAgIGlmICh4UG9zIDw9IHNlZ21lbnQuZnJvbS54KSB7IHJldHVybiBzZWdtZW50LmZyb20ueDsgfVxuICAgICAgICBpZiAoeFBvcyA+IHNlZ21lbnQudG8ueCkgeyByZXR1cm4gc2VnbWVudC50by54OyB9XG4gICAgICAgIHJldHVybiB4UG9zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlZ21lbnQuZnJvbS54O1xuICAgIH1cbiAgICBcbiAgICB2YXIgZHggPSAoc2VnbWVudC50by54IC0gc2VnbWVudC5mcm9tLngpOyBcbiAgICB2YXIgeE9mZnNldDsgXG4gICAgaWYgKGR5MSA+PSBkeTIpIHtcbiAgICAgIHhPZmZzZXQgPSBkeTEgKiAoZHggLyBkeSk7IFxuICAgICAgcmV0dXJuIChzZWdtZW50LmZyb20ueCAtIHhPZmZzZXQpO1xuICAgIH0gXG4gICAgeE9mZnNldCA9IGR5MiAqIChkeCAvIGR5KTtcbiAgICByZXR1cm4gKHNlZ21lbnQudG8ueCArIHhPZmZzZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5nbGUoZHgsIGR5KSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY1NDIwNDIvZmFzdGVzdC13YXktdG8tc29ydC12ZWN0b3JzLWJ5LWFuZ2xlLXdpdGhvdXQtYWN0dWFsbHktY29tcHV0aW5nLXRoYXQtYW5nbGVcbiAgICB2YXIgcCA9IGR4LyhNYXRoLmFicyhkeCkgKyBNYXRoLmFicyhkeSkpOyAvLyAtMSAuLiAxIGluY3JlYXNpbmcgd2l0aCB4XG5cbiAgICBpZiAoZHkgPCAwKSB7IHJldHVybiBwIC0gMTsgfSAgLy8gLTIgLi4gMCBpbmNyZWFzaW5nIHdpdGggeFxuICAgIHJldHVybiAxIC0gcCAgICAgICAgICAgICAgIC8vICAwIC4uIDIgZGVjcmVhc2luZyB3aXRoIHhcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVyc2VjdFNlZ21lbnRzKGEsIGIpIHtcbiAgICAvLyAgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NjgzNDUvMTI1MzUxXG4gICAgdmFyIGFTdGFydCA9IGEuZnJvbSwgYlN0YXJ0ID0gYi5mcm9tO1xuICAgIHZhciBwMF94ID0gYVN0YXJ0LngsIHAwX3kgPSBhU3RhcnQueSxcbiAgICAgICAgcDJfeCA9IGJTdGFydC54LCBwMl95ID0gYlN0YXJ0Lnk7XG5cbiAgICB2YXIgczFfeCA9IGEuZHgsIHMxX3kgPSBhLmR5LCBzMl94ID0gYi5keCwgczJfeSA9IGIuZHk7XG4gICAgdmFyIGRpdiA9IHMxX3ggKiBzMl95IC0gczJfeCAqIHMxX3k7XG5cbiAgICB2YXIgcyA9IChzMV95ICogKHAwX3ggLSBwMl94KSAtIHMxX3ggKiAocDBfeSAtIHAyX3kpKSAvIGRpdjtcbiAgICBpZiAocyA8IDAgfHwgcyA+IDEpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdCA9IChzMl94ICogKHAyX3kgLSBwMF95KSArIHMyX3kgKiAocDBfeCAtIHAyX3gpKSAvIGRpdjtcblxuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwMF94IC0gKHQgKiBzMV94KSxcbiAgICAgICAgeTogcDBfeSAtICh0ICogczFfeSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzYW1lUG9pbnQoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhhLnggLSBiLngpIDwgRVBTICYmIE1hdGguYWJzKGEueSAtIGIueSkgPCBFUFM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzd2VlcCBzdGF0dXMgZGF0YSBzdHJ1Y3R1cmUuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVTd2VlcFN0YXR1cyhvbkVycm9yLCBFUFMkJDEpIHtcbiAgICB2YXIgbGFzdFBvaW50WSwgcHJldlk7XG4gICAgdmFyIGxhc3RQb2ludFgsIHByZXZYO1xuICAgIHZhciB1c2VCZWxvdyA9IGZhbHNlO1xuICAgIHZhciBzdGF0dXMgPSBuZXcgVHJlZShjb21wYXJlU2VnbWVudHMpO1xuXG4gICAgLy8gVG8gc2F2ZSBvbiBHQyB3ZSByZXR1cm4gbXV0YWJsZSBvYmplY3QuXG4gICAgdmFyIGN1cnJlbnRCb3VuZGFyeSA9IHtcbiAgICAgIGJlZm9yZUxlZnQ6IG51bGwsXG4gICAgICBsZWZ0OiBudWxsLFxuICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICBhZnRlclJpZ2h0OiBudWxsLFxuICAgIH07XG5cbiAgICB2YXIgY3VycmVudExlZnRSaWdodCA9IHtsZWZ0OiBudWxsLCByaWdodDogbnVsbH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgbmV3IHNlZ21lbnRzIGludG8gdGhlIHN0YXR1cyB0cmVlLlxuICAgICAgICovXG4gICAgICBpbnNlcnRTZWdtZW50czogaW5zZXJ0U2VnbWVudHMsXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHNlZ21lbnRzIGZyb20gdGhlIHN0YXR1cyB0cmVlLlxuICAgICAgICovXG4gICAgICBkZWxldGVTZWdtZW50czogZGVsZXRlU2VnbWVudHMsXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBzZWdtZW50cyB0aGF0IGFyZSB0byB0aGUgbGVmdCBhbmQgcmlnaHQgZnJvbSBhIGdpdmVuIHBvaW50LlxuICAgICAgICovXG4gICAgICBnZXRMZWZ0UmlnaHRQb2ludDogZ2V0TGVmdFJpZ2h0UG9pbnQsXG5cbiAgICAgIC8qKlxuICAgICAgICogRm9yIGEgZ2l2ZW4gY29sbGVjdGlvbnMgb2Ygc2VnbWVudHMgZmluZHMgdGhlIG1vc3QgbGVmdCBhbmQgdGhlIG1vc3QgcmlnaHRcbiAgICAgICAqIHNlZ21lbnRzLiBBbHNvIHJldHVybnMgc2VnbWVudHMgaW1tZWRpYXRlbHkgYmVmb3JlIGxlZnQsIGFuZCBhZnRlciByaWdodCBzZWdtZW50cy5cbiAgICAgICAqL1xuICAgICAgZ2V0Qm91bmRhcnlTZWdtZW50czogZ2V0Qm91bmRhcnlTZWdtZW50cyxcblxuICAgICAgZmluZFNlZ21lbnRzV2l0aFBvaW50OiBmaW5kU2VnbWVudHNXaXRoUG9pbnQsXG5cbiAgICAgIC8qKlxuICAgICAgICogQ3VycmVudCBiaW5hcnkgc2VhcmNoIHRyZWUgd2l0aCBzZWdtZW50c1xuICAgICAgICovXG4gICAgICBzdGF0dXM6IHN0YXR1cyxcblxuICAgICAgLyoqXG4gICAgICAgKiBJbnRyb3NwZWN0aW9uIG1ldGhvZCB0aGF0IHZlcmlmaWVzIGlmIHRoZXJlIGFyZSBkdXBsaWNhdGVzIGluIHRoZSBzZWdtZW50IHRyZWUuXG4gICAgICAgKiBJZiB0aGVyZSBhcmUgLSBgb25FcnJvcigpYCBpcyBjYWxsZWQuXG4gICAgICAgKi9cbiAgICAgIGNoZWNrRHVwbGljYXRlOiBjaGVja0R1cGxpY2F0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcmludHMgY3VycmVudCBzZWdtZW50cyBpbiBvcmRlciBvZiB0aGVpciBpbnRlcnNlY3Rpb24gd2l0aCBzd2VlcCBsaW5lLiBJbnRyb3NwZWN0aW9uIG1ldGhvZC5cbiAgICAgICAqL1xuICAgICAgcHJpbnRTdGF0dXM6IHByaW50U3RhdHVzLFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgc3dlZXAgbGluZS5cbiAgICAgICAqL1xuICAgICAgZ2V0TGFzdFBvaW50OiBmdW5jdGlvbiBnZXRMYXN0UG9pbnQoKSB7XG4gICAgICAgIHJldHVybiB7eDogbGFzdFBvaW50WCwgeTogbGFzdFBvaW50WX07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZVNlZ21lbnRzKGEsIGIpIHtcbiAgICAgIGlmIChhID09PSBiKSB7IHJldHVybiAwOyB9XG5cbiAgICAgIHZhciBhayA9IGdldEludGVyc2VjdGlvblhQb2ludChhLCBsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcbiAgICAgIHZhciBiayA9IGdldEludGVyc2VjdGlvblhQb2ludChiLCBsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcblxuICAgICAgdmFyIHJlcyA9IGFrIC0gYms7XG4gICAgICBpZiAoTWF0aC5hYnMocmVzKSA+PSBFUFMkJDEpIHtcbiAgICAgICAgLy8gV2UgYXJlIG9rYXkgZmluZS4gSW50ZXJzZWN0aW9uIGRpc3RhbmNlIGJldHdlZW4gdHdvIHNlZ21lbnRzXG4gICAgICAgIC8vIGlzIGdvb2QgdG8gZ2l2ZSBjb25jbHVzaXZlIGFuc3dlclxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgYUlzSG9yaXpvbnRhbCA9IE1hdGguYWJzKGEuZHkpIDwgRVBTJCQxO1xuICAgICAgdmFyIGJJc0hvcml6b250YWwgPSBNYXRoLmFicyhiLmR5KSA8IEVQUyQkMTtcbiAgICAgIGlmIChhSXNIb3Jpem9udGFsICYmIGJJc0hvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIGIudG8ueCAtIGEudG8ueDtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IFdoYXQgaWYgYm90aCBhIGFuZCBiIGlzIGhvcml6b250YWw/XG4gICAgICAvLyBtb3ZlIGhvcml6b250YWwgdG8gZW5kXG4gICAgICBpZiAoYUlzSG9yaXpvbnRhbCkgeyBcbiAgICAgICAgcmV0dXJuIHVzZUJlbG93ID8gLTEgOiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoYklzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAodXNlQmVsb3cpIHtcbiAgICAgICAgICByZXR1cm4gKGIuZnJvbS54ID49IGxhc3RQb2ludFgpID8gLTEgOiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAvLyByZXR1cm4gdXNlQmVsb3cgPyAxIDogLTE7XG4gICAgICB9XG4gICAgICB2YXIgcGEgPSBhLmFuZ2xlO1xuICAgICAgdmFyIHBiID0gYi5hbmdsZTtcbiAgICAgIGlmIChNYXRoLmFicyhwYSAtIHBiKSA+PSBFUFMkJDEpIHtcbiAgICAgICAgcmV0dXJuIHVzZUJlbG93ID8gcGEgLSBwYiA6IHBiIC0gcGE7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdEaXN0ID0gYS5mcm9tLnkgLSBiLmZyb20ueTtcbiAgICAgIGlmIChNYXRoLmFicyhzZWdEaXN0KSA+PSBFUFMkJDEpIHtcbiAgICAgICAgcmV0dXJuIC1zZWdEaXN0O1xuICAgICAgfVxuICAgICAgc2VnRGlzdCA9IGEudG8ueSAtIGIudG8ueTtcbiAgICAgIGlmIChNYXRoLmFicyhzZWdEaXN0KSA+PSBFUFMkJDEpIHtcbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY2N1cmF0ZT9cbiAgICAgICAgcmV0dXJuIC1zZWdEaXN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICAgIC8vIENvdWxkIGFsc28gdXNlOlxuICAgICAgLy8gdmFyIGFBbmdsZSA9IE1hdGguYXRhbjIoYS5mcm9tLnkgLSBhLnRvLnksIGEuZnJvbS54IC0gYS50by54KTtcbiAgICAgIC8vIHZhciBiQW5nbGUgPSBNYXRoLmF0YW4yKGIuZnJvbS55IC0gYi50by55LCBiLmZyb20ueCAtIGIudG8ueCk7XG4gICAgICAvLyByZXR1cm4gdXNlQmVsb3cgPyBiQW5nbGUgLSBhQW5nbGUgOiBhQW5nbGUgLSBiQW5nbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRhcnlTZWdtZW50cyh1cHBlciwgaW50ZXJpb3IpIHtcbiAgICAgIHZhciBsZWZ0TW9zdCwgcmlnaHRNb3N0LCBpO1xuICAgICAgdmFyIHVMZW5ndGggPSB1cHBlci5sZW5ndGg7XG5cbiAgICAgIGlmICh1TGVuZ3RoID4gMCkge1xuICAgICAgICBsZWZ0TW9zdCA9IHJpZ2h0TW9zdCA9IHVwcGVyWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdE1vc3QgPSByaWdodE1vc3QgPSBpbnRlcmlvclswXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMTsgaSA8IHVMZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IHVwcGVyW2ldO1xuICAgICAgICB2YXIgY21wID0gY29tcGFyZVNlZ21lbnRzKGxlZnRNb3N0LCBzKTtcbiAgICAgICAgaWYgKGNtcCA+IDApIHsgbGVmdE1vc3QgPSBzOyB9XG5cbiAgICAgICAgY21wID0gY29tcGFyZVNlZ21lbnRzKHJpZ2h0TW9zdCwgcyk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7IHJpZ2h0TW9zdCA9IHM7IH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0RnJvbSA9IHVMZW5ndGggPiAwID8gMCA6IDE7XG4gICAgICBmb3IgKGkgPSBzdGFydEZyb207IGkgPCBpbnRlcmlvci5sZW5ndGg7ICsraSkge1xuICAgICAgICBzID0gaW50ZXJpb3JbaV07XG4gICAgICAgIGNtcCA9IGNvbXBhcmVTZWdtZW50cyhsZWZ0TW9zdCwgcyk7XG4gICAgICAgIGlmIChjbXAgPiAwKSB7IGxlZnRNb3N0ID0gczsgfVxuXG4gICAgICAgIGNtcCA9IGNvbXBhcmVTZWdtZW50cyhyaWdodE1vc3QsIHMpO1xuICAgICAgICBpZiAoY21wIDwgMCkgeyByaWdodE1vc3QgPSBzOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBvdXIgbGVmdC9yaWdodCBzZWdtZW50cyBpbiB0aGUgc3RhdHVzLlxuICAgICAgLy8gTGV0J3MgZmluZCB0aGVpciBwcmV2L25leHQgZWxlbWVudHMgYW5kIHJlcG9ydCB0aGVtIGJhY2s6XG4gICAgICB2YXIgbGVmdCA9IHN0YXR1cy5maW5kKGxlZnRNb3N0KTtcbiAgICAgIGlmICghbGVmdCkge1xuICAgICAgICBvbkVycm9yKCdMZWZ0IGlzIG1pc3NpbmcuIFByZWNpc2lvbiBlcnJvcj8nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJpZ2h0ID0gc3RhdHVzLmZpbmQocmlnaHRNb3N0KTtcbiAgICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgb25FcnJvcignUmlnaHQgaXMgbWlzc2luZy4gUHJlY2lzaW9uIGVycm9yPycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmVmb3JlTGVmdCA9IGxlZnQgJiYgc3RhdHVzLnByZXYobGVmdCk7XG4gICAgICB2YXIgYWZ0ZXJSaWdodCA9IHJpZ2h0ICYmIHN0YXR1cy5uZXh0KHJpZ2h0KTtcblxuICAgICAgd2hpbGUgKGFmdGVyUmlnaHQgJiYgcmlnaHQua2V5LmR5ID09PSAwICYmIGFmdGVyUmlnaHQua2V5LmR5ID09PSAwKSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgc2VnbWVudHMgYXJlIHNwZWNpYWwgOihcbiAgICAgICAgYWZ0ZXJSaWdodCA9IHN0YXR1cy5uZXh0KGFmdGVyUmlnaHQpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50Qm91bmRhcnkuYmVmb3JlTGVmdCA9IGJlZm9yZUxlZnQgJiYgYmVmb3JlTGVmdC5rZXk7XG4gICAgICBjdXJyZW50Qm91bmRhcnkubGVmdCA9IGxlZnQgJiYgbGVmdC5rZXk7XG4gICAgICBjdXJyZW50Qm91bmRhcnkucmlnaHQgPSByaWdodCAmJiByaWdodC5rZXk7XG4gICAgICBjdXJyZW50Qm91bmRhcnkuYWZ0ZXJSaWdodCA9IGFmdGVyUmlnaHQgJiYgYWZ0ZXJSaWdodC5rZXk7XG5cbiAgICAgIHJldHVybiBjdXJyZW50Qm91bmRhcnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGVmdFJpZ2h0UG9pbnQocCkge1xuICAgICAgLy8gV2UgYXJlIHRyeWluZyB0byBmaW5kIGxlZnQgYW5kIHJpZ2h0IHNlZ21lbnRzIHRoYXQgYXJlIG5lYXJlc3QgdG8gdGhlXG4gICAgICAvLyBwb2ludCBwLiBGb3IgdGhpcyB3ZSB0cmF2ZXJzZSB0aGUgYmluYXJ5IHNlYXJjaCB0cmVlLCBhbmQgcmVtZW1iZXJcbiAgICAgIC8vIG5vZGUgd2l0aCB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgdG8gcC5cbiAgICAgIHZhciBsYXN0TGVmdDtcbiAgICAgIHZhciBjdXJyZW50ID0gc3RhdHVzLl9yb290O1xuICAgICAgdmFyIG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChjdXJyZW50LmtleSwgcC54LCBwLnkpO1xuICAgICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgICBpZiAoZHggPj0gMCkge1xuICAgICAgICAgIGlmIChkeCA8IG1pblgpIHtcbiAgICAgICAgICAgIG1pblggPSBkeDtcbiAgICAgICAgICAgIGxhc3RMZWZ0ID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoLWR4IDwgbWluWCkge1xuICAgICAgICAgICAgbWluWCA9IC1keDtcbiAgICAgICAgICAgIGxhc3RMZWZ0ID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudExlZnRSaWdodC5sZWZ0ID0gbGFzdExlZnQgJiYgbGFzdExlZnQua2V5O1xuICAgICAgdmFyIG5leHQgPSBsYXN0TGVmdCAmJiBzdGF0dXMubmV4dChsYXN0TGVmdCk7XG4gICAgICBjdXJyZW50TGVmdFJpZ2h0LnJpZ2h0ID0gbmV4dCAmJiBuZXh0LmtleTtcbiAgICAgIHJldHVybiBjdXJyZW50TGVmdFJpZ2h0O1xuXG4gICAgICAvLyBDb25jZXB0dWFsbHksIHRoZSBjb2RlIGFib3ZlIHNob3VsZCBiZSBlcXVpdmFsZW50IHRvIHRoZSBjb2RlIGJlbG93O1xuICAgICAgLy8gVGhlIGNvZGUgYmVsb3cgaXMgZWFzaWVyIHRvIHVuZGVyc3RhbmQsIGJ1dCBpbnR1aXRpdmVseSwgdGhlIGNvZGUgYWJvdmVcbiAgICAgIC8vIHNob3VsZCBoYXZlIGJldHRlciBwZXJmb3JtYW5jZSAoYXMgd2UgZG8gbm90IHRyYXZlcnNlIHRoZSBlbnRpcmUgc3RhdHVzXG4gICAgICAvLyB0cmVlKVxuXG4gICAgICAvLyB2YXIgcmlnaHQsIGxlZnQsICB4O1xuICAgICAgLy8gdmFyIGFsbCA9IHN0YXR1cy5rZXlzKClcbiAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyAgIHZhciBzZWdtZW50ID0gYWxsW2ldO1xuICAgICAgLy8gICB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KHNlZ21lbnQsIHAueCwgcC55KTtcbiAgICAgIC8vICAgaWYgKHggPiBwLnggJiYgIXJpZ2h0KSB7XG4gICAgICAvLyAgICAgcmlnaHQgPSBzZWdtZW50O1xuICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgLy8gICB9IGVsc2UgaWYgKHggPCBwLngpIHtcbiAgICAgIC8vICAgICBsZWZ0ID0gc2VnbWVudDtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuXG4gICAgICAvLyBjdXJyZW50TGVmdFJpZ2h0LmxlZnQgPSBsZWZ0O1xuICAgICAgLy8gY3VycmVudExlZnRSaWdodC5yaWdodCA9IHJpZ2h0O1xuXG4gICAgICAvLyByZXR1cm4gY3VycmVudExlZnRSaWdodDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kU2VnbWVudHNXaXRoUG9pbnQocCwgb25Gb3VuZCkge1xuICAgICAgLy8gT3B0aW9uIDEuXG4gICAgICAvLyB2YXIgYXJyUmVzdWx0cyA9IFtdO1xuICAgICAgLy8gc3RhdHVzLmZvckVhY2goY3VycmVudCA9PiB7XG4gICAgICAvLyAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGN1cnJlbnQua2V5LCBwLngsIHAueSk7XG4gICAgICAvLyAgIHZhciBkeCA9IHAueCAtIHg7XG4gICAgICAvLyAgIGlmIChNYXRoLmFicyhkeCkgPCBFUFMpIHtcbiAgICAgIC8vICAgICBvbkZvdW5kKGN1cnJlbnQua2V5KTtcbiAgICAgIC8vICAgIC8vIGFyclJlc3VsdHMucHVzaChjdXJyZW50LmtleSlcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSk7XG4gICAgICAvLyByZXR1cm4gYXJyUmVzdWx0cztcblxuICAgICAgLy8gT3B0aW9uIDIuXG5cbiAgICAgIC8vIGxldCBjdXJyZW50ID0gc3RhdHVzLl9yb290O1xuICAgICAgLy8gY29uc3QgUSA9IFtdOyAgLyogSW5pdGlhbGl6ZSBzdGFjayBzICovXG4gICAgICAvLyBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgLy8gdmFyIHJlcyA9IFtdO1xuICAgICAgLy8gdmFyIGJyZWFrRWFybHkgPSBmYWxzZTtcblxuICAgICAgLy8gd2hpbGUgKCFkb25lKSB7XG4gICAgICAvLyAgIGlmIChjdXJyZW50ICE9PSAgbnVsbCkge1xuICAgICAgLy8gICAgIFEucHVzaChjdXJyZW50KTtcbiAgICAgIC8vICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgLy8gICAgIGlmIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgLy8gICAgICAgY3VycmVudCA9IFEucG9wKCk7XG5cbiAgICAgIC8vICAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGN1cnJlbnQua2V5LCBwLngsIHAueSk7XG4gICAgICAvLyAgICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgLy8gICAgICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQUykge1xuICAgICAgLy8gICAgICAgICByZXMucHVzaChjdXJyZW50LmtleSlcbiAgICAgIC8vICAgICAgICAgYnJlYWtFYXJseSA9IHRydWU7XG4gICAgICAvLyAgICAgICB9IGVsc2UgaWYgKGJyZWFrRWFybHkpIHtcbiAgICAgIC8vICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAvLyAgICAgICB9XG5cbiAgICAgIC8vICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgLy8gICAgIH0gZWxzZSBkb25lID0gdHJ1ZTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuXG4gICAgICAvLyByZXR1cm4gcmVzO1xuXG4gICAgICAvLyBvcHRpb24gMy5cbiAgICAgIHZhciBjdXJyZW50ID0gc3RhdHVzLl9yb290O1xuXG4gICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChjdXJyZW50LmtleSwgcC54LCBwLnkpO1xuICAgICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoZHgpIDwgRVBTJCQxKSB7XG4gICAgICAgICAgY29sbGVjdEFkamFjZW50Tm9kZXMoY3VycmVudCwgcCwgb25Gb3VuZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoZHggPCAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RBZGphY2VudE5vZGVzKHJvb3QsIHAsIG9uRm91bmQpIHtcbiAgICAgIG9uRm91bmQocm9vdC5rZXkpO1xuICAgICAgZ29PdmVyUHJlZGVjZXNzb3JzKHJvb3QubGVmdCwgcCwgb25Gb3VuZCk7XG4gICAgICBnb092ZXJTdWNjZXNzb3JzKHJvb3QucmlnaHQsIHAsIG9uRm91bmQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvT3ZlclByZWRlY2Vzc29ycyhyb290LCBwLCByZXMpIHtcbiAgICAgIGlmICghcm9vdCkgeyByZXR1cm47IH1cbiAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KHJvb3Qua2V5LCBwLngsIHAueSk7XG4gICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQUyQkMSkge1xuICAgICAgICBjb2xsZWN0QWRqYWNlbnROb2Rlcyhyb290LCBwLCByZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ29PdmVyUHJlZGVjZXNzb3JzKHJvb3QucmlnaHQsIHAsIHJlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ29PdmVyU3VjY2Vzc29ycyhyb290LCBwLCByZXMpIHtcbiAgICAgIGlmICghcm9vdCkgeyByZXR1cm47IH1cbiAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KHJvb3Qua2V5LCBwLngsIHAueSk7XG4gICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQUyQkMSkge1xuICAgICAgICBjb2xsZWN0QWRqYWNlbnROb2Rlcyhyb290LCBwLCByZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ29PdmVyU3VjY2Vzc29ycyhyb290LmxlZnQsIHAsIHJlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGUoKSB7XG4gICAgICB2YXIgcHJldjtcbiAgICAgIHN0YXR1cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbm9kZS5rZXk7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBpZiAoc2FtZVBvaW50KHByZXYuZnJvbSwgY3VycmVudC5mcm9tKSAmJiBzYW1lUG9pbnQocHJldi50bywgY3VycmVudC50bykpIHtcbiAgICAgICAgICAgIC8vIExpa2VseSB5b3UgaGF2ZSByZWNlaXZlZCBlcnJvciBiZWZvcmUgZHVyaW5nIHNlZ21lbnQgcmVtb3ZhbC5cbiAgICAgICAgICAgIG9uRXJyb3IoJ0R1cGxpY2F0ZSBrZXkgaW4gdGhlIHN0YXR1cyEgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IEZsb2F0aW5nIFBvaW50IHJvdW5kaW5nIGVycm9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBjdXJyZW50O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRTdGF0dXMocHJlZml4KSB7XG4gICAgICBpZiAoIHByZWZpeCA9PT0gdm9pZCAwICkgcHJlZml4ID0gJyc7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgY29uc29sZS5sb2cocHJlZml4LCAnc3RhdHVzIGxpbmU6ICcsIGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgICAgc3RhdHVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQobm9kZS5rZXksIGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY29uc29sZS5sb2coeCArICcgJyArIG5vZGUua2V5Lm5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0U2VnbWVudHMoaW50ZXJpb3IsIHVwcGVyLCBzd2VlcExpbmVQb3MpIHtcbiAgICAgIGxhc3RQb2ludFkgPSBzd2VlcExpbmVQb3MueTtcbiAgICAgIGxhc3RQb2ludFggPSBzd2VlcExpbmVQb3MueDtcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJpb3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAga2V5ID0gaW50ZXJpb3JbaV07XG4gICAgICAgIHN0YXR1cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB1cHBlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBrZXkgPSB1cHBlcltpXTtcbiAgICAgICAgc3RhdHVzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGV0ZVNlZ21lbnRzKGxvd2VyLCBpbnRlcmlvciwgc3dlZXBMaW5lUG9zKSB7XG4gICAgICAvLyBJIHNwZW50IG1vc3Qgb2YgdGhlIHRpbWUgZGVidWdnaW5nIHRoaXMgbWV0aG9kLiBEZXBlbmRpbmcgb24gdGhlXG4gICAgICAvLyBhbGdvcml0aG0gc3RhdGUgd2UgY2FuIHJ1biBpbnRvIHNpdHVhdGlvbiB3aGVuIGR5bmFtaWMga2V5cyBvZiB0aGVcbiAgICAgIC8vIGBzdGF0dXNgIHRyZWUgcHJlZGljdCB3cm9uZyBicmFuY2gsIGFuZCB0aHVzIHdlIGFyZSBub3QgYWJsZSB0byBmaW5kXG4gICAgICAvLyB0aGUgc2VnbWVudCB0aGF0IG5lZWRzIHRvIGJlIGRlbGV0ZWQuIElmIHRoYXQgaGFwcGVucyBJJ20gdHJ5aW5nIHRvXG4gICAgICAvLyB1c2UgcHJldmlvdXMgcG9pbnQgYW5kIHJlcGVhdCB0aGUgcHJvY2Vzcy4gVGhpcyBtYXkgcmVzdWx0IGluIFxuICAgICAgLy8gaW5jb3JyZWN0IHN0YXRlLiBJbiB0aGF0IGNhc2UgSSByZXBvcnQgYW4gZXJyb3IuIFxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgcHJldkNvdW50ID0gc3RhdHVzLl9zaXplO1xuICAgICAgcHJldlggPSBsYXN0UG9pbnRYO1xuICAgICAgcHJldlkgPSBsYXN0UG9pbnRZO1xuICAgICAgbGFzdFBvaW50WSA9IHN3ZWVwTGluZVBvcy55O1xuICAgICAgbGFzdFBvaW50WCA9IHN3ZWVwTGluZVBvcy54O1xuXG4gICAgICB1c2VCZWxvdyA9IHRydWU7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBsb3dlci5sZW5ndGg7ICsraSkge1xuICAgICAgICByZW1vdmVTZWdtZW50KGxvd2VyW2ldLCBzd2VlcExpbmVQb3MpO1xuICAgICAgfVxuICAgICAgZm9yKGkgPSAwOyBpIDwgaW50ZXJpb3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVtb3ZlU2VnbWVudChpbnRlcmlvcltpXSwgc3dlZXBMaW5lUG9zKTtcbiAgICAgIH1cbiAgICAgIHVzZUJlbG93ID0gZmFsc2U7XG5cbiAgICAgIGlmIChzdGF0dXMuX3NpemUgIT09IHByZXZDb3VudCAtIGludGVyaW9yLmxlbmd0aCAtIGxvd2VyLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiByb3VuZGluZyBlcnJvciBvY2N1cnMuIFlvdSBjYW4gdHJ5IHNjYWxpbmcgeW91ciBpbnB1dFxuICAgICAgICBvbkVycm9yKCdTZWdtZW50cyB3ZXJlIG5vdCByZW1vdmVkIGZyb20gYSB0cmVlIHByb3Blcmx5LiBQcmVjaXNpb24gZXJyb3I/Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU2VnbWVudChrZXksIHN3ZWVwTGluZVBvcykge1xuICAgICAgaWYgKHN0YXR1cy5maW5kKGtleSkpIHtcbiAgICAgICAgc3RhdHVzLnJlbW92ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFBvaW50WCA9IHByZXZYO1xuICAgICAgICBsYXN0UG9pbnRZID0gcHJldlk7XG4gICAgICAgIGlmIChzdGF0dXMuZmluZChrZXkpKSB7XG4gICAgICAgICAgc3RhdHVzLnJlbW92ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQb2ludFkgPSBzd2VlcExpbmVQb3MueTtcbiAgICAgICAgbGFzdFBvaW50WCA9IHN3ZWVwTGluZVBvcy54O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2luZ2xlIGV2ZW50IGluIHRoZSBzd2VlcC1saW5lIGFsZ29yaXRobVxuICAgKi9cbiAgdmFyIFN3ZWVwRXZlbnQgPSBmdW5jdGlvbiBTd2VlcEV2ZW50KHBvaW50LCBzZWdtZW50KSB7XG4gICAgdGhpcy5wb2ludCA9IHBvaW50O1xuICAgIGlmIChzZWdtZW50KSB7IHRoaXMuZnJvbSA9IFtzZWdtZW50XTsgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHBvaW50IG9uIGEgbGluZVxuICAgKiBcbiAgICogQHR5cGVkZWYge09iamVjdH0gUG9pbnRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggY29vcmRpbmF0ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0geSBjb29yZGluYXRlXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnQgXG4gICAqIEBwcm9wZXJ0eSB7UG9pbnR9IGZyb20gc3RhcnQgb2YgdGhlIHNlZ21lbnRcbiAgICogQHByb3BlcnR5IHtQb2ludH0gdG8gZW5kIG9mIHRoZSBzZWdtZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7ZnVuY3Rpb24ocG9pbnQgOiBQb2ludCwgaW50ZXJpb3IgOiBTZWdtZW50W10sIGxvd2VyIDogU2VnbWVudFtdLCB1cHBlciA6IFNlZ21lbnRbXSl9IFJlcG9ydEludGVyc2VjdGlvbkNhbGxiYWNrXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJU2VjdE9wdGlvbnMgXG4gICAqIEBwcm9wZXJ0eSB7UmVwb3J0SW50ZXJzZWN0aW9uQ2FsbGJhY2t9IG9uRm91bmQgXG4gICAqL1xuXG4gICAvKipcbiAgICAqIEB0eXBlZGVmIHtPYmplY3R9IElTZWN0UmVzdWx0XG4gICAgKi9cblxuICAvLyBXZSB1c2UgRU1QVFkgYXJyYXkgdG8gYXZvaWQgcHJlc3N1cmUgb24gZ2FyYmFnZSBjb2xsZWN0b3IuIE5lZWQgdG8gYmVcbiAgLy8gdmVyeSBjYXV0aW91cyB0byBub3QgbXV0YXRlIHRoaXMgYXJyYXkuXG4gIHZhciBFTVBUWSA9IFtdO1xuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgaW50ZXJzZWN0aW9ucyBhbW9uZyBnaXZlbiBzZWdtZW50cy5cbiAgICogXG4gICAqIFRoZSBhbGdvcml0aG0gZm9sbG93cyBcIkNvbXB1dGF0aW9uIEdlb21ldHJ5LCBBbGdvcml0aG1zIGFuZCBBcHBsaWNhdGlvbnNcIiBib29rXG4gICAqIGJ5IE1hcmsgZGUgQmVyZywgT3RmcmllZCBDaGVvbmcsIE1hcmMgdmFuIEtyZXZlbGQsIGFuZCBNYXJrIE92ZXJtYXJzLlxuICAgKiBcbiAgICogTGluZSBpcyBzd2VwdCB0b3AtZG93blxuICAgKiBcbiAgICogQHBhcmFtIHtTZWdtZW50W119IHNlZ21lbnRzXG4gICAqIEBwYXJhbSB7SVNlY3RPcHRpb25zPX0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7SVNlY3RSZXN1bHR9XG4gICAqL1xuICBmdW5jdGlvbiBpc2VjdChzZWdtZW50cywgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHJlcG9ydEludGVyc2VjdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMub25Gb3VuZCkgfHwgZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyO1xuXG4gICAgdmFyIG9uRXJyb3IgPSAob3B0aW9ucyAmJiBvcHRpb25zLm9uRXJyb3IpIHx8IGRlZmF1bHRFcnJvclJlcG9ydGVyO1xuXG4gICAgdmFyIGV2ZW50UXVldWUgPSBjcmVhdGVFdmVudFF1ZXVlKGJ5WSk7XG4gICAgdmFyIHN3ZWVwU3RhdHVzID0gY3JlYXRlU3dlZXBTdGF0dXMob25FcnJvciwgRVBTKTtcbiAgICB2YXIgbG93ZXIsIGludGVyaW9yLCBsYXN0UG9pbnQ7XG5cbiAgICBzZWdtZW50cy5mb3JFYWNoKGFkZFNlZ21lbnQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhbGwgaW50ZXJzZWN0aW9ucyBzeW5jaHJvbm91c2x5LlxuICAgICAgICogXG4gICAgICAgKiBAcmV0dXJucyBhcnJheSBvZiBmb3VuZCBpbnRlcnNlY3Rpb25zLlxuICAgICAgICovXG4gICAgICBydW46IHJ1bixcblxuICAgICAgLyoqXG4gICAgICAgKiBQZXJmb3JtcyBhIHNpbmdsZSBzdGVwIGluIHRoZSBzd2VlcCBsaW5lIGFsZ29yaXRobVxuICAgICAgICogXG4gICAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgdG8gcHJvY2VzczsgRmFsc2UgaWYgbm8gbW9yZSB3b3JrIHRvIGRvXG4gICAgICAgKi9cbiAgICAgIHN0ZXA6IHN0ZXAsXG5cbiAgICAgIC8vIE1ldGhvZHMgYmVsb3cgYXJlIGxvdyBsZXZlbCBBUEkgZm9yIGZpbmUtZ3JhaW5lZCBjb250cm9sLlxuICAgICAgLy8gRG9uJ3QgdXNlIGl0IHVubGVzcyB5b3UgdW5kZXJzdGFuZCB0aGlzIGNvZGUgdGhvcm91Z2hseVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBzZWdtZW50IGludG8gdGhlIFxuICAgICAgICovXG4gICAgICBhZGRTZWdtZW50OiBhZGRTZWdtZW50LFxuXG4gICAgICAvKipcbiAgICAgICAqIERpcmVjdCBhY2Nlc3MgdG8gZXZlbnQgcXVldWUuIFF1ZXVlIGNvbnRhaW5zIHNlZ21lbnQgZW5kcG9pbnRzIGFuZFxuICAgICAgICogcGVuZGluZyBkZXRlY3RlZCBpbnRlcnNlY3Rpb25zLlxuICAgICAgICovXG4gICAgICBldmVudFF1ZXVlOiBldmVudFF1ZXVlLCBcblxuICAgICAgLyoqXG4gICAgICAgKiBEaXJlY3QgYWNjZXNzIHRvIHN3ZWVwIGxpbmUgc3RhdHVzLiBcIlN0YXR1c1wiIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG4gICAgICAgKiBhbGwgaW50ZXJzZWN0ZWQgc2VnbWVudHMuXG4gICAgICAgKi9cbiAgICAgIHN3ZWVwU3RhdHVzOiBzd2VlcFN0YXR1cyxcblxuICAgICAgLyoqXG4gICAgICAgKiBBY2Nlc3MgdG8gcmVzdWx0cyBhcnJheS4gV29ya3Mgb25seSB3aGVuIHlvdSB1c2UgZGVmYXVsdCBvbkZvdW5kKCkgaGFuZGxlclxuICAgICAgICovXG4gICAgICByZXN1bHRzOiByZXN1bHRzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgd2hpbGUgKCFldmVudFF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICB2YXIgZXZlbnRQb2ludCA9IGV2ZW50UXVldWUucG9wKCk7XG4gICAgICAgIGlmIChoYW5kbGVFdmVudFBvaW50KGV2ZW50UG9pbnQpKSB7XG4gICAgICAgICAgLy8gdGhleSBkZWNpZGVkIHRvIHN0b3AuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9ICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmICghZXZlbnRRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgdmFyIGV2ZW50UG9pbnQgPSBldmVudFF1ZXVlLnBvcCgpO1xuICAgICAgICBoYW5kbGVFdmVudFBvaW50KGV2ZW50UG9pbnQpO1xuICAgICAgICAvLyBOb3RlOiB3ZSBkb24ndCBjaGVjayByZXN1bHRzIG9mIGBoYW5kbGVFdmVudFBvaW50KClgXG4gICAgICAgIC8vIGFzc3VtcHRpb24gaXMgdGhhdCBjbGllbnQgY29udHJvbHMgYHN0ZXAoKWAgYW5kIHRodXMgdGhleSBcbiAgICAgICAgLy8ga25vdyBiZXR0ZXIgaWYgdGhleSB3YW50IHRvIHN0b3AuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50UG9pbnQocCkge1xuICAgICAgbGFzdFBvaW50ID0gcC5wb2ludDtcbiAgICAgIHZhciB1cHBlciA9IHAuZnJvbSB8fCBFTVBUWTtcblxuICAgICAgbG93ZXIgPSBpbnRlcmlvciA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIFRPRE86IG1vdmUgbG93ZXIvaW50ZXJpb3IgaW50byBzd2VlcCBzdGF0dXMgbWV0aG9kP1xuXG4gICAgICBzd2VlcFN0YXR1cy5maW5kU2VnbWVudHNXaXRoUG9pbnQobGFzdFBvaW50LCBhZGRMb3dlck9ySW50ZXJpb3IpO1xuICAgICAgLy8gaWYgKHNlZ21lbnRzV2l0aFBvaW50KSB7XG4gICAgICAvLyAgIHNlZ21lbnRzV2l0aFBvaW50LmZvckVhY2goKVxuICAgICAgLy8gfSBcblxuICAgICAgaWYgKCFsb3dlcikgeyBsb3dlciA9IEVNUFRZOyB9XG4gICAgICBpZiAoIWludGVyaW9yKSB7IGludGVyaW9yID0gRU1QVFk7IH1cblxuICAgICAgdmFyIHVMZW5ndGggPSB1cHBlci5sZW5ndGg7XG4gICAgICB2YXIgaUxlbmd0aCA9IGludGVyaW9yLmxlbmd0aDtcbiAgICAgIHZhciBsTGVuZ3RoID0gbG93ZXIubGVuZ3RoO1xuICAgICAgdmFyIGhhc0ludGVyc2VjdGlvbiA9IHVMZW5ndGggKyBpTGVuZ3RoICsgbExlbmd0aCA+IDE7XG4gICAgICB2YXIgaGFzUG9pbnRJbnRlcnNlY3Rpb24gPSAhaGFzSW50ZXJzZWN0aW9uICYmICh1TGVuZ3RoID09PSAwICYmIGxMZW5ndGggPT09IDAgJiYgaUxlbmd0aCA+IDApO1xuXG4gICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uIHx8IGhhc1BvaW50SW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHAuaXNSZXBvcnRlZCA9IHRydWU7XG4gICAgICAgIGlmIChyZXBvcnRJbnRlcnNlY3Rpb24obGFzdFBvaW50LCB1bmlvbihpbnRlcmlvciwgdW5pb24obG93ZXIsIHVwcGVyKSkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dlZXBTdGF0dXMuZGVsZXRlU2VnbWVudHMobG93ZXIsIGludGVyaW9yLCBsYXN0UG9pbnQpO1xuICAgICAgc3dlZXBTdGF0dXMuaW5zZXJ0U2VnbWVudHMoaW50ZXJpb3IsIHVwcGVyLCBsYXN0UG9pbnQpO1xuXG4gICAgICB2YXIgc0xlZnQsIHNSaWdodDtcblxuICAgICAgdmFyIGhhc05vQ3Jvc3NpbmcgPSAodUxlbmd0aCArIGlMZW5ndGggPT09IDApO1xuXG4gICAgICBpZiAoaGFzTm9Dcm9zc2luZykge1xuICAgICAgICB2YXIgbGVmdFJpZ2h0ID0gc3dlZXBTdGF0dXMuZ2V0TGVmdFJpZ2h0UG9pbnQobGFzdFBvaW50KTtcbiAgICAgICAgc0xlZnQgPSBsZWZ0UmlnaHQubGVmdDtcbiAgICAgICAgaWYgKCFzTGVmdCkgeyByZXR1cm47IH1cblxuICAgICAgICBzUmlnaHQgPSBsZWZ0UmlnaHQucmlnaHQ7XG4gICAgICAgIGlmICghc1JpZ2h0KSB7IHJldHVybjsgfVxuXG4gICAgICAgIGZpbmROZXdFdmVudChzTGVmdCwgc1JpZ2h0LCBwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBib3VuZGFyeVNlZ21lbnRzID0gc3dlZXBTdGF0dXMuZ2V0Qm91bmRhcnlTZWdtZW50cyh1cHBlciwgaW50ZXJpb3IpO1xuXG4gICAgICAgIGZpbmROZXdFdmVudChib3VuZGFyeVNlZ21lbnRzLmJlZm9yZUxlZnQsIGJvdW5kYXJ5U2VnbWVudHMubGVmdCwgcCk7XG4gICAgICAgIGZpbmROZXdFdmVudChib3VuZGFyeVNlZ21lbnRzLnJpZ2h0LCBib3VuZGFyeVNlZ21lbnRzLmFmdGVyUmlnaHQsIHApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTG93ZXJPckludGVyaW9yKHMpIHtcbiAgICAgIGlmIChzYW1lUG9pbnQocy50bywgbGFzdFBvaW50KSkge1xuICAgICAgICBpZiAoIWxvd2VyKSB7IGxvd2VyID0gW3NdOyB9XG4gICAgICAgIGVsc2UgeyBsb3dlci5wdXNoKHMpOyB9XG4gICAgICB9IGVsc2UgaWYgKCFzYW1lUG9pbnQocy5mcm9tLCBsYXN0UG9pbnQpKSB7XG4gICAgICAgIGlmICghaW50ZXJpb3IpIHsgaW50ZXJpb3IgPSBbc107IH1cbiAgICAgICAgZWxzZSB7IGludGVyaW9yLnB1c2gocyk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kTmV3RXZlbnQobGVmdCwgcmlnaHQsIHApIHtcbiAgICAgIGlmICghbGVmdCB8fCAhcmlnaHQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RTZWdtZW50cyhsZWZ0LCByaWdodCk7XG4gICAgICBpZiAoIWludGVyc2VjdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGR5ID0gcC5wb2ludC55IC0gaW50ZXJzZWN0aW9uLnk7XG4gICAgICAvLyBUT0RPOiBzaG91bGQgSSBhZGQgZHkgdG8gaW50ZXJzZWN0aW9uLnk/XG4gICAgICBpZiAoZHkgPCAtRVBTKSB7XG4gICAgICAgIC8vIHRoaXMgbWVhbnMgaW50ZXJzZWN0aW9uIGhhcHBlbmVkIGFmdGVyIHRoZSBzd2VlcCBsaW5lLiBcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBwcm9jZXNzZWQgaXQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhkeSkgPCBFUFMgJiYgaW50ZXJzZWN0aW9uLnggPD0gcC5wb2ludC54KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTmVlZCB0byBhZGp1c3QgZmxvYXRpbmcgcG9pbnQgZm9yIHRoaXMgc3BlY2lhbCBjYXNlLFxuICAgICAgLy8gc2luY2Ugb3RoZXJ3aXNlIGl0IGdpdmVzIHJvdW5kaW5nIGVycm9yczpcbiAgICAgIHJvdW5kTmVhclplcm8oaW50ZXJzZWN0aW9uKTtcblxuICAgICAgdmFyIGN1cnJlbnQgPSBldmVudFF1ZXVlLmZpbmQoaW50ZXJzZWN0aW9uKTtcblxuICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5pc1JlcG9ydGVkKSB7XG4gICAgICAgIC8vIFdlIGFscmVhZHkgcmVwb3J0ZWQgdGhpcyBldmVudC4gTm8gbmVlZCB0byBhZGQgaXQgb25lIG1vcmUgdGltZVxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGNhc2UgZXZlbiBwb3NzaWJsZT9cbiAgICAgICAgb25FcnJvcignV2UgYWxyZWFkeSByZXBvcnRlZCB0aGlzIGV2ZW50LicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgU3dlZXBFdmVudChpbnRlcnNlY3Rpb24pO1xuICAgICAgICBldmVudFF1ZXVlLmluc2VydChldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyKHAsIHNlZ21lbnRzKSB7XG4gICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICBwb2ludDogcCwgXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50KSB7XG4gICAgICB2YXIgZnJvbSA9IHNlZ21lbnQuZnJvbTtcbiAgICAgIHZhciB0byA9IHNlZ21lbnQudG87XG5cbiAgICAgIC8vIFNtYWxsIG51bWJlcnMgZ2l2ZSBtb3JlIHByZWNpc2lvbiBlcnJvcnMuIFJvdW5kaW5nIHRoZW0gdG8gMC5cbiAgICAgIHJvdW5kTmVhclplcm8oZnJvbSk7XG4gICAgICByb3VuZE5lYXJaZXJvKHRvKTtcblxuICAgICAgdmFyIGR5ID0gZnJvbS55IC0gdG8ueTtcblxuICAgICAgLy8gTm90ZTogZHkgaXMgbXVjaCBzbWFsbGVyIHRoZW4gRVBTIG9uIHB1cnBvc2UuIEkgZm91bmQgdGhhdCBoaWdoZXJcbiAgICAgIC8vIHByZWNpc2lvbiBoZXJlIGRvZXMgbGVzcyBnb29kIC0gZ2V0dGluZyB3YXkgbW9yZSByb3VuZGluZyBlcnJvcnMuXG4gICAgICBpZiAoTWF0aC5hYnMoZHkpIDwgMWUtNSkge1xuICAgICAgICBmcm9tLnkgPSB0by55O1xuICAgICAgICBzZWdtZW50LmR5ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICgoZnJvbS55IDwgdG8ueSkgfHwgKFxuICAgICAgICAgIChmcm9tLnkgPT09IHRvLnkpICYmIChmcm9tLnggPiB0by54KSlcbiAgICAgICAgKSB7XG4gICAgICAgIHZhciB0ZW1wID0gZnJvbTtcbiAgICAgICAgZnJvbSA9IHNlZ21lbnQuZnJvbSA9IHRvOyBcbiAgICAgICAgdG8gPSBzZWdtZW50LnRvID0gdGVtcDtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgcHJlLWNvbXB1dGUgc29tZSBpbW11dGFibGUgcHJvcGVydGllcyBvZiB0aGUgc2VnbWVudFxuICAgICAgLy8gVGhleSBhcmUgdXNlZCBxdWl0ZSBvZnRlbiBpbiB0aGUgdHJlZSB0cmF2ZXJzYWwsIGFuZCBwcmUtY29tcHV0YXRpb25cbiAgICAgIC8vIGdpdmVzIHNpZ25pZmljYW50IGJvb3N0OlxuICAgICAgc2VnbWVudC5keSA9IGZyb20ueSAtIHRvLnk7XG4gICAgICBzZWdtZW50LmR4ID0gZnJvbS54IC0gdG8ueDtcbiAgICAgIHNlZ21lbnQuYW5nbGUgPSBhbmdsZShzZWdtZW50LmR5LCBzZWdtZW50LmR4KTtcblxuICAgICAgdmFyIGlzUG9pbnQgPSBzZWdtZW50LmR5ID09PSBzZWdtZW50LmR4ICYmIHNlZ21lbnQuZHkgPT09IDA7XG4gICAgICB2YXIgcHJldiA9IGV2ZW50UXVldWUuZmluZChmcm9tKTtcbiAgICAgIGlmIChwcmV2ICYmICFpc1BvaW50KSB7XG4gICAgICAgIC8vIHRoaXMgZGV0ZWN0cyBpZGVudGljYWwgc2VnbWVudHMgZWFybHkuIFdpdGhvdXQgdGhpcyBjaGVja1xuICAgICAgICAvLyB0aGUgYWxnb3JpdGhtIHdvdWxkIGJyZWFrIHNpbmNlIHN3ZWVwIGxpbmUgaGFzIG5vIG1lYW5zIHRvXG4gICAgICAgIC8vIGRldGVjdCBpZGVudGljYWwgc2VnbWVudHMuXG4gICAgICAgIHZhciBwcmV2RnJvbSA9IHByZXYuZGF0YS5mcm9tO1xuICAgICAgICBpZiAocHJldkZyb20pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZGcm9tLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHByZXZGcm9tW2ldO1xuICAgICAgICAgICAgaWYgKHNhbWVQb2ludChzLnRvLCB0bykpIHtcbiAgICAgICAgICAgICAgcmVwb3J0SW50ZXJzZWN0aW9uKHMuZnJvbSwgW3MuZnJvbSwgcy50b10pO1xuICAgICAgICAgICAgICByZXBvcnRJbnRlcnNlY3Rpb24ocy50bywgW3MuZnJvbSwgcy50b10pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNQb2ludCkge1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIGlmIChwcmV2LmRhdGEuZnJvbSkgeyBwcmV2LmRhdGEuZnJvbS5wdXNoKHNlZ21lbnQpOyB9XG4gICAgICAgICAgZWxzZSB7IHByZXYuZGF0YS5mcm9tID0gW3NlZ21lbnRdOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGUgPSBuZXcgU3dlZXBFdmVudChmcm9tLCBzZWdtZW50KTtcbiAgICAgICAgICBldmVudFF1ZXVlLmluc2VydChlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgU3dlZXBFdmVudCh0byk7XG4gICAgICAgIGV2ZW50UXVldWUuaW5zZXJ0KGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBTd2VlcEV2ZW50KHRvKTtcbiAgICAgICAgZXZlbnRRdWV1ZS5pbnNlcnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0gXG4gIH1cblxuICBmdW5jdGlvbiByb3VuZE5lYXJaZXJvKHBvaW50KSB7XG4gICAgaWYgKE1hdGguYWJzKHBvaW50LngpIDwgRVBTKSB7IHBvaW50LnggPSAwOyB9XG4gICAgaWYgKE1hdGguYWJzKHBvaW50LnkpIDwgRVBTKSB7IHBvaW50LnkgPSAwOyB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0RXJyb3JSZXBvcnRlcihlcnJvck1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuaW9uKGEsIGIpIHtcbiAgICBpZiAoIWEpIHsgcmV0dXJuIGI7IH1cbiAgICBpZiAoIWIpIHsgcmV0dXJuIGE7IH1cblxuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ5WShhLCBiKSB7XG4gICAgLy8gZGVjcmVhc2luZyBZIFxuICAgIHZhciByZXMgPSBiLnkgLSBhLnk7XG4gICAgLy8gVE9ETzogVGhpcyBtaWdodCBtZXNzIHVwIHRoZSBzdGF0dXMgdHJlZS5cbiAgICBpZiAoTWF0aC5hYnMocmVzKSA8IEVQUykge1xuICAgICAgLy8gaW5jcmVhc2luZyB4LlxuICAgICAgcmVzID0gYS54IC0gYi54O1xuICAgICAgaWYgKE1hdGguYWJzKHJlcykgPCBFUFMpIHsgcmVzID0gMDsgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnNlY3RTZWdtZW50cyQxKGEsIGIpIHtcbiAgICAvLyBOb3RlOiB0aGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBnZW9tLmludGVyc2VjdFNlZ21lbnRzKClcbiAgICAvLyBUaGUgbWFpbiBkaWZmZXJlbmNlIGlzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhIHByZS1jb21wdXRlZFxuICAgIC8vIHZhbHVlIGZvciBkeC9keSBvbiB0aGUgc2VnbWVudHMuXG4gICAgLy8gIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTY4MzQ1LzEyNTM1MVxuICAgIHZhciBhU3RhcnQgPSBhLmZyb20sIGJTdGFydCA9IGIuZnJvbTtcbiAgICB2YXIgcDBfeCA9IGFTdGFydC54LCBwMF95ID0gYVN0YXJ0LnksXG4gICAgICAgIHAyX3ggPSBiU3RhcnQueCwgcDJfeSA9IGJTdGFydC55O1xuXG4gICAgdmFyIHMxX3ggPSBhLmZyb20ueCAtIGEudG8ueCwgczFfeSA9IGEuZnJvbS55IC0gYS50by55LCBzMl94ID0gYi5mcm9tLnggLSBiLnRvLngsIHMyX3kgPSBiLmZyb20ueSAtIGIudG8ueTtcbiAgICB2YXIgZGl2ID0gczFfeCAqIHMyX3kgLSBzMl94ICogczFfeTtcblxuICAgIHZhciBzID0gKHMxX3kgKiAocDBfeCAtIHAyX3gpIC0gczFfeCAqIChwMF95IC0gcDJfeSkpIC8gZGl2O1xuICAgIGlmIChzIDwgMCB8fCBzID4gMSkgeyByZXR1cm47IH1cblxuICAgIHZhciB0ID0gKHMyX3ggKiAocDJfeSAtIHAwX3kpICsgczJfeSAqIChwMF94IC0gcDJfeCkpIC8gZGl2O1xuXG4gICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHAwX3ggLSAodCAqIHMxX3gpLFxuICAgICAgICB5OiBwMF95IC0gKHQgKiBzMV95KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgYnJ1dGUgZm9yY2Ugc29sdXRpb24gd2l0aCBPKG5eMikgcGVyZm9ybWFuY2UuXG4gICAqIChgbmAgaXMgbnVtYmVyIG9mIHNlZ21lbnRzKS5cbiAgICogXG4gICAqIFVzZSB0aGlzIHdoZW4gbnVtYmVyIG9mIGxpbmVzIGlzIGxvdywgYW5kIG51bWJlciBvZiBpbnRlcnNlY3Rpb25zXG4gICAqIGlzIGhpZ2guXG4gICAqL1xuICBmdW5jdGlvbiBicnV0ZShsaW5lcywgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHJlcG9ydEludGVyc2VjdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMub25Gb3VuZCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXI7XG4gICAgdmFyIGFzeW5jU3RhdGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBFeGVjdXRlIGJydXRlIGZvcmNlIG9mIHRoZSBzZWdtZW50IGludGVyc2VjdGlvbiBzZWFyY2hcbiAgICAgICAqL1xuICAgICAgcnVuOiBydW4sXG4gICAgICAvKipcbiAgICAgICAqIEFjY2VzcyB0byByZXN1bHRzIGFycmF5LiBXb3JrcyBvbmx5IHdoZW4geW91IHVzZSBkZWZhdWx0IG9uRm91bmQoKSBoYW5kbGVyXG4gICAgICAgKi9cbiAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybXMgYSBzaW5nbGUgc3RlcCBpbiB0aGUgYnJ1dGUgZm9yY2UgYWxnb3JpdGhtICgpXG4gICAgICAgKi9cbiAgICAgIHN0ZXA6IHN0ZXBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKCFhc3luY1N0YXRlKSB7XG4gICAgICAgIGFzeW5jU3RhdGUgPSB7XG4gICAgICAgICAgaTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHRlc3QgPSBsaW5lc1thc3luY1N0YXRlLmldO1xuICAgICAgZm9yICh2YXIgaiA9IGFzeW5jU3RhdGUuaSArIDE7IGogPCBsaW5lcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgb3RoZXIgPSBsaW5lc1tqXTtcbiAgICAgICAgdmFyIHB0ID0gaW50ZXJzZWN0U2VnbWVudHMkMSh0ZXN0LCBvdGhlcik7XG4gICAgICAgIGlmIChwdCkge1xuICAgICAgICAgIGlmIChyZXBvcnRJbnRlcnNlY3Rpb24ocHQsIFt0ZXN0LCBvdGhlcl0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3luY1N0YXRlLmkgKz0gMTtcbiAgICAgIHJldHVybiBhc3luY1N0YXRlLmkgPCBsaW5lcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gbGluZXNbaV07XG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGxpbmVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIG90aGVyID0gbGluZXNbal07XG4gICAgICAgICAgdmFyIHB0ID0gaW50ZXJzZWN0U2VnbWVudHMkMSh0ZXN0LCBvdGhlcik7XG4gICAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgICBpZiAocmVwb3J0SW50ZXJzZWN0aW9uKHB0LCBbdGVzdCwgb3RoZXJdKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXIocCwgaW50ZXJpb3IpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIHBvaW50OiBwLCBcbiAgICAgICAgc2VnbWVudHM6IGludGVyaW9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgQVJSQVlfVFlQRVMgPSBbXG4gICAgICBJbnQ4QXJyYXksIFVpbnQ4QXJyYXksIFVpbnQ4Q2xhbXBlZEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSxcbiAgICAgIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheVxuICBdO1xuXG4gIHZhciBWRVJTSU9OID0gMzsgLy8gc2VyaWFsaXplZCBmb3JtYXQgdmVyc2lvblxuXG4gIHZhciBGbGF0YnVzaCA9IGZ1bmN0aW9uIEZsYXRidXNoKG51bUl0ZW1zLCBub2RlU2l6ZSwgQXJyYXlUeXBlLCBkYXRhKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKG51bUl0ZW1zID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OiBudW1JdGVtcy4nKTsgfVxuICAgICAgaWYgKGlzTmFOKG51bUl0ZW1zKSB8fCBudW1JdGVtcyA8PSAwKSB7IHRocm93IG5ldyBFcnJvcigoXCJVbnBleHBlY3RlZCBudW1JdGVtcyB2YWx1ZTogXCIgKyBudW1JdGVtcyArIFwiLlwiKSk7IH1cblxuICAgICAgdGhpcy5udW1JdGVtcyA9ICtudW1JdGVtcztcbiAgICAgIHRoaXMubm9kZVNpemUgPSBNYXRoLm1pbihNYXRoLm1heCgrbm9kZVNpemUgfHwgMTYsIDIpLCA2NTUzNSk7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBSLXRyZWUgdG8gYWxsb2NhdGUgc3BhY2UgZm9yXG4gICAgICAvLyBhbmQgdGhlIGluZGV4IG9mIGVhY2ggdHJlZSBsZXZlbCAodXNlZCBpbiBzZWFyY2ggbGF0ZXIpXG4gICAgICB2YXIgbiA9IG51bUl0ZW1zO1xuICAgICAgdmFyIG51bU5vZGVzID0gbjtcbiAgICAgIHRoaXMuX2xldmVsQm91bmRzID0gW24gKiA0XTtcbiAgICAgIGRvIHtcbiAgICAgICAgICBuID0gTWF0aC5jZWlsKG4gLyB0aGlzJDEubm9kZVNpemUpO1xuICAgICAgICAgIG51bU5vZGVzICs9IG47XG4gICAgICAgICAgdGhpcyQxLl9sZXZlbEJvdW5kcy5wdXNoKG51bU5vZGVzICogNCk7XG4gICAgICB9IHdoaWxlIChuICE9PSAxKTtcblxuICAgICAgdGhpcy5BcnJheVR5cGUgPSBBcnJheVR5cGUgfHwgRmxvYXQ2NEFycmF5O1xuICAgICAgdGhpcy5JbmRleEFycmF5VHlwZSA9IG51bU5vZGVzIDwgMTYzODQgPyBVaW50MTZBcnJheSA6IFVpbnQzMkFycmF5O1xuXG4gICAgICB2YXIgYXJyYXlUeXBlSW5kZXggPSBBUlJBWV9UWVBFUy5pbmRleE9mKHRoaXMuQXJyYXlUeXBlKTtcbiAgICAgIHZhciBub2Rlc0J5dGVTaXplID0gbnVtTm9kZXMgKiA0ICogdGhpcy5BcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG5cbiAgICAgIGlmIChhcnJheVR5cGVJbmRleCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiVW5leHBlY3RlZCB0eXBlZCBhcnJheSBjbGFzczogXCIgKyBBcnJheVR5cGUgKyBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAmJiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgdGhpcy5fYm94ZXMgPSBuZXcgdGhpcy5BcnJheVR5cGUodGhpcy5kYXRhLCA4LCBudW1Ob2RlcyAqIDQpO1xuICAgICAgICAgIHRoaXMuX2luZGljZXMgPSBuZXcgdGhpcy5JbmRleEFycmF5VHlwZSh0aGlzLmRhdGEsIDggKyBub2Rlc0J5dGVTaXplLCBudW1Ob2Rlcyk7XG5cbiAgICAgICAgICB0aGlzLl9wb3MgPSBudW1Ob2RlcyAqIDQ7XG4gICAgICAgICAgdGhpcy5taW5YID0gdGhpcy5fYm94ZXNbdGhpcy5fcG9zIC0gNF07XG4gICAgICAgICAgdGhpcy5taW5ZID0gdGhpcy5fYm94ZXNbdGhpcy5fcG9zIC0gM107XG4gICAgICAgICAgdGhpcy5tYXhYID0gdGhpcy5fYm94ZXNbdGhpcy5fcG9zIC0gMl07XG4gICAgICAgICAgdGhpcy5tYXhZID0gdGhpcy5fYm94ZXNbdGhpcy5fcG9zIC0gMV07XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEFycmF5QnVmZmVyKDggKyBub2Rlc0J5dGVTaXplICsgbnVtTm9kZXMgKiB0aGlzLkluZGV4QXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICAgICAgICB0aGlzLl9ib3hlcyA9IG5ldyB0aGlzLkFycmF5VHlwZSh0aGlzLmRhdGEsIDgsIG51bU5vZGVzICogNCk7XG4gICAgICAgICAgdGhpcy5faW5kaWNlcyA9IG5ldyB0aGlzLkluZGV4QXJyYXlUeXBlKHRoaXMuZGF0YSwgOCArIG5vZGVzQnl0ZVNpemUsIG51bU5vZGVzKTtcbiAgICAgICAgICB0aGlzLl9wb3MgPSAwO1xuICAgICAgICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgICAgICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgICAgICAgIHRoaXMubWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgICB0aGlzLm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgICBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEsIDAsIDIpLnNldChbMHhmYiwgKFZFUlNJT04gPDwgNCkgKyBhcnJheVR5cGVJbmRleF0pO1xuICAgICAgICAgIG5ldyBVaW50MTZBcnJheSh0aGlzLmRhdGEsIDIsIDEpWzBdID0gbm9kZVNpemU7XG4gICAgICAgICAgbmV3IFVpbnQzMkFycmF5KHRoaXMuZGF0YSwgNCwgMSlbMF0gPSBudW1JdGVtcztcbiAgICAgIH1cbiAgfTtcblxuICBGbGF0YnVzaC5mcm9tID0gZnVuY3Rpb24gZnJvbSAoZGF0YSkge1xuICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEFycmF5QnVmZmVyLicpO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IG5ldyBVaW50OEFycmF5KGRhdGEsIDAsIDIpO1xuICAgICAgICAgIHZhciBtYWdpYyA9IHJlZlswXTtcbiAgICAgICAgICB2YXIgdmVyc2lvbkFuZFR5cGUgPSByZWZbMV07XG4gICAgICBpZiAobWFnaWMgIT09IDB4ZmIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGluIGEgRmxhdGJ1c2ggZm9ybWF0LicpO1xuICAgICAgfVxuICAgICAgaWYgKHZlcnNpb25BbmRUeXBlID4+IDQgIT09IFZFUlNJT04pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiR290IHZcIiArICh2ZXJzaW9uQW5kVHlwZSA+PiA0KSArIFwiIGRhdGEgd2hlbiBleHBlY3RlZCB2XCIgKyBWRVJTSU9OICsgXCIuXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWYkMSA9IG5ldyBVaW50MTZBcnJheShkYXRhLCAyLCAxKTtcbiAgICAgICAgICB2YXIgbm9kZVNpemUgPSByZWYkMVswXTtcbiAgICAgIHZhciByZWYkMiA9IG5ldyBVaW50MzJBcnJheShkYXRhLCA0LCAxKTtcbiAgICAgICAgICB2YXIgbnVtSXRlbXMgPSByZWYkMlswXTtcblxuICAgICAgcmV0dXJuIG5ldyBGbGF0YnVzaChudW1JdGVtcywgbm9kZVNpemUsIEFSUkFZX1RZUEVTW3ZlcnNpb25BbmRUeXBlICYgMHgwZl0sIGRhdGEpO1xuICB9O1xuXG4gIEZsYXRidXNoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG1pblgsIG1pblksIG1heFgsIG1heFkpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX3BvcyA+PiAyO1xuICAgICAgdGhpcy5faW5kaWNlc1tpbmRleF0gPSBpbmRleDtcbiAgICAgIHRoaXMuX2JveGVzW3RoaXMuX3BvcysrXSA9IG1pblg7XG4gICAgICB0aGlzLl9ib3hlc1t0aGlzLl9wb3MrK10gPSBtaW5ZO1xuICAgICAgdGhpcy5fYm94ZXNbdGhpcy5fcG9zKytdID0gbWF4WDtcbiAgICAgIHRoaXMuX2JveGVzW3RoaXMuX3BvcysrXSA9IG1heFk7XG5cbiAgICAgIGlmIChtaW5YIDwgdGhpcy5taW5YKSB7IHRoaXMubWluWCA9IG1pblg7IH1cbiAgICAgIGlmIChtaW5ZIDwgdGhpcy5taW5ZKSB7IHRoaXMubWluWSA9IG1pblk7IH1cbiAgICAgIGlmIChtYXhYID4gdGhpcy5tYXhYKSB7IHRoaXMubWF4WCA9IG1heFg7IH1cbiAgICAgIGlmIChtYXhZID4gdGhpcy5tYXhZKSB7IHRoaXMubWF4WSA9IG1heFk7IH1cbiAgfTtcblxuICBGbGF0YnVzaC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoICgpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX3BvcyA+PiAyICE9PSB0aGlzLm51bUl0ZW1zKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkFkZGVkIFwiICsgKHRoaXMuX3BvcyA+PiAyKSArIFwiIGl0ZW1zIHdoZW4gZXhwZWN0ZWQgXCIgKyAodGhpcy5udW1JdGVtcykgKyBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSB0aGlzLm1heFggLSB0aGlzLm1pblg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5tYXhZIC0gdGhpcy5taW5ZO1xuICAgICAgdmFyIGhpbGJlcnRWYWx1ZXMgPSBuZXcgVWludDMyQXJyYXkodGhpcy5udW1JdGVtcyk7XG4gICAgICB2YXIgaGlsYmVydE1heCA9ICgxIDw8IDE2KSAtIDE7XG5cbiAgICAgIC8vIG1hcCBpdGVtIGNlbnRlcnMgaW50byBIaWxiZXJ0IGNvb3JkaW5hdGUgc3BhY2UgYW5kIGNhbGN1bGF0ZSBIaWxiZXJ0IHZhbHVlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bUl0ZW1zOyBpKyspIHtcbiAgICAgICAgICB2YXIgcG9zID0gNCAqIGk7XG4gICAgICAgICAgdmFyIG1pblggPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgICB2YXIgbWluWSA9IHRoaXMkMS5fYm94ZXNbcG9zKytdO1xuICAgICAgICAgIHZhciBtYXhYID0gdGhpcyQxLl9ib3hlc1twb3MrK107XG4gICAgICAgICAgdmFyIG1heFkgPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoaGlsYmVydE1heCAqICgobWluWCArIG1heFgpIC8gMiAtIHRoaXMkMS5taW5YKSAvIHdpZHRoKTtcbiAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IoaGlsYmVydE1heCAqICgobWluWSArIG1heFkpIC8gMiAtIHRoaXMkMS5taW5ZKSAvIGhlaWdodCk7XG4gICAgICAgICAgaGlsYmVydFZhbHVlc1tpXSA9IGhpbGJlcnQoeCwgeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNvcnQgaXRlbXMgYnkgdGhlaXIgSGlsYmVydCB2YWx1ZSAoZm9yIHBhY2tpbmcgbGF0ZXIpXG4gICAgICBzb3J0JDEoaGlsYmVydFZhbHVlcywgdGhpcy5fYm94ZXMsIHRoaXMuX2luZGljZXMsIDAsIHRoaXMubnVtSXRlbXMgLSAxKTtcblxuICAgICAgLy8gZ2VuZXJhdGUgbm9kZXMgYXQgZWFjaCB0cmVlIGxldmVsLCBib3R0b20tdXBcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIHBvcyQxID0gMDsgaSQxIDwgdGhpcy5fbGV2ZWxCb3VuZHMubGVuZ3RoIC0gMTsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgZW5kID0gdGhpcyQxLl9sZXZlbEJvdW5kc1tpJDFdO1xuXG4gICAgICAgICAgLy8gZ2VuZXJhdGUgYSBwYXJlbnQgbm9kZSBmb3IgZWFjaCBibG9jayBvZiBjb25zZWN1dGl2ZSA8bm9kZVNpemU+IG5vZGVzXG4gICAgICAgICAgd2hpbGUgKHBvcyQxIDwgZW5kKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlTWluWCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICB2YXIgbm9kZU1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVNYXhYID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICB2YXIgbm9kZU1heFkgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBwb3MkMTtcblxuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgYmJveCBmb3IgdGhlIG5ldyBub2RlXG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHRoaXMubm9kZVNpemUgJiYgcG9zJDEgPCBlbmQ7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbWluWCQxID0gdGhpcyQxLl9ib3hlc1twb3MkMSsrXTtcbiAgICAgICAgICAgICAgICAgIHZhciBtaW5ZJDEgPSB0aGlzJDEuX2JveGVzW3BvcyQxKytdO1xuICAgICAgICAgICAgICAgICAgdmFyIG1heFgkMSA9IHRoaXMkMS5fYm94ZXNbcG9zJDErK107XG4gICAgICAgICAgICAgICAgICB2YXIgbWF4WSQxID0gdGhpcyQxLl9ib3hlc1twb3MkMSsrXTtcbiAgICAgICAgICAgICAgICAgIGlmIChtaW5YJDEgPCBub2RlTWluWCkgeyBub2RlTWluWCA9IG1pblgkMTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG1pblkkMSA8IG5vZGVNaW5ZKSB7IG5vZGVNaW5ZID0gbWluWSQxOyB9XG4gICAgICAgICAgICAgICAgICBpZiAobWF4WCQxID4gbm9kZU1heFgpIHsgbm9kZU1heFggPSBtYXhYJDE7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChtYXhZJDEgPiBub2RlTWF4WSkgeyBub2RlTWF4WSA9IG1heFkkMTsgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gYWRkIHRoZSBuZXcgbm9kZSB0byB0aGUgdHJlZSBkYXRhXG4gICAgICAgICAgICAgIHRoaXMkMS5faW5kaWNlc1t0aGlzJDEuX3BvcyA+PiAyXSA9IG5vZGVJbmRleDtcbiAgICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNaW5YO1xuICAgICAgICAgICAgICB0aGlzJDEuX2JveGVzW3RoaXMkMS5fcG9zKytdID0gbm9kZU1pblk7XG4gICAgICAgICAgICAgIHRoaXMkMS5fYm94ZXNbdGhpcyQxLl9wb3MrK10gPSBub2RlTWF4WDtcbiAgICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNYXhZO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICBGbGF0YnVzaC5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoIChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBmaWx0ZXJGbikge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fcG9zICE9PSB0aGlzLl9ib3hlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbm90IHlldCBpbmRleGVkIC0gY2FsbCBpbmRleC5maW5pc2goKS4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMuX2JveGVzLmxlbmd0aCAtIDQ7XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbEJvdW5kcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICB3aGlsZSAobm9kZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaW5kIHRoZSBlbmQgaW5kZXggb2YgdGhlIG5vZGVcbiAgICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4obm9kZUluZGV4ICsgdGhpcyQxLm5vZGVTaXplICogNCwgdGhpcyQxLl9sZXZlbEJvdW5kc1tsZXZlbF0pO1xuXG4gICAgICAgICAgLy8gc2VhcmNoIHRocm91Z2ggY2hpbGQgbm9kZXNcbiAgICAgICAgICBmb3IgKHZhciBwb3MgPSBub2RlSW5kZXg7IHBvcyA8IGVuZDsgcG9zICs9IDQpIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcyQxLl9pbmRpY2VzW3BvcyA+PiAyXTtcblxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBub2RlIGJib3ggaW50ZXJzZWN0cyB3aXRoIHF1ZXJ5IGJib3hcbiAgICAgICAgICAgICAgaWYgKG1heFggPCB0aGlzJDEuX2JveGVzW3Bvc10pIHsgY29udGludWU7IH0gLy8gbWF4WCA8IG5vZGVNaW5YXG4gICAgICAgICAgICAgIGlmIChtYXhZIDwgdGhpcyQxLl9ib3hlc1twb3MgKyAxXSkgeyBjb250aW51ZTsgfSAvLyBtYXhZIDwgbm9kZU1pbllcbiAgICAgICAgICAgICAgaWYgKG1pblggPiB0aGlzJDEuX2JveGVzW3BvcyArIDJdKSB7IGNvbnRpbnVlOyB9IC8vIG1pblggPiBub2RlTWF4WFxuICAgICAgICAgICAgICBpZiAobWluWSA+IHRoaXMkMS5fYm94ZXNbcG9zICsgM10pIHsgY29udGludWU7IH0gLy8gbWluWSA+IG5vZGVNYXhZXG5cbiAgICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA8IHRoaXMkMS5udW1JdGVtcyAqIDQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJGbiA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlckZuKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpbmRleCk7IC8vIGxlYWYgaXRlbVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGluZGV4KTsgLy8gbm9kZTsgYWRkIGl0IHRvIHRoZSBzZWFyY2ggcXVldWVcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobGV2ZWwgLSAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldmVsID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgbm9kZUluZGV4ID0gcXVldWUucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIGN1c3RvbSBxdWlja3NvcnQgdGhhdCBzb3J0cyBiYm94IGRhdGEgYWxvbmdzaWRlIHRoZSBoaWxiZXJ0IHZhbHVlc1xuICBmdW5jdGlvbiBzb3J0JDEodmFsdWVzLCBib3hlcywgaW5kaWNlcywgbGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmIChsZWZ0ID49IHJpZ2h0KSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgcGl2b3QgPSB2YWx1ZXNbKGxlZnQgKyByaWdodCkgPj4gMV07XG4gICAgICB2YXIgaSA9IGxlZnQgLSAxO1xuICAgICAgdmFyIGogPSByaWdodCArIDE7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgZG8geyBpKys7IH0gd2hpbGUgKHZhbHVlc1tpXSA8IHBpdm90KTtcbiAgICAgICAgICBkbyB7IGotLTsgfSB3aGlsZSAodmFsdWVzW2pdID4gcGl2b3QpO1xuICAgICAgICAgIGlmIChpID49IGopIHsgYnJlYWs7IH1cbiAgICAgICAgICBzd2FwKHZhbHVlcywgYm94ZXMsIGluZGljZXMsIGksIGopO1xuICAgICAgfVxuXG4gICAgICBzb3J0JDEodmFsdWVzLCBib3hlcywgaW5kaWNlcywgbGVmdCwgaik7XG4gICAgICBzb3J0JDEodmFsdWVzLCBib3hlcywgaW5kaWNlcywgaiArIDEsIHJpZ2h0KTtcbiAgfVxuXG4gIC8vIHN3YXAgdHdvIHZhbHVlcyBhbmQgdHdvIGNvcnJlc3BvbmRpbmcgYm94ZXNcbiAgZnVuY3Rpb24gc3dhcCh2YWx1ZXMsIGJveGVzLCBpbmRpY2VzLCBpLCBqKSB7XG4gICAgICB2YXIgdGVtcCA9IHZhbHVlc1tpXTtcbiAgICAgIHZhbHVlc1tpXSA9IHZhbHVlc1tqXTtcbiAgICAgIHZhbHVlc1tqXSA9IHRlbXA7XG5cbiAgICAgIHZhciBrID0gNCAqIGk7XG4gICAgICB2YXIgbSA9IDQgKiBqO1xuXG4gICAgICB2YXIgYSA9IGJveGVzW2tdO1xuICAgICAgdmFyIGIgPSBib3hlc1trICsgMV07XG4gICAgICB2YXIgYyA9IGJveGVzW2sgKyAyXTtcbiAgICAgIHZhciBkID0gYm94ZXNbayArIDNdO1xuICAgICAgYm94ZXNba10gPSBib3hlc1ttXTtcbiAgICAgIGJveGVzW2sgKyAxXSA9IGJveGVzW20gKyAxXTtcbiAgICAgIGJveGVzW2sgKyAyXSA9IGJveGVzW20gKyAyXTtcbiAgICAgIGJveGVzW2sgKyAzXSA9IGJveGVzW20gKyAzXTtcbiAgICAgIGJveGVzW21dID0gYTtcbiAgICAgIGJveGVzW20gKyAxXSA9IGI7XG4gICAgICBib3hlc1ttICsgMl0gPSBjO1xuICAgICAgYm94ZXNbbSArIDNdID0gZDtcblxuICAgICAgdmFyIGUgPSBpbmRpY2VzW2ldO1xuICAgICAgaW5kaWNlc1tpXSA9IGluZGljZXNbal07XG4gICAgICBpbmRpY2VzW2pdID0gZTtcbiAgfVxuXG4gIC8vIEZhc3QgSGlsYmVydCBjdXJ2ZSBhbGdvcml0aG0gYnkgaHR0cDovL3RocmVhZGxvY2FsbXV0ZXguY29tL1xuICAvLyBQb3J0ZWQgZnJvbSBDKysgaHR0cHM6Ly9naXRodWIuY29tL3Jhd3J1bnByb3RlY3RlZC9oaWxiZXJ0X2N1cnZlcyAocHVibGljIGRvbWFpbilcbiAgZnVuY3Rpb24gaGlsYmVydCh4LCB5KSB7XG4gICAgICB2YXIgYSA9IHggXiB5O1xuICAgICAgdmFyIGIgPSAweEZGRkYgXiBhO1xuICAgICAgdmFyIGMgPSAweEZGRkYgXiAoeCB8IHkpO1xuICAgICAgdmFyIGQgPSB4ICYgKHkgXiAweEZGRkYpO1xuXG4gICAgICB2YXIgQSA9IGEgfCAoYiA+PiAxKTtcbiAgICAgIHZhciBCID0gKGEgPj4gMSkgXiBhO1xuICAgICAgdmFyIEMgPSAoKGMgPj4gMSkgXiAoYiAmIChkID4+IDEpKSkgXiBjO1xuICAgICAgdmFyIEQgPSAoKGEgJiAoYyA+PiAxKSkgXiAoZCA+PiAxKSkgXiBkO1xuXG4gICAgICBhID0gQTsgYiA9IEI7IGMgPSBDOyBkID0gRDtcbiAgICAgIEEgPSAoKGEgJiAoYSA+PiAyKSkgXiAoYiAmIChiID4+IDIpKSk7XG4gICAgICBCID0gKChhICYgKGIgPj4gMikpIF4gKGIgJiAoKGEgXiBiKSA+PiAyKSkpO1xuICAgICAgQyBePSAoKGEgJiAoYyA+PiAyKSkgXiAoYiAmIChkID4+IDIpKSk7XG4gICAgICBEIF49ICgoYiAmIChjID4+IDIpKSBeICgoYSBeIGIpICYgKGQgPj4gMikpKTtcblxuICAgICAgYSA9IEE7IGIgPSBCOyBjID0gQzsgZCA9IEQ7XG4gICAgICBBID0gKChhICYgKGEgPj4gNCkpIF4gKGIgJiAoYiA+PiA0KSkpO1xuICAgICAgQiA9ICgoYSAmIChiID4+IDQpKSBeIChiICYgKChhIF4gYikgPj4gNCkpKTtcbiAgICAgIEMgXj0gKChhICYgKGMgPj4gNCkpIF4gKGIgJiAoZCA+PiA0KSkpO1xuICAgICAgRCBePSAoKGIgJiAoYyA+PiA0KSkgXiAoKGEgXiBiKSAmIChkID4+IDQpKSk7XG5cbiAgICAgIGEgPSBBOyBiID0gQjsgYyA9IEM7IGQgPSBEO1xuICAgICAgQyBePSAoKGEgJiAoYyA+PiA4KSkgXiAoYiAmIChkID4+IDgpKSk7XG4gICAgICBEIF49ICgoYiAmIChjID4+IDgpKSBeICgoYSBeIGIpICYgKGQgPj4gOCkpKTtcblxuICAgICAgYSA9IEMgXiAoQyA+PiAxKTtcbiAgICAgIGIgPSBEIF4gKEQgPj4gMSk7XG5cbiAgICAgIHZhciBpMCA9IHggXiB5O1xuICAgICAgdmFyIGkxID0gYiB8ICgweEZGRkYgXiAoaTAgfCBhKSk7XG5cbiAgICAgIGkwID0gKGkwIHwgKGkwIDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgICBpMCA9IChpMCB8IChpMCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgICAgaTAgPSAoaTAgfCAoaTAgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICAgIGkwID0gKGkwIHwgKGkwIDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICAgIGkxID0gKGkxIHwgKGkxIDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgICBpMSA9IChpMSB8IChpMSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgICAgaTEgPSAoaTEgfCAoaTEgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICAgIGkxID0gKGkxIHwgKGkxIDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICAgIHJldHVybiAoKGkxIDw8IDEpIHwgaTApID4+PiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgaW5zcGlyZWQgYnkgZGlzY3Vzc2lvbiBoZXJlIFxuICAgKiBodHRwczovL3R3aXR0ZXIuY29tL21vdXJuZXIvc3RhdHVzLzEwNDkzMjUxOTk2MTc5MjEwMjQgYW5kIFxuICAgKiBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnZha2EvaXNlY3QvaXNzdWVzLzFcbiAgICogXG4gICAqIEl0IGJ1aWxkcyBhbiBpbmRleCBvZiBhbGwgc2VnbWVudHMgdXNpbmcgc3RhdGljIHNwYXRpYWwgaW5kZXhcbiAgICogYW5kIHRoZW4gZm9yIGVhY2ggc2VnbWVudCBpdCBxdWVyaWVzIG92ZXJsYXBwaW5nIHJlY3RhbmdsZXMuXG4gICAqL1xuICBmdW5jdGlvbiBidXNoKGxpbmVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgcmVwb3J0SW50ZXJzZWN0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5vbkZvdW5kKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRJbnRlcnNlY3Rpb25SZXBvcnRlcjtcbiAgICB2YXIgYXN5bmNTdGF0ZTtcblxuICAgIHZhciBpbmRleCA9IG5ldyBGbGF0YnVzaChsaW5lcy5sZW5ndGgpO1xuICAgIGxpbmVzLmZvckVhY2goYWRkVG9JbmRleCk7XG4gICAgaW5kZXguZmluaXNoKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcnVuOiBydW4sXG4gICAgICBzdGVwOiBzdGVwLFxuICAgICAgcmVzdWx0czogcmVzdWx0cyxcblxuICAgICAgLy8gdW5kb2N1bWVudGVkLCBkb24ndCB1c2UgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZzpcbiAgICAgIGNoZWNrSW50ZXJzZWN0aW9uOiBjaGVja0ludGVyc2VjdGlvblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGNoZWNrSW50ZXJzZWN0aW9uKGxpbmVzW2ldLCBpKSkge1xuICAgICAgICAgIHJldHVybjsgLy8gc3RvcCBlYXJseVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0ludGVyc2VjdGlvbihjdXJyZW50U2VnbWVudCwgY3VycmVudElkKSB7XG4gICAgICAvLyBzb3JyeSBhYm91dCBjb2RlIGR1cGxpY2F0aW9uLlxuICAgICAgdmFyIG1pblggPSBjdXJyZW50U2VnbWVudC5mcm9tLng7IHZhciBtYXhYID0gY3VycmVudFNlZ21lbnQudG8ueDtcbiAgICAgIHZhciBtaW5ZID0gY3VycmVudFNlZ21lbnQuZnJvbS55OyB2YXIgbWF4WSA9IGN1cnJlbnRTZWdtZW50LnRvLnk7XG4gICAgICB2YXIgdDtcbiAgICAgIGlmIChtaW5YID4gbWF4WCkgeyB0ID0gbWluWDsgbWluWCA9IG1heFg7IG1heFggPSB0OyB9XG4gICAgICBpZiAobWluWSA+IG1heFkpIHsgdCA9IG1pblk7IG1pblkgPSBtYXhZOyBtYXhZID0gdDsgfVxuXG4gICAgICB2YXIgaWRzID0gaW5kZXguc2VhcmNoKG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gaWRzW2ldO1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDw9IGN1cnJlbnRJZCkgeyBjb250aW51ZTsgfSAvLyB3ZSBoYXZlIGVpdGhlciByZXBvcnRlZCBpdCwgb3IgaXQgaXMgY3VycmVudC5cblxuICAgICAgICB2YXIgb3RoZXJTZWdtZW50ID0gbGluZXNbc2VnbWVudEluZGV4XTtcbiAgICAgICAgdmFyIHBvaW50ID0gaW50ZXJzZWN0U2VnbWVudHMkMShvdGhlclNlZ21lbnQsIGN1cnJlbnRTZWdtZW50KTtcblxuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICBpZiAocmVwb3J0SW50ZXJzZWN0aW9uKHBvaW50LCBbY3VycmVudFNlZ21lbnQsIG90aGVyU2VnbWVudF0pKSB7XG4gICAgICAgICAgICAvLyBzdG9wIGVhcmx5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKCFhc3luY1N0YXRlKSB7XG4gICAgICAgIGFzeW5jU3RhdGUgPSB7aTogMH07XG4gICAgICB9XG4gICAgICB2YXIgdGVzdCA9IGxpbmVzW2FzeW5jU3RhdGUuaV07XG4gICAgICBjaGVja0ludGVyc2VjdGlvbih0ZXN0LCBhc3luY1N0YXRlLmkpO1xuICAgICAgYXN5bmNTdGF0ZS5pICs9IDE7XG4gICAgICByZXR1cm4gYXN5bmNTdGF0ZS5pIDwgbGluZXMubGVuZ3RoO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkVG9JbmRleChsaW5lKSB7XG4gICAgICB2YXIgbWluWCA9IGxpbmUuZnJvbS54OyB2YXIgbWF4WCA9IGxpbmUudG8ueDtcbiAgICAgIHZhciBtaW5ZID0gbGluZS5mcm9tLnk7IHZhciBtYXhZID0gbGluZS50by55O1xuICAgICAgdmFyIHQ7XG4gICAgICBpZiAobWluWCA+IG1heFgpIHsgdCA9IG1pblg7IG1pblggPSBtYXhYOyBtYXhYID0gdDsgfVxuICAgICAgaWYgKG1pblkgPiBtYXhZKSB7IHQgPSBtaW5ZOyBtaW5ZID0gbWF4WTsgbWF4WSA9IHQ7IH1cbiAgICAgIGluZGV4LmFkZChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXIocCwgaW50ZXJpb3IpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIHBvaW50OiBwLCBcbiAgICAgICAgc2VnbWVudHM6IGludGVyaW9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLnN3ZWVwID0gaXNlY3Q7XG4gIGV4cG9ydHMuYnJ1dGUgPSBicnV0ZTtcbiAgZXhwb3J0cy5idXNoID0gYnVzaDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNlY3QuanMubWFwXG4iLCIvKipcbiAqIEpTVFMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfRURMdjEudHh0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfRVBMdjEudHh0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfTElDRU5TRV9FUzZfQ09MTEVDVElPTlMudHh0XG4gKiBAbGljZW5zZVxuICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9lKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxlKTplKCh0PXR8fHNlbGYpLmpzdHM9e30pfSh0aGlzLChmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtjbGFzcyBle2NvbnN0cnVjdG9yKCl7ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBlcXVhbHNXaXRoVG9sZXJhbmNlKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnModC1lKTw9bn1nZXRDbGFzcygpe3JldHVybiBlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBuKHQpe3RoaXMubWVzc2FnZT10fWZ1bmN0aW9uIHModCxlKXt0aGlzLmxvdz0wfGUsdGhpcy5oaWdoPTB8dH1mdW5jdGlvbiBpKCl7fWZ1bmN0aW9uIHIoKXt9ZnVuY3Rpb24gbygpe31mdW5jdGlvbiBsKCl7fWZ1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gYyh0KXt0aGlzLm5hbWU9XCJSdW50aW1lRXhjZXB0aW9uXCIsdGhpcy5tZXNzYWdlPXQsdGhpcy5zdGFjaz0obmV3IEVycm9yKS5zdGFjayxFcnJvci5jYWxsKHRoaXMsdCl9ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LHMudG9CaW5hcnlTdHJpbmc9ZnVuY3Rpb24odCl7bGV0IGUsbj1cIlwiO2ZvcihlPTIxNDc0ODM2NDg7ZT4wO2U+Pj49MSluKz0odC5oaWdoJmUpPT09ZT9cIjFcIjpcIjBcIjtmb3IoZT0yMTQ3NDgzNjQ4O2U+MDtlPj4+PTEpbis9KHQubG93JmUpPT09ZT9cIjFcIjpcIjBcIjtyZXR1cm4gbn0saS5pc05hTj10PT5OdW1iZXIuaXNOYU4odCksaS5pc0luZmluaXRlPXQ9PiFOdW1iZXIuaXNGaW5pdGUodCksaS5NQVhfVkFMVUU9TnVtYmVyLk1BWF9WQUxVRSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBGbG9hdDY0QXJyYXkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEludDMyQXJyYXk/ZnVuY3Rpb24oKXtjb25zdCB0PW5ldyBGbG9hdDY0QXJyYXkoMSksZT1uZXcgSW50MzJBcnJheSh0LmJ1ZmZlcik7aS5kb3VibGVUb0xvbmdCaXRzPWZ1bmN0aW9uKG4pe3RbMF09bjtsZXQgaT0wfGVbMF0scj0wfGVbMV07cmV0dXJuIDIxNDY0MzUwNzI9PSgyMTQ2NDM1MDcyJnIpJiYwIT0oMTA0ODU3NSZyKSYmMCE9PWkmJihpPTAscj0yMTQ2OTU5MzYwKSxuZXcgcyhyLGkpfSxpLmxvbmdCaXRzVG9Eb3VibGU9ZnVuY3Rpb24obil7cmV0dXJuIGVbMF09bi5sb3csZVsxXT1uLmhpZ2gsdFswXX19KCk6ZnVuY3Rpb24oKXtjb25zdCB0PU1hdGgubG9nMixlPU1hdGguZmxvb3Isbj1NYXRoLnBvdyxyPWZ1bmN0aW9uKCl7Zm9yKGxldCBzPTUzO3M+MDtzLS0pe2NvbnN0IGk9bigyLHMpLTE7aWYoZSh0KGkpKSsxPT09cylyZXR1cm4gaX1yZXR1cm4gMH0oKTtpLmRvdWJsZVRvTG9uZ0JpdHM9ZnVuY3Rpb24oaSl7bGV0IG8sbCxhLGMsaCx1LGcsZCxfO2lmKGk8MHx8MS9pPT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZPyh1PTE8PDMxLGk9LWkpOnU9MCwwPT09aSlyZXR1cm4gXz0wLGQ9dSxuZXcgcyhkLF8pO2lmKGk9PT0xLzApcmV0dXJuIF89MCxkPTIxNDY0MzUwNzJ8dSxuZXcgcyhkLF8pO2lmKGkhPWkpcmV0dXJuIF89MCxkPTIxNDY5NTkzNjAsbmV3IHMoZCxfKTtpZihjPTAsXz0wLG89ZShpKSxvPjEpaWYobzw9ciljPWUodChvKSksYzw9MjA/KF89MCxkPW88PDIwLWMmMTA0ODU3NSk6KGE9Yy0yMCxsPW4oMixhKSxfPW8lbDw8MzItYSxkPW8vbCYxMDQ4NTc1KTtlbHNlIGZvcihhPW8sXz0wO2w9YS8yLGE9ZShsKSwwIT09YTspYysrLF8+Pj49MSxffD0oMSZkKTw8MzEsZD4+Pj0xLGwhPT1hJiYoZHw9NTI0Mjg4KTtpZihnPWMrMTAyMyxoPTA9PT1vLG89aS1vLGM8NTImJjAhPT1vKWZvcihhPTA7Oyl7aWYobD0yKm8sbD49MT8obz1sLTEsaD8oZy0tLGg9ITEpOihhPDw9MSxhfD0xLGMrKykpOihvPWwsaD8wPT0tLWcmJihjKyssaD0hMSk6KGE8PD0xLGMrKykpLDIwPT09YylkfD1hLGE9MDtlbHNlIGlmKDUyPT09Yyl7X3w9YTticmVha31pZigxPT09bCl7YzwyMD9kfD1hPDwyMC1jOmM8NTImJihffD1hPDw1Mi1jKTticmVha319cmV0dXJuIGR8PWc8PDIwLGR8PXUsbmV3IHMoZCxfKX0saS5sb25nQml0c1RvRG91YmxlPWZ1bmN0aW9uKHQpe2xldCBlLHMsaSxyLG87Y29uc3QgbD10LmhpZ2gsYT10Lmxvdztmb3IoaT1sJjE8PDMxPy0xOjEscj0oKDIxNDY0MzUwNzImbCk+PjIwKS0xMDIzLG89MCxzPTE8PDE5LGU9MTtlPD0yMDtlKyspbCZzJiYobys9bigyLC1lKSkscz4+Pj0xO2ZvcihzPTE8PDMxLGU9MjE7ZTw9NTI7ZSsrKWEmcyYmKG8rPW4oMiwtZSkpLHM+Pj49MTtpZigtMTAyMz09PXIpe2lmKDA9PT1vKXJldHVybiAwKmk7cj0tMTAyMn1lbHNle2lmKDEwMjQ9PT1yKXJldHVybiAwPT09bz9pLzA6TmFOO28rPTF9cmV0dXJuIGkqbypuKDIscil9fSgpLGMucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSxjLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1FcnJvcjtjbGFzcyBoIGV4dGVuZHMgY3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksaC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIGh9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWguY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpYy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtjLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fTtjbGFzcyB1e2NvbnN0cnVjdG9yKCl7dS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaG91bGROZXZlclJlYWNoSGVyZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUobnVsbCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhyb3cgbmV3IGgoXCJTaG91bGQgbmV2ZXIgcmVhY2ggaGVyZVwiKyhudWxsIT09dD9cIjogXCIrdDpcIlwiKSl9fXN0YXRpYyBpc1RydWUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dS5pc1RydWUodCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdCl0aHJvdyBudWxsPT09ZT9uZXcgaDpuZXcgaChlKX19c3RhdGljIGVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt1LmVxdWFscyh0LGUsbnVsbCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoIWUuZXF1YWxzKHQpKXRocm93IG5ldyBoKFwiRXhwZWN0ZWQgXCIrdCtcIiBidXQgZW5jb3VudGVyZWQgXCIrZSsobnVsbCE9PW4/XCI6IFwiK246XCJcIikpfX1nZXRDbGFzcygpe3JldHVybiB1fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX11LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgZ3tjb25zdHJ1Y3Rvcigpe2cuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaGFzaENvZGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1pLmRvdWJsZVRvTG9uZ0JpdHModCk7cmV0dXJuIE1hdGgudHJ1bmMoZV5lPj4+MzIpfX1zZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaCh0KXtjYXNlIGcuWDp0aGlzLng9ZTticmVhaztjYXNlIGcuWTp0aGlzLnk9ZTticmVhaztjYXNlIGcuWjp0aGlzLno9ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBuKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fWVxdWFsczJEKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuISFlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy54LHQueCxuKSYmISFlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy55LHQueSxuKX19Z2V0T3JkaW5hdGUodCl7c3dpdGNoKHQpe2Nhc2UgZy5YOnJldHVybiB0aGlzLng7Y2FzZSBnLlk6cmV0dXJuIHRoaXMueTtjYXNlIGcuWjpyZXR1cm4gdGhpcy56fXRocm93IG5ldyBuKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9ZXF1YWxzM0QodCl7cmV0dXJuIHRoaXMueD09PXQueCYmdGhpcy55PT09dC55JiYodGhpcy56PT09dC56fHxpLmlzTmFOKHRoaXMueikmJmkuaXNOYU4odC56KSl9ZXF1YWxzKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZyYmdGhpcy5lcXVhbHMyRCh0KX1lcXVhbEluWih0LG4pe3JldHVybiBlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy56LHQueixuKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLng8ZS54Py0xOnRoaXMueD5lLng/MTp0aGlzLnk8ZS55Py0xOnRoaXMueT5lLnk/MTowfWNsb25lKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gdS5zaG91bGROZXZlclJlYWNoSGVyZShcInRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoaXMgY2xhc3MgaXMgQ2xvbmVhYmxlXCIpLG51bGw7dGhyb3cgdH19Y29weSgpe3JldHVybiBuZXcgZyh0aGlzKX10b1N0cmluZygpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiLCBcIit0aGlzLnorXCIpXCJ9ZGlzdGFuY2UzRCh0KXtjb25zdCBlPXRoaXMueC10Lngsbj10aGlzLnktdC55LHM9dGhpcy56LXQuejtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4rcypzKX1kaXN0YW5jZSh0KXtjb25zdCBlPXRoaXMueC10Lngsbj10aGlzLnktdC55O3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9aGFzaENvZGUoKXtsZXQgdD0xNztyZXR1cm4gdD0zNyp0K2cuaGFzaENvZGUodGhpcy54KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLnkpLHR9c2V0Q29vcmRpbmF0ZSh0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuen1nZXRDbGFzcygpe3JldHVybiBnfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyLG8sYV19fWNsYXNzIGR7Y29uc3RydWN0b3IoKXtkLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXBhcmUodCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOmkuaXNOYU4odCk/aS5pc05hTihlKT8wOi0xOmkuaXNOYU4oZSk/MTowfWNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lLGk9ZC5jb21wYXJlKG4ueCxzLngpO2lmKDAhPT1pKXJldHVybiBpO2NvbnN0IHI9ZC5jb21wYXJlKG4ueSxzLnkpO3JldHVybiAwIT09cj9yOnRoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q8PTI/MDpkLmNvbXBhcmUobi56LHMueil9Z2V0Q2xhc3MoKXtyZXR1cm4gZH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fWZ1bmN0aW9uIF8odCxlKXtyZXR1cm4gdC5pbnRlcmZhY2VzXyYmdC5pbnRlcmZhY2VzXy5pbmRleE9mKGUpPi0xfWZ1bmN0aW9uIGYoKXt9ZnVuY3Rpb24gcCh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBtKCl7fWZ1bmN0aW9uIHkodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24geCgpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1kLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q9MiwwPT09YXJndW1lbnRzLmxlbmd0aClkLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMik7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMiE9PXQmJjMhPT10KXRocm93IG5ldyBuKFwib25seSAyIG9yIDMgZGltZW5zaW9ucyBtYXkgYmUgc3BlY2lmaWVkXCIpO3RoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q9dH19LGcuRGltZW5zaW9uYWxDb21wYXJhdG9yPWQsZy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLno9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClnLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtnLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSx0LnopfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2cuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsZy5OVUxMX09SRElOQVRFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9bn19LGcuc2VyaWFsVmVyc2lvblVJRD0weDVjYmYyYzIzNWM3ZTU4MDAsZy5OVUxMX09SRElOQVRFPWkuTmFOLGcuWD0wLGcuWT0xLGcuWj0yLGYucHJvdG90eXBlLmFkZD1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKCl7fSxmLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7fSxmLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7fSxwLnByb3RvdHlwZT1uZXcgRXJyb3IscC5wcm90b3R5cGUubmFtZT1cIkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25cIixtLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGYucHJvdG90eXBlKSxtLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1tLG0ucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe30sbS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKCl7fSxtLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7fSx5LnByb3RvdHlwZT1uZXcgRXJyb3IseS5wcm90b3R5cGUubmFtZT1cIk5vU3VjaEVsZW1lbnRFeGNlcHRpb25cIix4LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG0ucHJvdG90eXBlKSx4LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj14LHgucHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5PWZ1bmN0aW9uKCl7fSx4LnByb3RvdHlwZS5pbnRlcmZhY2VzXz1bbSxmXSx4LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMuYXJyYXlfLnB1c2godCk6dGhpcy5hcnJheV8uc3BsaWNlKGFyZ3VtZW50c1swXSwwLGFyZ3VtZW50c1sxXSksITB9LHgucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5hcnJheV89W119LHgucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbih0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7cmV0dXJuITB9LHgucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe2NvbnN0IG49dGhpcy5hcnJheV9bdF07cmV0dXJuIHRoaXMuYXJyYXlfW3RdPWUsbn0seC5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEUodGhpcyl9LHgucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtpZih0PDB8fHQ+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyBwO3JldHVybiB0aGlzLmFycmF5X1t0XX0seC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSx4LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0seC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2NvbnN0IHQ9W107Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSx4LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7bGV0IGU9ITE7Zm9yKGxldCBuPTAscz10aGlzLmFycmF5Xy5sZW5ndGg7bjxzO24rKylpZih0aGlzLmFycmF5X1tuXT09PXQpe3RoaXMuYXJyYXlfLnNwbGljZShuLDEpLGU9ITA7YnJlYWt9cmV0dXJuIGV9LHgucHJvdG90eXBlLnJlbW92ZUFsbD1mdW5jdGlvbih0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLnJlbW92ZShlLm5leHQoKSk7cmV0dXJuITB9O2NvbnN0IEU9ZnVuY3Rpb24odCl7dGhpcy5hcnJheUxpc3RfPXQsdGhpcy5wb3NpdGlvbl89MH07RS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy5hcnJheUxpc3RfLnNpemUoKSl0aHJvdyBuZXcgeTtyZXR1cm4gdGhpcy5hcnJheUxpc3RfLmdldCh0aGlzLnBvc2l0aW9uXysrKX0sRS5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLmFycmF5TGlzdF8uc2l6ZSgpfSxFLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlMaXN0Xy5zZXQodGhpcy5wb3NpdGlvbl8tMSx0KX0sRS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhpcy5hcnJheUxpc3RfLnJlbW92ZSh0aGlzLmFycmF5TGlzdF8uZ2V0KHRoaXMucG9zaXRpb25fKSl9O2NsYXNzIEkgZXh0ZW5kcyB4e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxJLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5nZXQodCl9YWRkQWxsKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZfKGFyZ3VtZW50c1swXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49ITE7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspdGhpcy5hZGQocy5uZXh0KCksZSksbj0hMDtyZXR1cm4gbn1yZXR1cm4gc3VwZXIuYWRkQWxsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbG9uZSgpe2NvbnN0IHQ9c3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuc2l6ZSgpO2UrKyl0LmFkZChlLHRoaXMuZ2V0KGUpLmNsb25lKCkpO3JldHVybiB0fXRvQ29vcmRpbmF0ZUFycmF5KCl7cmV0dXJuIHRoaXMudG9BcnJheShJLmNvb3JkQXJyYXlUeXBlKX1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07c3VwZXIuYWRkLmNhbGwodGhpcyx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKHQsZSwhMCksITB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoIWFyZ3VtZW50c1sxXSYmdGhpcy5zaXplKCk+PTEpe2lmKHRoaXMuZ2V0KHRoaXMuc2l6ZSgpLTEpLmVxdWFsczJEKHQpKXJldHVybiBudWxsfXN1cGVyLmFkZC5jYWxsKHRoaXMsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZCh0LGUpLCEwfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50c1syXSlmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl0aGlzLmFkZCh0W25dLGUpO2Vsc2UgZm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pdGhpcy5hZGQodFtuXSxlKTtyZXR1cm4hMH1pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCFhcmd1bWVudHNbMl0pe2NvbnN0IG49dGhpcy5zaXplKCk7aWYobj4wKXtpZih0PjApe2lmKHRoaXMuZ2V0KHQtMSkuZXF1YWxzMkQoZSkpcmV0dXJuIG51bGx9aWYodDxuKXtpZih0aGlzLmdldCh0KS5lcXVhbHMyRChlKSlyZXR1cm4gbnVsbH19fXN1cGVyLmFkZC5jYWxsKHRoaXMsdCxlKX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bGV0IGk9MTtuPnMmJihpPS0xKTtmb3IobGV0IHI9bjtyIT09cztyKz1pKXRoaXMuYWRkKHRbcl0sZSk7cmV0dXJuITB9fWNsb3NlUmluZygpe3RoaXMuc2l6ZSgpPjAmJnRoaXMuYWRkKG5ldyBnKHRoaXMuZ2V0KDApKSwhMSl9Z2V0Q2xhc3MoKXtyZXR1cm4gSX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lbnN1cmVDYXBhY2l0eSh0Lmxlbmd0aCksdGhpcy5hZGQodCwhMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbnN1cmVDYXBhY2l0eSh0Lmxlbmd0aCksdGhpcy5hZGQodCxlKX19LEkuY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCk7Y2xhc3MgTntjb25zdHJ1Y3Rvcigpe04uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW50ZXJzZWN0cygpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbi54Pj0odC54PGUueD90Lng6ZS54KSYmbi54PD0odC54PmUueD90Lng6ZS54KSYmbi55Pj0odC55PGUueT90Lnk6ZS55KSYmbi55PD0odC55PmUueT90Lnk6ZS55KX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bGV0IGk9TWF0aC5taW4obi54LHMueCkscj1NYXRoLm1heChuLngscy54KSxvPU1hdGgubWluKHQueCxlLngpLGw9TWF0aC5tYXgodC54LGUueCk7cmV0dXJuIShvPnIpJiYoIShsPGkpJiYoaT1NYXRoLm1pbihuLnkscy55KSxyPU1hdGgubWF4KG4ueSxzLnkpLG89TWF0aC5taW4odC55LGUueSksbD1NYXRoLm1heCh0LnksZS55KSwhKG8+cikmJiEobDxpKSkpfX1nZXRBcmVhKCl7cmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSp0aGlzLmdldEhlaWdodCgpfWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBOKSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKTp0aGlzLl9tYXh4PT09ZS5nZXRNYXhYKCkmJnRoaXMuX21heHk9PT1lLmdldE1heFkoKSYmdGhpcy5fbWlueD09PWUuZ2V0TWluWCgpJiZ0aGlzLl9taW55PT09ZS5nZXRNaW5ZKCl9aW50ZXJzZWN0aW9uKHQpe2lmKHRoaXMuaXNOdWxsKCl8fHQuaXNOdWxsKCl8fCF0aGlzLmludGVyc2VjdHModCkpcmV0dXJuIG5ldyBOO2NvbnN0IGU9dGhpcy5fbWlueD50Ll9taW54P3RoaXMuX21pbng6dC5fbWlueCxuPXRoaXMuX21pbnk+dC5fbWlueT90aGlzLl9taW55OnQuX21pbnkscz10aGlzLl9tYXh4PHQuX21heHg/dGhpcy5fbWF4eDp0Ll9tYXh4LGk9dGhpcy5fbWF4eTx0Ll9tYXh5P3RoaXMuX21heHk6dC5fbWF4eTtyZXR1cm4gbmV3IE4oZSxzLG4saSl9aXNOdWxsKCl7cmV0dXJuIHRoaXMuX21heHg8dGhpcy5fbWlueH1nZXRNYXhYKCl7cmV0dXJuIHRoaXMuX21heHh9Y292ZXJzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQueCx0LnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpJiYodC5nZXRNaW5YKCk+PXRoaXMuX21pbngmJnQuZ2V0TWF4WCgpPD10aGlzLl9tYXh4JiZ0LmdldE1pblkoKT49dGhpcy5fbWlueSYmdC5nZXRNYXhZKCk8PXRoaXMuX21heHkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmKHQ+PXRoaXMuX21pbngmJnQ8PXRoaXMuX21heHgmJmU+PXRoaXMuX21pbnkmJmU8PXRoaXMuX21heHkpfX1pbnRlcnNlY3RzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpJiYhKHQuX21pbng+dGhpcy5fbWF4eHx8dC5fbWF4eDx0aGlzLl9taW54fHx0Ll9taW55PnRoaXMuX21heHl8fHQuX21heHk8dGhpcy5fbWlueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQueCx0LnkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJighKCh0Lng8ZS54P3QueDplLngpPnRoaXMuX21heHgpJiYoISgodC54PmUueD90Lng6ZS54KTx0aGlzLl9taW54KSYmKCEoKHQueTxlLnk/dC55OmUueSk+dGhpcy5fbWF4eSkmJiEoKHQueT5lLnk/dC55OmUueSk8dGhpcy5fbWlueSkpKSl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiEodD50aGlzLl9tYXh4fHx0PHRoaXMuX21pbnh8fGU+dGhpcy5fbWF4eXx8ZTx0aGlzLl9taW55KX19fWdldE1pblkoKXtyZXR1cm4gdGhpcy5fbWlueX1nZXRNaW5YKCl7cmV0dXJuIHRoaXMuX21pbnh9ZXhwYW5kVG9JbmNsdWRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRUb0luY2x1ZGUodC54LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5pc051bGwoKT8odGhpcy5fbWlueD10LmdldE1pblgoKSx0aGlzLl9tYXh4PXQuZ2V0TWF4WCgpLHRoaXMuX21pbnk9dC5nZXRNaW5ZKCksdGhpcy5fbWF4eT10LmdldE1heFkoKSk6KHQuX21pbng8dGhpcy5fbWlueCYmKHRoaXMuX21pbng9dC5fbWlueCksdC5fbWF4eD50aGlzLl9tYXh4JiYodGhpcy5fbWF4eD10Ll9tYXh4KSx0Ll9taW55PHRoaXMuX21pbnkmJih0aGlzLl9taW55PXQuX21pbnkpLHQuX21heHk+dGhpcy5fbWF4eSYmKHRoaXMuX21heHk9dC5fbWF4eSkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmlzTnVsbCgpPyh0aGlzLl9taW54PXQsdGhpcy5fbWF4eD10LHRoaXMuX21pbnk9ZSx0aGlzLl9tYXh5PWUpOih0PHRoaXMuX21pbngmJih0aGlzLl9taW54PXQpLHQ+dGhpcy5fbWF4eCYmKHRoaXMuX21heHg9dCksZTx0aGlzLl9taW55JiYodGhpcy5fbWlueT1lKSxlPnRoaXMuX21heHkmJih0aGlzLl9tYXh5PWUpKX19bWluRXh0ZW50KCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDtjb25zdCB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ8ZT90OmV9Z2V0V2lkdGgoKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMuX21heHgtdGhpcy5fbWlueH1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk/MDotMTplLmlzTnVsbCgpPzE6dGhpcy5fbWlueDxlLl9taW54Py0xOnRoaXMuX21pbng+ZS5fbWlueD8xOnRoaXMuX21pbnk8ZS5fbWlueT8tMTp0aGlzLl9taW55PmUuX21pbnk/MTp0aGlzLl9tYXh4PGUuX21heHg/LTE6dGhpcy5fbWF4eD5lLl9tYXh4PzE6dGhpcy5fbWF4eTxlLl9tYXh5Py0xOnRoaXMuX21heHk+ZS5fbWF4eT8xOjB9dHJhbnNsYXRlKHQsZSl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLmluaXQodGhpcy5nZXRNaW5YKCkrdCx0aGlzLmdldE1heFgoKSt0LHRoaXMuZ2V0TWluWSgpK2UsdGhpcy5nZXRNYXhZKCkrZSl9dG9TdHJpbmcoKXtyZXR1cm5cIkVudltcIit0aGlzLl9taW54K1wiIDogXCIrdGhpcy5fbWF4eCtcIiwgXCIrdGhpcy5fbWlueStcIiA6IFwiK3RoaXMuX21heHkrXCJdXCJ9c2V0VG9OdWxsKCl7dGhpcy5fbWlueD0wLHRoaXMuX21heHg9LTEsdGhpcy5fbWlueT0wLHRoaXMuX21heHk9LTF9Z2V0SGVpZ2h0KCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLl9tYXh5LXRoaXMuX21pbnl9bWF4RXh0ZW50KCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDtjb25zdCB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ+ZT90OmV9ZXhwYW5kQnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRCeSh0LHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5fbWlueC09dCx0aGlzLl9tYXh4Kz10LHRoaXMuX21pbnktPWUsdGhpcy5fbWF4eSs9ZSwodGhpcy5fbWlueD50aGlzLl9tYXh4fHx0aGlzLl9taW55PnRoaXMuX21heHkpJiZ0aGlzLnNldFRvTnVsbCgpfX1jb250YWlucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY292ZXJzKHQsZSl9fWNlbnRyZSgpe3JldHVybiB0aGlzLmlzTnVsbCgpP251bGw6bmV3IGcoKHRoaXMuZ2V0TWluWCgpK3RoaXMuZ2V0TWF4WCgpKS8yLCh0aGlzLmdldE1pblkoKSt0aGlzLmdldE1heFkoKSkvMil9aW5pdCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuc2V0VG9OdWxsKCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWlueD10Ll9taW54LHRoaXMuX21heHg9dC5fbWF4eCx0aGlzLl9taW55PXQuX21pbnksdGhpcy5fbWF4eT10Ll9tYXh5fX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodC54LGUueCx0LnksZS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0PGU/KHRoaXMuX21pbng9dCx0aGlzLl9tYXh4PWUpOih0aGlzLl9taW54PWUsdGhpcy5fbWF4eD10KSxuPHM/KHRoaXMuX21pbnk9bix0aGlzLl9tYXh5PXMpOih0aGlzLl9taW55PXMsdGhpcy5fbWF4eT1uKX19Z2V0TWF4WSgpe3JldHVybiB0aGlzLl9tYXh5fWRpc3RhbmNlKHQpe2lmKHRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gMDtsZXQgZT0wO3RoaXMuX21heHg8dC5fbWlueD9lPXQuX21pbngtdGhpcy5fbWF4eDp0aGlzLl9taW54PnQuX21heHgmJihlPXRoaXMuX21pbngtdC5fbWF4eCk7bGV0IG49MDtyZXR1cm4gdGhpcy5fbWF4eTx0Ll9taW55P249dC5fbWlueS10aGlzLl9tYXh5OnRoaXMuX21pbnk+dC5fbWF4eSYmKG49dGhpcy5fbWlueS10Ll9tYXh5KSwwPT09ZT9uOjA9PT1uP2U6TWF0aC5zcXJ0KGUqZStuKm4pfWhhc2hDb2RlKCl7bGV0IHQ9MTc7cmV0dXJuIHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMuX21pbngpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMuX21heHgpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMuX21pbnkpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMuX21heHkpLHR9Z2V0Q2xhc3MoKXtyZXR1cm4gTn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcixhXX19ZnVuY3Rpb24gQygpe31OLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX21pbng9bnVsbCx0aGlzLl9tYXh4PW51bGwsdGhpcy5fbWlueT1udWxsLHRoaXMuX21heHk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLmluaXQoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdCh0LngsZS54LHQueSxlLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuaW5pdCh0LGUsbixzKX19LE4uc2VyaWFsVmVyc2lvblVJRD0weDUxODQ1Y2Q1NTIxODk4MDA7Y2xhc3MgUyBleHRlbmRzIEN7Y29uc3RydWN0b3IoKXtzdXBlcigpLFMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBTfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiB3KHQpe3RoaXMuc3RyPXR9ZnVuY3Rpb24gTCh0KXt0aGlzLnZhbHVlPXR9ZnVuY3Rpb24gVCgpe31TLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe0MuY29uc3RydWN0b3JfLmNhbGwodGhpcyxcIlByb2plY3RpdmUgcG9pbnQgbm90IHJlcHJlc2VudGFibGUgb24gdGhlIENhcnRlc2lhbiBwbGFuZS5cIil9LHcucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbih0KXt0aGlzLnN0cis9dH0sdy5wcm90b3R5cGUuc2V0Q2hhckF0PWZ1bmN0aW9uKHQsZSl7dGhpcy5zdHI9dGhpcy5zdHIuc3Vic3RyKDAsdCkrZSt0aGlzLnN0ci5zdWJzdHIodCsxKX0sdy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RyfSxMLnByb3RvdHlwZS5pbnRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxMLnByb3RvdHlwZS5jb21wYXJlVG89ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudmFsdWU8dD8tMTp0aGlzLnZhbHVlPnQ/MTowfSxMLmlzTmFOPXQ9Pk51bWJlci5pc05hTih0KSxULmlzV2hpdGVzcGFjZT10PT50PD0zMiYmdD49MHx8MTI3PT09dCxULnRvVXBwZXJDYXNlPXQ9PnQudG9VcHBlckNhc2UoKTtjbGFzcyBSe2NvbnN0cnVjdG9yKCl7Ui5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzcXIodCl7cmV0dXJuIFIudmFsdWVPZih0KS5zZWxmTXVsdGlwbHkodCl9c3RhdGljIHZhbHVlT2YoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gUi5wYXJzZSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IFIodCl9fXN0YXRpYyBzcXJ0KHQpe3JldHVybiBSLnZhbHVlT2YodCkuc3FydCgpfXN0YXRpYyBwYXJzZSh0KXtsZXQgZT0wO2NvbnN0IG49dC5sZW5ndGg7Zm9yKDtULmlzV2hpdGVzcGFjZSh0LmNoYXJBdChlKSk7KWUrKztsZXQgcz0hMTtpZihlPG4pe2NvbnN0IG49dC5jaGFyQXQoZSk7XCItXCIhPT1uJiZcIitcIiE9PW58fChlKyssXCItXCI9PT1uJiYocz0hMCkpfWNvbnN0IGk9bmV3IFI7bGV0IHI9MCxvPTAsbD0wO2Zvcig7IShlPj1uKTspe2NvbnN0IG49dC5jaGFyQXQoZSk7aWYoZSsrLFQuaXNEaWdpdChuKSl7Y29uc3QgdD1uLVwiMFwiO2kuc2VsZk11bHRpcGx5KFIuVEVOKSxpLnNlbGZBZGQodCkscisrfWVsc2V7aWYoXCIuXCIhPT1uKXtpZihcImVcIj09PW58fFwiRVwiPT09bil7Y29uc3Qgbj10LnN1YnN0cmluZyhlKTt0cnl7bD1MLnBhcnNlSW50KG4pfWNhdGNoKGUpe3Rocm93IGUgaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb24/bmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIkludmFsaWQgZXhwb25lbnQgXCIrbitcIiBpbiBzdHJpbmcgXCIrdCk6ZX1icmVha310aHJvdyBuZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK24rXCInIGF0IHBvc2l0aW9uIFwiK2UrXCIgaW4gc3RyaW5nIFwiK3QpfW89cn19bGV0IGE9aTtjb25zdCBjPXItby1sO2lmKDA9PT1jKWE9aTtlbHNlIGlmKGM+MCl7Y29uc3QgdD1SLlRFTi5wb3coYyk7YT1pLmRpdmlkZSh0KX1lbHNlIGlmKGM8MCl7Y29uc3QgdD1SLlRFTi5wb3coLWMpO2E9aS5tdWx0aXBseSh0KX1yZXR1cm4gcz9hLm5lZ2F0ZSgpOmF9c3RhdGljIGNyZWF0ZU5hTigpe3JldHVybiBuZXcgUihpLk5hTixpLk5hTil9c3RhdGljIGNvcHkodCl7cmV0dXJuIG5ldyBSKHQpfXN0YXRpYyBtYWduaXR1ZGUodCl7Y29uc3QgZT1NYXRoLmFicyh0KSxuPU1hdGgubG9nKGUpL01hdGgubG9nKDEwKTtsZXQgcz1NYXRoLnRydW5jKE1hdGguZmxvb3IobikpO3JldHVybiAxMCpNYXRoLnBvdygxMCxzKTw9ZSYmKHMrPTEpLHN9c3RhdGljIHN0cmluZ09mQ2hhcih0LGUpe2NvbnN0IG49bmV3IHc7Zm9yKGxldCBzPTA7czxlO3MrKyluLmFwcGVuZCh0KTtyZXR1cm4gbi50b1N0cmluZygpfWxlKHQpe3JldHVybiB0aGlzLl9oaTx0Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG88PXQuX2xvfWV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh0LGUpe2xldCBuPXRoaXMuYWJzKCkscz1SLm1hZ25pdHVkZShuLl9oaSk7Y29uc3QgaT1SLlRFTi5wb3cocyk7bj1uLmRpdmlkZShpKSxuLmd0KFIuVEVOKT8obj1uLmRpdmlkZShSLlRFTikscys9MSk6bi5sdChSLk9ORSkmJihuPW4ubXVsdGlwbHkoUi5URU4pLHMtPTEpO2NvbnN0IHI9cysxLG89bmV3IHcsbD1SLk1BWF9QUklOVF9ESUdJVFMtMTtmb3IobGV0IGU9MDtlPD1sO2UrKyl7dCYmZT09PXImJm8uYXBwZW5kKFwiLlwiKTtjb25zdCBzPU1hdGgudHJ1bmMobi5faGkpO2lmKHM8MClicmVhaztsZXQgaT0hMSxhPTA7cz45PyhpPSEwLGE9XCI5XCIpOmE9XCIwXCIrcyxvLmFwcGVuZChhKSxuPW4uc3VidHJhY3QoUi52YWx1ZU9mKHMpKS5tdWx0aXBseShSLlRFTiksaSYmbi5zZWxmQWRkKFIuVEVOKTtsZXQgYz0hMDtjb25zdCBoPVIubWFnbml0dWRlKG4uX2hpKTtpZihoPDAmJk1hdGguYWJzKGgpPj1sLWUmJihjPSExKSwhYylicmVha31yZXR1cm4gZVswXT1zLG8udG9TdHJpbmcoKX1zcXIoKXtyZXR1cm4gdGhpcy5tdWx0aXBseSh0aGlzKX1kb3VibGVWYWx1ZSgpe3JldHVybiB0aGlzLl9oaSt0aGlzLl9sb31zdWJ0cmFjdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKHQubmVnYXRlKCkpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCgtdCl9fWVxdWFscygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbz09PXQuX2xvfX1pc1plcm8oKXtyZXR1cm4gMD09PXRoaXMuX2hpJiYwPT09dGhpcy5fbG99c2VsZlN1YnRyYWN0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC10Ll9oaSwtdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLXQsMCl9fWdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKXtyZXR1cm4gdGhpcy5pc1plcm8oKT9cIjAuMFwiOnRoaXMuaXNOYU4oKT9cIk5hTiBcIjpudWxsfW1pbih0KXtyZXR1cm4gdGhpcy5sZSh0KT90aGlzOnR9c2VsZkRpdmlkZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZEaXZpZGUodC5faGksdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZEaXZpZGUodCwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsLGE9bnVsbCxjPW51bGw7cmV0dXJuIG89dGhpcy5faGkvdCxsPVIuU1BMSVQqbyxuPWwtbyxjPVIuU1BMSVQqdCxuPWwtbixzPW8tbixpPWMtdCxhPW8qdCxpPWMtaSxyPXQtaSxjPW4qaS1hK24qcitzKmkrcypyLGw9KHRoaXMuX2hpLWEtYyt0aGlzLl9sby1vKmUpL3QsYz1vK2wsdGhpcy5faGk9Yyx0aGlzLl9sbz1vLWMrbCx0aGlzfX1kdW1wKCl7cmV0dXJuXCJERDxcIit0aGlzLl9oaStcIiwgXCIrdGhpcy5fbG8rXCI+XCJ9ZGl2aWRlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsLG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsLGE9bnVsbDtyZXR1cm4gcj10aGlzLl9oaS90Ll9oaSxvPVIuU1BMSVQqcixlPW8tcixhPVIuU1BMSVQqdC5faGksZT1vLWUsbj1yLWUscz1hLXQuX2hpLGw9cip0Ll9oaSxzPWEtcyxpPXQuX2hpLXMsYT1lKnMtbCtlKmkrbipzK24qaSxvPSh0aGlzLl9oaS1sLWErdGhpcy5fbG8tcip0Ll9sbykvdC5faGksYT1yK28sbmV3IFIoYSxyLWErbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGkuaXNOYU4odCk/Ui5jcmVhdGVOYU4oKTpSLmNvcHkodGhpcykuc2VsZkRpdmlkZSh0LDApfX1nZSh0KXtyZXR1cm4gdGhpcy5faGk+dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPj10Ll9sb31wb3codCl7aWYoMD09PXQpcmV0dXJuIFIudmFsdWVPZigxKTtsZXQgZT1uZXcgUih0aGlzKSxuPVIudmFsdWVPZigxKSxzPU1hdGguYWJzKHQpO2lmKHM+MSlmb3IoO3M+MDspcyUyPT0xJiZuLnNlbGZNdWx0aXBseShlKSxzLz0yLHM+MCYmKGU9ZS5zcXIoKSk7ZWxzZSBuPWU7cmV0dXJuIHQ8MD9uLnJlY2lwcm9jYWwoKTpufWNlaWwoKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIFIuTmFOO2NvbnN0IHQ9TWF0aC5jZWlsKHRoaXMuX2hpKTtsZXQgZT0wO3JldHVybiB0PT09dGhpcy5faGkmJihlPU1hdGguY2VpbCh0aGlzLl9sbykpLG5ldyBSKHQsZSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5faGk8ZS5faGk/LTE6dGhpcy5faGk+ZS5faGk/MTp0aGlzLl9sbzxlLl9sbz8tMTp0aGlzLl9sbz5lLl9sbz8xOjB9cmludCgpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gdGhpcztyZXR1cm4gdGhpcy5hZGQoLjUpLmZsb29yKCl9c2V0VmFsdWUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluaXQodCksdGhpc31pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KHQpLHRoaXN9fW1heCh0KXtyZXR1cm4gdGhpcy5nZSh0KT90aGlzOnR9c3FydCgpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIFIudmFsdWVPZigwKTtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gUi5OYU47Y29uc3QgdD0xL01hdGguc3FydCh0aGlzLl9oaSksZT10aGlzLl9oaSp0LG49Ui52YWx1ZU9mKGUpLHM9dGhpcy5zdWJ0cmFjdChuLnNxcigpKS5faGkqKC41KnQpO3JldHVybiBuLmFkZChzKX1zZWxmQWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkFkZCh0Ll9oaSx0Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbCxuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsO3JldHVybiBzPXRoaXMuX2hpK3Qscj1zLXRoaXMuX2hpLGk9cy1yLGk9dC1yKyh0aGlzLl9oaS1pKSxvPWkrdGhpcy5fbG8sZT1zK28sbj1vKyhzLWUpLHRoaXMuX2hpPWUrbix0aGlzLl9sbz1uKyhlLXRoaXMuX2hpKSx0aGlzfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGwsYT1udWxsLGM9bnVsbDtvPXRoaXMuX2hpK3QsaT10aGlzLl9sbytlLGE9by10aGlzLl9oaSxjPWktdGhpcy5fbG8sbD1vLWEscj1pLWMsbD10LWErKHRoaXMuX2hpLWwpLHI9ZS1jKyh0aGlzLl9sby1yKSxhPWwraSxuPW8rYSxzPWErKG8tbiksYT1yK3M7Y29uc3QgaD1uK2EsdT1hKyhuLWgpO3JldHVybiB0aGlzLl9oaT1oLHRoaXMuX2xvPXUsdGhpc319c2VsZk11bHRpcGx5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHQuX2hpLHQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodCwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsO289Ui5TUExJVCp0aGlzLl9oaSxuPW8tdGhpcy5faGksbD1SLlNQTElUKnQsbj1vLW4scz10aGlzLl9oaS1uLGk9bC10LG89dGhpcy5faGkqdCxpPWwtaSxyPXQtaSxsPW4qaS1vK24qcitzKmkrcypyKyh0aGlzLl9oaSplK3RoaXMuX2xvKnQpO2NvbnN0IGE9bytsO249by1hO2NvbnN0IGM9bCtuO3JldHVybiB0aGlzLl9oaT1hLHRoaXMuX2xvPWMsdGhpc319c2VsZlNxcigpe3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0aGlzKX1mbG9vcigpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gUi5OYU47Y29uc3QgdD1NYXRoLmZsb29yKHRoaXMuX2hpKTtsZXQgZT0wO3JldHVybiB0PT09dGhpcy5faGkmJihlPU1hdGguZmxvb3IodGhpcy5fbG8pKSxuZXcgUih0LGUpfW5lZ2F0ZSgpe3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczpuZXcgUigtdGhpcy5faGksLXRoaXMuX2xvKX1jbG9uZSgpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIG51bGw7dGhyb3cgdH19bXVsdGlwbHkoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmlzTmFOKCk/Ui5jcmVhdGVOYU4oKTpSLmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBpLmlzTmFOKHQpP1IuY3JlYXRlTmFOKCk6Ui5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh0LDApfX1pc05hTigpe3JldHVybiBpLmlzTmFOKHRoaXMuX2hpKX1pbnRWYWx1ZSgpe3JldHVybiBNYXRoLnRydW5jKHRoaXMuX2hpKX10b1N0cmluZygpe2NvbnN0IHQ9Ui5tYWduaXR1ZGUodGhpcy5faGkpO3JldHVybiB0Pj0tMyYmdDw9MjA/dGhpcy50b1N0YW5kYXJkTm90YXRpb24oKTp0aGlzLnRvU2NpTm90YXRpb24oKX10b1N0YW5kYXJkTm90YXRpb24oKXtjb25zdCB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O2NvbnN0IGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMCxlKSxzPWVbMF0rMTtsZXQgaT1uO2lmKFwiLlwiPT09bi5jaGFyQXQoMCkpaT1cIjBcIituO2Vsc2UgaWYoczwwKWk9XCIwLlwiK1Iuc3RyaW5nT2ZDaGFyKFwiMFwiLC1zKStuO2Vsc2UgaWYoLTE9PT1uLmluZGV4T2YoXCIuXCIpKXtjb25zdCB0PXMtbi5sZW5ndGg7aT1uK1Iuc3RyaW5nT2ZDaGFyKFwiMFwiLHQpK1wiLjBcIn1yZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIraTppfXJlY2lwcm9jYWwoKXtsZXQgdD1udWxsLGU9bnVsbCxuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbDtpPTEvdGhpcy5faGkscj1SLlNQTElUKmksdD1yLWksbD1SLlNQTElUKnRoaXMuX2hpLHQ9ci10LGU9aS10LG49bC10aGlzLl9oaSxvPWkqdGhpcy5faGksbj1sLW4scz10aGlzLl9oaS1uLGw9dCpuLW8rdCpzK2UqbitlKnMscj0oMS1vLWwtaSp0aGlzLl9sbykvdGhpcy5faGk7Y29uc3QgYT1pK3I7cmV0dXJuIG5ldyBSKGEsaS1hK3IpfXRvU2NpTm90YXRpb24oKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBSLlNDSV9OT1RfWkVSTztjb25zdCB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O2NvbnN0IGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMSxlKSxzPVIuU0NJX05PVF9FWFBPTkVOVF9DSEFSK2VbMF07aWYoXCIwXCI9PT1uLmNoYXJBdCgwKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiRm91bmQgbGVhZGluZyB6ZXJvOiBcIituKTtsZXQgaT1cIlwiO24ubGVuZ3RoPjEmJihpPW4uc3Vic3RyaW5nKDEpKTtjb25zdCByPW4uY2hhckF0KDApK1wiLlwiK2k7cmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpP1wiLVwiK3IrczpyK3N9YWJzKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9SLk5hTjp0aGlzLmlzTmVnYXRpdmUoKT90aGlzLm5lZ2F0ZSgpOm5ldyBSKHRoaXMpfWlzUG9zaXRpdmUoKXtyZXR1cm4gdGhpcy5faGk+MHx8MD09PXRoaXMuX2hpJiZ0aGlzLl9sbz4wfWx0KHQpe3JldHVybiB0aGlzLl9oaTx0Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG88dC5fbG99YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gUi5jb3B5KHRoaXMpLnNlbGZBZGQodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIFIuY29weSh0aGlzKS5zZWxmQWRkKHQpfX1pbml0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2hpPXQsdGhpcy5fbG89MH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faGk9dC5faGksdGhpcy5fbG89dC5fbG99fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2hpPXQsdGhpcy5fbG89ZX19Z3QodCl7cmV0dXJuIHRoaXMuX2hpPnQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbz50Ll9sb31pc05lZ2F0aXZlKCl7cmV0dXJuIHRoaXMuX2hpPDB8fDA9PT10aGlzLl9oaSYmdGhpcy5fbG88MH10cnVuYygpe3JldHVybiB0aGlzLmlzTmFOKCk/Ui5OYU46dGhpcy5pc1Bvc2l0aXZlKCk/dGhpcy5mbG9vcigpOnRoaXMuY2VpbCgpfXNpZ251bSgpe3JldHVybiB0aGlzLl9oaT4wPzE6dGhpcy5faGk8MD8tMTp0aGlzLl9sbz4wPzE6dGhpcy5fbG88MD8tMTowfWdldENsYXNzKCl7cmV0dXJuIFJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2EscixvXX19Ui5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9oaT0wLHRoaXMuX2xvPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Ui5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFIucGFyc2UodCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodCxlKX19LFIuUEk9bmV3IFIoMy4xNDE1OTI2NTM1ODk3OTMsMTIyNDY0Njc5OTE0NzM1MzJlLTMyKSxSLlRXT19QST1uZXcgUig2LjI4MzE4NTMwNzE3OTU4NiwyNDQ5MjkzNTk4Mjk0NzA2NGUtMzIpLFIuUElfMj1uZXcgUigxLjU3MDc5NjMyNjc5NDg5NjYsNjEyMzIzMzk5NTczNjc2NmUtMzIpLFIuRT1uZXcgUigyLjcxODI4MTgyODQ1OTA0NSwxNDQ1NjQ2ODkxNzI5MjUwMmUtMzIpLFIuTmFOPW5ldyBSKGkuTmFOLGkuTmFOKSxSLkVQUz0xMjMyNTk1MTY0NDA3ODNlLTQ2LFIuU1BMSVQ9MTM0MjE3NzI5LFIuTUFYX1BSSU5UX0RJR0lUUz0zMixSLlRFTj1SLnZhbHVlT2YoMTApLFIuT05FPVIudmFsdWVPZigxKSxSLlNDSV9OT1RfRVhQT05FTlRfQ0hBUj1cIkVcIixSLlNDSV9OT1RfWkVSTz1cIjAuMEUwXCI7Y2xhc3MgUHtjb25zdHJ1Y3Rvcigpe1AuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb3JpZW50YXRpb25JbmRleCh0LGUsbil7Y29uc3Qgcz1QLm9yaWVudGF0aW9uSW5kZXhGaWx0ZXIodCxlLG4pO2lmKHM8PTEpcmV0dXJuIHM7Y29uc3QgaT1SLnZhbHVlT2YoZS54KS5zZWxmQWRkKC10LngpLHI9Ui52YWx1ZU9mKGUueSkuc2VsZkFkZCgtdC55KSxvPVIudmFsdWVPZihuLngpLnNlbGZBZGQoLWUueCksbD1SLnZhbHVlT2Yobi55KS5zZWxmQWRkKC1lLnkpO3JldHVybiBpLnNlbGZNdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoci5zZWxmTXVsdGlwbHkobykpLnNpZ251bSgpfXN0YXRpYyBzaWduT2ZEZXQyeDIoKXtpZihhcmd1bWVudHNbM11pbnN0YW5jZW9mIFImJmFyZ3VtZW50c1syXWluc3RhbmNlb2YgUiYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiB0Lm11bHRpcGx5KHMpLnNlbGZTdWJ0cmFjdChlLm11bHRpcGx5KG4pKS5zaWdudW0oKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzNdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPVIudmFsdWVPZih0KSxyPVIudmFsdWVPZihlKSxvPVIudmFsdWVPZihuKSxsPVIudmFsdWVPZihzKTtyZXR1cm4gaS5tdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoci5tdWx0aXBseShvKSkuc2lnbnVtKCl9fXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1SLnZhbHVlT2Yocy55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkpLHI9Ui52YWx1ZU9mKHMueCkuc2VsZlN1YnRyYWN0KG4ueCkuc2VsZk11bHRpcGx5KFIudmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxvPWkuc3VidHJhY3QociksbD1SLnZhbHVlT2Yocy54KS5zZWxmU3VidHJhY3Qobi54KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KG4ueSkpLGE9Ui52YWx1ZU9mKHMueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KFIudmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChuLngpKSxjPWwuc3VidHJhY3QoYSkuc2VsZkRpdmlkZShvKS5kb3VibGVWYWx1ZSgpLGg9Ui52YWx1ZU9mKHQueCkuc2VsZkFkZChSLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoYykpLmRvdWJsZVZhbHVlKCksdT1SLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KG4ueSkpLGQ9Ui52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkuc2VsZk11bHRpcGx5KFIudmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChuLngpKSxfPXUuc3VidHJhY3QoZCkuc2VsZkRpdmlkZShvKS5kb3VibGVWYWx1ZSgpLGY9Ui52YWx1ZU9mKG4ueSkuc2VsZkFkZChSLnZhbHVlT2Yocy55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoXykpLmRvdWJsZVZhbHVlKCk7cmV0dXJuIG5ldyBnKGgsZil9c3RhdGljIG9yaWVudGF0aW9uSW5kZXhGaWx0ZXIodCxlLG4pe2xldCBzPW51bGw7Y29uc3QgaT0odC54LW4ueCkqKGUueS1uLnkpLHI9KHQueS1uLnkpKihlLngtbi54KSxvPWktcjtpZihpPjApe2lmKHI8PTApcmV0dXJuIFAuc2lnbnVtKG8pO3M9aStyfWVsc2V7aWYoIShpPDApKXJldHVybiBQLnNpZ251bShvKTtpZihyPj0wKXJldHVybiBQLnNpZ251bShvKTtzPS1pLXJ9Y29uc3QgbD1QLkRQX1NBRkVfRVBTSUxPTipzO3JldHVybiBvPj1sfHwtbz49bD9QLnNpZ251bShvKToyfXN0YXRpYyBzaWdudW0odCl7cmV0dXJuIHQ+MD8xOnQ8MD8tMTowfWdldENsYXNzKCl7cmV0dXJuIFB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVAuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxQLkRQX1NBRkVfRVBTSUxPTj0xZS0xNTtjbGFzcyB2e2NvbnN0cnVjdG9yKCl7di5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbmRleCh0LGUsbil7cmV0dXJuIFAub3JpZW50YXRpb25JbmRleCh0LGUsbil9c3RhdGljIGlzQ0NXKHQpe2NvbnN0IGU9dC5sZW5ndGgtMTtpZihlPDMpdGhyb3cgbmV3IG4oXCJSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFwiKTtsZXQgcz10WzBdLGk9MDtmb3IobGV0IG49MTtuPD1lO24rKyl7Y29uc3QgZT10W25dO2UueT5zLnkmJihzPWUsaT1uKX1sZXQgcj1pO2Rve3ItPTEscjwwJiYocj1lKX13aGlsZSh0W3JdLmVxdWFsczJEKHMpJiZyIT09aSk7bGV0IG89aTtkb3tvPShvKzEpJWV9d2hpbGUodFtvXS5lcXVhbHMyRChzKSYmbyE9PWkpO2NvbnN0IGw9dFtyXSxhPXRbb107aWYobC5lcXVhbHMyRChzKXx8YS5lcXVhbHMyRChzKXx8bC5lcXVhbHMyRChhKSlyZXR1cm4hMTtjb25zdCBjPXYuaW5kZXgobCxzLGEpO2xldCBoPW51bGw7cmV0dXJuIGg9MD09PWM/bC54PmEueDpjPjAsaH1nZXRDbGFzcygpe3JldHVybiB2fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBPKCl7fXYuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSx2LkNMT0NLV0lTRT0tMSx2LlJJR0hUPXYuQ0xPQ0tXSVNFLHYuQ09VTlRFUkNMT0NLV0lTRT0xLHYuTEVGVD12LkNPVU5URVJDTE9DS1dJU0Usdi5DT0xMSU5FQVI9MCx2LlNUUkFJR0hUPXYuQ09MTElORUFSLE8uYXJyYXljb3B5PSh0LGUsbixzLGkpPT57bGV0IHI9MDtmb3IobGV0IG89ZTtvPGUraTtvKyspbltzK3JdPXRbb10scisrfSxPLmdldFByb3BlcnR5PXQ9Pih7XCJsaW5lLnNlcGFyYXRvclwiOlwiXFxuXCJ9W3RdKTtjbGFzcyBie2NvbnN0cnVjdG9yKCl7Yi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3Qgcj10LnktZS55LG89ZS54LXQueCxsPXQueCplLnktZS54KnQueSxhPW4ueS1zLnksYz1zLngtbi54LGg9bi54KnMueS1zLngqbi55LHU9cipjLWEqbyxkPShvKmgtYypsKS91LF89KGEqbC1yKmgpL3U7aWYoaS5pc05hTihkKXx8aS5pc0luZmluaXRlKGQpfHxpLmlzTmFOKF8pfHxpLmlzSW5maW5pdGUoXykpdGhyb3cgbmV3IFM7cmV0dXJuIG5ldyBnKGQsXyl9Z2V0WSgpe2NvbnN0IHQ9dGhpcy55L3RoaXMudztpZihpLmlzTmFOKHQpfHxpLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IFM7cmV0dXJuIHR9Z2V0WCgpe2NvbnN0IHQ9dGhpcy54L3RoaXMudztpZihpLmlzTmFOKHQpfHxpLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IFM7cmV0dXJuIHR9Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9bmV3IGc7cmV0dXJuIHQueD10aGlzLmdldFgoKSx0Lnk9dGhpcy5nZXRZKCksdH1nZXRDbGFzcygpe3JldHVybiBifWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1iLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMudz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMueD0wLHRoaXMueT0wLHRoaXMudz0xO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLnc9MX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLnc9MX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBiKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dC55KmUudy1lLnkqdC53LHRoaXMueT1lLngqdC53LXQueCplLncsdGhpcy53PXQueCplLnktZS54KnQueX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dC55LWUueSx0aGlzLnk9ZS54LXQueCx0aGlzLnc9dC54KmUueS1lLngqdC55fX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLnc9bn1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPXQueS1lLnkscj1lLngtdC54LG89dC54KmUueS1lLngqdC55LGw9bi55LXMueSxhPXMueC1uLngsYz1uLngqcy55LXMueCpuLnk7dGhpcy54PXIqYy1hKm8sdGhpcy55PWwqby1pKmMsdGhpcy53PWkqYS1sKnJ9fTtjbGFzcyBNe2NvbnN0cnVjdG9yKCl7TS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBsb2cxMCh0KXtjb25zdCBlPU1hdGgubG9nKHQpO3JldHVybiBpLmlzSW5maW5pdGUoZSl8fGkuaXNOYU4oZSk/ZTplL00uTE9HXzEwfXN0YXRpYyBtaW4odCxlLG4scyl7bGV0IGk9dDtyZXR1cm4gZTxpJiYoaT1lKSxuPGkmJihpPW4pLHM8aSYmKGk9cyksaX1zdGF0aWMgY2xhbXAoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdDxlP2U6dD5uP246dH1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdDxlP2U6dD5uP246dH19c3RhdGljIHdyYXAodCxlKXtyZXR1cm4gdDwwP2UtIC10JWU6dCVlfXN0YXRpYyBtYXgoKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bGV0IHM9dDtyZXR1cm4gZT5zJiYocz1lKSxuPnMmJihzPW4pLHN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2xldCBpPXQ7cmV0dXJuIGU+aSYmKGk9ZSksbj5pJiYoaT1uKSxzPmkmJihpPXMpLGl9fXN0YXRpYyBhdmVyYWdlKHQsZSl7cmV0dXJuKHQrZSkvMn1nZXRDbGFzcygpe3JldHVybiBNfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1NLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sTS5MT0dfMTA9TWF0aC5sb2coMTApO2NsYXNzIER7Y29uc3RydWN0b3IoKXtELmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNlZ21lbnRUb1NlZ21lbnQodCxlLG4scyl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIEQucG9pbnRUb1NlZ21lbnQodCxuLHMpO2lmKG4uZXF1YWxzKHMpKXJldHVybiBELnBvaW50VG9TZWdtZW50KHMsdCxlKTtsZXQgaT0hMTtpZihOLmludGVyc2VjdHModCxlLG4scykpe2NvbnN0IHI9KGUueC10LngpKihzLnktbi55KS0oZS55LXQueSkqKHMueC1uLngpO2lmKDA9PT1yKWk9ITA7ZWxzZXtjb25zdCBvPSh0Lnktbi55KSoocy54LW4ueCktKHQueC1uLngpKihzLnktbi55KSxsPSgodC55LW4ueSkqKGUueC10LngpLSh0Lngtbi54KSooZS55LXQueSkpL3IsYT1vL3I7KGE8MHx8YT4xfHxsPDB8fGw+MSkmJihpPSEwKX19ZWxzZSBpPSEwO3JldHVybiBpP00ubWluKEQucG9pbnRUb1NlZ21lbnQodCxuLHMpLEQucG9pbnRUb1NlZ21lbnQoZSxuLHMpLEQucG9pbnRUb1NlZ21lbnQobix0LGUpLEQucG9pbnRUb1NlZ21lbnQocyx0LGUpKTowfXN0YXRpYyBwb2ludFRvU2VnbWVudCh0LGUsbil7aWYoZS54PT09bi54JiZlLnk9PT1uLnkpcmV0dXJuIHQuZGlzdGFuY2UoZSk7Y29uc3Qgcz0obi54LWUueCkqKG4ueC1lLngpKyhuLnktZS55KSoobi55LWUueSksaT0oKHQueC1lLngpKihuLngtZS54KSsodC55LWUueSkqKG4ueS1lLnkpKS9zO2lmKGk8PTApcmV0dXJuIHQuZGlzdGFuY2UoZSk7aWYoaT49MSlyZXR1cm4gdC5kaXN0YW5jZShuKTtjb25zdCByPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL3M7cmV0dXJuIE1hdGguYWJzKHIpKk1hdGguc3FydChzKX1zdGF0aWMgcG9pbnRUb0xpbmVQZXJwZW5kaWN1bGFyKHQsZSxuKXtjb25zdCBzPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxpPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL3M7cmV0dXJuIE1hdGguYWJzKGkpKk1hdGguc3FydChzKX1zdGF0aWMgcG9pbnRUb1NlZ21lbnRTdHJpbmcodCxlKXtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IG4oXCJMaW5lIGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmVydGV4XCIpO2xldCBzPXQuZGlzdGFuY2UoZVswXSk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aC0xO24rKyl7Y29uc3QgaT1ELnBvaW50VG9TZWdtZW50KHQsZVtuXSxlW24rMV0pO2k8cyYmKHM9aSl9cmV0dXJuIHN9Z2V0Q2xhc3MoKXtyZXR1cm4gRH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEF7Y29uc3RydWN0b3IoKXtBLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0T3JkaW5hdGUodCxlLG4pe31zaXplKCl7fWdldE9yZGluYXRlKHQsZSl7fWdldENvb3JkaW5hdGUoKXt9Z2V0Q29vcmRpbmF0ZUNvcHkodCl7fWdldERpbWVuc2lvbigpe31nZXRYKHQpe31leHBhbmRFbnZlbG9wZSh0KXt9Y29weSgpe31nZXRZKHQpe310b0Nvb3JkaW5hdGVBcnJheSgpe31nZXRDbGFzcygpe3JldHVybiBBfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19QS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LEEuWD0wLEEuWT0xLEEuWj0yLEEuTT0zO2NsYXNzIEZ7Y29uc3RydWN0b3IoKXtGLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlKCl7MT09PWFyZ3VtZW50cy5sZW5ndGgmJihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5fHxfKGFyZ3VtZW50c1swXSxBKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gRn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Ri5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEd7Y29uc3RydWN0b3IoKXtHLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe31nZXRDbGFzcygpe3JldHVybiBHfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1HLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgcXtjb25zdHJ1Y3Rvcigpe3EuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0dlb21ldHJ5Q29sbGVjdGlvbigpe3JldHVybiB0aGlzLmdldFR5cGVDb2RlKCk9PT1xLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTn1nZXRGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX2ZhY3Rvcnl9Z2V0R2VvbWV0cnlOKHQpe3JldHVybiB0aGlzfWdldEFyZWEoKXtyZXR1cm4gMH1pc1JlY3RhbmdsZSgpe3JldHVybiExfWVxdWFscygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG51bGwhPT10JiZ0aGlzLmVxdWFsc1RvcG8odCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKCEodCBpbnN0YW5jZW9mIHEpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5lcXVhbHNFeGFjdChlKX19ZXF1YWxzRXhhY3QodCl7cmV0dXJuIHRoaXM9PT10fHx0aGlzLmVxdWFsc0V4YWN0KHQsMCl9Z2VvbWV0cnlDaGFuZ2VkKCl7dGhpcy5hcHBseShxLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcil9Z2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl7dGhpcy5fZW52ZWxvcGU9bnVsbH1lcXVhbHNOb3JtKHQpe3JldHVybiBudWxsIT09dCYmdGhpcy5ub3JtKCkuZXF1YWxzRXhhY3QodC5ub3JtKCkpfWdldExlbmd0aCgpe3JldHVybiAwfWdldE51bUdlb21ldHJpZXMoKXtyZXR1cm4gMX1jb21wYXJlVG8oKXtsZXQgdDtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT1hcmd1bWVudHNbMF07cmV0dXJuIHQ9ZSx0aGlzLmdldFR5cGVDb2RlKCkhPT10LmdldFR5cGVDb2RlKCk/dGhpcy5nZXRUeXBlQ29kZSgpLXQuZ2V0VHlwZUNvZGUoKTp0aGlzLmlzRW1wdHkoKSYmdC5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTp0LmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKGUpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gdD1lLHRoaXMuZ2V0VHlwZUNvZGUoKSE9PXQuZ2V0VHlwZUNvZGUoKT90aGlzLmdldFR5cGVDb2RlKCktdC5nZXRUeXBlQ29kZSgpOnRoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOnQuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3MoZSxuKX19Z2V0VXNlckRhdGEoKXtyZXR1cm4gdGhpcy5fdXNlckRhdGF9Z2V0U1JJRCgpe3JldHVybiB0aGlzLl9TUklEfWdldEVudmVsb3BlKCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkodGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkpfWNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpe2lmKHQuZ2V0VHlwZUNvZGUoKT09PXEuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OKXRocm93IG5ldyBuKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpfWVxdWFsKHQsZSxuKXtyZXR1cm4gMD09PW4/dC5lcXVhbHMoZSk6dC5kaXN0YW5jZShlKTw9bn1ub3JtKCl7Y29uc3QgdD10aGlzLmNvcHkoKTtyZXR1cm4gdC5ub3JtYWxpemUoKSx0fWdldFByZWNpc2lvbk1vZGVsKCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKX1nZXRFbnZlbG9wZUludGVybmFsKCl7cmV0dXJuIG51bGw9PT10aGlzLl9lbnZlbG9wZSYmKHRoaXMuX2VudmVsb3BlPXRoaXMuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKSksbmV3IE4odGhpcy5fZW52ZWxvcGUpfXNldFNSSUQodCl7dGhpcy5fU1JJRD10fXNldFVzZXJEYXRhKHQpe3RoaXMuX3VzZXJEYXRhPXR9Y29tcGFyZSh0LGUpe2NvbnN0IG49dC5pdGVyYXRvcigpLHM9ZS5pdGVyYXRvcigpO2Zvcig7bi5oYXNOZXh0KCkmJnMuaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxlPXMubmV4dCgpLGk9dC5jb21wYXJlVG8oZSk7aWYoMCE9PWkpcmV0dXJuIGl9cmV0dXJuIG4uaGFzTmV4dCgpPzE6cy5oYXNOZXh0KCk/LTE6MH1oYXNoQ29kZSgpe3JldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5oYXNoQ29kZSgpfWlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkKCl7cmV0dXJuIHRoaXMuZ2V0VHlwZUNvZGUoKT09PXEuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OfHx0aGlzLmdldFR5cGVDb2RlKCk9PT1xLlRZUEVDT0RFX01VTFRJUE9JTlR8fHRoaXMuZ2V0VHlwZUNvZGUoKT09PXEuVFlQRUNPREVfTVVMVElMSU5FU1RSSU5HfHx0aGlzLmdldFR5cGVDb2RlKCk9PT1xLlRZUEVDT0RFX01VTFRJUE9MWUdPTn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbyxyLGFdfWdldENsYXNzKCl7cmV0dXJuIHF9c3RhdGljIGhhc05vbkVtcHR5RWxlbWVudHModCl7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIXRbZV0uaXNFbXB0eSgpKXJldHVybiEwO3JldHVybiExfXN0YXRpYyBoYXNOdWxsRWxlbWVudHModCl7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYobnVsbD09PXRbZV0pcmV0dXJuITA7cmV0dXJuITF9fXEuY29uc3RydWN0b3JfPWZ1bmN0aW9uKHQpe3QmJih0aGlzLl9lbnZlbG9wZT1udWxsLHRoaXMuX3VzZXJEYXRhPW51bGwsdGhpcy5fZmFjdG9yeT10LHRoaXMuX1NSSUQ9dC5nZXRTUklEKCkpfSxxLnNlcmlhbFZlcnNpb25VSUQ9MHg3OTllYTQ2NTIyODU0YzAwLHEuVFlQRUNPREVfUE9JTlQ9MCxxLlRZUEVDT0RFX01VTFRJUE9JTlQ9MSxxLlRZUEVDT0RFX0xJTkVTVFJJTkc9MixxLlRZUEVDT0RFX0xJTkVBUlJJTkc9MyxxLlRZUEVDT0RFX01VTFRJTElORVNUUklORz00LHEuVFlQRUNPREVfUE9MWUdPTj01LHEuVFlQRUNPREVfTVVMVElQT0xZR09OPTYscS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT049NyxxLlRZUEVOQU1FX1BPSU5UPVwiUG9pbnRcIixxLlRZUEVOQU1FX01VTFRJUE9JTlQ9XCJNdWx0aVBvaW50XCIscS5UWVBFTkFNRV9MSU5FU1RSSU5HPVwiTGluZVN0cmluZ1wiLHEuVFlQRU5BTUVfTElORUFSUklORz1cIkxpbmVhclJpbmdcIixxLlRZUEVOQU1FX01VTFRJTElORVNUUklORz1cIk11bHRpTGluZVN0cmluZ1wiLHEuVFlQRU5BTUVfUE9MWUdPTj1cIlBvbHlnb25cIixxLlRZUEVOQU1FX01VTFRJUE9MWUdPTj1cIk11bHRpUG9seWdvblwiLHEuVFlQRU5BTUVfR0VPTUVUUllDT0xMRUNUSU9OPVwiR2VvbWV0cnlDb2xsZWN0aW9uXCIscS5nZW9tZXRyeUNoYW5nZWRGaWx0ZXI9e2dldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX0sZmlsdGVyKHQpe3QuZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl9fTtjbGFzcyBCe2NvbnN0cnVjdG9yKCl7Qi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gQn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Qi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFZ7Y29uc3RydWN0b3IoKXtWLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbkJvdW5kYXJ5KHQpe31nZXRDbGFzcygpe3JldHVybiBWfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyB6e2NvbnN0cnVjdG9yKCl7ei5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdCUyPT0xfWdldENsYXNzKCl7cmV0dXJuIHp9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1ZdfX16LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgWXtjb25zdHJ1Y3Rvcigpe1kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0luQm91bmRhcnkodCl7cmV0dXJuIHQ+MH1nZXRDbGFzcygpe3JldHVybiBZfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltWXX19WS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFV7Y29uc3RydWN0b3IoKXtVLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0PjF9Z2V0Q2xhc3MoKXtyZXR1cm4gVX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVl19fVUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBre2NvbnN0cnVjdG9yKCl7ay5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gMT09PXR9Z2V0Q2xhc3MoKXtyZXR1cm4ga31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVl19fWsuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxWLk1vZDJCb3VuZGFyeU5vZGVSdWxlPXosVi5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9WSxWLk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPVUsVi5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPWssVi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFYuTU9EMl9CT1VOREFSWV9SVUxFPW5ldyB6LFYuRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgWSxWLk1VTFRJVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IFUsVi5NT05PVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IGssVi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEU9Vi5NT0QyX0JPVU5EQVJZX1JVTEU7Y2xhc3MgWHtjb25zdHJ1Y3Rvcigpe1guY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNSaW5nKHQpe3JldHVybiEodC5sZW5ndGg8NCkmJiEhdFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX1zdGF0aWMgcHROb3RJbkxpc3QodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7Y29uc3Qgcz10W25dO2lmKFguaW5kZXhPZihzLGUpPDApcmV0dXJuIHN9cmV0dXJuIG51bGx9c3RhdGljIHNjcm9sbCh0LGUpe2NvbnN0IG49WC5pbmRleE9mKGUsdCk7aWYobjwwKXJldHVybiBudWxsO2NvbnN0IHM9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO08uYXJyYXljb3B5KHQsbixzLDAsdC5sZW5ndGgtbiksTy5hcnJheWNvcHkodCwwLHMsdC5sZW5ndGgtbixuKSxPLmFycmF5Y29weShzLDAsdCwwLHQubGVuZ3RoKX1zdGF0aWMgZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlW25dKSlyZXR1cm4hMTtyZXR1cm4hMH1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09PXR8fG51bGw9PT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspaWYoMCE9PW4uY29tcGFyZSh0W3NdLGVbc10pKXJldHVybiExO3JldHVybiEwfX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7Y29uc3Qgbj1uZXcgSTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyllLmludGVyc2VjdHModFtzXSkmJm4uYWRkKHRbc10sITApO3JldHVybiBuLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIGhhc1JlcGVhdGVkUG9pbnRzKHQpe2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZS0xXS5lcXVhbHModFtlXSkpcmV0dXJuITA7cmV0dXJuITF9c3RhdGljIHJlbW92ZVJlcGVhdGVkUG9pbnRzKHQpe2lmKCFYLmhhc1JlcGVhdGVkUG9pbnRzKHQpKXJldHVybiB0O3JldHVybiBuZXcgSSh0LCExKS50b0Nvb3JkaW5hdGVBcnJheSgpfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5sZW5ndGgtMSxuPU1hdGgudHJ1bmMoZS8yKTtmb3IobGV0IHM9MDtzPD1uO3MrKyl7Y29uc3Qgbj10W3NdO3Rbc109dFtlLXNdLHRbZS1zXT1ufX1zdGF0aWMgcmVtb3ZlTnVsbCh0KXtsZXQgZT0wO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKW51bGwhPT10W25dJiZlKys7Y29uc3Qgbj1uZXcgQXJyYXkoZSkuZmlsbChudWxsKTtpZigwPT09ZSlyZXR1cm4gbjtsZXQgcz0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKW51bGwhPT10W2VdJiYobltzKytdPXRbZV0pO3JldHVybiBufXN0YXRpYyBjb3B5RGVlcCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllW25dPW5ldyBnKHRbbl0pO3JldHVybiBlfWlmKDU9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XTtmb3IobGV0IHI9MDtyPGk7cisrKW5bcytyXT1uZXcgZyh0W2Urcl0pfX1zdGF0aWMgaXNFcXVhbFJldmVyc2VkKHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHM9dFtuXSxpPWVbdC5sZW5ndGgtbi0xXTtpZigwIT09cy5jb21wYXJlVG8oaSkpcmV0dXJuITF9cmV0dXJuITB9c3RhdGljIGVudmVsb3BlKHQpe2NvbnN0IGU9bmV3IE47Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZS5leHBhbmRUb0luY2x1ZGUodFtuXSk7cmV0dXJuIGV9c3RhdGljIHRvQ29vcmRpbmF0ZUFycmF5KHQpe3JldHVybiB0LnRvQXJyYXkoWC5jb29yZEFycmF5VHlwZSl9c3RhdGljIGF0TGVhc3ROQ29vcmRpbmF0ZXNPck5vdGhpbmcodCxlKXtyZXR1cm4gZS5sZW5ndGg+PXQ/ZTpbXX1zdGF0aWMgaW5kZXhPZih0LGUpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWlmKHQuZXF1YWxzKGVbbl0pKXJldHVybiBuO3JldHVybi0xfXN0YXRpYyBpbmNyZWFzaW5nRGlyZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8TWF0aC50cnVuYyh0Lmxlbmd0aC8yKTtlKyspe2NvbnN0IG49dC5sZW5ndGgtMS1lLHM9dFtlXS5jb21wYXJlVG8odFtuXSk7aWYoMCE9PXMpcmV0dXJuIHN9cmV0dXJuIDF9c3RhdGljIGNvbXBhcmUodCxlKXtsZXQgbj0wO2Zvcig7bjx0Lmxlbmd0aCYmbjxlLmxlbmd0aDspe2NvbnN0IHM9dFtuXS5jb21wYXJlVG8oZVtuXSk7aWYoMCE9PXMpcmV0dXJuIHM7bisrfXJldHVybiBuPGUubGVuZ3RoPy0xOm48dC5sZW5ndGg/MTowfXN0YXRpYyBtaW5Db29yZGluYXRlKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspKG51bGw9PT1lfHxlLmNvbXBhcmVUbyh0W25dKT4wKSYmKGU9dFtuXSk7cmV0dXJuIGV9c3RhdGljIGV4dHJhY3QodCxlLG4pe2U9TS5jbGFtcChlLDAsdC5sZW5ndGgpO2xldCBzPShuPU0uY2xhbXAobiwtMSx0Lmxlbmd0aCkpLWUrMTtuPDAmJihzPTApLGU+PXQubGVuZ3RoJiYocz0wKSxuPGUmJihzPTApO2NvbnN0IGk9bmV3IEFycmF5KHMpLmZpbGwobnVsbCk7aWYoMD09PXMpcmV0dXJuIGk7bGV0IHI9MDtmb3IobGV0IHM9ZTtzPD1uO3MrKylpW3IrK109dFtzXTtyZXR1cm4gaX1nZXRDbGFzcygpe3JldHVybiBYfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBIe2NvbnN0cnVjdG9yKCl7SC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO3JldHVybiBYLmNvbXBhcmUobixzKX1nZXRDbGFzcygpe3JldHVybiBIfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19SC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFd7Y29uc3RydWN0b3IoKXtXLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7aWYobi5sZW5ndGg8cy5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+cy5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO2NvbnN0IGk9WC5jb21wYXJlKG4scyk7cmV0dXJuIFguaXNFcXVhbFJldmVyc2VkKG4scyk/MDppfU9MRGNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO2lmKG4ubGVuZ3RoPHMubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPnMubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDtjb25zdCBpPVguaW5jcmVhc2luZ0RpcmVjdGlvbihuKSxyPVguaW5jcmVhc2luZ0RpcmVjdGlvbihzKTtsZXQgbz1pPjA/MDpuLmxlbmd0aC0xLGw9cj4wPzA6bi5sZW5ndGgtMTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3QgdD1uW29dLmNvbXBhcmVUbyhzW2xdKTtpZigwIT09dClyZXR1cm4gdDtvKz1pLGwrPXJ9cmV0dXJuIDB9Z2V0Q2xhc3MoKXtyZXR1cm4gV31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fWZ1bmN0aW9uIGooKXt9ZnVuY3Rpb24gSygpe31mdW5jdGlvbiBaKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIFEoKXt9ZnVuY3Rpb24gSigpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1XLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sWC5Gb3J3YXJkQ29tcGFyYXRvcj1ILFguQmlkaXJlY3Rpb25hbENvbXBhcmF0b3I9VyxYLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sWC5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxqLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt9LGoucHJvdG90eXBlLnB1dD1mdW5jdGlvbigpe30sai5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe30sai5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7fSxqLnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe30sSy5wcm90b3R5cGU9bmV3IGosWi5wcm90b3R5cGU9bmV3IEVycm9yLFoucHJvdG90eXBlLm5hbWU9XCJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRcIixRLnByb3RvdHlwZT1uZXcgZixRLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbigpe30sSi5wcm90b3R5cGU9bmV3IFEsSi5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl7aWYodGhpcy5hcnJheV9bZV09PT10KXJldHVybiEwfXJldHVybiExfSxKLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIXRoaXMuY29udGFpbnModCkmJih0aGlzLmFycmF5Xy5wdXNoKHQpLCEwKX0sSi5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sSi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBafSxKLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sSi5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxKLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Y29uc3QgdD1bXTtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LEoucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyAkKHRoaXMpfTtjb25zdCAkPWZ1bmN0aW9uKHQpe3RoaXMuaGFzaFNldF89dCx0aGlzLnBvc2l0aW9uXz0wfTskLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLmhhc2hTZXRfLnNpemUoKSl0aHJvdyBuZXcgeTtyZXR1cm4gdGhpcy5oYXNoU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK119LCQucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy5oYXNoU2V0Xy5zaXplKCl9LCQucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IG5ldyBafTtmdW5jdGlvbiB0dCh0KXtyZXR1cm4gbnVsbD09dD8wOnQuY29sb3J9ZnVuY3Rpb24gZXQodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnBhcmVudH1mdW5jdGlvbiBudCh0LGUpe251bGwhPT10JiYodC5jb2xvcj1lKX1mdW5jdGlvbiBzdCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQubGVmdH1mdW5jdGlvbiBpdCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucmlnaHR9ZnVuY3Rpb24gcnQoKXt0aGlzLnJvb3RfPW51bGwsdGhpcy5zaXplXz0wfXJ0LnByb3RvdHlwZT1uZXcgSyxydC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnJvb3RfO251bGwhPT1lOyl7dmFyIG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKG48MCllPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4gZS52YWx1ZTtlPWUucmlnaHR9fXJldHVybiBudWxsfSxydC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXRoaXMucm9vdF8pcmV0dXJuIHRoaXMucm9vdF89e2tleTp0LHZhbHVlOmUsbGVmdDpudWxsLHJpZ2h0Om51bGwscGFyZW50Om51bGwsY29sb3I6MCxnZXRWYWx1ZSgpe3JldHVybiB0aGlzLnZhbHVlfSxnZXRLZXkoKXtyZXR1cm4gdGhpcy5rZXl9fSx0aGlzLnNpemVfPTEsbnVsbDt2YXIgbixzLGk9dGhpcy5yb290Xztkb3tpZihuPWksKHM9dC5jb21wYXJlVG8oaS5rZXkpKTwwKWk9aS5sZWZ0O2Vsc2V7aWYoIShzPjApKXt2YXIgcj1pLnZhbHVlO3JldHVybiBpLnZhbHVlPWUscn1pPWkucmlnaHR9fXdoaWxlKG51bGwhPT1pKTt2YXIgbz17a2V5OnQsbGVmdDpudWxsLHJpZ2h0Om51bGwsdmFsdWU6ZSxwYXJlbnQ6bixjb2xvcjowLGdldFZhbHVlKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleSgpe3JldHVybiB0aGlzLmtleX19O3JldHVybiBzPDA/bi5sZWZ0PW86bi5yaWdodD1vLHRoaXMuZml4QWZ0ZXJJbnNlcnRpb24obyksdGhpcy5zaXplXysrLG51bGx9LHJ0LnByb3RvdHlwZS5maXhBZnRlckluc2VydGlvbj1mdW5jdGlvbih0KXtsZXQgZTtmb3IodC5jb2xvcj0xO251bGwhPXQmJnQhPT10aGlzLnJvb3RfJiYxPT09dC5wYXJlbnQuY29sb3I7KWV0KHQpPT09c3QoZXQoZXQodCkpKT8oZT1pdChldChldCh0KSkpLDE9PT10dChlKT8obnQoZXQodCksMCksbnQoZSwwKSxudChldChldCh0KSksMSksdD1ldChldCh0KSkpOih0PT09aXQoZXQodCkpJiYodD1ldCh0KSx0aGlzLnJvdGF0ZUxlZnQodCkpLG50KGV0KHQpLDApLG50KGV0KGV0KHQpKSwxKSx0aGlzLnJvdGF0ZVJpZ2h0KGV0KGV0KHQpKSkpKTooZT1zdChldChldCh0KSkpLDE9PT10dChlKT8obnQoZXQodCksMCksbnQoZSwwKSxudChldChldCh0KSksMSksdD1ldChldCh0KSkpOih0PT09c3QoZXQodCkpJiYodD1ldCh0KSx0aGlzLnJvdGF0ZVJpZ2h0KHQpKSxudChldCh0KSwwKSxudChldChldCh0KSksMSksdGhpcy5yb3RhdGVMZWZ0KGV0KGV0KHQpKSkpKTt0aGlzLnJvb3RfLmNvbG9yPTB9LHJ0LnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgeCxlPXRoaXMuZ2V0Rmlyc3RFbnRyeSgpO2lmKG51bGwhPT1lKWZvcih0LmFkZChlLnZhbHVlKTtudWxsIT09KGU9cnQuc3VjY2Vzc29yKGUpKTspdC5hZGQoZS52YWx1ZSk7cmV0dXJuIHR9LHJ0LnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe3ZhciB0PW5ldyBKLGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUpO251bGwhPT0oZT1ydC5zdWNjZXNzb3IoZSkpOyl0LmFkZChlKTtyZXR1cm4gdH0scnQucHJvdG90eXBlLnJvdGF0ZUxlZnQ9ZnVuY3Rpb24odCl7aWYobnVsbCE9dCl7dmFyIGU9dC5yaWdodDt0LnJpZ2h0PWUubGVmdCxudWxsIT1lLmxlZnQmJihlLmxlZnQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5sZWZ0PT09dD90LnBhcmVudC5sZWZ0PWU6dC5wYXJlbnQucmlnaHQ9ZSxlLmxlZnQ9dCx0LnBhcmVudD1lfX0scnQucHJvdG90eXBlLnJvdGF0ZVJpZ2h0PWZ1bmN0aW9uKHQpe2lmKG51bGwhPXQpe3ZhciBlPXQubGVmdDt0LmxlZnQ9ZS5yaWdodCxudWxsIT1lLnJpZ2h0JiYoZS5yaWdodC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LnJpZ2h0PT09dD90LnBhcmVudC5yaWdodD1lOnQucGFyZW50LmxlZnQ9ZSxlLnJpZ2h0PXQsdC5wYXJlbnQ9ZX19LHJ0LnByb3RvdHlwZS5nZXRGaXJzdEVudHJ5PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yb290XztpZihudWxsIT10KWZvcig7bnVsbCE9dC5sZWZ0Oyl0PXQubGVmdDtyZXR1cm4gdH0scnQuc3VjY2Vzc29yPWZ1bmN0aW9uKHQpe2xldCBlO2lmKG51bGw9PT10KXJldHVybiBudWxsO2lmKG51bGwhPT10LnJpZ2h0KXtmb3IoZT10LnJpZ2h0O251bGwhPT1lLmxlZnQ7KWU9ZS5sZWZ0O3JldHVybiBlfWU9dC5wYXJlbnQ7Zm9yKHZhciBuPXQ7bnVsbCE9PWUmJm49PT1lLnJpZ2h0OyluPWUsZT1lLnBhcmVudDtyZXR1cm4gZX0scnQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplX30scnQucHJvdG90eXBlLmNvbnRhaW5zS2V5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnJvb3RfO251bGwhPT1lOyl7dmFyIG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKG48MCllPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4hMDtlPWUucmlnaHR9fXJldHVybiExfTtjbGFzcyBvdHtjb25zdHJ1Y3Rvcigpe290LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gb3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIGx0KCl7fWZ1bmN0aW9uIGF0KCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmJiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfW90LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sbHQucHJvdG90eXBlPW5ldyBRLGF0LnByb3RvdHlwZT1uZXcgbHQsYXQucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO2U8bjtlKyspe2lmKDA9PT10aGlzLmFycmF5X1tlXS5jb21wYXJlVG8odCkpcmV0dXJuITB9cmV0dXJuITF9LGF0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7aWYodGhpcy5jb250YWlucyh0KSlyZXR1cm4hMTtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXtpZigxPT09dGhpcy5hcnJheV9bZV0uY29tcGFyZVRvKHQpKXJldHVybiB0aGlzLmFycmF5Xy5zcGxpY2UoZSwwLHQpLCEwfXJldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxhdC5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sYXQucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgWn0sYXQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2NvbnN0IHQ9W107Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxhdC5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGN0KHRoaXMpfTtjb25zdCBjdD1mdW5jdGlvbih0KXt0aGlzLnRyZWVTZXRfPXQsdGhpcy5wb3NpdGlvbl89MH07ZnVuY3Rpb24gaHQoKXt9Y3QucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvc2l0aW9uXz09PXRoaXMudHJlZVNldF8uc2l6ZSgpKXRocm93IG5ldyB5O3JldHVybiB0aGlzLnRyZWVTZXRfLmFycmF5X1t0aGlzLnBvc2l0aW9uXysrXX0sY3QucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy50cmVlU2V0Xy5zaXplKCl9LGN0LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgWn0saHQuc29ydD1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlLG4scyxpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb21wYXJlVG8oZSl9LHQuc29ydChpKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXM9YXJndW1lbnRzWzFdLGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcy5jb21wYXJlKHQsZSl9LHQuc29ydChpKTtlbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtuPXQuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSksbi5zb3J0KCk7Y29uc3Qgcz10LnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQobix0LnNsaWNlKGFyZ3VtZW50c1syXSx0Lmxlbmd0aCkpO2Zvcih0LnNwbGljZSgwLHQubGVuZ3RoKSxlPTA7ZTxzLmxlbmd0aDtlKyspdC5wdXNoKHNbZV0pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe249dC5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKSxzPWFyZ3VtZW50c1szXSxpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHMuY29tcGFyZSh0LGUpfSxuLnNvcnQoaSk7Y29uc3Qgcj10LnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQobix0LnNsaWNlKGFyZ3VtZW50c1syXSx0Lmxlbmd0aCkpO2Zvcih0LnNwbGljZSgwLHQubGVuZ3RoKSxlPTA7ZTxyLmxlbmd0aDtlKyspdC5wdXNoKHJbZV0pfX0saHQuYXNMaXN0PWZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPTAscz10Lmxlbmd0aDtuPHM7bisrKWUuYWRkKHRbbl0pO3JldHVybiBlfTtjbGFzcyB1dHtjb25zdHJ1Y3Rvcigpe3V0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvRGltZW5zaW9uU3ltYm9sKHQpe3N3aXRjaCh0KXtjYXNlIHV0LkZBTFNFOnJldHVybiB1dC5TWU1fRkFMU0U7Y2FzZSB1dC5UUlVFOnJldHVybiB1dC5TWU1fVFJVRTtjYXNlIHV0LkRPTlRDQVJFOnJldHVybiB1dC5TWU1fRE9OVENBUkU7Y2FzZSB1dC5QOnJldHVybiB1dC5TWU1fUDtjYXNlIHV0Lkw6cmV0dXJuIHV0LlNZTV9MO2Nhc2UgdXQuQTpyZXR1cm4gdXQuU1lNX0F9dGhyb3cgbmV3IG4oXCJVbmtub3duIGRpbWVuc2lvbiB2YWx1ZTogXCIrdCl9c3RhdGljIHRvRGltZW5zaW9uVmFsdWUodCl7c3dpdGNoKFQudG9VcHBlckNhc2UodCkpe2Nhc2UgdXQuU1lNX0ZBTFNFOnJldHVybiB1dC5GQUxTRTtjYXNlIHV0LlNZTV9UUlVFOnJldHVybiB1dC5UUlVFO2Nhc2UgdXQuU1lNX0RPTlRDQVJFOnJldHVybiB1dC5ET05UQ0FSRTtjYXNlIHV0LlNZTV9QOnJldHVybiB1dC5QO2Nhc2UgdXQuU1lNX0w6cmV0dXJuIHV0Lkw7Y2FzZSB1dC5TWU1fQTpyZXR1cm4gdXQuQX10aHJvdyBuZXcgbihcIlVua25vd24gZGltZW5zaW9uIHN5bWJvbDogXCIrdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gdXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXV0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sdXQuUD0wLHV0Lkw9MSx1dC5BPTIsdXQuRkFMU0U9LTEsdXQuVFJVRT0tMix1dC5ET05UQ0FSRT0tMyx1dC5TWU1fRkFMU0U9XCJGXCIsdXQuU1lNX1RSVUU9XCJUXCIsdXQuU1lNX0RPTlRDQVJFPVwiKlwiLHV0LlNZTV9QPVwiMFwiLHV0LlNZTV9MPVwiMVwiLHV0LlNZTV9BPVwiMlwiO2NsYXNzIGd0e2NvbnN0cnVjdG9yKCl7Z3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7fWdldENsYXNzKCl7cmV0dXJuIGd0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1ndC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGR0e2NvbnN0cnVjdG9yKCl7ZHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCxlKXt9aXNEb25lKCl7fWlzR2VvbWV0cnlDaGFuZ2VkKCl7fWdldENsYXNzKCl7cmV0dXJuIGR0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1kdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIF90IGV4dGVuZHMgcXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksX3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe2NvbnN0IHQ9bmV3IE47Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiB0fWdldEdlb21ldHJ5Tih0KXtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1t0XX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCk7bGV0IGU9LTE7Zm9yKGxldCBuPTA7bjx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dGhpcy5fZ2VvbWV0cmllc1tuXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248cy5sZW5ndGg7bisrKWUrKyx0W2VdPXNbbl19cmV0dXJuIHR9Z2V0QXJlYSgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRBcmVhKCk7cmV0dXJuIHR9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQ7aWYodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGghPT1uLl9nZW9tZXRyaWVzLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5fZ2VvbWV0cmllc1t0XS5lcXVhbHNFeGFjdChuLl9nZW9tZXRyaWVzW3RdLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspdGhpcy5fZ2VvbWV0cmllc1t0XS5ub3JtYWxpemUoKTtodC5zb3J0KHRoaXMuX2dlb21ldHJpZXMpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLl9nZW9tZXRyaWVzWzBdLmdldENvb3JkaW5hdGUoKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe2xldCB0PXV0LkZBTFNFO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLl9nZW9tZXRyaWVzW2VdLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpO3JldHVybiB0fWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OfWdldERpbWVuc2lvbigpe2xldCB0PXV0LkZBTFNFO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLl9nZW9tZXRyaWVzW2VdLmdldERpbWVuc2lvbigpKTtyZXR1cm4gdH1nZXRMZW5ndGgoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9Z2V0TnVtUG9pbnRzKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldE51bVBvaW50cygpO3JldHVybiB0fWdldE51bUdlb21ldHJpZXMoKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGh9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKyllW3RdPXRoaXMuX2dlb21ldHJpZXNbdF0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IGF0KGh0LmFzTGlzdCh0aGlzLl9nZW9tZXRyaWVzKSksbj1uZXcgYXQoaHQuYXNMaXN0KHQuX2dlb21ldHJpZXMpKTtyZXR1cm4gdGhpcy5jb21wYXJlKGUsbil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dCxzPXRoaXMuZ2V0TnVtR2VvbWV0cmllcygpLGk9bi5nZXROdW1HZW9tZXRyaWVzKCk7bGV0IHI9MDtmb3IoO3I8cyYmcjxpOyl7Y29uc3QgdD10aGlzLmdldEdlb21ldHJ5TihyKSxzPW4uZ2V0R2VvbWV0cnlOKHIpLGk9dC5jb21wYXJlVG9TYW1lQ2xhc3MocyxlKTtpZigwIT09aSlyZXR1cm4gaTtyKyt9cmV0dXJuIHI8cz8xOnI8aT8tMTowfX1hcHBseSgpe2lmKF8oYXJndW1lbnRzWzBdLEIpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZHQpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigwPT09dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCYmKHRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCksIXQuaXNEb25lKCkpO2UrKyk7dC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZ3QpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmZpbHRlcih0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuZmlsdGVyKHRoaXMpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCl9fWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksdS5zaG91bGROZXZlclJlYWNoSGVyZSgpLG51bGx9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfR0VPTUVUUllDT0xMRUNUSU9OfWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgX3QodCx0aGlzLl9mYWN0b3J5KX1pc0VtcHR5KCl7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uaXNFbXB0eSgpKXJldHVybiExO3JldHVybiEwfWdldENsYXNzKCl7cmV0dXJuIF90fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1fdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9nZW9tZXRyaWVzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1swXTtjb25zdCBlPWFyZ3VtZW50c1sxXTtpZihxLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksbnVsbD09PXQmJih0PVtdKSxxLmhhc051bGxFbGVtZW50cyh0KSl0aHJvdyBuZXcgbihcImdlb21ldHJpZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO3RoaXMuX2dlb21ldHJpZXM9dH19LF90LnNlcmlhbFZlcnNpb25VSUQ9LTB4NGYwN2JjYjFmODU3ZDgwMDtjbGFzcyBmdCBleHRlbmRzIF90e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxmdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT91dC5GQUxTRTowfWlzQ2xvc2VkKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uaXNDbG9zZWQoKSlyZXR1cm4hMTtyZXR1cm4hMH1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX01VTFRJTElORVNUUklOR31nZXREaW1lbnNpb24oKXtyZXR1cm4gMX1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKWVbdC0xLW5dPXRoaXMuX2dlb21ldHJpZXNbbl0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9Z2V0Qm91bmRhcnkoKXtyZXR1cm4gbmV3IHB0KHRoaXMpLmdldEJvdW5kYXJ5KCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfTVVMVElMSU5FU1RSSU5HfWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgZnQodCx0aGlzLl9mYWN0b3J5KX1nZXRDbGFzcygpe3JldHVybiBmdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb3RdfX1mdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtfdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9LGZ0LnNlcmlhbFZlcnNpb25VSUQ9MHg3MTU1ZDJhYjRhZmE4MDAwO2NsYXNzIHB0e2NvbnN0cnVjdG9yKCl7cHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0Qm91bmRhcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBwdCh0KS5nZXRCb3VuZGFyeSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IHB0KHQsZSkuZ2V0Qm91bmRhcnkoKX19Ym91bmRhcnlNdWx0aUxpbmVTdHJpbmcodCl7aWYodGhpcy5fZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7Y29uc3QgZT10aGlzLmNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpO3JldHVybiAxPT09ZS5sZW5ndGg/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoZVswXSk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoZSl9Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5fZ2VvbSBpbnN0YW5jZW9mIFR0P3RoaXMuYm91bmRhcnlMaW5lU3RyaW5nKHRoaXMuX2dlb20pOnRoaXMuX2dlb20gaW5zdGFuY2VvZiBmdD90aGlzLmJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nKHRoaXMuX2dlb20pOnRoaXMuX2dlb20uZ2V0Qm91bmRhcnkoKX1ib3VuZGFyeUxpbmVTdHJpbmcodCl7aWYodGhpcy5fZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7aWYodC5pc0Nsb3NlZCgpKXtyZXR1cm4gdGhpcy5fYm5SdWxlLmlzSW5Cb3VuZGFyeSgyKT90LmdldFN0YXJ0UG9pbnQoKTp0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoW3QuZ2V0U3RhcnRQb2ludCgpLHQuZ2V0RW5kUG9pbnQoKV0pfWdldEVtcHR5TXVsdGlQb2ludCgpe3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9Y29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgeDt0aGlzLl9lbmRwb2ludE1hcD1uZXcgcnQ7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7MCE9PW4uZ2V0TnVtUG9pbnRzKCkmJih0aGlzLmFkZEVuZHBvaW50KG4uZ2V0Q29vcmRpbmF0ZU4oMCkpLHRoaXMuYWRkRW5kcG9pbnQobi5nZXRDb29yZGluYXRlTihuLmdldE51bVBvaW50cygpLTEpKSl9Zm9yKGxldCB0PXRoaXMuX2VuZHBvaW50TWFwLmVudHJ5U2V0KCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkscz1uLmdldFZhbHVlKCkuY291bnQ7dGhpcy5fYm5SdWxlLmlzSW5Cb3VuZGFyeShzKSYmZS5hZGQobi5nZXRLZXkoKSl9cmV0dXJuIFgudG9Db29yZGluYXRlQXJyYXkoZSl9YWRkRW5kcG9pbnQodCl7bGV0IGU9dGhpcy5fZW5kcG9pbnRNYXAuZ2V0KHQpO251bGw9PT1lJiYoZT1uZXcgbXQsdGhpcy5fZW5kcG9pbnRNYXAucHV0KHQsZSkpLGUuY291bnQrK31nZXRDbGFzcygpe3JldHVybiBwdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZ2VvbT1udWxsLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fYm5SdWxlPW51bGwsdGhpcy5fZW5kcG9pbnRNYXA9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LFYuTU9EMl9CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tPXQsdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCksdGhpcy5fYm5SdWxlPWV9fTtjbGFzcyBtdHtjb25zdHJ1Y3Rvcigpe210LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gbXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW10LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuY291bnQ9bnVsbH07Y2xhc3MgeXR7Y29uc3RydWN0b3IoKXt5dC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvZkxpbmUodCl7Y29uc3QgZT10LnNpemUoKTtpZihlPD0xKXJldHVybiAwO2xldCBuPTA7Y29uc3Qgcz1uZXcgZzt0LmdldENvb3JkaW5hdGUoMCxzKTtsZXQgaT1zLngscj1zLnk7Zm9yKGxldCBvPTE7bzxlO28rKyl7dC5nZXRDb29yZGluYXRlKG8scyk7Y29uc3QgZT1zLngsbD1zLnksYT1lLWksYz1sLXI7bis9TWF0aC5zcXJ0KGEqYStjKmMpLGk9ZSxyPWx9cmV0dXJuIG59Z2V0Q2xhc3MoKXtyZXR1cm4geXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIHh0KCl7fWZ1bmN0aW9uIEV0KCl7fWZ1bmN0aW9uIEl0KCl7fWZ1bmN0aW9uIE50KCl7fWZ1bmN0aW9uIEN0KCl7fXl0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgU3R7Y29uc3RydWN0b3IoKXtTdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjaGFycyh0LGUpe2NvbnN0IG49bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7Zm9yKGxldCBzPTA7czxlO3MrKyluW3NdPXQ7cmV0dXJuIG5ldyBTdHJpbmcobil9c3RhdGljIGdldFN0YWNrVHJhY2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgSXQsbj1uZXcgeHQoZSk7cmV0dXJuIHQucHJpbnRTdGFja1RyYWNlKG4pLGUudG9TdHJpbmcoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49XCJcIjtjb25zdCBzPW5ldyBDdChuZXcgRXQoU3QuZ2V0U3RhY2tUcmFjZSh0KSkpO2ZvcihsZXQgdD0wO3Q8ZTt0KyspdHJ5e24rPXMucmVhZExpbmUoKStTdC5ORVdMSU5FfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIE50KSl0aHJvdyB0O3Uuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbn19c3RhdGljIHNwbGl0KHQsZSl7Y29uc3Qgbj1lLmxlbmd0aCxzPW5ldyB4O2xldCBpPVwiXCIrdCxyPWkuaW5kZXhPZihlKTtmb3IoO3I+PTA7KXtjb25zdCB0PWkuc3Vic3RyaW5nKDAscik7cy5hZGQodCksaT1pLnN1YnN0cmluZyhyK24pLHI9aS5pbmRleE9mKGUpfWkubGVuZ3RoPjAmJnMuYWRkKGkpO2NvbnN0IG89bmV3IEFycmF5KHMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKW9bdF09cy5nZXQodCk7cmV0dXJuIG99c3RhdGljIHRvU3RyaW5nKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBTdC5TSU1QTEVfT1JESU5BVEVfRk9STUFULmZvcm1hdCh0KX19c3RhdGljIHNwYWNlcyh0KXtyZXR1cm4gU3QuY2hhcnMoXCIgXCIsdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gU3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIHd0KHQpe3RoaXMuc3RyPXR9U3QuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxTdC5ORVdMSU5FPU8uZ2V0UHJvcGVydHkoXCJsaW5lLnNlcGFyYXRvclwiKSxTdC5TSU1QTEVfT1JESU5BVEVfRk9STUFUPW5ldyBmdW5jdGlvbigpe30oXCIwLiNcIiksd3QucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbih0KXt0aGlzLnN0cis9dH0sd3QucHJvdG90eXBlLnNldENoYXJBdD1mdW5jdGlvbih0LGUpe3RoaXMuc3RyPXRoaXMuc3RyLnN1YnN0cigwLHQpK2UrdGhpcy5zdHIuc3Vic3RyKHQrMSl9LHd0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdHJ9O2NsYXNzIEx0e2NvbnN0cnVjdG9yKCl7THQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29weUNvb3JkKHQsZSxuLHMpe2NvbnN0IGk9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxuLmdldERpbWVuc2lvbigpKTtmb3IobGV0IHI9MDtyPGk7cisrKW4uc2V0T3JkaW5hdGUocyxyLHQuZ2V0T3JkaW5hdGUoZSxyKSl9c3RhdGljIGlzUmluZyh0KXtjb25zdCBlPXQuc2l6ZSgpO3JldHVybiAwPT09ZXx8IShlPD0zKSYmKHQuZ2V0T3JkaW5hdGUoMCxBLlgpPT09dC5nZXRPcmRpbmF0ZShlLTEsQS5YKSYmdC5nZXRPcmRpbmF0ZSgwLEEuWSk9PT10LmdldE9yZGluYXRlKGUtMSxBLlkpKX1zdGF0aWMgaXNFcXVhbCh0LGUpe2NvbnN0IG49dC5zaXplKCk7aWYobiE9PWUuc2l6ZSgpKXJldHVybiExO2NvbnN0IHM9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKTtmb3IobGV0IHI9MDtyPG47cisrKWZvcihsZXQgbj0wO248cztuKyspe2NvbnN0IHM9dC5nZXRPcmRpbmF0ZShyLG4pLG89ZS5nZXRPcmRpbmF0ZShyLG4pO2lmKHQuZ2V0T3JkaW5hdGUocixuKSE9PWUuZ2V0T3JkaW5hdGUocixuKSYmKCFpLmlzTmFOKHMpfHwhaS5pc05hTihvKSkpcmV0dXJuITF9cmV0dXJuITB9c3RhdGljIGV4dGVuZCh0LGUsbil7Y29uc3Qgcz10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLGk9ZS5zaXplKCk7aWYoTHQuY29weShlLDAscywwLGkpLGk+MClmb3IobGV0IHQ9aTt0PG47dCsrKUx0LmNvcHkoZSxpLTEscyx0LDEpO3JldHVybiBzfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5zaXplKCktMSxuPU1hdGgudHJ1bmMoZS8yKTtmb3IobGV0IHM9MDtzPD1uO3MrKylMdC5zd2FwKHQscyxlLXMpfXN0YXRpYyBzd2FwKHQsZSxuKXtpZihlPT09bilyZXR1cm4gbnVsbDtmb3IobGV0IHM9MDtzPHQuZ2V0RGltZW5zaW9uKCk7cysrKXtjb25zdCBpPXQuZ2V0T3JkaW5hdGUoZSxzKTt0LnNldE9yZGluYXRlKGUscyx0LmdldE9yZGluYXRlKG4scykpLHQuc2V0T3JkaW5hdGUobixzLGkpfX1zdGF0aWMgY29weSh0LGUsbixzLGkpe2ZvcihsZXQgcj0wO3I8aTtyKyspTHQuY29weUNvb3JkKHQsZStyLG4scytyKX1zdGF0aWMgdG9TdHJpbmcoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5zaXplKCk7aWYoMD09PWUpcmV0dXJuXCIoKVwiO2NvbnN0IG49dC5nZXREaW1lbnNpb24oKSxzPW5ldyB3dDtzLmFwcGVuZChcIihcIik7Zm9yKGxldCBpPTA7aTxlO2krKyl7aT4wJiZzLmFwcGVuZChcIiBcIik7Zm9yKGxldCBlPTA7ZTxuO2UrKyllPjAmJnMuYXBwZW5kKFwiLFwiKSxzLmFwcGVuZChTdC50b1N0cmluZyh0LmdldE9yZGluYXRlKGksZSkpKX1yZXR1cm4gcy5hcHBlbmQoXCIpXCIpLHMudG9TdHJpbmcoKX19c3RhdGljIGVuc3VyZVZhbGlkUmluZyh0LGUpe2NvbnN0IG49ZS5zaXplKCk7cmV0dXJuIDA9PT1uP2U6bjw9Mz9MdC5jcmVhdGVDbG9zZWRSaW5nKHQsZSw0KTplLmdldE9yZGluYXRlKDAsQS5YKT09PWUuZ2V0T3JkaW5hdGUobi0xLEEuWCkmJmUuZ2V0T3JkaW5hdGUoMCxBLlkpPT09ZS5nZXRPcmRpbmF0ZShuLTEsQS5ZKT9lOkx0LmNyZWF0ZUNsb3NlZFJpbmcodCxlLG4rMSl9c3RhdGljIGNyZWF0ZUNsb3NlZFJpbmcodCxlLG4pe2NvbnN0IHM9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxpPWUuc2l6ZSgpO0x0LmNvcHkoZSwwLHMsMCxpKTtmb3IobGV0IHQ9aTt0PG47dCsrKUx0LmNvcHkoZSwwLHMsdCwxKTtyZXR1cm4gc31nZXRDbGFzcygpe3JldHVybiBMdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19THQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBUdCBleHRlbmRzIHF7Y29uc3RydWN0b3IoKXtzdXBlcigpLFR0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bmV3IE46dGhpcy5fcG9pbnRzLmV4cGFuZEVudmVsb3BlKG5ldyBOKX1pc1JpbmcoKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpJiZ0aGlzLmlzU2ltcGxlKCl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcG9pbnRzLnRvQ29vcmRpbmF0ZUFycmF5KCl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQ7aWYodGhpcy5fcG9pbnRzLnNpemUoKSE9PW4uX3BvaW50cy5zaXplKCkpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9wb2ludHMuc2l6ZSgpO3QrKylpZighdGhpcy5lcXVhbCh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSxuLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8TWF0aC50cnVuYyh0aGlzLl9wb2ludHMuc2l6ZSgpLzIpO3QrKyl7Y29uc3QgZT10aGlzLl9wb2ludHMuc2l6ZSgpLTEtdDtpZighdGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkuZXF1YWxzKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKSl7aWYodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkuY29tcGFyZVRvKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKT4wKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7THQucmV2ZXJzZSh0KSx0aGlzLl9wb2ludHM9dH1yZXR1cm4gbnVsbH19fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSgwKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/dXQuRkFMU0U6MH1pc0Nsb3NlZCgpe3JldHVybiF0aGlzLmlzRW1wdHkoKSYmdGhpcy5nZXRDb29yZGluYXRlTigwKS5lcXVhbHMyRCh0aGlzLmdldENvb3JkaW5hdGVOKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSkpfWdldEVuZFBvaW50KCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4odGhpcy5nZXROdW1Qb2ludHMoKS0xKX1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX0xJTkVTVFJJTkd9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDF9Z2V0TGVuZ3RoKCl7cmV0dXJuIHl0Lm9mTGluZSh0aGlzLl9wb2ludHMpfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLl9wb2ludHMuc2l6ZSgpfXJldmVyc2UoKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7cmV0dXJuIEx0LnJldmVyc2UodCksdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0KX1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9MCxuPTA7Zm9yKDtlPHRoaXMuX3BvaW50cy5zaXplKCkmJm48dC5fcG9pbnRzLnNpemUoKTspe2NvbnN0IHM9dGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkuY29tcGFyZVRvKHQuX3BvaW50cy5nZXRDb29yZGluYXRlKG4pKTtpZigwIT09cylyZXR1cm4gcztlKyssbisrfXJldHVybiBlPHRoaXMuX3BvaW50cy5zaXplKCk/MTpuPHQuX3BvaW50cy5zaXplKCk/LTE6MH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGFyZ3VtZW50c1sxXS5jb21wYXJlKHRoaXMuX3BvaW50cyx0Ll9wb2ludHMpfX1hcHBseSgpe2lmKF8oYXJndW1lbnRzWzBdLEIpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCk7ZSsrKXQuZmlsdGVyKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGR0KSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuX3BvaW50cy5zaXplKCkpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpJiYodC5maWx0ZXIodGhpcy5fcG9pbnRzLGUpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGd0KSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLEcpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfX1nZXRCb3VuZGFyeSgpe3JldHVybiBuZXcgcHQodGhpcykuZ2V0Qm91bmRhcnkoKX1pc0VxdWl2YWxlbnRDbGFzcyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFR0fWdldENvb3JkaW5hdGVOKHQpe3JldHVybiB0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9MSU5FU1RSSU5HfWNvcHkoKXtyZXR1cm4gbmV3IFR0KHRoaXMuX3BvaW50cy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCl7cmV0dXJuIHRoaXMuX3BvaW50c31pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9wb2ludHMuc2l6ZSgpfWluaXQodCl7aWYobnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSwxPT09dC5zaXplKCkpdGhyb3cgbmV3IG4oXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZVN0cmluZyAoZm91bmQgXCIrdC5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gMilcIik7dGhpcy5fcG9pbnRzPXR9aXNDb29yZGluYXRlKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9pbnRzLnNpemUoKTtlKyspaWYodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkuZXF1YWxzKHQpKXJldHVybiEwO3JldHVybiExfWdldFN0YXJ0UG9pbnQoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50TigwKX1nZXRQb2ludE4odCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpKX1nZXRDbGFzcygpe3JldHVybiBUdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb3RdfX1UdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wb2ludHM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX19LFR0LnNlcmlhbFZlcnNpb25VSUQ9MHgyYjJiNTFiYTQzNWM4ZTAwO2NsYXNzIFJ0e2NvbnN0cnVjdG9yKCl7UnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBSdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBQdCBleHRlbmRzIHF7Y29uc3RydWN0b3IoKXtzdXBlcigpLFB0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbmV3IE47Y29uc3QgdD1uZXcgTjtyZXR1cm4gdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fY29vcmRpbmF0ZXMuZ2V0WCgwKSx0aGlzLl9jb29yZGluYXRlcy5nZXRZKDApKSx0fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP1tdOlt0aGlzLmdldENvb3JkaW5hdGUoKV19ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJighKCF0aGlzLmlzRW1wdHkoKXx8IXQuaXNFbXB0eSgpKXx8dGhpcy5pc0VtcHR5KCk9PT10LmlzRW1wdHkoKSYmdGhpcy5lcXVhbCh0LmdldENvb3JkaW5hdGUoKSx0aGlzLmdldENvb3JkaW5hdGUoKSxlKSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXt9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiAwIT09dGhpcy5fY29vcmRpbmF0ZXMuc2l6ZSgpP3RoaXMuX2Nvb3JkaW5hdGVzLmdldENvb3JkaW5hdGUoMCk6bnVsbH1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB1dC5GQUxTRX1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX1BPSU5UfWdldERpbWVuc2lvbigpe3JldHVybiAwfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8wOjF9cmV2ZXJzZSgpe3JldHVybiB0aGlzLmNvcHkoKX1nZXRYKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJnZXRYIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueH1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0LmdldENvb3JkaW5hdGUoKSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBhcmd1bWVudHNbMV0uY29tcGFyZSh0aGlzLl9jb29yZGluYXRlcyx0Ll9jb29yZGluYXRlcyl9fWFwcGx5KCl7aWYoXyhhcmd1bWVudHNbMF0sQikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3QuZmlsdGVyKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGR0KSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dC5maWx0ZXIodGhpcy5fY29vcmRpbmF0ZXMsMCksdC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZ3QpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sRykpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9fWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX1BPSU5UfWNvcHkoKXtyZXR1cm4gbmV3IFB0KHRoaXMuX2Nvb3JkaW5hdGVzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1nZXRDb29yZGluYXRlU2VxdWVuY2UoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXN9Z2V0WSgpe2lmKG51bGw9PT10aGlzLmdldENvb3JkaW5hdGUoKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiZ2V0WSBjYWxsZWQgb24gZW1wdHkgUG9pbnRcIik7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnl9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5fY29vcmRpbmF0ZXMuc2l6ZSgpfWluaXQodCl7bnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSx1LmlzVHJ1ZSh0LnNpemUoKTw9MSksdGhpcy5fY29vcmRpbmF0ZXM9dH1pc1NpbXBsZSgpe3JldHVybiEwfWdldENsYXNzKCl7cmV0dXJuIFB0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltSdF19fVB0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Nvb3JkaW5hdGVzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX0sUHQuc2VyaWFsVmVyc2lvblVJRD0weDQ0MDc3YmFkMTYxY2JjMDA7Y2xhc3MgdnR7Y29uc3RydWN0b3IoKXt2dC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvZlJpbmcoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hYnModnQub2ZSaW5nU2lnbmVkKHQpKX1pZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYWJzKHZ0Lm9mUmluZ1NpZ25lZCh0KSl9fXN0YXRpYyBvZlJpbmdTaWduZWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0Lmxlbmd0aDwzKXJldHVybiAwO2xldCBlPTA7Y29uc3Qgbj10WzBdLng7Zm9yKGxldCBzPTE7czx0Lmxlbmd0aC0xO3MrKyl7Y29uc3QgaT10W3NdLngtbixyPXRbcysxXS55O2UrPWkqKHRbcy0xXS55LXIpfXJldHVybiBlLzJ9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5zaXplKCk7aWYoZTwzKXJldHVybiAwO2NvbnN0IG49bmV3IGcscz1uZXcgZyxpPW5ldyBnO3QuZ2V0Q29vcmRpbmF0ZSgwLHMpLHQuZ2V0Q29vcmRpbmF0ZSgxLGkpO2NvbnN0IHI9cy54O2kueC09cjtsZXQgbz0wO2ZvcihsZXQgbD0xO2w8ZS0xO2wrKyluLnk9cy55LHMueD1pLngscy55PWkueSx0LmdldENvb3JkaW5hdGUobCsxLGkpLGkueC09cixvKz1zLngqKG4ueS1pLnkpO3JldHVybiBvLzJ9fWdldENsYXNzKCl7cmV0dXJuIHZ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12dC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIE90e2NvbnN0cnVjdG9yKCl7T3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBPdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19T3QuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBidCBleHRlbmRzIHF7Y29uc3RydWN0b3IoKXtzdXBlcigpLGJ0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5fc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWdldENvb3JkaW5hdGVzKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuW107Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKTtsZXQgZT0tMTtjb25zdCBuPXRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspZSsrLHRbZV09bltzXTtmb3IobGV0IG49MDtuPHRoaXMuX2hvbGVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dGhpcy5faG9sZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPHMubGVuZ3RoO24rKyllKyssdFtlXT1zW25dfXJldHVybiB0fWdldEFyZWEoKXtsZXQgdD0wO3QrPXZ0Lm9mUmluZyh0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQtPXZ0Lm9mUmluZyh0aGlzLl9ob2xlc1tlXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7cmV0dXJuIHR9aXNSZWN0YW5nbGUoKXtpZigwIT09dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSlyZXR1cm4hMTtpZihudWxsPT09dGhpcy5fc2hlbGwpcmV0dXJuITE7aWYoNSE9PXRoaXMuX3NoZWxsLmdldE51bVBvaW50cygpKXJldHVybiExO2NvbnN0IHQ9dGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksZT10aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKTtmb3IobGV0IG49MDtuPDU7bisrKXtjb25zdCBzPXQuZ2V0WChuKTtpZihzIT09ZS5nZXRNaW5YKCkmJnMhPT1lLmdldE1heFgoKSlyZXR1cm4hMTtjb25zdCBpPXQuZ2V0WShuKTtpZihpIT09ZS5nZXRNaW5ZKCkmJmkhPT1lLmdldE1heFkoKSlyZXR1cm4hMX1sZXQgbj10LmdldFgoMCkscz10LmdldFkoMCk7Zm9yKGxldCBlPTE7ZTw9NDtlKyspe2NvbnN0IGk9dC5nZXRYKGUpLHI9dC5nZXRZKGUpO2lmKGkhPT1uPT09KHIhPT1zKSlyZXR1cm4hMTtuPWkscz1yfXJldHVybiEwfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7Y29uc3Qgbj10LHM9dGhpcy5fc2hlbGwsaT1uLl9zaGVsbDtpZighcy5lcXVhbHNFeGFjdChpLGUpKXJldHVybiExO2lmKHRoaXMuX2hvbGVzLmxlbmd0aCE9PW4uX2hvbGVzLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2hvbGVzW3RdLmVxdWFsc0V4YWN0KG4uX2hvbGVzW3RdLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMubm9ybWFsaXplKHRoaXMuX3NoZWxsLCEwKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspdGhpcy5ub3JtYWxpemUodGhpcy5faG9sZXNbdF0sITEpO2h0LnNvcnQodGhpcy5faG9sZXMpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49bmV3IEFycmF5KHQuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSkuZmlsbChudWxsKTtPLmFycmF5Y29weSh0LmdldENvb3JkaW5hdGVzKCksMCxuLDAsbi5sZW5ndGgpO2NvbnN0IHM9WC5taW5Db29yZGluYXRlKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7WC5zY3JvbGwobixzKSxPLmFycmF5Y29weShuLDAsdC5nZXRDb29yZGluYXRlcygpLDAsbi5sZW5ndGgpLHQuZ2V0Q29vcmRpbmF0ZXMoKVtuLmxlbmd0aF09blswXSx2LmlzQ0NXKHQuZ2V0Q29vcmRpbmF0ZXMoKSk9PT1lJiZYLnJldmVyc2UodC5nZXRDb29yZGluYXRlcygpKX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlKCl9Z2V0TnVtSW50ZXJpb3JSaW5nKCl7cmV0dXJuIHRoaXMuX2hvbGVzLmxlbmd0aH1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiAxfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfUE9MWUdPTn1nZXREaW1lbnNpb24oKXtyZXR1cm4gMn1nZXRMZW5ndGgoKXtsZXQgdD0wO3QrPXRoaXMuX3NoZWxsLmdldExlbmd0aCgpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9ob2xlc1tlXS5nZXRMZW5ndGgoKTtyZXR1cm4gdH1nZXROdW1Qb2ludHMoKXtsZXQgdD10aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5faG9sZXNbZV0uZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIHR9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5jb3B5KCk7dC5fc2hlbGw9dGhpcy5fc2hlbGwuY29weSgpLnJldmVyc2UoKSx0Ll9ob2xlcz1uZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0Ll9ob2xlc1tlXT10aGlzLl9ob2xlc1tlXS5jb3B5KCkucmV2ZXJzZSgpO3JldHVybiB0fWNvbnZleEh1bGwoKXtyZXR1cm4gdGhpcy5nZXRFeHRlcmlvclJpbmcoKS5jb252ZXhIdWxsKCl9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5fc2hlbGwsbj10Ll9zaGVsbDtyZXR1cm4gZS5jb21wYXJlVG9TYW1lQ2xhc3Mobil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dCxzPXRoaXMuX3NoZWxsLGk9bi5fc2hlbGwscj1zLmNvbXBhcmVUb1NhbWVDbGFzcyhpLGUpO2lmKDAhPT1yKXJldHVybiByO2NvbnN0IG89dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSxsPW4uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bGV0IGE9MDtmb3IoO2E8byYmYTxsOyl7Y29uc3QgdD10aGlzLmdldEludGVyaW9yUmluZ04oYSkscz1uLmdldEludGVyaW9yUmluZ04oYSksaT10LmNvbXBhcmVUb1NhbWVDbGFzcyhzLGUpO2lmKDAhPT1pKXJldHVybiBpO2ErK31yZXR1cm4gYTxvPzE6YTxsPy0xOjB9fWFwcGx5KCl7aWYoXyhhcmd1bWVudHNbMF0sQikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NoZWxsLmFwcGx5KHQpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0aGlzLl9ob2xlc1tlXS5hcHBseSh0KX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGR0KSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5fc2hlbGwuYXBwbHkodCksIXQuaXNEb25lKCkpZm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGgmJih0aGlzLl9ob2xlc1tlXS5hcHBseSh0KSwhdC5pc0RvbmUoKSk7ZSsrKTt0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxndCkpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5maWx0ZXIodGhpcyksdGhpcy5fc2hlbGwuYXBwbHkodCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpfX1nZXRCb3VuZGFyeSgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgrMSkuZmlsbChudWxsKTt0WzBdPXRoaXMuX3NoZWxsO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0W2UrMV09dGhpcy5faG9sZXNbZV07cmV0dXJuIHQubGVuZ3RoPD0xP3RoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodFswXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk6dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX1BPTFlHT059Y29weSgpe2NvbnN0IHQ9dGhpcy5fc2hlbGwuY29weSgpLGU9bmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspZVt0XT10aGlzLl9ob2xlc1t0XS5jb3B5KCk7cmV0dXJuIG5ldyBidCh0LGUsdGhpcy5fZmFjdG9yeSl9Z2V0RXh0ZXJpb3JSaW5nKCl7cmV0dXJuIHRoaXMuX3NoZWxsfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fc2hlbGwuaXNFbXB0eSgpfWdldEludGVyaW9yUmluZ04odCl7cmV0dXJuIHRoaXMuX2hvbGVzW3RdfWdldENsYXNzKCl7cmV0dXJuIGJ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltPdF19fWJ0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NoZWxsPW51bGwsdGhpcy5faG9sZXM9bnVsbDtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Y29uc3Qgcz1hcmd1bWVudHNbMl07aWYocS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHMpLG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKCkpLG51bGw9PT1lJiYoZT1bXSkscS5oYXNOdWxsRWxlbWVudHMoZSkpdGhyb3cgbmV3IG4oXCJob2xlcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7aWYodC5pc0VtcHR5KCkmJnEuaGFzTm9uRW1wdHlFbGVtZW50cyhlKSl0aHJvdyBuZXcgbihcInNoZWxsIGlzIGVtcHR5IGJ1dCBob2xlcyBhcmUgbm90XCIpO3RoaXMuX3NoZWxsPXQsdGhpcy5faG9sZXM9ZX0sYnQuc2VyaWFsVmVyc2lvblVJRD0tMHgzMDdmZmVmZDhkYzk3MjAwO2NsYXNzIE10IGV4dGVuZHMgX3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLE10LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNWYWxpZCgpe3JldHVybiEwfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1t0XS5nZXRDb29yZGluYXRlKCl9cmV0dXJuIHN1cGVyLmdldENvb3JkaW5hdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHV0LkZBTFNFfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfTVVMVElQT0lOVH1nZXREaW1lbnNpb24oKXtyZXR1cm4gMH1nZXRCb3VuZGFyeSgpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9NVUxUSVBPSU5UfWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgTXQodCx0aGlzLl9mYWN0b3J5KX1nZXRDbGFzcygpe3JldHVybiBNdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUnRdfX1NdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtfdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9LE10LnNlcmlhbFZlcnNpb25VSUQ9LTB4NmZiMWVkNDE2MmUwZmMwMDtjbGFzcyBEdCBleHRlbmRzIFR0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxEdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHV0LkZBTFNFfWlzQ2xvc2VkKCl7cmV0dXJuISF0aGlzLmlzRW1wdHkoKXx8c3VwZXIuaXNDbG9zZWQuY2FsbCh0aGlzKX1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX0xJTkVBUlJJTkd9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5fcG9pbnRzLmNvcHkoKTtyZXR1cm4gTHQucmV2ZXJzZSh0KSx0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHQpfXZhbGlkYXRlQ29uc3RydWN0aW9uKCl7aWYoIXRoaXMuaXNFbXB0eSgpJiYhc3VwZXIuaXNDbG9zZWQuY2FsbCh0aGlzKSl0aHJvdyBuZXcgbihcIlBvaW50cyBvZiBMaW5lYXJSaW5nIGRvIG5vdCBmb3JtIGEgY2xvc2VkIGxpbmVzdHJpbmdcIik7aWYodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk+PTEmJnRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPER0Lk1JTklNVU1fVkFMSURfU0laRSl0aHJvdyBuZXcgbihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lYXJSaW5nIChmb3VuZCBcIit0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKStcIiAtIG11c3QgYmUgMCBvciA+PSA0KVwiKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9MSU5FQVJSSU5HfWNvcHkoKXtyZXR1cm4gbmV3IER0KHRoaXMuX3BvaW50cy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9Z2V0Q2xhc3MoKXtyZXR1cm4gRHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUR0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0R0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpLGUpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sQSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1R0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLnZhbGlkYXRlQ29uc3RydWN0aW9uKCl9fSxEdC5NSU5JTVVNX1ZBTElEX1NJWkU9NCxEdC5zZXJpYWxWZXJzaW9uVUlEPS0weDNiMjI5ZTI2MjM2N2E2MDA7Y2xhc3MgQXQgZXh0ZW5kcyBfdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmc3VwZXIuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiAxfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfTVVMVElQT0xZR09OfWdldERpbWVuc2lvbigpe3JldHVybiAyfXJldmVyc2UoKXtjb25zdCB0PXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspZVt0XT10aGlzLl9nZW9tZXRyaWVzW3RdLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfWdldEJvdW5kYXJ5KCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2NvbnN0IHQ9bmV3IHg7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeSgpO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXQuYWRkKG4uZ2V0R2VvbWV0cnlOKGUpKX1jb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQudG9BcnJheShlKSl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfTVVMVElQT0xZR09OfWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgQXQodCx0aGlzLl9mYWN0b3J5KX1nZXRDbGFzcygpe3JldHVybiBBdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bT3RdfX1BdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtfdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9LEF0LnNlcmlhbFZlcnNpb25VSUQ9LTB4N2E1YWExMzY5MTcxOTgwO2NsYXNzIEZ0e2NvbnN0cnVjdG9yKCl7RnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRDb3B5VXNlckRhdGEodCl7dGhpcy5faXNVc2VyRGF0YUNvcGllZD10fWVkaXQodCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtjb25zdCBuPXRoaXMuZWRpdEludGVybmFsKHQsZSk7cmV0dXJuIHRoaXMuX2lzVXNlckRhdGFDb3BpZWQmJm4uc2V0VXNlckRhdGEodC5nZXRVc2VyRGF0YSgpKSxufWVkaXRJbnRlcm5hbCh0LGUpe3JldHVybiBudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHQgaW5zdGFuY2VvZiBfdD90aGlzLmVkaXRHZW9tZXRyeUNvbGxlY3Rpb24odCxlKTp0IGluc3RhbmNlb2YgYnQ/dGhpcy5lZGl0UG9seWdvbih0LGUpOnQgaW5zdGFuY2VvZiBQdHx8dCBpbnN0YW5jZW9mIFR0P2UuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpOih1LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5zdXBwb3J0ZWQgR2VvbWV0cnkgY2xhc3M6IFwiK3QuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpLG51bGwpfWVkaXRHZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPWUuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpLHM9bmV3IHg7Zm9yKGxldCB0PTA7dDxuLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IGk9dGhpcy5lZGl0KG4uZ2V0R2VvbWV0cnlOKHQpLGUpO251bGw9PT1pfHxpLmlzRW1wdHkoKXx8cy5hZGQoaSl9cmV0dXJuIG4uZ2V0Q2xhc3MoKT09PU10P3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChzLnRvQXJyYXkoW10pKTpuLmdldENsYXNzKCk9PT1mdD90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhzLnRvQXJyYXkoW10pKTpuLmdldENsYXNzKCk9PT1BdD90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihzLnRvQXJyYXkoW10pKTp0aGlzLl9mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihzLnRvQXJyYXkoW10pKX1lZGl0UG9seWdvbih0LGUpe2xldCBuPWUuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpO2lmKG51bGw9PT1uJiYobj10aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKSksbi5pc0VtcHR5KCkpcmV0dXJuIG47Y29uc3Qgcz10aGlzLmVkaXQobi5nZXRFeHRlcmlvclJpbmcoKSxlKTtpZihudWxsPT09c3x8cy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbigpO2NvbnN0IGk9bmV3IHg7Zm9yKGxldCB0PTA7dDxuLmdldE51bUludGVyaW9yUmluZygpO3QrKyl7Y29uc3Qgcz10aGlzLmVkaXQobi5nZXRJbnRlcmlvclJpbmdOKHQpLGUpO251bGw9PT1zfHxzLmlzRW1wdHkoKXx8aS5hZGQocyl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbihzLGkudG9BcnJheShbXSkpfWdldENsYXNzKCl7cmV0dXJuIEZ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBHdCgpe31GdC5HZW9tZXRyeUVkaXRvck9wZXJhdGlvbj1HdDtjbGFzcyBxdHtjb25zdHJ1Y3Rvcigpe3F0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZWRpdCh0LGUpe3JldHVybiB0fWdldENsYXNzKCl7cmV0dXJuIHF0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHdF19fXF0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgQnR7Y29uc3RydWN0b3IoKXtCdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVkaXQodCxlKXtjb25zdCBuPXRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVzKCksdCk7cmV0dXJuIHQgaW5zdGFuY2VvZiBEdD9udWxsPT09bj9lLmNyZWF0ZUxpbmVhclJpbmcoKTplLmNyZWF0ZUxpbmVhclJpbmcobik6dCBpbnN0YW5jZW9mIFR0P251bGw9PT1uP2UuY3JlYXRlTGluZVN0cmluZygpOmUuY3JlYXRlTGluZVN0cmluZyhuKTp0IGluc3RhbmNlb2YgUHQ/bnVsbD09PW58fDA9PT1uLmxlbmd0aD9lLmNyZWF0ZVBvaW50KCk6ZS5jcmVhdGVQb2ludChuWzBdKTp0fWdldENsYXNzKCl7cmV0dXJuIEJ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHdF19fUJ0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgVnR7Y29uc3RydWN0b3IoKXtWdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVkaXQodCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIER0P2UuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIFR0P2UuY3JlYXRlTGluZVN0cmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIFB0P2UuY3JlYXRlUG9pbnQodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnR9Z2V0Q2xhc3MoKXtyZXR1cm4gVnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0d0XX19VnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxGdC5Ob09wR2VvbWV0cnlPcGVyYXRpb249cXQsRnQuQ29vcmRpbmF0ZU9wZXJhdGlvbj1CdCxGdC5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb249VnQsRnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2lzVXNlckRhdGFDb3BpZWQ9ITEsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH19O2NsYXNzIHp0e2NvbnN0cnVjdG9yKCl7enQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRPcmRpbmF0ZSh0LGUscyl7c3dpdGNoKGUpe2Nhc2UgQS5YOnRoaXMuX2Nvb3JkaW5hdGVzW3RdLng9czticmVhaztjYXNlIEEuWTp0aGlzLl9jb29yZGluYXRlc1t0XS55PXM7YnJlYWs7Y2FzZSBBLlo6dGhpcy5fY29vcmRpbmF0ZXNbdF0uej1zO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IG4oXCJpbnZhbGlkIG9yZGluYXRlSW5kZXhcIil9fXNpemUoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RofWdldE9yZGluYXRlKHQsZSl7c3dpdGNoKGUpe2Nhc2UgQS5YOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS54O2Nhc2UgQS5ZOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS55O2Nhc2UgQS5aOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS56fXJldHVybiBpLk5hTn1nZXRDb29yZGluYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZS54PXRoaXMuX2Nvb3JkaW5hdGVzW3RdLngsZS55PXRoaXMuX2Nvb3JkaW5hdGVzW3RdLnksZS56PXRoaXMuX2Nvb3JkaW5hdGVzW3RdLnp9fWdldENvb3JkaW5hdGVDb3B5KHQpe3JldHVybiBuZXcgZyh0aGlzLl9jb29yZGluYXRlc1t0XSl9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuX2RpbWVuc2lvbn1nZXRYKHQpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS54fWV4cGFuZEVudmVsb3BlKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb29yZGluYXRlc1tlXSk7cmV0dXJuIHR9Y29weSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2Nvb3JkaW5hdGVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IHp0KHQsdGhpcy5fZGltZW5zaW9uKX10b1N0cmluZygpe2lmKHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aD4wKXtjb25zdCB0PW5ldyB3dCgxNyp0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgpO3QuYXBwZW5kKFwiKFwiKSx0LmFwcGVuZCh0aGlzLl9jb29yZGluYXRlc1swXSk7Zm9yKGxldCBlPTE7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuYXBwZW5kKFwiLCBcIiksdC5hcHBlbmQodGhpcy5fY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0LmFwcGVuZChcIilcIiksdC50b1N0cmluZygpfXJldHVyblwiKClcIn1nZXRZKHQpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS55fXRvQ29vcmRpbmF0ZUFycmF5KCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzfWdldENsYXNzKCl7cmV0dXJuIHp0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBLGFdfX16dC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9kaW1lbnNpb249Myx0aGlzLl9jb29yZGluYXRlcz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt6dC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMyl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dDtlKyspdGhpcy5fY29vcmRpbmF0ZXNbZV09bmV3IGd9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7dGhpcy5fZGltZW5zaW9uPXQuZ2V0RGltZW5zaW9uKCksdGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT10LmdldENvb3JkaW5hdGVDb3B5KGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY29vcmRpbmF0ZXM9dCx0aGlzLl9kaW1lbnNpb249ZSxudWxsPT09dCYmKHRoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLl9kaW1lbnNpb249ZTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXRoaXMuX2Nvb3JkaW5hdGVzW2VdPW5ldyBnfX0senQuc2VyaWFsVmVyc2lvblVJRD0tMHhjYjQ0YTc3OGRiMThlMDA7Y2xhc3MgWXR7Y29uc3RydWN0b3IoKXtZdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbnN0YW5jZSgpe3JldHVybiBZdC5pbnN0YW5jZU9iamVjdH1yZWFkUmVzb2x2ZSgpe3JldHVybiBZdC5pbnN0YW5jZSgpfWNyZWF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IHp0KHQpfWlmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IHp0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1hcmd1bWVudHNbMV07cmV0dXJuIGU+MyYmKGU9MyksZTwyP25ldyB6dCh0KTpuZXcgenQodCxlKX19Z2V0Q2xhc3MoKXtyZXR1cm4gWXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0YsYV19fWZ1bmN0aW9uIFV0KCl7dGhpcy5tYXBfPW5ldyBNYXB9WXQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxZdC5zZXJpYWxWZXJzaW9uVUlEPS0weDM4ZTQ5ZmE2Y2Y2ZjJlMDAsWXQuaW5zdGFuY2VPYmplY3Q9bmV3IFl0LFV0LnByb3RvdHlwZT1uZXcgaixVdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm1hcF8uZ2V0KHQpfHxudWxsfSxVdC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubWFwXy5zZXQodCxlKSxlfSxVdC5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgeCxlPXRoaXMubWFwXy52YWx1ZXMoKTtsZXQgbj1lLm5leHQoKTtmb3IoOyFuLmRvbmU7KXQuYWRkKG4udmFsdWUpLG49ZS5uZXh0KCk7cmV0dXJuIHR9LFV0LnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe2NvbnN0IHQ9bmV3IEo7cmV0dXJuIHRoaXMubWFwXy5lbnRyaWVzKCkuZm9yRWFjaChlPT50LmFkZChlKSksdH0sVXQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfLnNpemUoKX07Y2xhc3Mga3R7Y29uc3RydWN0b3IoKXtrdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtb3N0UHJlY2lzZSh0LGUpe3JldHVybiB0LmNvbXBhcmVUbyhlKT49MD90OmV9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIGt0KSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PWUuX21vZGVsVHlwZSYmdGhpcy5fc2NhbGU9PT1lLl9zY2FsZX1jb21wYXJlVG8odCl7Y29uc3QgZT10LG49dGhpcy5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKSxzPWUuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCk7cmV0dXJuIG5ldyBMKG4pLmNvbXBhcmVUbyhuZXcgTChzKSl9Z2V0U2NhbGUoKXtyZXR1cm4gdGhpcy5fc2NhbGV9aXNGbG9hdGluZygpe3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElOR3x8dGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkdfU0lOR0xFfWdldFR5cGUoKXtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlfXRvU3RyaW5nKCl7bGV0IHQ9XCJVTktOT1dOXCI7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HP3Q9XCJGbG9hdGluZ1wiOnRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HX1NJTkdMRT90PVwiRmxvYXRpbmctU2luZ2xlXCI6dGhpcy5fbW9kZWxUeXBlPT09a3QuRklYRUQmJih0PVwiRml4ZWQgKFNjYWxlPVwiK3RoaXMuZ2V0U2NhbGUoKStcIilcIiksdH1tYWtlUHJlY2lzZSgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKGkuaXNOYU4odCkpcmV0dXJuIHQ7aWYodGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkdfU0lOR0xFKXtyZXR1cm4gdH1yZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09a3QuRklYRUQ/TWF0aC5yb3VuZCh0KnRoaXMuX3NjYWxlKS90aGlzLl9zY2FsZTp0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkcpcmV0dXJuIG51bGw7dC54PXRoaXMubWFrZVByZWNpc2UodC54KSx0Lnk9dGhpcy5tYWtlUHJlY2lzZSh0LnkpfX1nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKXtsZXQgdD0xNjtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkc/dD0xNjp0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElOR19TSU5HTEU/dD02OnRoaXMuX21vZGVsVHlwZT09PWt0LkZJWEVEJiYodD0xK01hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGgubG9nKHRoaXMuZ2V0U2NhbGUoKSkvTWF0aC5sb2coMTApKSkpLHR9c2V0U2NhbGUodCl7dGhpcy5fc2NhbGU9TWF0aC5hYnModCl9Z2V0Q2xhc3MoKXtyZXR1cm4ga3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2Escl19fWNsYXNzIFh0e2NvbnN0cnVjdG9yKCl7WHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZWFkUmVzb2x2ZSgpe3JldHVybiBYdC5uYW1lVG9UeXBlTWFwLmdldCh0aGlzLl9uYW1lKX10b1N0cmluZygpe3JldHVybiB0aGlzLl9uYW1lfWdldENsYXNzKCl7cmV0dXJuIFh0fWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19WHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbmFtZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25hbWU9dCxYdC5uYW1lVG9UeXBlTWFwLnB1dCh0LHRoaXMpfSxYdC5zZXJpYWxWZXJzaW9uVUlEPS01NTI4NjAyNjMxNzMxNTllNCxYdC5uYW1lVG9UeXBlTWFwPW5ldyBVdCxrdC5UeXBlPVh0LGt0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX21vZGVsVHlwZT1udWxsLHRoaXMuX3NjYWxlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fbW9kZWxUeXBlPWt0LkZMT0FUSU5HO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPXQsdD09PWt0LkZJWEVEJiZ0aGlzLnNldFNjYWxlKDEpfWVsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPWt0LkZJWEVELHRoaXMuc2V0U2NhbGUodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGt0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tb2RlbFR5cGU9dC5fbW9kZWxUeXBlLHRoaXMuX3NjYWxlPXQuX3NjYWxlfX0sa3Quc2VyaWFsVmVyc2lvblVJRD0weDZiZWU2NDA0ZTlhMjVjMDAsa3QuRklYRUQ9bmV3IFh0KFwiRklYRURcIiksa3QuRkxPQVRJTkc9bmV3IFh0KFwiRkxPQVRJTkdcIiksa3QuRkxPQVRJTkdfU0lOR0xFPW5ldyBYdChcIkZMT0FUSU5HIFNJTkdMRVwiKSxrdC5tYXhpbXVtUHJlY2lzZVZhbHVlPTkwMDcxOTkyNTQ3NDA5OTI7Y2xhc3MgSHR7Y29uc3RydWN0b3IoKXtIdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b011bHRpUG9seWdvbkFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvR2VvbWV0cnlBcnJheSh0KXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyBnZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpe3JldHVybiBZdC5pbnN0YW5jZSgpfXN0YXRpYyB0b011bHRpTGluZVN0cmluZ0FycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvTGluZVN0cmluZ0FycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvTXVsdGlQb2ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvTGluZWFyUmluZ0FycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvUG9pbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b1BvbHlnb25BcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyBjcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX10b0dlb21ldHJ5KHQpe3JldHVybiB0LmlzTnVsbCgpP3RoaXMuY3JlYXRlUG9pbnQoKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpJiZ0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlUG9pbnQobmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpfHx0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlTGluZVN0cmluZyhbbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKV0pOnRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoW25ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1pblgoKSx0LmdldE1heFkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSldKSxudWxsKX1jcmVhdGVMaW5lU3RyaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgVHQodCx0aGlzKX19fWNyZWF0ZU11bHRpTGluZVN0cmluZygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgZnQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBmdCh0LHRoaXMpfX1idWlsZEdlb21ldHJ5KHQpe2xldCBlPW51bGwsbj0hMSxzPSExO2ZvcihsZXQgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCB0PWkubmV4dCgpLHI9dC5nZXRDbGFzcygpO251bGw9PT1lJiYoZT1yKSxyIT09ZSYmKG49ITApLHQgaW5zdGFuY2VvZiBfdCYmKHM9ITApfWlmKG51bGw9PT1lKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2lmKG58fHMpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEh0LnRvR2VvbWV0cnlBcnJheSh0KSk7Y29uc3QgaT10Lml0ZXJhdG9yKCkubmV4dCgpO2lmKHQuc2l6ZSgpPjEpe2lmKGkgaW5zdGFuY2VvZiBidClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvbHlnb24oSHQudG9Qb2x5Z29uQXJyYXkodCkpO2lmKGkgaW5zdGFuY2VvZiBUdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoSHQudG9MaW5lU3RyaW5nQXJyYXkodCkpO2lmKGkgaW5zdGFuY2VvZiBQdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KEh0LnRvUG9pbnRBcnJheSh0KSk7dS5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuaGFuZGxlZCBjbGFzczogXCIraS5nZXRDbGFzcygpLmdldE5hbWUoKSl9cmV0dXJuIGl9Y3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHModCl7cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9Y3JlYXRlUG9pbnQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVQb2ludCh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW3RdKTpudWxsKX1pZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBQdCh0LHRoaXMpfX19Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5fWNyZWF0ZVBvbHlnb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKG51bGwsbnVsbCk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyh0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcodCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odCxudWxsKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBidCh0LGUsdGhpcyl9fWdldFNSSUQoKXtyZXR1cm4gdGhpcy5fU1JJRH1jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IF90KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgX3QodCx0aGlzKX19Y3JlYXRlR2VvbWV0cnkodCl7cmV0dXJuIG5ldyBGdCh0aGlzKS5lZGl0KHQsbmV3IFd0KHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkpKX1nZXRQcmVjaXNpb25Nb2RlbCgpe3JldHVybiB0aGlzLl9wcmVjaXNpb25Nb2RlbH1jcmVhdGVMaW5lYXJSaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgRHQodCx0aGlzKX19fWNyZWF0ZU11bHRpUG9seWdvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgQXQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBBdCh0LHRoaXMpfX1jcmVhdGVNdWx0aVBvaW50KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBNdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IE10KHQsdGhpcyl9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobmV3IEFycmF5KDApLmZpbGwobnVsbCkpO2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSgxLHQuZ2V0RGltZW5zaW9uKCkpO0x0LmNvcHkodCxuLHMsMCwxKSxlW25dPXRoaXMuY3JlYXRlUG9pbnQocyl9cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChlKX19fWdldENsYXNzKCl7cmV0dXJuIEh0fWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19Y2xhc3MgV3QgZXh0ZW5kcyBGdC5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb257Y29uc3RydWN0b3IoKXtzdXBlcigpLFd0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZWRpdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHEmJl8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LmNyZWF0ZSh0KX1yZXR1cm4gc3VwZXIuZWRpdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gV3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVd0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT10fSxIdC5DbG9uZU9wPVd0LEh0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1udWxsLHRoaXMuX1NSSUQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClIdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBrdCwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1swXSxGKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07SHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcga3QsMCx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Yga3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0h0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwwLEh0LmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtIdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxIdC5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wcmVjaXNpb25Nb2RlbD10LHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9bix0aGlzLl9TUklEPWV9fSxIdC5zZXJpYWxWZXJzaW9uVUlEPS0weDVlYTc1ZjIwNTFlZWI0MDA7Y29uc3QganQ9e3R5cGVTdHI6L15cXHMqKFxcdyspXFxzKlxcKFxccyooLiopXFxzKlxcKVxccyokLyxlbXB0eVR5cGVTdHI6L15cXHMqKFxcdyspXFxzKkVNUFRZXFxzKiQvLHNwYWNlczovXFxzKy8scGFyZW5Db21tYTovXFwpXFxzKixcXHMqXFwoLyxkb3VibGVQYXJlbkNvbW1hOi9cXClcXHMqXFwpXFxzKixcXHMqXFwoXFxzKlxcKC8sdHJpbVBhcmVuczovXlxccypcXCg/KC4qPylcXCk/XFxzKiQvfTtjbGFzcyBLdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgSHQsdGhpcy5wcmVjaXNpb25Nb2RlbD10aGlzLmdlb21ldHJ5RmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpfXJlYWQodCl7dmFyIGUsbixzO3Q9dC5yZXBsYWNlKC9bXFxuXFxyXS9nLFwiIFwiKTt2YXIgaT1qdC50eXBlU3RyLmV4ZWModCk7aWYoLTEhPT10LnNlYXJjaChcIkVNUFRZXCIpJiYoKGk9anQuZW1wdHlUeXBlU3RyLmV4ZWModCkpWzJdPXZvaWQgMCksaSYmKG49aVsxXS50b0xvd2VyQ2FzZSgpLHM9aVsyXSxRdFtuXSYmKGU9UXRbbl0uY2FsbCh0aGlzLHMpKSksdm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgV0tUIFwiK3QpO3JldHVybiBlfXdyaXRlKHQpe3JldHVybiB0aGlzLmV4dHJhY3RHZW9tZXRyeSh0KX1leHRyYWN0R2VvbWV0cnkodCl7dmFyIGU9dC5nZXRHZW9tZXRyeVR5cGUoKS50b0xvd2VyQ2FzZSgpO2lmKCFadFtlXSlyZXR1cm4gbnVsbDt2YXIgbj1lLnRvVXBwZXJDYXNlKCk7cmV0dXJuIHQuaXNFbXB0eSgpP24rXCIgRU1QVFlcIjpuK1wiKFwiK1p0W2VdLmNhbGwodGhpcyx0KStcIilcIn19Y29uc3QgWnQ9e2Nvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodCksdC54K1wiIFwiK3QueX0scG9pbnQodCl7cmV0dXJuIFp0LmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuX2Nvb3JkaW5hdGVzLl9jb29yZGluYXRlc1swXSl9LG11bHRpcG9pbnQodCl7dmFyIGU9W107Zm9yKGxldCBuPTAscz10Ll9nZW9tZXRyaWVzLmxlbmd0aDtuPHM7KytuKWUucHVzaChcIihcIitadC5wb2ludC5jYWxsKHRoaXMsdC5fZ2VvbWV0cmllc1tuXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxsaW5lc3RyaW5nKHQpe3ZhciBlPVtdO2ZvcihsZXQgbj0wLHM9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5sZW5ndGg7bjxzOysrbillLnB1c2goWnQuY29vcmRpbmF0ZS5jYWxsKHRoaXMsdC5fcG9pbnRzLl9jb29yZGluYXRlc1tuXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxsaW5lYXJyaW5nKHQpe3ZhciBlPVtdO2ZvcihsZXQgbj0wLHM9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5sZW5ndGg7bjxzOysrbillLnB1c2goWnQuY29vcmRpbmF0ZS5jYWxsKHRoaXMsdC5fcG9pbnRzLl9jb29yZGluYXRlc1tuXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxtdWx0aWxpbmVzdHJpbmcodCl7dmFyIGU9W107Zm9yKGxldCBuPTAscz10Ll9nZW9tZXRyaWVzLmxlbmd0aDtuPHM7KytuKWUucHVzaChcIihcIitadC5saW5lc3RyaW5nLmNhbGwodGhpcyx0Ll9nZW9tZXRyaWVzW25dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LHBvbHlnb24odCl7dmFyIGU9W107ZS5wdXNoKFwiKFwiK1p0LmxpbmVzdHJpbmcuY2FsbCh0aGlzLHQuX3NoZWxsKStcIilcIik7Zm9yKGxldCBuPTAscz10Ll9ob2xlcy5sZW5ndGg7bjxzOysrbillLnB1c2goXCIoXCIrWnQubGluZXN0cmluZy5jYWxsKHRoaXMsdC5faG9sZXNbbl0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbXVsdGlwb2x5Z29uKHQpe3ZhciBlPVtdO2ZvcihsZXQgbj0wLHM9dC5fZ2VvbWV0cmllcy5sZW5ndGg7bjxzOysrbillLnB1c2goXCIoXCIrWnQucG9seWdvbi5jYWxsKHRoaXMsdC5fZ2VvbWV0cmllc1tuXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxnZW9tZXRyeWNvbGxlY3Rpb24odCl7dmFyIGU9W107Zm9yKGxldCBuPTAscz10Ll9nZW9tZXRyaWVzLmxlbmd0aDtuPHM7KytuKWUucHVzaCh0aGlzLmV4dHJhY3RHZW9tZXRyeSh0Ll9nZW9tZXRyaWVzW25dKSk7cmV0dXJuIGUuam9pbihcIixcIil9fSxRdD17Y29vcmQodCl7dmFyIGU9dC50cmltKCkuc3BsaXQoanQuc3BhY2VzKSxuPW5ldyBnKE51bWJlci5wYXJzZUZsb2F0KGVbMF0pLE51bWJlci5wYXJzZUZsb2F0KGVbMV0pKTtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShuKSxufSxwb2ludCh0KXtyZXR1cm4gdm9pZCAwPT09dD90aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludCgpOnRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KFF0LmNvb3JkLmNhbGwodGhpcyx0KSl9LG11bHRpcG9pbnQodCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludCgpO3ZhciBlLG49dC50cmltKCkuc3BsaXQoXCIsXCIpLHM9W107Zm9yKGxldCB0PTAsaT1uLmxlbmd0aDt0PGk7Kyt0KWU9blt0XS5yZXBsYWNlKGp0LnRyaW1QYXJlbnMsXCIkMVwiKSxzLnB1c2goUXQucG9pbnQuY2FsbCh0aGlzLGUpKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChzKX0sbGluZXN0cmluZyh0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKCk7dmFyIGU9dC50cmltKCkuc3BsaXQoXCIsXCIpLG49W107Zm9yKGxldCB0PTAscz1lLmxlbmd0aDt0PHM7Kyt0KW4ucHVzaChRdC5jb29yZC5jYWxsKHRoaXMsZVt0XSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKG4pfSxsaW5lYXJyaW5nKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoKTt2YXIgZT10LnRyaW0oKS5zcGxpdChcIixcIiksbj1bXTtmb3IobGV0IHQ9MCxzPWUubGVuZ3RoO3Q8czsrK3Qpbi5wdXNoKFF0LmNvb3JkLmNhbGwodGhpcyxlW3RdKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobil9LG11bHRpbGluZXN0cmluZyh0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTt2YXIgZSxuPXQudHJpbSgpLnNwbGl0KGp0LnBhcmVuQ29tbWEpLHM9W107Zm9yKGxldCB0PTAsaT1uLmxlbmd0aDt0PGk7Kyt0KWU9blt0XS5yZXBsYWNlKGp0LnRyaW1QYXJlbnMsXCIkMVwiKSxzLnB1c2goUXQubGluZXN0cmluZy5jYWxsKHRoaXMsZSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcocyl9LHBvbHlnb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbigpO3ZhciBlLG4scyxpLHI9dC50cmltKCkuc3BsaXQoanQucGFyZW5Db21tYSksbz1bXTtmb3IobGV0IHQ9MCxsPXIubGVuZ3RoO3Q8bDsrK3QpZT1yW3RdLnJlcGxhY2UoanQudHJpbVBhcmVucyxcIiQxXCIpLG49UXQubGluZXN0cmluZy5jYWxsKHRoaXMsZSkscz10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4uX3BvaW50cyksMD09PXQ/aT1zOm8ucHVzaChzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihpLG8pfSxtdWx0aXBvbHlnb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKCk7dmFyIGUsbj10LnRyaW0oKS5zcGxpdChqdC5kb3VibGVQYXJlbkNvbW1hKSxzPVtdO2ZvcihsZXQgdD0wLGk9bi5sZW5ndGg7dDxpOysrdCllPW5bdF0ucmVwbGFjZShqdC50cmltUGFyZW5zLFwiJDFcIikscy5wdXNoKFF0LnBvbHlnb24uY2FsbCh0aGlzLGUpKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKHMpfSxnZW9tZXRyeWNvbGxlY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7dmFyIGU9KHQ9dC5yZXBsYWNlKC8sXFxzKihbQS1aYS16XSkvZyxcInwkMVwiKSkudHJpbSgpLnNwbGl0KFwifFwiKSxuPVtdO2ZvcihsZXQgdD0wLHM9ZS5sZW5ndGg7dDxzOysrdCluLnB1c2godGhpcy5yZWFkKGVbdF0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG4pfX07Y2xhc3MgSnR7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9bmV3IEt0KHQpfXdyaXRlKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX1zdGF0aWMgdG9MaW5lU3RyaW5nKHQsZSl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO3JldHVyblwiTElORVNUUklORyAoIFwiK3QueCtcIiBcIit0LnkrXCIsIFwiK2UueCtcIiBcIitlLnkrXCIgKVwifX1jbGFzcyAkdHtjb25zdHJ1Y3RvcigpeyR0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXB1dGVFZGdlRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9TWF0aC5hYnMobi54LWUueCksaT1NYXRoLmFicyhuLnktZS55KTtsZXQgcj0tMTtpZih0LmVxdWFscyhlKSlyPTA7ZWxzZSBpZih0LmVxdWFscyhuKSlyPXM+aT9zOmk7ZWxzZXtjb25zdCBuPU1hdGguYWJzKHQueC1lLngpLG89TWF0aC5hYnModC55LWUueSk7cj1zPmk/bjpvLDAhPT1yfHx0LmVxdWFscyhlKXx8KHI9TWF0aC5tYXgobixvKSl9cmV0dXJuIHUuaXNUcnVlKCEoMD09PXImJiF0LmVxdWFscyhlKSksXCJCYWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIikscn1zdGF0aWMgbm9uUm9idXN0Q29tcHV0ZUVkZ2VEaXN0YW5jZSh0LGUsbil7Y29uc3Qgcz10LngtZS54LGk9dC55LWUueSxyPU1hdGguc3FydChzKnMraSppKTtyZXR1cm4gdS5pc1RydWUoISgwPT09ciYmIXQuZXF1YWxzKGUpKSxcIkludmFsaWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIikscn1nZXRJbmRleEFsb25nU2VnbWVudCh0LGUpe3JldHVybiB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKSx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bZV19Z2V0VG9wb2xvZ3lTdW1tYXJ5KCl7Y29uc3QgdD1uZXcgd3Q7cmV0dXJuIHRoaXMuaXNFbmRQb2ludCgpJiZ0LmFwcGVuZChcIiBlbmRwb2ludFwiKSx0aGlzLl9pc1Byb3BlciYmdC5hcHBlbmQoXCIgcHJvcGVyXCIpLHRoaXMuaXNDb2xsaW5lYXIoKSYmdC5hcHBlbmQoXCIgY29sbGluZWFyXCIpLHQudG9TdHJpbmcoKX1jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSxuLHMpe3RoaXMuX2lucHV0TGluZXNbMF1bMF09dCx0aGlzLl9pbnB1dExpbmVzWzBdWzFdPWUsdGhpcy5faW5wdXRMaW5lc1sxXVswXT1uLHRoaXMuX2lucHV0TGluZXNbMV1bMV09cyx0aGlzLl9yZXN1bHQ9dGhpcy5jb21wdXRlSW50ZXJzZWN0KHQsZSxuLHMpfWdldEludGVyc2VjdGlvbk51bSgpe3JldHVybiB0aGlzLl9yZXN1bHR9Y29tcHV0ZUludExpbmVJbmRleCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKW51bGw9PT10aGlzLl9pbnRMaW5lSW5kZXgmJih0aGlzLl9pbnRMaW5lSW5kZXg9QXJyYXkoMikuZmlsbCgpLm1hcCgoKT0+QXJyYXkoMikpLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgwKSx0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMSkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMCk+dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwxKT8odGhpcy5faW50TGluZUluZGV4W3RdWzBdPTAsdGhpcy5faW50TGluZUluZGV4W3RdWzFdPTEpOih0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMF09MSx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMV09MCl9fWlzUHJvcGVyKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2lzUHJvcGVyfXNldFByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX3ByZWNpc2lvbk1vZGVsPXR9aXNJbnRlcmlvckludGVyc2VjdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiEhdGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDApfHwhIXRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigxKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0aGlzLl9yZXN1bHQ7ZSsrKWlmKCF0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0aGlzLl9pbnB1dExpbmVzW3RdWzBdKSYmIXRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHRoaXMuX2lucHV0TGluZXNbdF1bMV0pKXJldHVybiEwO3JldHVybiExfX1nZXRJbnRlcnNlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2ludFB0W3RdfWlzRW5kUG9pbnQoKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmIXRoaXMuX2lzUHJvcGVyfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9yZXN1bHQhPT0kdC5OT19JTlRFUlNFQ1RJT059Z2V0RWRnZURpc3RhbmNlKHQsZSl7cmV0dXJuICR0LmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5faW50UHRbZV0sdGhpcy5faW5wdXRMaW5lc1t0XVswXSx0aGlzLl9pbnB1dExpbmVzW3RdWzFdKX1pc0NvbGxpbmVhcigpe3JldHVybiB0aGlzLl9yZXN1bHQ9PT0kdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OfXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzBdWzBdLHRoaXMuX2lucHV0TGluZXNbMF1bMV0pK1wiIC0gXCIrSnQudG9MaW5lU3RyaW5nKHRoaXMuX2lucHV0TGluZXNbMV1bMF0sdGhpcy5faW5wdXRMaW5lc1sxXVsxXSkrdGhpcy5nZXRUb3BvbG9neVN1bW1hcnkoKX1nZXRFbmRwb2ludCh0LGUpe3JldHVybiB0aGlzLl9pbnB1dExpbmVzW3RdW2VdfWlzSW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fcmVzdWx0O2UrKylpZih0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0KSlyZXR1cm4hMDtyZXR1cm4hMX1nZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQodCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5faW50UHRbdGhpcy5faW50TGluZUluZGV4W3RdW2VdXX1nZXRDbGFzcygpe3JldHVybiAkdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19JHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVzdWx0PW51bGwsdGhpcy5faW5wdXRMaW5lcz1BcnJheSgyKS5maWxsKCkubWFwKCgpPT5BcnJheSgyKSksdGhpcy5faW50UHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5faW50TGluZUluZGV4PW51bGwsdGhpcy5faXNQcm9wZXI9bnVsbCx0aGlzLl9wYT1udWxsLHRoaXMuX3BiPW51bGwsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9pbnRQdFswXT1uZXcgZyx0aGlzLl9pbnRQdFsxXT1uZXcgZyx0aGlzLl9wYT10aGlzLl9pbnRQdFswXSx0aGlzLl9wYj10aGlzLl9pbnRQdFsxXSx0aGlzLl9yZXN1bHQ9MH0sJHQuRE9OVF9JTlRFUlNFQ1Q9MCwkdC5ET19JTlRFUlNFQ1Q9MSwkdC5DT0xMSU5FQVI9MiwkdC5OT19JTlRFUlNFQ1RJT049MCwkdC5QT0lOVF9JTlRFUlNFQ1RJT049MSwkdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OPTI7Y2xhc3MgdGUgZXh0ZW5kcyAkdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpe2xldCBpPXQscj1ELnBvaW50VG9TZWdtZW50KHQsbixzKSxvPUQucG9pbnRUb1NlZ21lbnQoZSxuLHMpO3JldHVybiBvPHImJihyPW8saT1lKSxvPUQucG9pbnRUb1NlZ21lbnQobix0LGUpLG88ciYmKHI9byxpPW4pLG89RC5wb2ludFRvU2VnbWVudChzLHQsZSksbzxyJiYocj1vLGk9cyksaX1pc0luU2VnbWVudEVudmVsb3Blcyh0KXtjb25zdCBlPW5ldyBOKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sdGhpcy5faW5wdXRMaW5lc1swXVsxXSksbj1uZXcgTih0aGlzLl9pbnB1dExpbmVzWzFdWzBdLHRoaXMuX2lucHV0TGluZXNbMV1bMV0pO3JldHVybiBlLmNvbnRhaW5zKHQpJiZuLmNvbnRhaW5zKHQpfWNvbXB1dGVJbnRlcnNlY3Rpb24oKXtpZigzIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gc3VwZXIuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMuX2lzUHJvcGVyPSExLE4uaW50ZXJzZWN0cyhlLG4sdCkmJjA9PT12LmluZGV4KGUsbix0KSYmMD09PXYuaW5kZXgobixlLHQpKXJldHVybiB0aGlzLl9pc1Byb3Blcj0hMCwodC5lcXVhbHMoZSl8fHQuZXF1YWxzKG4pKSYmKHRoaXMuX2lzUHJvcGVyPSExKSx0aGlzLl9yZXN1bHQ9JHQuUE9JTlRfSU5URVJTRUNUSU9OLG51bGw7dGhpcy5fcmVzdWx0PSR0Lk5PX0lOVEVSU0VDVElPTn19bm9ybWFsaXplVG9NaW5pbXVtKHQsZSxuLHMsaSl7aS54PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueCxlLngsbi54LHMueCksaS55PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueSxlLnksbi55LHMueSksdC54LT1pLngsdC55LT1pLnksZS54LT1pLngsZS55LT1pLnksbi54LT1pLngsbi55LT1pLnkscy54LT1pLngscy55LT1pLnl9c2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2xldCBpPW51bGw7dHJ5e2k9Yi5pbnRlcnNlY3Rpb24odCxlLG4scyl9Y2F0Y2gocil7aWYoIShyIGluc3RhbmNlb2YgUykpdGhyb3cgcjtpPXRlLm5lYXJlc3RFbmRwb2ludCh0LGUsbixzKX1yZXR1cm4gaX1pbnRlcnNlY3Rpb24odCxlLG4scyl7bGV0IGk9dGhpcy5pbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbih0LGUsbixzKTtyZXR1cm4gdGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhpKXx8KGk9bmV3IGcodGUubmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpKSksbnVsbCE9PXRoaXMuX3ByZWNpc2lvbk1vZGVsJiZ0aGlzLl9wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShpKSxpfXNtYWxsZXN0SW5BYnNWYWx1ZSh0LGUsbixzKXtsZXQgaT10LHI9TWF0aC5hYnMoaSk7cmV0dXJuIE1hdGguYWJzKGUpPHImJihpPWUscj1NYXRoLmFicyhlKSksTWF0aC5hYnMobik8ciYmKGk9bixyPU1hdGguYWJzKG4pKSxNYXRoLmFicyhzKTxyJiYoaT1zKSxpfWNoZWNrREQodCxlLG4scyxpKXtjb25zdCByPVAuaW50ZXJzZWN0aW9uKHQsZSxuLHMpLG89dGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhyKTtPLm91dC5wcmludGxuKFwiREQgaW4gZW52ID0gXCIrbytcIiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFwiK3IpLGkuZGlzdGFuY2Uocik+MWUtNCYmTy5vdXQucHJpbnRsbihcIkRpc3RhbmNlID0gXCIraS5kaXN0YW5jZShyKSl9aW50ZXJzZWN0aW9uV2l0aE5vcm1hbGl6YXRpb24odCxlLG4scyl7Y29uc3QgaT1uZXcgZyh0KSxyPW5ldyBnKGUpLG89bmV3IGcobiksbD1uZXcgZyhzKSxhPW5ldyBnO3RoaXMubm9ybWFsaXplVG9FbnZDZW50cmUoaSxyLG8sbCxhKTtjb25zdCBjPXRoaXMuc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKGkscixvLGwpO3JldHVybiBjLngrPWEueCxjLnkrPWEueSxjfWNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1OLmludGVyc2VjdHModCxlLG4pLHI9Ti5pbnRlcnNlY3RzKHQsZSxzKSxvPU4uaW50ZXJzZWN0cyhuLHMsdCksbD1OLmludGVyc2VjdHMobixzLGUpO3JldHVybiBpJiZyPyh0aGlzLl9pbnRQdFswXT1uLHRoaXMuX2ludFB0WzFdPXMsJHQuQ09MTElORUFSX0lOVEVSU0VDVElPTik6byYmbD8odGhpcy5faW50UHRbMF09dCx0aGlzLl9pbnRQdFsxXT1lLCR0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT04pOmkmJm8/KHRoaXMuX2ludFB0WzBdPW4sdGhpcy5faW50UHRbMV09dCwhbi5lcXVhbHModCl8fHJ8fGw/JHQuQ09MTElORUFSX0lOVEVSU0VDVElPTjokdC5QT0lOVF9JTlRFUlNFQ1RJT04pOmkmJmw/KHRoaXMuX2ludFB0WzBdPW4sdGhpcy5faW50UHRbMV09ZSwhbi5lcXVhbHMoZSl8fHJ8fG8/JHQuQ09MTElORUFSX0lOVEVSU0VDVElPTjokdC5QT0lOVF9JTlRFUlNFQ1RJT04pOnImJm8/KHRoaXMuX2ludFB0WzBdPXMsdGhpcy5faW50UHRbMV09dCwhcy5lcXVhbHModCl8fGl8fGw/JHQuQ09MTElORUFSX0lOVEVSU0VDVElPTjokdC5QT0lOVF9JTlRFUlNFQ1RJT04pOnImJmw/KHRoaXMuX2ludFB0WzBdPXMsdGhpcy5faW50UHRbMV09ZSwhcy5lcXVhbHMoZSl8fGl8fG8/JHQuQ09MTElORUFSX0lOVEVSU0VDVElPTjokdC5QT0lOVF9JTlRFUlNFQ1RJT04pOiR0Lk5PX0lOVEVSU0VDVElPTn1ub3JtYWxpemVUb0VudkNlbnRyZSh0LGUsbixzLGkpe2NvbnN0IHI9dC54PGUueD90Lng6ZS54LG89dC55PGUueT90Lnk6ZS55LGw9dC54PmUueD90Lng6ZS54LGE9dC55PmUueT90Lnk6ZS55LGM9bi54PHMueD9uLng6cy54LGg9bi55PHMueT9uLnk6cy55LHU9bi54PnMueD9uLng6cy54LGc9bi55PnMueT9uLnk6cy55LGQ9KChyPmM/cjpjKSsobDx1P2w6dSkpLzIsXz0oKG8+aD9vOmgpKyhhPGc/YTpnKSkvMjtpLng9ZCxpLnk9Xyx0LngtPWkueCx0LnktPWkueSxlLngtPWkueCxlLnktPWkueSxuLngtPWkueCxuLnktPWkueSxzLngtPWkueCxzLnktPWkueX1jb21wdXRlSW50ZXJzZWN0KHQsZSxuLHMpe2lmKHRoaXMuX2lzUHJvcGVyPSExLCFOLmludGVyc2VjdHModCxlLG4scykpcmV0dXJuICR0Lk5PX0lOVEVSU0VDVElPTjtjb25zdCBpPXYuaW5kZXgodCxlLG4pLHI9di5pbmRleCh0LGUscyk7aWYoaT4wJiZyPjB8fGk8MCYmcjwwKXJldHVybiAkdC5OT19JTlRFUlNFQ1RJT047Y29uc3Qgbz12LmluZGV4KG4scyx0KSxsPXYuaW5kZXgobixzLGUpO3JldHVybiBvPjAmJmw+MHx8bzwwJiZsPDA/JHQuTk9fSU5URVJTRUNUSU9OOjA9PT1pJiYwPT09ciYmMD09PW8mJjA9PT1sP3RoaXMuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixzKTooMD09PWl8fDA9PT1yfHwwPT09b3x8MD09PWw/KHRoaXMuX2lzUHJvcGVyPSExLHQuZXF1YWxzMkQobil8fHQuZXF1YWxzMkQocyk/dGhpcy5faW50UHRbMF09dDplLmVxdWFsczJEKG4pfHxlLmVxdWFsczJEKHMpP3RoaXMuX2ludFB0WzBdPWU6MD09PWk/dGhpcy5faW50UHRbMF09bmV3IGcobik6MD09PXI/dGhpcy5faW50UHRbMF09bmV3IGcocyk6MD09PW8/dGhpcy5faW50UHRbMF09bmV3IGcodCk6MD09PWwmJih0aGlzLl9pbnRQdFswXT1uZXcgZyhlKSkpOih0aGlzLl9pc1Byb3Blcj0hMCx0aGlzLl9pbnRQdFswXT10aGlzLmludGVyc2VjdGlvbih0LGUsbixzKSksJHQuUE9JTlRfSU5URVJTRUNUSU9OKX1nZXRDbGFzcygpe3JldHVybiB0ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBlZXtjb25zdHJ1Y3Rvcigpe2VlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1pZFBvaW50KHQsZSl7cmV0dXJuIG5ldyBnKCh0LngrZS54KS8yLCh0LnkrZS55KS8yKX1taW5YKCl7cmV0dXJuIE1hdGgubWluKHRoaXMucDAueCx0aGlzLnAxLngpfW9yaWVudGF0aW9uSW5kZXgoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXYuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDApLG49di5pbmRleCh0aGlzLnAwLHRoaXMucDEsdC5wMSk7cmV0dXJuIGU+PTAmJm4+PTB8fGU8PTAmJm48PTA/TWF0aC5tYXgoZSxuKTowfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHYuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQpfX10b0dlb21ldHJ5KHQpe3JldHVybiB0LmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMucDAsdGhpcy5wMV0pfWlzVmVydGljYWwoKXtyZXR1cm4gdGhpcy5wMC54PT09dGhpcy5wMS54fWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBlZSkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLnAwLmVxdWFscyhlLnAwKSYmdGhpcy5wMS5lcXVhbHMoZS5wMSl9aW50ZXJzZWN0aW9uKHQpe2NvbnN0IGU9bmV3IHRlO3JldHVybiBlLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSksZS5oYXNJbnRlcnNlY3Rpb24oKT9lLmdldEludGVyc2VjdGlvbigwKTpudWxsfXByb2plY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuZXF1YWxzKHRoaXMucDApfHx0LmVxdWFscyh0aGlzLnAxKSlyZXR1cm4gbmV3IGcodCk7Y29uc3QgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCksbj1uZXcgZztyZXR1cm4gbi54PXRoaXMucDAueCtlKih0aGlzLnAxLngtdGhpcy5wMC54KSxuLnk9dGhpcy5wMC55K2UqKHRoaXMucDEueS10aGlzLnAwLnkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLnByb2plY3Rpb25GYWN0b3IodC5wMCksbj10aGlzLnByb2plY3Rpb25GYWN0b3IodC5wMSk7aWYoZT49MSYmbj49MSlyZXR1cm4gbnVsbDtpZihlPD0wJiZuPD0wKXJldHVybiBudWxsO2xldCBzPXRoaXMucHJvamVjdCh0LnAwKTtlPDAmJihzPXRoaXMucDApLGU+MSYmKHM9dGhpcy5wMSk7bGV0IGk9dGhpcy5wcm9qZWN0KHQucDEpO3JldHVybiBuPDAmJihpPXRoaXMucDApLG4+MSYmKGk9dGhpcy5wMSksbmV3IGVlKHMsaSl9fW5vcm1hbGl6ZSgpe3RoaXMucDEuY29tcGFyZVRvKHRoaXMucDApPDAmJnRoaXMucmV2ZXJzZSgpfWFuZ2xlKCl7cmV0dXJuIE1hdGguYXRhbjIodGhpcy5wMS55LXRoaXMucDAueSx0aGlzLnAxLngtdGhpcy5wMC54KX1nZXRDb29yZGluYXRlKHQpe3JldHVybiAwPT09dD90aGlzLnAwOnRoaXMucDF9ZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHQpe3JldHVybiBELnBvaW50VG9MaW5lUGVycGVuZGljdWxhcih0LHRoaXMucDAsdGhpcy5wMSl9bWluWSgpe3JldHVybiBNYXRoLm1pbih0aGlzLnAwLnksdGhpcy5wMS55KX1taWRQb2ludCgpe3JldHVybiBlZS5taWRQb2ludCh0aGlzLnAwLHRoaXMucDEpfXByb2plY3Rpb25GYWN0b3IodCl7aWYodC5lcXVhbHModGhpcy5wMCkpcmV0dXJuIDA7aWYodC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIDE7Y29uc3QgZT10aGlzLnAxLngtdGhpcy5wMC54LG49dGhpcy5wMS55LXRoaXMucDAueSxzPWUqZStuKm47cmV0dXJuIHM8PTA/aS5OYU46KCh0LngtdGhpcy5wMC54KSplKyh0LnktdGhpcy5wMC55KSpuKS9zfWNsb3Nlc3RQb2ludHModCl7Y29uc3QgZT10aGlzLmludGVyc2VjdGlvbih0KTtpZihudWxsIT09ZSlyZXR1cm5bZSxlXTtjb25zdCBuPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2xldCBzPWkuTUFYX1ZBTFVFLHI9bnVsbDtjb25zdCBvPXRoaXMuY2xvc2VzdFBvaW50KHQucDApO3M9by5kaXN0YW5jZSh0LnAwKSxuWzBdPW8sblsxXT10LnAwO2NvbnN0IGw9dGhpcy5jbG9zZXN0UG9pbnQodC5wMSk7cj1sLmRpc3RhbmNlKHQucDEpLHI8cyYmKHM9cixuWzBdPWwsblsxXT10LnAxKTtjb25zdCBhPXQuY2xvc2VzdFBvaW50KHRoaXMucDApO3I9YS5kaXN0YW5jZSh0aGlzLnAwKSxyPHMmJihzPXIsblswXT10aGlzLnAwLG5bMV09YSk7Y29uc3QgYz10LmNsb3Nlc3RQb2ludCh0aGlzLnAxKTtyZXR1cm4gcj1jLmRpc3RhbmNlKHRoaXMucDEpLHI8cyYmKHM9cixuWzBdPXRoaXMucDEsblsxXT1jKSxufWNsb3Nlc3RQb2ludCh0KXtjb25zdCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KTtyZXR1cm4gZT4wJiZlPDE/dGhpcy5wcm9qZWN0KHQpOnRoaXMucDAuZGlzdGFuY2UodCk8dGhpcy5wMS5kaXN0YW5jZSh0KT90aGlzLnAwOnRoaXMucDF9bWF4WCgpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLngsdGhpcy5wMS54KX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5wMC5kaXN0YW5jZSh0aGlzLnAxKX1jb21wYXJlVG8odCl7Y29uc3QgZT10LG49dGhpcy5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dGhpcy5wMS5jb21wYXJlVG8oZS5wMSl9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5wMDt0aGlzLnAwPXRoaXMucDEsdGhpcy5wMT10fWVxdWFsc1RvcG8odCl7cmV0dXJuIHRoaXMucDAuZXF1YWxzKHQucDApJiZ0aGlzLnAxLmVxdWFscyh0LnAxKXx8dGhpcy5wMC5lcXVhbHModC5wMSkmJnRoaXMucDEuZXF1YWxzKHQucDApfWxpbmVJbnRlcnNlY3Rpb24odCl7dHJ5e3JldHVybiBiLmludGVyc2VjdGlvbih0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBTKSl0aHJvdyB0fXJldHVybiBudWxsfW1heFkoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC55LHRoaXMucDEueSl9cG9pbnRBbG9uZ09mZnNldCh0LGUpe2NvbnN0IG49dGhpcy5wMC54K3QqKHRoaXMucDEueC10aGlzLnAwLngpLHM9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGk9dGhpcy5wMS54LXRoaXMucDAueCxyPXRoaXMucDEueS10aGlzLnAwLnksbz1NYXRoLnNxcnQoaSppK3Iqcik7bGV0IGw9MCxhPTA7aWYoMCE9PWUpe2lmKG88PTApdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkNhbm5vdCBjb21wdXRlIG9mZnNldCBmcm9tIHplcm8tbGVuZ3RoIGxpbmUgc2VnbWVudFwiKTtsPWUqaS9vLGE9ZSpyL299cmV0dXJuIG5ldyBnKG4tYSxzK2wpfXNldENvb3JkaW5hdGVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29vcmRpbmF0ZXModC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnAwLng9dC54LHRoaXMucDAueT10LnksdGhpcy5wMS54PWUueCx0aGlzLnAxLnk9ZS55fX1zZWdtZW50RnJhY3Rpb24odCl7bGV0IGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO3JldHVybiBlPDA/ZT0wOihlPjF8fGkuaXNOYU4oZSkpJiYoZT0xKSxlfXRvU3RyaW5nKCl7cmV0dXJuXCJMSU5FU1RSSU5HKCBcIit0aGlzLnAwLngrXCIgXCIrdGhpcy5wMC55K1wiLCBcIit0aGlzLnAxLngrXCIgXCIrdGhpcy5wMS55K1wiKVwifWlzSG9yaXpvbnRhbCgpe3JldHVybiB0aGlzLnAwLnk9PT10aGlzLnAxLnl9ZGlzdGFuY2UoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gRC5zZWdtZW50VG9TZWdtZW50KHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEQucG9pbnRUb1NlZ21lbnQodCx0aGlzLnAwLHRoaXMucDEpfX1wb2ludEFsb25nKHQpe2NvbnN0IGU9bmV3IGc7cmV0dXJuIGUueD10aGlzLnAwLngrdCoodGhpcy5wMS54LXRoaXMucDAueCksZS55PXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxlfWhhc2hDb2RlKCl7bGV0IHQ9amF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7dF49MzEqamF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSk7Y29uc3QgZT1NYXRoLnRydW5jKHQpXk1hdGgudHJ1bmModD4+MzIpO2xldCBuPWphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLngpO3JldHVybiBuXj0zMSpqYXZhLmxhbmcuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS55KSxlXihNYXRoLnRydW5jKG4pXk1hdGgudHJ1bmMobj4+MzIpKX1nZXRDbGFzcygpe3JldHVybiBlZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcixhXX19ZWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCllZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBnLG5ldyBnKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtlZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQucDAsdC5wMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wMD10LHRoaXMucDE9ZX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtlZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBnKHQsZSksbmV3IGcobixzKSl9fSxlZS5zZXJpYWxWZXJzaW9uVUlEPTB4MmQyMTcyMTM1ZjQxMWMwMDtjbGFzcyBuZXtjb25zdHJ1Y3Rvcigpe25lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvTG9jYXRpb25TeW1ib2wodCl7c3dpdGNoKHQpe2Nhc2UgbmUuRVhURVJJT1I6cmV0dXJuXCJlXCI7Y2FzZSBuZS5CT1VOREFSWTpyZXR1cm5cImJcIjtjYXNlIG5lLklOVEVSSU9SOnJldHVyblwiaVwiO2Nhc2UgbmUuTk9ORTpyZXR1cm5cIi1cIn10aHJvdyBuZXcgbihcIlVua25vd24gbG9jYXRpb24gdmFsdWU6IFwiK3QpfWdldENsYXNzKCl7cmV0dXJuIG5lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1uZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LG5lLklOVEVSSU9SPTAsbmUuQk9VTkRBUlk9MSxuZS5FWFRFUklPUj0yLG5lLk5PTkU9LTE7Y2xhc3Mgc2V7Y29uc3RydWN0b3IoKXtzZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtYXRjaGVzKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gZT09PXV0LlNZTV9ET05UQ0FSRXx8KGU9PT11dC5TWU1fVFJVRSYmKHQ+PTB8fHQ9PT11dC5UUlVFKXx8KGU9PT11dC5TWU1fRkFMU0UmJnQ9PT11dC5GQUxTRXx8KGU9PT11dC5TWU1fUCYmdD09PXV0LlB8fChlPT09dXQuU1lNX0wmJnQ9PT11dC5MfHxlPT09dXQuU1lNX0EmJnQ9PT11dC5BKSkpKX1pZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IHNlKHQpLm1hdGNoZXMoZSl9fXN0YXRpYyBpc1RydWUodCl7cmV0dXJuIHQ+PTB8fHQ9PT11dC5UUlVFfWlzSW50ZXJzZWN0cygpe3JldHVybiF0aGlzLmlzRGlzam9pbnQoKX1pc0NvdmVycygpe3JldHVybihzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5CT1VOREFSWV0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5JTlRFUklPUl0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5CT1VOREFSWV0pKSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRX1pc0NvdmVyZWRCeSgpe3JldHVybihzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5CT1VOREFSWV0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5JTlRFUklPUl0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5CT1VOREFSWV0pKSYmdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRX1zZXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49TWF0aC50cnVuYyhlLzMpLHM9ZSUzO3RoaXMuX21hdHJpeFtuXVtzXT11dC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbWF0cml4W3RdW2VdPW59fWlzQ29udGFpbnMoKXtyZXR1cm4gc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRX1zZXRBdExlYXN0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPU1hdGgudHJ1bmMoZS8zKSxzPWUlMzt0aGlzLnNldEF0TGVhc3QobixzLHV0LnRvRGltZW5zaW9uVmFsdWUodC5jaGFyQXQoZSkpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbWF0cml4W3RdW2VdPG4mJih0aGlzLl9tYXRyaXhbdF1bZV09bil9fXNldEF0TGVhc3RJZlZhbGlkKHQsZSxuKXt0Pj0wJiZlPj0wJiZ0aGlzLnNldEF0TGVhc3QodCxlLG4pfWlzV2l0aGluKCl7cmV0dXJuIHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSkmJnRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuRVhURVJJT1JdPT09dXQuRkFMU0V9aXNUb3VjaGVzKHQsZSl7cmV0dXJuIHQ+ZT90aGlzLmlzVG91Y2hlcyhlLHQpOih0PT09dXQuQSYmZT09PXV0LkF8fHQ9PT11dC5MJiZlPT09dXQuTHx8dD09PXV0LkwmJmU9PT11dC5BfHx0PT09dXQuUCYmZT09PXV0LkF8fHQ9PT11dC5QJiZlPT09dXQuTCkmJih0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXT09PXV0LkZBTFNFJiYoc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuQk9VTkRBUlldKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuSU5URVJJT1JdKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuQk9VTkRBUlldKSkpfWlzT3ZlcmxhcHModCxlKXtyZXR1cm4gdD09PXV0LlAmJmU9PT11dC5QfHx0PT09dXQuQSYmZT09PXV0LkE/c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdKSYmc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdKTp0PT09dXQuTCYmZT09PXV0LkwmJigxPT09dGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0mJnNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXSkmJnNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXSkpfWlzRXF1YWxzKHQsZSl7cmV0dXJuIHQ9PT1lJiYoc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRSl9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB3dChcIjEyMzQ1Njc4OVwiKTtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdC5zZXRDaGFyQXQoMyplK24sdXQudG9EaW1lbnNpb25TeW1ib2wodGhpcy5fbWF0cml4W2VdW25dKSk7cmV0dXJuIHQudG9TdHJpbmcoKX1zZXRBbGwodCl7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKXRoaXMuX21hdHJpeFtlXVtuXT10fWdldCh0LGUpe3JldHVybiB0aGlzLl9tYXRyaXhbdF1bZV19dHJhbnNwb3NlKCl7bGV0IHQ9dGhpcy5fbWF0cml4WzFdWzBdO3JldHVybiB0aGlzLl9tYXRyaXhbMV1bMF09dGhpcy5fbWF0cml4WzBdWzFdLHRoaXMuX21hdHJpeFswXVsxXT10LHQ9dGhpcy5fbWF0cml4WzJdWzBdLHRoaXMuX21hdHJpeFsyXVswXT10aGlzLl9tYXRyaXhbMF1bMl0sdGhpcy5fbWF0cml4WzBdWzJdPXQsdD10aGlzLl9tYXRyaXhbMl1bMV0sdGhpcy5fbWF0cml4WzJdWzFdPXRoaXMuX21hdHJpeFsxXVsyXSx0aGlzLl9tYXRyaXhbMV1bMl09dCx0aGlzfW1hdGNoZXModCl7aWYoOSE9PXQubGVuZ3RoKXRocm93IG5ldyBuKFwiU2hvdWxkIGJlIGxlbmd0aCA5OiBcIit0KTtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspaWYoIXNlLm1hdGNoZXModGhpcy5fbWF0cml4W2VdW25dLHQuY2hhckF0KDMqZStuKSkpcmV0dXJuITE7cmV0dXJuITB9YWRkKHQpe2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKyl0aGlzLnNldEF0TGVhc3QoZSxuLHQuZ2V0KGUsbikpfWlzRGlzam9pbnQoKXtyZXR1cm4gdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRX1pc0Nyb3NzZXModCxlKXtyZXR1cm4gdD09PXV0LlAmJmU9PT11dC5MfHx0PT09dXQuUCYmZT09PXV0LkF8fHQ9PT11dC5MJiZlPT09dXQuQT9zZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pJiZzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl0pOnQ9PT11dC5MJiZlPT09dXQuUHx8dD09PXV0LkEmJmU9PT11dC5QfHx0PT09dXQuQSYmZT09PXV0Lkw/c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdKTp0PT09dXQuTCYmZT09PXV0LkwmJjA9PT10aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXX1nZXRDbGFzcygpe3JldHVybiBzZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fXNlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX21hdHJpeD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX21hdHJpeD1BcnJheSgzKS5maWxsKCkubWFwKCgpPT5BcnJheSgzKSksdGhpcy5zZXRBbGwodXQuRkFMU0UpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07c2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyksdGhpcy5zZXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHNlKXtjb25zdCB0PWFyZ3VtZW50c1swXTtzZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXT10Ll9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkJPVU5EQVJZXT10Ll9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXT10Ll9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLklOVEVSSU9SXT10Ll9tYXRyaXhbbmUuQk9VTkRBUlldW25lLklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkJPVU5EQVJZXT10Ll9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkVYVEVSSU9SXT10Ll9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkVYVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXT10Ll9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkJPVU5EQVJZXT10Ll9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkVYVEVSSU9SXT10Ll9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkVYVEVSSU9SXX19O2NsYXNzIGlle2NvbnN0cnVjdG9yKCl7aWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9EZWdyZWVzKHQpe3JldHVybiAxODAqdC9NYXRoLlBJfXN0YXRpYyBub3JtYWxpemUodCl7Zm9yKDt0Pk1hdGguUEk7KXQtPWllLlBJX1RJTUVTXzI7Zm9yKDt0PD0tTWF0aC5QSTspdCs9aWUuUElfVElNRVNfMjtyZXR1cm4gdH1zdGF0aWMgYW5nbGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYXRhbjIodC55LHQueCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ZS54LXQueCxzPWUueS10Lnk7cmV0dXJuIE1hdGguYXRhbjIocyxuKX19c3RhdGljIGlzQWN1dGUodCxlLG4pe2NvbnN0IHM9dC54LWUueCxpPXQueS1lLnk7cmV0dXJuIHMqKG4ueC1lLngpK2kqKG4ueS1lLnkpPjB9c3RhdGljIGlzT2J0dXNlKHQsZSxuKXtjb25zdCBzPXQueC1lLngsaT10LnktZS55O3JldHVybiBzKihuLngtZS54KStpKihuLnktZS55KTwwfXN0YXRpYyBpbnRlcmlvckFuZ2xlKHQsZSxuKXtjb25zdCBzPWllLmFuZ2xlKGUsdCksaT1pZS5hbmdsZShlLG4pO3JldHVybiBNYXRoLmFicyhpLXMpfXN0YXRpYyBub3JtYWxpemVQb3NpdGl2ZSh0KXtpZih0PDApe2Zvcig7dDwwOyl0Kz1pZS5QSV9USU1FU18yO3Q+PWllLlBJX1RJTUVTXzImJih0PTApfWVsc2V7Zm9yKDt0Pj1pZS5QSV9USU1FU18yOyl0LT1pZS5QSV9USU1FU18yO3Q8MCYmKHQ9MCl9cmV0dXJuIHR9c3RhdGljIGFuZ2xlQmV0d2Vlbih0LGUsbil7Y29uc3Qgcz1pZS5hbmdsZShlLHQpLGk9aWUuYW5nbGUoZSxuKTtyZXR1cm4gaWUuZGlmZihzLGkpfXN0YXRpYyBkaWZmKHQsZSl7bGV0IG49bnVsbDtyZXR1cm4gbj10PGU/ZS10OnQtZSxuPk1hdGguUEkmJihuPTIqTWF0aC5QSS1uKSxufXN0YXRpYyB0b1JhZGlhbnModCl7cmV0dXJuIHQqTWF0aC5QSS8xODB9c3RhdGljIGdldFR1cm4odCxlKXtjb25zdCBuPU1hdGguc2luKGUtdCk7cmV0dXJuIG4+MD9pZS5DT1VOVEVSQ0xPQ0tXSVNFOm48MD9pZS5DTE9DS1dJU0U6aWUuTk9ORX1zdGF0aWMgYW5nbGVCZXR3ZWVuT3JpZW50ZWQodCxlLG4pe2NvbnN0IHM9aWUuYW5nbGUoZSx0KSxpPWllLmFuZ2xlKGUsbiktcztyZXR1cm4gaTw9LU1hdGguUEk/aStpZS5QSV9USU1FU18yOmk+TWF0aC5QST9pLWllLlBJX1RJTUVTXzI6aX1nZXRDbGFzcygpe3JldHVybiBpZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxpZS5QSV9USU1FU18yPTIqTWF0aC5QSSxpZS5QSV9PVkVSXzI9TWF0aC5QSS8yLGllLlBJX09WRVJfND1NYXRoLlBJLzQsaWUuQ09VTlRFUkNMT0NLV0lTRT12LkNPVU5URVJDTE9DS1dJU0UsaWUuQ0xPQ0tXSVNFPXYuQ0xPQ0tXSVNFLGllLk5PTkU9di5DT0xMSU5FQVI7Y2xhc3MgcmV7Y29uc3RydWN0b3IoKXtyZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBhcmVhKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnMoKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMil9c3RhdGljIHNpZ25lZEFyZWEodCxlLG4pe3JldHVybigobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzJ9c3RhdGljIGRldCh0LGUsbixzKXtyZXR1cm4gdCpzLWUqbn1zdGF0aWMgaW50ZXJwb2xhdGVaKHQsZSxuLHMpe2NvbnN0IGk9ZS54LHI9ZS55LG89bi54LWksbD1zLngtaSxhPW4ueS1yLGM9cy55LXIsaD1vKmMtbCphLHU9dC54LWksZz10LnktcixkPShjKnUtbCpnKS9oLF89KC1hKnUrbypnKS9oO3JldHVybiBlLnorZCoobi56LWUueikrXyoocy56LWUueil9c3RhdGljIGxvbmdlc3RTaWRlTGVuZ3RoKHQsZSxuKXtjb25zdCBzPXQuZGlzdGFuY2UoZSksaT1lLmRpc3RhbmNlKG4pLHI9bi5kaXN0YW5jZSh0KTtsZXQgbz1zO3JldHVybiBpPm8mJihvPWkpLHI+byYmKG89ciksb31zdGF0aWMgaXNBY3V0ZSh0LGUsbil7cmV0dXJuISFpZS5pc0FjdXRlKHQsZSxuKSYmKCEhaWUuaXNBY3V0ZShlLG4sdCkmJiEhaWUuaXNBY3V0ZShuLHQsZSkpfXN0YXRpYyBjaXJjdW1jZW50cmUodCxlLG4pe2NvbnN0IHM9bi54LGk9bi55LHI9dC54LXMsbz10LnktaSxsPWUueC1zLGE9ZS55LWksYz0yKnJlLmRldChyLG8sbCxhKSxoPXJlLmRldChvLHIqcitvKm8sYSxsKmwrYSphKSx1PXJlLmRldChyLHIqcitvKm8sbCxsKmwrYSphKTtyZXR1cm4gbmV3IGcocy1oL2MsaSt1L2MpfXN0YXRpYyBwZXJwZW5kaWN1bGFyQmlzZWN0b3IodCxlKXtjb25zdCBuPWUueC10Lngscz1lLnktdC55LGk9bmV3IGIodC54K24vMix0Lnkrcy8yLDEpLHI9bmV3IGIodC54LXMrbi8yLHQueStuK3MvMiwxKTtyZXR1cm4gbmV3IGIoaSxyKX1zdGF0aWMgYW5nbGVCaXNlY3Rvcih0LGUsbil7Y29uc3Qgcz1lLmRpc3RhbmNlKHQpLGk9cy8ocytlLmRpc3RhbmNlKG4pKSxyPW4ueC10Lngsbz1uLnktdC55O3JldHVybiBuZXcgZyh0LngraSpyLHQueStpKm8pfXN0YXRpYyBhcmVhM0QodCxlLG4pe2NvbnN0IHM9ZS54LXQueCxpPWUueS10Lnkscj1lLnotdC56LG89bi54LXQueCxsPW4ueS10LnksYT1uLnotdC56LGM9aSphLXIqbCxoPXIqby1zKmEsdT1zKmwtaSpvLGc9YypjK2gqaCt1KnU7cmV0dXJuIE1hdGguc3FydChnKS8yfXN0YXRpYyBjZW50cm9pZCh0LGUsbil7Y29uc3Qgcz0odC54K2UueCtuLngpLzMsaT0odC55K2UueStuLnkpLzM7cmV0dXJuIG5ldyBnKHMsaSl9c3RhdGljIGluQ2VudHJlKHQsZSxuKXtjb25zdCBzPWUuZGlzdGFuY2UobiksaT10LmRpc3RhbmNlKG4pLHI9dC5kaXN0YW5jZShlKSxvPXMraStyLGw9KHMqdC54K2kqZS54K3Iqbi54KS9vLGE9KHMqdC55K2kqZS55K3Iqbi55KS9vO3JldHVybiBuZXcgZyhsLGEpfWFyZWEoKXtyZXR1cm4gcmUuYXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9c2lnbmVkQXJlYSgpe3JldHVybiByZS5zaWduZWRBcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1pbnRlcnBvbGF0ZVoodCl7aWYobnVsbD09PXQpdGhyb3cgbmV3IG4oXCJTdXBwbGllZCBwb2ludCBpcyBudWxsLlwiKTtyZXR1cm4gcmUuaW50ZXJwb2xhdGVaKHQsdGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWxvbmdlc3RTaWRlTGVuZ3RoKCl7cmV0dXJuIHJlLmxvbmdlc3RTaWRlTGVuZ3RoKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1pc0FjdXRlKCl7cmV0dXJuIHJlLmlzQWN1dGUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWNpcmN1bWNlbnRyZSgpe3JldHVybiByZS5jaXJjdW1jZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWFyZWEzRCgpe3JldHVybiByZS5hcmVhM0QodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWNlbnRyb2lkKCl7cmV0dXJuIHJlLmNlbnRyb2lkKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1pbkNlbnRyZSgpe3JldHVybiByZS5pbkNlbnRyZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9Z2V0Q2xhc3MoKXtyZXR1cm4gcmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXJlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsdGhpcy5wMj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMucDA9dCx0aGlzLnAxPWUsdGhpcy5wMj1ufTtjbGFzcyBvZSBleHRlbmRzIEN7Y29uc3RydWN0b3IoKXtzdXBlcigpLG9lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gb2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW9lLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKUMuY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Qy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX07Y2xhc3MgbGV7Y29uc3RydWN0b3IoKXtsZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0cmFuc2xhdGlvbkluc3RhbmNlKHQsZSl7Y29uc3Qgbj1uZXcgbGU7cmV0dXJuIG4uc2V0VG9UcmFuc2xhdGlvbih0LGUpLG59c3RhdGljIHNoZWFySW5zdGFuY2UodCxlKXtjb25zdCBuPW5ldyBsZTtyZXR1cm4gbi5zZXRUb1NoZWFyKHQsZSksbn1zdGF0aWMgcmVmbGVjdGlvbkluc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlO3JldHVybiBuLnNldFRvUmVmbGVjdGlvbih0LGUpLG59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGxlO3JldHVybiBpLnNldFRvUmVmbGVjdGlvbih0LGUsbixzKSxpfX1zdGF0aWMgcm90YXRpb25JbnN0YW5jZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbGUucm90YXRpb25JbnN0YW5jZShNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlO3JldHVybiBuLnNldFRvUm90YXRpb24odCxlKSxufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbGUucm90YXRpb25JbnN0YW5jZShNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSxlLG4pfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBsZTtyZXR1cm4gaS5zZXRUb1JvdGF0aW9uKHQsZSxuLHMpLGl9fXN0YXRpYyBzY2FsZUluc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlO3JldHVybiBuLnNldFRvU2NhbGUodCxlKSxufWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBsZTtyZXR1cm4gaS50cmFuc2xhdGUoLW4sLXMpLGkuc2NhbGUodCxlKSxpLnRyYW5zbGF0ZShuLHMpLGl9fXNldFRvUmVmbGVjdGlvbkJhc2ljKHQsZSxzLGkpe2lmKHQ9PT1zJiZlPT09aSl0aHJvdyBuZXcgbihcIlJlZmxlY3Rpb24gbGluZSBwb2ludHMgbXVzdCBiZSBkaXN0aW5jdFwiKTtjb25zdCByPXMtdCxvPWktZSxsPU1hdGguc3FydChyKnIrbypvKSxhPW8vbCxjPXIvbCxoPTIqYSpjLHU9YypjLWEqYTtyZXR1cm4gdGhpcy5fbTAwPXUsdGhpcy5fbTAxPWgsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPWgsdGhpcy5fbTExPS11LHRoaXMuX20xMj0wLHRoaXN9Z2V0SW52ZXJzZSgpe2NvbnN0IHQ9dGhpcy5nZXREZXRlcm1pbmFudCgpO2lmKDA9PT10KXRocm93IG5ldyBvZShcIlRyYW5zZm9ybWF0aW9uIGlzIG5vbi1pbnZlcnRpYmxlXCIpO2NvbnN0IGU9dGhpcy5fbTExL3Qsbj0tdGhpcy5fbTEwL3Qscz0tdGhpcy5fbTAxL3QsaT10aGlzLl9tMDAvdCxyPSh0aGlzLl9tMDEqdGhpcy5fbTEyLXRoaXMuX20wMip0aGlzLl9tMTEpL3Qsbz0oLXRoaXMuX20wMCp0aGlzLl9tMTIrdGhpcy5fbTEwKnRoaXMuX20wMikvdDtyZXR1cm4gbmV3IGxlKGUscyxyLG4saSxvKX1jb21wb3NlKHQpe2NvbnN0IGU9dC5fbTAwKnRoaXMuX20wMCt0Ll9tMDEqdGhpcy5fbTEwLG49dC5fbTAwKnRoaXMuX20wMSt0Ll9tMDEqdGhpcy5fbTExLHM9dC5fbTAwKnRoaXMuX20wMit0Ll9tMDEqdGhpcy5fbTEyK3QuX20wMixpPXQuX20xMCp0aGlzLl9tMDArdC5fbTExKnRoaXMuX20xMCxyPXQuX20xMCp0aGlzLl9tMDErdC5fbTExKnRoaXMuX20xMSxvPXQuX20xMCp0aGlzLl9tMDIrdC5fbTExKnRoaXMuX20xMit0Ll9tMTI7cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT1uLHRoaXMuX20wMj1zLHRoaXMuX20xMD1pLHRoaXMuX20xMT1yLHRoaXMuX20xMj1vLHRoaXN9ZXF1YWxzKHQpe2lmKG51bGw9PT10KXJldHVybiExO2lmKCEodCBpbnN0YW5jZW9mIGxlKSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX20wMD09PWUuX20wMCYmdGhpcy5fbTAxPT09ZS5fbTAxJiZ0aGlzLl9tMDI9PT1lLl9tMDImJnRoaXMuX20xMD09PWUuX20xMCYmdGhpcy5fbTExPT09ZS5fbTExJiZ0aGlzLl9tMTI9PT1lLl9tMTJ9c2V0VG9TY2FsZSh0LGUpe3JldHVybiB0aGlzLl9tMDA9dCx0aGlzLl9tMDE9MCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9MCx0aGlzLl9tMTE9ZSx0aGlzLl9tMTI9MCx0aGlzfWlzSWRlbnRpdHkoKXtyZXR1cm4gMT09PXRoaXMuX20wMCYmMD09PXRoaXMuX20wMSYmMD09PXRoaXMuX20wMiYmMD09PXRoaXMuX20xMCYmMT09PXRoaXMuX20xMSYmMD09PXRoaXMuX20xMn1zY2FsZSh0LGUpe3JldHVybiB0aGlzLmNvbXBvc2UobGUuc2NhbGVJbnN0YW5jZSh0LGUpKSx0aGlzfXNldFRvSWRlbnRpdHkoKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPTAsdGhpcy5fbTExPTEsdGhpcy5fbTEyPTAsdGhpc31pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiEwfXNldFRyYW5zZm9ybWF0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9tMDA9dC5fbTAwLHRoaXMuX20wMT10Ll9tMDEsdGhpcy5fbTAyPXQuX20wMix0aGlzLl9tMTA9dC5fbTEwLHRoaXMuX20xMT10Ll9tMTEsdGhpcy5fbTEyPXQuX20xMix0aGlzfWlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtyZXR1cm4gdGhpcy5fbTAwPXQsdGhpcy5fbTAxPWUsdGhpcy5fbTAyPW4sdGhpcy5fbTEwPXMsdGhpcy5fbTExPWksdGhpcy5fbTEyPXIsdGhpc319c2V0VG9Sb3RhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZXRUb1JvdGF0aW9uKE1hdGguc2luKHQpLE1hdGguY29zKHQpKSx0aGlzfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPS10LHRoaXMuX20wMj0wLHRoaXMuX20xMD10LHRoaXMuX20xMT1lLHRoaXMuX20xMj0wLHRoaXN9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLnNldFRvUm90YXRpb24oTWF0aC5zaW4odCksTWF0aC5jb3ModCksZSxuKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPS10LHRoaXMuX20wMj1uLW4qZStzKnQsdGhpcy5fbTEwPXQsdGhpcy5fbTExPWUsdGhpcy5fbTEyPXMtbip0LXMqZSx0aGlzfX1nZXRNYXRyaXhFbnRyaWVzKCl7cmV0dXJuW3RoaXMuX20wMCx0aGlzLl9tMDEsdGhpcy5fbTAyLHRoaXMuX20xMCx0aGlzLl9tMTEsdGhpcy5fbTEyXX1maWx0ZXIodCxlKXt0aGlzLnRyYW5zZm9ybSh0LGUpfXJvdGF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnJvdGF0aW9uSW5zdGFuY2UodCkpLHRoaXN9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXBvc2UobGUucm90YXRpb25JbnN0YW5jZSh0LGUpKSx0aGlzfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnJvdGF0aW9uSW5zdGFuY2UodCxlLG4pKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnJvdGF0aW9uSW5zdGFuY2UodCxlKSksdGhpc319Z2V0RGV0ZXJtaW5hbnQoKXtyZXR1cm4gdGhpcy5fbTAwKnRoaXMuX20xMS10aGlzLl9tMDEqdGhpcy5fbTEwfWNvbXBvc2VCZWZvcmUodCl7Y29uc3QgZT10aGlzLl9tMDAqdC5fbTAwK3RoaXMuX20wMSp0Ll9tMTAsbj10aGlzLl9tMDAqdC5fbTAxK3RoaXMuX20wMSp0Ll9tMTEscz10aGlzLl9tMDAqdC5fbTAyK3RoaXMuX20wMSp0Ll9tMTIrdGhpcy5fbTAyLGk9dGhpcy5fbTEwKnQuX20wMCt0aGlzLl9tMTEqdC5fbTEwLHI9dGhpcy5fbTEwKnQuX20wMSt0aGlzLl9tMTEqdC5fbTExLG89dGhpcy5fbTEwKnQuX20wMit0aGlzLl9tMTEqdC5fbTEyK3RoaXMuX20xMjtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPW4sdGhpcy5fbTAyPXMsdGhpcy5fbTEwPWksdGhpcy5fbTExPXIsdGhpcy5fbTEyPW8sdGhpc31zZXRUb1NoZWFyKHQsZSl7cmV0dXJuIHRoaXMuX20wMD0xLHRoaXMuX20wMT10LHRoaXMuX20wMj0wLHRoaXMuX20xMD1lLHRoaXMuX20xMT0xLHRoaXMuX20xMj0wLHRoaXN9aXNEb25lKCl7cmV0dXJuITF9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgQykpdGhyb3cgdDt1LnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIG51bGx9dHJhbnNsYXRlKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShsZS50cmFuc2xhdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9c2V0VG9SZWZsZWN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgbihcIlJlZmxlY3Rpb24gdmVjdG9yIG11c3QgYmUgbm9uLXplcm9cIik7aWYodD09PWUpcmV0dXJuIHRoaXMuX20wMD0wLHRoaXMuX20wMT0xLHRoaXMuX20wMj0wLHRoaXMuX20xMD0xLHRoaXMuX20xMT0wLHRoaXMuX20xMj0wLHRoaXM7Y29uc3Qgcz1NYXRoLnNxcnQodCp0K2UqZSksaT1lL3Mscj10L3M7cmV0dXJuIHRoaXMucm90YXRlKC1pLHIpLHRoaXMuc2NhbGUoMSwtMSksdGhpcy5yb3RhdGUoaSxyKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTtpZih0PT09cyYmZT09PWkpdGhyb3cgbmV3IG4oXCJSZWZsZWN0aW9uIGxpbmUgcG9pbnRzIG11c3QgYmUgZGlzdGluY3RcIik7dGhpcy5zZXRUb1RyYW5zbGF0aW9uKC10LC1lKTtjb25zdCByPXMtdCxvPWktZSxsPU1hdGguc3FydChyKnIrbypvKSxhPW8vbCxjPXIvbDtyZXR1cm4gdGhpcy5yb3RhdGUoLWEsYyksdGhpcy5zY2FsZSgxLC0xKSx0aGlzLnJvdGF0ZShhLGMpLHRoaXMudHJhbnNsYXRlKHQsZSksdGhpc319dG9TdHJpbmcoKXtyZXR1cm5cIkFmZmluZVRyYW5zZm9ybWF0aW9uW1tcIit0aGlzLl9tMDArXCIsIFwiK3RoaXMuX20wMStcIiwgXCIrdGhpcy5fbTAyK1wiXSwgW1wiK3RoaXMuX20xMCtcIiwgXCIrdGhpcy5fbTExK1wiLCBcIit0aGlzLl9tMTIrXCJdXVwifXNldFRvVHJhbnNsYXRpb24odCxlKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPXQsdGhpcy5fbTEwPTAsdGhpcy5fbTExPTEsdGhpcy5fbTEyPWUsdGhpc31zaGVhcih0LGUpe3JldHVybiB0aGlzLmNvbXBvc2UobGUuc2hlYXJJbnN0YW5jZSh0LGUpKSx0aGlzfXRyYW5zZm9ybSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXS5jb3B5KCk7cmV0dXJuIHQuYXBwbHkodGhpcyksdH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fbTAwKnQueCt0aGlzLl9tMDEqdC55K3RoaXMuX20wMixzPXRoaXMuX20xMCp0LngrdGhpcy5fbTExKnQueSt0aGlzLl9tMTI7cmV0dXJuIGUueD1uLGUueT1zLGV9aWYoXyhhcmd1bWVudHNbMF0sQSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9tMDAqdC5nZXRPcmRpbmF0ZShlLDApK3RoaXMuX20wMSp0LmdldE9yZGluYXRlKGUsMSkrdGhpcy5fbTAyLHM9dGhpcy5fbTEwKnQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLl9tMTEqdC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMuX20xMjt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxzKX19fXJlZmxlY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcG9zZShsZS5yZWZsZWN0aW9uSW5zdGFuY2UodCxlKSksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHRoaXMuY29tcG9zZShsZS5yZWZsZWN0aW9uSW5zdGFuY2UodCxlLG4scykpLHRoaXN9fWdldENsYXNzKCl7cmV0dXJuIGxlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvLGR0XX19bGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbTAwPW51bGwsdGhpcy5fbTAxPW51bGwsdGhpcy5fbTAyPW51bGwsdGhpcy5fbTEwPW51bGwsdGhpcy5fbTExPW51bGwsdGhpcy5fbTEyPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5zZXRUb0lkZW50aXR5KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbTAwPXRbMF0sdGhpcy5fbTAxPXRbMV0sdGhpcy5fbTAyPXRbMl0sdGhpcy5fbTEwPXRbM10sdGhpcy5fbTExPXRbNF0sdGhpcy5fbTEyPXRbNV19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGxlKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFRyYW5zZm9ybWF0aW9uKHQpfX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzVdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzRdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzNdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTt0aGlzLnNldFRyYW5zZm9ybWF0aW9uKHQsZSxuLHMsaSxyKX19O2NsYXNzIGFle2NvbnN0cnVjdG9yKCl7YWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc29sdmUodCxlKXtjb25zdCBzPWUubGVuZ3RoO2lmKHQubGVuZ3RoIT09c3x8dFswXS5sZW5ndGghPT1zKXRocm93IG5ldyBuKFwiTWF0cml4IEEgaXMgaW5jb3JyZWN0bHkgc2l6ZWRcIik7Zm9yKGxldCBuPTA7bjxzO24rKyl7bGV0IGk9bjtmb3IobGV0IGU9bisxO2U8cztlKyspTWF0aC5hYnModFtlXVtuXSk+TWF0aC5hYnModFtpXVtuXSkmJihpPWUpO2lmKDA9PT10W2ldW25dKXJldHVybiBudWxsO2FlLnN3YXBSb3dzKHQsbixpKSxhZS5zd2FwUm93cyhlLG4saSk7Zm9yKGxldCBpPW4rMTtpPHM7aSsrKXtjb25zdCByPXRbaV1bbl0vdFtuXVtuXTtmb3IobGV0IGU9cy0xO2U+PW47ZS0tKXRbaV1bZV0tPXRbbl1bZV0qcjtlW2ldLT1lW25dKnJ9fWNvbnN0IGk9bmV3IEFycmF5KHMpLmZpbGwobnVsbCk7Zm9yKGxldCBuPXMtMTtuPj0wO24tLSl7bGV0IHI9MDtmb3IobGV0IGU9bisxO2U8cztlKyspcis9dFtuXVtlXSppW2VdO2lbbl09KGVbbl0tcikvdFtuXVtuXX1yZXR1cm4gaX1zdGF0aWMgc3dhcFJvd3MoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKGxldCBzPTA7czx0WzBdLmxlbmd0aDtzKyspe2NvbnN0IGk9dFtlXVtzXTt0W2VdW3NdPXRbbl1bc10sdFtuXVtzXT1pfX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihlPT09bilyZXR1cm4gbnVsbDtjb25zdCBzPXRbZV07dFtlXT10W25dLHRbbl09c319Z2V0Q2xhc3MoKXtyZXR1cm4gYWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWFlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgY2V7Y29uc3RydWN0b3IoKXtjZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNvbHZlKHQpe2NvbnN0IGU9W1t0aGlzLl9zcmMwLngsdGhpcy5fc3JjMC55LDFdLFt0aGlzLl9zcmMxLngsdGhpcy5fc3JjMS55LDFdLFt0aGlzLl9zcmMyLngsdGhpcy5fc3JjMi55LDFdXTtyZXR1cm4gYWUuc29sdmUoZSx0KX1jb21wdXRlKCl7Y29uc3QgdD1bdGhpcy5fZGVzdDAueCx0aGlzLl9kZXN0MS54LHRoaXMuX2Rlc3QyLnhdLGU9dGhpcy5zb2x2ZSh0KTtpZihudWxsPT09ZSlyZXR1cm4hMTt0aGlzLl9tMDA9ZVswXSx0aGlzLl9tMDE9ZVsxXSx0aGlzLl9tMDI9ZVsyXTtjb25zdCBuPVt0aGlzLl9kZXN0MC55LHRoaXMuX2Rlc3QxLnksdGhpcy5fZGVzdDIueV0scz10aGlzLnNvbHZlKG4pO3JldHVybiBudWxsIT09cyYmKHRoaXMuX20xMD1zWzBdLHRoaXMuX20xMT1zWzFdLHRoaXMuX20xMj1zWzJdLCEwKX1nZXRUcmFuc2Zvcm1hdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGUoKT9uZXcgbGUodGhpcy5fbTAwLHRoaXMuX20wMSx0aGlzLl9tMDIsdGhpcy5fbTEwLHRoaXMuX20xMSx0aGlzLl9tMTIpOm51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gY2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NyYzA9bnVsbCx0aGlzLl9zcmMxPW51bGwsdGhpcy5fc3JjMj1udWxsLHRoaXMuX2Rlc3QwPW51bGwsdGhpcy5fZGVzdDE9bnVsbCx0aGlzLl9kZXN0Mj1udWxsLHRoaXMuX20wMD1udWxsLHRoaXMuX20wMT1udWxsLHRoaXMuX20wMj1udWxsLHRoaXMuX20xMD1udWxsLHRoaXMuX20xMT1udWxsLHRoaXMuX20xMj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3RoaXMuX3NyYzA9dCx0aGlzLl9zcmMxPWUsdGhpcy5fc3JjMj1uLHRoaXMuX2Rlc3QwPXMsdGhpcy5fZGVzdDE9aSx0aGlzLl9kZXN0Mj1yfTtjbGFzcyBoZXtjb25zdHJ1Y3Rvcigpe2hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNyZWF0ZUZyb21CYXNlTGluZXModCxlLG4scyl7Y29uc3QgaT1uZXcgZyh0Lngrcy54LW4ueCx0Lnkrcy55LW4ueSkscj1pZS5hbmdsZUJldHdlZW5PcmllbnRlZChlLHQsaSksbz1lLmRpc3RhbmNlKHQpLGw9cy5kaXN0YW5jZShuKTtpZigwPT09bylyZXR1cm4gbmV3IGxlO2NvbnN0IGE9bC9vLGM9bGUudHJhbnNsYXRpb25JbnN0YW5jZSgtdC54LC10LnkpO3JldHVybiBjLnJvdGF0ZShyKSxjLnNjYWxlKGEsYSksYy50cmFuc2xhdGUobi54LG4ueSksY31zdGF0aWMgY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWUueC10Lngscz1lLnktdC55O3JldHVybiBsZS50cmFuc2xhdGlvbkluc3RhbmNlKG4scyl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgbihcIlNyYyBhbmQgRGVzdCBhcnJheXMgYXJlIG5vdCB0aGUgc2FtZSBsZW5ndGhcIik7aWYodC5sZW5ndGg8PTApdGhyb3cgbmV3IG4oXCJUb28gZmV3IGNvbnRyb2wgcG9pbnRzXCIpO2lmKHQubGVuZ3RoPjMpdGhyb3cgbmV3IG4oXCJUb28gbWFueSBjb250cm9sIHBvaW50c1wiKTtyZXR1cm4gMT09PXQubGVuZ3RoP2hlLmNyZWF0ZUZyb21Db250cm9sVmVjdG9ycyh0WzBdLGVbMF0pOjI9PT10Lmxlbmd0aD9oZS5jcmVhdGVGcm9tQ29udHJvbFZlY3RvcnModFswXSx0WzFdLGVbMF0sZVsxXSk6aGUuY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKHRbMF0sdFsxXSx0WzJdLGVbMF0sZVsxXSxlWzJdKX19ZWxzZXtpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgZyhzLngtbi54LHMueS1uLnkpLHI9aWUuYW5nbGVCZXR3ZWVuT3JpZW50ZWQoZSx0LGkpLG89ZS5kaXN0YW5jZSh0KSxsPXMuZGlzdGFuY2Uobik7aWYoMD09PW8pcmV0dXJuIG51bGw7Y29uc3QgYT1sL28sYz1sZS50cmFuc2xhdGlvbkluc3RhbmNlKC10LngsLXQueSk7cmV0dXJuIGMucm90YXRlKHIpLGMuc2NhbGUoYSxhKSxjLnRyYW5zbGF0ZShuLngsbi55KSxjfWlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtyZXR1cm4gbmV3IGNlKHQsZSxuLHMsaSxyKS5nZXRUcmFuc2Zvcm1hdGlvbigpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gaGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWhlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgdWV7Y29uc3RydWN0b3IoKXt1ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyB4O3JldHVybiB0LmFwcGx5KG5ldyB1ZShlKSksZX1maWx0ZXIodCl7KHQgaW5zdGFuY2VvZiBUdHx8dCBpbnN0YW5jZW9mIFB0KSYmdGhpcy5fY29vcmRzLmFkZCh0LmdldENvb3JkaW5hdGUoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gdWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ddfX11ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb29yZHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb29yZHM9dH07Y2xhc3MgZ2V7Y29uc3RydWN0b3IoKXtnZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtYXAodCxlKXtyZXR1cm4gbmV3IGdlKGUpLm1hcCh0KX1tYXAodCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10aGlzLl9tYXBPcC5tYXAodC5nZXRHZW9tZXRyeU4obikpO3MuaXNFbXB0eSgpfHxlLmFkZChzKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEh0LnRvR2VvbWV0cnlBcnJheShlKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gZ2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWdlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX21hcE9wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWFwT3A9dH07Y2xhc3MgZGV7Y29uc3RydWN0b3IoKXtkZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21iaW5lKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgZGUodCkuY29tYmluZSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IGRlKGRlLmNyZWF0ZUxpc3QodCxlKSkuY29tYmluZSgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbmV3IGRlKGRlLmNyZWF0ZUxpc3QodCxlLG4pKS5jb21iaW5lKCl9fXN0YXRpYyBleHRyYWN0RmFjdG9yeSh0KXtyZXR1cm4gdC5pc0VtcHR5KCk/bnVsbDp0Lml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKX1zdGF0aWMgY3JlYXRlTGlzdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB4O3JldHVybiBuLmFkZCh0KSxuLmFkZChlKSxufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyB4O3JldHVybiBzLmFkZCh0KSxzLmFkZChlKSxzLmFkZChuKSxzfX1leHRyYWN0RWxlbWVudHModCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKTt0aGlzLl9za2lwRW1wdHkmJnMuaXNFbXB0eSgpfHxlLmFkZChzKX19Y29tYmluZSgpe2NvbnN0IHQ9bmV3IHg7Zm9yKGxldCBlPXRoaXMuX2lucHV0R2VvbXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5leHRyYWN0RWxlbWVudHMobix0KX1yZXR1cm4gMD09PXQuc2l6ZSgpP251bGwhPT10aGlzLl9nZW9tRmFjdG9yeT90aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTpudWxsOnRoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gZGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWRlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5fc2tpcEVtcHR5PSExLHRoaXMuX2lucHV0R2VvbXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdG9yeT1kZS5leHRyYWN0RmFjdG9yeSh0KSx0aGlzLl9pbnB1dEdlb21zPXR9O2NsYXNzIF9le2NvbnN0cnVjdG9yKCl7X2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNPZlR5cGUodCxlKXtyZXR1cm4gdC5nZXRHZW9tZXRyeVR5cGUoKT09PWV8fGU9PT1xLlRZUEVOQU1FX0xJTkVTVFJJTkcmJnQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1xLlRZUEVOQU1FX0xJTkVBUlJJTkd9c3RhdGljIGV4dHJhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIF9lLmV4dHJhY3QodCxlLG5ldyB4KX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMl0sbSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1lP24uYWRkKHQpOnQgaW5zdGFuY2VvZiBfdCYmdC5hcHBseShuZXcgX2UoZSxuKSksbn1pZihfKGFyZ3VtZW50c1syXSxtKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIENsYXNzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gX2UuZXh0cmFjdCh0LF9lLnRvR2VvbWV0cnlUeXBlKGUpLG4pfX19ZmlsdGVyKHQpeyhudWxsPT09dGhpcy5fZ2VvbWV0cnlUeXBlfHxfZS5pc09mVHlwZSh0LHRoaXMuX2dlb21ldHJ5VHlwZSkpJiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gX2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2d0XX19X2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ2VvbWV0cnlUeXBlPW51bGwsdGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tZXRyeVR5cGU9dCx0aGlzLl9jb21wcz1lfTtjbGFzcyBmZXtjb25zdHJ1Y3Rvcigpe2ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bWFwKHQpe31nZXRDbGFzcygpe3JldHVybiBmZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBwZXtjb25zdHJ1Y3Rvcigpe3BlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1hcCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXyhhcmd1bWVudHNbMV0sZmUpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB4O2ZvcihsZXQgcz0wO3M8dC5nZXROdW1HZW9tZXRyaWVzKCk7cysrKXtjb25zdCBpPWUubWFwKHQuZ2V0R2VvbWV0cnlOKHMpKTtudWxsIT09aSYmbi5hZGQoaSl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkobil9aWYoXyhhcmd1bWVudHNbMF0sZikmJl8oYXJndW1lbnRzWzFdLGZlKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgeDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPWUubWFwKHQpO251bGwhPT1pJiZuLmFkZChpKX1yZXR1cm4gbn19Z2V0Q2xhc3MoKXtyZXR1cm4gcGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXBlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgbWV7Y29uc3RydWN0b3IoKXttZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXRyYW5zZm9ybVBvaW50KHQsZSl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7bGV0IG49ITA7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSx0KTtudWxsIT09cyYmcyBpbnN0YW5jZW9mIER0JiYhcy5pc0VtcHR5KCl8fChuPSExKTtjb25zdCBpPW5ldyB4O2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihlKSx0KTtudWxsPT09c3x8cy5pc0VtcHR5KCl8fChzIGluc3RhbmNlb2YgRHR8fChuPSExKSxpLmFkZChzKSl9aWYobilyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHMsaS50b0FycmF5KFtdKSk7e2NvbnN0IHQ9bmV3IHg7cmV0dXJuIG51bGwhPT1zJiZ0LmFkZChzKSx0LmFkZEFsbChpKSx0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodCl9fWNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZSh0KXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpfWdldElucHV0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tfXRyYW5zZm9ybU11bHRpTGluZVN0cmluZyh0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQuZ2V0R2VvbWV0cnlOKGUpLHQpO251bGwhPT1zJiYocy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7cmV0dXJuIHRoaXMuY29weSh0KX10cmFuc2Zvcm1MaW5lU3RyaW5nKHQsZSl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfXRyYW5zZm9ybU11bHRpUG9pbnQodCxlKXtjb25zdCBuPW5ldyB4O2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtUG9pbnQodC5nZXRHZW9tZXRyeU4oZSksdCk7bnVsbCE9PXMmJihzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybVBvbHlnb24odC5nZXRHZW9tZXRyeU4oZSksdCk7bnVsbCE9PXMmJihzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9Y29weSh0KXtyZXR1cm4gdC5jb3B5KCl9dHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybSh0LmdldEdlb21ldHJ5TihlKSk7bnVsbCE9PXMmJih0aGlzLl9wcnVuZUVtcHR5R2VvbWV0cnkmJnMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX3ByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT90aGlzLl9mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihIdC50b0dlb21ldHJ5QXJyYXkobikpOnRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX10cmFuc2Zvcm0odCl7aWYodGhpcy5faW5wdXRHZW9tPXQsdGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSx0IGluc3RhbmNlb2YgUHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgTXQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBEdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIFR0KXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgZnQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGJ0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgQXQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIF90KXJldHVybiB0aGlzLnRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbih0LG51bGwpO3Rocm93IG5ldyBuKFwiVW5rbm93biBHZW9tZXRyeSBzdWJ0eXBlOiBcIit0LmdldENsYXNzKCkuZ2V0TmFtZSgpKX10cmFuc2Zvcm1MaW5lYXJSaW5nKHQsZSl7Y29uc3Qgbj10aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCk7aWYobnVsbD09PW4pcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhudWxsKTtjb25zdCBzPW4uc2l6ZSgpO3JldHVybiBzPjAmJnM8NCYmIXRoaXMuX3ByZXNlcnZlVHlwZT90aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobik6dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4pfWdldENsYXNzKCl7cmV0dXJuIG1lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1tZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fcHJ1bmVFbXB0eUdlb21ldHJ5PSEwLHRoaXMuX3ByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT0hMCx0aGlzLl9wcmVzZXJ2ZUNvbGxlY3Rpb25zPSExLHRoaXMuX3ByZXNlcnZlVHlwZT0hMX07Y2xhc3MgeWV7Y29uc3RydWN0b3IoKXt5ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRHZW9tZXRyeSh0KXtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh5ZS5nZXRMaW5lcyh0KSl9c3RhdGljIGdldExpbmVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB5ZS5nZXRMaW5lcyh0LG5ldyB4KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiBUdD9lLmFkZCh0KTp0IGluc3RhbmNlb2YgX3QmJnQuYXBwbHkobmV3IHllKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4geWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2d0XX19eWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wcz10fTtjbGFzcyB4ZXtjb25zdHJ1Y3Rvcigpe3hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldEdlb21ldHJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHhlLmdldExpbmVzKHQpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoeGUuZ2V0TGluZXModCxlKSl9fXN0YXRpYyBnZXRMaW5lcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4geGUuZ2V0TGluZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLGYpJiZfKGFyZ3VtZW50c1sxXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7eGUuZ2V0TGluZXModCxlKX1yZXR1cm4gZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB4O3JldHVybiB0LmFwcGx5KG5ldyB4ZShuLGUpKSxufWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXyhhcmd1bWVudHNbMV0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgVHQ/ZS5hZGQodCk6dC5hcHBseShuZXcgeGUoZSkpLGV9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZfKGFyZ3VtZW50c1swXSxmKSYmXyhhcmd1bWVudHNbMV0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3hlLmdldExpbmVzKHQsZSxuKX1yZXR1cm4gZX1pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZfKGFyZ3VtZW50c1sxXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQuYXBwbHkobmV3IHhlKGUsbikpLGV9fX1maWx0ZXIodCl7aWYodGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmcmJnQgaW5zdGFuY2VvZiBEdCl7Y29uc3QgZT10LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO3JldHVybiB0aGlzLl9saW5lcy5hZGQoZSksbnVsbH10IGluc3RhbmNlb2YgVHQmJnRoaXMuX2xpbmVzLmFkZCh0KX1zZXRGb3JjZVRvTGluZVN0cmluZyh0KXt0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz10fWdldENsYXNzKCl7cmV0dXJuIHhlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX19eGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbGluZXM9bnVsbCx0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz0hMSwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZXM9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9saW5lcz10LHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nPWV9fTtjb25zdCBFZT17cmV2ZXJzZU9yZGVyOmZ1bmN0aW9uKCl7cmV0dXJue2NvbXBhcmU6KHQsZSk9PmUuY29tcGFyZVRvKHQpfX0sbWluOmZ1bmN0aW9uKHQpe3JldHVybiBFZS5zb3J0KHQpLHQuZ2V0KDApfSxzb3J0OmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10LnRvQXJyYXkoKTtlP2h0LnNvcnQobixlKTpodC5zb3J0KG4pO2NvbnN0IHM9dC5pdGVyYXRvcigpO2ZvcihsZXQgdD0wLGU9bi5sZW5ndGg7dDxlO3QrKylzLm5leHQoKSxzLnNldChuW3RdKX0sc2luZ2xldG9uTGlzdDpmdW5jdGlvbih0KXtjb25zdCBlPW5ldyB4O3JldHVybiBlLmFkZCh0KSxlfX07Y2xhc3MgSWV7Y29uc3RydWN0b3IoKXtJZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRQb2ludHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQgaW5zdGFuY2VvZiBQdD9FZS5zaW5nbGV0b25MaXN0KHQpOkllLmdldFBvaW50cyh0LG5ldyB4KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiBQdD9lLmFkZCh0KTp0IGluc3RhbmNlb2YgX3QmJnQuYXBwbHkobmV3IEllKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIFB0JiZ0aGlzLl9wdHMuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIEllfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltndF19fUllLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0cz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0cz10fTtjbGFzcyBOZXtjb25zdHJ1Y3Rvcigpe05lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldFBvbHlnb25zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBOZS5nZXRQb2x5Z29ucyh0LG5ldyB4KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiBidD9lLmFkZCh0KTp0IGluc3RhbmNlb2YgX3QmJnQuYXBwbHkobmV3IE5lKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIGJ0JiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gTmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2d0XX19TmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wcz10fTtjbGFzcyBDZXtjb25zdHJ1Y3Rvcigpe0NlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YXBwbHlUbyh0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpJiYhdGhpcy5faXNEb25lO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZihuIGluc3RhbmNlb2YgX3QpdGhpcy5hcHBseVRvKG4pO2Vsc2UgaWYodGhpcy52aXNpdChuKSx0aGlzLmlzRG9uZSgpKXJldHVybiB0aGlzLl9pc0RvbmU9ITAsbnVsbH19Z2V0Q2xhc3MoKXtyZXR1cm4gQ2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUNlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzRG9uZT0hMX07Y2xhc3MgU2V7Y29uc3RydWN0b3IoKXtTZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZVN1cGVyY2lyY2xlKHQpe2NvbnN0IGU9MS90LG49dGhpcy5fZGltLmdldE1pblNpemUoKS8yLHM9dGhpcy5fZGltLmdldENlbnRyZSgpLGk9TWF0aC5wb3cobix0KSxyPW4sbz1NYXRoLnBvdyhpLzIsZSksbD1NYXRoLnRydW5jKHRoaXMuX25QdHMvOCksYT1uZXcgQXJyYXkoOCpsKzEpLmZpbGwobnVsbCksYz1vL2w7Zm9yKGxldCBuPTA7bjw9bDtuKyspe2xldCBvPTAsaD1yO2lmKDAhPT1uKXtvPWMqbjtjb25zdCBzPU1hdGgucG93KG8sdCk7aD1NYXRoLnBvdyhpLXMsZSl9YVtuXT10aGlzLmNvb3JkVHJhbnMobyxoLHMpLGFbMipsLW5dPXRoaXMuY29vcmRUcmFucyhoLG8scyksYVsyKmwrbl09dGhpcy5jb29yZFRyYW5zKGgsLW8scyksYVs0Kmwtbl09dGhpcy5jb29yZFRyYW5zKG8sLWgscyksYVs0Kmwrbl09dGhpcy5jb29yZFRyYW5zKC1vLC1oLHMpLGFbNipsLW5dPXRoaXMuY29vcmRUcmFucygtaCwtbyxzKSxhWzYqbCtuXT10aGlzLmNvb3JkVHJhbnMoLWgsbyxzKSxhWzgqbC1uXT10aGlzLmNvb3JkVHJhbnMoLW8saCxzKX1hW2EubGVuZ3RoLTFdPW5ldyBnKGFbMF0pO2NvbnN0IGg9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhhKSx1PXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oaCk7cmV0dXJuIHRoaXMucm90YXRlKHUpfXNldE51bVBvaW50cyh0KXt0aGlzLl9uUHRzPXR9c2V0QmFzZSh0KXt0aGlzLl9kaW0uc2V0QmFzZSh0KX1zZXRSb3RhdGlvbih0KXt0aGlzLl9yb3RhdGlvbkFuZ2xlPXR9c2V0V2lkdGgodCl7dGhpcy5fZGltLnNldFdpZHRoKHQpfWNyZWF0ZUVsbGlwc2UoKXtjb25zdCB0PXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLGU9dC5nZXRXaWR0aCgpLzIsbj10LmdldEhlaWdodCgpLzIscz10LmdldE1pblgoKStlLGk9dC5nZXRNaW5ZKCkrbixyPW5ldyBBcnJheSh0aGlzLl9uUHRzKzEpLmZpbGwobnVsbCk7bGV0IG89MDtmb3IobGV0IHQ9MDt0PHRoaXMuX25QdHM7dCsrKXtjb25zdCBsPXQqKDIqTWF0aC5QSS90aGlzLl9uUHRzKSxhPWUqTWF0aC5jb3MobCkrcyxjPW4qTWF0aC5zaW4obCkraTtyW28rK109dGhpcy5jb29yZChhLGMpfXJbb109bmV3IGcoclswXSk7Y29uc3QgbD10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKHIpLGE9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihsKTtyZXR1cm4gdGhpcy5yb3RhdGUoYSl9Y29vcmRUcmFucyh0LGUsbil7cmV0dXJuIHRoaXMuY29vcmQodCtuLngsZStuLnkpfWNyZWF0ZVNxdWlyY2xlKCl7cmV0dXJuIHRoaXMuY3JlYXRlU3VwZXJjaXJjbGUoNCl9c2V0RW52ZWxvcGUodCl7dGhpcy5fZGltLnNldEVudmVsb3BlKHQpfXNldENlbnRyZSh0KXt0aGlzLl9kaW0uc2V0Q2VudHJlKHQpfWNyZWF0ZUFyYyh0LGUpe2NvbnN0IG49dGhpcy5fZGltLmdldEVudmVsb3BlKCkscz1uLmdldFdpZHRoKCkvMixpPW4uZ2V0SGVpZ2h0KCkvMixyPW4uZ2V0TWluWCgpK3Msbz1uLmdldE1pblkoKStpO2xldCBsPWU7KGw8PTB8fGw+MipNYXRoLlBJKSYmKGw9MipNYXRoLlBJKTtjb25zdCBhPWwvKHRoaXMuX25QdHMtMSksYz1uZXcgQXJyYXkodGhpcy5fblB0cykuZmlsbChudWxsKTtsZXQgaD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fblB0cztlKyspe2NvbnN0IG49dCtlKmEsbD1zKk1hdGguY29zKG4pK3IsdT1pKk1hdGguc2luKG4pK287Y1toKytdPXRoaXMuY29vcmQobCx1KX1jb25zdCB1PXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVTdHJpbmcoYyk7cmV0dXJuIHRoaXMucm90YXRlKHUpfXJvdGF0ZSh0KXtpZigwIT09dGhpcy5fcm90YXRpb25BbmdsZSl7Y29uc3QgZT1sZS5yb3RhdGlvbkluc3RhbmNlKHRoaXMuX3JvdGF0aW9uQW5nbGUsdGhpcy5fZGltLmdldENlbnRyZSgpLngsdGhpcy5fZGltLmdldENlbnRyZSgpLnkpO3QuYXBwbHkoZSl9cmV0dXJuIHR9Y29vcmQodCxlKXtjb25zdCBuPW5ldyBnKHQsZSk7cmV0dXJuIHRoaXMuX3ByZWNNb2RlbC5tYWtlUHJlY2lzZShuKSxufWNyZWF0ZUFyY1BvbHlnb24odCxlKXtjb25zdCBuPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLHM9bi5nZXRXaWR0aCgpLzIsaT1uLmdldEhlaWdodCgpLzIscj1uLmdldE1pblgoKStzLG89bi5nZXRNaW5ZKCkraTtsZXQgbD1lOyhsPD0wfHxsPjIqTWF0aC5QSSkmJihsPTIqTWF0aC5QSSk7Y29uc3QgYT1sLyh0aGlzLl9uUHRzLTEpLGM9bmV3IEFycmF5KHRoaXMuX25QdHMrMikuZmlsbChudWxsKTtsZXQgaD0wO2NbaCsrXT10aGlzLmNvb3JkKHIsbyk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9uUHRzO2UrKyl7Y29uc3Qgbj10K2EqZSxsPXMqTWF0aC5jb3Mobikrcix1PWkqTWF0aC5zaW4obikrbztjW2grK109dGhpcy5jb29yZChsLHUpfWNbaCsrXT10aGlzLmNvb3JkKHIsbyk7Y29uc3QgdT10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKGMpLGc9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbih1KTtyZXR1cm4gdGhpcy5yb3RhdGUoZyl9Y3JlYXRlUmVjdGFuZ2xlKCl7bGV0IHQ9bnVsbCxlPTAsbj1NYXRoLnRydW5jKHRoaXMuX25QdHMvNCk7bjwxJiYobj0xKTtjb25zdCBzPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLmdldFdpZHRoKCkvbixpPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLmdldEhlaWdodCgpL24scj1uZXcgQXJyYXkoNCpuKzEpLmZpbGwobnVsbCksbz10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKTtmb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNaW5YKCkrdCpzLGk9by5nZXRNaW5ZKCk7cltlKytdPXRoaXMuY29vcmQobixpKX1mb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNYXhYKCkscz1vLmdldE1pblkoKSt0Kmk7cltlKytdPXRoaXMuY29vcmQobixzKX1mb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNYXhYKCktdCpzLGk9by5nZXRNYXhZKCk7cltlKytdPXRoaXMuY29vcmQobixpKX1mb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNaW5YKCkscz1vLmdldE1heFkoKS10Kmk7cltlKytdPXRoaXMuY29vcmQobixzKX1yW2UrK109bmV3IGcoclswXSk7Y29uc3QgbD10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKHIpLGE9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihsKTtyZXR1cm4gdGhpcy5yb3RhdGUoYSl9Y3JlYXRlQ2lyY2xlKCl7cmV0dXJuIHRoaXMuY3JlYXRlRWxsaXBzZSgpfXNldEhlaWdodCh0KXt0aGlzLl9kaW0uc2V0SGVpZ2h0KHQpfXNldFNpemUodCl7dGhpcy5fZGltLnNldFNpemUodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gU2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHdle2NvbnN0cnVjdG9yKCl7d2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRCYXNlKHQpe3RoaXMuYmFzZT10fXNldFdpZHRoKHQpe3RoaXMud2lkdGg9dH1nZXRCYXNlKCl7cmV0dXJuIHRoaXMuYmFzZX1nZXRXaWR0aCgpe3JldHVybiB0aGlzLndpZHRofXNldEVudmVsb3BlKHQpe3RoaXMud2lkdGg9dC5nZXRXaWR0aCgpLHRoaXMuaGVpZ2h0PXQuZ2V0SGVpZ2h0KCksdGhpcy5iYXNlPW5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSx0aGlzLmNlbnRyZT1uZXcgZyh0LmNlbnRyZSgpKX1zZXRDZW50cmUodCl7dGhpcy5jZW50cmU9dH1nZXRNaW5TaXplKCl7cmV0dXJuIE1hdGgubWluKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpfWdldEVudmVsb3BlKCl7cmV0dXJuIG51bGwhPT10aGlzLmJhc2U/bmV3IE4odGhpcy5iYXNlLngsdGhpcy5iYXNlLngrdGhpcy53aWR0aCx0aGlzLmJhc2UueSx0aGlzLmJhc2UueSt0aGlzLmhlaWdodCk6bnVsbCE9PXRoaXMuY2VudHJlP25ldyBOKHRoaXMuY2VudHJlLngtdGhpcy53aWR0aC8yLHRoaXMuY2VudHJlLngrdGhpcy53aWR0aC8yLHRoaXMuY2VudHJlLnktdGhpcy5oZWlnaHQvMix0aGlzLmNlbnRyZS55K3RoaXMuaGVpZ2h0LzIpOm5ldyBOKDAsdGhpcy53aWR0aCwwLHRoaXMuaGVpZ2h0KX1nZXRDZW50cmUoKXtyZXR1cm4gbnVsbD09PXRoaXMuY2VudHJlJiYodGhpcy5jZW50cmU9bmV3IGcodGhpcy5iYXNlLngrdGhpcy53aWR0aC8yLHRoaXMuYmFzZS55K3RoaXMuaGVpZ2h0LzIpKSx0aGlzLmNlbnRyZX1nZXRIZWlnaHQoKXtyZXR1cm4gdGhpcy5oZWlnaHR9c2V0SGVpZ2h0KHQpe3RoaXMuaGVpZ2h0PXR9c2V0U2l6ZSh0KXt0aGlzLmhlaWdodD10LHRoaXMud2lkdGg9dH1nZXRDbGFzcygpe3JldHVybiB3ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19d2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5iYXNlPW51bGwsdGhpcy5jZW50cmU9bnVsbCx0aGlzLndpZHRoPW51bGwsdGhpcy5oZWlnaHQ9bnVsbH0sU2UuRGltZW5zaW9ucz13ZSxTZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX3ByZWNNb2RlbD1udWxsLHRoaXMuX2RpbT1uZXcgd2UsdGhpcy5fblB0cz0xMDAsdGhpcy5fcm90YXRpb25BbmdsZT0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKVNlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IEh0KTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdD10LHRoaXMuX3ByZWNNb2RlbD10LmdldFByZWNpc2lvbk1vZGVsKCl9fTtjbGFzcyBMZSBleHRlbmRzIFNle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxMZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldE51bUFybXModCl7dGhpcy5fbnVtQXJtcz10fXNldEFybUxlbmd0aFJhdGlvKHQpe3RoaXMuX2FybUxlbmd0aFJhdGlvPXR9Y3JlYXRlU2luZVN0YXIoKXtjb25zdCB0PXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLGU9dC5nZXRXaWR0aCgpLzI7bGV0IG49dGhpcy5fYXJtTGVuZ3RoUmF0aW87bjwwJiYobj0wKSxuPjEmJihuPTEpO2NvbnN0IHM9biplLGk9KDEtbikqZSxyPXQuZ2V0TWluWCgpK2Usbz10LmdldE1pblkoKStlLGw9bmV3IEFycmF5KHRoaXMuX25QdHMrMSkuZmlsbChudWxsKTtsZXQgYT0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5fblB0czt0Kyspe2NvbnN0IGU9dC90aGlzLl9uUHRzKnRoaXMuX251bUFybXMsbj1lLU1hdGguZmxvb3IoZSksYz0yKk1hdGguUEkqbixoPWkrcyooKE1hdGguY29zKGMpKzEpLzIpLHU9dCooMipNYXRoLlBJL3RoaXMuX25QdHMpLGc9aCpNYXRoLmNvcyh1KStyLGQ9aCpNYXRoLnNpbih1KStvO2xbYSsrXT10aGlzLmNvb3JkKGcsZCl9bFthXT1uZXcgZyhsWzBdKTtjb25zdCBjPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcobCk7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oYyl9Z2V0Q2xhc3MoKXtyZXR1cm4gTGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUxlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX251bUFybXM9OCx0aGlzLl9hcm1MZW5ndGhSYXRpbz0uNSwwPT09YXJndW1lbnRzLmxlbmd0aClTZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtTZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX07dmFyIFRlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFmZmluZVRyYW5zZm9ybWF0aW9uOmxlLEFmZmluZVRyYW5zZm9ybWF0aW9uQnVpbGRlcjpjZSxBZmZpbmVUcmFuc2Zvcm1hdGlvbkZhY3Rvcnk6aGUsQ29tcG9uZW50Q29vcmRpbmF0ZUV4dHJhY3Rlcjp1ZSxHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXI6Z2UsR2VvbWV0cnlDb21iaW5lcjpkZSxHZW9tZXRyeUVkaXRvcjpGdCxHZW9tZXRyeUV4dHJhY3RlcjpfZSxHZW9tZXRyeU1hcHBlcjpwZSxHZW9tZXRyeVRyYW5zZm9ybWVyOm1lLExpbmVTdHJpbmdFeHRyYWN0ZXI6eWUsTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyOnhlLE1hcE9wOmZlLFBvaW50RXh0cmFjdGVyOkllLFBvbHlnb25FeHRyYWN0ZXI6TmUsU2hvcnRDaXJjdWl0ZWRHZW9tZXRyeVZpc2l0b3I6Q2UsU2luZVN0YXJGYWN0b3J5OkxlfSksUmU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29vcmRpbmF0ZTpnLENvb3JkaW5hdGVMaXN0OkksRW52ZWxvcGU6TixMaW5lU2VnbWVudDplZSxHZW9tZXRyeUZhY3Rvcnk6SHQsR2VvbWV0cnk6cSxQb2ludDpQdCxMaW5lU3RyaW5nOlR0LExpbmVhclJpbmc6RHQsUG9seWdvbjpidCxHZW9tZXRyeUNvbGxlY3Rpb246X3QsTXVsdGlQb2ludDpNdCxNdWx0aUxpbmVTdHJpbmc6ZnQsTXVsdGlQb2x5Z29uOkF0LERpbWVuc2lvbjp1dCxJbnRlcnNlY3Rpb25NYXRyaXg6c2UsUHJlY2lzaW9uTW9kZWw6a3QsTG9jYXRpb246bmUsVHJpYW5nbGU6cmUsdXRpbDpUZX0pO2NsYXNzIFBle2NvbnN0cnVjdG9yKCl7UGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdFt0XX1zZXRNaW5pbXVtKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TWluaW11bSh0Ll9wdFswXSx0Ll9wdFsxXSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5faXNOdWxsKXJldHVybiB0aGlzLmluaXRpYWxpemUodCxlKSxudWxsO2NvbnN0IG49dC5kaXN0YW5jZShlKTtuPHRoaXMuX2Rpc3RhbmNlJiZ0aGlzLmluaXRpYWxpemUodCxlLG4pfX1pbml0aWFsaXplKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5faXNOdWxsPSEwO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUodCksdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShlKSx0aGlzLl9kaXN0YW5jZT10LmRpc3RhbmNlKGUpLHRoaXMuX2lzTnVsbD0hMX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHQpLHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUoZSksdGhpcy5fZGlzdGFuY2U9bix0aGlzLl9pc051bGw9ITF9fXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyh0aGlzLl9wdFswXSx0aGlzLl9wdFsxXSl9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2V9c2V0TWF4aW11bSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldE1heGltdW0odC5fcHRbMF0sdC5fcHRbMV0pfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuX2lzTnVsbClyZXR1cm4gdGhpcy5pbml0aWFsaXplKHQsZSksbnVsbDtjb25zdCBuPXQuZGlzdGFuY2UoZSk7bj50aGlzLl9kaXN0YW5jZSYmdGhpcy5pbml0aWFsaXplKHQsZSxuKX19Z2V0Q2xhc3MoKXtyZXR1cm4gUGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVBlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0PVtuZXcgZyxuZXcgZ10sdGhpcy5fZGlzdGFuY2U9aS5OYU4sdGhpcy5faXNOdWxsPSEwfTtjbGFzcyB2ZXtjb25zdHJ1Y3Rvcigpe3ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXB1dGVEaXN0YW5jZSgpe2lmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUGUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgZWUsaT10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxpLmxlbmd0aC0xO3QrKyl7cy5zZXRDb29yZGluYXRlcyhpW3RdLGlbdCsxXSk7Y29uc3Qgcj1zLmNsb3Nlc3RQb2ludChlKTtuLnNldE1pbmltdW0ocixlKX19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFBlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3ZlLmNvbXB1dGVEaXN0YW5jZSh0LmdldEV4dGVyaW9yUmluZygpLGUsbik7Zm9yKGxldCBzPTA7czx0LmdldE51bUludGVyaW9yUmluZygpO3MrKyl2ZS5jb21wdXRlRGlzdGFuY2UodC5nZXRJbnRlcmlvclJpbmdOKHMpLGUsbil9ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFBlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodCBpbnN0YW5jZW9mIFR0KXZlLmNvbXB1dGVEaXN0YW5jZSh0LGUsbik7ZWxzZSBpZih0IGluc3RhbmNlb2YgYnQpdmUuY29tcHV0ZURpc3RhbmNlKHQsZSxuKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBfdCl7Y29uc3Qgcz10O2ZvcihsZXQgdD0wO3Q8cy5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBpPXMuZ2V0R2VvbWV0cnlOKHQpO3ZlLmNvbXB1dGVEaXN0YW5jZShpLGUsbil9fWVsc2Ugbi5zZXRNaW5pbXVtKHQuZ2V0Q29vcmRpbmF0ZSgpLGUpfWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBQZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPXQuY2xvc2VzdFBvaW50KGUpO24uc2V0TWluaW11bShzLGUpfX1nZXRDbGFzcygpe3JldHVybiB2ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBPZXtjb25zdHJ1Y3Rvcigpe09lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRpc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgT2UodCxlKS5kaXN0YW5jZSgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBPZSh0LGUpO3JldHVybiBzLnNldERlbnNpZnlGcmFjdGlvbihuKSxzLmRpc3RhbmNlKCl9fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0RGlzdC5nZXRDb29yZGluYXRlcygpfXNldERlbnNpZnlGcmFjdGlvbih0KXtpZih0PjF8fHQ8PTApdGhyb3cgbmV3IG4oXCJGcmFjdGlvbiBpcyBub3QgaW4gcmFuZ2UgKDAuMCAtIDEuMF1cIik7dGhpcy5fZGVuc2lmeUZyYWM9dH1jb21wdXRlKHQsZSl7dGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0LGUsdGhpcy5fcHREaXN0KSx0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKGUsdCx0aGlzLl9wdERpc3QpfWRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSh0aGlzLl9nMCx0aGlzLl9nMSksdGhpcy5fcHREaXN0LmdldERpc3RhbmNlKCl9Y29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9bmV3IGJlKGUpO2lmKHQuYXBwbHkocyksbi5zZXRNYXhpbXVtKHMuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKSx0aGlzLl9kZW5zaWZ5RnJhYz4wKXtjb25zdCBzPW5ldyBNZShlLHRoaXMuX2RlbnNpZnlGcmFjKTt0LmFwcGx5KHMpLG4uc2V0TWF4aW11bShzLmdldE1heFBvaW50RGlzdGFuY2UoKSl9fW9yaWVudGVkRGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0aGlzLl9nMCx0aGlzLl9nMSx0aGlzLl9wdERpc3QpLHRoaXMuX3B0RGlzdC5nZXREaXN0YW5jZSgpfWdldENsYXNzKCl7cmV0dXJuIE9lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBiZXtjb25zdHJ1Y3Rvcigpe2JlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe3RoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCksdmUuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sdCx0aGlzLl9taW5QdERpc3QpLHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCl9Z2V0TWF4UG9pbnREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9tYXhQdERpc3R9Z2V0Q2xhc3MoKXtyZXR1cm4gYmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0JdfX1iZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9tYXhQdERpc3Q9bmV3IFBlLHRoaXMuX21pblB0RGlzdD1uZXcgUGUsdGhpcy5fZXVjbGlkZWFuRGlzdD1uZXcgdmUsdGhpcy5fZ2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb209dH07Y2xhc3MgTWV7Y29uc3RydWN0b3IoKXtNZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0LGUpe2lmKDA9PT1lKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRDb29yZGluYXRlKGUtMSkscz10LmdldENvb3JkaW5hdGUoZSksaT0ocy54LW4ueCkvdGhpcy5fbnVtU3ViU2VncyxyPShzLnktbi55KS90aGlzLl9udW1TdWJTZWdzO2ZvcihsZXQgdD0wO3Q8dGhpcy5fbnVtU3ViU2Vnczt0Kyspe2NvbnN0IGU9bi54K3QqaSxzPW4ueSt0KnIsbz1uZXcgZyhlLHMpO3RoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCksdmUuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sbyx0aGlzLl9taW5QdERpc3QpLHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCl9fWlzRG9uZSgpe3JldHVybiExfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITF9Z2V0TWF4UG9pbnREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9tYXhQdERpc3R9Z2V0Q2xhc3MoKXtyZXR1cm4gTWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2R0XX19TWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbWF4UHREaXN0PW5ldyBQZSx0aGlzLl9taW5QdERpc3Q9bmV3IFBlLHRoaXMuX2dlb209bnVsbCx0aGlzLl9udW1TdWJTZWdzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbT10LHRoaXMuX251bVN1YlNlZ3M9TWF0aC50cnVuYyhNYXRoLnJvdW5kKDEvZSkpfSxPZS5NYXhQb2ludERpc3RhbmNlRmlsdGVyPWJlLE9lLk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlcj1NZSxPZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nMD1udWxsLHRoaXMuX2cxPW51bGwsdGhpcy5fcHREaXN0PW5ldyBQZSx0aGlzLl9kZW5zaWZ5RnJhYz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2cwPXQsdGhpcy5fZzE9ZX07dmFyIERlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2U6T2UsRGlzdGFuY2VUb1BvaW50OnZlLFBvaW50UGFpckRpc3RhbmNlOlBlfSk7Y2xhc3MgQWV7Y29uc3RydWN0b3IoKXtBZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0SXRlbSh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gQWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUFlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgRmV7Y29uc3RydWN0b3IoKXtGZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWxvY2F0ZSh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gRmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUZlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgR2V7Y29uc3RydWN0b3IoKXtHZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE1pbigpe3JldHVybiB0aGlzLl9taW59aW50ZXJzZWN0cyh0LGUpe3JldHVybiEodGhpcy5fbWluPmV8fHRoaXMuX21heDx0KX1nZXRNYXgoKXtyZXR1cm4gdGhpcy5fbWF4fXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyhuZXcgZyh0aGlzLl9taW4sMCksbmV3IGcodGhpcy5fbWF4LDApKX1nZXRDbGFzcygpe3JldHVybiBHZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgcWV7Y29uc3RydWN0b3IoKXtxZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lLGk9KG4uX21pbituLl9tYXgpLzIscj0ocy5fbWluK3MuX21heCkvMjtyZXR1cm4gaTxyPy0xOmk+cj8xOjB9Z2V0Q2xhc3MoKXtyZXR1cm4gcWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1xZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LEdlLk5vZGVDb21wYXJhdG9yPXFlLEdlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX21pbj1pLlBPU0lUSVZFX0lORklOSVRZLHRoaXMuX21heD1pLk5FR0FUSVZFX0lORklOSVRZfTtjbGFzcyBCZSBleHRlbmRzIEdle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxCZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXF1ZXJ5KHQsZSxuKXtpZighdGhpcy5pbnRlcnNlY3RzKHQsZSkpcmV0dXJuIG51bGw7bi52aXNpdEl0ZW0odGhpcy5faXRlbSl9Z2V0Q2xhc3MoKXtyZXR1cm4gQmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUJlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2l0ZW09bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9taW49dCx0aGlzLl9tYXg9ZSx0aGlzLl9pdGVtPW59O2NsYXNzIFZlIGV4dGVuZHMgR2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLFZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YnVpbGRFeHRlbnQodCxlKXt0aGlzLl9taW49TWF0aC5taW4odC5fbWluLGUuX21pbiksdGhpcy5fbWF4PU1hdGgubWF4KHQuX21heCxlLl9tYXgpfXF1ZXJ5KHQsZSxuKXtpZighdGhpcy5pbnRlcnNlY3RzKHQsZSkpcmV0dXJuIG51bGw7bnVsbCE9PXRoaXMuX25vZGUxJiZ0aGlzLl9ub2RlMS5xdWVyeSh0LGUsbiksbnVsbCE9PXRoaXMuX25vZGUyJiZ0aGlzLl9ub2RlMi5xdWVyeSh0LGUsbil9Z2V0Q2xhc3MoKXtyZXR1cm4gVmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVZlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25vZGUxPW51bGwsdGhpcy5fbm9kZTI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ub2RlMT10LHRoaXMuX25vZGUyPWUsdGhpcy5idWlsZEV4dGVudCh0aGlzLl9ub2RlMSx0aGlzLl9ub2RlMil9O2NsYXNzIHple2NvbnN0cnVjdG9yKCl7emUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1idWlsZFRyZWUoKXtFZS5zb3J0KHRoaXMuX2xlYXZlcyxuZXcgR2UuTm9kZUNvbXBhcmF0b3IpO2xldCB0PXRoaXMuX2xlYXZlcyxlPW51bGwsbj1uZXcgeDtmb3IoOzspe2lmKHRoaXMuYnVpbGRMZXZlbCh0LG4pLDE9PT1uLnNpemUoKSlyZXR1cm4gbi5nZXQoMCk7ZT10LHQ9bixuPWV9fWluc2VydCh0LGUsbil7aWYobnVsbCE9PXRoaXMuX3Jvb3QpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkluZGV4IGNhbm5vdCBiZSBhZGRlZCB0byBvbmNlIGl0IGhhcyBiZWVuIHF1ZXJpZWRcIik7dGhpcy5fbGVhdmVzLmFkZChuZXcgQmUodCxlLG4pKX1xdWVyeSh0LGUsbil7dGhpcy5pbml0KCksdGhpcy5fcm9vdC5xdWVyeSh0LGUsbil9YnVpbGRSb290KCl7aWYobnVsbCE9PXRoaXMuX3Jvb3QpcmV0dXJuIG51bGw7dGhpcy5fcm9vdD10aGlzLmJ1aWxkVHJlZSgpfXByaW50Tm9kZSh0KXtPLm91dC5wcmludGxuKEp0LnRvTGluZVN0cmluZyhuZXcgZyh0Ll9taW4sdGhpcy5fbGV2ZWwpLG5ldyBnKHQuX21heCx0aGlzLl9sZXZlbCkpKX1pbml0KCl7aWYobnVsbCE9PXRoaXMuX3Jvb3QpcmV0dXJuIG51bGw7dGhpcy5idWlsZFJvb3QoKX1idWlsZExldmVsKHQsZSl7dGhpcy5fbGV2ZWwrKyxlLmNsZWFyKCk7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKz0yKXtjb25zdCBzPXQuZ2V0KG4pO2lmKG51bGw9PT0obisxPHQuc2l6ZSgpP3QuZ2V0KG4pOm51bGwpKWUuYWRkKHMpO2Vsc2V7Y29uc3Qgcz1uZXcgVmUodC5nZXQobiksdC5nZXQobisxKSk7ZS5hZGQocyl9fX1nZXRDbGFzcygpe3JldHVybiB6ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19emUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGVhdmVzPW5ldyB4LHRoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9sZXZlbD0wfTtjbGFzcyBZZXtjb25zdHJ1Y3Rvcigpe1llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXRJdGVtKHQpe3RoaXMuX2l0ZW1zLmFkZCh0KX1nZXRJdGVtcygpe3JldHVybiB0aGlzLl9pdGVtc31nZXRDbGFzcygpe3JldHVybiBZZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQWVdfX1ZZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pdGVtcz1uZXcgeH07Y2xhc3MgVWV7Y29uc3RydWN0b3IoKXtVZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBsb2NhdGVQb2ludEluUmluZygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmXyhhcmd1bWVudHNbMV0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFVlKHQpLHM9bmV3IGcsaT1uZXcgZztmb3IobGV0IHQ9MTt0PGUuc2l6ZSgpO3QrKylpZihlLmdldENvb3JkaW5hdGUodCxzKSxlLmdldENvb3JkaW5hdGUodC0xLGkpLG4uY291bnRTZWdtZW50KHMsaSksbi5pc09uU2VnbWVudCgpKXJldHVybiBuLmdldExvY2F0aW9uKCk7cmV0dXJuIG4uZ2V0TG9jYXRpb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFVlKHQpO2ZvcihsZXQgdD0xO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBzPWVbdF0saT1lW3QtMV07aWYobi5jb3VudFNlZ21lbnQocyxpKSxuLmlzT25TZWdtZW50KCkpcmV0dXJuIG4uZ2V0TG9jYXRpb24oKX1yZXR1cm4gbi5nZXRMb2NhdGlvbigpfX1jb3VudFNlZ21lbnQodCxlKXtpZih0Lng8dGhpcy5fcC54JiZlLng8dGhpcy5fcC54KXJldHVybiBudWxsO2lmKHRoaXMuX3AueD09PWUueCYmdGhpcy5fcC55PT09ZS55KXJldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50PSEwLG51bGw7aWYodC55PT09dGhpcy5fcC55JiZlLnk9PT10aGlzLl9wLnkpe2xldCBuPXQueCxzPWUueDtyZXR1cm4gbj5zJiYobj1lLngscz10LngpLHRoaXMuX3AueD49biYmdGhpcy5fcC54PD1zJiYodGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCksbnVsbH1pZih0Lnk+dGhpcy5fcC55JiZlLnk8PXRoaXMuX3AueXx8ZS55PnRoaXMuX3AueSYmdC55PD10aGlzLl9wLnkpe2xldCBuPXYuaW5kZXgodCxlLHRoaXMuX3ApO2lmKG49PT12LkNPTExJTkVBUilyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2UueTx0LnkmJihuPS1uKSxuPT09di5MRUZUJiZ0aGlzLl9jcm9zc2luZ0NvdW50Kyt9fWlzUG9pbnRJblBvbHlnb24oKXtyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbigpIT09bmUuRVhURVJJT1J9Z2V0TG9jYXRpb24oKXtyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD9uZS5CT1VOREFSWTp0aGlzLl9jcm9zc2luZ0NvdW50JTI9PTE/bmUuSU5URVJJT1I6bmUuRVhURVJJT1J9aXNPblNlZ21lbnQoKXtyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudH1nZXRDbGFzcygpe3JldHVybiBVZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcD1udWxsLHRoaXMuX2Nyb3NzaW5nQ291bnQ9MCx0aGlzLl9pc1BvaW50T25TZWdtZW50PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3A9dH07Y2xhc3Mga2V7Y29uc3RydWN0b3IoKXtrZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWxvY2F0ZSh0KXtjb25zdCBlPW5ldyBVZSh0KSxuPW5ldyBYZShlKTtyZXR1cm4gdGhpcy5faW5kZXgucXVlcnkodC55LHQueSxuKSxlLmdldExvY2F0aW9uKCl9Z2V0Q2xhc3MoKXtyZXR1cm4ga2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ZlXX19Y2xhc3MgWGV7Y29uc3RydWN0b3IoKXtYZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0SXRlbSh0KXtjb25zdCBlPXQ7dGhpcy5fY291bnRlci5jb3VudFNlZ21lbnQoZS5nZXRDb29yZGluYXRlKDApLGUuZ2V0Q29vcmRpbmF0ZSgxKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gWGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FlXX19WGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY291bnRlcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvdW50ZXI9dH07Y2xhc3MgSGV7Y29uc3RydWN0b3IoKXtIZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluaXQodCl7Zm9yKGxldCBlPXhlLmdldExpbmVzKHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7dGhpcy5hZGRMaW5lKHQpfX1hZGRMaW5lKHQpe2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPW5ldyBlZSh0W2UtMV0sdFtlXSkscz1NYXRoLm1pbihuLnAwLnksbi5wMS55KSxpPU1hdGgubWF4KG4ucDAueSxuLnAxLnkpO3RoaXMuX2luZGV4Lmluc2VydChzLGksbil9fXF1ZXJ5KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFllO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeSh0LGUsbiksbi5nZXRJdGVtcygpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9pbmRleC5xdWVyeSh0LGUsbil9fWdldENsYXNzKCl7cmV0dXJuIEhlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1IZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbmRleD1uZXcgemU7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfSxrZS5TZWdtZW50VmlzaXRvcj1YZSxrZS5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeT1IZSxrZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKCEoXyh0LE90KXx8dCBpbnN0YW5jZW9mIER0KSl0aHJvdyBuZXcgbihcIkFyZ3VtZW50IG11c3QgYmUgUG9seWdvbmFsIG9yIExpbmVhclJpbmdcIik7dGhpcy5faW5kZXg9bmV3IEhlKHQpfTtjbGFzcyBXZXtjb25zdHJ1Y3Rvcigpe1dlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzT25MaW5lKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZfKGFyZ3VtZW50c1sxXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgdGUscz1uZXcgZyxpPW5ldyBnLHI9ZS5zaXplKCk7Zm9yKGxldCBvPTE7bzxyO28rKylpZihlLmdldENvb3JkaW5hdGUoby0xLHMpLGUuZ2V0Q29vcmRpbmF0ZShvLGkpLG4uY29tcHV0ZUludGVyc2VjdGlvbih0LHMsaSksbi5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IHRlO2ZvcihsZXQgcz0xO3M8ZS5sZW5ndGg7cysrKXtjb25zdCBpPWVbcy0xXSxyPWVbc107aWYobi5jb21wdXRlSW50ZXJzZWN0aW9uKHQsaSxyKSxuLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiEwfXJldHVybiExfX1zdGF0aWMgbG9jYXRlSW5SaW5nKHQsZSl7cmV0dXJuIFVlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZSl9c3RhdGljIGlzSW5SaW5nKHQsZSl7cmV0dXJuIFdlLmxvY2F0ZUluUmluZyh0LGUpIT09bmUuRVhURVJJT1J9Z2V0Q2xhc3MoKXtyZXR1cm4gV2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIGplKCl7fVdlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30samUucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXt9LGplLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7fSxqZS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7fTtjbGFzcyBLZXtjb25zdHJ1Y3Rvcigpe0tlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzQXRvbWljKHQpe3JldHVybiEodCBpbnN0YW5jZW9mIF90KX1uZXh0KCl7aWYodGhpcy5fYXRTdGFydClyZXR1cm4gdGhpcy5fYXRTdGFydD0hMSxLZS5pc0F0b21pYyh0aGlzLl9wYXJlbnQpJiZ0aGlzLl9pbmRleCsrLHRoaXMuX3BhcmVudDtpZihudWxsIT09dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpO3RoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfWlmKHRoaXMuX2luZGV4Pj10aGlzLl9tYXgpdGhyb3cgbmV3IHk7Y29uc3QgdD10aGlzLl9wYXJlbnQuZ2V0R2VvbWV0cnlOKHRoaXMuX2luZGV4KyspO3JldHVybiB0IGluc3RhbmNlb2YgX3Q/KHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1uZXcgS2UodCksdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKSk6dH1yZW1vdmUoKXt0aHJvdyBuZXcgWih0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpKX1oYXNOZXh0KCl7aWYodGhpcy5fYXRTdGFydClyZXR1cm4hMDtpZihudWxsIT09dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiEwO3RoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfXJldHVybiEodGhpcy5faW5kZXg+PXRoaXMuX21heCl9Z2V0Q2xhc3MoKXtyZXR1cm4gS2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2plXX19S2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcGFyZW50PW51bGwsdGhpcy5fYXRTdGFydD1udWxsLHRoaXMuX21heD1udWxsLHRoaXMuX2luZGV4PW51bGwsdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50PXQsdGhpcy5fYXRTdGFydD0hMCx0aGlzLl9pbmRleD0wLHRoaXMuX21heD10LmdldE51bUdlb21ldHJpZXMoKX07Y2xhc3MgWmV7Y29uc3RydWN0b3IoKXtaZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBsb2NhdGVQb2ludEluUG9seWdvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiBuZS5FWFRFUklPUjtjb25zdCBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz1aZS5sb2NhdGVQb2ludEluUmluZyh0LG4pO2lmKHMhPT1uZS5JTlRFUklPUilyZXR1cm4gcztmb3IobGV0IG49MDtuPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bisrKXtjb25zdCBzPWUuZ2V0SW50ZXJpb3JSaW5nTihuKSxpPVplLmxvY2F0ZVBvaW50SW5SaW5nKHQscyk7aWYoaT09PW5lLkJPVU5EQVJZKXJldHVybiBuZS5CT1VOREFSWTtpZihpPT09bmUuSU5URVJJT1IpcmV0dXJuIG5lLkVYVEVSSU9SfXJldHVybiBuZS5JTlRFUklPUn1zdGF0aWMgbG9jYXRlUG9pbnRJblJpbmcodCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9XZS5sb2NhdGVJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOm5lLkVYVEVSSU9SfXN0YXRpYyBjb250YWluc1BvaW50SW5Qb2x5Z29uKHQsZSl7cmV0dXJuIG5lLkVYVEVSSU9SIT09WmUubG9jYXRlUG9pbnRJblBvbHlnb24odCxlKX1zdGF0aWMgbG9jYXRlSW5HZW9tZXRyeSh0LGUpe2lmKGUgaW5zdGFuY2VvZiBidClyZXR1cm4gWmUubG9jYXRlUG9pbnRJblBvbHlnb24odCxlKTtpZihlIGluc3RhbmNlb2YgX3Qpe2NvbnN0IG49bmV3IEtlKGUpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO2lmKHMhPT1lKXtjb25zdCBlPVplLmxvY2F0ZUluR2VvbWV0cnkodCxzKTtpZihlIT09bmUuRVhURVJJT1IpcmV0dXJuIGV9fX1yZXR1cm4gbmUuRVhURVJJT1J9c3RhdGljIGxvY2F0ZSh0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9uZS5FWFRFUklPUjpaZS5sb2NhdGVJbkdlb21ldHJ5KHQsZSl9bG9jYXRlKHQpe3JldHVybiBaZS5sb2NhdGUodCx0aGlzLl9nZW9tKX1nZXRDbGFzcygpe3JldHVybiBaZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRmVdfX1aZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbT10fTt2YXIgUWU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvcjprZSxQb2ludE9uR2VvbWV0cnlMb2NhdG9yOkZlLFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvcjpaZX0pO2NsYXNzIEple2NvbnN0cnVjdG9yKCl7SmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1tZWFzdXJlKHQsZSl7fWdldENsYXNzKCl7cmV0dXJuIEplfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1KZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzICRle2NvbnN0cnVjdG9yKCl7JGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1tZWFzdXJlKHQsZSl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKGUpLmdldEFyZWEoKS90LnVuaW9uKGUpLmdldEFyZWEoKX1nZXRDbGFzcygpe3JldHVybiAkZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSmVdfX0kZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHRue2NvbnN0cnVjdG9yKCl7dG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGlhZ29uYWxTaXplKHQpe2lmKHQuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpO3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9bWVhc3VyZSh0LGUpe2NvbnN0IG49T2UuZGlzdGFuY2UodCxlLHRuLkRFTlNJRllfRlJBQ1RJT04pLHM9bmV3IE4odC5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiBzLmV4cGFuZFRvSW5jbHVkZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSksMS1uL3RuLmRpYWdvbmFsU2l6ZShzKX1nZXRDbGFzcygpe3JldHVybiB0bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSmVdfX10bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LHRuLkRFTlNJRllfRlJBQ1RJT049LjI1O2NsYXNzIGVue2NvbnN0cnVjdG9yKCl7ZW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tYmluZSh0LGUpe3JldHVybiBNYXRoLm1pbih0LGUpfWdldENsYXNzKCl7cmV0dXJuIGVufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1lbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O3ZhciBubj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxBcmVhU2ltaWxhcml0eU1lYXN1cmU6JGUsSGF1c2RvcmZmU2ltaWxhcml0eU1lYXN1cmU6dG4sU2ltaWxhcml0eU1lYXN1cmU6SmUsU2ltaWxhcml0eU1lYXN1cmVDb21iaW5lcjplbn0pO2NsYXNzIHNue2NvbnN0cnVjdG9yKCl7c24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgYXJlYTIodCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKG4ueC10LngpKihlLnktdC55KX1zdGF0aWMgY2VudHJvaWQzKHQsZSxuLHMpe3JldHVybiBzLng9dC54K2UueCtuLngscy55PXQueStlLnkrbi55LG51bGx9c3RhdGljIGdldENlbnRyb2lkKHQpe3JldHVybiBuZXcgc24odCkuZ2V0Q2VudHJvaWQoKX1zZXRBcmVhQmFzZVBvaW50KHQpe3RoaXMuX2FyZWFCYXNlUHQ9dH1hZGRQb2ludCh0KXt0aGlzLl9wdENvdW50Kz0xLHRoaXMuX3B0Q2VudFN1bS54Kz10LngsdGhpcy5fcHRDZW50U3VtLnkrPXQueX1hZGRMaW5lU2VnbWVudHModCl7bGV0IGU9MDtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXtjb25zdCBzPXRbbl0uZGlzdGFuY2UodFtuKzFdKTtpZigwPT09cyljb250aW51ZTtlKz1zO2NvbnN0IGk9KHRbbl0ueCt0W24rMV0ueCkvMjt0aGlzLl9saW5lQ2VudFN1bS54Kz1zKmk7Y29uc3Qgcj0odFtuXS55K3RbbisxXS55KS8yO3RoaXMuX2xpbmVDZW50U3VtLnkrPXMqcn10aGlzLl90b3RhbExlbmd0aCs9ZSwwPT09ZSYmdC5sZW5ndGg+MCYmdGhpcy5hZGRQb2ludCh0WzBdKX1hZGRIb2xlKHQpe2NvbnN0IGU9di5pc0NDVyh0KTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5fYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX1nZXRDZW50cm9pZCgpe2NvbnN0IHQ9bmV3IGc7aWYoTWF0aC5hYnModGhpcy5fYXJlYXN1bTIpPjApdC54PXRoaXMuX2NnMy54LzMvdGhpcy5fYXJlYXN1bTIsdC55PXRoaXMuX2NnMy55LzMvdGhpcy5fYXJlYXN1bTI7ZWxzZSBpZih0aGlzLl90b3RhbExlbmd0aD4wKXQueD10aGlzLl9saW5lQ2VudFN1bS54L3RoaXMuX3RvdGFsTGVuZ3RoLHQueT10aGlzLl9saW5lQ2VudFN1bS55L3RoaXMuX3RvdGFsTGVuZ3RoO2Vsc2V7aWYoISh0aGlzLl9wdENvdW50PjApKXJldHVybiBudWxsO3QueD10aGlzLl9wdENlbnRTdW0ueC90aGlzLl9wdENvdW50LHQueT10aGlzLl9wdENlbnRTdW0ueS90aGlzLl9wdENvdW50fXJldHVybiB0fWFkZFNoZWxsKHQpe3QubGVuZ3RoPjAmJnRoaXMuc2V0QXJlYUJhc2VQb2ludCh0WzBdKTtjb25zdCBlPSF2LmlzQ0NXKHQpO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLl9hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfWFkZFRyaWFuZ2xlKHQsZSxuLHMpe2NvbnN0IGk9cz8xOi0xO3NuLmNlbnRyb2lkMyh0LGUsbix0aGlzLl90cmlhbmdsZUNlbnQzKTtjb25zdCByPXNuLmFyZWEyKHQsZSxuKTt0aGlzLl9jZzMueCs9aSpyKnRoaXMuX3RyaWFuZ2xlQ2VudDMueCx0aGlzLl9jZzMueSs9aSpyKnRoaXMuX3RyaWFuZ2xlQ2VudDMueSx0aGlzLl9hcmVhc3VtMis9aSpyfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkU2hlbGwodC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXRoaXMuYWRkSG9sZSh0LmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBQdCl0aGlzLmFkZFBvaW50KHQuZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZExpbmVTZWdtZW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGJ0KXtjb25zdCBlPXQ7dGhpcy5hZGQoZSl9ZWxzZSBpZih0IGluc3RhbmNlb2YgX3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5Tih0KSl9fX1nZXRDbGFzcygpe3JldHVybiBzbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gcm4odCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gb24oKXt0aGlzLmFycmF5Xz1bXX1zbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9hcmVhQmFzZVB0PW51bGwsdGhpcy5fdHJpYW5nbGVDZW50Mz1uZXcgZyx0aGlzLl9hcmVhc3VtMj0wLHRoaXMuX2NnMz1uZXcgZyx0aGlzLl9saW5lQ2VudFN1bT1uZXcgZyx0aGlzLl90b3RhbExlbmd0aD0wLHRoaXMuX3B0Q291bnQ9MCx0aGlzLl9wdENlbnRTdW09bmV3IGc7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYXJlYUJhc2VQdD1udWxsLHRoaXMuYWRkKHQpfSxybi5wcm90b3R5cGU9bmV3IEVycm9yLHJuLnByb3RvdHlwZS5uYW1lPVwiRW1wdHlTdGFja0V4Y2VwdGlvblwiLG9uLnByb3RvdHlwZT1uZXcgbSxvbi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxvbi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2lmKHQ8MHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IHA7cmV0dXJuIHRoaXMuYXJyYXlfW3RdfSxvbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSx0fSxvbi5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLmFycmF5Xy5sZW5ndGgpdGhyb3cgbmV3IHJuO3JldHVybiB0aGlzLmFycmF5Xy5wb3AoKX0sb24ucHJvdG90eXBlLnBlZWs9ZnVuY3Rpb24oKXtpZigwPT09dGhpcy5hcnJheV8ubGVuZ3RoKXRocm93IG5ldyBybjtyZXR1cm4gdGhpcy5hcnJheV9bdGhpcy5hcnJheV8ubGVuZ3RoLTFdfSxvbi5wcm90b3R5cGUuZW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sb24ucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbXB0eSgpfSxvbi5wcm90b3R5cGUuc2VhcmNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5pbmRleE9mKHQpfSxvbi5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LG9uLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9O2NsYXNzIGxue2NvbnN0cnVjdG9yKCl7bG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmlsdGVyQ29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgbG47Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZS5maWx0ZXIodFtuXSk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZXMoKX1maWx0ZXIodCl7dGhpcy50cmVlU2V0LmNvbnRhaW5zKHQpfHwodGhpcy5saXN0LmFkZCh0KSx0aGlzLnRyZWVTZXQuYWRkKHQpKX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMubGlzdC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMubGlzdC50b0FycmF5KHQpfWdldENsYXNzKCl7cmV0dXJuIGxufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltCXX19bG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy50cmVlU2V0PW5ldyBhdCx0aGlzLmxpc3Q9bmV3IHh9O2NsYXNzIGFue2NvbnN0cnVjdG9yKCl7YW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZXh0cmFjdENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IGxuO3JldHVybiB0LmFwcGx5KGUpLGUuZ2V0Q29vcmRpbmF0ZXMoKX1wcmVTb3J0KHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspKHRbbl0ueTx0WzBdLnl8fHRbbl0ueT09PXRbMF0ueSYmdFtuXS54PHRbMF0ueCkmJihlPXRbMF0sdFswXT10W25dLHRbbl09ZSk7cmV0dXJuIGh0LnNvcnQodCwxLHQubGVuZ3RoLG5ldyBjbih0WzBdKSksdH1jb21wdXRlT2N0UmluZyh0KXtjb25zdCBlPXRoaXMuY29tcHV0ZU9jdFB0cyh0KSxuPW5ldyBJO3JldHVybiBuLmFkZChlLCExKSxuLnNpemUoKTwzP251bGw6KG4uY2xvc2VSaW5nKCksbi50b0Nvb3JkaW5hdGVBcnJheSgpKX1saW5lT3JQb2x5Z29uKHQpe2lmKDM9PT0odD10aGlzLmNsZWFuUmluZyh0KSkubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKFt0WzBdLHRbMV1dKTtjb25zdCBlPXRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodCk7cmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZVBvbHlnb24oZSl9Y2xlYW5SaW5nKHQpe3UuZXF1YWxzKHRbMF0sdFt0Lmxlbmd0aC0xXSk7Y29uc3QgZT1uZXcgeDtsZXQgbj1udWxsO2ZvcihsZXQgcz0wO3M8PXQubGVuZ3RoLTI7cysrKXtjb25zdCBpPXRbc10scj10W3MrMV07aS5lcXVhbHMocil8fChudWxsIT09biYmdGhpcy5pc0JldHdlZW4obixpLHIpfHwoZS5hZGQoaSksbj1pKSl9ZS5hZGQodFt0Lmxlbmd0aC0xXSk7Y29uc3Qgcz1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIGUudG9BcnJheShzKX1pc0JldHdlZW4odCxlLG4pe2lmKDAhPT12LmluZGV4KHQsZSxuKSlyZXR1cm4hMTtpZih0LnghPT1uLngpe2lmKHQueDw9ZS54JiZlLng8PW4ueClyZXR1cm4hMDtpZihuLng8PWUueCYmZS54PD10LngpcmV0dXJuITB9aWYodC55IT09bi55KXtpZih0Lnk8PWUueSYmZS55PD1uLnkpcmV0dXJuITA7aWYobi55PD1lLnkmJmUueTw9dC55KXJldHVybiEwfXJldHVybiExfXJlZHVjZSh0KXtjb25zdCBlPXRoaXMuY29tcHV0ZU9jdFJpbmcodCk7aWYobnVsbD09PWUpcmV0dXJuIHQ7Y29uc3Qgbj1uZXcgYXQ7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspbi5hZGQoZVt0XSk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspV2UuaXNJblJpbmcodFtzXSxlKXx8bi5hZGQodFtzXSk7Y29uc3Qgcz1YLnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiBzLmxlbmd0aDwzP3RoaXMucGFkQXJyYXkzKHMpOnN9Z2V0Q29udmV4SHVsbCgpe2lmKDA9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2lmKDE9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMuX2lucHV0UHRzWzBdKTtpZigyPT09dGhpcy5faW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuX2lucHV0UHRzKTtsZXQgdD10aGlzLl9pbnB1dFB0czt0aGlzLl9pbnB1dFB0cy5sZW5ndGg+NTAmJih0PXRoaXMucmVkdWNlKHRoaXMuX2lucHV0UHRzKSk7Y29uc3QgZT10aGlzLnByZVNvcnQodCksbj10aGlzLmdyYWhhbVNjYW4oZSkscz10aGlzLnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiB0aGlzLmxpbmVPclBvbHlnb24ocyl9cGFkQXJyYXkzKHQpe2NvbnN0IGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspbjx0Lmxlbmd0aD9lW25dPXRbbl06ZVtuXT10WzBdO3JldHVybiBlfWNvbXB1dGVPY3RQdHModCl7Y29uc3QgZT1uZXcgQXJyYXkoOCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspdFtuXS54PGVbMF0ueCYmKGVbMF09dFtuXSksdFtuXS54LXRbbl0ueTxlWzFdLngtZVsxXS55JiYoZVsxXT10W25dKSx0W25dLnk+ZVsyXS55JiYoZVsyXT10W25dKSx0W25dLngrdFtuXS55PmVbM10ueCtlWzNdLnkmJihlWzNdPXRbbl0pLHRbbl0ueD5lWzRdLngmJihlWzRdPXRbbl0pLHRbbl0ueC10W25dLnk+ZVs1XS54LWVbNV0ueSYmKGVbNV09dFtuXSksdFtuXS55PGVbNl0ueSYmKGVbNl09dFtuXSksdFtuXS54K3Rbbl0ueTxlWzddLngrZVs3XS55JiYoZVs3XT10W25dKTtyZXR1cm4gZX10b0Nvb3JkaW5hdGVBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKyl7Y29uc3Qgcz10LmdldChuKTtlW25dPXN9cmV0dXJuIGV9Z3JhaGFtU2Nhbih0KXtsZXQgZT1udWxsO2NvbnN0IG49bmV3IG9uO24ucHVzaCh0WzBdKSxuLnB1c2godFsxXSksbi5wdXNoKHRbMl0pO2ZvcihsZXQgcz0zO3M8dC5sZW5ndGg7cysrKXtmb3IoZT1uLnBvcCgpOyFuLmVtcHR5KCkmJnYuaW5kZXgobi5wZWVrKCksZSx0W3NdKT4wOyllPW4ucG9wKCk7bi5wdXNoKGUpLG4ucHVzaCh0W3NdKX1yZXR1cm4gbi5wdXNoKHRbMF0pLG59Z2V0Q2xhc3MoKXtyZXR1cm4gYW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGNue2NvbnN0cnVjdG9yKCl7Y24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcG9sYXJDb21wYXJlKHQsZSxuKXtjb25zdCBzPWUueC10LngsaT1lLnktdC55LHI9bi54LXQueCxvPW4ueS10LnksbD12LmluZGV4KHQsZSxuKTtpZihsPT09di5DT1VOVEVSQ0xPQ0tXSVNFKXJldHVybiAxO2lmKGw9PT12LkNMT0NLV0lTRSlyZXR1cm4tMTtjb25zdCBhPXMqcytpKmksYz1yKnIrbypvO3JldHVybiBhPGM/LTE6YT5jPzE6MH1jb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtyZXR1cm4gY24ucG9sYXJDb21wYXJlKHRoaXMuX29yaWdpbixuLHMpfWdldENsYXNzKCl7cmV0dXJuIGNufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19Y24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fb3JpZ2luPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZ2luPXR9LGFuLlJhZGlhbENvbXBhcmF0b3I9Y24sYW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9pbnB1dFB0cz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTthbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGFuLmV4dHJhY3RDb29yZGluYXRlcyh0KSx0LmdldEZhY3RvcnkoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRQdHM9bG4uZmlsdGVyQ29vcmRpbmF0ZXModCksdGhpcy5fZ2VvbUZhY3Rvcnk9ZX19O2NsYXNzIGhue2NvbnN0cnVjdG9yKCl7aG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY2VudHJlKHQpe3JldHVybiBuZXcgZyhobi5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpLGhuLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSkpfXN0YXRpYyBhdmcodCxlKXtyZXR1cm4odCtlKS8yfWFkZFBvbHlnb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7bGV0IGU9bnVsbCxuPW51bGw7Y29uc3Qgcz10aGlzLmhvcml6b250YWxCaXNlY3Rvcih0KTtpZigwPT09cy5nZXRMZW5ndGgoKSluPTAsZT1zLmdldENvb3JkaW5hdGUoKTtlbHNle2NvbnN0IGk9cy5pbnRlcnNlY3Rpb24odCkscj10aGlzLndpZGVzdEdlb21ldHJ5KGkpO249ci5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKSxlPWhuLmNlbnRyZShyLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9KG51bGw9PT10aGlzLl9pbnRlcmlvclBvaW50fHxuPnRoaXMuX21heFdpZHRoKSYmKHRoaXMuX2ludGVyaW9yUG9pbnQ9ZSx0aGlzLl9tYXhXaWR0aD1uKX1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9d2lkZXN0R2VvbWV0cnkoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF90KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gdDtsZXQgZT10LmdldEdlb21ldHJ5TigwKTtmb3IobGV0IG49MTtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0LmdldEdlb21ldHJ5TihuKS5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKT5lLmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRXaWR0aCgpJiYoZT10LmdldEdlb21ldHJ5TihuKSk7cmV0dXJuIGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdCBpbnN0YW5jZW9mIF90P3RoaXMud2lkZXN0R2VvbWV0cnkodCk6dH19aG9yaXpvbnRhbEJpc2VjdG9yKHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCksbj11bi5nZXRCaXNlY3RvclkodCk7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbbmV3IGcoZS5nZXRNaW5YKCksbiksbmV3IGcoZS5nZXRNYXhYKCksbildKX1hZGQodCl7aWYodCBpbnN0YW5jZW9mIGJ0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBfdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKHQpKX19Z2V0Q2xhc3MoKXtyZXR1cm4gaG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHVue2NvbnN0cnVjdG9yKCl7dW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0QmlzZWN0b3JZKHQpe3JldHVybiBuZXcgdW4odCkuZ2V0QmlzZWN0b3JZKCl9dXBkYXRlSW50ZXJ2YWwodCl7dDw9dGhpcy5fY2VudHJlWT90PnRoaXMuX2xvWSYmKHRoaXMuX2xvWT10KTp0PnRoaXMuX2NlbnRyZVkmJnQ8dGhpcy5faGlZJiYodGhpcy5faGlZPXQpfWdldEJpc2VjdG9yWSgpe3RoaXMucHJvY2Vzcyh0aGlzLl9wb2x5LmdldEV4dGVyaW9yUmluZygpKTtmb3IobGV0IHQ9MDt0PHRoaXMuX3BvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7dCsrKXRoaXMucHJvY2Vzcyh0aGlzLl9wb2x5LmdldEludGVyaW9yUmluZ04odCkpO3JldHVybiBobi5hdmcodGhpcy5faGlZLHRoaXMuX2xvWSl9cHJvY2Vzcyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IG49ZS5nZXRZKHQpO3RoaXMudXBkYXRlSW50ZXJ2YWwobil9fWdldENsYXNzKCl7cmV0dXJuIHVufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX11bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wb2x5PW51bGwsdGhpcy5fY2VudHJlWT1udWxsLHRoaXMuX2hpWT1pLk1BWF9WQUxVRSx0aGlzLl9sb1k9LWkuTUFYX1ZBTFVFO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BvbHk9dCx0aGlzLl9oaVk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWF4WSgpLHRoaXMuX2xvWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNaW5ZKCksdGhpcy5fY2VudHJlWT1obi5hdmcodGhpcy5fbG9ZLHRoaXMuX2hpWSl9LGhuLlNhZmVCaXNlY3RvckZpbmRlcj11bixobi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5faW50ZXJpb3JQb2ludD1udWxsLHRoaXMuX21heFdpZHRoPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSx0aGlzLmFkZCh0KX07Y2xhc3MgZ257Y29uc3RydWN0b3IoKXtnbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZEVuZHBvaW50cygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkRW5kcG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgX3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZEVuZHBvaW50cyhlLmdldEdlb21ldHJ5Tih0KSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodFswXSksdGhpcy5hZGQodFt0Lmxlbmd0aC0xXSl9fWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1hZGRJbnRlcmlvcigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkSW50ZXJpb3IodC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBfdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkSW50ZXJpb3IoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0xO2U8dC5sZW5ndGgtMTtlKyspdGhpcy5hZGQodFtlXSl9fWFkZCh0KXtjb25zdCBlPXQuZGlzdGFuY2UodGhpcy5fY2VudHJvaWQpO2U8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBnKHQpLHRoaXMuX21pbkRpc3RhbmNlPWUpfWdldENsYXNzKCl7cmV0dXJuIGdufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1nbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jZW50cm9pZD1udWxsLHRoaXMuX21pbkRpc3RhbmNlPWkuTUFYX1ZBTFVFLHRoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmlzRW1wdHkoKT90aGlzLl9jZW50cm9pZD1uZXcgZzp0aGlzLl9jZW50cm9pZD1zbi5nZXRDZW50cm9pZCh0KSx0aGlzLmFkZEludGVyaW9yKHQpLG51bGw9PT10aGlzLl9pbnRlcmlvclBvaW50JiZ0aGlzLmFkZEVuZHBvaW50cyh0KX07Y2xhc3MgZG57Y29uc3RydWN0b3IoKXtkbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBQdCl0aGlzLmFkZCh0LmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgX3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5Tih0KSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuZGlzdGFuY2UodGhpcy5fY2VudHJvaWQpO2U8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBnKHQpLHRoaXMuX21pbkRpc3RhbmNlPWUpfX1nZXRDbGFzcygpe3JldHVybiBkbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY2VudHJvaWQ9bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1pLk1BWF9WQUxVRSx0aGlzLl9pbnRlcmlvclBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY2VudHJvaWQ9dC5nZXRDZW50cm9pZCgpLmdldENvb3JkaW5hdGUoKSx0aGlzLmFkZCh0KX07Y2xhc3MgX257Y29uc3RydWN0b3IoKXtfbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWxvY2F0ZUluUG9seWdvblJpbmcodCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9XZS5sb2NhdGVJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOm5lLkVYVEVSSU9SfWludGVyc2VjdHModCxlKXtyZXR1cm4gdGhpcy5sb2NhdGUodCxlKSE9PW5lLkVYVEVSSU9SfXVwZGF0ZUxvY2F0aW9uSW5mbyh0KXt0PT09bmUuSU5URVJJT1ImJih0aGlzLl9pc0luPSEwKSx0PT09bmUuQk9VTkRBUlkmJnRoaXMuX251bUJvdW5kYXJpZXMrK31jb21wdXRlTG9jYXRpb24odCxlKXtpZihlIGluc3RhbmNlb2YgUHQmJnRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlT25Qb2ludCh0LGUpKSxlIGluc3RhbmNlb2YgVHQpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVPbkxpbmVTdHJpbmcodCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgYnQpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJblBvbHlnb24odCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgZnQpe2NvbnN0IG49ZTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5TihlKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LHMpKX19ZWxzZSBpZihlIGluc3RhbmNlb2YgQXQpe2NvbnN0IG49ZTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5TihlKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUluUG9seWdvbih0LHMpKX19ZWxzZSBpZihlIGluc3RhbmNlb2YgX3Qpe2NvbnN0IG49bmV3IEtlKGUpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MhPT1lJiZ0aGlzLmNvbXB1dGVMb2NhdGlvbih0LHMpfX19bG9jYXRlT25Qb2ludCh0LGUpe3JldHVybiBlLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0KT9uZS5JTlRFUklPUjpuZS5FWFRFUklPUn1sb2NhdGVPbkxpbmVTdHJpbmcodCxlKXtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KSlyZXR1cm4gbmUuRVhURVJJT1I7Y29uc3Qgbj1lLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO3JldHVybiBlLmlzQ2xvc2VkKCl8fCF0LmVxdWFscyhuLmdldENvb3JkaW5hdGUoMCkpJiYhdC5lcXVhbHMobi5nZXRDb29yZGluYXRlKG4uc2l6ZSgpLTEpKT9XZS5pc09uTGluZSh0LG4pP25lLklOVEVSSU9SOm5lLkVYVEVSSU9SOm5lLkJPVU5EQVJZfWxvY2F0ZUluUG9seWdvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiBuZS5FWFRFUklPUjtjb25zdCBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxuKTtpZihzPT09bmUuRVhURVJJT1IpcmV0dXJuIG5lLkVYVEVSSU9SO2lmKHM9PT1uZS5CT1VOREFSWSlyZXR1cm4gbmUuQk9VTkRBUlk7Zm9yKGxldCBuPTA7bjxlLmdldE51bUludGVyaW9yUmluZygpO24rKyl7Y29uc3Qgcz1lLmdldEludGVyaW9yUmluZ04obiksaT10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxzKTtpZihpPT09bmUuSU5URVJJT1IpcmV0dXJuIG5lLkVYVEVSSU9SO2lmKGk9PT1uZS5CT1VOREFSWSlyZXR1cm4gbmUuQk9VTkRBUll9cmV0dXJuIG5lLklOVEVSSU9SfWxvY2F0ZSh0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9uZS5FWFRFUklPUjplIGluc3RhbmNlb2YgVHQ/dGhpcy5sb2NhdGVPbkxpbmVTdHJpbmcodCxlKTplIGluc3RhbmNlb2YgYnQ/dGhpcy5sb2NhdGVJblBvbHlnb24odCxlKToodGhpcy5faXNJbj0hMSx0aGlzLl9udW1Cb3VuZGFyaWVzPTAsdGhpcy5jb21wdXRlTG9jYXRpb24odCxlKSx0aGlzLl9ib3VuZGFyeVJ1bGUuaXNJbkJvdW5kYXJ5KHRoaXMuX251bUJvdW5kYXJpZXMpP25lLkJPVU5EQVJZOnRoaXMuX251bUJvdW5kYXJpZXM+MHx8dGhpcy5faXNJbj9uZS5JTlRFUklPUjpuZS5FWFRFUklPUil9Z2V0Q2xhc3MoKXtyZXR1cm4gX259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fV9uLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2JvdW5kYXJ5UnVsZT1WLk9HQ19TRlNfQk9VTkRBUllfUlVMRSx0aGlzLl9pc0luPW51bGwsdGhpcy5fbnVtQm91bmRhcmllcz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dCl0aHJvdyBuZXcgbihcIlJ1bGUgbXVzdCBiZSBub24tbnVsbFwiKTt0aGlzLl9ib3VuZGFyeVJ1bGU9dH19O2NsYXNzIGZue2NvbnN0cnVjdG9yKCl7Zm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcG9pbnRXaXRNaW5BbmdsZVdpdGhYKHQsZSl7bGV0IG49aS5NQVhfVkFMVUUscz1udWxsO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtjb25zdCByPXRbaV07aWYocj09PWUpY29udGludWU7Y29uc3Qgbz1yLngtZS54O2xldCBsPXIueS1lLnk7bDwwJiYobD0tbCk7Y29uc3QgYT1sL01hdGguc3FydChvKm8rbCpsKTthPG4mJihuPWEscz1yKX1yZXR1cm4gc31zdGF0aWMgbG93ZXN0UG9pbnQodCl7bGV0IGU9dFswXTtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl0W25dLnk8ZS55JiYoZT10W25dKTtyZXR1cm4gZX1zdGF0aWMgcG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudCh0LGUsbil7bGV0IHM9aS5NQVhfVkFMVUUscj1udWxsO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtjb25zdCBvPXRbaV07aWYobz09PWUpY29udGludWU7aWYobz09PW4pY29udGludWU7Y29uc3QgbD1pZS5hbmdsZUJldHdlZW4oZSxvLG4pO2w8cyYmKHM9bCxyPW8pfXJldHVybiByfWdldFJhZGl1cygpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9yYWRpdXN9Z2V0RGlhbWV0ZXIoKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKX1jb25zdCB0PXRoaXMuX2V4dHJlbWFsUHRzWzBdLGU9dGhpcy5fZXh0cmVtYWxQdHNbMV07cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX1nZXRFeHRyZW1hbFBvaW50cygpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0c31jb21wdXRlQ2lyY2xlUG9pbnRzKCl7aWYodGhpcy5faW5wdXQuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO2lmKDE9PT10aGlzLl9pbnB1dC5nZXROdW1Qb2ludHMoKSl7Y29uc3QgdD10aGlzLl9pbnB1dC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IGcodFswXSldLG51bGx9Y29uc3QgdD10aGlzLl9pbnB1dC5jb252ZXhIdWxsKCkuZ2V0Q29vcmRpbmF0ZXMoKTtsZXQgZT10O2lmKHRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSkmJihlPW5ldyBBcnJheSh0Lmxlbmd0aC0xKS5maWxsKG51bGwpLFguY29weURlZXAodCwwLGUsMCx0Lmxlbmd0aC0xKSksZS5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVguY29weURlZXAoZSksbnVsbDtsZXQgbj1mbi5sb3dlc3RQb2ludChlKSxzPWZuLnBvaW50V2l0TWluQW5nbGVXaXRoWChlLG4pO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCB0PWZuLnBvaW50V2l0aE1pbkFuZ2xlV2l0aFNlZ21lbnQoZSxuLHMpO2lmKGllLmlzT2J0dXNlKG4sdCxzKSlyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9W25ldyBnKG4pLG5ldyBnKHMpXSxudWxsO2lmKGllLmlzT2J0dXNlKHQsbixzKSluPXQ7ZWxzZXtpZighaWUuaXNPYnR1c2UodCxzLG4pKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IGcobiksbmV3IGcocyksbmV3IGcodCldLG51bGw7cz10fX11LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiTG9naWMgZmFpbHVyZSBpbiBNaW5pbXVtIEJvdW5kaW5nIENpcmNsZSBhbGdvcml0aG0hXCIpfWNvbXB1dGUoKXtpZihudWxsIT09dGhpcy5fZXh0cmVtYWxQdHMpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ2lyY2xlUG9pbnRzKCksdGhpcy5jb21wdXRlQ2VudHJlKCksbnVsbCE9PXRoaXMuX2NlbnRyZSYmKHRoaXMuX3JhZGl1cz10aGlzLl9jZW50cmUuZGlzdGFuY2UodGhpcy5fZXh0cmVtYWxQdHNbMF0pKX1nZXRGYXJ0aGVzdFBvaW50cygpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpfWNvbnN0IHQ9dGhpcy5fZXh0cmVtYWxQdHNbMF0sZT10aGlzLl9leHRyZW1hbFB0c1t0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgtMV07cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX1nZXRDaXJjbGUoKXtpZih0aGlzLmNvbXB1dGUoKSxudWxsPT09dGhpcy5fY2VudHJlKXJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbigpO2NvbnN0IHQ9dGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX2NlbnRyZSk7cmV0dXJuIDA9PT10aGlzLl9yYWRpdXM/dDp0LmJ1ZmZlcih0aGlzLl9yYWRpdXMpfWdldENlbnRyZSgpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9jZW50cmV9Y29tcHV0ZUNlbnRyZSgpe3N3aXRjaCh0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDp0aGlzLl9jZW50cmU9bnVsbDticmVhaztjYXNlIDE6dGhpcy5fY2VudHJlPXRoaXMuX2V4dHJlbWFsUHRzWzBdO2JyZWFrO2Nhc2UgMjp0aGlzLl9jZW50cmU9bmV3IGcoKHRoaXMuX2V4dHJlbWFsUHRzWzBdLngrdGhpcy5fZXh0cmVtYWxQdHNbMV0ueCkvMiwodGhpcy5fZXh0cmVtYWxQdHNbMF0ueSt0aGlzLl9leHRyZW1hbFB0c1sxXS55KS8yKTticmVhaztjYXNlIDM6dGhpcy5fY2VudHJlPXJlLmNpcmN1bWNlbnRyZSh0aGlzLl9leHRyZW1hbFB0c1swXSx0aGlzLl9leHRyZW1hbFB0c1sxXSx0aGlzLl9leHRyZW1hbFB0c1syXSl9fWdldENsYXNzKCl7cmV0dXJuIGZufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dD1udWxsLHRoaXMuX2V4dHJlbWFsUHRzPW51bGwsdGhpcy5fY2VudHJlPW51bGwsdGhpcy5fcmFkaXVzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXQ9dH07Y2xhc3MgcG57Y29uc3RydWN0b3IoKXtwbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBuZXh0SW5kZXgodCxlKXtyZXR1cm4rK2U+PXQubGVuZ3RoJiYoZT0wKSxlfXN0YXRpYyBjb21wdXRlQyh0LGUsbil7cmV0dXJuIHQqbi55LWUqbi54fXN0YXRpYyBnZXRNaW5pbXVtRGlhbWV0ZXIodCl7cmV0dXJuIG5ldyBwbih0KS5nZXREaWFtZXRlcigpfXN0YXRpYyBnZXRNaW5pbXVtUmVjdGFuZ2xlKHQpe3JldHVybiBuZXcgcG4odCkuZ2V0TWluaW11bVJlY3RhbmdsZSgpfXN0YXRpYyBjb21wdXRlU2VnbWVudEZvckxpbmUodCxlLG4pe2xldCBzPW51bGwsaT1udWxsO3JldHVybiBNYXRoLmFicyhlKT5NYXRoLmFicyh0KT8ocz1uZXcgZygwLG4vZSksaT1uZXcgZygxLG4vZS10L2UpKToocz1uZXcgZyhuL3QsMCksaT1uZXcgZyhuL3QtZS90LDEpKSxuZXcgZWUocyxpKX1nZXRXaWR0aENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5fbWluV2lkdGhQdH1nZXRTdXBwb3J0aW5nU2VnbWVudCgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMuX21pbkJhc2VTZWcucDAsdGhpcy5fbWluQmFzZVNlZy5wMV0pfWdldERpYW1ldGVyKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksbnVsbD09PXRoaXMuX21pbldpZHRoUHQpcmV0dXJuIHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2NvbnN0IHQ9dGhpcy5fbWluQmFzZVNlZy5wcm9qZWN0KHRoaXMuX21pbldpZHRoUHQpO3JldHVybiB0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsdGhpcy5fbWluV2lkdGhQdF0pfWNvbXB1dGVXaWR0aENvbnZleCh0KXt0aGlzLl9jb252ZXhIdWxsUHRzPXQgaW5zdGFuY2VvZiBidD90LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCk6dC5nZXRDb29yZGluYXRlcygpLDA9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5fbWluV2lkdGg9MCx0aGlzLl9taW5XaWR0aFB0PW51bGwsdGhpcy5fbWluQmFzZVNlZz1udWxsKToxPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMuX21pbldpZHRoPTAsdGhpcy5fbWluV2lkdGhQdD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDA9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAxPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0pOjI9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aHx8Mz09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLl9taW5XaWR0aD0wLHRoaXMuX21pbldpZHRoUHQ9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAwPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMT10aGlzLl9jb252ZXhIdWxsUHRzWzFdKTp0aGlzLmNvbXB1dGVDb252ZXhSaW5nTWluRGlhbWV0ZXIodGhpcy5fY29udmV4SHVsbFB0cyl9Y29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0KXt0aGlzLl9taW5XaWR0aD1pLk1BWF9WQUxVRTtsZXQgZT0xO2NvbnN0IG49bmV3IGVlO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGgtMTtzKyspbi5wMD10W3NdLG4ucDE9dFtzKzFdLGU9dGhpcy5maW5kTWF4UGVycERpc3RhbmNlKHQsbixlKX1jb21wdXRlTWluaW11bURpYW1ldGVyKCl7aWYobnVsbCE9PXRoaXMuX21pbldpZHRoUHQpcmV0dXJuIG51bGw7aWYodGhpcy5faXNDb252ZXgpdGhpcy5jb21wdXRlV2lkdGhDb252ZXgodGhpcy5faW5wdXRHZW9tKTtlbHNle2NvbnN0IHQ9bmV3IGFuKHRoaXMuX2lucHV0R2VvbSkuZ2V0Q29udmV4SHVsbCgpO3RoaXMuY29tcHV0ZVdpZHRoQ29udmV4KHQpfX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5fbWluV2lkdGh9ZmluZE1heFBlcnBEaXN0YW5jZSh0LGUsbil7bGV0IHM9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtuXSksaT1zLHI9bixvPXI7Zm9yKDtpPj1zOylzPWkscj1vLG89cG4ubmV4dEluZGV4KHQsciksaT1lLmRpc3RhbmNlUGVycGVuZGljdWxhcih0W29dKTtyZXR1cm4gczx0aGlzLl9taW5XaWR0aCYmKHRoaXMuX21pblB0SW5kZXg9cix0aGlzLl9taW5XaWR0aD1zLHRoaXMuX21pbldpZHRoUHQ9dFt0aGlzLl9taW5QdEluZGV4XSx0aGlzLl9taW5CYXNlU2VnPW5ldyBlZShlKSkscn1nZXRNaW5pbXVtUmVjdGFuZ2xlKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksMD09PXRoaXMuX21pbldpZHRoKXJldHVybiB0aGlzLl9taW5CYXNlU2VnLnAwLmVxdWFsczJEKHRoaXMuX21pbkJhc2VTZWcucDEpP3RoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fbWluQmFzZVNlZy5wMCk6dGhpcy5fbWluQmFzZVNlZy50b0dlb21ldHJ5KHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkpO2NvbnN0IHQ9dGhpcy5fbWluQmFzZVNlZy5wMS54LXRoaXMuX21pbkJhc2VTZWcucDAueCxlPXRoaXMuX21pbkJhc2VTZWcucDEueS10aGlzLl9taW5CYXNlU2VnLnAwLnk7bGV0IG49aS5NQVhfVkFMVUUscz0taS5NQVhfVkFMVUUscj1pLk1BWF9WQUxVRSxvPS1pLk1BWF9WQUxVRTtmb3IobGV0IGk9MDtpPHRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoO2krKyl7Y29uc3QgbD1wbi5jb21wdXRlQyh0LGUsdGhpcy5fY29udmV4SHVsbFB0c1tpXSk7bD5zJiYocz1sKSxsPG4mJihuPWwpO2NvbnN0IGE9cG4uY29tcHV0ZUMoLWUsdCx0aGlzLl9jb252ZXhIdWxsUHRzW2ldKTthPm8mJihvPWEpLGE8ciYmKHI9YSl9Y29uc3QgbD1wbi5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsbyksYT1wbi5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsciksYz1wbi5jb21wdXRlU2VnbWVudEZvckxpbmUoLWUsdCxzKSxoPXBuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LG4pLHU9Yy5saW5lSW50ZXJzZWN0aW9uKGwpLGc9aC5saW5lSW50ZXJzZWN0aW9uKGwpLGQ9aC5saW5lSW50ZXJzZWN0aW9uKGEpLF89Yy5saW5lSW50ZXJzZWN0aW9uKGEpLGY9dGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKFt1LGcsZCxfLHVdKTtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKGYpfWdldENsYXNzKCl7cmV0dXJuIHBufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1wbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9pc0NvbnZleD1udWxsLHRoaXMuX2NvbnZleEh1bGxQdHM9bnVsbCx0aGlzLl9taW5CYXNlU2VnPW5ldyBlZSx0aGlzLl9taW5XaWR0aFB0PW51bGwsdGhpcy5fbWluUHRJbmRleD1udWxsLHRoaXMuX21pbldpZHRoPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3BuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwhMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5faXNDb252ZXg9ZX19O3ZhciBtbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkaXN0YW5jZTpEZSxsb2NhdGU6UWUsbWF0Y2g6bm4sQW5nbGU6aWUsQXJlYTp2dCxDZW50cm9pZDpzbixDb252ZXhIdWxsOmFuLERpc3RhbmNlOkQsSW50ZXJpb3JQb2ludEFyZWE6aG4sSW50ZXJpb3JQb2ludExpbmU6Z24sSW50ZXJpb3JQb2ludFBvaW50OmRuLExlbmd0aDp5dCxPcmllbnRhdGlvbjp2LFBvaW50TG9jYXRpb246V2UsUG9pbnRMb2NhdG9yOl9uLFJvYnVzdExpbmVJbnRlcnNlY3Rvcjp0ZSxNaW5pbXVtQm91bmRpbmdDaXJjbGU6Zm4sTWluaW11bURpYW1ldGVyOnBufSk7Y2xhc3MgeW57Y29uc3RydWN0b3IoKXt5bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkZW5zaWZ5UG9pbnRzKHQsZSxuKXtjb25zdCBzPW5ldyBlZSxpPW5ldyBJO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGgtMTtyKyspe3MucDA9dFtyXSxzLnAxPXRbcisxXSxpLmFkZChzLnAwLCExKTtjb25zdCBvPXMuZ2V0TGVuZ3RoKCksbD1NYXRoLnRydW5jKG8vZSkrMTtpZihsPjEpe2NvbnN0IHQ9by9sO2ZvcihsZXQgZT0xO2U8bDtlKyspe2NvbnN0IHI9ZSp0L28sbD1zLnBvaW50QWxvbmcocik7bi5tYWtlUHJlY2lzZShsKSxpLmFkZChsLCExKX19fXJldHVybiBpLmFkZCh0W3QubGVuZ3RoLTFdLCExKSxpLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIGRlbnNpZnkodCxlKXtjb25zdCBuPW5ldyB5bih0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gbmV3IHhuKHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PD0wKXRocm93IG5ldyBuKFwiVG9sZXJhbmNlIG11c3QgYmUgcG9zaXRpdmVcIik7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1nZXRDbGFzcygpe3JldHVybiB5bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgeG4gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkseG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIEF0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz15bi5kZW5zaWZ5UG9pbnRzKG4sdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSxlLmdldFByZWNpc2lvbk1vZGVsKCkpO3JldHVybiBlIGluc3RhbmNlb2YgVHQmJjE9PT1zLmxlbmd0aCYmKHM9bmV3IEFycmF5KDApLmZpbGwobnVsbCkpLHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX1jcmVhdGVWYWxpZEFyZWEodCl7cmV0dXJuIHQuYnVmZmVyKDApfWdldENsYXNzKCl7cmV0dXJuIHhufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX14bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSx5bi5EZW5zaWZ5VHJhbnNmb3JtZXI9eG4seW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH07dmFyIEVuPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERlbnNpZmllcjp5bn0pO2NsYXNzIElue2NvbnN0cnVjdG9yKCl7SW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNOb3J0aGVybih0KXtyZXR1cm4gdD09PUluLk5FfHx0PT09SW4uTld9c3RhdGljIGlzT3Bwb3NpdGUodCxlKXtpZih0PT09ZSlyZXR1cm4hMTtyZXR1cm4gMj09PSh0LWUrNCklNH1zdGF0aWMgY29tbW9uSGFsZlBsYW5lKHQsZSl7aWYodD09PWUpcmV0dXJuIHQ7aWYoMj09PSh0LWUrNCklNClyZXR1cm4tMTtjb25zdCBuPXQ8ZT90OmU7cmV0dXJuIDA9PT1uJiYzPT09KHQ+ZT90OmUpPzM6bn1zdGF0aWMgaXNJbkhhbGZQbGFuZSh0LGUpe3JldHVybiBlPT09SW4uU0U/dD09PUluLlNFfHx0PT09SW4uU1c6dD09PWV8fHQ9PT1lKzF9c3RhdGljIHF1YWRyYW50KCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBuKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTtyZXR1cm4gdD49MD9lPj0wP0luLk5FOkluLlNFOmU+PTA/SW4uTlc6SW4uU1d9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKGUueD09PXQueCYmZS55PT09dC55KXRocm93IG5ldyBuKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIit0KTtyZXR1cm4gZS54Pj10Lng/ZS55Pj10Lnk/SW4uTkU6SW4uU0U6ZS55Pj10Lnk/SW4uTlc6SW4uU1d9fWdldENsYXNzKCl7cmV0dXJuIElufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Jbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LEluLk5FPTAsSW4uTlc9MSxJbi5TVz0yLEluLlNFPTM7Y2xhc3MgTm57Y29uc3RydWN0b3IoKXtObi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbml0KHQsZSl7aWYobnVsbCE9PXQuX3N5bXx8bnVsbCE9PWUuX3N5bXx8bnVsbCE9PXQuX25leHR8fG51bGwhPT1lLl9uZXh0KXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJFZGdlcyBhcmUgYWxyZWFkeSBpbml0aWFsaXplZFwiKTtyZXR1cm4gdC5pbml0KGUpLHR9c3RhdGljIGNyZWF0ZSh0LGUpe2NvbnN0IG49bmV3IE5uKHQpLHM9bmV3IE5uKGUpO3JldHVybiBuLmluaXQocyksbn1maW5kKHQpe2xldCBlPXRoaXM7ZG97aWYobnVsbD09PWUpcmV0dXJuIG51bGw7aWYoZS5kZXN0KCkuZXF1YWxzMkQodCkpcmV0dXJuIGU7ZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiBudWxsfWRlc3QoKXtyZXR1cm4gdGhpcy5fc3ltLl9vcmlnfW9OZXh0KCl7cmV0dXJuIHRoaXMuX3N5bS5fbmV4dH1pbnNlcnQodCl7aWYodGhpcy5vTmV4dCgpPT09dGhpcylyZXR1cm4gdGhpcy5pbnNlcnRBZnRlcih0KSxudWxsO2NvbnN0IGU9dGhpcy5jb21wYXJlVG8odCk7bGV0IG49dGhpcztkb3tjb25zdCBzPW4ub05leHQoKTtpZihzLmNvbXBhcmVUbyh0KSE9PWV8fHM9PT10aGlzKXJldHVybiBuLmluc2VydEFmdGVyKHQpLG51bGw7bj1zfXdoaWxlKG4hPT10aGlzKTt1LnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9aW5zZXJ0QWZ0ZXIodCl7dS5lcXVhbHModGhpcy5fb3JpZyx0Lm9yaWcoKSk7Y29uc3QgZT10aGlzLm9OZXh0KCk7dGhpcy5fc3ltLnNldE5leHQodCksdC5zeW0oKS5zZXROZXh0KGUpfWRlZ3JlZSgpe2xldCB0PTAsZT10aGlzO2Rve3QrKyxlPWUub05leHQoKX13aGlsZShlIT09dGhpcyk7cmV0dXJuIHR9ZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fb3JpZy5lcXVhbHMyRCh0KSYmdGhpcy5fc3ltLl9vcmlnLmVxdWFscyhlKX19ZGVsdGFZKCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZy55LXRoaXMuX29yaWcueX1zeW0oKXtyZXR1cm4gdGhpcy5fc3ltfXByZXYoKXtyZXR1cm4gdGhpcy5fc3ltLm5leHQoKS5fc3ltfWNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKHQpe2NvbnN0IGU9dGhpcy5kZWx0YVgoKSxuPXRoaXMuZGVsdGFZKCkscz10LmRlbHRhWCgpLGk9dC5kZWx0YVkoKTtpZihlPT09cyYmbj09PWkpcmV0dXJuIDA7Y29uc3Qgcj1Jbi5xdWFkcmFudChlLG4pLG89SW4ucXVhZHJhbnQocyxpKTtyZXR1cm4gcj5vPzE6cjxvPy0xOnYuaW5kZXgodC5fb3JpZyx0LmRlc3QoKSx0aGlzLmRlc3QoKSl9cHJldk5vZGUoKXtsZXQgdD10aGlzO2Zvcig7Mj09PXQuZGVncmVlKCk7KWlmKHQ9dC5wcmV2KCksdD09PXRoaXMpcmV0dXJuIG51bGw7cmV0dXJuIHR9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlQW5ndWxhckRpcmVjdGlvbihlKX1uZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9c2V0U3ltKHQpe3RoaXMuX3N5bT10fW9yaWcoKXtyZXR1cm4gdGhpcy5fb3JpZ310b1N0cmluZygpe3JldHVyblwiSEUoXCIrdGhpcy5fb3JpZy54K1wiIFwiK3RoaXMuX29yaWcueStcIiwgXCIrdGhpcy5fc3ltLl9vcmlnLngrXCIgXCIrdGhpcy5fc3ltLl9vcmlnLnkrXCIpXCJ9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9aW5pdCh0KXt0aGlzLnNldFN5bSh0KSx0LnNldFN5bSh0aGlzKSx0aGlzLnNldE5leHQodCksdC5zZXROZXh0KHRoaXMpfWRlbHRhWCgpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueC10aGlzLl9vcmlnLnh9Z2V0Q2xhc3MoKXtyZXR1cm4gTm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU5uLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX29yaWc9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZz10fTtjbGFzcyBDbiBleHRlbmRzIE5ue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxDbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzZXRNYXJrQm90aCh0LGUpe3Quc2V0TWFyayhlKSx0LnN5bSgpLnNldE1hcmsoZSl9c3RhdGljIGlzTWFya2VkKHQpe3JldHVybiB0LmlzTWFya2VkKCl9c3RhdGljIHNldE1hcmsodCxlKXt0LnNldE1hcmsoZSl9c3RhdGljIG1hcmtCb3RoKHQpe3QubWFyaygpLHQuc3ltKCkubWFyaygpfXN0YXRpYyBtYXJrKHQpe3QubWFyaygpfW1hcmsoKXt0aGlzLl9pc01hcmtlZD0hMH1zZXRNYXJrKHQpe3RoaXMuX2lzTWFya2VkPXR9aXNNYXJrZWQoKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9Z2V0Q2xhc3MoKXtyZXR1cm4gQ259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUNuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzTWFya2VkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO05uLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9O2NsYXNzIFNue2NvbnN0cnVjdG9yKCl7U24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNWYWxpZEVkZ2UodCxlKXtyZXR1cm4gMCE9PWUuY29tcGFyZVRvKHQpfWluc2VydCh0LGUsbil7Y29uc3Qgcz10aGlzLmNyZWF0ZSh0LGUpO251bGwhPT1uP24uaW5zZXJ0KHMpOnRoaXMuX3ZlcnRleE1hcC5wdXQodCxzKTtjb25zdCBpPXRoaXMuX3ZlcnRleE1hcC5nZXQoZSk7cmV0dXJuIG51bGwhPT1pP2kuaW5zZXJ0KHMuc3ltKCkpOnRoaXMuX3ZlcnRleE1hcC5wdXQoZSxzLnN5bSgpKSxzfWNyZWF0ZSh0LGUpe2NvbnN0IG49dGhpcy5jcmVhdGVFZGdlKHQpLHM9dGhpcy5jcmVhdGVFZGdlKGUpO3JldHVybiBObi5pbml0KG4scyksbn1jcmVhdGVFZGdlKHQpe3JldHVybiBuZXcgTm4odCl9YWRkRWRnZSh0LGUpe2lmKCFTbi5pc1ZhbGlkRWRnZSh0LGUpKXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5fdmVydGV4TWFwLmdldCh0KTtsZXQgcz1udWxsO2lmKG51bGwhPT1uJiYocz1uLmZpbmQoZSkpLG51bGwhPT1zKXJldHVybiBzO3JldHVybiB0aGlzLmluc2VydCh0LGUsbil9Z2V0VmVydGV4RWRnZXMoKXtyZXR1cm4gdGhpcy5fdmVydGV4TWFwLnZhbHVlcygpfWZpbmRFZGdlKHQsZSl7Y29uc3Qgbj10aGlzLl92ZXJ0ZXhNYXAuZ2V0KHQpO3JldHVybiBudWxsPT09bj9udWxsOm4uZmluZChlKX1nZXRDbGFzcygpe3JldHVybiBTbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19U24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdmVydGV4TWFwPW5ldyBVdH07Y2xhc3Mgd24gZXh0ZW5kcyBDbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksd24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRTdGFydCgpe3RoaXMuX2lzU3RhcnQ9ITB9aXNTdGFydCgpe3JldHVybiB0aGlzLl9pc1N0YXJ0fWdldENsYXNzKCl7cmV0dXJuIHdufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX13bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc1N0YXJ0PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO0NuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9O2NsYXNzIExuIGV4dGVuZHMgU257Y29uc3RydWN0b3IoKXtzdXBlcigpLExuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlRWRnZSh0KXtyZXR1cm4gbmV3IHduKHQpfWdldENsYXNzKCl7cmV0dXJuIExufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Mbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFRue2NvbnN0cnVjdG9yKCl7VG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGlzc29sdmUodCl7Y29uc3QgZT1uZXcgVG47cmV0dXJuIGUuYWRkKHQpLGUuZ2V0UmVzdWx0KCl9YWRkTGluZSh0KXt0aGlzLl9saW5lcy5hZGQodGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHQudG9Db29yZGluYXRlQXJyYXkoKSkpfXVwZGF0ZVJpbmdTdGFydEVkZ2UodCl7cmV0dXJuIHQuaXNTdGFydCgpfHwodD10LnN5bSgpKS5pc1N0YXJ0KCk/bnVsbD09PXRoaXMuX3JpbmdTdGFydEVkZ2U/KHRoaXMuX3JpbmdTdGFydEVkZ2U9dCxudWxsKTp2b2lkKHQub3JpZygpLmNvbXBhcmVUbyh0aGlzLl9yaW5nU3RhcnRFZGdlLm9yaWcoKSk8MCYmKHRoaXMuX3JpbmdTdGFydEVkZ2U9dCkpOm51bGx9Z2V0UmVzdWx0KCl7cmV0dXJuIG51bGw9PT10aGlzLl9yZXN1bHQmJnRoaXMuY29tcHV0ZVJlc3VsdCgpLHRoaXMuX3Jlc3VsdH1wcm9jZXNzKHQpe2xldCBlPXQucHJldk5vZGUoKTtudWxsPT09ZSYmKGU9dCksdGhpcy5zdGFja0VkZ2VzKGUpLHRoaXMuYnVpbGRMaW5lcygpfWJ1aWxkUmluZyh0KXtjb25zdCBlPW5ldyBJO2xldCBuPXQ7Zm9yKGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXtjb25zdCBzPW4ubmV4dCgpO2lmKHM9PT10KWJyZWFrO2UuYWRkKHMub3JpZygpLmNvcHkoKSwhMSksbj1zfWUuYWRkKG4uZGVzdCgpLmNvcHkoKSwhMSksdGhpcy5hZGRMaW5lKGUpfWJ1aWxkTGluZSh0KXtjb25zdCBlPW5ldyBJO2xldCBuPXQ7Zm9yKHRoaXMuX3JpbmdTdGFydEVkZ2U9bnVsbCxDbi5tYXJrQm90aChuKSxlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7dGhpcy51cGRhdGVSaW5nU3RhcnRFZGdlKG4pO2NvbnN0IHM9bi5uZXh0KCk7aWYocz09PXQpcmV0dXJuIHRoaXMuYnVpbGRSaW5nKHRoaXMuX3JpbmdTdGFydEVkZ2UpLG51bGw7ZS5hZGQocy5vcmlnKCkuY29weSgpLCExKSxuPXMsQ24ubWFya0JvdGgobil9ZS5hZGQobi5kZXN0KCkuY2xvbmUoKSwhMSksdGhpcy5zdGFja0VkZ2VzKG4uc3ltKCkpLHRoaXMuYWRkTGluZShlKX1zdGFja0VkZ2VzKHQpe2xldCBlPXQ7ZG97Q24uaXNNYXJrZWQoZSl8fHRoaXMuX25vZGVFZGdlU3RhY2suYWRkKGUpLGU9ZS5vTmV4dCgpfXdoaWxlKGUhPT10KX1jb21wdXRlUmVzdWx0KCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldFZlcnRleEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7Q24uaXNNYXJrZWQoZSl8fHRoaXMucHJvY2VzcyhlKX10aGlzLl9yZXN1bHQ9dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMuX2xpbmVzKX1idWlsZExpbmVzKCl7Zm9yKDshdGhpcy5fbm9kZUVkZ2VTdGFjay5lbXB0eSgpOyl7Y29uc3QgdD10aGlzLl9ub2RlRWRnZVN0YWNrLnBvcCgpO0NuLmlzTWFya2VkKHQpfHx0aGlzLmJ1aWxkTGluZSh0KX19YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXthcmd1bWVudHNbMF0uYXBwbHkobmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLmFkZCh0KX19KX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGYpKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSk7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2xldCBuPSExO2ZvcihsZXQgdD0xO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPXRoaXMuX2dyYXBoLmFkZEVkZ2UoZS5nZXRDb29yZGluYXRlKHQtMSksZS5nZXRDb29yZGluYXRlKHQpKTtudWxsIT09cyYmKG58fChzLnNldFN0YXJ0KCksbj0hMCkpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gVG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVRuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3Jlc3VsdD1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2xpbmVzPW5ldyB4LHRoaXMuX25vZGVFZGdlU3RhY2s9bmV3IG9uLHRoaXMuX3JpbmdTdGFydEVkZ2U9bnVsbCx0aGlzLl9ncmFwaD1uZXcgTG59O3ZhciBSbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxMaW5lRGlzc29sdmVyOlRufSk7Y2xhc3MgUG57Y29uc3RydWN0b3IoKXtQbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvcHBvc2l0ZSh0KXtyZXR1cm4gdD09PVBuLkxFRlQ/UG4uUklHSFQ6dD09PVBuLlJJR0hUP1BuLkxFRlQ6dH1nZXRDbGFzcygpe3JldHVybiBQbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxQbi5PTj0wLFBuLkxFRlQ9MSxQbi5SSUdIVD0yO2NsYXNzIHZue2NvbnN0cnVjdG9yKCl7dm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlSW50ZXJzZWN0aW9ucyh0LGUpe3RoaXMubWNlLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5jaGFpbkluZGV4LHQubWNlLHQuY2hhaW5JbmRleCxlKX1nZXRDbGFzcygpe3JldHVybiB2bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dm4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5tY2U9bnVsbCx0aGlzLmNoYWluSW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm1jZT10LHRoaXMuY2hhaW5JbmRleD1lfTtjbGFzcyBPbntjb25zdHJ1Y3Rvcigpe09uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNEZWxldGUoKXtyZXR1cm4gdGhpcy5fZXZlbnRUeXBlPT09T24uREVMRVRFfXNldERlbGV0ZUV2ZW50SW5kZXgodCl7dGhpcy5fZGVsZXRlRXZlbnRJbmRleD10fWdldE9iamVjdCgpe3JldHVybiB0aGlzLl9vYmp9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5feFZhbHVlPGUuX3hWYWx1ZT8tMTp0aGlzLl94VmFsdWU+ZS5feFZhbHVlPzE6dGhpcy5fZXZlbnRUeXBlPGUuX2V2ZW50VHlwZT8tMTp0aGlzLl9ldmVudFR5cGU+ZS5fZXZlbnRUeXBlPzE6MH1nZXRJbnNlcnRFdmVudCgpe3JldHVybiB0aGlzLl9pbnNlcnRFdmVudH1pc0luc2VydCgpe3JldHVybiB0aGlzLl9ldmVudFR5cGU9PT1Pbi5JTlNFUlR9aXNTYW1lTGFiZWwodCl7cmV0dXJuIG51bGwhPT10aGlzLl9sYWJlbCYmdGhpcy5fbGFiZWw9PT10Ll9sYWJlbH1nZXREZWxldGVFdmVudEluZGV4KCl7cmV0dXJuIHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXh9Z2V0Q2xhc3MoKXtyZXR1cm4gT259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Pbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9sYWJlbD1udWxsLHRoaXMuX3hWYWx1ZT1udWxsLHRoaXMuX2V2ZW50VHlwZT1udWxsLHRoaXMuX2luc2VydEV2ZW50PW51bGwsdGhpcy5fZGVsZXRlRXZlbnRJbmRleD1udWxsLHRoaXMuX29iaj1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ldmVudFR5cGU9T24uREVMRVRFLHRoaXMuX3hWYWx1ZT10LHRoaXMuX2luc2VydEV2ZW50PWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fZXZlbnRUeXBlPU9uLklOU0VSVCx0aGlzLl9sYWJlbD10LHRoaXMuX3hWYWx1ZT1lLHRoaXMuX29iaj1ufX0sT24uSU5TRVJUPTEsT24uREVMRVRFPTI7Y2xhc3MgYm57Y29uc3RydWN0b3IoKXtibi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIGJufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1ibi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIE1ue2NvbnN0cnVjdG9yKCl7TW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNBZGphY2VudFNlZ21lbnRzKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfWlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXtpZih0PT09biYmMT09PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihNbi5pc0FkamFjZW50U2VnbWVudHMoZSxzKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe2NvbnN0IG49dC5nZXROdW1Qb2ludHMoKS0xO2lmKDA9PT1lJiZzPT09bnx8MD09PXMmJmU9PT1uKXJldHVybiEwfX1yZXR1cm4hMX1nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpe3JldHVybiB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH1zZXRJc0RvbmVJZlByb3BlckludCh0KXt0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50PXR9aGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3J9aXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKS5nZXRDb29yZGluYXRlKCk7aWYodC5pc0ludGVyc2VjdGlvbihlKSlyZXR1cm4hMH1yZXR1cm4hMX1oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVyfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuIHRoaXMuX2lzRG9uZX1pc0JvdW5kYXJ5UG9pbnQodCxlKXtyZXR1cm4gbnVsbCE9PWUmJighIXRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzBdKXx8ISF0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZVsxXSkpfXNldEJvdW5kYXJ5Tm9kZXModCxlKXt0aGlzLl9iZHlOb2Rlcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9iZHlOb2Rlc1swXT10LHRoaXMuX2JkeU5vZGVzWzFdPWV9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5fcmVjb3JkSXNvbGF0ZWQmJih0LnNldElzb2xhdGVkKCExKSxuLnNldElzb2xhdGVkKCExKSksdGhpcy5fbnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLCF0aGlzLl9pbmNsdWRlUHJvcGVyJiZ0aGlzLl9saS5pc1Byb3BlcigpfHwodC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLHMsMSkpLHRoaXMuX2xpLmlzUHJvcGVyKCkmJih0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCkuY29weSgpLHRoaXMuX2hhc1Byb3Blcj0hMCx0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50JiYodGhpcy5faXNEb25lPSEwKSx0aGlzLmlzQm91bmRhcnlQb2ludCh0aGlzLl9saSx0aGlzLl9iZHlOb2Rlcyl8fCh0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gTW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU1uLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9oYXNQcm9wZXI9ITEsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX2luY2x1ZGVQcm9wZXI9bnVsbCx0aGlzLl9yZWNvcmRJc29sYXRlZD1udWxsLHRoaXMuX2lzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMuX251bUludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTAsdGhpcy5fYmR5Tm9kZXM9bnVsbCx0aGlzLl9pc0RvbmU9ITEsdGhpcy5faXNEb25lV2hlblByb3BlckludD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9saT10LHRoaXMuX2luY2x1ZGVQcm9wZXI9ZSx0aGlzLl9yZWNvcmRJc29sYXRlZD1ufTtjbGFzcyBEbiBleHRlbmRzIGJue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxEbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXByZXBhcmVFdmVudHMoKXtFZS5zb3J0KHRoaXMuZXZlbnRzKTtmb3IobGV0IHQ9MDt0PHRoaXMuZXZlbnRzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5ldmVudHMuZ2V0KHQpO2UuaXNEZWxldGUoKSYmZS5nZXRJbnNlcnRFdmVudCgpLnNldERlbGV0ZUV2ZW50SW5kZXgodCl9fWNvbXB1dGVJbnRlcnNlY3Rpb25zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubk92ZXJsYXBzPTAsdGhpcy5wcmVwYXJlRXZlbnRzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLmV2ZW50cy5zaXplKCk7ZSsrKXtjb25zdCBuPXRoaXMuZXZlbnRzLmdldChlKTtpZihuLmlzSW5zZXJ0KCkmJnRoaXMucHJvY2Vzc092ZXJsYXBzKGUsbi5nZXREZWxldGVFdmVudEluZGV4KCksbix0KSx0LmlzRG9uZSgpKWJyZWFrfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgTW4mJl8oYXJndW1lbnRzWzBdLG0pJiZfKGFyZ3VtZW50c1sxXSxtKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5hZGRFZGdlcyh0LHQpLHRoaXMuYWRkRWRnZXMoZSxlKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKG4pfWVsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJl8oYXJndW1lbnRzWzBdLG0pJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIE1uKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl0/dGhpcy5hZGRFZGdlcyh0LG51bGwpOnRoaXMuYWRkRWRnZXModCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhlKX19YWRkRWRnZSh0LGUpe2NvbnN0IG49dC5nZXRNb25vdG9uZUNoYWluRWRnZSgpLHM9bi5nZXRTdGFydEluZGV4ZXMoKTtmb3IobGV0IHQ9MDt0PHMubGVuZ3RoLTE7dCsrKXtjb25zdCBzPW5ldyB2bihuLHQpLGk9bmV3IE9uKGUsbi5nZXRNaW5YKHQpLHMpO3RoaXMuZXZlbnRzLmFkZChpKSx0aGlzLmV2ZW50cy5hZGQobmV3IE9uKG4uZ2V0TWF4WCh0KSxpKSl9fXByb2Nlc3NPdmVybGFwcyh0LGUsbixzKXtjb25zdCBpPW4uZ2V0T2JqZWN0KCk7Zm9yKGxldCByPXQ7cjxlO3IrKyl7Y29uc3QgdD10aGlzLmV2ZW50cy5nZXQocik7aWYodC5pc0luc2VydCgpKXtjb25zdCBlPXQuZ2V0T2JqZWN0KCk7bi5pc1NhbWVMYWJlbCh0KXx8KGkuY29tcHV0ZUludGVyc2VjdGlvbnMoZSxzKSx0aGlzLm5PdmVybGFwcysrKX19fWFkZEVkZ2VzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGRFZGdlKGUsZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuYWRkRWRnZSh0LGUpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gRG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fURuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuZXZlbnRzPW5ldyB4LHRoaXMubk92ZXJsYXBzPW51bGx9O2NsYXNzIEFue2NvbnN0cnVjdG9yKCl7QW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRBbGxMb2NhdGlvbnModCl7Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10fWlzTnVsbCgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5sb2NhdGlvbi5sZW5ndGg7dCsrKWlmKHRoaXMubG9jYXRpb25bdF0hPT1uZS5OT05FKXJldHVybiExO3JldHVybiEwfXNldEFsbExvY2F0aW9uc0lmTnVsbCh0KXtmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPT09bmUuTk9ORSYmKHRoaXMubG9jYXRpb25bZV09dCl9aXNMaW5lKCl7cmV0dXJuIDE9PT10aGlzLmxvY2F0aW9uLmxlbmd0aH1tZXJnZSh0KXtpZih0LmxvY2F0aW9uLmxlbmd0aD50aGlzLmxvY2F0aW9uLmxlbmd0aCl7Y29uc3QgdD1uZXcgQXJyYXkoMykuZmlsbChudWxsKTt0W1BuLk9OXT10aGlzLmxvY2F0aW9uW1BuLk9OXSx0W1BuLkxFRlRdPW5lLk5PTkUsdFtQbi5SSUdIVF09bmUuTk9ORSx0aGlzLmxvY2F0aW9uPXR9Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PW5lLk5PTkUmJmU8dC5sb2NhdGlvbi5sZW5ndGgmJih0aGlzLmxvY2F0aW9uW2VdPXQubG9jYXRpb25bZV0pfWdldExvY2F0aW9ucygpe3JldHVybiB0aGlzLmxvY2F0aW9ufWZsaXAoKXtpZih0aGlzLmxvY2F0aW9uLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMubG9jYXRpb25bUG4uTEVGVF07dGhpcy5sb2NhdGlvbltQbi5MRUZUXT10aGlzLmxvY2F0aW9uW1BuLlJJR0hUXSx0aGlzLmxvY2F0aW9uW1BuLlJJR0hUXT10fXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdztyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MSYmdC5hcHBlbmQobmUudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1BuLkxFRlRdKSksdC5hcHBlbmQobmUudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1BuLk9OXSkpLHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKG5lLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltQbi5SSUdIVF0pKSx0LnRvU3RyaW5nKCl9c2V0TG9jYXRpb25zKHQsZSxuKXt0aGlzLmxvY2F0aW9uW1BuLk9OXT10LHRoaXMubG9jYXRpb25bUG4uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW1BuLlJJR0hUXT1ufWdldCh0KXtyZXR1cm4gdDx0aGlzLmxvY2F0aW9uLmxlbmd0aD90aGlzLmxvY2F0aW9uW3RdOm5lLk5PTkV9aXNBcmVhKCl7cmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoPjF9aXNBbnlOdWxsKCl7Zm9yKGxldCB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XT09PW5lLk5PTkUpcmV0dXJuITA7cmV0dXJuITF9c2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRMb2NhdGlvbihQbi5PTix0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmxvY2F0aW9uW3RdPWV9fWluaXQodCl7dGhpcy5sb2NhdGlvbj1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLnNldEFsbExvY2F0aW9ucyhuZS5OT05FKX1pc0VxdWFsT25TaWRlKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRpb25bZV09PT10LmxvY2F0aW9uW2VdfWFsbFBvc2l0aW9uc0VxdWFsKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKWlmKHRoaXMubG9jYXRpb25bZV0hPT10KXJldHVybiExO3JldHVybiEwfWdldENsYXNzKCl7cmV0dXJuIEFufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Bbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLmxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0Lmxlbmd0aCl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCgxKSx0aGlzLmxvY2F0aW9uW1BuLk9OXT10fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBbil7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pbml0KHQubG9jYXRpb24ubGVuZ3RoKSxudWxsIT09dClmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPXQubG9jYXRpb25bZV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuaW5pdCgzKSx0aGlzLmxvY2F0aW9uW1BuLk9OXT10LHRoaXMubG9jYXRpb25bUG4uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW1BuLlJJR0hUXT1ufX07Y2xhc3MgRm57Y29uc3RydWN0b3IoKXtGbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0xpbmVMYWJlbCh0KXtjb25zdCBlPW5ldyBGbihuZS5OT05FKTtmb3IobGV0IG49MDtuPDI7bisrKWUuc2V0TG9jYXRpb24obix0LmdldExvY2F0aW9uKG4pKTtyZXR1cm4gZX1nZXRHZW9tZXRyeUNvdW50KCl7bGV0IHQ9MDtyZXR1cm4gdGhpcy5lbHRbMF0uaXNOdWxsKCl8fHQrKyx0aGlzLmVsdFsxXS5pc051bGwoKXx8dCsrLHR9c2V0QWxsTG9jYXRpb25zKHQsZSl7dGhpcy5lbHRbdF0uc2V0QWxsTG9jYXRpb25zKGUpfWlzTnVsbCh0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNOdWxsKCl9c2V0QWxsTG9jYXRpb25zSWZOdWxsKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdCksdGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFt0XS5zZXRBbGxMb2NhdGlvbnNJZk51bGwoZSl9fWlzTGluZSh0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNMaW5lKCl9bWVyZ2UodCl7Zm9yKGxldCBlPTA7ZTwyO2UrKyludWxsPT09dGhpcy5lbHRbZV0mJm51bGwhPT10LmVsdFtlXT90aGlzLmVsdFtlXT1uZXcgQW4odC5lbHRbZV0pOnRoaXMuZWx0W2VdLm1lcmdlKHQuZWx0W2VdKX1mbGlwKCl7dGhpcy5lbHRbMF0uZmxpcCgpLHRoaXMuZWx0WzFdLmZsaXAoKX1nZXRMb2NhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uZ2V0KFBuLk9OKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuZWx0W3RdLmdldChlKX19dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB3O3JldHVybiBudWxsIT09dGhpcy5lbHRbMF0mJih0LmFwcGVuZChcIkE6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzBdLnRvU3RyaW5nKCkpKSxudWxsIT09dGhpcy5lbHRbMV0mJih0LmFwcGVuZChcIiBCOlwiKSx0LmFwcGVuZCh0aGlzLmVsdFsxXS50b1N0cmluZygpKSksdC50b1N0cmluZygpfWlzQXJlYSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmVsdFswXS5pc0FyZWEoKXx8dGhpcy5lbHRbMV0uaXNBcmVhKCk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5pc0FyZWEoKX19aXNBbnlOdWxsKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0FueU51bGwoKX1zZXRMb2NhdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbihQbi5PTixlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbihlLG4pfX1pc0VxdWFsT25TaWRlKHQsZSl7cmV0dXJuIHRoaXMuZWx0WzBdLmlzRXF1YWxPblNpZGUodC5lbHRbMF0sZSkmJnRoaXMuZWx0WzFdLmlzRXF1YWxPblNpZGUodC5lbHRbMV0sZSl9YWxsUG9zaXRpb25zRXF1YWwodCxlKXtyZXR1cm4gdGhpcy5lbHRbdF0uYWxsUG9zaXRpb25zRXF1YWwoZSl9dG9MaW5lKHQpe3RoaXMuZWx0W3RdLmlzQXJlYSgpJiYodGhpcy5lbHRbdF09bmV3IEFuKHRoaXMuZWx0W3RdLmxvY2F0aW9uWzBdKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gRm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUZuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuZWx0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWx0WzBdPW5ldyBBbih0KSx0aGlzLmVsdFsxXT1uZXcgQW4odCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZuKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgQW4odC5lbHRbMF0pLHRoaXMuZWx0WzFdPW5ldyBBbih0LmVsdFsxXSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0WzBdPW5ldyBBbihuZS5OT05FKSx0aGlzLmVsdFsxXT1uZXcgQW4obmUuTk9ORSksdGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5lbHRbMF09bmV3IEFuKHQsZSxuKSx0aGlzLmVsdFsxXT1uZXcgQW4odCxlLG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuZWx0WzBdPW5ldyBBbihuZS5OT05FLG5lLk5PTkUsbmUuTk9ORSksdGhpcy5lbHRbMV09bmV3IEFuKG5lLk5PTkUsbmUuTk9ORSxuZS5OT05FKSx0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbnMoZSxuLHMpfX07Y2xhc3MgR257Y29uc3RydWN0b3IoKXtHbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldFNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuY29vcmR9cHJpbnQodCl7dC5wcmludCh0aGlzLmNvb3JkKSx0LnByaW50KFwiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgpLHQucHJpbnRsbihcIiBkaXN0ID0gXCIrdGhpcy5kaXN0KX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmUoZS5zZWdtZW50SW5kZXgsZS5kaXN0KX1pc0VuZFBvaW50KHQpe3JldHVybiAwPT09dGhpcy5zZWdtZW50SW5kZXgmJjA9PT10aGlzLmRpc3R8fHRoaXMuc2VnbWVudEluZGV4PT09dH10b1N0cmluZygpe3JldHVybiB0aGlzLmNvb3JkK1wiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgrXCIgZGlzdCA9IFwiK3RoaXMuZGlzdH1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLmRpc3R9Y29tcGFyZSh0LGUpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDx0Py0xOnRoaXMuc2VnbWVudEluZGV4PnQ/MTp0aGlzLmRpc3Q8ZT8tMTp0aGlzLmRpc3Q+ZT8xOjB9Z2V0Q2xhc3MoKXtyZXR1cm4gR259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Hbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLmRpc3Q9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmNvb3JkPW5ldyBnKHQpLHRoaXMuc2VnbWVudEluZGV4PWUsdGhpcy5kaXN0PW59O2NsYXNzIHFue2NvbnN0cnVjdG9yKCl7cW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1wcmludCh0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX1hZGRTcGxpdEVkZ2VzKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCk7Y29uc3QgZT10aGlzLml0ZXJhdG9yKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLHMpO3QuYWRkKGkpLG49c319YWRkRW5kcG9pbnRzKCl7Y29uc3QgdD10aGlzLmVkZ2UucHRzLmxlbmd0aC0xO3RoaXMuYWRkKHRoaXMuZWRnZS5wdHNbMF0sMCwwKSx0aGlzLmFkZCh0aGlzLmVkZ2UucHRzW3RdLHQsMCl9Y3JlYXRlU3BsaXRFZGdlKHQsZSl7bGV0IG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMjtjb25zdCBzPXRoaXMuZWRnZS5wdHNbZS5zZWdtZW50SW5kZXhdLGk9ZS5kaXN0PjB8fCFlLmNvb3JkLmVxdWFsczJEKHMpO2l8fG4tLTtjb25zdCByPW5ldyBBcnJheShuKS5maWxsKG51bGwpO2xldCBvPTA7cltvKytdPW5ldyBnKHQuY29vcmQpO2ZvcihsZXQgbj10LnNlZ21lbnRJbmRleCsxO248PWUuc2VnbWVudEluZGV4O24rKylyW28rK109dGhpcy5lZGdlLnB0c1tuXTtyZXR1cm4gaSYmKHJbb109ZS5jb29yZCksbmV3IFVuKHIsbmV3IEZuKHRoaXMuZWRnZS5fbGFiZWwpKX1hZGQodCxlLG4pe2NvbnN0IHM9bmV3IEduKHQsZSxuKSxpPXRoaXMuX25vZGVNYXAuZ2V0KHMpO3JldHVybiBudWxsIT09aT9pOih0aGlzLl9ub2RlTWFwLnB1dChzLHMpLHMpfWlzSW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtpZihlLm5leHQoKS5jb29yZC5lcXVhbHModCkpcmV0dXJuITB9cmV0dXJuITF9Z2V0Q2xhc3MoKXtyZXR1cm4gcW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXFuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25vZGVNYXA9bmV3IHJ0LHRoaXMuZWRnZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fTtjbGFzcyBCbntjb25zdHJ1Y3Rvcigpe0JuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvSW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10LmdldChuKS5pbnRWYWx1ZSgpO3JldHVybiBlfWdldENoYWluU3RhcnRJbmRpY2VzKHQpe2xldCBlPTA7Y29uc3Qgbj1uZXcgeDtuLmFkZChuZXcgTChlKSk7ZG97Y29uc3Qgcz10aGlzLmZpbmRDaGFpbkVuZCh0LGUpO24uYWRkKG5ldyBMKHMpKSxlPXN9d2hpbGUoZTx0Lmxlbmd0aC0xKTtyZXR1cm4gQm4udG9JbnRBcnJheShuKX1maW5kQ2hhaW5FbmQodCxlKXtjb25zdCBuPUluLnF1YWRyYW50KHRbZV0sdFtlKzFdKTtsZXQgcz1lKzE7Zm9yKDtzPHQubGVuZ3RoOyl7aWYoSW4ucXVhZHJhbnQodFtzLTFdLHRbc10pIT09bilicmVhaztzKyt9cmV0dXJuIHMtMX1nZXRDbGFzcygpe3JldHVybiBCbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Qm4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBWbntjb25zdHJ1Y3Rvcigpe1ZuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5wdHN9Z2V0TWF4WCh0KXtjb25zdCBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBlPm4/ZTpufWdldE1pblgodCl7Y29uc3QgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gZTxuP2U6bn1jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKCl7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLnN0YXJ0SW5kZXhbdF0sdGhpcy5zdGFydEluZGV4W3QrMV0sZSxlLnN0YXJ0SW5kZXhbbl0sZS5zdGFydEluZGV4W24rMV0scyl9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07aWYoZS10PT0xJiZpLXM9PTEpcmV0dXJuIHIuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmUsdCxuLmUscyksbnVsbDtpZighdGhpcy5vdmVybGFwcyh0LGUsbixzLGkpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygodCtlKS8yKSxsPU1hdGgudHJ1bmMoKHMraSkvMik7dDxvJiYoczxsJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odCxvLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHQsbyxuLGwsaSxyKSksbzxlJiYoczxsJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obyxlLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG8sZSxuLGwsaSxyKSl9fW92ZXJsYXBzKHQsZSxuLHMsaSl7cmV0dXJuIE4uaW50ZXJzZWN0cyh0aGlzLnB0c1t0XSx0aGlzLnB0c1tlXSxuLnB0c1tzXSxuLnB0c1tpXSl9Z2V0U3RhcnRJbmRleGVzKCl7cmV0dXJuIHRoaXMuc3RhcnRJbmRleH1jb21wdXRlSW50ZXJzZWN0cyh0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5zdGFydEluZGV4Lmxlbmd0aC0xO24rKylmb3IobGV0IHM9MDtzPHQuc3RhcnRJbmRleC5sZW5ndGgtMTtzKyspdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG4sdCxzLGUpfWdldENsYXNzKCl7cmV0dXJuIFZufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Wbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmU9bnVsbCx0aGlzLnB0cz1udWxsLHRoaXMuc3RhcnRJbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZT10LHRoaXMucHRzPXQuZ2V0Q29vcmRpbmF0ZXMoKTtjb25zdCBlPW5ldyBCbjt0aGlzLnN0YXJ0SW5kZXg9ZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyh0aGlzLnB0cyl9O2NsYXNzIHpue2NvbnN0cnVjdG9yKCl7em4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGVwdGhBdExvY2F0aW9uKHQpe3JldHVybiB0PT09bmUuRVhURVJJT1I/MDp0PT09bmUuSU5URVJJT1I/MTp6bi5OVUxMX1ZBTFVFfWdldERlcHRoKHQsZSl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2VdfXNldERlcHRoKHQsZSxuKXt0aGlzLl9kZXB0aFt0XVtlXT1ufWlzTnVsbCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobGV0IHQ9MDt0PDI7dCsrKWZvcihsZXQgZT0wO2U8MztlKyspaWYodGhpcy5fZGVwdGhbdF1bZV0hPT16bi5OVUxMX1ZBTFVFKXJldHVybiExO3JldHVybiEwfWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bMV09PT16bi5OVUxMX1ZBTFVFfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bZV09PT16bi5OVUxMX1ZBTFVFfX1ub3JtYWxpemUoKXtmb3IobGV0IHQ9MDt0PDI7dCsrKWlmKCF0aGlzLmlzTnVsbCh0KSl7bGV0IGU9dGhpcy5fZGVwdGhbdF1bMV07dGhpcy5fZGVwdGhbdF1bMl08ZSYmKGU9dGhpcy5fZGVwdGhbdF1bMl0pLGU8MCYmKGU9MCk7Zm9yKGxldCBuPTE7bjwzO24rKyl7bGV0IHM9MDt0aGlzLl9kZXB0aFt0XVtuXT5lJiYocz0xKSx0aGlzLl9kZXB0aFt0XVtuXT1zfX19Z2V0RGVsdGEodCl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW1BuLlJJR0hUXS10aGlzLl9kZXB0aFt0XVtQbi5MRUZUXX1nZXRMb2NhdGlvbih0LGUpe3JldHVybiB0aGlzLl9kZXB0aFt0XVtlXTw9MD9uZS5FWFRFUklPUjpuZS5JTlRFUklPUn10b1N0cmluZygpe3JldHVyblwiQTogXCIrdGhpcy5fZGVwdGhbMF1bMV0rXCIsXCIrdGhpcy5fZGVwdGhbMF1bMl0rXCIgQjogXCIrdGhpcy5fZGVwdGhbMV1bMV0rXCIsXCIrdGhpcy5fZGVwdGhbMV1bMl19YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8MjtlKyspZm9yKGxldCBuPTE7bjwzO24rKyl7Y29uc3Qgcz10LmdldExvY2F0aW9uKGUsbik7cyE9PW5lLkVYVEVSSU9SJiZzIT09bmUuSU5URVJJT1J8fCh0aGlzLmlzTnVsbChlLG4pP3RoaXMuX2RlcHRoW2VdW25dPXpuLmRlcHRoQXRMb2NhdGlvbihzKTp0aGlzLl9kZXB0aFtlXVtuXSs9em4uZGVwdGhBdExvY2F0aW9uKHMpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdPT09bmUuSU5URVJJT1ImJnRoaXMuX2RlcHRoW3RdW2VdKyt9fWdldENsYXNzKCl7cmV0dXJuIHpufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX16bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9kZXB0aD1BcnJheSgyKS5maWxsKCkubWFwKCgpPT5BcnJheSgzKSk7Zm9yKGxldCB0PTA7dDwyO3QrKylmb3IobGV0IGU9MDtlPDM7ZSsrKXRoaXMuX2RlcHRoW3RdW2VdPXpuLk5VTExfVkFMVUV9LHpuLk5VTExfVkFMVUU9LTE7Y2xhc3MgWW57Y29uc3RydWN0b3IoKXtZbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9c2V0SW5SZXN1bHQodCl7dGhpcy5faXNJblJlc3VsdD10fWlzQ292ZXJlZCgpe3JldHVybiB0aGlzLl9pc0NvdmVyZWR9aXNDb3ZlcmVkU2V0KCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZFNldH1zZXRMYWJlbCh0KXt0aGlzLl9sYWJlbD10fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfXNldENvdmVyZWQodCl7dGhpcy5faXNDb3ZlcmVkPXQsdGhpcy5faXNDb3ZlcmVkU2V0PSEwfXVwZGF0ZUlNKHQpe3UuaXNUcnVlKHRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKT49MixcImZvdW5kIHBhcnRpYWwgbGFiZWxcIiksdGhpcy5jb21wdXRlSU0odCl9aXNJblJlc3VsdCgpe3JldHVybiB0aGlzLl9pc0luUmVzdWx0fWlzVmlzaXRlZCgpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9Z2V0Q2xhc3MoKXtyZXR1cm4gWW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVluLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2xhYmVsPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc0NvdmVyZWQ9ITEsdGhpcy5faXNDb3ZlcmVkU2V0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGFiZWw9dH19O2NsYXNzIFVuIGV4dGVuZHMgWW57Y29uc3RydWN0b3IoKXtzdXBlcigpLFVuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHVwZGF0ZUlNKCl7aWYoISgyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBzZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGbikpcmV0dXJuIHN1cGVyLnVwZGF0ZUlNLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsUG4uT04pLHQuZ2V0TG9jYXRpb24oMSxQbi5PTiksMSksdC5pc0FyZWEoKSYmKGUuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLFBuLkxFRlQpLHQuZ2V0TG9jYXRpb24oMSxQbi5MRUZUKSwyKSxlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCksdC5nZXRMb2NhdGlvbigxLFBuLlJJR0hUKSwyKSl9fWdldERlcHRoKCl7cmV0dXJuIHRoaXMuX2RlcHRofWdldENvbGxhcHNlZEVkZ2UoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiB0WzBdPXRoaXMucHRzWzBdLHRbMV09dGhpcy5wdHNbMV0sbmV3IFVuKHQsRm4udG9MaW5lTGFiZWwodGhpcy5fbGFiZWwpKX1pc0lzb2xhdGVkKCl7cmV0dXJuIHRoaXMuX2lzSXNvbGF0ZWR9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5wdHN9c2V0SXNvbGF0ZWQodCl7dGhpcy5faXNJc29sYXRlZD10fXNldE5hbWUodCl7dGhpcy5fbmFtZT10fWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBVbikpcmV0dXJuITE7Y29uc3QgZT10O2lmKHRoaXMucHRzLmxlbmd0aCE9PWUucHRzLmxlbmd0aClyZXR1cm4hMTtsZXQgbj0hMCxzPSEwLGk9dGhpcy5wdHMubGVuZ3RoO2ZvcihsZXQgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKylpZih0aGlzLnB0c1t0XS5lcXVhbHMyRChlLnB0c1t0XSl8fChuPSExKSx0aGlzLnB0c1t0XS5lcXVhbHMyRChlLnB0c1stLWldKXx8KHM9ITEpLCFuJiYhcylyZXR1cm4hMTtyZXR1cm4hMH1nZXRDb29yZGluYXRlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMucHRzLmxlbmd0aD4wP3RoaXMucHRzWzBdOm51bGw7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnB0c1t0XX19cHJpbnQodCl7dC5wcmludChcImVkZ2UgXCIrdGhpcy5fbmFtZStcIjogXCIpLHQucHJpbnQoXCJMSU5FU1RSSU5HIChcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWU+MCYmdC5wcmludChcIixcIiksdC5wcmludCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3QucHJpbnQoXCIpICBcIit0aGlzLl9sYWJlbCtcIiBcIit0aGlzLl9kZXB0aERlbHRhKX1jb21wdXRlSU0odCl7VW4udXBkYXRlSU0odGhpcy5fbGFiZWwsdCl9aXNDb2xsYXBzZWQoKXtyZXR1cm4hIXRoaXMuX2xhYmVsLmlzQXJlYSgpJiYoMz09PXRoaXMucHRzLmxlbmd0aCYmISF0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbMl0pKX1pc0Nsb3NlZCgpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX1nZXRNYXhpbXVtU2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aC0xfWdldERlcHRoRGVsdGEoKXtyZXR1cm4gdGhpcy5fZGVwdGhEZWx0YX1nZXROdW1Qb2ludHMoKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RofXByaW50UmV2ZXJzZSh0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLl9uYW1lK1wiOiBcIik7Zm9yKGxldCBlPXRoaXMucHRzLmxlbmd0aC0xO2U+PTA7ZS0tKXQucHJpbnQodGhpcy5wdHNbZV0rXCIgXCIpO3QucHJpbnRsbihcIlwiKX1nZXRNb25vdG9uZUNoYWluRWRnZSgpe3JldHVybiBudWxsPT09dGhpcy5fbWNlJiYodGhpcy5fbWNlPW5ldyBWbih0aGlzKSksdGhpcy5fbWNlfWdldEVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX2Vudil7dGhpcy5fZW52PW5ldyBOO2ZvcihsZXQgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKyl0aGlzLl9lbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMucHRzW3RdKX1yZXR1cm4gdGhpcy5fZW52fWFkZEludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCBpPW5ldyBnKHQuZ2V0SW50ZXJzZWN0aW9uKHMpKTtsZXQgcj1lLG89dC5nZXRFZGdlRGlzdGFuY2UobixzKTtjb25zdCBsPXIrMTtpZihsPHRoaXMucHRzLmxlbmd0aCl7Y29uc3QgdD10aGlzLnB0c1tsXTtpLmVxdWFsczJEKHQpJiYocj1sLG89MCl9dGhpcy5laUxpc3QuYWRkKGkscixvKX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHd0O3QuYXBwZW5kKFwiZWRnZSBcIit0aGlzLl9uYW1lK1wiOiBcIiksdC5hcHBlbmQoXCJMSU5FU1RSSU5HIChcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWU+MCYmdC5hcHBlbmQoXCIsXCIpLHQuYXBwZW5kKHRoaXMucHRzW2VdLngrXCIgXCIrdGhpcy5wdHNbZV0ueSk7cmV0dXJuIHQuYXBwZW5kKFwiKSAgXCIrdGhpcy5fbGFiZWwrXCIgXCIrdGhpcy5fZGVwdGhEZWx0YSksdC50b1N0cmluZygpfWlzUG9pbnR3aXNlRXF1YWwodCl7aWYodGhpcy5wdHMubGVuZ3RoIT09dC5wdHMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKylpZighdGhpcy5wdHNbZV0uZXF1YWxzMkQodC5wdHNbZV0pKXJldHVybiExO3JldHVybiEwfXNldERlcHRoRGVsdGEodCl7dGhpcy5fZGVwdGhEZWx0YT10fWdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCl7cmV0dXJuIHRoaXMuZWlMaXN0fWFkZEludGVyc2VjdGlvbnModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtzKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4scyl9Z2V0Q2xhc3MoKXtyZXR1cm4gVW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVVuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMucHRzPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5laUxpc3Q9bmV3IHFuKHRoaXMpLHRoaXMuX25hbWU9bnVsbCx0aGlzLl9tY2U9bnVsbCx0aGlzLl9pc0lzb2xhdGVkPSEwLHRoaXMuX2RlcHRoPW5ldyB6bix0aGlzLl9kZXB0aERlbHRhPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO1VuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz10LHRoaXMuX2xhYmVsPWV9fTtjbGFzcyBrbiBleHRlbmRzIFlue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxrbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKXtmb3IobGV0IHQ9dGhpcy5nZXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2lmKHQubmV4dCgpLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpcmV0dXJuITB9cmV0dXJuITF9aXNJc29sYXRlZCgpe3JldHVybiAxPT09dGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fY29vcmR9cHJpbnQodCl7dC5wcmludGxuKFwibm9kZSBcIit0aGlzLl9jb29yZCtcIiBsYmw6IFwiK3RoaXMuX2xhYmVsKX1jb21wdXRlSU0odCl7fWNvbXB1dGVNZXJnZWRMb2NhdGlvbih0LGUpe2xldCBuPW5lLk5PTkU7aWYobj10aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlKSwhdC5pc051bGwoZSkpe2NvbnN0IHM9dC5nZXRMb2NhdGlvbihlKTtuIT09bmUuQk9VTkRBUlkmJihuPXMpfXJldHVybiBufXNldExhYmVsKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSl8fCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpcmV0dXJuIHN1cGVyLnNldExhYmVsLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMuX2xhYmVsP3RoaXMuX2xhYmVsPW5ldyBGbih0LGUpOnRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSl9fWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfW1lcmdlTGFiZWwoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGtuKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodC5fbGFiZWwpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGbil7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTwyO2UrKyl7Y29uc3Qgbj10aGlzLmNvbXB1dGVNZXJnZWRMb2NhdGlvbih0LGUpO3RoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUpPT09bmUuTk9ORSYmdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24oZSxuKX19fWFkZCh0KXt0aGlzLl9lZGdlcy5pbnNlcnQodCksdC5zZXROb2RlKHRoaXMpfXNldExhYmVsQm91bmRhcnkodCl7aWYobnVsbD09PXRoaXMuX2xhYmVsKXJldHVybiBudWxsO2xldCBlPW5lLk5PTkU7bnVsbCE9PXRoaXMuX2xhYmVsJiYoZT10aGlzLl9sYWJlbC5nZXRMb2NhdGlvbih0KSk7bGV0IG49bnVsbDtzd2l0Y2goZSl7Y2FzZSBuZS5CT1VOREFSWTpuPW5lLklOVEVSSU9SO2JyZWFrO2Nhc2UgbmUuSU5URVJJT1I6ZGVmYXVsdDpuPW5lLkJPVU5EQVJZfXRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsbil9Z2V0Q2xhc3MoKXtyZXR1cm4ga259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWtuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Nvb3JkPW51bGwsdGhpcy5fZWRnZXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jb29yZD10LHRoaXMuX2VkZ2VzPWUsdGhpcy5fbGFiZWw9bmV3IEZuKDAsbmUuTk9ORSl9O2NsYXNzIFhue2NvbnN0cnVjdG9yKCl7WG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5kKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZ2V0KHQpfWFkZE5vZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPXRoaXMubm9kZU1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1lJiYoZT10aGlzLm5vZGVGYWN0LmNyZWF0ZU5vZGUodCksdGhpcy5ub2RlTWFwLnB1dCh0LGUpKSxlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Yga24pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5ub2RlTWFwLmdldCh0LmdldENvb3JkaW5hdGUoKSk7cmV0dXJuIG51bGw9PT1lPyh0aGlzLm5vZGVNYXAucHV0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpLHQpOihlLm1lcmdlTGFiZWwodCksZSl9fXByaW50KHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9dmFsdWVzKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKX1nZXRCb3VuZGFyeU5vZGVzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cy5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpPT09bmUuQk9VTkRBUlkmJmUuYWRkKHMpfXJldHVybiBlfWFkZCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuYWRkTm9kZShlKS5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gWG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVhuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMubm9kZU1hcD1uZXcgcnQsdGhpcy5ub2RlRmFjdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZUZhY3Q9dH07Y2xhc3MgSG57Y29uc3RydWN0b3IoKXtIbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmVEaXJlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2R4PT09dC5fZHgmJnRoaXMuX2R5PT09dC5fZHk/MDp0aGlzLl9xdWFkcmFudD50Ll9xdWFkcmFudD8xOnRoaXMuX3F1YWRyYW50PHQuX3F1YWRyYW50Py0xOnYuaW5kZXgodC5fcDAsdC5fcDEsdGhpcy5fcDEpfWdldER5KCl7cmV0dXJuIHRoaXMuX2R5fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcDB9c2V0Tm9kZSh0KXt0aGlzLl9ub2RlPXR9cHJpbnQodCl7Y29uc3QgZT1NYXRoLmF0YW4yKHRoaXMuX2R5LHRoaXMuX2R4KSxuPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkscz1uLmxhc3RJbmRleE9mKFwiLlwiKSxpPW4uc3Vic3RyaW5nKHMrMSk7dC5wcmludChcIiAgXCIraStcIjogXCIrdGhpcy5fcDArXCIgLSBcIit0aGlzLl9wMStcIiBcIit0aGlzLl9xdWFkcmFudCtcIjpcIitlK1wiICAgXCIrdGhpcy5fbGFiZWwpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX1nZXREaXJlY3RlZENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcDF9Z2V0RHgoKXtyZXR1cm4gdGhpcy5fZHh9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfWdldFF1YWRyYW50KCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50fWdldE5vZGUoKXtyZXR1cm4gdGhpcy5fbm9kZX10b1N0cmluZygpe2NvbnN0IHQ9TWF0aC5hdGFuMih0aGlzLl9keSx0aGlzLl9keCksZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIik7cmV0dXJuXCIgIFwiK2Uuc3Vic3RyaW5nKG4rMSkrXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrdCtcIiAgIFwiK3RoaXMuX2xhYmVsfWNvbXB1dGVMYWJlbCh0KXt9aW5pdCh0LGUpe3RoaXMuX3AwPXQsdGhpcy5fcDE9ZSx0aGlzLl9keD1lLngtdC54LHRoaXMuX2R5PWUueS10LnksdGhpcy5fcXVhZHJhbnQ9SW4ucXVhZHJhbnQodGhpcy5fZHgsdGhpcy5fZHkpLHUuaXNUcnVlKCEoMD09PXRoaXMuX2R4JiYwPT09dGhpcy5fZHkpLFwiRWRnZUVuZCB3aXRoIGlkZW50aWNhbCBlbmRwb2ludHMgZm91bmRcIil9Z2V0Q2xhc3MoKXtyZXR1cm4gSG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Ibi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9lZGdlPW51bGwsdGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9ub2RlPW51bGwsdGhpcy5fcDA9bnVsbCx0aGlzLl9wMT1udWxsLHRoaXMuX2R4PW51bGwsdGhpcy5fZHk9bnVsbCx0aGlzLl9xdWFkcmFudD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlPXR9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07SG4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixudWxsKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtIbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuaW5pdChlLG4pLHRoaXMuX2xhYmVsPXN9fTtjbGFzcyBXbiBleHRlbmRzIGN7Y29uc3RydWN0b3IoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07c3VwZXIodCksYy5jYWxsKHRoaXMsdCl9ZWxzZXtpZigyIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBFcnJvcigpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtzdXBlcihXbi5tc2dXaXRoQ29vcmQodCxlKSksdGhpcy5uYW1lPVwiVG9wb2xvZ3lFeGNlcHRpb25cIix0aGlzLnB0PW5ldyBnKGUpfX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLnB0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfWdldENsYXNzKCl7cmV0dXJuIFdufXN0YXRpYyBtc2dXaXRoQ29vcmQodCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9fWNsYXNzIGpuIGV4dGVuZHMgSG57Y29uc3RydWN0b3IoKXtzdXBlcigpLGpuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRlcHRoRmFjdG9yKHQsZSl7cmV0dXJuIHQ9PT1uZS5FWFRFUklPUiYmZT09PW5lLklOVEVSSU9SPzE6dD09PW5lLklOVEVSSU9SJiZlPT09bmUuRVhURVJJT1I/LTE6MH1nZXROZXh0TWluKCl7cmV0dXJuIHRoaXMuX25leHRNaW59Z2V0RGVwdGgodCl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdfXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9Y29tcHV0ZURpcmVjdGVkTGFiZWwoKXt0aGlzLl9sYWJlbD1uZXcgRm4odGhpcy5fZWRnZS5nZXRMYWJlbCgpKSx0aGlzLl9pc0ZvcndhcmR8fHRoaXMuX2xhYmVsLmZsaXAoKX1nZXROZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9c2V0RGVwdGgodCxlKXtpZigtOTk5IT09dGhpcy5fZGVwdGhbdF0mJnRoaXMuX2RlcHRoW3RdIT09ZSl0aHJvdyBuZXcgV24oXCJhc3NpZ25lZCBkZXB0aHMgZG8gbm90IG1hdGNoXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO3RoaXMuX2RlcHRoW3RdPWV9aXNJbnRlcmlvckFyZWFFZGdlKCl7bGV0IHQ9ITA7Zm9yKGxldCBlPTA7ZTwyO2UrKyl0aGlzLl9sYWJlbC5pc0FyZWEoZSkmJnRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUsUG4uTEVGVCk9PT1uZS5JTlRFUklPUiYmdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSxQbi5SSUdIVCk9PT1uZS5JTlRFUklPUnx8KHQ9ITEpO3JldHVybiB0fXNldE5leHRNaW4odCl7dGhpcy5fbmV4dE1pbj10fXByaW50KHQpe3N1cGVyLnByaW50LmNhbGwodGhpcyx0KSx0LnByaW50KFwiIFwiK3RoaXMuX2RlcHRoW1BuLkxFRlRdK1wiL1wiK3RoaXMuX2RlcHRoW1BuLlJJR0hUXSksdC5wcmludChcIiAoXCIrdGhpcy5nZXREZXB0aERlbHRhKCkrXCIpXCIpLHRoaXMuX2lzSW5SZXN1bHQmJnQucHJpbnQoXCIgaW5SZXN1bHRcIil9c2V0TWluRWRnZVJpbmcodCl7dGhpcy5fbWluRWRnZVJpbmc9dH1pc0xpbmVFZGdlKCl7Y29uc3QgdD10aGlzLl9sYWJlbC5pc0xpbmUoMCl8fHRoaXMuX2xhYmVsLmlzTGluZSgxKSxlPSF0aGlzLl9sYWJlbC5pc0FyZWEoMCl8fHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDAsbmUuRVhURVJJT1IpLG49IXRoaXMuX2xhYmVsLmlzQXJlYSgxKXx8dGhpcy5fbGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMSxuZS5FWFRFUklPUik7cmV0dXJuIHQmJmUmJm59c2V0RWRnZVJpbmcodCl7dGhpcy5fZWRnZVJpbmc9dH1nZXRNaW5FZGdlUmluZygpe3JldHVybiB0aGlzLl9taW5FZGdlUmluZ31nZXREZXB0aERlbHRhKCl7bGV0IHQ9dGhpcy5fZWRnZS5nZXREZXB0aERlbHRhKCk7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZHx8KHQ9LXQpLHR9c2V0SW5SZXN1bHQodCl7dGhpcy5faXNJblJlc3VsdD10fWdldFN5bSgpe3JldHVybiB0aGlzLl9zeW19aXNGb3J3YXJkKCl7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZH1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX2VkZ2V9cHJpbnRFZGdlKHQpe3RoaXMucHJpbnQodCksdC5wcmludChcIiBcIiksdGhpcy5faXNGb3J3YXJkP3RoaXMuX2VkZ2UucHJpbnQodCk6dGhpcy5fZWRnZS5wcmludFJldmVyc2UodCl9c2V0U3ltKHQpe3RoaXMuX3N5bT10fXNldFZpc2l0ZWRFZGdlKHQpe3RoaXMuc2V0VmlzaXRlZCh0KSx0aGlzLl9zeW0uc2V0VmlzaXRlZCh0KX1zZXRFZGdlRGVwdGhzKHQsZSl7bGV0IG49dGhpcy5nZXRFZGdlKCkuZ2V0RGVwdGhEZWx0YSgpO3RoaXMuX2lzRm9yd2FyZHx8KG49LW4pO2xldCBzPTE7dD09PVBuLkxFRlQmJihzPS0xKTtjb25zdCBpPVBuLm9wcG9zaXRlKHQpLHI9ZStuKnM7dGhpcy5zZXREZXB0aCh0LGUpLHRoaXMuc2V0RGVwdGgoaSxyKX1nZXRFZGdlUmluZygpe3JldHVybiB0aGlzLl9lZGdlUmluZ31pc0luUmVzdWx0KCl7cmV0dXJuIHRoaXMuX2lzSW5SZXN1bHR9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9aXNWaXNpdGVkKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH1nZXRDbGFzcygpe3JldHVybiBqbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19am4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNGb3J3YXJkPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5fc3ltPW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX25leHRNaW49bnVsbCx0aGlzLl9lZGdlUmluZz1udWxsLHRoaXMuX21pbkVkZ2VSaW5nPW51bGwsdGhpcy5fZGVwdGg9WzAsLTk5OSwtOTk5XTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihIbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuX2lzRm9yd2FyZD1lLGUpdGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZSgwKSx0LmdldENvb3JkaW5hdGUoMSkpO2Vsc2V7Y29uc3QgZT10LmdldE51bVBvaW50cygpLTE7dGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZShlKSx0LmdldENvb3JkaW5hdGUoZS0xKSl9dGhpcy5jb21wdXRlRGlyZWN0ZWRMYWJlbCgpfTtjbGFzcyBLbntjb25zdHJ1Y3Rvcigpe0tuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IGtuKHQsbnVsbCl9Z2V0Q2xhc3MoKXtyZXR1cm4gS259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUtuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgWm57Y29uc3RydWN0b3IoKXtabi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpfX1wcmludEVkZ2VzKHQpe3QucHJpbnRsbihcIkVkZ2VzOlwiKTtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspe3QucHJpbnRsbihcImVkZ2UgXCIrZStcIjpcIik7Y29uc3Qgbj10aGlzLl9lZGdlcy5nZXQoZSk7bi5wcmludCh0KSxuLmVpTGlzdC5wcmludCh0KX19ZmluZCh0KXtyZXR1cm4gdGhpcy5fbm9kZXMuZmluZCh0KX1hZGROb2RlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBrbil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX25vZGVzLmFkZE5vZGUodCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZSh0KX19Z2V0Tm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVzLml0ZXJhdG9yKCl9bGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19ZGVidWdQcmludGxuKHQpe08ub3V0LnByaW50bG4odCl9aXNCb3VuZGFyeU5vZGUodCxlKXtjb25zdCBuPXRoaXMuX25vZGVzLmZpbmQoZSk7aWYobnVsbD09PW4pcmV0dXJuITE7Y29uc3Qgcz1uLmdldExhYmVsKCk7cmV0dXJuIG51bGwhPT1zJiZzLmdldExvY2F0aW9uKHQpPT09bmUuQk9VTkRBUll9bGlua0FsbERpcmVjdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubGlua0FsbERpcmVjdGVkRWRnZXMoKX19bWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLG4scyl7cmV0dXJuISF0LmVxdWFscyhuKSYmKHYuaW5kZXgodCxlLHMpPT09di5DT0xMSU5FQVImJkluLnF1YWRyYW50KHQsZSk9PT1Jbi5xdWFkcmFudChuLHMpKX1nZXRFZGdlRW5kcygpe3JldHVybiB0aGlzLl9lZGdlRW5kTGlzdH1kZWJ1Z1ByaW50KHQpe08ub3V0LnByaW50KHQpfWdldEVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKHQsZSl7Zm9yKGxldCBuPTA7bjx0aGlzLl9lZGdlcy5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuX2VkZ2VzLmdldChuKSxpPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxpWzBdLGlbMV0pKXJldHVybiBzO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLGlbaS5sZW5ndGgtMV0saVtpLmxlbmd0aC0yXSkpcmV0dXJuIHN9cmV0dXJuIG51bGx9aW5zZXJ0RWRnZSh0KXt0aGlzLl9lZGdlcy5hZGQodCl9ZmluZEVkZ2VFbmQodCl7Zm9yKGxldCBlPXRoaXMuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZihuLmdldEVkZ2UoKT09PXQpcmV0dXJuIG59cmV0dXJuIG51bGx9YWRkRWRnZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fZWRnZXMuYWRkKHQpO2NvbnN0IG49bmV3IGpuKHQsITApLHM9bmV3IGpuKHQsITEpO24uc2V0U3ltKHMpLHMuc2V0U3ltKG4pLHRoaXMuYWRkKG4pLHRoaXMuYWRkKHMpfX1hZGQodCl7dGhpcy5fbm9kZXMuYWRkKHQpLHRoaXMuX2VkZ2VFbmRMaXN0LmFkZCh0KX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2Rlcy52YWx1ZXMoKX1maW5kRWRnZSh0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5fZWRnZXMuc2l6ZSgpO24rKyl7Y29uc3Qgcz10aGlzLl9lZGdlcy5nZXQobiksaT1zLmdldENvb3JkaW5hdGVzKCk7aWYodC5lcXVhbHMoaVswXSkmJmUuZXF1YWxzKGlbMV0pKXJldHVybiBzfXJldHVybiBudWxsfWdldENsYXNzKCl7cmV0dXJuIFpufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1abi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9lZGdlcz1uZXcgeCx0aGlzLl9ub2Rlcz1udWxsLHRoaXMuX2VkZ2VFbmRMaXN0PW5ldyB4LDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX25vZGVzPW5ldyBYbihuZXcgS24pO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25vZGVzPW5ldyBYbih0KX19O2NsYXNzIFFuIGV4dGVuZHMgWm57Y29uc3RydWN0b3IoKXtzdXBlcigpLFFuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRldGVybWluZUJvdW5kYXJ5KHQsZSl7cmV0dXJuIHQuaXNJbkJvdW5kYXJ5KGUpP25lLkJPVU5EQVJZOm5lLklOVEVSSU9SfWluc2VydEJvdW5kYXJ5UG9pbnQodCxlKXtjb25zdCBuPXRoaXMuX25vZGVzLmFkZE5vZGUoZSkuZ2V0TGFiZWwoKTtsZXQgcz0xLGk9bmUuTk9ORTtpPW4uZ2V0TG9jYXRpb24odCxQbi5PTiksaT09PW5lLkJPVU5EQVJZJiZzKys7Y29uc3Qgcj1Rbi5kZXRlcm1pbmVCb3VuZGFyeSh0aGlzLl9ib3VuZGFyeU5vZGVSdWxlLHMpO24uc2V0TG9jYXRpb24odCxyKX1jb21wdXRlU2VsZk5vZGVzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXB1dGVTZWxmTm9kZXModCxlLCExKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgTW4odCwhMCwhMSk7cy5zZXRJc0RvbmVJZlByb3BlckludChuKTtjb25zdCBpPXRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCkscj10aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgRHR8fHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBidHx8dGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIEF0LG89ZXx8IXI7cmV0dXJuIGkuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMscyxvKSx0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0aGlzLl9hcmdJbmRleCksc319Y29tcHV0ZVNwbGl0RWRnZXModCl7Zm9yKGxldCBlPXRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5laUxpc3QuYWRkU3BsaXRFZGdlcyh0KX19Y29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHQsZSxuKXtjb25zdCBzPW5ldyBNbihlLG4sITApO3JldHVybiBzLnNldEJvdW5kYXJ5Tm9kZXModGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksdC5nZXRCb3VuZGFyeU5vZGVzKCkpLHRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCkuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMsdC5fZWRnZXMscyksc31nZXRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9wYXJlbnRHZW9tfWdldEJvdW5kYXJ5Tm9kZVJ1bGUoKXtyZXR1cm4gdGhpcy5fYm91bmRhcnlOb2RlUnVsZX1oYXNUb29GZXdQb2ludHMoKXtyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzfWFkZFBvaW50KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsdCxuZS5JTlRFUklPUil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsdCxuZS5JTlRFUklPUil9fWFkZFBvbHlnb24odCl7dGhpcy5hZGRQb2x5Z29uUmluZyh0LmdldEV4dGVyaW9yUmluZygpLG5lLkVYVEVSSU9SLG5lLklOVEVSSU9SKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBuPXQuZ2V0SW50ZXJpb3JSaW5nTihlKTt0aGlzLmFkZFBvbHlnb25SaW5nKG4sbmUuSU5URVJJT1IsbmUuRVhURVJJT1IpfX1hZGRFZGdlKHQpe3RoaXMuaW5zZXJ0RWRnZSh0KTtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LGVbMF0sbmUuQk9VTkRBUlkpLHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSxuZS5CT1VOREFSWSl9YWRkTGluZVN0cmluZyh0KXtjb25zdCBlPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHM9ITAsdGhpcy5faW52YWxpZFBvaW50PWVbMF0sbnVsbDtjb25zdCBuPW5ldyBVbihlLG5ldyBGbih0aGlzLl9hcmdJbmRleCxuZS5JTlRFUklPUikpO3RoaXMuX2xpbmVFZGdlTWFwLnB1dCh0LG4pLHRoaXMuaW5zZXJ0RWRnZShuKSx1LmlzVHJ1ZShlLmxlbmd0aD49MixcImZvdW5kIExpbmVTdHJpbmcgd2l0aCBzaW5nbGUgcG9pbnRcIiksdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuX2FyZ0luZGV4LGVbMF0pLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLl9hcmdJbmRleCxlW2UubGVuZ3RoLTFdKX1nZXRJbnZhbGlkUG9pbnQoKXtyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50fWdldEJvdW5kYXJ5UG9pbnRzKCl7Y29uc3QgdD10aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSxlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtsZXQgbj0wO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2VbbisrXT10LmdldENvb3JkaW5hdGUoKS5jb3B5KCl9cmV0dXJuIGV9Z2V0Qm91bmRhcnlOb2Rlcygpe3JldHVybiBudWxsPT09dGhpcy5fYm91bmRhcnlOb2RlcyYmKHRoaXMuX2JvdW5kYXJ5Tm9kZXM9dGhpcy5fbm9kZXMuZ2V0Qm91bmRhcnlOb2Rlcyh0aGlzLl9hcmdJbmRleCkpLHRoaXMuX2JvdW5kYXJ5Tm9kZXN9YWRkU2VsZkludGVyc2VjdGlvbk5vZGUodCxlLG4pe2lmKHRoaXMuaXNCb3VuZGFyeU5vZGUodCxlKSlyZXR1cm4gbnVsbDtuPT09bmUuQk9VTkRBUlkmJnRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU/dGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHQsZSk6dGhpcy5pbnNlcnRQb2ludCh0LGUsbil9YWRkUG9seWdvblJpbmcodCxlLG4pe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IHM9WC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKHMubGVuZ3RoPDQpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLl9pbnZhbGlkUG9pbnQ9c1swXSxudWxsO2xldCBpPWUscj1uO3YuaXNDQ1cocykmJihpPW4scj1lKTtjb25zdCBvPW5ldyBVbihzLG5ldyBGbih0aGlzLl9hcmdJbmRleCxuZS5CT1VOREFSWSxpLHIpKTt0aGlzLl9saW5lRWRnZU1hcC5wdXQodCxvKSx0aGlzLmluc2VydEVkZ2UobyksdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCxzWzBdLG5lLkJPVU5EQVJZKX1pbnNlcnRQb2ludCh0LGUsbil7Y29uc3Qgcz10aGlzLl9ub2Rlcy5hZGROb2RlKGUpLGk9cy5nZXRMYWJlbCgpO251bGw9PT1pP3MuX2xhYmVsPW5ldyBGbih0LG4pOmkuc2V0TG9jYXRpb24odCxuKX1jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKXtyZXR1cm4gbmV3IERufWFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZWlMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGUodCxuLmNvb3JkLHMpfX19YWRkKCl7aWYoISgxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKSlyZXR1cm4gc3VwZXIuYWRkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIEF0JiYodGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT0hMSksdCBpbnN0YW5jZW9mIGJ0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZExpbmVTdHJpbmcodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGRQb2ludCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBNdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEF0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIF90KSl0aHJvdyBuZXcgWih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fX1hZGRDb2xsZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO3RoaXMuYWRkKG4pfX1sb2NhdGUodCl7cmV0dXJuIF8odGhpcy5fcGFyZW50R2VvbSxPdCkmJnRoaXMuX3BhcmVudEdlb20uZ2V0TnVtR2VvbWV0cmllcygpPjUwPyhudWxsPT09dGhpcy5fYXJlYVB0TG9jYXRvciYmKHRoaXMuX2FyZWFQdExvY2F0b3I9bmV3IGtlKHRoaXMuX3BhcmVudEdlb20pKSx0aGlzLl9hcmVhUHRMb2NhdG9yLmxvY2F0ZSh0KSk6dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LHRoaXMuX3BhcmVudEdlb20pfWZpbmRFZGdlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9saW5lRWRnZU1hcC5nZXQodCl9cmV0dXJuIHN1cGVyLmZpbmRFZGdlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBRbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcGFyZW50R2VvbT1udWxsLHRoaXMuX2xpbmVFZGdlTWFwPW5ldyBVdCx0aGlzLl9ib3VuZGFyeU5vZGVSdWxlPW51bGwsdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT0hMCx0aGlzLl9hcmdJbmRleD1udWxsLHRoaXMuX2JvdW5kYXJ5Tm9kZXM9bnVsbCx0aGlzLl9oYXNUb29GZXdQb2ludHM9ITEsdGhpcy5faW52YWxpZFBvaW50PW51bGwsdGhpcy5fYXJlYVB0TG9jYXRvcj1udWxsLHRoaXMuX3B0TG9jYXRvcj1uZXcgX24sMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1FuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9hcmdJbmRleD10LHRoaXMuX3BhcmVudEdlb209ZSx0aGlzLl9ib3VuZGFyeU5vZGVSdWxlPW4sbnVsbCE9PWUmJnRoaXMuYWRkKGUpfX07dmFyIEpuPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb21ldHJ5R3JhcGg6UW59KTtjbGFzcyAkbntjb25zdHJ1Y3RvcigpeyRuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXQodCl7fWdldENsYXNzKCl7cmV0dXJuICRufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX0kbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHRze2NvbnN0cnVjdG9yKCl7dHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc1JlcGVhdGVkKCl7cmV0dXJuIHRoaXMuX2NvdW50PjF9Z2V0UmlnaHQoKXtyZXR1cm4gdGhpcy5fcmlnaHR9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wfXNldExlZnQodCl7dGhpcy5fbGVmdD10fWdldFgoKXtyZXR1cm4gdGhpcy5fcC54fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1nZXRDb3VudCgpe3JldHVybiB0aGlzLl9jb3VudH1nZXRMZWZ0KCl7cmV0dXJuIHRoaXMuX2xlZnR9Z2V0WSgpe3JldHVybiB0aGlzLl9wLnl9aW5jcmVtZW50KCl7dGhpcy5fY291bnQ9dGhpcy5fY291bnQrMX1zZXRSaWdodCh0KXt0aGlzLl9yaWdodD10fWdldENsYXNzKCl7cmV0dXJuIHRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX10cy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wPW51bGwsdGhpcy5fZGF0YT1udWxsLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2NvdW50PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3A9bmV3IGcodCksdGhpcy5fbGVmdD1udWxsLHRoaXMuX3JpZ2h0PW51bGwsdGhpcy5fY291bnQ9MSx0aGlzLl9kYXRhPWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcD1uZXcgZyh0LGUpLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2NvdW50PTEsdGhpcy5fZGF0YT1ufX07Y2xhc3MgZXN7Y29uc3RydWN0b3IoKXtlcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0Nvb3JkaW5hdGVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBlcy50b0Nvb3JkaW5hdGVzKHQsITEpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBJO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9ZT90LmdldENvdW50KCk6MTtmb3IobGV0IGU9MDtlPGk7ZSsrKW4uYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpLCEwKX1yZXR1cm4gbi50b0Nvb3JkaW5hdGVBcnJheSgpfX1pbnNlcnQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5zZXJ0KHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKG51bGw9PT10aGlzLl9yb290KXJldHVybiB0aGlzLl9yb290PW5ldyB0cyh0LGUpLHRoaXMuX3Jvb3Q7aWYodGhpcy5fdG9sZXJhbmNlPjApe2NvbnN0IGU9dGhpcy5maW5kQmVzdE1hdGNoTm9kZSh0KTtpZihudWxsIT09ZSlyZXR1cm4gZS5pbmNyZW1lbnQoKSxlfXJldHVybiB0aGlzLmluc2VydEV4YWN0KHQsZSl9fXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHg7cmV0dXJuIHRoaXMucXVlcnkodCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTiYmXyhhcmd1bWVudHNbMV0sbSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucXVlcnlOb2RlKHRoaXMuX3Jvb3QsdCwhMCxuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuWyRuXX12aXNpdCh0KXtlLmFkZCh0KX19KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTiYmXyhhcmd1bWVudHNbMV0sJG4pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnF1ZXJ5Tm9kZSh0aGlzLl9yb290LHQsITAsZSl9fXF1ZXJ5Tm9kZSh0LGUsbixzKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtsZXQgaT1udWxsLHI9bnVsbCxvPW51bGw7bj8oaT1lLmdldE1pblgoKSxyPWUuZ2V0TWF4WCgpLG89dC5nZXRYKCkpOihpPWUuZ2V0TWluWSgpLHI9ZS5nZXRNYXhZKCksbz10LmdldFkoKSk7Y29uc3QgbD1vPD1yO2k8byYmdGhpcy5xdWVyeU5vZGUodC5nZXRMZWZ0KCksZSwhbixzKSxlLmNvbnRhaW5zKHQuZ2V0Q29vcmRpbmF0ZSgpKSYmcy52aXNpdCh0KSxsJiZ0aGlzLnF1ZXJ5Tm9kZSh0LmdldFJpZ2h0KCksZSwhbixzKX1maW5kQmVzdE1hdGNoTm9kZSh0KXtjb25zdCBlPW5ldyBucyh0LHRoaXMuX3RvbGVyYW5jZSk7cmV0dXJuIHRoaXMucXVlcnkoZS5xdWVyeUVudmVsb3BlKCksZSksZS5nZXROb2RlKCl9aXNFbXB0eSgpe3JldHVybiBudWxsPT09dGhpcy5fcm9vdH1pbnNlcnRFeGFjdCh0LGUpe2xldCBuPXRoaXMuX3Jvb3Qscz10aGlzLl9yb290LGk9ITAscj0hMDtmb3IoO251bGwhPT1uOyl7aWYobnVsbCE9PW4pe2lmKHQuZGlzdGFuY2Uobi5nZXRDb29yZGluYXRlKCkpPD10aGlzLl90b2xlcmFuY2UpcmV0dXJuIG4uaW5jcmVtZW50KCksbn1yPWk/dC54PG4uZ2V0WCgpOnQueTxuLmdldFkoKSxzPW4sbj1yP24uZ2V0TGVmdCgpOm4uZ2V0UmlnaHQoKSxpPSFpfXRoaXMuX251bWJlck9mTm9kZXM9dGhpcy5fbnVtYmVyT2ZOb2RlcysxO2NvbnN0IG89bmV3IHRzKHQsZSk7cmV0dXJuIHI/cy5zZXRMZWZ0KG8pOnMuc2V0UmlnaHQobyksb31nZXRDbGFzcygpe3JldHVybiBlc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgbnN7Y29uc3RydWN0b3IoKXtucy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0KHQpe2NvbnN0IGU9dGhpcy5fcC5kaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoKSk7aWYoIShlPD10aGlzLl90b2xlcmFuY2UpKXJldHVybiBudWxsO2xldCBuPSExOyhudWxsPT09dGhpcy5fbWF0Y2hOb2RlfHxlPHRoaXMuX21hdGNoRGlzdHx8bnVsbCE9PXRoaXMuX21hdGNoTm9kZSYmZT09PXRoaXMuX21hdGNoRGlzdCYmdC5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMuX21hdGNoTm9kZS5nZXRDb29yZGluYXRlKCkpPDEpJiYobj0hMCksbiYmKHRoaXMuX21hdGNoTm9kZT10LHRoaXMuX21hdGNoRGlzdD1lKX1xdWVyeUVudmVsb3BlKCl7Y29uc3QgdD1uZXcgTih0aGlzLl9wKTtyZXR1cm4gdC5leHBhbmRCeSh0aGlzLl90b2xlcmFuY2UpLHR9Z2V0Tm9kZSgpe3JldHVybiB0aGlzLl9tYXRjaE5vZGV9Z2V0Q2xhc3MoKXtyZXR1cm4gbnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuWyRuXX19bnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdG9sZXJhbmNlPW51bGwsdGhpcy5fbWF0Y2hOb2RlPW51bGwsdGhpcy5fbWF0Y2hEaXN0PTAsdGhpcy5fcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3A9dCx0aGlzLl90b2xlcmFuY2U9ZX0sZXMuQmVzdE1hdGNoVmlzaXRvcj1ucyxlcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9yb290PW51bGwsdGhpcy5fbnVtYmVyT2ZOb2Rlcz1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWVzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fdG9sZXJhbmNlPXR9fTt2YXIgc3M9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsS2RUcmVlOmVzfSk7Y2xhc3MgaXN7Y29uc3RydWN0b3IoKXtpcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRTdWJub2RlSW5kZXgodCxlLG4pe2xldCBzPS0xO3JldHVybiB0LmdldE1pblgoKT49ZSYmKHQuZ2V0TWluWSgpPj1uJiYocz0zKSx0LmdldE1heFkoKTw9biYmKHM9MSkpLHQuZ2V0TWF4WCgpPD1lJiYodC5nZXRNaW5ZKCk+PW4mJihzPTIpLHQuZ2V0TWF4WSgpPD1uJiYocz0wKSksc31oYXNDaGlsZHJlbigpe2ZvcihsZXQgdD0wO3Q8NDt0KyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbdF0pcmV0dXJuITA7cmV0dXJuITF9aXNQcnVuYWJsZSgpe3JldHVybiEodGhpcy5oYXNDaGlsZHJlbigpfHx0aGlzLmhhc0l0ZW1zKCkpfWFkZEFsbEl0ZW1zKHQpe3QuYWRkQWxsKHRoaXMuX2l0ZW1zKTtmb3IobGV0IGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLl9zdWJub2RlW2VdJiZ0aGlzLl9zdWJub2RlW2VdLmFkZEFsbEl0ZW1zKHQpO3JldHVybiB0fWdldE5vZGVDb3VudCgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmKHQrPXRoaXMuX3N1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCsxfXNpemUoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJih0Kz10aGlzLl9zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrdGhpcy5faXRlbXMuc2l6ZSgpfWFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDtlLmFkZEFsbCh0aGlzLl9pdGVtcyk7Zm9yKGxldCBuPTA7bjw0O24rKyludWxsIT09dGhpcy5fc3Vibm9kZVtuXSYmdGhpcy5fc3Vibm9kZVtuXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpfXZpc2l0SXRlbXModCxlKXtmb3IobGV0IHQ9dGhpcy5faXRlbXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspZS52aXNpdEl0ZW0odC5uZXh0KCkpfWhhc0l0ZW1zKCl7cmV0dXJuIXRoaXMuX2l0ZW1zLmlzRW1wdHkoKX1yZW1vdmUodCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiExO2xldCBuPSExO2ZvcihsZXQgcz0wO3M8NDtzKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbc10mJihuPXRoaXMuX3N1Ym5vZGVbc10ucmVtb3ZlKHQsZSksbikpe3RoaXMuX3N1Ym5vZGVbc10uaXNQcnVuYWJsZSgpJiYodGhpcy5fc3Vibm9kZVtzXT1udWxsKTticmVha31yZXR1cm4gbnx8KG49dGhpcy5faXRlbXMucmVtb3ZlKGUpLG4pfXZpc2l0KHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDt0aGlzLnZpc2l0SXRlbXModCxlKTtmb3IobGV0IG49MDtuPDQ7bisrKW51bGwhPT10aGlzLl9zdWJub2RlW25dJiZ0aGlzLl9zdWJub2RlW25dLnZpc2l0KHQsZSl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9ZGVwdGgoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0pe2NvbnN0IG49dGhpcy5fc3Vibm9kZVtlXS5kZXB0aCgpO24+dCYmKHQ9bil9cmV0dXJuIHQrMX1pc0VtcHR5KCl7bGV0IHQ9ITA7aWYodGhpcy5faXRlbXMuaXNFbXB0eSgpKXtmb3IobGV0IGU9MDtlPDQ7ZSsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdJiYhdGhpcy5fc3Vibm9kZVtlXS5pc0VtcHR5KCkpe3Q9ITE7YnJlYWt9fWVsc2UgdD0hMTtyZXR1cm4gdH1hZGQodCl7dGhpcy5faXRlbXMuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIGlzfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19ZnVuY3Rpb24gcnMoKXt9aXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXRlbXM9bmV3IHgsdGhpcy5fc3Vibm9kZT1uZXcgQXJyYXkoNCkuZmlsbChudWxsKX0scnMuZXhwb25lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7bGV0IG4scyxpLHI7Y29uc3Qgbz17MzI6e2Q6MTI3LGM6MTI4LGI6MCxhOjB9LDY0OntkOjMyNzUyLGM6MCxiOjAsYTowfX0sbD17MzI6OCw2NDoxMX1bdF07cnx8KG49ZTwwfHwxL2U8MCxpc0Zpbml0ZShlKXx8KHI9b1t0XSxuJiYoci5kKz0xPDx0LzQtMSkscz1NYXRoLnBvdygyLGwpLTEsaT0wKSk7aWYoIXIpe2ZvcihzPXszMjoxMjcsNjQ6MTAyM31bdF0saT1NYXRoLmFicyhlKTtpPj0yOylzKyssaS89Mjtmb3IoO2k8MSYmcz4wOylzLS0saSo9MjtzPD0wJiYoaS89MiksMzI9PT10JiZzPjI1NCYmKHI9e2Q6bj8yNTU6MTI3LGM6MTI4LGI6MCxhOjB9LHM9TWF0aC5wb3coMixsKS0xLGk9MCl9cmV0dXJuIHN9KDY0LHQpLTEwMjN9LHJzLnBvd2VyT2YyPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLHQpfTtjbGFzcyBvc3tjb25zdHJ1Y3Rvcigpe29zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXB1dGVRdWFkTGV2ZWwodCl7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpLHM9ZT5uP2U6bjtyZXR1cm4gcnMuZXhwb25lbnQocykrMX1nZXRMZXZlbCgpe3JldHVybiB0aGlzLl9sZXZlbH1jb21wdXRlS2V5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2Zvcih0aGlzLl9sZXZlbD1vcy5jb21wdXRlUXVhZExldmVsKHQpLHRoaXMuX2Vudj1uZXcgTix0aGlzLmNvbXB1dGVLZXkodGhpcy5fbGV2ZWwsdCk7IXRoaXMuX2Vudi5jb250YWlucyh0KTspdGhpcy5fbGV2ZWwrPTEsdGhpcy5jb21wdXRlS2V5KHRoaXMuX2xldmVsLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49cnMucG93ZXJPZjIodCk7dGhpcy5fcHQueD1NYXRoLmZsb29yKGUuZ2V0TWluWCgpL24pKm4sdGhpcy5fcHQueT1NYXRoLmZsb29yKGUuZ2V0TWluWSgpL24pKm4sdGhpcy5fZW52LmluaXQodGhpcy5fcHQueCx0aGlzLl9wdC54K24sdGhpcy5fcHQueSx0aGlzLl9wdC55K24pfX1nZXRFbnZlbG9wZSgpe3JldHVybiB0aGlzLl9lbnZ9Z2V0Q2VudHJlKCl7cmV0dXJuIG5ldyBnKCh0aGlzLl9lbnYuZ2V0TWluWCgpK3RoaXMuX2Vudi5nZXRNYXhYKCkpLzIsKHRoaXMuX2Vudi5nZXRNaW5ZKCkrdGhpcy5fZW52LmdldE1heFkoKSkvMil9Z2V0UG9pbnQoKXtyZXR1cm4gdGhpcy5fcHR9Z2V0Q2xhc3MoKXtyZXR1cm4gb3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW9zLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0PW5ldyBnLHRoaXMuX2xldmVsPTAsdGhpcy5fZW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wdXRlS2V5KHQpfTtjbGFzcyBscyBleHRlbmRzIGlze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxscy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjcmVhdGVOb2RlKHQpe2NvbnN0IGU9bmV3IG9zKHQpO3JldHVybiBuZXcgbHMoZS5nZXRFbnZlbG9wZSgpLGUuZ2V0TGV2ZWwoKSl9c3RhdGljIGNyZWF0ZUV4cGFuZGVkKHQsZSl7Y29uc3Qgbj1uZXcgTihlKTtudWxsIT09dCYmbi5leHBhbmRUb0luY2x1ZGUodC5fZW52KTtjb25zdCBzPWxzLmNyZWF0ZU5vZGUobik7cmV0dXJuIG51bGwhPT10JiZzLmluc2VydE5vZGUodCksc31maW5kKHQpe2NvbnN0IGU9aXMuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5fY2VudHJleCx0aGlzLl9jZW50cmV5KTtpZigtMT09PWUpcmV0dXJuIHRoaXM7aWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0pe3JldHVybiB0aGlzLl9zdWJub2RlW2VdLmZpbmQodCl9cmV0dXJuIHRoaXN9aXNTZWFyY2hNYXRjaCh0KXtyZXR1cm4gbnVsbCE9PXQmJnRoaXMuX2Vudi5pbnRlcnNlY3RzKHQpfWdldFN1Ym5vZGUodCl7cmV0dXJuIG51bGw9PT10aGlzLl9zdWJub2RlW3RdJiYodGhpcy5fc3Vibm9kZVt0XT10aGlzLmNyZWF0ZVN1Ym5vZGUodCkpLHRoaXMuX3N1Ym5vZGVbdF19Z2V0RW52ZWxvcGUoKXtyZXR1cm4gdGhpcy5fZW52fWdldE5vZGUodCl7Y29uc3QgZT1pcy5nZXRTdWJub2RlSW5kZXgodCx0aGlzLl9jZW50cmV4LHRoaXMuX2NlbnRyZXkpO2lmKC0xIT09ZSl7cmV0dXJuIHRoaXMuZ2V0U3Vibm9kZShlKS5nZXROb2RlKHQpfXJldHVybiB0aGlzfWNyZWF0ZVN1Ym5vZGUodCl7bGV0IGU9MCxuPTAscz0wLGk9MDtzd2l0Y2godCl7Y2FzZSAwOmU9dGhpcy5fZW52LmdldE1pblgoKSxuPXRoaXMuX2NlbnRyZXgscz10aGlzLl9lbnYuZ2V0TWluWSgpLGk9dGhpcy5fY2VudHJleTticmVhaztjYXNlIDE6ZT10aGlzLl9jZW50cmV4LG49dGhpcy5fZW52LmdldE1heFgoKSxzPXRoaXMuX2Vudi5nZXRNaW5ZKCksaT10aGlzLl9jZW50cmV5O2JyZWFrO2Nhc2UgMjplPXRoaXMuX2Vudi5nZXRNaW5YKCksbj10aGlzLl9jZW50cmV4LHM9dGhpcy5fY2VudHJleSxpPXRoaXMuX2Vudi5nZXRNYXhZKCk7YnJlYWs7Y2FzZSAzOmU9dGhpcy5fY2VudHJleCxuPXRoaXMuX2Vudi5nZXRNYXhYKCkscz10aGlzLl9jZW50cmV5LGk9dGhpcy5fZW52LmdldE1heFkoKX1jb25zdCByPW5ldyBOKGUsbixzLGkpO3JldHVybiBuZXcgbHMocix0aGlzLl9sZXZlbC0xKX1pbnNlcnROb2RlKHQpe3UuaXNUcnVlKG51bGw9PT10aGlzLl9lbnZ8fHRoaXMuX2Vudi5jb250YWlucyh0Ll9lbnYpKTtjb25zdCBlPWlzLmdldFN1Ym5vZGVJbmRleCh0Ll9lbnYsdGhpcy5fY2VudHJleCx0aGlzLl9jZW50cmV5KTtpZih0Ll9sZXZlbD09PXRoaXMuX2xldmVsLTEpdGhpcy5fc3Vibm9kZVtlXT10O2Vsc2V7Y29uc3Qgbj10aGlzLmNyZWF0ZVN1Ym5vZGUoZSk7bi5pbnNlcnROb2RlKHQpLHRoaXMuX3N1Ym5vZGVbZV09bn19Z2V0Q2xhc3MoKXtyZXR1cm4gbHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWxzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Vudj1udWxsLHRoaXMuX2NlbnRyZXg9bnVsbCx0aGlzLl9jZW50cmV5PW51bGwsdGhpcy5fbGV2ZWw9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9lbnY9dCx0aGlzLl9sZXZlbD1lLHRoaXMuX2NlbnRyZXg9KHQuZ2V0TWluWCgpK3QuZ2V0TWF4WCgpKS8yLHRoaXMuX2NlbnRyZXk9KHQuZ2V0TWluWSgpK3QuZ2V0TWF4WSgpKS8yfTtjbGFzcyBhc3tjb25zdHJ1Y3Rvcigpe2FzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzWmVyb1dpZHRoKHQsZSl7Y29uc3Qgbj1lLXQ7aWYoMD09PW4pcmV0dXJuITA7Y29uc3Qgcz1uL01hdGgubWF4KE1hdGguYWJzKHQpLE1hdGguYWJzKGUpKTtyZXR1cm4gcnMuZXhwb25lbnQocyk8PWFzLk1JTl9CSU5BUllfRVhQT05FTlR9Z2V0Q2xhc3MoKXtyZXR1cm4gYXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWFzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sYXMuTUlOX0JJTkFSWV9FWFBPTkVOVD0tNTA7Y2xhc3MgY3MgZXh0ZW5kcyBpc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksY3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnQodCxlKXtjb25zdCBuPWlzLmdldFN1Ym5vZGVJbmRleCh0LGNzLm9yaWdpbi54LGNzLm9yaWdpbi55KTtpZigtMT09PW4pcmV0dXJuIHRoaXMuYWRkKGUpLG51bGw7Y29uc3Qgcz10aGlzLl9zdWJub2RlW25dO2lmKG51bGw9PT1zfHwhcy5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKHQpKXtjb25zdCBlPWxzLmNyZWF0ZUV4cGFuZGVkKHMsdCk7dGhpcy5fc3Vibm9kZVtuXT1lfXRoaXMuaW5zZXJ0Q29udGFpbmVkKHRoaXMuX3N1Ym5vZGVbbl0sdCxlKX1pc1NlYXJjaE1hdGNoKHQpe3JldHVybiEwfWluc2VydENvbnRhaW5lZCh0LGUsbil7dS5pc1RydWUodC5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKGUpKTtjb25zdCBzPWFzLmlzWmVyb1dpZHRoKGUuZ2V0TWluWCgpLGUuZ2V0TWF4WCgpKSxpPWFzLmlzWmVyb1dpZHRoKGUuZ2V0TWluWSgpLGUuZ2V0TWF4WSgpKTtsZXQgcj1udWxsO3I9c3x8aT90LmZpbmQoZSk6dC5nZXROb2RlKGUpLHIuYWRkKG4pfWdldENsYXNzKCl7cmV0dXJuIGNzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LGNzLm9yaWdpbj1uZXcgZygwLDApO2NsYXNzIGhze2NvbnN0cnVjdG9yKCl7aHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnQodCxlKXt9cmVtb3ZlKHQsZSl7fXF1ZXJ5KCl7fWdldENsYXNzKCl7cmV0dXJuIGhzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1ocy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHVze2NvbnN0cnVjdG9yKCl7dXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZW5zdXJlRXh0ZW50KHQsZSl7bGV0IG49dC5nZXRNaW5YKCkscz10LmdldE1heFgoKSxpPXQuZ2V0TWluWSgpLHI9dC5nZXRNYXhZKCk7cmV0dXJuIG4hPT1zJiZpIT09cj90OihuPT09cyYmKG4tPWUvMixzPW4rZS8yKSxpPT09ciYmKGktPWUvMixyPWkrZS8yKSxuZXcgTihuLHMsaSxyKSl9c2l6ZSgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdD90aGlzLl9yb290LnNpemUoKTowfWluc2VydCh0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO2NvbnN0IG49dXMuZW5zdXJlRXh0ZW50KHQsdGhpcy5fbWluRXh0ZW50KTt0aGlzLl9yb290Lmluc2VydChuLGUpfXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IFllO3JldHVybiB0aGlzLnF1ZXJ5KHQsZSksZS5nZXRJdGVtcygpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9yb290LnZpc2l0KHQsZSl9fXF1ZXJ5QWxsKCl7Y29uc3QgdD1uZXcgeDtyZXR1cm4gdGhpcy5fcm9vdC5hZGRBbGxJdGVtcyh0KSx0fXJlbW92ZSh0LGUpe2NvbnN0IG49dXMuZW5zdXJlRXh0ZW50KHQsdGhpcy5fbWluRXh0ZW50KTtyZXR1cm4gdGhpcy5fcm9vdC5yZW1vdmUobixlKX1jb2xsZWN0U3RhdHModCl7Y29uc3QgZT10LmdldFdpZHRoKCk7ZTx0aGlzLl9taW5FeHRlbnQmJmU+MCYmKHRoaXMuX21pbkV4dGVudD1lKTtjb25zdCBuPXQuZ2V0SGVpZ2h0KCk7bjx0aGlzLl9taW5FeHRlbnQmJm4+MCYmKHRoaXMuX21pbkV4dGVudD1uKX1kZXB0aCgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdD90aGlzLl9yb290LmRlcHRoKCk6MH1pc0VtcHR5KCl7cmV0dXJuIG51bGw9PT10aGlzLl9yb290fHx0aGlzLl9yb290LmlzRW1wdHkoKX1nZXRDbGFzcygpe3JldHVybiB1c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5baHMsYV19fXVzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9taW5FeHRlbnQ9MSx0aGlzLl9yb290PW5ldyBjc30sdXMuc2VyaWFsVmVyc2lvblVJRD0tMHg2NzhiNjBjOTY3YTI1NDAwO3ZhciBncz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxRdWFkdHJlZTp1c30pO2NsYXNzIGRze2NvbnN0cnVjdG9yKCl7ZHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZHMoKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gZHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWRzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgX3N7Y29uc3RydWN0b3IoKXtfcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEl0ZW0oKXtyZXR1cm4gdGhpcy5faXRlbX1nZXRCb3VuZHMoKXtyZXR1cm4gdGhpcy5fYm91bmRzfWdldENsYXNzKCl7cmV0dXJuIF9zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltkcyxhXX19X3MuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fYm91bmRzPW51bGwsdGhpcy5faXRlbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2JvdW5kcz10LHRoaXMuX2l0ZW09ZX07Y2xhc3MgZnN7Y29uc3RydWN0b3IoKXtmcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXBvbGwoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMuX2l0ZW1zLmdldCgxKTtyZXR1cm4gdGhpcy5faXRlbXMuc2V0KDEsdGhpcy5faXRlbXMuZ2V0KHRoaXMuX3NpemUpKSx0aGlzLl9zaXplLT0xLHRoaXMucmVvcmRlcigxKSx0fXNpemUoKXtyZXR1cm4gdGhpcy5fc2l6ZX1yZW9yZGVyKHQpe2xldCBlPW51bGw7Y29uc3Qgbj10aGlzLl9pdGVtcy5nZXQodCk7Zm9yKDsyKnQ8PXRoaXMuX3NpemUmJihlPTIqdCxlIT09dGhpcy5fc2l6ZSYmdGhpcy5faXRlbXMuZ2V0KGUrMSkuY29tcGFyZVRvKHRoaXMuX2l0ZW1zLmdldChlKSk8MCYmZSsrLHRoaXMuX2l0ZW1zLmdldChlKS5jb21wYXJlVG8obik8MCk7dD1lKXRoaXMuX2l0ZW1zLnNldCh0LHRoaXMuX2l0ZW1zLmdldChlKSk7dGhpcy5faXRlbXMuc2V0KHQsbil9Y2xlYXIoKXt0aGlzLl9zaXplPTAsdGhpcy5faXRlbXMuY2xlYXIoKX1wZWVrKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7cmV0dXJuIHRoaXMuX2l0ZW1zLmdldCgxKX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9zaXplfWFkZCh0KXt0aGlzLl9pdGVtcy5hZGQobnVsbCksdGhpcy5fc2l6ZSs9MTtsZXQgZT10aGlzLl9zaXplO2Zvcih0aGlzLl9pdGVtcy5zZXQoMCx0KTt0LmNvbXBhcmVUbyh0aGlzLl9pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk8MDtlLz0yKXRoaXMuX2l0ZW1zLnNldChlLHRoaXMuX2l0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTt0aGlzLl9pdGVtcy5zZXQoZSx0KX1nZXRDbGFzcygpe3JldHVybiBmc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2l6ZT1udWxsLHRoaXMuX2l0ZW1zPW51bGwsdGhpcy5fc2l6ZT0wLHRoaXMuX2l0ZW1zPW5ldyB4LHRoaXMuX2l0ZW1zLmFkZChudWxsKX07Y2xhc3MgcHN7Y29uc3RydWN0b3IoKXtwcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldExldmVsKCl7cmV0dXJuIHRoaXMuX2xldmVsfXNpemUoKXtyZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzLnNpemUoKX1nZXRDaGlsZEJvdW5kYWJsZXMoKXtyZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzfWFkZENoaWxkQm91bmRhYmxlKHQpe3UuaXNUcnVlKG51bGw9PT10aGlzLl9ib3VuZHMpLHRoaXMuX2NoaWxkQm91bmRhYmxlcy5hZGQodCl9aXNFbXB0eSgpe3JldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuaXNFbXB0eSgpfWdldEJvdW5kcygpe3JldHVybiBudWxsPT09dGhpcy5fYm91bmRzJiYodGhpcy5fYm91bmRzPXRoaXMuY29tcHV0ZUJvdW5kcygpKSx0aGlzLl9ib3VuZHN9Z2V0Q2xhc3MoKXtyZXR1cm4gcHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2RzLGFdfX1wcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9jaGlsZEJvdW5kYWJsZXM9bmV3IHgsdGhpcy5fYm91bmRzPW51bGwsdGhpcy5fbGV2ZWw9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGV2ZWw9dH19LHBzLnNlcmlhbFZlcnNpb25VSUQ9MHg1YTFlNTVlYzQxMzY5ODAwO2NsYXNzIG1ze2NvbnN0cnVjdG9yKCl7bXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgYXJlYSh0KXtyZXR1cm4gdC5nZXRCb3VuZHMoKS5nZXRBcmVhKCl9c3RhdGljIGlzQ29tcG9zaXRlKHQpe3JldHVybiB0IGluc3RhbmNlb2YgcHN9ZXhwYW5kVG9RdWV1ZSh0LGUpe2NvbnN0IHM9bXMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSksaT1tcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKTtpZihzJiZpKXJldHVybiBtcy5hcmVhKHRoaXMuX2JvdW5kYWJsZTEpPm1zLmFyZWEodGhpcy5fYm91bmRhYmxlMik/KHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMix0LGUpLG51bGwpOih0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUyLHRoaXMuX2JvdW5kYWJsZTEsdCxlKSxudWxsKTtpZihzKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUxLHRoaXMuX2JvdW5kYWJsZTIsdCxlKSxudWxsO2lmKGkpcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsdGhpcy5fYm91bmRhYmxlMSx0LGUpLG51bGw7dGhyb3cgbmV3IG4oXCJuZWl0aGVyIGJvdW5kYWJsZSBpcyBjb21wb3NpdGVcIil9aXNMZWF2ZXMoKXtyZXR1cm4hKG1zLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTEpfHxtcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fZGlzdGFuY2U8ZS5fZGlzdGFuY2U/LTE6dGhpcy5fZGlzdGFuY2U+ZS5fZGlzdGFuY2U/MTowfWV4cGFuZCh0LGUsbixzKXtmb3IobGV0IGk9dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKSxyPW5ldyBtcyh0LGUsdGhpcy5faXRlbURpc3RhbmNlKTtyLmdldERpc3RhbmNlKCk8cyYmbi5hZGQocil9fWdldEJvdW5kYWJsZSh0KXtyZXR1cm4gMD09PXQ/dGhpcy5fYm91bmRhYmxlMTp0aGlzLl9ib3VuZGFibGUyfWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfWRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuaXNMZWF2ZXMoKT90aGlzLl9pdGVtRGlzdGFuY2UuZGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMSx0aGlzLl9ib3VuZGFibGUyKTp0aGlzLl9ib3VuZGFibGUxLmdldEJvdW5kcygpLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTIuZ2V0Qm91bmRzKCkpfWdldENsYXNzKCl7cmV0dXJuIG1zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19bXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fYm91bmRhYmxlMT1udWxsLHRoaXMuX2JvdW5kYWJsZTI9bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuX2l0ZW1EaXN0YW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2JvdW5kYWJsZTE9dCx0aGlzLl9ib3VuZGFibGUyPWUsdGhpcy5faXRlbURpc3RhbmNlPW4sdGhpcy5fZGlzdGFuY2U9dGhpcy5kaXN0YW5jZSgpfTtjbGFzcyB5c3tjb25zdHJ1Y3Rvcigpe3lzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXBhcmVEb3VibGVzKHQsZSl7cmV0dXJuIHQ+ZT8xOnQ8ZT8tMTowfXF1ZXJ5SW50ZXJuYWwoKXtpZihfKGFyZ3VtZW50c1syXSxBZSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHBzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCk7Zm9yKGxldCBlPTA7ZTxzLnNpemUoKTtlKyspe2NvbnN0IGk9cy5nZXQoZSk7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGkuZ2V0Qm91bmRzKCksdCkmJihpIGluc3RhbmNlb2YgcHM/dGhpcy5xdWVyeUludGVybmFsKHQsaSxuKTppIGluc3RhbmNlb2YgX3M/bi52aXNpdEl0ZW0oaS5nZXRJdGVtKCkpOnUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fWVsc2UgaWYoXyhhcmd1bWVudHNbMl0sbSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHBzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCk7Zm9yKGxldCBlPTA7ZTxzLnNpemUoKTtlKyspe2NvbnN0IGk9cy5nZXQoZSk7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGkuZ2V0Qm91bmRzKCksdCkmJihpIGluc3RhbmNlb2YgcHM/dGhpcy5xdWVyeUludGVybmFsKHQsaSxuKTppIGluc3RhbmNlb2YgX3M/bi5hZGQoaS5nZXRJdGVtKCkpOnUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fX1nZXROb2RlQ2FwYWNpdHkoKXtyZXR1cm4gdGhpcy5fbm9kZUNhcGFjaXR5fWxhc3ROb2RlKHQpe3JldHVybiB0LmdldCh0LnNpemUoKS0xKX1zaXplKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLnNpemUodGhpcy5fcm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD0wO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7biBpbnN0YW5jZW9mIHBzP3QrPXRoaXMuc2l6ZShuKTpuIGluc3RhbmNlb2YgX3MmJih0Kz0xKX1yZXR1cm4gdH19cmVtb3ZlSXRlbSh0LGUpe2xldCBuPW51bGw7Zm9yKGxldCBzPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dCBpbnN0YW5jZW9mIF9zJiZ0LmdldEl0ZW0oKT09PWUmJihuPXQpfXJldHVybiBudWxsIT09biYmKHQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKG4pLCEwKX1pdGVtc1RyZWUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5idWlsZCgpO2NvbnN0IHQ9dGhpcy5pdGVtc1RyZWUodGhpcy5fcm9vdCk7cmV0dXJuIG51bGw9PT10P25ldyB4OnR9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHg7Zm9yKGxldCBuPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodCBpbnN0YW5jZW9mIHBzKXtjb25zdCBuPXRoaXMuaXRlbXNUcmVlKHQpO251bGwhPT1uJiZlLmFkZChuKX1lbHNlIHQgaW5zdGFuY2VvZiBfcz9lLmFkZCh0LmdldEl0ZW0oKSk6dS5zaG91bGROZXZlclJlYWNoSGVyZSgpfXJldHVybiBlLnNpemUoKTw9MD9udWxsOmV9fWluc2VydCh0LGUpe3UuaXNUcnVlKCF0aGlzLl9idWlsdCxcIkNhbm5vdCBpbnNlcnQgaXRlbXMgaW50byBhbiBTVFIgcGFja2VkIFItdHJlZSBhZnRlciBpdCBoYXMgYmVlbiBidWlsdC5cIiksdGhpcy5faXRlbUJvdW5kYWJsZXMuYWRkKG5ldyBfcyh0LGUpKX1ib3VuZGFibGVzQXRMZXZlbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4O3JldHVybiB0aGlzLmJvdW5kYWJsZXNBdExldmVsKHQsdGhpcy5fcm9vdCxlKSxlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih1LmlzVHJ1ZSh0Pi0yKSxlLmdldExldmVsKCk9PT10KXJldHVybiBuLmFkZChlKSxudWxsO2ZvcihsZXQgcz1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBlPXMubmV4dCgpO2UgaW5zdGFuY2VvZiBwcz90aGlzLmJvdW5kYWJsZXNBdExldmVsKHQsZSxuKToodS5pc1RydWUoZSBpbnN0YW5jZW9mIF9zKSwtMT09PXQmJm4uYWRkKGUpKX1yZXR1cm4gbnVsbH19cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5idWlsZCgpO2NvbnN0IGU9bmV3IHg7cmV0dXJuIHRoaXMuaXNFbXB0eSgpfHx0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5xdWVyeUludGVybmFsKHQsdGhpcy5fcm9vdCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLmJ1aWxkKCksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucXVlcnlJbnRlcm5hbCh0LHRoaXMuX3Jvb3QsZSl9fWJ1aWxkKCl7aWYodGhpcy5fYnVpbHQpcmV0dXJuIG51bGw7dGhpcy5fcm9vdD10aGlzLl9pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCk/dGhpcy5jcmVhdGVOb2RlKDApOnRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKHRoaXMuX2l0ZW1Cb3VuZGFibGVzLC0xKSx0aGlzLl9pdGVtQm91bmRhYmxlcz1udWxsLHRoaXMuX2J1aWx0PSEwfWdldFJvb3QoKXtyZXR1cm4gdGhpcy5idWlsZCgpLHRoaXMuX3Jvb3R9cmVtb3ZlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmJ1aWxkKCksISF0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5yZW1vdmUodCx0aGlzLl9yb290LGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtsZXQgcz10aGlzLnJlbW92ZUl0ZW0oZSxuKTtpZihzKXJldHVybiEwO2xldCBpPW51bGw7Zm9yKGxldCByPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe2NvbnN0IGU9ci5uZXh0KCk7aWYodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGUuZ2V0Qm91bmRzKCksdCkmJihlIGluc3RhbmNlb2YgcHMmJihzPXRoaXMucmVtb3ZlKHQsZSxuKSxzKSkpe2k9ZTticmVha319cmV0dXJuIG51bGwhPT1pJiZpLmdldENoaWxkQm91bmRhYmxlcygpLmlzRW1wdHkoKSYmZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUoaSksc319Y3JlYXRlSGlnaGVyTGV2ZWxzKHQsZSl7dS5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPXRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUrMSk7cmV0dXJuIDE9PT1uLnNpemUoKT9uLmdldCgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyhuLGUrMSl9ZGVwdGgoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoodGhpcy5idWlsZCgpLHRoaXMuZGVwdGgodGhpcy5fcm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD0wO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYobiBpbnN0YW5jZW9mIHBzKXtjb25zdCBlPXRoaXMuZGVwdGgobik7ZT50JiYodD1lKX19cmV0dXJuIHQrMX19Y3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUpe3UuaXNUcnVlKCF0LmlzRW1wdHkoKSk7Y29uc3Qgbj1uZXcgeDtuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpO2NvbnN0IHM9bmV3IHgodCk7RWUuc29ydChzLHRoaXMuZ2V0Q29tcGFyYXRvcigpKTtmb3IobGV0IHQ9cy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgcz10Lm5leHQoKTt0aGlzLmxhc3ROb2RlKG4pLmdldENoaWxkQm91bmRhYmxlcygpLnNpemUoKT09PXRoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkmJm4uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSksdGhpcy5sYXN0Tm9kZShuKS5hZGRDaGlsZEJvdW5kYWJsZShzKX1yZXR1cm4gbn1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX2J1aWx0P3RoaXMuX3Jvb3QuaXNFbXB0eSgpOnRoaXMuX2l0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKX1nZXRDbGFzcygpe3JldHVybiB5c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fXlzLkludGVyc2VjdHNPcD1mdW5jdGlvbigpe30seXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcm9vdD1udWxsLHRoaXMuX2J1aWx0PSExLHRoaXMuX2l0ZW1Cb3VuZGFibGVzPW5ldyB4LHRoaXMuX25vZGVDYXBhY2l0eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXlzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMseXMuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt1LmlzVHJ1ZSh0PjEsXCJOb2RlIGNhcGFjaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksdGhpcy5fbm9kZUNhcGFjaXR5PXR9fSx5cy5zZXJpYWxWZXJzaW9uVUlEPS0weDM1ZWY2NGM4MmQ0YzU0MDAseXMuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwO2NsYXNzIHhze2NvbnN0cnVjdG9yKCl7eHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1kaXN0YW5jZSh0LGUpe31nZXRDbGFzcygpe3JldHVybiB4c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBFcyBleHRlbmRzIHlze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxFcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjZW50cmVYKHQpe3JldHVybiBFcy5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpfXN0YXRpYyBhdmcodCxlKXtyZXR1cm4odCtlKS8yfXN0YXRpYyBnZXRJdGVtcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtsZXQgbj0wO2Zvcig7IXQuaXNFbXB0eSgpOyl7Y29uc3Qgcz10LnBvbGwoKTtlW25dPXMuZ2V0Qm91bmRhYmxlKDApLmdldEl0ZW0oKSxuKyt9cmV0dXJuIGV9c3RhdGljIGNlbnRyZVkodCl7cmV0dXJuIEVzLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSl9Y3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyh0LGUpe3UuaXNUcnVlKHQubGVuZ3RoPjApO2NvbnN0IG49bmV3IHg7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspbi5hZGRBbGwodGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodFtzXSxlKSk7cmV0dXJuIG59Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IElzKHQpfXNpemUoKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/c3VwZXIuc2l6ZS5jYWxsKHRoaXMpOnN1cGVyLnNpemUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydCgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pKXJldHVybiBzdXBlci5pbnNlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0LmlzTnVsbCgpKXJldHVybiBudWxsO3N1cGVyLmluc2VydC5jYWxsKHRoaXMsdCxlKX19Z2V0SW50ZXJzZWN0c09wKCl7cmV0dXJuIEVzLmludGVyc2VjdHNPcH12ZXJ0aWNhbFNsaWNlcyh0LGUpe2NvbnN0IG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvZSkpLHM9bmV3IEFycmF5KGUpLmZpbGwobnVsbCksaT10Lml0ZXJhdG9yKCk7Zm9yKGxldCB0PTA7dDxlO3QrKyl7c1t0XT1uZXcgeDtsZXQgZT0wO2Zvcig7aS5oYXNOZXh0KCkmJmU8bjspe2NvbnN0IG49aS5uZXh0KCk7c1t0XS5hZGQobiksZSsrfX1yZXR1cm4gc31xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc3VwZXIucXVlcnkuY2FsbCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtzdXBlci5xdWVyeS5jYWxsKHRoaXMsdCxlKX19Z2V0Q29tcGFyYXRvcigpe3JldHVybiBFcy55Q29tcGFyYXRvcn1jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodCxlKXtyZXR1cm4gc3VwZXIuY3JlYXRlUGFyZW50Qm91bmRhYmxlcy5jYWxsKHRoaXMsdCxlKX1yZW1vdmUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHN1cGVyLnJlbW92ZS5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIucmVtb3ZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1kZXB0aCgpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9zdXBlci5kZXB0aC5jYWxsKHRoaXMpOnN1cGVyLmRlcHRoLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSl7dS5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL3RoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkpKSxzPW5ldyB4KHQpO0VlLnNvcnQocyxFcy54Q29tcGFyYXRvcik7Y29uc3QgaT10aGlzLnZlcnRpY2FsU2xpY2VzKHMsTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5zcXJ0KG4pKSkpO3JldHVybiB0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMoaSxlKX1uZWFyZXN0TmVpZ2hib3VyKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLHhzKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgbXModGhpcy5nZXRSb290KCksdGhpcy5nZXRSb290KCksdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1zKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKHQsaS5QT1NJVElWRV9JTkZJTklUWSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRXMmJl8oYXJndW1lbnRzWzFdLHhzKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgbXModGhpcy5nZXRSb290KCksdC5nZXRSb290KCksZSk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihuKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1zJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1hcmd1bWVudHNbMV0sbj1udWxsO2NvbnN0IHM9bmV3IGZzO2ZvcihzLmFkZCh0KTshcy5pc0VtcHR5KCkmJmU+MDspe2NvbnN0IHQ9cy5wb2xsKCksaT10LmdldERpc3RhbmNlKCk7aWYoaT49ZSlicmVhazt0LmlzTGVhdmVzKCk/KGU9aSxuPXQpOnQuZXhwYW5kVG9RdWV1ZShzLGUpfXJldHVybltuLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksbi5nZXRCb3VuZGFibGUoMSkuZ2V0SXRlbSgpXX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1zJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIodCxpLlBPU0lUSVZFX0lORklOSVRZLGUpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1syXSx4cykmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBPYmplY3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IF9zKHQsZSksaT1uZXcgbXModGhpcy5nZXRSb290KCkscyxuKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGkpWzBdfWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcyYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bGV0IHM9ZTtjb25zdCBpPW5ldyBmcztpLmFkZCh0KTtjb25zdCByPW5ldyBmcztmb3IoOyFpLmlzRW1wdHkoKSYmcz49MDspe2NvbnN0IHQ9aS5wb2xsKCksZT10LmdldERpc3RhbmNlKCk7aWYoZT49cylicmVhaztpZih0LmlzTGVhdmVzKCkpaWYoci5zaXplKCk8bilyLmFkZCh0KTtlbHNle3IucGVlaygpLmdldERpc3RhbmNlKCk+ZSYmKHIucG9sbCgpLHIuYWRkKHQpKSxzPXIucGVlaygpLmdldERpc3RhbmNlKCl9ZWxzZSB0LmV4cGFuZFRvUXVldWUoaSxzKX1yZXR1cm4gRXMuZ2V0SXRlbXMocil9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IF9zKHQsZSkscj1uZXcgbXModGhpcy5nZXRSb290KCksaSxuKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKHIscyl9fWdldENsYXNzKCl7cmV0dXJuIEVzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltocyxhXX19Y2xhc3MgSXMgZXh0ZW5kcyBwc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksSXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlQm91bmRzKCl7bGV0IHQ9bnVsbDtmb3IobGV0IGU9dGhpcy5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtudWxsPT09dD90PW5ldyBOKG4uZ2V0Qm91bmRzKCkpOnQuZXhwYW5kVG9JbmNsdWRlKG4uZ2V0Qm91bmRzKCkpfXJldHVybiB0fWdldENsYXNzKCl7cmV0dXJuIElzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Jcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXTtwcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfSxFcy5TVFJ0cmVlTm9kZT1JcyxFcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClFcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLEVzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07eXMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19LEVzLnNlcmlhbFZlcnNpb25VSUQ9MHgzOTkyMGY3ZDVmMjYxZTAsRXMueENvbXBhcmF0b3I9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX1jb21wYXJlKHQsZSl7cmV0dXJuIHlzLmNvbXBhcmVEb3VibGVzKEVzLmNlbnRyZVgodC5nZXRCb3VuZHMoKSksRXMuY2VudHJlWChlLmdldEJvdW5kcygpKSl9fSxFcy55Q29tcGFyYXRvcj1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfWNvbXBhcmUodCxlKXtyZXR1cm4geXMuY29tcGFyZURvdWJsZXMoRXMuY2VudHJlWSh0LmdldEJvdW5kcygpKSxFcy5jZW50cmVZKGUuZ2V0Qm91bmRzKCkpKX19LEVzLmludGVyc2VjdHNPcD1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ludGVyc2VjdHNPcF19aW50ZXJzZWN0cyh0LGUpe3JldHVybiB0LmludGVyc2VjdHMoZSl9fSxFcy5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTA7dmFyIE5zPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFNUUnRyZWU6RXN9KSxDcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxrZHRyZWU6c3MscXVhZHRyZWU6Z3Msc3RydHJlZTpOc30pO2NvbnN0IFNzPVtcIlBvaW50XCIsXCJNdWx0aVBvaW50XCIsXCJMaW5lU3RyaW5nXCIsXCJNdWx0aUxpbmVTdHJpbmdcIixcIlBvbHlnb25cIixcIk11bHRpUG9seWdvblwiXTtjbGFzcyB3c3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgSHR9cmVhZCh0KXtsZXQgZTtlPVwic3RyaW5nXCI9PXR5cGVvZiB0P0pTT04ucGFyc2UodCk6dDtjb25zdCBuPWUudHlwZTtpZighTHNbbl0pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9KU09OIHR5cGU6IFwiK2UudHlwZSk7cmV0dXJuLTEhPT1Tcy5pbmRleE9mKG4pP0xzW25dLmNhbGwodGhpcyxlLmNvb3JkaW5hdGVzKTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09bj9Mc1tuXS5jYWxsKHRoaXMsZS5nZW9tZXRyaWVzKTpMc1tuXS5jYWxsKHRoaXMsZSl9d3JpdGUodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5VHlwZSgpO2lmKCFUc1tlXSl0aHJvdyBuZXcgRXJyb3IoXCJHZW9tZXRyeSBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBUc1tlXS5jYWxsKHRoaXMsdCl9fWNvbnN0IExzPXtGZWF0dXJlOmZ1bmN0aW9uKHQpe2NvbnN0IGU9e307Zm9yKGNvbnN0IG4gaW4gdCllW25dPXRbbl07aWYodC5nZW9tZXRyeSl7Y29uc3Qgbj10Lmdlb21ldHJ5LnR5cGU7aWYoIUxzW25dKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvSlNPTiB0eXBlOiBcIit0LnR5cGUpO2UuZ2VvbWV0cnk9dGhpcy5yZWFkKHQuZ2VvbWV0cnkpfXJldHVybiB0LmJib3gmJihlLmJib3g9THMuYmJveC5jYWxsKHRoaXMsdC5iYm94KSksZX0sRmVhdHVyZUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT17fTtpZih0LmZlYXR1cmVzKXtlLmZlYXR1cmVzPVtdO2ZvcihsZXQgbj0wO248dC5mZWF0dXJlcy5sZW5ndGg7KytuKWUuZmVhdHVyZXMucHVzaCh0aGlzLnJlYWQodC5mZWF0dXJlc1tuXSkpfXJldHVybiB0LmJib3gmJihlLmJib3g9dGhpcy5wYXJzZS5iYm94LmNhbGwodGhpcyx0LmJib3gpKSxlfSxjb29yZGluYXRlczpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKG5ldyBnKHNbMF0sc1sxXSkpfXJldHVybiBlfSxiYm94OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgZyh0WzBdLHRbMV0pLG5ldyBnKHRbMl0sdFsxXSksbmV3IGcodFsyXSx0WzNdKSxuZXcgZyh0WzBdLHRbM10pLG5ldyBnKHRbMF0sdFsxXSldKX0sUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgZyh0WzBdLHRbMV0pO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKWUucHVzaChMcy5Qb2ludC5jYWxsKHRoaXMsdFtuXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGUpfSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9THMuY29vcmRpbmF0ZXMuY2FsbCh0aGlzLHQpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGUpfSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbillLnB1c2goTHMuTGluZVN0cmluZy5jYWxsKHRoaXMsdFtuXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9LFBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1Mcy5jb29yZGluYXRlcy5jYWxsKHRoaXMsdFswXSksbj10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGUpLHM9W107Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDsrK2Upe2NvbnN0IG49dFtlXSxpPUxzLmNvb3JkaW5hdGVzLmNhbGwodGhpcyxuKSxyPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoaSk7cy5wdXNoKHIpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4scyl9LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKExzLlBvbHlnb24uY2FsbCh0aGlzLHMpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbil7Y29uc3Qgcz10W25dO2UucHVzaCh0aGlzLnJlYWQocykpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9fSxUcz17Y29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm5bdC54LHQueV19LFBvaW50OmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczpUcy5jb29yZGluYXRlLmNhbGwodGhpcyx0LmdldENvb3JkaW5hdGUoKSl9fSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPVRzLlBvaW50LmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvaW50XCIsY29vcmRpbmF0ZXM6ZX19LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXSxuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoOysrdCl7Y29uc3Qgcz1uW3RdO2UucHVzaChUcy5jb29yZGluYXRlLmNhbGwodGhpcyxzKSl9cmV0dXJue3R5cGU6XCJMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1Ucy5MaW5lU3RyaW5nLmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aUxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdLG49VHMuTGluZVN0cmluZy5jYWxsKHRoaXMsdC5fc2hlbGwpO2UucHVzaChuLmNvb3JkaW5hdGVzKTtmb3IobGV0IG49MDtuPHQuX2hvbGVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5faG9sZXNbbl0saT1Ucy5MaW5lU3RyaW5nLmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1Ucy5Qb2x5Z29uLmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvbHlnb25cIixjb29yZGluYXRlczplfX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPXMuZ2V0R2VvbWV0cnlUeXBlKCk7ZS5wdXNoKFRzW2ldLmNhbGwodGhpcyxzKSl9cmV0dXJue3R5cGU6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixnZW9tZXRyaWVzOmV9fX07ZnVuY3Rpb24gUnModCl7cmV0dXJuW3QueCx0LnldfXZhciBQcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxHZW9KU09OUmVhZGVyOmNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPW5ldyB3cyh0fHxuZXcgSHQpfXJlYWQodCl7cmV0dXJuIHRoaXMucGFyc2VyLnJlYWQodCl9fSxHZW9KU09OV3JpdGVyOmNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5wYXJzZXI9bmV3IHdzKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KX13cml0ZSh0KXtyZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUodCl9fSxPTDNQYXJzZXI6Y2xhc3N7Y29uc3RydWN0b3IodCxlKXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgSHQsdGhpcy5vbD1lfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygb2wmJm9sfWluamVjdCh0LGUsbixzLGkscixvLGwpe3RoaXMub2w9e2dlb206e1BvaW50OnQsTGluZVN0cmluZzplLExpbmVhclJpbmc6bixQb2x5Z29uOnMsTXVsdGlQb2ludDppLE11bHRpTGluZVN0cmluZzpyLE11bHRpUG9seWdvbjpvLEdlb21ldHJ5Q29sbGVjdGlvbjpsfX19cmVhZCh0KXtjb25zdCBlPXRoaXMub2w7cmV0dXJuIHQgaW5zdGFuY2VvZiBlLmdlb20uUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTGluZVN0cmluZz90aGlzLmNvbnZlcnRGcm9tTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkxpbmVhclJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5Qb2x5Z29uP3RoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTXVsdGlQb2ludD90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2ludCh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpTGluZVN0cmluZz90aGlzLmNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTXVsdGlQb2x5Z29uP3RoaXMuY29udmVydEZyb21NdWx0aVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24/dGhpcy5jb252ZXJ0RnJvbUNvbGxlY3Rpb24odCk6dm9pZCAwfWNvbnZlcnRGcm9tUG9pbnQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KG5ldyBnKGVbMF0sZVsxXSkpfWNvbnZlcnRGcm9tTGluZVN0cmluZyh0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LmdldENvb3JkaW5hdGVzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodFswXSx0WzFdKX0pKSl9Y29udmVydEZyb21MaW5lYXJSaW5nKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyh0WzBdLHRbMV0pfSkpKX1jb252ZXJ0RnJvbVBvbHlnb24odCl7Y29uc3QgZT10LmdldExpbmVhclJpbmdzKCk7bGV0IG49bnVsbDtjb25zdCBzPVtdO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBpPXRoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKGVbdF0pOzA9PT10P249aTpzLnB1c2goaSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24obixzKX1jb252ZXJ0RnJvbU11bHRpUG9pbnQodCl7Y29uc3QgZT10LmdldFBvaW50cygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2ludCh0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGUpfWNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nKHQpe2NvbnN0IGU9dC5nZXRMaW5lU3RyaW5ncygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX1jb252ZXJ0RnJvbU11bHRpUG9seWdvbih0KXtjb25zdCBlPXQuZ2V0UG9seWdvbnMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9Y29udmVydEZyb21Db2xsZWN0aW9uKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyaWVzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkKHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX13cml0ZSh0KXtyZXR1cm5cIlBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9pbnQodC5nZXRDb29yZGluYXRlKCkpOlwiTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodCk6XCJMaW5lYXJSaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZWFyUmluZyh0KTpcIlBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQpOlwiTXVsdGlQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9pbnQodCk6XCJNdWx0aUxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmcodCk6XCJNdWx0aVBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvbHlnb24odCk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Db2xsZWN0aW9uKHQpOnZvaWQgMH1jb252ZXJ0VG9Qb2ludCh0KXtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5Qb2ludChbdC54LHQueV0pfWNvbnZlcnRUb0xpbmVTdHJpbmcodCl7Y29uc3QgZT10Ll9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChScyk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTGluZVN0cmluZyhlKX1jb252ZXJ0VG9MaW5lYXJSaW5nKHQpe2NvbnN0IGU9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoUnMpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLkxpbmVhclJpbmcoZSl9Y29udmVydFRvUG9seWdvbih0KXtjb25zdCBlPVt0Ll9zaGVsbC5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoUnMpXTtmb3IobGV0IG49MDtuPHQuX2hvbGVzLmxlbmd0aDtuKyspZS5wdXNoKHQuX2hvbGVzW25dLl9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChScykpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLlBvbHlnb24oZSl9Y29udmVydFRvTXVsdGlQb2ludCh0KXtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aVBvaW50KHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoUnMpKX1jb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmcodCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9MaW5lU3RyaW5nKHQuX2dlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpTGluZVN0cmluZyhlKX1jb252ZXJ0VG9NdWx0aVBvbHlnb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQuX2dlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpUG9seWdvbihlKX1jb252ZXJ0VG9Db2xsZWN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXTtlLnB1c2godGhpcy53cml0ZShzKSl9cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0sV0tUUmVhZGVyOmNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPW5ldyBLdCh0fHxuZXcgSHQpfXJlYWQodCl7cmV0dXJuIHRoaXMucGFyc2VyLnJlYWQodCl9fSxXS1RXcml0ZXI6SnR9KTtjbGFzcyB2c3tjb25zdHJ1Y3Rvcigpe3ZzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHJlbGF0aXZlU2lnbih0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6MH1zdGF0aWMgY29tcGFyZSh0LGUsbil7aWYoZS5lcXVhbHMyRChuKSlyZXR1cm4gMDtjb25zdCBzPXZzLnJlbGF0aXZlU2lnbihlLngsbi54KSxpPXZzLnJlbGF0aXZlU2lnbihlLnksbi55KTtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiB2cy5jb21wYXJlVmFsdWUocyxpKTtjYXNlIDE6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZShpLHMpO2Nhc2UgMjpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKGksLXMpO2Nhc2UgMzpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKC1zLGkpO2Nhc2UgNDpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKC1zLC1pKTtjYXNlIDU6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZSgtaSwtcyk7Y2FzZSA2OnJldHVybiB2cy5jb21wYXJlVmFsdWUoLWkscyk7Y2FzZSA3OnJldHVybiB2cy5jb21wYXJlVmFsdWUocywtaSl9cmV0dXJuIHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJpbnZhbGlkIG9jdGFudCB2YWx1ZVwiKSwwfXN0YXRpYyBjb21wYXJlVmFsdWUodCxlKXtyZXR1cm4gdDwwPy0xOnQ+MD8xOmU8MD8tMTplPjA/MTowfWdldENsYXNzKCl7cmV0dXJuIHZzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12cy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIE9ze2NvbnN0cnVjdG9yKCl7T3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuY29vcmR9cHJpbnQodCl7dC5wcmludCh0aGlzLmNvb3JkKSx0LnByaW50KFwiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PGUuc2VnbWVudEluZGV4Py0xOnRoaXMuc2VnbWVudEluZGV4PmUuc2VnbWVudEluZGV4PzE6dGhpcy5jb29yZC5lcXVhbHMyRChlLmNvb3JkKT8wOnZzLmNvbXBhcmUodGhpcy5fc2VnbWVudE9jdGFudCx0aGlzLmNvb3JkLGUuY29vcmQpfWlzRW5kUG9pbnQodCl7cmV0dXJuIDA9PT10aGlzLnNlZ21lbnRJbmRleCYmIXRoaXMuX2lzSW50ZXJpb3J8fHRoaXMuc2VnbWVudEluZGV4PT09dH1pc0ludGVyaW9yKCl7cmV0dXJuIHRoaXMuX2lzSW50ZXJpb3J9Z2V0Q2xhc3MoKXtyZXR1cm4gT3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Pcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zZWdTdHJpbmc9bnVsbCx0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLl9zZWdtZW50T2N0YW50PW51bGwsdGhpcy5faXNJbnRlcmlvcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX3NlZ1N0cmluZz10LHRoaXMuY29vcmQ9bmV3IGcoZSksdGhpcy5zZWdtZW50SW5kZXg9bix0aGlzLl9zZWdtZW50T2N0YW50PXMsdGhpcy5faXNJbnRlcmlvcj0hZS5lcXVhbHMyRCh0LmdldENvb3JkaW5hdGUobikpfTtjbGFzcyBic3tjb25zdHJ1Y3Rvcigpe2JzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0U3BsaXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEk7dGhpcy5hZGRFbmRwb2ludHMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKTt0aGlzLmFkZEVkZ2VDb29yZGluYXRlcyhuLHMsdCksbj1zfXJldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9YWRkQ29sbGFwc2VkTm9kZXMoKXtjb25zdCB0PW5ldyB4O3RoaXMuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpLHRoaXMuZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLmludFZhbHVlKCk7dGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHQpLHQpfX1wcmludCh0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2Uuc2l6ZSgpLTI7ZSsrKXtjb25zdCBuPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKSxzPSh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSsxKSx0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSsyKSk7bi5lcXVhbHMyRChzKSYmdC5hZGQobmV3IEwoZSsxKSl9fWFkZEVkZ2VDb29yZGluYXRlcyh0LGUsbil7ZS5zZWdtZW50SW5kZXgsdC5zZWdtZW50SW5kZXg7Y29uc3Qgcz10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLGk9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKHMpO24uYWRkKG5ldyBnKHQuY29vcmQpLCExKTtmb3IobGV0IHM9dC5zZWdtZW50SW5kZXgrMTtzPD1lLnNlZ21lbnRJbmRleDtzKyspbi5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHMpKTtpJiZuLmFkZChuZXcgZyhlLmNvb3JkKSl9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfWFkZFNwbGl0RWRnZXModCl7dGhpcy5hZGRFbmRwb2ludHMoKSx0aGlzLmFkZENvbGxhcHNlZE5vZGVzKCk7Y29uc3QgZT10aGlzLml0ZXJhdG9yKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLHMpO3QuYWRkKGkpLG49c319ZmluZENvbGxhcHNlSW5kZXgodCxlLG4pe2lmKCF0LmNvb3JkLmVxdWFsczJEKGUuY29vcmQpKXJldHVybiExO2xldCBzPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4O3JldHVybiBlLmlzSW50ZXJpb3IoKXx8cy0tLDE9PT1zJiYoblswXT10LnNlZ21lbnRJbmRleCsxLCEwKX1maW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXModCl7Y29uc3QgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuaXRlcmF0b3IoKTtsZXQgcz1uLm5leHQoKTtmb3IoO24uaGFzTmV4dCgpOyl7Y29uc3QgaT1uLm5leHQoKTt0aGlzLmZpbmRDb2xsYXBzZUluZGV4KHMsaSxlKSYmdC5hZGQobmV3IEwoZVswXSkpLHM9aX19Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfWFkZEVuZHBvaW50cygpe2NvbnN0IHQ9dGhpcy5fZWRnZS5zaXplKCktMTt0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoMCksMCksdGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHQpLHQpfWNyZWF0ZVNwbGl0RWRnZSh0LGUpe2xldCBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzI7Y29uc3Qgcz10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLGk9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKHMpO2l8fG4tLTtjb25zdCByPW5ldyBBcnJheShuKS5maWxsKG51bGwpO2xldCBvPTA7cltvKytdPW5ldyBnKHQuY29vcmQpO2ZvcihsZXQgbj10LnNlZ21lbnRJbmRleCsxO248PWUuc2VnbWVudEluZGV4O24rKylyW28rK109dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKG4pO3JldHVybiBpJiYocltvXT1uZXcgZyhlLmNvb3JkKSksbmV3IEZzKHIsdGhpcy5fZWRnZS5nZXREYXRhKCkpfWFkZCh0LGUpe2NvbnN0IG49bmV3IE9zKHRoaXMuX2VkZ2UsdCxlLHRoaXMuX2VkZ2UuZ2V0U2VnbWVudE9jdGFudChlKSkscz10aGlzLl9ub2RlTWFwLmdldChuKTtyZXR1cm4gbnVsbCE9PXM/KHUuaXNUcnVlKHMuY29vcmQuZXF1YWxzMkQodCksXCJGb3VuZCBlcXVhbCBub2RlcyB3aXRoIGRpZmZlcmVudCBjb29yZGluYXRlc1wiKSxzKToodGhpcy5fbm9kZU1hcC5wdXQobixuKSxuKX1jaGVja1NwbGl0RWRnZXNDb3JyZWN0bmVzcyh0KXtjb25zdCBlPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZXMoKSxuPXQuZ2V0KDApLmdldENvb3JkaW5hdGUoMCk7aWYoIW4uZXF1YWxzMkQoZVswXSkpdGhyb3cgbmV3IGMoXCJiYWQgc3BsaXQgZWRnZSBzdGFydCBwb2ludCBhdCBcIituKTtjb25zdCBzPXQuZ2V0KHQuc2l6ZSgpLTEpLmdldENvb3JkaW5hdGVzKCksaT1zW3MubGVuZ3RoLTFdO2lmKCFpLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pKXRocm93IG5ldyBjKFwiYmFkIHNwbGl0IGVkZ2UgZW5kIHBvaW50IGF0IFwiK2kpfWdldENsYXNzKCl7cmV0dXJuIGJzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1icy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ub2RlTWFwPW5ldyBydCx0aGlzLl9lZGdlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZWRnZT10fTtjbGFzcyBNc3tjb25zdHJ1Y3Rvcigpe01zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG9jdGFudCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgbihcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHBvaW50ICggXCIrdCtcIiwgXCIrZStcIiApXCIpO2NvbnN0IHM9TWF0aC5hYnModCksaT1NYXRoLmFicyhlKTtyZXR1cm4gdD49MD9lPj0wP3M+PWk/MDoxOnM+PWk/Nzo2OmU+PTA/cz49aT8zOjI6cz49aT80OjV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLHM9ZS54LXQueCxpPWUueS10Lnk7aWYoMD09PXMmJjA9PT1pKXRocm93IG5ldyBuKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgXCIrdCk7cmV0dXJuIE1zLm9jdGFudChzLGkpfX1nZXRDbGFzcygpe3JldHVybiBNc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBEc3tjb25zdHJ1Y3Rvcigpe0RzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZXMoKXt9c2l6ZSgpe31nZXRDb29yZGluYXRlKHQpe31pc0Nsb3NlZCgpe31zZXREYXRhKHQpe31nZXREYXRhKCl7fWdldENsYXNzKCl7cmV0dXJuIERzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ecy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEFze2NvbnN0cnVjdG9yKCl7QXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGRJbnRlcnNlY3Rpb24odCxlKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gQXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RzXX19QXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBGc3tjb25zdHJ1Y3Rvcigpe0ZzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldE5vZGVkU3Vic3RyaW5ncygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4O3JldHVybiBGcy5nZXROb2RlZFN1YnN0cmluZ3ModCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuZ2V0Tm9kZUxpc3QoKS5hZGRTcGxpdEVkZ2VzKGUpfX19Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHRzfXNpemUoKXtyZXR1cm4gdGhpcy5fcHRzLmxlbmd0aH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdHNbdF19aXNDbG9zZWQoKXtyZXR1cm4gdGhpcy5fcHRzWzBdLmVxdWFscyh0aGlzLl9wdHNbdGhpcy5fcHRzLmxlbmd0aC0xXSl9Z2V0U2VnbWVudE9jdGFudCh0KXtyZXR1cm4gdD09PXRoaXMuX3B0cy5sZW5ndGgtMT8tMTp0aGlzLnNhZmVPY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1zYWZlT2N0YW50KHQsZSl7cmV0dXJuIHQuZXF1YWxzMkQoZSk/MDpNcy5vY3RhbnQodCxlKX1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9YWRkSW50ZXJzZWN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuYWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzNdLHM9bmV3IGcodC5nZXRJbnRlcnNlY3Rpb24obikpO3RoaXMuYWRkSW50ZXJzZWN0aW9uKHMsZSl9fXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyhuZXcgenQodGhpcy5fcHRzKSl9Z2V0Tm9kZUxpc3QoKXtyZXR1cm4gdGhpcy5fbm9kZUxpc3R9YWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpe2xldCBuPWU7Y29uc3Qgcz1uKzE7aWYoczx0aGlzLl9wdHMubGVuZ3RoKXtjb25zdCBlPXRoaXMuX3B0c1tzXTt0LmVxdWFsczJEKGUpJiYobj1zKX1yZXR1cm4gdGhpcy5fbm9kZUxpc3QuYWRkKHQsbil9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LmdldEludGVyc2VjdGlvbk51bSgpO3MrKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixzKX1nZXRDbGFzcygpe3JldHVybiBGc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQXNdfX1Gcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ub2RlTGlzdD1uZXcgYnModGhpcyksdGhpcy5fcHRzPW51bGwsdGhpcy5fZGF0YT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX2RhdGE9ZX07Y2xhc3MgR3N7Y29uc3RydWN0b3IoKXtHcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfW92ZXJsYXAoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dC5nZXRMaW5lU2VnbWVudChlLHRoaXMuX292ZXJsYXBTZWcxKSxuLmdldExpbmVTZWdtZW50KHMsdGhpcy5fb3ZlcmxhcFNlZzIpLHRoaXMub3ZlcmxhcCh0aGlzLl9vdmVybGFwU2VnMSx0aGlzLl9vdmVybGFwU2VnMil9fWdldENsYXNzKCl7cmV0dXJuIEdzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Hcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9vdmVybGFwU2VnMT1uZXcgZWUsdGhpcy5fb3ZlcmxhcFNlZzI9bmV3IGVlfTtjbGFzcyBxc3tjb25zdHJ1Y3Rvcigpe3FzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TGluZVNlZ21lbnQodCxlKXtlLnAwPXRoaXMuX3B0c1t0XSxlLnAxPXRoaXMuX3B0c1t0KzFdfWNvbXB1dGVTZWxlY3QodCxlLG4scyl7Y29uc3QgaT10aGlzLl9wdHNbZV0scj10aGlzLl9wdHNbbl07aWYobi1lPT0xKXJldHVybiBzLnNlbGVjdCh0aGlzLGUpLG51bGw7aWYoIXQuaW50ZXJzZWN0cyhpLHIpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygoZStuKS8yKTtlPG8mJnRoaXMuY29tcHV0ZVNlbGVjdCh0LGUsbyxzKSxvPG4mJnRoaXMuY29tcHV0ZVNlbGVjdCh0LG8sbixzKX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2VuZC10aGlzLl9zdGFydCsxKS5maWxsKG51bGwpO2xldCBlPTA7Zm9yKGxldCBuPXRoaXMuX3N0YXJ0O248PXRoaXMuX2VuZDtuKyspdFtlKytdPXRoaXMuX3B0c1tuXTtyZXR1cm4gdH1jb21wdXRlT3ZlcmxhcHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5jb21wdXRlT3ZlcmxhcHModGhpcy5fc3RhcnQsdGhpcy5fZW5kLHQsdC5fc3RhcnQsdC5fZW5kLGUpfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO2lmKGUtdD09MSYmaS1zPT0xKXJldHVybiByLm92ZXJsYXAodGhpcyx0LG4scyksbnVsbDtpZighdGhpcy5vdmVybGFwcyh0LGUsbixzLGkpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygodCtlKS8yKSxsPU1hdGgudHJ1bmMoKHMraSkvMik7dDxvJiYoczxsJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyh0LG8sbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyh0LG8sbixsLGkscikpLG88ZSYmKHM8bCYmdGhpcy5jb21wdXRlT3ZlcmxhcHMobyxlLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHMobyxlLG4sbCxpLHIpKX19c2V0SWQodCl7dGhpcy5faWQ9dH1zZWxlY3QodCxlKXt0aGlzLmNvbXB1dGVTZWxlY3QodCx0aGlzLl9zdGFydCx0aGlzLl9lbmQsZSl9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXtjb25zdCB0PXRoaXMuX3B0c1t0aGlzLl9zdGFydF0sZT10aGlzLl9wdHNbdGhpcy5fZW5kXTt0aGlzLl9lbnY9bmV3IE4odCxlKX1yZXR1cm4gdGhpcy5fZW52fW92ZXJsYXBzKHQsZSxuLHMsaSl7cmV0dXJuIE4uaW50ZXJzZWN0cyh0aGlzLl9wdHNbdF0sdGhpcy5fcHRzW2VdLG4uX3B0c1tzXSxuLl9wdHNbaV0pfWdldEVuZEluZGV4KCl7cmV0dXJuIHRoaXMuX2VuZH1nZXRTdGFydEluZGV4KCl7cmV0dXJuIHRoaXMuX3N0YXJ0fWdldENvbnRleHQoKXtyZXR1cm4gdGhpcy5fY29udGV4dH1nZXRJZCgpe3JldHVybiB0aGlzLl9pZH1nZXRDbGFzcygpe3JldHVybiBxc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fc3RhcnQ9bnVsbCx0aGlzLl9lbmQ9bnVsbCx0aGlzLl9lbnY9bnVsbCx0aGlzLl9jb250ZXh0PW51bGwsdGhpcy5faWQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9wdHM9dCx0aGlzLl9zdGFydD1lLHRoaXMuX2VuZD1uLHRoaXMuX2NvbnRleHQ9c307Y2xhc3MgQnN7Y29uc3RydWN0b3IoKXtCcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRDaGFpblN0YXJ0SW5kaWNlcyh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IHg7bi5hZGQobmV3IEwoZSkpO2Rve2NvbnN0IHM9QnMuZmluZENoYWluRW5kKHQsZSk7bi5hZGQobmV3IEwocykpLGU9c313aGlsZShlPHQubGVuZ3RoLTEpO3JldHVybiBCcy50b0ludEFycmF5KG4pfXN0YXRpYyBmaW5kQ2hhaW5FbmQodCxlKXtsZXQgbj1lO2Zvcig7bjx0Lmxlbmd0aC0xJiZ0W25dLmVxdWFsczJEKHRbbisxXSk7KW4rKztpZihuPj10Lmxlbmd0aC0xKXJldHVybiB0Lmxlbmd0aC0xO2NvbnN0IHM9SW4ucXVhZHJhbnQodFtuXSx0W24rMV0pO2xldCBpPWUrMTtmb3IoO2k8dC5sZW5ndGg7KXtpZighdFtpLTFdLmVxdWFsczJEKHRbaV0pKXtpZihJbi5xdWFkcmFudCh0W2ktMV0sdFtpXSkhPT1zKWJyZWFrfWkrK31yZXR1cm4gaS0xfXN0YXRpYyBnZXRDaGFpbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEJzLmdldENoYWlucyh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB4LHM9QnMuZ2V0Q2hhaW5TdGFydEluZGljZXModCk7Zm9yKGxldCBpPTA7aTxzLmxlbmd0aC0xO2krKyl7Y29uc3Qgcj1uZXcgcXModCxzW2ldLHNbaSsxXSxlKTtuLmFkZChyKX1yZXR1cm4gbn19c3RhdGljIHRvSW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10LmdldChuKS5pbnRWYWx1ZSgpO3JldHVybiBlfWdldENsYXNzKCl7cmV0dXJuIEJzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ccy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFZze2NvbnN0cnVjdG9yKCl7VnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlTm9kZXModCl7fWdldE5vZGVkU3Vic3RyaW5ncygpe31nZXRDbGFzcygpe3JldHVybiBWc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB6c3tjb25zdHJ1Y3Rvcigpe3pzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0U2VnbWVudEludGVyc2VjdG9yKHQpe3RoaXMuX3NlZ0ludD10fWdldENsYXNzKCl7cmV0dXJuIHpzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltWc119fXpzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3NlZ0ludD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFNlZ21lbnRJbnRlcnNlY3Rvcih0KX19O2NsYXNzIFlzIGV4dGVuZHMgenN7Y29uc3RydWN0b3IoKXtzdXBlcigpLFlzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TW9ub3RvbmVDaGFpbnMoKXtyZXR1cm4gdGhpcy5fbW9ub0NoYWluc31nZXROb2RlZFN1YnN0cmluZ3MoKXtyZXR1cm4gRnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMuX25vZGVkU2VnU3RyaW5ncyl9Z2V0SW5kZXgoKXtyZXR1cm4gdGhpcy5faW5kZXh9YWRkKHQpe2ZvcihsZXQgZT1Ccy5nZXRDaGFpbnModC5nZXRDb29yZGluYXRlcygpLHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0SWQodGhpcy5faWRDb3VudGVyKyspLHRoaXMuX2luZGV4Lmluc2VydCh0LmdldEVudmVsb3BlKCksdCksdGhpcy5fbW9ub0NoYWlucy5hZGQodCl9fWNvbXB1dGVOb2Rlcyh0KXt0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9dDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7dGhpcy5pbnRlcnNlY3RDaGFpbnMoKX1pbnRlcnNlY3RDaGFpbnMoKXtjb25zdCB0PW5ldyBVcyh0aGlzLl9zZWdJbnQpO2ZvcihsZXQgZT10aGlzLl9tb25vQ2hhaW5zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2ZvcihsZXQgZT10aGlzLl9pbmRleC5xdWVyeShuLmdldEVudmVsb3BlKCkpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpO2lmKHMuZ2V0SWQoKT5uLmdldElkKCkmJihuLmNvbXB1dGVPdmVybGFwcyhzLHQpLHRoaXMuX25PdmVybGFwcysrKSx0aGlzLl9zZWdJbnQuaXNEb25lKCkpcmV0dXJuIG51bGx9fX1nZXRDbGFzcygpe3JldHVybiBZc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgVXMgZXh0ZW5kcyBHc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksVXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1vdmVybGFwKCl7aWYoNCE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHN1cGVyLm92ZXJsYXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPXQuZ2V0Q29udGV4dCgpLHI9bi5nZXRDb250ZXh0KCk7dGhpcy5fc2kucHJvY2Vzc0ludGVyc2VjdGlvbnMoaSxlLHIscyl9fWdldENsYXNzKCl7cmV0dXJuIFVzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Vcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zaT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpPXR9LFlzLlNlZ21lbnRPdmVybGFwQWN0aW9uPVVzLFlzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX21vbm9DaGFpbnM9bmV3IHgsdGhpcy5faW5kZXg9bmV3IEVzLHRoaXMuX2lkQ291bnRlcj0wLHRoaXMuX25vZGVkU2VnU3RyaW5ncz1udWxsLHRoaXMuX25PdmVybGFwcz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt6cy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX07Y2xhc3Mga3N7Y29uc3RydWN0b3IoKXtrcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJlc2NhbGUoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLnJlc2NhbGUoZS5nZXRDb29yZGluYXRlcygpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsLG49bnVsbDsyPT09dC5sZW5ndGgmJihlPW5ldyBnKHRbMF0pLG49bmV3IGcodFsxXSkpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV0ueD10W2VdLngvdGhpcy5fc2NhbGVGYWN0b3IrdGhpcy5fb2Zmc2V0WCx0W2VdLnk9dFtlXS55L3RoaXMuX3NjYWxlRmFjdG9yK3RoaXMuX29mZnNldFk7Mj09PXQubGVuZ3RoJiZ0WzBdLmVxdWFsczJEKHRbMV0pJiZPLm91dC5wcmludGxuKHQpfX1zY2FsZSgpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4KHQuc2l6ZSgpKTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZChuZXcgRnModGhpcy5zY2FsZSh0LmdldENvb3JkaW5hdGVzKCkpLHQuZ2V0RGF0YSgpKSl9cmV0dXJuIGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZVtuXT1uZXcgZyhNYXRoLnJvdW5kKCh0W25dLngtdGhpcy5fb2Zmc2V0WCkqdGhpcy5fc2NhbGVGYWN0b3IpLE1hdGgucm91bmQoKHRbbl0ueS10aGlzLl9vZmZzZXRZKSp0aGlzLl9zY2FsZUZhY3RvciksdFtuXS56KTtyZXR1cm4gWC5yZW1vdmVSZXBlYXRlZFBvaW50cyhlKX19aXNJbnRlZ2VyUHJlY2lzaW9uKCl7cmV0dXJuIDE9PT10aGlzLl9zY2FsZUZhY3Rvcn1nZXROb2RlZFN1YnN0cmluZ3MoKXtjb25zdCB0PXRoaXMuX25vZGVyLmdldE5vZGVkU3Vic3RyaW5ncygpO3JldHVybiB0aGlzLl9pc1NjYWxlZCYmdGhpcy5yZXNjYWxlKHQpLHR9Y29tcHV0ZU5vZGVzKHQpe2xldCBlPXQ7dGhpcy5faXNTY2FsZWQmJihlPXRoaXMuc2NhbGUodCkpLHRoaXMuX25vZGVyLmNvbXB1dGVOb2RlcyhlKX1nZXRDbGFzcygpe3JldHVybiBrc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVnNdfX1rcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9ub2Rlcj1udWxsLHRoaXMuX3NjYWxlRmFjdG9yPW51bGwsdGhpcy5fb2Zmc2V0WD1udWxsLHRoaXMuX29mZnNldFk9bnVsbCx0aGlzLl9pc1NjYWxlZD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07a3MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsMCwwKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ub2Rlcj10LHRoaXMuX3NjYWxlRmFjdG9yPWUsdGhpcy5faXNTY2FsZWQ9IXRoaXMuaXNJbnRlZ2VyUHJlY2lzaW9uKCl9fTt2YXIgWHM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTUNJbmRleE5vZGVyOllzLFNjYWxlZE5vZGVyOmtzLFNlZ21lbnRTdHJpbmc6RHN9KTtjbGFzcyBIc3tjb25zdHJ1Y3Rvcigpe0hzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzU2ltcGxlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgSHModCkuaXNTaW1wbGUoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBIcyh0LGUpLmlzU2ltcGxlKCl9fWlzU2ltcGxlTXVsdGlQb2ludCh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDtjb25zdCBlPW5ldyBhdDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKS5nZXRDb29yZGluYXRlKCk7aWYoZS5jb250YWlucyhzKSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249cywhMTtlLmFkZChzKX1yZXR1cm4hMH1pc1NpbXBsZVBvbHlnb25hbCh0KXtmb3IobGV0IGU9eGUuZ2V0TGluZXModCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYoIXRoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KSlyZXR1cm4hMX1yZXR1cm4hMH1oYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbih0KXtjb25zdCBlPW5ldyBydDtmb3IobGV0IG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkscz0odC5nZXRNYXhpbXVtU2VnbWVudEluZGV4KCksdC5pc0Nsb3NlZCgpKSxpPXQuZ2V0Q29vcmRpbmF0ZSgwKTt0aGlzLmFkZEVuZHBvaW50KGUsaSxzKTtjb25zdCByPXQuZ2V0Q29vcmRpbmF0ZSh0LmdldE51bVBvaW50cygpLTEpO3RoaXMuYWRkRW5kcG9pbnQoZSxyLHMpfWZvcihsZXQgdD1lLnZhbHVlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2lmKGUuaXNDbG9zZWQmJjIhPT1lLmRlZ3JlZSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249ZS5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9Z2V0Tm9uU2ltcGxlTG9jYXRpb24oKXtyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb259aXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDtjb25zdCBlPW5ldyBRbigwLHQpLG49bmV3IHRlLHM9ZS5jb21wdXRlU2VsZk5vZGVzKG4sITApO3JldHVybiFzLmhhc0ludGVyc2VjdGlvbigpfHwocy5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKT8odGhpcy5fbm9uU2ltcGxlTG9jYXRpb249cy5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKTohdGhpcy5oYXNOb25FbmRwb2ludEludGVyc2VjdGlvbihlKSYmKCF0aGlzLl9pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3J8fCF0aGlzLmhhc0Nsb3NlZEVuZHBvaW50SW50ZXJzZWN0aW9uKGUpKSl9aGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRNYXhpbXVtU2VnbWVudEluZGV4KCk7Zm9yKGxldCBlPXQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZighdC5pc0VuZFBvaW50KG4pKXJldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj10LmdldENvb3JkaW5hdGUoKSwhMH19cmV0dXJuITF9YWRkRW5kcG9pbnQodCxlLG4pe2xldCBzPXQuZ2V0KGUpO251bGw9PT1zJiYocz1uZXcgV3MoZSksdC5wdXQoZSxzKSkscy5hZGRFbmRwb2ludChuKX1jb21wdXRlU2ltcGxlKHQpe3JldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1udWxsLCEhdC5pc0VtcHR5KCl8fCh0IGluc3RhbmNlb2YgVHR8fHQgaW5zdGFuY2VvZiBmdD90aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCk6dCBpbnN0YW5jZW9mIE10P3RoaXMuaXNTaW1wbGVNdWx0aVBvaW50KHQpOl8odCxPdCk/dGhpcy5pc1NpbXBsZVBvbHlnb25hbCh0KTohKHQgaW5zdGFuY2VvZiBfdCl8fHRoaXMuaXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCkpfWlzU2ltcGxlKCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsdGhpcy5jb21wdXRlU2ltcGxlKHRoaXMuX2lucHV0R2VvbSl9aXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuY29tcHV0ZVNpbXBsZShuKSlyZXR1cm4hMX1yZXR1cm4hMH1nZXRDbGFzcygpe3JldHVybiBIc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgV3N7Y29uc3RydWN0b3IoKXtXcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZEVuZHBvaW50KHQpe3RoaXMuZGVncmVlKyssdGhpcy5pc0Nsb3NlZHw9dH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMucHR9Z2V0Q2xhc3MoKXtyZXR1cm4gV3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVdzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMucHQ9bnVsbCx0aGlzLmlzQ2xvc2VkPW51bGwsdGhpcy5kZWdyZWU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnB0PXQsdGhpcy5pc0Nsb3NlZD0hMSx0aGlzLmRlZ3JlZT0wfSxIcy5FbmRwb2ludEluZm89V3MsSHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSEwLHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2lzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hZS5pc0luQm91bmRhcnkoMil9fTtjbGFzcyBqc3tjb25zdHJ1Y3Rvcigpe2pzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGJ1ZmZlckRpc3RhbmNlRXJyb3IodCl7Y29uc3QgZT1NYXRoLlBJLzIvdDtyZXR1cm4gMS1NYXRoLmNvcyhlLzIpfWdldEVuZENhcFN0eWxlKCl7cmV0dXJuIHRoaXMuX2VuZENhcFN0eWxlfWlzU2luZ2xlU2lkZWQoKXtyZXR1cm4gdGhpcy5faXNTaW5nbGVTaWRlZH1zZXRRdWFkcmFudFNlZ21lbnRzKHQpe3RoaXMuX3F1YWRyYW50U2VnbWVudHM9dCwwPT09dGhpcy5fcXVhZHJhbnRTZWdtZW50cyYmKHRoaXMuX2pvaW5TdHlsZT1qcy5KT0lOX0JFVkVMKSx0aGlzLl9xdWFkcmFudFNlZ21lbnRzPDAmJih0aGlzLl9qb2luU3R5bGU9anMuSk9JTl9NSVRSRSx0aGlzLl9taXRyZUxpbWl0PU1hdGguYWJzKHRoaXMuX3F1YWRyYW50U2VnbWVudHMpKSx0PD0wJiYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz0xKSx0aGlzLl9qb2luU3R5bGUhPT1qcy5KT0lOX1JPVU5EJiYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz1qcy5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTKX1nZXRKb2luU3R5bGUoKXtyZXR1cm4gdGhpcy5fam9pblN0eWxlfXNldEpvaW5TdHlsZSh0KXt0aGlzLl9qb2luU3R5bGU9dH1zZXRTaW1wbGlmeUZhY3Rvcih0KXt0aGlzLl9zaW1wbGlmeUZhY3Rvcj10PDA/MDp0fWdldFNpbXBsaWZ5RmFjdG9yKCl7cmV0dXJuIHRoaXMuX3NpbXBsaWZ5RmFjdG9yfWdldFF1YWRyYW50U2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fcXVhZHJhbnRTZWdtZW50c31zZXRFbmRDYXBTdHlsZSh0KXt0aGlzLl9lbmRDYXBTdHlsZT10fWdldE1pdHJlTGltaXQoKXtyZXR1cm4gdGhpcy5fbWl0cmVMaW1pdH1zZXRNaXRyZUxpbWl0KHQpe3RoaXMuX21pdHJlTGltaXQ9dH1zZXRTaW5nbGVTaWRlZCh0KXt0aGlzLl9pc1NpbmdsZVNpZGVkPXR9Z2V0Q2xhc3MoKXtyZXR1cm4ganN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWpzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3F1YWRyYW50U2VnbWVudHM9anMuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUyx0aGlzLl9lbmRDYXBTdHlsZT1qcy5DQVBfUk9VTkQsdGhpcy5fam9pblN0eWxlPWpzLkpPSU5fUk9VTkQsdGhpcy5fbWl0cmVMaW1pdD1qcy5ERUZBVUxUX01JVFJFX0xJTUlULHRoaXMuX2lzU2luZ2xlU2lkZWQ9ITEsdGhpcy5fc2ltcGxpZnlGYWN0b3I9anMuREVGQVVMVF9TSU1QTElGWV9GQUNUT1IsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCksdGhpcy5zZXRFbmRDYXBTdHlsZShlKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCksdGhpcy5zZXRFbmRDYXBTdHlsZShlKSx0aGlzLnNldEpvaW5TdHlsZShuKSx0aGlzLnNldE1pdHJlTGltaXQocyl9fSxqcy5DQVBfUk9VTkQ9MSxqcy5DQVBfRkxBVD0yLGpzLkNBUF9TUVVBUkU9Myxqcy5KT0lOX1JPVU5EPTEsanMuSk9JTl9NSVRSRT0yLGpzLkpPSU5fQkVWRUw9Myxqcy5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTPTgsanMuREVGQVVMVF9NSVRSRV9MSU1JVD01LGpzLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SPS4wMTtjbGFzcyBLc3tjb25zdHJ1Y3Rvcigpe0tzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9taW5Db29yZH1nZXRSaWdodG1vc3RTaWRlKHQsZSl7bGV0IG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZSk7cmV0dXJuIG48MCYmKG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZS0xKSksbjwwJiYodGhpcy5fbWluQ29vcmQ9bnVsbCx0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KSksbn1maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCl7Y29uc3QgdD10aGlzLl9taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTt1LmlzVHJ1ZSh0aGlzLl9taW5JbmRleD4wJiZ0aGlzLl9taW5JbmRleDx0Lmxlbmd0aCxcInJpZ2h0bW9zdCBwb2ludCBleHBlY3RlZCB0byBiZSBpbnRlcmlvciB2ZXJ0ZXggb2YgZWRnZVwiKTtjb25zdCBlPXRbdGhpcy5fbWluSW5kZXgtMV0sbj10W3RoaXMuX21pbkluZGV4KzFdLHM9di5pbmRleCh0aGlzLl9taW5Db29yZCxuLGUpO2xldCBpPSExOyhlLnk8dGhpcy5fbWluQ29vcmQueSYmbi55PHRoaXMuX21pbkNvb3JkLnkmJnM9PT12LkNPVU5URVJDTE9DS1dJU0V8fGUueT50aGlzLl9taW5Db29yZC55JiZuLnk+dGhpcy5fbWluQ29vcmQueSYmcz09PXYuQ0xPQ0tXSVNFKSYmKGk9ITApLGkmJih0aGlzLl9taW5JbmRleD10aGlzLl9taW5JbmRleC0xKX1nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZSl7Y29uc3Qgbj10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2lmKGU8MHx8ZSsxPj1uLmxlbmd0aClyZXR1cm4tMTtpZihuW2VdLnk9PT1uW2UrMV0ueSlyZXR1cm4tMTtsZXQgcz1Qbi5MRUZUO3JldHVybiBuW2VdLnk8bltlKzFdLnkmJihzPVBuLlJJR0hUKSxzfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fb3JpZW50ZWREZX1jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCl7Y29uc3QgZT10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGgtMTtuKyspKG51bGw9PT10aGlzLl9taW5Db29yZHx8ZVtuXS54PnRoaXMuX21pbkNvb3JkLngpJiYodGhpcy5fbWluRGU9dCx0aGlzLl9taW5JbmRleD1uLHRoaXMuX21pbkNvb3JkPWVbbl0pfWZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCl7Y29uc3QgdD10aGlzLl9taW5EZS5nZXROb2RlKCkuZ2V0RWRnZXMoKTt0aGlzLl9taW5EZT10LmdldFJpZ2h0bW9zdEVkZ2UoKSx0aGlzLl9taW5EZS5pc0ZvcndhcmQoKXx8KHRoaXMuX21pbkRlPXRoaXMuX21pbkRlLmdldFN5bSgpLHRoaXMuX21pbkluZGV4PXRoaXMuX21pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLmxlbmd0aC0xKX1maW5kRWRnZSh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmlzRm9yd2FyZCgpJiZ0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KX11LmlzVHJ1ZSgwIT09dGhpcy5fbWluSW5kZXh8fHRoaXMuX21pbkNvb3JkLmVxdWFscyh0aGlzLl9taW5EZS5nZXRDb29yZGluYXRlKCkpLFwiaW5jb25zaXN0ZW5jeSBpbiByaWdodG1vc3QgcHJvY2Vzc2luZ1wiKSwwPT09dGhpcy5fbWluSW5kZXg/dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpOnRoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpLHRoaXMuX29yaWVudGVkRGU9dGhpcy5fbWluRGUsdGhpcy5nZXRSaWdodG1vc3RTaWRlKHRoaXMuX21pbkRlLHRoaXMuX21pbkluZGV4KT09PVBuLkxFRlQmJih0aGlzLl9vcmllbnRlZERlPXRoaXMuX21pbkRlLmdldFN5bSgpKX1nZXRDbGFzcygpe3JldHVybiBLc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gWnMoKXt0aGlzLmFycmF5Xz1bXX1Lcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9taW5JbmRleD0tMSx0aGlzLl9taW5Db29yZD1udWxsLHRoaXMuX21pbkRlPW51bGwsdGhpcy5fb3JpZW50ZWREZT1udWxsfSxacy5wcm90b3R5cGUuYWRkTGFzdD1mdW5jdGlvbih0KXt0aGlzLmFycmF5Xy5wdXNoKHQpfSxacy5wcm90b3R5cGUucmVtb3ZlRmlyc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8uc2hpZnQoKX0sWnMucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH07Y2xhc3MgUXN7Y29uc3RydWN0b3IoKXtRcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNsZWFyVmlzaXRlZEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRWaXNpdGVkKCExKX19Z2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9yaWdodE1vc3RDb29yZH1jb21wdXRlTm9kZURlcHRoKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzVmlzaXRlZCgpfHx0LmdldFN5bSgpLmlzVmlzaXRlZCgpKXtlPXQ7YnJlYWt9fWlmKG51bGw9PT1lKXRocm93IG5ldyBXbihcInVuYWJsZSB0byBmaW5kIGVkZ2UgdG8gY29tcHV0ZSBkZXB0aHMgYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpO3QuZ2V0RWRnZXMoKS5jb21wdXRlRGVwdGhzKGUpO2ZvcihsZXQgZT10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5zZXRWaXNpdGVkKCEwKSx0aGlzLmNvcHlTeW1EZXB0aHModCl9fWNvbXB1dGVEZXB0aCh0KXt0aGlzLmNsZWFyVmlzaXRlZEVkZ2VzKCk7Y29uc3QgZT10aGlzLl9maW5kZXIuZ2V0RWRnZSgpO2UuZ2V0Tm9kZSgpLGUuZ2V0TGFiZWwoKTtlLnNldEVkZ2VEZXB0aHMoUG4uUklHSFQsdCksdGhpcy5jb3B5U3ltRGVwdGhzKGUpLHRoaXMuY29tcHV0ZURlcHRocyhlKX1jcmVhdGUodCl7dGhpcy5hZGRSZWFjaGFibGUodCksdGhpcy5fZmluZGVyLmZpbmRFZGdlKHRoaXMuX2RpckVkZ2VMaXN0KSx0aGlzLl9yaWdodE1vc3RDb29yZD10aGlzLl9maW5kZXIuZ2V0Q29vcmRpbmF0ZSgpfWZpbmRSZXN1bHRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtlLmdldERlcHRoKFBuLlJJR0hUKT49MSYmZS5nZXREZXB0aChQbi5MRUZUKTw9MCYmIWUuaXNJbnRlcmlvckFyZWFFZGdlKCkmJmUuc2V0SW5SZXN1bHQoITApfX1jb21wdXRlRGVwdGhzKHQpe2NvbnN0IGU9bmV3IEosbj1uZXcgWnMscz10LmdldE5vZGUoKTtmb3Iobi5hZGRMYXN0KHMpLGUuYWRkKHMpLHQuc2V0VmlzaXRlZCghMCk7IW4uaXNFbXB0eSgpOyl7Y29uc3QgdD1uLnJlbW92ZUZpcnN0KCk7ZS5hZGQodCksdGhpcy5jb21wdXRlTm9kZURlcHRoKHQpO2ZvcihsZXQgcz10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCkuZ2V0U3ltKCk7aWYodC5pc1Zpc2l0ZWQoKSljb250aW51ZTtjb25zdCBpPXQuZ2V0Tm9kZSgpO2UuY29udGFpbnMoaSl8fChuLmFkZExhc3QoaSksZS5hZGQoaSkpfX19Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fcmlnaHRNb3N0Q29vcmQueDxlLl9yaWdodE1vc3RDb29yZC54Py0xOnRoaXMuX3JpZ2h0TW9zdENvb3JkLng+ZS5fcmlnaHRNb3N0Q29vcmQueD8xOjB9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXtjb25zdCB0PW5ldyBOO2ZvcihsZXQgZT10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoLTE7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKG5bZV0pfXRoaXMuX2Vudj10fXJldHVybiB0aGlzLl9lbnZ9YWRkUmVhY2hhYmxlKHQpe2NvbnN0IGU9bmV3IG9uO2ZvcihlLmFkZCh0KTshZS5lbXB0eSgpOyl7Y29uc3QgdD1lLnBvcCgpO3RoaXMuYWRkKHQsZSl9fWNvcHlTeW1EZXB0aHModCl7Y29uc3QgZT10LmdldFN5bSgpO2Uuc2V0RGVwdGgoUG4uTEVGVCx0LmdldERlcHRoKFBuLlJJR0hUKSksZS5zZXREZXB0aChQbi5SSUdIVCx0LmdldERlcHRoKFBuLkxFRlQpKX1hZGQodCxlKXt0LnNldFZpc2l0ZWQoITApLHRoaXMuX25vZGVzLmFkZCh0KTtmb3IobGV0IG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuX2RpckVkZ2VMaXN0LmFkZCh0KTtjb25zdCBzPXQuZ2V0U3ltKCkuZ2V0Tm9kZSgpO3MuaXNWaXNpdGVkKCl8fGUucHVzaChzKX19Z2V0Tm9kZXMoKXtyZXR1cm4gdGhpcy5fbm9kZXN9Z2V0RGlyZWN0ZWRFZGdlcygpe3JldHVybiB0aGlzLl9kaXJFZGdlTGlzdH1nZXRDbGFzcygpe3JldHVybiBRc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fVFzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2ZpbmRlcj1udWxsLHRoaXMuX2RpckVkZ2VMaXN0PW5ldyB4LHRoaXMuX25vZGVzPW5ldyB4LHRoaXMuX3JpZ2h0TW9zdENvb3JkPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5fZmluZGVyPW5ldyBLc307Y2xhc3MgSnN7Y29uc3RydWN0b3IoKXtKcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXB1dGVSaW5nKCl7aWYobnVsbCE9PXRoaXMuX3JpbmcpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fcHRzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX3B0cy5zaXplKCk7ZSsrKXRbZV09dGhpcy5fcHRzLmdldChlKTt0aGlzLl9yaW5nPXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpLHRoaXMuX2lzSG9sZT12LmlzQ0NXKHRoaXMuX3JpbmcuZ2V0Q29vcmRpbmF0ZXMoKSl9aXNJc29sYXRlZCgpe3JldHVybiAxPT09dGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfWNvbXB1dGVQb2ludHModCl7dGhpcy5fc3RhcnREZT10O2xldCBlPXQsbj0hMDtkb3tpZihudWxsPT09ZSl0aHJvdyBuZXcgV24oXCJGb3VuZCBudWxsIERpcmVjdGVkRWRnZVwiKTtpZihlLmdldEVkZ2VSaW5nKCk9PT10aGlzKXRocm93IG5ldyBXbihcIkRpcmVjdGVkIEVkZ2UgdmlzaXRlZCB0d2ljZSBkdXJpbmcgcmluZy1idWlsZGluZyBhdCBcIitlLmdldENvb3JkaW5hdGUoKSk7dGhpcy5fZWRnZXMuYWRkKGUpO2NvbnN0IHQ9ZS5nZXRMYWJlbCgpO3UuaXNUcnVlKHQuaXNBcmVhKCkpLHRoaXMubWVyZ2VMYWJlbCh0KSx0aGlzLmFkZFBvaW50cyhlLmdldEVkZ2UoKSxlLmlzRm9yd2FyZCgpLG4pLG49ITEsdGhpcy5zZXRFZGdlUmluZyhlLHRoaXMpLGU9dGhpcy5nZXROZXh0KGUpfXdoaWxlKGUhPT10aGlzLl9zdGFydERlKX1nZXRMaW5lYXJSaW5nKCl7cmV0dXJuIHRoaXMuX3Jpbmd9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzLmdldCh0KX1jb21wdXRlTWF4Tm9kZURlZ3JlZSgpe3RoaXMuX21heE5vZGVEZWdyZWU9MDtsZXQgdD10aGlzLl9zdGFydERlO2Rve2NvbnN0IGU9dC5nZXROb2RlKCkuZ2V0RWRnZXMoKS5nZXRPdXRnb2luZ0RlZ3JlZSh0aGlzKTtlPnRoaXMuX21heE5vZGVEZWdyZWUmJih0aGlzLl9tYXhOb2RlRGVncmVlPWUpLHQ9dGhpcy5nZXROZXh0KHQpfXdoaWxlKHQhPT10aGlzLl9zdGFydERlKTt0aGlzLl9tYXhOb2RlRGVncmVlKj0yfWFkZFBvaW50cyh0LGUsbil7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCk7aWYoZSl7bGV0IHQ9MTtuJiYodD0wKTtmb3IobGV0IGU9dDtlPHMubGVuZ3RoO2UrKyl0aGlzLl9wdHMuYWRkKHNbZV0pfWVsc2V7bGV0IHQ9cy5sZW5ndGgtMjtuJiYodD1zLmxlbmd0aC0xKTtmb3IobGV0IGU9dDtlPj0wO2UtLSl0aGlzLl9wdHMuYWRkKHNbZV0pfX1pc0hvbGUoKXtyZXR1cm4gdGhpcy5faXNIb2xlfXNldEluUmVzdWx0KCl7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3t0LmdldEVkZ2UoKS5zZXRJblJlc3VsdCghMCksdD10LmdldE5leHQoKX13aGlsZSh0IT09dGhpcy5fc3RhcnREZSl9Y29udGFpbnNQb2ludCh0KXtjb25zdCBlPXRoaXMuZ2V0TGluZWFyUmluZygpO2lmKCFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyh0KSlyZXR1cm4hMTtpZighV2UuaXNJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpKXJldHVybiExO2ZvcihsZXQgZT10aGlzLl9ob2xlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7aWYoZS5uZXh0KCkuY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMX1yZXR1cm4hMH1hZGRIb2xlKHQpe3RoaXMuX2hvbGVzLmFkZCh0KX1pc1NoZWxsKCl7cmV0dXJuIG51bGw9PT10aGlzLl9zaGVsbH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31nZXRNYXhOb2RlRGVncmVlKCl7cmV0dXJuIHRoaXMuX21heE5vZGVEZWdyZWU8MCYmdGhpcy5jb21wdXRlTWF4Tm9kZURlZ3JlZSgpLHRoaXMuX21heE5vZGVEZWdyZWV9Z2V0U2hlbGwoKXtyZXR1cm4gdGhpcy5fc2hlbGx9bWVyZ2VMYWJlbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodCwwKSx0aGlzLm1lcmdlTGFiZWwodCwxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0TG9jYXRpb24oZSxQbi5SSUdIVCk7aWYobj09PW5lLk5PTkUpcmV0dXJuIG51bGw7aWYodGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSk9PT1uZS5OT05FKXJldHVybiB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbihlLG4pLG51bGx9fXNldFNoZWxsKHQpe3RoaXMuX3NoZWxsPXQsbnVsbCE9PXQmJnQuYWRkSG9sZSh0aGlzKX10b1BvbHlnb24odCl7Y29uc3QgZT1uZXcgQXJyYXkodGhpcy5faG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMuc2l6ZSgpO3QrKyllW3RdPXRoaXMuX2hvbGVzLmdldCh0KS5nZXRMaW5lYXJSaW5nKCk7cmV0dXJuIHQuY3JlYXRlUG9seWdvbih0aGlzLmdldExpbmVhclJpbmcoKSxlKX1nZXRDbGFzcygpe3JldHVybiBKc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fc3RhcnREZT1udWxsLHRoaXMuX21heE5vZGVEZWdyZWU9LTEsdGhpcy5fZWRnZXM9bmV3IHgsdGhpcy5fcHRzPW5ldyB4LHRoaXMuX2xhYmVsPW5ldyBGbihuZS5OT05FKSx0aGlzLl9yaW5nPW51bGwsdGhpcy5faXNIb2xlPW51bGwsdGhpcy5fc2hlbGw9bnVsbCx0aGlzLl9ob2xlcz1uZXcgeCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5jb21wdXRlUG9pbnRzKHQpLHRoaXMuY29tcHV0ZVJpbmcoKX19O2NsYXNzICRzIGV4dGVuZHMgSnN7Y29uc3RydWN0b3IoKXtzdXBlcigpLCRzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0RWRnZVJpbmcodCxlKXt0LnNldE1pbkVkZ2VSaW5nKGUpfWdldE5leHQodCl7cmV0dXJuIHQuZ2V0TmV4dE1pbigpfWdldENsYXNzKCl7cmV0dXJuICRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX0kcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtKcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9O2NsYXNzIHRpIGV4dGVuZHMgSnN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YnVpbGRNaW5pbWFsUmluZ3MoKXtjb25zdCB0PW5ldyB4O2xldCBlPXRoaXMuX3N0YXJ0RGU7ZG97aWYobnVsbD09PWUuZ2V0TWluRWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgJHMoZSx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO3QuYWRkKG4pfWU9ZS5nZXROZXh0KCl9d2hpbGUoZSE9PXRoaXMuX3N0YXJ0RGUpO3JldHVybiB0fXNldEVkZ2VSaW5nKHQsZSl7dC5zZXRFZGdlUmluZyhlKX1saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKXtsZXQgdD10aGlzLl9zdGFydERlO2Rve3QuZ2V0Tm9kZSgpLmdldEVkZ2VzKCkubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHRoaXMpLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuX3N0YXJ0RGUpfWdldE5leHQodCl7cmV0dXJuIHQuZ2V0TmV4dCgpfWdldENsYXNzKCl7cmV0dXJuIHRpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX10aS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtKcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9O2NsYXNzIGVpe2NvbnN0cnVjdG9yKCl7ZWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zb3J0U2hlbGxzQW5kSG9sZXModCxlLG4pe2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuaXNIb2xlKCk/bi5hZGQodCk6ZS5hZGQodCl9fWNvbXB1dGVQb2x5Z29ucyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLnRvUG9seWdvbih0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKHQpfXJldHVybiBlfXBsYWNlRnJlZUhvbGVzKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCk7aWYobnVsbD09PWUuZ2V0U2hlbGwoKSl7Y29uc3Qgbj10aGlzLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcoZSx0KTtpZihudWxsPT09bil0aHJvdyBuZXcgV24oXCJ1bmFibGUgdG8gYXNzaWduIGhvbGUgdG8gYSBzaGVsbFwiLGUuZ2V0Q29vcmRpbmF0ZSgwKSk7ZS5zZXRTaGVsbChuKX19fWJ1aWxkTWluaW1hbEVkZ2VSaW5ncyh0LGUsbil7Y29uc3Qgcz1uZXcgeDtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKTtpZih0LmdldE1heE5vZGVEZWdyZWUoKT4yKXt0LmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO2NvbnN0IHM9dC5idWlsZE1pbmltYWxSaW5ncygpLGk9dGhpcy5maW5kU2hlbGwocyk7bnVsbCE9PWk/KHRoaXMucGxhY2VQb2x5Z29uSG9sZXMoaSxzKSxlLmFkZChpKSk6bi5hZGRBbGwocyl9ZWxzZSBzLmFkZCh0KX1yZXR1cm4gc31jb250YWluc1BvaW50KHQpe2ZvcihsZXQgZT10aGlzLl9zaGVsbExpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2lmKGUubmV4dCgpLmNvbnRhaW5zUG9pbnQodCkpcmV0dXJuITB9cmV0dXJuITF9YnVpbGRNYXhpbWFsRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc0luUmVzdWx0KCkmJnQuZ2V0TGFiZWwoKS5pc0FyZWEoKSYmbnVsbD09PXQuZ2V0RWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgdGkodCx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKG4pLG4uc2V0SW5SZXN1bHQoKX19cmV0dXJuIGV9cGxhY2VQb2x5Z29uSG9sZXModCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKTtlLmlzSG9sZSgpJiZlLnNldFNoZWxsKHQpfX1nZXRQb2x5Z29ucygpe3JldHVybiB0aGlzLmNvbXB1dGVQb2x5Z29ucyh0aGlzLl9zaGVsbExpc3QpfWZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKXtjb25zdCBuPXQuZ2V0TGluZWFyUmluZygpLHM9bi5nZXRFbnZlbG9wZUludGVybmFsKCksaT1uLmdldENvb3JkaW5hdGVOKDApO2xldCByPW51bGwsbz1udWxsO2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMaW5lYXJSaW5nKCksbD1uLmdldEVudmVsb3BlSW50ZXJuYWwoKTtudWxsIT09ciYmKG89ci5nZXRMaW5lYXJSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtsZXQgYT0hMTtsLmNvbnRhaW5zKHMpJiZXZS5pc0luUmluZyhpLG4uZ2V0Q29vcmRpbmF0ZXMoKSkmJihhPSEwKSxhJiYobnVsbD09PXJ8fG8uY29udGFpbnMobCkpJiYocj1lKX1yZXR1cm4gcn1maW5kU2hlbGwodCl7bGV0IGU9MCxuPW51bGw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5pc0hvbGUoKXx8KG49dCxlKyspfXJldHVybiB1LmlzVHJ1ZShlPD0xLFwiZm91bmQgdHdvIHNoZWxscyBpbiBNaW5pbWFsRWRnZVJpbmcgbGlzdFwiKSxufWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0LmdldEVkZ2VFbmRzKCksdC5nZXROb2RlcygpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtabi5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyhlKTtjb25zdCBuPXRoaXMuYnVpbGRNYXhpbWFsRWRnZVJpbmdzKHQpLHM9bmV3IHgsaT10aGlzLmJ1aWxkTWluaW1hbEVkZ2VSaW5ncyhuLHRoaXMuX3NoZWxsTGlzdCxzKTt0aGlzLnNvcnRTaGVsbHNBbmRIb2xlcyhpLHRoaXMuX3NoZWxsTGlzdCxzKSx0aGlzLnBsYWNlRnJlZUhvbGVzKHRoaXMuX3NoZWxsTGlzdCxzKX19Z2V0Q2xhc3MoKXtyZXR1cm4gZWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWVpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3NoZWxsTGlzdD1uZXcgeDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9dH07Y2xhc3Mgbml7Y29uc3RydWN0b3IoKXtuaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe3JldHVybiBuZXcgbmkodCkuc2ltcGxpZnkoZSl9aXNEZWxldGFibGUodCxlLG4scyl7Y29uc3QgaT10aGlzLl9pbnB1dExpbmVbdF0scj10aGlzLl9pbnB1dExpbmVbZV0sbz10aGlzLl9pbnB1dExpbmVbbl07cmV0dXJuISF0aGlzLmlzQ29uY2F2ZShpLHIsbykmJighIXRoaXMuaXNTaGFsbG93KGkscixvLHMpJiZ0aGlzLmlzU2hhbGxvd1NhbXBsZWQoaSxyLHQsbixzKSl9ZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCl7bGV0IHQ9MTt0aGlzLl9pbnB1dExpbmUubGVuZ3RoO2xldCBlPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCksbj10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGUpLHM9ITE7Zm9yKDtuPHRoaXMuX2lucHV0TGluZS5sZW5ndGg7KXtsZXQgaT0hMTt0aGlzLmlzRGVsZXRhYmxlKHQsZSxuLHRoaXMuX2Rpc3RhbmNlVG9sKSYmKHRoaXMuX2lzRGVsZXRlZFtlXT1uaS5ERUxFVEUsaT0hMCxzPSEwKSx0PWk/bjplLGU9dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSl9cmV0dXJuIHN9aXNTaGFsbG93Q29uY2F2aXR5KHQsZSxuLHMpe3JldHVybiB2LmluZGV4KHQsZSxuKT09PXRoaXMuX2FuZ2xlT3JpZW50YXRpb24mJkQucG9pbnRUb1NlZ21lbnQoZSx0LG4pPHN9aXNTaGFsbG93U2FtcGxlZCh0LGUsbixzLGkpe2xldCByPU1hdGgudHJ1bmMoKHMtbikvbmkuTlVNX1BUU19UT19DSEVDSyk7cjw9MCYmKHI9MSk7Zm9yKGxldCBvPW47bzxzO28rPXIpaWYoIXRoaXMuaXNTaGFsbG93KHQsZSx0aGlzLl9pbnB1dExpbmVbb10saSkpcmV0dXJuITE7cmV0dXJuITB9aXNDb25jYXZlKHQsZSxuKXtyZXR1cm4gdi5pbmRleCh0LGUsbik9PT10aGlzLl9hbmdsZU9yaWVudGF0aW9ufXNpbXBsaWZ5KHQpe3RoaXMuX2Rpc3RhbmNlVG9sPU1hdGguYWJzKHQpLHQ8MCYmKHRoaXMuX2FuZ2xlT3JpZW50YXRpb249di5DTE9DS1dJU0UpLHRoaXMuX2lzRGVsZXRlZD1uZXcgQXJyYXkodGhpcy5faW5wdXRMaW5lLmxlbmd0aCkuZmlsbChudWxsKTtsZXQgZT0hMTtkb3tlPXRoaXMuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCl9d2hpbGUoZSk7cmV0dXJuIHRoaXMuY29sbGFwc2VMaW5lKCl9ZmluZE5leHROb25EZWxldGVkSW5kZXgodCl7bGV0IGU9dCsxO2Zvcig7ZTx0aGlzLl9pbnB1dExpbmUubGVuZ3RoJiZ0aGlzLl9pc0RlbGV0ZWRbZV09PT1uaS5ERUxFVEU7KWUrKztyZXR1cm4gZX1pc1NoYWxsb3codCxlLG4scyl7cmV0dXJuIEQucG9pbnRUb1NlZ21lbnQoZSx0LG4pPHN9Y29sbGFwc2VMaW5lKCl7Y29uc3QgdD1uZXcgSTtmb3IobGV0IGU9MDtlPHRoaXMuX2lucHV0TGluZS5sZW5ndGg7ZSsrKXRoaXMuX2lzRGVsZXRlZFtlXSE9PW5pLkRFTEVURSYmdC5hZGQodGhpcy5faW5wdXRMaW5lW2VdKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWdldENsYXNzKCl7cmV0dXJuIG5pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1uaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dExpbmU9bnVsbCx0aGlzLl9kaXN0YW5jZVRvbD1udWxsLHRoaXMuX2lzRGVsZXRlZD1udWxsLHRoaXMuX2FuZ2xlT3JpZW50YXRpb249di5DT1VOVEVSQ0xPQ0tXSVNFO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0TGluZT10fSxuaS5JTklUPTAsbmkuREVMRVRFPTEsbmkuS0VFUD0xLG5pLk5VTV9QVFNfVE9fQ0hFQ0s9MTA7Y2xhc3Mgc2l7Y29uc3RydWN0b3IoKXtzaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0TGlzdC50b0FycmF5KHNpLkNPT1JESU5BVEVfQVJSQVlfVFlQRSl9c2V0UHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fcHJlY2lzaW9uTW9kZWw9dH1hZGRQdCh0KXtjb25zdCBlPW5ldyBnKHQpO2lmKHRoaXMuX3ByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGUpLHRoaXMuaXNSZWR1bmRhbnQoZSkpcmV0dXJuIG51bGw7dGhpcy5fcHRMaXN0LmFkZChlKX1yZXZlcnNlKCl7fWFkZFB0cyh0LGUpe2lmKGUpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdGhpcy5hZGRQdCh0W2VdKTtlbHNlIGZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXRoaXMuYWRkUHQodFtlXSl9aXNSZWR1bmRhbnQodCl7aWYodGhpcy5fcHRMaXN0LnNpemUoKTwxKXJldHVybiExO2NvbnN0IGU9dGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpLTEpO3JldHVybiB0LmRpc3RhbmNlKGUpPHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZX10b1N0cmluZygpe3JldHVybihuZXcgSHQpLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKS50b1N0cmluZygpfWNsb3NlUmluZygpe2lmKHRoaXMuX3B0TGlzdC5zaXplKCk8MSlyZXR1cm4gbnVsbDtjb25zdCB0PW5ldyBnKHRoaXMuX3B0TGlzdC5nZXQoMCkpLGU9dGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpLTEpO2xldCBuPW51bGw7aWYodGhpcy5fcHRMaXN0LnNpemUoKT49MiYmdGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpLTIpLHQuZXF1YWxzKGUpKXJldHVybiBudWxsO3RoaXMuX3B0TGlzdC5hZGQodCl9c2V0TWluaW11bVZlcnRleERpc3RhbmNlKHQpe3RoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZT10fWdldENsYXNzKCl7cmV0dXJuIHNpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1zaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdExpc3Q9bnVsbCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZT0wLHRoaXMuX3B0TGlzdD1uZXcgeH0sc2kuQ09PUkRJTkFURV9BUlJBWV9UWVBFPW5ldyBBcnJheSgwKS5maWxsKG51bGwpO2NsYXNzIGlpe2NvbnN0cnVjdG9yKCl7aWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGROZXh0U2VnbWVudCh0LGUpe2lmKHRoaXMuX3MwPXRoaXMuX3MxLHRoaXMuX3MxPXRoaXMuX3MyLHRoaXMuX3MyPXQsdGhpcy5fc2VnMC5zZXRDb29yZGluYXRlcyh0aGlzLl9zMCx0aGlzLl9zMSksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcwLHRoaXMuX3NpZGUsdGhpcy5fZGlzdGFuY2UsdGhpcy5fb2Zmc2V0MCksdGhpcy5fc2VnMS5zZXRDb29yZGluYXRlcyh0aGlzLl9zMSx0aGlzLl9zMiksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcxLHRoaXMuX3NpZGUsdGhpcy5fZGlzdGFuY2UsdGhpcy5fb2Zmc2V0MSksdGhpcy5fczEuZXF1YWxzKHRoaXMuX3MyKSlyZXR1cm4gbnVsbDtjb25zdCBuPXYuaW5kZXgodGhpcy5fczAsdGhpcy5fczEsdGhpcy5fczIpLHM9bj09PXYuQ0xPQ0tXSVNFJiZ0aGlzLl9zaWRlPT09UG4uTEVGVHx8bj09PXYuQ09VTlRFUkNMT0NLV0lTRSYmdGhpcy5fc2lkZT09PVBuLlJJR0hUOzA9PT1uP3RoaXMuYWRkQ29sbGluZWFyKGUpOnM/dGhpcy5hZGRPdXRzaWRlVHVybihuLGUpOnRoaXMuYWRkSW5zaWRlVHVybihuLGUpfWFkZExpbmVFbmRDYXAodCxlKXtjb25zdCBuPW5ldyBlZSh0LGUpLHM9bmV3IGVlO3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixQbi5MRUZULHRoaXMuX2Rpc3RhbmNlLHMpO2NvbnN0IGk9bmV3IGVlO3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixQbi5SSUdIVCx0aGlzLl9kaXN0YW5jZSxpKTtjb25zdCByPWUueC10Lngsbz1lLnktdC55LGw9TWF0aC5hdGFuMihvLHIpO3N3aXRjaCh0aGlzLl9idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBqcy5DQVBfUk9VTkQ6dGhpcy5fc2VnTGlzdC5hZGRQdChzLnAxKSx0aGlzLmFkZERpcmVjdGVkRmlsbGV0KGUsbCtNYXRoLlBJLzIsbC1NYXRoLlBJLzIsdi5DTE9DS1dJU0UsdGhpcy5fZGlzdGFuY2UpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoaS5wMSk7YnJlYWs7Y2FzZSBqcy5DQVBfRkxBVDp0aGlzLl9zZWdMaXN0LmFkZFB0KHMucDEpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoaS5wMSk7YnJlYWs7Y2FzZSBqcy5DQVBfU1FVQVJFOmNvbnN0IHQ9bmV3IGc7dC54PU1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSpNYXRoLmNvcyhsKSx0Lnk9TWF0aC5hYnModGhpcy5fZGlzdGFuY2UpKk1hdGguc2luKGwpO2NvbnN0IG49bmV3IGcocy5wMS54K3QueCxzLnAxLnkrdC55KSxyPW5ldyBnKGkucDEueCt0LngsaS5wMS55K3QueSk7dGhpcy5fc2VnTGlzdC5hZGRQdChuKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHIpfX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9zZWdMaXN0LmdldENvb3JkaW5hdGVzKCl9YWRkTWl0cmVKb2luKHQsZSxuLHMpe2xldCBpPSEwLHI9bnVsbDt0cnl7cj1iLmludGVyc2VjdGlvbihlLnAwLGUucDEsbi5wMCxuLnAxKSwoczw9MD8xOnIuZGlzdGFuY2UodCkvTWF0aC5hYnMocykpPnRoaXMuX2J1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkmJihpPSExKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBTKSl0aHJvdyB0O3I9bmV3IGcoMCwwKSxpPSExfWk/dGhpcy5fc2VnTGlzdC5hZGRQdChyKTp0aGlzLmFkZExpbWl0ZWRNaXRyZUpvaW4oZSxuLHMsdGhpcy5fYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSl9YWRkT3V0c2lkZVR1cm4odCxlKXtpZih0aGlzLl9vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMuX29mZnNldDEucDApPHRoaXMuX2Rpc3RhbmNlKmlpLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SKXJldHVybiB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLG51bGw7dGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09anMuSk9JTl9NSVRSRT90aGlzLmFkZE1pdHJlSm9pbih0aGlzLl9zMSx0aGlzLl9vZmZzZXQwLHRoaXMuX29mZnNldDEsdGhpcy5fZGlzdGFuY2UpOnRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWpzLkpPSU5fQkVWRUw/dGhpcy5hZGRCZXZlbEpvaW4odGhpcy5fb2Zmc2V0MCx0aGlzLl9vZmZzZXQxKTooZSYmdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSx0aGlzLmFkZENvcm5lckZpbGxldCh0aGlzLl9zMSx0aGlzLl9vZmZzZXQwLnAxLHRoaXMuX29mZnNldDEucDAsdCx0aGlzLl9kaXN0YW5jZSksdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKSl9Y3JlYXRlU3F1YXJlKHQpe3RoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IGcodC54K3RoaXMuX2Rpc3RhbmNlLHQueSt0aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IGcodC54K3RoaXMuX2Rpc3RhbmNlLHQueS10aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IGcodC54LXRoaXMuX2Rpc3RhbmNlLHQueS10aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IGcodC54LXRoaXMuX2Rpc3RhbmNlLHQueSt0aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCl9YWRkU2VnbWVudHModCxlKXt0aGlzLl9zZWdMaXN0LmFkZFB0cyh0LGUpfWFkZEZpcnN0U2VnbWVudCgpe3RoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCl9YWRkQ29ybmVyRmlsbGV0KHQsZSxuLHMsaSl7Y29uc3Qgcj1lLngtdC54LG89ZS55LXQueTtsZXQgbD1NYXRoLmF0YW4yKG8scik7Y29uc3QgYT1uLngtdC54LGM9bi55LXQueSxoPU1hdGguYXRhbjIoYyxhKTtzPT09di5DTE9DS1dJU0U/bDw9aCYmKGwrPTIqTWF0aC5QSSk6bD49aCYmKGwtPTIqTWF0aC5QSSksdGhpcy5fc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZERpcmVjdGVkRmlsbGV0KHQsbCxoLHMsaSksdGhpcy5fc2VnTGlzdC5hZGRQdChuKX1hZGRMYXN0U2VnbWVudCgpe3RoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMSl9aW5pdFNpZGVTZWdtZW50cyh0LGUsbil7dGhpcy5fczE9dCx0aGlzLl9zMj1lLHRoaXMuX3NpZGU9bix0aGlzLl9zZWcxLnNldENvb3JkaW5hdGVzKHQsZSksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcxLG4sdGhpcy5fZGlzdGFuY2UsdGhpcy5fb2Zmc2V0MSl9YWRkTGltaXRlZE1pdHJlSm9pbih0LGUsbixzKXtjb25zdCBpPXRoaXMuX3NlZzAucDEscj1pZS5hbmdsZShpLHRoaXMuX3NlZzAucDApLG89KGllLmFuZ2xlKGksdGhpcy5fc2VnMS5wMSksaWUuYW5nbGVCZXR3ZWVuT3JpZW50ZWQodGhpcy5fc2VnMC5wMCxpLHRoaXMuX3NlZzEucDEpLzIpLGw9aWUubm9ybWFsaXplKHIrbyksYT1pZS5ub3JtYWxpemUobCtNYXRoLlBJKSxjPXMqbixoPW4tYypNYXRoLmFicyhNYXRoLnNpbihvKSksdT1pLngrYypNYXRoLmNvcyhhKSxkPWkueStjKk1hdGguc2luKGEpLF89bmV3IGcodSxkKSxmPW5ldyBlZShpLF8pLHA9Zi5wb2ludEFsb25nT2Zmc2V0KDEsaCksbT1mLnBvaW50QWxvbmdPZmZzZXQoMSwtaCk7dGhpcy5fc2lkZT09PVBuLkxFRlQ/KHRoaXMuX3NlZ0xpc3QuYWRkUHQocCksdGhpcy5fc2VnTGlzdC5hZGRQdChtKSk6KHRoaXMuX3NlZ0xpc3QuYWRkUHQobSksdGhpcy5fc2VnTGlzdC5hZGRQdChwKSl9YWRkRGlyZWN0ZWRGaWxsZXQodCxlLG4scyxpKXtjb25zdCByPXM9PT12LkNMT0NLV0lTRT8tMToxLG89TWF0aC5hYnMoZS1uKSxsPU1hdGgudHJ1bmMoby90aGlzLl9maWxsZXRBbmdsZVF1YW50dW0rLjUpO2lmKGw8MSlyZXR1cm4gbnVsbDtsZXQgYT1udWxsLGM9bnVsbDthPTAsYz1vL2w7bGV0IGg9MDtjb25zdCB1PW5ldyBnO2Zvcig7aDxvOyl7Y29uc3Qgbj1lK3IqaDt1Lng9dC54K2kqTWF0aC5jb3MobiksdS55PXQueStpKk1hdGguc2luKG4pLHRoaXMuX3NlZ0xpc3QuYWRkUHQodSksaCs9Y319Y29tcHV0ZU9mZnNldFNlZ21lbnQodCxlLG4scyl7Y29uc3QgaT1lPT09UG4uTEVGVD8xOi0xLHI9dC5wMS54LXQucDAueCxvPXQucDEueS10LnAwLnksbD1NYXRoLnNxcnQocipyK28qbyksYT1pKm4qci9sLGM9aSpuKm8vbDtzLnAwLng9dC5wMC54LWMscy5wMC55PXQucDAueSthLHMucDEueD10LnAxLngtYyxzLnAxLnk9dC5wMS55K2F9YWRkSW5zaWRlVHVybih0LGUpe2lmKHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5fb2Zmc2V0MC5wMCx0aGlzLl9vZmZzZXQwLnAxLHRoaXMuX29mZnNldDEucDAsdGhpcy5fb2Zmc2V0MS5wMSksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCkpO2Vsc2UgaWYodGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlPSEwLHRoaXMuX29mZnNldDAucDEuZGlzdGFuY2UodGhpcy5fb2Zmc2V0MS5wMCk8dGhpcy5fZGlzdGFuY2UqaWkuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKXRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7ZWxzZXtpZih0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3I+MCl7Y29uc3QgdD1uZXcgZygodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQwLnAxLngrdGhpcy5fczEueCkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSksKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MC5wMS55K3RoaXMuX3MxLnkpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLl9zZWdMaXN0LmFkZFB0KHQpO2NvbnN0IGU9bmV3IGcoKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MS5wMC54K3RoaXMuX3MxLngpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDEucDAueSt0aGlzLl9zMS55KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5fc2VnTGlzdC5hZGRQdChlKX1lbHNlIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fczEpO3RoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCl9fWNyZWF0ZUNpcmNsZSh0KXtjb25zdCBlPW5ldyBnKHQueCt0aGlzLl9kaXN0YW5jZSx0LnkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGREaXJlY3RlZEZpbGxldCh0LDAsMipNYXRoLlBJLC0xLHRoaXMuX2Rpc3RhbmNlKSx0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpfWFkZEJldmVsSm9pbih0LGUpe3RoaXMuX3NlZ0xpc3QuYWRkUHQodC5wMSksdGhpcy5fc2VnTGlzdC5hZGRQdChlLnAwKX1pbml0KHQpe3RoaXMuX2Rpc3RhbmNlPXQsdGhpcy5fbWF4Q3VydmVTZWdtZW50RXJyb3I9dCooMS1NYXRoLmNvcyh0aGlzLl9maWxsZXRBbmdsZVF1YW50dW0vMikpLHRoaXMuX3NlZ0xpc3Q9bmV3IHNpLHRoaXMuX3NlZ0xpc3Quc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5fcHJlY2lzaW9uTW9kZWwpLHRoaXMuX3NlZ0xpc3Quc2V0TWluaW11bVZlcnRleERpc3RhbmNlKHQqaWkuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKX1hZGRDb2xsaW5lYXIodCl7dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLl9zMCx0aGlzLl9zMSx0aGlzLl9zMSx0aGlzLl9zMiksdGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk+PTImJih0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1qcy5KT0lOX0JFVkVMfHx0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1qcy5KT0lOX01JVFJFPyh0JiZ0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCkpOnRoaXMuYWRkQ29ybmVyRmlsbGV0KHRoaXMuX3MxLHRoaXMuX29mZnNldDAucDEsdGhpcy5fb2Zmc2V0MS5wMCx2LkNMT0NLV0lTRSx0aGlzLl9kaXN0YW5jZSkpfWNsb3NlUmluZygpe3RoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCl9aGFzTmFycm93Q29uY2F2ZUFuZ2xlKCl7cmV0dXJuIHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZX1nZXRDbGFzcygpe3JldHVybiBpaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbWF4Q3VydmVTZWdtZW50RXJyb3I9MCx0aGlzLl9maWxsZXRBbmdsZVF1YW50dW09bnVsbCx0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPTEsdGhpcy5fc2VnTGlzdD1udWxsLHRoaXMuX2Rpc3RhbmNlPTAsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9idWZQYXJhbXM9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX3MwPW51bGwsdGhpcy5fczE9bnVsbCx0aGlzLl9zMj1udWxsLHRoaXMuX3NlZzA9bmV3IGVlLHRoaXMuX3NlZzE9bmV3IGVlLHRoaXMuX29mZnNldDA9bmV3IGVlLHRoaXMuX29mZnNldDE9bmV3IGVlLHRoaXMuX3NpZGU9MCx0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9idWZQYXJhbXM9ZSx0aGlzLl9saT1uZXcgdGUsdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtPU1hdGguUEkvMi9lLmdldFF1YWRyYW50U2VnbWVudHMoKSxlLmdldFF1YWRyYW50U2VnbWVudHMoKT49OCYmZS5nZXRKb2luU3R5bGUoKT09PWpzLkpPSU5fUk9VTkQmJih0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPWlpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SKSx0aGlzLmluaXQobil9LGlpLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SPS4wMDEsaWkuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPS4wMDEsaWkuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPTFlLTYsaWkuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1I9ODA7Y2xhc3Mgcml7Y29uc3RydWN0b3IoKXtyaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb3B5Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT1uZXcgZyh0W25dKTtyZXR1cm4gZX1nZXRPZmZzZXRDdXJ2ZSh0LGUpe2lmKHRoaXMuX2Rpc3RhbmNlPWUsMD09PWUpcmV0dXJuIG51bGw7Y29uc3Qgbj1lPDAscz1NYXRoLmFicyhlKSxpPXRoaXMuZ2V0U2VnR2VuKHMpO3QubGVuZ3RoPD0xP3RoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxpKTp0aGlzLmNvbXB1dGVPZmZzZXRDdXJ2ZSh0LG4saSk7Y29uc3Qgcj1pLmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIG4mJlgucmV2ZXJzZShyKSxyfWNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKHQsZSxuKXtjb25zdCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2lmKGUpe24uYWRkU2VnbWVudHModCwhMCk7Y29uc3QgZT1uaS5zaW1wbGlmeSh0LC1zKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbaV0sZVtpLTFdLFBuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PWktMjt0Pj0wO3QtLSluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfWVsc2V7bi5hZGRTZWdtZW50cyh0LCExKTtjb25zdCBlPW5pLnNpbXBsaWZ5KHQscyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlWzBdLGVbMV0sUG4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfW4uYWRkTGFzdFNlZ21lbnQoKSxuLmNsb3NlUmluZygpfWNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLG4pe2xldCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2U9PT1Qbi5SSUdIVCYmKHM9LXMpO2NvbnN0IGk9bmkuc2ltcGxpZnkodCxzKSxyPWkubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGlbci0xXSxpWzBdLGUpO2ZvcihsZXQgdD0xO3Q8PXI7dCsrKXtjb25zdCBlPTEhPT10O24uYWRkTmV4dFNlZ21lbnQoaVt0XSxlKX1uLmNsb3NlUmluZygpfWNvbXB1dGVMaW5lQnVmZmVyQ3VydmUodCxlKXtjb25zdCBuPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpLHM9bmkuc2ltcGxpZnkodCxuKSxpPXMubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKHNbMF0sc1sxXSxQbi5MRUZUKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyllLmFkZE5leHRTZWdtZW50KHNbdF0sITApO2UuYWRkTGFzdFNlZ21lbnQoKSxlLmFkZExpbmVFbmRDYXAoc1tpLTFdLHNbaV0pO2NvbnN0IHI9bmkuc2ltcGxpZnkodCwtbiksbz1yLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhyW29dLHJbby0xXSxQbi5MRUZUKTtmb3IobGV0IHQ9by0yO3Q+PTA7dC0tKWUuYWRkTmV4dFNlZ21lbnQoclt0XSwhMCk7ZS5hZGRMYXN0U2VnbWVudCgpLGUuYWRkTGluZUVuZENhcChyWzFdLHJbMF0pLGUuY2xvc2VSaW5nKCl9Y29tcHV0ZVBvaW50Q3VydmUodCxlKXtzd2l0Y2godGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UganMuQ0FQX1JPVU5EOmUuY3JlYXRlQ2lyY2xlKHQpO2JyZWFrO2Nhc2UganMuQ0FQX1NRVUFSRTplLmNyZWF0ZVNxdWFyZSh0KX19Z2V0TGluZUN1cnZlKHQsZSl7aWYodGhpcy5fZGlzdGFuY2U9ZSxlPDAmJiF0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKXJldHVybiBudWxsO2lmKDA9PT1lKXJldHVybiBudWxsO2NvbnN0IG49TWF0aC5hYnMoZSkscz10aGlzLmdldFNlZ0dlbihuKTtpZih0Lmxlbmd0aDw9MSl0aGlzLmNvbXB1dGVQb2ludEN1cnZlKHRbMF0scyk7ZWxzZSBpZih0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKXtjb25zdCBuPWU8MDt0aGlzLmNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKHQsbixzKX1lbHNlIHRoaXMuY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSh0LHMpO3JldHVybiBzLmdldENvb3JkaW5hdGVzKCl9Z2V0QnVmZmVyUGFyYW1ldGVycygpe3JldHVybiB0aGlzLl9idWZQYXJhbXN9c2ltcGxpZnlUb2xlcmFuY2UodCl7cmV0dXJuIHQqdGhpcy5fYnVmUGFyYW1zLmdldFNpbXBsaWZ5RmFjdG9yKCl9Z2V0UmluZ0N1cnZlKHQsZSxuKXtpZih0aGlzLl9kaXN0YW5jZT1uLHQubGVuZ3RoPD0yKXJldHVybiB0aGlzLmdldExpbmVDdXJ2ZSh0LG4pO2lmKDA9PT1uKXJldHVybiByaS5jb3B5Q29vcmRpbmF0ZXModCk7Y29uc3Qgcz10aGlzLmdldFNlZ0dlbihuKTtyZXR1cm4gdGhpcy5jb21wdXRlUmluZ0J1ZmZlckN1cnZlKHQsZSxzKSxzLmdldENvb3JkaW5hdGVzKCl9Y29tcHV0ZU9mZnNldEN1cnZlKHQsZSxuKXtjb25zdCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2lmKGUpe2NvbnN0IGU9bmkuc2ltcGxpZnkodCwtcyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlW2ldLGVbaS0xXSxQbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD1pLTI7dD49MDt0LS0pbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1lbHNle2NvbnN0IGU9bmkuc2ltcGxpZnkodCxzKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbMF0sZVsxXSxQbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9bi5hZGRMYXN0U2VnbWVudCgpfWdldFNlZ0dlbih0KXtyZXR1cm4gbmV3IGlpKHRoaXMuX3ByZWNpc2lvbk1vZGVsLHRoaXMuX2J1ZlBhcmFtcyx0KX1nZXRDbGFzcygpe3JldHVybiByaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZGlzdGFuY2U9MCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2J1ZlBhcmFtcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fYnVmUGFyYW1zPWV9O2NsYXNzIG9pe2NvbnN0cnVjdG9yKCl7b2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5kU3RhYmJlZFNlZ21lbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHg7Zm9yKGxldCBuPXRoaXMuX3N1YmdyYXBocy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMuZ2V0RW52ZWxvcGUoKTt0Lnk8aS5nZXRNaW5ZKCl8fHQueT5pLmdldE1heFkoKXx8dGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQscy5nZXREaXJlY3RlZEVkZ2VzKCksZSl9cmV0dXJuIGV9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoXyhhcmd1bWVudHNbMl0sbSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBqbil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1lLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgaT0wO2k8cy5sZW5ndGgtMTtpKyspe2lmKHRoaXMuX3NlZy5wMD1zW2ldLHRoaXMuX3NlZy5wMT1zW2krMV0sdGhpcy5fc2VnLnAwLnk+dGhpcy5fc2VnLnAxLnkmJnRoaXMuX3NlZy5yZXZlcnNlKCksTWF0aC5tYXgodGhpcy5fc2VnLnAwLngsdGhpcy5fc2VnLnAxLngpPHQueCljb250aW51ZTtpZih0aGlzLl9zZWcuaXNIb3Jpem9udGFsKCkpY29udGludWU7aWYodC55PHRoaXMuX3NlZy5wMC55fHx0Lnk+dGhpcy5fc2VnLnAxLnkpY29udGludWU7aWYodi5pbmRleCh0aGlzLl9zZWcucDAsdGhpcy5fc2VnLnAxLHQpPT09di5SSUdIVCljb250aW51ZTtsZXQgcj1lLmdldERlcHRoKFBuLkxFRlQpO3RoaXMuX3NlZy5wMC5lcXVhbHMoc1tpXSl8fChyPWUuZ2V0RGVwdGgoUG4uUklHSFQpKTtjb25zdCBvPW5ldyBsaSh0aGlzLl9zZWcscik7bi5hZGQobyl9fWVsc2UgaWYoXyhhcmd1bWVudHNbMl0sbSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmXyhhcmd1bWVudHNbMV0sbSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz1lLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBlPXMubmV4dCgpO2UuaXNGb3J3YXJkKCkmJnRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0LGUsbil9fX1nZXREZXB0aCh0KXtjb25zdCBlPXRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0KTtyZXR1cm4gMD09PWUuc2l6ZSgpPzA6RWUubWluKGUpLl9sZWZ0RGVwdGh9Z2V0Q2xhc3MoKXtyZXR1cm4gb2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGxpe2NvbnN0cnVjdG9yKCl7bGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O2lmKHRoaXMuX3Vwd2FyZFNlZy5taW5YKCk+PWUuX3Vwd2FyZFNlZy5tYXhYKCkpcmV0dXJuIDE7aWYodGhpcy5fdXB3YXJkU2VnLm1heFgoKTw9ZS5fdXB3YXJkU2VnLm1pblgoKSlyZXR1cm4tMTtsZXQgbj10aGlzLl91cHdhcmRTZWcub3JpZW50YXRpb25JbmRleChlLl91cHdhcmRTZWcpO3JldHVybiAwIT09bj9uOihuPS0xKmUuX3Vwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KHRoaXMuX3Vwd2FyZFNlZyksMCE9PW4/bjp0aGlzLl91cHdhcmRTZWcuY29tcGFyZVRvKGUuX3Vwd2FyZFNlZykpfWNvbXBhcmVYKHQsZSl7Y29uc3Qgbj10LnAwLmNvbXBhcmVUbyhlLnAwKTtyZXR1cm4gMCE9PW4/bjp0LnAxLmNvbXBhcmVUbyhlLnAxKX10b1N0cmluZygpe3JldHVybiB0aGlzLl91cHdhcmRTZWcudG9TdHJpbmcoKX1nZXRDbGFzcygpe3JldHVybiBsaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fWxpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3Vwd2FyZFNlZz1udWxsLHRoaXMuX2xlZnREZXB0aD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3Vwd2FyZFNlZz1uZXcgZWUodCksdGhpcy5fbGVmdERlcHRoPWV9LG9pLkRlcHRoU2VnbWVudD1saSxvaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zdWJncmFwaHM9bnVsbCx0aGlzLl9zZWc9bmV3IGVlO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3N1YmdyYXBocz10fTtjbGFzcyBhaXtjb25zdHJ1Y3Rvcigpe2FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkUG9pbnQodCl7aWYodGhpcy5fZGlzdGFuY2U8PTApcmV0dXJuIG51bGw7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCksbj10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5fZGlzdGFuY2UpO3RoaXMuYWRkQ3VydmUobixuZS5FWFRFUklPUixuZS5JTlRFUklPUil9YWRkUG9seWdvbih0KXtsZXQgZT10aGlzLl9kaXN0YW5jZSxuPVBuLkxFRlQ7dGhpcy5fZGlzdGFuY2U8MCYmKGU9LXRoaXMuX2Rpc3RhbmNlLG49UG4uUklHSFQpO2NvbnN0IHM9dC5nZXRFeHRlcmlvclJpbmcoKSxpPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHMocy5nZXRDb29yZGluYXRlcygpKTtpZih0aGlzLl9kaXN0YW5jZTwwJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShzLHRoaXMuX2Rpc3RhbmNlKSlyZXR1cm4gbnVsbDtpZih0aGlzLl9kaXN0YW5jZTw9MCYmaS5sZW5ndGg8MylyZXR1cm4gbnVsbDt0aGlzLmFkZFBvbHlnb25SaW5nKGksZSxuLG5lLkVYVEVSSU9SLG5lLklOVEVSSU9SKTtmb3IobGV0IHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXtjb25zdCBpPXQuZ2V0SW50ZXJpb3JSaW5nTihzKSxyPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHMoaS5nZXRDb29yZGluYXRlcygpKTt0aGlzLl9kaXN0YW5jZT4wJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShpLC10aGlzLl9kaXN0YW5jZSl8fHRoaXMuYWRkUG9seWdvblJpbmcocixlLFBuLm9wcG9zaXRlKG4pLG5lLklOVEVSSU9SLG5lLkVYVEVSSU9SKX19aXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkodCxlKXtjb25zdCBuPW5ldyByZSh0WzBdLHRbMV0sdFsyXSkscz1uLmluQ2VudHJlKCk7cmV0dXJuIEQucG9pbnRUb1NlZ21lbnQocyxuLnAwLG4ucDEpPE1hdGguYWJzKGUpfWFkZExpbmVTdHJpbmcodCl7aWYodGhpcy5fZGlzdGFuY2U8PTAmJiF0aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0QnVmZmVyUGFyYW1ldGVycygpLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDtjb25zdCBlPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKSxuPXRoaXMuX2N1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLl9kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZShuLG5lLkVYVEVSSU9SLG5lLklOVEVSSU9SKX1hZGRDdXJ2ZSh0LGUsbil7aWYobnVsbD09PXR8fHQubGVuZ3RoPDIpcmV0dXJuIG51bGw7Y29uc3Qgcz1uZXcgRnModCxuZXcgRm4oMCxuZS5CT1VOREFSWSxlLG4pKTt0aGlzLl9jdXJ2ZUxpc3QuYWRkKHMpfWdldEN1cnZlcygpe3JldHVybiB0aGlzLmFkZCh0aGlzLl9pbnB1dEdlb20pLHRoaXMuX2N1cnZlTGlzdH1hZGRQb2x5Z29uUmluZyh0LGUsbixzLGkpe2lmKDA9PT1lJiZ0Lmxlbmd0aDxEdC5NSU5JTVVNX1ZBTElEX1NJWkUpcmV0dXJuIG51bGw7bGV0IHI9cyxvPWk7dC5sZW5ndGg+PUR0Lk1JTklNVU1fVkFMSURfU0laRSYmdi5pc0NDVyh0KSYmKHI9aSxvPXMsbj1Qbi5vcHBvc2l0ZShuKSk7Y29uc3QgbD10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0UmluZ0N1cnZlKHQsbixlKTt0aGlzLmFkZEN1cnZlKGwscixvKX1hZGQodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIGJ0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZExpbmVTdHJpbmcodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGRQb2ludCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBNdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEF0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIF90KSl0aHJvdyBuZXcgWih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fWlzRXJvZGVkQ29tcGxldGVseSh0LGUpe2NvbnN0IG49dC5nZXRDb29yZGluYXRlcygpO2lmKG4ubGVuZ3RoPDQpcmV0dXJuIGU8MDtpZig0PT09bi5sZW5ndGgpcmV0dXJuIHRoaXMuaXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkobixlKTtjb25zdCBzPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9TWF0aC5taW4ocy5nZXRIZWlnaHQoKSxzLmdldFdpZHRoKCkpO3JldHVybiBlPDAmJjIqTWF0aC5hYnMoZSk+aX1hZGRDb2xsZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO3RoaXMuYWRkKG4pfX1nZXRDbGFzcygpe3JldHVybiBhaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19YWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLl9jdXJ2ZUJ1aWxkZXI9bnVsbCx0aGlzLl9jdXJ2ZUxpc3Q9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5fZGlzdGFuY2U9ZSx0aGlzLl9jdXJ2ZUJ1aWxkZXI9bn07Y2xhc3MgY2l7Y29uc3RydWN0b3IoKXtjaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE5leHRDVyh0KXt0aGlzLmdldEVkZ2VzKCk7Y29uc3QgZT10aGlzLl9lZGdlTGlzdC5pbmRleE9mKHQpO2xldCBuPWUtMTtyZXR1cm4gMD09PWUmJihuPXRoaXMuX2VkZ2VMaXN0LnNpemUoKS0xKSx0aGlzLl9lZGdlTGlzdC5nZXQobil9cHJvcGFnYXRlU2lkZUxhYmVscyh0KXtsZXQgZT1uZS5OT05FO2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLmdldExhYmVsKCk7cy5pc0FyZWEodCkmJnMuZ2V0TG9jYXRpb24odCxQbi5MRUZUKSE9PW5lLk5PTkUmJihlPXMuZ2V0TG9jYXRpb24odCxQbi5MRUZUKSl9aWYoZT09PW5lLk5PTkUpcmV0dXJuIG51bGw7bGV0IG49ZTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXMuZ2V0TGFiZWwoKTtpZihpLmdldExvY2F0aW9uKHQsUG4uT04pPT09bmUuTk9ORSYmaS5zZXRMb2NhdGlvbih0LFBuLk9OLG4pLGkuaXNBcmVhKHQpKXtjb25zdCBlPWkuZ2V0TG9jYXRpb24odCxQbi5MRUZUKSxyPWkuZ2V0TG9jYXRpb24odCxQbi5SSUdIVCk7aWYociE9PW5lLk5PTkUpe2lmKHIhPT1uKXRocm93IG5ldyBXbihcInNpZGUgbG9jYXRpb24gY29uZmxpY3RcIixzLmdldENvb3JkaW5hdGUoKSk7ZT09PW5lLk5PTkUmJnUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlIChhdCBcIitzLmdldENvb3JkaW5hdGUoKStcIilcIiksbj1lfWVsc2UgdS5pc1RydWUoaS5nZXRMb2NhdGlvbih0LFBuLkxFRlQpPT09bmUuTk9ORSxcImZvdW5kIHNpbmdsZSBudWxsIHNpZGVcIiksaS5zZXRMb2NhdGlvbih0LFBuLlJJR0hULG4pLGkuc2V0TG9jYXRpb24odCxQbi5MRUZULG4pfX19Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9dGhpcy5pdGVyYXRvcigpO3JldHVybiB0Lmhhc05leHQoKT90Lm5leHQoKS5nZXRDb29yZGluYXRlKCk6bnVsbH1wcmludCh0KXtPLm91dC5wcmludGxuKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXNBcmVhTGFiZWxzQ29uc2lzdGVudCh0KXtyZXR1cm4gdGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0LmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50KDApfWNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQodCl7Y29uc3QgZT10aGlzLmdldEVkZ2VzKCk7aWYoZS5zaXplKCk8PTApcmV0dXJuITA7Y29uc3Qgbj1lLnNpemUoKS0xLHM9ZS5nZXQobikuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LFBuLkxFRlQpO3UuaXNUcnVlKHMhPT1uZS5OT05FLFwiRm91bmQgdW5sYWJlbGxlZCBhcmVhIGVkZ2VcIik7bGV0IGk9cztmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRMYWJlbCgpO3UuaXNUcnVlKG4uaXNBcmVhKHQpLFwiRm91bmQgbm9uLWFyZWEgZWRnZVwiKTtjb25zdCBzPW4uZ2V0TG9jYXRpb24odCxQbi5MRUZUKSxyPW4uZ2V0TG9jYXRpb24odCxQbi5SSUdIVCk7aWYocz09PXIpcmV0dXJuITE7aWYociE9PWkpcmV0dXJuITE7aT1zfXJldHVybiEwfWZpbmRJbmRleCh0KXt0aGlzLml0ZXJhdG9yKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlTGlzdC5zaXplKCk7ZSsrKXtpZih0aGlzLl9lZGdlTGlzdC5nZXQoZSk9PT10KXJldHVybiBlfXJldHVybi0xfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoKS5pdGVyYXRvcigpfWdldEVkZ2VzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9lZGdlTGlzdCYmKHRoaXMuX2VkZ2VMaXN0PW5ldyB4KHRoaXMuX2VkZ2VNYXAudmFsdWVzKCkpKSx0aGlzLl9lZGdlTGlzdH1nZXRMb2NhdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bdF09PT1uZS5OT05FJiYodGhpcy5fcHRJbkFyZWFMb2NhdGlvblt0XT1aZS5sb2NhdGUoZSxuW3RdLmdldEdlb21ldHJ5KCkpKSx0aGlzLl9wdEluQXJlYUxvY2F0aW9uW3RdfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdzt0LmFwcGVuZChcIkVkZ2VFbmRTdGFyOiAgIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKSx0LmFwcGVuZChcIlxcblwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0LmFwcGVuZChuKSx0LmFwcGVuZChcIlxcblwiKX1yZXR1cm4gdC50b1N0cmluZygpfWNvbXB1dGVFZGdlRW5kTGFiZWxzKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5jb21wdXRlTGFiZWwodCl9fWNvbXB1dGVMYWJlbGxpbmcodCl7dGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0WzBdLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDApLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygxKTtjb25zdCBlPVshMSwhMV07Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkuZ2V0TGFiZWwoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKW4uaXNMaW5lKHQpJiZuLmdldExvY2F0aW9uKHQpPT09bmUuQk9VTkRBUlkmJihlW3RdPSEwKX1mb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMuZ2V0TGFiZWwoKTtmb3IobGV0IG49MDtuPDI7bisrKWlmKGkuaXNBbnlOdWxsKG4pKXtsZXQgcj1uZS5OT05FO2lmKGVbbl0pcj1uZS5FWFRFUklPUjtlbHNle2NvbnN0IGU9cy5nZXRDb29yZGluYXRlKCk7cj10aGlzLmdldExvY2F0aW9uKG4sZSx0KX1pLnNldEFsbExvY2F0aW9uc0lmTnVsbChuLHIpfX19Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX2VkZ2VNYXAuc2l6ZSgpfWluc2VydEVkZ2VFbmQodCxlKXt0aGlzLl9lZGdlTWFwLnB1dCh0LGUpLHRoaXMuX2VkZ2VMaXN0PW51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gY2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2VkZ2VNYXA9bmV3IHJ0LHRoaXMuX2VkZ2VMaXN0PW51bGwsdGhpcy5fcHRJbkFyZWFMb2NhdGlvbj1bbmUuTk9ORSxuZS5OT05FXX07Y2xhc3MgaGkgZXh0ZW5kcyBjaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksaGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpe3RoaXMuZ2V0UmVzdWx0QXJlYUVkZ2VzKCk7bGV0IHQ9bnVsbCxlPW51bGwsbj10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7Zm9yKGxldCBzPTA7czx0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpO3MrKyl7Y29uc3QgaT10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KHMpLHI9aS5nZXRTeW0oKTtpZihpLmdldExhYmVsKCkuaXNBcmVhKCkpc3dpdGNoKG51bGw9PT10JiZpLmlzSW5SZXN1bHQoKSYmKHQ9aSksbil7Y2FzZSB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoIXIuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2U9cixuPXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc7YnJlYWs7Y2FzZSB0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HOmlmKCFpLmlzSW5SZXN1bHQoKSljb250aW51ZTtlLnNldE5leHQoaSksbj10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkd9fWlmKG49PT10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HKXtpZihudWxsPT09dCl0aHJvdyBuZXcgV24oXCJubyBvdXRnb2luZyBkaXJFZGdlIGZvdW5kXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO3UuaXNUcnVlKHQuaXNJblJlc3VsdCgpLFwidW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlXCIpLGUuc2V0TmV4dCh0KX19aW5zZXJ0KHQpe2NvbnN0IGU9dDt0aGlzLmluc2VydEVkZ2VFbmQoZSxlKX1nZXRSaWdodG1vc3RFZGdlKCl7Y29uc3QgdD10aGlzLmdldEVkZ2VzKCksZT10LnNpemUoKTtpZihlPDEpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldCgwKTtpZigxPT09ZSlyZXR1cm4gbjtjb25zdCBzPXQuZ2V0KGUtMSksaT1uLmdldFF1YWRyYW50KCkscj1zLmdldFF1YWRyYW50KCk7cmV0dXJuIEluLmlzTm9ydGhlcm4oaSkmJkluLmlzTm9ydGhlcm4ocik/bjpJbi5pc05vcnRoZXJuKGkpfHxJbi5pc05vcnRoZXJuKHIpPzAhPT1uLmdldER5KCk/bjowIT09cy5nZXREeSgpP3M6KHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCB0d28gaG9yaXpvbnRhbCBlZGdlcyBpbmNpZGVudCBvbiBub2RlXCIpLG51bGwpOnN9cHJpbnQodCl7Ty5vdXQucHJpbnRsbihcIkRpcmVjdGVkRWRnZVN0YXI6IFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0LnByaW50KFwib3V0IFwiKSxuLnByaW50KHQpLHQucHJpbnRsbigpLHQucHJpbnQoXCJpbiBcIiksbi5nZXRTeW0oKS5wcmludCh0KSx0LnByaW50bG4oKX19Z2V0UmVzdWx0QXJlYUVkZ2VzKCl7aWYobnVsbCE9PXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdClyZXR1cm4gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0O3RoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdD1uZXcgeDtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTsoZS5pc0luUmVzdWx0KCl8fGUuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKSYmdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LmFkZChlKX1yZXR1cm4gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0fXVwZGF0ZUxhYmVsbGluZyh0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRMYWJlbCgpO24uc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdC5nZXRMb2NhdGlvbigwKSksbi5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0LmdldExvY2F0aW9uKDEpKX19bGlua0FsbERpcmVjdGVkRWRnZXMoKXt0aGlzLmdldEVkZ2VzKCk7bGV0IHQ9bnVsbCxlPW51bGw7Zm9yKGxldCBuPXRoaXMuX2VkZ2VMaXN0LnNpemUoKS0xO24+PTA7bi0tKXtjb25zdCBzPXRoaXMuX2VkZ2VMaXN0LmdldChuKSxpPXMuZ2V0U3ltKCk7bnVsbD09PWUmJihlPWkpLG51bGwhPT10JiZpLnNldE5leHQodCksdD1zfWUuc2V0TmV4dCh0KX1jb21wdXRlRGVwdGhzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5maW5kSW5kZXgodCksbj10LmdldERlcHRoKFBuLkxFRlQpLHM9dC5nZXREZXB0aChQbi5SSUdIVCksaT10aGlzLmNvbXB1dGVEZXB0aHMoZSsxLHRoaXMuX2VkZ2VMaXN0LnNpemUoKSxuKTtpZih0aGlzLmNvbXB1dGVEZXB0aHMoMCxlLGkpIT09cyl0aHJvdyBuZXcgV24oXCJkZXB0aCBtaXNtYXRjaCBhdCBcIit0LmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz10O3M8ZTtzKyspe2NvbnN0IHQ9dGhpcy5fZWRnZUxpc3QuZ2V0KHMpO3Quc2V0RWRnZURlcHRocyhQbi5SSUdIVCxuKSxuPXQuZ2V0RGVwdGgoUG4uTEVGVCl9cmV0dXJuIG59fW1lcmdlU3ltTGFiZWxzKCl7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5nZXRMYWJlbCgpLm1lcmdlKGUuZ2V0U3ltKCkuZ2V0TGFiZWwoKSl9fWxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0KXtsZXQgZT1udWxsLG49bnVsbCxzPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztmb3IobGV0IGk9dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKS0xO2k+PTA7aS0tKXtjb25zdCByPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5nZXQoaSksbz1yLmdldFN5bSgpO3N3aXRjaChudWxsPT09ZSYmci5nZXRFZGdlUmluZygpPT09dCYmKGU9cikscyl7Y2FzZSB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoby5nZXRFZGdlUmluZygpIT09dCljb250aW51ZTtuPW8scz10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5fTElOS0lOR19UT19PVVRHT0lORzppZihyLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO24uc2V0TmV4dE1pbihyKSxzPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlOR319cz09PXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcmJih1LmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgZm9yIGZpcnN0IG91dGdvaW5nIGRpckVkZ2VcIiksdS5pc1RydWUoZS5nZXRFZGdlUmluZygpPT09dCxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxuLnNldE5leHRNaW4oZSkpfWdldE91dGdvaW5nRGVncmVlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmlzSW5SZXN1bHQoKSYmdCsrfXJldHVybiB0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT0wO2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5nZXRFZGdlUmluZygpPT09dCYmZSsrfXJldHVybiBlfX1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1maW5kQ292ZXJlZExpbmVFZGdlcygpe2xldCB0PW5lLk5PTkU7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldFN5bSgpO2lmKCFuLmlzTGluZUVkZ2UoKSl7aWYobi5pc0luUmVzdWx0KCkpe3Q9bmUuSU5URVJJT1I7YnJlYWt9aWYocy5pc0luUmVzdWx0KCkpe3Q9bmUuRVhURVJJT1I7YnJlYWt9fX1pZih0PT09bmUuTk9ORSlyZXR1cm4gbnVsbDtsZXQgZT10O2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRTeW0oKTtuLmlzTGluZUVkZ2UoKT9uLmdldEVkZ2UoKS5zZXRDb3ZlcmVkKGU9PT1uZS5JTlRFUklPUik6KG4uaXNJblJlc3VsdCgpJiYoZT1uZS5FWFRFUklPUikscy5pc0luUmVzdWx0KCkmJihlPW5lLklOVEVSSU9SKSl9fWNvbXB1dGVMYWJlbGxpbmcodCl7c3VwZXIuY29tcHV0ZUxhYmVsbGluZy5jYWxsKHRoaXMsdCksdGhpcy5fbGFiZWw9bmV3IEZuKG5lLk5PTkUpO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLmdldEVkZ2UoKS5nZXRMYWJlbCgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspe2NvbnN0IG49ZS5nZXRMb2NhdGlvbih0KTtuIT09bmUuSU5URVJJT1ImJm4hPT1uZS5CT1VOREFSWXx8dGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxuZS5JTlRFUklPUil9fX1nZXRDbGFzcygpe3JldHVybiBoaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0PW51bGwsdGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc9MSx0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HPTJ9O2NsYXNzIHVpIGV4dGVuZHMgS257Y29uc3RydWN0b3IoKXtzdXBlcigpLHVpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IGtuKHQsbmV3IGhpKX1nZXRDbGFzcygpe3JldHVybiB1aX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBnaXtjb25zdHJ1Y3Rvcigpe2dpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG9yaWVudGF0aW9uKHQpe3JldHVybiAxPT09WC5pbmNyZWFzaW5nRGlyZWN0aW9uKHQpfXN0YXRpYyBjb21wYXJlT3JpZW50ZWQodCxlLG4scyl7Y29uc3QgaT1lPzE6LTEscj1zPzE6LTEsbz1lP3QubGVuZ3RoOi0xLGw9cz9uLmxlbmd0aDotMTtsZXQgYT1lPzA6dC5sZW5ndGgtMSxjPXM/MDpuLmxlbmd0aC0xO2Zvcig7Oyl7Y29uc3QgZT10W2FdLmNvbXBhcmVUbyhuW2NdKTtpZigwIT09ZSlyZXR1cm4gZTthKz1pLGMrPXI7Y29uc3Qgcz1hPT09byxoPWM9PT1sO2lmKHMmJiFoKXJldHVybi0xO2lmKCFzJiZoKXJldHVybiAxO2lmKHMmJmgpcmV0dXJuIDB9fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIGdpLmNvbXBhcmVPcmllbnRlZCh0aGlzLl9wdHMsdGhpcy5fb3JpZW50YXRpb24sZS5fcHRzLGUuX29yaWVudGF0aW9uKX1nZXRDbGFzcygpe3JldHVybiBnaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fWdpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0cz1udWxsLHRoaXMuX29yaWVudGF0aW9uPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHRzPXQsdGhpcy5fb3JpZW50YXRpb249Z2kub3JpZW50YXRpb24odCl9O2NsYXNzIGRpe2NvbnN0cnVjdG9yKCl7ZGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1wcmludCh0KXt0LnByaW50KFwiTVVMVElMSU5FU1RSSU5HICggXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10aGlzLl9lZGdlcy5nZXQoZSk7ZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KFwiKFwiKTtjb25zdCBzPW4uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPHMubGVuZ3RoO2UrKyllPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoc1tlXS54K1wiIFwiK3NbZV0ueSk7dC5wcmludGxuKFwiKVwiKX10LnByaW50KFwiKSAgXCIpfWFkZEFsbCh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSl9ZmluZEVkZ2VJbmRleCh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspaWYodGhpcy5fZWRnZXMuZ2V0KGUpLmVxdWFscyh0KSlyZXR1cm4gZTtyZXR1cm4tMX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfWdldCh0KXtyZXR1cm4gdGhpcy5fZWRnZXMuZ2V0KHQpfWZpbmRFcXVhbEVkZ2UodCl7Y29uc3QgZT1uZXcgZ2kodC5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gdGhpcy5fb2NhTWFwLmdldChlKX1hZGQodCl7dGhpcy5fZWRnZXMuYWRkKHQpO2NvbnN0IGU9bmV3IGdpKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5fb2NhTWFwLnB1dChlLHQpfWdldENsYXNzKCl7cmV0dXJuIGRpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1kaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9lZGdlcz1uZXcgeCx0aGlzLl9vY2FNYXA9bmV3IHJ0fTtjbGFzcyBfaXtjb25zdHJ1Y3Rvcigpe19pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7fWlzRG9uZSgpe31nZXRDbGFzcygpe3JldHVybiBfaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19X2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBmaXtjb25zdHJ1Y3Rvcigpe2ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzQWRqYWNlbnRTZWdtZW50cyh0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX1pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl7aWYodD09PW4mJjE9PT10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYoZmkuaXNBZGphY2VudFNlZ21lbnRzKGUscykpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXtjb25zdCBuPXQuc2l6ZSgpLTE7aWYoMD09PWUmJnM9PT1ufHwwPT09cyYmZT09PW4pcmV0dXJuITB9fXJldHVybiExfWdldFByb3BlckludGVyc2VjdGlvblBvaW50KCl7cmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50fWhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3BlckludGVyaW9yfWdldExpbmVJbnRlcnNlY3Rvcigpe3JldHVybiB0aGlzLl9saX1oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVyfXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyc2VjdGlvbnMrKyx0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucysrLHRoaXMuX2hhc0ludGVyaW9yPSEwKSx0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXx8KHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCx0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKSx0aGlzLl9saS5pc1Byb3BlcigpJiYodGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zKyssdGhpcy5faGFzUHJvcGVyPSEwLHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSEwKSkpfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuITF9aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJpb3J9Z2V0Q2xhc3MoKXtyZXR1cm4gZml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW19pXX19ZmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuX2hhc1Byb3Blcj0hMSx0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMSx0aGlzLl9oYXNJbnRlcmlvcj0hMSx0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5faXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dH07Y2xhc3MgcGl7Y29uc3RydWN0b3IoKXtwaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkZXB0aERlbHRhKHQpe2NvbnN0IGU9dC5nZXRMb2NhdGlvbigwLFBuLkxFRlQpLG49dC5nZXRMb2NhdGlvbigwLFBuLlJJR0hUKTtyZXR1cm4gZT09PW5lLklOVEVSSU9SJiZuPT09bmUuRVhURVJJT1I/MTplPT09bmUuRVhURVJJT1ImJm49PT1uZS5JTlRFUklPUj8tMTowfXN0YXRpYyBjb252ZXJ0U2VnU3RyaW5ncyh0KXtjb25zdCBlPW5ldyBIdCxuPW5ldyB4O2Zvcig7dC5oYXNOZXh0KCk7KXtjb25zdCBzPXQubmV4dCgpLGk9ZS5jcmVhdGVMaW5lU3RyaW5nKHMuZ2V0Q29vcmRpbmF0ZXMoKSk7bi5hZGQoaSl9cmV0dXJuIGUuYnVpbGRHZW9tZXRyeShuKX1zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsPXR9aW5zZXJ0VW5pcXVlRWRnZSh0KXtjb25zdCBlPXRoaXMuX2VkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe2NvbnN0IG49ZS5nZXRMYWJlbCgpO2xldCBzPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChzPW5ldyBGbih0LmdldExhYmVsKCkpLHMuZmxpcCgpKSxuLm1lcmdlKHMpO2NvbnN0IGk9cGkuZGVwdGhEZWx0YShzKSxyPWUuZ2V0RGVwdGhEZWx0YSgpK2k7ZS5zZXREZXB0aERlbHRhKHIpfWVsc2UgdGhpcy5fZWRnZUxpc3QuYWRkKHQpLHQuc2V0RGVwdGhEZWx0YShwaS5kZXB0aERlbHRhKHQuZ2V0TGFiZWwoKSkpfWJ1aWxkU3ViZ3JhcGhzKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPXQuZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpLHI9bmV3IG9pKG4pLmdldERlcHRoKGkpO3QuY29tcHV0ZURlcHRoKHIpLHQuZmluZFJlc3VsdEVkZ2VzKCksbi5hZGQodCksZS5hZGQodC5nZXREaXJlY3RlZEVkZ2VzKCksdC5nZXROb2RlcygpKX19Y3JlYXRlU3ViZ3JhcGhzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZighdC5pc1Zpc2l0ZWQoKSl7Y29uc3Qgbj1uZXcgUXM7bi5jcmVhdGUodCksZS5hZGQobil9fXJldHVybiBFZS5zb3J0KGUsRWUucmV2ZXJzZU9yZGVyKCkpLGV9Y3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCl9Z2V0Tm9kZXIodCl7aWYobnVsbCE9PXRoaXMuX3dvcmtpbmdOb2RlcilyZXR1cm4gdGhpcy5fd29ya2luZ05vZGVyO2NvbnN0IGU9bmV3IFlzLG49bmV3IHRlO3JldHVybiBuLnNldFByZWNpc2lvbk1vZGVsKHQpLGUuc2V0U2VnbWVudEludGVyc2VjdG9yKG5ldyBmaShuKSksZX1idWZmZXIodCxlKXtsZXQgbj10aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw7bnVsbD09PW4mJihuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCk7Y29uc3Qgcz1uZXcgcmkobix0aGlzLl9idWZQYXJhbXMpLGk9bmV3IGFpKHQsZSxzKS5nZXRDdXJ2ZXMoKTtpZihpLnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7dGhpcy5jb21wdXRlTm9kZWRFZGdlcyhpLG4pLHRoaXMuX2dyYXBoPW5ldyBabihuZXcgdWkpLHRoaXMuX2dyYXBoLmFkZEVkZ2VzKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpO2NvbnN0IHI9dGhpcy5jcmVhdGVTdWJncmFwaHModGhpcy5fZ3JhcGgpLG89bmV3IGVpKHRoaXMuX2dlb21GYWN0KTt0aGlzLmJ1aWxkU3ViZ3JhcGhzKHIsbyk7Y29uc3QgbD1vLmdldFBvbHlnb25zKCk7cmV0dXJuIGwuc2l6ZSgpPD0wP3RoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpOnRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkobCl9Y29tcHV0ZU5vZGVkRWRnZXModCxlKXtjb25zdCBuPXRoaXMuZ2V0Tm9kZXIoZSk7bi5jb21wdXRlTm9kZXModCk7Zm9yKGxldCB0PW4uZ2V0Tm9kZWRTdWJzdHJpbmdzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCk7aWYoMj09PW4ubGVuZ3RoJiZuWzBdLmVxdWFsczJEKG5bMV0pKWNvbnRpbnVlO2NvbnN0IHM9ZS5nZXREYXRhKCksaT1uZXcgVW4oZS5nZXRDb29yZGluYXRlcygpLG5ldyBGbihzKSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKGkpfX1zZXROb2Rlcih0KXt0aGlzLl93b3JraW5nTm9kZXI9dH1nZXRDbGFzcygpe3JldHVybiBwaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fYnVmUGFyYW1zPW51bGwsdGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fd29ya2luZ05vZGVyPW51bGwsdGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2VkZ2VMaXN0PW5ldyBkaTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9idWZQYXJhbXM9dH07Y2xhc3MgbWl7Y29uc3RydWN0b3IoKXttaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKGVbMF0sdGhpcy5fc2VnU3RyaW5ncyksdGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhlW2UubGVuZ3RoLTFdLHRoaXMuX3NlZ1N0cmluZ3MpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT1hcmd1bWVudHNbMV0uaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MTtlPG4ubGVuZ3RoLTE7ZSsrKWlmKG5bZV0uZXF1YWxzKHQpKXRocm93IG5ldyBjKFwiZm91bmQgZW5kcHQvaW50ZXJpb3IgcHQgaW50ZXJzZWN0aW9uIGF0IGluZGV4IFwiK2UrXCIgOnB0IFwiK3QpfX19Y2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKTt0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKGUsbil9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRDb29yZGluYXRlcygpLHM9ZS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGgtMTtpKyspZm9yKGxldCBuPTA7bjxzLmxlbmd0aC0xO24rKyl0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHQsaSxlLG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07aWYodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMuX2xpLmlzUHJvcGVyKCl8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5fbGksaSxyKXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLl9saSxvLGwpKSl0aHJvdyBuZXcgYyhcImZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYXQgXCIraStcIi1cIityK1wiIGFuZCBcIitvK1wiLVwiK2wpfX1jaGVja1ZhbGlkKCl7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpLHRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrQ29sbGFwc2VzKCl9Y2hlY2tDb2xsYXBzZXMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmNoZWNrQ29sbGFwc2VzKGUpfWVsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0yO2UrKyl0aGlzLmNoZWNrQ29sbGFwc2UodFtlXSx0W2UrMV0sdFtlKzJdKX19aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtzKyspe2NvbnN0IGk9dC5nZXRJbnRlcnNlY3Rpb24ocyk7aWYoIWkuZXF1YWxzKGUpJiYhaS5lcXVhbHMobikpcmV0dXJuITB9cmV0dXJuITF9Y2hlY2tDb2xsYXBzZSh0LGUsbil7aWYodC5lcXVhbHMobikpdGhyb3cgbmV3IGMoXCJmb3VuZCBub24tbm9kZWQgY29sbGFwc2UgYXQgXCIrbWkuZmFjdC5jcmVhdGVMaW5lU3RyaW5nKFt0LGUsbl0pKX1nZXRDbGFzcygpe3JldHVybiBtaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bmV3IHRlLHRoaXMuX3NlZ1N0cmluZ3M9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWdTdHJpbmdzPXR9LG1pLmZhY3Q9bmV3IEh0O2NsYXNzIHlpe2NvbnN0cnVjdG9yKCl7eWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnRlcnNlY3RzU2NhbGVkKHQsZSl7Y29uc3Qgbj1NYXRoLm1pbih0LngsZS54KSxzPU1hdGgubWF4KHQueCxlLngpLGk9TWF0aC5taW4odC55LGUueSkscj1NYXRoLm1heCh0LnksZS55KSxvPXRoaXMuX21heHg8bnx8dGhpcy5fbWlueD5zfHx0aGlzLl9tYXh5PGl8fHRoaXMuX21pbnk+cjtpZihvKXJldHVybiExO2NvbnN0IGw9dGhpcy5pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlKHQsZSk7cmV0dXJuIHUuaXNUcnVlKCEobyYmbCksXCJGb3VuZCBiYWQgZW52ZWxvcGUgdGVzdFwiKSxsfWluaXRDb3JuZXJzKHQpe3RoaXMuX21pbng9dC54LS41LHRoaXMuX21heHg9dC54Ky41LHRoaXMuX21pbnk9dC55LS41LHRoaXMuX21heHk9dC55Ky41LHRoaXMuX2Nvcm5lclswXT1uZXcgZyh0aGlzLl9tYXh4LHRoaXMuX21heHkpLHRoaXMuX2Nvcm5lclsxXT1uZXcgZyh0aGlzLl9taW54LHRoaXMuX21heHkpLHRoaXMuX2Nvcm5lclsyXT1uZXcgZyh0aGlzLl9taW54LHRoaXMuX21pbnkpLHRoaXMuX2Nvcm5lclszXT1uZXcgZyh0aGlzLl9tYXh4LHRoaXMuX21pbnkpfWludGVyc2VjdHModCxlKXtyZXR1cm4gMT09PXRoaXMuX3NjYWxlRmFjdG9yP3RoaXMuaW50ZXJzZWN0c1NjYWxlZCh0LGUpOih0aGlzLmNvcHlTY2FsZWQodCx0aGlzLl9wMFNjYWxlZCksdGhpcy5jb3B5U2NhbGVkKGUsdGhpcy5fcDFTY2FsZWQpLHRoaXMuaW50ZXJzZWN0c1NjYWxlZCh0aGlzLl9wMFNjYWxlZCx0aGlzLl9wMVNjYWxlZCkpfXNjYWxlKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqdGhpcy5fc2NhbGVGYWN0b3IpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fb3JpZ2luYWxQdH1jb3B5U2NhbGVkKHQsZSl7ZS54PXRoaXMuc2NhbGUodC54KSxlLnk9dGhpcy5zY2FsZSh0LnkpfWdldFNhZmVFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9zYWZlRW52KXtjb25zdCB0PXlpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1IvdGhpcy5fc2NhbGVGYWN0b3I7dGhpcy5fc2FmZUVudj1uZXcgTih0aGlzLl9vcmlnaW5hbFB0LngtdCx0aGlzLl9vcmlnaW5hbFB0LngrdCx0aGlzLl9vcmlnaW5hbFB0LnktdCx0aGlzLl9vcmlnaW5hbFB0LnkrdCl9cmV0dXJuIHRoaXMuX3NhZmVFbnZ9aW50ZXJzZWN0c1BpeGVsQ2xvc3VyZSh0LGUpe3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMF0sdGhpcy5fY29ybmVyWzFdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzFdLHRoaXMuX2Nvcm5lclsyXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsyXSx0aGlzLl9jb3JuZXJbM10pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbM10sdGhpcy5fY29ybmVyWzBdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSkpfWludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUodCxlKXtsZXQgbj0hMSxzPSExO3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMF0sdGhpcy5fY29ybmVyWzFdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMV0sdGhpcy5fY29ybmVyWzJdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKG49ITApLHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsyXSx0aGlzLl9jb3JuZXJbM10pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYocz0hMCksdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzNdLHRoaXMuX2Nvcm5lclswXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwoISghbnx8IXMpfHwoISF0LmVxdWFscyh0aGlzLl9wdCl8fCEhZS5lcXVhbHModGhpcy5fcHQpKSkpKSl9YWRkU25hcHBlZE5vZGUodCxlKXtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZShlKSxzPXQuZ2V0Q29vcmRpbmF0ZShlKzEpO3JldHVybiEhdGhpcy5pbnRlcnNlY3RzKG4scykmJih0LmFkZEludGVyc2VjdGlvbih0aGlzLmdldENvb3JkaW5hdGUoKSxlKSwhMCl9Z2V0Q2xhc3MoKXtyZXR1cm4geWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXlpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW51bGwsdGhpcy5fcHQ9bnVsbCx0aGlzLl9vcmlnaW5hbFB0PW51bGwsdGhpcy5fcHRTY2FsZWQ9bnVsbCx0aGlzLl9wMFNjYWxlZD1udWxsLHRoaXMuX3AxU2NhbGVkPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9taW54PW51bGwsdGhpcy5fbWF4eD1udWxsLHRoaXMuX21pbnk9bnVsbCx0aGlzLl9tYXh5PW51bGwsdGhpcy5fY29ybmVyPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuX3NhZmVFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtpZih0aGlzLl9vcmlnaW5hbFB0PXQsdGhpcy5fcHQ9dCx0aGlzLl9zY2FsZUZhY3Rvcj1lLHRoaXMuX2xpPXMsZTw9MCl0aHJvdyBuZXcgbihcIlNjYWxlIGZhY3RvciBtdXN0IGJlIG5vbi16ZXJvXCIpOzEhPT1lJiYodGhpcy5fcHQ9bmV3IGcodGhpcy5zY2FsZSh0LngpLHRoaXMuc2NhbGUodC55KSksdGhpcy5fcDBTY2FsZWQ9bmV3IGcsdGhpcy5fcDFTY2FsZWQ9bmV3IGcpLHRoaXMuaW5pdENvcm5lcnModGhpcy5fcHQpfSx5aS5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SPS43NTtjbGFzcyB4aXtjb25zdHJ1Y3Rvcigpe3hpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2VsZWN0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3QuZ2V0TGluZVNlZ21lbnQoZSx0aGlzLnNlbGVjdGVkU2VnbWVudCksdGhpcy5zZWxlY3QodGhpcy5zZWxlY3RlZFNlZ21lbnQpfX1nZXRDbGFzcygpe3JldHVybiB4aX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RlZFNlZ21lbnQ9bmV3IGVlfTtjbGFzcyBFaXtjb25zdHJ1Y3Rvcigpe0VpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c25hcCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zbmFwKHQsbnVsbCwtMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9dC5nZXRTYWZlRW52ZWxvcGUoKSxpPW5ldyBJaSh0LGUsbik7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHMsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19dmlzaXRJdGVtKHQpe3Quc2VsZWN0KHMsaSl9fSksaS5pc05vZGVBZGRlZCgpfX1nZXRDbGFzcygpe3JldHVybiBFaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgSWkgZXh0ZW5kcyB4aXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksSWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc05vZGVBZGRlZCgpe3JldHVybiB0aGlzLl9pc05vZGVBZGRlZH1zZWxlY3QoKXtpZighKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcXMpKXJldHVybiBzdXBlci5zZWxlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0Q29udGV4dCgpO2lmKG51bGwhPT10aGlzLl9wYXJlbnRFZGdlJiZuPT09dGhpcy5fcGFyZW50RWRnZSYmZT09PXRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXgpcmV0dXJuIG51bGw7dGhpcy5faXNOb2RlQWRkZWQ9dGhpcy5faG90UGl4ZWwuYWRkU25hcHBlZE5vZGUobixlKX19Z2V0Q2xhc3MoKXtyZXR1cm4gSWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUlpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2hvdFBpeGVsPW51bGwsdGhpcy5fcGFyZW50RWRnZT1udWxsLHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXg9bnVsbCx0aGlzLl9pc05vZGVBZGRlZD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9ob3RQaXhlbD10LHRoaXMuX3BhcmVudEVkZ2U9ZSx0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4PW59LEVpLkhvdFBpeGVsU25hcEFjdGlvbj1JaSxFaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2luZGV4PXR9O2NsYXNzIE5pe2NvbnN0cnVjdG9yKCl7TmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1wcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO2lmKHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSl7Zm9yKGxldCB0PTA7dDx0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTt0KyspdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zLmFkZCh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24odCkpO3QuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxzLDEpfX1pc0RvbmUoKXtyZXR1cm4hMX1nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zfWdldENsYXNzKCl7cmV0dXJuIE5pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltfaV19fU5pLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW51bGwsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnM9bmV3IHh9O2NsYXNzIENpe2NvbnN0cnVjdG9yKCl7Q2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jaGVja0NvcnJlY3RuZXNzKHQpe2NvbnN0IGU9RnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQpLG49bmV3IG1pKGUpO3RyeXtuLmNoZWNrVmFsaWQoKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBDKSl0aHJvdyB0O3QucHJpbnRTdGFja1RyYWNlKCl9fWdldE5vZGVkU3Vic3RyaW5ncygpe3JldHVybiBGcy5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5fbm9kZWRTZWdTdHJpbmdzKX1zbmFwUm91bmQodCxlKXtjb25zdCBuPXRoaXMuZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGUpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvblNuYXBzKG4pLHRoaXMuY29tcHV0ZVZlcnRleFNuYXBzKHQpfWZpbmRJbnRlcmlvckludGVyc2VjdGlvbnModCxlKXtjb25zdCBuPW5ldyBOaShlKTtyZXR1cm4gdGhpcy5fbm9kZXIuc2V0U2VnbWVudEludGVyc2VjdG9yKG4pLHRoaXMuX25vZGVyLmNvbXB1dGVOb2Rlcyh0KSxuLmdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpfWNvbXB1dGVWZXJ0ZXhTbmFwcygpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuY29tcHV0ZVZlcnRleFNuYXBzKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRnMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtjb25zdCBzPW5ldyB5aShlW25dLHRoaXMuX3NjYWxlRmFjdG9yLHRoaXMuX2xpKTt0aGlzLl9wb2ludFNuYXBwZXIuc25hcChzLHQsbikmJnQuYWRkSW50ZXJzZWN0aW9uKGVbbl0sbil9fX1jb21wdXRlTm9kZXModCl7dGhpcy5fbm9kZWRTZWdTdHJpbmdzPXQsdGhpcy5fbm9kZXI9bmV3IFlzLHRoaXMuX3BvaW50U25hcHBlcj1uZXcgRWkodGhpcy5fbm9kZXIuZ2V0SW5kZXgoKSksdGhpcy5zbmFwUm91bmQodCx0aGlzLl9saSl9Y29tcHV0ZUludGVyc2VjdGlvblNuYXBzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49bmV3IHlpKHQsdGhpcy5fc2NhbGVGYWN0b3IsdGhpcy5fbGkpO3RoaXMuX3BvaW50U25hcHBlci5zbmFwKG4pfX1nZXRDbGFzcygpe3JldHVybiBDaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVnNdfX1DaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wbT1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9ub2Rlcj1udWxsLHRoaXMuX3BvaW50U25hcHBlcj1udWxsLHRoaXMuX25vZGVkU2VnU3RyaW5ncz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BtPXQsdGhpcy5fbGk9bmV3IHRlLHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHQpLHRoaXMuX3NjYWxlRmFjdG9yPXQuZ2V0U2NhbGUoKX07Y2xhc3MgU2l7Y29uc3RydWN0b3IoKXtTaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBidWZmZXJPcCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IFNpKHQpLmdldFJlc3VsdEdlb21ldHJ5KGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgU2kodCk7cmV0dXJuIHMuc2V0UXVhZHJhbnRTZWdtZW50cyhuKSxzLmdldFJlc3VsdEdlb21ldHJ5KGUpfWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YganMmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG5ldyBTaSh0LG4pLmdldFJlc3VsdEdlb21ldHJ5KGUpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBTaSh0KTtyZXR1cm4gaS5zZXRRdWFkcmFudFNlZ21lbnRzKG4pLGkuc2V0RW5kQ2FwU3R5bGUocyksaS5nZXRSZXN1bHRHZW9tZXRyeShlKX19c3RhdGljIHByZWNpc2lvblNjYWxlRmFjdG9yKHQsZSxuKXtjb25zdCBzPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9TS5tYXgoTWF0aC5hYnMocy5nZXRNYXhYKCkpLE1hdGguYWJzKHMuZ2V0TWF4WSgpKSxNYXRoLmFicyhzLmdldE1pblgoKSksTWF0aC5hYnMocy5nZXRNaW5ZKCkpKSsyKihlPjA/ZTowKSxyPW4tTWF0aC50cnVuYyhNYXRoLmxvZyhpKS9NYXRoLmxvZygxMCkrMSk7cmV0dXJuIE1hdGgucG93KDEwLHIpfWJ1ZmZlckZpeGVkUHJlY2lzaW9uKHQpe2NvbnN0IGU9bmV3IGtzKG5ldyBDaShuZXcga3QoMSkpLHQuZ2V0U2NhbGUoKSksbj1uZXcgcGkodGhpcy5fYnVmUGFyYW1zKTtuLnNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCh0KSxuLnNldE5vZGVyKGUpLHRoaXMuX3Jlc3VsdEdlb21ldHJ5PW4uYnVmZmVyKHRoaXMuX2FyZ0dlb20sdGhpcy5fZGlzdGFuY2UpfWJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGxldCB0PVNpLk1BWF9QUkVDSVNJT05fRElHSVRTO3Q+PTA7dC0tKXt0cnl7dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKHQpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFduKSl0aHJvdyB0O3RoaXMuX3NhdmVFeGNlcHRpb249dH1pZihudWxsIT09dGhpcy5fcmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGx9dGhyb3cgdGhpcy5fc2F2ZUV4Y2VwdGlvbn1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1TaS5wcmVjaXNpb25TY2FsZUZhY3Rvcih0aGlzLl9hcmdHZW9tLHRoaXMuX2Rpc3RhbmNlLHQpLG49bmV3IGt0KGUpO3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24obil9fWNvbXB1dGVHZW9tZXRyeSgpe2lmKHRoaXMuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKSxudWxsIT09dGhpcy5fcmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLl9hcmdHZW9tLmdldEZhY3RvcnkoKS5nZXRQcmVjaXNpb25Nb2RlbCgpO3QuZ2V0VHlwZSgpPT09a3QuRklYRUQ/dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbih0KTp0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKX1zZXRRdWFkcmFudFNlZ21lbnRzKHQpe3RoaXMuX2J1ZlBhcmFtcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpfWJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uKCl7dHJ5e2NvbnN0IHQ9bmV3IHBpKHRoaXMuX2J1ZlBhcmFtcyk7dGhpcy5fcmVzdWx0R2VvbWV0cnk9dC5idWZmZXIodGhpcy5fYXJnR2VvbSx0aGlzLl9kaXN0YW5jZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgYykpdGhyb3cgdDt0aGlzLl9zYXZlRXhjZXB0aW9uPXR9fWdldFJlc3VsdEdlb21ldHJ5KHQpe3JldHVybiB0aGlzLl9kaXN0YW5jZT10LHRoaXMuY29tcHV0ZUdlb21ldHJ5KCksdGhpcy5fcmVzdWx0R2VvbWV0cnl9c2V0RW5kQ2FwU3R5bGUodCl7dGhpcy5fYnVmUGFyYW1zLnNldEVuZENhcFN0eWxlKHQpfWdldENsYXNzKCl7cmV0dXJuIFNpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1TaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9hcmdHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLl9idWZQYXJhbXM9bmV3IGpzLHRoaXMuX3Jlc3VsdEdlb21ldHJ5PW51bGwsdGhpcy5fc2F2ZUV4Y2VwdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9hcmdHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fYXJnR2VvbT10LHRoaXMuX2J1ZlBhcmFtcz1lfX0sU2kuQ0FQX1JPVU5EPWpzLkNBUF9ST1VORCxTaS5DQVBfQlVUVD1qcy5DQVBfRkxBVCxTaS5DQVBfRkxBVD1qcy5DQVBfRkxBVCxTaS5DQVBfU1FVQVJFPWpzLkNBUF9TUVVBUkUsU2kuTUFYX1BSRUNJU0lPTl9ESUdJVFM9MTI7dmFyIHdpPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEJ1ZmZlck9wOlNpLEJ1ZmZlclBhcmFtZXRlcnM6anN9KTtjbGFzcyBMaXtjb25zdHJ1Y3Rvcigpe0xpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbnNpZGVBcmVhKCl7cmV0dXJuIHRoaXMuX3NlZ0luZGV4PT09TGkuSU5TSURFX0FSRUF9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wdH1nZXRHZW9tZXRyeUNvbXBvbmVudCgpe3JldHVybiB0aGlzLl9jb21wb25lbnR9Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuX3NlZ0luZGV4fWdldENsYXNzKCl7cmV0dXJuIExpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1MaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9jb21wb25lbnQ9bnVsbCx0aGlzLl9zZWdJbmRleD1udWxsLHRoaXMuX3B0PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0xpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxMaS5JTlNJREVfQVJFQSxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9jb21wb25lbnQ9dCx0aGlzLl9zZWdJbmRleD1lLHRoaXMuX3B0PW59fSxMaS5JTlNJREVfQVJFQT0tMTtjbGFzcyBUaXtjb25zdHJ1Y3Rvcigpe1RpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldExvY2F0aW9ucyh0KXtjb25zdCBlPW5ldyB4O3JldHVybiB0LmFwcGx5KG5ldyBUaShlKSksZX1maWx0ZXIodCl7KHQgaW5zdGFuY2VvZiBQdHx8dCBpbnN0YW5jZW9mIFR0fHx0IGluc3RhbmNlb2YgYnQpJiZ0aGlzLl9sb2NhdGlvbnMuYWRkKG5ldyBMaSh0LDAsdC5nZXRDb29yZGluYXRlKCkpKX1nZXRDbGFzcygpe3JldHVybiBUaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ3RdfX1UaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9sb2NhdGlvbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sb2NhdGlvbnM9dH07Y2xhc3MgUml7Y29uc3RydWN0b3IoKXtSaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkaXN0YW5jZSh0LGUpe3JldHVybiBuZXcgUmkodCxlKS5kaXN0YW5jZSgpfXN0YXRpYyBpc1dpdGhpbkRpc3RhbmNlKHQsZSxuKXtyZXR1cm4hKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT5uKSYmbmV3IFJpKHQsZSxuKS5kaXN0YW5jZSgpPD1ufXN0YXRpYyBuZWFyZXN0UG9pbnRzKHQsZSl7cmV0dXJuIG5ldyBSaSh0LGUpLm5lYXJlc3RQb2ludHMoKX1jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMCx0KSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fZ2VvbVt0XTtpZihuLmdldERpbWVuc2lvbigpPDIpcmV0dXJuIG51bGw7Y29uc3Qgcz0xLXQsaT1OZS5nZXRQb2x5Z29ucyhuKTtpZihpLnNpemUoKT4wKXtjb25zdCBuPVRpLmdldExvY2F0aW9ucyh0aGlzLl9nZW9tW3NdKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKG4saSxlKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bc109ZVswXSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW3RdPWVbMV0sbnVsbH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZfKGFyZ3VtZW50c1swXSxtKSYmXyhhcmd1bWVudHNbMV0sbSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKWlmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoaSxlLmdldCh0KSxuKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMaSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBidCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz10LmdldENvb3JkaW5hdGUoKTtpZihuZS5FWFRFUklPUiE9PXRoaXMuX3B0TG9jYXRvci5sb2NhdGUocyxlKSlyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2U9MCxuWzBdPXQsblsxXT1uZXcgTGkoZSxzKSxudWxsfX1jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoaSxzLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fWNvbXB1dGVGYWNldERpc3RhbmNlKCl7Y29uc3QgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxlPXhlLmdldExpbmVzKHRoaXMuX2dlb21bMF0pLG49eGUuZ2V0TGluZXModGhpcy5fZ2VvbVsxXSkscz1JZS5nZXRQb2ludHModGhpcy5fZ2VvbVswXSksaT1JZS5nZXRQb2ludHModGhpcy5fZ2VvbVsxXSk7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXMoZSxuLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhlLGksdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKG4scyx0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITApLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzKHMsaSx0KSx2b2lkIHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSkpKSl9bmVhcmVzdExvY2F0aW9ucygpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb259dXBkYXRlTWluRGlzdGFuY2UodCxlKXtpZihudWxsPT09dFswXSlyZXR1cm4gbnVsbDtlPyh0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMV0sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzBdKToodGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXT10WzBdLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV09dFsxXSl9bmVhcmVzdFBvaW50cygpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLFt0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdLmdldENvb3JkaW5hdGUoKV19Y29tcHV0ZU1pbkRpc3RhbmNlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKG51bGwhPT10aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uKXJldHVybiBudWxsO2lmKHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb249bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVGYWNldERpc3RhbmNlKCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFB0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5fbWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGUoKTtmb3IobGV0IHI9MDtyPHMubGVuZ3RoLTE7cisrKXtjb25zdCBvPUQucG9pbnRUb1NlZ21lbnQoaSxzW3JdLHNbcisxXSk7aWYobzx0aGlzLl9taW5EaXN0YW5jZSl7dGhpcy5fbWluRGlzdGFuY2U9bztjb25zdCBsPW5ldyBlZShzW3JdLHNbcisxXSkuY2xvc2VzdFBvaW50KGkpO25bMF09bmV3IExpKHQscixsKSxuWzFdPW5ldyBMaShlLDAsaSl9aWYodGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgVHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLl9taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHI9MDtyPHMubGVuZ3RoLTE7cisrKWZvcihsZXQgbz0wO288aS5sZW5ndGgtMTtvKyspe2NvbnN0IGw9RC5zZWdtZW50VG9TZWdtZW50KHNbcl0sc1tyKzFdLGlbb10saVtvKzFdKTtpZihsPHRoaXMuX21pbkRpc3RhbmNlKXt0aGlzLl9taW5EaXN0YW5jZT1sO2NvbnN0IGE9bmV3IGVlKHNbcl0sc1tyKzFdKSxjPW5ldyBlZShpW29dLGlbbysxXSksaD1hLmNsb3Nlc3RQb2ludHMoYyk7blswXT1uZXcgTGkodCxyLGhbMF0pLG5bMV09bmV3IExpKGUsbyxoWzFdKX1pZih0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX1jb21wdXRlTWluRGlzdGFuY2VQb2ludHModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPWUuZ2V0KHQpLHI9aS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2Uocy5nZXRDb29yZGluYXRlKCkpO2lmKHI8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9taW5EaXN0YW5jZT1yLG5bMF09bmV3IExpKGksMCxpLmdldENvb3JkaW5hdGUoKSksblsxXT1uZXcgTGkocywwLHMuZ2V0Q29vcmRpbmF0ZSgpKSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19ZGlzdGFuY2UoKXtpZihudWxsPT09dGhpcy5fZ2VvbVswXXx8bnVsbD09PXRoaXMuX2dlb21bMV0pdGhyb3cgbmV3IG4oXCJudWxsIGdlb21ldHJpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIHRoaXMuX2dlb21bMF0uaXNFbXB0eSgpfHx0aGlzLl9nZW9tWzFdLmlzRW1wdHkoKT8wOih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlKX1jb21wdXRlTWluRGlzdGFuY2VMaW5lcyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoaSxzLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fWdldENsYXNzKCl7cmV0dXJuIFJpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1SaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9nZW9tPW51bGwsdGhpcy5fdGVybWluYXRlRGlzdGFuY2U9MCx0aGlzLl9wdExvY2F0b3I9bmV3IF9uLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb249bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1pLk1BWF9WQUxVRSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07UmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsMCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9nZW9tWzBdPXQsdGhpcy5fZ2VvbVsxXT1lLHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlPW59fTt2YXIgUGk9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGlzdGFuY2VPcDpSaX0pO2NsYXNzIHZpe2NvbnN0cnVjdG9yKCl7dmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlcygpe2lmKG51bGw9PT10aGlzLl9jb29yZGluYXRlcyl7bGV0IHQ9MCxlPTA7Y29uc3Qgbj1uZXcgSTtmb3IobGV0IHM9dGhpcy5fZGlyZWN0ZWRFZGdlcy5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKTtpLmdldEVkZ2VEaXJlY3Rpb24oKT90Kys6ZSsrLG4uYWRkKGkuZ2V0RWRnZSgpLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLCExLGkuZ2V0RWRnZURpcmVjdGlvbigpKX10aGlzLl9jb29yZGluYXRlcz1uLnRvQ29vcmRpbmF0ZUFycmF5KCksZT50JiZYLnJldmVyc2UodGhpcy5fY29vcmRpbmF0ZXMpfXJldHVybiB0aGlzLl9jb29yZGluYXRlc310b0xpbmVTdHJpbmcoKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSl9YWRkKHQpe3RoaXMuX2RpcmVjdGVkRWRnZXMuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIHZpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12aS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZGlyZWN0ZWRFZGdlcz1uZXcgeCx0aGlzLl9jb29yZGluYXRlcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH07Y2xhc3MgT2l7Y29uc3RydWN0b3IoKXtPaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRDb21wb25lbnRXaXRoVmlzaXRlZFN0YXRlKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7aWYobi5pc1Zpc2l0ZWQoKT09PWUpcmV0dXJuIG59cmV0dXJuIG51bGx9c3RhdGljIHNldFZpc2l0ZWQodCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0VmlzaXRlZChlKX19c3RhdGljIHNldE1hcmtlZCh0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRNYXJrZWQoZSl9fXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9aXNNYXJrZWQoKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfXNldE1hcmtlZCh0KXt0aGlzLl9pc01hcmtlZD10fWdldENvbnRleHQoKXtyZXR1cm4gdGhpcy5fZGF0YX1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfXNldENvbnRleHQodCl7dGhpcy5fZGF0YT10fWdldENsYXNzKCl7cmV0dXJuIE9pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1PaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc01hcmtlZD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5fZGF0YT1udWxsfTtjbGFzcyBiaSBleHRlbmRzIE9pe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxiaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0VkZ2VzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZS5hZGQobi5uZXh0KCkuX3BhcmVudEVkZ2UpO3JldHVybiBlfWlzUmVtb3ZlZCgpe3JldHVybiBudWxsPT09dGhpcy5fcGFyZW50RWRnZX1jb21wYXJlRGlyZWN0aW9uKHQpe3JldHVybiB0aGlzLl9xdWFkcmFudD50Ll9xdWFkcmFudD8xOnRoaXMuX3F1YWRyYW50PHQuX3F1YWRyYW50Py0xOnYuaW5kZXgodC5fcDAsdC5fcDEsdGhpcy5fcDEpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fZnJvbS5nZXRDb29yZGluYXRlKCl9cHJpbnQodCl7Y29uc3QgZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIikscz1lLnN1YnN0cmluZyhuKzEpO3QucHJpbnQoXCIgIFwiK3MrXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrdGhpcy5fYW5nbGUpfWdldERpcmVjdGlvblB0KCl7cmV0dXJuIHRoaXMuX3AxfWdldEFuZ2xlKCl7cmV0dXJuIHRoaXMuX2FuZ2xlfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX1nZXRGcm9tTm9kZSgpe3JldHVybiB0aGlzLl9mcm9tfWdldFN5bSgpe3JldHVybiB0aGlzLl9zeW19c2V0RWRnZSh0KXt0aGlzLl9wYXJlbnRFZGdlPXR9cmVtb3ZlKCl7dGhpcy5fc3ltPW51bGwsdGhpcy5fcGFyZW50RWRnZT1udWxsfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fcGFyZW50RWRnZX1nZXRRdWFkcmFudCgpe3JldHVybiB0aGlzLl9xdWFkcmFudH1zZXRTeW0odCl7dGhpcy5fc3ltPXR9Z2V0VG9Ob2RlKCl7cmV0dXJuIHRoaXMuX3RvfWdldEVkZ2VEaXJlY3Rpb24oKXtyZXR1cm4gdGhpcy5fZWRnZURpcmVjdGlvbn1nZXRDbGFzcygpe3JldHVybiBiaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fWJpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3BhcmVudEVkZ2U9bnVsbCx0aGlzLl9mcm9tPW51bGwsdGhpcy5fdG89bnVsbCx0aGlzLl9wMD1udWxsLHRoaXMuX3AxPW51bGwsdGhpcy5fc3ltPW51bGwsdGhpcy5fZWRnZURpcmVjdGlvbj1udWxsLHRoaXMuX3F1YWRyYW50PW51bGwsdGhpcy5fYW5nbGU9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fZnJvbT10LHRoaXMuX3RvPWUsdGhpcy5fZWRnZURpcmVjdGlvbj1zLHRoaXMuX3AwPXQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX3AxPW47Y29uc3QgaT10aGlzLl9wMS54LXRoaXMuX3AwLngscj10aGlzLl9wMS55LXRoaXMuX3AwLnk7dGhpcy5fcXVhZHJhbnQ9SW4ucXVhZHJhbnQoaSxyKSx0aGlzLl9hbmdsZT1NYXRoLmF0YW4yKHIsaSl9fTtjbGFzcyBNaSBleHRlbmRzIGJpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxNaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE5leHQoKXtyZXR1cm4gMiE9PXRoaXMuZ2V0VG9Ob2RlKCkuZ2V0RGVncmVlKCk/bnVsbDp0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCk9PT10aGlzLmdldFN5bSgpP3RoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKToodS5pc1RydWUodGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpPT09dGhpcy5nZXRTeW0oKSksdGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApKX1nZXRDbGFzcygpe3JldHVybiBNaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107YmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixzKX07Y2xhc3MgRGkgZXh0ZW5kcyBPaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2RpckVkZ2V9c2V0RGlyZWN0ZWRFZGdlcyh0LGUpe3RoaXMuX2RpckVkZ2U9W3QsZV0sdC5zZXRFZGdlKHRoaXMpLGUuc2V0RWRnZSh0aGlzKSx0LnNldFN5bShlKSxlLnNldFN5bSh0KSx0LmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZSh0KSxlLmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZShlKX1nZXREaXJFZGdlKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGlyRWRnZVt0XX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzBdOnRoaXMuX2RpckVkZ2VbMV0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVsxXTpudWxsfX1yZW1vdmUoKXt0aGlzLl9kaXJFZGdlPW51bGx9Z2V0T3Bwb3NpdGVOb2RlKHQpe3JldHVybiB0aGlzLl9kaXJFZGdlWzBdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMF0uZ2V0VG9Ob2RlKCk6dGhpcy5fZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzFdLmdldFRvTm9kZSgpOm51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gRGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fURpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2RpckVkZ2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zZXREaXJlY3RlZEVkZ2VzKHQsZSl9fTtjbGFzcyBBaXtjb25zdHJ1Y3Rvcigpe0FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TmV4dEVkZ2UodCl7Y29uc3QgZT10aGlzLmdldEluZGV4KHQpO3JldHVybiB0aGlzLl9vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlKzEpKX1nZXRDb29yZGluYXRlKCl7Y29uc3QgdD10aGlzLml0ZXJhdG9yKCk7cmV0dXJuIHQuaGFzTmV4dCgpP3QubmV4dCgpLmdldENvb3JkaW5hdGUoKTpudWxsfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuc29ydEVkZ2VzKCksdGhpcy5fb3V0RWRnZXMuaXRlcmF0b3IoKX1zb3J0RWRnZXMoKXt0aGlzLl9zb3J0ZWR8fChFZS5zb3J0KHRoaXMuX291dEVkZ2VzKSx0aGlzLl9zb3J0ZWQ9ITApfXJlbW92ZSh0KXt0aGlzLl9vdXRFZGdlcy5yZW1vdmUodCl9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLl9vdXRFZGdlc31nZXROZXh0Q1dFZGdlKHQpe2NvbnN0IGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5fb3V0RWRnZXMuZ2V0KHRoaXMuZ2V0SW5kZXgoZS0xKSl9Z2V0SW5kZXgoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIERpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2ZvcihsZXQgZT0wO2U8dGhpcy5fb3V0RWRnZXMuc2l6ZSgpO2UrKyl7aWYodGhpcy5fb3V0RWRnZXMuZ2V0KGUpLmdldEVkZ2UoKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBiaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX291dEVkZ2VzLnNpemUoKTtlKyspe2lmKHRoaXMuX291dEVkZ2VzLmdldChlKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtsZXQgdD1hcmd1bWVudHNbMF0ldGhpcy5fb3V0RWRnZXMuc2l6ZSgpO3JldHVybiB0PDAmJih0Kz10aGlzLl9vdXRFZGdlcy5zaXplKCkpLHR9fWFkZCh0KXt0aGlzLl9vdXRFZGdlcy5hZGQodCksdGhpcy5fc29ydGVkPSExfWdldERlZ3JlZSgpe3JldHVybiB0aGlzLl9vdXRFZGdlcy5zaXplKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gQWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUFpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX291dEVkZ2VzPW5ldyB4LHRoaXMuX3NvcnRlZD0hMX07Y2xhc3MgRmkgZXh0ZW5kcyBPaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0RWRnZXNCZXR3ZWVuKHQsZSl7Y29uc3Qgbj1uZXcgSihiaS50b0VkZ2VzKHQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKSkscz1iaS50b0VkZ2VzKGUuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKTtyZXR1cm4gbi5yZXRhaW5BbGwocyksbn1pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3B0fWFkZE91dEVkZ2UodCl7dGhpcy5fZGVTdGFyLmFkZCh0KX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fWdldE91dEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2RlU3Rhcn1yZW1vdmUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9wdD1udWxsO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2RlU3Rhci5yZW1vdmUodCl9fWdldEluZGV4KHQpe3JldHVybiB0aGlzLl9kZVN0YXIuZ2V0SW5kZXgodCl9Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX2RlU3Rhci5nZXREZWdyZWUoKX1nZXRDbGFzcygpe3JldHVybiBGaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcHQ9bnVsbCx0aGlzLl9kZVN0YXI9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07RmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LG5ldyBBaSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHQ9dCx0aGlzLl9kZVN0YXI9ZX19O2NsYXNzIEdpIGV4dGVuZHMgRGl7Y29uc3RydWN0b3IoKXtzdXBlcigpLEdpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TGluZSgpe3JldHVybiB0aGlzLl9saW5lfWdldENsYXNzKCl7cmV0dXJuIEdpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1HaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZT10fTtjbGFzcyBxaXtjb25zdHJ1Y3Rvcigpe3FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluZCh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5nZXQodCl9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfXJlbW92ZSh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5yZW1vdmUodCl9dmFsdWVzKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCl9YWRkKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLnB1dCh0LmdldENvb3JkaW5hdGUoKSx0KSx0fWdldENsYXNzKCl7cmV0dXJuIHFpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1xaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ub2RlTWFwPW5ldyBydH07Y2xhc3MgQml7Y29uc3RydWN0b3IoKXtCaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmROb2Rlc09mRGVncmVlKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXRoaXMubm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MuZ2V0RGVncmVlKCk9PT10JiZlLmFkZChzKX1yZXR1cm4gZX1kaXJFZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKX1lZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1yZW1vdmUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIERpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnJlbW92ZSh0LmdldERpckVkZ2UoMCkpLHRoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgxKSksdGhpcy5fZWRnZXMucmVtb3ZlKHQpLHQucmVtb3ZlKCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0U3ltKCk7bnVsbCE9PWUmJmUuc2V0U3ltKG51bGwpLHQuZ2V0RnJvbU5vZGUoKS5yZW1vdmUodCksdC5yZW1vdmUoKSx0aGlzLl9kaXJFZGdlcy5yZW1vdmUodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldFN5bSgpO251bGwhPT1uJiZ0aGlzLnJlbW92ZShuKSx0aGlzLl9kaXJFZGdlcy5yZW1vdmUodCk7Y29uc3Qgcz10LmdldEVkZ2UoKTtudWxsIT09cyYmdGhpcy5fZWRnZXMucmVtb3ZlKHMpfXRoaXMuX25vZGVNYXAucmVtb3ZlKHQuZ2V0Q29vcmRpbmF0ZSgpKSx0LnJlbW92ZSgpfX1maW5kTm9kZSh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5maW5kKHQpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfW5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLml0ZXJhdG9yKCl9Y29udGFpbnMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIERpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZWRnZXMuY29udGFpbnModCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBiaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RpckVkZ2VzLmNvbnRhaW5zKHQpfX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ub2RlTWFwLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRGkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2VkZ2VzLmFkZCh0KSx0aGlzLmFkZCh0LmdldERpckVkZ2UoMCkpLHRoaXMuYWRkKHQuZ2V0RGlyRWRnZSgxKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9kaXJFZGdlcy5hZGQodCl9fWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gQml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUJpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2VkZ2VzPW5ldyBKLHRoaXMuX2RpckVkZ2VzPW5ldyBKLHRoaXMuX25vZGVNYXA9bmV3IHFpfTtjbGFzcyBWaSBleHRlbmRzIEJpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxWaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZEVkZ2UodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgZT1YLnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8PTEpcmV0dXJuIG51bGw7Y29uc3Qgbj1lWzBdLHM9ZVtlLmxlbmd0aC0xXSxpPXRoaXMuZ2V0Tm9kZShuKSxyPXRoaXMuZ2V0Tm9kZShzKSxvPW5ldyBNaShpLHIsZVsxXSwhMCksbD1uZXcgTWkocixpLGVbZS5sZW5ndGgtMl0sITEpLGE9bmV3IEdpKHQpO2Euc2V0RGlyZWN0ZWRFZGdlcyhvLGwpLHRoaXMuYWRkKGEpfWdldE5vZGUodCl7bGV0IGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBGaSh0KSx0aGlzLmFkZChlKSksZX1nZXRDbGFzcygpe3JldHVybiBWaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB6aXtjb25zdHJ1Y3Rvcigpe3ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YnVpbGRFZGdlU3RyaW5nc0ZvclVucHJvY2Vzc2VkTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtlLmlzTWFya2VkKCl8fCh1LmlzVHJ1ZSgyPT09ZS5nZXREZWdyZWUoKSksdGhpcy5idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdChlKSxlLnNldE1hcmtlZCghMCkpfX1idWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7MiE9PWUuZ2V0RGVncmVlKCkmJih0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fWJ1aWxkRWRnZVN0cmluZ3NGb3JPYnZpb3VzU3RhcnROb2Rlcygpe3RoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck5vbkRlZ3JlZTJOb2RlcygpfWdldE1lcmdlZExpbmVTdHJpbmdzKCl7cmV0dXJuIHRoaXMubWVyZ2UoKSx0aGlzLl9tZXJnZWRMaW5lU3RyaW5nc31idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdCh0KXtmb3IobGV0IGU9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuZ2V0RWRnZSgpLmlzTWFya2VkKCl8fHRoaXMuX2VkZ2VTdHJpbmdzLmFkZCh0aGlzLmJ1aWxkRWRnZVN0cmluZ1N0YXJ0aW5nV2l0aCh0KSl9fW1lcmdlKCl7aWYobnVsbCE9PXRoaXMuX21lcmdlZExpbmVTdHJpbmdzKXJldHVybiBudWxsO09pLnNldE1hcmtlZCh0aGlzLl9ncmFwaC5ub2RlSXRlcmF0b3IoKSwhMSksT2kuc2V0TWFya2VkKHRoaXMuX2dyYXBoLmVkZ2VJdGVyYXRvcigpLCExKSx0aGlzLl9lZGdlU3RyaW5ncz1uZXcgeCx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JPYnZpb3VzU3RhcnROb2RlcygpLHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvcklzb2xhdGVkTG9vcHMoKSx0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1uZXcgeDtmb3IobGV0IHQ9dGhpcy5fZWRnZVN0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5fbWVyZ2VkTGluZVN0cmluZ3MuYWRkKGUudG9MaW5lU3RyaW5nKCkpfX1hZGRMaW5lU3RyaW5nKHQpe251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdGhpcy5fZ3JhcGguYWRkRWRnZSh0KX1idWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGgodCl7Y29uc3QgZT1uZXcgdmkodGhpcy5fZmFjdG9yeSk7bGV0IG49dDtkb3tlLmFkZChuKSxuLmdldEVkZ2UoKS5zZXRNYXJrZWQoITApLG49bi5nZXROZXh0KCl9d2hpbGUobnVsbCE9PW4mJm4hPT10KTtyZXR1cm4gZX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO24gaW5zdGFuY2VvZiBUdCYmdGhpcy5hZGRMaW5lU3RyaW5nKG4pfX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1udWxsO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuYWRkKHQpfX19YnVpbGRFZGdlU3RyaW5nc0Zvcklzb2xhdGVkTG9vcHMoKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzKCl9Z2V0Q2xhc3MoKXtyZXR1cm4geml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXppLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dyYXBoPW5ldyBWaSx0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9lZGdlU3RyaW5ncz1udWxsfTtjbGFzcyBZaXtjb25zdHJ1Y3Rvcigpe1lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZGlyRWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCl9ZWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9Z2V0UGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudEdyYXBofW5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLml0ZXJhdG9yKCl9Y29udGFpbnModCl7cmV0dXJuIHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpfWFkZCh0KXtpZih0aGlzLl9lZGdlcy5jb250YWlucyh0KSlyZXR1cm4gbnVsbDt0aGlzLl9lZGdlcy5hZGQodCksdGhpcy5fZGlyRWRnZXMuYWRkKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5fZGlyRWRnZXMuYWRkKHQuZ2V0RGlyRWRnZSgxKSksdGhpcy5fbm9kZU1hcC5hZGQodC5nZXREaXJFZGdlKDApLmdldEZyb21Ob2RlKCkpLHRoaXMuX25vZGVNYXAuYWRkKHQuZ2V0RGlyRWRnZSgxKS5nZXRGcm9tTm9kZSgpKX1nZXRDbGFzcygpe3JldHVybiBZaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19WWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcGFyZW50R3JhcGg9bnVsbCx0aGlzLl9lZGdlcz1uZXcgSix0aGlzLl9kaXJFZGdlcz1uZXcgeCx0aGlzLl9ub2RlTWFwPW5ldyBxaTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wYXJlbnRHcmFwaD10fTtjbGFzcyBVaXtjb25zdHJ1Y3Rvcigpe1VpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkUmVhY2hhYmxlKHQsZSl7Y29uc3Qgbj1uZXcgb247Zm9yKG4uYWRkKHQpOyFuLmVtcHR5KCk7KXtjb25zdCB0PW4ucG9wKCk7dGhpcy5hZGRFZGdlcyh0LG4sZSl9fWZpbmRTdWJncmFwaCh0KXtjb25zdCBlPW5ldyBZaSh0aGlzLl9ncmFwaCk7cmV0dXJuIHRoaXMuYWRkUmVhY2hhYmxlKHQsZSksZX1nZXRDb25uZWN0ZWRTdWJncmFwaHMoKXtjb25zdCB0PW5ldyB4O09pLnNldFZpc2l0ZWQodGhpcy5fZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpO2ZvcihsZXQgZT10aGlzLl9ncmFwaC5lZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0RGlyRWRnZSgwKS5nZXRGcm9tTm9kZSgpO24uaXNWaXNpdGVkKCl8fHQuYWRkKHRoaXMuZmluZFN1YmdyYXBoKG4pKX1yZXR1cm4gdH1hZGRFZGdlcyh0LGUsbil7dC5zZXRWaXNpdGVkKCEwKTtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO24uYWRkKHQuZ2V0RWRnZSgpKTtjb25zdCBpPXQuZ2V0VG9Ob2RlKCk7aS5pc1Zpc2l0ZWQoKXx8ZS5wdXNoKGkpfX1nZXRDbGFzcygpe3JldHVybiBVaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ3JhcGg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ncmFwaD10fTtjbGFzcyBraXtjb25zdHJ1Y3Rvcigpe2tpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERSh0KXtsZXQgZT1udWxsLG49bnVsbDtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuZ2V0RWRnZSgpLmlzVmlzaXRlZCgpfHwobj10LHQuZ2V0RWRnZURpcmVjdGlvbigpJiYoZT10KSl9cmV0dXJuIG51bGwhPT1lP2U6bn1zdGF0aWMgZmluZExvd2VzdERlZ3JlZU5vZGUodCl7bGV0IGU9TC5NQVhfVkFMVUUsbj1udWxsO2ZvcihsZXQgcz10Lm5vZGVJdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTsobnVsbD09PW58fHQuZ2V0RGVncmVlKCk8ZSkmJihlPXQuZ2V0RGVncmVlKCksbj10KX1yZXR1cm4gbn1zdGF0aWMgaXNTZXF1ZW5jZWQodCl7aWYoISh0IGluc3RhbmNlb2YgZnQpKXJldHVybiEwO2NvbnN0IGU9dCxuPW5ldyBhdDtsZXQgcz1udWxsO2NvbnN0IGk9bmV3IHg7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IHI9ZS5nZXRHZW9tZXRyeU4odCksbz1yLmdldENvb3JkaW5hdGVOKDApLGw9ci5nZXRDb29yZGluYXRlTihyLmdldE51bVBvaW50cygpLTEpO2lmKG4uY29udGFpbnMobykpcmV0dXJuITE7aWYobi5jb250YWlucyhsKSlyZXR1cm4hMTtudWxsIT09cyYmKG8uZXF1YWxzKHMpfHwobi5hZGRBbGwoaSksaS5jbGVhcigpKSksaS5hZGQobyksaS5hZGQobCkscz1sfXJldHVybiEwfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpLG49bmV3IEFycmF5KGUubGVuZ3RoKS5maWxsKG51bGwpLHM9ZS5sZW5ndGg7Zm9yKGxldCB0PTA7dDxzO3QrKyluW3MtMS10XT1uZXcgZyhlW3RdKTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhuKX1zdGF0aWMgc2VxdWVuY2UodCl7Y29uc3QgZT1uZXcga2k7cmV0dXJuIGUuYWRkKHQpLGUuZ2V0U2VxdWVuY2VkTGluZVN0cmluZ3MoKX1hZGRMaW5lKHQpe251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdGhpcy5fZ3JhcGguYWRkRWRnZSh0KSx0aGlzLl9saW5lQ291bnQrK31oYXNTZXF1ZW5jZSh0KXtsZXQgZT0wO2ZvcihsZXQgbj10Lm5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuZ2V0RGVncmVlKCklMj09MSYmZSsrfXJldHVybiBlPD0yfWNvbXB1dGVTZXF1ZW5jZSgpe2lmKHRoaXMuX2lzUnVuKXJldHVybiBudWxsO3RoaXMuX2lzUnVuPSEwO2NvbnN0IHQ9dGhpcy5maW5kU2VxdWVuY2VzKCk7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnk9dGhpcy5idWlsZFNlcXVlbmNlZEdlb21ldHJ5KHQpLHRoaXMuX2lzU2VxdWVuY2VhYmxlPSEwO2NvbnN0IGU9dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkuZ2V0TnVtR2VvbWV0cmllcygpO3UuaXNUcnVlKHRoaXMuX2xpbmVDb3VudD09PWUsXCJMaW5lcyB3ZXJlIG1pc3NpbmcgZnJvbSByZXN1bHRcIiksdS5pc1RydWUodGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkgaW5zdGFuY2VvZiBUdHx8dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkgaW5zdGFuY2VvZiBmdCxcIlJlc3VsdCBpcyBub3QgbGluZWFsXCIpfWZpbmRTZXF1ZW5jZXMoKXtjb25zdCB0PW5ldyB4O2ZvcihsZXQgZT1uZXcgVWkodGhpcy5fZ3JhcGgpLmdldENvbm5lY3RlZFN1YmdyYXBocygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKCF0aGlzLmhhc1NlcXVlbmNlKG4pKXJldHVybiBudWxsO3tjb25zdCBlPXRoaXMuZmluZFNlcXVlbmNlKG4pO3QuYWRkKGUpfX1yZXR1cm4gdH1hZGRSZXZlcnNlU3VicGF0aCh0LGUsbil7Y29uc3Qgcz10LmdldFRvTm9kZSgpO2xldCBpPW51bGw7Zm9yKDs7KXtlLmFkZCh0LmdldFN5bSgpKSx0LmdldEVkZ2UoKS5zZXRWaXNpdGVkKCEwKSxpPXQuZ2V0RnJvbU5vZGUoKTtjb25zdCBuPWtpLmZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERShpKTtpZihudWxsPT09bilicmVhazt0PW4uZ2V0U3ltKCl9biYmdS5pc1RydWUoaT09PXMsXCJwYXRoIG5vdCBjb250aWd1b3VzXCIpfWZpbmRTZXF1ZW5jZSh0KXtPaS5zZXRWaXNpdGVkKHQuZWRnZUl0ZXJhdG9yKCksITEpO2NvbnN0IGU9a2kuZmluZExvd2VzdERlZ3JlZU5vZGUodCkuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpLm5leHQoKS5nZXRTeW0oKSxuPW5ldyBacyxzPW4ubGlzdEl0ZXJhdG9yKCk7Zm9yKHRoaXMuYWRkUmV2ZXJzZVN1YnBhdGgoZSxzLCExKTtzLmhhc1ByZXZpb3VzKCk7KXtjb25zdCB0PXMucHJldmlvdXMoKSxlPWtpLmZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERSh0LmdldEZyb21Ob2RlKCkpO251bGwhPT1lJiZ0aGlzLmFkZFJldmVyc2VTdWJwYXRoKGUuZ2V0U3ltKCkscywhMCl9cmV0dXJuIHRoaXMub3JpZW50KG4pfXJldmVyc2UodCl7Y29uc3QgZT1uZXcgWnM7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGRGaXJzdCh0LmdldFN5bSgpKX1yZXR1cm4gZX1vcmllbnQodCl7Y29uc3QgZT10LmdldCgwKSxuPXQuZ2V0KHQuc2l6ZSgpLTEpLHM9ZS5nZXRGcm9tTm9kZSgpLGk9bi5nZXRUb05vZGUoKTtsZXQgcj0hMTtpZigxPT09cy5nZXREZWdyZWUoKXx8MT09PWkuZ2V0RGVncmVlKCkpe2xldCB0PSExOzE9PT1uLmdldFRvTm9kZSgpLmdldERlZ3JlZSgpJiYhMT09PW4uZ2V0RWRnZURpcmVjdGlvbigpJiYodD0hMCxyPSEwKSwxPT09ZS5nZXRGcm9tTm9kZSgpLmdldERlZ3JlZSgpJiYhMD09PWUuZ2V0RWRnZURpcmVjdGlvbigpJiYodD0hMCxyPSExKSx0fHwxPT09ZS5nZXRGcm9tTm9kZSgpLmdldERlZ3JlZSgpJiYocj0hMCl9cmV0dXJuIHI/dGhpcy5yZXZlcnNlKHQpOnR9YnVpbGRTZXF1ZW5jZWRHZW9tZXRyeSh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtmb3IobGV0IHQ9bi5uZXh0KCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkscz1uLmdldEVkZ2UoKS5nZXRMaW5lKCk7bGV0IGk9cztuLmdldEVkZ2VEaXJlY3Rpb24oKXx8cy5pc0Nsb3NlZCgpfHwoaT1raS5yZXZlcnNlKHMpKSxlLmFkZChpKX19cmV0dXJuIDA9PT1lLnNpemUoKT90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk6dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KGUpfWdldFNlcXVlbmNlZExpbmVTdHJpbmdzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVNlcXVlbmNlKCksdGhpcy5fc2VxdWVuY2VkR2VvbWV0cnl9aXNTZXF1ZW5jZWFibGUoKXtyZXR1cm4gdGhpcy5jb21wdXRlU2VxdWVuY2UoKSx0aGlzLl9pc1NlcXVlbmNlYWJsZX1hZGQoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2FyZ3VtZW50c1swXS5hcHBseShuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ddfWZpbHRlcih0KXt0IGluc3RhbmNlb2YgVHQmJnRoaXMuYWRkTGluZSh0KX19KX19Z2V0Q2xhc3MoKXtyZXR1cm4ga2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWtpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dyYXBoPW5ldyBWaSx0aGlzLl9mYWN0b3J5PW5ldyBIdCx0aGlzLl9saW5lQ291bnQ9MCx0aGlzLl9pc1J1bj0hMSx0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeT1udWxsLHRoaXMuX2lzU2VxdWVuY2VhYmxlPSExfTt2YXIgWGk9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTGluZU1lcmdlcjp6aSxMaW5lU2VxdWVuY2VyOmtpfSk7Y2xhc3MgSGl7Y29uc3RydWN0b3IoKXtIaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc0Nsb3NlZCh0KXtyZXR1cm4hKHQubGVuZ3RoPD0xKSYmdFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX1zbmFwVmVydGljZXModCxlKXtjb25zdCBuPXRoaXMuX2lzQ2xvc2VkP3Quc2l6ZSgpLTE6dC5zaXplKCk7Zm9yKGxldCBzPTA7czxuO3MrKyl7Y29uc3Qgbj10LmdldChzKSxpPXRoaXMuZmluZFNuYXBGb3JWZXJ0ZXgobixlKTtudWxsIT09aSYmKHQuc2V0KHMsbmV3IGcoaSkpLDA9PT1zJiZ0aGlzLl9pc0Nsb3NlZCYmdC5zZXQodC5zaXplKCktMSxuZXcgZyhpKSkpfX1maW5kU25hcEZvclZlcnRleCh0LGUpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtpZih0LmVxdWFsczJEKGVbbl0pKXJldHVybiBudWxsO2lmKHQuZGlzdGFuY2UoZVtuXSk8dGhpcy5fc25hcFRvbGVyYW5jZSlyZXR1cm4gZVtuXX1yZXR1cm4gbnVsbH1zbmFwVG8odCl7Y29uc3QgZT1uZXcgSSh0aGlzLl9zcmNQdHMpO3JldHVybiB0aGlzLnNuYXBWZXJ0aWNlcyhlLHQpLHRoaXMuc25hcFNlZ21lbnRzKGUsdCksZS50b0Nvb3JkaW5hdGVBcnJheSgpfXNuYXBTZWdtZW50cyh0LGUpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbnVsbDtsZXQgbj1lLmxlbmd0aDtlWzBdLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pJiYobj1lLmxlbmd0aC0xKTtmb3IobGV0IHM9MDtzPG47cysrKXtjb25zdCBuPWVbc10saT10aGlzLmZpbmRTZWdtZW50SW5kZXhUb1NuYXAobix0KTtpPj0wJiZ0LmFkZChpKzEsbmV3IGcobiksITEpfX1maW5kU2VnbWVudEluZGV4VG9TbmFwKHQsZSl7bGV0IG49aS5NQVhfVkFMVUUscz0tMTtmb3IobGV0IGk9MDtpPGUuc2l6ZSgpLTE7aSsrKXtpZih0aGlzLl9zZWcucDA9ZS5nZXQoaSksdGhpcy5fc2VnLnAxPWUuZ2V0KGkrMSksdGhpcy5fc2VnLnAwLmVxdWFsczJEKHQpfHx0aGlzLl9zZWcucDEuZXF1YWxzMkQodCkpe2lmKHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKWNvbnRpbnVlO3JldHVybi0xfWNvbnN0IHI9dGhpcy5fc2VnLmRpc3RhbmNlKHQpO3I8dGhpcy5fc25hcFRvbGVyYW5jZSYmcjxuJiYobj1yLHM9aSl9cmV0dXJuIHN9c2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModCl7dGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9dH1nZXRDbGFzcygpe3JldHVybiBIaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fc25hcFRvbGVyYW5jZT0wLHRoaXMuX3NyY1B0cz1udWxsLHRoaXMuX3NlZz1uZXcgZWUsdGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9ITEsdGhpcy5faXNDbG9zZWQ9ITEsYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07SGkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LmdldENvb3JkaW5hdGVzKCksZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9zcmNQdHM9dCx0aGlzLl9pc0Nsb3NlZD1IaS5pc0Nsb3NlZCh0KSx0aGlzLl9zbmFwVG9sZXJhbmNlPWV9fTtjbGFzcyBXaXtjb25zdHJ1Y3Rvcigpe1dpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNuYXAodCxlLG4pe2NvbnN0IHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksaT1uZXcgV2kodCk7c1swXT1pLnNuYXBUbyhlLG4pO2NvbnN0IHI9bmV3IFdpKGUpO3JldHVybiBzWzFdPXIuc25hcFRvKHNbMF0sbiksc31zdGF0aWMgY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPVdpLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKHQpO2NvbnN0IG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpO2lmKG4uZ2V0VHlwZSgpPT09a3QuRklYRUQpe2NvbnN0IHQ9MS9uLmdldFNjYWxlKCkqMi8xLjQxNTt0PmUmJihlPXQpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gTWF0aC5taW4oV2kuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHQpLFdpLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShlKSl9fXN0YXRpYyBjb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSh0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiBNYXRoLm1pbihlLmdldEhlaWdodCgpLGUuZ2V0V2lkdGgoKSkqV2kuU05BUF9QUkVDSVNJT05fRkFDVE9SfXN0YXRpYyBzbmFwVG9TZWxmKHQsZSxuKXtyZXR1cm4gbmV3IFdpKHQpLnNuYXBUb1NlbGYoZSxuKX1zbmFwVG8odCxlKXtjb25zdCBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHQpO3JldHVybiBuZXcgamkoZSxuKS50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSl9c25hcFRvU2VsZih0LGUpe2NvbnN0IG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModGhpcy5fc3JjR2VvbSkscz1uZXcgamkodCxuLCEwKS50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSk7bGV0IGk9cztyZXR1cm4gZSYmXyhpLE90KSYmKGk9cy5idWZmZXIoMCkpLGl9Y29tcHV0ZVNuYXBUb2xlcmFuY2UodCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHQpLzEwfWV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBhdCxuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyllLmFkZChuW3RdKTtyZXR1cm4gZS50b0FycmF5KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKX1jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGgodCl7bGV0IGU9aS5NQVhfVkFMVUU7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl7Y29uc3Qgcz10W25dLmRpc3RhbmNlKHRbbisxXSk7czxlJiYoZT1zKX1yZXR1cm4gZX1nZXRDbGFzcygpe3JldHVybiBXaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19V2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc3JjR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NyY0dlb209dH0sV2kuU05BUF9QUkVDSVNJT05fRkFDVE9SPTFlLTk7Y2xhc3MgamkgZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksamkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zbmFwTGluZSh0LGUpe2NvbnN0IG49bmV3IEhpKHQsdGhpcy5fc25hcFRvbGVyYW5jZSk7cmV0dXJuIG4uc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModGhpcy5faXNTZWxmU25hcCksbi5zbmFwVG8oZSl9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxzPXRoaXMuc25hcExpbmUobix0aGlzLl9zbmFwUHRzKTtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfWdldENsYXNzKCl7cmV0dXJuIGppfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1qaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5fc25hcFB0cz1udWxsLHRoaXMuX2lzU2VsZlNuYXA9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3NuYXBUb2xlcmFuY2U9dCx0aGlzLl9zbmFwUHRzPWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fc25hcFRvbGVyYW5jZT10LHRoaXMuX3NuYXBQdHM9ZSx0aGlzLl9pc1NlbGZTbmFwPW59fTt2YXIgS2k9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvbWV0cnlTbmFwcGVyOldpLExpbmVTdHJpbmdTbmFwcGVyOkhpfSk7Y2xhc3MgWml7Y29uc3RydWN0b3IoKXtaaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0c31zaXplKCl7cmV0dXJuIHRoaXMuX3B0cy5sZW5ndGh9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzW3RdfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGgtMV0pfWdldFNlZ21lbnRPY3RhbnQodCl7cmV0dXJuIHQ9PT10aGlzLl9wdHMubGVuZ3RoLTE/LTE6TXMub2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KSx0aGlzLmdldENvb3JkaW5hdGUodCsxKSl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyhuZXcgenQodGhpcy5fcHRzKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gWml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RzXX19WmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fZGF0YT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX2RhdGE9ZX07Y2xhc3MgUWl7Y29uc3RydWN0b3IoKXtRaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjcmVhdGVBbGxJbnRlcnNlY3Rpb25zRmluZGVyKHQpe2NvbnN0IGU9bmV3IFFpKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlfXN0YXRpYyBjcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXIodCl7cmV0dXJuIG5ldyBRaSh0KX1zdGF0aWMgY3JlYXRlSW50ZXJzZWN0aW9uQ291bnRlcih0KXtjb25zdCBlPW5ldyBRaSh0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyghMSksZX1nZXRJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbn1zZXRDaGVja0VuZFNlZ21lbnRzT25seSh0KXt0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5PXR9Z2V0SW50ZXJzZWN0aW9uU2VnbWVudHMoKXtyZXR1cm4gdGhpcy5faW50U2VnbWVudHN9Y291bnQoKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uQ291bnR9Z2V0SW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9pbnRlcnNlY3Rpb25zfXNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9c2V0S2VlcEludGVyc2VjdGlvbnModCl7dGhpcy5fa2VlcEludGVyc2VjdGlvbnM9dH1wcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZighdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMmJnRoaXMuaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuIG51bGw7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO2lmKHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHkpe2lmKCEodGhpcy5pc0VuZFNlZ21lbnQodCxlKXx8dGhpcy5pc0VuZFNlZ21lbnQobixzKSkpcmV0dXJuIG51bGx9Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSYmKHRoaXMuX2ludFNlZ21lbnRzPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuX2ludFNlZ21lbnRzWzBdPWksdGhpcy5faW50U2VnbWVudHNbMV09cix0aGlzLl9pbnRTZWdtZW50c1syXT1vLHRoaXMuX2ludFNlZ21lbnRzWzNdPWwsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb249dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApLHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zJiZ0aGlzLl9pbnRlcnNlY3Rpb25zLmFkZCh0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiksdGhpcy5faW50ZXJzZWN0aW9uQ291bnQrKyl9aXNFbmRTZWdtZW50KHQsZSl7cmV0dXJuIDA9PT1lfHxlPj10LnNpemUoKS0yfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuIXRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zJiZudWxsIT09dGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259Z2V0Q2xhc3MoKXtyZXR1cm4gUWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW19pXX19UWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9ITEsdGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seT0hMSx0aGlzLl9saT1udWxsLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uPW51bGwsdGhpcy5faW50U2VnbWVudHM9bnVsbCx0aGlzLl9pbnRlcnNlY3Rpb25zPW5ldyB4LHRoaXMuX2ludGVyc2VjdGlvbkNvdW50PTAsdGhpcy5fa2VlcEludGVyc2VjdGlvbnM9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbj1udWxsfTtjbGFzcyBKaXtjb25zdHJ1Y3Rvcigpe0ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXB1dGVJbnRlcnNlY3Rpb25zKHQpe2NvbnN0IGU9bmV3IEppKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLmlzVmFsaWQoKSxlLmdldEludGVyc2VjdGlvbnMoKX1leGVjdXRlKCl7aWYobnVsbCE9PXRoaXMuX3NlZ0ludClyZXR1cm4gbnVsbDt0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9Z2V0SW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9zZWdJbnQuZ2V0SW50ZXJzZWN0aW9ucygpfWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5leGVjdXRlKCksdGhpcy5faXNWYWxpZH1zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0KXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz10fWNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7dGhpcy5faXNWYWxpZD0hMCx0aGlzLl9zZWdJbnQ9bmV3IFFpKHRoaXMuX2xpKSx0aGlzLl9zZWdJbnQuc2V0RmluZEFsbEludGVyc2VjdGlvbnModGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMpO2NvbnN0IHQ9bmV3IFlzO2lmKHQuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuX3NlZ0ludCksdC5jb21wdXRlTm9kZXModGhpcy5fc2VnU3RyaW5ncyksdGhpcy5fc2VnSW50Lmhhc0ludGVyc2VjdGlvbigpKXJldHVybiB0aGlzLl9pc1ZhbGlkPSExLG51bGx9Y2hlY2tWYWxpZCgpe2lmKHRoaXMuZXhlY3V0ZSgpLCF0aGlzLl9pc1ZhbGlkKXRocm93IG5ldyBXbih0aGlzLmdldEVycm9yTWVzc2FnZSgpLHRoaXMuX3NlZ0ludC5nZXRJbnRlcmlvckludGVyc2VjdGlvbigpKX1nZXRFcnJvck1lc3NhZ2UoKXtpZih0aGlzLl9pc1ZhbGlkKXJldHVyblwibm8gaW50ZXJzZWN0aW9ucyBmb3VuZFwiO2NvbnN0IHQ9dGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvblNlZ21lbnRzKCk7cmV0dXJuXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGJldHdlZW4gXCIrSnQudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSkrXCIgYW5kIFwiK0p0LnRvTGluZVN0cmluZyh0WzJdLHRbM10pfWdldENsYXNzKCl7cmV0dXJuIEppfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1KaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saT1uZXcgdGUsdGhpcy5fc2VnU3RyaW5ncz1udWxsLHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuX3NlZ0ludD1udWxsLHRoaXMuX2lzVmFsaWQ9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2VnU3RyaW5ncz10fTtjbGFzcyAkaXtjb25zdHJ1Y3RvcigpeyRpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvU2VnbWVudFN0cmluZ3ModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZChuZXcgWmkodC5nZXRDb29yZGluYXRlcygpLHQpKX1yZXR1cm4gZX1zdGF0aWMgY2hlY2tWYWxpZCh0KXtuZXcgJGkodCkuY2hlY2tWYWxpZCgpfWNoZWNrVmFsaWQoKXt0aGlzLl9udi5jaGVja1ZhbGlkKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gJGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fSRpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX252PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbnY9bmV3IEppKCRpLnRvU2VnbWVudFN0cmluZ3ModCkpfTtjbGFzcyB0cntjb25zdHJ1Y3Rvcigpe3RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29sbGVjdExpbmVzKHQpe2ZvcihsZXQgZT10aGlzLl9vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5jb2xsZWN0TGluZUVkZ2Uobix0LHRoaXMuX2xpbmVFZGdlc0xpc3QpLHRoaXMuY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlKG4sdCx0aGlzLl9saW5lRWRnZXNMaXN0KX19bGFiZWxJc29sYXRlZExpbmUodCxlKXtjb25zdCBuPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5fb3AuZ2V0QXJnR2VvbWV0cnkoZSkpO3QuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbihlLG4pfWJ1aWxkKHQpe3JldHVybiB0aGlzLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCksdGhpcy5jb2xsZWN0TGluZXModCksdGhpcy5idWlsZExpbmVzKHQpLHRoaXMuX3Jlc3VsdExpbmVMaXN0fWNvbGxlY3RMaW5lRWRnZSh0LGUsbil7Y29uc3Qgcz10LmdldExhYmVsKCksaT10LmdldEVkZ2UoKTt0LmlzTGluZUVkZ2UoKSYmKHQuaXNWaXNpdGVkKCl8fCFjci5pc1Jlc3VsdE9mT3AocyxlKXx8aS5pc0NvdmVyZWQoKXx8KG4uYWRkKGkpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSl9ZmluZENvdmVyZWRMaW5lRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl9Zm9yKGxldCB0PXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZSgpO2lmKGUuaXNMaW5lRWRnZSgpJiYhbi5pc0NvdmVyZWRTZXQoKSl7Y29uc3QgdD10aGlzLl9vcC5pc0NvdmVyZWRCeUEoZS5nZXRDb29yZGluYXRlKCkpO24uc2V0Q292ZXJlZCh0KX19fWxhYmVsSXNvbGF0ZWRMaW5lcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0TGFiZWwoKTt0LmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZExpbmUodCwwKTp0aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKHQsMSkpfX1idWlsZExpbmVzKHQpe2ZvcihsZXQgdD10aGlzLl9saW5lRWRnZXNMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49KGUuZ2V0TGFiZWwoKSx0aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlLmdldENvb3JkaW5hdGVzKCkpKTt0aGlzLl9yZXN1bHRMaW5lTGlzdC5hZGQobiksZS5zZXRJblJlc3VsdCghMCl9fWNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZSh0LGUsbil7Y29uc3Qgcz10LmdldExhYmVsKCk7cmV0dXJuIHQuaXNMaW5lRWRnZSgpfHx0LmlzVmlzaXRlZCgpfHx0LmlzSW50ZXJpb3JBcmVhRWRnZSgpfHx0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCk/bnVsbDoodS5pc1RydWUoISh0LmlzSW5SZXN1bHQoKXx8dC5nZXRTeW0oKS5pc0luUmVzdWx0KCkpfHwhdC5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKSx2b2lkKGNyLmlzUmVzdWx0T2ZPcChzLGUpJiZlPT09Y3IuSU5URVJTRUNUSU9OJiYobi5hZGQodC5nZXRFZGdlKCkpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSkpfWdldENsYXNzKCl7cmV0dXJuIHRyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX10ci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9vcD1udWxsLHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3B0TG9jYXRvcj1udWxsLHRoaXMuX2xpbmVFZGdlc0xpc3Q9bmV3IHgsdGhpcy5fcmVzdWx0TGluZUxpc3Q9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fb3A9dCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZSx0aGlzLl9wdExvY2F0b3I9bn07Y2xhc3MgZXJ7Y29uc3RydWN0b3IoKXtlci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlckNvdmVyZWROb2RlVG9Qb2ludCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZSgpO2lmKCF0aGlzLl9vcC5pc0NvdmVyZWRCeUxBKGUpKXtjb25zdCB0PXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKTt0aGlzLl9yZXN1bHRQb2ludExpc3QuYWRkKHQpfX1leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYoIW4uaXNJblJlc3VsdCgpJiYoIW4uaXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpJiYoMD09PW4uZ2V0RWRnZXMoKS5nZXREZWdyZWUoKXx8dD09PWNyLklOVEVSU0VDVElPTikpKXtjb25zdCBlPW4uZ2V0TGFiZWwoKTtjci5pc1Jlc3VsdE9mT3AoZSx0KSYmdGhpcy5maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQobil9fX1idWlsZCh0KXtyZXR1cm4gdGhpcy5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpLHRoaXMuX3Jlc3VsdFBvaW50TGlzdH1nZXRDbGFzcygpe3JldHVybiBlcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fb3A9bnVsbCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLl9yZXN1bHRQb2ludExpc3Q9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fb3A9dCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZX07Y2xhc3MgbnJ7Y29uc3RydWN0b3IoKXt0aGlzLl9pc0ZpcnN0PSEwLHRoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50PTUzLHRoaXMuX2NvbW1vbkJpdHM9bmV3IHMsdGhpcy5fY29tbW9uU2lnbkV4cD1udWxsfWdldENvbW1vbigpe3JldHVybiBpLmxvbmdCaXRzVG9Eb3VibGUodGhpcy5fY29tbW9uQml0cyl9YWRkKHQpe2NvbnN0IGU9aS5kb3VibGVUb0xvbmdCaXRzKHQpO3JldHVybiB0aGlzLl9pc0ZpcnN0Pyh0aGlzLl9jb21tb25CaXRzPWUsdGhpcy5fY29tbW9uU2lnbkV4cD1uci5zaWduRXhwQml0cyh0aGlzLl9jb21tb25CaXRzKSx0aGlzLl9pc0ZpcnN0PSExLG51bGwpOm5yLnNpZ25FeHBCaXRzKGUpIT09dGhpcy5fY29tbW9uU2lnbkV4cD8odGhpcy5fY29tbW9uQml0cy5oaWdoPTAsdGhpcy5fY29tbW9uQml0cy5sb3c9MCxudWxsKToodGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQ9bnIubnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyh0aGlzLl9jb21tb25CaXRzLGUpLHZvaWQodGhpcy5fY29tbW9uQml0cz1uci56ZXJvTG93ZXJCaXRzKHRoaXMuX2NvbW1vbkJpdHMsNjQtKDEyK3RoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50KSkpKX10b1N0cmluZygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWkubG9uZ0JpdHNUb0RvdWJsZSh0KSxuPVwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiK3MudG9CaW5hcnlTdHJpbmcodCkscj1uLnN1YnN0cmluZyhuLmxlbmd0aC02NCk7cmV0dXJuIHIuc3Vic3RyaW5nKDAsMSkrXCIgIFwiK3Iuc3Vic3RyaW5nKDEsMTIpK1wiKGV4cCkgXCIrci5zdWJzdHJpbmcoMTIpK1wiIFsgXCIrZStcIiBdXCJ9fWdldENsYXNzKCl7cmV0dXJuIG5yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfXN0YXRpYyBnZXRCaXQodCxlKXtjb25zdCBuPTE8PGUlMzI7cmV0dXJuIGU8MzI/MCE9KHQubG93Jm4pPzE6MDowIT0odC5oaWdoJm4pPzE6MH1zdGF0aWMgc2lnbkV4cEJpdHModCl7cmV0dXJuIHQuaGlnaD4+PjIwfXN0YXRpYyB6ZXJvTG93ZXJCaXRzKHQsZSl7bGV0IG49XCJsb3dcIjtpZihlPjMyJiYodC5sb3c9MCxlJT0zMixuPVwiaGlnaFwiKSxlPjApe2NvbnN0IHM9ZTwzMj9+KCgxPDxlKS0xKTowO3Rbbl0mPXN9cmV0dXJuIHR9c3RhdGljIG51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHModCxlKXtsZXQgbj0wO2ZvcihsZXQgcz01MjtzPj0wO3MtLSl7aWYobnIuZ2V0Qml0KHQscykhPT1uci5nZXRCaXQoZSxzKSlyZXR1cm4gbjtuKyt9cmV0dXJuIDUyfX1jbGFzcyBzcntjb25zdHJ1Y3Rvcigpe3NyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkQ29tbW9uQml0cyh0KXtjb25zdCBlPW5ldyBycih0aGlzLl9jb21tb25Db29yZCk7dC5hcHBseShlKSx0Lmdlb21ldHJ5Q2hhbmdlZCgpfXJlbW92ZUNvbW1vbkJpdHModCl7aWYoMD09PXRoaXMuX2NvbW1vbkNvb3JkLngmJjA9PT10aGlzLl9jb21tb25Db29yZC55KXJldHVybiB0O2NvbnN0IGU9bmV3IGcodGhpcy5fY29tbW9uQ29vcmQpO2UueD0tZS54LGUueT0tZS55O2NvbnN0IG49bmV3IHJyKGUpO3JldHVybiB0LmFwcGx5KG4pLHQuZ2VvbWV0cnlDaGFuZ2VkKCksdH1nZXRDb21tb25Db29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2NvbW1vbkNvb3JkfWFkZCh0KXt0LmFwcGx5KHRoaXMuX2NjRmlsdGVyKSx0aGlzLl9jb21tb25Db29yZD10aGlzLl9jY0ZpbHRlci5nZXRDb21tb25Db29yZGluYXRlKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gc3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGlye2NvbnN0cnVjdG9yKCl7aXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7dGhpcy5fY29tbW9uQml0c1guYWRkKHQueCksdGhpcy5fY29tbW9uQml0c1kuYWRkKHQueSl9Z2V0Q29tbW9uQ29vcmRpbmF0ZSgpe3JldHVybiBuZXcgZyh0aGlzLl9jb21tb25CaXRzWC5nZXRDb21tb24oKSx0aGlzLl9jb21tb25CaXRzWS5nZXRDb21tb24oKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gaXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0JdfX1pci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb21tb25CaXRzWD1uZXcgbnIsdGhpcy5fY29tbW9uQml0c1k9bmV3IG5yfTtjbGFzcyBycntjb25zdHJ1Y3Rvcigpe3JyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQsZSl7Y29uc3Qgbj10LmdldE9yZGluYXRlKGUsMCkrdGhpcy50cmFucy54LHM9dC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMudHJhbnMueTt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxzKX1pc0RvbmUoKXtyZXR1cm4hMX1pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiEwfWdldENsYXNzKCl7cmV0dXJuIHJyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltkdF19fXJyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMudHJhbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnRyYW5zPXR9LHNyLkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXI9aXIsc3IuVHJhbnNsYXRlcj1ycixzci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb21tb25Db29yZD1udWxsLHRoaXMuX2NjRmlsdGVyPW5ldyBpcn07Y2xhc3Mgb3J7Y29uc3RydWN0b3IoKXtvci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvdmVybGF5T3AodCxlLG4pe3JldHVybiBuZXcgb3IodCxlKS5nZXRSZXN1bHRHZW9tZXRyeShuKX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gb3Iub3ZlcmxheU9wKHQsZSxjci5VTklPTil9c3RhdGljIGludGVyc2VjdGlvbih0LGUpe3JldHVybiBvci5vdmVybGF5T3AodCxlLGNyLklOVEVSU0VDVElPTil9c3RhdGljIHN5bURpZmZlcmVuY2UodCxlKXtyZXR1cm4gb3Iub3ZlcmxheU9wKHQsZSxjci5TWU1ESUZGRVJFTkNFKX1zdGF0aWMgZGlmZmVyZW5jZSh0LGUpe3JldHVybiBvci5vdmVybGF5T3AodCxlLGNyLkRJRkZFUkVOQ0UpfXNlbGZTbmFwKHQpe3JldHVybiBuZXcgV2kodCkuc25hcFRvKHQsdGhpcy5fc25hcFRvbGVyYW5jZSl9cmVtb3ZlQ29tbW9uQml0cyh0KXt0aGlzLl9jYnI9bmV3IHNyLHRoaXMuX2Nici5hZGQodFswXSksdGhpcy5fY2JyLmFkZCh0WzFdKTtjb25zdCBlPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiBlWzBdPXRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKHRbMF0uY29weSgpKSxlWzFdPXRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKHRbMV0uY29weSgpKSxlfXByZXBhcmVSZXN1bHQodCl7cmV0dXJuIHRoaXMuX2Nici5hZGRDb21tb25CaXRzKHQpLHR9Z2V0UmVzdWx0R2VvbWV0cnkodCl7Y29uc3QgZT10aGlzLnNuYXAodGhpcy5fZ2VvbSksbj1jci5vdmVybGF5T3AoZVswXSxlWzFdLHQpO3JldHVybiB0aGlzLnByZXBhcmVSZXN1bHQobil9Y2hlY2tWYWxpZCh0KXt0LmlzVmFsaWQoKXx8Ty5vdXQucHJpbnRsbihcIlNuYXBwZWQgZ2VvbWV0cnkgaXMgaW52YWxpZFwiKX1jb21wdXRlU25hcFRvbGVyYW5jZSgpe3RoaXMuX3NuYXBUb2xlcmFuY2U9V2kuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHRoaXMuX2dlb21bMF0sdGhpcy5fZ2VvbVsxXSl9c25hcCh0KXtjb25zdCBlPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0KTtyZXR1cm4gV2kuc25hcChlWzBdLGVbMV0sdGhpcy5fc25hcFRvbGVyYW5jZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gb3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW9yLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuX2Nicj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21bMF09dCx0aGlzLl9nZW9tWzFdPWUsdGhpcy5jb21wdXRlU25hcFRvbGVyYW5jZSgpfTtjbGFzcyBscntjb25zdHJ1Y3Rvcigpe2xyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG92ZXJsYXlPcCh0LGUsbil7cmV0dXJuIG5ldyBscih0LGUpLmdldFJlc3VsdEdlb21ldHJ5KG4pfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuRElGRkVSRU5DRSl9Z2V0UmVzdWx0R2VvbWV0cnkodCl7bGV0IGU9bnVsbCxuPSExLHM9bnVsbDt0cnl7ZT1jci5vdmVybGF5T3AodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdLHQpLCEwJiYobj0hMCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgYykpdGhyb3cgdDtzPXR9aWYoIW4pdHJ5e2U9b3Iub3ZlcmxheU9wKHRoaXMuX2dlb21bMF0sdGhpcy5fZ2VvbVsxXSx0KX1jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgYz9zOnR9cmV0dXJuIGV9Z2V0Q2xhc3MoKXtyZXR1cm4gbHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWxyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbVswXT10LHRoaXMuX2dlb21bMV09ZX07Y2xhc3MgYXJ7Y29uc3RydWN0b3IoKXthci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEFyZ0dlb21ldHJ5KHQpe3JldHVybiB0aGlzLl9hcmdbdF0uZ2V0R2VvbWV0cnkoKX1zZXRDb21wdXRhdGlvblByZWNpc2lvbih0KXt0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbD10LHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsKX1nZXRDbGFzcygpe3JldHVybiBhcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19YXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbGk9bmV3IHRlLHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYXJnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24odC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9hcmc9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksdGhpcy5fYXJnWzBdPW5ldyBRbigwLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0LmdldFByZWNpc2lvbk1vZGVsKCkuY29tcGFyZVRvKGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSk+PTA/dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpOnRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZS5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9hcmc9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fYXJnWzBdPW5ldyBRbigwLHQsbiksdGhpcy5fYXJnWzFdPW5ldyBRbigxLGUsbil9fTtjbGFzcyBjciBleHRlbmRzIGFye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxjci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvdmVybGF5T3AodCxlLG4pe3JldHVybiBuZXcgY3IodCxlKS5nZXRSZXN1bHRHZW9tZXRyeShuKX1zdGF0aWMgdW5pb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gY3IuY3JlYXRlRW1wdHlSZXN1bHQoY3IuVU5JT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfWlmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBuKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXJldHVybiBjci5jcmVhdGVFbXB0eVJlc3VsdChjci5JTlRFUlNFQ1RJT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe2NvbnN0IG49ZTtyZXR1cm4gZ2UubWFwKHQsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltmZV19bWFwKHQpe3JldHVybiBjci5pbnRlcnNlY3Rpb24odCxuKX19KX1yZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIGNyLmNyZWF0ZUVtcHR5UmVzdWx0KGNyLlNZTURJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfWlmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBuKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyByZXN1bHREaW1lbnNpb24odCxlLG4pe2NvbnN0IHM9ZS5nZXREaW1lbnNpb24oKSxpPW4uZ2V0RGltZW5zaW9uKCk7bGV0IHI9LTE7c3dpdGNoKHQpe2Nhc2UgY3IuSU5URVJTRUNUSU9OOnI9TWF0aC5taW4ocyxpKTticmVhaztjYXNlIGNyLlVOSU9OOnI9TWF0aC5tYXgocyxpKTticmVhaztjYXNlIGNyLkRJRkZFUkVOQ0U6cj1zO2JyZWFrO2Nhc2UgY3IuU1lNRElGRkVSRU5DRTpyPU1hdGgubWF4KHMsaSl9cmV0dXJuIHJ9c3RhdGljIGNyZWF0ZUVtcHR5UmVzdWx0KHQsZSxuLHMpe2xldCBpPW51bGw7c3dpdGNoKGNyLnJlc3VsdERpbWVuc2lvbih0LGUsbikpe2Nhc2UtMTppPXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7YnJlYWs7Y2FzZSAwOmk9cy5jcmVhdGVQb2ludCgpO2JyZWFrO2Nhc2UgMTppPXMuY3JlYXRlTGluZVN0cmluZygpO2JyZWFrO2Nhc2UgMjppPXMuY3JlYXRlUG9seWdvbigpfXJldHVybiBpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGNyLmNyZWF0ZUVtcHR5UmVzdWx0KGNyLkRJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpdGhyb3cgbmV3IG4oXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIik7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuRElGRkVSRU5DRSl9c3RhdGljIGlzUmVzdWx0T2ZPcCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0TG9jYXRpb24oMCkscz10LmdldExvY2F0aW9uKDEpO3JldHVybiBjci5pc1Jlc3VsdE9mT3AobixzLGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Y29uc3Qgbj1hcmd1bWVudHNbMl07c3dpdGNoKHQ9PT1uZS5CT1VOREFSWSYmKHQ9bmUuSU5URVJJT1IpLGU9PT1uZS5CT1VOREFSWSYmKGU9bmUuSU5URVJJT1IpLG4pe2Nhc2UgY3IuSU5URVJTRUNUSU9OOnJldHVybiB0PT09bmUuSU5URVJJT1ImJmU9PT1uZS5JTlRFUklPUjtjYXNlIGNyLlVOSU9OOnJldHVybiB0PT09bmUuSU5URVJJT1J8fGU9PT1uZS5JTlRFUklPUjtjYXNlIGNyLkRJRkZFUkVOQ0U6cmV0dXJuIHQ9PT1uZS5JTlRFUklPUiYmZSE9PW5lLklOVEVSSU9SO2Nhc2UgY3IuU1lNRElGRkVSRU5DRTpyZXR1cm4gdD09PW5lLklOVEVSSU9SJiZlIT09bmUuSU5URVJJT1J8fHQhPT1uZS5JTlRFUklPUiYmZT09PW5lLklOVEVSSU9SfXJldHVybiExfX1pbnNlcnRVbmlxdWVFZGdlKHQpe2NvbnN0IGU9dGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZSh0KTtpZihudWxsIT09ZSl7Y29uc3Qgbj1lLmdldExhYmVsKCk7bGV0IHM9dC5nZXRMYWJlbCgpO2UuaXNQb2ludHdpc2VFcXVhbCh0KXx8KHM9bmV3IEZuKHQuZ2V0TGFiZWwoKSkscy5mbGlwKCkpO2NvbnN0IGk9ZS5nZXREZXB0aCgpO2kuaXNOdWxsKCkmJmkuYWRkKG4pLGkuYWRkKHMpLG4ubWVyZ2Uocyl9ZWxzZSB0aGlzLl9lZGdlTGlzdC5hZGQodCl9Z2V0R3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Y2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0U3ltKCk7ZS5pc0luUmVzdWx0KCkmJm4uaXNJblJlc3VsdCgpJiYoZS5zZXRJblJlc3VsdCghMSksbi5zZXRJblJlc3VsdCghMSkpfX1pc0NvdmVyZWRCeUxBKHQpe3JldHVybiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLl9yZXN1bHRMaW5lTGlzdCl8fCEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLl9yZXN1bHRQb2x5TGlzdCl9Y29tcHV0ZUdlb21ldHJ5KHQsZSxuLHMpe2NvbnN0IGk9bmV3IHg7cmV0dXJuIGkuYWRkQWxsKHQpLGkuYWRkQWxsKGUpLGkuYWRkQWxsKG4pLGkuaXNFbXB0eSgpP2NyLmNyZWF0ZUVtcHR5UmVzdWx0KHMsdGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCksdGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCksdGhpcy5fZ2VvbUZhY3QpOnRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkoaSl9bWVyZ2VTeW1MYWJlbHMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5tZXJnZVN5bUxhYmVscygpfX1pc0NvdmVyZWQodCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKTtpZih0aGlzLl9wdExvY2F0b3IubG9jYXRlKHQsZSkhPT1uZS5FWFRFUklPUilyZXR1cm4hMH1yZXR1cm4hMX1yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKXtjb25zdCB0PW5ldyB4O2ZvcihsZXQgZT10aGlzLl9lZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtuLmlzQ29sbGFwc2VkKCkmJihlLnJlbW92ZSgpLHQuYWRkKG4uZ2V0Q29sbGFwc2VkRWRnZSgpKSl9dGhpcy5fZWRnZUxpc3QuYWRkQWxsKHQpfXVwZGF0ZU5vZGVMYWJlbGxpbmcoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZXMoKS5nZXRMYWJlbCgpO2UuZ2V0TGFiZWwoKS5tZXJnZShuKX19Z2V0UmVzdWx0R2VvbWV0cnkodCl7cmV0dXJuIHRoaXMuY29tcHV0ZU92ZXJsYXkodCksdGhpcy5fcmVzdWx0R2VvbX1pbnNlcnRVbmlxdWVFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2UodCl9fWNvbXB1dGVPdmVybGF5KHQpe3RoaXMuY29weVBvaW50cygwKSx0aGlzLmNvcHlQb2ludHMoMSksdGhpcy5fYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpLHRoaXMuX2FyZ1sxXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuX2FyZ1sxXSx0aGlzLl9saSwhMCk7Y29uc3QgZT1uZXcgeDt0aGlzLl9hcmdbMF0uY29tcHV0ZVNwbGl0RWRnZXMoZSksdGhpcy5fYXJnWzFdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpLHRoaXMuaW5zZXJ0VW5pcXVlRWRnZXMoZSksdGhpcy5jb21wdXRlTGFiZWxzRnJvbURlcHRocygpLHRoaXMucmVwbGFjZUNvbGxhcHNlZEVkZ2VzKCksJGkuY2hlY2tWYWxpZCh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLl9ncmFwaC5hZGRFZGdlcyh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLmNvbXB1dGVMYWJlbGxpbmcoKSx0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGVzKCksdGhpcy5maW5kUmVzdWx0QXJlYUVkZ2VzKHQpLHRoaXMuY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKTtjb25zdCBuPW5ldyBlaSh0aGlzLl9nZW9tRmFjdCk7bi5hZGQodGhpcy5fZ3JhcGgpLHRoaXMuX3Jlc3VsdFBvbHlMaXN0PW4uZ2V0UG9seWdvbnMoKTtjb25zdCBzPW5ldyB0cih0aGlzLHRoaXMuX2dlb21GYWN0LHRoaXMuX3B0TG9jYXRvcik7dGhpcy5fcmVzdWx0TGluZUxpc3Q9cy5idWlsZCh0KTtjb25zdCBpPW5ldyBlcih0aGlzLHRoaXMuX2dlb21GYWN0LHRoaXMuX3B0TG9jYXRvcik7dGhpcy5fcmVzdWx0UG9pbnRMaXN0PWkuYnVpbGQodCksdGhpcy5fcmVzdWx0R2VvbT10aGlzLmNvbXB1dGVHZW9tZXRyeSh0aGlzLl9yZXN1bHRQb2ludExpc3QsdGhpcy5fcmVzdWx0TGluZUxpc3QsdGhpcy5fcmVzdWx0UG9seUxpc3QsdCl9bGFiZWxJbmNvbXBsZXRlTm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9Y29weVBvaW50cyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLl9ncmFwaC5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fWZpbmRSZXN1bHRBcmVhRWRnZXModCl7Zm9yKGxldCBlPXRoaXMuX2dyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCk7cy5pc0FyZWEoKSYmIW4uaXNJbnRlcmlvckFyZWFFZGdlKCkmJmNyLmlzUmVzdWx0T2ZPcChzLmdldExvY2F0aW9uKDAsUG4uUklHSFQpLHMuZ2V0TG9jYXRpb24oMSxQbi5SSUdIVCksdCkmJm4uc2V0SW5SZXN1bHQoITApfX1jb21wdXRlTGFiZWxzRnJvbURlcHRocygpe2ZvcihsZXQgdD10aGlzLl9lZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKSxzPWUuZ2V0RGVwdGgoKTtpZighcy5pc051bGwoKSl7cy5ub3JtYWxpemUoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKW4uaXNOdWxsKHQpfHwhbi5pc0FyZWEoKXx8cy5pc051bGwodCl8fCgwPT09cy5nZXREZWx0YSh0KT9uLnRvTGluZSh0KToodS5pc1RydWUoIXMuaXNOdWxsKHQsUG4uTEVGVCksXCJkZXB0aCBvZiBMRUZUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24odCxQbi5MRUZULHMuZ2V0TG9jYXRpb24odCxQbi5MRUZUKSksdS5pc1RydWUoIXMuaXNOdWxsKHQsUG4uUklHSFQpLFwiZGVwdGggb2YgUklHSFQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbih0LFBuLlJJR0hULHMuZ2V0TG9jYXRpb24odCxQbi5SSUdIVCkpKSl9fX1jb21wdXRlTGFiZWxsaW5nKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLl9hcmcpfXRoaXMubWVyZ2VTeW1MYWJlbHMoKSx0aGlzLnVwZGF0ZU5vZGVMYWJlbGxpbmcoKX1sYWJlbEluY29tcGxldGVOb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO2UuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbEluY29tcGxldGVOb2RlKGUsMCk6dGhpcy5sYWJlbEluY29tcGxldGVOb2RlKGUsMSkpLGUuZ2V0RWRnZXMoKS51cGRhdGVMYWJlbGxpbmcobil9fWlzQ292ZXJlZEJ5QSh0KXtyZXR1cm4hIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5fcmVzdWx0UG9seUxpc3QpfWdldENsYXNzKCl7cmV0dXJuIGNyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdExvY2F0b3I9bmV3IF9uLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fcmVzdWx0R2VvbT1udWxsLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fZWRnZUxpc3Q9bmV3IGRpLHRoaXMuX3Jlc3VsdFBvbHlMaXN0PW5ldyB4LHRoaXMuX3Jlc3VsdExpbmVMaXN0PW5ldyB4LHRoaXMuX3Jlc3VsdFBvaW50TGlzdD1uZXcgeDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy5fZ3JhcGg9bmV3IFpuKG5ldyB1aSksdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCl9LGNyLklOVEVSU0VDVElPTj0xLGNyLlVOSU9OPTIsY3IuRElGRkVSRU5DRT0zLGNyLlNZTURJRkZFUkVOQ0U9NDt2YXIgaHI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsc25hcDpLaSxPdmVybGF5T3A6Y3J9KTtjbGFzcyB1ciBleHRlbmRzIGJpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx1ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1pc0luUmluZygpe3JldHVybiBudWxsIT09dGhpcy5fZWRnZVJpbmd9c2V0UmluZyh0KXt0aGlzLl9lZGdlUmluZz10fXNldExhYmVsKHQpe3RoaXMuX2xhYmVsPXR9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9Z2V0UmluZygpe3JldHVybiB0aGlzLl9lZGdlUmluZ31nZXRDbGFzcygpe3JldHVybiB1cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZWRnZVJpbmc9bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fbGFiZWw9LTE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107YmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixzKX07Y2xhc3MgZ3IgZXh0ZW5kcyBEaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZ3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2xpbmV9Z2V0Q2xhc3MoKXtyZXR1cm4gZ3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWdyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lPXR9O2NsYXNzIGRye2NvbnN0cnVjdG9yKCl7ZHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmluZERpZmZlcmVudFBvaW50KHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGUpKXJldHVybiB0W25dO3JldHVybiBudWxsfXZpc2l0SW50ZXJpb3JSaW5nKHQsZSl7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCkscz1uWzBdLGk9ZHIuZmluZERpZmZlcmVudFBvaW50KG4scykscj1lLmZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKHMsaSksbz1lLmZpbmRFZGdlRW5kKHIpO2xldCBsPW51bGw7by5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsUG4uUklHSFQpPT09bmUuSU5URVJJT1I/bD1vOm8uZ2V0U3ltKCkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLFBuLlJJR0hUKT09PW5lLklOVEVSSU9SJiYobD1vLmdldFN5bSgpKSx1LmlzVHJ1ZShudWxsIT09bCxcInVuYWJsZSB0byBmaW5kIGRpckVkZ2Ugd2l0aCBJbnRlcmlvciBvbiBSSFNcIiksdGhpcy52aXNpdExpbmtlZERpcmVjdGVkRWRnZXMobCl9dmlzaXRTaGVsbEludGVyaW9ycyh0LGUpe2lmKHQgaW5zdGFuY2VvZiBidCl7Y29uc3Qgbj10O3RoaXMudmlzaXRJbnRlcmlvclJpbmcobi5nZXRFeHRlcmlvclJpbmcoKSxlKX1pZih0IGluc3RhbmNlb2YgQXQpe2NvbnN0IG49dDtmb3IobGV0IHQ9MDt0PG4uZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5Tih0KTt0aGlzLnZpc2l0SW50ZXJpb3JSaW5nKHMuZ2V0RXh0ZXJpb3JSaW5nKCksZSl9fX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZH1zZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQodCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCk9PT1uZS5JTlRFUklPUiYmdC5zZXRJblJlc3VsdCghMCl9fXZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlcyh0KXtjb25zdCBlPXQ7bGV0IG49dDtkb3t1LmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgRGlyZWN0ZWQgRWRnZVwiKSxuLnNldFZpc2l0ZWQoITApLG49bi5nZXROZXh0KCl9d2hpbGUobiE9PWUpfWJ1aWxkRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc0luUmVzdWx0KCkmJm51bGw9PT10LmdldEVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3IHRpKHQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtuLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO2NvbnN0IHM9bi5idWlsZE1pbmltYWxSaW5ncygpO2UuYWRkQWxsKHMpfX1yZXR1cm4gZX1oYXNVbnZpc2l0ZWRTaGVsbEVkZ2UodCl7Zm9yKGxldCBlPTA7ZTx0LnNpemUoKTtlKyspe2NvbnN0IG49dC5nZXQoZSk7aWYobi5pc0hvbGUoKSljb250aW51ZTtjb25zdCBzPW4uZ2V0RWRnZXMoKTtsZXQgaT1zLmdldCgwKTtpZihpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCk9PT1uZS5JTlRFUklPUilmb3IobGV0IHQ9MDt0PHMuc2l6ZSgpO3QrKylpZihpPXMuZ2V0KHQpLCFpLmlzVmlzaXRlZCgpKXJldHVybiB0aGlzLl9kaXNjb25uZWN0ZWRSaW5nY29vcmQ9aS5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9aXNJbnRlcmlvcnNDb25uZWN0ZWQoKXtjb25zdCB0PW5ldyB4O3RoaXMuX2dlb21HcmFwaC5jb21wdXRlU3BsaXRFZGdlcyh0KTtjb25zdCBlPW5ldyBabihuZXcgdWkpO2UuYWRkRWRnZXModCksdGhpcy5zZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQoZSksZS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpO2NvbnN0IG49dGhpcy5idWlsZEVkZ2VSaW5ncyhlLmdldEVkZ2VFbmRzKCkpO3JldHVybiB0aGlzLnZpc2l0U2hlbGxJbnRlcmlvcnModGhpcy5fZ2VvbUdyYXBoLmdldEdlb21ldHJ5KCksZSksIXRoaXMuaGFzVW52aXNpdGVkU2hlbGxFZGdlKG4pfWdldENsYXNzKCl7cmV0dXJuIGRyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1kci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bmV3IEh0LHRoaXMuX2dlb21HcmFwaD1udWxsLHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21HcmFwaD10fTtjbGFzcyBfcntjb25zdHJ1Y3Rvcigpe19yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlRWRnZUVuZEZvck5leHQodCxlLG4scyl7Y29uc3QgaT1uLnNlZ21lbnRJbmRleCsxO2lmKGk+PXQuZ2V0TnVtUG9pbnRzKCkmJm51bGw9PT1zKXJldHVybiBudWxsO2xldCByPXQuZ2V0Q29vcmRpbmF0ZShpKTtudWxsIT09cyYmcy5zZWdtZW50SW5kZXg9PT1uLnNlZ21lbnRJbmRleCYmKHI9cy5jb29yZCk7Y29uc3Qgbz1uZXcgSG4odCxuLmNvb3JkLHIsbmV3IEZuKHQuZ2V0TGFiZWwoKSkpO2UuYWRkKG8pfWNyZWF0ZUVkZ2VFbmRGb3JQcmV2KHQsZSxuLHMpe2xldCBpPW4uc2VnbWVudEluZGV4O2lmKDA9PT1uLmRpc3Qpe2lmKDA9PT1pKXJldHVybiBudWxsO2ktLX1sZXQgcj10LmdldENvb3JkaW5hdGUoaSk7bnVsbCE9PXMmJnMuc2VnbWVudEluZGV4Pj1pJiYocj1zLmNvb3JkKTtjb25zdCBvPW5ldyBGbih0LmdldExhYmVsKCkpO28uZmxpcCgpO2NvbnN0IGw9bmV3IEhuKHQsbi5jb29yZCxyLG8pO2UuYWRkKGwpfWNvbXB1dGVFZGdlRW5kcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4O2ZvcihsZXQgbj10O24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLmNvbXB1dGVFZGdlRW5kcyh0LGUpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtuLmFkZEVuZHBvaW50cygpO2NvbnN0IHM9bi5pdGVyYXRvcigpO2xldCBpPW51bGwscj1udWxsO2lmKCFzLmhhc05leHQoKSlyZXR1cm4gbnVsbDtsZXQgbz1zLm5leHQoKTtkb3tpPXIscj1vLG89bnVsbCxzLmhhc05leHQoKSYmKG89cy5uZXh0KCkpLG51bGwhPT1yJiYodGhpcy5jcmVhdGVFZGdlRW5kRm9yUHJldih0LGUscixpKSx0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JOZXh0KHQsZSxyLG8pKX13aGlsZShudWxsIT09cil9fWdldENsYXNzKCl7cmV0dXJuIF9yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1fci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGZyIGV4dGVuZHMgSG57Y29uc3RydWN0b3IoKXtzdXBlcigpLGZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0KHQpe3RoaXMuX2VkZ2VFbmRzLmFkZCh0KX1wcmludCh0KXt0LnByaW50bG4oXCJFZGdlRW5kQnVuZGxlLS1cXHgzZSBMYWJlbDogXCIrdGhpcy5fbGFiZWwpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KSx0LnByaW50bG4oKX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZUVuZHMuaXRlcmF0b3IoKX1nZXRFZGdlRW5kcygpe3JldHVybiB0aGlzLl9lZGdlRW5kc31jb21wdXRlTGFiZWxPbih0LGUpe2xldCBuPTAscz0hMTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgaT1lLm5leHQoKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2k9PT1uZS5CT1VOREFSWSYmbisrLGk9PT1uZS5JTlRFUklPUiYmKHM9ITApfWxldCBpPW5lLk5PTkU7cyYmKGk9bmUuSU5URVJJT1IpLG4+MCYmKGk9UW4uZGV0ZXJtaW5lQm91bmRhcnkoZSxuKSksdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxpKX1jb21wdXRlTGFiZWxTaWRlKHQsZSl7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocy5nZXRMYWJlbCgpLmlzQXJlYSgpKXtjb25zdCBuPXMuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LGUpO2lmKG49PT1uZS5JTlRFUklPUilyZXR1cm4gdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlLG5lLklOVEVSSU9SKSxudWxsO249PT1uZS5FWFRFUklPUiYmdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlLG5lLkVYVEVSSU9SKX19fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWNvbXB1dGVMYWJlbFNpZGVzKHQpe3RoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LFBuLkxFRlQpLHRoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LFBuLlJJR0hUKX11cGRhdGVJTSh0KXtVbi51cGRhdGVJTSh0aGlzLl9sYWJlbCx0KX1jb21wdXRlTGFiZWwodCl7bGV0IGU9ITE7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldExhYmVsKCkuaXNBcmVhKCkmJihlPSEwKX10aGlzLl9sYWJlbD1lP25ldyBGbihuZS5OT05FLG5lLk5PTkUsbmUuTk9ORSk6bmV3IEZuKG5lLk5PTkUpO2ZvcihsZXQgbj0wO248MjtuKyspdGhpcy5jb21wdXRlTGFiZWxPbihuLHQpLGUmJnRoaXMuY29tcHV0ZUxhYmVsU2lkZXMobil9Z2V0Q2xhc3MoKXtyZXR1cm4gZnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2VkZ2VFbmRzPW5ldyB4LDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG51bGwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07SG4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LmdldEVkZ2UoKSx0LmdldENvb3JkaW5hdGUoKSx0LmdldERpcmVjdGVkQ29vcmRpbmF0ZSgpLG5ldyBGbih0LmdldExhYmVsKCkpKSx0aGlzLmluc2VydCh0KX19O2NsYXNzIHByIGV4dGVuZHMgY2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLHByLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dXBkYXRlSU0odCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnVwZGF0ZUlNKHQpfX1pbnNlcnQodCl7bGV0IGU9dGhpcy5fZWRnZU1hcC5nZXQodCk7bnVsbD09PWU/KGU9bmV3IGZyKHQpLHRoaXMuaW5zZXJ0RWRnZUVuZCh0LGUpKTplLmluc2VydCh0KX1nZXRDbGFzcygpe3JldHVybiBwcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBtciBleHRlbmRzIGtue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxtci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXVwZGF0ZUlNRnJvbUVkZ2VzKHQpe3RoaXMuX2VkZ2VzLnVwZGF0ZUlNKHQpfWNvbXB1dGVJTSh0KXt0LnNldEF0TGVhc3RJZlZhbGlkKHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKDApLHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKDEpLDApfWdldENsYXNzKCl7cmV0dXJuIG1yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1tci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtrbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9O2NsYXNzIHlyIGV4dGVuZHMgS257Y29uc3RydWN0b3IoKXtzdXBlcigpLHlyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IG1yKHQsbmV3IHByKX1nZXRDbGFzcygpe3JldHVybiB5cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB4cntjb25zdHJ1Y3Rvcigpe3hyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0RWRnZUVuZHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkKHQpfX1nZXROb2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKX1jb3B5Tm9kZXNBbmRMYWJlbHModCxlKXtmb3IobGV0IG49dC5nZXROb2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkTm9kZSh0LmdldENvb3JkaW5hdGUoKSkuc2V0TGFiZWwoZSx0LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSkpfX1idWlsZCh0KXt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0LDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKHQsMCk7Y29uc3QgZT0obmV3IF9yKS5jb21wdXRlRWRnZUVuZHModC5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhlKX1jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCxlKXtmb3IobGV0IG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkscz10LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSk7Zm9yKGxldCBuPXQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxpPXRoaXMuX25vZGVzLmFkZE5vZGUodC5jb29yZCk7cz09PW5lLkJPVU5EQVJZP2kuc2V0TGFiZWxCb3VuZGFyeShlKTppLmdldExhYmVsKCkuaXNOdWxsKGUpJiZpLnNldExhYmVsKGUsbmUuSU5URVJJT1IpfX19Z2V0Q2xhc3MoKXtyZXR1cm4geHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXhyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25vZGVzPW5ldyBYbihuZXcgeXIpfTtjbGFzcyBFcntjb25zdHJ1Y3Rvcigpe0VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNOb2RlRWRnZUFyZWFMYWJlbHNDb25zaXN0ZW50KCl7Zm9yKGxldCB0PXRoaXMuX25vZGVHcmFwaC5nZXROb2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7aWYoIWUuZ2V0RWRnZXMoKS5pc0FyZWFMYWJlbHNDb25zaXN0ZW50KHRoaXMuX2dlb21HcmFwaCkpcmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludD1lLmdldENvb3JkaW5hdGUoKS5jb3B5KCksITF9cmV0dXJuITB9Z2V0SW52YWxpZFBvaW50KCl7cmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludH1oYXNEdXBsaWNhdGVSaW5ncygpe2ZvcihsZXQgdD10aGlzLl9ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtmb3IobGV0IGU9dC5uZXh0KCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZih0LmdldEVkZ2VFbmRzKCkuc2l6ZSgpPjEpcmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludD10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlKDApLCEwfX1yZXR1cm4hMX1pc05vZGVDb25zaXN0ZW50QXJlYSgpe2NvbnN0IHQ9dGhpcy5fZ2VvbUdyYXBoLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITAsITApO3JldHVybiB0Lmhhc1Byb3BlckludGVyc2VjdGlvbigpPyh0aGlzLl9pbnZhbGlkUG9pbnQ9dC5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKToodGhpcy5fbm9kZUdyYXBoLmJ1aWxkKHRoaXMuX2dlb21HcmFwaCksdGhpcy5pc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gRXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUVyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW5ldyB0ZSx0aGlzLl9nZW9tR3JhcGg9bnVsbCx0aGlzLl9ub2RlR3JhcGg9bmV3IHhyLHRoaXMuX2ludmFsaWRQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21HcmFwaD10fTtjbGFzcyBJcntjb25zdHJ1Y3Rvcigpe0lyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YnVpbGRJbmRleCgpe3RoaXMuX2luZGV4PW5ldyBFcztmb3IobGV0IHQ9MDt0PHRoaXMuX3JpbmdzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fcmluZ3MuZ2V0KHQpLG49ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7dGhpcy5faW5kZXguaW5zZXJ0KG4sZSl9fWdldE5lc3RlZFBvaW50KCl7cmV0dXJuIHRoaXMuX25lc3RlZFB0fWlzTm9uTmVzdGVkKCl7dGhpcy5idWlsZEluZGV4KCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9yaW5ncy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX3JpbmdzLmdldCh0KSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKSxzPXRoaXMuX2luZGV4LnF1ZXJ5KGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtmb3IobGV0IHQ9MDt0PHMuc2l6ZSgpO3QrKyl7Y29uc3QgaT1zLmdldCh0KSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlPT09aSljb250aW51ZTtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhpLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpY29udGludWU7Y29uc3Qgbz1Dci5maW5kUHROb3ROb2RlKG4saSx0aGlzLl9ncmFwaCk7aWYobnVsbCE9PW8mJldlLmlzSW5SaW5nKG8scikpcmV0dXJuIHRoaXMuX25lc3RlZFB0PW8sITF9fXJldHVybiEwfWFkZCh0KXt0aGlzLl9yaW5ncy5hZGQodCksdGhpcy5fdG90YWxFbnYuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX1nZXRDbGFzcygpe3JldHVybiBJcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9yaW5ncz1uZXcgeCx0aGlzLl90b3RhbEVudj1uZXcgTix0aGlzLl9pbmRleD1udWxsLHRoaXMuX25lc3RlZFB0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ3JhcGg9dH07Y2xhc3MgTnJ7Y29uc3RydWN0b3IoKXtOci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEVycm9yVHlwZSgpe3JldHVybiB0aGlzLl9lcnJvclR5cGV9Z2V0TWVzc2FnZSgpe3JldHVybiBOci5lcnJNc2dbdGhpcy5fZXJyb3JUeXBlXX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fXRvU3RyaW5nKCl7bGV0IHQ9XCJcIjtyZXR1cm4gbnVsbCE9PXRoaXMuX3B0JiYodD1cIiBhdCBvciBuZWFyIHBvaW50IFwiK3RoaXMuX3B0KSx0aGlzLmdldE1lc3NhZ2UoKSt0fWdldENsYXNzKCl7cmV0dXJuIE5yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Oci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9lcnJvclR5cGU9bnVsbCx0aGlzLl9wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtOci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZXJyb3JUeXBlPXQsbnVsbCE9PWUmJih0aGlzLl9wdD1lLmNvcHkoKSl9fSxOci5FUlJPUj0wLE5yLlJFUEVBVEVEX1BPSU5UPTEsTnIuSE9MRV9PVVRTSURFX1NIRUxMPTIsTnIuTkVTVEVEX0hPTEVTPTMsTnIuRElTQ09OTkVDVEVEX0lOVEVSSU9SPTQsTnIuU0VMRl9JTlRFUlNFQ1RJT049NSxOci5SSU5HX1NFTEZfSU5URVJTRUNUSU9OPTYsTnIuTkVTVEVEX1NIRUxMUz03LE5yLkRVUExJQ0FURV9SSU5HUz04LE5yLlRPT19GRVdfUE9JTlRTPTksTnIuSU5WQUxJRF9DT09SRElOQVRFPTEwLE5yLlJJTkdfTk9UX0NMT1NFRD0xMSxOci5lcnJNc2c9W1wiVG9wb2xvZ3kgVmFsaWRhdGlvbiBFcnJvclwiLFwiUmVwZWF0ZWQgUG9pbnRcIixcIkhvbGUgbGllcyBvdXRzaWRlIHNoZWxsXCIsXCJIb2xlcyBhcmUgbmVzdGVkXCIsXCJJbnRlcmlvciBpcyBkaXNjb25uZWN0ZWRcIixcIlNlbGYtaW50ZXJzZWN0aW9uXCIsXCJSaW5nIFNlbGYtaW50ZXJzZWN0aW9uXCIsXCJOZXN0ZWQgc2hlbGxzXCIsXCJEdXBsaWNhdGUgUmluZ3NcIixcIlRvbyBmZXcgZGlzdGluY3QgcG9pbnRzIGluIGdlb21ldHJ5IGNvbXBvbmVudFwiLFwiSW52YWxpZCBDb29yZGluYXRlXCIsXCJSaW5nIGlzIG5vdCBjbG9zZWRcIl07Y2xhc3MgQ3J7Y29uc3RydWN0b3IoKXtDci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaW5kUHROb3ROb2RlKHQsZSxuKXtjb25zdCBzPW4uZmluZEVkZ2UoZSkuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj10W2VdO2lmKCFzLmlzSW50ZXJzZWN0aW9uKG4pKXJldHVybiBufXJldHVybiBudWxsfXN0YXRpYyBpc1ZhbGlkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IENyKHQpLmlzVmFsaWQoKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiFpLmlzTmFOKHQueCkmJighaS5pc0luZmluaXRlKHQueCkmJighaS5pc05hTih0LnkpJiYhaS5pc0luZmluaXRlKHQueSkpKX19Y2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZighQ3IuaXNWYWxpZCh0W2VdKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLklOVkFMSURfQ09PUkRJTkFURSx0W2VdKSxudWxsfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBidCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKWlmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRJbnRlcmlvclJpbmdOKGUpLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19Y2hlY2tIb2xlc05vdE5lc3RlZCh0LGUpe2NvbnN0IG49bmV3IElyKGUpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe2NvbnN0IHM9dC5nZXRJbnRlcmlvclJpbmdOKGUpO24uYWRkKHMpfW4uaXNOb25OZXN0ZWQoKXx8KHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5ORVNURURfSE9MRVMsbi5nZXROZXN0ZWRQb2ludCgpKSl9Y2hlY2tDb25zaXN0ZW50QXJlYSh0KXtjb25zdCBlPW5ldyBFcih0KTtpZighZS5pc05vZGVDb25zaXN0ZW50QXJlYSgpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuU0VMRl9JTlRFUlNFQ1RJT04sZS5nZXRJbnZhbGlkUG9pbnQoKSksbnVsbDtlLmhhc0R1cGxpY2F0ZVJpbmdzKCkmJih0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuRFVQTElDQVRFX1JJTkdTLGUuZ2V0SW52YWxpZFBvaW50KCkpKX1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLl9wYXJlbnRHZW9tZXRyeSksbnVsbD09PXRoaXMuX3ZhbGlkRXJyfWNoZWNrU2hlbGxJbnNpZGVIb2xlKHQsZSxuKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0Q29vcmRpbmF0ZXMoKSxyPUNyLmZpbmRQdE5vdE5vZGUocyxlLG4pO2lmKG51bGwhPT1yKXtpZighV2UuaXNJblJpbmcocixpKSlyZXR1cm4gcn1jb25zdCBvPUNyLmZpbmRQdE5vdE5vZGUoaSx0LG4pO2lmKG51bGwhPT1vKXtyZXR1cm4gV2UuaXNJblJpbmcobyxzKT9vOm51bGx9cmV0dXJuIHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJwb2ludHMgaW4gc2hlbGwgYW5kIGhvbGUgYXBwZWFyIHRvIGJlIGVxdWFsXCIpLG51bGx9Y2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyh0KXtmb3IobGV0IGU9dC5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmcodC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fWNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKHQpe2NvbnN0IGU9bmV3IGRyKHQpO2UuaXNJbnRlcmlvcnNDb25uZWN0ZWQoKXx8KHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5ESVNDT05ORUNURURfSU5URVJJT1IsZS5nZXRDb29yZGluYXRlKCkpKX1jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmcodCl7Y29uc3QgZT1uZXcgYXQ7bGV0IG49ITA7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7aWYobiluPSExO2Vsc2V7aWYoZS5jb250YWlucyh0LmNvb3JkKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT04sdC5jb29yZCksbnVsbDtlLmFkZCh0LmNvb3JkKX19fWNoZWNrSG9sZXNJblNoZWxsKHQsZSl7Y29uc3Qgbj10LmdldEV4dGVyaW9yUmluZygpLHM9bmV3IGtlKG4pO2ZvcihsZXQgaT0wO2k8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtpKyspe2NvbnN0IHI9dC5nZXRJbnRlcmlvclJpbmdOKGkpLG89Q3IuZmluZFB0Tm90Tm9kZShyLmdldENvb3JkaW5hdGVzKCksbixlKTtpZihudWxsPT09bylyZXR1cm4gbnVsbDtpZihuZS5FWFRFUklPUj09PXMubG9jYXRlKG8pKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuSE9MRV9PVVRTSURFX1NIRUxMLG8pLG51bGx9fWNoZWNrVG9vRmV3UG9pbnRzKHQpe2lmKHQuaGFzVG9vRmV3UG9pbnRzKCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5UT09fRkVXX1BPSU5UUyx0LmdldEludmFsaWRQb2ludCgpKSxudWxsfWdldFZhbGlkYXRpb25FcnJvcigpe3JldHVybiB0aGlzLmNoZWNrVmFsaWQodGhpcy5fcGFyZW50R2VvbWV0cnkpLHRoaXMuX3ZhbGlkRXJyfWNoZWNrVmFsaWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFB0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE10KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIER0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBRbigwLHQpO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IG49bmV3IHRlO2UuY29tcHV0ZVNlbGZOb2RlcyhuLCEwLCEwKSx0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IFFuKDAsdCk7dGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyh0KSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgUW4oMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycikpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMobiksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhuKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Y29uc3QgZT1uZXcgUW4oMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycikpcmV0dXJuIG51bGw7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbChzLGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1mb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKTtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQocyxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9aWYodGhpcy5jaGVja1NoZWxsc05vdE5lc3RlZCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDt0aGlzLmNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYodGhpcy5jaGVja1ZhbGlkKG4pLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuX3ZhbGlkRXJyPW51bGwsdC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBNdCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgRHQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBidCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgX3QpKXRocm93IG5ldyBaKHQuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuY2hlY2tWYWxpZCh0KX19fXNldFNlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkKHQpe3RoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9dH1jaGVja1NoZWxsTm90TmVzdGVkKHQsZSxuKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscj1pLmdldENvb3JkaW5hdGVzKCksbz1Dci5maW5kUHROb3ROb2RlKHMsaSxuKTtpZihudWxsPT09bylyZXR1cm4gbnVsbDtpZighV2UuaXNJblJpbmcobyxyKSlyZXR1cm4gbnVsbDtpZihlLmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuTkVTVEVEX1NIRUxMUyxvKSxudWxsO2xldCBsPW51bGw7Zm9yKGxldCBzPTA7czxlLmdldE51bUludGVyaW9yUmluZygpO3MrKyl7Y29uc3QgaT1lLmdldEludGVyaW9yUmluZ04ocyk7aWYobD10aGlzLmNoZWNrU2hlbGxJbnNpZGVIb2xlKHQsaSxuKSxudWxsPT09bClyZXR1cm4gbnVsbH10aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuTkVTVEVEX1NIRUxMUyxsKX1jaGVja0Nsb3NlZFJpbmdzKHQpe2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKWlmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihlKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWNoZWNrQ2xvc2VkUmluZyh0KXtpZighdC5pc0Nsb3NlZCgpKXtsZXQgZT1udWxsO3QuZ2V0TnVtUG9pbnRzKCk+PTEmJihlPXQuZ2V0Q29vcmRpbmF0ZU4oMCkpLHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5SSU5HX05PVF9DTE9TRUQsZSl9fWNoZWNrU2hlbGxzTm90TmVzdGVkKHQsZSl7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obikuZ2V0RXh0ZXJpb3JSaW5nKCk7Zm9yKGxldCBpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe2lmKG49PT1pKWNvbnRpbnVlO2NvbnN0IHI9dC5nZXRHZW9tZXRyeU4oaSk7aWYodGhpcy5jaGVja1NoZWxsTm90TmVzdGVkKHMscixlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fX1nZXRDbGFzcygpe3JldHVybiBDcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Q3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcGFyZW50R2VvbWV0cnk9bnVsbCx0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkPSExLHRoaXMuX3ZhbGlkRXJyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50R2VvbWV0cnk9dH07Y2xhc3MgU3J7Y29uc3RydWN0b3IoKXtTci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaW5kRGlyRWRnZXNJblJpbmcodCl7bGV0IGU9dDtjb25zdCBuPW5ldyB4O2Rve24uYWRkKGUpLGU9ZS5nZXROZXh0KCksdS5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksdS5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUoZSE9PXQpO3JldHVybiBufXN0YXRpYyBhZGRFZGdlKHQsZSxuKXtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKW4uYWRkKHRbZV0sITEpO2Vsc2UgZm9yKGxldCBlPXQubGVuZ3RoLTE7ZT49MDtlLS0pbi5hZGQodFtlXSwhMSl9c3RhdGljIGZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKXtjb25zdCBuPXQuZ2V0UmluZygpLHM9bi5nZXRFbnZlbG9wZUludGVybmFsKCk7bGV0IGk9bi5nZXRDb29yZGluYXRlTigwKSxyPW51bGwsbz1udWxsO2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLGw9ZS5nZXRSaW5nKCksYT1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZihhLmVxdWFscyhzKSljb250aW51ZTtpZighYS5jb250YWlucyhzKSljb250aW51ZTtpPVgucHROb3RJbkxpc3Qobi5nZXRDb29yZGluYXRlcygpLGwuZ2V0Q29vcmRpbmF0ZXMoKSk7bGV0IGM9ITE7V2UuaXNJblJpbmcoaSxsLmdldENvb3JkaW5hdGVzKCkpJiYoYz0hMCksYyYmKG51bGw9PT1yfHxvLmNvbnRhaW5zKGEpKSYmKHI9ZSxvPXIuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9cmV0dXJuIHJ9aXNJbmNsdWRlZCgpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkfWdldENvb3JkaW5hdGVzKCl7aWYobnVsbD09PXRoaXMuX3JpbmdQdHMpe2NvbnN0IHQ9bmV3IEk7Zm9yKGxldCBlPXRoaXMuX2RlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0RWRnZSgpO1NyLmFkZEVkZ2Uocy5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSxuLmdldEVkZ2VEaXJlY3Rpb24oKSx0KX10aGlzLl9yaW5nUHRzPXQudG9Db29yZGluYXRlQXJyYXkoKX1yZXR1cm4gdGhpcy5fcmluZ1B0c31pc0luY2x1ZGVkU2V0KCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWRTZXR9aXNWYWxpZCgpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksISh0aGlzLl9yaW5nUHRzLmxlbmd0aDw9MykmJih0aGlzLmdldFJpbmcoKSxDci5pc1ZhbGlkKHRoaXMuX3JpbmcpKX1idWlsZCh0KXtsZXQgZT10O2Rve3RoaXMuYWRkKGUpLGUuc2V0UmluZyh0aGlzKSxlPWUuZ2V0TmV4dCgpLHUuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLHUuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKGUhPT10KX1pc091dGVySG9sZSgpe3JldHVybiEhdGhpcy5faXNIb2xlJiYhdGhpcy5oYXNTaGVsbCgpfWdldFBvbHlnb24oKXtsZXQgdD1udWxsO2lmKG51bGwhPT10aGlzLl9ob2xlcyl7dD1uZXcgQXJyYXkodGhpcy5faG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMuX2hvbGVzLmdldChlKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHRoaXMuX3JpbmcsdCl9aXNIb2xlKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX1pc1Byb2Nlc3NlZCgpe3JldHVybiB0aGlzLl9pc1Byb2Nlc3NlZH1hZGRIb2xlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuX2hvbGVzJiYodGhpcy5faG9sZXM9bmV3IHgpLHRoaXMuX2hvbGVzLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Ipe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3Quc2V0U2hlbGwodGhpcyk7Y29uc3QgZT10LmdldFJpbmcoKTtudWxsPT09dGhpcy5faG9sZXMmJih0aGlzLl9ob2xlcz1uZXcgeCksdGhpcy5faG9sZXMuYWRkKGUpfX1zZXRJbmNsdWRlZCh0KXt0aGlzLl9pc0luY2x1ZGVkPXQsdGhpcy5faXNJbmNsdWRlZFNldD0hMH1nZXRPdXRlckhvbGUoKXtpZih0aGlzLmlzSG9sZSgpKXJldHVybiBudWxsO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZGVMaXN0LnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fZGVMaXN0LmdldCh0KS5nZXRTeW0oKS5nZXRSaW5nKCk7aWYoZS5pc091dGVySG9sZSgpKXJldHVybiBlfXJldHVybiBudWxsfWNvbXB1dGVIb2xlKCl7Y29uc3QgdD10aGlzLmdldFJpbmcoKTt0aGlzLl9pc0hvbGU9di5pc0NDVyh0LmdldENvb3JkaW5hdGVzKCkpfWhhc1NoZWxsKCl7cmV0dXJuIG51bGwhPT10aGlzLl9zaGVsbH1pc091dGVyU2hlbGwoKXtyZXR1cm4gbnVsbCE9PXRoaXMuZ2V0T3V0ZXJIb2xlKCl9Z2V0TGluZVN0cmluZygpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuX3JpbmdQdHMpfXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyhuZXcgenQodGhpcy5nZXRDb29yZGluYXRlcygpKSl9Z2V0U2hlbGwoKXtyZXR1cm4gdGhpcy5pc0hvbGUoKT90aGlzLl9zaGVsbDp0aGlzfWFkZCh0KXt0aGlzLl9kZUxpc3QuYWRkKHQpfWdldFJpbmcoKXtpZihudWxsIT09dGhpcy5fcmluZylyZXR1cm4gdGhpcy5fcmluZzt0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5fcmluZ1B0cy5sZW5ndGg8MyYmTy5vdXQucHJpbnRsbih0aGlzLl9yaW5nUHRzKTt0cnl7dGhpcy5fcmluZz10aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodGhpcy5fcmluZ1B0cyl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgQykpdGhyb3cgdDtPLm91dC5wcmludGxuKHRoaXMuX3JpbmdQdHMpfXJldHVybiB0aGlzLl9yaW5nfXVwZGF0ZUluY2x1ZGVkKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IHQ9MDt0PHRoaXMuX2RlTGlzdC5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX2RlTGlzdC5nZXQodCkuZ2V0U3ltKCkuZ2V0UmluZygpLmdldFNoZWxsKCk7aWYobnVsbCE9PWUmJmUuaXNJbmNsdWRlZFNldCgpKXJldHVybiB0aGlzLnNldEluY2x1ZGVkKCFlLmlzSW5jbHVkZWQoKSksbnVsbH19c2V0U2hlbGwodCl7dGhpcy5fc2hlbGw9dH1zZXRQcm9jZXNzZWQodCl7dGhpcy5faXNQcm9jZXNzZWQ9dH1nZXRDbGFzcygpe3JldHVybiBTcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3Mgd3J7Y29uc3RydWN0b3IoKXt3ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmUodCxlKXtjb25zdCBuPWU7cmV0dXJuIHQuZ2V0UmluZygpLmdldEVudmVsb3BlKCkuY29tcGFyZVRvKG4uZ2V0UmluZygpLmdldEVudmVsb3BlKCkpfWdldENsYXNzKCl7cmV0dXJuIHdyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19d3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxTci5FbnZlbG9wZUNvbXBhcmF0b3I9d3IsU3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2RlTGlzdD1uZXcgeCx0aGlzLl9sb3dlc3RFZGdlPW51bGwsdGhpcy5fcmluZz1udWxsLHRoaXMuX3JpbmdQdHM9bnVsbCx0aGlzLl9ob2xlcz1udWxsLHRoaXMuX3NoZWxsPW51bGwsdGhpcy5faXNIb2xlPW51bGwsdGhpcy5faXNQcm9jZXNzZWQ9ITEsdGhpcy5faXNJbmNsdWRlZFNldD0hMSx0aGlzLl9pc0luY2x1ZGVkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH07Y2xhc3MgTHIgZXh0ZW5kcyBCaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmluZExhYmVsZWRFZGdlUmluZ3ModCl7Y29uc3QgZT1uZXcgeDtsZXQgbj0xO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2lmKHQuaXNNYXJrZWQoKSljb250aW51ZTtpZih0LmdldExhYmVsKCk+PTApY29udGludWU7ZS5hZGQodCk7Y29uc3QgaT1Tci5maW5kRGlyRWRnZXNJblJpbmcodCk7THIubGFiZWwoaSxuKSxuKyt9cmV0dXJuIGV9c3RhdGljIGdldERlZ3JlZU5vbkRlbGV0ZWQodCl7bGV0IGU9MDtmb3IobGV0IG49dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLmlzTWFya2VkKCl8fGUrK31yZXR1cm4gZX1zdGF0aWMgZGVsZXRlQWxsRWRnZXModCl7Zm9yKGxldCBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0TWFya2VkKCEwKTtjb25zdCBuPXQuZ2V0U3ltKCk7bnVsbCE9PW4mJm4uc2V0TWFya2VkKCEwKX19c3RhdGljIGxhYmVsKHQsZSl7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLnNldExhYmVsKGUpfX1zdGF0aWMgY29tcHV0ZU5leHRDV0VkZ2VzKHQpe2xldCBlPW51bGwsbj1udWxsO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtpZighdC5pc01hcmtlZCgpKXtpZihudWxsPT09ZSYmKGU9dCksbnVsbCE9PW4pe24uZ2V0U3ltKCkuc2V0TmV4dCh0KX1uPXR9fWlmKG51bGwhPT1uKXtuLmdldFN5bSgpLnNldE5leHQoZSl9fXN0YXRpYyBjb21wdXRlTmV4dENDV0VkZ2VzKHQsZSl7bGV0IG49bnVsbCxzPW51bGw7Y29uc3QgaT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKTtmb3IobGV0IHQ9aS5zaXplKCktMTt0Pj0wO3QtLSl7Y29uc3Qgcj1pLmdldCh0KSxvPXIuZ2V0U3ltKCk7bGV0IGw9bnVsbDtyLmdldExhYmVsKCk9PT1lJiYobD1yKTtsZXQgYT1udWxsO28uZ2V0TGFiZWwoKT09PWUmJihhPW8pLG51bGw9PT1sJiZudWxsPT09YXx8KG51bGwhPT1hJiYocz1hKSxudWxsIT09bCYmKG51bGwhPT1zJiYocy5zZXROZXh0KGwpLHM9bnVsbCksbnVsbD09PW4mJihuPWwpKSl9bnVsbCE9PXMmJih1LmlzVHJ1ZShudWxsIT09bikscy5zZXROZXh0KG4pKX1zdGF0aWMgZ2V0RGVncmVlKHQsZSl7bGV0IG49MDtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3MubmV4dCgpLmdldExhYmVsKCk9PT1lJiZuKyt9cmV0dXJuIG59c3RhdGljIGZpbmRJbnRlcnNlY3Rpb25Ob2Rlcyh0LGUpe2xldCBuPXQscz1udWxsO2Rve2NvbnN0IGk9bi5nZXRGcm9tTm9kZSgpO0xyLmdldERlZ3JlZShpLGUpPjEmJihudWxsPT09cyYmKHM9bmV3IHgpLHMuYWRkKGkpKSxuPW4uZ2V0TmV4dCgpLHUuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLHUuaXNUcnVlKG49PT10fHwhbi5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKG4hPT10KTtyZXR1cm4gc31maW5kRWRnZVJpbmcodCl7Y29uc3QgZT1uZXcgU3IodGhpcy5fZmFjdG9yeSk7cmV0dXJuIGUuYnVpbGQodCksZX1jb21wdXRlRGVwdGhQYXJpdHkoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IoOzspcmV0dXJuIG51bGx9Y29tcHV0ZU5leHRDV0VkZ2VzKCl7Zm9yKGxldCB0PXRoaXMubm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO0xyLmNvbXB1dGVOZXh0Q1dFZGdlcyhlKX19YWRkRWRnZSh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBlPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiBudWxsO2NvbnN0IG49ZVswXSxzPWVbZS5sZW5ndGgtMV0saT10aGlzLmdldE5vZGUobikscj10aGlzLmdldE5vZGUocyksbz1uZXcgdXIoaSxyLGVbMV0sITApLGw9bmV3IHVyKHIsaSxlW2UubGVuZ3RoLTJdLCExKSxhPW5ldyBncih0KTthLnNldERpcmVjdGVkRWRnZXMobyxsKSx0aGlzLmFkZChhKX1kZWxldGVDdXRFZGdlcygpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCksTHIuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5fZGlyRWRnZXMpO2NvbnN0IHQ9bmV3IHg7Zm9yKGxldCBlPXRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4uaXNNYXJrZWQoKSljb250aW51ZTtjb25zdCBzPW4uZ2V0U3ltKCk7aWYobi5nZXRMYWJlbCgpPT09cy5nZXRMYWJlbCgpKXtuLnNldE1hcmtlZCghMCkscy5zZXRNYXJrZWQoITApO2NvbnN0IGU9bi5nZXRFZGdlKCk7dC5hZGQoZS5nZXRMaW5lKCkpfX1yZXR1cm4gdH1nZXRFZGdlUmluZ3MoKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLExyLmxhYmVsKHRoaXMuX2RpckVkZ2VzLC0xKTtjb25zdCB0PUxyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuX2RpckVkZ2VzKTt0aGlzLmNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzKHQpO2NvbnN0IGU9bmV3IHg7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO2lmKG4uaXNNYXJrZWQoKSljb250aW51ZTtpZihuLmlzSW5SaW5nKCkpY29udGludWU7Y29uc3Qgcz10aGlzLmZpbmRFZGdlUmluZyhuKTtlLmFkZChzKX1yZXR1cm4gZX1nZXROb2RlKHQpe2xldCBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgRmkodCksdGhpcy5hZGQoZSkpLGV9Y29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3ModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldExhYmVsKCkscz1Mci5maW5kSW50ZXJzZWN0aW9uTm9kZXModCxuKTtpZihudWxsIT09cylmb3IobGV0IHQ9cy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtMci5jb21wdXRlTmV4dENDV0VkZ2VzKGUsbil9fX1kZWxldGVEYW5nbGVzKCl7Y29uc3QgdD10aGlzLmZpbmROb2Rlc09mRGVncmVlKDEpLGU9bmV3IEosbj1uZXcgb247Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspbi5wdXNoKGUubmV4dCgpKTtmb3IoOyFuLmlzRW1wdHkoKTspe2NvbnN0IHQ9bi5wb3AoKTtMci5kZWxldGVBbGxFZGdlcyh0KTtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5zZXRNYXJrZWQoITApO2NvbnN0IGk9dC5nZXRTeW0oKTtudWxsIT09aSYmaS5zZXRNYXJrZWQoITApO2NvbnN0IHI9dC5nZXRFZGdlKCk7ZS5hZGQoci5nZXRMaW5lKCkpO2NvbnN0IG89dC5nZXRUb05vZGUoKTsxPT09THIuZ2V0RGVncmVlTm9uRGVsZXRlZChvKSYmbi5wdXNoKG8pfX1yZXR1cm4gZX1nZXRDbGFzcygpe3JldHVybiBMcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19THIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZmFjdG9yeT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH07Y2xhc3MgVHJ7Y29uc3RydWN0b3IoKXtUci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaW5kT3V0ZXJTaGVsbHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldE91dGVySG9sZSgpO251bGw9PT1ufHxuLmlzUHJvY2Vzc2VkKCl8fCh0LnNldEluY2x1ZGVkKCEwKSxuLnNldFByb2Nlc3NlZCghMCkpfX1zdGF0aWMgZXh0cmFjdFBvbHlnb25zKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTsoZXx8dC5pc0luY2x1ZGVkKCkpJiZuLmFkZCh0LmdldFBvbHlnb24oKSl9cmV0dXJuIG59c3RhdGljIGFzc2lnbkhvbGVzVG9TaGVsbHModCxlKXtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtUci5hc3NpZ25Ib2xlVG9TaGVsbCh0LGUpfX1zdGF0aWMgYXNzaWduSG9sZVRvU2hlbGwodCxlKXtjb25zdCBuPVNyLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKTtudWxsIT09biYmbi5hZGRIb2xlKHQpfXN0YXRpYyBmaW5kRGlzam9pbnRTaGVsbHModCl7VHIuZmluZE91dGVyU2hlbGxzKHQpO2xldCBlPW51bGw7ZG97ZT0hMTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0LmlzSW5jbHVkZWRTZXQoKXx8KHQudXBkYXRlSW5jbHVkZWQoKSx0LmlzSW5jbHVkZWRTZXQoKXx8KGU9ITApKX19d2hpbGUoZSl9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2dlb21GYWN0b3J5JiYodGhpcy5fZ2VvbUZhY3Rvcnk9bmV3IEh0KSx0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD90aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMuX3BvbHlMaXN0KTp0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oSHQudG9HZW9tZXRyeUFycmF5KHRoaXMuX3BvbHlMaXN0KSl9Z2V0SW52YWxpZFJpbmdMaW5lcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9pbnZhbGlkUmluZ0xpbmVzfWZpbmRWYWxpZFJpbmdzKHQsZSxuKXtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmlzVmFsaWQoKT9lLmFkZCh0KTpuLmFkZCh0LmdldExpbmVTdHJpbmcoKSl9fXBvbHlnb25pemUoKXtpZihudWxsIT09dGhpcy5fcG9seUxpc3QpcmV0dXJuIG51bGw7aWYodGhpcy5fcG9seUxpc3Q9bmV3IHgsbnVsbD09PXRoaXMuX2dyYXBoKXJldHVybiBudWxsO3RoaXMuX2RhbmdsZXM9dGhpcy5fZ3JhcGguZGVsZXRlRGFuZ2xlcygpLHRoaXMuX2N1dEVkZ2VzPXRoaXMuX2dyYXBoLmRlbGV0ZUN1dEVkZ2VzKCk7Y29uc3QgdD10aGlzLl9ncmFwaC5nZXRFZGdlUmluZ3MoKTtsZXQgZT1uZXcgeDt0aGlzLl9pbnZhbGlkUmluZ0xpbmVzPW5ldyB4LHRoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkP3RoaXMuZmluZFZhbGlkUmluZ3ModCxlLHRoaXMuX2ludmFsaWRSaW5nTGluZXMpOmU9dCx0aGlzLmZpbmRTaGVsbHNBbmRIb2xlcyhlKSxUci5hc3NpZ25Ib2xlc1RvU2hlbGxzKHRoaXMuX2hvbGVMaXN0LHRoaXMuX3NoZWxsTGlzdCksRWUuc29ydCh0aGlzLl9zaGVsbExpc3QsbmV3IFNyLkVudmVsb3BlQ29tcGFyYXRvcik7bGV0IG49ITA7dGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWwmJihUci5maW5kRGlzam9pbnRTaGVsbHModGhpcy5fc2hlbGxMaXN0KSxuPSExKSx0aGlzLl9wb2x5TGlzdD1Uci5leHRyYWN0UG9seWdvbnModGhpcy5fc2hlbGxMaXN0LG4pfWdldERhbmdsZXMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fZGFuZ2xlc31nZXRDdXRFZGdlcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9jdXRFZGdlc31nZXRQb2x5Z29ucygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9wb2x5TGlzdH1hZGQoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdG9yeT10LmdldEZhY3RvcnkoKSxudWxsPT09dGhpcy5fZ3JhcGgmJih0aGlzLl9ncmFwaD1uZXcgTHIodGhpcy5fZ2VvbUZhY3RvcnkpKSx0aGlzLl9ncmFwaC5hZGRFZGdlKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXthcmd1bWVudHNbMF0uYXBwbHkodGhpcy5fbGluZVN0cmluZ0FkZGVyKX19c2V0Q2hlY2tSaW5nc1ZhbGlkKHQpe3RoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkPXR9ZmluZFNoZWxsc0FuZEhvbGVzKHQpe3RoaXMuX2hvbGVMaXN0PW5ldyB4LHRoaXMuX3NoZWxsTGlzdD1uZXcgeDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmNvbXB1dGVIb2xlKCksdC5pc0hvbGUoKT90aGlzLl9ob2xlTGlzdC5hZGQodCk6dGhpcy5fc2hlbGxMaXN0LmFkZCh0KX19Z2V0Q2xhc3MoKXtyZXR1cm4gVHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIFJye2NvbnN0cnVjdG9yKCl7UnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLnAuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIFJyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX19UnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wPXR9LFRyLkxpbmVTdHJpbmdBZGRlcj1ScixUci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9saW5lU3RyaW5nQWRkZXI9bmV3IFJyKHRoaXMpLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fZGFuZ2xlcz1uZXcgeCx0aGlzLl9jdXRFZGdlcz1uZXcgeCx0aGlzLl9pbnZhbGlkUmluZ0xpbmVzPW5ldyB4LHRoaXMuX2hvbGVMaXN0PW51bGwsdGhpcy5fc2hlbGxMaXN0PW51bGwsdGhpcy5fcG9seUxpc3Q9bnVsbCx0aGlzLl9pc0NoZWNraW5nUmluZ3NWYWxpZD0hMCx0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD1udWxsLHRoaXMuX2dlb21GYWN0b3J5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpVHIuY29uc3RydWN0b3JfLmNhbGwodGhpcywhMSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWw9dH19O3ZhciBQcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxQb2x5Z29uaXplcjpUcn0pO2NsYXNzIHZye2NvbnN0cnVjdG9yKCl7dnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnRFZGdlRW5kcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGQodCl9fWNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTSh0LGUpe2NvbnN0IG49dGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCkscz10aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxpPXQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCkscj10Lmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCk7Mj09PW4mJjI9PT1zP2kmJmUuc2V0QXRMZWFzdChcIjIxMjEwMTIxMlwiKToyPT09biYmMT09PXM/KGkmJmUuc2V0QXRMZWFzdChcIkZGRjBGRkZGMlwiKSxyJiZlLnNldEF0TGVhc3QoXCIxRkZGRkYxRkZcIikpOjE9PT1uJiYyPT09cz8oaSYmZS5zZXRBdExlYXN0KFwiRjBGRkZGRkYyXCIpLHImJmUuc2V0QXRMZWFzdChcIjFGMUZGRkZGRlwiKSk6MT09PW4mJjE9PT1zJiZyJiZlLnNldEF0TGVhc3QoXCIwRkZGRkZGRkZcIil9bGFiZWxJc29sYXRlZEVkZ2VzKHQsZSl7Zm9yKGxldCBuPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dC5pc0lzb2xhdGVkKCkmJih0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlKHQsZSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSksdGhpcy5faXNvbGF0ZWRFZGdlcy5hZGQodCkpfX1sYWJlbElzb2xhdGVkRWRnZSh0LGUsbil7aWYobi5nZXREaW1lbnNpb24oKT4wKXtjb25zdCBzPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksbik7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLHMpfWVsc2UgdC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLG5lLkVYVEVSSU9SKX1jb21wdXRlSU0oKXtjb25zdCB0PW5ldyBzZTtpZih0LnNldChuZS5FWFRFUklPUixuZS5FWFRFUklPUiwyKSwhdGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4gdGhpcy5jb21wdXRlRGlzam9pbnRJTSh0KSx0O3RoaXMuX2FyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSk7Y29uc3QgZT10aGlzLl9hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuX2FyZ1sxXSx0aGlzLl9saSwhMSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMSksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMSksdGhpcy5sYWJlbElzb2xhdGVkTm9kZXMoKSx0aGlzLmNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTShlLHQpO2NvbnN0IG49bmV3IF9yLHM9bi5jb21wdXRlRWRnZUVuZHModGhpcy5fYXJnWzBdLmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKHMpO2NvbnN0IGk9bi5jb21wdXRlRWRnZUVuZHModGhpcy5fYXJnWzFdLmdldEVkZ2VJdGVyYXRvcigpKTtyZXR1cm4gdGhpcy5pbnNlcnRFZGdlRW5kcyhpKSx0aGlzLmxhYmVsTm9kZUVkZ2VzKCksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMCwxKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygxLDApLHRoaXMudXBkYXRlSU0odCksdH1sYWJlbE5vZGVFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuX2FyZyl9fWNvcHlOb2Rlc0FuZExhYmVscyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fWxhYmVsSW50ZXJzZWN0aW9uTm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxpPXRoaXMuX25vZGVzLmZpbmQobi5jb29yZCk7aS5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmKHM9PT1uZS5CT1VOREFSWT9pLnNldExhYmVsQm91bmRhcnkodCk6aS5zZXRMYWJlbCh0LG5lLklOVEVSSU9SKSl9fX1sYWJlbElzb2xhdGVkTm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLG4pfWNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtmb3IobGV0IGU9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLGk9dGhpcy5fbm9kZXMuYWRkTm9kZShuLmNvb3JkKTtzPT09bmUuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KHQpOmkuZ2V0TGFiZWwoKS5pc051bGwodCkmJmkuc2V0TGFiZWwodCxuZS5JTlRFUklPUil9fX1sYWJlbElzb2xhdGVkTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7dS5pc1RydWUobi5nZXRHZW9tZXRyeUNvdW50KCk+MCxcIm5vZGUgd2l0aCBlbXB0eSBsYWJlbCBmb3VuZFwiKSxlLmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwwKTp0aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMSkpfX11cGRhdGVJTSh0KXtmb3IobGV0IGU9dGhpcy5faXNvbGF0ZWRFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkudXBkYXRlSU0odCl9Zm9yKGxldCBlPXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24udXBkYXRlSU0odCksbi51cGRhdGVJTUZyb21FZGdlcyh0KX19Y29tcHV0ZURpc2pvaW50SU0odCl7Y29uc3QgZT10aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKTtlLmlzRW1wdHkoKXx8KHQuc2V0KG5lLklOVEVSSU9SLG5lLkVYVEVSSU9SLGUuZ2V0RGltZW5zaW9uKCkpLHQuc2V0KG5lLkJPVU5EQVJZLG5lLkVYVEVSSU9SLGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpO2NvbnN0IG49dGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCk7bi5pc0VtcHR5KCl8fCh0LnNldChuZS5FWFRFUklPUixuZS5JTlRFUklPUixuLmdldERpbWVuc2lvbigpKSx0LnNldChuZS5FWFRFUklPUixuZS5CT1VOREFSWSxuLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKX1nZXRDbGFzcygpe3JldHVybiB2cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bmV3IHRlLHRoaXMuX3B0TG9jYXRvcj1uZXcgX24sdGhpcy5fYXJnPW51bGwsdGhpcy5fbm9kZXM9bmV3IFhuKG5ldyB5ciksdGhpcy5faW09bnVsbCx0aGlzLl9pc29sYXRlZEVkZ2VzPW5ldyB4LHRoaXMuX2ludmFsaWRQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2FyZz10fTtjbGFzcyBPcntjb25zdHJ1Y3Rvcigpe09yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnRhaW5zKHQsZSl7cmV0dXJuIG5ldyBPcih0KS5jb250YWlucyhlKX1pc0NvbnRhaW5lZEluQm91bmRhcnkodCl7aWYodCBpbnN0YW5jZW9mIGJ0KXJldHVybiExO2lmKHQgaW5zdGFuY2VvZiBQdClyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0IGluc3RhbmNlb2YgVHQpcmV0dXJuIHRoaXMuaXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeSh0KTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZighdGhpcy5pc0NvbnRhaW5lZEluQm91bmRhcnkobikpcmV0dXJuITF9cmV0dXJuITB9aXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnkodCxlKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0Lng9PT1lLngpe2lmKHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWCgpfHx0Lng9PT10aGlzLl9yZWN0RW52LmdldE1heFgoKSlyZXR1cm4hMH1lbHNlIGlmKHQueT09PWUueSYmKHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpfHx0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1heFkoKSkpcmV0dXJuITA7cmV0dXJuITF9aXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeSh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbj1uZXcgZyxzPW5ldyBnO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCktMTt0KyspaWYoZS5nZXRDb29yZGluYXRlKHQsbiksZS5nZXRDb29yZGluYXRlKHQrMSxzKSwhdGhpcy5pc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeShuLHMpKXJldHVybiExO3JldHVybiEwfWlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodC5nZXRDb29yZGluYXRlKCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWCgpfHx0Lng9PT10aGlzLl9yZWN0RW52LmdldE1heFgoKXx8dC55PT09dGhpcy5fcmVjdEVudi5nZXRNaW5ZKCl8fHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WSgpfX1jb250YWlucyh0KXtyZXR1cm4hIXRoaXMuX3JlY3RFbnYuY29udGFpbnModC5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYhdGhpcy5pc0NvbnRhaW5lZEluQm91bmRhcnkodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gT3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU9yLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3JlY3RFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfTtjbGFzcyBicntjb25zdHJ1Y3Rvcigpe2JyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW50ZXJzZWN0cyh0LGUpe2NvbnN0IG49bmV3IE4odCxlKTtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKG4pKXJldHVybiExO2lmKHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyh0KSlyZXR1cm4hMDtpZih0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuITA7aWYodC5jb21wYXJlVG8oZSk+MCl7Y29uc3Qgbj10O3Q9ZSxlPW59bGV0IHM9ITE7cmV0dXJuIGUueT50LnkmJihzPSEwKSxzP3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2RpYWdEb3duMCx0aGlzLl9kaWFnRG93bjEpOnRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2RpYWdVcDAsdGhpcy5fZGlhZ1VwMSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKX1nZXRDbGFzcygpe3JldHVybiBicn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19YnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bmV3IHRlLHRoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9kaWFnVXAwPW51bGwsdGhpcy5fZGlhZ1VwMT1udWxsLHRoaXMuX2RpYWdEb3duMD1udWxsLHRoaXMuX2RpYWdEb3duMT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dCx0aGlzLl9kaWFnVXAwPW5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSx0aGlzLl9kaWFnVXAxPW5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKSx0aGlzLl9kaWFnRG93bjA9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLHRoaXMuX2RpYWdEb3duMT1uZXcgZyh0LmdldE1heFgoKSx0LmdldE1pblkoKSl9O2NsYXNzIE1ye2NvbnN0cnVjdG9yKCl7TXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW50ZXJzZWN0cyh0LGUpe3JldHVybiBuZXcgTXIodCkuaW50ZXJzZWN0cyhlKX1pbnRlcnNlY3RzKHQpe2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHModC5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiExO2NvbnN0IGU9bmV3IERyKHRoaXMuX3JlY3RFbnYpO2lmKGUuYXBwbHlUbyh0KSxlLmludGVyc2VjdHMoKSlyZXR1cm4hMDtjb25zdCBuPW5ldyBBcih0aGlzLl9yZWN0YW5nbGUpO2lmKG4uYXBwbHlUbyh0KSxuLmNvbnRhaW5zUG9pbnQoKSlyZXR1cm4hMDtjb25zdCBzPW5ldyBGcih0aGlzLl9yZWN0YW5nbGUpO3JldHVybiBzLmFwcGx5VG8odCksISFzLmludGVyc2VjdHMoKX1nZXRDbGFzcygpe3JldHVybiBNcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVjdGFuZ2xlPW51bGwsdGhpcy5fcmVjdEVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RhbmdsZT10LHRoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9O2NsYXNzIERyIGV4dGVuZHMgQ2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLERyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9pbnRlcnNlY3RzfXZpc2l0KHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKT90aGlzLl9yZWN0RW52LmNvbnRhaW5zKGUpfHxlLmdldE1pblgoKT49dGhpcy5fcmVjdEVudi5nZXRNaW5YKCkmJmUuZ2V0TWF4WCgpPD10aGlzLl9yZWN0RW52LmdldE1heFgoKXx8ZS5nZXRNaW5ZKCk+PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpJiZlLmdldE1heFkoKTw9dGhpcy5fcmVjdEVudi5nZXRNYXhZKCk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6dm9pZCAwOm51bGx9aW50ZXJzZWN0cygpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzfWdldENsYXNzKCl7cmV0dXJuIERyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Eci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5faW50ZXJzZWN0cz0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXR9O2NsYXNzIEFyIGV4dGVuZHMgQ2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLEFyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9jb250YWluc1BvaW50fXZpc2l0KHQpe2lmKCEodCBpbnN0YW5jZW9mIGJ0KSlyZXR1cm4gbnVsbDtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgZztmb3IobGV0IHM9MDtzPDQ7cysrKWlmKHRoaXMuX3JlY3RTZXEuZ2V0Q29vcmRpbmF0ZShzLG4pLGUuY29udGFpbnMobikmJlplLmNvbnRhaW5zUG9pbnRJblBvbHlnb24obix0KSlyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludD0hMCxudWxsfWNvbnRhaW5zUG9pbnQoKXtyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludH1nZXRDbGFzcygpe3JldHVybiBBcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19QXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVjdFNlcT1udWxsLHRoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9jb250YWluc1BvaW50PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RTZXE9dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfTtjbGFzcyBGciBleHRlbmRzIENle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxGci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWludGVyc2VjdHMoKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufWlzRG9uZSgpe3JldHVybiEwPT09dGhpcy5faGFzSW50ZXJzZWN0aW9ufXZpc2l0KHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDtjb25zdCBuPXhlLmdldExpbmVzKHQpO3RoaXMuY2hlY2tJbnRlcnNlY3Rpb25XaXRoTGluZVN0cmluZ3Mobil9Y2hlY2tJbnRlcnNlY3Rpb25XaXRoTGluZVN0cmluZ3ModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYodGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50cyh0KSx0aGlzLl9oYXNJbnRlcnNlY3Rpb24pcmV0dXJuIG51bGx9fWNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtmb3IobGV0IHQ9MTt0PGUuc2l6ZSgpO3QrKylpZihlLmdldENvb3JkaW5hdGUodC0xLHRoaXMuX3AwKSxlLmdldENvb3JkaW5hdGUodCx0aGlzLl9wMSksdGhpcy5fcmVjdEludGVyc2VjdG9yLmludGVyc2VjdHModGhpcy5fcDAsdGhpcy5fcDEpKXJldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsbnVsbH1nZXRDbGFzcygpe3JldHVybiBGcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX3JlY3RJbnRlcnNlY3Rvcj1udWxsLHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9wMD1uZXcgZyx0aGlzLl9wMT1uZXcgZztjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHRoaXMuX3JlY3RJbnRlcnNlY3Rvcj1uZXcgYnIodGhpcy5fcmVjdEVudil9O2NsYXNzIEdyIGV4dGVuZHMgYXJ7Y29uc3RydWN0b3IoKXtzdXBlcigpLEdyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvdmVycyh0LGUpe3JldHVybiEoMj09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MikmJighKDE9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDEmJmUuZ2V0TGVuZ3RoKCk+MCkmJighIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvdmVycyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJighIXQuaXNSZWN0YW5nbGUoKXx8bmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDb3ZlcnMoKSkpKX1zdGF0aWMgaW50ZXJzZWN0cyh0LGUpe2lmKCF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTtpZih0LmlzUmVjdGFuZ2xlKCkpcmV0dXJuIE1yLmludGVyc2VjdHModCxlKTtpZihlLmlzUmVjdGFuZ2xlKCkpcmV0dXJuIE1yLmludGVyc2VjdHMoZSx0KTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspZm9yKGxldCBzPTA7czxlLmdldE51bUdlb21ldHJpZXMoKTtzKyspaWYodC5nZXRHZW9tZXRyeU4obikuaW50ZXJzZWN0cyhlLmdldEdlb21ldHJ5TihzKSkpcmV0dXJuITA7cmV0dXJuITF9cmV0dXJuIG5ldyBHcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzSW50ZXJzZWN0cygpfXN0YXRpYyB0b3VjaGVzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNUb3VjaGVzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGVxdWFsc1RvcG8odCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmVxdWFscyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJkdyLnJlbGF0ZSh0LGUpLmlzRXF1YWxzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIHJlbGF0ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuZXcgR3IodCxlLG4pLmdldEludGVyc2VjdGlvbk1hdHJpeCgpfX1zdGF0aWMgb3ZlcmxhcHModCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc092ZXJsYXBzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGNyb3NzZXModCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0Nyb3NzZXModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgY29udGFpbnModCxlKXtyZXR1cm4hKDI9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDIpJiYoISgxPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwxJiZlLmdldExlbmd0aCgpPjApJiYoISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJih0LmlzUmVjdGFuZ2xlKCk/T3IuY29udGFpbnModCxlKTpuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0NvbnRhaW5zKCkpKSl9Z2V0SW50ZXJzZWN0aW9uTWF0cml4KCl7cmV0dXJuIHRoaXMuX3JlbGF0ZS5jb21wdXRlSU0oKX1nZXRDbGFzcygpe3JldHVybiBHcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19R3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcmVsYXRlPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLl9yZWxhdGU9bmV3IHZyKHRoaXMuX2FyZyl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07YXIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbiksdGhpcy5fcmVsYXRlPW5ldyB2cih0aGlzLl9hcmcpfX07dmFyIHFyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFJlbGF0ZU9wOkdyfSk7Y2xhc3MgQnJ7Y29uc3RydWN0b3IoKXtCci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBuZXcgQnIodCxlKS51bmlvbigpfXVuaW9uKCl7Y29uc3QgdD1uZXcgX24sZT1uZXcgYXQ7Zm9yKGxldCBuPTA7bjx0aGlzLl9wb2ludEdlb20uZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10aGlzLl9wb2ludEdlb20uZ2V0R2VvbWV0cnlOKG4pLmdldENvb3JkaW5hdGUoKTt0LmxvY2F0ZShzLHRoaXMuX290aGVyR2VvbSk9PT1uZS5FWFRFUklPUiYmZS5hZGQocyl9aWYoMD09PWUuc2l6ZSgpKXJldHVybiB0aGlzLl9vdGhlckdlb207bGV0IG49bnVsbDtjb25zdCBzPVgudG9Db29yZGluYXRlQXJyYXkoZSk7cmV0dXJuIG49MT09PXMubGVuZ3RoP3RoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KHNbMF0pOnRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKHMpLGRlLmNvbWJpbmUobix0aGlzLl9vdGhlckdlb20pfWdldENsYXNzKCl7cmV0dXJuIEJyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Cci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wb2ludEdlb209bnVsbCx0aGlzLl9vdGhlckdlb209bnVsbCx0aGlzLl9nZW9tRmFjdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3BvaW50R2VvbT10LHRoaXMuX290aGVyR2VvbT1lLHRoaXMuX2dlb21GYWN0PWUuZ2V0RmFjdG9yeSgpfTtjbGFzcyBWcntjb25zdHJ1Y3Rvcigpe1ZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHJlc3RyaWN0VG9Qb2x5Z29ucyh0KXtpZihfKHQsT3QpKXJldHVybiB0O2NvbnN0IGU9TmUuZ2V0UG9seWdvbnModCk7cmV0dXJuIDE9PT1lLnNpemUoKT9lLmdldCgwKTp0LmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oSHQudG9Qb2x5Z29uQXJyYXkoZSkpfXN0YXRpYyBnZXRHZW9tZXRyeSh0LGUpe3JldHVybiBlPj10LnNpemUoKT9udWxsOnQuZ2V0KGUpfXN0YXRpYyB1bmlvbih0KXtyZXR1cm4gbmV3IFZyKHQpLnVuaW9uKCl9cmVkdWNlVG9HZW9tZXRyaWVzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7bGV0IHM9bnVsbDtfKHQsbSk/cz10aGlzLnVuaW9uVHJlZSh0KTp0IGluc3RhbmNlb2YgcSYmKHM9dCksZS5hZGQocyl9cmV0dXJuIGV9ZXh0cmFjdEJ5RW52ZWxvcGUodCxlLG4pe2NvbnN0IHM9bmV3IHg7Zm9yKGxldCBpPTA7aTxlLmdldE51bUdlb21ldHJpZXMoKTtpKyspe2NvbnN0IHI9ZS5nZXRHZW9tZXRyeU4oaSk7ci5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9zLmFkZChyKTpuLmFkZChyKX1yZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeShzKX11bmlvbk9wdGltaXplZCh0LGUpe2NvbnN0IG49dC5nZXRFbnZlbG9wZUludGVybmFsKCkscz1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighbi5pbnRlcnNlY3RzKHMpKXtyZXR1cm4gZGUuY29tYmluZSh0LGUpfWlmKHQuZ2V0TnVtR2VvbWV0cmllcygpPD0xJiZlLmdldE51bUdlb21ldHJpZXMoKTw9MSlyZXR1cm4gdGhpcy51bmlvbkFjdHVhbCh0LGUpO2NvbnN0IGk9bi5pbnRlcnNlY3Rpb24ocyk7cmV0dXJuIHRoaXMudW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uKHQsZSxpKX11bmlvbigpe2lmKG51bGw9PT10aGlzLl9pbnB1dFBvbHlzKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJ1bmlvbigpIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlXCIpO2lmKHRoaXMuX2lucHV0UG9seXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuX2dlb21GYWN0b3J5PXRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpO2NvbnN0IHQ9bmV3IEVzKFZyLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWSk7Zm9yKGxldCBlPXRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dC5pbnNlcnQobi5nZXRFbnZlbG9wZUludGVybmFsKCksbil9dGhpcy5faW5wdXRQb2x5cz1udWxsO2NvbnN0IGU9dC5pdGVtc1RyZWUoKTtyZXR1cm4gdGhpcy51bmlvblRyZWUoZSl9YmluYXJ5VW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYmluYXJ5VW5pb24odCwwLHQuc2l6ZSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYobi1lPD0xKXtjb25zdCBuPVZyLmdldEdlb21ldHJ5KHQsZSk7cmV0dXJuIHRoaXMudW5pb25TYWZlKG4sbnVsbCl9aWYobi1lPT0yKXJldHVybiB0aGlzLnVuaW9uU2FmZShWci5nZXRHZW9tZXRyeSh0LGUpLFZyLmdldEdlb21ldHJ5KHQsZSsxKSk7e2NvbnN0IHM9TWF0aC50cnVuYygobitlKS8yKSxpPXRoaXMuYmluYXJ5VW5pb24odCxlLHMpLHI9dGhpcy5iaW5hcnlVbmlvbih0LHMsbik7cmV0dXJuIHRoaXMudW5pb25TYWZlKGkscil9fX1yZXBlYXRlZFVuaW9uKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZT1udWxsPT09ZT90LmNvcHkoKTplLnVuaW9uKHQpfXJldHVybiBlfXVuaW9uU2FmZSh0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09dD9lLmNvcHkoKTpudWxsPT09ZT90LmNvcHkoKTp0aGlzLnVuaW9uT3B0aW1pemVkKHQsZSl9dW5pb25BY3R1YWwodCxlKXtyZXR1cm4gVnIucmVzdHJpY3RUb1BvbHlnb25zKHQudW5pb24oZSkpfXVuaW9uVHJlZSh0KXtjb25zdCBlPXRoaXMucmVkdWNlVG9HZW9tZXRyaWVzKHQpO3JldHVybiB0aGlzLmJpbmFyeVVuaW9uKGUpfXVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbih0LGUsbil7Y29uc3Qgcz1uZXcgeCxpPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUobix0LHMpLHI9dGhpcy5leHRyYWN0QnlFbnZlbG9wZShuLGUscyksbz10aGlzLnVuaW9uQWN0dWFsKGkscik7cmV0dXJuIHMuYWRkKG8pLGRlLmNvbWJpbmUocyl9YnVmZmVyVW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuZ2V0KDApLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHQpLmJ1ZmZlcigwKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihbdCxlXSkuYnVmZmVyKDApfX1nZXRDbGFzcygpe3JldHVybiBWcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRQb2x5cz1udWxsLHRoaXMuX2dlb21GYWN0b3J5PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRQb2x5cz10LG51bGw9PT10aGlzLl9pbnB1dFBvbHlzJiYodGhpcy5faW5wdXRQb2x5cz1uZXcgeCl9LFZyLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWT00O2NsYXNzIHpye2NvbnN0cnVjdG9yKCl7enIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMF0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgenIodCkudW5pb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgenIodCkudW5pb24oKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyB6cih0LGUpLnVuaW9uKCl9fXVuaW9uTm9PcHQodCl7Y29uc3QgZT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludCgpO3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlVOSU9OKX11bmlvbldpdGhOdWxsKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT1lP3Q6bnVsbD09PXQ/ZTp0LnVuaW9uKGUpfWV4dHJhY3QoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmV4dHJhY3QoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5fZ2VvbUZhY3QmJih0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKSksX2UuZXh0cmFjdCh0LHEuVFlQRU5BTUVfUE9MWUdPTix0aGlzLl9wb2x5Z29ucyksX2UuZXh0cmFjdCh0LHEuVFlQRU5BTUVfTElORVNUUklORyx0aGlzLl9saW5lcyksX2UuZXh0cmFjdCh0LHEuVFlQRU5BTUVfUE9JTlQsdGhpcy5fcG9pbnRzKX19dW5pb24oKXtpZihudWxsPT09dGhpcy5fZ2VvbUZhY3QpcmV0dXJuIG51bGw7bGV0IHQ9bnVsbDtpZih0aGlzLl9wb2ludHMuc2l6ZSgpPjApe2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLl9wb2ludHMpO3Q9dGhpcy51bmlvbk5vT3B0KGUpfWxldCBlPW51bGw7aWYodGhpcy5fbGluZXMuc2l6ZSgpPjApe2NvbnN0IHQ9dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLl9saW5lcyk7ZT10aGlzLnVuaW9uTm9PcHQodCl9bGV0IG49bnVsbDt0aGlzLl9wb2x5Z29ucy5zaXplKCk+MCYmKG49VnIudW5pb24odGhpcy5fcG9seWdvbnMpKTtjb25zdCBzPXRoaXMudW5pb25XaXRoTnVsbChlLG4pO2xldCBpPW51bGw7cmV0dXJuIGk9bnVsbD09PXQ/czpudWxsPT09cz90OkJyLnVuaW9uKHQscyksbnVsbD09PWk/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6aX1nZXRDbGFzcygpe3JldHVybiB6cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19enIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcG9seWdvbnM9bmV3IHgsdGhpcy5fbGluZXM9bmV3IHgsdGhpcy5fcG9pbnRzPW5ldyB4LHRoaXMuX2dlb21GYWN0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbUZhY3Q9ZSx0aGlzLmV4dHJhY3QodCl9fTt2YXIgWXI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsVW5hcnlVbmlvbk9wOnpyfSksVXI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsSXNWYWxpZE9wOkNyLENvbnNpc3RlbnRBcmVhVGVzdGVyOkVyfSksa3I9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQm91bmRhcnlPcDpwdCxJc1NpbXBsZU9wOkhzLGJ1ZmZlcjp3aSxkaXN0YW5jZTpQaSxsaW5lbWVyZ2U6WGksb3ZlcmxheTpocixwb2x5Z29uaXplOlByLHJlbGF0ZTpxcix1bmlvbjpZcix2YWxpZDpVcn0pO2NsYXNzIFhyIGV4dGVuZHMgRnQuQ29vcmRpbmF0ZU9wZXJhdGlvbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksWHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lZGl0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgcSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBzPW5ldyBnKHRbZV0pO3RoaXMuX3RhcmdldFBNLm1ha2VQcmVjaXNlKHMpLG5bZV09c31jb25zdCBzPW5ldyBJKG4sITEpLnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IGk9MDtlIGluc3RhbmNlb2YgVHQmJihpPTIpLGUgaW5zdGFuY2VvZiBEdCYmKGk9NCk7bGV0IHI9bjtyZXR1cm4gdGhpcy5fcmVtb3ZlQ29sbGFwc2VkJiYocj1udWxsKSxzLmxlbmd0aDxpP3I6c31yZXR1cm4gc3VwZXIuZWRpdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gWHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVhyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3RhcmdldFBNPW51bGwsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3RhcmdldFBNPXQsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPWV9O2NsYXNzIEhye2NvbnN0cnVjdG9yKCl7SHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcmVkdWNlKHQsZSl7cmV0dXJuIG5ldyBIcihlKS5yZWR1Y2UodCl9c3RhdGljIHJlZHVjZVBvaW50d2lzZSh0LGUpe2NvbnN0IG49bmV3IEhyKGUpO3JldHVybiBuLnNldFBvaW50d2lzZSghMCksbi5yZWR1Y2UodCl9Zml4UG9seWdvbmFsVG9wb2xvZ3kodCl7bGV0IGU9dDt0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbHx8KGU9dGhpcy5jaGFuZ2VQTSh0LHRoaXMuX3RhcmdldFBNKSk7Y29uc3Qgbj1TaS5idWZmZXJPcChlLDApO2xldCBzPW47cmV0dXJuIHRoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsfHwocz10LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeShuKSksc31yZWR1Y2VQb2ludHdpc2UodCl7bGV0IGU9bnVsbDtpZih0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbCl7Y29uc3Qgbj10aGlzLmNyZWF0ZUZhY3RvcnkodC5nZXRGYWN0b3J5KCksdGhpcy5fdGFyZ2V0UE0pO2U9bmV3IEZ0KG4pfWVsc2UgZT1uZXcgRnQ7bGV0IG49dGhpcy5fcmVtb3ZlQ29sbGFwc2VkO3JldHVybiB0LmdldERpbWVuc2lvbigpPj0yJiYobj0hMCksZS5lZGl0KHQsbmV3IFhyKHRoaXMuX3RhcmdldFBNLG4pKX1jaGFuZ2VQTSh0LGUpe3JldHVybiB0aGlzLmNyZWF0ZUVkaXRvcih0LmdldEZhY3RvcnkoKSxlKS5lZGl0KHQsbmV3IEZ0Lk5vT3BHZW9tZXRyeU9wZXJhdGlvbil9c2V0UmVtb3ZlQ29sbGFwc2VkQ29tcG9uZW50cyh0KXt0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9dH1jcmVhdGVGYWN0b3J5KHQsZSl7cmV0dXJuIG5ldyBIdChlLHQuZ2V0U1JJRCgpLHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX1zZXRDaGFuZ2VQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbD10fXJlZHVjZSh0KXtjb25zdCBlPXRoaXMucmVkdWNlUG9pbnR3aXNlKHQpO3JldHVybiB0aGlzLl9pc1BvaW50d2lzZT9lOl8oZSxPdCk/Q3IuaXNWYWxpZChlKT9lOnRoaXMuZml4UG9seWdvbmFsVG9wb2xvZ3koZSk6ZX1zZXRQb2ludHdpc2UodCl7dGhpcy5faXNQb2ludHdpc2U9dH1jcmVhdGVFZGl0b3IodCxlKXtpZih0LmdldFByZWNpc2lvbk1vZGVsKCk9PT1lKXJldHVybiBuZXcgRnQ7Y29uc3Qgbj10aGlzLmNyZWF0ZUZhY3RvcnkodCxlKTtyZXR1cm4gbmV3IEZ0KG4pfWdldENsYXNzKCl7cmV0dXJuIEhyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ici5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl90YXJnZXRQTT1udWxsLHRoaXMuX3JlbW92ZUNvbGxhcHNlZD0hMCx0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbD0hMSx0aGlzLl9pc1BvaW50d2lzZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl90YXJnZXRQTT10fTt2YXIgV3I9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvbWV0cnlQcmVjaXNpb25SZWR1Y2VyOkhyfSk7Y2xhc3MganJ7Y29uc3RydWN0b3IoKXtqci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IGpyKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uc2ltcGxpZnkoKX1zaW1wbGlmeVNlY3Rpb24odCxlKXtpZih0KzE9PT1lKXJldHVybiBudWxsO3RoaXMuX3NlZy5wMD10aGlzLl9wdHNbdF0sdGhpcy5fc2VnLnAxPXRoaXMuX3B0c1tlXTtsZXQgbj0tMSxzPXQ7Zm9yKGxldCBpPXQrMTtpPGU7aSsrKXtjb25zdCB0PXRoaXMuX3NlZy5kaXN0YW5jZSh0aGlzLl9wdHNbaV0pO3Q+biYmKG49dCxzPWkpfWlmKG48PXRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKWZvcihsZXQgbj10KzE7bjxlO24rKyl0aGlzLl91c2VQdFtuXT0hMTtlbHNlIHRoaXMuc2ltcGxpZnlTZWN0aW9uKHQscyksdGhpcy5zaW1wbGlmeVNlY3Rpb24ocyxlKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fXNpbXBsaWZ5KCl7dGhpcy5fdXNlUHQ9bmV3IEFycmF5KHRoaXMuX3B0cy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9wdHMubGVuZ3RoO3QrKyl0aGlzLl91c2VQdFt0XT0hMDt0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMuX3B0cy5sZW5ndGgtMSk7Y29uc3QgdD1uZXcgSTtmb3IobGV0IGU9MDtlPHRoaXMuX3B0cy5sZW5ndGg7ZSsrKXRoaXMuX3VzZVB0W2VdJiZ0LmFkZChuZXcgZyh0aGlzLl9wdHNbZV0pKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWdldENsYXNzKCl7cmV0dXJuIGpyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1qci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl91c2VQdD1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5fc2VnPW5ldyBlZTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dH07Y2xhc3MgS3J7Y29uc3RydWN0b3IoKXtLci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IEtyKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1zZXRFbnN1cmVWYWxpZCh0KXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dH1nZXRSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpP3RoaXMuX2lucHV0R2VvbS5jb3B5KCk6bmV3IFpyKHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neSx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBuKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9Z2V0Q2xhc3MoKXtyZXR1cm4gS3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIFpyIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLFpyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dHJhbnNmb3JtUG9seWdvbih0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIEF0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9Y3JlYXRlVmFsaWRBcmVhKHQpe3JldHVybiB0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k/dC5idWZmZXIoMCk6dH10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBzPW51bGw7cmV0dXJuIHM9MD09PW4ubGVuZ3RoP25ldyBBcnJheSgwKS5maWxsKG51bGwpOmpyLnNpbXBsaWZ5KG4sdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtTGluZWFyUmluZyh0LGUpe2NvbnN0IG49ZSBpbnN0YW5jZW9mIGJ0LHM9c3VwZXIudHJhbnNmb3JtTGluZWFyUmluZy5jYWxsKHRoaXMsdCxlKTtyZXR1cm4hbnx8cyBpbnN0YW5jZW9mIER0P3M6bnVsbH1nZXRDbGFzcygpe3JldHVybiBacn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19WnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXQsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9ZX0sS3IuRFBUcmFuc2Zvcm1lcj1acixLci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH07Y2xhc3MgUXIgZXh0ZW5kcyBlZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRJbmRleCgpe3JldHVybiB0aGlzLl9pbmRleH1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50fWdldENsYXNzKCl7cmV0dXJuIFFyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Rci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wYXJlbnQ9bnVsbCx0aGlzLl9pbmRleD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtRci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxudWxsLC0xKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtlZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy5fcGFyZW50PW4sdGhpcy5faW5kZXg9c319O2NsYXNzIEpye2NvbnN0cnVjdG9yKCl7SnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZXh0cmFjdENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKzEpLmZpbGwobnVsbCk7bGV0IG49bnVsbDtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyluPXQuZ2V0KHMpLGVbc109bi5wMDtyZXR1cm4gZVtlLmxlbmd0aC0xXT1uLnAxLGV9YWRkVG9SZXN1bHQodCl7dGhpcy5fcmVzdWx0U2Vncy5hZGQodCl9YXNMaW5lU3RyaW5nKCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoSnIuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMuX3Jlc3VsdFNlZ3MpKX1nZXRSZXN1bHRTaXplKCl7Y29uc3QgdD10aGlzLl9yZXN1bHRTZWdzLnNpemUoKTtyZXR1cm4gMD09PXQ/MDp0KzF9Z2V0UGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmV9Z2V0U2VnbWVudCh0KXtyZXR1cm4gdGhpcy5fc2Vnc1t0XX1nZXRQYXJlbnRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCl9Z2V0TWluaW11bVNpemUoKXtyZXR1cm4gdGhpcy5fbWluaW11bVNpemV9YXNMaW5lYXJSaW5nKCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoSnIuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMuX3Jlc3VsdFNlZ3MpKX1nZXRTZWdtZW50cygpe3JldHVybiB0aGlzLl9zZWdzfWluaXQoKXtjb25zdCB0PXRoaXMuX3BhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLl9zZWdzPW5ldyBBcnJheSh0Lmxlbmd0aC0xKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMTtlKyspe2NvbnN0IG49bmV3IFFyKHRbZV0sdFtlKzFdLHRoaXMuX3BhcmVudExpbmUsZSk7dGhpcy5fc2Vnc1tlXT1ufX1nZXRSZXN1bHRDb29yZGluYXRlcygpe3JldHVybiBKci5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5fcmVzdWx0U2Vncyl9Z2V0Q2xhc3MoKXtyZXR1cm4gSnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUpyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3BhcmVudExpbmU9bnVsbCx0aGlzLl9zZWdzPW51bGwsdGhpcy5fcmVzdWx0U2Vncz1uZXcgeCx0aGlzLl9taW5pbXVtU2l6ZT1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtKci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcGFyZW50TGluZT10LHRoaXMuX21pbmltdW1TaXplPWUsdGhpcy5pbml0KCl9fTtjbGFzcyAkcntjb25zdHJ1Y3RvcigpeyRyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmVtb3ZlKHQpe3RoaXMuX2luZGV4LnJlbW92ZShuZXcgTih0LnAwLHQucDEpLHQpfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSnIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldFNlZ21lbnRzKCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49dFtlXTt0aGlzLmFkZChuKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbmRleC5pbnNlcnQobmV3IE4odC5wMCx0LnAxKSx0KX19cXVlcnkodCl7Y29uc3QgZT1uZXcgTih0LnAwLHQucDEpLG49bmV3IHRvKHQpO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeShlLG4pLG4uZ2V0SXRlbXMoKX1nZXRDbGFzcygpe3JldHVybiAkcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19JHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5kZXg9bmV3IHVzfTtjbGFzcyB0b3tjb25zdHJ1Y3Rvcigpe3RvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXRJdGVtKHQpe2NvbnN0IGU9dDtOLmludGVyc2VjdHMoZS5wMCxlLnAxLHRoaXMuX3F1ZXJ5U2VnLnAwLHRoaXMuX3F1ZXJ5U2VnLnAxKSYmdGhpcy5faXRlbXMuYWRkKHQpfWdldEl0ZW1zKCl7cmV0dXJuIHRoaXMuX2l0ZW1zfWdldENsYXNzKCl7cmV0dXJuIHRvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19fXRvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3F1ZXJ5U2VnPW51bGwsdGhpcy5faXRlbXM9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcXVlcnlTZWc9dH07Y2xhc3MgZW97Y29uc3RydWN0b3IoKXtlby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc0luTGluZVNlY3Rpb24odCxlLG4pe2lmKG4uZ2V0UGFyZW50KCkhPT10LmdldFBhcmVudCgpKXJldHVybiExO2NvbnN0IHM9bi5nZXRJbmRleCgpO3JldHVybiBzPj1lWzBdJiZzPGVbMV19ZmxhdHRlbih0LGUpe2NvbnN0IG49dGhpcy5fbGluZVB0c1t0XSxzPXRoaXMuX2xpbmVQdHNbZV0saT1uZXcgZWUobixzKTtyZXR1cm4gdGhpcy5yZW1vdmUodGhpcy5fbGluZSx0LGUpLHRoaXMuX291dHB1dEluZGV4LmFkZChpKSxpfWhhc0JhZEludGVyc2VjdGlvbih0LGUsbil7cmV0dXJuISF0aGlzLmhhc0JhZE91dHB1dEludGVyc2VjdGlvbihuKXx8ISF0aGlzLmhhc0JhZElucHV0SW50ZXJzZWN0aW9uKHQsZSxuKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fXNpbXBsaWZ5U2VjdGlvbih0LGUsbil7bis9MTtjb25zdCBzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHQrMT09PWUpe2NvbnN0IGU9dGhpcy5fbGluZS5nZXRTZWdtZW50KHQpO3JldHVybiB0aGlzLl9saW5lLmFkZFRvUmVzdWx0KGUpLG51bGx9bGV0IGk9ITA7aWYodGhpcy5fbGluZS5nZXRSZXN1bHRTaXplKCk8dGhpcy5fbGluZS5nZXRNaW5pbXVtU2l6ZSgpKXtuKzE8dGhpcy5fbGluZS5nZXRNaW5pbXVtU2l6ZSgpJiYoaT0hMSl9Y29uc3Qgcj1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxvPXRoaXMuZmluZEZ1cnRoZXN0UG9pbnQodGhpcy5fbGluZVB0cyx0LGUscik7clswXT50aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSYmKGk9ITEpO2NvbnN0IGw9bmV3IGVlO2lmKGwucDA9dGhpcy5fbGluZVB0c1t0XSxsLnAxPXRoaXMuX2xpbmVQdHNbZV0sc1swXT10LHNbMV09ZSx0aGlzLmhhc0JhZEludGVyc2VjdGlvbih0aGlzLl9saW5lLHMsbCkmJihpPSExKSxpKXtjb25zdCBuPXRoaXMuZmxhdHRlbih0LGUpO3JldHVybiB0aGlzLl9saW5lLmFkZFRvUmVzdWx0KG4pLG51bGx9dGhpcy5zaW1wbGlmeVNlY3Rpb24odCxvLG4pLHRoaXMuc2ltcGxpZnlTZWN0aW9uKG8sZSxuKX1oYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPXRoaXMuX291dHB1dEluZGV4LnF1ZXJ5KHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24obix0KSlyZXR1cm4hMH1yZXR1cm4hMX1maW5kRnVydGhlc3RQb2ludCh0LGUsbixzKXtjb25zdCBpPW5ldyBlZTtpLnAwPXRbZV0saS5wMT10W25dO2xldCByPS0xLG89ZTtmb3IobGV0IHM9ZSsxO3M8bjtzKyspe2NvbnN0IGU9dFtzXSxuPWkuZGlzdGFuY2UoZSk7bj5yJiYocj1uLG89cyl9cmV0dXJuIHNbMF09cixvfXNpbXBsaWZ5KHQpe3RoaXMuX2xpbmU9dCx0aGlzLl9saW5lUHRzPXQuZ2V0UGFyZW50Q29vcmRpbmF0ZXMoKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMuX2xpbmVQdHMubGVuZ3RoLTEsMCl9cmVtb3ZlKHQsZSxuKXtmb3IobGV0IHM9ZTtzPG47cysrKXtjb25zdCBlPXQuZ2V0U2VnbWVudChzKTt0aGlzLl9pbnB1dEluZGV4LnJlbW92ZShlKX19aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LnAwLHQucDEsZS5wMCxlLnAxKSx0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl9aGFzQmFkSW5wdXRJbnRlcnNlY3Rpb24odCxlLG4pe2ZvcihsZXQgcz10aGlzLl9pbnB1dEluZGV4LnF1ZXJ5KG4pLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBpPXMubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24oaSxuKSl7aWYoZW8uaXNJbkxpbmVTZWN0aW9uKHQsZSxpKSljb250aW51ZTtyZXR1cm4hMH19cmV0dXJuITF9Z2V0Q2xhc3MoKXtyZXR1cm4gZW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWVvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW5ldyB0ZSx0aGlzLl9pbnB1dEluZGV4PW5ldyAkcix0aGlzLl9vdXRwdXRJbmRleD1uZXcgJHIsdGhpcy5fbGluZT1udWxsLHRoaXMuX2xpbmVQdHM9bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0SW5kZXg9dCx0aGlzLl9vdXRwdXRJbmRleD1lfTtjbGFzcyBub3tjb25zdHJ1Y3Rvcigpe25vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1zaW1wbGlmeSh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLl9pbnB1dEluZGV4LmFkZChlLm5leHQoKSk7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9bmV3IGVvKHRoaXMuX2lucHV0SW5kZXgsdGhpcy5fb3V0cHV0SW5kZXgpO3Quc2V0RGlzdGFuY2VUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLHQuc2ltcGxpZnkoZS5uZXh0KCkpfX1nZXRDbGFzcygpe3JldHVybiBub31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRJbmRleD1uZXcgJHIsdGhpcy5fb3V0cHV0SW5kZXg9bmV3ICRyLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPTB9O2NsYXNzIHNve2NvbnN0cnVjdG9yKCl7c28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBzbyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9Z2V0UmVzdWx0R2VvbWV0cnkoKXtpZih0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLl9pbnB1dEdlb20uY29weSgpO3JldHVybiB0aGlzLl9saW5lc3RyaW5nTWFwPW5ldyBVdCx0aGlzLl9pbnB1dEdlb20uYXBwbHkobmV3IHJvKHRoaXMpKSx0aGlzLl9saW5lU2ltcGxpZmllci5zaW1wbGlmeSh0aGlzLl9saW5lc3RyaW5nTWFwLnZhbHVlcygpKSxuZXcgaW8odGhpcy5fbGluZXN0cmluZ01hcCkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBuKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2xpbmVTaW1wbGlmaWVyLnNldERpc3RhbmNlVG9sZXJhbmNlKHQpfWdldENsYXNzKCl7cmV0dXJuIHNvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBpbyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxpby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7aWYoMD09PXQuc2l6ZSgpKXJldHVybiBudWxsO2lmKGUgaW5zdGFuY2VvZiBUdCl7Y29uc3QgdD10aGlzLl9saW5lc3RyaW5nTWFwLmdldChlKTtyZXR1cm4gdGhpcy5jcmVhdGVDb29yZGluYXRlU2VxdWVuY2UodC5nZXRSZXN1bHRDb29yZGluYXRlcygpKX1yZXR1cm4gc3VwZXIudHJhbnNmb3JtQ29vcmRpbmF0ZXMuY2FsbCh0aGlzLHQsZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gaW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWlvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVzdHJpbmdNYXA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lc3RyaW5nTWFwPXR9O2NsYXNzIHJve2NvbnN0cnVjdG9yKCl7cm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7aWYodCBpbnN0YW5jZW9mIFR0KXtjb25zdCBlPXQ7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1lLmlzQ2xvc2VkKCk/NDoyLHM9bmV3IEpyKGUsbik7dGhpcy50cHMuX2xpbmVzdHJpbmdNYXAucHV0KGUscyl9fWdldENsYXNzKCl7cmV0dXJuIHJvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX19cm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy50cHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnRwcz10fSxzby5MaW5lU3RyaW5nVHJhbnNmb3JtZXI9aW8sc28uTGluZVN0cmluZ01hcEJ1aWxkZXJGaWx0ZXI9cm8sc28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fbGluZVNpbXBsaWZpZXI9bmV3IG5vLHRoaXMuX2xpbmVzdHJpbmdNYXA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH07Y2xhc3Mgb297Y29uc3RydWN0b3IoKXtvby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe3JldHVybiBuZXcgb28odCxlKS5zaW1wbGlmeSgpfXNpbXBsaWZ5VmVydGV4KHQpe2xldCBlPXQsbj1lLmdldEFyZWEoKSxzPW51bGw7Zm9yKDtudWxsIT09ZTspe2NvbnN0IHQ9ZS5nZXRBcmVhKCk7dDxuJiYobj10LHM9ZSksZT1lLl9uZXh0fXJldHVybiBudWxsIT09cyYmbjx0aGlzLl90b2xlcmFuY2UmJnMucmVtb3ZlKCksdC5pc0xpdmUoKT9uOi0xfXNpbXBsaWZ5KCl7Y29uc3QgdD1sby5idWlsZExpbmUodGhpcy5fcHRzKTtsZXQgZT10aGlzLl90b2xlcmFuY2U7ZG97ZT10aGlzLnNpbXBsaWZ5VmVydGV4KHQpfXdoaWxlKGU8dGhpcy5fdG9sZXJhbmNlKTtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gbi5sZW5ndGg8Mj9bblswXSxuZXcgZyhuWzBdKV06bn1nZXRDbGFzcygpe3JldHVybiBvb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgbG97Y29uc3RydWN0b3IoKXtsby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBidWlsZExpbmUodCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2NvbnN0IGk9bmV3IGxvKHRbc10pO251bGw9PT1lJiYoZT1pKSxpLnNldFByZXYobiksbnVsbCE9PW4mJihuLnNldE5leHQoaSksbi51cGRhdGVBcmVhKCkpLG49aX1yZXR1cm4gZX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEk7bGV0IGU9dGhpcztkb3t0LmFkZChlLl9wdCwhMSksZT1lLl9uZXh0fXdoaWxlKG51bGwhPT1lKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWdldEFyZWEoKXtyZXR1cm4gdGhpcy5fYXJlYX11cGRhdGVBcmVhKCl7aWYobnVsbD09PXRoaXMuX3ByZXZ8fG51bGw9PT10aGlzLl9uZXh0KXJldHVybiB0aGlzLl9hcmVhPWxvLk1BWF9BUkVBLG51bGw7dGhpcy5fYXJlYT1NYXRoLmFicyhyZS5hcmVhKHRoaXMuX3ByZXYuX3B0LHRoaXMuX3B0LHRoaXMuX25leHQuX3B0KSl9cmVtb3ZlKCl7Y29uc3QgdD10aGlzLl9wcmV2LGU9dGhpcy5fbmV4dDtsZXQgbj1udWxsO3JldHVybiBudWxsIT09dGhpcy5fcHJldiYmKHRoaXMuX3ByZXYuc2V0TmV4dChlKSx0aGlzLl9wcmV2LnVwZGF0ZUFyZWEoKSxuPXRoaXMuX3ByZXYpLG51bGwhPT10aGlzLl9uZXh0JiYodGhpcy5fbmV4dC5zZXRQcmV2KHQpLHRoaXMuX25leHQudXBkYXRlQXJlYSgpLG51bGw9PT1uJiYobj10aGlzLl9uZXh0KSksdGhpcy5faXNMaXZlPSExLG59aXNMaXZlKCl7cmV0dXJuIHRoaXMuX2lzTGl2ZX1zZXRQcmV2KHQpe3RoaXMuX3ByZXY9dH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1nZXRDbGFzcygpe3JldHVybiBsb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHQ9bnVsbCx0aGlzLl9wcmV2PW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2FyZWE9bG8uTUFYX0FSRUEsdGhpcy5faXNMaXZlPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0PXR9LGxvLk1BWF9BUkVBPWkuTUFYX1ZBTFVFLG9vLlZXVmVydGV4PWxvLG9vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0cz1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX3RvbGVyYW5jZT1lKmV9O2NsYXNzIGFve2NvbnN0cnVjdG9yKCl7YW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBhbyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9c2V0RW5zdXJlVmFsaWQodCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXR9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKT90aGlzLl9pbnB1dEdlb20uY29weSgpOm5ldyBjbyh0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgbihcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fWdldENsYXNzKCl7cmV0dXJuIGFvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBjbyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxjby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXRyYW5zZm9ybVBvbHlnb24odCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBBdD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5P3QuYnVmZmVyKDApOnR9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz1udWxsO3JldHVybiBzPTA9PT1uLmxlbmd0aD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTpvby5zaW1wbGlmeShuLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybUxpbmVhclJpbmcodCxlKXtjb25zdCBuPWUgaW5zdGFuY2VvZiBidCxzPXN1cGVyLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fHMgaW5zdGFuY2VvZiBEdD9zOm51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gY299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPWV9LGFvLlZXVHJhbnNmb3JtZXI9Y28sYW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9O3ZhciBobz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEb3VnbGFzUGV1Y2tlclNpbXBsaWZpZXI6S3IsVG9wb2xvZ3lQcmVzZXJ2aW5nU2ltcGxpZmllcjpzbyxWV1NpbXBsaWZpZXI6YW99KTtjbGFzcyB1b3tjb25zdHJ1Y3Rvcigpe3VvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHBvaW50QWxvbmdSZXZlcnNlKHQsZSl7Y29uc3Qgbj1uZXcgZztyZXR1cm4gbi54PXQucDEueC1lKih0LnAxLngtdC5wMC54KSxuLnk9dC5wMS55LWUqKHQucDEueS10LnAwLnkpLG59c3BsaXRBdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX21pbmltdW1MZW4vdGhpcy5fc2VnTGVuO2lmKHQuZGlzdGFuY2UodGhpcy5fc2VnLnAwKTx0aGlzLl9taW5pbXVtTGVuKXJldHVybiB0aGlzLl9zcGxpdFB0PXRoaXMuX3NlZy5wb2ludEFsb25nKGUpLG51bGw7aWYodC5kaXN0YW5jZSh0aGlzLl9zZWcucDEpPHRoaXMuX21pbmltdW1MZW4pcmV0dXJuIHRoaXMuX3NwbGl0UHQ9dW8ucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5fc2VnLGUpLG51bGw7dGhpcy5fc3BsaXRQdD10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5nZXRDb25zdHJhaW5lZExlbmd0aCh0KS90aGlzLl9zZWdMZW47ZS5lcXVhbHMyRCh0aGlzLl9zZWcucDApP3RoaXMuX3NwbGl0UHQ9dGhpcy5fc2VnLnBvaW50QWxvbmcobik6dGhpcy5fc3BsaXRQdD11by5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLl9zZWcsbil9fXNldE1pbmltdW1MZW5ndGgodCl7dGhpcy5fbWluaW11bUxlbj10fWdldENvbnN0cmFpbmVkTGVuZ3RoKHQpe3JldHVybiB0PHRoaXMuX21pbmltdW1MZW4/dGhpcy5fbWluaW11bUxlbjp0fWdldFNwbGl0UG9pbnQoKXtyZXR1cm4gdGhpcy5fc3BsaXRQdH1nZXRDbGFzcygpe3JldHVybiB1b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2VnPW51bGwsdGhpcy5fc2VnTGVuPW51bGwsdGhpcy5fc3BsaXRQdD1udWxsLHRoaXMuX21pbmltdW1MZW49MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWc9dCx0aGlzLl9zZWdMZW49dC5nZXRMZW5ndGgoKX07Y2xhc3MgZ297Y29uc3RydWN0b3IoKXtnby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmRTcGxpdFBvaW50KHQsZSl7fWdldENsYXNzKCl7cmV0dXJuIGdvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1nby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIF9ve2NvbnN0cnVjdG9yKCl7X28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcHJvamVjdGVkU3BsaXRQb2ludCh0LGUpe3JldHVybiB0LmdldExpbmVTZWdtZW50KCkucHJvamVjdChlKX1maW5kU3BsaXRQb2ludCh0LGUpe2NvbnN0IG49dC5nZXRMaW5lU2VnbWVudCgpLHM9bi5nZXRMZW5ndGgoKS8yLGk9bmV3IHVvKG4pLHI9X28ucHJvamVjdGVkU3BsaXRQb2ludCh0LGUpO2xldCBvPTIqci5kaXN0YW5jZShlKSouODtyZXR1cm4gbz5zJiYobz1zKSxpLnNldE1pbmltdW1MZW5ndGgobyksaS5zcGxpdEF0KHIpLGkuZ2V0U3BsaXRQb2ludCgpfWdldENsYXNzKCl7cmV0dXJuIF9vfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnb119fV9vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgZm97Y29uc3RydWN0b3IoKXtmby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0cmlBcmVhKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShlLnktdC55KSoobi54LXQueCl9c3RhdGljIGlzSW5DaXJjbGVERE5vcm1hbGl6ZWQodCxlLG4scyl7Y29uc3QgaT1SLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qocy54KSxyPVIudmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChzLnkpLG89Ui52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHMueCksbD1SLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3Qocy55KSxhPVIudmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdChzLngpLGM9Ui52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KHMueSksaD1pLm11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChvLm11bHRpcGx5KHIpKSx1PW8ubXVsdGlwbHkoYykuc2VsZlN1YnRyYWN0KGEubXVsdGlwbHkobCkpLGc9YS5tdWx0aXBseShyKS5zZWxmU3VidHJhY3QoaS5tdWx0aXBseShjKSksZD1pLm11bHRpcGx5KGkpLnNlbGZBZGQoci5tdWx0aXBseShyKSksXz1vLm11bHRpcGx5KG8pLnNlbGZBZGQobC5tdWx0aXBseShsKSksZj1hLm11bHRpcGx5KGEpLnNlbGZBZGQoYy5tdWx0aXBseShjKSk7cmV0dXJuIGQuc2VsZk11bHRpcGx5KHUpLnNlbGZBZGQoXy5zZWxmTXVsdGlwbHkoZykpLnNlbGZBZGQoZi5zZWxmTXVsdGlwbHkoaCkpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgY2hlY2tSb2J1c3RJbkNpcmNsZSh0LGUsbixzKXtjb25zdCBpPWZvLmlzSW5DaXJjbGVOb25Sb2J1c3QodCxlLG4scykscj1mby5pc0luQ2lyY2xlRERTbG93KHQsZSxuLHMpLG89Zm8uaXNJbkNpcmNsZUNDKHQsZSxuLHMpLGw9cmUuY2lyY3VtY2VudHJlKHQsZSxuKTtPLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS10LmRpc3RhbmNlKGwpKS90LmRpc3RhbmNlKGwpKSxpPT09ciYmaT09PW98fChPLm91dC5wcmludGxuKFwiaW5DaXJjbGUgcm9idXN0bmVzcyBmYWlsdXJlIChkb3VibGUgcmVzdWx0ID0gXCIraStcIiwgREQgcmVzdWx0ID0gXCIrcitcIiwgQ0MgcmVzdWx0ID0gXCIrbytcIilcIiksTy5vdXQucHJpbnRsbihKdC50b0xpbmVTdHJpbmcobmV3IHp0KFt0LGUsbixzXSkpKSxPLm91dC5wcmludGxuKFwiQ2lyY3VtY2VudHJlID0gXCIrSnQudG9Qb2ludChsKStcIiByYWRpdXMgPSBcIit0LmRpc3RhbmNlKGwpKSxPLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS90LmRpc3RhbmNlKGwpLTEpKSxPLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBiID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS9lLmRpc3RhbmNlKGwpLTEpKSxPLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBjID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS9uLmRpc3RhbmNlKGwpLTEpKSxPLm91dC5wcmludGxuKCkpfXN0YXRpYyBpc0luQ2lyY2xlRERGYXN0KHQsZSxuLHMpe2NvbnN0IGk9Ui5zcXIodC54KS5zZWxmQWRkKFIuc3FyKHQueSkpLnNlbGZNdWx0aXBseShmby50cmlBcmVhRERGYXN0KGUsbixzKSkscj1SLnNxcihlLngpLnNlbGZBZGQoUi5zcXIoZS55KSkuc2VsZk11bHRpcGx5KGZvLnRyaUFyZWFEREZhc3QodCxuLHMpKSxvPVIuc3FyKG4ueCkuc2VsZkFkZChSLnNxcihuLnkpKS5zZWxmTXVsdGlwbHkoZm8udHJpQXJlYURERmFzdCh0LGUscykpLGw9Ui5zcXIocy54KS5zZWxmQWRkKFIuc3FyKHMueSkpLnNlbGZNdWx0aXBseShmby50cmlBcmVhRERGYXN0KHQsZSxuKSk7cmV0dXJuIGkuc2VsZlN1YnRyYWN0KHIpLnNlbGZBZGQobykuc2VsZlN1YnRyYWN0KGwpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgaXNJbkNpcmNsZUNDKHQsZSxuLHMpe2NvbnN0IGk9cmUuY2lyY3VtY2VudHJlKHQsZSxuKSxyPXQuZGlzdGFuY2UoaSk7cmV0dXJuIHMuZGlzdGFuY2UoaSktcjw9MH1zdGF0aWMgaXNJbkNpcmNsZU5vcm1hbGl6ZWQodCxlLG4scyl7Y29uc3QgaT10Lngtcy54LHI9dC55LXMueSxvPWUueC1zLngsbD1lLnktcy55LGE9bi54LXMueCxjPW4ueS1zLnk7cmV0dXJuKGkqaStyKnIpKihvKmMtYSpsKSsobypvK2wqbCkqKGEqci1pKmMpKyhhKmErYypjKSooaSpsLW8qcik+MH1zdGF0aWMgaXNJbkNpcmNsZUREU2xvdyh0LGUsbixzKXtjb25zdCBpPVIudmFsdWVPZihzLngpLHI9Ui52YWx1ZU9mKHMueSksbz1SLnZhbHVlT2YodC54KSxsPVIudmFsdWVPZih0LnkpLGE9Ui52YWx1ZU9mKGUueCksYz1SLnZhbHVlT2YoZS55KSxoPVIudmFsdWVPZihuLngpLHU9Ui52YWx1ZU9mKG4ueSksZz1vLm11bHRpcGx5KG8pLmFkZChsLm11bHRpcGx5KGwpKS5tdWx0aXBseShmby50cmlBcmVhRERTbG93KGEsYyxoLHUsaSxyKSksZD1hLm11bHRpcGx5KGEpLmFkZChjLm11bHRpcGx5KGMpKS5tdWx0aXBseShmby50cmlBcmVhRERTbG93KG8sbCxoLHUsaSxyKSksXz1oLm11bHRpcGx5KGgpLmFkZCh1Lm11bHRpcGx5KHUpKS5tdWx0aXBseShmby50cmlBcmVhRERTbG93KG8sbCxhLGMsaSxyKSksZj1pLm11bHRpcGx5KGkpLmFkZChyLm11bHRpcGx5KHIpKS5tdWx0aXBseShmby50cmlBcmVhRERTbG93KG8sbCxhLGMsaCx1KSk7cmV0dXJuIGcuc3VidHJhY3QoZCkuYWRkKF8pLnN1YnRyYWN0KGYpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgaXNJbkNpcmNsZU5vblJvYnVzdCh0LGUsbixzKXtyZXR1cm4odC54KnQueCt0LnkqdC55KSpmby50cmlBcmVhKGUsbixzKS0oZS54KmUueCtlLnkqZS55KSpmby50cmlBcmVhKHQsbixzKSsobi54Km4ueCtuLnkqbi55KSpmby50cmlBcmVhKHQsZSxzKS0ocy54KnMueCtzLnkqcy55KSpmby50cmlBcmVhKHQsZSxuKT4wfXN0YXRpYyBpc0luQ2lyY2xlUm9idXN0KHQsZSxuLHMpe3JldHVybiBmby5pc0luQ2lyY2xlTm9ybWFsaXplZCh0LGUsbixzKX1zdGF0aWMgdHJpQXJlYUREU2xvdyh0LGUsbixzLGkscil7cmV0dXJuIG4uc3VidHJhY3QodCkubXVsdGlwbHkoci5zdWJ0cmFjdChlKSkuc3VidHJhY3Qocy5zdWJ0cmFjdChlKS5tdWx0aXBseShpLnN1YnRyYWN0KHQpKSl9c3RhdGljIHRyaUFyZWFEREZhc3QodCxlLG4pe2NvbnN0IHM9Ui52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KFIudmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxpPVIudmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShSLnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3QodC54KSk7cmV0dXJuIHMuc2VsZlN1YnRyYWN0KGkpfWdldENsYXNzKCl7cmV0dXJuIGZvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHBve2NvbnN0cnVjdG9yKCl7cG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW50ZXJwb2xhdGVaKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9ZS5kaXN0YW5jZShuKSxpPXQuZGlzdGFuY2UoZSkscj1uLnotZS56O3JldHVybiBlLnorciooaS9zKX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1lLngscj1lLnksbz1uLngtaSxsPXMueC1pLGE9bi55LXIsYz1zLnktcixoPW8qYy1sKmEsdT10LngtaSxnPXQueS1yLGQ9KGMqdS1sKmcpL2gsXz0oLWEqdStvKmcpL2g7cmV0dXJuIGUueitkKihuLnotZS56KStfKihzLnotZS56KX19Y2lyY2xlQ2VudGVyKHQsZSl7Y29uc3Qgbj1uZXcgcG8odGhpcy5nZXRYKCksdGhpcy5nZXRZKCkpLHM9dGhpcy5iaXNlY3RvcihuLHQpLGk9dGhpcy5iaXNlY3Rvcih0LGUpLHI9bmV3IGIocyxpKTtsZXQgbz1udWxsO3RyeXtvPW5ldyBwbyhyLmdldFgoKSxyLmdldFkoKSl9Y2F0Y2gocyl7aWYoIShzIGluc3RhbmNlb2YgUykpdGhyb3cgcztPLmVyci5wcmludGxuKFwiYTogXCIrbitcIiAgYjogXCIrdCtcIiAgYzogXCIrZSksTy5lcnIucHJpbnRsbihzKX1yZXR1cm4gb31kb3QodCl7cmV0dXJuIHRoaXMuX3AueCp0LmdldFgoKSt0aGlzLl9wLnkqdC5nZXRZKCl9bWFnbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy5fcC54KnRoaXMuX3AueCt0aGlzLl9wLnkqdGhpcy5fcC55KX1nZXRaKCl7cmV0dXJuIHRoaXMuX3Auen1iaXNlY3Rvcih0LGUpe2NvbnN0IG49ZS5nZXRYKCktdC5nZXRYKCkscz1lLmdldFkoKS10LmdldFkoKSxpPW5ldyBiKHQuZ2V0WCgpK24vMix0LmdldFkoKStzLzIsMSkscj1uZXcgYih0LmdldFgoKS1zK24vMix0LmdldFkoKStuK3MvMiwxKTtyZXR1cm4gbmV3IGIoaSxyKX1lcXVhbHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX3AueD09PXQuZ2V0WCgpJiZ0aGlzLl9wLnk9PT10LmdldFkoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX3AuZGlzdGFuY2UodC5nZXRDb29yZGluYXRlKCkpPGV9fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcH1pc0luQ2lyY2xlKHQsZSxuKXtyZXR1cm4gZm8uaXNJbkNpcmNsZVJvYnVzdCh0Ll9wLGUuX3Asbi5fcCx0aGlzLl9wKX1pbnRlcnBvbGF0ZVpWYWx1ZSh0LGUsbil7Y29uc3Qgcz10LmdldFgoKSxpPXQuZ2V0WSgpLHI9ZS5nZXRYKCktcyxvPW4uZ2V0WCgpLXMsbD1lLmdldFkoKS1pLGE9bi5nZXRZKCktaSxjPXIqYS1vKmwsaD10aGlzLmdldFgoKS1zLHU9dGhpcy5nZXRZKCktaSxnPShhKmgtbyp1KS9jLGQ9KC1sKmgrcip1KS9jO3JldHVybiB0LmdldFooKStnKihlLmdldFooKS10LmdldFooKSkrZCoobi5nZXRaKCktdC5nZXRaKCkpfW1pZFBvaW50KHQpe2NvbnN0IGU9KHRoaXMuX3AueCt0LmdldFgoKSkvMixuPSh0aGlzLl9wLnkrdC5nZXRZKCkpLzIscz0odGhpcy5fcC56K3QuZ2V0WigpKS8yO3JldHVybiBuZXcgcG8oZSxuLHMpfXJpZ2h0T2YodCl7cmV0dXJuIHRoaXMuaXNDQ1codC5kZXN0KCksdC5vcmlnKCkpfWlzQ0NXKHQsZSl7cmV0dXJuKHQuX3AueC10aGlzLl9wLngpKihlLl9wLnktdGhpcy5fcC55KS0odC5fcC55LXRoaXMuX3AueSkqKGUuX3AueC10aGlzLl9wLngpPjB9Z2V0WCgpe3JldHVybiB0aGlzLl9wLnh9Y3Jvc3NQcm9kdWN0KHQpe3JldHVybiB0aGlzLl9wLngqdC5nZXRZKCktdGhpcy5fcC55KnQuZ2V0WCgpfXNldFoodCl7dGhpcy5fcC56PXR9dGltZXModCl7cmV0dXJuIG5ldyBwbyh0KnRoaXMuX3AueCx0KnRoaXMuX3AueSl9Y3Jvc3MoKXtyZXR1cm4gbmV3IHBvKHRoaXMuX3AueSwtdGhpcy5fcC54KX1sZWZ0T2YodCl7cmV0dXJuIHRoaXMuaXNDQ1codC5vcmlnKCksdC5kZXN0KCkpfXRvU3RyaW5nKCl7cmV0dXJuXCJQT0lOVCAoXCIrdGhpcy5fcC54K1wiIFwiK3RoaXMuX3AueStcIilcIn1zdWIodCl7cmV0dXJuIG5ldyBwbyh0aGlzLl9wLngtdC5nZXRYKCksdGhpcy5fcC55LXQuZ2V0WSgpKX1nZXRZKCl7cmV0dXJuIHRoaXMuX3AueX1jbGFzc2lmeSh0LGUpe2NvbnN0IG49ZS5zdWIodCkscz10aGlzLnN1Yih0KSxpPW4uY3Jvc3NQcm9kdWN0KHMpO3JldHVybiBpPjA/cG8uTEVGVDppPDA/cG8uUklHSFQ6bi5nZXRYKCkqcy5nZXRYKCk8MHx8bi5nZXRZKCkqcy5nZXRZKCk8MD9wby5CRUhJTkQ6bi5tYWduKCk8cy5tYWduKCk/cG8uQkVZT05EOnQuZXF1YWxzKHRoaXMpP3BvLk9SSUdJTjplLmVxdWFscyh0aGlzKT9wby5ERVNUSU5BVElPTjpwby5CRVRXRUVOfXN1bSh0KXtyZXR1cm4gbmV3IHBvKHRoaXMuX3AueCt0LmdldFgoKSx0aGlzLl9wLnkrdC5nZXRZKCkpfWRpc3RhbmNlKHQsZSl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlLmdldFgoKS10LmdldFgoKSwyKStNYXRoLnBvdyhlLmdldFkoKS10LmdldFkoKSwyKSl9Y2lyY3VtUmFkaXVzUmF0aW8odCxlKXtjb25zdCBuPXRoaXMuY2lyY2xlQ2VudGVyKHQsZSkscz10aGlzLmRpc3RhbmNlKG4sdCk7bGV0IGk9dGhpcy5kaXN0YW5jZSh0aGlzLHQpLHI9dGhpcy5kaXN0YW5jZSh0LGUpO3JldHVybiByPGkmJihpPXIpLHI9dGhpcy5kaXN0YW5jZShlLHRoaXMpLHI8aSYmKGk9cikscy9pfWdldENsYXNzKCl7cmV0dXJuIHBvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1wby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3A9bmV3IGcodCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD1uZXcgZyh0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3A9bmV3IGcodCxlLG4pfX0scG8uTEVGVD0wLHBvLlJJR0hUPTEscG8uQkVZT05EPTIscG8uQkVISU5EPTMscG8uQkVUV0VFTj00LHBvLk9SSUdJTj01LHBvLkRFU1RJTkFUSU9OPTY7Y2xhc3MgbW8gZXh0ZW5kcyBwb3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb25zdHJhaW50KCl7cmV0dXJuIHRoaXMuX2NvbnN0cmFpbnR9c2V0T25Db25zdHJhaW50KHQpe3RoaXMuX2lzT25Db25zdHJhaW50PXR9bWVyZ2UodCl7dC5faXNPbkNvbnN0cmFpbnQmJih0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLl9jb25zdHJhaW50PXQuX2NvbnN0cmFpbnQpfWlzT25Db25zdHJhaW50KCl7cmV0dXJuIHRoaXMuX2lzT25Db25zdHJhaW50fXNldENvbnN0cmFpbnQodCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5fY29uc3RyYWludD10fWdldENsYXNzKCl7cmV0dXJuIG1vfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1tby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc09uQ29uc3RyYWludD1udWxsLHRoaXMuX2NvbnN0cmFpbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTtwby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfTtjbGFzcyB5b3tjb25zdHJ1Y3Rvcigpe3lvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1ha2VFZGdlKHQsZSl7Y29uc3Qgbj1uZXcgeW8scz1uZXcgeW8saT1uZXcgeW8scj1uZXcgeW87bi5fcm90PXMscy5fcm90PWksaS5fcm90PXIsci5fcm90PW4sbi5zZXROZXh0KG4pLHMuc2V0TmV4dChyKSxpLnNldE5leHQoaSksci5zZXROZXh0KHMpO2NvbnN0IG89bjtyZXR1cm4gby5zZXRPcmlnKHQpLG8uc2V0RGVzdChlKSxvfXN0YXRpYyBzd2FwKHQpe2NvbnN0IGU9dC5vUHJldigpLG49dC5zeW0oKS5vUHJldigpO3lvLnNwbGljZSh0LGUpLHlvLnNwbGljZSh0LnN5bSgpLG4pLHlvLnNwbGljZSh0LGUubE5leHQoKSkseW8uc3BsaWNlKHQuc3ltKCksbi5sTmV4dCgpKSx0LnNldE9yaWcoZS5kZXN0KCkpLHQuc2V0RGVzdChuLmRlc3QoKSl9c3RhdGljIHNwbGljZSh0LGUpe2NvbnN0IG49dC5vTmV4dCgpLnJvdCgpLHM9ZS5vTmV4dCgpLnJvdCgpLGk9ZS5vTmV4dCgpLHI9dC5vTmV4dCgpLG89cy5vTmV4dCgpLGw9bi5vTmV4dCgpO3Quc2V0TmV4dChpKSxlLnNldE5leHQociksbi5zZXROZXh0KG8pLHMuc2V0TmV4dChsKX1zdGF0aWMgY29ubmVjdCh0LGUpe2NvbnN0IG49eW8ubWFrZUVkZ2UodC5kZXN0KCksZS5vcmlnKCkpO3JldHVybiB5by5zcGxpY2Uobix0LmxOZXh0KCkpLHlvLnNwbGljZShuLnN5bSgpLGUpLG59ZXF1YWxzTm9uT3JpZW50ZWQodCl7cmV0dXJuISF0aGlzLmVxdWFsc09yaWVudGVkKHQpfHwhIXRoaXMuZXF1YWxzT3JpZW50ZWQodC5zeW0oKSl9dG9MaW5lU2VnbWVudCgpe3JldHVybiBuZXcgZWUodGhpcy5fdmVydGV4LmdldENvb3JkaW5hdGUoKSx0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpfWRlc3QoKXtyZXR1cm4gdGhpcy5zeW0oKS5vcmlnKCl9b05leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1lcXVhbHNPcmllbnRlZCh0KXtyZXR1cm4hKCF0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpKXx8IXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpKX1kTmV4dCgpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCkuc3ltKCl9bFByZXYoKXtyZXR1cm4gdGhpcy5fbmV4dC5zeW0oKX1yUHJldigpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCl9cm90KCl7cmV0dXJuIHRoaXMuX3JvdH1vUHJldigpe3JldHVybiB0aGlzLl9yb3QuX25leHQuX3JvdH1zeW0oKXtyZXR1cm4gdGhpcy5fcm90Ll9yb3R9c2V0T3JpZyh0KXt0aGlzLl92ZXJ0ZXg9dH1sTmV4dCgpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkucm90KCl9Z2V0TGVuZ3RoKCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZSh0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpfWludlJvdCgpe3JldHVybiB0aGlzLl9yb3Quc3ltKCl9c2V0RGVzdCh0KXt0aGlzLnN5bSgpLnNldE9yaWcodCl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWRlbGV0ZSgpe3RoaXMuX3JvdD1udWxsfW9yaWcoKXtyZXR1cm4gdGhpcy5fdmVydGV4fXJOZXh0KCl7cmV0dXJuIHRoaXMuX3JvdC5fbmV4dC5pbnZSb3QoKX10b1N0cmluZygpe2NvbnN0IHQ9dGhpcy5fdmVydGV4LmdldENvb3JkaW5hdGUoKSxlPXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKTtyZXR1cm4gSnQudG9MaW5lU3RyaW5nKHQsZSl9aXNMaXZlKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb3R9Z2V0UHJpbWFyeSgpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSk8PTA/dGhpczp0aGlzLnN5bSgpfWRQcmV2KCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5pbnZSb3QoKX1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1nZXRDbGFzcygpe3JldHVybiB5b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcm90PW51bGwsdGhpcy5fdmVydGV4PW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2RhdGE9bnVsbH07Y2xhc3MgeG97Y29uc3RydWN0b3IoKXt4by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydFNpdGUodCl7bGV0IGU9dGhpcy5fc3ViZGl2LmxvY2F0ZSh0KTtpZih0aGlzLl9zdWJkaXYuaXNWZXJ0ZXhPZkVkZ2UoZSx0KSlyZXR1cm4gZTt0aGlzLl9zdWJkaXYuaXNPbkVkZ2UoZSx0LmdldENvb3JkaW5hdGUoKSkmJihlPWUub1ByZXYoKSx0aGlzLl9zdWJkaXYuZGVsZXRlKGUub05leHQoKSkpO2xldCBuPXRoaXMuX3N1YmRpdi5tYWtlRWRnZShlLm9yaWcoKSx0KTt5by5zcGxpY2UobixlKTtjb25zdCBzPW47ZG97bj10aGlzLl9zdWJkaXYuY29ubmVjdChlLG4uc3ltKCkpLGU9bi5vUHJldigpfXdoaWxlKGUubE5leHQoKSE9PXMpO2Zvcig7Oyl7Y29uc3QgaT1lLm9QcmV2KCk7aWYoaS5kZXN0KCkucmlnaHRPZihlKSYmdC5pc0luQ2lyY2xlKGUub3JpZygpLGkuZGVzdCgpLGUuZGVzdCgpKSl5by5zd2FwKGUpLGU9ZS5vUHJldigpO2Vsc2V7aWYoZS5vTmV4dCgpPT09cylyZXR1cm4gbjtlPWUub05leHQoKS5sUHJldigpfX19aW5zZXJ0U2l0ZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKHQpfX1nZXRDbGFzcygpe3JldHVybiB4b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc3ViZGl2PW51bGwsdGhpcy5faXNVc2luZ1RvbGVyYW5jZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJkaXY9dCx0aGlzLl9pc1VzaW5nVG9sZXJhbmNlPXQuZ2V0VG9sZXJhbmNlKCk+MH07Y2xhc3MgRW97Y29uc3RydWN0b3IoKXtFby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWxvY2F0ZSh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gRW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUVvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgSW97Y29uc3RydWN0b3IoKXtJby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluaXQoKXt0aGlzLl9sYXN0RWRnZT10aGlzLmZpbmRFZGdlKCl9bG9jYXRlKHQpe3RoaXMuX2xhc3RFZGdlLmlzTGl2ZSgpfHx0aGlzLmluaXQoKTtjb25zdCBlPXRoaXMuX3N1YmRpdi5sb2NhdGVGcm9tRWRnZSh0LHRoaXMuX2xhc3RFZGdlKTtyZXR1cm4gdGhpcy5fbGFzdEVkZ2U9ZSxlfWZpbmRFZGdlKCl7cmV0dXJuIHRoaXMuX3N1YmRpdi5nZXRFZGdlcygpLml0ZXJhdG9yKCkubmV4dCgpfWdldENsYXNzKCl7cmV0dXJuIElvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltFb119fUlvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2xhc3RFZGdlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3ViZGl2PXQsdGhpcy5pbml0KCl9O2NsYXNzIE5vIGV4dGVuZHMgY3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbXNnV2l0aFNwYXRpYWwodCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9Z2V0U2VnbWVudCgpe3JldHVybiB0aGlzLl9zZWd9Z2V0Q2xhc3MoKXtyZXR1cm4gTm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU5vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3NlZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtjLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXTtjLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsXCJMb2NhdGUgZmFpbGVkIHRvIGNvbnZlcmdlIChhdCBlZGdlOiBcIit0K1wiKS4gIFBvc3NpYmxlIGNhdXNlcyBpbmNsdWRlIGludmFsaWQgU3ViZGl2aXNpb24gdG9wb2xvZ3kgb3IgdmVyeSBjbG9zZSBzaXRlc1wiKSx0aGlzLl9zZWc9bmV3IGVlKHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtjLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsTm8ubXNnV2l0aFNwYXRpYWwodCxlKSksdGhpcy5fc2VnPW5ldyBlZShlKX19O2NsYXNzIENve2NvbnN0cnVjdG9yKCl7Q28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdCh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gQ299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUNvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgU297Y29uc3RydWN0b3IoKXtTby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRUcmlhbmdsZUVkZ2VzKHQsZSl7aWYoZVswXT10LGVbMV09ZVswXS5sTmV4dCgpLGVbMl09ZVsxXS5sTmV4dCgpLGVbMl0ubE5leHQoKSE9PWVbMF0pdGhyb3cgbmV3IG4oXCJFZGdlcyBkbyBub3QgZm9ybSBhIHRyaWFuZ2xlXCIpfWdldFRyaWFuZ2xlVmVydGljZXModCl7Y29uc3QgZT1uZXcgVG87cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlVmVydGljZXMoKX1pc0ZyYW1lVmVydGV4KHQpe3JldHVybiEhdC5lcXVhbHModGhpcy5fZnJhbWVWZXJ0ZXhbMF0pfHwoISF0LmVxdWFscyh0aGlzLl9mcmFtZVZlcnRleFsxXSl8fCEhdC5lcXVhbHModGhpcy5fZnJhbWVWZXJ0ZXhbMl0pKX1pc1ZlcnRleE9mRWRnZSh0LGUpe3JldHVybiEoIWUuZXF1YWxzKHQub3JpZygpLHRoaXMuX3RvbGVyYW5jZSkmJiFlLmVxdWFscyh0LmRlc3QoKSx0aGlzLl90b2xlcmFuY2UpKX1jb25uZWN0KHQsZSl7Y29uc3Qgbj15by5jb25uZWN0KHQsZSk7cmV0dXJuIHRoaXMuX3F1YWRFZGdlcy5hZGQobiksbn1nZXRWb3Jvbm9pQ2VsbFBvbHlnb24odCxlKXtjb25zdCBuPW5ldyB4LHM9dDtkb3tjb25zdCBlPXQucm90KCkub3JpZygpLmdldENvb3JkaW5hdGUoKTtuLmFkZChlKSx0PXQub1ByZXYoKX13aGlsZSh0IT09cyk7Y29uc3QgaT1uZXcgSTtpLmFkZEFsbChuLCExKSxpLmNsb3NlUmluZygpLGkuc2l6ZSgpPDQmJihPLm91dC5wcmludGxuKGkpLGkuYWRkKGkuZ2V0KGkuc2l6ZSgpLTEpLCEwKSk7Y29uc3Qgcj1pLnRvQ29vcmRpbmF0ZUFycmF5KCksbz1lLmNyZWF0ZVBvbHlnb24oZS5jcmVhdGVMaW5lYXJSaW5nKHIpKSxsPXMub3JpZygpO3JldHVybiBvLnNldFVzZXJEYXRhKGwuZ2V0Q29vcmRpbmF0ZSgpKSxvfXNldExvY2F0b3IodCl7dGhpcy5fbG9jYXRvcj10fWluaXRTdWJkaXYoKXtjb25zdCB0PXRoaXMubWFrZUVkZ2UodGhpcy5fZnJhbWVWZXJ0ZXhbMF0sdGhpcy5fZnJhbWVWZXJ0ZXhbMV0pLGU9dGhpcy5tYWtlRWRnZSh0aGlzLl9mcmFtZVZlcnRleFsxXSx0aGlzLl9mcmFtZVZlcnRleFsyXSk7eW8uc3BsaWNlKHQuc3ltKCksZSk7Y29uc3Qgbj10aGlzLm1ha2VFZGdlKHRoaXMuX2ZyYW1lVmVydGV4WzJdLHRoaXMuX2ZyYW1lVmVydGV4WzBdKTtyZXR1cm4geW8uc3BsaWNlKGUuc3ltKCksbikseW8uc3BsaWNlKG4uc3ltKCksdCksdH1pc0ZyYW1lQm9yZGVyRWRnZSh0KXtjb25zdCBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO1NvLmdldFRyaWFuZ2xlRWRnZXModCxlKTtjb25zdCBuPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO1NvLmdldFRyaWFuZ2xlRWRnZXModC5zeW0oKSxuKTtjb25zdCBzPXQubE5leHQoKS5kZXN0KCk7aWYodGhpcy5pc0ZyYW1lVmVydGV4KHMpKXJldHVybiEwO2NvbnN0IGk9dC5zeW0oKS5sTmV4dCgpLmRlc3QoKTtyZXR1cm4hIXRoaXMuaXNGcmFtZVZlcnRleChpKX1tYWtlRWRnZSh0LGUpe2NvbnN0IG49eW8ubWFrZUVkZ2UodCxlKTtyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzLmFkZChuKSxufXZpc2l0VHJpYW5nbGVzKHQsZSl7dGhpcy5fdmlzaXRlZEtleSsrO2NvbnN0IG49bmV3IG9uO24ucHVzaCh0aGlzLl9zdGFydGluZ0VkZ2UpO2NvbnN0IHM9bmV3IEo7Zm9yKDshbi5lbXB0eSgpOyl7Y29uc3QgaT1uLnBvcCgpO2lmKCFzLmNvbnRhaW5zKGkpKXtjb25zdCByPXRoaXMuZmV0Y2hUcmlhbmdsZVRvVmlzaXQoaSxuLGUscyk7bnVsbCE9PXImJnQudmlzaXQocil9fX1pc0ZyYW1lRWRnZSh0KXtyZXR1cm4hKCF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5vcmlnKCkpJiYhdGhpcy5pc0ZyYW1lVmVydGV4KHQuZGVzdCgpKSl9aXNPbkVkZ2UodCxlKXtyZXR1cm4gdGhpcy5fc2VnLnNldENvb3JkaW5hdGVzKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSx0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpLHRoaXMuX3NlZy5kaXN0YW5jZShlKTx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2V9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gbmV3IE4odGhpcy5fZnJhbWVFbnYpfWNyZWF0ZUZyYW1lKHQpe2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKTtsZXQgcz0wO3M9ZT5uPzEwKmU6MTAqbix0aGlzLl9mcmFtZVZlcnRleFswXT1uZXcgcG8oKHQuZ2V0TWF4WCgpK3QuZ2V0TWluWCgpKS8yLHQuZ2V0TWF4WSgpK3MpLHRoaXMuX2ZyYW1lVmVydGV4WzFdPW5ldyBwbyh0LmdldE1pblgoKS1zLHQuZ2V0TWluWSgpLXMpLHRoaXMuX2ZyYW1lVmVydGV4WzJdPW5ldyBwbyh0LmdldE1heFgoKStzLHQuZ2V0TWluWSgpLXMpLHRoaXMuX2ZyYW1lRW52PW5ldyBOKHRoaXMuX2ZyYW1lVmVydGV4WzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLl9mcmFtZVZlcnRleFsxXS5nZXRDb29yZGluYXRlKCkpLHRoaXMuX2ZyYW1lRW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9mcmFtZVZlcnRleFsyXS5nZXRDb29yZGluYXRlKCkpfWdldFRyaWFuZ2xlQ29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgUm87cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlcygpfWdldFZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IEo7Zm9yKGxldCBuPXRoaXMuX3F1YWRFZGdlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMub3JpZygpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgoaSl8fGUuYWRkKGkpO2NvbnN0IHI9cy5kZXN0KCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChyKXx8ZS5hZGQocil9cmV0dXJuIGV9ZmV0Y2hUcmlhbmdsZVRvVmlzaXQodCxlLG4scyl7bGV0IGk9dCxyPTAsbz0hMTtkb3t0aGlzLl90cmlFZGdlc1tyXT1pLHRoaXMuaXNGcmFtZUVkZ2UoaSkmJihvPSEwKTtjb25zdCB0PWkuc3ltKCk7cy5jb250YWlucyh0KXx8ZS5wdXNoKHQpLHMuYWRkKGkpLHIrKyxpPWkubE5leHQoKX13aGlsZShpIT09dCk7cmV0dXJuIG8mJiFuP251bGw6dGhpcy5fdHJpRWRnZXN9Z2V0RWRnZXMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZ2V0UHJpbWFyeUVkZ2VzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtsZXQgcz0wO2ZvcihsZXQgaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCBlPWkubmV4dCgpO25bcysrXT10LmNyZWF0ZUxpbmVTdHJpbmcoW2Uub3JpZygpLmdldENvb3JkaW5hdGUoKSxlLmRlc3QoKS5nZXRDb29yZGluYXRlKCldKX1yZXR1cm4gdC5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobil9fWdldFZlcnRleFVuaXF1ZUVkZ2VzKHQpe2NvbnN0IGU9bmV3IHgsbj1uZXcgSjtmb3IobGV0IHM9dGhpcy5fcXVhZEVkZ2VzLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBpPXMubmV4dCgpLHI9aS5vcmlnKCk7bi5jb250YWlucyhyKXx8KG4uYWRkKHIpLCF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocil8fGUuYWRkKGkpKTtjb25zdCBvPWkuc3ltKCksbD1vLm9yaWcoKTtuLmNvbnRhaW5zKGwpfHwobi5hZGQobCksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChsKXx8ZS5hZGQobykpfXJldHVybiBlfWdldFRyaWFuZ2xlRWRnZXModCl7Y29uc3QgZT1uZXcgTG87cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlRWRnZXMoKX1nZXRQcmltYXJ5RWRnZXModCl7dGhpcy5fdmlzaXRlZEtleSsrO2NvbnN0IGU9bmV3IHgsbj1uZXcgb247bi5wdXNoKHRoaXMuX3N0YXJ0aW5nRWRnZSk7Y29uc3Qgcz1uZXcgSjtmb3IoOyFuLmVtcHR5KCk7KXtjb25zdCBpPW4ucG9wKCk7aWYoIXMuY29udGFpbnMoaSkpe2NvbnN0IHI9aS5nZXRQcmltYXJ5KCk7IXQmJnRoaXMuaXNGcmFtZUVkZ2Uocil8fGUuYWRkKHIpLG4ucHVzaChpLm9OZXh0KCkpLG4ucHVzaChpLnN5bSgpLm9OZXh0KCkpLHMuYWRkKGkpLHMuYWRkKGkuc3ltKCkpfX1yZXR1cm4gZX1kZWxldGUodCl7eW8uc3BsaWNlKHQsdC5vUHJldigpKSx5by5zcGxpY2UodC5zeW0oKSx0LnN5bSgpLm9QcmV2KCkpO2NvbnN0IGU9dC5zeW0oKSxuPXQucm90KCkscz10LnJvdCgpLnN5bSgpO3RoaXMuX3F1YWRFZGdlcy5yZW1vdmUodCksdGhpcy5fcXVhZEVkZ2VzLnJlbW92ZShlKSx0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKG4pLHRoaXMuX3F1YWRFZGdlcy5yZW1vdmUocyksdC5kZWxldGUoKSxlLmRlbGV0ZSgpLG4uZGVsZXRlKCkscy5kZWxldGUoKX1sb2NhdGVGcm9tRWRnZSh0LGUpe2xldCBuPTA7Y29uc3Qgcz10aGlzLl9xdWFkRWRnZXMuc2l6ZSgpO2xldCBpPWU7Zm9yKDs7KXtpZihuKyssbj5zKXRocm93IG5ldyBObyhpLnRvTGluZVNlZ21lbnQoKSk7aWYodC5lcXVhbHMoaS5vcmlnKCkpfHx0LmVxdWFscyhpLmRlc3QoKSkpYnJlYWs7aWYodC5yaWdodE9mKGkpKWk9aS5zeW0oKTtlbHNlIGlmKHQucmlnaHRPZihpLm9OZXh0KCkpKXtpZih0LnJpZ2h0T2YoaS5kUHJldigpKSlicmVhaztpPWkuZFByZXYoKX1lbHNlIGk9aS5vTmV4dCgpfXJldHVybiBpfWdldFRvbGVyYW5jZSgpe3JldHVybiB0aGlzLl90b2xlcmFuY2V9Z2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KXt0aGlzLnZpc2l0VHJpYW5nbGVzKG5ldyB3bywhMCk7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dGhpcy5nZXRWZXJ0ZXhVbmlxdWVFZGdlcyghMSkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7ZS5hZGQodGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb24ocyx0KSl9cmV0dXJuIGV9Z2V0Vm9yb25vaURpYWdyYW0odCl7Y29uc3QgZT10aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbnModCk7cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEh0LnRvR2VvbWV0cnlBcnJheShlKSl9Z2V0VHJpYW5nbGVzKHQpe2NvbnN0IGU9dGhpcy5nZXRUcmlhbmdsZUNvb3JkaW5hdGVzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtsZXQgcz0wO2ZvcihsZXQgaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCBlPWkubmV4dCgpO25bcysrXT10LmNyZWF0ZVBvbHlnb24odC5jcmVhdGVMaW5lYXJSaW5nKGUpKX1yZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obil9aW5zZXJ0U2l0ZSh0KXtsZXQgZT10aGlzLmxvY2F0ZSh0KTtpZih0LmVxdWFscyhlLm9yaWcoKSx0aGlzLl90b2xlcmFuY2UpfHx0LmVxdWFscyhlLmRlc3QoKSx0aGlzLl90b2xlcmFuY2UpKXJldHVybiBlO2xldCBuPXRoaXMubWFrZUVkZ2UoZS5vcmlnKCksdCk7eW8uc3BsaWNlKG4sZSk7Y29uc3Qgcz1uO2Rve249dGhpcy5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCl9d2hpbGUoZS5sTmV4dCgpIT09cyk7cmV0dXJuIHN9bG9jYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcG8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9sb2NhdG9yLmxvY2F0ZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9sb2NhdG9yLmxvY2F0ZShuZXcgcG8odCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX2xvY2F0b3IubG9jYXRlKG5ldyBwbyh0KSk7aWYobnVsbD09PW4pcmV0dXJuIG51bGw7bGV0IHM9bjtuLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodCkmJihzPW4uc3ltKCkpO2xldCBpPXM7ZG97aWYoaS5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKGUpKXJldHVybiBpO2k9aS5vTmV4dCgpfXdoaWxlKGkhPT1zKTtyZXR1cm4gbnVsbH19Z2V0Q2xhc3MoKXtyZXR1cm4gU299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHdve2NvbnN0cnVjdG9yKCl7d28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdCh0KXtjb25zdCBlPXRbMF0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxuPXRbMV0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxzPXRbMl0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxpPXJlLmNpcmN1bWNlbnRyZShlLG4scykscj1uZXcgcG8oaSk7Zm9yKGxldCBlPTA7ZTwzO2UrKyl0W2VdLnJvdCgpLnNldE9yaWcocil9Z2V0Q2xhc3MoKXtyZXR1cm4gd299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0NvXX19d28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBMb3tjb25zdHJ1Y3Rvcigpe0xvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0VHJpYW5nbGVFZGdlcygpe3JldHVybiB0aGlzLl90cmlMaXN0fXZpc2l0KHQpe3RoaXMuX3RyaUxpc3QuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIExvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltDb119fUxvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3RyaUxpc3Q9bmV3IHh9O2NsYXNzIFRve2NvbnN0cnVjdG9yKCl7VG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdCh0KXt0aGlzLl90cmlMaXN0LmFkZChbdFswXS5vcmlnKCksdFsxXS5vcmlnKCksdFsyXS5vcmlnKCldKX1nZXRUcmlhbmdsZVZlcnRpY2VzKCl7cmV0dXJuIHRoaXMuX3RyaUxpc3R9Z2V0Q2xhc3MoKXtyZXR1cm4gVG99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0NvXX19VG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdHJpTGlzdD1uZXcgeH07Y2xhc3MgUm97Y29uc3RydWN0b3IoKXtSby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNoZWNrVHJpYW5nbGVTaXplKHQpe2xldCBlPVwiXCI7dC5sZW5ndGg+PTI/ZT1KdC50b0xpbmVTdHJpbmcodFswXSx0WzFdKTp0Lmxlbmd0aD49MSYmKGU9SnQudG9Qb2ludCh0WzBdKSl9dmlzaXQodCl7dGhpcy5fY29vcmRMaXN0LmNsZWFyKCk7Zm9yKGxldCBlPTA7ZTwzO2UrKyl7Y29uc3Qgbj10W2VdLm9yaWcoKTt0aGlzLl9jb29yZExpc3QuYWRkKG4uZ2V0Q29vcmRpbmF0ZSgpKX1pZih0aGlzLl9jb29yZExpc3Quc2l6ZSgpPjApe3RoaXMuX2Nvb3JkTGlzdC5jbG9zZVJpbmcoKTtjb25zdCB0PXRoaXMuX2Nvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpO2lmKDQhPT10Lmxlbmd0aClyZXR1cm4gbnVsbDt0aGlzLl90cmlDb29yZHMuYWRkKHQpfX1nZXRUcmlhbmdsZXMoKXtyZXR1cm4gdGhpcy5fdHJpQ29vcmRzfWdldENsYXNzKCl7cmV0dXJuIFJvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltDb119fVJvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Nvb3JkTGlzdD1uZXcgSSx0aGlzLl90cmlDb29yZHM9bmV3IHh9LFNvLlRyaWFuZ2xlQ2lyY3VtY2VudHJlVmlzaXRvcj13byxTby5UcmlhbmdsZUVkZ2VzTGlzdFZpc2l0b3I9TG8sU28uVHJpYW5nbGVWZXJ0ZXhMaXN0VmlzaXRvcj1UbyxTby5UcmlhbmdsZUNvb3JkaW5hdGVzVmlzaXRvcj1SbyxTby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl92aXNpdGVkS2V5PTAsdGhpcy5fcXVhZEVkZ2VzPW5ldyB4LHRoaXMuX3N0YXJ0aW5nRWRnZT1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsLHRoaXMuX2VkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2ZyYW1lVmVydGV4PW5ldyBBcnJheSgzKS5maWxsKG51bGwpLHRoaXMuX2ZyYW1lRW52PW51bGwsdGhpcy5fbG9jYXRvcj1udWxsLHRoaXMuX3NlZz1uZXcgZWUsdGhpcy5fdHJpRWRnZXM9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fdG9sZXJhbmNlPWUsdGhpcy5fZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlPWUvU28uRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SLHRoaXMuY3JlYXRlRnJhbWUodCksdGhpcy5fc3RhcnRpbmdFZGdlPXRoaXMuaW5pdFN1YmRpdigpLHRoaXMuX2xvY2F0b3I9bmV3IElvKHRoaXMpfSxTby5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1I9MWUzO2NsYXNzIFBve2NvbnN0cnVjdG9yKCl7UG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRMaW5lU2VnbWVudCgpe3JldHVybiB0aGlzLl9sc31nZXRFbmRaKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkuen1nZXRTdGFydFooKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS56fWludGVyc2VjdGlvbih0KXtyZXR1cm4gdGhpcy5fbHMuaW50ZXJzZWN0aW9uKHQuZ2V0TGluZVNlZ21lbnQoKSl9Z2V0U3RhcnQoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKX1nZXRFbmQoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKX1nZXRFbmRZKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkueX1nZXRTdGFydFgoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS54fWVxdWFsc1RvcG8odCl7cmV0dXJuIHRoaXMuX2xzLmVxdWFsc1RvcG8odC5nZXRMaW5lU2VnbWVudCgpKX1nZXRTdGFydFkoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS55fXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1nZXRFbmRYKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkueH10b1N0cmluZygpe3JldHVybiB0aGlzLl9scy50b1N0cmluZygpfWdldENsYXNzKCl7cmV0dXJuIFBvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Qby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9scz1udWxsLHRoaXMuX2RhdGE9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbHM9bmV3IGVlKHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbHM9bmV3IGVlKHQsZSksdGhpcy5fZGF0YT1ufWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO1BvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IGcodCxlLG4pLG5ldyBnKHMsaSxyKSl9ZWxzZSBpZig3PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV0sbz1hcmd1bWVudHNbNl07UG8uY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgZyh0LGUsbiksbmV3IGcocyxpLHIpLG8pfX07Y2xhc3Mgdm97Y29uc3RydWN0b3IoKXt2by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21wdXRlVmVydGV4RW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTjtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZSh0LmdldENvb3JkaW5hdGUoKSl9cmV0dXJuIGV9Z2V0SW5pdGlhbFZlcnRpY2VzKCl7cmV0dXJuIHRoaXMuX2luaXRpYWxWZXJ0aWNlc31nZXRLRFQoKXtyZXR1cm4gdGhpcy5fa2R0fWVuZm9yY2VDb25zdHJhaW50cygpe3RoaXMuYWRkQ29uc3RyYWludFZlcnRpY2VzKCk7bGV0IHQ9MCxlPTA7ZG97ZT10aGlzLmVuZm9yY2VHYWJyaWVsKHRoaXMuX3NlZ21lbnRzKSx0Kyt9d2hpbGUoZT4wJiZ0PHZvLk1BWF9TUExJVF9JVEVSKX1pbnNlcnRTaXRlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUodCl9fWdldFZlcnRleEZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fdmVydGV4RmFjdG9yeX1nZXRQb2ludEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5faW5pdGlhbFZlcnRpY2VzLnNpemUoKSt0aGlzLl9zZWdWZXJ0aWNlcy5zaXplKCkpLmZpbGwobnVsbCk7bGV0IGU9MDtmb3IobGV0IG49dGhpcy5faW5pdGlhbFZlcnRpY2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3RbZSsrXT1zLmdldENvb3JkaW5hdGUoKX1mb3IobGV0IG49dGhpcy5fc2VnVmVydGljZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7dFtlKytdPXMuZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiB0fXNldENvbnN0cmFpbnRzKHQsZSl7dGhpcy5fc2VnbWVudHM9dCx0aGlzLl9zZWdWZXJ0aWNlcz1lfWNvbXB1dGVDb252ZXhIdWxsKCl7Y29uc3QgdD1uZXcgSHQsZT10aGlzLmdldFBvaW50QXJyYXkoKSxuPW5ldyBhbihlLHQpO3RoaXMuX2NvbnZleEh1bGw9bi5nZXRDb252ZXhIdWxsKCl9YWRkQ29uc3RyYWludFZlcnRpY2VzKCl7dGhpcy5jb21wdXRlQ29udmV4SHVsbCgpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5fc2VnVmVydGljZXMpfWZpbmROb25HYWJyaWVsUG9pbnQodCl7Y29uc3QgZT10LmdldFN0YXJ0KCksbj10LmdldEVuZCgpLHM9bmV3IGcoKGUueCtuLngpLzIsKGUueStuLnkpLzIpLHI9ZS5kaXN0YW5jZShzKSxvPW5ldyBOKHMpO28uZXhwYW5kQnkocik7Y29uc3QgbD10aGlzLl9rZHQucXVlcnkobyk7bGV0IGE9bnVsbCxjPWkuTUFYX1ZBTFVFO2ZvcihsZXQgdD1sLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBpPXQubmV4dCgpLmdldENvb3JkaW5hdGUoKTtpZihpLmVxdWFsczJEKGUpfHxpLmVxdWFsczJEKG4pKWNvbnRpbnVlO2NvbnN0IG89cy5kaXN0YW5jZShpKTtpZihvPHIpe2NvbnN0IHQ9bzsobnVsbD09PWF8fHQ8YykmJihhPWksYz10KX19cmV0dXJuIGF9Z2V0Q29uc3RyYWludFNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRzfXNldFNwbGl0UG9pbnRGaW5kZXIodCl7dGhpcy5fc3BsaXRGaW5kZXI9dH1nZXRDb252ZXhIdWxsKCl7cmV0dXJuIHRoaXMuX2NvbnZleEh1bGx9Z2V0VG9sZXJhbmNlKCl7cmV0dXJuIHRoaXMuX3RvbGVyYW5jZX1lbmZvcmNlR2FicmllbCh0KXtjb25zdCBlPW5ldyB4O2xldCBuPTA7Y29uc3Qgcz1uZXcgeDtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKSxyPXRoaXMuZmluZE5vbkdhYnJpZWxQb2ludCh0KTtpZihudWxsPT09ciljb250aW51ZTt0aGlzLl9zcGxpdFB0PXRoaXMuX3NwbGl0RmluZGVyLmZpbmRTcGxpdFBvaW50KHQscik7Y29uc3Qgbz10aGlzLmNyZWF0ZVZlcnRleCh0aGlzLl9zcGxpdFB0LHQpO3RoaXMuaW5zZXJ0U2l0ZShvKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodGhpcy5fc3BsaXRQdCk7Y29uc3QgbD1uZXcgUG8odC5nZXRTdGFydFgoKSx0LmdldFN0YXJ0WSgpLHQuZ2V0U3RhcnRaKCksby5nZXRYKCksby5nZXRZKCksby5nZXRaKCksdC5nZXREYXRhKCkpLGE9bmV3IFBvKG8uZ2V0WCgpLG8uZ2V0WSgpLG8uZ2V0WigpLHQuZ2V0RW5kWCgpLHQuZ2V0RW5kWSgpLHQuZ2V0RW5kWigpLHQuZ2V0RGF0YSgpKTtlLmFkZChsKSxlLmFkZChhKSxzLmFkZCh0KSxuKz0xfXJldHVybiB0LnJlbW92ZUFsbChzKSx0LmFkZEFsbChlKSxufWNyZWF0ZVZlcnRleCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsO3JldHVybiBlPW51bGwhPT10aGlzLl92ZXJ0ZXhGYWN0b3J5P3RoaXMuX3ZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsbnVsbCk6bmV3IG1vKHQpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGw7cmV0dXJuIG49bnVsbCE9PXRoaXMuX3ZlcnRleEZhY3Rvcnk/dGhpcy5fdmVydGV4RmFjdG9yeS5jcmVhdGVWZXJ0ZXgodCxlKTpuZXcgbW8odCksbi5zZXRPbkNvbnN0cmFpbnQoITApLG59fWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuX3N1YmRpdn1jb21wdXRlQm91bmRpbmdCb3goKXtjb25zdCB0PXZvLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLl9pbml0aWFsVmVydGljZXMpLGU9dm8uY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuX3NlZ1ZlcnRpY2VzKSxuPW5ldyBOKHQpO24uZXhwYW5kVG9JbmNsdWRlKGUpO2NvbnN0IHM9LjIqbi5nZXRXaWR0aCgpLGk9LjIqbi5nZXRIZWlnaHQoKSxyPU1hdGgubWF4KHMsaSk7dGhpcy5fY29tcHV0ZUFyZWFFbnY9bmV3IE4obiksdGhpcy5fY29tcHV0ZUFyZWFFbnYuZXhwYW5kQnkocil9c2V0VmVydGV4RmFjdG9yeSh0KXt0aGlzLl92ZXJ0ZXhGYWN0b3J5PXR9Zm9ybUluaXRpYWxEZWxhdW5heSgpe3RoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5fc3ViZGl2PW5ldyBTbyh0aGlzLl9jb21wdXRlQXJlYUVudix0aGlzLl90b2xlcmFuY2UpLHRoaXMuX3N1YmRpdi5zZXRMb2NhdG9yKG5ldyBJbyh0aGlzLl9zdWJkaXYpKSx0aGlzLl9pbmNEZWw9bmV3IHhvKHRoaXMuX3N1YmRpdiksdGhpcy5pbnNlcnRTaXRlcyh0aGlzLl9pbml0aWFsVmVydGljZXMpfWluc2VydFNpdGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1vKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX2tkdC5pbnNlcnQodC5nZXRDb29yZGluYXRlKCksdCk7aWYoZS5pc1JlcGVhdGVkKCkpe2NvbnN0IG49ZS5nZXREYXRhKCk7cmV0dXJuIG4ubWVyZ2UodCksbn1yZXR1cm4gdGhpcy5faW5jRGVsLmluc2VydFNpdGUodCksdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0U2l0ZSh0aGlzLmNyZWF0ZVZlcnRleCh0KSl9fWdldENsYXNzKCl7cmV0dXJuIHZvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12by5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbml0aWFsVmVydGljZXM9bnVsbCx0aGlzLl9zZWdWZXJ0aWNlcz1udWxsLHRoaXMuX3NlZ21lbnRzPW5ldyB4LHRoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2luY0RlbD1udWxsLHRoaXMuX2NvbnZleEh1bGw9bnVsbCx0aGlzLl9zcGxpdEZpbmRlcj1uZXcgX28sdGhpcy5fa2R0PW51bGwsdGhpcy5fdmVydGV4RmFjdG9yeT1udWxsLHRoaXMuX2NvbXB1dGVBcmVhRW52PW51bGwsdGhpcy5fc3BsaXRQdD1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2luaXRpYWxWZXJ0aWNlcz1uZXcgeCh0KSx0aGlzLl90b2xlcmFuY2U9ZSx0aGlzLl9rZHQ9bmV3IGVzKGUpfSx2by5NQVhfU1BMSVRfSVRFUj05OTtjbGFzcyBPb3tjb25zdHJ1Y3Rvcigpe09vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KXtpZihudWxsPT09dClyZXR1cm4gbmV3IEk7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIE9vLnVuaXF1ZShlKX1zdGF0aWMgZW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTjtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZSh0KX1yZXR1cm4gZX1zdGF0aWMgdW5pcXVlKHQpe2NvbnN0IGU9WC5jb3B5RGVlcCh0KTtyZXR1cm4gaHQuc29ydChlKSxuZXcgSShlLCExKX1zdGF0aWMgdG9WZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyBwbyh0KSl9cmV0dXJuIGV9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PU9vLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpLGU9T28udG9WZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKTt0aGlzLl9zdWJkaXY9bmV3IFNvKHQsdGhpcy5fdG9sZXJhbmNlKSxuZXcgeG8odGhpcy5fc3ViZGl2KS5pbnNlcnRTaXRlcyhlKX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0U2l0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9T28uZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9T28udW5pcXVlKFgudG9Db29yZGluYXRlQXJyYXkodCkpfX1nZXRFZGdlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0RWRnZXModCl9Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXZ9Z2V0VHJpYW5nbGVzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRUcmlhbmdsZXModCl9Z2V0Q2xhc3MoKXtyZXR1cm4gT299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU9vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbH07Y2xhc3MgYm97Y29uc3RydWN0b3IoKXtiby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjcmVhdGVDb25zdHJhaW50U2VnbWVudHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT14ZS5nZXRMaW5lcyh0KSxuPW5ldyB4O2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2JvLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyhlLG4pfXJldHVybiBufWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MTt0PG4ubGVuZ3RoO3QrKyllLmFkZChuZXcgUG8oblt0LTFdLG5bdF0pKX19Y3JlYXRlU2l0ZVZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fY29uc3RyYWludFZlcnRleE1hcC5jb250YWluc0tleSh0KXx8ZS5hZGQobmV3IG1vKHQpKX1yZXR1cm4gZX1jcmVhdGUoKXtpZihudWxsIT09dGhpcy5fc3ViZGl2KXJldHVybiBudWxsO2NvbnN0IHQ9T28uZW52ZWxvcGUodGhpcy5fc2l0ZUNvb3Jkcyk7bGV0IGU9bmV3IHg7bnVsbCE9PXRoaXMuX2NvbnN0cmFpbnRMaW5lcyYmKHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2NvbnN0cmFpbnRMaW5lcy5nZXRFbnZlbG9wZUludGVybmFsKCkpLHRoaXMuY3JlYXRlVmVydGljZXModGhpcy5fY29uc3RyYWludExpbmVzKSxlPWJvLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyh0aGlzLl9jb25zdHJhaW50TGluZXMpKTtjb25zdCBuPXRoaXMuY3JlYXRlU2l0ZVZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpLHM9bmV3IHZvKG4sdGhpcy5fdG9sZXJhbmNlKTtzLnNldENvbnN0cmFpbnRzKGUsbmV3IHgodGhpcy5fY29uc3RyYWludFZlcnRleE1hcC52YWx1ZXMoKSkpLHMuZm9ybUluaXRpYWxEZWxhdW5heSgpLHMuZW5mb3JjZUNvbnN0cmFpbnRzKCksdGhpcy5fc3ViZGl2PXMuZ2V0U3ViZGl2aXNpb24oKX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0Q29uc3RyYWludHModCl7dGhpcy5fY29uc3RyYWludExpbmVzPXR9c2V0U2l0ZXModCl7dGhpcy5fc2l0ZUNvb3Jkcz1Pby5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9Z2V0RWRnZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldEVkZ2VzKHQpfWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fWdldFRyaWFuZ2xlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfWNyZWF0ZVZlcnRpY2VzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBuPW5ldyBtbyhlW3RdKTt0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwLnB1dChlW3RdLG4pfX1nZXRDbGFzcygpe3JldHVybiBib31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Ym8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2l0ZUNvb3Jkcz1udWxsLHRoaXMuX2NvbnN0cmFpbnRMaW5lcz1udWxsLHRoaXMuX3RvbGVyYW5jZT0wLHRoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXA9bmV3IHJ0fTtjbGFzcyBNb3tjb25zdHJ1Y3Rvcigpe01vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNsaXBHZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPXQuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkoZSkscz1uZXcgeDtmb3IobGV0IGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7Y29uc3Qgcj10LmdldEdlb21ldHJ5TihpKTtsZXQgbz1udWxsO2UuY29udGFpbnMoci5nZXRFbnZlbG9wZUludGVybmFsKCkpP289cjplLmludGVyc2VjdHMoci5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYobz1uLmludGVyc2VjdGlvbihyKSxvLnNldFVzZXJEYXRhKHIuZ2V0VXNlckRhdGEoKSkpLG51bGw9PT1vfHxvLmlzRW1wdHkoKXx8cy5hZGQobyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihIdC50b0dlb21ldHJ5QXJyYXkocykpfWNyZWF0ZSgpe2lmKG51bGwhPT10aGlzLl9zdWJkaXYpcmV0dXJuIG51bGw7Y29uc3QgdD1Pby5lbnZlbG9wZSh0aGlzLl9zaXRlQ29vcmRzKTt0aGlzLl9kaWFncmFtRW52PXQ7Y29uc3QgZT1NYXRoLm1heCh0aGlzLl9kaWFncmFtRW52LmdldFdpZHRoKCksdGhpcy5fZGlhZ3JhbUVudi5nZXRIZWlnaHQoKSk7dGhpcy5fZGlhZ3JhbUVudi5leHBhbmRCeShlKSxudWxsIT09dGhpcy5fY2xpcEVudiYmdGhpcy5fZGlhZ3JhbUVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5fY2xpcEVudik7Y29uc3Qgbj1Pby50b1ZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpO3RoaXMuX3N1YmRpdj1uZXcgU28odCx0aGlzLl90b2xlcmFuY2UpLG5ldyB4byh0aGlzLl9zdWJkaXYpLmluc2VydFNpdGVzKG4pfWdldERpYWdyYW0odCl7dGhpcy5jcmVhdGUoKTtjb25zdCBlPXRoaXMuX3N1YmRpdi5nZXRWb3Jvbm9pRGlhZ3JhbSh0KTtyZXR1cm4gTW8uY2xpcEdlb21ldHJ5Q29sbGVjdGlvbihlLHRoaXMuX2RpYWdyYW1FbnYpfXNldFRvbGVyYW5jZSh0KXt0aGlzLl90b2xlcmFuY2U9dH1zZXRTaXRlcygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1Pby5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1Pby51bmlxdWUoWC50b0Nvb3JkaW5hdGVBcnJheSh0KSl9fXNldENsaXBFbnZlbG9wZSh0KXt0aGlzLl9jbGlwRW52PXR9Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXZ9Z2V0Q2xhc3MoKXtyZXR1cm4gTW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU1vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9jbGlwRW52PW51bGwsdGhpcy5fZGlhZ3JhbUVudj1udWxsfTt2YXIgRG89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsVmVydGV4OnBvfSksQW89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29uZm9ybWluZ0RlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6Ym8sRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjpPbyxWb3Jvbm9pRGlhZ3JhbUJ1aWxkZXI6TW8scXVhZGVkZ2U6RG99KTtjbGFzcyBGb3tjb25zdHJ1Y3Rvcigpe0ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldEVuZExvY2F0aW9uKHQpe2NvbnN0IGU9bmV3IEZvO3JldHVybiBlLnNldFRvRW5kKHQpLGV9c3RhdGljIHBvaW50QWxvbmdTZWdtZW50QnlGcmFjdGlvbih0LGUsbil7aWYobjw9MClyZXR1cm4gdDtpZihuPj0xKXJldHVybiBlO2NvbnN0IHM9KGUueC10LngpKm4rdC54LGk9KGUueS10LnkpKm4rdC55LHI9KGUuei10LnopKm4rdC56O3JldHVybiBuZXcgZyhzLGkscil9c3RhdGljIGNvbXBhcmVMb2NhdGlvblZhbHVlcyh0LGUsbixzLGkscil7cmV0dXJuIHQ8cz8tMTp0PnM/MTplPGk/LTE6ZT5pPzE6bjxyPy0xOm4+cj8xOjB9Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleH1nZXRDb21wb25lbnRJbmRleCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleH1pc0VuZHBvaW50KHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLmdldE51bVBvaW50cygpLTE7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleD49ZXx8dGhpcy5fc2VnbWVudEluZGV4PT09ZSYmdGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xfWlzVmFsaWQodCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg8MHx8dGhpcy5fY29tcG9uZW50SW5kZXg+PXQuZ2V0TnVtR2VvbWV0cmllcygpKXJldHVybiExO2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3JldHVybiEodGhpcy5fc2VnbWVudEluZGV4PDB8fHRoaXMuX3NlZ21lbnRJbmRleD5lLmdldE51bVBvaW50cygpKSYmKCh0aGlzLl9zZWdtZW50SW5kZXghPT1lLmdldE51bVBvaW50cygpfHwwPT09dGhpcy5fc2VnbWVudEZyYWN0aW9uKSYmISh0aGlzLl9zZWdtZW50RnJhY3Rpb248MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPjEpKX1ub3JtYWxpemUoKXt0aGlzLl9zZWdtZW50RnJhY3Rpb248MCYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSx0aGlzLl9zZWdtZW50RnJhY3Rpb24+MSYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xKSx0aGlzLl9jb21wb25lbnRJbmRleDwwJiYodGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksdGhpcy5fc2VnbWVudEluZGV4PDAmJih0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksMT09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbiYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wLHRoaXMuX3NlZ21lbnRJbmRleCs9MSl9dG9Mb3dlc3QodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCkuZ2V0TnVtUG9pbnRzKCktMTtyZXR1cm4gdGhpcy5fc2VnbWVudEluZGV4PGU/dGhpczpuZXcgRm8odGhpcy5fY29tcG9uZW50SW5kZXgsZSwxLCExKX1nZXRDb29yZGluYXRlKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLG49ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgpO2lmKHRoaXMuX3NlZ21lbnRJbmRleD49ZS5nZXROdW1Qb2ludHMoKS0xKXJldHVybiBuO2NvbnN0IHM9ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgrMSk7cmV0dXJuIEZvLnBvaW50QWxvbmdTZWdtZW50QnlGcmFjdGlvbihuLHMsdGhpcy5fc2VnbWVudEZyYWN0aW9uKX1nZXRTZWdtZW50RnJhY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2VnbWVudEZyYWN0aW9ufWdldFNlZ21lbnQodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCk7aWYodGhpcy5fc2VnbWVudEluZGV4Pj1lLmdldE51bVBvaW50cygpLTEpe2NvbnN0IHQ9ZS5nZXRDb29yZGluYXRlTihlLmdldE51bVBvaW50cygpLTIpO3JldHVybiBuZXcgZWUodCxuKX1jb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KzEpO3JldHVybiBuZXcgZWUobixzKX1jbGFtcCh0KXtpZih0aGlzLl9jb21wb25lbnRJbmRleD49dC5nZXROdW1HZW9tZXRyaWVzKCkpcmV0dXJuIHRoaXMuc2V0VG9FbmQodCksbnVsbDtpZih0aGlzLl9zZWdtZW50SW5kZXg+PXQuZ2V0TnVtUG9pbnRzKCkpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3RoaXMuX3NlZ21lbnRJbmRleD1lLmdldE51bVBvaW50cygpLTEsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTF9fXNldFRvRW5kKHQpe3RoaXMuX2NvbXBvbmVudEluZGV4PXQuZ2V0TnVtR2VvbWV0cmllcygpLTE7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7dGhpcy5fc2VnbWVudEluZGV4PWUuZ2V0TnVtUG9pbnRzKCktMSx0aGlzLl9zZWdtZW50RnJhY3Rpb249MX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleDxlLl9jb21wb25lbnRJbmRleD8tMTp0aGlzLl9jb21wb25lbnRJbmRleD5lLl9jb21wb25lbnRJbmRleD8xOnRoaXMuX3NlZ21lbnRJbmRleDxlLl9zZWdtZW50SW5kZXg/LTE6dGhpcy5fc2VnbWVudEluZGV4PmUuX3NlZ21lbnRJbmRleD8xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbjxlLl9zZWdtZW50RnJhY3Rpb24/LTE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPmUuX3NlZ21lbnRGcmFjdGlvbj8xOjB9Y29weSgpe3JldHVybiBuZXcgRm8odGhpcy5fY29tcG9uZW50SW5kZXgsdGhpcy5fc2VnbWVudEluZGV4LHRoaXMuX3NlZ21lbnRGcmFjdGlvbil9dG9TdHJpbmcoKXtyZXR1cm5cIkxpbmVhckxvY1tcIit0aGlzLl9jb21wb25lbnRJbmRleCtcIiwgXCIrdGhpcy5fc2VnbWVudEluZGV4K1wiLCBcIit0aGlzLl9zZWdtZW50RnJhY3Rpb24rXCJdXCJ9aXNPblNhbWVTZWdtZW50KHQpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleD09PXQuX2NvbXBvbmVudEluZGV4JiYodGhpcy5fc2VnbWVudEluZGV4PT09dC5fc2VnbWVudEluZGV4fHwodC5fc2VnbWVudEluZGV4LXRoaXMuX3NlZ21lbnRJbmRleD09MSYmMD09PXQuX3NlZ21lbnRGcmFjdGlvbnx8dGhpcy5fc2VnbWVudEluZGV4LXQuX3NlZ21lbnRJbmRleD09MSYmMD09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbikpfXNuYXBUb1ZlcnRleCh0LGUpe2lmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbjw9MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xKXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5nZXRTZWdtZW50TGVuZ3RoKHQpLHM9dGhpcy5fc2VnbWVudEZyYWN0aW9uKm4saT1uLXM7czw9aSYmczxlP3RoaXMuX3NlZ21lbnRGcmFjdGlvbj0wOmk8PXMmJmk8ZSYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xKX1jb21wYXJlTG9jYXRpb25WYWx1ZXModCxlLG4pe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleDx0Py0xOnRoaXMuX2NvbXBvbmVudEluZGV4PnQ/MTp0aGlzLl9zZWdtZW50SW5kZXg8ZT8tMTp0aGlzLl9zZWdtZW50SW5kZXg+ZT8xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbjxuPy0xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbj5uPzE6MH1nZXRTZWdtZW50TGVuZ3RoKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO2xldCBuPXRoaXMuX3NlZ21lbnRJbmRleDt0aGlzLl9zZWdtZW50SW5kZXg+PWUuZ2V0TnVtUG9pbnRzKCktMSYmKG49ZS5nZXROdW1Qb2ludHMoKS0yKTtjb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4obiksaT1lLmdldENvb3JkaW5hdGVOKG4rMSk7cmV0dXJuIHMuZGlzdGFuY2UoaSl9aXNWZXJ0ZXgoKXtyZXR1cm4gdGhpcy5fc2VnbWVudEZyYWN0aW9uPD0wfHx0aGlzLl9zZWdtZW50RnJhY3Rpb24+PTF9Z2V0Q2xhc3MoKXtyZXR1cm4gRm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Gby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9jb21wb25lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wb25lbnRJbmRleD10Ll9jb21wb25lbnRJbmRleCx0aGlzLl9zZWdtZW50SW5kZXg9dC5fc2VnbWVudEluZGV4LHRoaXMuX3NlZ21lbnRGcmFjdGlvbj10Ll9zZWdtZW50RnJhY3Rpb259ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Rm8uY29uc3RydWN0b3JfLmNhbGwodGhpcywwLHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fY29tcG9uZW50SW5kZXg9dCx0aGlzLl9zZWdtZW50SW5kZXg9ZSx0aGlzLl9zZWdtZW50RnJhY3Rpb249bix0aGlzLm5vcm1hbGl6ZSgpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX2NvbXBvbmVudEluZGV4PXQsdGhpcy5fc2VnbWVudEluZGV4PWUsdGhpcy5fc2VnbWVudEZyYWN0aW9uPW4scyYmdGhpcy5ub3JtYWxpemUoKX19O2NsYXNzIEdve2NvbnN0cnVjdG9yKCl7R28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2VnbWVudEVuZFZlcnRleEluZGV4KHQpe3JldHVybiB0LmdldFNlZ21lbnRGcmFjdGlvbigpPjA/dC5nZXRTZWdtZW50SW5kZXgoKSsxOnQuZ2V0U2VnbWVudEluZGV4KCl9Z2V0Q29tcG9uZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXh9Z2V0TGluZSgpe3JldHVybiB0aGlzLl9jdXJyZW50TGluZX1nZXRWZXJ0ZXhJbmRleCgpe3JldHVybiB0aGlzLl92ZXJ0ZXhJbmRleH1nZXRTZWdtZW50RW5kKCl7cmV0dXJuIHRoaXMuX3ZlcnRleEluZGV4PHRoaXMuZ2V0TGluZSgpLmdldE51bVBvaW50cygpLTE/dGhpcy5fY3VycmVudExpbmUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fdmVydGV4SW5kZXgrMSk6bnVsbH1uZXh0KCl7aWYoIXRoaXMuaGFzTmV4dCgpKXJldHVybiBudWxsO3RoaXMuX3ZlcnRleEluZGV4KyssdGhpcy5fdmVydGV4SW5kZXg+PXRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpJiYodGhpcy5fY29tcG9uZW50SW5kZXgrKyx0aGlzLmxvYWRDdXJyZW50TGluZSgpLHRoaXMuX3ZlcnRleEluZGV4PTApfWxvYWRDdXJyZW50TGluZSgpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcylyZXR1cm4gdGhpcy5fY3VycmVudExpbmU9bnVsbCxudWxsO3RoaXMuX2N1cnJlbnRMaW5lPXRoaXMuX2xpbmVhckdlb20uZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KX1nZXRTZWdtZW50U3RhcnQoKXtyZXR1cm4gdGhpcy5fY3VycmVudExpbmUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fdmVydGV4SW5kZXgpfWlzRW5kT2ZMaW5lKCl7cmV0dXJuISh0aGlzLl9jb21wb25lbnRJbmRleD49dGhpcy5fbnVtTGluZXMpJiYhKHRoaXMuX3ZlcnRleEluZGV4PHRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpLTEpfWhhc05leHQoKXtyZXR1cm4hKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcykmJiEodGhpcy5fY29tcG9uZW50SW5kZXg9PT10aGlzLl9udW1MaW5lcy0xJiZ0aGlzLl92ZXJ0ZXhJbmRleD49dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCkpfWdldENsYXNzKCl7cmV0dXJuIEdvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Hby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9saW5lYXJHZW9tPW51bGwsdGhpcy5fbnVtTGluZXM9bnVsbCx0aGlzLl9jdXJyZW50TGluZT1udWxsLHRoaXMuX2NvbXBvbmVudEluZGV4PTAsdGhpcy5fdmVydGV4SW5kZXg9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07R28uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDAsMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07R28uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUuZ2V0Q29tcG9uZW50SW5kZXgoKSxHby5zZWdtZW50RW5kVmVydGV4SW5kZXgoZSkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO2lmKCFfKHQsb3QpKXRocm93IG5ldyBuKFwiTGluZWFsIGdlb21ldHJ5IGlzIHJlcXVpcmVkXCIpO3RoaXMuX2xpbmVhckdlb209dCx0aGlzLl9udW1MaW5lcz10LmdldE51bUdlb21ldHJpZXMoKSx0aGlzLl9jb21wb25lbnRJbmRleD1lLHRoaXMuX3ZlcnRleEluZGV4PXMsdGhpcy5sb2FkQ3VycmVudExpbmUoKX19O2NsYXNzIHFve2NvbnN0cnVjdG9yKCl7cW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW5kZXhPZih0LGUpe3JldHVybiBuZXcgcW8odCkuaW5kZXhPZihlKX1zdGF0aWMgaW5kZXhPZkFmdGVyKHQsZSxuKXtyZXR1cm4gbmV3IHFvKHQpLmluZGV4T2ZBZnRlcihlLG4pfWluZGV4T2YodCl7cmV0dXJuIHRoaXMuaW5kZXhPZkZyb21TdGFydCh0LG51bGwpfWluZGV4T2ZGcm9tU3RhcnQodCxlKXtsZXQgbj1pLk1BWF9WQUxVRSxzPTAscj0wLG89LTE7Y29uc3QgbD1uZXcgZWU7Zm9yKGxldCBpPW5ldyBHbyh0aGlzLl9saW5lYXJHZW9tKTtpLmhhc05leHQoKTtpLm5leHQoKSlpZighaS5pc0VuZE9mTGluZSgpKXtsLnAwPWkuZ2V0U2VnbWVudFN0YXJ0KCksbC5wMT1pLmdldFNlZ21lbnRFbmQoKTtjb25zdCBhPWwuZGlzdGFuY2UodCksYz1sLnNlZ21lbnRGcmFjdGlvbih0KSxoPWkuZ2V0Q29tcG9uZW50SW5kZXgoKSx1PWkuZ2V0VmVydGV4SW5kZXgoKTthPG4mJihudWxsPT09ZXx8ZS5jb21wYXJlTG9jYXRpb25WYWx1ZXMoaCx1LGMpPDApJiYocz1oLHI9dSxvPWMsbj1hKX1yZXR1cm4gbj09PWkuTUFYX1ZBTFVFP25ldyBGbyhlKTpuZXcgRm8ocyxyLG8pfWluZGV4T2ZBZnRlcih0LGUpe2lmKG51bGw9PT1lKXJldHVybiB0aGlzLmluZGV4T2YodCk7Y29uc3Qgbj1Gby5nZXRFbmRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tKTtpZihuLmNvbXBhcmVUbyhlKTw9MClyZXR1cm4gbjtjb25zdCBzPXRoaXMuaW5kZXhPZkZyb21TdGFydCh0LGUpO3JldHVybiB1LmlzVHJ1ZShzLmNvbXBhcmVUbyhlKT49MCxcImNvbXB1dGVkIGxvY2F0aW9uIGlzIGJlZm9yZSBzcGVjaWZpZWQgbWluaW11bSBsb2NhdGlvblwiKSxzfWdldENsYXNzKCl7cmV0dXJuIHFvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1xby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fTtjbGFzcyBCb3tjb25zdHJ1Y3Rvcigpe0JvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGluZGljZXNPZih0LGUpe3JldHVybiBuZXcgQm8odCkuaW5kaWNlc09mKGUpfWluZGljZXNPZih0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKDApLmdldENvb3JkaW5hdGVOKDApLG49dC5nZXRHZW9tZXRyeU4odC5nZXROdW1HZW9tZXRyaWVzKCktMSkscz1uLmdldENvb3JkaW5hdGVOKG4uZ2V0TnVtUG9pbnRzKCktMSksaT1uZXcgcW8odGhpcy5fbGluZWFyR2VvbSkscj1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtyZXR1cm4gclswXT1pLmluZGV4T2YoZSksMD09PXQuZ2V0TGVuZ3RoKCk/clsxXT1yWzBdLmNvcHkoKTpyWzFdPWkuaW5kZXhPZkFmdGVyKHMsclswXSkscn1nZXRDbGFzcygpe3JldHVybiBCb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Qm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH07Y2xhc3MgVm97Y29uc3RydWN0b3IoKXtWby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuZW5kTGluZSgpLHRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5fbGluZXMpfWdldExhc3RDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2xhc3RQdH1lbmRMaW5lKCl7aWYobnVsbD09PXRoaXMuX2Nvb3JkTGlzdClyZXR1cm4gbnVsbDtpZih0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXMmJnRoaXMuX2Nvb3JkTGlzdC5zaXplKCk8MilyZXR1cm4gdGhpcy5fY29vcmRMaXN0PW51bGwsbnVsbDtjb25zdCB0PXRoaXMuX2Nvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBlPXQ7dGhpcy5fZml4SW52YWxpZExpbmVzJiYoZT10aGlzLnZhbGlkQ29vcmRpbmF0ZVNlcXVlbmNlKHQpKSx0aGlzLl9jb29yZExpc3Q9bnVsbDtsZXQgcz1udWxsO3RyeXtzPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVTdHJpbmcoZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbikpdGhyb3cgdDtpZighdGhpcy5faWdub3JlSW52YWxpZExpbmVzKXRocm93IHR9bnVsbCE9PXMmJnRoaXMuX2xpbmVzLmFkZChzKX1zZXRGaXhJbnZhbGlkTGluZXModCl7dGhpcy5fZml4SW52YWxpZExpbmVzPXR9YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHQsITApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO251bGw9PT10aGlzLl9jb29yZExpc3QmJih0aGlzLl9jb29yZExpc3Q9bmV3IEkpLHRoaXMuX2Nvb3JkTGlzdC5hZGQodCxlKSx0aGlzLl9sYXN0UHQ9dH19c2V0SWdub3JlSW52YWxpZExpbmVzKHQpe3RoaXMuX2lnbm9yZUludmFsaWRMaW5lcz10fXZhbGlkQ29vcmRpbmF0ZVNlcXVlbmNlKHQpe2lmKHQubGVuZ3RoPj0yKXJldHVybiB0O3JldHVyblt0WzBdLHRbMF1dfWdldENsYXNzKCl7cmV0dXJuIFZvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Wby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX2xpbmVzPW5ldyB4LHRoaXMuX2Nvb3JkTGlzdD1udWxsLHRoaXMuX2lnbm9yZUludmFsaWRMaW5lcz0hMSx0aGlzLl9maXhJbnZhbGlkTGluZXM9ITEsdGhpcy5fbGFzdFB0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Q9dH07Y2xhc3Mgem97Y29uc3RydWN0b3IoKXt6by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBleHRyYWN0KHQsZSxuKXtyZXR1cm4gbmV3IHpvKHQpLmV4dHJhY3QoZSxuKX1jb21wdXRlTGluZWFyKHQsZSl7Y29uc3Qgbj1uZXcgVm8odGhpcy5fbGluZS5nZXRGYWN0b3J5KCkpO24uc2V0Rml4SW52YWxpZExpbmVzKCEwKSx0LmlzVmVydGV4KCl8fG4uYWRkKHQuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSk7Zm9yKGxldCBzPW5ldyBHbyh0aGlzLl9saW5lLHQpO3MuaGFzTmV4dCgpJiYhKGUuY29tcGFyZUxvY2F0aW9uVmFsdWVzKHMuZ2V0Q29tcG9uZW50SW5kZXgoKSxzLmdldFZlcnRleEluZGV4KCksMCk8MCk7cy5uZXh0KCkpe2NvbnN0IHQ9cy5nZXRTZWdtZW50U3RhcnQoKTtuLmFkZCh0KSxzLmlzRW5kT2ZMaW5lKCkmJm4uZW5kTGluZSgpfXJldHVybiBlLmlzVmVydGV4KCl8fG4uYWRkKGUuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSksbi5nZXRHZW9tZXRyeSgpfWNvbXB1dGVMaW5lKHQsZSl7Y29uc3Qgbj10aGlzLl9saW5lLmdldENvb3JkaW5hdGVzKCkscz1uZXcgSTtsZXQgaT10LmdldFNlZ21lbnRJbmRleCgpO3QuZ2V0U2VnbWVudEZyYWN0aW9uKCk+MCYmKGkrPTEpO2xldCByPWUuZ2V0U2VnbWVudEluZGV4KCk7MT09PWUuZ2V0U2VnbWVudEZyYWN0aW9uKCkmJihyKz0xKSxyPj1uLmxlbmd0aCYmKHI9bi5sZW5ndGgtMSksdC5pc1ZlcnRleCgpfHxzLmFkZCh0LmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpO2ZvcihsZXQgdD1pO3Q8PXI7dCsrKXMuYWRkKG5bdF0pO2UuaXNWZXJ0ZXgoKXx8cy5hZGQoZS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKSxzLnNpemUoKTw9MCYmcy5hZGQodC5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKTtsZXQgbz1zLnRvQ29vcmRpbmF0ZUFycmF5KCk7cmV0dXJuIG8ubGVuZ3RoPD0xJiYobz1bb1swXSxvWzBdXSksdGhpcy5fbGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhvKX1leHRyYWN0KHQsZSl7cmV0dXJuIGUuY29tcGFyZVRvKHQpPDA/dGhpcy5yZXZlcnNlKHRoaXMuY29tcHV0ZUxpbmVhcihlLHQpKTp0aGlzLmNvbXB1dGVMaW5lYXIodCxlKX1yZXZlcnNlKHQpe3JldHVybiB0IGluc3RhbmNlb2YgVHR8fHQgaW5zdGFuY2VvZiBmdD90LnJldmVyc2UoKToodS5zaG91bGROZXZlclJlYWNoSGVyZShcIm5vbi1saW5lYXIgZ2VvbWV0cnkgZW5jb3VudGVyZWRcIiksbnVsbCl9Z2V0Q2xhc3MoKXtyZXR1cm4gem99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXpvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lPXR9O2NsYXNzIFlve2NvbnN0cnVjdG9yKCl7WW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbGFtcEluZGV4KHQpe2NvbnN0IGU9dC5jb3B5KCk7cmV0dXJuIGUuY2xhbXAodGhpcy5fbGluZWFyR2VvbSksZX1wcm9qZWN0KHQpe3JldHVybiBxby5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9Y2hlY2tHZW9tZXRyeVR5cGUoKXtpZighKHRoaXMuX2xpbmVhckdlb20gaW5zdGFuY2VvZiBUdHx8dGhpcy5fbGluZWFyR2VvbSBpbnN0YW5jZW9mIGZ0KSl0aHJvdyBuZXcgbihcIklucHV0IGdlb21ldHJ5IG11c3QgYmUgbGluZWFyXCIpfWV4dHJhY3RQb2ludCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gYXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGUodGhpcy5fbGluZWFyR2VvbSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC50b0xvd2VzdCh0aGlzLl9saW5lYXJHZW9tKTtyZXR1cm4gbi5nZXRTZWdtZW50KHRoaXMuX2xpbmVhckdlb20pLnBvaW50QWxvbmdPZmZzZXQobi5nZXRTZWdtZW50RnJhY3Rpb24oKSxlKX19aXNWYWxpZEluZGV4KHQpe3JldHVybiB0LmlzVmFsaWQodGhpcy5fbGluZWFyR2VvbSl9Z2V0RW5kSW5kZXgoKXtyZXR1cm4gRm8uZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSl9Z2V0U3RhcnRJbmRleCgpe3JldHVybiBuZXcgRm99aW5kZXhPZkFmdGVyKHQsZSl7cmV0dXJuIHFvLmluZGV4T2ZBZnRlcih0aGlzLl9saW5lYXJHZW9tLHQsZSl9ZXh0cmFjdExpbmUodCxlKXtyZXR1cm4gem8uZXh0cmFjdCh0aGlzLl9saW5lYXJHZW9tLHQsZSl9aW5kZXhPZih0KXtyZXR1cm4gcW8uaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfWluZGljZXNPZih0KXtyZXR1cm4gQm8uaW5kaWNlc09mKHRoaXMuX2xpbmVhckdlb20sdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gWW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVlvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXQsdGhpcy5jaGVja0dlb21ldHJ5VHlwZSgpfTtjbGFzcyBVb3tjb25zdHJ1Y3Rvcigpe1VvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGluZGV4T2YodCxlKXtyZXR1cm4gbmV3IFVvKHQpLmluZGV4T2YoZSl9c3RhdGljIGluZGV4T2ZBZnRlcih0LGUsbil7cmV0dXJuIG5ldyBVbyh0KS5pbmRleE9mQWZ0ZXIoZSxuKX1pbmRleE9mKHQpe3JldHVybiB0aGlzLmluZGV4T2ZGcm9tU3RhcnQodCwtMSl9aW5kZXhPZkZyb21TdGFydCh0LGUpe2xldCBuPWkuTUFYX1ZBTFVFLHM9ZSxyPTA7Y29uc3Qgbz1uZXcgZWUsbD1uZXcgR28odGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtsLmhhc05leHQoKTspe2lmKCFsLmlzRW5kT2ZMaW5lKCkpe28ucDA9bC5nZXRTZWdtZW50U3RhcnQoKSxvLnAxPWwuZ2V0U2VnbWVudEVuZCgpO2NvbnN0IGk9by5kaXN0YW5jZSh0KSxhPXRoaXMuc2VnbWVudE5lYXJlc3RNZWFzdXJlKG8sdCxyKTtpPG4mJmE+ZSYmKHM9YSxuPWkpLHIrPW8uZ2V0TGVuZ3RoKCl9bC5uZXh0KCl9cmV0dXJuIHN9aW5kZXhPZkFmdGVyKHQsZSl7aWYoZTwwKXJldHVybiB0aGlzLmluZGV4T2YodCk7Y29uc3Qgbj10aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpO2lmKG48ZSlyZXR1cm4gbjtjb25zdCBzPXRoaXMuaW5kZXhPZkZyb21TdGFydCh0LGUpO3JldHVybiB1LmlzVHJ1ZShzPj1lLFwiY29tcHV0ZWQgaW5kZXggaXMgYmVmb3JlIHNwZWNpZmllZCBtaW5pbXVtIGluZGV4XCIpLHN9c2VnbWVudE5lYXJlc3RNZWFzdXJlKHQsZSxuKXtjb25zdCBzPXQucHJvamVjdGlvbkZhY3RvcihlKTtyZXR1cm4gczw9MD9uOnM8PTE/bitzKnQuZ2V0TGVuZ3RoKCk6bit0LmdldExlbmd0aCgpfWdldENsYXNzKCl7cmV0dXJuIFVvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Vby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fTtjbGFzcyBrb3tjb25zdHJ1Y3Rvcigpe2tvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldExlbmd0aCh0LGUpe3JldHVybiBuZXcga28odCkuZ2V0TGVuZ3RoKGUpfXN0YXRpYyBnZXRMb2NhdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IGtvKHQpLmdldExvY2F0aW9uKGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbmV3IGtvKHQpLmdldExvY2F0aW9uKGUsbil9fWdldExlbmd0aCh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IEdvKHRoaXMuX2xpbmVhckdlb20pO2Zvcig7bi5oYXNOZXh0KCk7KXtpZighbi5pc0VuZE9mTGluZSgpKXtjb25zdCBzPW4uZ2V0U2VnbWVudFN0YXJ0KCksaT1uLmdldFNlZ21lbnRFbmQoKS5kaXN0YW5jZShzKTtpZih0LmdldENvbXBvbmVudEluZGV4KCk9PT1uLmdldENvbXBvbmVudEluZGV4KCkmJnQuZ2V0U2VnbWVudEluZGV4KCk9PT1uLmdldFZlcnRleEluZGV4KCkpcmV0dXJuIGUraSp0LmdldFNlZ21lbnRGcmFjdGlvbigpO2UrPWl9bi5uZXh0KCl9cmV0dXJuIGV9cmVzb2x2ZUhpZ2hlcih0KXtpZighdC5pc0VuZHBvaW50KHRoaXMuX2xpbmVhckdlb20pKXJldHVybiB0O2xldCBlPXQuZ2V0Q29tcG9uZW50SW5kZXgoKTtpZihlPj10aGlzLl9saW5lYXJHZW9tLmdldE51bUdlb21ldHJpZXMoKS0xKXJldHVybiB0O2Rve2UrK313aGlsZShlPHRoaXMuX2xpbmVhckdlb20uZ2V0TnVtR2VvbWV0cmllcygpLTEmJjA9PT10aGlzLl9saW5lYXJHZW9tLmdldEdlb21ldHJ5TihlKS5nZXRMZW5ndGgoKSk7cmV0dXJuIG5ldyBGbyhlLDAsMCl9Z2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24odCwhMCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPXQ7aWYodDwwKXtuPXRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCkrdH1jb25zdCBzPXRoaXMuZ2V0TG9jYXRpb25Gb3J3YXJkKG4pO3JldHVybiBlP3M6dGhpcy5yZXNvbHZlSGlnaGVyKHMpfX1nZXRMb2NhdGlvbkZvcndhcmQodCl7aWYodDw9MClyZXR1cm4gbmV3IEZvO2xldCBlPTA7Y29uc3Qgbj1uZXcgR28odGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtuLmhhc05leHQoKTspe2lmKG4uaXNFbmRPZkxpbmUoKSl7aWYoZT09PXQpe2NvbnN0IHQ9bi5nZXRDb21wb25lbnRJbmRleCgpLGU9bi5nZXRWZXJ0ZXhJbmRleCgpO3JldHVybiBuZXcgRm8odCxlLDApfX1lbHNle2NvbnN0IHM9bi5nZXRTZWdtZW50U3RhcnQoKSxpPW4uZ2V0U2VnbWVudEVuZCgpLmRpc3RhbmNlKHMpO2lmKGUraT50KXtjb25zdCBzPSh0LWUpL2kscj1uLmdldENvbXBvbmVudEluZGV4KCksbz1uLmdldFZlcnRleEluZGV4KCk7cmV0dXJuIG5ldyBGbyhyLG8scyl9ZSs9aX1uLm5leHQoKX1yZXR1cm4gRm8uZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSl9Z2V0Q2xhc3MoKXtyZXR1cm4ga299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWtvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9O2NsYXNzIFhve2NvbnN0cnVjdG9yKCl7WG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbGFtcEluZGV4KHQpe2NvbnN0IGU9dGhpcy5wb3NpdGl2ZUluZGV4KHQpLG49dGhpcy5nZXRTdGFydEluZGV4KCk7aWYoZTxuKXJldHVybiBuO2NvbnN0IHM9dGhpcy5nZXRFbmRJbmRleCgpO3JldHVybiBlPnM/czplfWxvY2F0aW9uT2YoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGtvLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBrby5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQsZSl9fXByb2plY3QodCl7cmV0dXJuIFVvLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1wb3NpdGl2ZUluZGV4KHQpe3JldHVybiB0Pj0wP3Q6dGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKSt0fWV4dHJhY3RQb2ludCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4ga28uZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmVhckdlb20pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWtvLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCkudG9Mb3dlc3QodGhpcy5fbGluZWFyR2VvbSk7cmV0dXJuIG4uZ2V0U2VnbWVudCh0aGlzLl9saW5lYXJHZW9tKS5wb2ludEFsb25nT2Zmc2V0KG4uZ2V0U2VnbWVudEZyYWN0aW9uKCksZSl9fWlzVmFsaWRJbmRleCh0KXtyZXR1cm4gdD49dGhpcy5nZXRTdGFydEluZGV4KCkmJnQ8PXRoaXMuZ2V0RW5kSW5kZXgoKX1nZXRFbmRJbmRleCgpe3JldHVybiB0aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gMH1pbmRleE9mQWZ0ZXIodCxlKXtyZXR1cm4gVW8uaW5kZXhPZkFmdGVyKHRoaXMuX2xpbmVhckdlb20sdCxlKX1leHRyYWN0TGluZSh0LGUpe25ldyBZbyh0aGlzLl9saW5lYXJHZW9tKTtjb25zdCBuPXRoaXMuY2xhbXBJbmRleCh0KSxzPXRoaXMuY2xhbXBJbmRleChlKSxpPW49PT1zLHI9dGhpcy5sb2NhdGlvbk9mKG4saSksbz10aGlzLmxvY2F0aW9uT2Yocyk7cmV0dXJuIHpvLmV4dHJhY3QodGhpcy5fbGluZWFyR2VvbSxyLG8pfWluZGV4T2YodCl7cmV0dXJuIFVvLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1pbmRpY2VzT2YodCl7Y29uc3QgZT1Cby5pbmRpY2VzT2YodGhpcy5fbGluZWFyR2VvbSx0KTtyZXR1cm5ba28uZ2V0TGVuZ3RoKHRoaXMuX2xpbmVhckdlb20sZVswXSksa28uZ2V0TGVuZ3RoKHRoaXMuX2xpbmVhckdlb20sZVsxXSldfWdldENsYXNzKCl7cmV0dXJuIFhvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Yby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fTt2YXIgSG89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTGVuZ3RoSW5kZXhlZExpbmU6WG8sTGVuZ3RoTG9jYXRpb25NYXA6a28sTGluZWFyR2VvbWV0cnlCdWlsZGVyOlZvLExpbmVhckl0ZXJhdG9yOkdvLExpbmVhckxvY2F0aW9uOkZvLExvY2F0aW9uSW5kZXhlZExpbmU6WW99KTtjbGFzcyBXb3tjb25zdHJ1Y3Rvcigpe1dvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRyYW5zZm9ybSh0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspbi5hZGQoZS5leGVjdXRlKHMubmV4dCgpKSk7cmV0dXJuIG59c3RhdGljIHNlbGVjdCh0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7Qm9vbGVhbi5UUlVFLmVxdWFscyhlLmV4ZWN1dGUodCkpJiZuLmFkZCh0KX1yZXR1cm4gbn1zdGF0aWMgYXBwbHkodCxlKXtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLmV4ZWN1dGUobi5uZXh0KCkpfWdldENsYXNzKCl7cmV0dXJuIFdvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Xby5GdW5jdGlvbj1mdW5jdGlvbigpe30sV28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBqb3tjb25zdHJ1Y3Rvcigpe2pvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe3RoaXMucHRzW3RoaXMubisrXT10fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfWdldENsYXNzKCl7cmV0dXJuIGpvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltCXX19am8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5wdHM9bnVsbCx0aGlzLm49MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnB0cz1uZXcgQXJyYXkodCkuZmlsbChudWxsKX07Y2xhc3MgS297Y29uc3RydWN0b3IoKXtLby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt0aGlzLl9uKyt9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5fbn1nZXRDbGFzcygpe3JldHVybiBLb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQl19fUtvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX249MH07Y2xhc3MgWm97Y29uc3RydWN0b3IoKXtaby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvdW50KHQpe2NvbnN0IGU9dGhpcy5fY291bnRzLmdldCh0KTtyZXR1cm4gbnVsbD09PWU/MDplLmNvdW50KCl9YWRkKHQpe2NvbnN0IGU9dGhpcy5fY291bnRzLmdldCh0KTtudWxsPT09ZT90aGlzLl9jb3VudHMucHV0KHQsbmV3IFFvKDEpKTplLmluY3JlbWVudCgpfWdldENsYXNzKCl7cmV0dXJuIFpvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBRb3tjb25zdHJ1Y3Rvcigpe1FvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y291bnQoKXtyZXR1cm4gdGhpcy5jb3VudH1pbmNyZW1lbnQoKXt0aGlzLmNvdW50Kyt9Z2V0Q2xhc3MoKXtyZXR1cm4gUW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVFvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuY291bnQ9MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jb3VudD10fX0sWm8uQ291bnRlcj1Rbyxaby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb3VudHM9bmV3IFV0fTt2YXIgSm89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29sbGVjdGlvblV0aWw6V28sQ29vcmRpbmF0ZUFycmF5RmlsdGVyOmpvLENvb3JkaW5hdGVDb3VudEZpbHRlcjpLbyxHZW9tZXRyaWNTaGFwZUZhY3Rvcnk6U2UsTnVtYmVyVXRpbDplLE9iamVjdENvdW50ZXI6Wm8sUHJpb3JpdHlRdWV1ZTpmcyxTdHJpbmdVdGlsOlN0LFVuaXF1ZUNvb3JkaW5hdGVBcnJheUZpbHRlcjpsbn0pO2NsYXNzICRve2dldCBpbnRlcmZhY2VzXygpe3JldHVybltdfWdldENsYXNzKCl7cmV0dXJuICRvfXN0YXRpYyB1bmlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiBjci5jcmVhdGVFbXB0eVJlc3VsdChjci5VTklPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9cmV0dXJuIHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxsci5vdmVybGF5T3AodCxlLGNyLlVOSU9OKX19cS5wcm90b3R5cGUuZXF1YWxzVG9wbz1mdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmVxdWFscyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJkdyLnJlbGF0ZSh0aGlzLHQpLmlzRXF1YWxzKHRoaXMuZ2V0RGltZW5zaW9uKCksdC5nZXREaW1lbnNpb24oKSl9LHEucHJvdG90eXBlLnVuaW9uPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHpyLnVuaW9uKHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gJG8udW5pb24odGhpcyx0KX19LHEucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gQ3IuaXNWYWxpZCh0aGlzKX0scS5wcm90b3R5cGUuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBjci5pbnRlcnNlY3Rpb24odGhpcyx0KX0scS5wcm90b3R5cGUuY292ZXJzPWZ1bmN0aW9uKHQpe3JldHVybiBHci5jb3ZlcnModGhpcyx0KX0scS5wcm90b3R5cGUuY292ZXJlZEJ5PWZ1bmN0aW9uKHQpe3JldHVybiBHci5jb3ZlcnModCx0aGlzKX0scS5wcm90b3R5cGUudG91Y2hlcz1mdW5jdGlvbih0KXtyZXR1cm4gR3IudG91Y2hlcyh0aGlzLHQpfSxxLnByb3RvdHlwZS5pbnRlcnNlY3RzPWZ1bmN0aW9uKHQpe3JldHVybiBHci5pbnRlcnNlY3RzKHRoaXMsdCl9LHEucHJvdG90eXBlLndpdGhpbj1mdW5jdGlvbih0KXtyZXR1cm4gR3IuY29udGFpbnModCx0aGlzKX0scS5wcm90b3R5cGUub3ZlcmxhcHM9ZnVuY3Rpb24odCl7cmV0dXJuIEdyLm92ZXJsYXBzKHRoaXMsdCl9LHEucHJvdG90eXBlLmRpc2pvaW50PWZ1bmN0aW9uKHQpe3JldHVybiBHci5kaXNqb2ludCh0aGlzLHQpfSxxLnByb3RvdHlwZS5jcm9zc2VzPWZ1bmN0aW9uKHQpe3JldHVybiBHci5jcm9zc2VzKHRoaXMsdCl9LHEucHJvdG90eXBlLmJ1ZmZlcj1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gU2kuYnVmZmVyT3AodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIFNpLmJ1ZmZlck9wKHRoaXMsdCxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIFNpLmJ1ZmZlck9wKHRoaXMsdCxlLG4pfX0scS5wcm90b3R5cGUuY29udmV4SHVsbD1mdW5jdGlvbigpe3JldHVybiBuZXcgYW4odGhpcykuZ2V0Q29udmV4SHVsbCgpfSxxLnByb3RvdHlwZS5yZWxhdGU9ZnVuY3Rpb24oLi4udCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBHci5yZWxhdGUodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIEdyLnJlbGF0ZSh0aGlzLHQpLm1hdGNoZXMoZSl9fSxxLnByb3RvdHlwZS5nZXRDZW50cm9pZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KCk7Y29uc3QgdD1zbi5nZXRDZW50cm9pZCh0aGlzKTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsdGhpcyl9LHEucHJvdG90eXBlLmdldEludGVyaW9yUG9pbnQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCgpO2xldCB0PW51bGw7Y29uc3QgZT10aGlzLmdldERpbWVuc2lvbigpO3Q9MD09PWU/bmV3IGRuKHRoaXMpOjE9PT1lP25ldyBnbih0aGlzKTpuZXcgaG4odGhpcyk7Y29uc3Qgbj10LmdldEludGVyaW9yUG9pbnQoKTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKG4sdGhpcyl9LHEucHJvdG90eXBlLnN5bURpZmZlcmVuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIGNyLnN5bURpZmZlcmVuY2UodGhpcyx0KX0scS5wcm90b3R5cGUuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZD1mdW5jdGlvbih0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9LHEucHJvdG90eXBlLnRvVGV4dD1mdW5jdGlvbigpe3JldHVybihuZXcgSnQpLndyaXRlKHRoaXMpfSxxLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3RoaXMudG9UZXh0KCl9LHEucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe3JldHVybiBHci5jb250YWlucyh0aGlzLHQpfSxxLnByb3RvdHlwZS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQpe3JldHVybiBjci5kaWZmZXJlbmNlKHRoaXMsdCl9LHEucHJvdG90eXBlLmlzU2ltcGxlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBIcyh0aGlzKS5pc1NpbXBsZSgpfSxxLnByb3RvdHlwZS5pc1dpdGhpbkRpc3RhbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk+ZSkmJlJpLmlzV2l0aGluRGlzdGFuY2UodGhpcyx0LGUpfSxxLnByb3RvdHlwZS5kaXN0YW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gUmkuZGlzdGFuY2UodGhpcyx0KX0scS5wcm90b3R5cGUuaXNFcXVpdmFsZW50Q2xhc3M9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0Q2xhc3MoKT09PXQuZ2V0Q2xhc3MoKX07dC5hbGdvcml0aG09bW4sdC5kZW5zaWZ5PUVuLHQuZGlzc29sdmU9Um4sdC5nZW9tPVJlLHQuZ2VvbWdyYXBoPUpuLHQuaW5kZXg9Q3MsdC5pbz1Qcyx0LmxpbmVhcnJlZj1Ibyx0Lm5vZGluZz1Ycyx0Lm9wZXJhdGlvbj1rcix0LnByZWNpc2lvbj1Xcix0LnNpbXBsaWZ5PWhvLHQudHJpYW5ndWxhdGU9QW8sdC51dGlsPUpvLHQudmVyc2lvbj1cIjIuMS4yICg4M2I1YWVlKVwiLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN0cy5taW4uanMubWFwIiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrcywgaWYgcG9seWdvbiBpcyBzaW1wbGUuIFBvbHlnb24gaXMgc2ltcGxlLCB3aGVuIGl0cyBlZGdlcyBkb24ndCBjcm9zcyBlYWNoIG90aGVyLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgUG9seWdvbiBpcyBzaW1wbGVcbiAqL1xuZnVuY3Rpb24gSXNTaW1wbGUgKHBvbHlnb24pIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICB2YXIgbiA9IHAubGVuZ3RoID4+IDE7XG4gIGlmIChuIDwgNCkgcmV0dXJuIHRydWVcbiAgdmFyIGExID0gUG9pbnQoKTtcbiAgdmFyIGEyID0gUG9pbnQoKTtcbiAgdmFyIGIxID0gUG9pbnQoKTtcbiAgdmFyIGIyID0gUG9pbnQoKTtcbiAgdmFyIGMgPSBQb2ludCgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgYTEueCA9IHBbMiAqIGldO1xuICAgIGExLnkgPSBwWzIgKiBpICsgMV07XG4gICAgaWYgKGkgPT0gbiAtIDEpIHtcbiAgICAgIGEyLnggPSBwWzBdO1xuICAgICAgYTIueSA9IHBbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEyLnggPSBwWzIgKiBpICsgMl07XG4gICAgICBhMi55ID0gcFsyICogaSArIDNdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoaSAtIGopIDwgMikgY29udGludWVcbiAgICAgIGlmIChqID09IG4gLSAxICYmIGkgPT0gMCkgY29udGludWVcbiAgICAgIGlmIChpID09IG4gLSAxICYmIGogPT0gMCkgY29udGludWVcblxuICAgICAgYjEueCA9IHBbMiAqIGpdO1xuICAgICAgYjEueSA9IHBbMiAqIGogKyAxXTtcbiAgICAgIGlmIChqID09IG4gLSAxKSB7XG4gICAgICAgIGIyLnggPSBwWzBdO1xuICAgICAgICBiMi55ID0gcFsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIyLnggPSBwWzIgKiBqICsgMl07XG4gICAgICAgIGIyLnkgPSBwWzIgKiBqICsgM107XG4gICAgICB9XG5cbiAgICAgIGlmIChHZXRMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKSAhPSBudWxsKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbm1vZHVsZS5leHBvcnRzLklzU2ltcGxlID0gSXNTaW1wbGU7XG5cbi8qKlxuICogQ2hlY2tzLCBpZiBwb2x5Z29uIGlzIGNvbnZleC4gUG9seWdvbiBpcyBjb252ZXgsIHdoZW4gZWFjaCBpbm5lciBhbmdsZSBpcyA8PSAxODDCsC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBJc0NvbnZleCAocG9seWdvbikge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIGlmIChwLmxlbmd0aCA8IDYpIHJldHVybiB0cnVlXG4gIHZhciBsID0gcC5sZW5ndGggLSA0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIGlmICghY29udmV4KHBbaV0sIHBbaSArIDFdLCBwW2kgKyAyXSwgcFtpICsgM10sIHBbaSArIDRdLCBwW2kgKyA1XSkpIHJldHVybiBmYWxzZVxuICB9XG4gIGlmICghY29udmV4KHBbbF0sIHBbbCArIDFdLCBwW2wgKyAyXSwgcFtsICsgM10sIHBbMF0sIHBbMV0pKSByZXR1cm4gZmFsc2VcbiAgaWYgKCFjb252ZXgocFtsICsgMl0sIHBbbCArIDNdLCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB0cnVlXG59XG5tb2R1bGUuZXhwb3J0cy5Jc0NvbnZleCA9IElzQ29udmV4O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFyZWEgb2YgcG9seWdvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIEdldEFyZWEgKHBvbHlnb24pIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICBpZiAocC5sZW5ndGggPCA2KSByZXR1cm4gMFxuICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgdmFyIHN1bSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgc3VtICs9IChwW2kgKyAyXSAtIHBbaV0pICogKHBbaSArIDFdICsgcFtpICsgM10pO1xuICB9XG4gIHN1bSArPSAocFswXSAtIHBbbF0pICogKHBbbCArIDFdICsgcFsxXSk7XG4gIHJldHVybiAtc3VtICogMC41XG59XG5tb2R1bGUuZXhwb3J0cy5HZXRBcmVhID0gR2V0QXJlYTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBBeGlzLWFsaWduZWQgQm91bmRpbmcgQm94IG9mIHBvbHlnb25cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEByZXR1cm5zIHtBQUJCfVxuICogQGV4YW1wbGVcbiAqIC8vPXt4OjAsIHk6MCwgd2lkdGg6MCwgaGVpZ2h0OjB9XG4gKi9cbmZ1bmN0aW9uIEdldEFBQkIgKHBvbHlnb24pIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICB2YXIgbWlueCA9IEluZmluaXR5O1xuICB2YXIgbWlueSA9IEluZmluaXR5O1xuICB2YXIgbWF4eCA9IC1taW54O1xuICB2YXIgbWF4eSA9IC1taW55O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBtaW54ID0gTWF0aC5taW4obWlueCwgcFtpXSk7XG4gICAgbWF4eCA9IE1hdGgubWF4KG1heHgsIHBbaV0pO1xuICAgIG1pbnkgPSBNYXRoLm1pbihtaW55LCBwW2kgKyAxXSk7XG4gICAgbWF4eSA9IE1hdGgubWF4KG1heHksIHBbaSArIDFdKTtcbiAgfVxuICByZXR1cm4ge3g6IG1pbngsIHk6IG1pbnksIHdpZHRoOiBtYXh4IC0gbWlueCwgaGVpZ2h0OiBtYXh5IC0gbWlueX1cbn1cbm1vZHVsZS5leHBvcnRzLkdldEFBQkIgPSBHZXRBQUJCO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB0cmlhbmd1bGF0aW9uLiBPdXRwdXQgYXJyYXkgaXMgYXJyYXkgb2YgdHJpYW5nbGVzICh0cmlhbmdsZSA9IDMgaW5kaWNlcyBvZiBwb2x5Z29uIHZlcnRpY2VzKS5cbiAqXG4gKiBXb3JrcyB3aXRoIHNpbXBsZSBwb2x5Z29ucyBvbmx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHJldHVybnMge251bWJlcltdfSBhcnJheSBvZiB0cmlhbmdsZXMgKHRyaWFuZ2xlID0gMyBpbmRpY2VzIG9mIHBvbHlnb24gdmVydGljZXMpXG4gKiBAZXhhbXBsZVxuICogdmFyIGlkcyA9IFBvbHlLLlRyaWFuZ3VsYXRlKFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSk7XG4gKiAvLz1bMCwgMSwgMiwgMCwgMiwgM11cbiAqL1xuZnVuY3Rpb24gVHJpYW5ndWxhdGUgKHBvbHlnb24pIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICB2YXIgbiA9IHAubGVuZ3RoID4+IDE7XG4gIGlmIChuIDwgMykgcmV0dXJuIFtdXG4gIHZhciB0Z3MgPSBbXTtcbiAgdmFyIGF2bCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgeyBhdmwucHVzaChpKTsgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIGFsID0gbjtcbiAgd2hpbGUgKGFsID4gMykge1xuICAgIHZhciBpMCA9IGF2bFsoaSArIDApICUgYWxdO1xuICAgIHZhciBpMSA9IGF2bFsoaSArIDEpICUgYWxdO1xuICAgIHZhciBpMiA9IGF2bFsoaSArIDIpICUgYWxdO1xuXG4gICAgdmFyIGF4ID0gcFsyICogaTBdO1xuICAgIHZhciBheSA9IHBbMiAqIGkwICsgMV07XG4gICAgdmFyIGJ4ID0gcFsyICogaTFdO1xuICAgIHZhciBieSA9IHBbMiAqIGkxICsgMV07XG4gICAgdmFyIGN4ID0gcFsyICogaTJdO1xuICAgIHZhciBjeSA9IHBbMiAqIGkyICsgMV07XG5cbiAgICB2YXIgZWFyRm91bmQgPSBmYWxzZTtcbiAgICBpZiAoY29udmV4KGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7XG4gICAgICBlYXJGb3VuZCA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsOyBqKyspIHtcbiAgICAgICAgdmFyIHZpID0gYXZsW2pdO1xuICAgICAgICBpZiAodmkgPT0gaTAgfHwgdmkgPT0gaTEgfHwgdmkgPT0gaTIpIGNvbnRpbnVlXG4gICAgICAgIGlmIChQb2ludEluVHJpYW5nbGUocFsyICogdmldLCBwWzIgKiB2aSArIDFdLCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KSkge1xuICAgICAgICAgIGVhckZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWFyRm91bmQpIHtcbiAgICAgIHRncy5wdXNoKGkwLCBpMSwgaTIpO1xuICAgICAgYXZsLnNwbGljZSgoaSArIDEpICUgYWwsIDEpO1xuICAgICAgYWwtLTtcbiAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSBpZiAoaSsrID4gMyAqIGFsKSBicmVhayAgICAvLyBubyBjb252ZXggYW5nbGVzIDooXG4gIH1cbiAgdGdzLnB1c2goYXZsWzBdLCBhdmxbMV0sIGF2bFsyXSk7XG4gIHJldHVybiB0Z3Ncbn1cbm1vZHVsZS5leHBvcnRzLlRyaWFuZ3VsYXRlID0gVHJpYW5ndWxhdGU7XG5cbi8qKlxuICogU2xpY2VzIHRoZSBwb2x5Z29uIHdpdGggbGluZSBzZWdtZW50IEEtQiwgZGVmaW5lZCBieSBbYXgsYXldIGFuZCBbYngsYnldLiBBLCBCIG11c3Qgbm90IGxheSBpbnNpZGUgYSBwb2x5Z29uLiBSZXR1cm5zIGFuIGFycmF5IG9mIHBvbHlnb25zLlxuICpcbiAqIFdvcmtzIHdpdGggc2ltcGxlIHBvbHlnb25zIG9ubHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRYIFN0YXJ0IENvb3JkaW5hdGUgW3hdXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRZIFN0YXJ0IENvb3JkaW5hdGUgW3ldXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kWCBFbmQgQ29vcmRpbmF0ZSBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRZIEVuZCBDb29yZGluYXRlIFt5XVxuICogQHJldHVybnMge251bWJlcltdW119IEFycmF5IG9mIFBvbHlnb25cbiAqL1xuZnVuY3Rpb24gU2xpY2UgKHBvbHlnb24sIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIGF4ID0gc3RhcnRYO1xuICB2YXIgYXkgPSBzdGFydFk7XG4gIHZhciBieCA9IGVuZFg7XG4gIHZhciBieSA9IGVuZFk7XG4gIGlmIChDb250YWluc1BvaW50KHAsIGF4LCBheSkgfHwgQ29udGFpbnNQb2ludChwLCBieCwgYnkpKSB7XG4gICAgcmV0dXJuIFtwLnNsaWNlKDApXVxuICB9XG5cbiAgdmFyIGEgPSBQb2ludChheCwgYXkpO1xuICB2YXIgYiA9IFBvaW50KGJ4LCBieSk7XG4gIHZhciBpc2NzID0gW107ICAvLyBpbnRlcnNlY3Rpb25zXG4gIHZhciBwcyA9IFtdOyAgLy8gcG9pbnRzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBzLnB1c2goUG9pbnQocFtpXSwgcFtpICsgMV0pKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlzYyA9IFBvaW50KDAsIDApO1xuICAgIGlzYyA9IEdldExpbmVJbnRlcnNlY3Rpb24oYSwgYiwgcHNbaV0sIHBzWyhpICsgMSkgJSBwcy5sZW5ndGhdLCBpc2MpO1xuICAgIHZhciBmaXNjID0gaXNjc1swXTtcbiAgICB2YXIgbGlzYyA9IGlzY3NbaXNjcy5sZW5ndGggLSAxXTtcbiAgICAvLyAmJiAoaXNjLnghPXBzW2ldLnggfHwgaXNjLnkhPXBzW2ldLnkpIClcbiAgICBpZiAoaXNjICYmIChmaXNjID09IG51bGwgfHwgZGlzdGFuY2UoaXNjLCBmaXNjKSA+IDFlLTEwKSAmJiAobGlzYyA9PSBudWxsIHx8IGRpc3RhbmNlKGlzYywgbGlzYykgPiAxZS0xMCkpIHtcbiAgICAgIGlzYy5mbGFnID0gdHJ1ZTtcbiAgICAgIGlzY3MucHVzaChpc2MpO1xuICAgICAgcHMuc3BsaWNlKGkgKyAxLCAwLCBpc2MpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc2NzLmxlbmd0aCA8IDIpIHJldHVybiBbcC5zbGljZSgwKV1cbiAgdmFyIGNvbXAgPSBmdW5jdGlvbiAodSwgdikgeyByZXR1cm4gZGlzdGFuY2UoYSwgdSkgLSBkaXN0YW5jZShhLCB2KSB9O1xuICBpc2NzLnNvcnQoY29tcCk7XG5cbiAgdmFyIHBncyA9IFtdO1xuICB2YXIgZGlyID0gMDtcbiAgd2hpbGUgKGlzY3MubGVuZ3RoID4gMCkge1xuICAgIC8vIHZhciBuID0gcHMubGVuZ3RoIC8vIGlzIGFzc2lnbmVkIGEgdmFsdWUgYnV0IG5ldmVyIHVzZWQuIChuby11bnVzZWQtdmFycylcbiAgICB2YXIgaTAgPSBpc2NzWzBdO1xuICAgIHZhciBpMSA9IGlzY3NbMV07XG4gICAgLy8gaWYoaTAueD09aTEueCAmJiBpMC55PT1pMS55KSB7IGlzY3Muc3BsaWNlKDAsMik7IGNvbnRpbnVlO31cbiAgICB2YXIgaW5kZXgwID0gcHMuaW5kZXhPZihpMCk7XG4gICAgdmFyIGluZGV4MSA9IHBzLmluZGV4T2YoaTEpO1xuICAgIHZhciBzb2x2ZWQgPSBmYWxzZTtcblxuICAgIGlmIChmaXJzdFdpdGhGbGFnKHBzLCBpbmRleDApID09PSBpbmRleDEpIHtcbiAgICAgIHNvbHZlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkwID0gaXNjc1sxXTtcbiAgICAgIGkxID0gaXNjc1swXTtcbiAgICAgIGluZGV4MCA9IHBzLmluZGV4T2YoaTApO1xuICAgICAgaW5kZXgxID0gcHMuaW5kZXhPZihpMSk7XG4gICAgICBpZiAoZmlyc3RXaXRoRmxhZyhwcywgaW5kZXgwKSA9PT0gaW5kZXgxKSBzb2x2ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoc29sdmVkKSB7XG4gICAgICBkaXItLTtcbiAgICAgIHZhciBwZ24gPSBnZXRQb2ludHMocHMsIGluZGV4MCwgaW5kZXgxKTtcbiAgICAgIHBncy5wdXNoKHBnbik7XG4gICAgICBwcyA9IGdldFBvaW50cyhwcywgaW5kZXgxLCBpbmRleDApO1xuICAgICAgaTAuZmxhZyA9IGkxLmZsYWcgPSBmYWxzZTtcbiAgICAgIGlzY3Muc3BsaWNlKDAsIDIpO1xuICAgICAgaWYgKGlzY3MubGVuZ3RoID09IDApIHBncy5wdXNoKHBzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlyKys7XG4gICAgICBpc2NzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgaWYgKGRpciA+IDEpIGJyZWFrXG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwZyA9IHBnc1tpXTtcbiAgICB2YXIgbnBnID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwZy5sZW5ndGg7IGorKykgeyBucGcucHVzaChwZ1tqXS54LCBwZ1tqXS55KTsgfVxuICAgIHJlc3VsdC5wdXNoKG5wZyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxubW9kdWxlLmV4cG9ydHMuU2xpY2UgPSBTbGljZTtcblxuLyoqXG4gKiBDaGVja3MsIGlmIHBvbHlnb24gY29udGFpbnMgW3gsIHldLlxuICpcbiAqIFdvcmtzIHdpdGggc2ltcGxlIHBvbHlnb25zIG9ubHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcGFyYW0ge251bWJlcn0gcG9pbnRYIENvb3JkaW5hdGUgW3hdXG4gKiBAcGFyYW0ge251bWJlcn0gcG9pbnRZIENvb3JkaW5hdGUgW3ldXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gZGVwdGhcbiAqL1xuZnVuY3Rpb24gQ29udGFpbnNQb2ludCAocG9seWdvbiwgcG9pbnRYLCBwb2ludFkpIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICB2YXIgcHggPSBwb2ludFg7XG4gIHZhciBweSA9IHBvaW50WTtcbiAgdmFyIG4gPSBwLmxlbmd0aCA+PiAxO1xuICB2YXIgYXg7XG4gIHZhciBheSA9IHBbMiAqIG4gLSAzXSAtIHB5O1xuICB2YXIgYnggPSBwWzIgKiBuIC0gMl0gLSBweDtcbiAgdmFyIGJ5ID0gcFsyICogbiAtIDFdIC0gcHk7XG5cbiAgLy8gdmFyIGx1cCA9IGJ5ID4gYXk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgYXggPSBieDtcbiAgICBheSA9IGJ5O1xuICAgIGJ4ID0gcFsyICogaV0gLSBweDtcbiAgICBieSA9IHBbMiAqIGkgKyAxXSAtIHB5O1xuICAgIGlmIChheSA9PT0gYnkpIGNvbnRpbnVlXG4gICAgdmFyIGx1cCA9IGJ5ID4gYXk7XG4gIH1cblxuICB2YXIgZGVwdGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGF4ID0gYng7XG4gICAgYXkgPSBieTtcbiAgICBieCA9IHBbMiAqIGldIC0gcHg7XG4gICAgYnkgPSBwWzIgKiBpICsgMV0gLSBweTtcbiAgICBpZiAoYXkgPCAwICYmIGJ5IDwgMCkgY29udGludWUgIC8vIGJvdGggXCJ1cFwiIG9yIGJvdGggXCJkb3duXCJcbiAgICBpZiAoYXkgPiAwICYmIGJ5ID4gMCkgY29udGludWUgIC8vIGJvdGggXCJ1cFwiIG9yIGJvdGggXCJkb3duXCJcbiAgICBpZiAoYXggPCAwICYmIGJ4IDwgMCkgY29udGludWUgICAvLyBib3RoIHBvaW50cyBvbiB0aGUgbGVmdFxuXG4gICAgaWYgKGF5ID09PSBieSAmJiBNYXRoLm1pbihheCwgYngpIDw9IDApIHJldHVybiB0cnVlXG4gICAgaWYgKGF5ID09PSBieSkgY29udGludWVcblxuICAgIHZhciBseCA9IGF4ICsgKGJ4IC0gYXgpICogKC1heSkgLyAoYnkgLSBheSk7XG4gICAgaWYgKGx4ID09PSAwKSByZXR1cm4gdHJ1ZSAgICAgIC8vIHBvaW50IG9uIGVkZ2VcbiAgICBpZiAobHggPiAwKSBkZXB0aCsrO1xuICAgIGlmIChheSA9PT0gMCAmJiBsdXAgJiYgYnkgPiBheSkgZGVwdGgtLTsgIC8vIGhpdCB2ZXJ0ZXgsIGJvdGggdXBcbiAgICBpZiAoYXkgPT09IDAgJiYgIWx1cCAmJiBieSA8IGF5KSBkZXB0aC0tOyAvLyBoaXQgdmVydGV4LCBib3RoIGRvd25cbiAgICBsdXAgPSBieSA+IGF5O1xuICB9XG4gIHJldHVybiAoZGVwdGggJiAxKSA9PT0gMVxufVxubW9kdWxlLmV4cG9ydHMuQ29udGFpbnNQb2ludCA9IENvbnRhaW5zUG9pbnQ7XG5cbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgcG9pbnQgb2YgcG9seWdvbiwgd2hpY2ggbGF5cyBvbiByYXkgZGVmaW5lZCBieSBbeCx5XSAob3JpZ2luKSBhbmQgW2R4LGR5XSAoZGlyZWN0aW9uKS5cbiAqXG4gKiBcImRpc3RcIiBpcyB0aGUgZGlzdGFuY2Ugb2YgdGhlIHBvbHlnb24gcG9pbnQsIFwiZWRnZVwiIGlzIHRoZSBudW1iZXIgb2YgdGhlIGVkZ2UsIG9uIHdoaWNoIGludGVyc2VjdGlvbiBvY2N1cnMsIFwibm9ybVwiIGlzIHRoZSBub3JtYWwgaW4gdGhhdCBwbGFjZSwgXCJyZWZsXCIgaXMgcmVmbGVjdGVkIGRpcmVjdGlvbi5cbiAqXG4gKiBXb3JrcyB3aXRoIHNpbXBsZSBwb2x5Z29ucyBvbmx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblggT3JpZ2luIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblkgT3JpZ2luIFt5XVxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvblggRGlyZWN0aW9uIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvblkgRGlyZWN0aW9uIFt5XVxuICogQHJldHVybnMge1JheWNhc3R9XG4gKiBAZXhhbXBsZVxuICogLy89e2Rpc3Q6MCwgZWRnZTowLCBub3JtOnt4OjAsIHk6MH0sIHJlZmw6e3g6MCwgeTowfX1cbiAqL1xuZnVuY3Rpb24gUmF5Y2FzdCAocG9seWdvbiwgb3JpZ2luWCwgb3JpZ2luWSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSwgaXNjKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIHggPSBvcmlnaW5YO1xuICB2YXIgeSA9IG9yaWdpblk7XG4gIHZhciBkeCA9IGRpcmVjdGlvblg7XG4gIHZhciBkeSA9IGRpcmVjdGlvblk7XG4gIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICB2YXIgZW1wdHkgPSBlbXB0eVBvaW50cygpO1xuICB2YXIgYTEgPSBlbXB0eVswXTtcbiAgdmFyIGEyID0gZW1wdHlbMV07XG4gIHZhciBiMSA9IGVtcHR5WzJdO1xuICB2YXIgYjIgPSBlbXB0eVszXTtcbiAgdmFyIGMgPSBlbXB0eVs0XTtcbiAgYTEueCA9IHg7XG4gIGExLnkgPSB5O1xuICBhMi54ID0geCArIGR4O1xuICBhMi55ID0geSArIGR5O1xuXG4gIGlmIChpc2MgPT09IG51bGwgfHwgaXNjID09PSB1bmRlZmluZWQpIHtcbiAgICBpc2MgPSB7ZGlzdDogMCwgZWRnZTogMCwgbm9ybToge3g6IDAsIHk6IDB9LCByZWZsOiB7eDogMCwgeTogMH19O1xuICB9XG4gIGlzYy5kaXN0ID0gSW5maW5pdHk7XG5cbiAgdmFyIG5pc2M7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgYjEueCA9IHBbaV07XG4gICAgYjEueSA9IHBbaSArIDFdO1xuICAgIGIyLnggPSBwW2kgKyAyXTtcbiAgICBiMi55ID0gcFtpICsgM107XG4gICAgbmlzYyA9IFJheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xuICAgIGlmIChuaXNjKSB7XG4gICAgICBpc2MgPSB1cGRhdGVJU0MoZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCBpIC8gMiwgaXNjKTtcbiAgICB9XG4gIH1cbiAgYjEueCA9IGIyLng7XG4gIGIxLnkgPSBiMi55O1xuICBiMi54ID0gcFswXTtcbiAgYjIueSA9IHBbMV07XG4gIG5pc2MgPSBSYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgaWYgKG5pc2MpIHtcbiAgICBpc2MgPSB1cGRhdGVJU0MoZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCAocC5sZW5ndGggLyAyKSAtIDEsIGlzYyk7XG4gIH1cblxuICByZXR1cm4gKGlzYy5kaXN0ICE9PSBJbmZpbml0eSkgPyBpc2MgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cy5SYXljYXN0ID0gUmF5Y2FzdDtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcG9pbnQgb24gcG9seWdvbiBlZGdlcywgd2hpY2ggaXMgY2xvc2VzdCB0byBbeCx5XS4gUmV0dXJucyBhbiBvYmplY3QgaW4gdGhpcyBmb3JtYXRcbiAqXG4gKiBcImRpc3RcIiBpcyB0aGUgZGlzdGFuY2Ugb2YgdGhlIHBvbHlnb24gcG9pbnQsIFwiZWRnZVwiIGlzIHRoZSBudW1iZXIgb2YgdGhlIGNsb3Nlc3QgZWRnZSwgXCJwb2ludFwiIGlzIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoYXQgZWRnZSwgXCJub3JtXCIgaXMgdGhlIG5vcm1hbCBmcm9tIFwicG9pbnRcIiB0byBbeCx5XS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IENvb3JkaW5hdGUgW3hdXG4gKiBAcGFyYW0ge251bWJlcn0geSBDb29yZGluYXRlIFt5XVxuICogQHJldHVybnMge0Nsb3Nlc3RFZGdlfVxuICogQGV4YW1wbGVcbiAqIC8vPXtkaXN0OjAsIGVkZ2U6MCwgcG9pbnQ6e3g6MCwgeTowfSwgbm9ybTp7eDowLCB5OjB9fVxuICovXG5mdW5jdGlvbiBDbG9zZXN0RWRnZSAocG9seWdvbiwgeCwgeSwgaXNjKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gIHZhciBlbXB0eSA9IGVtcHR5UG9pbnRzKCk7XG4gIHZhciBhMSA9IGVtcHR5WzBdO1xuICB2YXIgYjEgPSBlbXB0eVsyXTtcbiAgdmFyIGIyID0gZW1wdHlbM107XG4gIC8vIHZhciBjID0gdHBbNF0gLy8gaXMgYXNzaWduZWQgYSB2YWx1ZSBidXQgbmV2ZXIgdXNlZC5cbiAgYTEueCA9IHg7XG4gIGExLnkgPSB5O1xuXG4gIGlmIChpc2MgPT0gbnVsbCkge1xuICAgIGlzYyA9IHtkaXN0OiAwLCBlZGdlOiAwLCBwb2ludDoge3g6IDAsIHk6IDB9LCBub3JtOiB7eDogMCwgeTogMH19O1xuICB9XG4gIGlzYy5kaXN0ID0gSW5maW5pdHk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICBiMS54ID0gcFtpXTtcbiAgICBiMS55ID0gcFtpICsgMV07XG4gICAgYjIueCA9IHBbaSArIDJdO1xuICAgIGIyLnkgPSBwW2kgKyAzXTtcbiAgICBpc2MgPSBwb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGkgPj4gMSwgaXNjKTtcbiAgfVxuICBiMS54ID0gYjIueDtcbiAgYjEueSA9IGIyLnk7XG4gIGIyLnggPSBwWzBdO1xuICBiMi55ID0gcFsxXTtcbiAgaXNjID0gcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBsID4+IDEsIGlzYyk7XG5cbiAgdmFyIGlkc3QgPSAxIC8gaXNjLmRpc3Q7XG4gIGlzYy5ub3JtLnggPSAoeCAtIGlzYy5wb2ludC54KSAqIGlkc3Q7XG4gIGlzYy5ub3JtLnkgPSAoeSAtIGlzYy5wb2ludC55KSAqIGlkc3Q7XG4gIHJldHVybiBpc2Ncbn1cbm1vZHVsZS5leHBvcnRzLkNsb3Nlc3RFZGdlID0gQ2xvc2VzdEVkZ2U7XG5cbi8qKlxuICogUmV2ZXJzZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICovXG5mdW5jdGlvbiBSZXZlcnNlIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG5wID0gW107XG4gIGZvciAodmFyIGogPSBwLmxlbmd0aCAtIDI7IGogPj0gMDsgaiAtPSAyKSB7IG5wLnB1c2gocFtqXSwgcFtqICsgMV0pOyB9XG4gIHJldHVybiBucFxufVxubW9kdWxlLmV4cG9ydHMuUmV2ZXJzZSA9IFJldmVyc2U7XG5cbi8qKlxuICogUG9pbnQgTGluZSBEaXN0YW5jZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBwXG4gKiBAcGFyYW0ge1BvaW50fSBhXG4gKiBAcGFyYW0ge1BvaW50fSBiXG4gKiBAcGFyYW0gez8/fSBlZGdlXG4gKiBAcGFyYW0gez8/fSBpc2NcbiAqIEByZXR1cm5zIHs/P30gSVNDXG4gKi9cbmZ1bmN0aW9uIHBvaW50TGluZURpc3QgKHAsIGEsIGIsIGVkZ2UsIGlzYykge1xuICB2YXIgeCA9IHAueDtcbiAgdmFyIHkgPSBwLnk7XG4gIHZhciB4MSA9IGEueDtcbiAgdmFyIHkxID0gYS55O1xuICB2YXIgeDIgPSBiLng7XG4gIHZhciB5MiA9IGIueTtcblxuICB2YXIgQSA9IHggLSB4MTtcbiAgdmFyIEIgPSB5IC0geTE7XG4gIHZhciBDID0geDIgLSB4MTtcbiAgdmFyIEQgPSB5MiAtIHkxO1xuXG4gIHZhciBkb3QgPSBBICogQyArIEIgKiBEO1xuICB2YXIgbGVuU3EgPSBDICogQyArIEQgKiBEO1xuICB2YXIgcGFyYW0gPSBkb3QgLyBsZW5TcTtcblxuICB2YXIgeHg7XG4gIHZhciB5eTtcblxuICBpZiAocGFyYW0gPCAwIHx8ICh4MSA9PSB4MiAmJiB5MSA9PSB5MikpIHtcbiAgICB4eCA9IHgxO1xuICAgIHl5ID0geTE7XG4gIH0gZWxzZSBpZiAocGFyYW0gPiAxKSB7XG4gICAgeHggPSB4MjtcbiAgICB5eSA9IHkyO1xuICB9IGVsc2Uge1xuICAgIHh4ID0geDEgKyBwYXJhbSAqIEM7XG4gICAgeXkgPSB5MSArIHBhcmFtICogRDtcbiAgfVxuXG4gIHZhciBkeCA9IHggLSB4eDtcbiAgdmFyIGR5ID0geSAtIHl5O1xuICB2YXIgZHN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgaWYgKGRzdCA8IGlzYy5kaXN0KSB7XG4gICAgaXNjLmRpc3QgPSBkc3Q7XG4gICAgaXNjLmVkZ2UgPSBlZGdlO1xuICAgIGlzYy5wb2ludC54ID0geHg7XG4gICAgaXNjLnBvaW50LnkgPSB5eTtcbiAgfVxuICByZXR1cm4gaXNjXG59XG5cbi8qKlxuICogVXBkYXRlIElTQ1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICogQHBhcmFtIHtQb2ludH0gYTFcbiAqIEBwYXJhbSB7UG9pbnR9IGIxXG4gKiBAcGFyYW0ge1BvaW50fSBiMlxuICogQHBhcmFtIHtQb2ludH0gY1xuICogQHBhcmFtIHs/P30gZWRnZVxuICogQHBhcmFtIHs/P30gaXNjXG4gKiBAcmV0dXJucyB7Pz99XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUlTQyAoZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCBlZGdlLCBpc2MpIHtcbiAgdmFyIG5ybCA9IGRpc3RhbmNlKGExLCBjKTtcbiAgaWYgKG5ybCA8IGlzYy5kaXN0KSB7XG4gICAgdmFyIGlibCA9IDEgLyBkaXN0YW5jZShiMSwgYjIpO1xuICAgIHZhciBueCA9IC0oYjIueSAtIGIxLnkpICogaWJsO1xuICAgIHZhciBueSA9IChiMi54IC0gYjEueCkgKiBpYmw7XG4gICAgdmFyIGRkb3QgPSAyICogKGR4ICogbnggKyBkeSAqIG55KTtcbiAgICBpc2MuZGlzdCA9IG5ybDtcbiAgICBpc2Mubm9ybS54ID0gbng7XG4gICAgaXNjLm5vcm0ueSA9IG55O1xuICAgIGlzYy5yZWZsLnggPSAtZGRvdCAqIG54ICsgZHg7XG4gICAgaXNjLnJlZmwueSA9IC1kZG90ICogbnkgKyBkeTtcbiAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gIH1cbiAgcmV0dXJuIGlzY1xufVxuXG4vKipcbiAqIEdldCBQb2ludHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXgwXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXgxXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHBvaW50c1xuICovXG5mdW5jdGlvbiBnZXRQb2ludHMgKHBvaW50cywgaW5kZXgwLCBpbmRleDEpIHtcbiAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChpbmRleDEgPCBpbmRleDApIGluZGV4MSArPSBuO1xuICBmb3IgKHZhciBpID0gaW5kZXgwOyBpIDw9IGluZGV4MTsgaSsrKSB7IHJlc3VsdC5wdXNoKHBvaW50c1tpICUgbl0pOyB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBGaXJzdCBXaXRoIEZsYWdcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZmlyc3RXaXRoRmxhZyAocG9pbnRzLCBpbmRleCkge1xuICB2YXIgbiA9IHBvaW50cy5sZW5ndGg7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaW5kZXggPSAoaW5kZXggKyAxKSAlIG47XG4gICAgaWYgKHBvaW50c1tpbmRleF0uZmxhZykge1xuICAgICAgcmV0dXJuIGluZGV4XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUG9pbnQgaW4gVHJpYW5nbGVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHB4XG4gKiBAcGFyYW0ge251bWJlcn0gcHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBheFxuICogQHBhcmFtIHtudW1iZXJ9IGF5XG4gKiBAcGFyYW0ge251bWJlcn0gYnhcbiAqIEBwYXJhbSB7bnVtYmVyfSBieVxuICogQHBhcmFtIHtudW1iZXJ9IGN4XG4gKiBAcGFyYW0ge251bWJlcn0gY3lcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBQb2ludEluVHJpYW5nbGUgKHB4LCBweSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSkge1xuICB2YXIgdjB4ID0gY3ggLSBheDtcbiAgdmFyIHYweSA9IGN5IC0gYXk7XG4gIHZhciB2MXggPSBieCAtIGF4O1xuICB2YXIgdjF5ID0gYnkgLSBheTtcbiAgdmFyIHYyeCA9IHB4IC0gYXg7XG4gIHZhciB2MnkgPSBweSAtIGF5O1xuXG4gIHZhciBkb3QwMCA9IHYweCAqIHYweCArIHYweSAqIHYweTtcbiAgdmFyIGRvdDAxID0gdjB4ICogdjF4ICsgdjB5ICogdjF5O1xuICB2YXIgZG90MDIgPSB2MHggKiB2MnggKyB2MHkgKiB2Mnk7XG4gIHZhciBkb3QxMSA9IHYxeCAqIHYxeCArIHYxeSAqIHYxeTtcbiAgdmFyIGRvdDEyID0gdjF4ICogdjJ4ICsgdjF5ICogdjJ5O1xuXG4gIHZhciBpbnZEZW5vbSA9IDEgLyAoZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEpO1xuICB2YXIgdSA9IChkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgKiBpbnZEZW5vbTtcbiAgdmFyIHYgPSAoZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpICogaW52RGVub207XG5cbiAgLy8gQ2hlY2sgaWYgcG9pbnQgaXMgaW4gdHJpYW5nbGVcbiAgcmV0dXJuICh1ID49IDApICYmICh2ID49IDApICYmICh1ICsgdiA8IDEpXG59XG5cbi8qKlxuICogUmF5TGluZSBJbnRlcnNlY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gYTFcbiAqIEBwYXJhbSB7UG9pbnR9IGEyXG4gKiBAcGFyYW0ge1BvaW50fSBiMVxuICogQHBhcmFtIHtQb2ludH0gYjJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqL1xuZnVuY3Rpb24gUmF5TGluZUludGVyc2VjdGlvbiAoYTEsIGEyLCBiMSwgYjIsIGMpIHtcbiAgdmFyIGRheCA9IChhMS54IC0gYTIueCk7XG4gIHZhciBkYnggPSAoYjEueCAtIGIyLngpO1xuICB2YXIgZGF5ID0gKGExLnkgLSBhMi55KTtcbiAgdmFyIGRieSA9IChiMS55IC0gYjIueSk7XG5cbiAgdmFyIERlbiA9IGRheCAqIGRieSAtIGRheSAqIGRieDtcbiAgaWYgKERlbiA9PSAwKSByZXR1cm4gbnVsbCAgLy8gcGFyYWxsZWxcblxuICB2YXIgQSA9IChhMS54ICogYTIueSAtIGExLnkgKiBhMi54KTtcbiAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XG5cbiAgdmFyIEkgPSBjO1xuICB2YXIgaURlbiA9IDEgLyBEZW47XG4gIEkueCA9IChBICogZGJ4IC0gZGF4ICogQikgKiBpRGVuO1xuICBJLnkgPSAoQSAqIGRieSAtIGRheSAqIEIpICogaURlbjtcblxuICBpZiAoIUluUmVjdGFuZ2xlKEksIGIxLCBiMikpIHJldHVybiBudWxsXG4gIGlmICgoZGF5ID4gMCAmJiBJLnkgPiBhMS55KSB8fCAoZGF5IDwgMCAmJiBJLnkgPCBhMS55KSkgcmV0dXJuIG51bGxcbiAgaWYgKChkYXggPiAwICYmIEkueCA+IGExLngpIHx8IChkYXggPCAwICYmIEkueCA8IGExLngpKSByZXR1cm4gbnVsbFxuICByZXR1cm4gSVxufVxuXG4vKipcbiAqIEdldCBMaW5lIEludGVyc2VjdGlvblxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBhMVxuICogQHBhcmFtIHtQb2ludH0gYTJcbiAqIEBwYXJhbSB7UG9pbnR9IGIxXG4gKiBAcGFyYW0ge1BvaW50fSBiMlxuICogQHBhcmFtIHtQb2ludH0gY1xuICogQHJldHVybnMge1BvaW50fVxuICovXG5mdW5jdGlvbiBHZXRMaW5lSW50ZXJzZWN0aW9uIChhMSwgYTIsIGIxLCBiMiwgYykge1xuICB2YXIgZGF4ID0gKGExLnggLSBhMi54KTtcbiAgdmFyIGRieCA9IChiMS54IC0gYjIueCk7XG4gIHZhciBkYXkgPSAoYTEueSAtIGEyLnkpO1xuICB2YXIgZGJ5ID0gKGIxLnkgLSBiMi55KTtcblxuICB2YXIgRGVuID0gZGF4ICogZGJ5IC0gZGF5ICogZGJ4O1xuXG4gIGlmIChEZW4gPT09IDApIHsgcmV0dXJuIG51bGwgfSAvLyBwYXJhbGxlbFxuXG4gIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICB2YXIgSSA9IGM7XG4gIEkueCA9IChBICogZGJ4IC0gZGF4ICogQikgLyBEZW47XG4gIEkueSA9IChBICogZGJ5IC0gZGF5ICogQikgLyBEZW47XG5cbiAgaWYgKEluUmVjdGFuZ2xlKEksIGExLCBhMikgJiYgSW5SZWN0YW5nbGUoSSwgYjEsIGIyKSkge1xuICAgIHJldHVybiBJXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBJbiBSZWN0YW5nbGVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gYVxuICogQHBhcmFtIHtQb2ludH0gYlxuICogQHBhcmFtIHtQb2ludH0gY1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gSW5SZWN0YW5nbGUgKGEsIGIsIGMpIHtcbiAgdmFyIG1pbnggPSBNYXRoLm1pbihiLngsIGMueCk7XG4gIHZhciBtYXh4ID0gTWF0aC5tYXgoYi54LCBjLngpO1xuICB2YXIgbWlueSA9IE1hdGgubWluKGIueSwgYy55KTtcbiAgdmFyIG1heHkgPSBNYXRoLm1heChiLnksIGMueSk7XG5cbiAgaWYgKG1pbnggPT09IG1heHgpIHsgcmV0dXJuIChtaW55IDw9IGEueSAmJiBhLnkgPD0gbWF4eSkgfVxuICBpZiAobWlueSA9PT0gbWF4eSkgeyByZXR1cm4gKG1pbnggPD0gYS54ICYmIGEueCA8PSBtYXh4KSB9XG5cbiAgLy8gcmV0dXJuIChtaW54IDw9IGEueCAmJiBhLnggPD0gbWF4eCAmJiBtaW55IDw9IGEueSAmJiBhLnkgPD0gbWF4eSlcbiAgcmV0dXJuIChtaW54IDw9IGEueCArIDFlLTEwICYmIGEueCAtIDFlLTEwIDw9IG1heHggJiYgbWlueSA8PSBhLnkgKyAxZS0xMCAmJiBhLnkgLSAxZS0xMCA8PSBtYXh5KVxufVxuXG4vKipcbiAqIENvbnZleFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBheFxuICogQHBhcmFtIHtQb2ludH0gYXlcbiAqIEBwYXJhbSB7UG9pbnR9IGJ4XG4gKiBAcGFyYW0ge1BvaW50fSBieVxuICogQHBhcmFtIHtQb2ludH0gY3hcbiAqIEBwYXJhbSB7UG9pbnR9IGN5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udmV4IChheCwgYXksIGJ4LCBieSwgY3gsIGN5KSB7XG4gIHJldHVybiAoYXkgLSBieSkgKiAoY3ggLSBieCkgKyAoYnggLSBheCkgKiAoY3kgLSBieSkgPj0gMFxufVxuXG4vKipcbiAqIFBvaW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybnMge1BvaW50fVxuICovXG5mdW5jdGlvbiBQb2ludCAoeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICBmbGFnOiBmYWxzZSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1BvaW50IFsnICsgeCArICcsICcgKyB5ICsgJ10nIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc3RhbmNlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IGFcbiAqIEBwYXJhbSB7UG9pbnR9IGJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlIChhLCBiKSB7XG4gIHZhciBkeCA9IGIueCAtIGEueDtcbiAgdmFyIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZW1wdHkgUG9pbnRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbnVtPTEwXSBOdW1iZXIgb2YgcG9pbnRzXG4gKiBAcmV0dXJucyB7UG9pbnRbXX1cbiAqL1xuZnVuY3Rpb24gZW1wdHlQb2ludHMgKG51bSkge1xuICBudW0gPSBudW0gfHwgMTA7XG4gIHZhciBjb250YWluZXIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykgeyBjb250YWluZXIucHVzaChQb2ludCgwLCAwKSk7IH1cbiAgcmV0dXJuIGNvbnRhaW5lclxufVxuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9seWsuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cblxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL3ZhciB0PWZ1bmN0aW9uKGUsbil7cmV0dXJuKHQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSl9KShlLG4pfTtmdW5jdGlvbiBlKGUsbil7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9ZX10KGUsbiksZS5wcm90b3R5cGU9bnVsbD09PW4/T2JqZWN0LmNyZWF0ZShuKTooci5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IHIpfWZ1bmN0aW9uIG4oKXtmb3IodmFyIHQ9MCxlPTAsbj1hcmd1bWVudHMubGVuZ3RoO2U8bjtlKyspdCs9YXJndW1lbnRzW2VdLmxlbmd0aDt2YXIgcj1BcnJheSh0KSxhPTA7Zm9yKGU9MDtlPG47ZSsrKWZvcih2YXIgbz1hcmd1bWVudHNbZV0scz0wLGg9by5sZW5ndGg7czxoO3MrKyxhKyspclthXT1vW3NdO3JldHVybiByfWZ1bmN0aW9uIHIodCxlLG4pe2lmKHQmJnQubGVuZ3RoKXt2YXIgcj1lWzBdLGE9ZVsxXSxvPU1hdGguUEkvMTgwKm4scz1NYXRoLmNvcyhvKSxoPU1hdGguc2luKG8pO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9dFswXSxuPXRbMV07dFswXT0oZS1yKSpzLShuLWEpKmgrcix0WzFdPShlLXIpKmgrKG4tYSkqcythfSkpfX1mdW5jdGlvbiBhKHQpe3ZhciBlPXRbMF0sbj10WzFdO3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZVswXS1uWzBdLDIpK01hdGgucG93KGVbMV0tblsxXSwyKSl9ZnVuY3Rpb24gbyh0LGUpe3ZhciBhPVswLDBdLG89TWF0aC5yb3VuZChlLmhhY2h1cmVBbmdsZSs5MCk7byYmcih0LGEsbyk7dmFyIHM9ZnVuY3Rpb24odCxlKXt2YXIgcj1uKHQpO3JbMF0uam9pbihcIixcIikhPT1yW3IubGVuZ3RoLTFdLmpvaW4oXCIsXCIpJiZyLnB1c2goW3JbMF1bMF0sclswXVsxXV0pO3ZhciBhPVtdO2lmKHImJnIubGVuZ3RoPjIpe3ZhciBvPWUuaGFjaHVyZUdhcDtvPDAmJihvPTQqZS5zdHJva2VXaWR0aCksbz1NYXRoLm1heChvLC4xKTtmb3IodmFyIHM9W10saD0wO2g8ci5sZW5ndGgtMTtoKyspe3ZhciBpPXJbaF0sdT1yW2grMV07aWYoaVsxXSE9PXVbMV0pe3ZhciBwPU1hdGgubWluKGlbMV0sdVsxXSk7cy5wdXNoKHt5bWluOnAseW1heDpNYXRoLm1heChpWzFdLHVbMV0pLHg6cD09PWlbMV0/aVswXTp1WzBdLGlzbG9wZToodVswXS1pWzBdKS8odVsxXS1pWzFdKX0pfX1pZihzLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQueW1pbjxlLnltaW4/LTE6dC55bWluPmUueW1pbj8xOnQueDxlLng/LTE6dC54PmUueD8xOnQueW1heD09PWUueW1heD8wOih0LnltYXgtZS55bWF4KS9NYXRoLmFicyh0LnltYXgtZS55bWF4KX0pKSwhcy5sZW5ndGgpcmV0dXJuIGE7Zm9yKHZhciBjPVtdLGw9c1swXS55bWluO2MubGVuZ3RofHxzLmxlbmd0aDspe2lmKHMubGVuZ3RoKXt2YXIgZj0tMTtmb3IoaD0wO2g8cy5sZW5ndGgmJiEoc1toXS55bWluPmwpO2grKylmPWg7cy5zcGxpY2UoMCxmKzEpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2MucHVzaCh7czpsLGVkZ2U6dH0pfSkpfWlmKChjPWMuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hKHQuZWRnZS55bWF4PD1sKX0pKSkuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5lZGdlLng9PT1lLmVkZ2UueD8wOih0LmVkZ2UueC1lLmVkZ2UueCkvTWF0aC5hYnModC5lZGdlLngtZS5lZGdlLngpfSkpLGMubGVuZ3RoPjEpZm9yKGg9MDtoPGMubGVuZ3RoO2grPTIpe3ZhciBkPWgrMTtpZihkPj1jLmxlbmd0aClicmVhazt2YXIgZz1jW2hdLmVkZ2UseT1jW2RdLmVkZ2U7YS5wdXNoKFtbTWF0aC5yb3VuZChnLngpLGxdLFtNYXRoLnJvdW5kKHkueCksbF1dKX1sKz1vLGMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5lZGdlLng9dC5lZGdlLngrbyp0LmVkZ2UuaXNsb3BlfSkpfX1yZXR1cm4gYX0odCxlKTtyZXR1cm4gbyYmKHIodCxhLC1vKSxmdW5jdGlvbih0LGUsbil7dmFyIGE9W107dC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gYS5wdXNoLmFwcGx5KGEsdCl9KSkscihhLGUsbil9KHMsYSwtbykpLHN9dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaGVscGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2ZpbGxQb2x5Z29uKHQsZSl9LHQucHJvdG90eXBlLl9maWxsUG9seWdvbj1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPW8odCxlKTtyZXR1cm57dHlwZTpcImZpbGxTa2V0Y2hcIixvcHM6dGhpcy5yZW5kZXJMaW5lcyhyLGUsbil9fSx0LnByb3RvdHlwZS5yZW5kZXJMaW5lcz1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPVtdLGE9bnVsbCxvPTAscz10O288cy5sZW5ndGg7bysrKXt2YXIgaD1zW29dO3IucHVzaC5hcHBseShyLHRoaXMuaGVscGVyLmRvdWJsZUxpbmVPcHMoaFswXVswXSxoWzBdWzFdLGhbMV1bMF0saFsxXVsxXSxlKSksbiYmYSYmci5wdXNoLmFwcGx5KHIsdGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhhWzBdLGFbMV0saFswXVswXSxoWzBdWzFdLGUpKSxhPWhbMV19cmV0dXJuIHJ9LHR9KCksaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2ZpbGxQb2x5Z29uKHQsZSwhMCl9LG59KHMpLGk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbigpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5maWxsUG9seWdvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX2ZpbGxQb2x5Z29uKHQsZSkscj1PYmplY3QuYXNzaWduKHt9LGUse2hhY2h1cmVBbmdsZTplLmhhY2h1cmVBbmdsZSs5MH0pLGE9dGhpcy5fZmlsbFBvbHlnb24odCxyKTtyZXR1cm4gbi5vcHM9bi5vcHMuY29uY2F0KGEub3BzKSxufSxufShzKSx1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmhlbHBlcj10fXJldHVybiB0LnByb3RvdHlwZS5maWxsUG9seWdvbj1mdW5jdGlvbih0LGUpe3ZhciBuPW8odCxlPU9iamVjdC5hc3NpZ24oe30sZSx7Y3VydmVTdGVwQ291bnQ6NCxoYWNodXJlQW5nbGU6MCxyb3VnaG5lc3M6MX0pKTtyZXR1cm4gdGhpcy5kb3RzT25MaW5lcyhuLGUpfSx0LnByb3RvdHlwZS5kb3RzT25MaW5lcz1mdW5jdGlvbih0LGUpe3ZhciBuPVtdLHI9ZS5oYWNodXJlR2FwO3I8MCYmKHI9NCplLnN0cm9rZVdpZHRoKSxyPU1hdGgubWF4KHIsLjEpO3ZhciBvPWUuZmlsbFdlaWdodDtvPDAmJihvPWUuc3Ryb2tlV2lkdGgvMik7Zm9yKHZhciBzPXIvNCxoPTAsaT10O2g8aS5sZW5ndGg7aCsrKWZvcih2YXIgdT1pW2hdLHA9YSh1KSxjPXAvcixsPU1hdGguY2VpbChjKS0xLGY9cC1sKnIsZD0odVswXVswXSt1WzFdWzBdKS8yLXIvNCxnPU1hdGgubWluKHVbMF1bMV0sdVsxXVsxXSkseT0wO3k8bDt5Kyspe3ZhciB2PWcrZit5KnIsTT10aGlzLmhlbHBlci5yYW5kT2Zmc2V0V2l0aFJhbmdlKGQtcyxkK3MsZSksaz10aGlzLmhlbHBlci5yYW5kT2Zmc2V0V2l0aFJhbmdlKHYtcyx2K3MsZSksYj10aGlzLmhlbHBlci5lbGxpcHNlKE0sayxvLG8sZSk7bi5wdXNoLmFwcGx5KG4sYi5vcHMpfXJldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczpufX0sdH0oKSxwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmhlbHBlcj10fXJldHVybiB0LnByb3RvdHlwZS5maWxsUG9seWdvbj1mdW5jdGlvbih0LGUpe3ZhciBuPW8odCxlKTtyZXR1cm57dHlwZTpcImZpbGxTa2V0Y2hcIixvcHM6dGhpcy5kYXNoZWRMaW5lKG4sZSl9fSx0LnByb3RvdHlwZS5kYXNoZWRMaW5lPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcyxyPWUuZGFzaE9mZnNldDwwP2UuaGFjaHVyZUdhcDwwPzQqZS5zdHJva2VXaWR0aDplLmhhY2h1cmVHYXA6ZS5kYXNoT2Zmc2V0LG89ZS5kYXNoR2FwPDA/ZS5oYWNodXJlR2FwPDA/NCplLnN0cm9rZVdpZHRoOmUuaGFjaHVyZUdhcDplLmRhc2hHYXAscz1bXTtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgaD1hKHQpLGk9TWF0aC5mbG9vcihoLyhyK28pKSx1PShoK28taSoocitvKSkvMixwPXRbMF0sYz10WzFdO3BbMF0+Y1swXSYmKHA9dFsxXSxjPXRbMF0pO2Zvcih2YXIgbD1NYXRoLmF0YW4oKGNbMV0tcFsxXSkvKGNbMF0tcFswXSkpLGY9MDtmPGk7ZisrKXt2YXIgZD1mKihyK28pLGc9ZCtyLHk9W3BbMF0rZCpNYXRoLmNvcyhsKSt1Kk1hdGguY29zKGwpLHBbMV0rZCpNYXRoLnNpbihsKSt1Kk1hdGguc2luKGwpXSx2PVtwWzBdK2cqTWF0aC5jb3MobCkrdSpNYXRoLmNvcyhsKSxwWzFdK2cqTWF0aC5zaW4obCkrdSpNYXRoLnNpbihsKV07cy5wdXNoLmFwcGx5KHMsbi5oZWxwZXIuZG91YmxlTGluZU9wcyh5WzBdLHlbMV0sdlswXSx2WzFdLGUpKX19KSksc30sdH0oKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmhlbHBlcj10fXJldHVybiB0LnByb3RvdHlwZS5maWxsUG9seWdvbj1mdW5jdGlvbih0LGUpe3ZhciBuPWUuaGFjaHVyZUdhcDwwPzQqZS5zdHJva2VXaWR0aDplLmhhY2h1cmVHYXAscj1lLnppZ3phZ09mZnNldDwwP246ZS56aWd6YWdPZmZzZXQsYT1vKHQsZT1PYmplY3QuYXNzaWduKHt9LGUse2hhY2h1cmVHYXA6bityfSkpO3JldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczp0aGlzLnppZ3phZ0xpbmVzKGEscixlKX19LHQucHJvdG90eXBlLnppZ3phZ0xpbmVzPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbz10aGlzLHM9W107cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGg9YSh0KSxpPU1hdGgucm91bmQoaC8oMiplKSksdT10WzBdLHA9dFsxXTt1WzBdPnBbMF0mJih1PXRbMV0scD10WzBdKTtmb3IodmFyIGM9TWF0aC5hdGFuKChwWzFdLXVbMV0pLyhwWzBdLXVbMF0pKSxsPTA7bDxpO2wrKyl7dmFyIGY9MipsKmUsZD0yKihsKzEpKmUsZz1NYXRoLnNxcnQoMipNYXRoLnBvdyhlLDIpKSx5PVt1WzBdK2YqTWF0aC5jb3MoYyksdVsxXStmKk1hdGguc2luKGMpXSx2PVt1WzBdK2QqTWF0aC5jb3MoYyksdVsxXStkKk1hdGguc2luKGMpXSxNPVt5WzBdK2cqTWF0aC5jb3MoYytNYXRoLlBJLzQpLHlbMV0rZypNYXRoLnNpbihjK01hdGguUEkvNCldO3MucHVzaC5hcHBseShzLG4oby5oZWxwZXIuZG91YmxlTGluZU9wcyh5WzBdLHlbMV0sTVswXSxNWzFdLHIpLG8uaGVscGVyLmRvdWJsZUxpbmVPcHMoTVswXSxNWzFdLHZbMF0sdlsxXSxyKSkpfX0pKSxzfSx0fSgpLGw9e307dmFyIGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuc2VlZD10fXJldHVybiB0LnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VlZD8oTWF0aC5wb3coMiwzMSktMSYodGhpcy5zZWVkPU1hdGguaW11bCg0ODI3MSx0aGlzLnNlZWQpKSkvTWF0aC5wb3coMiwzMSk6TWF0aC5yYW5kb20oKX0sdH0oKTtjb25zdCBkPXtBOjcsYTo3LEM6NixjOjYsSDoxLGg6MSxMOjIsbDoyLE06MixtOjIsUTo0LHE6NCxTOjQsczo0LFQ6Mix0OjIsVjoxLHY6MSxaOjAsejowfTtmdW5jdGlvbiBnKHQsZSl7cmV0dXJuIHQudHlwZT09PWV9ZnVuY3Rpb24geSh0KXtjb25zdCBlPVtdLG49ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgQXJyYXk7Zm9yKDtcIlwiIT09dDspaWYodC5tYXRjaCgvXihbIFxcdFxcclxcbixdKykvKSl0PXQuc3Vic3RyKFJlZ0V4cC4kMS5sZW5ndGgpO2Vsc2UgaWYodC5tYXRjaCgvXihbYUFjQ2hIbExtTXFRc1N0VHZWelpdKS8pKWVbZS5sZW5ndGhdPXt0eXBlOjAsdGV4dDpSZWdFeHAuJDF9LHQ9dC5zdWJzdHIoUmVnRXhwLiQxLmxlbmd0aCk7ZWxzZXtpZighdC5tYXRjaCgvXigoWy0rXT9bMC05XSsoXFwuWzAtOV0qKT98Wy0rXT9cXC5bMC05XSspKFtlRV1bLStdP1swLTldKyk/KS8pKXJldHVybltdO2VbZS5sZW5ndGhdPXt0eXBlOjEsdGV4dDpcIlwiK3BhcnNlRmxvYXQoUmVnRXhwLiQxKX0sdD10LnN1YnN0cihSZWdFeHAuJDEubGVuZ3RoKX1yZXR1cm4gZVtlLmxlbmd0aF09e3R5cGU6Mix0ZXh0OlwiXCJ9LGV9KHQpO2xldCByPVwiQk9EXCIsYT0wLG89blthXTtmb3IoOyFnKG8sMik7KXtsZXQgcz0wO2NvbnN0IGg9W107aWYoXCJCT0RcIj09PXIpe2lmKFwiTVwiIT09by50ZXh0JiZcIm1cIiE9PW8udGV4dClyZXR1cm4geShcIk0wLDBcIit0KTthKysscz1kW28udGV4dF0scj1vLnRleHR9ZWxzZSBnKG8sMSk/cz1kW3JdOihhKysscz1kW28udGV4dF0scj1vLnRleHQpO2lmKCEoYStzPG4ubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGRhdGEgZW5kZWQgc2hvcnRcIik7Zm9yKGxldCB0PWE7dDxhK3M7dCsrKXtjb25zdCBlPW5bdF07aWYoIWcoZSwxKSl0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbSBub3QgYSBudW1iZXI6IFwiK3IrXCIsXCIrZS50ZXh0KTtoW2gubGVuZ3RoXT0rZS50ZXh0fWlmKFwibnVtYmVyXCIhPXR5cGVvZiBkW3JdKXRocm93IG5ldyBFcnJvcihcIkJhZCBzZWdtZW50OiBcIityKTt7Y29uc3QgdD17a2V5OnIsZGF0YTpofTtlLnB1c2godCksYSs9cyxvPW5bYV0sXCJNXCI9PT1yJiYocj1cIkxcIiksXCJtXCI9PT1yJiYocj1cImxcIil9fXJldHVybiBlfWZ1bmN0aW9uIHYodCl7bGV0IGU9MCxuPTAscj0wLGE9MDtjb25zdCBvPVtdO2Zvcihjb25zdHtrZXk6cyxkYXRhOmh9b2YgdClzd2l0Y2gocyl7Y2FzZVwiTVwiOm8ucHVzaCh7a2V5OlwiTVwiLGRhdGE6Wy4uLmhdfSksW2Usbl09aCxbcixhXT1oO2JyZWFrO2Nhc2VcIm1cIjplKz1oWzBdLG4rPWhbMV0sby5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbZSxuXX0pLHI9ZSxhPW47YnJlYWs7Y2FzZVwiTFwiOm8ucHVzaCh7a2V5OlwiTFwiLGRhdGE6Wy4uLmhdfSksW2Usbl09aDticmVhaztjYXNlXCJsXCI6ZSs9aFswXSxuKz1oWzFdLG8ucHVzaCh7a2V5OlwiTFwiLGRhdGE6W2Usbl19KTticmVhaztjYXNlXCJDXCI6by5wdXNoKHtrZXk6XCJDXCIsZGF0YTpbLi4uaF19KSxlPWhbNF0sbj1oWzVdO2JyZWFrO2Nhc2VcImNcIjp7Y29uc3QgdD1oLm1hcCgodCxyKT0+ciUyP3Qrbjp0K2UpO28ucHVzaCh7a2V5OlwiQ1wiLGRhdGE6dH0pLGU9dFs0XSxuPXRbNV07YnJlYWt9Y2FzZVwiUVwiOm8ucHVzaCh7a2V5OlwiUVwiLGRhdGE6Wy4uLmhdfSksZT1oWzJdLG49aFszXTticmVhaztjYXNlXCJxXCI6e2NvbnN0IHQ9aC5tYXAoKHQscik9PnIlMj90K246dCtlKTtvLnB1c2goe2tleTpcIlFcIixkYXRhOnR9KSxlPXRbMl0sbj10WzNdO2JyZWFrfWNhc2VcIkFcIjpvLnB1c2goe2tleTpcIkFcIixkYXRhOlsuLi5oXX0pLGU9aFs1XSxuPWhbNl07YnJlYWs7Y2FzZVwiYVwiOmUrPWhbNV0sbis9aFs2XSxvLnB1c2goe2tleTpcIkFcIixkYXRhOltoWzBdLGhbMV0saFsyXSxoWzNdLGhbNF0sZSxuXX0pO2JyZWFrO2Nhc2VcIkhcIjpvLnB1c2goe2tleTpcIkhcIixkYXRhOlsuLi5oXX0pLGU9aFswXTticmVhaztjYXNlXCJoXCI6ZSs9aFswXSxvLnB1c2goe2tleTpcIkhcIixkYXRhOltlXX0pO2JyZWFrO2Nhc2VcIlZcIjpvLnB1c2goe2tleTpcIlZcIixkYXRhOlsuLi5oXX0pLG49aFswXTticmVhaztjYXNlXCJ2XCI6bis9aFswXSxvLnB1c2goe2tleTpcIlZcIixkYXRhOltuXX0pO2JyZWFrO2Nhc2VcIlNcIjpvLnB1c2goe2tleTpcIlNcIixkYXRhOlsuLi5oXX0pLGU9aFsyXSxuPWhbM107YnJlYWs7Y2FzZVwic1wiOntjb25zdCB0PWgubWFwKCh0LHIpPT5yJTI/dCtuOnQrZSk7by5wdXNoKHtrZXk6XCJTXCIsZGF0YTp0fSksZT10WzJdLG49dFszXTticmVha31jYXNlXCJUXCI6by5wdXNoKHtrZXk6XCJUXCIsZGF0YTpbLi4uaF19KSxlPWhbMF0sbj1oWzFdO2JyZWFrO2Nhc2VcInRcIjplKz1oWzBdLG4rPWhbMV0sby5wdXNoKHtrZXk6XCJUXCIsZGF0YTpbZSxuXX0pO2JyZWFrO2Nhc2VcIlpcIjpjYXNlXCJ6XCI6by5wdXNoKHtrZXk6XCJaXCIsZGF0YTpbXX0pLGU9cixuPWF9cmV0dXJuIG99ZnVuY3Rpb24gTSh0KXtjb25zdCBlPVtdO2xldCBuPVwiXCIscj0wLGE9MCxvPTAscz0wLGg9MCxpPTA7Zm9yKGNvbnN0e2tleTp1LGRhdGE6cH1vZiB0KXtzd2l0Y2godSl7Y2FzZVwiTVwiOmUucHVzaCh7a2V5OlwiTVwiLGRhdGE6Wy4uLnBdfSksW3IsYV09cCxbbyxzXT1wO2JyZWFrO2Nhc2VcIkNcIjplLnB1c2goe2tleTpcIkNcIixkYXRhOlsuLi5wXX0pLHI9cFs0XSxhPXBbNV0saD1wWzJdLGk9cFszXTticmVhaztjYXNlXCJMXCI6ZS5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbLi4ucF19KSxbcixhXT1wO2JyZWFrO2Nhc2VcIkhcIjpyPXBbMF0sZS5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbcixhXX0pO2JyZWFrO2Nhc2VcIlZcIjphPXBbMF0sZS5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbcixhXX0pO2JyZWFrO2Nhc2VcIlNcIjp7bGV0IHQ9MCxvPTA7XCJDXCI9PT1ufHxcIlNcIj09PW4/KHQ9cisoci1oKSxvPWErKGEtaSkpOih0PXIsbz1hKSxlLnB1c2goe2tleTpcIkNcIixkYXRhOlt0LG8sLi4ucF19KSxoPXBbMF0saT1wWzFdLHI9cFsyXSxhPXBbM107YnJlYWt9Y2FzZVwiVFwiOntjb25zdFt0LG9dPXA7bGV0IHM9MCx1PTA7XCJRXCI9PT1ufHxcIlRcIj09PW4/KHM9cisoci1oKSx1PWErKGEtaSkpOihzPXIsdT1hKTtjb25zdCBjPXIrMioocy1yKS8zLGw9YSsyKih1LWEpLzMsZj10KzIqKHMtdCkvMyxkPW8rMioodS1vKS8zO2UucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W2MsbCxmLGQsdCxvXX0pLGg9cyxpPXUscj10LGE9bzticmVha31jYXNlXCJRXCI6e2NvbnN0W3QsbixvLHNdPXAsdT1yKzIqKHQtcikvMyxjPWErMioobi1hKS8zLGw9bysyKih0LW8pLzMsZj1zKzIqKG4tcykvMztlLnB1c2goe2tleTpcIkNcIixkYXRhOlt1LGMsbCxmLG8sc119KSxoPXQsaT1uLHI9byxhPXM7YnJlYWt9Y2FzZVwiQVwiOntjb25zdCB0PU1hdGguYWJzKHBbMF0pLG49TWF0aC5hYnMocFsxXSksbz1wWzJdLHM9cFszXSxoPXBbNF0saT1wWzVdLHU9cFs2XTtpZigwPT09dHx8MD09PW4pZS5wdXNoKHtrZXk6XCJDXCIsZGF0YTpbcixhLGksdSxpLHVdfSkscj1pLGE9dTtlbHNlIGlmKHIhPT1pfHxhIT09dSl7YihyLGEsaSx1LHQsbixvLHMsaCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZS5wdXNoKHtrZXk6XCJDXCIsZGF0YTp0fSl9KSkscj1pLGE9dX1icmVha31jYXNlXCJaXCI6ZS5wdXNoKHtrZXk6XCJaXCIsZGF0YTpbXX0pLHI9byxhPXN9bj11fXJldHVybiBlfWZ1bmN0aW9uIGsodCxlLG4pe3JldHVyblt0Kk1hdGguY29zKG4pLWUqTWF0aC5zaW4obiksdCpNYXRoLnNpbihuKStlKk1hdGguY29zKG4pXX1mdW5jdGlvbiBiKHQsZSxuLHIsYSxvLHMsaCxpLHUpe2NvbnN0IHA9KGM9cyxNYXRoLlBJKmMvMTgwKTt2YXIgYztsZXQgbD1bXSxmPTAsZD0wLGc9MCx5PTA7aWYodSlbZixkLGcseV09dTtlbHNle1t0LGVdPWsodCxlLC1wKSxbbixyXT1rKG4sciwtcCk7Y29uc3Qgcz0odC1uKS8yLHU9KGUtcikvMjtsZXQgYz1zKnMvKGEqYSkrdSp1LyhvKm8pO2M+MSYmKGM9TWF0aC5zcXJ0KGMpLGEqPWMsbyo9Yyk7Y29uc3QgbD1hKmEsdj1vKm8sTT1sKnYtbCp1KnUtdipzKnMsYj1sKnUqdSt2KnMqcyxtPShoPT09aT8tMToxKSpNYXRoLnNxcnQoTWF0aC5hYnMoTS9iKSk7Zz1tKmEqdS9vKyh0K24pLzIseT1tKi1vKnMvYSsoZStyKS8yLGY9TWF0aC5hc2luKHBhcnNlRmxvYXQoKChlLXkpL28pLnRvRml4ZWQoOSkpKSxkPU1hdGguYXNpbihwYXJzZUZsb2F0KCgoci15KS9vKS50b0ZpeGVkKDkpKSksdDxnJiYoZj1NYXRoLlBJLWYpLG48ZyYmKGQ9TWF0aC5QSS1kKSxmPDAmJihmPTIqTWF0aC5QSStmKSxkPDAmJihkPTIqTWF0aC5QSStkKSxpJiZmPmQmJihmLT0yKk1hdGguUEkpLCFpJiZkPmYmJihkLT0yKk1hdGguUEkpfWxldCB2PWQtZjtpZihNYXRoLmFicyh2KT4xMjAqTWF0aC5QSS8xODApe2NvbnN0IHQ9ZCxlPW4saD1yO2Q9aSYmZD5mP2YrMTIwKk1hdGguUEkvMTgwKjE6ZisxMjAqTWF0aC5QSS8xODAqLTEsbD1iKG49ZythKk1hdGguY29zKGQpLHI9eStvKk1hdGguc2luKGQpLGUsaCxhLG8scywwLGksW2QsdCxnLHldKX12PWQtZjtjb25zdCBNPU1hdGguY29zKGYpLG09TWF0aC5zaW4oZiksdz1NYXRoLmNvcyhkKSxQPU1hdGguc2luKGQpLHg9TWF0aC50YW4odi80KSxPPTQvMyphKngsUz00LzMqbyp4LFQ9W3QsZV0sXz1bdCtPKm0sZS1TKk1dLEM9W24rTypQLHItUyp3XSxXPVtuLHJdO2lmKF9bMF09MipUWzBdLV9bMF0sX1sxXT0yKlRbMV0tX1sxXSx1KXJldHVybltfLEMsV10uY29uY2F0KGwpO3tsPVtfLEMsV10uY29uY2F0KGwpO2NvbnN0IHQ9W107Zm9yKGxldCBlPTA7ZTxsLmxlbmd0aDtlKz0zKXtjb25zdCBuPWsobFtlXVswXSxsW2VdWzFdLHApLHI9ayhsW2UrMV1bMF0sbFtlKzFdWzFdLHApLGE9ayhsW2UrMl1bMF0sbFtlKzJdWzFdLHApO3QucHVzaChbblswXSxuWzFdLHJbMF0sclsxXSxhWzBdLGFbMV1dKX1yZXR1cm4gdH19dmFyIG09e3JhbmRPZmZzZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gRSh0LGUpfSxyYW5kT2Zmc2V0V2l0aFJhbmdlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTCh0LGUsbil9LGVsbGlwc2U6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgbz1PKG4scixhKTtyZXR1cm4gUyh0LGUsYSxvKS5vcHNldH0sZG91YmxlTGluZU9wczpmdW5jdGlvbih0LGUsbixyLGEpe3JldHVybiB6KHQsZSxuLHIsYSl9fTtmdW5jdGlvbiB3KHQsZSxuLHIsYSl7cmV0dXJue3R5cGU6XCJwYXRoXCIsb3BzOnoodCxlLG4scixhKX19ZnVuY3Rpb24gUCh0LGUsbil7dmFyIHI9KHR8fFtdKS5sZW5ndGg7aWYocj4yKXtmb3IodmFyIGE9W10sbz0wO288ci0xO28rKylhLnB1c2guYXBwbHkoYSx6KHRbb11bMF0sdFtvXVsxXSx0W28rMV1bMF0sdFtvKzFdWzFdLG4pKTtyZXR1cm4gZSYmYS5wdXNoLmFwcGx5KGEseih0W3ItMV1bMF0sdFtyLTFdWzFdLHRbMF1bMF0sdFswXVsxXSxuKSkse3R5cGU6XCJwYXRoXCIsb3BzOmF9fXJldHVybiAyPT09cj93KHRbMF1bMF0sdFswXVsxXSx0WzFdWzBdLHRbMV1bMV0sbik6e3R5cGU6XCJwYXRoXCIsb3BzOltdfX1mdW5jdGlvbiB4KHQsZSxuLHIsYSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7cmV0dXJuIFAodCwhMCxlKX0oW1t0LGVdLFt0K24sZV0sW3QrbixlK3JdLFt0LGUrcl1dLGEpfWZ1bmN0aW9uIE8odCxlLG4pe3ZhciByPU1hdGguc3FydCgyKk1hdGguUEkqTWF0aC5zcXJ0KChNYXRoLnBvdyh0LzIsMikrTWF0aC5wb3coZS8yLDIpKS8yKSksYT1NYXRoLm1heChuLmN1cnZlU3RlcENvdW50LG4uY3VydmVTdGVwQ291bnQvTWF0aC5zcXJ0KDIwMCkqciksbz0yKk1hdGguUEkvYSxzPU1hdGguYWJzKHQvMiksaD1NYXRoLmFicyhlLzIpLGk9MS1uLmN1cnZlRml0dGluZztyZXR1cm57aW5jcmVtZW50Om8scng6cys9RShzKmksbikscnk6aCs9RShoKmksbil9fWZ1bmN0aW9uIFModCxlLG4scil7dmFyIGE9RyhyLmluY3JlbWVudCx0LGUsci5yeCxyLnJ5LDEsci5pbmNyZW1lbnQqTCguMSxMKC40LDEsbiksbiksbiksbz1hWzBdLHM9YVsxXSxoPUcoci5pbmNyZW1lbnQsdCxlLHIucngsci5yeSwxLjUsMCxuKVswXSxpPXEobyxudWxsLG4pLHU9cShoLG51bGwsbik7cmV0dXJue2VzdGltYXRlZFBvaW50czpzLG9wc2V0Ont0eXBlOlwicGF0aFwiLG9wczppLmNvbmNhdCh1KX19fWZ1bmN0aW9uIFQodCxlLHIsYSxvLHMsaCxpLHUpe3ZhciBwPXQsYz1lLGw9TWF0aC5hYnMoci8yKSxmPU1hdGguYWJzKGEvMik7bCs9RSguMDEqbCx1KSxmKz1FKC4wMSpmLHUpO2Zvcih2YXIgZD1vLGc9cztkPDA7KWQrPTIqTWF0aC5QSSxnKz0yKk1hdGguUEk7Zy1kPjIqTWF0aC5QSSYmKGQ9MCxnPTIqTWF0aC5QSSk7dmFyIHk9MipNYXRoLlBJL3UuY3VydmVTdGVwQ291bnQsdj1NYXRoLm1pbih5LzIsKGctZCkvMiksTT1qKHYscCxjLGwsZixkLGcsMSx1KSxrPWoodixwLGMsbCxmLGQsZywxLjUsdSksYj1NLmNvbmNhdChrKTtyZXR1cm4gaCYmKGk/Yi5wdXNoLmFwcGx5KGIsbih6KHAsYyxwK2wqTWF0aC5jb3MoZCksYytmKk1hdGguc2luKGQpLHUpLHoocCxjLHArbCpNYXRoLmNvcyhnKSxjK2YqTWF0aC5zaW4oZyksdSkpKTpiLnB1c2goe29wOlwibGluZVRvXCIsZGF0YTpbcCxjXX0se29wOlwibGluZVRvXCIsZGF0YTpbcCtsKk1hdGguY29zKGQpLGMrZipNYXRoLnNpbihkKV19KSkse3R5cGU6XCJwYXRoXCIsb3BzOmJ9fWZ1bmN0aW9uIF8odCxlKXtmb3IodmFyIG49TSh2KHkodCkpKSxyPVtdLGE9WzAsMF0sbz1bMCwwXSxzPWZ1bmN0aW9uKHQsbil7c3dpdGNoKHQpe2Nhc2VcIk1cIjp2YXIgcz0xKihlLm1heFJhbmRvbW5lc3NPZmZzZXR8fDApO3IucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpuLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQrRShzLGUpfSkpfSksbz1bblswXSxuWzFdXSxhPVtuWzBdLG5bMV1dO2JyZWFrO2Nhc2VcIkxcIjpyLnB1c2guYXBwbHkocix6KG9bMF0sb1sxXSxuWzBdLG5bMV0sZSkpLG89W25bMF0sblsxXV07YnJlYWs7Y2FzZVwiQ1wiOnZhciBoPW5bMF0saT1uWzFdLHU9blsyXSxwPW5bM10sYz1uWzRdLGw9bls1XTtyLnB1c2guYXBwbHkocixmdW5jdGlvbih0LGUsbixyLGEsbyxzLGgpe2Zvcih2YXIgaT1bXSx1PVtoLm1heFJhbmRvbW5lc3NPZmZzZXR8fDEsKGgubWF4UmFuZG9tbmVzc09mZnNldHx8MSkrLjNdLHA9WzAsMF0sYz0wO2M8MjtjKyspMD09PWM/aS5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOltzWzBdLHNbMV1dfSk6aS5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOltzWzBdK0UodVswXSxoKSxzWzFdK0UodVswXSxoKV19KSxwPVthK0UodVtjXSxoKSxvK0UodVtjXSxoKV0saS5wdXNoKHtvcDpcImJjdXJ2ZVRvXCIsZGF0YTpbdCtFKHVbY10saCksZStFKHVbY10saCksbitFKHVbY10saCkscitFKHVbY10saCkscFswXSxwWzFdXX0pO3JldHVybiBpfShoLGksdSxwLGMsbCxvLGUpKSxvPVtjLGxdO2JyZWFrO2Nhc2VcIlpcIjpyLnB1c2guYXBwbHkocix6KG9bMF0sb1sxXSxhWzBdLGFbMV0sZSkpLG89W2FbMF0sYVsxXV19fSxoPTAsaT1uO2g8aS5sZW5ndGg7aCsrKXt2YXIgdT1pW2hdO3ModS5rZXksdS5kYXRhKX1yZXR1cm57dHlwZTpcInBhdGhcIixvcHM6cn19ZnVuY3Rpb24gQyh0LGUpe3ZhciBuPVtdO2lmKHQubGVuZ3RoKXt2YXIgcj1lLm1heFJhbmRvbW5lc3NPZmZzZXR8fDAsYT10Lmxlbmd0aDtpZihhPjIpe24ucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdFswXVswXStFKHIsZSksdFswXVsxXStFKHIsZSldfSk7Zm9yKHZhciBvPTE7bzxhO28rKyluLnB1c2goe29wOlwibGluZVRvXCIsZGF0YTpbdFtvXVswXStFKHIsZSksdFtvXVsxXStFKHIsZSldfSl9fXJldHVybnt0eXBlOlwiZmlsbFBhdGhcIixvcHM6bn19ZnVuY3Rpb24gVyh0LGUpe3JldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPXQuZmlsbFN0eWxlfHxcImhhY2h1cmVcIjtpZighbFtuXSlzd2l0Y2gobil7Y2FzZVwiemlnemFnXCI6bFtuXXx8KGxbbl09bmV3IGgoZSkpO2JyZWFrO2Nhc2VcImNyb3NzLWhhdGNoXCI6bFtuXXx8KGxbbl09bmV3IGkoZSkpO2JyZWFrO2Nhc2VcImRvdHNcIjpsW25dfHwobFtuXT1uZXcgdShlKSk7YnJlYWs7Y2FzZVwiZGFzaGVkXCI6bFtuXXx8KGxbbl09bmV3IHAoZSkpO2JyZWFrO2Nhc2VcInppZ3phZy1saW5lXCI6bFtuXXx8KGxbbl09bmV3IGMoZSkpO2JyZWFrO2Nhc2VcImhhY2h1cmVcIjpkZWZhdWx0Omxbbj1cImhhY2h1cmVcIl18fChsW25dPW5ldyBzKGUpKX1yZXR1cm4gbFtuXX0oZSxtKS5maWxsUG9seWdvbih0LGUpfWZ1bmN0aW9uIEkodCl7cmV0dXJuIHQucmFuZG9taXplcnx8KHQucmFuZG9taXplcj1uZXcgZih0LnNlZWR8fDApKSx0LnJhbmRvbWl6ZXIubmV4dCgpfWZ1bmN0aW9uIEwodCxlLG4scil7cmV0dXJuIHZvaWQgMD09PXImJihyPTEpLG4ucm91Z2huZXNzKnIqKEkobikqKGUtdCkrdCl9ZnVuY3Rpb24gRSh0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTEpLEwoLXQsdCxlLG4pfWZ1bmN0aW9uIHoodCxlLG4scixhKXt2YXIgbz1BKHQsZSxuLHIsYSwhMCwhMSkscz1BKHQsZSxuLHIsYSwhMCwhMCk7cmV0dXJuIG8uY29uY2F0KHMpfWZ1bmN0aW9uIEEodCxlLG4scixhLG8scyl7dmFyIGg9TWF0aC5wb3codC1uLDIpK01hdGgucG93KGUtciwyKSxpPU1hdGguc3FydChoKSx1PTE7dT1pPDIwMD8xOmk+NTAwPy40Oi0uMDAxNjY2OCppKzEuMjMzMzM0O3ZhciBwPWEubWF4UmFuZG9tbmVzc09mZnNldHx8MDtwKnAqMTAwPmgmJihwPWkvMTApO3ZhciBjPXAvMixsPS4yKy4yKkkoYSksZj1hLmJvd2luZyphLm1heFJhbmRvbW5lc3NPZmZzZXQqKHItZSkvMjAwLGQ9YS5ib3dpbmcqYS5tYXhSYW5kb21uZXNzT2Zmc2V0Kih0LW4pLzIwMDtmPUUoZixhLHUpLGQ9RShkLGEsdSk7dmFyIGc9W10seT1mdW5jdGlvbigpe3JldHVybiBFKGMsYSx1KX0sdj1mdW5jdGlvbigpe3JldHVybiBFKHAsYSx1KX07cmV0dXJuIG8mJihzP2cucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdCt5KCksZSt5KCldfSk6Zy5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0K0UocCxhLHUpLGUrRShwLGEsdSldfSkpLHM/Zy5wdXNoKHtvcDpcImJjdXJ2ZVRvXCIsZGF0YTpbZit0KyhuLXQpKmwreSgpLGQrZSsoci1lKSpsK3koKSxmK3QrMioobi10KSpsK3koKSxkK2UrMiooci1lKSpsK3koKSxuK3koKSxyK3koKV19KTpnLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOltmK3QrKG4tdCkqbCt2KCksZCtlKyhyLWUpKmwrdigpLGYrdCsyKihuLXQpKmwrdigpLGQrZSsyKihyLWUpKmwrdigpLG4rdigpLHIrdigpXX0pLGd9ZnVuY3Rpb24gUih0LGUsbil7dmFyIHI9W107ci5wdXNoKFt0WzBdWzBdK0UoZSxuKSx0WzBdWzFdK0UoZSxuKV0pLHIucHVzaChbdFswXVswXStFKGUsbiksdFswXVsxXStFKGUsbildKTtmb3IodmFyIGE9MTthPHQubGVuZ3RoO2ErKylyLnB1c2goW3RbYV1bMF0rRShlLG4pLHRbYV1bMV0rRShlLG4pXSksYT09PXQubGVuZ3RoLTEmJnIucHVzaChbdFthXVswXStFKGUsbiksdFthXVsxXStFKGUsbildKTtyZXR1cm4gcShyLG51bGwsbil9ZnVuY3Rpb24gcSh0LGUsbil7dmFyIHI9dC5sZW5ndGgsYT1bXTtpZihyPjMpe3ZhciBvPVtdLHM9MS1uLmN1cnZlVGlnaHRuZXNzO2EucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdFsxXVswXSx0WzFdWzFdXX0pO2Zvcih2YXIgaD0xO2grMjxyO2grKyl7dmFyIGk9dFtoXTtvWzBdPVtpWzBdLGlbMV1dLG9bMV09W2lbMF0rKHMqdFtoKzFdWzBdLXMqdFtoLTFdWzBdKS82LGlbMV0rKHMqdFtoKzFdWzFdLXMqdFtoLTFdWzFdKS82XSxvWzJdPVt0W2grMV1bMF0rKHMqdFtoXVswXS1zKnRbaCsyXVswXSkvNix0W2grMV1bMV0rKHMqdFtoXVsxXS1zKnRbaCsyXVsxXSkvNl0sb1szXT1bdFtoKzFdWzBdLHRbaCsxXVsxXV0sYS5wdXNoKHtvcDpcImJjdXJ2ZVRvXCIsZGF0YTpbb1sxXVswXSxvWzFdWzFdLG9bMl1bMF0sb1syXVsxXSxvWzNdWzBdLG9bM11bMV1dfSl9aWYoZSYmMj09PWUubGVuZ3RoKXt2YXIgdT1uLm1heFJhbmRvbW5lc3NPZmZzZXQ7YS5wdXNoKHtvcDpcImxpbmVUb1wiLGRhdGE6W2VbMF0rRSh1LG4pLGVbMV0rRSh1LG4pXX0pfX1lbHNlIDM9PT1yPyhhLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3RbMV1bMF0sdFsxXVsxXV19KSxhLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOlt0WzFdWzBdLHRbMV1bMV0sdFsyXVswXSx0WzJdWzFdLHRbMl1bMF0sdFsyXVsxXV19KSk6Mj09PXImJmEucHVzaC5hcHBseShhLHoodFswXVswXSx0WzBdWzFdLHRbMV1bMF0sdFsxXVsxXSxuKSk7cmV0dXJuIGF9ZnVuY3Rpb24gRyh0LGUsbixyLGEsbyxzLGgpe3ZhciBpPVtdLHU9W10scD1FKC41LGgpLU1hdGguUEkvMjt1LnB1c2goW0UobyxoKStlKy45KnIqTWF0aC5jb3MocC10KSxFKG8saCkrbisuOSphKk1hdGguc2luKHAtdCldKTtmb3IodmFyIGM9cDtjPDIqTWF0aC5QSStwLS4wMTtjKz10KXt2YXIgbD1bRShvLGgpK2UrcipNYXRoLmNvcyhjKSxFKG8saCkrbithKk1hdGguc2luKGMpXTtpLnB1c2gobCksdS5wdXNoKGwpfXJldHVybiB1LnB1c2goW0UobyxoKStlK3IqTWF0aC5jb3MocCsyKk1hdGguUEkrLjUqcyksRShvLGgpK24rYSpNYXRoLnNpbihwKzIqTWF0aC5QSSsuNSpzKV0pLHUucHVzaChbRShvLGgpK2UrLjk4KnIqTWF0aC5jb3MocCtzKSxFKG8saCkrbisuOTgqYSpNYXRoLnNpbihwK3MpXSksdS5wdXNoKFtFKG8saCkrZSsuOSpyKk1hdGguY29zKHArLjUqcyksRShvLGgpK24rLjkqYSpNYXRoLnNpbihwKy41KnMpXSksW3UsaV19ZnVuY3Rpb24gaih0LGUsbixyLGEsbyxzLGgsaSl7dmFyIHU9bytFKC4xLGkpLHA9W107cC5wdXNoKFtFKGgsaSkrZSsuOSpyKk1hdGguY29zKHUtdCksRShoLGkpK24rLjkqYSpNYXRoLnNpbih1LXQpXSk7Zm9yKHZhciBjPXU7Yzw9cztjKz10KXAucHVzaChbRShoLGkpK2UrcipNYXRoLmNvcyhjKSxFKGgsaSkrbithKk1hdGguc2luKGMpXSk7cmV0dXJuIHAucHVzaChbZStyKk1hdGguY29zKHMpLG4rYSpNYXRoLnNpbihzKV0pLHAucHVzaChbZStyKk1hdGguY29zKHMpLG4rYSpNYXRoLnNpbihzKV0pLHEocCxudWxsLGkpfWZ1bmN0aW9uIFoodCl7cmV0dXJuWy4uLnRdfWZ1bmN0aW9uIEQodCxlKXtyZXR1cm4gTWF0aC5wb3codFswXS1lWzBdLDIpK01hdGgucG93KHRbMV0tZVsxXSwyKX1mdW5jdGlvbiBGKHQsZSxuKXtjb25zdCByPUQoZSxuKTtpZigwPT09cilyZXR1cm4gRCh0LGUpO2xldCBhPSgodFswXS1lWzBdKSooblswXS1lWzBdKSsodFsxXS1lWzFdKSooblsxXS1lWzFdKSkvcjtyZXR1cm4gYT1NYXRoLm1heCgwLE1hdGgubWluKDEsYSkpLEQodCxRKGUsbixhKSl9ZnVuY3Rpb24gUSh0LGUsbil7cmV0dXJuW3RbMF0rKGVbMF0tdFswXSkqbix0WzFdKyhlWzFdLXRbMV0pKm5dfWZ1bmN0aW9uIEgodCxlLG4scil7Y29uc3QgYT1yfHxbXTtpZihmdW5jdGlvbih0LGUpe2NvbnN0IG49dFtlKzBdLHI9dFtlKzFdLGE9dFtlKzJdLG89dFtlKzNdO2xldCBzPTMqclswXS0yKm5bMF0tb1swXTtzKj1zO2xldCBoPTMqclsxXS0yKm5bMV0tb1sxXTtoKj1oO2xldCBpPTMqYVswXS0yKm9bMF0tblswXTtpKj1pO2xldCB1PTMqYVsxXS0yKm9bMV0tblsxXTtyZXR1cm4gdSo9dSxzPGkmJihzPWkpLGg8dSYmKGg9dSkscytofSh0LGUpPG4pe2NvbnN0IG49dFtlKzBdO2lmKGEubGVuZ3RoKXsobz1hW2EubGVuZ3RoLTFdLHM9bixNYXRoLnNxcnQoRChvLHMpKSk+MSYmYS5wdXNoKG4pfWVsc2UgYS5wdXNoKG4pO2EucHVzaCh0W2UrM10pfWVsc2V7Y29uc3Qgcj0uNSxvPXRbZSswXSxzPXRbZSsxXSxoPXRbZSsyXSxpPXRbZSszXSx1PVEobyxzLHIpLHA9UShzLGgsciksYz1RKGgsaSxyKSxsPVEodSxwLHIpLGY9UShwLGMsciksZD1RKGwsZixyKTtIKFtvLHUsbCxkXSwwLG4sYSksSChbZCxmLGMsaV0sMCxuLGEpfXZhciBvLHM7cmV0dXJuIGF9ZnVuY3Rpb24gTih0LGUpe3JldHVybiBWKHQsMCx0Lmxlbmd0aCxlKX1mdW5jdGlvbiBWKHQsZSxuLHIsYSl7Y29uc3Qgbz1hfHxbXSxzPXRbZV0saD10W24tMV07bGV0IGk9MCx1PTE7Zm9yKGxldCByPWUrMTtyPG4tMTsrK3Ipe2NvbnN0IGU9Rih0W3JdLHMsaCk7ZT5pJiYoaT1lLHU9cil9cmV0dXJuIE1hdGguc3FydChpKT5yPyhWKHQsZSx1KzEscixvKSxWKHQsdSxuLHIsbykpOihvLmxlbmd0aHx8by5wdXNoKHMpLG8ucHVzaChoKSksb31mdW5jdGlvbiAkKHQsZT0uMTUsbil7Y29uc3Qgcj1bXSxhPSh0Lmxlbmd0aC0xKS8zO2ZvcihsZXQgbj0wO248YTtuKyspe0godCwzKm4sZSxyKX1yZXR1cm4gbiYmbj4wP1YociwwLHIubGVuZ3RoLG4pOnJ9dmFyIEI9XCJub25lXCIsSj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5kZWZhdWx0T3B0aW9ucz17bWF4UmFuZG9tbmVzc09mZnNldDoyLHJvdWdobmVzczoxLGJvd2luZzoxLHN0cm9rZTpcIiMwMDBcIixzdHJva2VXaWR0aDoxLGN1cnZlVGlnaHRuZXNzOjAsY3VydmVGaXR0aW5nOi45NSxjdXJ2ZVN0ZXBDb3VudDo5LGZpbGxTdHlsZTpcImhhY2h1cmVcIixmaWxsV2VpZ2h0Oi0xLGhhY2h1cmVBbmdsZTotNDEsaGFjaHVyZUdhcDotMSxkYXNoT2Zmc2V0Oi0xLGRhc2hHYXA6LTEsemlnemFnT2Zmc2V0Oi0xLHNlZWQ6MCxjb21iaW5lTmVzdGVkU3ZnUGF0aHM6ITF9LHRoaXMuY29uZmlnPXR8fHt9LHRoaXMuY29uZmlnLm9wdGlvbnMmJih0aGlzLmRlZmF1bHRPcHRpb25zPXRoaXMuX28odGhpcy5jb25maWcub3B0aW9ucykpfXJldHVybiB0Lm5ld1NlZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKk1hdGgucG93KDIsMzEpKX0sdC5wcm90b3R5cGUuX289ZnVuY3Rpb24odCl7cmV0dXJuIHQ/T2JqZWN0LmFzc2lnbih7fSx0aGlzLmRlZmF1bHRPcHRpb25zLHQpOnRoaXMuZGVmYXVsdE9wdGlvbnN9LHQucHJvdG90eXBlLl9kPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm57c2hhcGU6dCxzZXRzOmV8fFtdLG9wdGlvbnM6bnx8dGhpcy5kZWZhdWx0T3B0aW9uc319LHQucHJvdG90eXBlLmxpbmU9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgbz10aGlzLl9vKGEpO3JldHVybiB0aGlzLl9kKFwibGluZVwiLFt3KHQsZSxuLHIsbyldLG8pfSx0LnByb3RvdHlwZS5yZWN0YW5nbGU9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgbz10aGlzLl9vKGEpLHM9W10saD14KHQsZSxuLHIsbyk7aWYoby5maWxsKXt2YXIgaT1bW3QsZV0sW3QrbixlXSxbdCtuLGUrcl0sW3QsZStyXV07XCJzb2xpZFwiPT09by5maWxsU3R5bGU/cy5wdXNoKEMoaSxvKSk6cy5wdXNoKFcoaSxvKSl9cmV0dXJuIG8uc3Ryb2tlIT09QiYmcy5wdXNoKGgpLHRoaXMuX2QoXCJyZWN0YW5nbGVcIixzLG8pfSx0LnByb3RvdHlwZS5lbGxpcHNlPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5fbyhhKSxzPVtdLGg9TyhuLHIsbyksaT1TKHQsZSxvLGgpO2lmKG8uZmlsbClpZihcInNvbGlkXCI9PT1vLmZpbGxTdHlsZSl7dmFyIHU9Uyh0LGUsbyxoKS5vcHNldDt1LnR5cGU9XCJmaWxsUGF0aFwiLHMucHVzaCh1KX1lbHNlIHMucHVzaChXKGkuZXN0aW1hdGVkUG9pbnRzLG8pKTtyZXR1cm4gby5zdHJva2UhPT1CJiZzLnB1c2goaS5vcHNldCksdGhpcy5fZChcImVsbGlwc2VcIixzLG8pfSx0LnByb3RvdHlwZS5jaXJjbGU9ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9dGhpcy5lbGxpcHNlKHQsZSxuLG4scik7cmV0dXJuIGEuc2hhcGU9XCJjaXJjbGVcIixhfSx0LnByb3RvdHlwZS5saW5lYXJQYXRoPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fbyhlKTtyZXR1cm4gdGhpcy5fZChcImxpbmVhclBhdGhcIixbUCh0LCExLG4pXSxuKX0sdC5wcm90b3R5cGUuYXJjPWZ1bmN0aW9uKHQsZSxuLHIsYSxvLHMsaCl7dm9pZCAwPT09cyYmKHM9ITEpO3ZhciBpPXRoaXMuX28oaCksdT1bXSxwPVQodCxlLG4scixhLG8scywhMCxpKTtpZihzJiZpLmZpbGwpaWYoXCJzb2xpZFwiPT09aS5maWxsU3R5bGUpe3ZhciBjPVQodCxlLG4scixhLG8sITAsITEsaSk7Yy50eXBlPVwiZmlsbFBhdGhcIix1LnB1c2goYyl9ZWxzZSB1LnB1c2goZnVuY3Rpb24odCxlLG4scixhLG8scyl7dmFyIGg9dCxpPWUsdT1NYXRoLmFicyhuLzIpLHA9TWF0aC5hYnMoci8yKTt1Kz1FKC4wMSp1LHMpLHArPUUoLjAxKnAscyk7Zm9yKHZhciBjPWEsbD1vO2M8MDspYys9MipNYXRoLlBJLGwrPTIqTWF0aC5QSTtsLWM+MipNYXRoLlBJJiYoYz0wLGw9MipNYXRoLlBJKTtmb3IodmFyIGY9KGwtYykvcy5jdXJ2ZVN0ZXBDb3VudCxkPVtdLGc9YztnPD1sO2crPWYpZC5wdXNoKFtoK3UqTWF0aC5jb3MoZyksaStwKk1hdGguc2luKGcpXSk7cmV0dXJuIGQucHVzaChbaCt1Kk1hdGguY29zKGwpLGkrcCpNYXRoLnNpbihsKV0pLGQucHVzaChbaCxpXSksVyhkLHMpfSh0LGUsbixyLGEsbyxpKSk7cmV0dXJuIGkuc3Ryb2tlIT09QiYmdS5wdXNoKHApLHRoaXMuX2QoXCJhcmNcIix1LGkpfSx0LnByb3RvdHlwZS5jdXJ2ZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX28oZSkscj1bXSxhPWZ1bmN0aW9uKHQsZSl7dmFyIG49Uih0LDEqKDErLjIqZS5yb3VnaG5lc3MpLGUpLHI9Uih0LDEuNSooMSsuMjIqZS5yb3VnaG5lc3MpLGUpO3JldHVybnt0eXBlOlwicGF0aFwiLG9wczpuLmNvbmNhdChyKX19KHQsbik7aWYobi5maWxsJiZuLmZpbGwhPT1CJiZ0Lmxlbmd0aD49Myl7dmFyIG89JChmdW5jdGlvbih0LGU9MCl7Y29uc3Qgbj10Lmxlbmd0aDtpZihuPDMpdGhyb3cgbmV3IEVycm9yKFwiQSBjdXJ2ZSBtdXN0IGhhdmUgYXQgbGVhc3QgdGhyZWUgcG9pbnRzLlwiKTtjb25zdCByPVtdO2lmKDM9PT1uKXIucHVzaChaKHRbMF0pLFoodFsxXSksWih0WzJdKSxaKHRbMl0pKTtlbHNle2NvbnN0IG49W107bi5wdXNoKHRbMF0sdFswXSk7Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDtlKyspbi5wdXNoKHRbZV0pLGU9PT10Lmxlbmd0aC0xJiZuLnB1c2godFtlXSk7Y29uc3QgYT1bXSxvPTEtZTtyLnB1c2goWihuWzBdKSk7Zm9yKGxldCB0PTE7dCsyPG4ubGVuZ3RoO3QrKyl7Y29uc3QgZT1uW3RdO2FbMF09W2VbMF0sZVsxXV0sYVsxXT1bZVswXSsobypuW3QrMV1bMF0tbypuW3QtMV1bMF0pLzYsZVsxXSsobypuW3QrMV1bMV0tbypuW3QtMV1bMV0pLzZdLGFbMl09W25bdCsxXVswXSsobypuW3RdWzBdLW8qblt0KzJdWzBdKS82LG5bdCsxXVsxXSsobypuW3RdWzFdLW8qblt0KzJdWzFdKS82XSxhWzNdPVtuW3QrMV1bMF0sblt0KzFdWzFdXSxyLnB1c2goYVsxXSxhWzJdLGFbM10pfX1yZXR1cm4gcn0odCksMTAsKDErbi5yb3VnaG5lc3MpLzIpO1wic29saWRcIj09PW4uZmlsbFN0eWxlP3IucHVzaChDKG8sbikpOnIucHVzaChXKG8sbikpfXJldHVybiBuLnN0cm9rZSE9PUImJnIucHVzaChhKSx0aGlzLl9kKFwiY3VydmVcIixyLG4pfSx0LnByb3RvdHlwZS5wb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fbyhlKSxyPVtdLGE9UCh0LCEwLG4pO3JldHVybiBuLmZpbGwmJihcInNvbGlkXCI9PT1uLmZpbGxTdHlsZT9yLnB1c2goQyh0LG4pKTpyLnB1c2goVyh0LG4pKSksbi5zdHJva2UhPT1CJiZyLnB1c2goYSksdGhpcy5fZChcInBvbHlnb25cIixyLG4pfSx0LnByb3RvdHlwZS5wYXRoPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fbyhlKSxyPVtdO2lmKCF0KXJldHVybiB0aGlzLl9kKFwicGF0aFwiLHIsbik7dD0odHx8XCJcIikucmVwbGFjZSgvXFxuL2csXCIgXCIpLnJlcGxhY2UoLygtXFxzKS9nLFwiLVwiKS5yZXBsYWNlKFwiLyhzcykvZ1wiLFwiIFwiKTt2YXIgYT1uLmZpbGwmJlwidHJhbnNwYXJlbnRcIiE9PW4uZmlsbCYmbi5maWxsIT09QixvPW4uc3Ryb2tlIT09QixzPSEhKG4uc2ltcGxpZmljYXRpb24mJm4uc2ltcGxpZmljYXRpb248MSksaD1mdW5jdGlvbih0LGUsbil7Y29uc3Qgcj1NKHYoeSh0KSkpLGE9W107bGV0IG89W10scz1bMCwwXSxoPVtdO2NvbnN0IGk9KCk9PntoLmxlbmd0aD49NCYmby5wdXNoKC4uLiQoaCxlKSksaD1bXX0sdT0oKT0+e2koKSxvLmxlbmd0aCYmKGEucHVzaChvKSxvPVtdKX07Zm9yKGNvbnN0e2tleTp0LGRhdGE6ZX1vZiByKXN3aXRjaCh0KXtjYXNlXCJNXCI6dSgpLHM9W2VbMF0sZVsxXV0sby5wdXNoKHMpO2JyZWFrO2Nhc2VcIkxcIjppKCksby5wdXNoKFtlWzBdLGVbMV1dKTticmVhaztjYXNlXCJDXCI6aWYoIWgubGVuZ3RoKXtjb25zdCB0PW8ubGVuZ3RoP29bby5sZW5ndGgtMV06cztoLnB1c2goW3RbMF0sdFsxXV0pfWgucHVzaChbZVswXSxlWzFdXSksaC5wdXNoKFtlWzJdLGVbM11dKSxoLnB1c2goW2VbNF0sZVs1XV0pO2JyZWFrO2Nhc2VcIlpcIjppKCksby5wdXNoKFtzWzBdLHNbMV1dKX1pZih1KCksIW4pcmV0dXJuIGE7Y29uc3QgcD1bXTtmb3IoY29uc3QgdCBvZiBhKXtjb25zdCBlPU4odCxuKTtlLmxlbmd0aCYmcC5wdXNoKGUpfXJldHVybiBwfSh0LDEscz80LTQqbi5zaW1wbGlmaWNhdGlvbjooMStuLnJvdWdobmVzcykvMik7aWYoYSlpZihuLmNvbWJpbmVOZXN0ZWRTdmdQYXRocyl7dmFyIGk9W107aC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gaS5wdXNoLmFwcGx5KGksdCl9KSksXCJzb2xpZFwiPT09bi5maWxsU3R5bGU/ci5wdXNoKEMoaSxuKSk6ci5wdXNoKFcoaSxuKSl9ZWxzZSBoLmZvckVhY2goKGZ1bmN0aW9uKHQpe1wic29saWRcIj09PW4uZmlsbFN0eWxlP3IucHVzaChDKHQsbikpOnIucHVzaChXKHQsbikpfSkpO3JldHVybiBvJiYocz9oLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IucHVzaChQKHQsITEsbikpfSkpOnIucHVzaChfKHQsbikpKSx0aGlzLl9kKFwicGF0aFwiLHIsbil9LHQucHJvdG90eXBlLm9wc1RvUGF0aD1mdW5jdGlvbih0KXtmb3IodmFyIGU9XCJcIixuPTAscj10Lm9wcztuPHIubGVuZ3RoO24rKyl7dmFyIGE9cltuXSxvPWEuZGF0YTtzd2l0Y2goYS5vcCl7Y2FzZVwibW92ZVwiOmUrPVwiTVwiK29bMF0rXCIgXCIrb1sxXStcIiBcIjticmVhaztjYXNlXCJiY3VydmVUb1wiOmUrPVwiQ1wiK29bMF0rXCIgXCIrb1sxXStcIiwgXCIrb1syXStcIiBcIitvWzNdK1wiLCBcIitvWzRdK1wiIFwiK29bNV0rXCIgXCI7YnJlYWs7Y2FzZVwibGluZVRvXCI6ZSs9XCJMXCIrb1swXStcIiBcIitvWzFdK1wiIFwifX1yZXR1cm4gZS50cmltKCl9LHQucHJvdG90eXBlLnRvUGF0aHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc2V0c3x8W10sbj10Lm9wdGlvbnN8fHRoaXMuZGVmYXVsdE9wdGlvbnMscj1bXSxhPTAsbz1lO2E8by5sZW5ndGg7YSsrKXt2YXIgcz1vW2FdLGg9bnVsbDtzd2l0Y2gocy50eXBlKXtjYXNlXCJwYXRoXCI6aD17ZDp0aGlzLm9wc1RvUGF0aChzKSxzdHJva2U6bi5zdHJva2Usc3Ryb2tlV2lkdGg6bi5zdHJva2VXaWR0aCxmaWxsOkJ9O2JyZWFrO2Nhc2VcImZpbGxQYXRoXCI6aD17ZDp0aGlzLm9wc1RvUGF0aChzKSxzdHJva2U6QixzdHJva2VXaWR0aDowLGZpbGw6bi5maWxsfHxCfTticmVhaztjYXNlXCJmaWxsU2tldGNoXCI6aD10aGlzLmZpbGxTa2V0Y2gocyxuKX1oJiZyLnB1c2goaCl9cmV0dXJuIHJ9LHQucHJvdG90eXBlLmZpbGxTa2V0Y2g9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLmZpbGxXZWlnaHQ7cmV0dXJuIG48MCYmKG49ZS5zdHJva2VXaWR0aC8yKSx7ZDp0aGlzLm9wc1RvUGF0aCh0KSxzdHJva2U6ZS5maWxsfHxCLHN0cm9rZVdpZHRoOm4sZmlsbDpCfX0sdH0oKSxLPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMuY2FudmFzPXQsdGhpcy5jdHg9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLHRoaXMuZ2VuPW5ldyBKKGUpfXJldHVybiB0LnByb3RvdHlwZS5kcmF3PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnNldHN8fFtdLG49dC5vcHRpb25zfHx0aGlzLmdldERlZmF1bHRPcHRpb25zKCkscj10aGlzLmN0eCxhPTAsbz1lO2E8by5sZW5ndGg7YSsrKXt2YXIgcz1vW2FdO3N3aXRjaChzLnR5cGUpe2Nhc2VcInBhdGhcIjpyLnNhdmUoKSxyLnN0cm9rZVN0eWxlPVwibm9uZVwiPT09bi5zdHJva2U/XCJ0cmFuc3BhcmVudFwiOm4uc3Ryb2tlLHIubGluZVdpZHRoPW4uc3Ryb2tlV2lkdGgsdGhpcy5fZHJhd1RvQ29udGV4dChyLHMpLHIucmVzdG9yZSgpO2JyZWFrO2Nhc2VcImZpbGxQYXRoXCI6ci5zYXZlKCksci5maWxsU3R5bGU9bi5maWxsfHxcIlwiO3ZhciBoPVwiY3VydmVcIj09PXQuc2hhcGV8fFwicG9seWdvblwiPT09dC5zaGFwZT9cImV2ZW5vZGRcIjpcIm5vbnplcm9cIjt0aGlzLl9kcmF3VG9Db250ZXh0KHIscyxoKSxyLnJlc3RvcmUoKTticmVhaztjYXNlXCJmaWxsU2tldGNoXCI6dGhpcy5maWxsU2tldGNoKHIscyxuKX19fSx0LnByb3RvdHlwZS5maWxsU2tldGNoPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uLmZpbGxXZWlnaHQ7cjwwJiYocj1uLnN0cm9rZVdpZHRoLzIpLHQuc2F2ZSgpLHQuc3Ryb2tlU3R5bGU9bi5maWxsfHxcIlwiLHQubGluZVdpZHRoPXIsdGhpcy5fZHJhd1RvQ29udGV4dCh0LGUpLHQucmVzdG9yZSgpfSx0LnByb3RvdHlwZS5fZHJhd1RvQ29udGV4dD1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49XCJub256ZXJvXCIpLHQuYmVnaW5QYXRoKCk7Zm9yKHZhciByPTAsYT1lLm9wcztyPGEubGVuZ3RoO3IrKyl7dmFyIG89YVtyXSxzPW8uZGF0YTtzd2l0Y2goby5vcCl7Y2FzZVwibW92ZVwiOnQubW92ZVRvKHNbMF0sc1sxXSk7YnJlYWs7Y2FzZVwiYmN1cnZlVG9cIjp0LmJlemllckN1cnZlVG8oc1swXSxzWzFdLHNbMl0sc1szXSxzWzRdLHNbNV0pO2JyZWFrO2Nhc2VcImxpbmVUb1wiOnQubGluZVRvKHNbMF0sc1sxXSl9fVwiZmlsbFBhdGhcIj09PWUudHlwZT90LmZpbGwobik6dC5zdHJva2UoKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZ2VuZXJhdG9yXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXREZWZhdWx0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdlbi5kZWZhdWx0T3B0aW9uc30sdC5wcm90b3R5cGUubGluZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuZ2VuLmxpbmUodCxlLG4scixhKTtyZXR1cm4gdGhpcy5kcmF3KG8pLG99LHQucHJvdG90eXBlLnJlY3RhbmdsZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuZ2VuLnJlY3RhbmdsZSh0LGUsbixyLGEpO3JldHVybiB0aGlzLmRyYXcobyksb30sdC5wcm90b3R5cGUuZWxsaXBzZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuZ2VuLmVsbGlwc2UodCxlLG4scixhKTtyZXR1cm4gdGhpcy5kcmF3KG8pLG99LHQucHJvdG90eXBlLmNpcmNsZT1mdW5jdGlvbih0LGUsbixyKXt2YXIgYT10aGlzLmdlbi5jaXJjbGUodCxlLG4scik7cmV0dXJuIHRoaXMuZHJhdyhhKSxhfSx0LnByb3RvdHlwZS5saW5lYXJQYXRoPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4ubGluZWFyUGF0aCh0LGUpO3JldHVybiB0aGlzLmRyYXcobiksbn0sdC5wcm90b3R5cGUucG9seWdvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2VuLnBvbHlnb24odCxlKTtyZXR1cm4gdGhpcy5kcmF3KG4pLG59LHQucHJvdG90eXBlLmFyYz1mdW5jdGlvbih0LGUsbixyLGEsbyxzLGgpe3ZvaWQgMD09PXMmJihzPSExKTt2YXIgaT10aGlzLmdlbi5hcmModCxlLG4scixhLG8scyxoKTtyZXR1cm4gdGhpcy5kcmF3KGkpLGl9LHQucHJvdG90eXBlLmN1cnZlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4uY3VydmUodCxlKTtyZXR1cm4gdGhpcy5kcmF3KG4pLG59LHQucHJvdG90eXBlLnBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5wYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKSxufSx0fSgpLFU9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5zdmc9dCx0aGlzLmdlbj1uZXcgSihlKX1yZXR1cm4gdC5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5zZXRzfHxbXSxuPXQub3B0aW9uc3x8dGhpcy5nZXREZWZhdWx0T3B0aW9ucygpLHI9dGhpcy5zdmcub3duZXJEb2N1bWVudHx8d2luZG93LmRvY3VtZW50LGE9ci5jcmVhdGVFbGVtZW50TlMoVSxcImdcIiksbz0wLHM9ZTtvPHMubGVuZ3RoO28rKyl7dmFyIGg9c1tvXSxpPW51bGw7c3dpdGNoKGgudHlwZSl7Y2FzZVwicGF0aFwiOihpPXIuY3JlYXRlRWxlbWVudE5TKFUsXCJwYXRoXCIpKS5zZXRBdHRyaWJ1dGUoXCJkXCIsdGhpcy5vcHNUb1BhdGgoaCkpLGkuc3R5bGUuc3Ryb2tlPW4uc3Ryb2tlLGkuc3R5bGUuc3Ryb2tlV2lkdGg9bi5zdHJva2VXaWR0aCtcIlwiLGkuc3R5bGUuZmlsbD1cIm5vbmVcIjticmVhaztjYXNlXCJmaWxsUGF0aFwiOihpPXIuY3JlYXRlRWxlbWVudE5TKFUsXCJwYXRoXCIpKS5zZXRBdHRyaWJ1dGUoXCJkXCIsdGhpcy5vcHNUb1BhdGgoaCkpLGkuc3R5bGUuc3Ryb2tlPVwibm9uZVwiLGkuc3R5bGUuc3Ryb2tlV2lkdGg9XCIwXCIsaS5zdHlsZS5maWxsPW4uZmlsbHx8XCJcIjticmVhaztjYXNlXCJmaWxsU2tldGNoXCI6aT10aGlzLmZpbGxTa2V0Y2gocixoLG4pfWkmJmEuYXBwZW5kQ2hpbGQoaSl9cmV0dXJuIGF9LHQucHJvdG90eXBlLmZpbGxTa2V0Y2g9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW4uZmlsbFdlaWdodDtyPDAmJihyPW4uc3Ryb2tlV2lkdGgvMik7dmFyIGE9dC5jcmVhdGVFbGVtZW50TlMoVSxcInBhdGhcIik7cmV0dXJuIGEuc2V0QXR0cmlidXRlKFwiZFwiLHRoaXMub3BzVG9QYXRoKGUpKSxhLnN0eWxlLnN0cm9rZT1uLmZpbGx8fFwiXCIsYS5zdHlsZS5zdHJva2VXaWR0aD1yK1wiXCIsYS5zdHlsZS5maWxsPVwibm9uZVwiLGF9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImdlbmVyYXRvclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW59LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0RGVmYXVsdE9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW4uZGVmYXVsdE9wdGlvbnN9LHQucHJvdG90eXBlLm9wc1RvUGF0aD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW4ub3BzVG9QYXRoKHQpfSx0LnByb3RvdHlwZS5saW5lPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5nZW4ubGluZSh0LGUsbixyLGEpO3JldHVybiB0aGlzLmRyYXcobyl9LHQucHJvdG90eXBlLnJlY3RhbmdsZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuZ2VuLnJlY3RhbmdsZSh0LGUsbixyLGEpO3JldHVybiB0aGlzLmRyYXcobyl9LHQucHJvdG90eXBlLmVsbGlwc2U9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgbz10aGlzLmdlbi5lbGxpcHNlKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhvKX0sdC5wcm90b3R5cGUuY2lyY2xlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPXRoaXMuZ2VuLmNpcmNsZSh0LGUsbixyKTtyZXR1cm4gdGhpcy5kcmF3KGEpfSx0LnByb3RvdHlwZS5saW5lYXJQYXRoPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4ubGluZWFyUGF0aCh0LGUpO3JldHVybiB0aGlzLmRyYXcobil9LHQucHJvdG90eXBlLnBvbHlnb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5wb2x5Z29uKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKX0sdC5wcm90b3R5cGUuYXJjPWZ1bmN0aW9uKHQsZSxuLHIsYSxvLHMsaCl7dm9pZCAwPT09cyYmKHM9ITEpO3ZhciBpPXRoaXMuZ2VuLmFyYyh0LGUsbixyLGEsbyxzLGgpO3JldHVybiB0aGlzLmRyYXcoaSl9LHQucHJvdG90eXBlLmN1cnZlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4uY3VydmUodCxlKTtyZXR1cm4gdGhpcy5kcmF3KG4pfSx0LnByb3RvdHlwZS5wYXRoPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4ucGF0aCh0LGUpO3JldHVybiB0aGlzLmRyYXcobil9LHR9KCksWT17Y2FudmFzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBLKHQsZSl9LHN2ZzpmdW5jdGlvbih0LGUpe3JldHVybiBuZXcgWCh0LGUpfSxnZW5lcmF0b3I6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBKKHQpfSxuZXdTZWVkOmZ1bmN0aW9uKCl7cmV0dXJuIEoubmV3U2VlZCgpfX07bW9kdWxlLmV4cG9ydHM9WTtcbiIsIi8qXG4gKiBBIGZhc3QgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBzaW1wbGV4IG5vaXNlIGJ5IEpvbmFzIFdhZ25lclxuXG5CYXNlZCBvbiBhIHNwZWVkLWltcHJvdmVkIHNpbXBsZXggbm9pc2UgYWxnb3JpdGhtIGZvciAyRCwgM0QgYW5kIDREIGluIEphdmEuXG5XaGljaCBpcyBiYXNlZCBvbiBleGFtcGxlIGNvZGUgYnkgU3RlZmFuIEd1c3RhdnNvbiAoc3RlZ3VAaXRuLmxpdS5zZSkuXG5XaXRoIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxuQmV0dGVyIHJhbmsgb3JkZXJpbmcgbWV0aG9kIGJ5IFN0ZWZhbiBHdXN0YXZzb24gaW4gMjAxMi5cblxuXG4gQ29weXJpZ2h0IChjKSAyMDE4IEpvbmFzIFdhZ25lclxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBGMiA9IDAuNSAqIChNYXRoLnNxcnQoMy4wKSAtIDEuMCk7XG4gIHZhciBHMiA9ICgzLjAgLSBNYXRoLnNxcnQoMy4wKSkgLyA2LjA7XG4gIHZhciBGMyA9IDEuMCAvIDMuMDtcbiAgdmFyIEczID0gMS4wIC8gNi4wO1xuICB2YXIgRjQgPSAoTWF0aC5zcXJ0KDUuMCkgLSAxLjApIC8gNC4wO1xuICB2YXIgRzQgPSAoNS4wIC0gTWF0aC5zcXJ0KDUuMCkpIC8gMjAuMDtcblxuICBmdW5jdGlvbiBTaW1wbGV4Tm9pc2UocmFuZG9tT3JTZWVkKSB7XG4gICAgdmFyIHJhbmRvbTtcbiAgICBpZiAodHlwZW9mIHJhbmRvbU9yU2VlZCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByYW5kb20gPSByYW5kb21PclNlZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmRvbU9yU2VlZCkge1xuICAgICAgcmFuZG9tID0gYWxlYShyYW5kb21PclNlZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5kb20gPSBNYXRoLnJhbmRvbTtcbiAgICB9XG4gICAgdGhpcy5wID0gYnVpbGRQZXJtdXRhdGlvblRhYmxlKHJhbmRvbSk7XG4gICAgdGhpcy5wZXJtID0gbmV3IFVpbnQ4QXJyYXkoNTEyKTtcbiAgICB0aGlzLnBlcm1Nb2QxMiA9IG5ldyBVaW50OEFycmF5KDUxMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MTI7IGkrKykge1xuICAgICAgdGhpcy5wZXJtW2ldID0gdGhpcy5wW2kgJiAyNTVdO1xuICAgICAgdGhpcy5wZXJtTW9kMTJbaV0gPSB0aGlzLnBlcm1baV0gJSAxMjtcbiAgICB9XG5cbiAgfVxuICBTaW1wbGV4Tm9pc2UucHJvdG90eXBlID0ge1xuICAgIGdyYWQzOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwLFxuICAgICAgLTEsIDEsIDAsXG4gICAgICAxLCAtMSwgMCxcblxuICAgICAgLTEsIC0xLCAwLFxuICAgICAgMSwgMCwgMSxcbiAgICAgIC0xLCAwLCAxLFxuXG4gICAgICAxLCAwLCAtMSxcbiAgICAgIC0xLCAwLCAtMSxcbiAgICAgIDAsIDEsIDEsXG5cbiAgICAgIDAsIC0xLCAxLFxuICAgICAgMCwgMSwgLTEsXG4gICAgICAwLCAtMSwgLTFdKSxcbiAgICBncmFkNDogbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMSwgMSwgMCwgMSwgMSwgLTEsIDAsIDEsIC0xLCAxLCAwLCAxLCAtMSwgLTEsXG4gICAgICAwLCAtMSwgMSwgMSwgMCwgLTEsIDEsIC0xLCAwLCAtMSwgLTEsIDEsIDAsIC0xLCAtMSwgLTEsXG4gICAgICAxLCAwLCAxLCAxLCAxLCAwLCAxLCAtMSwgMSwgMCwgLTEsIDEsIDEsIDAsIC0xLCAtMSxcbiAgICAgIC0xLCAwLCAxLCAxLCAtMSwgMCwgMSwgLTEsIC0xLCAwLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSxcbiAgICAgIDEsIDEsIDAsIDEsIDEsIDEsIDAsIC0xLCAxLCAtMSwgMCwgMSwgMSwgLTEsIDAsIC0xLFxuICAgICAgLTEsIDEsIDAsIDEsIC0xLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIC0xLFxuICAgICAgMSwgMSwgMSwgMCwgMSwgMSwgLTEsIDAsIDEsIC0xLCAxLCAwLCAxLCAtMSwgLTEsIDAsXG4gICAgICAtMSwgMSwgMSwgMCwgLTEsIDEsIC0xLCAwLCAtMSwgLTEsIDEsIDAsIC0xLCAtMSwgLTEsIDBdKSxcbiAgICBub2lzZTJEOiBmdW5jdGlvbih4aW4sIHlpbikge1xuICAgICAgdmFyIHBlcm1Nb2QxMiA9IHRoaXMucGVybU1vZDEyO1xuICAgICAgdmFyIHBlcm0gPSB0aGlzLnBlcm07XG4gICAgICB2YXIgZ3JhZDMgPSB0aGlzLmdyYWQzO1xuICAgICAgdmFyIG4wID0gMDsgLy8gTm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG4gICAgICB2YXIgbjEgPSAwO1xuICAgICAgdmFyIG4yID0gMDtcbiAgICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cbiAgICAgIHZhciBzID0gKHhpbiArIHlpbikgKiBGMjsgLy8gSGFpcnkgZmFjdG9yIGZvciAyRFxuICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xuICAgICAgdmFyIGogPSBNYXRoLmZsb29yKHlpbiArIHMpO1xuICAgICAgdmFyIHQgPSAoaSArIGopICogRzI7XG4gICAgICB2YXIgWDAgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkpIHNwYWNlXG4gICAgICB2YXIgWTAgPSBqIC0gdDtcbiAgICAgIHZhciB4MCA9IHhpbiAtIFgwOyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICAgICAgdmFyIHkwID0geWluIC0gWTA7XG4gICAgICAvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLlxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuICAgICAgdmFyIGkxLCBqMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIChtaWRkbGUpIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGopIGNvb3Jkc1xuICAgICAgaWYgKHgwID4geTApIHtcbiAgICAgICAgaTEgPSAxO1xuICAgICAgICBqMSA9IDA7XG4gICAgICB9IC8vIGxvd2VyIHRyaWFuZ2xlLCBYWSBvcmRlcjogKDAsMCktPigxLDApLT4oMSwxKVxuICAgICAgZWxzZSB7XG4gICAgICAgIGkxID0gMDtcbiAgICAgICAgajEgPSAxO1xuICAgICAgfSAvLyB1cHBlciB0cmlhbmdsZSwgWVggb3JkZXI6ICgwLDApLT4oMCwxKS0+KDEsMSlcbiAgICAgIC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZFxuICAgICAgLy8gYSBzdGVwIG9mICgwLDEpIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jKSBpbiAoeCx5KSwgd2hlcmVcbiAgICAgIC8vIGMgPSAoMy1zcXJ0KDMpKS82XG4gICAgICB2YXIgeDEgPSB4MCAtIGkxICsgRzI7IC8vIE9mZnNldHMgZm9yIG1pZGRsZSBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG4gICAgICB2YXIgeTEgPSB5MCAtIGoxICsgRzI7XG4gICAgICB2YXIgeDIgPSB4MCAtIDEuMCArIDIuMCAqIEcyOyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcbiAgICAgIHZhciB5MiA9IHkwIC0gMS4wICsgMi4wICogRzI7XG4gICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIHRocmVlIHNpbXBsZXggY29ybmVyc1xuICAgICAgdmFyIGlpID0gaSAmIDI1NTtcbiAgICAgIHZhciBqaiA9IGogJiAyNTU7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG4gICAgICB2YXIgdDAgPSAwLjUgLSB4MCAqIHgwIC0geTAgKiB5MDtcbiAgICAgIGlmICh0MCA+PSAwKSB7XG4gICAgICAgIHZhciBnaTAgPSBwZXJtTW9kMTJbaWkgKyBwZXJtW2pqXV0gKiAzO1xuICAgICAgICB0MCAqPSB0MDtcbiAgICAgICAgbjAgPSB0MCAqIHQwICogKGdyYWQzW2dpMF0gKiB4MCArIGdyYWQzW2dpMCArIDFdICogeTApOyAvLyAoeCx5KSBvZiBncmFkMyB1c2VkIGZvciAyRCBncmFkaWVudFxuICAgICAgfVxuICAgICAgdmFyIHQxID0gMC41IC0geDEgKiB4MSAtIHkxICogeTE7XG4gICAgICBpZiAodDEgPj0gMCkge1xuICAgICAgICB2YXIgZ2kxID0gcGVybU1vZDEyW2lpICsgaTEgKyBwZXJtW2pqICsgajFdXSAqIDM7XG4gICAgICAgIHQxICo9IHQxO1xuICAgICAgICBuMSA9IHQxICogdDEgKiAoZ3JhZDNbZ2kxXSAqIHgxICsgZ3JhZDNbZ2kxICsgMV0gKiB5MSk7XG4gICAgICB9XG4gICAgICB2YXIgdDIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MjtcbiAgICAgIGlmICh0MiA+PSAwKSB7XG4gICAgICAgIHZhciBnaTIgPSBwZXJtTW9kMTJbaWkgKyAxICsgcGVybVtqaiArIDFdXSAqIDM7XG4gICAgICAgIHQyICo9IHQyO1xuICAgICAgICBuMiA9IHQyICogdDIgKiAoZ3JhZDNbZ2kyXSAqIHgyICsgZ3JhZDNbZ2kyICsgMV0gKiB5Mik7XG4gICAgICB9XG4gICAgICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXG4gICAgICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byByZXR1cm4gdmFsdWVzIGluIHRoZSBpbnRlcnZhbCBbLTEsMV0uXG4gICAgICByZXR1cm4gNzAuMCAqIChuMCArIG4xICsgbjIpO1xuICAgIH0sXG4gICAgLy8gM0Qgc2ltcGxleCBub2lzZVxuICAgIG5vaXNlM0Q6IGZ1bmN0aW9uKHhpbiwgeWluLCB6aW4pIHtcbiAgICAgIHZhciBwZXJtTW9kMTIgPSB0aGlzLnBlcm1Nb2QxMjtcbiAgICAgIHZhciBwZXJtID0gdGhpcy5wZXJtO1xuICAgICAgdmFyIGdyYWQzID0gdGhpcy5ncmFkMztcbiAgICAgIHZhciBuMCwgbjEsIG4yLCBuMzsgLy8gTm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcbiAgICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cbiAgICAgIHZhciBzID0gKHhpbiArIHlpbiArIHppbikgKiBGMzsgLy8gVmVyeSBuaWNlIGFuZCBzaW1wbGUgc2tldyBmYWN0b3IgZm9yIDNEXG4gICAgICB2YXIgaSA9IE1hdGguZmxvb3IoeGluICsgcyk7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gICAgICB2YXIgayA9IE1hdGguZmxvb3IoemluICsgcyk7XG4gICAgICB2YXIgdCA9IChpICsgaiArIGspICogRzM7XG4gICAgICB2YXIgWDAgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseikgc3BhY2VcbiAgICAgIHZhciBZMCA9IGogLSB0O1xuICAgICAgdmFyIFowID0gayAtIHQ7XG4gICAgICB2YXIgeDAgPSB4aW4gLSBYMDsgLy8gVGhlIHgseSx6IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICAgICAgdmFyIHkwID0geWluIC0gWTA7XG4gICAgICB2YXIgejAgPSB6aW4gLSBaMDtcbiAgICAgIC8vIEZvciB0aGUgM0QgY2FzZSwgdGhlIHNpbXBsZXggc2hhcGUgaXMgYSBzbGlnaHRseSBpcnJlZ3VsYXIgdGV0cmFoZWRyb24uXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG4gICAgICB2YXIgaTEsIGoxLCBrMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXG4gICAgICB2YXIgaTIsIGoyLCBrMjsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcbiAgICAgIGlmICh4MCA+PSB5MCkge1xuICAgICAgICBpZiAoeTAgPj0gejApIHtcbiAgICAgICAgICBpMSA9IDE7XG4gICAgICAgICAgajEgPSAwO1xuICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICBpMiA9IDE7XG4gICAgICAgICAgajIgPSAxO1xuICAgICAgICAgIGsyID0gMDtcbiAgICAgICAgfSAvLyBYIFkgWiBvcmRlclxuICAgICAgICBlbHNlIGlmICh4MCA+PSB6MCkge1xuICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgazEgPSAwO1xuICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICBqMiA9IDA7XG4gICAgICAgICAgazIgPSAxO1xuICAgICAgICB9IC8vIFggWiBZIG9yZGVyXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgazEgPSAxO1xuICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICBqMiA9IDA7XG4gICAgICAgICAgazIgPSAxO1xuICAgICAgICB9IC8vIFogWCBZIG9yZGVyXG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8geDA8eTBcbiAgICAgICAgaWYgKHkwIDwgejApIHtcbiAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgajEgPSAwO1xuICAgICAgICAgIGsxID0gMTtcbiAgICAgICAgICBpMiA9IDA7XG4gICAgICAgICAgajIgPSAxO1xuICAgICAgICAgIGsyID0gMTtcbiAgICAgICAgfSAvLyBaIFkgWCBvcmRlclxuICAgICAgICBlbHNlIGlmICh4MCA8IHowKSB7XG4gICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgIGoxID0gMTtcbiAgICAgICAgICBrMSA9IDA7XG4gICAgICAgICAgaTIgPSAwO1xuICAgICAgICAgIGoyID0gMTtcbiAgICAgICAgICBrMiA9IDE7XG4gICAgICAgIH0gLy8gWSBaIFggb3JkZXJcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgIGoxID0gMTtcbiAgICAgICAgICBrMSA9IDA7XG4gICAgICAgICAgaTIgPSAxO1xuICAgICAgICAgIGoyID0gMTtcbiAgICAgICAgICBrMiA9IDA7XG4gICAgICAgIH0gLy8gWSBYIFogb3JkZXJcbiAgICAgIH1cbiAgICAgIC8vIEEgc3RlcCBvZiAoMSwwLDApIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgxLWMsLWMsLWMpIGluICh4LHkseiksXG4gICAgICAvLyBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmRcbiAgICAgIC8vIGEgc3RlcCBvZiAoMCwwLDEpIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgtYywtYywxLWMpIGluICh4LHkseiksIHdoZXJlXG4gICAgICAvLyBjID0gMS82LlxuICAgICAgdmFyIHgxID0geDAgLSBpMSArIEczOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gICAgICB2YXIgeTEgPSB5MCAtIGoxICsgRzM7XG4gICAgICB2YXIgejEgPSB6MCAtIGsxICsgRzM7XG4gICAgICB2YXIgeDIgPSB4MCAtIGkyICsgMi4wICogRzM7IC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xuICAgICAgdmFyIHkyID0geTAgLSBqMiArIDIuMCAqIEczO1xuICAgICAgdmFyIHoyID0gejAgLSBrMiArIDIuMCAqIEczO1xuICAgICAgdmFyIHgzID0geDAgLSAxLjAgKyAzLjAgKiBHMzsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgICAgIHZhciB5MyA9IHkwIC0gMS4wICsgMy4wICogRzM7XG4gICAgICB2YXIgejMgPSB6MCAtIDEuMCArIDMuMCAqIEczO1xuICAgICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xuICAgICAgdmFyIGlpID0gaSAmIDI1NTtcbiAgICAgIHZhciBqaiA9IGogJiAyNTU7XG4gICAgICB2YXIga2sgPSBrICYgMjU1O1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZm91ciBjb3JuZXJzXG4gICAgICB2YXIgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XG4gICAgICBpZiAodDAgPCAwKSBuMCA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kwID0gcGVybU1vZDEyW2lpICsgcGVybVtqaiArIHBlcm1ba2tdXV0gKiAzO1xuICAgICAgICB0MCAqPSB0MDtcbiAgICAgICAgbjAgPSB0MCAqIHQwICogKGdyYWQzW2dpMF0gKiB4MCArIGdyYWQzW2dpMCArIDFdICogeTAgKyBncmFkM1tnaTAgKyAyXSAqIHowKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MSA9IDAuNiAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MTtcbiAgICAgIGlmICh0MSA8IDApIG4xID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTEgPSBwZXJtTW9kMTJbaWkgKyBpMSArIHBlcm1bamogKyBqMSArIHBlcm1ba2sgKyBrMV1dXSAqIDM7XG4gICAgICAgIHQxICo9IHQxO1xuICAgICAgICBuMSA9IHQxICogdDEgKiAoZ3JhZDNbZ2kxXSAqIHgxICsgZ3JhZDNbZ2kxICsgMV0gKiB5MSArIGdyYWQzW2dpMSArIDJdICogejEpO1xuICAgICAgfVxuICAgICAgdmFyIHQyID0gMC42IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyO1xuICAgICAgaWYgKHQyIDwgMCkgbjIgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMiA9IHBlcm1Nb2QxMltpaSArIGkyICsgcGVybVtqaiArIGoyICsgcGVybVtrayArIGsyXV1dICogMztcbiAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgIG4yID0gdDIgKiB0MiAqIChncmFkM1tnaTJdICogeDIgKyBncmFkM1tnaTIgKyAxXSAqIHkyICsgZ3JhZDNbZ2kyICsgMl0gKiB6Mik7XG4gICAgICB9XG4gICAgICB2YXIgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XG4gICAgICBpZiAodDMgPCAwKSBuMyA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kzID0gcGVybU1vZDEyW2lpICsgMSArIHBlcm1bamogKyAxICsgcGVybVtrayArIDFdXV0gKiAzO1xuICAgICAgICB0MyAqPSB0MztcbiAgICAgICAgbjMgPSB0MyAqIHQzICogKGdyYWQzW2dpM10gKiB4MyArIGdyYWQzW2dpMyArIDFdICogeTMgKyBncmFkM1tnaTMgKyAyXSAqIHozKTtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgICAgIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHN0YXkganVzdCBpbnNpZGUgWy0xLDFdXG4gICAgICByZXR1cm4gMzIuMCAqIChuMCArIG4xICsgbjIgKyBuMyk7XG4gICAgfSxcbiAgICAvLyA0RCBzaW1wbGV4IG5vaXNlLCBiZXR0ZXIgc2ltcGxleCByYW5rIG9yZGVyaW5nIG1ldGhvZCAyMDEyLTAzLTA5XG4gICAgbm9pc2U0RDogZnVuY3Rpb24oeCwgeSwgeiwgdykge1xuICAgICAgdmFyIHBlcm0gPSB0aGlzLnBlcm07XG4gICAgICB2YXIgZ3JhZDQgPSB0aGlzLmdyYWQ0O1xuXG4gICAgICB2YXIgbjAsIG4xLCBuMiwgbjMsIG40OyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZpdmUgY29ybmVyc1xuICAgICAgLy8gU2tldyB0aGUgKHgseSx6LHcpIHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBjZWxsIG9mIDI0IHNpbXBsaWNlcyB3ZSdyZSBpblxuICAgICAgdmFyIHMgPSAoeCArIHkgKyB6ICsgdykgKiBGNDsgLy8gRmFjdG9yIGZvciA0RCBza2V3aW5nXG4gICAgICB2YXIgaSA9IE1hdGguZmxvb3IoeCArIHMpO1xuICAgICAgdmFyIGogPSBNYXRoLmZsb29yKHkgKyBzKTtcbiAgICAgIHZhciBrID0gTWF0aC5mbG9vcih6ICsgcyk7XG4gICAgICB2YXIgbCA9IE1hdGguZmxvb3IodyArIHMpO1xuICAgICAgdmFyIHQgPSAoaSArIGogKyBrICsgbCkgKiBHNDsgLy8gRmFjdG9yIGZvciA0RCB1bnNrZXdpbmdcbiAgICAgIHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6LHcpIHNwYWNlXG4gICAgICB2YXIgWTAgPSBqIC0gdDtcbiAgICAgIHZhciBaMCA9IGsgLSB0O1xuICAgICAgdmFyIFcwID0gbCAtIHQ7XG4gICAgICB2YXIgeDAgPSB4IC0gWDA7IC8vIFRoZSB4LHkseix3IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICAgICAgdmFyIHkwID0geSAtIFkwO1xuICAgICAgdmFyIHowID0geiAtIFowO1xuICAgICAgdmFyIHcwID0gdyAtIFcwO1xuICAgICAgLy8gRm9yIHRoZSA0RCBjYXNlLCB0aGUgc2ltcGxleCBpcyBhIDREIHNoYXBlIEkgd29uJ3QgZXZlbiB0cnkgdG8gZGVzY3JpYmUuXG4gICAgICAvLyBUbyBmaW5kIG91dCB3aGljaCBvZiB0aGUgMjQgcG9zc2libGUgc2ltcGxpY2VzIHdlJ3JlIGluLCB3ZSBuZWVkIHRvXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIG1hZ25pdHVkZSBvcmRlcmluZyBvZiB4MCwgeTAsIHowIGFuZCB3MC5cbiAgICAgIC8vIFNpeCBwYWlyLXdpc2UgY29tcGFyaXNvbnMgYXJlIHBlcmZvcm1lZCBiZXR3ZWVuIGVhY2ggcG9zc2libGUgcGFpclxuICAgICAgLy8gb2YgdGhlIGZvdXIgY29vcmRpbmF0ZXMsIGFuZCB0aGUgcmVzdWx0cyBhcmUgdXNlZCB0byByYW5rIHRoZSBudW1iZXJzLlxuICAgICAgdmFyIHJhbmt4ID0gMDtcbiAgICAgIHZhciByYW5reSA9IDA7XG4gICAgICB2YXIgcmFua3ogPSAwO1xuICAgICAgdmFyIHJhbmt3ID0gMDtcbiAgICAgIGlmICh4MCA+IHkwKSByYW5reCsrO1xuICAgICAgZWxzZSByYW5reSsrO1xuICAgICAgaWYgKHgwID4gejApIHJhbmt4Kys7XG4gICAgICBlbHNlIHJhbmt6Kys7XG4gICAgICBpZiAoeDAgPiB3MCkgcmFua3grKztcbiAgICAgIGVsc2UgcmFua3crKztcbiAgICAgIGlmICh5MCA+IHowKSByYW5reSsrO1xuICAgICAgZWxzZSByYW5reisrO1xuICAgICAgaWYgKHkwID4gdzApIHJhbmt5Kys7XG4gICAgICBlbHNlIHJhbmt3Kys7XG4gICAgICBpZiAoejAgPiB3MCkgcmFua3orKztcbiAgICAgIGVsc2UgcmFua3crKztcbiAgICAgIHZhciBpMSwgajEsIGsxLCBsMTsgLy8gVGhlIGludGVnZXIgb2Zmc2V0cyBmb3IgdGhlIHNlY29uZCBzaW1wbGV4IGNvcm5lclxuICAgICAgdmFyIGkyLCBqMiwgazIsIGwyOyAvLyBUaGUgaW50ZWdlciBvZmZzZXRzIGZvciB0aGUgdGhpcmQgc2ltcGxleCBjb3JuZXJcbiAgICAgIHZhciBpMywgajMsIGszLCBsMzsgLy8gVGhlIGludGVnZXIgb2Zmc2V0cyBmb3IgdGhlIGZvdXJ0aCBzaW1wbGV4IGNvcm5lclxuICAgICAgLy8gc2ltcGxleFtjXSBpcyBhIDQtdmVjdG9yIHdpdGggdGhlIG51bWJlcnMgMCwgMSwgMiBhbmQgMyBpbiBzb21lIG9yZGVyLlxuICAgICAgLy8gTWFueSB2YWx1ZXMgb2YgYyB3aWxsIG5ldmVyIG9jY3VyLCBzaW5jZSBlLmcuIHg+eT56PncgbWFrZXMgeDx6LCB5PHcgYW5kIHg8d1xuICAgICAgLy8gaW1wb3NzaWJsZS4gT25seSB0aGUgMjQgaW5kaWNlcyB3aGljaCBoYXZlIG5vbi16ZXJvIGVudHJpZXMgbWFrZSBhbnkgc2Vuc2UuXG4gICAgICAvLyBXZSB1c2UgYSB0aHJlc2hvbGRpbmcgdG8gc2V0IHRoZSBjb29yZGluYXRlcyBpbiB0dXJuIGZyb20gdGhlIGxhcmdlc3QgbWFnbml0dWRlLlxuICAgICAgLy8gUmFuayAzIGRlbm90ZXMgdGhlIGxhcmdlc3QgY29vcmRpbmF0ZS5cbiAgICAgIGkxID0gcmFua3ggPj0gMyA/IDEgOiAwO1xuICAgICAgajEgPSByYW5reSA+PSAzID8gMSA6IDA7XG4gICAgICBrMSA9IHJhbmt6ID49IDMgPyAxIDogMDtcbiAgICAgIGwxID0gcmFua3cgPj0gMyA/IDEgOiAwO1xuICAgICAgLy8gUmFuayAyIGRlbm90ZXMgdGhlIHNlY29uZCBsYXJnZXN0IGNvb3JkaW5hdGUuXG4gICAgICBpMiA9IHJhbmt4ID49IDIgPyAxIDogMDtcbiAgICAgIGoyID0gcmFua3kgPj0gMiA/IDEgOiAwO1xuICAgICAgazIgPSByYW5reiA+PSAyID8gMSA6IDA7XG4gICAgICBsMiA9IHJhbmt3ID49IDIgPyAxIDogMDtcbiAgICAgIC8vIFJhbmsgMSBkZW5vdGVzIHRoZSBzZWNvbmQgc21hbGxlc3QgY29vcmRpbmF0ZS5cbiAgICAgIGkzID0gcmFua3ggPj0gMSA/IDEgOiAwO1xuICAgICAgajMgPSByYW5reSA+PSAxID8gMSA6IDA7XG4gICAgICBrMyA9IHJhbmt6ID49IDEgPyAxIDogMDtcbiAgICAgIGwzID0gcmFua3cgPj0gMSA/IDEgOiAwO1xuICAgICAgLy8gVGhlIGZpZnRoIGNvcm5lciBoYXMgYWxsIGNvb3JkaW5hdGUgb2Zmc2V0cyA9IDEsIHNvIG5vIG5lZWQgdG8gY29tcHV0ZSB0aGF0LlxuICAgICAgdmFyIHgxID0geDAgLSBpMSArIEc0OyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgIHZhciB5MSA9IHkwIC0gajEgKyBHNDtcbiAgICAgIHZhciB6MSA9IHowIC0gazEgKyBHNDtcbiAgICAgIHZhciB3MSA9IHcwIC0gbDEgKyBHNDtcbiAgICAgIHZhciB4MiA9IHgwIC0gaTIgKyAyLjAgKiBHNDsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgIHZhciB5MiA9IHkwIC0gajIgKyAyLjAgKiBHNDtcbiAgICAgIHZhciB6MiA9IHowIC0gazIgKyAyLjAgKiBHNDtcbiAgICAgIHZhciB3MiA9IHcwIC0gbDIgKyAyLjAgKiBHNDtcbiAgICAgIHZhciB4MyA9IHgwIC0gaTMgKyAzLjAgKiBHNDsgLy8gT2Zmc2V0cyBmb3IgZm91cnRoIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICB2YXIgeTMgPSB5MCAtIGozICsgMy4wICogRzQ7XG4gICAgICB2YXIgejMgPSB6MCAtIGszICsgMy4wICogRzQ7XG4gICAgICB2YXIgdzMgPSB3MCAtIGwzICsgMy4wICogRzQ7XG4gICAgICB2YXIgeDQgPSB4MCAtIDEuMCArIDQuMCAqIEc0OyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICB2YXIgeTQgPSB5MCAtIDEuMCArIDQuMCAqIEc0O1xuICAgICAgdmFyIHo0ID0gejAgLSAxLjAgKyA0LjAgKiBHNDtcbiAgICAgIHZhciB3NCA9IHcwIC0gMS4wICsgNC4wICogRzQ7XG4gICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZpdmUgc2ltcGxleCBjb3JuZXJzXG4gICAgICB2YXIgaWkgPSBpICYgMjU1O1xuICAgICAgdmFyIGpqID0gaiAmIDI1NTtcbiAgICAgIHZhciBrayA9IGsgJiAyNTU7XG4gICAgICB2YXIgbGwgPSBsICYgMjU1O1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZml2ZSBjb3JuZXJzXG4gICAgICB2YXIgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejAgLSB3MCAqIHcwO1xuICAgICAgaWYgKHQwIDwgMCkgbjAgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMCA9IChwZXJtW2lpICsgcGVybVtqaiArIHBlcm1ba2sgKyBwZXJtW2xsXV1dXSAlIDMyKSAqIDQ7XG4gICAgICAgIHQwICo9IHQwO1xuICAgICAgICBuMCA9IHQwICogdDAgKiAoZ3JhZDRbZ2kwXSAqIHgwICsgZ3JhZDRbZ2kwICsgMV0gKiB5MCArIGdyYWQ0W2dpMCArIDJdICogejAgKyBncmFkNFtnaTAgKyAzXSAqIHcwKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MSA9IDAuNiAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MSAtIHcxICogdzE7XG4gICAgICBpZiAodDEgPCAwKSBuMSA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kxID0gKHBlcm1baWkgKyBpMSArIHBlcm1bamogKyBqMSArIHBlcm1ba2sgKyBrMSArIHBlcm1bbGwgKyBsMV1dXV0gJSAzMikgKiA0O1xuICAgICAgICB0MSAqPSB0MTtcbiAgICAgICAgbjEgPSB0MSAqIHQxICogKGdyYWQ0W2dpMV0gKiB4MSArIGdyYWQ0W2dpMSArIDFdICogeTEgKyBncmFkNFtnaTEgKyAyXSAqIHoxICsgZ3JhZDRbZ2kxICsgM10gKiB3MSk7XG4gICAgICB9XG4gICAgICB2YXIgdDIgPSAwLjYgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejIgLSB3MiAqIHcyO1xuICAgICAgaWYgKHQyIDwgMCkgbjIgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMiA9IChwZXJtW2lpICsgaTIgKyBwZXJtW2pqICsgajIgKyBwZXJtW2trICsgazIgKyBwZXJtW2xsICsgbDJdXV1dICUgMzIpICogNDtcbiAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgIG4yID0gdDIgKiB0MiAqIChncmFkNFtnaTJdICogeDIgKyBncmFkNFtnaTIgKyAxXSAqIHkyICsgZ3JhZDRbZ2kyICsgMl0gKiB6MiArIGdyYWQ0W2dpMiArIDNdICogdzIpO1xuICAgICAgfVxuICAgICAgdmFyIHQzID0gMC42IC0geDMgKiB4MyAtIHkzICogeTMgLSB6MyAqIHozIC0gdzMgKiB3MztcbiAgICAgIGlmICh0MyA8IDApIG4zID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTMgPSAocGVybVtpaSArIGkzICsgcGVybVtqaiArIGozICsgcGVybVtrayArIGszICsgcGVybVtsbCArIGwzXV1dXSAlIDMyKSAqIDQ7XG4gICAgICAgIHQzICo9IHQzO1xuICAgICAgICBuMyA9IHQzICogdDMgKiAoZ3JhZDRbZ2kzXSAqIHgzICsgZ3JhZDRbZ2kzICsgMV0gKiB5MyArIGdyYWQ0W2dpMyArIDJdICogejMgKyBncmFkNFtnaTMgKyAzXSAqIHczKTtcbiAgICAgIH1cbiAgICAgIHZhciB0NCA9IDAuNiAtIHg0ICogeDQgLSB5NCAqIHk0IC0gejQgKiB6NCAtIHc0ICogdzQ7XG4gICAgICBpZiAodDQgPCAwKSBuNCA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2k0ID0gKHBlcm1baWkgKyAxICsgcGVybVtqaiArIDEgKyBwZXJtW2trICsgMSArIHBlcm1bbGwgKyAxXV1dXSAlIDMyKSAqIDQ7XG4gICAgICAgIHQ0ICo9IHQ0O1xuICAgICAgICBuNCA9IHQ0ICogdDQgKiAoZ3JhZDRbZ2k0XSAqIHg0ICsgZ3JhZDRbZ2k0ICsgMV0gKiB5NCArIGdyYWQ0W2dpNCArIDJdICogejQgKyBncmFkNFtnaTQgKyAzXSAqIHc0KTtcbiAgICAgIH1cbiAgICAgIC8vIFN1bSB1cCBhbmQgc2NhbGUgdGhlIHJlc3VsdCB0byBjb3ZlciB0aGUgcmFuZ2UgWy0xLDFdXG4gICAgICByZXR1cm4gMjcuMCAqIChuMCArIG4xICsgbjIgKyBuMyArIG40KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gYnVpbGRQZXJtdXRhdGlvblRhYmxlKHJhbmRvbSkge1xuICAgIHZhciBpO1xuICAgIHZhciBwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIHBbaV0gPSBpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU1OyBpKyspIHtcbiAgICAgIHZhciByID0gaSArIH5+KHJhbmRvbSgpICogKDI1NiAtIGkpKTtcbiAgICAgIHZhciBhdXggPSBwW2ldO1xuICAgICAgcFtpXSA9IHBbcl07XG4gICAgICBwW3JdID0gYXV4O1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICBTaW1wbGV4Tm9pc2UuX2J1aWxkUGVybXV0YXRpb25UYWJsZSA9IGJ1aWxkUGVybXV0YXRpb25UYWJsZTtcblxuICBmdW5jdGlvbiBhbGVhKCkge1xuICAgIC8vIEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2UuY29tPiwgMjAxMFxuICAgIHZhciBzMCA9IDA7XG4gICAgdmFyIHMxID0gMDtcbiAgICB2YXIgczIgPSAwO1xuICAgIHZhciBjID0gMTtcblxuICAgIHZhciBtYXNoID0gbWFzaGVyKCk7XG4gICAgczAgPSBtYXNoKCcgJyk7XG4gICAgczEgPSBtYXNoKCcgJyk7XG4gICAgczIgPSBtYXNoKCcgJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgczAgLT0gbWFzaChhcmd1bWVudHNbaV0pO1xuICAgICAgaWYgKHMwIDwgMCkge1xuICAgICAgICBzMCArPSAxO1xuICAgICAgfVxuICAgICAgczEgLT0gbWFzaChhcmd1bWVudHNbaV0pO1xuICAgICAgaWYgKHMxIDwgMCkge1xuICAgICAgICBzMSArPSAxO1xuICAgICAgfVxuICAgICAgczIgLT0gbWFzaChhcmd1bWVudHNbaV0pO1xuICAgICAgaWYgKHMyIDwgMCkge1xuICAgICAgICBzMiArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXNoID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdCA9IDIwOTE2MzkgKiBzMCArIGMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgICAgczAgPSBzMTtcbiAgICAgIHMxID0gczI7XG4gICAgICByZXR1cm4gczIgPSB0IC0gKGMgPSB0IHwgMCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtYXNoZXIoKSB7XG4gICAgdmFyIG4gPSAweGVmYzgyNDlkO1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgICBuID0gaCA+Pj4gMDtcbiAgICAgICAgaCAtPSBuO1xuICAgICAgICBoICo9IG47XG4gICAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgICBoIC09IG47XG4gICAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgICB9XG4gICAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICB9O1xuICB9XG5cbiAgLy8gYW1kXG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZnVuY3Rpb24oKSB7cmV0dXJuIFNpbXBsZXhOb2lzZTt9KTtcbiAgLy8gY29tbW9uIGpzXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIGV4cG9ydHMuU2ltcGxleE5vaXNlID0gU2ltcGxleE5vaXNlO1xuICAvLyBicm93c2VyXG4gIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB3aW5kb3cuU2ltcGxleE5vaXNlID0gU2ltcGxleE5vaXNlO1xuICAvLyBub2RlanNcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTaW1wbGV4Tm9pc2U7XG4gIH1cblxufSkoKTtcbiIsIi8qXG4gKGMpIDIwMTcsIFZsYWRpbWlyIEFnYWZvbmtpblxuIFNpbXBsaWZ5LmpzLCBhIGhpZ2gtcGVyZm9ybWFuY2UgSlMgcG9seWxpbmUgc2ltcGxpZmljYXRpb24gbGlicmFyeVxuIG1vdXJuZXIuZ2l0aHViLmlvL3NpbXBsaWZ5LWpzXG4qL1xuXG4oZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbi8vIHRvIHN1aXQgeW91ciBwb2ludCBmb3JtYXQsIHJ1biBzZWFyY2gvcmVwbGFjZSBmb3IgJy54JyBhbmQgJy55Jztcbi8vIGZvciAzRCB2ZXJzaW9uLCBzZWUgM2QgYnJhbmNoIChjb25maWd1cmFiaWxpdHkgd291bGQgZHJhdyBzaWduaWZpY2FudCBwZXJmb3JtYW5jZSBvdmVyaGVhZClcblxuLy8gc3F1YXJlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbmZ1bmN0aW9uIGdldFNxRGlzdChwMSwgcDIpIHtcblxuICAgIHZhciBkeCA9IHAxLnggLSBwMi54LFxuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudFxuZnVuY3Rpb24gZ2V0U3FTZWdEaXN0KHAsIHAxLCBwMikge1xuXG4gICAgdmFyIHggPSBwMS54LFxuICAgICAgICB5ID0gcDEueSxcbiAgICAgICAgZHggPSBwMi54IC0geCxcbiAgICAgICAgZHkgPSBwMi55IC0geTtcblxuICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuXG4gICAgICAgIHZhciB0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgIHggPSBwMi54O1xuICAgICAgICAgICAgeSA9IHAyLnk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgICAgICAgeCArPSBkeCAqIHQ7XG4gICAgICAgICAgICB5ICs9IGR5ICogdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGR4ID0gcC54IC0geDtcbiAgICBkeSA9IHAueSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG4vLyByZXN0IG9mIHRoZSBjb2RlIGRvZXNuJ3QgY2FyZSBhYm91dCBwb2ludCBmb3JtYXRcblxuLy8gYmFzaWMgZGlzdGFuY2UtYmFzZWQgc2ltcGxpZmljYXRpb25cbmZ1bmN0aW9uIHNpbXBsaWZ5UmFkaWFsRGlzdChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XG5cbiAgICB2YXIgcHJldlBvaW50ID0gcG9pbnRzWzBdLFxuICAgICAgICBuZXdQb2ludHMgPSBbcHJldlBvaW50XSxcbiAgICAgICAgcG9pbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmIChnZXRTcURpc3QocG9pbnQsIHByZXZQb2ludCkgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldlBvaW50ICE9PSBwb2ludCkgbmV3UG9pbnRzLnB1c2gocG9pbnQpO1xuXG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBmaXJzdCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpIHtcbiAgICB2YXIgbWF4U3FEaXN0ID0gc3FUb2xlcmFuY2UsXG4gICAgICAgIGluZGV4O1xuXG4gICAgZm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICB2YXIgc3FEaXN0ID0gZ2V0U3FTZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdKTtcblxuICAgICAgICBpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICBtYXhTcURpc3QgPSBzcURpc3Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgaWYgKGluZGV4IC0gZmlyc3QgPiAxKSBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBpbmRleCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgICAgICBzaW1wbGlmaWVkLnB1c2gocG9pbnRzW2luZGV4XSk7XG4gICAgICAgIGlmIChsYXN0IC0gaW5kZXggPiAxKSBzaW1wbGlmeURQU3RlcChwb2ludHMsIGluZGV4LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgfVxufVxuXG4vLyBzaW1wbGlmaWNhdGlvbiB1c2luZyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXG5mdW5jdGlvbiBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcbiAgICB2YXIgbGFzdCA9IHBvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgdmFyIHNpbXBsaWZpZWQgPSBbcG9pbnRzWzBdXTtcbiAgICBzaW1wbGlmeURQU3RlcChwb2ludHMsIDAsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICBzaW1wbGlmaWVkLnB1c2gocG9pbnRzW2xhc3RdKTtcblxuICAgIHJldHVybiBzaW1wbGlmaWVkO1xufVxuXG4vLyBib3RoIGFsZ29yaXRobXMgY29tYmluZWQgZm9yIGF3ZXNvbWUgcGVyZm9ybWFuY2VcbmZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlLCBoaWdoZXN0UXVhbGl0eSkge1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPD0gMikgcmV0dXJuIHBvaW50cztcblxuICAgIHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID8gdG9sZXJhbmNlICogdG9sZXJhbmNlIDogMTtcblxuICAgIHBvaW50cyA9IGhpZ2hlc3RRdWFsaXR5ID8gcG9pbnRzIDogc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpO1xuICAgIHBvaW50cyA9IHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG5cbiAgICByZXR1cm4gcG9pbnRzO1xufVxuXG4vLyBleHBvcnQgYXMgQU1EIG1vZHVsZSAvIE5vZGUgbW9kdWxlIC8gYnJvd3NlciBvciB3b3JrZXIgdmFyaWFibGVcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNpbXBsaWZ5OyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzaW1wbGlmeTtcbiAgICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gc2ltcGxpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgc2VsZi5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuZWxzZSB3aW5kb3cuc2ltcGxpZnkgPSBzaW1wbGlmeTtcblxufSkoKTtcbiIsIm1vZHVsZS5leHBvcnRzPS8vIGJnQ29sb3VyOiBzdHJpbmc7XG4vLyBiZ0NvbG91ckluPzogc3RyaW5nO1xuLy8gYnVpbGRpbmdDb2xvdXI/OiBzdHJpbmc7XG4vLyBidWlsZGluZ1N0cm9rZT86IHN0cmluZztcbi8vIHNlYUNvbG91cjogc3RyaW5nO1xuLy8gZ3Jhc3NDb2xvdXI/OiBzdHJpbmc7XG4vLyBtaW5vclJvYWRDb2xvdXI6IHN0cmluZztcbi8vIG1pbm9yUm9hZE91dGxpbmU/OiBzdHJpbmc7XG4vLyBtYWpvclJvYWRDb2xvdXI/OiBzdHJpbmc7XG4vLyBtYWpvclJvYWRPdXRsaW5lPzogc3RyaW5nO1xuLy8gbWFpblJvYWRDb2xvdXI/OiBzdHJpbmc7XG4vLyBtYWluUm9hZE91dGxpbmU/OiBzdHJpbmc7ICAvLyBCZSBjYXJlZnVsLCBpbmhlcml0cyBtYWpvclJvYWRPdXRsaW5lLCBub3QgbWFpblJvYWRDb2xvdXJcbi8vIG91dGxpbmVTaXplPzogbnVtYmVyOyAgICAgIC8vIENhc2NhZGUgc2VtYW50aWNzIGluIHN0eWxlLnRzXG4vLyB6b29tQnVpbGRpbmdzPzogYm9vbGVhbjtcblxue1xuICAgIFwiRGVmYXVsdFwiOiB7XG4gICAgICAgIFwiYmdDb2xvdXJcIjogXCJyZ2IoMjM2LDIyOSwyMTkpXCIsXG4gICAgICAgIFwiYnVpbGRpbmdTdHJva2VcIjogXCIjMjgyODI4XCIsXG4gICAgICAgIC8vIFwiYnVpbGRpbmdDb2xvdXJcIjogXCJyZWRcIixcbiAgICAgICAgXCJzZWFDb2xvdXJcIjogXCIjYTlkOWZlXCIsXG4gICAgICAgIFwiZ3Jhc3NDb2xvdXJcIjogXCIjYzVlOGM1XCIsXG4gICAgICAgIFwibWlub3JSb2FkT3V0bGluZVwiOiBcIiMwMjAyMDJcIixcbiAgICAgICAgXCJtaW5vclJvYWRDb2xvdXJcIjogXCIjRjhGOEY4XCIsXG4gICAgICAgIFwibWFpblJvYWRPdXRsaW5lXCI6IFwiIzI4MjgyOFwiLFxuICAgICAgICBcIm1haW5Sb2FkQ29sb3VyXCI6IFwiI0ZBRkE3QVwiLFxuICAgIH0sXG4gICAgXCJBcHBsZVwiOiB7XG4gICAgICAgIFwiYmdDb2xvdXJcIjogXCJyZ2IoMjQ4LDI0NSwyMzgpXCIsXG4gICAgICAgIFwiYnVpbGRpbmdDb2xvdXJcIjogXCJyZ2IoMjM5LDIzNiwyMjkpXCIsXG4gICAgICAgIFwiYnVpbGRpbmdTdHJva2VcIjogXCJyZ2IoMjM1LDIzNCwyMjQpXCIsXG4gICAgICAgIFwic2VhQ29sb3VyXCI6IFwicmdiKDE4NCwyMjQsMjQzKVwiLFxuICAgICAgICBcImdyYXNzQ29sb3VyXCI6IFwicmdiKDIyNCwyMzcsMjA1KVwiLFxuICAgICAgICBcIm1pbm9yUm9hZENvbG91clwiOiBcInJnYigyNTUsMjU1LDI1NSlcIixcbiAgICAgICAgXCJtaW5vclJvYWRPdXRsaW5lXCI6IFwicmdiKDIxNSwyMDgsMTk4KVwiLFxuICAgICAgICBcIm1ham9yUm9hZENvbG91clwiOiBcInJnYigyNTIsMjUyLDIyNClcIixcbiAgICAgICAgXCJtYWpvclJvYWRPdXRsaW5lXCI6IFwicmdiKDI0MCwyMTAsMTUyKVwiLFxuICAgICAgICBcIm1haW5Sb2FkQ29sb3VyXCI6IFwicmdiKDI1MCwyMjQsOTgpXCIsXG4gICAgICAgIFwibWFpblJvYWRPdXRsaW5lXCI6IFwicmdiKDIzOCwxOTksMTMyKVwiLFxuICAgICAgICBcInpvb21CdWlsZGluZ3NcIjogdHJ1ZSxcbiAgICAgICAgXCJvdXRsaW5lU2l6ZVwiOiAyLFxuICAgIH0sXG4gICAgXCJBcHBsZURhcmtcIjoge1xuICAgICAgICBcImJnQ29sb3VyXCI6IFwicmdiKDQzLDQ1LDQ3KVwiLFxuICAgICAgICBcImJ1aWxkaW5nQ29sb3VyXCI6IFwicmdiKDUyLDU0LDU2KVwiLFxuICAgICAgICBcImJ1aWxkaW5nU3Ryb2tlXCI6IFwicmdiKDQ3LDQ5LDUxKVwiLFxuICAgICAgICBcInNlYUNvbG91clwiOiBcInJnYig1NSw2OCwxMDApXCIsXG4gICAgICAgIFwiZ3Jhc3NDb2xvdXJcIjogXCJyZ2IoNDAsNTYsNTYpXCIsXG4gICAgICAgIFwibWlub3JSb2FkQ29sb3VyXCI6IFwicmdiKDY1LDY4LDcxKVwiLFxuICAgICAgICBcIm1pbm9yUm9hZE91dGxpbmVcIjogXCJyZ2IoNDMsNDUsNDcpXCIsXG4gICAgICAgIFwibWFqb3JSb2FkQ29sb3VyXCI6IFwicmdiKDc4LDgxLDg0KVwiLFxuICAgICAgICBcIm1ham9yUm9hZE91dGxpbmVcIjogXCJyZ2IoNDMsNDUsNDcpXCIsXG4gICAgICAgIFwibWFpblJvYWRDb2xvdXJcIjogXCJyZ2IoMTQ5LDEwOCw2MilcIixcbiAgICAgICAgXCJtYWluUm9hZE91dGxpbmVcIjogXCJyZ2IoNTEsNTEsNTEpXCIsXG4gICAgICAgIFwiem9vbUJ1aWxkaW5nc1wiOiB0cnVlLFxuICAgICAgICBcIm91dGxpbmVTaXplXCI6IDEsXG4gICAgfSxcbiAgICBcIkFzc2Fzc2luXCI6IHtcbiAgICAgICAgXCJiZ0NvbG91clwiOiBcInJnYig3Nyw5Niw4OSlcIixcbiAgICAgICAgXCJidWlsZGluZ1N0cm9rZVwiOiBcInJnYig3Miw5MSw4NClcIixcbiAgICAgICAgXCJzZWFDb2xvdXJcIjogXCJyZ2IoMzYsNDAsNDMpXCIsXG4gICAgICAgIFwibWlub3JSb2FkQ29sb3VyXCI6IFwicmdiKDEyNywxNDEsMTM3KVwiLFxuICAgICAgICBcIm1haW5Sb2FkQ29sb3VyXCI6IFwicmdiKDE0OSwxNjEsMTU3KVwiLFxuICAgICAgICBcIm1haW5Sb2FkT3V0bGluZVwiOiBcInJnYigxNDksMTYxLDE1NylcIixcbiAgICB9LFxuICAgIFwiRHJhd25cIjoge30sICAvLyBTcGVjaWFsIGNhbnZhc1xuICAgIFwiR29vZ2xlXCI6IHtcbiAgICAgICAgXCJiZ0NvbG91clwiOiBcInJnYigyNDgsMjQ5LDI1MClcIixcbiAgICAgICAgXCJiZ0NvbG91ckluXCI6IFwicmdiKDI0MSwyNDIsMjQzKVwiLFxuICAgICAgICBcImJ1aWxkaW5nQ29sb3VyXCI6IFwicmdiKDI0MCwyNDAsMjQwKVwiLFxuICAgICAgICBcImJ1aWxkaW5nU3Ryb2tlXCI6IFwicmdiKDIyMCwyMjAsMjIwKVwiLFxuICAgICAgICBcInNlYUNvbG91clwiOiBcInJnYigxNjYsMjEzLDI0OSlcIixcbiAgICAgICAgXCJncmFzc0NvbG91clwiOiBcInJnYigxOTgsMjMyLDE5OClcIixcbiAgICAgICAgXCJtaW5vclJvYWRDb2xvdXJcIjogXCJyZ2IoMjU1LDI1NSwyNTUpXCIsXG4gICAgICAgIFwibWlub3JSb2FkT3V0bGluZVwiOiBcInJnYigxOTMsMTk3LDIxNClcIixcbiAgICAgICAgXCJtYWluUm9hZENvbG91clwiOiBcInJnYigyNTUsMjQyLDE3NSlcIixcbiAgICAgICAgXCJtYWluUm9hZE91dGxpbmVcIjogXCJyZ2IoMjQ2LDIwNywxMDEpXCIsXG4gICAgICAgIFwiem9vbUJ1aWxkaW5nc1wiOiB0cnVlLFxuICAgIH0sXG4gICAgXCJQYXBlclwiOiB7XG4gICAgICAgIFwiYmdDb2xvdXJcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInNlYUNvbG91clwiOiBcInJnYigyMzMsMjQwLDI1NSlcIixcbiAgICAgICAgXCJncmFzc0NvbG91clwiOiBcInJnYigxOTcsMjMyLDE5NylcIixcbiAgICAgICAgXCJtaW5vclJvYWRDb2xvdXJcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcIm1pbm9yUm9hZE91dGxpbmVcIjogXCJyZ2IoMjIyLDIyMywyMjcpXCIsXG4gICAgICAgIFwib3V0bGluZVNpemVcIjogMixcbiAgICB9LFxuICAgIFwiU3VidGxlR3JleVwiOiB7XG4gICAgICAgIFwiYmdDb2xvdXJcIjogXCJyZ2IoMjQ3LDI0NywyNDcpXCIsXG4gICAgICAgIFwiYnVpbGRpbmdDb2xvdXJcIjogXCJyZ2IoMjUxLDI1MSwyNTEpXCIsXG4gICAgICAgIFwiYnVpbGRpbmdTdHJva2VcIjogXCJyZ2IoMjQzLDI0MywyNDMpXCIsXG4gICAgICAgIFwic2VhQ29sb3VyXCI6IFwicmdiKDE2MiwxNjIsMTU3KVwiLFxuICAgICAgICBcImdyYXNzQ29sb3VyXCI6IFwicmdiKDIzOSwyMzksMjM5KVwiLFxuICAgICAgICBcIm1pbm9yUm9hZE91dGxpbmVcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcIm1pbm9yUm9hZENvbG91clwiOiBcInJnYigyMTIsMjEyLDIxMilcIixcbiAgICAgICAgXCJtYWluUm9hZE91dGxpbmVcIjogXCJyZ2IoMjA4LDIwOCwyMDgpXCIsXG4gICAgICAgIFwibWFpblJvYWRDb2xvdXJcIjogXCJyZ2IoMjA4LDIwOCwyMDgpXCIsXG4gICAgICAgIFwiZnJhbWVUZXh0Q29sb3VyXCI6IFwicmdiKDE2MiwxNjIsMTU3KVwiLFxuICAgIH0sXG4gICAgXCJVbHRyYUxpZ2h0XCI6IHtcbiAgICAgICAgXCJiZ0NvbG91clwiOiBcInJnYigyNDcsMjQ3LDI0NylcIixcbiAgICAgICAgXCJzZWFDb2xvdXJcIjogXCJyZ2IoMjM3LDIzNywyMzcpXCIsXG4gICAgICAgIFwiYnVpbGRpbmdTdHJva2VcIjogXCJyZ2IoMjM4LDIzOCwyMzgpXCIsXG4gICAgICAgIFwiZ3Jhc3NDb2xvdXJcIjogXCJyZ2IoMjI5LDIyOSwyMjkpXCIsXG4gICAgICAgIFwibWlub3JSb2FkQ29sb3VyXCI6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiV3lcIjoge1xuICAgICAgICBcImJnQ29sb3VyXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJzZWFDb2xvdXJcIjogXCJyZ2IoMjAwLDIxNSwyMTIpXCIsXG4gICAgICAgIFwiYnVpbGRpbmdTdHJva2VcIjogXCJyZ2IoMjM4LDIzOCwyMzgpXCIsXG4gICAgICAgIFwibWlub3JSb2FkT3V0bGluZVwiOiBcInJnYigxOTAsMTkwLDE5MClcIixcbiAgICAgICAgXCJtaW5vclJvYWRDb2xvdXJcIjogXCJyZ2IoMjM4LDIzOCwyMzgpXCIsXG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCAqIGFzIGRhdCBmcm9tICdkYXQuZ3VpJztcbmltcG9ydCBUZW5zb3JGaWVsZEdVSSBmcm9tICcuL3RzL3VpL3RlbnNvcl9maWVsZF9ndWknO1xuaW1wb3J0IHtOb2lzZVBhcmFtc30gZnJvbSAnLi90cy9pbXBsL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQgUm9hZHNHVUkgZnJvbSAnLi90cy91aS9yb2Fkc19ndWknO1xuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi90cy91aS9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQge0RlZmF1bHRDYW52YXNXcmFwcGVyLCBSb3VnaENhbnZhc1dyYXBwZXJ9IGZyb20gJy4vdHMvdWkvY2FudmFzX3dyYXBwZXInO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi90cy91dGlsJztcbmltcG9ydCBEcmFnQ29udHJvbGxlciBmcm9tICcuL3RzL3VpL2RyYWdfY29udHJvbGxlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL3RzL3VpL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBTdHlsZSBmcm9tICcuL3RzL3VpL3N0eWxlJztcbmltcG9ydCB7Q29sb3VyU2NoZW1lLCBEZWZhdWx0U3R5bGUsIFJvdWdoU3R5bGV9IGZyb20gJy4vdHMvdWkvc3R5bGUnO1xuaW1wb3J0ICogYXMgQ29sb3VyU2NoZW1lcyBmcm9tICcuL2NvbG91cl9zY2hlbWVzLmpzb24nO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuL3RzL3ZlY3Rvcic7XG5cbmNsYXNzIE1haW4ge1xuICAgIHByaXZhdGUgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBwcml2YXRlIGd1aTogZGF0LkdVSSA9IG5ldyBkYXQuR1VJKHt3aWR0aDogMzAwfSk7XG4gICAgcHJpdmF0ZSB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGRHVUk7XG4gICAgcHJpdmF0ZSByb2Fkc0dVSTogUm9hZHNHVUk7XG4gICAgcHJpdmF0ZSBkcmFnQ29udHJvbGxlciA9IG5ldyBEcmFnQ29udHJvbGxlcih0aGlzLmd1aSk7XG5cbiAgICAvLyBPcHRpb25zXG4gICAgcHJpdmF0ZSBpbWFnZVNjYWxlID0gMztcblxuICAgIC8vIEZvbGRlcnNcbiAgICBwcml2YXRlIHRlbnNvckZvbGRlcjogZGF0LkdVSTtcbiAgICBwcml2YXRlIHJvYWRzRm9sZGVyOiBkYXQuR1VJO1xuXG4gICAgLy8gVG8gZm9yY2UgZHJhdyBpZiBuZWVkZWRcbiAgICBwcml2YXRlIHByZXZpb3VzRnJhbWVEcmF3VGVuc29yID0gdHJ1ZTtcblxuICAgIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICBwcml2YXRlIHRlbnNvckNhbnZhczogRGVmYXVsdENhbnZhc1dyYXBwZXI7XG4gICAgcHJpdmF0ZSBfc3R5bGU6IFN0eWxlO1xuICAgIHByaXZhdGUgc3R5bGVGb2xkZXI6IGRhdC5HVUk7XG4gICAgcHJpdmF0ZSBjb2xvdXJTY2hlbWU6IHN0cmluZyA9IFwiRGVmYXVsdFwiO1xuICAgIHByaXZhdGUgem9vbUJ1aWxkaW5nczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgc2hvd0ZyYW1lOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHVibGljIGhpZ2hEUEkgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFV0aWwuQ0FOVkFTX0lEKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgICAgdGhpcy50ZW5zb3JDYW52YXMgPSBuZXcgRGVmYXVsdENhbnZhc1dyYXBwZXIodGhpcy5jYW52YXMpO1xuXG4gICAgICAgIGNvbnN0IHpvb21Db250cm9sbGVyID0gdGhpcy5ndWkuYWRkKHRoaXMuZG9tYWluQ29udHJvbGxlciwgJ3pvb20nKTtcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnNldFpvb21VcGRhdGUoKCkgPT4gem9vbUNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG5vaXNlUGFyYW1zOiBOb2lzZVBhcmFtcyA9IHtcbiAgICAgICAgICAgIGdsb2JhbE5vaXNlOiBmYWxzZSxcbiAgICAgICAgICAgIG5vaXNlU2l6ZVBhcms6IDIwLFxuICAgICAgICAgICAgbm9pc2VBbmdsZVBhcms6IDkwLFxuICAgICAgICAgICAgbm9pc2VTaXplR2xvYmFsOiAzMCxcbiAgICAgICAgICAgIG5vaXNlQW5nbGVHbG9iYWw6IDIwXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50ZW5zb3JGb2xkZXIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoJ1RlbnNvciBGaWVsZCcpO1xuICAgICAgICB0aGlzLnRlbnNvckZpZWxkID0gbmV3IFRlbnNvckZpZWxkR1VJKHRoaXMudGVuc29yRm9sZGVyLCB0aGlzLmRyYWdDb250cm9sbGVyLCB0cnVlLCBub2lzZVBhcmFtcyk7XG4gICAgICAgIHRoaXMudGVuc29yRm9sZGVyLm9wZW4oKTtcbiAgICAgICAgdGhpcy5yb2Fkc0ZvbGRlciA9IHRoaXMuZ3VpLmFkZEZvbGRlcignTWFwJyk7XG4gICAgICAgIHRoaXMucm9hZHNGb2xkZXIub3BlbigpO1xuICAgICAgICB0aGlzLnJvYWRzR1VJID0gbmV3IFJvYWRzR1VJKHRoaXMucm9hZHNGb2xkZXIsIHRoaXMudGVuc29yRmllbGQsICgpID0+IHRoaXMudGVuc29yRm9sZGVyLmNsb3NlKCkpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnNGb2xkZXIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoJ09wdGlvbnMnKTtcbiAgICAgICAgb3B0aW9uc0ZvbGRlci5hZGQodGhpcy50ZW5zb3JGaWVsZCwgJ2RyYXdDZW50cmUnKTtcbiAgICAgICAgY29uc3QgY2FudmFzU2NhbGVDb250cm9sbGVyID0gb3B0aW9uc0ZvbGRlci5hZGQodGhpcywgJ2hpZ2hEUEknKTtcbiAgICAgICAgY2FudmFzU2NhbGVDb250cm9sbGVyLm9uQ2hhbmdlKChoaWdoOiBib29sZWFuKSA9PiB0aGlzLmNoYW5nZUNhbnZhc1NjYWxlKGhpZ2gpKTtcbiAgICAgICAgb3B0aW9uc0ZvbGRlci5hZGQodGhpcywgJ2ltYWdlU2NhbGUnLCAxLCA1KS5zdGVwKDEpO1xuICAgICAgICBvcHRpb25zRm9sZGVyLmFkZCh0aGlzLCAnZG93bmxvYWQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0eWxlXG4gICAgICAgIHRoaXMuc3R5bGVGb2xkZXIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoJ1N0eWxlJyk7XG4gICAgICAgIGNvbnN0IHN0eWxlQ29udHJvbGxlciA9IHRoaXMuc3R5bGVGb2xkZXIuYWRkKHRoaXMsICdjb2xvdXJTY2hlbWUnLCBPYmplY3Qua2V5cyhDb2xvdXJTY2hlbWVzKSk7XG4gICAgICAgIHRoaXMuc3R5bGVGb2xkZXIuYWRkKHRoaXMsICd6b29tQnVpbGRpbmdzJykub25DaGFuZ2UoKHZhbDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlIGluc3RhbmNlb2YgRGVmYXVsdFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgcmVkcmF3XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0ZyYW1lRHJhd1RlbnNvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3R5bGUuem9vbUJ1aWxkaW5ncyA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnN0eWxlRm9sZGVyLmFkZCh0aGlzLCAnc2hvd0ZyYW1lJykub25DaGFuZ2UoKHZhbDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0ZyYW1lRHJhd1RlbnNvciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZS5zaG93RnJhbWUgPSB2YWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0eWxlQ29udHJvbGxlci5vbkNoYW5nZSgodmFsOiBzdHJpbmcpID0+IHRoaXMuY2hhbmdlQ29sb3VyU2NoZW1lKHZhbCkpO1xuICAgICAgICB0aGlzLmNoYW5nZUNvbG91clNjaGVtZSh0aGlzLmNvbG91clNjaGVtZSk7XG5cbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5zZXRSZWNvbW1lbmRlZCgpO1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBjaGFuZ2VDb2xvdXJTY2hlbWUoc2NoZW1lOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJEcmF3blwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZSA9IG5ldyBSb3VnaFN0eWxlKHRoaXMuY2FudmFzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG91clNjaGVtZTogQ29sb3VyU2NoZW1lID0gKENvbG91clNjaGVtZXMgYXMgYW55KVtzY2hlbWVdO1xuICAgICAgICAgICAgdGhpcy56b29tQnVpbGRpbmdzID0gY29sb3VyU2NoZW1lLnpvb21CdWlsZGluZ3M7XG4gICAgICAgICAgICBVdGlsLnVwZGF0ZUd1aSh0aGlzLnN0eWxlRm9sZGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gbmV3IERlZmF1bHRTdHlsZSh0aGlzLmNhbnZhcywgT2JqZWN0LmFzc2lnbih7fSwgY29sb3VyU2NoZW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3R5bGUuc2hvd0ZyYW1lID0gdGhpcy5zaG93RnJhbWU7XG4gICAgICAgIHRoaXMuY2hhbmdlQ2FudmFzU2NhbGUodGhpcy5oaWdoRFBJKTtcbiAgICB9XG5cbiAgICBjaGFuZ2VDYW52YXNTY2FsZShoaWdoOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGlnaCA/IDIgOiAxO1xuICAgICAgICB0aGlzLl9zdHlsZS5jYW52YXNTY2FsZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRlbnNvckNhbnZhcy5jYW52YXNTY2FsZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBpbWFnZSBvZiBtYXBcbiAgICAgKiBEcmF3cyBvbnRvIGhpZGRlbiBjYW52YXMgYXQgcmVxdWVzdGVkIHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkb3dubG9hZCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFV0aWwuSU1HX0NBTlZBU19JRCkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG5cbiAgICAgICAgLy8gRHJhd1xuICAgICAgICBpZiAodGhpcy5zaG93VGVuc29yRmllbGQoKSkge1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5kcmF3KG5ldyBEZWZhdWx0Q2FudmFzV3JhcHBlcihjLCB0aGlzLmltYWdlU2NhbGUsIGZhbHNlKSk7XG4gICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBpbWdDYW52YXMgPSB0aGlzLl9zdHlsZS5jcmVhdGVDYW52YXNXcmFwcGVyKGMsIHRoaXMuaW1hZ2VTY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5yb2Fkc0dVSS5kcmF3KHRoaXMuX3N0eWxlLCB0cnVlLCBpbWdDYW52YXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgbGluay5kb3dubG9hZCA9ICdtYXAucG5nJztcbiAgICAgICAgbGluay5ocmVmID0gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFV0aWwuSU1HX0NBTlZBU19JRCkgYXMgYW55KS50b0RhdGFVUkwoKTtcbiAgICAgICAgbGluay5jbGljaygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2hvd1RlbnNvckZpZWxkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMudGVuc29yRm9sZGVyLmNsb3NlZCB8fCB0aGlzLnJvYWRzR1VJLnJvYWRzRW1wdHkoKTtcbiAgICB9XG5cbiAgICBkcmF3KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zaG93VGVuc29yRmllbGQoKSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0ZyYW1lRHJhd1RlbnNvciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRyYWdDb250cm9sbGVyLnNldERyYWdEaXNhYmxlZChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnRlbnNvckZpZWxkLmRyYXcodGhpcy50ZW5zb3JDYW52YXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlzYWJsZSBmaWVsZCBkcmFnIGFuZCBkcm9wXG4gICAgICAgICAgICB0aGlzLmRyYWdDb250cm9sbGVyLnNldERyYWdEaXNhYmxlZCh0cnVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNGcmFtZURyYXdUZW5zb3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzRnJhbWVEcmF3VGVuc29yID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3JjZSByZWRyYXcgaWYgc3dpdGNoaW5nIGZyb20gdGVuc29yIGZpZWxkXG4gICAgICAgICAgICAgICAgdGhpcy5yb2Fkc0dVSS5kcmF3KHRoaXMuX3N0eWxlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb2Fkc0dVSS5kcmF3KHRoaXMuX3N0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yb2Fkc0dVSS51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG59XG5cbih3aW5kb3cgYXMgYW55KS5sb2cgPSBsb2c7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpOiB2b2lkID0+IHtcbiAgICBuZXcgTWFpbigpO1xufSk7XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB4OiBudW1iZXIsIHB1YmxpYyB5OiBudW1iZXIpIHt9XG5cbiAgICBzdGF0aWMgemVyb1ZlY3RvcigpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihzLCBzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAtcGkgdG8gcGlcbiAgICAgKi9cbiAgICBzdGF0aWMgYW5nbGVCZXR3ZWVuKHYxOiBWZWN0b3IsIHYyOiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICAvLyAtMnBpIHRvIDJwaVxuICAgICAgICBsZXQgYW5nbGVCZXR3ZWVuID0gdjEuYW5nbGUoKSAtIHYyLmFuZ2xlKCk7XG4gICAgICAgIGlmIChhbmdsZUJldHdlZW4gPiBNYXRoLlBJKSB7XG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gLT0gMiAqIE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5nbGVCZXR3ZWVuIDw9IC1NYXRoLlBJKSB7XG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuZ2xlQmV0d2VlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIGEgcG9pbnQgbGllcyB0byB0aGUgbGVmdCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IGxpbmVQb2ludCAgICAgUG9pbnQgb24gdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IGxpbmVEaXJlY3Rpb24gXG4gICAgICogQHBhcmFtICB7VmVjdG9yfSBwb2ludFxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gICAgICAgICAgICAgICB0cnVlIGlmIGxlZnQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0xlZnQobGluZVBvaW50OiBWZWN0b3IsIGxpbmVEaXJlY3Rpb246IFZlY3RvciwgcG9pbnQ6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBwZXJwZW5kaWN1bGFyVmVjdG9yID0gbmV3IFZlY3RvcihsaW5lRGlyZWN0aW9uLnksIC1saW5lRGlyZWN0aW9uLngpO1xuICAgICAgICByZXR1cm4gcG9pbnQuY2xvbmUoKS5zdWIobGluZVBvaW50KS5kb3QocGVycGVuZGljdWxhclZlY3RvcikgPCAwO1xuICAgIH1cblxuICAgIGFkZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKz0gdi54O1xuICAgICAgICB0aGlzLnkgKz0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBpbiByYWRpYW5zIHRvIHBvc2l0aXZlIHgtYXhpcyBiZXR3ZWVuIC1waSBhbmQgcGlcbiAgICAgKi9cbiAgICBhbmdsZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cblxuICAgIGNvcHkodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgICB0aGlzLnkgPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNyb3NzKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG4gICAgfVxuXG4gICAgZGlzdGFuY2VUbyh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xuICAgIH1cblxuICAgIGRpc3RhbmNlVG9TcXVhcmVkICh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkeCA9IHRoaXMueCAtIHYueFxuICAgICAgICBjb25zdCBkeSA9IHRoaXMueSAtIHYueTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH1cblxuICAgIGRpdmlkZSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICBpZiAodi54ID09PSAwIHx8IHYueSA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggLz0gdi54O1xuICAgICAgICB0aGlzLnkgLz0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkaXZpZGVTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiRGl2aXNpb24gYnkgemVyb1wiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzKTtcbiAgICB9XG5cbiAgICBkb3QodjogVmVjdG9yKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcbiAgICB9XG5cbiAgICBlcXVhbHModjogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoKHYueCA9PT0gdGhpcy54KSAmJiAodi55ID09PSB0aGlzLnkpKTtcbiAgICB9XG5cbiAgICBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkpO1xuICAgIH1cblxuICAgIGxlbmd0aFNxKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG4gICAgfVxuXG4gICAgbXVsdGlwbHkodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ICo9IHYueDtcbiAgICAgICAgdGhpcy55ICo9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbXVsdGlwbHlTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ICo9IHM7XG4gICAgICAgIHRoaXMueSAqPSBzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBuZWdhdGUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoLTEpO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZSgpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiWmVybyBWZWN0b3JcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICByb3RhdGVBcm91bmQoY2VudGVyOiBWZWN0b3IsIGFuZ2xlOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSlcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnggLSBjZW50ZXIueDtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIGNlbnRlci55O1xuXG4gICAgICAgIHRoaXMueCA9IHggKiBjb3MgLSB5ICogc2luICsgY2VudGVyLng7XG4gICAgICAgIHRoaXMueSA9IHggKiBzaW4gKyB5ICogY29zICsgY2VudGVyLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0WCh4OiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRZKHk6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldExlbmd0aCAobGVuZ3RoOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgIH1cblxuICAgIHN1Yih2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgICB0aGlzLnkgLT0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCJpbXBvcnQgVGVuc29yIGZyb20gJy4vdGVuc29yJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2lzRmllbGQge1xuICAgIGFic3RyYWN0IHJlYWRvbmx5IEZPTERFUl9OQU1FOiBzdHJpbmc7XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBmb2xkZXJOYW1lSW5kZXg6IG51bWJlciA9IDA7XG4gICAgcHJvdGVjdGVkIF9jZW50cmU6IFZlY3RvcjtcblxuICAgIGNvbnN0cnVjdG9yKGNlbnRyZTogVmVjdG9yLCBwcm90ZWN0ZWQgX3NpemU6IG51bWJlciwgcHJvdGVjdGVkIF9kZWNheTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2NlbnRyZSA9IGNlbnRyZS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHNldCBjZW50cmUoY2VudHJlOiBWZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fY2VudHJlLmNvcHkoY2VudHJlKTtcbiAgICB9XG5cbiAgICBnZXQgY2VudHJlKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jZW50cmUuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBzZXQgZGVjYXkoZGVjYXk6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9kZWNheSA9IGRlY2F5O1xuICAgIH1cblxuICAgIHNldCBzaXplKHNpemU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB9XG5cbiAgICBkcmFnTW92ZUxpc3RlbmVyKGRlbHRhOiBWZWN0b3IpOiB2b2lkIHtcbiAgICAgICAgLy8gRGVsdGEgYXNzdW1lZCB0byBiZSBpbiB3b3JsZCBzcGFjZSAob25seSByZWxldmFudCB3aGVuIHpvb21lZClcbiAgICAgICAgdGhpcy5fY2VudHJlLmFkZChkZWx0YSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0VGVuc29yKHBvaW50OiBWZWN0b3IpOiBUZW5zb3I7XG5cbiAgICBnZXRXZWlnaHRlZFRlbnNvcihwb2ludDogVmVjdG9yKTogVGVuc29yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGVuc29yKHBvaW50KS5zY2FsZSh0aGlzLmdldFRlbnNvcldlaWdodChwb2ludCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmb2xkZXIgYW5kIGFkZHMgaXQgdG8gdGhlIEdVSSB0byBjb250cm9sIHBhcmFtc1xuICAgICAqL1xuICAgIHNldEd1aShndWk6IGRhdC5HVUkpOiB2b2lkIHtcbiAgICAgICAgZ3VpLmFkZCh0aGlzLl9jZW50cmUsICd4Jyk7XG4gICAgICAgIGd1aS5hZGQodGhpcy5fY2VudHJlLCAneScpO1xuICAgICAgICBndWkuYWRkKHRoaXMsICdfc2l6ZScpO1xuICAgICAgICBndWkuYWRkKHRoaXMsICdfZGVjYXknLCAwLCA1MCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJwb2xhdGVzIGJldHdlZW4gKDAgYW5kIDEpXmRlY2F5XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldFRlbnNvcldlaWdodChwb2ludDogVmVjdG9yKTogbnVtYmVyIHsgICAgICAgIFxuICAgICAgICBjb25zdCBub3JtRGlzdGFuY2VUb0NlbnRyZSA9IHBvaW50LmNsb25lKCkuc3ViKHRoaXMuX2NlbnRyZSkubGVuZ3RoKCkgLyB0aGlzLl9zaXplO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcCAoKiogMCkgdHVybmluZyB3ZWlnaHQgaW50byAxLCBmaWxsaW5nIHNjcmVlbiBldmVuIHdoZW4gb3V0c2lkZSAnc2l6ZSdcbiAgICAgICAgaWYgKHRoaXMuX2RlY2F5ID09PSAwICYmIG5vcm1EaXN0YW5jZVRvQ2VudHJlID49IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCAoMSAtIG5vcm1EaXN0YW5jZVRvQ2VudHJlKSkgKiogdGhpcy5fZGVjYXk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgR3JpZCBleHRlbmRzIEJhc2lzRmllbGQge1xuICAgIHJlYWRvbmx5IEZPTERFUl9OQU1FID0gYEdyaWQgJHtHcmlkLmZvbGRlck5hbWVJbmRleCsrfWA7XG5cbiAgICBjb25zdHJ1Y3RvcihjZW50cmU6IFZlY3Rvciwgc2l6ZTogbnVtYmVyLCBkZWNheTogbnVtYmVyLCBwcml2YXRlIF90aGV0YTogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKGNlbnRyZSwgc2l6ZSwgZGVjYXkpO1xuICAgIH1cblxuICAgIHNldCB0aGV0YSh0aGV0YTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3RoZXRhID0gdGhldGE7XG4gICAgfVxuXG4gICAgc2V0R3VpKGd1aTogZGF0LkdVSSk6IHZvaWQge1xuICAgICAgICBzdXBlci5zZXRHdWkoZ3VpKTtcblxuICAgICAgICAvLyBHVUkgaW4gZGVncmVlcywgY29udmVydCB0byByYWRzXG4gICAgICAgIGNvbnN0IHRoZXRhUHJvcCA9IHt0aGV0YTogdGhpcy5fdGhldGEgKiAxODAgLyBNYXRoLlBJfTtcbiAgICAgICAgY29uc3QgdGhldGFDb250cm9sbGVyID0gZ3VpLmFkZCh0aGV0YVByb3AsICd0aGV0YScsIC05MCwgOTApO1xuICAgICAgICB0aGV0YUNvbnRyb2xsZXIub25DaGFuZ2UodGhldGEgPT4gdGhpcy5fdGhldGEgPSB0aGV0YSAqIChNYXRoLlBJIC8gMTgwKSk7XG4gICAgfVxuXG4gICAgZ2V0VGVuc29yKHBvaW50OiBWZWN0b3IpOiBUZW5zb3Ige1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcygyICogdGhpcy5fdGhldGEpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbigyICogdGhpcy5fdGhldGEpO1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigxLCBbY29zLCBzaW5dKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSYWRpYWwgZXh0ZW5kcyBCYXNpc0ZpZWxkIHtcbiAgICByZWFkb25seSBGT0xERVJfTkFNRSA9IGBSYWRpYWwgJHtSYWRpYWwuZm9sZGVyTmFtZUluZGV4Kyt9YDtcbiAgICBjb25zdHJ1Y3RvcihjZW50cmU6IFZlY3Rvciwgc2l6ZTogbnVtYmVyLCBkZWNheTogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKGNlbnRyZSwgc2l6ZSwgZGVjYXkpO1xuICAgIH1cblxuICAgIGdldFRlbnNvcihwb2ludDogVmVjdG9yKTogVGVuc29yIHtcbiAgICAgICAgY29uc3QgdCA9IHBvaW50LmNsb25lKCkuc3ViKHRoaXMuX2NlbnRyZSk7XG4gICAgICAgIGNvbnN0IHQxID0gdC55KioyIC0gdC54KioyO1xuICAgICAgICBjb25zdCB0MiA9IC0yICogdC54ICogdC55O1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigxLCBbdDEsIHQyXSk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCAqIGFzIGlzZWN0IGZyb20gJ2lzZWN0JztcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzLXF1YWR0cmVlJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuZGVjbGFyZSBtb2R1bGUgJ2lzZWN0JyB7XG4gICAgZXhwb3J0IGZ1bmN0aW9uIGJ1c2gobGluZXM6IFNlZ21lbnRbXSk6IERldGVjdEludGVyc2VjdGlvbnM7XG59XG5cbmludGVyZmFjZSBEZXRlY3RJbnRlcnNlY3Rpb25zIHtcbiAgICBydW46ICgpID0+IEludGVyc2VjdGlvbltdO1xufVxuXG5pbnRlcmZhY2UgU2VnbWVudCB7XG4gICAgZnJvbTogVmVjdG9yO1xuICAgIHRvOiBWZWN0b3I7XG59XG5cbmludGVyZmFjZSBJbnRlcnNlY3Rpb24ge1xuICAgIHBvaW50OiBWZWN0b3I7XG4gICAgc2VnbWVudHM6IFNlZ21lbnRbXTtcbn1cblxuZXhwb3J0IGNsYXNzIE5vZGUge1xuICAgIHB1YmxpYyBzZWdtZW50cyA9IG5ldyBTZXQ8U2VnbWVudD4oKTtcbiAgICBwdWJsaWMgYWRqOiBOb2RlW107XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IFZlY3RvciwgcHVibGljIG5laWdoYm9ycz1uZXcgU2V0PE5vZGU+KCkpIHt9XG5cbiAgICBhZGRTZWdtZW50KHNlZ21lbnQ6IFNlZ21lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZWdtZW50cy5hZGQoc2VnbWVudCk7XG4gICAgfVxuXG4gICAgYWRkTmVpZ2hib3Iobm9kZTogTm9kZSk6IHZvaWQge1xuICAgICAgICBpZiAobm9kZSAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcnMuYWRkKG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5uZWlnaGJvcnMuYWRkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaCB7XG4gICAgcHVibGljIG5vZGVzOiBOb2RlW107XG4gICAgcHVibGljIGludGVyc2VjdGlvbnM6IFZlY3RvcltdO1xuXG4gICAgY29uc3RydWN0b3Ioc3RyZWFtbGluZXM6IFZlY3RvcltdW10sIGRzdGVwOiBudW1iZXIsIGRlbGV0ZURhbmdsaW5nPWZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBpc2VjdC5idXNoKHRoaXMuc3RyZWFtbGluZXNUb1NlZ21lbnQoc3RyZWFtbGluZXMpKS5ydW4oKTtcbiAgICAgICAgY29uc3QgcXVhZHRyZWUgPSAoZDMucXVhZHRyZWUoKSBhcyBkMy5RdWFkdHJlZTxOb2RlPikueChuID0+IG4udmFsdWUueCkueShuID0+IG4udmFsdWUueSk7XG4gICAgICAgIGNvbnN0IG5vZGVBZGRSYWRpdXMgPSAwLjAwMTtcblxuICAgICAgICAvLyBBZGQgYWxsIHNlZ21lbnQgc3RhcnQgYW5kIGVuZHBvaW50c1xuICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2Ygc3RyZWFtbGluZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZShzdHJlYW1saW5lW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRTZWdtZW50KHRoaXMudmVjdG9yc1RvU2VnbWVudChzdHJlYW1saW5lW2kgLSAxXSwgc3RyZWFtbGluZVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgc3RyZWFtbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkU2VnbWVudCh0aGlzLnZlY3RvcnNUb1NlZ21lbnQoc3RyZWFtbGluZVtpXSwgc3RyZWFtbGluZVtpICsgMV0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZ1enp5QWRkVG9RdWFkdHJlZShxdWFkdHJlZSwgbm9kZSwgbm9kZUFkZFJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYWxsIGludGVyc2VjdGlvbnNcbiAgICAgICAgZm9yIChjb25zdCBpbnRlcnNlY3Rpb24gb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKG5ldyBWZWN0b3IoaW50ZXJzZWN0aW9uLnBvaW50LngsIGludGVyc2VjdGlvbi5wb2ludC55KSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgaW50ZXJzZWN0aW9uLnNlZ21lbnRzKSBub2RlLmFkZFNlZ21lbnQocyk7XG4gICAgICAgICAgICB0aGlzLmZ1enp5QWRkVG9RdWFkdHJlZShxdWFkdHJlZSwgbm9kZSwgbm9kZUFkZFJhZGl1cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgZWFjaCBzaW1wbGlmaWVkIHN0cmVhbWxpbmUsIGJ1aWxkIGxpc3Qgb2Ygbm9kZXMgaW4gb3JkZXIgYWxvbmcgc3RyZWFtbGluZVxuICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2Ygc3RyZWFtbGluZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2Rlc0Fsb25nU2VnbWVudCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Tm9kZXNBbG9uZ1NlZ21lbnQodGhpcy52ZWN0b3JzVG9TZWdtZW50KHN0cmVhbWxpbmVbaV0sIHN0cmVhbWxpbmVbaSArIDFdKSwgcXVhZHRyZWUsIG5vZGVBZGRSYWRpdXMsIGRzdGVwKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobm9kZXNBbG9uZ1NlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVzQWxvbmdTZWdtZW50Lmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNBbG9uZ1NlZ21lbnRbal0uYWRkTmVpZ2hib3Iobm9kZXNBbG9uZ1NlZ21lbnRbaisxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJFcnJvciBHcmFwaC5qczogc2VnbWVudCB3aXRoIGxlc3MgdGhhbiAyIG5vZGVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFxuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgcXVhZHRyZWUuZGF0YSgpKSB7XG4gICAgICAgICAgICBpZiAoZGVsZXRlRGFuZ2xpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZURhbmdsaW5nTm9kZXMobiwgcXVhZHRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4uYWRqID0gQXJyYXkuZnJvbShuLm5laWdoYm9ycyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vZGVzID0gcXVhZHRyZWUuZGF0YSgpO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGludGVyc2VjdGlvbnMpIHRoaXMuaW50ZXJzZWN0aW9ucy5wdXNoKG5ldyBWZWN0b3IoaS5wb2ludC54LCBpLnBvaW50LnkpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlbGV0ZURhbmdsaW5nTm9kZXMobjogTm9kZSwgcXVhZHRyZWU6IGQzLlF1YWR0cmVlPE5vZGU+KSB7XG4gICAgICAgIGlmIChuLm5laWdoYm9ycy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICBxdWFkdHJlZS5yZW1vdmUobik7XG4gICAgICAgICAgICBmb3IgKGxldCBuZWlnaGJvciBvZiBuLm5laWdoYm9ycykge1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLm5laWdoYm9ycy5kZWxldGUobik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVEYW5nbGluZ05vZGVzKG5laWdoYm9yLCBxdWFkdHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE5vZGVzQWxvbmdTZWdtZW50KHNlZ21lbnQ6IFNlZ21lbnQsIHF1YWR0cmVlOiBkMy5RdWFkdHJlZTxOb2RlPiwgcmFkaXVzOiBudW1iZXIsIHN0ZXA6IG51bWJlcik6IE5vZGVbXSB7XG4gICAgICAgIC8vIFdhbGsgZHN0ZXAgYWxvbmcgZWFjaCBzdHJlYW1saW5lLCBhZGRpbmcgbm9kZXMgd2l0aGluIGRzdGVwLzJcbiAgICAgICAgLy8gYW5kIGNvbm5lY3RlZCB0byB0aGlzIHN0cmVhbWxpbmUgKGZ1enp5IC0gbm9kZUFkZFJhZGl1cykgdG8gbGlzdCwgcmVtb3ZpbmcgZnJvbVxuICAgICAgICAvLyBxdWFkdHJlZSBhbmQgYWRkaW5nIHRoZW0gYWxsIGJhY2sgYXQgdGhlIGVuZFxuXG4gICAgICAgIGNvbnN0IGZvdW5kTm9kZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgbm9kZXNBbG9uZ1NlZ21lbnQ6IE5vZGVbXSA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IFZlY3RvcihzZWdtZW50LmZyb20ueCwgc2VnbWVudC5mcm9tLnkpO1xuICAgICAgICBjb25zdCBlbmQgPSBuZXcgVmVjdG9yKHNlZ21lbnQudG8ueCwgc2VnbWVudC50by55KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRpZmZlcmVuY2VWZWN0b3IgPSBlbmQuY2xvbmUoKS5zdWIoc3RhcnQpO1xuICAgICAgICBzdGVwID0gTWF0aC5taW4oc3RlcCwgZGlmZmVyZW5jZVZlY3Rvci5sZW5ndGgoKSAvIDIpOyAgLy8gTWluIG9mIDIgc3RlcCBhbG9uZyB2ZWN0b3JcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBNYXRoLmNlaWwoZGlmZmVyZW5jZVZlY3Rvci5sZW5ndGgoKSAvIHN0ZXApO1xuICAgICAgICBjb25zdCBkaWZmZXJlbmNlVmVjdG9yTGVuZ3RoID0gZGlmZmVyZW5jZVZlY3Rvci5sZW5ndGgoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBzdGVwczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFBvaW50ID0gc3RhcnQuY2xvbmUoKS5hZGQoZGlmZmVyZW5jZVZlY3Rvci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGkgLyBzdGVwcykpO1xuXG4gICAgICAgICAgICAvLyBPcmRlciBub2Rlcywgbm90IGJ5ICdjbG9zZW5lc3MnLCBidXQgYnkgZG90IHByb2R1Y3RcbiAgICAgICAgICAgIGxldCBub2Rlc1RvQWRkID0gW107XG4gICAgICAgICAgICBsZXQgY2xvc2VzdE5vZGUgPSBxdWFkdHJlZS5maW5kKGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSwgcmFkaXVzICsgc3RlcC8yKTtcblxuICAgICAgICAgICAgd2hpbGUgKGNsb3Nlc3ROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWFkdHJlZS5yZW1vdmUoY2xvc2VzdE5vZGUpO1xuICAgICAgICAgICAgICAgIGZvdW5kTm9kZXMucHVzaChjbG9zZXN0Tm9kZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGV0IG5vZGVPblNlZ21lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzIG9mIGNsb3Nlc3ROb2RlLnNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1enp5U2VnbWVudHNFcXVhbChzLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9uU2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChub2RlT25TZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9BZGQucHVzaChjbG9zZXN0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xvc2VzdE5vZGUgPSBxdWFkdHJlZS5maW5kKGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSwgcmFkaXVzICsgc3RlcC8yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZXNUb0FkZC5zb3J0KChmaXJzdDogTm9kZSwgc2Vjb25kOiBOb2RlKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZG90UHJvZHVjdFRvU2VnbWVudChmaXJzdCwgc3RhcnQsIGRpZmZlcmVuY2VWZWN0b3IpIC0gdGhpcy5kb3RQcm9kdWN0VG9TZWdtZW50KHNlY29uZCwgc3RhcnQsIGRpZmZlcmVuY2VWZWN0b3IpKTtcbiAgICAgICAgICAgIG5vZGVzQWxvbmdTZWdtZW50LnB1c2goLi4ubm9kZXNUb0FkZCk7XG4gICAgICAgIH1cblxuICAgICAgICBxdWFkdHJlZS5hZGRBbGwoZm91bmROb2Rlcyk7XG4gICAgICAgIHJldHVybiBub2Rlc0Fsb25nU2VnbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZ1enp5U2VnbWVudHNFcXVhbChzMTogU2VnbWVudCwgczI6IFNlZ21lbnQsIHRvbGVyYW5jZT0wLjAwMDEpOiBib29sZWFuIHtcbiAgICAgICAgLy8gRnJvbVxuICAgICAgICBpZiAoczEuZnJvbS54IC0gczIuZnJvbS54ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoczEuZnJvbS55IC0gczIuZnJvbS55ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb1xuXG4gICAgICAgIGlmIChzMS50by54IC0gczIudG8ueCA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHMxLnRvLnkgLSBzMi50by55ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRvdFByb2R1Y3RUb1NlZ21lbnQobm9kZTogTm9kZSwgc3RhcnQ6IFZlY3RvciwgZGlmZmVyZW5jZVZlY3RvcjogVmVjdG9yKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgZG90VmVjdG9yID0gbm9kZS52YWx1ZS5jbG9uZSgpLnN1YihzdGFydCk7XG4gICAgICAgIHJldHVybiBkaWZmZXJlbmNlVmVjdG9yLmRvdChkb3RWZWN0b3IpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZnV6enlBZGRUb1F1YWR0cmVlKHF1YWR0cmVlOiBkMy5RdWFkdHJlZTxOb2RlPiwgbm9kZTogTm9kZSwgcmFkaXVzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gT25seSBhZGQgaWYgdGhlcmUgaXNuJ3QgYSBub2RlIHdpdGhpbiByYWRpdXNcbiAgICAgICAgLy8gUmVtZW1iZXIgdG8gY2hlY2sgZm9yIGRvdWJsZSByYWRpdXMgd2hlbiBxdWVyeWluZyB0cmVlLCBvciBwb2ludCBtaWdodCBiZSBtaXNzZWRcbiAgICAgICAgY29uc3QgZXhpc3RpbmdOb2RlID0gcXVhZHRyZWUuZmluZChub2RlLnZhbHVlLngsIG5vZGUudmFsdWUueSwgcmFkaXVzKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBxdWFkdHJlZS5hZGQobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5laWdoYm9yIG9mIG5vZGUubmVpZ2hib3JzKSBleGlzdGluZ05vZGUuYWRkTmVpZ2hib3IobmVpZ2hib3IpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIG5vZGUuc2VnbWVudHMpIGV4aXN0aW5nTm9kZS5hZGRTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdHJlYW1saW5lc1RvU2VnbWVudChzdHJlYW1saW5lczogVmVjdG9yW11bXSk6IFNlZ21lbnRbXSB7XG4gICAgICAgIGNvbnN0IG91dDogU2VnbWVudFtdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzdHJlYW1saW5lcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHRoaXMudmVjdG9yc1RvU2VnbWVudChzW2ldLCBzW2kgKyAxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZlY3RvcnNUb1NlZ21lbnQodjE6IFZlY3RvciwgdjI6IFZlY3Rvcik6IFNlZ21lbnQge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogdjEsXG4gICAgICAgICAgICB0bzogICB2MlxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRTdG9yYWdlIHtcblxuICAgIHByaXZhdGUgZ3JpZERpbWVuc2lvbnM6IFZlY3RvcjtcbiAgICBwcml2YXRlIGdyaWQ6IFZlY3RvcltdW11bXTtcbiAgICBwcml2YXRlIGRzZXBTcTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogd29ybGREaW1lbnNpb25zIGFzc3VtZXMgb3JpZ2luIG9mIDAsMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkc2VwIFNlcGFyYXRpb24gZGlzdGFuY2UgYmV0d2VlbiBzYW1wbGVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKHByaXZhdGUgd29ybGREaW1lbnNpb25zOiBWZWN0b3IsIHByaXZhdGUgb3JpZ2luOiBWZWN0b3IsIHByaXZhdGUgZHNlcDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZHNlcFNxID0gdGhpcy5kc2VwICogdGhpcy5kc2VwO1xuICAgICAgICB0aGlzLmdyaWREaW1lbnNpb25zID0gd29ybGREaW1lbnNpb25zLmNsb25lKCkuZGl2aWRlU2NhbGFyKHRoaXMuZHNlcCk7XG4gICAgICAgIHRoaXMuZ3JpZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuZ3JpZERpbWVuc2lvbnMueDsgeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQucHVzaChbXSk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuZ3JpZERpbWVuc2lvbnMueTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkW3hdLnB1c2goW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGFsbCBzYW1wbGVzIGZyb20gYW5vdGhlciBncmlkIHRvIHRoaXMgb25lXG4gICAgICovXG4gICAgYWRkQWxsKGdyaWRTdG9yYWdlOiBHcmlkU3RvcmFnZSk6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBncmlkU3RvcmFnZS5ncmlkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNhbXBsZShzYW1wbGUpOyAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkUG9seWxpbmUobGluZTogVmVjdG9yW10pOiB2b2lkIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIGxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2FtcGxlKHYpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmZvcmNlIHNlcGFyYXRpb25cbiAgICAgKiBEb2VzIG5vdCBjbG9uZVxuICAgICAqL1xuICAgIGFkZFNhbXBsZSh2OiBWZWN0b3IsIGNvb3Jkcz86IFZlY3Rvcik6IHZvaWQge1xuICAgICAgICBpZiAoIWNvb3Jkcykge1xuICAgICAgICAgICAgY29vcmRzID0gdGhpcy5nZXRTYW1wbGVDb29yZHModik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkW2Nvb3Jkcy54XVtjb29yZHMueV0ucHVzaCh2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIHYgaXMgYXQgbGVhc3QgZCBhd2F5IGZyb20gc2FtcGxlc1xuICAgICAqIFBlcmZvcm1hbmNlIHZlcnkgaW1wb3J0YW50IC0gdGhpcyBpcyBjYWxsZWQgYXQgZXZlcnkgaW50ZWdyYXRpb24gc3RlcFxuICAgICAqIEBwYXJhbSBkU3E9dGhpcy5kc2VwU3Egc3F1YXJlZCB0ZXN0IGRpc3RhbmNlXG4gICAgICogQ291bGQgYmUgZHRlc3QgaWYgd2UgYXJlIGludGVncmF0aW5nIGEgc3RyZWFtbGluZVxuICAgICAqL1xuICAgIGlzVmFsaWRTYW1wbGUodjogVmVjdG9yLCBkU3E9dGhpcy5kc2VwU3EpOiBib29sZWFuIHtcbiAgICAgICAgLy8gQ29kZSBkdXBsaWNhdGlvbiB3aXRoIHRoaXMuZ2V0TmVhcmJ5UG9pbnRzIGJ1dCBtdWNoIHNsb3dlciB3aGVuIGNhbGxpbmdcbiAgICAgICAgLy8gdGhpcy5nZXROZWFyYnlQb2ludHMgZHVlIHRvIGFycmF5IGNyZWF0aW9uIGluIHRoYXQgbWV0aG9kXG5cbiAgICAgICAgY29uc3QgY29vcmRzID0gdGhpcy5nZXRTYW1wbGVDb29yZHModik7XG5cbiAgICAgICAgLy8gQ2hlY2sgc2FtcGxlcyBpbiA5IGNlbGxzIGluIDN4MyBncmlkXG4gICAgICAgIGZvciAobGV0IHggPSAtMTsgeCA8PSAxOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAtMTsgeSA8PSAxOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY29vcmRzLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IoeCwgeSkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy52ZWN0b3JPdXRPZkJvdW5kcyhjZWxsLCB0aGlzLmdyaWREaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmVjdG9yRmFyRnJvbVZlY3RvcnModiwgdGhpcy5ncmlkW2NlbGwueF1bY2VsbC55XSwgZFNxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB2IGlzIGF0IGxlYXN0IGQgYXdheSBmcm9tIHZlY3RvcnNcbiAgICAgKiBQZXJmb3JtYW5jZSB2ZXJ5IGltcG9ydGFudCAtIHRoaXMgaXMgY2FsbGVkIGF0IGV2ZXJ5IGludGVncmF0aW9uIHN0ZXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICBkU3EgICAgIHNxdWFyZWQgdGVzdCBkaXN0YW5jZVxuICAgICAqL1xuICAgIHZlY3RvckZhckZyb21WZWN0b3JzKHY6IFZlY3RvciwgdmVjdG9yczogVmVjdG9yW10sIGRTcTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIHZlY3RvcnMpIHtcbiAgICAgICAgICAgIGlmIChzYW1wbGUgIT09IHYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZVNxID0gc2FtcGxlLmRpc3RhbmNlVG9TcXVhcmVkKHYpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVNxIDwgZFNxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBvaW50cyBpbiBjZWxscyBzdXJyb3VuZGluZyB2XG4gICAgICogUmVzdWx0cyBpbmNsdWRlIHYsIGlmIGl0IGV4aXN0cyBpbiB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXR1cm5zIHNhbXBsZXMgKGtpbmQgb2YpIGNsb3NlciB0aGFuIGRpc3RhbmNlIC0gcmV0dXJucyBhbGwgc2FtcGxlcyBpbiBcbiAgICAgKiBjZWxscyBzbyBhcHByb3hpbWF0aW9uIChzcXVhcmUgdG8gYXBwcm94aW1hdGUgY2lyY2xlKVxuICAgICAqL1xuICAgIGdldE5lYXJieVBvaW50cyh2OiBWZWN0b3IsIGRpc3RhbmNlOiBudW1iZXIpOiBWZWN0b3JbXSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGguY2VpbCgoZGlzdGFuY2UvdGhpcy5kc2VwKSAtIDAuNSk7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuZ2V0U2FtcGxlQ29vcmRzKHYpO1xuICAgICAgICBjb25zdCBvdXQ6IFZlY3RvcltdID0gW107XG4gICAgICAgIGZvciAobGV0IHggPSAtMSAqIHJhZGl1czsgeCA8PSAxICogcmFkaXVzOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAtMSAqIHJhZGl1czsgeSA8PSAxICogcmFkaXVzOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY29vcmRzLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IoeCwgeSkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy52ZWN0b3JPdXRPZkJvdW5kcyhjZWxsLCB0aGlzLmdyaWREaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYyIG9mIHRoaXMuZ3JpZFtjZWxsLnhdW2NlbGwueV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHYyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB3b3JsZFRvR3JpZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5jbG9uZSgpLnN1Yih0aGlzLm9yaWdpbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBncmlkVG9Xb3JsZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5jbG9uZSgpLmFkZCh0aGlzLm9yaWdpbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2ZWN0b3JPdXRPZkJvdW5kcyhncmlkVjogVmVjdG9yLCBib3VuZHM6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGdyaWRWLnggPCAwIHx8IGdyaWRWLnkgPCAwIHx8XG4gICAgICAgICAgICBncmlkVi54ID49IGJvdW5kcy54IHx8IGdyaWRWLnkgPj0gYm91bmRzLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gICBDZWxsIGNvb3JkcyBjb3JyZXNwb25kaW5nIHRvIHZlY3RvclxuICAgICAqIFBlcmZvcm1hbmNlIGltcG9ydGFudCAtIGNhbGxlZCBhdCBldmVyeSBpbnRlZ3JhdGlvbiBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTYW1wbGVDb29yZHMod29ybGRWOiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCB2ID0gdGhpcy53b3JsZFRvR3JpZCh3b3JsZFYpO1xuICAgICAgICBpZiAodGhpcy52ZWN0b3JPdXRPZkJvdW5kcyh2LCB0aGlzLndvcmxkRGltZW5zaW9ucykpIHtcbiAgICAgICAgICAgIC8vIGxvZy5lcnJvcihcIlRyaWVkIHRvIGFjY2VzcyBvdXQtb2YtYm91bmRzIHNhbXBsZSBpbiBncmlkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFZlY3Rvci56ZXJvVmVjdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihcbiAgICAgICAgICAgIE1hdGguZmxvb3Iodi54IC8gdGhpcy5kc2VwKSxcbiAgICAgICAgICAgIE1hdGguZmxvb3Iodi55IC8gdGhpcy5kc2VwKVxuICAgICAgICApO1xuICAgIH1cbn1cbiIsImltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4vc3RyZWFtbGluZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBGaWVsZEludGVncmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBmaWVsZDogVGVuc29yRmllbGQpIHt9XG5cbiAgICBhYnN0cmFjdCBpbnRlZ3JhdGUocG9pbnQ6IFZlY3RvciwgbWFqb3I6IGJvb2xlYW4pOiBWZWN0b3I7XG5cbiAgICBwcm90ZWN0ZWQgc2FtcGxlRmllbGRWZWN0b3IocG9pbnQ6IFZlY3RvciwgbWFqb3I6IGJvb2xlYW4pOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCB0ZW5zb3IgPSB0aGlzLmZpZWxkLnNhbXBsZVBvaW50KHBvaW50KTtcbiAgICAgICAgaWYgKG1ham9yKSByZXR1cm4gdGVuc29yLmdldE1ham9yKCk7XG4gICAgICAgIHJldHVybiB0ZW5zb3IuZ2V0TWlub3IoKTtcbiAgICB9XG5cbiAgICBvbkxhbmQocG9pbnQ6IFZlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5vbkxhbmQocG9pbnQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEV1bGVySW50ZWdyYXRvciBleHRlbmRzIEZpZWxkSW50ZWdyYXRvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBzdXBlcihmaWVsZCk7XG4gICAgfVxuXG4gICAgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQsIG1ham9yKS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5kc3RlcCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUks0SW50ZWdyYXRvciBleHRlbmRzIEZpZWxkSW50ZWdyYXRvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBzdXBlcihmaWVsZCk7XG4gICAgfVxuXG4gICAgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yIHtcbiAgICAgICAgY29uc3QgazEgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LCBtYWpvcik7XG4gICAgICAgIGNvbnN0IGsyMyA9IHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQuY2xvbmUoKS5hZGQoVmVjdG9yLmZyb21TY2FsYXIodGhpcy5wYXJhbXMuZHN0ZXAgLyAyKSksIG1ham9yKTtcbiAgICAgICAgY29uc3QgazQgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LmNsb25lKCkuYWRkKFZlY3Rvci5mcm9tU2NhbGFyKHRoaXMucGFyYW1zLmRzdGVwKSksIG1ham9yKTtcblxuICAgICAgICByZXR1cm4gazEuYWRkKGsyMy5tdWx0aXBseVNjYWxhcig0KSkuYWRkKGs0KS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5kc3RlcCAvIDYpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge05vZGV9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4vcG9seWdvbl91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBQb2x5Z29uUGFyYW1zIHtcbiAgICBtYXhMZW5ndGg6IG51bWJlcjtcbiAgICBtaW5BcmVhOiBudW1iZXI7XG4gICAgbWF4QXNwZWN0UmF0aW86IG51bWJlcjtcbiAgICBzaHJpbmtTcGFjaW5nOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb25GaW5kZXIge1xuICAgIHByaXZhdGUgX3BvbHlnb25zOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHJpdmF0ZSBfc2hydW5rUG9seWdvbnM6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwcml2YXRlIF9kaXZpZGVkUG9seWdvbnM6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwcml2YXRlIHRvU2hyaW5rOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHJpdmF0ZSByZXNvbHZlU2hyaW5rOiAoKSA9PiB2b2lkO1xuICAgIHByaXZhdGUgdG9EaXZpZGU6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwcml2YXRlIHJlc29sdmVEaXZpZGU6ICgpID0+IHZvaWQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5vZGVzOiBOb2RlW10sIHByaXZhdGUgcGFyYW1zOiBQb2x5Z29uUGFyYW1zKSB7fVxuXG4gICAgZ2V0IHBvbHlnb25zKCk6IFZlY3RvcltdW10ge1xuICAgICAgICBpZiAodGhpcy5fZGl2aWRlZFBvbHlnb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXZpZGVkUG9seWdvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2hydW5rUG9seWdvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NocnVua1BvbHlnb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnRvU2hyaW5rID0gW107XG4gICAgICAgIHRoaXMudG9EaXZpZGUgPSBbXTtcbiAgICAgICAgdGhpcy5fcG9seWdvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hydW5rUG9seWdvbnMgPSBbXVxuICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMgPSBbXTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBjaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMudG9TaHJpbmsubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSB0aGlzLnRvU2hyaW5rLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIGNvbnN0IHNocnVuayA9IFBvbHlnb25VdGlsLnJlc2l6ZUdlb21ldHJ5KHRoaXMudG9TaHJpbmsucG9wKCksIC10aGlzLnBhcmFtcy5zaHJpbmtTcGFjaW5nKTtcbiAgICAgICAgICAgIGlmIChzaHJ1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NocnVua1BvbHlnb25zLnB1c2goc2hydW5rKVxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlc29sdmUpIHRoaXMucmVzb2x2ZVNocmluaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudG9EaXZpZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSB0aGlzLnRvRGl2aWRlLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIGNvbnN0IGRpdmlkZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBQb2x5Z29uVXRpbC5zdWJkaXZpZGVQb2x5Z29uKHRoaXMudG9EaXZpZGUucG9wKCksIHRoaXMucGFyYW1zLm1pbkFyZWEsIHRoaXMucGFyYW1zLm1pbkFyZWEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFBvbHlnb25VdGlsLmNhbGNQb2x5Z29uQXJlYShwKSA+IHRoaXMucGFyYW1zLm1pbkFyZWEgKiAwLjQpIGRpdmlkZWQucHVzaChwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpdmlkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpdmlkZWRQb2x5Z29ucy5wdXNoKC4uLmRpdmlkZWQpO1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc29sdmUpIHRoaXMucmVzb2x2ZURpdmlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuXG4gICAgYXN5bmMgc2hyaW5rKGFuaW1hdGU9ZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluZFBvbHlnb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRvU2hyaW5rID0gdGhpcy5fcG9seWdvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVTaHJpbmsgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaHJ1bmtQb2x5Z29ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLl9wb2x5Z29ucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaHJ1bmsgPSBQb2x5Z29uVXRpbC5yZXNpemVHZW9tZXRyeShwLCAtdGhpcy5wYXJhbXMuc2hyaW5rU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaHJ1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hydW5rUG9seWdvbnMucHVzaChzaHJ1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGl2aWRlKGFuaW1hdGU9ZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluZFBvbHlnb25zKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwb2x5Z29ucyA9IHRoaXMuX3BvbHlnb25zO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NocnVua1BvbHlnb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29ucyA9IHRoaXMuX3NocnVua1BvbHlnb25zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy50b0RpdmlkZSA9IHBvbHlnb25zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlRGl2aWRlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpdmlkZWQ6IFZlY3RvcltdW10gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcG9seWdvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlZC5wdXNoKC4uLlBvbHlnb25VdGlsLnN1YmRpdmlkZVBvbHlnb24ocCwgdGhpcy5wYXJhbXMubWluQXJlYSwgdGhpcy5wYXJhbXMubWluQXJlYSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgZGl2aWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUG9seWdvblV0aWwuY2FsY1BvbHlnb25BcmVhKHApID4gdGhpcy5wYXJhbXMubWluQXJlYSAqIDAuNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGl2aWRlZFBvbHlnb25zLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmaW5kUG9seWdvbnMoKTogdm9pZCB7XG4gICAgICAgIC8vIE5vZGVcbiAgICAgICAgLy8geCwgeSwgdmFsdWUgKFZlY3RvcjIpLCBhZGogKGxpc3Qgb2Ygbm9kZSByZWZzKVxuICAgICAgICAvLyBHb25uYSBlZGl0IGFkaiBmb3Igbm93XG5cbiAgICAgICAgLy8gV2FsayBhIGNsb2Nrd2lzZSBwYXRoIHVudGlsIHBvbHlnb24gZm91bmQgb3IgbGltaXQgcmVhY2hlZFxuICAgICAgICAvLyBXaGVuIHdlIGZpbmQgYSBwb2x5Z29uLCBtYXJrIGFsbCBlZGdlcyBhcyB0cmF2ZXJzZWQgKGluIHBhcnRpY3VsYXIgZGlyZWN0aW9uKVxuICAgICAgICAvLyBFYWNoIGVkZ2Ugc2VwYXJhdGVzIHR3byBwb2x5Z29uc1xuICAgICAgICAvLyBJZiBlZGdlIGFscmVhZHkgdHJhdmVyc2VkIGluIHRoaXMgZGlyZWN0aW9uLCB0aGlzIHBvbHlnb24gaGFzIGFscmVhZHkgYmVlbiBmb3VuZFxuICAgICAgICB0aGlzLl9zaHJ1bmtQb2x5Z29ucyA9IFtdO1xuICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgcG9seWdvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmFkai5sZW5ndGggPCAyKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IG5leHROb2RlIG9mIG5vZGUuYWRqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9seWdvbiA9IHRoaXMucmVjdXJzaXZlV2Fsayhbbm9kZSwgbmV4dE5vZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbiAhPT0gbnVsbCAmJiBwb2x5Z29uLmxlbmd0aCA8IHRoaXMucGFyYW1zLm1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVBvbHlnb25BZGphY2VuY2llcyhwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uLm1hcChuID0+IG4udmFsdWUuY2xvbmUoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BvbHlnb25zID0gcG9seWdvbnM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW1vdmVQb2x5Z29uQWRqYWNlbmNpZXMocG9seWdvbjogTm9kZVtdKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHBvbHlnb25baV07XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gcG9seWdvblsoaSArIDEpICUgcG9seWdvbi5sZW5ndGhdO1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnQuYWRqLmluZGV4T2YobmV4dCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRqLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIlBvbHlnb25GaW5kZXIgLSBub2RlIG5vdCBpbiBhZGpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlY3Vyc2l2ZVdhbGsodmlzaXRlZDogTm9kZVtdLCBjb3VudD0wKTogTm9kZVtdIHtcbiAgICAgICAgaWYgKGNvdW50ID49IHRoaXMucGFyYW1zLm1heExlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIFRPRE8gYmFja3RyYWNraW5nIHRvIGZpbmQgcG9seWdvbnMgd2l0aCBkZWFkIGVuZCByb2FkcyBpbnNpZGUgdGhlbVxuICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMuZ2V0UmlnaHRtb3N0Tm9kZSh2aXNpdGVkW3Zpc2l0ZWQubGVuZ3RoIC0gMl0sIHZpc2l0ZWRbdmlzaXRlZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChuZXh0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7ICAvLyBDdXJyZW50bHkgaWdub3JlcyBwb2x5Z29ucyB3aXRoIGRlYWQgZW5kIGluc2lkZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmlzaXRlZEluZGV4ID0gdmlzaXRlZC5pbmRleE9mKG5leHROb2RlKTtcbiAgICAgICAgaWYgKHZpc2l0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRlZC5zbGljZSh2aXNpdGVkSW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaXRlZC5wdXNoKG5leHROb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVdhbGsodmlzaXRlZCwgY291bnQrKyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFJpZ2h0bW9zdE5vZGUobm9kZUZyb206IE5vZGUsIG5vZGVUbzogTm9kZSk6IE5vZGUge1xuICAgICAgICAvLyBXZSB3YW50IHRvIHR1cm4gcmlnaHQgYXQgZXZlcnkganVuY3Rpb25cbiAgICAgICAgaWYgKG5vZGVUby5hZGoubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBiYWNrd2FyZHNEaWZmZXJlbmNlVmVjdG9yID0gbm9kZUZyb20udmFsdWUuY2xvbmUoKS5zdWIobm9kZVRvLnZhbHVlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtQW5nbGUgPSBNYXRoLmF0YW4yKGJhY2t3YXJkc0RpZmZlcmVuY2VWZWN0b3IueSwgYmFja3dhcmRzRGlmZmVyZW5jZVZlY3Rvci54KTtcblxuICAgICAgICBsZXQgcmlnaHRtb3N0Tm9kZSA9IG51bGw7XG4gICAgICAgIGxldCBzbWFsbGVzdFRoZXRhID0gTWF0aC5QSSAqIDI7XG5cbiAgICAgICAgZm9yIChsZXQgbmV4dE5vZGUgb2Ygbm9kZVRvLmFkaikge1xuICAgICAgICAgICAgaWYgKG5leHROb2RlICE9PSBub2RlRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWZWN0b3IgPSBuZXh0Tm9kZS52YWx1ZS5jbG9uZSgpLnN1Yihub2RlVG8udmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0QW5nbGUgPSBNYXRoLmF0YW4yKG5leHRWZWN0b3IueSwgbmV4dFZlY3Rvci54KSAtIHRyYW5zZm9ybUFuZ2xlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0QW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRBbmdsZSArPSBNYXRoLlBJICogMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dEFuZ2xlIDwgc21hbGxlc3RUaGV0YSkge1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdFRoZXRhID0gbmV4dEFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICByaWdodG1vc3ROb2RlID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJpZ2h0bW9zdE5vZGU7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCAqIGFzIFBvbHlLIGZyb20gJ3BvbHlrJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCAqIGFzIGpzdHMgZnJvbSAnanN0cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb25VdGlsIHtcbiAgICBwcml2YXRlIHN0YXRpYyBnZW9tZXRyeUZhY3RvcnkgPSBuZXcganN0cy5nZW9tLkdlb21ldHJ5RmFjdG9yeSgpO1xuXG4gICAgLyoqXG4gICAgICogU2xpY2VzIHJlY3RhbmdsZSBieSBsaW5lLCByZXR1cm5pbmcgbGFyZ2VzdCBwb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBzbGljZVJlY3RhbmdsZShvcmlnaW46IFZlY3Rvciwgd29ybGREaW1lbnNpb25zOiBWZWN0b3IsIHAxOiBWZWN0b3IsIHAyOiBWZWN0b3IpOiBWZWN0b3JbXSB7XG4gICAgICAgIGNvbnN0IHJlY3RhbmdsZSA9IFtcbiAgICAgICAgICAgIG9yaWdpbi54LCBvcmlnaW4ueSxcbiAgICAgICAgICAgIG9yaWdpbi54ICsgd29ybGREaW1lbnNpb25zLngsIG9yaWdpbi55LFxuICAgICAgICAgICAgb3JpZ2luLnggKyB3b3JsZERpbWVuc2lvbnMueCwgb3JpZ2luLnkgKyB3b3JsZERpbWVuc2lvbnMueSxcbiAgICAgICAgICAgIG9yaWdpbi54LCBvcmlnaW4ueSArIHdvcmxkRGltZW5zaW9ucy55LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBzbGljZWQgPSBQb2x5Sy5TbGljZShyZWN0YW5nbGUsIHAxLngsIHAxLnksIHAyLngsIHAyLnkpLm1hcChwID0+IFBvbHlnb25VdGlsLnBvbHlnb25BcnJheVRvUG9seWdvbihwKSk7XG4gICAgICAgIGNvbnN0IG1pbkFyZWEgPSBQb2x5Z29uVXRpbC5jYWxjUG9seWdvbkFyZWEoc2xpY2VkWzBdKTtcblxuICAgICAgICBpZiAoc2xpY2VkLmxlbmd0aCA+IDEgJiYgUG9seWdvblV0aWwuY2FsY1BvbHlnb25BcmVhKHNsaWNlZFsxXSkgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICByZXR1cm4gc2xpY2VkWzFdO1xuICAgICAgICB9IFxuICAgICAgICByZXR1cm4gc2xpY2VkWzBdO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgY2FsY1BvbHlnb25BcmVhKHBvbHlnb246IFZlY3RvcltdKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgYWRkWCA9IHBvbHlnb25baV0ueDtcbiAgICAgICAgICBsZXQgYWRkWSA9IHBvbHlnb25baSA9PSBwb2x5Z29uLmxlbmd0aCAtIDEgPyAwIDogaSArIDFdLnk7XG4gICAgICAgICAgbGV0IHN1YlggPSBwb2x5Z29uW2kgPT0gcG9seWdvbi5sZW5ndGggLSAxID8gMCA6IGkgKyAxXS54O1xuICAgICAgICAgIGxldCBzdWJZID0gcG9seWdvbltpXS55O1xuXG4gICAgICAgICAgdG90YWwgKz0gKGFkZFggKiBhZGRZICogMC41KTtcbiAgICAgICAgICB0b3RhbCAtPSAoc3ViWCAqIHN1YlkgKiAwLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvdGFsKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHN1YmRpdmlkZVBvbHlnb24ocDogVmVjdG9yW10sIG1pbkFyZWE6IG51bWJlciwgbWF4QXNwZWN0UmF0aW86IG51bWJlcik6IFZlY3RvcltdW10ge1xuICAgICAgICBjb25zdCBhcmVhID0gUG9seWdvblV0aWwuY2FsY1BvbHlnb25BcmVhKHApO1xuICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiBbcF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGl2aWRlZDogVmVjdG9yW11bXSA9IFtdOyAgLy8gQXJyYXkgb2YgcG9seWdvbnNcblxuICAgICAgICBsZXQgbG9uZ2VzdFNpZGVMZW5ndGhTcSA9IDA7XG4gICAgICAgIGxldCBsb25nZXN0U2lkZSA9IFtwWzBdLCBwWzFdXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZGVMZW5ndGggPSBwW2ldLmNsb25lKCkuc3ViKHBbKGkrMSkgJSBwLmxlbmd0aF0pLmxlbmd0aFNxKCk7ICAvLyBUT0RPIHNxdWFyZWRcbiAgICAgICAgICAgIGlmIChzaWRlTGVuZ3RoID4gbG9uZ2VzdFNpZGVMZW5ndGhTcSkge1xuICAgICAgICAgICAgICAgIGxvbmdlc3RTaWRlTGVuZ3RoU3EgPSBzaWRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxvbmdlc3RTaWRlID0gW3BbaV0sIHBbKGkrMSkgJSBwLmxlbmd0aF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXNwZWN0IHJhdGlvIGFwcHJveGltYXRpb25cbiAgICAgICAgLy8gaWYgKGxvbmdlc3RTaWRlTGVuZ3RoU3EgLyBhcmVhID49IG1heEFzcGVjdFJhdGlvKSB7ICAvLyBBcHByb3hpbWF0aW9uXG4gICAgICAgIC8vICAgICByZXR1cm4gW107XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBCZXR3ZWVuIDAuNCBhbmQgMC42XG4gICAgICAgIGNvbnN0IGRldmlhdGlvbiA9IChNYXRoLnJhbmRvbSgpICogMC4yKSArIDAuNDtcblxuICAgICAgICBjb25zdCBhdmVyYWdlUG9pbnQgPSBsb25nZXN0U2lkZVswXS5jbG9uZSgpLmFkZChsb25nZXN0U2lkZVsxXSkubXVsdGlwbHlTY2FsYXIoZGV2aWF0aW9uKTtcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZVZlY3RvciA9IGxvbmdlc3RTaWRlWzBdLmNsb25lKCkuc3ViKGxvbmdlc3RTaWRlWzFdKTtcbiAgICAgICAgY29uc3QgcGVycFZlY3RvciA9IChuZXcgVmVjdG9yKGRpZmZlcmVuY2VWZWN0b3IueSwgLTEgKiBkaWZmZXJlbmNlVmVjdG9yLngpKVxuICAgICAgICAgICAgLm5vcm1hbGl6ZSgpXG4gICAgICAgICAgICAubXVsdGlwbHlTY2FsYXIoMTAwKTtcblxuICAgICAgICBjb25zdCBiaXNlY3QgPSBbYXZlcmFnZVBvaW50LmNsb25lKCkuYWRkKHBlcnBWZWN0b3IpLCBhdmVyYWdlUG9pbnQuY2xvbmUoKS5zdWIocGVycFZlY3RvcildO1xuXG4gICAgICAgIC8vIEFycmF5IG9mIHBvbHlnb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZWQgPSBQb2x5Sy5TbGljZShQb2x5Z29uVXRpbC5wb2x5Z29uVG9Qb2x5Z29uQXJyYXkocCksIGJpc2VjdFswXS54LCBiaXNlY3RbMF0ueSwgYmlzZWN0WzFdLngsIGJpc2VjdFsxXS55KTtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc2xpY2VkKSB7XG4gICAgICAgICAgICAgICAgZGl2aWRlZC5wdXNoKC4uLlBvbHlnb25VdGlsLnN1YmRpdmlkZVBvbHlnb24oUG9seWdvblV0aWwucG9seWdvbkFycmF5VG9Qb2x5Z29uKHMpLCBtaW5BcmVhLCBtYXhBc3BlY3RSYXRpbykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGl2aWRlZDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHJlc2l6ZUdlb21ldHJ5KGdlb21ldHJ5OiBWZWN0b3JbXSwgc3BhY2luZzogbnVtYmVyLCBpc1BvbHlnb249dHJ1ZSk6IFZlY3RvcltdIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzdHNHZW9tZXRyeSA9IGlzUG9seWdvbj8gUG9seWdvblV0aWwucG9seWdvblRvSnRzKGdlb21ldHJ5KSA6IFBvbHlnb25VdGlsLmxpbmVUb0p0cyhnZW9tZXRyeSk7XG4gICAgICAgICAgICBjb25zdCByZXNpemVkID0ganN0c0dlb21ldHJ5LmJ1ZmZlcihzcGFjaW5nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoIXJlc2l6ZWQuaXNTaW1wbGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNpemVkLmdldENvb3JkaW5hdGVzKCkubWFwKGMgPT4gbmV3IFZlY3RvcihjLngsIGMueSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaW5zaWRlUG9seWdvbihwb2ludDogVmVjdG9yLCBwb2x5Z29uOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyByYXktY2FzdGluZyBhbGdvcml0aG0gYmFzZWQgb25cbiAgICAgICAgLy8gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbFxuXG4gICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgaSA8IHBvbHlnb24ubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgICAgICB2YXIgeGkgPSBwb2x5Z29uW2ldLngsIHlpID0gcG9seWdvbltpXS55O1xuICAgICAgICAgICAgdmFyIHhqID0gcG9seWdvbltqXS54LCB5aiA9IHBvbHlnb25bal0ueTtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9ICgoeWkgPiBwb2ludC55KSAhPSAoeWogPiBwb2ludC55KSlcbiAgICAgICAgICAgICAgICAmJiAocG9pbnQueCA8ICh4aiAtIHhpKSAqIChwb2ludC55IC0geWkpIC8gKHlqIC0geWkpICsgeGkpO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdCkgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbGluZVRvSnRzKGxpbmU6IFZlY3RvcltdKToganN0cy5nZW9tLkxpbmVTdHJpbmcge1xuICAgICAgICBjb25zdCBjb29yZHMgPSBsaW5lLm1hcCh2ID0+IG5ldyBqc3RzLmdlb20uQ29vcmRpbmF0ZSh2LngsIHYueSkpO1xuICAgICAgICByZXR1cm4gUG9seWdvblV0aWwuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoY29vcmRzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwb2x5Z29uVG9KdHMocG9seWdvbjogVmVjdG9yW10pOiBqc3RzLmdlb20uUG9seWdvbiB7XG4gICAgICAgIGNvbnN0IGdlb0lucHV0ID0gcG9seWdvbi5tYXAodiA9PiBuZXcganN0cy5nZW9tLkNvb3JkaW5hdGUodi54LCB2LnkpKTtcbiAgICAgICAgZ2VvSW5wdXQucHVzaChnZW9JbnB1dFswXSk7ICAvLyBDcmVhdGUgbG9vcFxuICAgICAgICByZXR1cm4gUG9seWdvblV0aWwuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24oUG9seWdvblV0aWwuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoZ2VvSW5wdXQpLCBbXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWyB2LngsIHYueSwgdi54LCB2LnkgXS4uLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIHBvbHlnb25Ub1BvbHlnb25BcnJheShwOiBWZWN0b3JbXSk6IG51bWJlcltdIHtcbiAgICAgICAgY29uc3Qgb3V0UDogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHApIHtcbiAgICAgICAgICAgIG91dFAucHVzaCh2LngpO1xuICAgICAgICAgICAgb3V0UC5wdXNoKHYueSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dFA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWyB2LngsIHYueSwgdi54LCB2LnkgXS4uLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIHBvbHlnb25BcnJheVRvUG9seWdvbihwOiBudW1iZXJbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3Qgb3V0UCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRQLnB1c2gobmV3IFZlY3RvcihwWzIqaV0sIHBbMippICsgMV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0UDtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0ICogYXMgc2ltcGxpZnkgZnJvbSAnc2ltcGxpZnktanMnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IEdyaWRTdG9yYWdlIGZyb20gJy4vZ3JpZF9zdG9yYWdlJztcbmltcG9ydCBGaWVsZEludGVncmF0b3IgZnJvbSAnLi9pbnRlZ3JhdG9yJztcblxuaW50ZXJmYWNlIFN0cmVhbWxpbmVJbnRlZ3JhdGlvbiB7XG4gICAgc2VlZDogVmVjdG9yO1xuICAgIG9yaWdpbmFsRGlyOiBWZWN0b3I7XG4gICAgc3RyZWFtbGluZTogVmVjdG9yW107XG4gICAgcHJldmlvdXNEaXJlY3Rpb246IFZlY3RvcjtcbiAgICBwcmV2aW91c1BvaW50OiBWZWN0b3I7XG4gICAgdmFsaWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtbGluZVBhcmFtcyB7XG4gICAgW2tleTogc3RyaW5nXTogYW55O1xuICAgIGRzZXA6IG51bWJlcjsgIC8vIFN0cmVhbWxpbmUgc2VlZCBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgZHRlc3Q6IG51bWJlcjsgIC8vIFN0cmVhbWxpbmUgaW50ZWdyYXRpb24gc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgIGRzdGVwOiBudW1iZXI7ICAvLyBTdGVwIHNpemVcbiAgICBkY2lyY2xlam9pbjogbnVtYmVyOyAgLy8gSG93IGZhciB0byBsb29rIHRvIGpvaW4gY2lyY2xlcyAtIChlLmcuIDIgeCBkc3RlcClcbiAgICBkbG9va2FoZWFkOiBudW1iZXI7ICAvLyBIb3cgZmFyIHRvIGxvb2sgYWhlYWQgdG8gam9pbiB1cCBkYW5nbGluZ1xuICAgIGpvaW5hbmdsZTogbnVtYmVyOyAgLy8gQW5nbGUgdG8gam9pbiByb2FkcyBpbiByYWRpYW5zXG4gICAgcGF0aEl0ZXJhdGlvbnM6IG51bWJlcjsgIC8vIFBhdGggaW50ZWdyYXRpb24gaXRlcmF0aW9uIGxpbWl0XG4gICAgc2VlZFRyaWVzOiBudW1iZXI7ICAvLyBNYXggZmFpbGVkIHNlZWRzXG4gICAgc2ltcGxpZnlUb2xlcmFuY2U6IG51bWJlcjtcbiAgICBjb2xsaWRlRWFybHk6IG51bWJlcjsgIC8vIENoYW5jZSBvZiBlYXJseSBjb2xsaXNpb24gMC0xXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmVhbWxpbmVHZW5lcmF0b3Ige1xuICAgIHByb3RlY3RlZCByZWFkb25seSBTRUVEX0FUX0VORFBPSU5UUyA9IGZhbHNlO1xuICAgIHByb3RlY3RlZCByZWFkb25seSBORUFSX0VER0UgPSAzOyAgLy8gU2FtcGxlIG5lYXIgZWRnZVxuXG4gICAgcHJvdGVjdGVkIG1ham9yR3JpZDogR3JpZFN0b3JhZ2U7XG4gICAgcHJvdGVjdGVkIG1pbm9yR3JpZDogR3JpZFN0b3JhZ2U7XG4gICAgcHJvdGVjdGVkIHBhcmFtc1NxOiBTdHJlYW1saW5lUGFyYW1zO1xuXG4gICAgLy8gSG93IG1hbnkgc2FtcGxlcyB0byBza2lwIHdoZW4gY2hlY2tpbmcgc3RyZWFtbGluZSBjb2xsaXNpb24gd2l0aCBpdHNlbGZcbiAgICBwcm90ZWN0ZWQgblN0cmVhbWxpbmVTdGVwOiBudW1iZXI7XG4gICAgLy8gSG93IG1hbnkgc2FtcGxlcyB0byBpZ25vcmUgYmFja3dhcmRzIHdoZW4gY2hlY2tpbmcgc3RyZWFtbGluZSBjb2xsaXNpb24gd2l0aCBpdHNlbGZcbiAgICBwcm90ZWN0ZWQgblN0cmVhbWxpbmVMb29rQmFjazogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBkY29sbGlkZXNlbGZTcTogbnVtYmVyO1xuXG4gICAgcHJvdGVjdGVkIGNhbmRpZGF0ZVNlZWRzTWFqb3I6IFZlY3RvcltdID0gW107XG4gICAgcHJvdGVjdGVkIGNhbmRpZGF0ZVNlZWRzTWlub3I6IFZlY3RvcltdID0gW107XG5cbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZXNEb25lID0gdHJ1ZTtcbiAgICBwcm90ZWN0ZWQgcmVzb2x2ZTogKCkgPT4gdm9pZDtcbiAgICBwcm90ZWN0ZWQgbGFzdFN0cmVhbWxpbmVNYWpvciA9IHRydWU7XG5cbiAgICBwdWJsaWMgYWxsU3RyZWFtbGluZXM6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwdWJsaWMgc3RyZWFtbGluZXNNYWpvcjogVmVjdG9yW11bXSA9IFtdO1xuICAgIHB1YmxpYyBzdHJlYW1saW5lc01pbm9yOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHVibGljIGFsbFN0cmVhbWxpbmVzU2ltcGxlOiBWZWN0b3JbXVtdID0gW107ICAvLyBSZWR1Y2VkIHZlcnRleCBjb3VudFxuXG4gICAgLyoqXG4gICAgICogVXNlcyB3b3JsZC1zcGFjZSBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpbnRlZ3JhdG9yOiBGaWVsZEludGVncmF0b3IsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIG9yaWdpbjogVmVjdG9yLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCB3b3JsZERpbWVuc2lvbnM6IFZlY3RvcixcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuZHN0ZXAgPiBwYXJhbXMuZHNlcCkge1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiU1RSRUFNTElORSBTQU1QTEUgRElTVEFOQ0UgQklHR0VSIFRIQU4gRFNFUFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZm9yY2UgdGVzdCA8IHNlcFxuICAgICAgICBwYXJhbXMuZHRlc3QgPSBNYXRoLm1pbihwYXJhbXMuZHRlc3QsIHBhcmFtcy5kc2VwKTtcblxuICAgICAgICAvLyBOZWVkcyB0byBiZSBsZXNzIHRoYW4gY2lyY2xlam9pblxuICAgICAgICB0aGlzLmRjb2xsaWRlc2VsZlNxID0gKHBhcmFtcy5kY2lyY2xlam9pbiAvIDIpICoqIDI7XG4gICAgICAgIHRoaXMublN0cmVhbWxpbmVTdGVwID0gTWF0aC5mbG9vcihwYXJhbXMuZGNpcmNsZWpvaW4gLyBwYXJhbXMuZHN0ZXApO1xuICAgICAgICB0aGlzLm5TdHJlYW1saW5lTG9va0JhY2sgPSAyICogdGhpcy5uU3RyZWFtbGluZVN0ZXA7XG5cbiAgICAgICAgdGhpcy5tYWpvckdyaWQgPSBuZXcgR3JpZFN0b3JhZ2UodGhpcy53b3JsZERpbWVuc2lvbnMsIHRoaXMub3JpZ2luLCBwYXJhbXMuZHNlcCk7XG4gICAgICAgIHRoaXMubWlub3JHcmlkID0gbmV3IEdyaWRTdG9yYWdlKHRoaXMud29ybGREaW1lbnNpb25zLCB0aGlzLm9yaWdpbiwgcGFyYW1zLmRzZXApO1xuXG4gICAgICAgIHRoaXMuc2V0UGFyYW1zU3EoKTtcbiAgICB9XG5cbiAgICBjbGVhclN0cmVhbWxpbmVzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlID0gW107XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXNNYWpvciA9IFtdO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzTWlub3IgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVkaXRzIHN0cmVhbWxpbmVzXG4gICAgICovXG4gICAgam9pbkRhbmdsaW5nU3RyZWFtbGluZXMoKTogdm9pZCB7XG4gICAgICAgIC8vIFRPRE8gZG8gaW4gdXBkYXRlIG1ldGhvZFxuICAgICAgICBmb3IgKGNvbnN0IG1ham9yIG9mIFt0cnVlLCBmYWxzZV0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3RyZWFtbGluZSBvZiB0aGlzLnN0cmVhbWxpbmVzKG1ham9yKSkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBjaXJjbGVzXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbWxpbmVbMF0uZXF1YWxzKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3RhcnQgPSB0aGlzLmdldEJlc3ROZXh0UG9pbnQoc3RyZWFtbGluZVswXSwgc3RyZWFtbGluZVs0XSwgc3RyZWFtbGluZSlcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucG9pbnRzQmV0d2VlbihzdHJlYW1saW5lWzBdLCBuZXdTdGFydCwgdGhpcy5wYXJhbXMuZHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1saW5lLnVuc2hpZnQocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFNhbXBsZShwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VuZCA9IHRoaXMuZ2V0QmVzdE5leHRQb2ludChzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0sIHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSA0XSwgc3RyZWFtbGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0VuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wb2ludHNCZXR3ZWVuKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXSwgbmV3RW5kLCB0aGlzLnBhcmFtcy5kc3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbWxpbmUucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkU2FtcGxlKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgc2ltcGxpZmllZCBzdHJlYW1saW5lc1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLmFsbFN0cmVhbWxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnB1c2godGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUocykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiBwb2ludHMgZnJvbSB2MSB0byB2MiBzdWNoIHRoYXQgdGhleSBhcmUgc2VwYXJhdGVkIGJ5IGF0IG1vc3QgZHNlcFxuICAgICAqIG5vdCBpbmNsdWRpbmcgdjFcbiAgICAgKi9cbiAgICBwb2ludHNCZXR3ZWVuKHYxOiBWZWN0b3IsIHYyOiBWZWN0b3IsIGRzdGVwOiBudW1iZXIpOiBWZWN0b3JbXSB7XG4gICAgICAgIGNvbnN0IGQgPSB2MS5kaXN0YW5jZVRvKHYyKTtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoZCAvIGRzdGVwKTtcbiAgICAgICAgaWYgKG5Qb2ludHMgPT09IDApIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCBzdGVwVmVjdG9yID0gdjIuY2xvbmUoKS5zdWIodjEpO1xuXG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgIGxldCBuZXh0ID0gdjEuY2xvbmUoKS5hZGQoc3RlcFZlY3Rvci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGkgLyBuUG9pbnRzKSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gblBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlZ3JhdG9yLmludGVncmF0ZShuZXh0LCB0cnVlKS5sZW5ndGhTcSgpID4gMC4wMDEpIHsgIC8vIFRlc3QgZm9yIGRlZ2VuZXJhdGUgcG9pbnRcbiAgICAgICAgICAgICAgICBvdXQucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSB2MS5jbG9uZSgpLmFkZChzdGVwVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoaSAvIG5Qb2ludHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0cyBuZXh0IGJlc3QgcG9pbnQgdG8gam9pbiBzdHJlYW1saW5lXG4gICAgICogcmV0dXJucyBudWxsIGlmIHRoZXJlIGFyZSBubyBnb29kIGNhbmRpZGF0ZXNcbiAgICAgKi9cbiAgICBnZXRCZXN0TmV4dFBvaW50KHBvaW50OiBWZWN0b3IsIHByZXZpb3VzUG9pbnQ6IFZlY3Rvciwgc3RyZWFtbGluZTogVmVjdG9yW10pOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBuZWFyYnlQb2ludHMgPSB0aGlzLm1ham9yR3JpZC5nZXROZWFyYnlQb2ludHMocG9pbnQsIHRoaXMucGFyYW1zLmRsb29rYWhlYWQpO1xuICAgICAgICBuZWFyYnlQb2ludHMucHVzaCguLi50aGlzLm1pbm9yR3JpZC5nZXROZWFyYnlQb2ludHMocG9pbnQsIHRoaXMucGFyYW1zLmRsb29rYWhlYWQpKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcG9pbnQuY2xvbmUoKS5zdWIocHJldmlvdXNQb2ludCk7XG5cbiAgICAgICAgbGV0IGNsb3Nlc3RTYW1wbGUgPSBudWxsO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgbmVhcmJ5UG9pbnRzKSB7XG4gICAgICAgICAgICBpZiAoIXNhbXBsZS5lcXVhbHMocG9pbnQpICYmICFzYW1wbGUuZXF1YWxzKHByZXZpb3VzUG9pbnQpKSB7Ly8gJiYgIXN0cmVhbWxpbmUuaW5jbHVkZXMoc2FtcGxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2VWZWN0b3IgPSBzYW1wbGUuY2xvbmUoKS5zdWIocG9pbnQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlVmVjdG9yLmRvdChkaXJlY3Rpb24pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFjdXRlIGFuZ2xlIGJldHdlZW4gdmVjdG9ycyAoYWdub3N0aWMgb2YgQ1csIEFDVylcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZVRvU2FtcGxlID0gcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoc2FtcGxlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VUb1NhbXBsZSA8IDIgKiB0aGlzLnBhcmFtc1NxLmRzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RTYW1wbGUgPSBzYW1wbGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhbmdsZUJldHdlZW4gPSBNYXRoLmFicyhWZWN0b3IuYW5nbGVCZXR3ZWVuKGRpcmVjdGlvbiwgZGlmZmVyZW5jZVZlY3RvcikpO1xuXG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IGFuZ2xlXG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlQmV0d2VlbiA8IHRoaXMucGFyYW1zLmpvaW5hbmdsZSAmJiBkaXN0YW5jZVRvU2FtcGxlIDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlVG9TYW1wbGU7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RTYW1wbGUgPSBzYW1wbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBpcyByZWltcGxlbWVudCBzaW1wbGlmeS1qcyB0byBwcmVzZXJ2ZSBpbnRlcnNlY3Rpb24gcG9pbnRzXG4gICAgICAgIC8vICAtIHRoaXMgaXMgdGhlIHByaW1hcnkgcmVhc29uIHBvbHlnb25zIGFyZW4ndCBmb3VuZFxuICAgICAgICAvLyBJZiB0cnlpbmcgdG8gZmluZCBpbnRlcnNlY3Rpb25zIGluIHRoZSBzaW1wbGlmaWVkIGdyYXBoXG4gICAgICAgIC8vIHByZXZlbnQgZW5kcyBnZXR0aW5nIHB1bGxlZCBhd2F5IGZyb20gc2ltcGxpZmllZCBsaW5lc1xuICAgICAgICBpZiAoY2xvc2VzdFNhbXBsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xvc2VzdFNhbXBsZSA9IGNsb3Nlc3RTYW1wbGUuY2xvbmUoKS5hZGQoZGlyZWN0aW9uLnNldExlbmd0aCh0aGlzLnBhcmFtcy5zaW1wbGlmeVRvbGVyYW5jZSAqIDQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9zZXN0U2FtcGxlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXNzdW1lcyBzIGhhcyBhbHJlYWR5IGdlbmVyYXRlZFxuICAgICAqL1xuICAgIGFkZEV4aXN0aW5nU3RyZWFtbGluZXMoczogU3RyZWFtbGluZUdlbmVyYXRvcik6IHZvaWQge1xuICAgICAgICB0aGlzLm1ham9yR3JpZC5hZGRBbGwocy5tYWpvckdyaWQpO1xuICAgICAgICB0aGlzLm1pbm9yR3JpZC5hZGRBbGwocy5taW5vckdyaWQpO1xuICAgIH1cblxuICAgIHNldEdyaWQoczogU3RyZWFtbGluZUdlbmVyYXRvcik6IHZvaWQge1xuICAgICAgICB0aGlzLm1ham9yR3JpZCA9IHMubWFqb3JHcmlkO1xuICAgICAgICB0aGlzLm1pbm9yR3JpZCA9IHMubWlub3JHcmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdHJ1ZSBpZiBzdGF0ZSB1cGRhdGVzXG4gICAgICovXG4gICAgdXBkYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXRoaXMuc3RyZWFtbGluZXNEb25lKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdHJlYW1saW5lTWFqb3IgPSAhdGhpcy5sYXN0U3RyZWFtbGluZU1ham9yO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZVN0cmVhbWxpbmUodGhpcy5sYXN0U3RyZWFtbGluZU1ham9yKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtbGluZXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbCBhdCBvbmNlIC0gd2lsbCBmcmVlemUgaWYgZHNlcCBzbWFsbFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFsbFN0cmVhbWxpbmVzKGFuaW1hdGU9ZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgICAgICAgdGhpcy5zdHJlYW1saW5lc0RvbmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCFhbmltYXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ham9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jcmVhdGVTdHJlYW1saW5lKG1ham9yKSkge1xuICAgICAgICAgICAgICAgICAgICBtYWpvciA9ICFtYWpvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oKCkgPT4gdGhpcy5qb2luRGFuZ2xpbmdTdHJlYW1saW5lcygpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2ltcGxpZnlTdHJlYW1saW5lKHN0cmVhbWxpbmU6IFZlY3RvcltdKTogVmVjdG9yW10ge1xuICAgICAgICBjb25zdCBzaW1wbGlmaWVkID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2Ygc2ltcGxpZnkoc3RyZWFtbGluZSwgdGhpcy5wYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2UpKSB7XG4gICAgICAgICAgICBzaW1wbGlmaWVkLnB1c2gobmV3IFZlY3Rvcihwb2ludC54LCBwb2ludC55KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgc2VlZCBhbmQgY3JlYXRlcyBhIHN0cmVhbWxpbmUgZnJvbSB0aGF0IHBvaW50XG4gICAgICogUHVzaGVzIG5ldyBjYW5kaWRhdGUgc2VlZHMgdG8gcXVldWVcbiAgICAgKiBAcmV0dXJuIHtWZWN0b3JbXX0gcmV0dXJucyBmYWxzZSBpZiBzZWVkIGlzbid0IGZvdW5kIHdpdGhpbiBwYXJhbXMuc2VlZFRyaWVzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVN0cmVhbWxpbmUobWFqb3I6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgc2VlZCA9IHRoaXMuZ2V0U2VlZChtYWpvcik7XG4gICAgICAgIGlmIChzZWVkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtbGluZSA9IHRoaXMuaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkLCBtYWpvcik7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkU3RyZWFtbGluZShzdHJlYW1saW5lKSkge1xuICAgICAgICAgICAgdGhpcy5ncmlkKG1ham9yKS5hZGRQb2x5bGluZShzdHJlYW1saW5lKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtbGluZXMobWFqb3IpLnB1c2goc3RyZWFtbGluZSk7XG4gICAgICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzLnB1c2goc3RyZWFtbGluZSk7XG5cbiAgICAgICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXNTaW1wbGUucHVzaCh0aGlzLnNpbXBsaWZ5U3RyZWFtbGluZShzdHJlYW1saW5lKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBjYW5kaWRhdGUgc2VlZHNcbiAgICAgICAgICAgIGlmICghc3RyZWFtbGluZVswXS5lcXVhbHMoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuZGlkYXRlU2VlZHMoIW1ham9yKS5wdXNoKHN0cmVhbWxpbmVbMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuZGlkYXRlU2VlZHMoIW1ham9yKS5wdXNoKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgdmFsaWRTdHJlYW1saW5lKHM6IFZlY3RvcltdKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzLmxlbmd0aCA+IDU7XG4gICAgfSBcblxuICAgIHByb3RlY3RlZCBzZXRQYXJhbXNTcSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXJhbXNTcSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zKTtcbiAgICAgICAgZm9yIChjb25zdCBwIGluIHRoaXMucGFyYW1zU3EpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYXJhbXNTcVtwXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zU3FbcF0gKj0gdGhpcy5wYXJhbXNTcVtwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBzYW1wbGVQb2ludCgpOiBWZWN0b3Ige1xuICAgICAgICAvLyBUT0RPIGJldHRlciBzZWVkaW5nIHNjaGVtZVxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihcbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiB0aGlzLndvcmxkRGltZW5zaW9ucy54LFxuICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIHRoaXMud29ybGREaW1lbnNpb25zLnkpXG4gICAgICAgICAgICAuYWRkKHRoaXMub3JpZ2luKTtcbiAgICB9XG4gXG4gICAgLyoqXG4gICAgICogVHJpZXMgdGhpcy5jYW5kaWRhdGVTZWVkcyBmaXJzdCwgdGhlbiBzYW1wbGVzIHVzaW5nIHRoaXMuc2FtcGxlUG9pbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0U2VlZChtYWpvcjogYm9vbGVhbik6IFZlY3RvciB7XG4gICAgICAgIC8vIENhbmRpZGF0ZSBzZWVkcyBmaXJzdFxuICAgICAgICBpZiAodGhpcy5TRUVEX0FUX0VORFBPSU5UUyAmJiB0aGlzLmNhbmRpZGF0ZVNlZWRzKG1ham9yKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5jYW5kaWRhdGVTZWVkcyhtYWpvcikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZWQgPSB0aGlzLmNhbmRpZGF0ZVNlZWRzKG1ham9yKS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkU2FtcGxlKG1ham9yLCBzZWVkLCB0aGlzLnBhcmFtc1NxLmRzZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZWVkID0gdGhpcy5zYW1wbGVQb2ludCgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlICghdGhpcy5pc1ZhbGlkU2FtcGxlKG1ham9yLCBzZWVkLCB0aGlzLnBhcmFtc1NxLmRzZXApKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLnBhcmFtcy5zZWVkVHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZWQgPSB0aGlzLnNhbXBsZVBvaW50KCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VlZDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaXNWYWxpZFNhbXBsZShtYWpvcjogYm9vbGVhbiwgcG9pbnQ6IFZlY3RvciwgZFNxOiBudW1iZXIsIGJvdGhHcmlkcz1mYWxzZSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBkU3EgPSBkU3EgKiBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZChWZWN0b3IuemVyb1ZlY3RvcigpKTtcbiAgICAgICAgbGV0IGdyaWRWYWxpZCA9IHRoaXMuZ3JpZChtYWpvcikuaXNWYWxpZFNhbXBsZShwb2ludCwgZFNxKTtcbiAgICAgICAgaWYgKGJvdGhHcmlkcykge1xuICAgICAgICAgICAgZ3JpZFZhbGlkID0gZ3JpZFZhbGlkICYmIHRoaXMuZ3JpZCghbWFqb3IpLmlzVmFsaWRTYW1wbGUocG9pbnQsIGRTcSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdyYXRvci5vbkxhbmQocG9pbnQpICYmIGdyaWRWYWxpZDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY2FuZGlkYXRlU2VlZHMobWFqb3I6IGJvb2xlYW4pOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiBtYWpvciA/IHRoaXMuY2FuZGlkYXRlU2VlZHNNYWpvciA6IHRoaXMuY2FuZGlkYXRlU2VlZHNNaW5vcjtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZXMobWFqb3I6IGJvb2xlYW4pOiBWZWN0b3JbXVtdIHtcbiAgICAgICAgcmV0dXJuIG1ham9yID8gdGhpcy5zdHJlYW1saW5lc01ham9yIDogdGhpcy5zdHJlYW1saW5lc01pbm9yO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBncmlkKG1ham9yOiBib29sZWFuKTogR3JpZFN0b3JhZ2Uge1xuICAgICAgICByZXR1cm4gbWFqb3IgPyB0aGlzLm1ham9yR3JpZCA6IHRoaXMubWlub3JHcmlkO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBwb2ludEluQm91bmRzKHY6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKHYueCA+PSB0aGlzLm9yaWdpbi54XG4gICAgICAgICAgICAmJiB2LnkgPj0gdGhpcy5vcmlnaW4ueVxuICAgICAgICAgICAgJiYgdi54IDwgdGhpcy53b3JsZERpbWVuc2lvbnMueCArIHRoaXMub3JpZ2luLnhcbiAgICAgICAgICAgICYmIHYueSA8IHRoaXMud29ybGREaW1lbnNpb25zLnkgKyB0aGlzLm9yaWdpbi55XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlkbid0IGVuZCB1cCB1c2luZyAtIGJpdCBleHBlbnNpdmUsIHVzZWQgc3RyZWFtbGluZVR1cm5lZCBpbnN0ZWFkXG4gICAgICogU3RvcHMgc3BpcmFscyBmcm9tIGZvcm1pbmdcbiAgICAgKiB1c2VzIDAuNSBkY2lyY2xlam9pbiBzbyB0aGF0IGNpcmNsZXMgYXJlIHN0aWxsIGpvaW5lZCB1cFxuICAgICAqIHRlc3RTYW1wbGUgaXMgY2FuZGlkYXRlIHRvIHB1c2hlZCBvbiBlbmQgb2Ygc3RyZWFtbGluZUZvcndhcmRzXG4gICAgICogcmV0dXJucyB0cnVlIGlmIHN0cmVhbWxpbmUgY29sbGlkZXMgd2l0aCBpdHNlbGZcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZG9lc1N0cmVhbWxpbmVDb2xsaWRlU2VsZih0ZXN0U2FtcGxlOiBWZWN0b3IsIHN0cmVhbWxpbmVGb3J3YXJkczogVmVjdG9yW10sIHN0cmVhbWxpbmVCYWNrd2FyZHM6IFZlY3RvcltdKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIFN0cmVhbWxpbmUgbG9uZyBlbm91Z2hcbiAgICAgICAgaWYgKHN0cmVhbWxpbmVGb3J3YXJkcy5sZW5ndGggPiB0aGlzLm5TdHJlYW1saW5lTG9va0JhY2spIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmRzIGNoZWNrXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmVhbWxpbmVGb3J3YXJkcy5sZW5ndGggLSB0aGlzLm5TdHJlYW1saW5lTG9va0JhY2s7IGkgKz0gdGhpcy5uU3RyZWFtbGluZVN0ZXApIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFNhbXBsZS5kaXN0YW5jZVRvU3F1YXJlZChzdHJlYW1saW5lRm9yd2FyZHNbaV0pIDwgdGhpcy5kY29sbGlkZXNlbGZTcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjaGVja1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJlYW1saW5lQmFja3dhcmRzLmxlbmd0aDsgaSArPSB0aGlzLm5TdHJlYW1saW5lU3RlcCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0U2FtcGxlLmRpc3RhbmNlVG9TcXVhcmVkKHN0cmVhbWxpbmVCYWNrd2FyZHNbaV0pIDwgdGhpcy5kY29sbGlkZXNlbGZTcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBzdHJlYW1saW5lIGhhcyB0dXJuZWQgdGhyb3VnaCBncmVhdGVyIHRoYW4gMTgwIGRlZ3JlZXNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZVR1cm5lZChzZWVkOiBWZWN0b3IsIG9yaWdpbmFsRGlyOiBWZWN0b3IsIHBvaW50OiBWZWN0b3IsIGRpcmVjdGlvbjogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChvcmlnaW5hbERpci5kb3QoZGlyZWN0aW9uKSA8IDApIHtcbiAgICAgICAgICAgIC8vIFRPRE8gb3B0aW1pc2VcbiAgICAgICAgICAgIGNvbnN0IHBlcnBlbmRpY3VsYXJWZWN0b3IgPSBuZXcgVmVjdG9yKG9yaWdpbmFsRGlyLnksIC1vcmlnaW5hbERpci54KTtcbiAgICAgICAgICAgIGNvbnN0IGlzTGVmdCA9IHBvaW50LmNsb25lKCkuc3ViKHNlZWQpLmRvdChwZXJwZW5kaWN1bGFyVmVjdG9yKSA8IDA7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25VcCA9IGRpcmVjdGlvbi5kb3QocGVycGVuZGljdWxhclZlY3RvcikgPiAwO1xuICAgICAgICAgICAgcmV0dXJuIGlzTGVmdCA9PT0gZGlyZWN0aW9uVXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogLy8gVE9ETyB0aGlzIGRvZXNuJ3Qgd29yayB3ZWxsIC0gY29uc2lkZXIgc29tZXRoaW5nIGRpc2FsbG93aW5nIG9uZSBkaXJlY3Rpb24gKEYvQikgdG8gdHVybiBtb3JlIHRoYW4gMTgwIGRlZ1xuICAgICAqIE9uZSBzdGVwIG9mIHRoZSBzdHJlYW1saW5lIGludGVncmF0aW9uIHByb2Nlc3NcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZUludGVncmF0aW9uU3RlcChwYXJhbXM6IFN0cmVhbWxpbmVJbnRlZ3JhdGlvbiwgbWFqb3I6IGJvb2xlYW4sIGNvbGxpZGVCb3RoOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGlmIChwYXJhbXMudmFsaWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zdHJlYW1saW5lLnB1c2gocGFyYW1zLnByZXZpb3VzUG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgbmV4dERpcmVjdGlvbiA9IHRoaXMuaW50ZWdyYXRvci5pbnRlZ3JhdGUocGFyYW1zLnByZXZpb3VzUG9pbnQsIG1ham9yKTtcblxuICAgICAgICAgICAgLy8gU3RvcCBhdCBkZWdlbmVyYXRlIHBvaW50XG4gICAgICAgICAgICBpZiAobmV4dERpcmVjdGlvbi5sZW5ndGhTcSgpIDwgMC4wMSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyYXZlbCBpbiB0aGUgc2FtZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIGlmIChuZXh0RGlyZWN0aW9uLmRvdChwYXJhbXMucHJldmlvdXNEaXJlY3Rpb24pIDwgMCkge1xuICAgICAgICAgICAgICAgIG5leHREaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5leHRQb2ludCA9IHBhcmFtcy5wcmV2aW91c1BvaW50LmNsb25lKCkuYWRkKG5leHREaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICAvLyBWaXN1YWxpc2Ugc3RvcHBpbmcgcG9pbnRzXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5zdHJlYW1saW5lVHVybmVkKHBhcmFtcy5zZWVkLCBwYXJhbXMub3JpZ2luYWxEaXIsIG5leHRQb2ludCwgbmV4dERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIC8vICAgICBwYXJhbXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vICAgICBwYXJhbXMuc3RyZWFtbGluZS5wdXNoKFZlY3Rvci56ZXJvVmVjdG9yKCkpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludEluQm91bmRzKG5leHRQb2ludClcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmlzVmFsaWRTYW1wbGUobWFqb3IsIG5leHRQb2ludCwgdGhpcy5wYXJhbXNTcS5kdGVzdCwgY29sbGlkZUJvdGgpXG4gICAgICAgICAgICAgICAgJiYgIXRoaXMuc3RyZWFtbGluZVR1cm5lZChwYXJhbXMuc2VlZCwgcGFyYW1zLm9yaWdpbmFsRGlyLCBuZXh0UG9pbnQsIG5leHREaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnByZXZpb3VzUG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnByZXZpb3VzRGlyZWN0aW9uID0gbmV4dERpcmVjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT25lIG1vcmUgc3RlcFxuICAgICAgICAgICAgICAgIHBhcmFtcy5zdHJlYW1saW5lLnB1c2gobmV4dFBvaW50KTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IHNpbXVsdGFuZW91c2x5IGludGVncmF0aW5nIGluIGJvdGggZGlyZWN0aW9ucyB3ZSByZWR1Y2UgdGhlIGltcGFjdCBvZiBjaXJjbGVzIG5vdCBqb2luaW5nXG4gICAgICogdXAgYXMgdGhlIGVycm9yIG1hdGNoZXMgYXQgdGhlIGpvaW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkOiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yW10ge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBsZXQgcG9pbnRzRXNjYXBlZCA9IGZhbHNlOyAgLy8gVHJ1ZSBvbmNlIHR3byBpbnRlZ3JhdGlvbiBmcm9udHMgaGF2ZSBtb3ZlZCBkbG9va2FoZWFkIGF3YXlcblxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0byB0ZXN0IHZhbGlkaXR5IHVzaW5nIGJvdGggZ3JpZCBzdG9yYWdlc1xuICAgICAgICAvLyAoQ29sbGlkZSB3aXRoIGJvdGggbWFqb3IgYW5kIG1pbm9yKVxuICAgICAgICBjb25zdCBjb2xsaWRlQm90aCA9IE1hdGgucmFuZG9tKCkgPCB0aGlzLnBhcmFtcy5jb2xsaWRlRWFybHk7XG5cbiAgICAgICAgY29uc3QgZCA9IHRoaXMuaW50ZWdyYXRvci5pbnRlZ3JhdGUoc2VlZCwgbWFqb3IpO1xuXG4gICAgICAgIGNvbnN0IGZvcndhcmRQYXJhbXM6IFN0cmVhbWxpbmVJbnRlZ3JhdGlvbiA9IHtcbiAgICAgICAgICAgIHNlZWQ6IHNlZWQsXG4gICAgICAgICAgICBvcmlnaW5hbERpcjogZCxcbiAgICAgICAgICAgIHN0cmVhbWxpbmU6IFtzZWVkXSxcbiAgICAgICAgICAgIHByZXZpb3VzRGlyZWN0aW9uOiBkLFxuICAgICAgICAgICAgcHJldmlvdXNQb2ludDogc2VlZC5jbG9uZSgpLmFkZChkKSxcbiAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yd2FyZFBhcmFtcy52YWxpZCA9IHRoaXMucG9pbnRJbkJvdW5kcyhmb3J3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQpO1xuXG4gICAgICAgIGNvbnN0IG5lZ0QgPSBkLmNsb25lKCkubmVnYXRlKCk7XG4gICAgICAgIGNvbnN0IGJhY2t3YXJkUGFyYW1zOiBTdHJlYW1saW5lSW50ZWdyYXRpb24gPSB7XG4gICAgICAgICAgICBzZWVkOiBzZWVkLFxuICAgICAgICAgICAgb3JpZ2luYWxEaXI6IG5lZ0QsXG4gICAgICAgICAgICBzdHJlYW1saW5lOiBbXSxcbiAgICAgICAgICAgIHByZXZpb3VzRGlyZWN0aW9uOiBuZWdELFxuICAgICAgICAgICAgcHJldmlvdXNQb2ludDogc2VlZC5jbG9uZSgpLmFkZChuZWdEKSxcbiAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICB9XG5cbiAgICAgICAgYmFja3dhcmRQYXJhbXMudmFsaWQgPSB0aGlzLnBvaW50SW5Cb3VuZHMoYmFja3dhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG5cbiAgICAgICAgd2hpbGUgKGNvdW50IDwgdGhpcy5wYXJhbXMucGF0aEl0ZXJhdGlvbnMgJiYgKGZvcndhcmRQYXJhbXMudmFsaWQgfHwgYmFja3dhcmRQYXJhbXMudmFsaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVJbnRlZ3JhdGlvblN0ZXAoZm9yd2FyZFBhcmFtcywgbWFqb3IsIGNvbGxpZGVCb3RoKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtbGluZUludGVncmF0aW9uU3RlcChiYWNrd2FyZFBhcmFtcywgbWFqb3IsIGNvbGxpZGVCb3RoKTtcblxuICAgICAgICAgICAgLy8gSm9pbiB1cCBjaXJjbGVzXG4gICAgICAgICAgICBjb25zdCBzcURpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZvcndhcmRQYXJhbXMucHJldmlvdXNQb2ludC5kaXN0YW5jZVRvU3F1YXJlZChiYWNrd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcblxuICAgICAgICAgICAgaWYgKCFwb2ludHNFc2NhcGVkICYmIHNxRGlzdGFuY2VCZXR3ZWVuUG9pbnRzID4gdGhpcy5wYXJhbXNTcS5kY2lyY2xlam9pbikge1xuICAgICAgICAgICAgICAgIHBvaW50c0VzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9pbnRzRXNjYXBlZCAmJiBzcURpc3RhbmNlQmV0d2VlblBvaW50cyA8PSB0aGlzLnBhcmFtc1NxLmRjaXJjbGVqb2luKSB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFBhcmFtcy5zdHJlYW1saW5lLnB1c2goZm9yd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3J3YXJkUGFyYW1zLnN0cmVhbWxpbmUucHVzaChiYWNrd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcbiAgICAgICAgICAgICAgICBiYWNrd2FyZFBhcmFtcy5zdHJlYW1saW5lLnB1c2goYmFja3dhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBiYWNrd2FyZFBhcmFtcy5zdHJlYW1saW5lLnJldmVyc2UoKS5wdXNoKC4uLmZvcndhcmRQYXJhbXMuc3RyZWFtbGluZSk7XG4gICAgICAgIHJldHVybiBiYWNrd2FyZFBhcmFtcy5zdHJlYW1saW5lO1xuICAgIH1cbn1cbiIsImltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVuc29yIHtcbiAgICBwcml2YXRlIG9sZFRoZXRhOiBib29sZWFuO1xuICAgIHByaXZhdGUgX3RoZXRhOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHI6IG51bWJlciwgcHJpdmF0ZSBtYXRyaXg6IG51bWJlcltdKSB7XG4gICAgICAgIC8vIE1hdHJpeCBpcyAyIGVsZW1lbnQgbGlzdFxuICAgICAgICAvLyBbIDAsIDFcbiAgICAgICAgLy8gICAxLCAtMCBdXG4gICAgICAgIHRoaXMub2xkVGhldGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGhldGEgPSB0aGlzLmNhbGN1bGF0ZVRoZXRhKCk7XG4gICAgfVxuXG4gICAgZ2V0IHRoZXRhKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLm9sZFRoZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl90aGV0YSA9IHRoaXMuY2FsY3VsYXRlVGhldGEoKTtcbiAgICAgICAgICAgIHRoaXMub2xkVGhldGEgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90aGV0YTtcbiAgICB9XG5cbiAgICBhZGQodGVuc29yOiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgICAgICB0aGlzLm1hdHJpeCA9IHRoaXMubWF0cml4Lm1hcCgodiwgaSkgPT4gdiAqIHRoaXMuciArIHRlbnNvci5tYXRyaXhbaV0gKiB0ZW5zb3Iucik7XG4gICAgICAgIHRoaXMuciA9IDI7XG4gICAgICAgIHRoaXMub2xkVGhldGEgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzY2FsZShzOiBudW1iZXIpOiBUZW5zb3Ige1xuICAgICAgICB0aGlzLnIgKj0gcztcbiAgICAgICAgdGhpcy5vbGRUaGV0YSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFJhZGlhbnNcbiAgICByb3RhdGUodGhldGE6IG51bWJlcik6IFRlbnNvciB7XG4gICAgICAgIGlmICh0aGV0YSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1RoZXRhID0gdGhpcy50aGV0YSArIHRoZXRhO1xuICAgICAgICBpZiAobmV3VGhldGEgPCBNYXRoLlBJKSB7XG4gICAgICAgICAgICBuZXdUaGV0YSArPSBNYXRoLlBJO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1RoZXRhID49IE1hdGguUEkpIHtcbiAgICAgICAgICAgIG5ld1RoZXRhIC09IE1hdGguUEk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hdHJpeFswXSA9IE1hdGguY29zKDIgKiBuZXdUaGV0YSkgKiB0aGlzLnI7XG4gICAgICAgIHRoaXMubWF0cml4WzFdID0gTWF0aC5zaW4oMiAqIG5ld1RoZXRhKSAqIHRoaXMucjtcbiAgICAgICAgdGhpcy5fdGhldGEgPSBuZXdUaGV0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0TWFqb3IoKTogVmVjdG9yIHtcbiAgICAgICAgLy8gRGVnZW5lcmF0ZSBjYXNlXG4gICAgICAgIGlmICh0aGlzLnIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKE1hdGguY29zKHRoaXMudGhldGEpLCBNYXRoLnNpbih0aGlzLnRoZXRhKSk7XG4gICAgfVxuXG4gICAgZ2V0TWlub3IoKTogVmVjdG9yIHtcbiAgICAgICAgLy8gRGVnZW5lcmF0ZSBjYXNlXG4gICAgICAgIGlmICh0aGlzLnIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdGhpcy50aGV0YSArIE1hdGguUEkgLyAyO1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLmNvcyhhbmdsZSksIE1hdGguc2luKGFuZ2xlKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVUaGV0YSgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5yID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLm1hdHJpeFsxXSAvIHRoaXMuciwgdGhpcy5tYXRyaXhbMF0gLyB0aGlzLnIpIC8gMjtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuLy8gaW1wb3J0ICogYXMgbm9pc2UgZnJvbSAnbm9pc2Vqcyc7XG5pbXBvcnQgKiBhcyBTaW1wbGV4Tm9pc2UgZnJvbSAnc2ltcGxleC1ub2lzZSc7XG5pbXBvcnQgVGVuc29yIGZyb20gJy4vdGVuc29yJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCB7R3JpZCwgUmFkaWFsLCBCYXNpc0ZpZWxkfSBmcm9tICcuL2Jhc2lzX2ZpZWxkJztcbmltcG9ydCBQb2x5Z29uVXRpbCBmcm9tICcuL3BvbHlnb25fdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9pc2VQYXJhbXMge1xuICAgIGdsb2JhbE5vaXNlOiBib29sZWFuO1xuICAgIG5vaXNlU2l6ZVBhcms6IG51bWJlcjtcbiAgICBub2lzZUFuZ2xlUGFyazogbnVtYmVyOyAgLy8gRGVncmVlc1xuICAgIG5vaXNlU2l6ZUdsb2JhbDogbnVtYmVyO1xuICAgIG5vaXNlQW5nbGVHbG9iYWw6IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVuc29yRmllbGQge1xuICAgIHByaXZhdGUgYmFzaXNGaWVsZHM6IEJhc2lzRmllbGRbXSA9IFtdO1xuICAgIHByaXZhdGUgbm9pc2U6IFNpbXBsZXhOb2lzZTtcblxuICAgIHB1YmxpYyBwYXJrczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHB1YmxpYyBzZWE6IFZlY3RvcltdID0gW107XG4gICAgcHVibGljIHJpdmVyOiBWZWN0b3JbXSA9IFtdO1xuICAgIHB1YmxpYyBpZ25vcmVSaXZlciA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIG5vaXNlUGFyYW1zOiBOb2lzZVBhcmFtcykge1xuICAgICAgICB0aGlzLm5vaXNlID0gbmV3IFNpbXBsZXhOb2lzZSgpO1xuICAgIH1cblxuICAgIGVuYWJsZUdsb2JhbE5vaXNlKGFuZ2xlOiBudW1iZXIsIHNpemU6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLm5vaXNlUGFyYW1zLmdsb2JhbE5vaXNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub2lzZVBhcmFtcy5ub2lzZUFuZ2xlR2xvYmFsID0gYW5nbGU7XG4gICAgICAgIHRoaXMubm9pc2VQYXJhbXMubm9pc2VTaXplR2xvYmFsID0gc2l6ZTtcbiAgICB9XG5cbiAgICBkaXNhYmxlR2xvYmFsTm9pc2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubm9pc2VQYXJhbXMuZ2xvYmFsTm9pc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBhZGRHcmlkKGNlbnRyZTogVmVjdG9yLCBzaXplOiBudW1iZXIsIGRlY2F5OiBudW1iZXIsIHRoZXRhOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZ3JpZCA9IG5ldyBHcmlkKGNlbnRyZSwgc2l6ZSwgZGVjYXksIHRoZXRhKTtcbiAgICAgICAgdGhpcy5hZGRGaWVsZChncmlkKTsgICAgICAgIFxuICAgIH1cblxuICAgIGFkZFJhZGlhbChjZW50cmU6IFZlY3Rvciwgc2l6ZTogbnVtYmVyLCBkZWNheTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHJhZGlhbCA9IG5ldyBSYWRpYWwoY2VudHJlLCBzaXplLCBkZWNheSk7XG4gICAgICAgIHRoaXMuYWRkRmllbGQocmFkaWFsKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYWRkRmllbGQoZmllbGQ6IEJhc2lzRmllbGQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iYXNpc0ZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVtb3ZlRmllbGQoZmllbGQ6IEJhc2lzRmllbGQpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmJhc2lzRmllbGRzLmluZGV4T2YoZmllbGQpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5iYXNpc0ZpZWxkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYmFzaXNGaWVsZHMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJrcyA9IFtdO1xuICAgICAgICB0aGlzLnNlYSA9IFtdO1xuICAgICAgICB0aGlzLnJpdmVyID0gW107XG4gICAgfVxuXG4gICAgZ2V0Q2VudHJlUG9pbnRzKCk6IFZlY3RvcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzaXNGaWVsZHMubWFwKGZpZWxkID0+IGZpZWxkLmNlbnRyZSk7XG4gICAgfVxuXG4gICAgc2FtcGxlUG9pbnQocG9pbnQ6IFZlY3Rvcik6IFRlbnNvciB7XG4gICAgICAgIGlmICghdGhpcy5vbkxhbmQocG9pbnQpKSB7XG4gICAgICAgICAgICAvLyBEZWdlbmVyYXRlIHBvaW50XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigwLCBbMCwwXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IGZpZWxkIGlzIGEgZ3JpZFxuICAgICAgICBpZiAodGhpcy5iYXNpc0ZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yKDEsIFswLCAwXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW5zb3JBY2MgPSBuZXcgVGVuc29yKDAsIFswLCAwXSk7XG4gICAgICAgIHRoaXMuYmFzaXNGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB0ZW5zb3JBY2MuYWRkKGZpZWxkLmdldFdlaWdodGVkVGVuc29yKHBvaW50KSkpO1xuXG4gICAgICAgIC8vIEFkZCByb3RhdGlvbmFsIG5vaXNlIGZvciBwYXJrcyAtIHJhbmdlIC1waS8yIHRvIHBpLzJcbiAgICAgICAgaWYgKHRoaXMucGFya3Muc29tZShwID0+IFBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24ocG9pbnQsIHApKSkge1xuICAgICAgICAgICAgLy8gVE9ETyBvcHRpbWlzZSBpbnNpZGVQb2x5Z29uIGUuZy4gZGlzdGFuY2VcbiAgICAgICAgICAgIHRlbnNvckFjYy5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbmFsTm9pc2UocG9pbnQsIHRoaXMubm9pc2VQYXJhbXMubm9pc2VTaXplUGFyaywgdGhpcy5ub2lzZVBhcmFtcy5ub2lzZUFuZ2xlUGFyaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubm9pc2VQYXJhbXMuZ2xvYmFsTm9pc2UpIHtcbiAgICAgICAgICAgIHRlbnNvckFjYy5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbmFsTm9pc2UocG9pbnQsIHRoaXMubm9pc2VQYXJhbXMubm9pc2VTaXplR2xvYmFsLCB0aGlzLm5vaXNlUGFyYW1zLm5vaXNlQW5nbGVHbG9iYWwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW5zb3JBY2M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9pc2UgQW5nbGUgaXMgaW4gZGVncmVlc1xuICAgICAqL1xuICAgIGdldFJvdGF0aW9uYWxOb2lzZShwb2ludDogVmVjdG9yLCBub2lzZVNpemU6IG51bWJlciwgbm9pc2VBbmdsZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9pc2Uubm9pc2UyRChwb2ludC54IC8gbm9pc2VTaXplLCBwb2ludC55IC8gbm9pc2VTaXplKSAqIG5vaXNlQW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIH1cblxuICAgIG9uTGFuZChwb2ludDogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGluU2VhID0gUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbihwb2ludCwgdGhpcy5zZWEpO1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVSaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuICFpblNlYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhaW5TZWEgJiYgIVBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24ocG9pbnQsIHRoaXMucml2ZXIpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBzaW1wbGlmeSBmcm9tICdzaW1wbGlmeS1qcyc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgR3JpZFN0b3JhZ2UgZnJvbSAnLi9ncmlkX3N0b3JhZ2UnO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuL2ludGVncmF0b3InO1xuaW1wb3J0IFN0cmVhbWxpbmVHZW5lcmF0b3IgZnJvbSAnLi9zdHJlYW1saW5lcyc7XG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4vc3RyZWFtbGluZXMnO1xuaW1wb3J0IFRlbnNvckZpZWxkIGZyb20gJy4vdGVuc29yX2ZpZWxkJztcbmltcG9ydCBQb2x5Z29uVXRpbCBmcm9tICcuL3BvbHlnb25fdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2F0ZXJQYXJhbXMgZXh0ZW5kcyBTdHJlYW1saW5lUGFyYW1zIHtcbiAgICBjb2FzdE5vaXNlOiBOb2lzZVN0cmVhbWxpbmVQYXJhbXM7XG4gICAgcml2ZXJOb2lzZTogTm9pc2VTdHJlYW1saW5lUGFyYW1zO1xuICAgIHJpdmVyQmFua1NpemU6IG51bWJlcjtcbiAgICByaXZlclNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb2lzZVN0cmVhbWxpbmVQYXJhbXMge1xuICAgIG5vaXNlRW5hYmxlZDogYm9vbGVhbjtcbiAgICBub2lzZVNpemU6IG51bWJlcjtcbiAgICBub2lzZUFuZ2xlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhdGVyR2VuZXJhdG9yIGV4dGVuZHMgU3RyZWFtbGluZUdlbmVyYXRvciB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBUUklFUyA9IDEwMDtcbiAgICBwcml2YXRlIGNvYXN0bGluZU1ham9yID0gdHJ1ZTtcbiAgICBwcml2YXRlIF9jb2FzdGxpbmU6IFZlY3RvcltdID0gW107ICAvLyBOb2lzeSBsaW5lXG4gICAgcHJpdmF0ZSBfc2VhUG9seWdvbjogVmVjdG9yW10gPSBbXTsgIC8vIFVzZXMgc2NyZWVuIHJlY3RhbmdsZSBhbmQgc2ltcGxpZmllZCByb2FkXG4gICAgcHJpdmF0ZSBfcml2ZXJQb2x5Z29uOiBWZWN0b3JbXSA9IFtdOyAvLyBTaW1wbGlmaWVkXG4gICAgcHJpdmF0ZSBfcml2ZXJTZWNvbmRhcnlSb2FkOiBWZWN0b3JbXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IoaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogVmVjdG9yLFxuICAgICAgICAgICAgICAgIHdvcmxkRGltZW5zaW9uczogVmVjdG9yLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJhbXM6IFdhdGVyUGFyYW1zLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkKSB7XG4gICAgICAgIHN1cGVyKGludGVncmF0b3IsIG9yaWdpbiwgd29ybGREaW1lbnNpb25zLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGdldCBjb2FzdGxpbmUoKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29hc3RsaW5lO1xuICAgIH1cblxuICAgIGdldCBzZWFQb2x5Z29uKCk6IFZlY3RvcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlYVBvbHlnb247XG4gICAgfVxuXG4gICAgZ2V0IHJpdmVyUG9seWdvbigpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaXZlclBvbHlnb247XG4gICAgfVxuXG4gICAgZ2V0IHJpdmVyU2Vjb25kYXJ5Um9hZCgpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaXZlclNlY29uZGFyeVJvYWQ7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29hc3QoKTogdm9pZCB7XG4gICAgICAgIGxldCBjb2FzdFN0cmVhbWxpbmU7XG4gICAgICAgIGxldCBzZWVkO1xuICAgICAgICBsZXQgbWFqb3I7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmNvYXN0Tm9pc2Uubm9pc2VFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRlbnNvckZpZWxkLmVuYWJsZUdsb2JhbE5vaXNlKHRoaXMucGFyYW1zLmNvYXN0Tm9pc2Uubm9pc2VBbmdsZSwgdGhpcy5wYXJhbXMuY29hc3ROb2lzZS5ub2lzZVNpemUpOyAgICBcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuVFJJRVM7IGkrKykge1xuICAgICAgICAgICAgbWFqb3IgPSBNYXRoLnJhbmRvbSgpIDwgMC41O1xuICAgICAgICAgICAgc2VlZCA9IHRoaXMuZ2V0U2VlZChtYWpvcik7XG4gICAgICAgICAgICBjb2FzdFN0cmVhbWxpbmUgPSB0aGlzLmV4dGVuZFN0cmVhbWxpbmUodGhpcy5pbnRlZ3JhdGVTdHJlYW1saW5lKHNlZWQsIG1ham9yKSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWNoZXNFZGdlcyhjb2FzdFN0cmVhbWxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5kaXNhYmxlR2xvYmFsTm9pc2UoKTtcblxuICAgICAgICB0aGlzLl9jb2FzdGxpbmUgPSBjb2FzdFN0cmVhbWxpbmU7XG4gICAgICAgIHRoaXMuY29hc3RsaW5lTWFqb3IgPSBtYWpvcjtcblxuICAgICAgICBjb25zdCByb2FkID0gdGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUoY29hc3RTdHJlYW1saW5lKTtcbiAgICAgICAgdGhpcy5fc2VhUG9seWdvbiA9IHRoaXMuZ2V0U2VhUG9seWdvbihyb2FkKTtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5wdXNoKHJvYWQpO1xuICAgICAgICB0aGlzLnRlbnNvckZpZWxkLnNlYSA9ICh0aGlzLl9zZWFQb2x5Z29uKTtcblxuICAgICAgICAvLyBDcmVhdGUgaW50ZXJtZWRpYXRlIHNhbXBsZXNcbiAgICAgICAgY29uc3QgY29tcGxleCA9IHRoaXMuY29tcGxleGlmeVN0cmVhbWxpbmUocm9hZCk7XG4gICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoY29tcGxleCk7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMobWFqb3IpLnB1c2goY29tcGxleCk7XG4gICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXMucHVzaChjb21wbGV4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVSaXZlcigpOiB2b2lkIHtcbiAgICAgICAgbGV0IHJpdmVyU3RyZWFtbGluZTtcbiAgICAgICAgbGV0IHNlZWQ7XG5cbiAgICAgICAgLy8gTmVlZCB0byBpZ25vcmUgc2VhIHdoZW4gaW50ZWdyYXRpbmcgZm9yIGVkZ2UgY2hlY2tcbiAgICAgICAgY29uc3Qgb2xkU2VhID0gdGhpcy50ZW5zb3JGaWVsZC5zZWE7XG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuc2VhID0gW107XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5yaXZlck5vaXNlLm5vaXNlRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5lbmFibGVHbG9iYWxOb2lzZSh0aGlzLnBhcmFtcy5yaXZlck5vaXNlLm5vaXNlQW5nbGUsIHRoaXMucGFyYW1zLnJpdmVyTm9pc2Uubm9pc2VTaXplKTsgICAgXG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuVFJJRVM7IGkrKykge1xuICAgICAgICAgICAgc2VlZCA9IHRoaXMuZ2V0U2VlZCghdGhpcy5jb2FzdGxpbmVNYWpvcik7XG4gICAgICAgICAgICByaXZlclN0cmVhbWxpbmUgPSB0aGlzLmV4dGVuZFN0cmVhbWxpbmUodGhpcy5pbnRlZ3JhdGVTdHJlYW1saW5lKHNlZWQsICF0aGlzLmNvYXN0bGluZU1ham9yKSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWNoZXNFZGdlcyhyaXZlclN0cmVhbWxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IHRoaXMuVFJJRVMgLSAxKSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdGYWlsZWQgdG8gZmluZCByaXZlciByZWFjaGluZyBlZGdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5zZWEgPSBvbGRTZWE7XG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuZGlzYWJsZUdsb2JhbE5vaXNlKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJpdmVyIHJvYWRzXG4gICAgICAgIGNvbnN0IGV4cGFuZGVkTm9pc3kgPSB0aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lKFBvbHlnb25VdGlsLnJlc2l6ZUdlb21ldHJ5KHJpdmVyU3RyZWFtbGluZSwgdGhpcy5wYXJhbXMucml2ZXJTaXplLCBmYWxzZSkpO1xuICAgICAgICB0aGlzLl9yaXZlclBvbHlnb24gPSBQb2x5Z29uVXRpbC5yZXNpemVHZW9tZXRyeShyaXZlclN0cmVhbWxpbmUsIHRoaXMucGFyYW1zLnJpdmVyU2l6ZSAtIHRoaXMucGFyYW1zLnJpdmVyQmFua1NpemUsIGZhbHNlKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHJpdmVyUG9seWdvblswXSBpcyBvZmYgc2NyZWVuXG4gICAgICAgIGNvbnN0IGZpcnN0T2ZmU2NyZWVuID0gZXhwYW5kZWROb2lzeS5maW5kSW5kZXgodiA9PiB0aGlzLnZlY3Rvck9mZlNjcmVlbih2KSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RPZmZTY3JlZW47IGkrKykge1xuICAgICAgICAgICAgZXhwYW5kZWROb2lzeS5wdXNoKGV4cGFuZGVkTm9pc3kuc2hpZnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgcml2ZXIgcm9hZHNcbiAgICAgICAgY29uc3Qgcml2ZXJTcGxpdFBvbHkgPSB0aGlzLmdldFNlYVBvbHlnb24ocml2ZXJTdHJlYW1saW5lKTtcbiAgICAgICAgY29uc3Qgcm9hZDEgPSBleHBhbmRlZE5vaXN5LmZpbHRlcih2ID0+XG4gICAgICAgICAgICAhUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbih2LCB0aGlzLl9zZWFQb2x5Z29uKVxuICAgICAgICAgICAgJiYgIXRoaXMudmVjdG9yT2ZmU2NyZWVuKHYpXG4gICAgICAgICAgICAmJiBQb2x5Z29uVXRpbC5pbnNpZGVQb2x5Z29uKHYsIHJpdmVyU3BsaXRQb2x5KSk7XG4gICAgICAgIGNvbnN0IHJvYWQxU2ltcGxlID0gdGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUocm9hZDEpO1xuICAgICAgICBjb25zdCByb2FkMiA9IGV4cGFuZGVkTm9pc3kuZmlsdGVyKHYgPT5cbiAgICAgICAgICAgICFQb2x5Z29uVXRpbC5pbnNpZGVQb2x5Z29uKHYsIHRoaXMuX3NlYVBvbHlnb24pXG4gICAgICAgICAgICAmJiAhdGhpcy52ZWN0b3JPZmZTY3JlZW4odilcbiAgICAgICAgICAgICYmICFQb2x5Z29uVXRpbC5pbnNpZGVQb2x5Z29uKHYsIHJpdmVyU3BsaXRQb2x5KSk7XG4gICAgICAgIGNvbnN0IHJvYWQyU2ltcGxlID0gdGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUocm9hZDIpO1xuXG4gICAgICAgIGlmIChyb2FkMS5sZW5ndGggPT09IDAgfHwgcm9hZDIubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHJvYWQxWzBdLmRpc3RhbmNlVG9TcXVhcmVkKHJvYWQyWzBdKSA8IHJvYWQxWzBdLmRpc3RhbmNlVG9TcXVhcmVkKHJvYWQyW3JvYWQyLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgcm9hZDJTaW1wbGUucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5yaXZlciA9IHJvYWQxU2ltcGxlLmNvbmNhdChyb2FkMlNpbXBsZSk7XG5cbiAgICAgICAgLy8gUm9hZCAxXG4gICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXNTaW1wbGUucHVzaChyb2FkMVNpbXBsZSk7XG4gICAgICAgIHRoaXMuX3JpdmVyU2Vjb25kYXJ5Um9hZCA9IHJvYWQyU2ltcGxlO1xuXG4gICAgICAgIHRoaXMuZ3JpZCghdGhpcy5jb2FzdGxpbmVNYWpvcikuYWRkUG9seWxpbmUocm9hZDEpO1xuICAgICAgICB0aGlzLmdyaWQoIXRoaXMuY29hc3RsaW5lTWFqb3IpLmFkZFBvbHlsaW5lKHJvYWQyKTtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyghdGhpcy5jb2FzdGxpbmVNYWpvcikucHVzaChyb2FkMSk7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMoIXRoaXMuY29hc3RsaW5lTWFqb3IpLnB1c2gocm9hZDIpO1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzLnB1c2gocm9hZDEpO1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzLnB1c2gocm9hZDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc3VtZXMgc2ltcGxpZmllZFxuICAgICAqIFVzZWQgZm9yIGFkZGluZyByaXZlciByb2Fkc1xuICAgICAqL1xuICAgIHByaXZhdGUgbWFudWFsbHlBZGRTdHJlYW1saW5lKHM6IFZlY3RvcltdLCBtYWpvcjogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnB1c2gocyk7XG4gICAgICAgIC8vIENyZWF0ZSBpbnRlcm1lZGlhdGUgc2FtcGxlc1xuICAgICAgICBjb25zdCBjb21wbGV4ID0gdGhpcy5jb21wbGV4aWZ5U3RyZWFtbGluZShzKTtcbiAgICAgICAgdGhpcy5ncmlkKG1ham9yKS5hZGRQb2x5bGluZShjb21wbGV4KTtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyhtYWpvcikucHVzaChjb21wbGV4KTtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcy5wdXNoKGNvbXBsZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pZ2h0IHJldmVyc2UgaW5wdXQgYXJyYXlcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFNlYVBvbHlnb24ocG9seWxpbmU6IFZlY3RvcltdKTogVmVjdG9yW10ge1xuICAgICAgICBjb25zdCBzZWFQb2x5Z29uID0gUG9seWdvblV0aWwuc2xpY2VSZWN0YW5nbGUodGhpcy5vcmlnaW4sIHRoaXMud29ybGREaW1lbnNpb25zLFxuICAgICAgICAgICAgcG9seWxpbmVbMF0sIHBvbHlsaW5lW3BvbHlsaW5lLmxlbmd0aCAtIDFdKTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBsb25nZXN0IHNpZGUgd2l0aCBjb2FzdGxpbmVcbiAgICAgICAgbGV0IGxvbmdlc3RJbmRleCA9IDA7XG4gICAgICAgIGxldCBsb25nZXN0TGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFQb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gKGkgKyAxKSAlIHNlYVBvbHlnb24ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZCA9IHNlYVBvbHlnb25baV0uZGlzdGFuY2VUb1NxdWFyZWQoc2VhUG9seWdvbltuZXh0XSk7XG4gICAgICAgICAgICBpZiAoZCA+IGxvbmdlc3RMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb25nZXN0TGVuZ3RoID0gZDtcbiAgICAgICAgICAgICAgICBsb25nZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5zZXJ0QmFja3dhcmRzID0gc2VhUG9seWdvbltsb25nZXN0SW5kZXhdLmRpc3RhbmNlVG9TcXVhcmVkKHBvbHlsaW5lWzBdKSA+IHNlYVBvbHlnb25bbG9uZ2VzdEluZGV4XS5kaXN0YW5jZVRvU3F1YXJlZChwb2x5bGluZVtwb2x5bGluZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChpbnNlcnRCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHBvbHlsaW5lLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlYVBvbHlnb24uc3BsaWNlKChsb25nZXN0SW5kZXggKyAxKSAlIHNlYVBvbHlnb24ubGVuZ3RoLCAwLCAuLi5wb2x5bGluZSk7XG4gICAgICAgIHJldHVybiBzZWFQb2x5Z29uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBzYW1wbGVzIGluIHN0cmVhbWxpbmUgdW50aWwgc2VwYXJhdGVkIGJ5IGRzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBjb21wbGV4aWZ5U3RyZWFtbGluZShzOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgbGV0IG91dDogVmVjdG9yW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgb3V0LnB1c2goLi4udGhpcy5jb21wbGV4aWZ5U3RyZWFtbGluZVJlY3Vyc2l2ZShzW2ldLCBzW2krMV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgY29tcGxleGlmeVN0cmVhbWxpbmVSZWN1cnNpdmUodjE6IFZlY3RvciwgdjI6IFZlY3Rvcik6IFZlY3RvcltdIHtcbiAgICAgICAgaWYgKHYxLmRpc3RhbmNlVG9TcXVhcmVkKHYyKSA8PSB0aGlzLnBhcmFtc1NxLmRzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gW3YxLCB2Ml07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZCA9IHYyLmNsb25lKCkuc3ViKHYxKTtcbiAgICAgICAgY29uc3QgaGFsZndheSA9IHYxLmNsb25lKCkuYWRkKGQubXVsdGlwbHlTY2FsYXIoMC41KSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjb21wbGV4ID0gdGhpcy5jb21wbGV4aWZ5U3RyZWFtbGluZVJlY3Vyc2l2ZSh2MSwgaGFsZndheSk7XG4gICAgICAgIGNvbXBsZXgucHVzaCguLi50aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lUmVjdXJzaXZlKGhhbGZ3YXksIHYyKSk7XG4gICAgICAgIHJldHVybiBjb21wbGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11dGF0ZXMgc3RyZWFtbGluZVxuICAgICAqL1xuICAgIHByaXZhdGUgZXh0ZW5kU3RyZWFtbGluZShzdHJlYW1saW5lOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgICAgIHN0cmVhbWxpbmUudW5zaGlmdChzdHJlYW1saW5lWzBdLmNsb25lKCkuYWRkKFxuICAgICAgICAgICAgICAgIHN0cmVhbWxpbmVbMF0uY2xvbmUoKS5zdWIoc3RyZWFtbGluZVsxXSkuc2V0TGVuZ3RoKHRoaXMucGFyYW1zLmRzdGVwICogNSkpKTtcbiAgICAgICAgICAgIHN0cmVhbWxpbmUucHVzaChzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0uY2xvbmUoKS5hZGQoXG4gICAgICAgICAgICAgICAgc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdLmNsb25lKCkuc3ViKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAyXSkuc2V0TGVuZ3RoKHRoaXMucGFyYW1zLmRzdGVwICogNSkpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW1saW5lO1xuICAgICAgICB9XG5cbiAgICBwcml2YXRlIHJlYWNoZXNFZGdlcyhzdHJlYW1saW5lOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JPZmZTY3JlZW4oc3RyZWFtbGluZVswXSkgJiYgdGhpcy52ZWN0b3JPZmZTY3JlZW4oc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZlY3Rvck9mZlNjcmVlbih2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgdG9PcmlnaW4gPSB2LmNsb25lKCkuc3ViKHRoaXMub3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRvT3JpZ2luLnggPD0gMCB8fCB0b09yaWdpbi55IDw9IDAgfHxcbiAgICAgICAgICAgIHRvT3JpZ2luLnggPj0gdGhpcy53b3JsZERpbWVuc2lvbnMueCB8fCB0b09yaWdpbi55ID49IHRoaXMud29ybGREaW1lbnNpb25zLnk7XG4gICAgfVxufVxuXG4vLyBjcmVhdGVDb2FzdFN0cmVhbWxpbmUoKTogVmVjdG9yW11bXSB7XG4vLyAgICAgICAgIGxldCBjb2FzdFN0cmVhbWxpbmU7XG4vLyAgICAgICAgIGxldCByaXZlclN0cmVhbWxpbmU7XG4vLyAgICAgICAgIGxldCBzZWVkO1xuLy8gICAgICAgICBsZXQgbWFqb3I7XG5cbi8vICAgICAgICAgY29uc3QgZXh0ZW5kU3RyZWFtbGluZSA9IChzdHJlYW1saW5lOiBWZWN0b3JbXSkgPT4ge1xuLy8gICAgICAgICAgICAgc3RyZWFtbGluZS51bnNoaWZ0KHN0cmVhbWxpbmVbMF0uY2xvbmUoKS5hZGQoXG4vLyAgICAgICAgICAgICAgICAgc3RyZWFtbGluZVswXS5jbG9uZSgpLnN1YihzdHJlYW1saW5lWzFdKS5zZXRMZW5ndGgodGhpcy5wYXJhbXMuZHN0ZXAgKiA1KSkpO1xuLy8gICAgICAgICAgICAgc3RyZWFtbGluZS5wdXNoKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXS5jbG9uZSgpLmFkZChcbi8vICAgICAgICAgICAgICAgICBzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0uY2xvbmUoKS5zdWIoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDJdKS5zZXRMZW5ndGgodGhpcy5wYXJhbXMuZHN0ZXAgKiA1KSkpO1xuLy8gICAgICAgICAgICAgcmV0dXJuIHN0cmVhbWxpbmU7XG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICBjb25zdCByZWFjaGVzRWRnZXMgPSAoc3RyZWFtbGluZTogVmVjdG9yW10pID0+IHtcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlY3Rvck9mZlNjcmVlbihzdHJlYW1saW5lWzBdKSAmJiB0aGlzLnZlY3Rvck9mZlNjcmVlbihzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pO1xuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuLy8gICAgICAgICAgICAgLy8gVE9ET1xuLy8gICAgICAgICAgICAgbWFqb3IgPSB0cnVlO1xuLy8gICAgICAgICAgICAgLy8gbWFqb3IgPSBNYXRoLnJhbmRvbSgpIDwgMC41O1xuLy8gICAgICAgICAgICAgc2VlZCA9IHRoaXMuZ2V0U2VlZChtYWpvcik7XG4vLyAgICAgICAgICAgICBjb2FzdFN0cmVhbWxpbmUgPSBleHRlbmRTdHJlYW1saW5lKHRoaXMuaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkLCBtYWpvcikpO1xuLy8gICAgICAgICAgICAgcml2ZXJTdHJlYW1saW5lID0gZXh0ZW5kU3RyZWFtbGluZSh0aGlzLmludGVncmF0ZVN0cmVhbWxpbmUoc2VlZCwgIW1ham9yKSk7XG5cbi8vICAgICAgICAgICAgIGlmIChyZWFjaGVzRWRnZXMoY29hc3RTdHJlYW1saW5lKSAmJiByZWFjaGVzRWRnZXMocml2ZXJTdHJlYW1saW5lKSkge1xuLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgLy8gU3RyZWFtbGluZSBpcyBjb2FzdGFsID0gbm9pc3lcbi8vICAgICAgICAgY29uc3Qgcm9hZCA9IHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKGNvYXN0U3RyZWFtbGluZSk7XG4vLyAgICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXNTaW1wbGUucHVzaChyb2FkKTtcblxuLy8gICAgICAgICAvLyBDcmVhdGUgaW50ZXJtZWRpYXRlIHNhbXBsZXNcbi8vICAgICAgICAgY29uc3QgY29tcGxleCA9IHRoaXMuY29tcGxleGlmeVN0cmVhbWxpbmUocm9hZCk7XG4vLyAgICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoY29tcGxleCk7XG4vLyAgICAgICAgIHRoaXMuc3RyZWFtbGluZXMobWFqb3IpLnB1c2goY29tcGxleCk7XG4vLyAgICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXMucHVzaChjb21wbGV4KTtcblxuLy8gICAgICAgICB0aGlzLnRlbnNvckZpZWxkLmFkZFdhdGVyKHRoaXMuZ2V0U2VhUG9seWdvbihyb2FkKSk7XG5cbi8vICAgICAgICAgLy8gUmV0dXJuIHVuc2ltcGxpZmllZCBzdHJlYW1saW5lc1xuLy8gICAgICAgICByZXR1cm4gW2NvYXN0U3RyZWFtbGluZSwgcml2ZXJTdHJlYW1saW5lXTtcbi8vICAgICB9XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvdWdoT3B0aW9ucyB7XG4gICAgcm91Z2huZXNzPzogbnVtYmVyO1xuICAgIGJvd2luZz86IG51bWJlcjtcbiAgICBzZWVkPzogbnVtYmVyO1xuICAgIHN0cm9rZT86IHN0cmluZztcbiAgICBzdHJva2VXaWR0aD86IG51bWJlcjtcbiAgICBmaWxsPzogc3RyaW5nO1xuICAgIGZpbGxTdHlsZT86IHN0cmluZztcbiAgICBmaWxsV2VpZ2h0PzogbnVtYmVyO1xuICAgIGhhY2h1cmVBbmdsZT86IG51bWJlcjtcbiAgICBoYWNodXJlR2FwPzogbnVtYmVyO1xuICAgIGRhc2hPZmZzZXQ/OiBudW1iZXI7XG4gICAgZGFzaEdhcD86IG51bWJlcjtcbiAgICB6aWd6YWdPZmZzZXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIENhbnZhc1dyYXBwZXIge1xuICAgIHByb3RlY3RlZCBfd2lkdGg6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2hlaWdodDogbnVtYmVyO1xuICAgIHB1YmxpYyBuZWVkc1VwZGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBwcm90ZWN0ZWQgX3NjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpIHtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMucmVzaXplQ2FudmFzKCk7XG4gICAgICAgIGlmIChyZXNpemVUb1dpbmRvdykge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhYnN0cmFjdCBkcmF3RnJhbWUobGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyLCB1cDogbnVtYmVyLCBkb3duOiBudW1iZXIpOiB2b2lkO1xuXG4gICAgc2V0RGltZW5zaW9ucygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAqIHRoaXMuX3NjYWxlO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiB0aGlzLl9zY2FsZTtcbiAgICB9XG5cbiAgICBnZXQgd2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIH1cblxuICAgIGdldCBoZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG5cbiAgICBnZXQgY2FudmFzU2NhbGUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlO1xuICAgIH1cblxuICAgIHNldCBjYW52YXNTY2FsZShzOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSBzO1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgem9vbVZlY3RvcnModnM6IFZlY3RvcltdKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdnNbaV0gPSB2c1tpXS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuX3NjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCByZXNpemVDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGVmYXVsdENhbnZhc1dyYXBwZXIgZXh0ZW5kcyBDYW52YXNXcmFwcGVyIHtcbiAgICBwcml2YXRlIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGU9MSwgcmVzaXplVG9XaW5kb3c9dHJ1ZSkge1xuICAgICAgICBzdXBlcihjYW52YXMsIHNjYWxlLCByZXNpemVUb1dpbmRvdyk7XG4gICAgICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfVxuXG4gICAgc2V0RmlsbFN0eWxlKGNvbG91cjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG91cjtcbiAgICB9XG5cbiAgICBjbGVhckNhbnZhcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIGRyYXdGcmFtZShsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHVwOiBudW1iZXIsIGRvd246IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoMCwgMCwgdGhpcy5fd2lkdGgvdGhpcy5fc2NhbGUsIHVwKTtcbiAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKDAsIDAsIGxlZnQsIHRoaXMuX2hlaWdodC90aGlzLl9zY2FsZSk7XG4gICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZSh0aGlzLl93aWR0aC90aGlzLl9zY2FsZSAtIHJpZ2h0LCAwLCByaWdodCwgdGhpcy5faGVpZ2h0L3RoaXMuX3NjYWxlKTtcbiAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKDAsIHRoaXMuX2hlaWdodC90aGlzLl9zY2FsZSAtIGRvd24sIHRoaXMuX3dpZHRoL3RoaXMuX3NjYWxlLCBkb3duKTtcbiAgICB9XG5cbiAgICBkcmF3Q2l0eU5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gNTAgKiB0aGlzLl9zY2FsZTtcbiAgICAgICAgdGhpcy5jdHguZm9udCA9IGBzbWFsbC1jYXBzICR7Zm9udFNpemV9cHggVmVyZGFuYWA7XG4gICAgICAgIHRoaXMuY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KFwic2FuIGZyYW5jaXNjb1wiLCB0aGlzLl93aWR0aC8yLCB0aGlzLl9oZWlnaHQgLSAoODAgKiB0aGlzLl9zY2FsZSAtIGZvbnRTaXplKSk7XG4gICAgfVxuXG4gICAgZHJhd1JlY3RhbmdsZSh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICB4ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgeSAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgIHdpZHRoICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgaGVpZ2h0ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGRyYXdQb2x5Z29uKHBvbHlnb246IFZlY3RvcltdKSB7XG4gICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuem9vbVZlY3RvcnMocG9seWdvbik7XG5cbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhwb2x5Z29uWzBdLngsIHBvbHlnb25bMF0ueSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lVG8ocG9seWdvbltpXS54LCBwb2x5Z29uW2ldLnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyhwb2x5Z29uWzBdLngsIHBvbHlnb25bMF0ueSk7XG5cbiAgICAgICAgdGhpcy5jdHguZmlsbCgpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBkcmF3U3F1YXJlKGNlbnRyZTogVmVjdG9yLCByYWRpdXM6IG51bWJlcikge1xuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoY2VudHJlLnggLSByYWRpdXMsIGNlbnRyZS55IC0gcmFkaXVzLCAyICogcmFkaXVzLCAyICogcmFkaXVzKTtcbiAgICB9XG5cbiAgICBzZXRMaW5lV2lkdGgod2lkdGg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHdpZHRoICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIH1cblxuICAgIHNldFN0cm9rZVN0eWxlKGNvbG91cjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3VyO1xuICAgIH1cblxuICAgIGRyYXdQb2x5bGluZShsaW5lOiBWZWN0b3JbXSk6IHZvaWQge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnpvb21WZWN0b3JzKGxpbmUpO1xuXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8obGluZVswXS54LCBsaW5lWzBdLnkpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKGxpbmVbaV0ueCwgbGluZVtpXS55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJvdWdoQ2FudmFzV3JhcHBlciBleHRlbmRzIENhbnZhc1dyYXBwZXIge1xuICAgIHByaXZhdGUgcmM6IGFueTtcbiAgICBwcml2YXRlIG9wdGlvbnM6IFJvdWdoT3B0aW9ucyA9IHtcbiAgICAgICAgcm91Z2huZXNzOiAxLFxuICAgICAgICBib3dpbmc6IDEsXG4gICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuICAgICAgICBmaWxsU3R5bGU6ICdzb2xpZCcsXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpIHtcbiAgICAgICAgc3VwZXIoY2FudmFzLCBzY2FsZSwgcmVzaXplVG9XaW5kb3cpO1xuICAgICAgICBsZXQgciA9IHJlcXVpcmUoJ3JvdWdoanMvYnVuZGxlZC9yb3VnaC5janMnKTtcbiAgICAgICAgdGhpcy5yYyA9IHIuY2FudmFzKGNhbnZhcyk7XG4gICAgfVxuXG4gICAgZHJhd0ZyYW1lKGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgdXA6IG51bWJlciwgZG93bjogbnVtYmVyKTogdm9pZCB7XG5cbiAgICB9XG5cbiAgICBzZXRPcHRpb25zKG9wdGlvbnM6IFJvdWdoT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VXaWR0aCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdHJva2VXaWR0aCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY2xlYXJDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZSgwLCAwLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB9XG5cbiAgICBkcmF3UmVjdGFuZ2xlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICB5ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgd2lkdGggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICBoZWlnaHQgKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYy5yZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBkcmF3UG9seWdvbihwb2x5Z29uOiBWZWN0b3JbXSkge1xuICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgcG9seWdvbiA9IHBvbHlnb24ubWFwKHYgPT4gdi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuX3NjYWxlKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJjLnBvbHlnb24ocG9seWdvbi5tYXAodiA9PiBbdi54LCB2LnldKSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBkcmF3U3F1YXJlKGNlbnRyZTogVmVjdG9yLCByYWRpdXM6IG51bWJlcikge1xuICAgICAgICBjb25zdCBwcmV2U3Ryb2tlID0gdGhpcy5vcHRpb25zLnN0cm9rZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnN0cm9rZSA9ICdub25lJztcbiAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKGNlbnRyZS54IC0gcmFkaXVzLCBjZW50cmUueSAtIHJhZGl1cywgMiAqIHJhZGl1cywgMiAqIHJhZGl1cyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdHJva2UgPSBwcmV2U3Ryb2tlO1xuICAgIH1cblxuICAgIGRyYXdQb2x5bGluZShsaW5lOiBWZWN0b3JbXSk6IHZvaWQge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLm1hcCh2ID0+IHYuY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLl9zY2FsZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yYy5saW5lYXJQYXRoKGxpbmUubWFwKHYgPT4gW3YueCwgdi55XSksIHRoaXMub3B0aW9ucyk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIFNpbmdsZXRvblxuICogQ29udHJvbHMgcGFubmluZyBhbmQgem9vbWluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb21haW5Db250cm9sbGVyIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRG9tYWluQ29udHJvbGxlcjtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgWk9PTV9TUEVFRCA9IDAuOTY7XG5cbiAgICAvLyBMb2NhdGlvbiBvZiBzY3JlZW4gb3JpZ2luIGluIHdvcmxkIHNwYWNlXG4gICAgcHJpdmF0ZSBfb3JpZ2luOiBWZWN0b3IgPSBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgIFxuICAgIC8vIFNjcmVlbi1zcGFjZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgcHJpdmF0ZSBfc2NyZWVuRGltZW5zaW9ucyA9IFZlY3Rvci56ZXJvVmVjdG9yKCk7XG5cbiAgICAvLyBSYXRpbyBvZiBzY3JlZW4gcGl4ZWxzIHRvIHdvcmxkIHBpeGVsc1xuICAgIHByaXZhdGUgX3pvb206IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSB6b29tQ2FsbGJhY2s6ICgpID0+IGFueSA9ICgpID0+IHt9O1xuXG4gICAgLy8gU2V0IGFmdGVyIHBhbiBvciB6b29tXG4gICAgcHVibGljIG1vdmVkID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNldFNjcmVlbkRpbWVuc2lvbnMoKTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCk6IHZvaWQgPT4gdGhpcy5zZXRTY3JlZW5EaW1lbnNpb25zKCkpO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChlOiBhbnkpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhOiBudW1iZXIgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIC8vIFRPRE8gc2NhbGUgYnkgdmFsdWUgb2YgZGVsdGFcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSB0aGlzLl96b29tICogdGhpcy5aT09NX1NQRUVEO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSB0aGlzLl96b29tIC8gdGhpcy5aT09NX1NQRUVEO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0U2NyZWVuRGltZW5zaW9ucygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjcmVlbkRpbWVuc2lvbnMuc2V0WCh3aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgICAgIHRoaXMuX3NjcmVlbkRpbWVuc2lvbnMuc2V0WSh3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogRG9tYWluQ29udHJvbGxlciB7XG4gICAgICAgIGlmICghRG9tYWluQ29udHJvbGxlci5pbnN0YW5jZSkge1xuICAgICAgICAgICAgRG9tYWluQ29udHJvbGxlci5pbnN0YW5jZSA9IG5ldyBEb21haW5Db250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERvbWFpbkNvbnRyb2xsZXIuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtWZWN0b3J9IGRlbHRhIGluIHdvcmxkIHNwYWNlXG4gICAgICovXG4gICAgcGFuKGRlbHRhOiBWZWN0b3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX29yaWdpbi5zdWIoZGVsdGEpO1xuICAgIH1cblxuICAgIGdldCBvcmlnaW4oKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbi5jbG9uZSgpO1xuICAgIH1cblxuICAgIGdldCB6b29tKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl96b29tO1xuICAgIH1cblxuICAgIGdldCBzY3JlZW5EaW1lbnNpb25zKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JlZW5EaW1lbnNpb25zLmNsb25lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7VmVjdG9yfSB3b3JsZC1zcGFjZSB3L2ggdmlzaWJsZSBvbiBzY3JlZW5cbiAgICAgKi9cbiAgICBnZXQgd29ybGREaW1lbnNpb25zKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbkRpbWVuc2lvbnMuZGl2aWRlU2NhbGFyKHRoaXMuX3pvb20pO1xuICAgIH1cblxuICAgIHNldCBzY3JlZW5EaW1lbnNpb25zKHY6IFZlY3Rvcikge1xuICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NyZWVuRGltZW5zaW9ucy5jb3B5KHYpO1xuICAgIH1cblxuICAgIHNldCB6b29tKHo6IG51bWJlcikge1xuICAgICAgICBpZiAoeiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgb2xkV29ybGRTcGFjZU1pZHBvaW50ID0gdGhpcy5vcmlnaW4uYWRkKHRoaXMud29ybGREaW1lbnNpb25zLmRpdmlkZVNjYWxhcigyKSk7XG4gICAgICAgICAgICB0aGlzLl96b29tID0gejtcbiAgICAgICAgICAgIGNvbnN0IG5ld1dvcmxkU3BhY2VNaWRwb2ludCA9IHRoaXMub3JpZ2luLmFkZCh0aGlzLndvcmxkRGltZW5zaW9ucy5kaXZpZGVTY2FsYXIoMikpO1xuICAgICAgICAgICAgdGhpcy5wYW4obmV3V29ybGRTcGFjZU1pZHBvaW50LnN1YihvbGRXb3JsZFNwYWNlTWlkcG9pbnQpKTtcbiAgICAgICAgICAgIHRoaXMuem9vbUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNjcmVlbih2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgc2NyZWVuU3BhY2UgPSB0aGlzLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKTtcbiAgICAgICAgcmV0dXJuIHNjcmVlblNwYWNlLnggPj0gMCAmJiBzY3JlZW5TcGFjZS55ID49IDBcbiAgICAgICAgICAgICYmIHNjcmVlblNwYWNlLnggPD0gdGhpcy5zY3JlZW5EaW1lbnNpb25zLnggJiYgc2NyZWVuU3BhY2UueSA8PSB0aGlzLnNjcmVlbkRpbWVuc2lvbnMueTtcbiAgICB9XG5cbiAgICBzZXRab29tVXBkYXRlKGNhbGxiYWNrOiAoKSA9PiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy56b29tQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0cyB2ZWN0b3JcbiAgICAgKi9cbiAgICB6b29tVG9Xb3JsZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5kaXZpZGVTY2FsYXIodGhpcy5fem9vbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgdmVjdG9yXG4gICAgICovXG4gICAgem9vbVRvU2NyZWVuKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB2Lm11bHRpcGx5U2NhbGFyKHRoaXMuX3pvb20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVkaXRzIHZlY3RvclxuICAgICAqL1xuICAgIHNjcmVlblRvV29ybGQodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbVRvV29ybGQodikuYWRkKHRoaXMuX29yaWdpbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgdmVjdG9yXG4gICAgICovXG4gICAgd29ybGRUb1NjcmVlbih2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy56b29tVG9TY3JlZW4odi5zdWIodGhpcy5fb3JpZ2luKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBpbnRlcmFjdCBmcm9tICdpbnRlcmFjdGpzJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi9WZWN0b3InO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5cbmludGVyZmFjZSBEcmFnZ2FibGUge1xuICAgIGdldENlbnRyZTogKCgpID0+IFZlY3Rvcik7XG4gICAgY2FsbGJhY2tGbjogKCh2OiBWZWN0b3IpID0+IHZvaWQpO1xufVxuXG4vKipcbiogUmVnaXN0ZXIgbXVsdGlwbGUgY2VudHJlIHBvaW50c1xuKiBDbG9zZXN0IG9uZSB0byBtb3VzZSBjbGljayB3aWxsIGJlIHNlbGVjdGVkIHRvIGRyYWdcbiogVXAgdG8gY2FsbGVyIHRvIGFjdHVhbGx5IG1vdmUgdGhlaXIgY2VudHJlIHBvaW50IHZpYSBjYWxsYmFja1xuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyYWdDb250cm9sbGVyIHtcbiAgICAvLyBIb3cgY2xvc2UgdG8gZHJhZyBoYW5kbGUgcG9pbnRlciBuZWVkcyB0byBiZVxuICAgIHByaXZhdGUgcmVhZG9ubHkgTUlOX0RSQUdfRElTVEFOQ0UgPSA1MDtcblxuICAgIHByaXZhdGUgZHJhZ2dhYmxlczogRHJhZ2dhYmxlW10gPSBbXTtcbiAgICBwcml2YXRlIGN1cnJlbnRseURyYWdnaW5nOiBEcmFnZ2FibGUgPSBudWxsO1xuICAgIHByaXZhdGUgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGd1aTogZGF0LkdVSSkge1xuICAgICAgICBpbnRlcmFjdChgIyR7VXRpbC5DQU5WQVNfSUR9YCkuZHJhZ2dhYmxlKHtcbiAgICAgICAgICAgIG9uc3RhcnQ6IHRoaXMuZHJhZ1N0YXJ0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBvbm1vdmU6IHRoaXMuZHJhZ01vdmUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uZW5kOiB0aGlzLmRyYWdFbmQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGN1cnNvckNoZWNrZXI6IHRoaXMuZ2V0Q3Vyc29yLmJpbmQodGhpcyksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldERyYWdEaXNhYmxlZChkaXNhYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlO1xuICAgIH1cblxuICAgIGdldEN1cnNvcihhY3Rpb246IGFueSwgaW50ZXJhY3RhYmxlOiBhbnksIGVsZW1lbnQ6IGFueSwgaW50ZXJhY3Rpbmc6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKGludGVyYWN0aW5nKSByZXR1cm4gJ2dyYWJiaW5nJztcbiAgICAgICAgcmV0dXJuICdncmFiJztcbiAgICB9XG5cbiAgICBkcmFnU3RhcnQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICAvLyBUcmFuc2Zvcm0gc2NyZWVuIHNwYWNlIHRvIHdvcmxkIHNwYWNlXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZG9tYWluQ29udHJvbGxlci5zY3JlZW5Ub1dvcmxkKG5ldyBWZWN0b3IoZXZlbnQueDAsIGV2ZW50LnkwKSk7XG4gICAgICAgIFxuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlcy5mb3JFYWNoKGRyYWdnYWJsZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkID0gZHJhZ2dhYmxlLmdldENlbnRyZSgpLmRpc3RhbmNlVG8ob3JpZ2luKTtcbiAgICAgICAgICAgIGlmIChkIDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZDtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRseURyYWdnaW5nID0gZHJhZ2dhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBab29tIHNjcmVlbiBzaXplIHRvIHdvcmxkIHNpemUgZm9yIGNvbnNpc3RlbnQgZHJhZyBkaXN0YW5jZSB3aGlsZSB6b29tZWQgaW5cbiAgICAgICAgY29uc3Qgc2NhbGVkRHJhZ0Rpc3RhbmNlID0gdGhpcy5NSU5fRFJBR19ESVNUQU5DRSAvIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tO1xuXG4gICAgICAgIGlmIChjbG9zZXN0RGlzdGFuY2UgPiBzY2FsZWREcmFnRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHJhZ01vdmUoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCBkZWx0YSA9IG5ldyBWZWN0b3IoZXZlbnQuZGVsdGEueCwgZXZlbnQuZGVsdGEueSk7XG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tVG9Xb3JsZChkZWx0YSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERyYWcgZmllbGRcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcuY2FsbGJhY2tGbihkZWx0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNb3ZlIG1hcFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnBhbihkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmFnRW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnRseURyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgVXRpbC51cGRhdGVHdWkodGhpcy5ndWkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7KCgpID0+IFZlY3Rvcil9IEdldHMgY2VudHJlIHBvaW50XG4gICAgICogQHBhcmFtIHsoKHY6IFZlY3RvcikgPT4gdm9pZCl9IENhbGxlZCBvbiBtb3ZlIHdpdGggZGVsdGEgdmVjdG9yXG4gICAgICogQHJldHVybnMgeygoKSA9PiB2b2lkKX0gRnVuY3Rpb24gdG8gZGVyZWdpc3RlciBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlZ2lzdGVyKGdldENlbnRyZTogKCgpID0+IFZlY3RvciksXG4gICAgICAgICAgICAgb25Nb3ZlOiAoKHY6IFZlY3RvcikgPT4gdm9pZCkpOiAoKCkgPT4gdm9pZCkge1xuICAgICAgICBjb25zdCBkcmFnZ2FibGU6IERyYWdnYWJsZSA9IHtcbiAgICAgICAgICAgIGdldENlbnRyZTogZ2V0Q2VudHJlLFxuICAgICAgICAgICAgY2FsbGJhY2tGbjogb25Nb3ZlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlcy5wdXNoKGRyYWdnYWJsZSk7XG4gICAgICAgIHJldHVybiAoKCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRyYWdnYWJsZXMuaW5kZXhPZihkcmFnZ2FibGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb2FkR1VJIHtcbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZXM6IFN0cmVhbWxpbmVHZW5lcmF0b3I7XG4gICAgcHJpdmF0ZSBleGlzdGluZ1N0cmVhbWxpbmVzOiBSb2FkR1VJW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBwcm90ZWN0ZWQgcHJlR2VuZXJhdGVDYWxsYmFjazogKCkgPT4gYW55ID0gKCkgPT4ge307XG4gICAgcHJvdGVjdGVkIHBvc3RHZW5lcmF0ZUNhbGxiYWNrOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcblxuICAgIHByaXZhdGUgc3RyZWFtbGluZXNJblByb2dyZXNzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBpbnRlZ3JhdG9yOiBGaWVsZEludGVncmF0b3IsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIGd1aUZvbGRlcjogZGF0LkdVSSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgY2xvc2VUZW5zb3JGb2xkZXI6ICgpID0+IHZvaWQsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIGZvbGRlck5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcmVkcmF3OiAoKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBfYW5pbWF0ZT1mYWxzZSkge1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzID0gbmV3IFN0cmVhbWxpbmVHZW5lcmF0b3IoXG4gICAgICAgICAgICB0aGlzLmludGVncmF0b3IsIHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4sXG4gICAgICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLCB0aGlzLnBhcmFtcyk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHBhdGggaXRlcmF0aW9ucyBiYXNlZCBvbiB3aW5kb3cgc2l6ZVxuICAgICAgICB0aGlzLnNldFBhdGhJdGVyYXRpb25zKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKTogdm9pZCA9PiB0aGlzLnNldFBhdGhJdGVyYXRpb25zKCkpO1xuICAgIH1cblxuICAgIGluaXRGb2xkZXIoKTogUm9hZEdVSSB7XG4gICAgICAgIGNvbnN0IHJvYWRHVUkgPSB7XG4gICAgICAgICAgICBHZW5lcmF0ZTogKCkgPT4gdGhpcy5nZW5lcmF0ZVJvYWRzKHRoaXMuX2FuaW1hdGUpLnRoZW4oKCkgPT4gdGhpcy5yZWRyYXcoKSksXG4gICAgICAgICAgICBKb2luRGFuZ2xpbmc6ICgpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmpvaW5EYW5nbGluZ1N0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5ndWlGb2xkZXIuYWRkRm9sZGVyKHRoaXMuZm9sZGVyTmFtZSk7XG4gICAgICAgIGZvbGRlci5hZGQocm9hZEdVSSwgJ0dlbmVyYXRlJyk7XG4gICAgICAgIGZvbGRlci5hZGQocm9hZEdVSSwgJ0pvaW5EYW5nbGluZycpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFyYW1zRm9sZGVyID0gZm9sZGVyLmFkZEZvbGRlcignUGFyYW1zJyk7XG4gICAgICAgIHBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMsICdkc2VwJyk7XG4gICAgICAgIHBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMsICdkdGVzdCcpO1xuXG4gICAgICAgIGNvbnN0IGRldlBhcmFtc0ZvbGRlciA9IHBhcmFtc0ZvbGRlci5hZGRGb2xkZXIoJ0RldicpO1xuICAgICAgICB0aGlzLmFkZERldlBhcmFtc1RvRm9sZGVyKHRoaXMucGFyYW1zLCBkZXZQYXJhbXNGb2xkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQgYW5pbWF0ZShiOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGUgPSBiO1xuICAgIH1cblxuICAgIGdldCBhbGxTdHJlYW1saW5lcygpOiBWZWN0b3JbXVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMuYWxsU3RyZWFtbGluZXNTaW1wbGU7XG4gICAgfVxuXG4gICAgZ2V0IHJvYWRzKCk6IFZlY3RvcltdW10ge1xuICAgICAgICAvLyBGb3IgZHJhd2luZyBub3QgZ2VuZXJhdGlvbiwgcHJvYmFibHkgZmluZSB0byBsZWF2ZSBtYXBcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMuYWxsU3RyZWFtbGluZXNTaW1wbGUubWFwKHMgPT5cbiAgICAgICAgICAgIHMubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByb2Fkc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgc2V0RXhpc3RpbmdTdHJlYW1saW5lcyhleGlzdGluZ1N0cmVhbWxpbmVzOiBSb2FkR1VJW10pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5leGlzdGluZ1N0cmVhbWxpbmVzID0gZXhpc3RpbmdTdHJlYW1saW5lcztcbiAgICB9XG5cbiAgICBzZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKGNhbGxiYWNrOiAoKSA9PiBhbnkpIHtcbiAgICAgICAgdGhpcy5wcmVHZW5lcmF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgc2V0UG9zdEdlbmVyYXRlQ2FsbGJhY2soY2FsbGJhY2s6ICgpID0+IGFueSkge1xuICAgICAgICB0aGlzLnBvc3RHZW5lcmF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgY2xlYXJTdHJlYW1saW5lcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2VuZXJhdGVSb2FkcyhhbmltYXRlPWZhbHNlKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgICAgIHRoaXMucHJlR2VuZXJhdGVDYWxsYmFjaygpO1xuXG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID0gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gLyAxLjI7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMgPSBuZXcgU3RyZWFtbGluZUdlbmVyYXRvcihcbiAgICAgICAgICAgIHRoaXMuaW50ZWdyYXRvciwgdGhpcy5kb21haW5Db250cm9sbGVyLm9yaWdpbixcbiAgICAgICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMsIE9iamVjdC5hc3NpZ24oe30sdGhpcy5wYXJhbXMpKTtcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSAqIDEuMjtcblxuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5leGlzdGluZ1N0cmVhbWxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmFkZEV4aXN0aW5nU3RyZWFtbGluZXMocy5zdHJlYW1saW5lcykgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xvc2VUZW5zb3JGb2xkZXIoKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLmNyZWF0ZUFsbFN0cmVhbWxpbmVzKGFuaW1hdGUpLnRoZW4oKCkgPT4gdGhpcy5wb3N0R2VuZXJhdGVDYWxsYmFjaygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3RyZWFtbGluZXMgY2hhbmdlc1xuICAgICAqL1xuICAgIHVwZGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFkZERldlBhcmFtc1RvRm9sZGVyKHBhcmFtczogU3RyZWFtbGluZVBhcmFtcywgZm9sZGVyOiBkYXQuR1VJKTogdm9pZCB7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAncGF0aEl0ZXJhdGlvbnMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdzZWVkVHJpZXMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkc3RlcCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2Rsb29rYWhlYWQnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkY2lyY2xlam9pbicpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2pvaW5hbmdsZScpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ3NpbXBsaWZ5VG9sZXJhbmNlJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnY29sbGlkZUVhcmx5Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwYXRoIGl0ZXJhdGlvbnMgc28gdGhhdCBhIHJvYWQgY2FuIGNvdmVyIHRoZSBzY3JlZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFBhdGhJdGVyYXRpb25zKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXggPSAxLjUgKiBNYXRoLm1heCh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy5wYXJhbXMucGF0aEl0ZXJhdGlvbnMgPSBtYXgvdGhpcy5wYXJhbXMuZHN0ZXA7XG4gICAgICAgIFV0aWwudXBkYXRlR3VpKHRoaXMuZ3VpRm9sZGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5pbXBvcnQgVGVuc29yRmllbGQgZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IHtSSzRJbnRlZ3JhdG9yfSBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCB7V2F0ZXJQYXJhbXN9IGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBHcmFwaCBmcm9tICcuLi9pbXBsL2dyYXBoJztcbmltcG9ydCBSb2FkR1VJIGZyb20gJy4vcm9hZF9ndWknO1xuaW1wb3J0IFdhdGVyR1VJIGZyb20gJy4vd2F0ZXJfZ3VpJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBQb2x5Z29uRmluZGVyIGZyb20gJy4uL2ltcGwvcG9seWdvbl9maW5kZXInO1xuaW1wb3J0IHtQb2x5Z29uUGFyYW1zfSBmcm9tICcuLi9pbXBsL3BvbHlnb25fZmluZGVyJztcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IFdhdGVyR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBTdHlsZSBmcm9tICcuL3N0eWxlJztcbmltcG9ydCBDYW52YXNXcmFwcGVyIGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb2Fkc0dVSSB7XG4gICAgcHVibGljIG51bVBhcmtzOiBudW1iZXIgPSAyO1xuICAgIHByaXZhdGUgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBwcml2YXRlIGludGVyc2VjdGlvbnM6IFZlY3RvcltdID0gW107XG4gICAgcHJpdmF0ZSBwYXJrczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHByaXZhdGUgYW5pbWF0ZTogYm9vbGVhbiA9IHRydWU7XG4gICAgcHJpdmF0ZSBhbmltYXRpb25TcGVlZDogbnVtYmVyID0gMzA7XG5cbiAgICBwcml2YXRlIGNvYXN0bGluZTogV2F0ZXJHVUk7XG4gICAgcHJpdmF0ZSBtYWluUm9hZHM6IFJvYWRHVUk7XG4gICAgcHJpdmF0ZSBtYWpvclJvYWRzOiBSb2FkR1VJO1xuICAgIHByaXZhdGUgbWlub3JSb2FkczogUm9hZEdVSTtcbiAgICBwcml2YXRlIGJ1aWxkaW5nczogUG9seWdvbkZpbmRlcjtcblxuICAgIC8vIFBhcmFtc1xuICAgIHByaXZhdGUgY29hc3RsaW5lUGFyYW1zOiBXYXRlclBhcmFtcztcbiAgICBwcml2YXRlIG1haW5QYXJhbXM6IFN0cmVhbWxpbmVQYXJhbXM7XG4gICAgcHJpdmF0ZSBtYWpvclBhcmFtczogU3RyZWFtbGluZVBhcmFtcztcbiAgICBwcml2YXRlIG1pbm9yUGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zID0ge1xuICAgICAgICBkc2VwOiAyMCxcbiAgICAgICAgZHRlc3Q6IDE1LFxuICAgICAgICBkc3RlcDogMSxcbiAgICAgICAgZGxvb2thaGVhZDogNDAsXG4gICAgICAgIGRjaXJjbGVqb2luOiA1LFxuICAgICAgICBqb2luYW5nbGU6IDAuMSwgIC8vIGFwcHJveCAzMGRlZ1xuICAgICAgICBwYXRoSXRlcmF0aW9uczogMTAwMCxcbiAgICAgICAgc2VlZFRyaWVzOiAzMDAsXG4gICAgICAgIHNpbXBsaWZ5VG9sZXJhbmNlOiAwLjUsXG4gICAgICAgIGNvbGxpZGVFYXJseTogMC43LFxuICAgIH07XG5cbiAgICBwcml2YXRlIGJ1aWxkaW5nUGFyYW1zOiBQb2x5Z29uUGFyYW1zID0ge1xuICAgICAgICBtYXhMZW5ndGg6IDIwLFxuICAgICAgICBtaW5BcmVhOiA4MCxcbiAgICAgICAgc2hyaW5rU3BhY2luZzogNCxcbiAgICAgICAgbWF4QXNwZWN0UmF0aW86IDUsXG4gICAgfTtcblxuICAgIHByaXZhdGUgcmVkcmF3OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3VpRm9sZGVyOiBkYXQuR1VJLCB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGQsIHByaXZhdGUgY2xvc2VUZW5zb3JGb2xkZXI6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgZ3VpRm9sZGVyLmFkZCh0aGlzLCAnZ2VuZXJhdGVFdmVyeXRoaW5nJyk7XG4gICAgICAgIGd1aUZvbGRlci5hZGQodGhpcywgJ3NpbXBsZUJlbmNoTWFyaycpO1xuICAgICAgICBjb25zdCBhbmltYXRlQ29udHJvbGxlciA9IGd1aUZvbGRlci5hZGQodGhpcywgJ2FuaW1hdGUnKTtcbiAgICAgICAgZ3VpRm9sZGVyLmFkZCh0aGlzLCAnYW5pbWF0aW9uU3BlZWQnKTtcblxuICAgICAgICBjb25zdCByb2Fkc1BhcmFtcyA9IGd1aUZvbGRlci5hZGRGb2xkZXIoJ1BhcmFtcycpO1xuICAgICAgICByb2Fkc1BhcmFtcy5hZGQodGhpcywgJ251bVBhcmtzJyk7XG5cbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNvYXN0Tm9pc2U6IHtcbiAgICAgICAgICAgICAgICBub2lzZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbm9pc2VTaXplOiAzMCxcbiAgICAgICAgICAgICAgICBub2lzZUFuZ2xlOiAyMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaXZlck5vaXNlOiB7XG4gICAgICAgICAgICAgICAgbm9pc2VFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5vaXNlU2l6ZTogMzAsXG4gICAgICAgICAgICAgICAgbm9pc2VBbmdsZTogMjAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcml2ZXJCYW5rU2l6ZTogMTAsXG4gICAgICAgICAgICByaXZlclNpemU6IDMwLFxuICAgICAgICB9LCB0aGlzLm1pbm9yUGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMucGF0aEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2UgPSAxMDtcblxuICAgICAgICB0aGlzLm1ham9yUGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5taW5vclBhcmFtcyk7XG4gICAgICAgIHRoaXMubWFqb3JQYXJhbXMuZHNlcCA9IDEwMDtcbiAgICAgICAgdGhpcy5tYWpvclBhcmFtcy5kdGVzdCA9IDMwO1xuICAgICAgICB0aGlzLm1ham9yUGFyYW1zLmRsb29rYWhlYWQgPSAyMDA7XG4gICAgICAgIHRoaXMubWFqb3JQYXJhbXMuY29sbGlkZUVhcmx5ID0gMDtcblxuICAgICAgICB0aGlzLm1haW5QYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1pbm9yUGFyYW1zKTtcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zLmRzZXAgPSA0MDA7XG4gICAgICAgIHRoaXMubWFpblBhcmFtcy5kdGVzdCA9IDIwMDtcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zLmRsb29rYWhlYWQgPSA1MDA7XG4gICAgICAgIHRoaXMubWFpblBhcmFtcy5jb2xsaWRlRWFybHkgPSAwO1xuXG4gICAgICAgIGNvbnN0IGludGVncmF0b3IgPSBuZXcgUks0SW50ZWdyYXRvcih0ZW5zb3JGaWVsZCwgdGhpcy5taW5vclBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlZHJhdyA9ICgpID0+IHRoaXMucmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb2FzdGxpbmUgPSBuZXcgV2F0ZXJHVUkodGVuc29yRmllbGQsIHRoaXMuY29hc3RsaW5lUGFyYW1zLCBpbnRlZ3JhdG9yLFxuICAgICAgICAgICAgdGhpcy5ndWlGb2xkZXIsIGNsb3NlVGVuc29yRm9sZGVyLCAnV2F0ZXInLCByZWRyYXcpLmluaXRGb2xkZXIoKTtcbiAgICAgICAgdGhpcy5tYWluUm9hZHMgPSBuZXcgUm9hZEdVSSh0aGlzLm1haW5QYXJhbXMsIGludGVncmF0b3IsIHRoaXMuZ3VpRm9sZGVyLCBjbG9zZVRlbnNvckZvbGRlciwgJ01haW4nLCByZWRyYXcpLmluaXRGb2xkZXIoKTtcbiAgICAgICAgdGhpcy5tYWpvclJvYWRzID0gbmV3IFJvYWRHVUkodGhpcy5tYWpvclBhcmFtcywgaW50ZWdyYXRvciwgdGhpcy5ndWlGb2xkZXIsIGNsb3NlVGVuc29yRm9sZGVyLCAnTWFqb3InLCByZWRyYXcsIHRoaXMuYW5pbWF0ZSkuaW5pdEZvbGRlcigpO1xuICAgICAgICB0aGlzLm1pbm9yUm9hZHMgPSBuZXcgUm9hZEdVSSh0aGlzLm1pbm9yUGFyYW1zLCBpbnRlZ3JhdG9yLCB0aGlzLmd1aUZvbGRlciwgY2xvc2VUZW5zb3JGb2xkZXIsICdNaW5vcicsIHJlZHJhdywgdGhpcy5hbmltYXRlKS5pbml0Rm9sZGVyKCk7XG4gICAgICAgIHRoaXMuYnVpbGRpbmdzID0gbmV3IFBvbHlnb25GaW5kZXIoW10sIHRoaXMuYnVpbGRpbmdQYXJhbXMpO1xuXG4gICAgICAgIGFuaW1hdGVDb250cm9sbGVyLm9uQ2hhbmdlKChiOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuYW5pbWF0ZSA9IGI7XG4gICAgICAgICAgICB0aGlzLm1pbm9yUm9hZHMuYW5pbWF0ZSA9IGI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWlub3JSb2Fkcy5zZXRFeGlzdGluZ1N0cmVhbWxpbmVzKFt0aGlzLmNvYXN0bGluZSwgdGhpcy5tYWluUm9hZHMsIHRoaXMubWFqb3JSb2Fkc10pO1xuICAgICAgICB0aGlzLm1ham9yUm9hZHMuc2V0RXhpc3RpbmdTdHJlYW1saW5lcyhbdGhpcy5jb2FzdGxpbmUsIHRoaXMubWFpblJvYWRzXSk7XG4gICAgICAgIHRoaXMubWFpblJvYWRzLnNldEV4aXN0aW5nU3RyZWFtbGluZXMoW3RoaXMuY29hc3RsaW5lXSk7XG5cbiAgICAgICAgdGhpcy5jb2FzdGxpbmUuc2V0UHJlR2VuZXJhdGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1haW5Sb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgdGhpcy5taW5vclJvYWRzLmNsZWFyU3RyZWFtbGluZXMoKTtcbiAgICAgICAgICAgIHRoaXMucGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmdzLnJlc2V0KCk7XG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5wYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGVuc29yRmllbGQuc2VhID0gW107XG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5yaXZlciA9IFtdO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1haW5Sb2Fkcy5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFqb3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICB0aGlzLm1pbm9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgdGhpcy5wYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MucmVzZXQoKTtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnBhcmtzID0gW107XG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5pZ25vcmVSaXZlciA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWFpblJvYWRzLnNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLmlnbm9yZVJpdmVyID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWFqb3JSb2Fkcy5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWlub3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmtzID0gW107XG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5ncy5yZXNldCgpO1xuICAgICAgICAgICAgdGVuc29yRmllbGQucGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLmlnbm9yZVJpdmVyID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYWpvclJvYWRzLnNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBuZXcgR3JhcGgodGhpcy5tYWpvclJvYWRzLmFsbFN0cmVhbWxpbmVzLmNvbmNhdCh0aGlzLm1haW5Sb2Fkcy5hbGxTdHJlYW1saW5lcyksIHRoaXMubWlub3JQYXJhbXMuZHN0ZXApO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25zID0gZy5pbnRlcnNlY3Rpb25zO1xuXG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFBvbHlnb25GaW5kZXIoZy5ub2RlcywgdGhpcy5idWlsZGluZ1BhcmFtcyk7XG4gICAgICAgICAgICBwLmZpbmRQb2x5Z29ucygpO1xuICAgICAgICAgICAgY29uc3QgcG9seWdvbnMgPSBwLnBvbHlnb25zO1xuXG4gICAgICAgICAgICBpZiAocG9seWdvbnMubGVuZ3RoID4gdGhpcy5udW1QYXJrcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmtJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChwb2x5Z29ucy5sZW5ndGggLSB0aGlzLm51bVBhcmtzKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcmtJbmRleDsgaSA8IHBhcmtJbmRleCArIHRoaXMubnVtUGFya3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmtzLnB1c2gocG9seWdvbnNbaV0pOyAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2YgcG9seWdvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJrcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVuc29yRmllbGQucGFya3MgPSB0aGlzLnBhcmtzO1xuICAgICAgICAgICAgdGVuc29yRmllbGQuaWdub3JlUml2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5taW5vclJvYWRzLnNldFByZUdlbmVyYXRlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MucmVzZXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYnVpbGRpbmdzRm9sZGVyID0gZ3VpRm9sZGVyLmFkZEZvbGRlcignQnVpbGRpbmdzJyk7XG4gICAgICAgIGJ1aWxkaW5nc0ZvbGRlci5hZGQoeydBZGRCdWlsZGluZ3MnOiAoKSA9PiB0aGlzLmFkZEJ1aWxkaW5ncyh0aGlzLmFuaW1hdGUpfSwgJ0FkZEJ1aWxkaW5ncycpO1xuICAgICAgICBidWlsZGluZ3NGb2xkZXIuYWRkKHRoaXMuYnVpbGRpbmdQYXJhbXMsICdtaW5BcmVhJyk7XG4gICAgICAgIGJ1aWxkaW5nc0ZvbGRlci5hZGQodGhpcy5idWlsZGluZ1BhcmFtcywgJ21heEFzcGVjdFJhdGlvJyk7XG4gICAgICAgIGJ1aWxkaW5nc0ZvbGRlci5hZGQodGhpcy5idWlsZGluZ1BhcmFtcywgJ3Nocmlua1NwYWNpbmcnKTtcbiAgICB9XG5cbiAgICBhc3luYyBzaW1wbGVCZW5jaE1hcmsoKSB7XG4gICAgICAgIGxvZy5pbmZvKGBTdGFydGluZyBCZW5jaG1hcmsuLi5gKTtcbiAgICAgICAgY29uc3QgdHJpZXMgPSAxMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZXM7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubWFpblJvYWRzLmdlbmVyYXRlUm9hZHMoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubWFqb3JSb2Fkcy5nZW5lcmF0ZVJvYWRzKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1pbm9yUm9hZHMuZ2VuZXJhdGVSb2FkcygpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRCdWlsZGluZ3MoKTtcbiAgICAgICAgICAgIHN1bSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nLmluZm8oYEdlbmVyYXRlZCAke3RyaWVzfSBjaXRpZXMgd2l0aCBhdmVyYWdlICR7c3VtL3RyaWVzfW1zYCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2VuZXJhdGVFdmVyeXRoaW5nKCkge1xuICAgICAgICB0aGlzLmNvYXN0bGluZS5nZW5lcmF0ZVJvYWRzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMubWFpblJvYWRzLmdlbmVyYXRlUm9hZHMoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5tYWpvclJvYWRzLmdlbmVyYXRlUm9hZHModGhpcy5hbmltYXRlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5taW5vclJvYWRzLmdlbmVyYXRlUm9hZHModGhpcy5hbmltYXRlKTtcbiAgICAgICAgdGhpcy5yZWRyYXcgPSB0cnVlO1xuICAgICAgICBhd2FpdCB0aGlzLmFkZEJ1aWxkaW5ncyh0aGlzLmFuaW1hdGUpO1xuICAgIH1cblxuICAgIGFzeW5jIGFkZEJ1aWxkaW5ncyhhbmltYXRlPWZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGFsbFN0cmVhbWxpbmVzID0gW107XG4gICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5tYWluUm9hZHMuYWxsU3RyZWFtbGluZXMpO1xuICAgICAgICBhbGxTdHJlYW1saW5lcy5wdXNoKC4uLnRoaXMubWFqb3JSb2Fkcy5hbGxTdHJlYW1saW5lcyk7XG4gICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5taW5vclJvYWRzLmFsbFN0cmVhbWxpbmVzKTtcbiAgICAgICAgYWxsU3RyZWFtbGluZXMucHVzaCguLi50aGlzLmNvYXN0bGluZS5zdHJlYW1saW5lc1dpdGhTZWNvbmRhcnlSb2FkKTtcblxuICAgICAgICBjb25zdCBnID0gbmV3IEdyYXBoKGFsbFN0cmVhbWxpbmVzLCB0aGlzLm1pbm9yUGFyYW1zLmRzdGVwLCB0cnVlKTtcblxuICAgICAgICB0aGlzLmJ1aWxkaW5ncyA9IG5ldyBQb2x5Z29uRmluZGVyKGcubm9kZXMsIHRoaXMuYnVpbGRpbmdQYXJhbXMpO1xuICAgICAgICB0aGlzLmJ1aWxkaW5ncy5maW5kUG9seWdvbnMoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5idWlsZGluZ3Muc2hyaW5rKGFuaW1hdGUpO1xuICAgICAgICBhd2FpdCB0aGlzLmJ1aWxkaW5ncy5kaXZpZGUoYW5pbWF0ZSk7XG5cblxuICAgICAgICB0aGlzLnJlZHJhdyA9IHRydWU7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgY29udGludWVVcGRhdGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB3aGlsZSAoY29udGludWVVcGRhdGUgJiYgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCA8IHRoaXMuYW5pbWF0aW9uU3BlZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbm9yQ2hhbmdlZCA9IHRoaXMubWlub3JSb2Fkcy51cGRhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG1ham9yQ2hhbmdlZCA9IHRoaXMubWFqb3JSb2Fkcy51cGRhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG1haW5DaGFuZ2VkID0gdGhpcy5tYWluUm9hZHMudXBkYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBidWlsZGluZ3NDaGFuZ2VkID0gdGhpcy5idWlsZGluZ3MudXBkYXRlKCk7XG4gICAgICAgICAgICBjb250aW51ZVVwZGF0ZSA9IG1pbm9yQ2hhbmdlZCB8fCBtYWpvckNoYW5nZWQgfHwgbWFpbkNoYW5nZWQgfHwgYnVpbGRpbmdzQ2hhbmdlZDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWRyYXcgPSB0aGlzLnJlZHJhdyB8fCBjb250aW51ZVVwZGF0ZTtcbiAgICB9XG5cbiAgICBkcmF3KHN0eWxlOiBTdHlsZSwgZm9yY2VEcmF3PWZhbHNlLCBjdXN0b21DYW52YXM/OiBDYW52YXNXcmFwcGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghc3R5bGUubmVlZHNVcGRhdGUgJiYgIWZvcmNlRHJhdyAmJiAhdGhpcy5yZWRyYXcgJiYgIXRoaXMuZG9tYWluQ29udHJvbGxlci5tb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLm1vdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVkcmF3ID0gZmFsc2U7XG5cbiAgICAgICAgc3R5bGUuc2VhUG9seWdvbiA9IHRoaXMuY29hc3RsaW5lLnNlYVBvbHlnb247XG4gICAgICAgIHN0eWxlLmNvYXN0bGluZSA9IHRoaXMuY29hc3RsaW5lLmNvYXN0bGluZTtcbiAgICAgICAgc3R5bGUucml2ZXIgPSB0aGlzLmNvYXN0bGluZS5yaXZlcjtcbiAgICAgICAgLy8gc3R5bGUucml2ZXJSb2FkcyA9IHRoaXMuY29hc3RsaW5lLnJpdmVyUm9hZHM7XG4gICAgICAgIHN0eWxlLmJ1aWxkaW5ncyA9IHRoaXMuYnVpbGRpbmdzLnBvbHlnb25zLm1hcChsID0+IGwubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSkpO1xuICAgICAgICBzdHlsZS5wYXJrcyA9IHRoaXMucGFya3MubWFwKHAgPT4gcC5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKSk7XG4gICAgICAgIHN0eWxlLm1pbm9yUm9hZHMgPSB0aGlzLm1pbm9yUm9hZHMucm9hZHM7XG4gICAgICAgIHN0eWxlLm1ham9yUm9hZHMgPSB0aGlzLm1ham9yUm9hZHMucm9hZHM7XG4gICAgICAgIHN0eWxlLm1haW5Sb2FkcyA9IHRoaXMubWFpblJvYWRzLnJvYWRzO1xuICAgICAgICBzdHlsZS5jb2FzdGxpbmVSb2FkcyA9IHRoaXMuY29hc3RsaW5lLnJvYWRzO1xuICAgICAgICBzdHlsZS5zZWNvbmRhcnlSaXZlciA9IHRoaXMuY29hc3RsaW5lLnNlY29uZGFyeVJpdmVyO1xuICAgICAgICBzdHlsZS5kcmF3KGN1c3RvbUNhbnZhcyk7XG4gICAgfVxuXG4gICAgcm9hZHNFbXB0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFqb3JSb2Fkcy5yb2Fkc0VtcHR5KClcbiAgICAgICAgICAgICYmIHRoaXMubWlub3JSb2Fkcy5yb2Fkc0VtcHR5KClcbiAgICAgICAgICAgICYmIHRoaXMubWFpblJvYWRzLnJvYWRzRW1wdHkoKVxuICAgICAgICAgICAgJiYgdGhpcy5jb2FzdGxpbmUucm9hZHNFbXB0eSgpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBkYXQgZnJvbSAnZGF0Lmd1aSc7XG5pbXBvcnQgVGVuc29yRmllbGRHVUkgZnJvbSAnLi90ZW5zb3JfZmllbGRfZ3VpJztcbmltcG9ydCB7Tm9pc2VQYXJhbXN9IGZyb20gJy4uL2ltcGwvdGVuc29yX2ZpZWxkJztcbmltcG9ydCBSb2Fkc0dVSSBmcm9tICcuL3JvYWRzX2d1aSc7XG5pbXBvcnQgQ2FudmFzV3JhcHBlciBmcm9tICcuL2NhbnZhc193cmFwcGVyJztcbmltcG9ydCB7RGVmYXVsdENhbnZhc1dyYXBwZXIsIFJvdWdoQ2FudmFzV3JhcHBlcn0gZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBEcmFnQ29udHJvbGxlciBmcm9tICcuL2RyYWdfY29udHJvbGxlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuZXhwb3J0IGludGVyZmFjZSBDb2xvdXJTY2hlbWUge1xuICAgIGJnQ29sb3VyOiBzdHJpbmc7XG4gICAgYmdDb2xvdXJJbj86IHN0cmluZztcbiAgICBidWlsZGluZ0NvbG91cj86IHN0cmluZztcbiAgICBidWlsZGluZ1N0cm9rZT86IHN0cmluZztcbiAgICBzZWFDb2xvdXI6IHN0cmluZztcbiAgICBncmFzc0NvbG91cj86IHN0cmluZztcbiAgICBtaW5vclJvYWRDb2xvdXI6IHN0cmluZztcbiAgICBtaW5vclJvYWRPdXRsaW5lPzogc3RyaW5nO1xuICAgIG1ham9yUm9hZENvbG91cj86IHN0cmluZztcbiAgICBtYWpvclJvYWRPdXRsaW5lPzogc3RyaW5nO1xuICAgIG1haW5Sb2FkQ29sb3VyPzogc3RyaW5nO1xuICAgIG1haW5Sb2FkT3V0bGluZT86IHN0cmluZztcbiAgICBvdXRsaW5lU2l6ZT86IG51bWJlcjtcbiAgICBtaW5vcldpZHRoPzogbnVtYmVyO1xuICAgIG1ham9yV2lkdGg/OiBudW1iZXI7XG4gICAgbWFpbldpZHRoPzogbnVtYmVyO1xuICAgIHpvb21CdWlsZGluZ3M/OiBib29sZWFuO1xuICAgIGZyYW1lQ29sb3VyPzogc3RyaW5nO1xuICAgIGZyYW1lVGV4dENvbG91cj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU3R5bGUge1xuICAgIHByb3RlY3RlZCBjYW52YXM6IENhbnZhc1dyYXBwZXI7XG4gICAgcHJvdGVjdGVkIGRvbWFpbkNvbnRyb2xsZXI6IERvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG4gICAgcHVibGljIGFic3RyYWN0IGNyZWF0ZUNhbnZhc1dyYXBwZXIoYzogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlOiBudW1iZXIsIHJlc2l6ZVRvV2luZG93OiBib29sZWFuKTogQ2FudmFzV3JhcHBlcjtcbiAgICBwdWJsaWMgYWJzdHJhY3QgZHJhdyhjYW52YXM/OiBDYW52YXNXcmFwcGVyKTogdm9pZDtcblxuICAgIC8vIFBvbHlnb25zXG4gICAgcHVibGljIHNlYVBvbHlnb246IFZlY3RvcltdO1xuICAgIHB1YmxpYyBidWlsZGluZ3M6IFZlY3RvcltdW107XG4gICAgcHVibGljIHBhcmtzOiBWZWN0b3JbXVtdO1xuXG4gICAgLy8gUG9seWxpbmVzXG4gICAgcHVibGljIGNvYXN0bGluZTogVmVjdG9yW107XG4gICAgcHVibGljIHJpdmVyOiBWZWN0b3JbXTtcbiAgICBwdWJsaWMgc2Vjb25kYXJ5Uml2ZXI6IFZlY3RvcltdO1xuICAgIHB1YmxpYyBtaW5vclJvYWRzOiBWZWN0b3JbXVtdO1xuICAgIHB1YmxpYyBtYWpvclJvYWRzOiBWZWN0b3JbXVtdO1xuICAgIHB1YmxpYyBtYWluUm9hZHM6IFZlY3RvcltdW107XG4gICAgcHVibGljIGNvYXN0bGluZVJvYWRzOiBWZWN0b3JbXVtdO1xuICAgIHB1YmxpYyBzaG93RnJhbWU6IGJvb2xlYW47XG5cbiAgICBwdWJsaWMgc2V0IGNhbnZhc1NjYWxlKHNjYWxlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2FudmFzU2NhbGUgPSBzY2FsZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG5lZWRzVXBkYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMubmVlZHNVcGRhdGU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBuZWVkc1VwZGF0ZShuOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLm5lZWRzVXBkYXRlID0gbjtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZWZhdWx0U3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgY29uc3RydWN0b3IoYzogSFRNTENhbnZhc0VsZW1lbnQsIHByaXZhdGUgY29sb3VyU2NoZW1lOiBDb2xvdXJTY2hlbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBEZWZhdWx0IGNhc2NhZGVcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuYmdDb2xvdXJJbikgY29sb3VyU2NoZW1lLmJnQ29sb3VySW4gPSBjb2xvdXJTY2hlbWUuYmdDb2xvdXI7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmJ1aWxkaW5nQ29sb3VyKSBjb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXIgPSBjb2xvdXJTY2hlbWUuYmdDb2xvdXI7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlKSBjb2xvdXJTY2hlbWUuYnVpbGRpbmdTdHJva2UgPSBjb2xvdXJTY2hlbWUuYmdDb2xvdXI7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmdyYXNzQ29sb3VyKSBjb2xvdXJTY2hlbWUuZ3Jhc3NDb2xvdXIgPSBjb2xvdXJTY2hlbWUuYmdDb2xvdXI7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1pbm9yUm9hZE91dGxpbmUpIGNvbG91clNjaGVtZS5taW5vclJvYWRPdXRsaW5lID0gY29sb3VyU2NoZW1lLm1pbm9yUm9hZENvbG91cjtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWFqb3JSb2FkQ29sb3VyKSBjb2xvdXJTY2hlbWUubWFqb3JSb2FkQ29sb3VyID0gY29sb3VyU2NoZW1lLm1pbm9yUm9hZENvbG91cjtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWFqb3JSb2FkT3V0bGluZSkgY29sb3VyU2NoZW1lLm1ham9yUm9hZE91dGxpbmUgPSBjb2xvdXJTY2hlbWUubWlub3JSb2FkT3V0bGluZTtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWFpblJvYWRDb2xvdXIpIGNvbG91clNjaGVtZS5tYWluUm9hZENvbG91ciA9IGNvbG91clNjaGVtZS5tYWpvclJvYWRDb2xvdXI7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1haW5Sb2FkT3V0bGluZSkgY29sb3VyU2NoZW1lLm1haW5Sb2FkT3V0bGluZSA9IGNvbG91clNjaGVtZS5tYWpvclJvYWRPdXRsaW5lO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5vdXRsaW5lU2l6ZSkgY29sb3VyU2NoZW1lLm91dGxpbmVTaXplID0gMTtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncykgY29sb3VyU2NoZW1lLnpvb21CdWlsZGluZ3MgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWlub3JXaWR0aCkgY29sb3VyU2NoZW1lLm1pbm9yV2lkdGggPSAyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWpvcldpZHRoKSBjb2xvdXJTY2hlbWUubWFqb3JXaWR0aCA9IDQ7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1haW5XaWR0aCkgY29sb3VyU2NoZW1lLm1haW5XaWR0aCA9IDU7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1haW5XaWR0aCkgY29sb3VyU2NoZW1lLm1haW5XaWR0aCA9IDU7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmZyYW1lQ29sb3VyKSBjb2xvdXJTY2hlbWUuZnJhbWVDb2xvdXIgPSBjb2xvdXJTY2hlbWUuYmdDb2xvdXI7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmZyYW1lVGV4dENvbG91cikgY29sb3VyU2NoZW1lLmZyYW1lVGV4dENvbG91ciA9IGNvbG91clNjaGVtZS5taW5vclJvYWRPdXRsaW5lO1xuXG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXNXcmFwcGVyKGMsIDEsIHRydWUpO1xuICAgIH1cblxuICAgIHNldCB6b29tQnVpbGRpbmdzKGI6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5jb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyA9IGI7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUNhbnZhc1dyYXBwZXIoYzogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpOiBDYW52YXNXcmFwcGVyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0Q2FudmFzV3JhcHBlcihjLCBzY2FsZSwgcmVzaXplVG9XaW5kb3cpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KGNhbnZhcz10aGlzLmNhbnZhcyBhcyBEZWZhdWx0Q2FudmFzV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBsZXQgYmdDb2xvdXI7XG4gICAgICAgIGlmICh0aGlzLmNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzKSB7XG4gICAgICAgICAgICBiZ0NvbG91ciA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID49IDIgPyB0aGlzLmNvbG91clNjaGVtZS5iZ0NvbG91ciA6IHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VySW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZ0NvbG91ciA9IHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUoYmdDb2xvdXIpO1xuICAgICAgICBjYW52YXMuY2xlYXJDYW52YXMoKTtcblxuICAgICAgICAvLyBTZWFcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5zZWFDb2xvdXIpO1xuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgwLjEpO1xuICAgICAgICBjYW52YXMuZHJhd1BvbHlnb24odGhpcy5zZWFQb2x5Z29uKTtcblxuICAgICAgICAvLyBDb2FzdGxpbmVcbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKGJnQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgzMCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5bGluZSh0aGlzLmNvYXN0bGluZSk7XG5cbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgxKTtcbiAgICAgICAgLy8gQnVpbGRpbmdzXG4gICAgICAgIGlmICghdGhpcy5jb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyB8fCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA+PSAyKSB7XG4gICAgICAgICAgICBjYW52YXMuc2V0RmlsbFN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nQ29sb3VyKTtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ1N0cm9rZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5idWlsZGluZ3MpIGNhbnZhcy5kcmF3UG9seWdvbihiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcmtzXG4gICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZ3Jhc3NDb2xvdXIpO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wYXJrcykgY2FudmFzLmRyYXdQb2x5Z29uKHApO1xuXG4gICAgICAgIC8vIFJpdmVyXG4gICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLnNlYUNvbG91cik7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgoMC4xKTtcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHRoaXMucml2ZXIpO1xuXG4gICAgICAgIC8vIFJvYWQgb3V0bGluZVxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUubWlub3JSb2FkT3V0bGluZSk7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUub3V0bGluZVNpemUgKyB0aGlzLmNvbG91clNjaGVtZS5taW5vcldpZHRoICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5taW5vclJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5tYWpvclJvYWRPdXRsaW5lKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5vdXRsaW5lU2l6ZSArIHRoaXMuY29sb3VyU2NoZW1lLm1ham9yV2lkdGggKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLm1ham9yUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5zZWNvbmRhcnlSaXZlcik7XG5cbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLm1haW5Sb2FkT3V0bGluZSk7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUub3V0bGluZVNpemUgKyB0aGlzLmNvbG91clNjaGVtZS5tYWluV2lkdGggKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLm1haW5Sb2FkcykgY2FudmFzLmRyYXdQb2x5bGluZShzKTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuY29hc3RsaW5lUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XG5cbiAgICAgICAgLy8gUm9hZCBpbmxpbmVcbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLm1pbm9yUm9hZENvbG91cik7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUubWlub3JXaWR0aCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMubWlub3JSb2FkcykgY2FudmFzLmRyYXdQb2x5bGluZShzKTtcblxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUubWFqb3JSb2FkQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5tYWpvcldpZHRoICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5tYWpvclJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xuICAgICAgICBjYW52YXMuZHJhd1BvbHlsaW5lKHRoaXMuc2Vjb25kYXJ5Uml2ZXIpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5tYWluUm9hZENvbG91cik7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUubWFpbldpZHRoICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5tYWluUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLmNvYXN0bGluZVJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xuXG4gICAgICAgIGlmICh0aGlzLnNob3dGcmFtZSkge1xuICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5mcmFtZUNvbG91cik7XG4gICAgICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZnJhbWVDb2xvdXIpO1xuICAgICAgICAgICAgY2FudmFzLmRyYXdGcmFtZSgzMCwgMzAsIDMwLCA4MCk7XG5cbiAgICAgICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZnJhbWVUZXh0Q29sb3VyKTtcbiAgICAgICAgICAgIGNhbnZhcy5kcmF3Q2l0eU5hbWUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJvdWdoU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgY29uc3RydWN0b3IoYzogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhc1dyYXBwZXIoYywgMSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUNhbnZhc1dyYXBwZXIoYzogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpOiBDYW52YXNXcmFwcGVyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VnaENhbnZhc1dyYXBwZXIoYywgc2NhbGUsIHJlc2l6ZVRvV2luZG93KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZHJhdyhjYW52YXM9dGhpcy5jYW52YXMgYXMgUm91Z2hDYW52YXNXcmFwcGVyKTogdm9pZCB7XG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHJvdWdobmVzczogMSxcbiAgICAgICAgICAgIGJvd2luZzogMSxcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICBmaWxsU3R5bGU6ICdzb2xpZCcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIGZpbGw6IFwicmdiKDI0MiwyMzYsMjIyKVwiLFxuICAgICAgICAgICAgcm91Z2huZXNzOiAxLFxuICAgICAgICAgICAgYm93aW5nOiAxLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiAnc29saWQnLFxuICAgICAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FudmFzLmNsZWFyQ2FudmFzKCk7XG5cbiAgICAgICAgLy8gU2VhXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHJvdWdobmVzczogMCxcbiAgICAgICAgICAgIGZpbGxXZWlnaHQ6IDEsXG4gICAgICAgICAgICBmaWxsOiBcIiNkYmQyYmRcIixcbiAgICAgICAgICAgIGZpbGxTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHRoaXMuc2VhUG9seWdvbik7XG5cbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgc3Ryb2tlOiBcInJnYigyNDIsMjM2LDIyMilcIixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAzMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5jb2FzdGxpbmUpO1xuXG4gICAgICAgIC8vIEJ1aWxkaW5nc1xuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICByb3VnaG5lc3M6IDEuMixcbiAgICAgICAgICAgIHN0cm9rZTogJyMzMzMzMzMnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgICBmaWxsOiAnJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5idWlsZGluZ3MuZm9yRWFjaChiID0+IGNhbnZhcy5kcmF3UG9seWdvbihiKSk7XG5cbiAgICAgICAgLy8gUGFya3NcbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgZmlsbDogXCJyZ2IoMjQyLDIzNiwyMjIpXCIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcmtzLmZvckVhY2gocCA9PiBjYW52YXMuZHJhd1BvbHlnb24ocCkpO1xuXG4gICAgICAgIC8vIFJvYWQgaW5saW5lXG4gICAgICAgIFxuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBzdHJva2U6ICcjNjY2NjY2JyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1pbm9yUm9hZHMuZm9yRWFjaChzID0+IGNhbnZhcy5kcmF3UG9seWxpbmUocykpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzQ0NDQ0NCcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWFqb3JSb2Fkcy5mb3JFYWNoKHMgPT4gY2FudmFzLmRyYXdQb2x5bGluZShzKSk7XG5cbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDMsXG4gICAgICAgICAgICBzdHJva2U6ICcjMjIyMjIyJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYWluUm9hZHMuZm9yRWFjaChzID0+IGNhbnZhcy5kcmF3UG9seWxpbmUocykpO1xuICAgICAgICB0aGlzLmNvYXN0bGluZVJvYWRzLmZvckVhY2gocyA9PiBjYW52YXMuZHJhd1BvbHlsaW5lKHMpKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHtEZWZhdWx0Q2FudmFzV3JhcHBlcn0gZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBEcmFnQ29udHJvbGxlciBmcm9tICcuL2RyYWdfY29udHJvbGxlcic7XG5pbXBvcnQgVGVuc29yRmllbGQgZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IHtOb2lzZVBhcmFtc30gZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IHtCYXNpc0ZpZWxkfSBmcm9tICcuLi9pbXBsL2Jhc2lzX2ZpZWxkJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW5zb3JGaWVsZEdVSSBleHRlbmRzIFRlbnNvckZpZWxkIHtcbiAgICBwcml2YXRlIFRFTlNPUl9MSU5FX0RJQU1FVEVSID0gMjA7XG4gICAgcHJpdmF0ZSBURU5TT1JfU1BBV05fU0NBTEUgPSAwLjc7ICAvLyBIb3cgbXVjaCB0byBzaHJpbmsgd29ybGREaW1lbnNpb25zIHRvIGZpbmQgc3Bhd24gcG9pbnRcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGd1aUZvbGRlcjogZGF0LkdVSSwgcHJpdmF0ZSBkcmFnQ29udHJvbGxlcjogRHJhZ0NvbnRyb2xsZXIsXG4gICAgICAgIHB1YmxpYyBkcmF3Q2VudHJlOiBib29sZWFuLCBub2lzZVBhcmFtczogTm9pc2VQYXJhbXMpIHtcbiAgICAgICAgc3VwZXIobm9pc2VQYXJhbXMpO1xuICAgICAgICAvLyBGb3IgY3VzdG9tIG5hbWluZyBvZiBndWkgYnV0dG9uc1xuICAgICAgICBjb25zdCB0ZW5zb3JGaWVsZEd1aU9iaiA9IHtcbiAgICAgICAgICAgIHJlc2V0OiAoKTogdm9pZCA9PiB0aGlzLnJlc2V0KCksXG4gICAgICAgICAgICBzZXRSZWNvbW1lbmRlZDogKCk6IHZvaWQgPT4gdGhpcy5zZXRSZWNvbW1lbmRlZCgpLFxuICAgICAgICAgICAgYWRkUmFkaWFsOiAoKTogdm9pZCA9PiB0aGlzLmFkZFJhZGlhbFJhbmRvbSgpLFxuICAgICAgICAgICAgYWRkR3JpZDogKCk6IHZvaWQgPT4gdGhpcy5hZGRHcmlkUmFuZG9tKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ndWlGb2xkZXIuYWRkKHRlbnNvckZpZWxkR3VpT2JqLCAncmVzZXQnKTtcbiAgICAgICAgdGhpcy5ndWlGb2xkZXIuYWRkKHRlbnNvckZpZWxkR3VpT2JqLCAnc2V0UmVjb21tZW5kZWQnKTtcbiAgICAgICAgdGhpcy5ndWlGb2xkZXIuYWRkKHRlbnNvckZpZWxkR3VpT2JqLCAnYWRkUmFkaWFsJyk7XG4gICAgICAgIHRoaXMuZ3VpRm9sZGVyLmFkZCh0ZW5zb3JGaWVsZEd1aU9iaiwgJ2FkZEdyaWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA0IEdyaWRzLCBvbmUgcmFkaWFsXG4gICAgICovXG4gICAgc2V0UmVjb21tZW5kZWQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMubXVsdGlwbHlTY2FsYXIodGhpcy5URU5TT1JfU1BBV05fU0NBTEUpO1xuICAgICAgICBjb25zdCBuZXdPcmlnaW4gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zXG4gICAgICAgICAgICAubXVsdGlwbHlTY2FsYXIoKDEgLSB0aGlzLlRFTlNPUl9TUEFXTl9TQ0FMRSkgLyAyKVxuICAgICAgICAgICAgLmFkZCh0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luKTtcbiAgICAgICAgdGhpcy5hZGRHcmlkQXRMb2NhdGlvbihuZXdPcmlnaW4pO1xuICAgICAgICB0aGlzLmFkZEdyaWRBdExvY2F0aW9uKG5ld09yaWdpbi5jbG9uZSgpLmFkZChzaXplKSk7XG4gICAgICAgIHRoaXMuYWRkR3JpZEF0TG9jYXRpb24obmV3T3JpZ2luLmNsb25lKCkuYWRkKG5ldyBWZWN0b3Ioc2l6ZS54LCAwKSkpO1xuICAgICAgICB0aGlzLmFkZEdyaWRBdExvY2F0aW9uKG5ld09yaWdpbi5jbG9uZSgpLmFkZChuZXcgVmVjdG9yKDAsIHNpemUueSkpKTtcbiAgICAgICAgdGhpcy5hZGRSYWRpYWxSYW5kb20oKTtcbiAgICB9XG5cbiAgICBhZGRSYWRpYWxSYW5kb20oKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucy54O1xuICAgICAgICB0aGlzLmFkZFJhZGlhbCh0aGlzLnJhbmRvbUxvY2F0aW9uKCksXG4gICAgICAgICAgICBVdGlsLnJhbmRvbVJhbmdlKHdpZHRoLzEwLCB3aWR0aC81KSwgIC8vIFNpemVcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2UoNTApKTsgIC8vIERlY2F5XG4gICAgfVxuXG4gICAgYWRkR3JpZFJhbmRvbSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hZGRHcmlkQXRMb2NhdGlvbih0aGlzLnJhbmRvbUxvY2F0aW9uKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkR3JpZEF0TG9jYXRpb24obG9jYXRpb246IFZlY3Rvcik6IHZvaWQge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMueDtcbiAgICAgICAgdGhpcy5hZGRHcmlkKGxvY2F0aW9uLFxuICAgICAgICAgICAgVXRpbC5yYW5kb21SYW5nZSh3aWR0aC80LCB3aWR0aCksICAvLyBTaXplXG4gICAgICAgICAgICBVdGlsLnJhbmRvbVJhbmdlKDUwKSwgIC8vIERlY2F5XG4gICAgICAgICAgICBVdGlsLnJhbmRvbVJhbmdlKE1hdGguUEkvMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdvcmxkLXNwYWNlIHJhbmRvbSBsb2NhdGlvbiBmb3IgdGVuc29yIGZpZWxkIHNwYXduXG4gICAgICogU2FtcGxlZCBmcm9tIG1pZGRsZSBvZiBzY3JlZW4gKHNocnVuayByZWN0YW5nbGUpXG4gICAgICovXG4gICAgcHJpdmF0ZSByYW5kb21Mb2NhdGlvbigpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucy5tdWx0aXBseVNjYWxhcih0aGlzLlRFTlNPUl9TUEFXTl9TQ0FMRSk7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gbmV3IFZlY3RvcihNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKS5tdWx0aXBseShzaXplKTtcbiAgICAgICAgY29uc3QgbmV3T3JpZ2luID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucy5tdWx0aXBseVNjYWxhcigoMSAtIHRoaXMuVEVOU09SX1NQQVdOX1NDQUxFKSAvIDIpO1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uYWRkKHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4pLmFkZChuZXdPcmlnaW4pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q3Jvc3NMb2NhdGlvbnMoKTogVmVjdG9yW10ge1xuICAgICAgICAvLyBHZXRzIGdyaWQgb2YgcG9pbnRzIGZvciB2ZWN0b3IgZmllbGQgdmlzIGluIHdvcmxkIHNwYWNlXG4gICAgICAgIGNvbnN0IGRpYW1ldGVyID0gdGhpcy5URU5TT1JfTElORV9ESUFNRVRFUiAvIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tO1xuICAgICAgICBjb25zdCB3b3JsZERpbWVuc2lvbnMgPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zO1xuICAgICAgICBjb25zdCBuSG9yID0gTWF0aC5jZWlsKHdvcmxkRGltZW5zaW9ucy54IC8gZGlhbWV0ZXIpICsgMTsgLy8gUHJldmVudCBwb3AtaW5cbiAgICAgICAgY29uc3QgblZlciA9IE1hdGguY2VpbCh3b3JsZERpbWVuc2lvbnMueSAvIGRpYW1ldGVyKSArIDE7XG4gICAgICAgIGNvbnN0IG9yaWdpblggPSBkaWFtZXRlciAqIE1hdGguZmxvb3IodGhpcy5kb21haW5Db250cm9sbGVyLm9yaWdpbi54IC8gZGlhbWV0ZXIpO1xuICAgICAgICBjb25zdCBvcmlnaW5ZID0gZGlhbWV0ZXIgKiBNYXRoLmZsb29yKHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4ueSAvIGRpYW1ldGVyKTtcblxuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPD0gbkhvcjsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8PSBuVmVyOyB5KyspIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChuZXcgVmVjdG9yKG9yaWdpblggKyAoeCAqIGRpYW1ldGVyKSwgb3JpZ2luWSArICh5ICogZGlhbWV0ZXIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGVuc29yTGluZShwb2ludDogVmVjdG9yLCB0ZW5zb3JWOiBWZWN0b3IpOiBWZWN0b3JbXSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbihwb2ludC5jbG9uZSgpKTtcblxuICAgICAgICBjb25zdCBkaWZmID0gdGVuc29yVi5tdWx0aXBseVNjYWxhcih0aGlzLlRFTlNPUl9MSU5FX0RJQU1FVEVSIC8gMik7ICAvLyBBc3N1bWVzIG5vcm1hbGlzZWRcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0cmFuc2Zvcm1lZFBvaW50LmNsb25lKCkuc3ViKGRpZmYpO1xuICAgICAgICBjb25zdCBlbmQgPSB0cmFuc2Zvcm1lZFBvaW50LmNsb25lKCkuYWRkKGRpZmYpO1xuICAgICAgICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xuICAgIH1cblxuICAgIGRyYXcoY2FudmFzOiBEZWZhdWx0Q2FudmFzV3JhcHBlcik6IHZvaWQge1xuICAgICAgICAvLyBEcmF3IHRlbnNvciBmaWVsZFxuICAgICAgICBjYW52YXMuc2V0RmlsbFN0eWxlKCdibGFjaycpO1xuICAgICAgICBjYW52YXMuY2xlYXJDYW52YXMoKTtcblxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUoJ3doaXRlJyk7XG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgoMSk7XG4gICAgICAgIGNvbnN0IHRlbnNvclBvaW50cyA9IHRoaXMuZ2V0Q3Jvc3NMb2NhdGlvbnMoKTtcbiAgICAgICAgdGVuc29yUG9pbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcy5zYW1wbGVQb2ludChwKTtcbiAgICAgICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5nZXRUZW5zb3JMaW5lKHAsIHQuZ2V0TWFqb3IoKSkpO1xuICAgICAgICAgICAgY2FudmFzLmRyYXdQb2x5bGluZSh0aGlzLmdldFRlbnNvckxpbmUocCwgdC5nZXRNaW5vcigpKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERyYXcgY2VudHJlIHBvaW50cyBvZiBmaWVsZHNcbiAgICAgICAgaWYgKHRoaXMuZHJhd0NlbnRyZSkge1xuICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSgncmVkJyk7XG4gICAgICAgICAgICB0aGlzLmdldENlbnRyZVBvaW50cygpLmZvckVhY2godiA9PlxuICAgICAgICAgICAgICAgIGNhbnZhcy5kcmF3U3F1YXJlKHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYpLCA3KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYWRkRmllbGQoZmllbGQ6IEJhc2lzRmllbGQpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuYWRkRmllbGQoZmllbGQpO1xuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmd1aUZvbGRlci5hZGRGb2xkZXIoYCR7ZmllbGQuRk9MREVSX05BTUV9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGdW5jdGlvbiB0byBkZXJlZ2lzdGVyIGZyb20gZHJhZyBjb250cm9sbGVyXG4gICAgICAgIGNvbnN0IGRlcmVnaXN0ZXJEcmFnID0gdGhpcy5kcmFnQ29udHJvbGxlci5yZWdpc3RlcihcbiAgICAgICAgICAgICgpID0+IGZpZWxkLmNlbnRyZSwgZmllbGQuZHJhZ01vdmVMaXN0ZW5lci5iaW5kKGZpZWxkKSk7XG4gICAgICAgIGNvbnN0IHJlbW92ZUZpZWxkT2JqID0ge3JlbW92ZTogKCk6IHZvaWQgPT4gdGhpcy5yZW1vdmVGaWVsZEdVSS5iaW5kKHRoaXMpKGZpZWxkLCBmb2xkZXIsIGRlcmVnaXN0ZXJEcmFnKX07XG4gICAgICAgIFxuICAgICAgICAvLyBHaXZlIGRhdCBndWkgcmVtb3ZlRmllbGQgYnV0dG9uXG4gICAgICAgIGZvbGRlci5hZGQocmVtb3ZlRmllbGRPYmosICdyZW1vdmUnKTtcbiAgICAgICAgZmllbGQuc2V0R3VpKGZvbGRlcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW1vdmVGaWVsZEdVSShmaWVsZDogQmFzaXNGaWVsZCwgZm9sZGVyOiBkYXQuR1VJLCBkZXJlZ2lzdGVyRHJhZzogKCgpID0+IHZvaWQpKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnJlbW92ZUZpZWxkKGZpZWxkKTtcbiAgICAgICAgdGhpcy5ndWlGb2xkZXIucmVtb3ZlRm9sZGVyKGZvbGRlcik7XG4gICAgICAgIC8vIERlcmVnaXN0ZXIgZnJvbSBkcmFnIGNvbnRyb2xsZXJcbiAgICAgICAgZGVyZWdpc3RlckRyYWcoKTtcbiAgICB9XG5cbiAgICByZXNldCgpOiB2b2lkIHtcbiAgICAgICAgLy8gVE9ETyBraW5kIG9mIGhhY2t5IC0gY2FsbGluZyByZW1vdmUgY2FsbGJhY2tzIGZyb20gZ3VpIG9iamVjdCwgc2hvdWxkIHN0b3JlIGNhbGxiYWNrc1xuICAgICAgICAvLyBpbiBhZGRmaWVsZCBhbmQgY2FsbCB0aGVtIChyZXF1aXJlcyBtYWtpbmcgc3VyZSB0aGV5J3JlIGlkZW1wb3RlbnQpXG4gICAgICAgIGZvciAoY29uc3QgZmllbGRGb2xkZXJOYW1lIGluIHRoaXMuZ3VpRm9sZGVyLl9fZm9sZGVycykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRGb2xkZXIgPSB0aGlzLmd1aUZvbGRlci5fX2ZvbGRlcnNbZmllbGRGb2xkZXJOYW1lXTtcbiAgICAgICAgICAgIChmaWVsZEZvbGRlci5fX2NvbnRyb2xsZXJzWzBdIGFzIGFueSkuaW5pdGlhbFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5yZXNldCgpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgQ2FudmFzV3JhcHBlciBmcm9tICcuL2NhbnZhc193cmFwcGVyJztcbmltcG9ydCBEb21haW5Db250cm9sbGVyIGZyb20gJy4vZG9tYWluX2NvbnRyb2xsZXInO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgRmllbGRJbnRlZ3JhdG9yIGZyb20gJy4uL2ltcGwvaW50ZWdyYXRvcic7XG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IHtXYXRlclBhcmFtc30gZnJvbSAnLi4vaW1wbC93YXRlcl9nZW5lcmF0b3InO1xuaW1wb3J0IFdhdGVyR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBQb2x5Z29uRmluZGVyIGZyb20gJy4uL2ltcGwvcG9seWdvbl9maW5kZXInO1xuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4uL2ltcGwvcG9seWdvbl91dGlsJztcbmltcG9ydCBSb2FkR1VJIGZyb20gJy4vcm9hZF9ndWknO1xuaW1wb3J0IHtOb2lzZVBhcmFtc30gZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IFRlbnNvckZpZWxkIGZyb20gJy4uL2ltcGwvdGVuc29yX2ZpZWxkJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2F0ZXJHVUkgZXh0ZW5kcyBSb2FkR1VJIHtcbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZXM6IFdhdGVyR2VuZXJhdG9yO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGQsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmFtczogV2F0ZXJQYXJhbXMsXG4gICAgICAgICAgICAgICAgaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxuICAgICAgICAgICAgICAgIGd1aUZvbGRlcjogZGF0LkdVSSxcbiAgICAgICAgICAgICAgICBjbG9zZVRlbnNvckZvbGRlcjogKCkgPT4gdm9pZCxcbiAgICAgICAgICAgICAgICBmb2xkZXJOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVkcmF3OiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcywgaW50ZWdyYXRvciwgZ3VpRm9sZGVyLCBjbG9zZVRlbnNvckZvbGRlciwgZm9sZGVyTmFtZSwgcmVkcmF3KTtcblxuICAgIH1cblxuICAgIGluaXRGb2xkZXIoKTogV2F0ZXJHVUkge1xuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmd1aUZvbGRlci5hZGRGb2xkZXIodGhpcy5mb2xkZXJOYW1lKTtcbiAgICAgICAgZm9sZGVyLm9wZW4oKTtcbiAgICAgICAgZm9sZGVyLmFkZCh7R2VuZXJhdGU6ICgpID0+IHRoaXMuZ2VuZXJhdGVSb2FkcygpfSwgJ0dlbmVyYXRlJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjb2FzdFBhcmFtc0ZvbGRlciA9IGZvbGRlci5hZGRGb2xkZXIoJ0NvYXN0UGFyYW1zJyk7XG4gICAgICAgIGNvYXN0UGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VFbmFibGVkJyk7XG4gICAgICAgIGNvYXN0UGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VTaXplJyk7XG4gICAgICAgIGNvYXN0UGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VBbmdsZScpO1xuICAgICAgICBjb25zdCByaXZlclBhcmFtc0ZvbGRlciA9IGZvbGRlci5hZGRGb2xkZXIoJ1JpdmVyUGFyYW1zJyk7XG4gICAgICAgIHJpdmVyUGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VFbmFibGVkJyk7XG4gICAgICAgIHJpdmVyUGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VTaXplJyk7XG4gICAgICAgIHJpdmVyUGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VBbmdsZScpO1xuICAgICAgICBcbiAgICAgICAgZm9sZGVyLmFkZCh0aGlzLnBhcmFtcywgJ3NpbXBsaWZ5VG9sZXJhbmNlJyk7XG4gICAgICAgIGNvbnN0IGRldlBhcmFtc0ZvbGRlciA9IGZvbGRlci5hZGRGb2xkZXIoJ0RldicpO1xuICAgICAgICB0aGlzLmFkZERldlBhcmFtc1RvRm9sZGVyKHRoaXMucGFyYW1zLCBkZXZQYXJhbXNGb2xkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZW5lcmF0ZVJvYWRzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLnByZUdlbmVyYXRlQ2FsbGJhY2soKTtcblxuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tIC8gMS4yO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzID0gbmV3IFdhdGVyR2VuZXJhdG9yKFxuICAgICAgICAgICAgdGhpcy5pbnRlZ3JhdG9yLCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucyxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sdGhpcy5wYXJhbXMpLCB0aGlzLnRlbnNvckZpZWxkKTtcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSAqIDEuMjtcblxuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmNyZWF0ZUNvYXN0KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMuY3JlYXRlUml2ZXIoKTtcbiAgICAgICBcbiAgICAgICAgdGhpcy5jbG9zZVRlbnNvckZvbGRlcigpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB0aGlzLnBvc3RHZW5lcmF0ZUNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHJlc29sdmUoKSk7XG4gICAgfVxuXG4gICAgZ2V0IHN0cmVhbWxpbmVzV2l0aFNlY29uZGFyeVJvYWQoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIGNvbnN0IHdpdGhTZWNvbmRhcnkgPSB0aGlzLnN0cmVhbWxpbmVzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnNsaWNlKCk7XG4gICAgICAgIHdpdGhTZWNvbmRhcnkucHVzaCh0aGlzLnN0cmVhbWxpbmVzLnJpdmVyU2Vjb25kYXJ5Um9hZCk7XG4gICAgICAgIHJldHVybiB3aXRoU2Vjb25kYXJ5O1xuICAgIH1cblxuICAgIGdldCByaXZlcigpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLnJpdmVyUG9seWdvbi5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKTtcbiAgICB9XG5cbiAgICBnZXQgc2Vjb25kYXJ5Uml2ZXIoKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5yaXZlclNlY29uZGFyeVJvYWQubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSk7O1xuICAgIH1cblxuICAgIGdldCBjb2FzdGxpbmUoKTogVmVjdG9yW10ge1xuICAgICAgICAvLyBVc2UgdW5zaW1wbGlmaWVkIG5vaXN5IHN0cmVhbWxpbmUgYXMgY29hc3RsaW5lXG4gICAgICAgIC8vIFZpc3VhbCBvbmx5LCBubyByb2FkIGxvZ2ljIHBlcmZvcm1lZCB1c2luZyB0aGlzXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLmNvYXN0bGluZS5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKTtcbiAgICB9XG5cbiAgICBnZXQgc2VhUG9seWdvbigpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLnNlYVBvbHlnb24ubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFkZERldlBhcmFtc1RvRm9sZGVyKHBhcmFtczogU3RyZWFtbGluZVBhcmFtcywgZm9sZGVyOiBkYXQuR1VJKTogdm9pZCB7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnZHNlcCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2R0ZXN0Jyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAncGF0aEl0ZXJhdGlvbnMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdzZWVkVHJpZXMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkc3RlcCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2Rsb29rYWhlYWQnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkY2lyY2xlam9pbicpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2pvaW5hbmdsZScpO1xuICAgIH1cbiAgICBcbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgUmFuZG9tUmFuZ2Uge1xuICAgIG1pbj86IG51bWJlcixcbiAgICBtYXg6IG51bWJlcixcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXRpbCB7XG4gICAgLy8gTXVzdCBtYXRjaCBzdHlsZS5jc3NcbiAgICBzdGF0aWMgcmVhZG9ubHkgQ0FOVkFTX0lEID0gJ21hcC1jYW52YXMnO1xuICAgIHN0YXRpYyByZWFkb25seSBJTUdfQ0FOVkFTX0lEID0gJ2ltZy1jYW52YXMnO1xuXG4gICAgc3RhdGljIHVwZGF0ZUd1aShndWk6IGRhdC5HVUkpOiB2b2lkIHtcbiAgICAgICAgaWYgKGd1aS5fX2NvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICBndWkuX19jb250cm9sbGVycy5mb3JFYWNoKGMgPT4gYy51cGRhdGVEaXNwbGF5KCkpOyAgICBcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3VpLl9fZm9sZGVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgZm9sZGVyTmFtZSBpbiBndWkuX19mb2xkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVHdWkoZ3VpLl9fZm9sZGVyc1tmb2xkZXJOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlQWxsRm9sZGVycyhndWk6IGRhdC5HVUkpIHtcbiAgICAgICAgaWYgKGd1aS5fX2ZvbGRlcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGZvbGRlck5hbWUgaW4gZ3VpLl9fZm9sZGVycykge1xuICAgICAgICAgICAgICAgIGd1aS5yZW1vdmVGb2xkZXIoZ3VpLl9fZm9sZGVyc1tmb2xkZXJOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmFuZG9tUmFuZ2UobWF4OiBudW1iZXIsIG1pbj0wKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB4OiBudW1iZXIsIHB1YmxpYyB5OiBudW1iZXIpIHt9XG5cbiAgICBzdGF0aWMgemVyb1ZlY3RvcigpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihzLCBzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAtcGkgdG8gcGlcbiAgICAgKi9cbiAgICBzdGF0aWMgYW5nbGVCZXR3ZWVuKHYxOiBWZWN0b3IsIHYyOiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICAvLyAtMnBpIHRvIDJwaVxuICAgICAgICBsZXQgYW5nbGVCZXR3ZWVuID0gdjEuYW5nbGUoKSAtIHYyLmFuZ2xlKCk7XG4gICAgICAgIGlmIChhbmdsZUJldHdlZW4gPiBNYXRoLlBJKSB7XG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gLT0gMiAqIE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5nbGVCZXR3ZWVuIDw9IC1NYXRoLlBJKSB7XG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuZ2xlQmV0d2VlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIGEgcG9pbnQgbGllcyB0byB0aGUgbGVmdCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IGxpbmVQb2ludCAgICAgUG9pbnQgb24gdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IGxpbmVEaXJlY3Rpb24gXG4gICAgICogQHBhcmFtICB7VmVjdG9yfSBwb2ludFxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gICAgICAgICAgICAgICB0cnVlIGlmIGxlZnQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0xlZnQobGluZVBvaW50OiBWZWN0b3IsIGxpbmVEaXJlY3Rpb246IFZlY3RvciwgcG9pbnQ6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBwZXJwZW5kaWN1bGFyVmVjdG9yID0gbmV3IFZlY3RvcihsaW5lRGlyZWN0aW9uLnksIC1saW5lRGlyZWN0aW9uLngpO1xuICAgICAgICByZXR1cm4gcG9pbnQuY2xvbmUoKS5zdWIobGluZVBvaW50KS5kb3QocGVycGVuZGljdWxhclZlY3RvcikgPCAwO1xuICAgIH1cblxuICAgIGFkZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKz0gdi54O1xuICAgICAgICB0aGlzLnkgKz0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBpbiByYWRpYW5zIHRvIHBvc2l0aXZlIHgtYXhpcyBiZXR3ZWVuIC1waSBhbmQgcGlcbiAgICAgKi9cbiAgICBhbmdsZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cblxuICAgIGNvcHkodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgICB0aGlzLnkgPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNyb3NzKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG4gICAgfVxuXG4gICAgZGlzdGFuY2VUbyh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xuICAgIH1cblxuICAgIGRpc3RhbmNlVG9TcXVhcmVkICh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkeCA9IHRoaXMueCAtIHYueFxuICAgICAgICBjb25zdCBkeSA9IHRoaXMueSAtIHYueTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH1cblxuICAgIGRpdmlkZSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICBpZiAodi54ID09PSAwIHx8IHYueSA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggLz0gdi54O1xuICAgICAgICB0aGlzLnkgLz0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkaXZpZGVTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiRGl2aXNpb24gYnkgemVyb1wiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzKTtcbiAgICB9XG5cbiAgICBkb3QodjogVmVjdG9yKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcbiAgICB9XG5cbiAgICBlcXVhbHModjogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoKHYueCA9PT0gdGhpcy54KSAmJiAodi55ID09PSB0aGlzLnkpKTtcbiAgICB9XG5cbiAgICBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkpO1xuICAgIH1cblxuICAgIGxlbmd0aFNxKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG4gICAgfVxuXG4gICAgbXVsdGlwbHkodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ICo9IHYueDtcbiAgICAgICAgdGhpcy55ICo9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbXVsdGlwbHlTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ICo9IHM7XG4gICAgICAgIHRoaXMueSAqPSBzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBuZWdhdGUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoLTEpO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZSgpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiWmVybyBWZWN0b3JcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICByb3RhdGVBcm91bmQoY2VudGVyOiBWZWN0b3IsIGFuZ2xlOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSlcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnggLSBjZW50ZXIueDtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIGNlbnRlci55O1xuXG4gICAgICAgIHRoaXMueCA9IHggKiBjb3MgLSB5ICogc2luICsgY2VudGVyLng7XG4gICAgICAgIHRoaXMueSA9IHggKiBzaW4gKyB5ICogY29zICsgY2VudGVyLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0WCh4OiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRZKHk6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldExlbmd0aCAobGVuZ3RoOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgIH1cblxuICAgIHN1Yih2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgICB0aGlzLnkgLT0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iXX0=
