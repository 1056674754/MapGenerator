(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adopt = adopt;
exports.assignNewId = assignNewId;
exports.create = create;
exports.dispatch = dispatch;
exports.eid = eid;
exports.extend = extend;
exports.find = baseFind;
exports.getClass = getClass;
exports.invent = invent;
exports.makeInstance = makeInstance;
exports.makeMorphable = makeMorphable;
exports.mockAdopt = mockAdopt;
exports.nodeOrNew = nodeOrNew;
exports.off = off;
exports.on = on;
exports.parser = parser;
exports.register = register;
exports.registerMorphableType = registerMorphableType;
exports.registerWindow = registerWindow;
exports.wrapWithAttrCheck = wrapWithAttrCheck;
exports.utils = exports.root = exports.regex = exports.namespaces = exports.easing = exports.defaults = exports.Use = exports.Tspan = exports.TransformBag = exports.Timeline = exports.TextPath = exports.Text = exports.Symbol = exports.Svg = exports.Style = exports.Stop = exports.Spring = exports.Shape = exports.SVG = exports.Runner = exports.Rect = exports.Queue = exports.Polyline = exports.Polygon = exports.PointArray = exports.Point = exports.Pattern = exports.PathArray = exports.Path = exports.PID = exports.ObjectBag = exports.Number = exports.NonMorphable = exports.Morphable = exports.Matrix = exports.Mask = exports.Marker = exports.List = exports.Line = exports.Image = exports.Gradient = exports.G = exports.ForeignObject = exports.EventTarget = exports.Ellipse = exports.Element = exports.Ease = exports.Dom = exports.Defs = exports.Controller = exports.Container = exports.Color = exports.ClipPath = exports.Circle = exports.Box = exports.Array = exports.Animator = exports.A = void 0;

function _typeof3(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof3 = function _typeof3(obj) { return typeof obj; }; } else { _typeof3 = function _typeof3(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof3(obj); }

/*!
* @svgdotjs/svg.js - A lightweight library for manipulating and animating SVG.
* @version 3.0.16
* https://svgdotjs.github.io/
*
* @copyright Wout Fierens <wout@mick-wout.com>
* @license MIT
*
* BUILT: Tue Nov 12 2019 21:57:16 GMT+0100 (GMT+01:00)
*/
;
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var check = function check(it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


var global_1 = // eslint-disable-next-line no-undef
check((typeof globalThis === "undefined" ? "undefined" : _typeof3(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : _typeof3(window)) == 'object' && window) || check((typeof self === "undefined" ? "undefined" : _typeof3(self)) == 'object' && self) || check(_typeof3(commonjsGlobal) == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func
Function('return this')();

var fails = function fails(exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
}; // Thank's IE8 for his funny defineProperty


var descriptors = !fails(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});
var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;
var objectPropertyIsEnumerable = {
  f: f
};

var createPropertyDescriptor = function createPropertyDescriptor(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var toString = {}.toString;

var classofRaw = function classofRaw(it) {
  return toString.call(it).slice(8, -1);
};

var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

var indexedObject = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
} : Object; // `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible

var requireObjectCoercible = function requireObjectCoercible(it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
}; // toObject with fallback for non-array-like ES3 strings


var toIndexedObject = function toIndexedObject(it) {
  return indexedObject(requireObjectCoercible(it));
};

var isObject = function isObject(it) {
  return _typeof3(it) === 'object' ? it !== null : typeof it === 'function';
}; // `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


var toPrimitive = function toPrimitive(input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var hasOwnProperty = {}.hasOwnProperty;

var has = function has(it, key) {
  return hasOwnProperty.call(it, key);
};

var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

var EXISTS = isObject(document$1) && isObject(document$1.createElement);

var documentCreateElement = function documentCreateElement(it) {
  return EXISTS ? document$1.createElement(it) : {};
}; // Thank's IE8 for his funny defineProperty


var ie8DomDefine = !descriptors && !fails(function () {
  return Object.defineProperty(documentCreateElement('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (ie8DomDefine) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {
    /* empty */
  }
  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
};
var objectGetOwnPropertyDescriptor = {
  f: f$1
};

var anObject = function anObject(it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }

  return it;
};

var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty

var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (ie8DomDefine) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};
var objectDefineProperty = {
  f: f$2
};
var createNonEnumerableProperty = descriptors ? function (object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var setGlobal = function setGlobal(key, value) {
  try {
    createNonEnumerableProperty(global_1, key, value);
  } catch (error) {
    global_1[key] = value;
  }

  return value;
};

var SHARED = '__core-js_shared__';
var store = global_1[SHARED] || setGlobal(SHARED, {});
var sharedStore = store;
var shared = createCommonjsModule(function (module) {
  (module.exports = function (key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.3.6',
    mode: 'global',
    copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
  });
});
var functionToString = shared('native-function-to-string', Function.toString);
var WeakMap = global_1.WeakMap;
var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(functionToString.call(WeakMap));
var id = 0;
var postfix = Math.random();

var uid = function uid(key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var keys = shared('keys');

var sharedKey = function sharedKey(key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys = {};
var WeakMap$1 = global_1.WeakMap;
var set, get, has$1;

var enforce = function enforce(it) {
  return has$1(it) ? get(it) : set(it, {});
};

var getterFor = function getterFor(TYPE) {
  return function (it) {
    var state;

    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (nativeWeakMap) {
  var store$1 = new WeakMap$1();
  var wmget = store$1.get;
  var wmhas = store$1.has;
  var wmset = store$1.set;

  set = function set(it, metadata) {
    wmset.call(store$1, it, metadata);
    return metadata;
  };

  get = function get(it) {
    return wmget.call(store$1, it) || {};
  };

  has$1 = function has$1(it) {
    return wmhas.call(store$1, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;

  set = function set(it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };

  get = function get(it) {
    return has(it, STATE) ? it[STATE] : {};
  };

  has$1 = function has$1(it) {
    return has(it, STATE);
  };
}

var internalState = {
  set: set,
  get: get,
  has: has$1,
  enforce: enforce,
  getterFor: getterFor
};
var redefine = createCommonjsModule(function (module) {
  var getInternalState = internalState.get;
  var enforceInternalState = internalState.enforce;
  var TEMPLATE = String(functionToString).split('toString');
  shared('inspectSource', function (it) {
    return functionToString.call(it);
  });
  (module.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;

    if (typeof value == 'function') {
      if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
      enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }

    if (O === global_1) {
      if (simple) O[key] = value;else setGlobal(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }

    if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || functionToString.call(this);
  });
});
var path = global_1;

var aFunction = function aFunction(variable) {
  return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn = function getBuiltIn(namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
};

var ceil = Math.ceil;
var floor = Math.floor; // `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger

var toInteger = function toInteger(argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var min = Math.min; // `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength

var toLength = function toLength(argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).

var toAbsoluteIndex = function toAbsoluteIndex(index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
}; // `Array.prototype.{ indexOf, includes }` methods implementation


var createMethod = function createMethod(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};
var indexOf = arrayIncludes.indexOf;

var objectKeysInternal = function objectKeysInternal(object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    !has(hiddenKeys, key) && has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys


  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~indexOf(result, key) || result.push(key);
    }
  }

  return result;
}; // IE8- don't enum bug keys


var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];
var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys$1);
};

var objectGetOwnPropertyNames = {
  f: f$3
};
var f$4 = Object.getOwnPropertySymbols;
var objectGetOwnPropertySymbols = {
  f: f$4
}; // all object keys, includes non-enumerable and symbols

var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var copyConstructorProperties = function copyConstructorProperties(target, source) {
  var keys = ownKeys(source);
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

var replacement = /#|\.prototype\./;

var isForced = function isForced(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
var isForced_1 = isForced;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/

var _export = function _export(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

  if (GLOBAL) {
    target = global_1;
  } else if (STATIC) {
    target = global_1[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global_1[TARGET] || {}).prototype;
  }

  if (target) for (key in source) {
    sourceProperty = source[key];

    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];

    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

    if (!FORCED && targetProperty !== undefined) {
      if (_typeof3(sourceProperty) === _typeof3(targetProperty)) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    } // add a flag to not completely full polyfills


    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    } // extend global


    redefine(target, key, sourceProperty, options);
  }
}; // `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray


var isArray = Array.isArray || function isArray(arg) {
  return classofRaw(arg) == 'Array';
};

var createProperty = function createProperty(object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
};

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});
var Symbol$1 = global_1.Symbol;
var store$2 = shared('wks');

var wellKnownSymbol = function wellKnownSymbol(name) {
  return store$2[name] || (store$2[name] = nativeSymbol && Symbol$1[name] || (nativeSymbol ? Symbol$1 : uid)('Symbol.' + name));
};

var userAgent = getBuiltIn('navigator', 'userAgent') || '';
var process = global_1.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);

  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

var v8Version = version && +version;
var SPECIES = wellKnownSymbol('species');

var arrayMethodHasSpeciesSupport = function arrayMethodHasSpeciesSupport(METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return v8Version >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};

    constructor[SPECIES] = function () {
      return {
        foo: 1
      };
    };

    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var SPECIES$1 = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max$1 = Math.max; // `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('slice')
}, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

    var Constructor, result, n;

    if (isArray(O)) {
      Constructor = O.constructor; // cross-realm fallback

      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES$1];
        if (Constructor === null) Constructor = undefined;
      }

      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }

    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));

    for (n = 0; k < fin; k++, n++) {
      if (k in O) createProperty(result, n, O[k]);
    }

    result.length = n;
    return result;
  }
});

var defineProperty = objectDefineProperty.f;
var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name

if (descriptors && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function get() {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}

var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;
var toString$1 = {}.toString;
var windowNames = (typeof window === "undefined" ? "undefined" : _typeof3(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


var f$5 = function getOwnPropertyNames(it) {
  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
};

var objectGetOwnPropertyNamesExternal = {
  f: f$5
};
var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
var FAILS_ON_PRIMITIVES = fails(function () {
  return !Object.getOwnPropertyNames(1);
}); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  getOwnPropertyNames: nativeGetOwnPropertyNames$1
});

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
} // `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject


var toObject = function toObject(argument) {
  return Object(requireObjectCoercible(argument));
}; // `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys


var objectKeys = Object.keys || function keys(O) {
  return objectKeysInternal(O, enumBugKeys);
}; // `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties


var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;

  while (length > index) {
    objectDefineProperty.f(O, key = keys[index++], Properties[key]);
  }

  return O;
};
var html = getBuiltIn('document', 'documentElement');
var IE_PROTO = sharedKey('IE_PROTO');
var PROTOTYPE = 'prototype';

var Empty = function Empty() {
  /* empty */
}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var length = enumBugKeys.length;
  var lt = '<';
  var script = 'script';
  var gt = '>';
  var js = 'java' + script + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = String(js);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;

  while (length--) {
    delete _createDict[PROTOTYPE][enumBugKeys[length]];
  }

  return _createDict();
}; // `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create


var objectCreate = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = _createDict();

  return Properties === undefined ? result : objectDefineProperties(result, Properties);
};

hiddenKeys[IE_PROTO] = true;
var f$6 = wellKnownSymbol;
var wrappedWellKnownSymbol = {
  f: f$6
};
var defineProperty$1 = objectDefineProperty.f;

var defineWellKnownSymbol = function defineWellKnownSymbol(NAME) {
  var _Symbol2 = path.Symbol || (path.Symbol = {});

  if (!has(_Symbol2, NAME)) defineProperty$1(_Symbol2, NAME, {
    value: wrappedWellKnownSymbol.f(NAME)
  });
};

var defineProperty$2 = objectDefineProperty.f;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var setToStringTag = function setToStringTag(it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty$2(it, TO_STRING_TAG, {
      configurable: true,
      value: TAG
    });
  }
};

var aFunction$1 = function aFunction$1(it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }

  return it;
}; // optional / simple context binding


var bindContext = function bindContext(fn, that, length) {
  aFunction$1(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };

    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

var SPECIES$2 = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate

var arraySpeciesCreate = function arraySpeciesCreate(originalArray, length) {
  var C;

  if (isArray(originalArray)) {
    C = originalArray.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
      C = C[SPECIES$2];
      if (C === null) C = undefined;
    }
  }

  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

var createMethod$1 = function createMethod$1(TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = indexedObject(O);
    var boundFunction = bindContext(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;

    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);

        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return value;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                push.call(target, value);
              // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$1(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod$1(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod$1(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod$1(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod$1(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod$1(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$1(6)
};
var $forEach = arrayIteration.forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE$1 = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = internalState.set;
var getInternalState = internalState.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE$1];
var $Symbol = global_1.Symbol;
var JSON$1 = global_1.JSON;
var nativeJSONStringify = JSON$1 && JSON$1.stringify;
var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var nativeDefineProperty$1 = objectDefineProperty.f;
var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global_1.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDescriptor = descriptors && fails(function () {
  return objectCreate(nativeDefineProperty$1({}, 'a', {
    get: function get() {
      return nativeDefineProperty$1(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty$1(O, P, Attributes);

  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty$1;

var wrap = function wrap(tag, description) {
  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!descriptors) symbol.description = description;
  return symbol;
};

var isSymbol = nativeSymbol && _typeof3($Symbol.iterator) == 'symbol' ? function (it) {
  return _typeof3(it) == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);

  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = objectCreate(Attributes, {
        enumerable: createPropertyDescriptor(0, false)
      });
    }

    return setSymbolDescriptor(O, key, Attributes);
  }

  return nativeDefineProperty$1(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }

  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames$2(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames$2(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
}; // `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor


if (!nativeSymbol) {
  $Symbol = function _Symbol3() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);

    var setter = function setter(value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };

    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
      configurable: true,
      set: setter
    });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
    return getInternalState(this).tag;
  });
  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
  objectDefineProperty.f = $defineProperty;
  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

  if (descriptors) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
        unsafe: true
      });
    }
  }

  wrappedWellKnownSymbol.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };
}

_export({
  global: true,
  wrap: true,
  forced: !nativeSymbol,
  sham: !nativeSymbol
}, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

_export({
  target: SYMBOL,
  stat: true,
  forced: !nativeSymbol
}, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function _for(key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function useSetter() {
    USE_SETTER = true;
  },
  useSimple: function useSimple() {
    USE_SETTER = false;
  }
});

_export({
  target: 'Object',
  stat: true,
  forced: !nativeSymbol,
  sham: !descriptors
}, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

_export({
  target: 'Object',
  stat: true,
  forced: !nativeSymbol
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443


_export({
  target: 'Object',
  stat: true,
  forced: fails(function () {
    objectGetOwnPropertySymbols.f(1);
  })
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return objectGetOwnPropertySymbols.f(toObject(it));
  }
}); // `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify


JSON$1 && _export({
  target: 'JSON',
  stat: true,
  forced: !nativeSymbol || fails(function () {
    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

    return nativeJSONStringify([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
    || nativeJSONStringify({
      a: symbol
    }) != '{}' // V8 throws on boxed symbols
    || nativeJSONStringify(Object(symbol)) != '{}';
  })
}, {
  stringify: function stringify(it) {
    var args = [it];
    var index = 1;
    var replacer, $replacer;

    while (arguments.length > index) {
      args.push(arguments[index++]);
    }

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function replacer(key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return nativeJSONStringify.apply(JSON$1, args);
  }
}); // `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive

if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
} // `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag


setToStringTag($Symbol, SYMBOL);
hiddenKeys[HIDDEN] = true;
var defineProperty$3 = objectDefineProperty.f;
var NativeSymbol = global_1.Symbol;

if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || // Safari 12 bug
NativeSymbol().description !== undefined)) {
  var EmptyStringDescriptionStore = {}; // wrap Symbol constructor for correct work with undefined description

  var SymbolWrapper = function _Symbol4() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper ? new NativeSymbol(description) // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
    : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;
  var symbolToString = symbolPrototype.toString;

  var _native = String(NativeSymbol('test')) == 'Symbol(test)';

  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty$3(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = _native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  _export({
    global: true,
    forced: true
  }, {
    Symbol: SymbolWrapper
  });
} // `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator


defineWellKnownSymbol('iterator');
var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

if (ArrayPrototype[UNSCOPABLES] == undefined) {
  createNonEnumerableProperty(ArrayPrototype, UNSCOPABLES, objectCreate(null));
} // add a key to Array.prototype[@@unscopables]


var addToUnscopables = function addToUnscopables(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

var iterators = {};
var correctPrototypeGetter = !fails(function () {
  function F() {
    /* empty */
  }

  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var IE_PROTO$1 = sharedKey('IE_PROTO');
var ObjectPrototype$1 = Object.prototype; // `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof

var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectPrototype$1 : null;
};
var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function returnThis() {
  return this;
}; // `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

if (!has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

var returnThis$1 = function returnThis$1() {
  return this;
};

var createIteratorConstructor = function createIteratorConstructor(IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
    next: createPropertyDescriptor(1, next)
  });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
  iterators[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var aPossiblePrototype = function aPossiblePrototype(it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  }

  return it;
}; // `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */


var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;

  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {
    /* empty */
  }

  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);
var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis$2 = function returnThis$2() {
  return this;
};

var defineIterator = function defineIterator(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function getIterationMethod(KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };

      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };

      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }

    return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY; // fix native

  if (anyNativeIterator) {
    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
      if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
        if (objectSetPrototypeOf) {
          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
        }
      } // Set @@toStringTag to native iterators


      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;

    defaultIterator = function values() {
      return nativeIterator.call(this);
    };
  } // define iterator


  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
  }

  iterators[NAME] = defaultIterator; // export additional methods

  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else _export({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
    }, methods);
  }

  return methods;
};

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$1 = internalState.set;
var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator

var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState$1(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind

  }); // `%ArrayIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;

  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }

  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
var nativeAssign = Object.assign; // `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
// should work with symbols and should have deterministic property order (V8 bug)

var objectAssign = !nativeAssign || fails(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  var propertyIsEnumerable = objectPropertyIsEnumerable.f;

  while (argumentsLength > index) {
    var S = indexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : nativeAssign; // `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign

_export({
  target: 'Object',
  stat: true,
  forced: Object.assign !== objectAssign
}, {
  assign: objectAssign
});

var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


var classof = function classof(it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG$2] = 'z'; // `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring

var objectToString = String(test) !== '[object z]' ? function toString() {
  return '[object ' + classof(this) + ']';
} : test.toString;
var ObjectPrototype$2 = Object.prototype; // `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring

if (objectToString !== ObjectPrototype$2.toString) {
  redefine(ObjectPrototype$2, 'toString', objectToString, {
    unsafe: true
  });
}

var freezing = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});
var internalMetadata = createCommonjsModule(function (module) {
  var defineProperty = objectDefineProperty.f;
  var METADATA = uid('meta');
  var id = 0;

  var isExtensible = Object.isExtensible || function () {
    return true;
  };

  var setMetadata = function setMetadata(it) {
    defineProperty(it, METADATA, {
      value: {
        objectID: 'O' + ++id,
        // object ID
        weakData: {} // weak collections IDs

      }
    });
  };

  var fastKey = function fastKey(it, create) {
    // return a primitive with prefix
    if (!isObject(it)) return _typeof3(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F'; // not necessary to add metadata

      if (!create) return 'E'; // add missing metadata

      setMetadata(it); // return object ID
    }

    return it[METADATA].objectID;
  };

  var getWeakData = function getWeakData(it, create) {
    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true; // not necessary to add metadata

      if (!create) return false; // add missing metadata

      setMetadata(it); // return the store of weak collections IDs
    }

    return it[METADATA].weakData;
  }; // add metadata on freeze-family methods calling


  var onFreeze = function onFreeze(it) {
    if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
    return it;
  };

  var meta = module.exports = {
    REQUIRED: false,
    fastKey: fastKey,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };
  hiddenKeys[METADATA] = true;
});
var ITERATOR$2 = wellKnownSymbol('iterator');
var ArrayPrototype$1 = Array.prototype; // check on default Array iterator

var isArrayIteratorMethod = function isArrayIteratorMethod(it) {
  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$2] === it);
};

var ITERATOR$3 = wellKnownSymbol('iterator');

var getIteratorMethod = function getIteratorMethod(it) {
  if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || iterators[classof(it)];
}; // call something on iterator step with safe closing on error


var callWithSafeIterationClosing = function callWithSafeIterationClosing(iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

var iterate_1 = createCommonjsModule(function (module) {
  var Result = function Result(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = bindContext(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next, step;

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = toLength(iterable.length); length > index; index++) {
          result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
          if (result && result instanceof Result) return result;
        }

        return new Result(false);
      }

      iterator = iterFn.call(iterable);
    }

    next = iterator.next;

    while (!(step = next.call(iterator)).done) {
      result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
      if (_typeof3(result) == 'object' && result && result instanceof Result) return result;
    }

    return new Result(false);
  };

  iterate.stop = function (result) {
    return new Result(true, result);
  };
});

var anInstance = function anInstance(it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  }

  return it;
};

var ITERATOR$4 = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function next() {
      return {
        done: !!called++
      };
    },
    'return': function _return() {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR$4] = function () {
    return this;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

var checkCorrectnessOfIteration = function checkCorrectnessOfIteration(exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR$4] = function () {
      return {
        next: function next() {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
}; // makes subclassing work correct for wrapped built-ins


var inheritIfRequired = function inheritIfRequired($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if ( // it can work only with native `setPrototypeOf`
  objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
  return $this;
};

var collection = function collection(CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {
  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var ADDER = IS_MAP ? 'set' : 'add';
  var exported = {};

  var fixMethod = function fixMethod(KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
      nativeMethod.call(this, value === 0 ? 0 : value);
      return this;
    } : KEY == 'delete' ? function (key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'get' ? function get(key) {
      return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'has' ? function has(key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : function set(key, value) {
      nativeMethod.call(this, key === 0 ? 0 : key, value);
      return this;
    });
  }; // eslint-disable-next-line max-len


  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    internalMetadata.REQUIRED = true;
  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new

    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
      new NativeConstructor(iterable);
    }); // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;

      while (index--) {
        $instance[ADDER](index, index);
      }

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;

  _export({
    global: true,
    forced: Constructor != NativeConstructor
  }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

var redefineAll = function redefineAll(target, src, options) {
  for (var key in src) {
    redefine(target, key, src[key], options);
  }

  return target;
};

var SPECIES$3 = wellKnownSymbol('species');

var setSpecies = function setSpecies(CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = objectDefineProperty.f;

  if (descriptors && Constructor && !Constructor[SPECIES$3]) {
    defineProperty(Constructor, SPECIES$3, {
      configurable: true,
      get: function get() {
        return this;
      }
    });
  }
};

var defineProperty$4 = objectDefineProperty.f;
var fastKey = internalMetadata.fastKey;
var setInternalState$2 = internalState.set;
var internalStateGetterFor = internalState.getterFor;
var collectionStrong = {
  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState$2(that, {
        type: CONSTRUCTOR_NAME,
        index: objectCreate(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!descriptors) that.size = 0;
      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
    });
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function define(that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index; // change existing entry

      if (entry) {
        entry.value = value; // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (descriptors) state.size++;else that.size++; // add to index

        if (index !== 'F') state.index[index] = entry;
      }

      return that;
    };

    var getEntry = function getEntry(that, key) {
      var state = getInternalState(that); // fast case

      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index]; // frozen object case

      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;

        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }

        state.first = state.last = undefined;
        if (descriptors) state.size = 0;else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (descriptors) state.size--;else that.size--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        var state = getInternalState(this);
        var boundFunction = bindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this); // revert to the last existing entry

          while (entry && entry.removed) {
            entry = entry.previous;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (descriptors) defineProperty$4(C.prototype, 'size', {
      get: function get() {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function setStrong(C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$2(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last; // revert to the last existing entry

      while (entry && entry.removed) {
        entry = entry.previous;
      } // get next entry


      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      } // return step by kind


      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(CONSTRUCTOR_NAME);
  }
}; // `Set` constructor
// https://tc39.github.io/ecma262/#sec-set-objects

var es_set = collection('Set', function (get) {
  return function Set() {
    return get(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong); // `String.prototype.{ codePointAt, at }` methods implementation

var createMethod$2 = function createMethod$2(CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$2(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$2(true)
};
var charAt = stringMultibyte.charAt;
var STRING_ITERATOR = 'String Iterator';
var setInternalState$3 = internalState.set;
var getInternalState$2 = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator

defineIterator(String, 'String', function (iterated) {
  setInternalState$3(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  }); // `%StringIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$2(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
}); // iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var ITERATOR$5 = wellKnownSymbol('iterator');
var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
var ArrayValues = es_array_iterator.values;

for (var COLLECTION_NAME in domIterables) {
  var Collection = global_1[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;

  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR$5] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR$5, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR$5] = ArrayValues;
    }

    if (!CollectionPrototype[TO_STRING_TAG$3]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
    }

    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
      }
    }
  }
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

var methods = {};
var names = [];

function registerMethods(name, m) {
  if (Array.isArray(name)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = name[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _name = _step.value;
        registerMethods(_name, m);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return;
  }

  if (_typeof(name) === 'object') {
    for (var _name2 in name) {
      registerMethods(_name2, name[_name2]);
    }

    return;
  }

  addMethodNames(Object.getOwnPropertyNames(m));
  methods[name] = Object.assign(methods[name] || {}, m);
}

function getMethodsFor(name) {
  return methods[name] || {};
}

function getMethodNames() {
  return _toConsumableArray(new Set(names));
}

function addMethodNames(_names) {
  names.push.apply(names, _toConsumableArray(_names));
}

var $includes = arrayIncludes.includes; // `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes

_export({
  target: 'Array',
  proto: true
}, {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables


addToUnscopables('includes'); // `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags

var regexpFlags = function regexpFlags() {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var regexpExec = patchedExec;

_export({
  target: 'RegExp',
  proto: true,
  forced: /./.exec !== regexpExec
}, {
  exec: regexpExec
});

var MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp

var isRegexp = function isRegexp(it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
};

var notARegexp = function notARegexp(it) {
  if (isRegexp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  }

  return it;
};

var MATCH$1 = wellKnownSymbol('match');

var correctIsRegexpLogic = function correctIsRegexpLogic(METHOD_NAME) {
  var regexp = /./;

  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH$1] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) {
      /* empty */
    }
  }

  return false;
}; // `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes


_export({
  target: 'String',
  proto: true,
  forced: !correctIsRegexpLogic('includes')
}, {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});

var SPECIES$4 = wellKnownSymbol('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
}); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

var fixRegexpWellKnownSymbolLogic = function fixRegexpWellKnownSymbolLogic(KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.

      re.constructor = {};

      re.constructor[SPECIES$4] = function () {
        return re;
      };

      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {
      execCalled = true;
      return null;
    };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];
    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return regexMethod.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return regexMethod.call(string, this);
    });
    if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
  }
};

var charAt$1 = stringMultibyte.charAt; // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex

var advanceStringIndex = function advanceStringIndex(S, index, unicode) {
  return index + (unicode ? charAt$1(S, index).length : 1);
}; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec


var regexpExecAbstract = function regexpExecAbstract(R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (_typeof3(result) !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classofRaw(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};

var max$2 = Math.max;
var min$2 = Math.min;
var floor$1 = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function maybeToString(it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
    return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regexpExecAbstract(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max$2(min$2(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) {
        captures.push(maybeToString(result[j]));
      }

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor$1(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
}); // a string of all valid unicode whitespaces
// eslint-disable-next-line max-len

var whitespaces = "\t\n\x0B\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

var createMethod$3 = function createMethod$3(TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod$3(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod$3(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod$3(3)
};
var non = "\u200B\x85\u180E"; // check that a method works with the correct list
// of whitespaces and has a correct name

var forcedStringTrimMethod = function forcedStringTrimMethod(METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};

var $trim = stringTrim.trim; // `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim

_export({
  target: 'String',
  proto: true,
  forced: forcedStringTrimMethod('trim')
}, {
  trim: function trim() {
    return $trim(this);
  }
}); // Map function


function map(array, block) {
  var i;
  var il = array.length;
  var result = [];

  for (i = 0; i < il; i++) {
    result.push(block(array[i]));
  }

  return result;
} // Filter function


function filter(array, block) {
  var i;
  var il = array.length;
  var result = [];

  for (i = 0; i < il; i++) {
    if (block(array[i])) {
      result.push(array[i]);
    }
  }

  return result;
} // Degrees to radians


function radians(d) {
  return d % 360 * Math.PI / 180;
} // Radians to degrees


function degrees(r) {
  return r * 180 / Math.PI % 360;
} // Convert dash-separated-string to camelCase


function camelCase(s) {
  return s.toLowerCase().replace(/-(.)/g, function (m, g) {
    return g.toUpperCase();
  });
} // Convert camel cased string to string seperated


function unCamelCase(s) {
  return s.replace(/([A-Z])/g, function (m, g) {
    return '-' + g.toLowerCase();
  });
} // Capitalize first letter of a string


function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
} // Calculate proportional width and height values when necessary


function proportionalSize(element, width, height, box) {
  if (width == null || height == null) {
    box = box || element.bbox();

    if (width == null) {
      width = box.width / box.height * height;
    } else if (height == null) {
      height = box.height / box.width * width;
    }
  }

  return {
    width: width,
    height: height
  };
}

function getOrigin(o, element) {
  // Allow origin or around as the names
  var origin = o.origin; // o.around == null ? o.origin : o.around

  var ox, oy; // Allow the user to pass a string to rotate around a given point

  if (typeof origin === 'string' || origin == null) {
    // Get the bounding box of the element with no transformations applied
    var string = (origin || 'center').toLowerCase().trim();

    var _element$bbox = element.bbox(),
        height = _element$bbox.height,
        width = _element$bbox.width,
        x = _element$bbox.x,
        y = _element$bbox.y; // Calculate the transformed x and y coordinates


    var bx = string.includes('left') ? x : string.includes('right') ? x + width : x + width / 2;
    var by = string.includes('top') ? y : string.includes('bottom') ? y + height : y + height / 2; // Set the bounds eg : "bottom-left", "Top right", "middle" etc...

    ox = o.ox != null ? o.ox : bx;
    oy = o.oy != null ? o.oy : by;
  } else {
    ox = origin[0];
    oy = origin[1];
  } // Return the origin as it is if it wasn't a string


  return [ox, oy];
}

var utils = {
  __proto__: null,
  map: map,
  filter: filter,
  radians: radians,
  degrees: degrees,
  camelCase: camelCase,
  unCamelCase: unCamelCase,
  capitalize: capitalize,
  proportionalSize: proportionalSize,
  getOrigin: getOrigin
}; // Default namespaces

exports.utils = utils;
var ns = 'http://www.w3.org/2000/svg';
var xmlns = 'http://www.w3.org/2000/xmlns/';
var xlink = 'http://www.w3.org/1999/xlink';
var svgjs = 'http://svgjs.com/svgjs';
var namespaces = {
  __proto__: null,
  ns: ns,
  xmlns: xmlns,
  xlink: xlink,
  svgjs: svgjs
};
exports.namespaces = namespaces;
var globals = {
  window: typeof window === 'undefined' ? null : window,
  document: typeof document === 'undefined' ? null : document
};

function registerWindow() {
  var win = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  globals.window = win;
  globals.document = doc;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Base = function Base() {
  _classCallCheck(this, Base);
};

var elements = {};
var root = '___SYMBOL___ROOT___'; // Method for element creation

exports.root = root;

function create(name) {
  // create element
  return globals.document.createElementNS(ns, name);
}

function makeInstance(element) {
  if (element instanceof Base) return element;

  if (_typeof(element) === 'object') {
    return adopter(element);
  }

  if (element == null) {
    return new elements[root]();
  }

  if (typeof element === 'string' && element.charAt(0) !== '<') {
    return adopter(globals.document.querySelector(element));
  }

  var node = create('svg');
  node.innerHTML = element; // We can use firstChild here because we know,
  // that the first char is < and thus an element

  element = adopter(node.firstChild);
  return element;
}

function nodeOrNew(name, node) {
  return node instanceof globals.window.Node ? node : create(name);
} // Adopt existing svg elements


function adopt(node) {
  // check for presence of node
  if (!node) return null; // make sure a node isn't already adopted

  if (node.instance instanceof Base) return node.instance; // initialize variables

  var className = capitalize(node.nodeName || 'Dom'); // Make sure that gradients are adopted correctly

  if (className === 'LinearGradient' || className === 'RadialGradient') {
    className = 'Gradient'; // Fallback to Dom if element is not known
  } else if (!elements[className]) {
    className = 'Dom';
  }

  return new elements[className](node);
}

var adopter = adopt;

function mockAdopt() {
  var mock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : adopt;
  adopter = mock;
}

function register(element) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : element.name;
  var asRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  elements[name] = element;
  if (asRoot) elements[root] = element;
  addMethodNames(Object.getOwnPropertyNames(element.prototype));
  return element;
}

function getClass(name) {
  return elements[name];
} // Element id sequence


var did = 1000; // Get next named element id

function eid(name) {
  return 'Svgjs' + capitalize(name) + did++;
} // Deep new id assignment


function assignNewId(node) {
  // do the same for SVG child nodes as well
  for (var i = node.children.length - 1; i >= 0; i--) {
    assignNewId(node.children[i]);
  }

  if (node.id) {
    return adopt(node).id(eid(node.nodeName));
  }

  return adopt(node);
} // Method for extending objects


function extend(modules, methods, attrCheck) {
  var key, i;
  modules = Array.isArray(modules) ? modules : [modules];

  for (i = modules.length - 1; i >= 0; i--) {
    for (key in methods) {
      var method = methods[key];

      if (attrCheck) {
        method = wrapWithAttrCheck(methods[key]);
      }

      modules[i].prototype[key] = method;
    }
  }
} // export function extendWithAttrCheck (...args) {
//   extend(...args, true)
// }


function wrapWithAttrCheck(fn) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var o = args[args.length - 1];

    if (o && o.constructor === Object && !(o instanceof Array)) {
      return fn.apply(this, args.slice(0, -1)).attr(o);
    } else {
      return fn.apply(this, args);
    }
  };
}

function invent(config) {
  // Create element initializer
  var initializer = typeof config.create === 'function' ? config.create : function (node) {
    this.constructor(node || create(config.create));
  }; // Inherit prototype

  if (config.inherit) {
    /* eslint new-cap: off */
    initializer.prototype = new config.inherit();
    initializer.prototype.constructor = initializer;
  } // Extend with methods


  if (config.extend) {
    extend(initializer, config.extend);
  } // Attach construct method to parent


  if (config.construct) {
    extend(config.parent || elements.Container, config.construct);
  }

  return initializer;
}

function siblings() {
  return this.parent().children();
} // Get the curent position siblings


function position() {
  return this.parent().index(this);
} // Get the next element (will return null if there is none)


function next() {
  return this.siblings()[this.position() + 1];
} // Get the next element (will return null if there is none)


function prev() {
  return this.siblings()[this.position() - 1];
} // Send given element one step forward


function forward() {
  var i = this.position() + 1;
  var p = this.parent(); // move node one step forward

  p.removeElement(this).add(this, i); // make sure defs node is always at the top

  if (typeof p.isRoot === 'function' && p.isRoot()) {
    p.node.appendChild(p.defs().node);
  }

  return this;
} // Send given element one step backward


function backward() {
  var i = this.position();

  if (i > 0) {
    this.parent().removeElement(this).add(this, i - 1);
  }

  return this;
} // Send given element all the way to the front


function front() {
  var p = this.parent(); // Move node forward

  p.node.appendChild(this.node); // Make sure defs node is always at the top

  if (typeof p.isRoot === 'function' && p.isRoot()) {
    p.node.appendChild(p.defs().node);
  }

  return this;
} // Send given element all the way to the back


function back() {
  if (this.position() > 0) {
    this.parent().removeElement(this).add(this, 0);
  }

  return this;
} // Inserts a given element before the targeted element


function before(element) {
  element = makeInstance(element);
  element.remove();
  var i = this.position();
  this.parent().add(element, i);
  return this;
} // Inserts a given element after the targeted element


function after(element) {
  element = makeInstance(element);
  element.remove();
  var i = this.position();
  this.parent().add(element, i + 1);
  return this;
}

function insertBefore(element) {
  element = makeInstance(element);
  element.before(this);
  return this;
}

function insertAfter(element) {
  element = makeInstance(element);
  element.after(this);
  return this;
}

registerMethods('Dom', {
  siblings: siblings,
  position: position,
  next: next,
  prev: prev,
  forward: forward,
  backward: backward,
  front: front,
  back: back,
  before: before,
  after: after,
  insertBefore: insertBefore,
  insertAfter: insertAfter
});
var $filter = arrayIteration.filter; // `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('filter')
}, {
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var sloppyArrayMethod = function sloppyArrayMethod(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !method || !fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () {
      throw 1;
    }, 1);
  });
};

var $indexOf = arrayIncludes.indexOf;
var nativeIndexOf = [].indexOf;
var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var SLOPPY_METHOD = sloppyArrayMethod('indexOf'); // `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof

_export({
  target: 'Array',
  proto: true,
  forced: NEGATIVE_ZERO || SLOPPY_METHOD
}, {
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var nativeJoin = [].join;
var ES3_STRINGS = indexedObject != Object;
var SLOPPY_METHOD$1 = sloppyArrayMethod('join', ','); // `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join

_export({
  target: 'Array',
  proto: true,
  forced: ES3_STRINGS || SLOPPY_METHOD$1
}, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});

var SPECIES$5 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor

var speciesConstructor = function speciesConstructor(O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES$5]) == undefined ? defaultConstructor : aFunction$1(S);
};

var arrayPush = [].push;
var min$3 = Math.min;
var MAX_UINT32 = 0xFFFFFFFF; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  return !RegExp(MAX_UINT32, 'y');
}); // @@split logic

fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;

  if ('abbc'.split(/(b)*/)[1] == 'c' || 'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function internalSplit(separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string]; // If `separator` is not a regex, use native split

      if (!isRegexp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }

      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }

        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }

      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output.length > lim ? output.slice(0, lim) : output;
    }; // Chakra, V8

  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function internalSplit(separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = requireObjectCoercible(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = min$3(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
}, !SUPPORTS_Y); // Parse unit value

var numberAndUnit = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i; // Parse hex value

var hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i; // Parse rgb value

var rgb = /rgb\((\d+),(\d+),(\d+)\)/; // Parse reference id

var reference = /(#[a-z0-9\-_]+)/i; // splits a transformation chain

var transforms = /\)\s*,?\s*/; // Whitespace

var whitespace$1 = /\s/g; // Test hex value

var isHex = /^#[a-f0-9]{3,6}$/i; // Test rgb value

var isRgb = /^rgb\(/; // Test css declaration

var isCss = /[^:]+:[^;]+;?/; // Test for blank string

var isBlank = /^(\s+)?$/; // Test for numeric string

var isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i; // Test for percent value

var isPercent = /^-?[\d.]+%$/; // Test for image url

var isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i; // split at whitespace and comma

var delimiter = /[\s,]+/; // The following regex are used to parse the d attribute of a path
// Matches all hyphens which are not after an exponent

var hyphen = /([^e])-/gi; // Replaces and tests for all path letters

var pathLetters = /[MLHVCSQTAZ]/gi; // yes we need this one, too

var isPathLetter = /[MLHVCSQTAZ]/i; // matches 0.154.23.45

var numbersWithDots = /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi; // matches .

var dots = /\./g;
var regex = {
  __proto__: null,
  numberAndUnit: numberAndUnit,
  hex: hex,
  rgb: rgb,
  reference: reference,
  transforms: transforms,
  whitespace: whitespace$1,
  isHex: isHex,
  isRgb: isRgb,
  isCss: isCss,
  isBlank: isBlank,
  isNumber: isNumber,
  isPercent: isPercent,
  isImage: isImage,
  delimiter: delimiter,
  hyphen: hyphen,
  pathLetters: pathLetters,
  isPathLetter: isPathLetter,
  numbersWithDots: numbersWithDots,
  dots: dots
};
exports.regex = regex;

function classes() {
  var attr = this.attr('class');
  return attr == null ? [] : attr.trim().split(delimiter);
} // Return true if class exists on the node, false otherwise


function hasClass(name) {
  return this.classes().indexOf(name) !== -1;
} // Add class to the node


function addClass(name) {
  if (!this.hasClass(name)) {
    var array = this.classes();
    array.push(name);
    this.attr('class', array.join(' '));
  }

  return this;
} // Remove class from the node


function removeClass(name) {
  if (this.hasClass(name)) {
    this.attr('class', this.classes().filter(function (c) {
      return c !== name;
    }).join(' '));
  }

  return this;
} // Toggle the presence of a class on the node


function toggleClass(name) {
  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);
}

registerMethods('Dom', {
  classes: classes,
  hasClass: hasClass,
  addClass: addClass,
  removeClass: removeClass,
  toggleClass: toggleClass
});
var $forEach$1 = arrayIteration.forEach; // `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

var arrayForEach = sloppyArrayMethod('forEach') ? function forEach(callbackfn
/* , thisArg */
) {
  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach; // `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

_export({
  target: 'Array',
  proto: true,
  forced: [].forEach != arrayForEach
}, {
  forEach: arrayForEach
});

for (var COLLECTION_NAME$1 in domIterables) {
  var Collection$1 = global_1[COLLECTION_NAME$1];
  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

  if (CollectionPrototype$1 && CollectionPrototype$1.forEach !== arrayForEach) try {
    createNonEnumerableProperty(CollectionPrototype$1, 'forEach', arrayForEach);
  } catch (error) {
    CollectionPrototype$1.forEach = arrayForEach;
  }
}

function css(style, val) {
  var ret = {};

  if (arguments.length === 0) {
    // get full style as object
    this.node.style.cssText.split(/\s*;\s*/).filter(function (el) {
      return !!el.length;
    }).forEach(function (el) {
      var t = el.split(/\s*:\s*/);
      ret[t[0]] = t[1];
    });
    return ret;
  }

  if (arguments.length < 2) {
    // get style properties in the array
    if (Array.isArray(style)) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = style[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var name = _step.value;
          var cased = camelCase(name);
          ret[cased] = this.node.style[cased];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return ret;
    } // get style for property


    if (typeof style === 'string') {
      return this.node.style[camelCase(style)];
    } // set styles in object


    if (_typeof(style) === 'object') {
      for (var _name in style) {
        // set empty string if null/undefined/'' was given
        this.node.style[camelCase(_name)] = style[_name] == null || isBlank.test(style[_name]) ? '' : style[_name];
      }
    }
  } // set style for property


  if (arguments.length === 2) {
    this.node.style[camelCase(style)] = val == null || isBlank.test(val) ? '' : val;
  }

  return this;
} // Show element


function show() {
  return this.css('display', '');
} // Hide element


function hide() {
  return this.css('display', 'none');
} // Is element visible?


function visible() {
  return this.css('display') !== 'none';
}

registerMethods('Dom', {
  css: css,
  show: show,
  hide: hide,
  visible: visible
});

function data$1(a, v, r) {
  if (_typeof(a) === 'object') {
    for (v in a) {
      this.data(v, a[v]);
    }
  } else if (arguments.length < 2) {
    try {
      return JSON.parse(this.attr('data-' + a));
    } catch (e) {
      return this.attr('data-' + a);
    }
  } else {
    this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));
  }

  return this;
}

registerMethods('Dom', {
  data: data$1
});

function remember(k, v) {
  // remember every item in an object individually
  if (_typeof(arguments[0]) === 'object') {
    for (var key in k) {
      this.remember(key, k[key]);
    }
  } else if (arguments.length === 1) {
    // retrieve memory
    return this.memory()[k];
  } else {
    // store memory
    this.memory()[k] = v;
  }

  return this;
} // Erase a given memory


function forget() {
  if (arguments.length === 0) {
    this._memory = {};
  } else {
    for (var i = arguments.length - 1; i >= 0; i--) {
      delete this.memory()[arguments[i]];
    }
  }

  return this;
} // This triggers creation of a new hidden class which is not performant
// However, this function is not rarely used so it will not happen frequently
// Return local memory object


function memory() {
  return this._memory = this._memory || {};
}

registerMethods('Dom', {
  remember: remember,
  forget: forget,
  memory: memory
}); // `Array.prototype.{ reduce, reduceRight }` methods implementation

var createMethod$4 = function createMethod$4(IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction$1(callbackfn);
    var O = toObject(that);
    var self = indexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }

    for (; IS_RIGHT ? index >= 0 : length > index; index += i) {
      if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
    }

    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod$4(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod$4(true)
};
var $reduce = arrayReduce.left; // `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce

_export({
  target: 'Array',
  proto: true,
  forced: sloppyArrayMethod('reduce')
}, {
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var listenerId = 0;
var windowEvents = {};

function getEvents(instance) {
  var n = instance.getEventHolder(); // We dont want to save events in global space

  if (n === globals.window) n = windowEvents;
  if (!n.events) n.events = {};
  return n.events;
}

function getEventTarget(instance) {
  return instance.getEventTarget();
}

function clearEvents(instance) {
  var n = instance.getEventHolder();
  if (n.events) n.events = {};
} // Add event binder in the SVG namespace


function on(node, events, listener, binding, options) {
  var l = listener.bind(binding || node);
  var instance = makeInstance(node);
  var bag = getEvents(instance);
  var n = getEventTarget(instance); // events can be an array of events or a string of events

  events = Array.isArray(events) ? events : events.split(delimiter); // add id to listener

  if (!listener._svgjsListenerId) {
    listener._svgjsListenerId = ++listenerId;
  }

  events.forEach(function (event) {
    var ev = event.split('.')[0];
    var ns = event.split('.')[1] || '*'; // ensure valid object

    bag[ev] = bag[ev] || {};
    bag[ev][ns] = bag[ev][ns] || {}; // reference listener

    bag[ev][ns][listener._svgjsListenerId] = l; // add listener

    n.addEventListener(ev, l, options || false);
  });
} // Add event unbinder in the SVG namespace


function off(node, events, listener, options) {
  var instance = makeInstance(node);
  var bag = getEvents(instance);
  var n = getEventTarget(instance); // listener can be a function or a number

  if (typeof listener === 'function') {
    listener = listener._svgjsListenerId;
    if (!listener) return;
  } // events can be an array of events or a string or undefined


  events = Array.isArray(events) ? events : (events || '').split(delimiter);
  events.forEach(function (event) {
    var ev = event && event.split('.')[0];
    var ns = event && event.split('.')[1];
    var namespace, l;

    if (listener) {
      // remove listener reference
      if (bag[ev] && bag[ev][ns || '*']) {
        // removeListener
        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);
        delete bag[ev][ns || '*'][listener];
      }
    } else if (ev && ns) {
      // remove all listeners for a namespaced event
      if (bag[ev] && bag[ev][ns]) {
        for (l in bag[ev][ns]) {
          off(n, [ev, ns].join('.'), l);
        }

        delete bag[ev][ns];
      }
    } else if (ns) {
      // remove all listeners for a specific namespace
      for (event in bag) {
        for (namespace in bag[event]) {
          if (ns === namespace) {
            off(n, [event, ns].join('.'));
          }
        }
      }
    } else if (ev) {
      // remove all listeners for the event
      if (bag[ev]) {
        for (namespace in bag[ev]) {
          off(n, [ev, namespace].join('.'));
        }

        delete bag[ev];
      }
    } else {
      // remove all listeners on a given node
      for (event in bag) {
        off(n, event);
      }

      clearEvents(instance);
    }
  });
}

function dispatch(node, event, data) {
  var n = getEventTarget(node); // Dispatch event

  if (event instanceof globals.window.Event) {
    n.dispatchEvent(event);
  } else {
    event = new globals.window.CustomEvent(event, {
      detail: data,
      cancelable: true
    });
    n.dispatchEvent(event);
  }

  return event;
}

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; // We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679

var IS_CONCAT_SPREADABLE_SUPPORT = v8Version >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function isConcatSpreadable(O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species

_export({
  target: 'Array',
  proto: true,
  forced: FORCED
}, {
  concat: function concat(arg) {
    // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;

    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];

      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

        for (k = 0; k < len; k++, n++) {
          if (k in E) createProperty(A, n, E[k]);
        }
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }

    A.length = n;
    return A;
  }
});

var $map = arrayIteration.map; // `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('map')
}, {
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime; // `Date.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tostring

if (new Date(NaN) + '' != INVALID_DATE) {
  redefine(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}

var trim = stringTrim.trim;
var nativeParseInt = global_1.parseInt;
var hex$1 = /^[+-]?0[Xx]/;
var FORCED$1 = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22; // `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix

var _parseInt = FORCED$1 ? function parseInt(string, radix) {
  var S = trim(String(string));
  return nativeParseInt(S, radix >>> 0 || (hex$1.test(S) ? 16 : 10));
} : nativeParseInt; // `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix


_export({
  global: true,
  forced: parseInt != _parseInt
}, {
  parseInt: _parseInt
});

var TO_STRING$1 = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING$1];
var NOT_GENERIC = fails(function () {
  return nativeToString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
}); // FF44- RegExp#toString has a wrong name

var INCORRECT_NAME = nativeToString.name != TO_STRING$1; // `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring

if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING$1, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);
    return '/' + p + '/' + f;
  }, {
    unsafe: true
  });
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function sixDigitHex(hex) {
  return hex.length === 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;
}

function componentHex(component) {
  var integer = Math.round(component);
  var bounded = Math.max(0, Math.min(255, integer));
  var hex = bounded.toString(16);
  return hex.length === 1 ? '0' + hex : hex;
}

function is(object, space) {
  for (var i = space.length; i--;) {
    if (object[space[i]] == null) {
      return false;
    }
  }

  return true;
}

function getParameters(a, b) {
  var params = is(a, 'rgb') ? {
    _a: a.r,
    _b: a.g,
    _c: a.b,
    space: 'rgb'
  } : is(a, 'xyz') ? {
    _a: a.x,
    _b: a.y,
    _c: a.z,
    _d: 0,
    space: 'xyz'
  } : is(a, 'hsl') ? {
    _a: a.h,
    _b: a.s,
    _c: a.l,
    _d: 0,
    space: 'hsl'
  } : is(a, 'lab') ? {
    _a: a.l,
    _b: a.a,
    _c: a.b,
    _d: 0,
    space: 'lab'
  } : is(a, 'lch') ? {
    _a: a.l,
    _b: a.c,
    _c: a.h,
    _d: 0,
    space: 'lch'
  } : is(a, 'cmyk') ? {
    _a: a.c,
    _b: a.m,
    _c: a.y,
    _d: a.k,
    space: 'cmyk'
  } : {
    _a: 0,
    _b: 0,
    _c: 0,
    space: 'rgb'
  };
  params.space = b || params.space;
  return params;
}

function cieSpace(space) {
  if (space === 'lab' || space === 'xyz' || space === 'lch') {
    return true;
  } else {
    return false;
  }
}

function hueToRgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

var Color = /*#__PURE__*/function () {
  function Color() {
    _classCallCheck(this, Color);

    this.init.apply(this, arguments);
  }

  _createClass(Color, [{
    key: "init",
    value: function init() {
      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var space = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'rgb'; // This catches the case when a falsy value is passed like ''

      a = !a ? 0 : a; // Reset all values in case the init function is rerun with new color space

      if (this.space) {
        for (var component in this.space) {
          delete this[this.space[component]];
        }
      }

      if (typeof a === 'number') {
        // Allow for the case that we don't need d...
        space = typeof d === 'string' ? d : space;
        d = typeof d === 'string' ? 0 : d; // Assign the values straight to the color

        Object.assign(this, {
          _a: a,
          _b: b,
          _c: c,
          _d: d,
          space: space
        }); // If the user gave us an array, make the color from it
      } else if (a instanceof Array) {
        this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';
        Object.assign(this, {
          _a: a[0],
          _b: a[1],
          _c: a[2],
          _d: a[3] || 0
        });
      } else if (a instanceof Object) {
        // Set the object up and assign its values directly
        var values = getParameters(a, b);
        Object.assign(this, values);
      } else if (typeof a === 'string') {
        if (isRgb.test(a)) {
          var noWhitespace = a.replace(whitespace$1, '');

          var _rgb$exec$slice$map = rgb.exec(noWhitespace).slice(1, 4).map(function (v) {
            return parseInt(v);
          }),
              _rgb$exec$slice$map2 = _slicedToArray(_rgb$exec$slice$map, 3),
              _a2 = _rgb$exec$slice$map2[0],
              _b2 = _rgb$exec$slice$map2[1],
              _c2 = _rgb$exec$slice$map2[2];

          Object.assign(this, {
            _a: _a2,
            _b: _b2,
            _c: _c2,
            _d: 0,
            space: 'rgb'
          });
        } else if (isHex.test(a)) {
          var hexParse = function hexParse(v) {
            return parseInt(v, 16);
          };

          var _hex$exec$map = hex.exec(sixDigitHex(a)).map(hexParse),
              _hex$exec$map2 = _slicedToArray(_hex$exec$map, 4),
              _a3 = _hex$exec$map2[1],
              _b3 = _hex$exec$map2[2],
              _c3 = _hex$exec$map2[3];

          Object.assign(this, {
            _a: _a3,
            _b: _b3,
            _c: _c3,
            _d: 0,
            space: 'rgb'
          });
        } else throw Error('Unsupported string format, can\'t construct Color');
      } // Now add the components as a convenience


      var _a = this._a,
          _b = this._b,
          _c = this._c,
          _d = this._d;
      var components = this.space === 'rgb' ? {
        r: _a,
        g: _b,
        b: _c
      } : this.space === 'xyz' ? {
        x: _a,
        y: _b,
        z: _c
      } : this.space === 'hsl' ? {
        h: _a,
        s: _b,
        l: _c
      } : this.space === 'lab' ? {
        l: _a,
        a: _b,
        b: _c
      } : this.space === 'lch' ? {
        l: _a,
        c: _b,
        h: _c
      } : this.space === 'cmyk' ? {
        c: _a,
        m: _b,
        y: _c,
        k: _d
      } : {};
      Object.assign(this, components);
    }
    /*
    Conversion Methods
    */

  }, {
    key: "rgb",
    value: function rgb() {
      if (this.space === 'rgb') {
        return this;
      } else if (cieSpace(this.space)) {
        // Convert to the xyz color space
        var x = this.x,
            y = this.y,
            z = this.z;

        if (this.space === 'lab' || this.space === 'lch') {
          // Get the values in the lab space
          var l = this.l,
              a = this.a,
              _b4 = this.b;

          if (this.space === 'lch') {
            var c = this.c,
                h = this.h;
            var dToR = Math.PI / 180;
            a = c * Math.cos(dToR * h);
            _b4 = c * Math.sin(dToR * h);
          } // Undo the nonlinear function


          var yL = (l + 16) / 116;
          var xL = a / 500 + yL;
          var zL = yL - _b4 / 200; // Get the xyz values

          var ct = 16 / 116;
          var mx = 0.008856;
          var nm = 7.787;
          x = 0.95047 * (Math.pow(xL, 3) > mx ? Math.pow(xL, 3) : (xL - ct) / nm);
          y = 1.00000 * (Math.pow(yL, 3) > mx ? Math.pow(yL, 3) : (yL - ct) / nm);
          z = 1.08883 * (Math.pow(zL, 3) > mx ? Math.pow(zL, 3) : (zL - ct) / nm);
        } // Convert xyz to unbounded rgb values


        var rU = x * 3.2406 + y * -1.5372 + z * -0.4986;
        var gU = x * -0.9689 + y * 1.8758 + z * 0.0415;
        var bU = x * 0.0557 + y * -0.2040 + z * 1.0570; // Convert the values to true rgb values

        var pow = Math.pow;
        var bd = 0.0031308;
        var r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;
        var g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;
        var b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU; // Make and return the color

        var color = new Color(255 * r, 255 * g, 255 * b);
        return color;
      } else if (this.space === 'hsl') {
        // https://bgrins.github.io/TinyColor/docs/tinycolor.html
        // Get the current hsl values
        var _h = this.h,
            s = this.s,
            _l = this.l;
        _h /= 360;
        s /= 100;
        _l /= 100; // If we are grey, then just make the color directly

        if (s === 0) {
          _l *= 255;

          var _color2 = new Color(_l, _l, _l);

          return _color2;
        } // TODO I have no idea what this does :D If you figure it out, tell me!


        var q = _l < 0.5 ? _l * (1 + s) : _l + s - _l * s;
        var p = 2 * _l - q; // Get the rgb values

        var _r = 255 * hueToRgb(p, q, _h + 1 / 3);

        var _g = 255 * hueToRgb(p, q, _h);

        var _b5 = 255 * hueToRgb(p, q, _h - 1 / 3); // Make a new color


        var _color = new Color(_r, _g, _b5);

        return _color;
      } else if (this.space === 'cmyk') {
        // https://gist.github.com/felipesabino/5066336
        // Get the normalised cmyk values
        var _c4 = this.c,
            m = this.m,
            _y = this.y,
            k = this.k; // Get the rgb values

        var _r2 = 255 * (1 - Math.min(1, _c4 * (1 - k) + k));

        var _g2 = 255 * (1 - Math.min(1, m * (1 - k) + k));

        var _b6 = 255 * (1 - Math.min(1, _y * (1 - k) + k)); // Form the color and return it


        var _color3 = new Color(_r2, _g2, _b6);

        return _color3;
      } else {
        return this;
      }
    }
  }, {
    key: "lab",
    value: function lab() {
      // Get the xyz color
      var _this$xyz = this.xyz(),
          x = _this$xyz.x,
          y = _this$xyz.y,
          z = _this$xyz.z; // Get the lab components


      var l = 116 * y - 16;
      var a = 500 * (x - y);
      var b = 200 * (y - z); // Construct and return a new color

      var color = new Color(l, a, b, 'lab');
      return color;
    }
  }, {
    key: "xyz",
    value: function xyz() {
      // Normalise the red, green and blue values
      var _this$rgb = this.rgb(),
          r255 = _this$rgb._a,
          g255 = _this$rgb._b,
          b255 = _this$rgb._c;

      var _map = [r255, g255, b255].map(function (v) {
        return v / 255;
      }),
          _map2 = _slicedToArray(_map, 3),
          r = _map2[0],
          g = _map2[1],
          b = _map2[2]; // Convert to the lab rgb space


      var rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      var gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      var bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92; // Convert to the xyz color space without bounding the values

      var xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
      var yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.00000;
      var zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883; // Get the proper xyz values by applying the bounding

      var x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;
      var y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;
      var z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116; // Make and return the color

      var color = new Color(x, y, z, 'xyz');
      return color;
    }
  }, {
    key: "lch",
    value: function lch() {
      // Get the lab color directly
      var _this$lab = this.lab(),
          l = _this$lab.l,
          a = _this$lab.a,
          b = _this$lab.b; // Get the chromaticity and the hue using polar coordinates


      var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
      var h = 180 * Math.atan2(b, a) / Math.PI;

      if (h < 0) {
        h *= -1;
        h = 360 - h;
      } // Make a new color and return it


      var color = new Color(l, c, h, 'lch');
      return color;
    }
  }, {
    key: "hsl",
    value: function hsl() {
      // Get the rgb values
      var _this$rgb2 = this.rgb(),
          _a = _this$rgb2._a,
          _b = _this$rgb2._b,
          _c = _this$rgb2._c;

      var _map3 = [_a, _b, _c].map(function (v) {
        return v / 255;
      }),
          _map4 = _slicedToArray(_map3, 3),
          r = _map4[0],
          g = _map4[1],
          b = _map4[2]; // Find the maximum and minimum values to get the lightness


      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var l = (max + min) / 2; // If the r, g, v values are identical then we are grey

      var isGrey = max === min; // Calculate the hue and saturation

      var delta = max - min;
      var s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
      var h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0; // Construct and return the new color

      var color = new Color(360 * h, 100 * s, 100 * l, 'hsl');
      return color;
    }
  }, {
    key: "cmyk",
    value: function cmyk() {
      // Get the rgb values for the current color
      var _this$rgb3 = this.rgb(),
          _a = _this$rgb3._a,
          _b = _this$rgb3._b,
          _c = _this$rgb3._c;

      var _map5 = [_a, _b, _c].map(function (v) {
        return v / 255;
      }),
          _map6 = _slicedToArray(_map5, 3),
          r = _map6[0],
          g = _map6[1],
          b = _map6[2]; // Get the cmyk values in an unbounded format


      var k = Math.min(1 - r, 1 - g, 1 - b);

      if (k === 1) {
        // Catch the black case
        return new Color(0, 0, 0, 1, 'cmyk');
      }

      var c = (1 - r - k) / (1 - k);
      var m = (1 - g - k) / (1 - k);
      var y = (1 - b - k) / (1 - k); // Construct the new color

      var color = new Color(c, m, y, k, 'cmyk');
      return color;
    }
    /*
    Input and Output methods
    */

  }, {
    key: "_clamped",
    value: function _clamped() {
      var _this$rgb4 = this.rgb(),
          _a = _this$rgb4._a,
          _b = _this$rgb4._b,
          _c = _this$rgb4._c;

      var max = Math.max,
          min = Math.min,
          round = Math.round;

      var format = function format(v) {
        return max(0, min(round(v), 255));
      };

      return [_a, _b, _c].map(format);
    }
  }, {
    key: "toHex",
    value: function toHex() {
      var _this$_clamped$map = this._clamped().map(componentHex),
          _this$_clamped$map2 = _slicedToArray(_this$_clamped$map, 3),
          r = _this$_clamped$map2[0],
          g = _this$_clamped$map2[1],
          b = _this$_clamped$map2[2];

      return "#".concat(r).concat(g).concat(b);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.toHex();
    }
  }, {
    key: "toRgb",
    value: function toRgb() {
      var _this$_clamped = this._clamped(),
          _this$_clamped2 = _slicedToArray(_this$_clamped, 3),
          rV = _this$_clamped2[0],
          gV = _this$_clamped2[1],
          bV = _this$_clamped2[2];

      var string = "rgb(".concat(rV, ",").concat(gV, ",").concat(bV, ")");
      return string;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var _a = this._a,
          _b = this._b,
          _c = this._c,
          _d = this._d,
          space = this.space;
      return [_a, _b, _c, _d, space];
    }
    /*
    Generating random colors
    */

  }], [{
    key: "random",
    value: function random() {
      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'vibrant';
      var t = arguments.length > 1 ? arguments[1] : undefined; // Get the math modules

      var random = Math.random,
          round = Math.round,
          sin = Math.sin,
          pi = Math.PI; // Run the correct generator

      if (mode === 'vibrant') {
        var l = (81 - 57) * random() + 57;
        var c = (83 - 45) * random() + 45;
        var h = 360 * random();
        var color = new Color(l, c, h, 'lch');
        return color;
      } else if (mode === 'sine') {
        t = t == null ? random() : t;
        var r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);
        var g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);
        var b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);

        var _color4 = new Color(r, g, b);

        return _color4;
      } else if (mode === 'pastel') {
        var _l2 = (94 - 86) * random() + 86;

        var _c5 = (26 - 9) * random() + 9;

        var _h2 = 360 * random();

        var _color5 = new Color(_l2, _c5, _h2, 'lch');

        return _color5;
      } else if (mode === 'dark') {
        var _l3 = 10 + 10 * random();

        var _c6 = (125 - 75) * random() + 86;

        var _h3 = 360 * random();

        var _color6 = new Color(_l3, _c6, _h3, 'lch');

        return _color6;
      } else if (mode === 'rgb') {
        var _r3 = 255 * random();

        var _g3 = 255 * random();

        var _b7 = 255 * random();

        var _color7 = new Color(_r3, _g3, _b7);

        return _color7;
      } else if (mode === 'lab') {
        var _l4 = 100 * random();

        var a = 256 * random() - 128;

        var _b8 = 256 * random() - 128;

        var _color8 = new Color(_l4, a, _b8, 'lab');

        return _color8;
      } else if (mode === 'grey') {
        var grey = 255 * random();

        var _color9 = new Color(grey, grey, grey);

        return _color9;
      }
    }
    /*
    Constructing colors
    */
    // Test if given value is a color string

  }, {
    key: "test",
    value: function test(color) {
      return typeof color === 'string' && (isHex.test(color) || isRgb.test(color));
    } // Test if given value is an rgb object

  }, {
    key: "isRgb",
    value: function isRgb(color) {
      return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';
    } // Test if given value is a color

  }, {
    key: "isColor",
    value: function isColor(color) {
      return color && (color instanceof Color || this.isRgb(color) || this.test(color));
    }
  }]);

  return Color;
}();

exports.Color = Color;
var FAILS_ON_PRIMITIVES$1 = fails(function () {
  objectKeys(1);
}); // `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$1
}, {
  keys: function keys(it) {
    return objectKeys(toObject(it));
  }
}); // @@match logic


fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = requireObjectCoercible(this);
    var matcher = regexp == undefined ? undefined : regexp[MATCH];
    return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative(nativeMatch, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regexpExecAbstract(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regexpExecAbstract(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var defineProperty$5 = objectDefineProperty.f;
var trim$1 = stringTrim.trim;
var NUMBER = 'Number';
var NativeNumber = global_1[NUMBER];
var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber

var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;

  if (typeof it == 'string' && it.length > 2) {
    it = trim$1(it);
    first = it.charCodeAt(0);

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal of /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal of /^0o[0-7]+$/i

        default:
          return +it;
      }

      digits = it.slice(2);
      length = digits.length;

      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
}; // `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor


if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
    && (BROKEN_CLASSOF ? fails(function () {
      NumberPrototype.valueOf.call(dummy);
    }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };

  for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys$1.length > j; j++) {
    if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {
      defineProperty$5(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
    }
  }

  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global_1, NUMBER, NumberWrapper);
}

var trim$2 = stringTrim.trim;
var nativeParseFloat = global_1.parseFloat;
var FORCED$2 = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity; // `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string

var _parseFloat = FORCED$2 ? function parseFloat(string) {
  var trimmedString = trim$2(String(string));
  var result = nativeParseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : nativeParseFloat; // `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string


_export({
  global: true,
  forced: parseFloat != _parseFloat
}, {
  parseFloat: _parseFloat
});

var Point = /*#__PURE__*/function () {
  // Initialize
  function Point() {
    _classCallCheck(this, Point);

    this.init.apply(this, arguments);
  }

  _createClass(Point, [{
    key: "init",
    value: function init(x, y) {
      var base = {
        x: 0,
        y: 0
      }; // ensure source as object

      var source = Array.isArray(x) ? {
        x: x[0],
        y: x[1]
      } : _typeof(x) === 'object' ? {
        x: x.x,
        y: x.y
      } : {
        x: x,
        y: y
      }; // merge source

      this.x = source.x == null ? base.x : source.x;
      this.y = source.y == null ? base.y : source.y;
      return this;
    } // Clone point

  }, {
    key: "clone",
    value: function clone() {
      return new Point(this);
    }
  }, {
    key: "transform",
    value: function transform(m) {
      return this.clone().transformO(m);
    } // Transform point with matrix

  }, {
    key: "transformO",
    value: function transformO(m) {
      if (!Matrix.isMatrixLike(m)) {
        m = new Matrix(m);
      }

      var x = this.x,
          y = this.y; // Perform the matrix multiplication

      this.x = m.a * x + m.c * y + m.e;
      this.y = m.b * x + m.d * y + m.f;
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.x, this.y];
    }
  }]);

  return Point;
}();

exports.Point = Point;

function point(x, y) {
  return new Point(x, y).transform(this.screenCTM().inverse());
}

function closeEnough(a, b, threshold) {
  return Math.abs(b - a) < (threshold || 1e-6);
}

var Matrix = /*#__PURE__*/function () {
  function Matrix() {
    _classCallCheck(this, Matrix);

    this.init.apply(this, arguments);
  } // Initialize


  _createClass(Matrix, [{
    key: "init",
    value: function init(source) {
      var base = Matrix.fromArray([1, 0, 0, 1, 0, 0]); // ensure source as object

      source = source instanceof Element ? source.matrixify() : typeof source === 'string' ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : _typeof(source) === 'object' && Matrix.isMatrixLike(source) ? source : _typeof(source) === 'object' ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base; // Merge the source matrix with the base matrix

      this.a = source.a != null ? source.a : base.a;
      this.b = source.b != null ? source.b : base.b;
      this.c = source.c != null ? source.c : base.c;
      this.d = source.d != null ? source.d : base.d;
      this.e = source.e != null ? source.e : base.e;
      this.f = source.f != null ? source.f : base.f;
      return this;
    } // Clones this matrix

  }, {
    key: "clone",
    value: function clone() {
      return new Matrix(this);
    } // Transform a matrix into another matrix by manipulating the space

  }, {
    key: "transform",
    value: function transform(o) {
      // Check if o is a matrix and then left multiply it directly
      if (Matrix.isMatrixLike(o)) {
        var matrix = new Matrix(o);
        return matrix.multiplyO(this);
      } // Get the proposed transformations and the current transformations


      var t = Matrix.formatTransforms(o);
      var current = this;

      var _transform = new Point(t.ox, t.oy).transform(current),
          ox = _transform.x,
          oy = _transform.y; // Construct the resulting matrix


      var transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy); // If we want the origin at a particular place, we force it there

      if (isFinite(t.px) || isFinite(t.py)) {
        var origin = new Point(ox, oy).transform(transformer); // TODO: Replace t.px with isFinite(t.px)

        var dx = t.px ? t.px - origin.x : 0;
        var dy = t.py ? t.py - origin.y : 0;
        transformer.translateO(dx, dy);
      } // Translate now after positioning


      transformer.translateO(t.tx, t.ty);
      return transformer;
    } // Applies a matrix defined by its affine parameters

  }, {
    key: "compose",
    value: function compose(o) {
      if (o.origin) {
        o.originX = o.origin[0];
        o.originY = o.origin[1];
      } // Get the parameters


      var ox = o.originX || 0;
      var oy = o.originY || 0;
      var sx = o.scaleX || 1;
      var sy = o.scaleY || 1;
      var lam = o.shear || 0;
      var theta = o.rotate || 0;
      var tx = o.translateX || 0;
      var ty = o.translateY || 0; // Apply the standard matrix

      var result = new Matrix().translateO(-ox, -oy).scaleO(sx, sy).shearO(lam).rotateO(theta).translateO(tx, ty).lmultiplyO(this).translateO(ox, oy);
      return result;
    } // Decomposes this matrix into its affine parameters

  }, {
    key: "decompose",
    value: function decompose() {
      var cx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var cy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Get the parameters from the matrix

      var a = this.a;
      var b = this.b;
      var c = this.c;
      var d = this.d;
      var e = this.e;
      var f = this.f; // Figure out if the winding direction is clockwise or counterclockwise

      var determinant = a * d - b * c;
      var ccw = determinant > 0 ? 1 : -1; // Since we only shear in x, we can use the x basis to get the x scale
      // and the rotation of the resulting matrix

      var sx = ccw * Math.sqrt(a * a + b * b);
      var thetaRad = Math.atan2(ccw * b, ccw * a);
      var theta = 180 / Math.PI * thetaRad;
      var ct = Math.cos(thetaRad);
      var st = Math.sin(thetaRad); // We can then solve the y basis vector simultaneously to get the other
      // two affine parameters directly from these parameters

      var lam = (a * c + b * d) / determinant;
      var sy = c * sx / (lam * a - b) || d * sx / (lam * b + a); // Use the translations

      var tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);
      var ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy); // Construct the decomposition and return it

      return {
        // Return the affine parameters
        scaleX: sx,
        scaleY: sy,
        shear: lam,
        rotate: theta,
        translateX: tx,
        translateY: ty,
        originX: cx,
        originY: cy,
        // Return the matrix parameters
        a: this.a,
        b: this.b,
        c: this.c,
        d: this.d,
        e: this.e,
        f: this.f
      };
    } // Left multiplies by the given matrix

  }, {
    key: "multiply",
    value: function multiply(matrix) {
      return this.clone().multiplyO(matrix);
    }
  }, {
    key: "multiplyO",
    value: function multiplyO(matrix) {
      // Get the matrices
      var l = this;
      var r = matrix instanceof Matrix ? matrix : new Matrix(matrix);
      return Matrix.matrixMultiply(l, r, this);
    }
  }, {
    key: "lmultiply",
    value: function lmultiply(matrix) {
      return this.clone().lmultiplyO(matrix);
    }
  }, {
    key: "lmultiplyO",
    value: function lmultiplyO(matrix) {
      var r = this;
      var l = matrix instanceof Matrix ? matrix : new Matrix(matrix);
      return Matrix.matrixMultiply(l, r, this);
    } // Inverses matrix

  }, {
    key: "inverseO",
    value: function inverseO() {
      // Get the current parameters out of the matrix
      var a = this.a;
      var b = this.b;
      var c = this.c;
      var d = this.d;
      var e = this.e;
      var f = this.f; // Invert the 2x2 matrix in the top left

      var det = a * d - b * c;
      if (!det) throw new Error('Cannot invert ' + this); // Calculate the top 2x2 matrix

      var na = d / det;
      var nb = -b / det;
      var nc = -c / det;
      var nd = a / det; // Apply the inverted matrix to the top right

      var ne = -(na * e + nc * f);
      var nf = -(nb * e + nd * f); // Construct the inverted matrix

      this.a = na;
      this.b = nb;
      this.c = nc;
      this.d = nd;
      this.e = ne;
      this.f = nf;
      return this;
    }
  }, {
    key: "inverse",
    value: function inverse() {
      return this.clone().inverseO();
    } // Translate matrix

  }, {
    key: "translate",
    value: function translate(x, y) {
      return this.clone().translateO(x, y);
    }
  }, {
    key: "translateO",
    value: function translateO(x, y) {
      this.e += x || 0;
      this.f += y || 0;
      return this;
    } // Scale matrix

  }, {
    key: "scale",
    value: function scale(x, y, cx, cy) {
      var _this$clone;

      return (_this$clone = this.clone()).scaleO.apply(_this$clone, arguments);
    }
  }, {
    key: "scaleO",
    value: function scaleO(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; // Support uniform scaling

      if (arguments.length === 3) {
        cy = cx;
        cx = y;
        y = x;
      }

      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
      this.a = a * x;
      this.b = b * y;
      this.c = c * x;
      this.d = d * y;
      this.e = e * x - cx * x + cx;
      this.f = f * y - cy * y + cy;
      return this;
    } // Rotate matrix

  }, {
    key: "rotate",
    value: function rotate(r, cx, cy) {
      return this.clone().rotateO(r, cx, cy);
    }
  }, {
    key: "rotateO",
    value: function rotateO(r) {
      var cx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // Convert degrees to radians

      r = radians(r);
      var cos = Math.cos(r);
      var sin = Math.sin(r);
      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
      this.a = a * cos - b * sin;
      this.b = b * cos + a * sin;
      this.c = c * cos - d * sin;
      this.d = d * cos + c * sin;
      this.e = e * cos - f * sin + cy * sin - cx * cos + cx;
      this.f = f * cos + e * sin - cx * sin - cy * cos + cy;
      return this;
    } // Flip matrix on x or y, at a given offset

  }, {
    key: "flip",
    value: function flip(axis, around) {
      return this.clone().flipO(axis, around);
    }
  }, {
    key: "flipO",
    value: function flipO(axis, around) {
      return axis === 'x' ? this.scaleO(-1, 1, around, 0) : axis === 'y' ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis); // Define an x, y flip point
    } // Shear matrix

  }, {
    key: "shear",
    value: function shear(a, cx, cy) {
      return this.clone().shearO(a, cx, cy);
    }
  }, {
    key: "shearO",
    value: function shearO(lx) {
      var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
      this.a = a + b * lx;
      this.c = c + d * lx;
      this.e = e + f * lx - cy * lx;
      return this;
    } // Skew Matrix

  }, {
    key: "skew",
    value: function skew(x, y, cx, cy) {
      var _this$clone2;

      return (_this$clone2 = this.clone()).skewO.apply(_this$clone2, arguments);
    }
  }, {
    key: "skewO",
    value: function skewO(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; // support uniformal skew

      if (arguments.length === 3) {
        cy = cx;
        cx = y;
        y = x;
      } // Convert degrees to radians


      x = radians(x);
      y = radians(y);
      var lx = Math.tan(x);
      var ly = Math.tan(y);
      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
      this.a = a + b * lx;
      this.b = b + a * ly;
      this.c = c + d * lx;
      this.d = d + c * ly;
      this.e = e + f * lx - cy * lx;
      this.f = f + e * ly - cx * ly;
      return this;
    } // SkewX

  }, {
    key: "skewX",
    value: function skewX(x, cx, cy) {
      return this.skew(x, 0, cx, cy);
    }
  }, {
    key: "skewXO",
    value: function skewXO(x, cx, cy) {
      return this.skewO(x, 0, cx, cy);
    } // SkewY

  }, {
    key: "skewY",
    value: function skewY(y, cx, cy) {
      return this.skew(0, y, cx, cy);
    }
  }, {
    key: "skewYO",
    value: function skewYO(y, cx, cy) {
      return this.skewO(0, y, cx, cy);
    } // Transform around a center point

  }, {
    key: "aroundO",
    value: function aroundO(cx, cy, matrix) {
      var dx = cx || 0;
      var dy = cy || 0;
      return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);
    }
  }, {
    key: "around",
    value: function around(cx, cy, matrix) {
      return this.clone().aroundO(cx, cy, matrix);
    } // Check if two matrices are equal

  }, {
    key: "equals",
    value: function equals(other) {
      var comp = new Matrix(other);
      return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);
    } // Convert matrix to string

  }, {
    key: "toString",
    value: function toString() {
      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.a, this.b, this.c, this.d, this.e, this.f];
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return {
        a: this.a,
        b: this.b,
        c: this.c,
        d: this.d,
        e: this.e,
        f: this.f
      };
    }
  }], [{
    key: "fromArray",
    value: function fromArray(a) {
      return {
        a: a[0],
        b: a[1],
        c: a[2],
        d: a[3],
        e: a[4],
        f: a[5]
      };
    }
  }, {
    key: "isMatrixLike",
    value: function isMatrixLike(o) {
      return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;
    }
  }, {
    key: "formatTransforms",
    value: function formatTransforms(o) {
      // Get all of the parameters required to form the matrix
      var flipBoth = o.flip === 'both' || o.flip === true;
      var flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;
      var flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;
      var skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;
      var skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;
      var scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;
      var scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;
      var shear = o.shear || 0;
      var theta = o.rotate || o.theta || 0;
      var origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);
      var ox = origin.x;
      var oy = origin.y;
      var position = new Point(o.position || o.px || o.positionX, o.py || o.positionY);
      var px = position.x;
      var py = position.y;
      var translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);
      var tx = translate.x;
      var ty = translate.y;
      var relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);
      var rx = relative.x;
      var ry = relative.y; // Populate all of the values

      return {
        scaleX: scaleX,
        scaleY: scaleY,
        skewX: skewX,
        skewY: skewY,
        shear: shear,
        theta: theta,
        rx: rx,
        ry: ry,
        tx: tx,
        ty: ty,
        ox: ox,
        oy: oy,
        px: px,
        py: py
      };
    } // left matrix, right matrix, target matrix which is overwritten

  }, {
    key: "matrixMultiply",
    value: function matrixMultiply(l, r, o) {
      // Work out the product directly
      var a = l.a * r.a + l.c * r.b;
      var b = l.b * r.a + l.d * r.b;
      var c = l.a * r.c + l.c * r.d;
      var d = l.b * r.c + l.d * r.d;
      var e = l.e + l.a * r.e + l.c * r.f;
      var f = l.f + l.b * r.e + l.d * r.f; // make sure to use local variables because l/r and o could be the same

      o.a = a;
      o.b = b;
      o.c = c;
      o.d = d;
      o.e = e;
      o.f = f;
      return o;
    }
  }]);

  return Matrix;
}();

exports.Matrix = Matrix;

function ctm() {
  return new Matrix(this.node.getCTM());
}

function screenCTM() {
  /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
     This is needed because FF does not return the transformation matrix
     for the inner coordinate system when getScreenCTM() is called on nested svgs.
     However all other Browsers do that */
  if (typeof this.isRoot === 'function' && !this.isRoot()) {
    var rect = this.rect(1, 1);
    var m = rect.node.getScreenCTM();
    rect.remove();
    return new Matrix(m);
  }

  return new Matrix(this.node.getScreenCTM());
}

register(Matrix, 'Matrix');

function parser() {
  // Reuse cached element if possible
  if (!parser.nodes) {
    var svg = makeInstance().size(2, 0);
    svg.node.style.cssText = ['opacity: 0', 'position: absolute', 'left: -100%', 'top: -100%', 'overflow: hidden'].join(';');
    svg.attr('focusable', 'false');
    svg.attr('aria-hidden', 'true');
    var path = svg.path().node;
    parser.nodes = {
      svg: svg,
      path: path
    };
  }

  if (!parser.nodes.svg.node.parentNode) {
    var b = globals.document.body || globals.document.documentElement;
    parser.nodes.svg.addTo(b);
  }

  return parser.nodes;
}

function isNulledBox(box) {
  return !box.width && !box.height && !box.x && !box.y;
}

function domContains(node) {
  return node === globals.document || (globals.document.documentElement.contains || function (node) {
    // This is IE - it does not support contains() for top-level SVGs
    while (node.parentNode) {
      node = node.parentNode;
    }

    return node === globals.document;
  }).call(globals.document.documentElement, node);
}

var Box = /*#__PURE__*/function () {
  function Box() {
    _classCallCheck(this, Box);

    this.init.apply(this, arguments);
  }

  _createClass(Box, [{
    key: "init",
    value: function init(source) {
      var base = [0, 0, 0, 0];
      source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : _typeof(source) === 'object' ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;
      this.x = source[0] || 0;
      this.y = source[1] || 0;
      this.width = this.w = source[2] || 0;
      this.height = this.h = source[3] || 0; // Add more bounding box properties

      this.x2 = this.x + this.w;
      this.y2 = this.y + this.h;
      this.cx = this.x + this.w / 2;
      this.cy = this.y + this.h / 2;
      return this;
    } // Merge rect box with another, return a new instance

  }, {
    key: "merge",
    value: function merge(box) {
      var x = Math.min(this.x, box.x);
      var y = Math.min(this.y, box.y);
      var width = Math.max(this.x + this.width, box.x + box.width) - x;
      var height = Math.max(this.y + this.height, box.y + box.height) - y;
      return new Box(x, y, width, height);
    }
  }, {
    key: "transform",
    value: function transform(m) {
      if (!(m instanceof Matrix)) {
        m = new Matrix(m);
      }

      var xMin = Infinity;
      var xMax = -Infinity;
      var yMin = Infinity;
      var yMax = -Infinity;
      var pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];
      pts.forEach(function (p) {
        p = p.transform(m);
        xMin = Math.min(xMin, p.x);
        xMax = Math.max(xMax, p.x);
        yMin = Math.min(yMin, p.y);
        yMax = Math.max(yMax, p.y);
      });
      return new Box(xMin, yMin, xMax - xMin, yMax - yMin);
    }
  }, {
    key: "addOffset",
    value: function addOffset() {
      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
      this.x += globals.window.pageXOffset;
      this.y += globals.window.pageYOffset;
      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.x, this.y, this.width, this.height];
    }
  }, {
    key: "isNulled",
    value: function isNulled() {
      return isNulledBox(this);
    }
  }]);

  return Box;
}();

exports.Box = Box;

function getBox(cb, retry) {
  var box;

  try {
    box = cb(this.node);

    if (isNulledBox(box) && !domContains(this.node)) {
      throw new Error('Element not in the dom');
    }
  } catch (e) {
    box = retry(this);
  }

  return box;
}

function bbox() {
  return new Box(getBox.call(this, function (node) {
    return node.getBBox();
  }, function (el) {
    try {
      var clone = el.clone().addTo(parser().svg).show();
      var box = clone.node.getBBox();
      clone.remove();
      return box;
    } catch (e) {
      throw new Error('Getting bbox of element "' + el.node.nodeName + '" is not possible. ' + e.toString());
    }
  }));
}

function rbox(el) {
  var box = new Box(getBox.call(this, function (node) {
    return node.getBoundingClientRect();
  }, function (el) {
    throw new Error('Getting rbox of element "' + el.node.nodeName + '" is not possible');
  }));
  if (el) return box.transform(el.screenCTM().inverse());
  return box.addOffset();
}

registerMethods({
  viewbox: {
    viewbox: function viewbox(x, y, width, height) {
      // act as getter
      if (x == null) return new Box(this.attr('viewBox')); // act as setter

      return this.attr('viewBox', new Box(x, y, width, height));
    },
    zoom: function zoom(level, point) {
      var width = this.node.clientWidth;
      var height = this.node.clientHeight;
      var v = this.viewbox(); // Firefox does not support clientHeight and returns 0
      // https://bugzilla.mozilla.org/show_bug.cgi?id=874811

      if (!width && !height) {
        var style = window.getComputedStyle(this.node);
        width = parseFloat(style.getPropertyValue('width'));
        height = parseFloat(style.getPropertyValue('height'));
      }

      var zoomX = width / v.width;
      var zoomY = height / v.height;
      var zoom = Math.min(zoomX, zoomY);

      if (level == null) {
        return zoom;
      }

      var zoomAmount = zoom / level;
      if (zoomAmount === Infinity) zoomAmount = Number.MIN_VALUE;
      point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);
      var box = new Box(v).transform(new Matrix({
        scale: zoomAmount,
        origin: point
      }));
      return this.viewbox(box);
    }
  }
});
register(Box, 'Box');
/* eslint no-new-func: "off" */

var subClassArray = function () {
  try {
    // try es6 subclassing
    return Function('name', 'baseClass', '_constructor', ['baseClass = baseClass || Array', 'return {', '  [name]: class extends baseClass {', '    constructor (...args) {', '      super(...args)', '      _constructor && _constructor.apply(this, args)', '    }', '  }', '}[name]'].join('\n'));
  } catch (e) {
    // Use es5 approach
    return function (name) {
      var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Array;

      var _constructor = arguments.length > 2 ? arguments[2] : undefined;

      var Arr = function Arr() {
        baseClass.apply(this, arguments);
        _constructor && _constructor.apply(this, arguments);
      };

      Arr.prototype = Object.create(baseClass.prototype);
      Arr.prototype.constructor = Arr;

      Arr.prototype.map = function (fn) {
        var arr = new Arr();
        arr.push.apply(arr, Array.prototype.map.call(this, fn));
        return arr;
      };

      return Arr;
    };
  }
}();

var List = subClassArray('List', Array, function () {
  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // This catches the case, that native map tries to create an array with new Array(1)

  if (typeof arr === 'number') return this;
  this.length = 0;
  this.push.apply(this, _toConsumableArray(arr));
});
exports.List = List;
extend(List, {
  each: function each(fnOrMethodName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (typeof fnOrMethodName === 'function') {
      return this.map(function (el) {
        return fnOrMethodName.call(el, el);
      });
    } else {
      return this.map(function (el) {
        return el[fnOrMethodName].apply(el, args);
      });
    }
  },
  toArray: function toArray() {
    return Array.prototype.concat.apply([], this);
  }
});
var reserved = ['toArray', 'constructor', 'each'];

List.extend = function (methods) {
  methods = methods.reduce(function (obj, name) {
    // Don't overwrite own methods
    if (reserved.includes(name)) return obj; // Don't add private methods

    if (name[0] === '_') return obj; // Relay every call to each()

    obj[name] = function () {
      for (var _len2 = arguments.length, attrs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        attrs[_key2] = arguments[_key2];
      }

      return this.each.apply(this, [name].concat(attrs));
    };

    return obj;
  }, {});
  extend(List, methods);
};

function baseFind(query, parent) {
  return new List(map((parent || globals.document).querySelectorAll(query), function (node) {
    return adopt(node);
  }));
} // Scoped find method


function find(query) {
  return baseFind(query, this.node);
}

function findOne(query) {
  return adopt(this.node.querySelector(query));
}

var EventTarget = /*#__PURE__*/function (_Base) {
  _inherits(EventTarget, _Base);

  function EventTarget() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$events = _ref.events,
        events = _ref$events === void 0 ? {} : _ref$events;

    _classCallCheck(this, EventTarget);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EventTarget).call(this));
    _this.events = events;
    return _this;
  }

  _createClass(EventTarget, [{
    key: "addEventListener",
    value: function addEventListener() {}
  }, {
    key: "dispatch",
    value: function dispatch$1(event, data) {
      return dispatch(this, event, data);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      var bag = this.getEventHolder().events;
      if (!bag) return true;
      var events = bag[event.type];

      for (var i in events) {
        for (var j in events[i]) {
          events[i][j](event);
        }
      }

      return !event.defaultPrevented;
    } // Fire given event

  }, {
    key: "fire",
    value: function fire(event, data) {
      this.dispatch(event, data);
      return this;
    }
  }, {
    key: "getEventHolder",
    value: function getEventHolder() {
      return this;
    }
  }, {
    key: "getEventTarget",
    value: function getEventTarget() {
      return this;
    } // Unbind event from listener

  }, {
    key: "off",
    value: function off$1(event, listener) {
      off(this, event, listener);
      return this;
    } // Bind given event to listener

  }, {
    key: "on",
    value: function on$1(event, listener, binding, options) {
      on(this, event, listener, binding, options);
      return this;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener() {}
  }]);

  return EventTarget;
}(Base);

exports.EventTarget = EventTarget;
register(EventTarget, 'EventTarget');

function noop() {} // Default animation values


var timeline = {
  duration: 400,
  ease: '>',
  delay: 0
}; // Default attribute values

var attrs = {
  // fill and stroke
  'fill-opacity': 1,
  'stroke-opacity': 1,
  'stroke-width': 0,
  'stroke-linejoin': 'miter',
  'stroke-linecap': 'butt',
  fill: '#000000',
  stroke: '#000000',
  opacity: 1,
  // position
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,
  // size
  width: 0,
  height: 0,
  // radius
  r: 0,
  rx: 0,
  ry: 0,
  // gradient
  offset: 0,
  'stop-opacity': 1,
  'stop-color': '#000000',
  // text
  'text-anchor': 'start'
};
var defaults = {
  __proto__: null,
  noop: noop,
  timeline: timeline,
  attrs: attrs
};
exports.defaults = defaults;
var SVGArray = subClassArray('SVGArray', Array, function (arr) {
  this.init(arr);
});
exports.Array = SVGArray;
extend(SVGArray, {
  init: function init(arr) {
    // This catches the case, that native map tries to create an array with new Array(1)
    if (typeof arr === 'number') return this;
    this.length = 0;
    this.push.apply(this, _toConsumableArray(this.parse(arr)));
    return this;
  },
  toArray: function toArray() {
    return Array.prototype.concat.apply([], this);
  },
  toString: function toString() {
    return this.join(' ');
  },
  // Flattens the array if needed
  valueOf: function valueOf() {
    var ret = [];
    ret.push.apply(ret, _toConsumableArray(this));
    return ret;
  },
  // Parse whitespace separated string
  parse: function parse() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // If already is an array, no need to parse it

    if (array instanceof Array) return array;
    return array.trim().split(delimiter).map(parseFloat);
  },
  clone: function clone() {
    return new this.constructor(this);
  },
  toSet: function toSet() {
    return new Set(this);
  }
});

var SVGNumber = /*#__PURE__*/function () {
  // Initialize
  function SVGNumber() {
    _classCallCheck(this, SVGNumber);

    this.init.apply(this, arguments);
  }

  _createClass(SVGNumber, [{
    key: "init",
    value: function init(value, unit) {
      unit = Array.isArray(value) ? value[1] : unit;
      value = Array.isArray(value) ? value[0] : value; // initialize defaults

      this.value = 0;
      this.unit = unit || ''; // parse value

      if (typeof value === 'number') {
        // ensure a valid numeric value
        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;
      } else if (typeof value === 'string') {
        unit = value.match(numberAndUnit);

        if (unit) {
          // make value numeric
          this.value = parseFloat(unit[1]); // normalize

          if (unit[5] === '%') {
            this.value /= 100;
          } else if (unit[5] === 's') {
            this.value *= 1000;
          } // store unit


          this.unit = unit[5];
        }
      } else {
        if (value instanceof SVGNumber) {
          this.value = value.valueOf();
          this.unit = value.unit;
        }
      }

      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return (this.unit === '%' ? ~~(this.value * 1e8) / 1e6 : this.unit === 's' ? this.value / 1e3 : this.value) + this.unit;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.value, this.unit];
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    } // Add number

  }, {
    key: "plus",
    value: function plus(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this + number, this.unit || number.unit);
    } // Subtract number

  }, {
    key: "minus",
    value: function minus(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this - number, this.unit || number.unit);
    } // Multiply number

  }, {
    key: "times",
    value: function times(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this * number, this.unit || number.unit);
    } // Divide number

  }, {
    key: "divide",
    value: function divide(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this / number, this.unit || number.unit);
    }
  }, {
    key: "convert",
    value: function convert(unit) {
      return new SVGNumber(this.value, unit);
    }
  }]);

  return SVGNumber;
}();

exports.Number = SVGNumber;
var hooks = [];

function registerAttrHook(fn) {
  hooks.push(fn);
} // Set svg element attribute


function attr(attr, val, ns) {
  var _this = this; // act as full getter


  if (attr == null) {
    // get an object of attributes
    attr = {};
    val = this.node.attributes;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = val[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;
        attr[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return attr;
  } else if (attr instanceof Array) {
    // loop through array and get all values
    return attr.reduce(function (last, curr) {
      last[curr] = _this.attr(curr);
      return last;
    }, {});
  } else if (_typeof(attr) === 'object' && attr.constructor === Object) {
    // apply every attribute individually if an object is passed
    for (val in attr) {
      this.attr(val, attr[val]);
    }
  } else if (val === null) {
    // remove value
    this.node.removeAttribute(attr);
  } else if (val == null) {
    // act as a getter if the first and only argument is not an object
    val = this.node.getAttribute(attr);
    return val == null ? attrs[attr] : isNumber.test(val) ? parseFloat(val) : val;
  } else {
    // Loop through hooks and execute them to convert value
    val = hooks.reduce(function (_val, hook) {
      return hook(attr, _val, _this);
    }, val); // ensure correct numeric values (also accepts NaN and Infinity)

    if (typeof val === 'number') {
      val = new SVGNumber(val);
    } else if (Color.isColor(val)) {
      // ensure full hex color
      val = new Color(val);
    } else if (val.constructor === Array) {
      // Check for plain arrays and parse array values
      val = new SVGArray(val);
    } // if the passed attribute is leading...


    if (attr === 'leading') {
      // ... call the leading method instead
      if (this.leading) {
        this.leading(val);
      }
    } else {
      // set given attribute on node
      typeof ns === 'string' ? this.node.setAttributeNS(ns, attr, val.toString()) : this.node.setAttribute(attr, val.toString());
    } // rebuild if required


    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {
      this.rebuild();
    }
  }

  return this;
}

var Dom = /*#__PURE__*/function (_EventTarget) {
  _inherits(Dom, _EventTarget);

  function Dom(node, attrs) {
    var _this2;

    _classCallCheck(this, Dom);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Dom).call(this, node));
    _this2.node = node;
    _this2.type = node.nodeName;

    if (attrs && node !== attrs) {
      _this2.attr(attrs);
    }

    return _this2;
  } // Add given element at a position


  _createClass(Dom, [{
    key: "add",
    value: function add(element, i) {
      element = makeInstance(element);

      if (i == null) {
        this.node.appendChild(element.node);
      } else if (element.node !== this.node.childNodes[i]) {
        this.node.insertBefore(element.node, this.node.childNodes[i]);
      }

      return this;
    } // Add element to given container and return self

  }, {
    key: "addTo",
    value: function addTo(parent) {
      return makeInstance(parent).put(this);
    } // Returns all child elements

  }, {
    key: "children",
    value: function children() {
      return new List(map(this.node.children, function (node) {
        return adopt(node);
      }));
    } // Remove all elements in this container

  }, {
    key: "clear",
    value: function clear() {
      // remove children
      while (this.node.hasChildNodes()) {
        this.node.removeChild(this.node.lastChild);
      }

      return this;
    } // Clone element

  }, {
    key: "clone",
    value: function clone() {
      // write dom data to the dom so the clone can pickup the data
      this.writeDataToDom(); // clone element and assign new id

      return assignNewId(this.node.cloneNode(true));
    } // Iterates over all children and invokes a given block

  }, {
    key: "each",
    value: function each(block, deep) {
      var children = this.children();
      var i, il;

      for (i = 0, il = children.length; i < il; i++) {
        block.apply(children[i], [i, children]);

        if (deep) {
          children[i].each(block, deep);
        }
      }

      return this;
    }
  }, {
    key: "element",
    value: function element(nodeName) {
      return this.put(new Dom(create(nodeName)));
    } // Get first child

  }, {
    key: "first",
    value: function first() {
      return adopt(this.node.firstChild);
    } // Get a element at the given index

  }, {
    key: "get",
    value: function get(i) {
      return adopt(this.node.childNodes[i]);
    }
  }, {
    key: "getEventHolder",
    value: function getEventHolder() {
      return this.node;
    }
  }, {
    key: "getEventTarget",
    value: function getEventTarget() {
      return this.node;
    } // Checks if the given element is a child

  }, {
    key: "has",
    value: function has(element) {
      return this.index(element) >= 0;
    } // Get / set id

  }, {
    key: "id",
    value: function id(_id) {
      // generate new id if no id set
      if (typeof _id === 'undefined' && !this.node.id) {
        this.node.id = eid(this.type);
      } // dont't set directly width this.node.id to make `null` work correctly


      return this.attr('id', _id);
    } // Gets index of given element

  }, {
    key: "index",
    value: function index(element) {
      return [].slice.call(this.node.childNodes).indexOf(element.node);
    } // Get the last child

  }, {
    key: "last",
    value: function last() {
      return adopt(this.node.lastChild);
    } // matches the element vs a css selector

  }, {
    key: "matches",
    value: function matches(selector) {
      var el = this.node;
      return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
    } // Returns the parent element instance

  }, {
    key: "parent",
    value: function parent(type) {
      var parent = this; // check for parent

      if (!parent.node.parentNode) return null; // get parent element

      parent = adopt(parent.node.parentNode);
      if (!type) return parent; // loop trough ancestors if type is given

      while (parent) {
        if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;
        if (!parent.node.parentNode || parent.node.parentNode.nodeName === '#document' || parent.node.parentNode.nodeName === '#document-fragment') return null; // #759, #720

        parent = adopt(parent.node.parentNode);
      }
    } // Basically does the same as `add()` but returns the added element instead

  }, {
    key: "put",
    value: function put(element, i) {
      this.add(element, i);
      return element;
    } // Add element to given container and return container

  }, {
    key: "putIn",
    value: function putIn(parent) {
      return makeInstance(parent).add(this);
    } // Remove element

  }, {
    key: "remove",
    value: function remove() {
      if (this.parent()) {
        this.parent().removeElement(this);
      }

      return this;
    } // Remove a given child

  }, {
    key: "removeElement",
    value: function removeElement(element) {
      this.node.removeChild(element.node);
      return this;
    } // Replace this with element

  }, {
    key: "replace",
    value: function replace(element) {
      element = makeInstance(element);
      this.node.parentNode.replaceChild(element.node, this.node);
      return element;
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
      var map = arguments.length > 1 ? arguments[1] : undefined;
      var factor = Math.pow(10, precision);
      var attrs = this.attr(); // If we have no map, build one from attrs

      if (!map) {
        map = Object.keys(attrs);
      } // Holds rounded attributes


      var newAttrs = {};
      map.forEach(function (key) {
        newAttrs[key] = Math.round(attrs[key] * factor) / factor;
      });
      this.attr(newAttrs);
      return this;
    } // Return id on string conversion

  }, {
    key: "toString",
    value: function toString() {
      return this.id();
    } // Import raw svg

  }, {
    key: "svg",
    value: function svg(svgOrFn, outerHTML) {
      var well, len, fragment;

      if (svgOrFn === false) {
        outerHTML = false;
        svgOrFn = null;
      } // act as getter if no svg string is given


      if (svgOrFn == null || typeof svgOrFn === 'function') {
        // The default for exports is, that the outerNode is included
        outerHTML = outerHTML == null ? true : outerHTML; // write svgjs data to the dom

        this.writeDataToDom();
        var current = this; // An export modifier was passed

        if (svgOrFn != null) {
          current = adopt(current.node.cloneNode(true)); // If the user wants outerHTML we need to process this node, too

          if (outerHTML) {
            var result = svgOrFn(current);
            current = result || current; // The user does not want this node? Well, then he gets nothing

            if (result === false) return '';
          } // Deep loop through all children and apply modifier


          current.each(function () {
            var result = svgOrFn(this);

            var _this = result || this; // If modifier returns false, discard node


            if (result === false) {
              this.remove(); // If modifier returns new node, use it
            } else if (result && this !== _this) {
              this.replace(_this);
            }
          }, true);
        } // Return outer or inner content


        return outerHTML ? current.node.outerHTML : current.node.innerHTML;
      } // Act as setter if we got a string
      // The default for import is, that the current node is not replaced


      outerHTML = outerHTML == null ? false : outerHTML; // Create temporary holder

      well = globals.document.createElementNS(ns, 'svg');
      fragment = globals.document.createDocumentFragment(); // Dump raw svg

      well.innerHTML = svgOrFn; // Transplant nodes into the fragment

      for (len = well.children.length; len--;) {
        fragment.appendChild(well.firstElementChild);
      }

      var parent = this.parent(); // Add the whole fragment at once

      return outerHTML ? this.replace(fragment) && parent : this.add(fragment);
    }
  }, {
    key: "words",
    value: function words(text) {
      // This is faster than removing all children and adding a new one
      this.node.textContent = text;
      return this;
    } // write svgjs data to the dom

  }, {
    key: "writeDataToDom",
    value: function writeDataToDom() {
      // dump variables recursively
      this.each(function () {
        this.writeDataToDom();
      });
      return this;
    }
  }]);

  return Dom;
}(EventTarget);

exports.Dom = Dom;
extend(Dom, {
  attr: attr,
  find: find,
  findOne: findOne
});
register(Dom, 'Dom');

var Element = /*#__PURE__*/function (_Dom) {
  _inherits(Element, _Dom);

  function Element(node, attrs) {
    var _this;

    _classCallCheck(this, Element);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this, node, attrs)); // initialize data object

    _this.dom = {}; // create circular reference

    _this.node.instance = _assertThisInitialized(_this);

    if (node.hasAttribute('svgjs:data')) {
      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
      _this.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});
    }

    return _this;
  } // Move element by its center


  _createClass(Element, [{
    key: "center",
    value: function center(x, y) {
      return this.cx(x).cy(y);
    } // Move by center over x-axis

  }, {
    key: "cx",
    value: function cx(x) {
      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);
    } // Move by center over y-axis

  }, {
    key: "cy",
    value: function cy(y) {
      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);
    } // Get defs

  }, {
    key: "defs",
    value: function defs() {
      return this.root().defs();
    } // Relative move over x and y axes

  }, {
    key: "dmove",
    value: function dmove(x, y) {
      return this.dx(x).dy(y);
    } // Relative move over x axis

  }, {
    key: "dx",
    value: function dx() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.x(new SVGNumber(x).plus(this.x()));
    } // Relative move over y axis

  }, {
    key: "dy",
    value: function dy() {
      var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.y(new SVGNumber(y).plus(this.y()));
    } // Get parent document

  }, {
    key: "root",
    value: function root$1() {
      var p = this.parent(getClass(root));
      return p && p.root();
    }
  }, {
    key: "getEventHolder",
    value: function getEventHolder() {
      return this;
    } // Set height of element

  }, {
    key: "height",
    value: function height(_height) {
      return this.attr('height', _height);
    } // Checks whether the given point inside the bounding box of the element

  }, {
    key: "inside",
    value: function inside(x, y) {
      var box = this.bbox();
      return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;
    } // Move element to given x and y values

  }, {
    key: "move",
    value: function move(x, y) {
      return this.x(x).y(y);
    } // return array of all ancestors of given type up to the root svg

  }, {
    key: "parents",
    value: function parents() {
      var until = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : globals.document;
      until = makeInstance(until);
      var parents = new List();
      var parent = this;

      while ((parent = parent.parent()) && parent.node !== until.node && parent.node !== globals.document) {
        parents.push(parent);
      }

      return parents;
    } // Get referenced element form attribute value

  }, {
    key: "reference",
    value: function reference$1(attr) {
      attr = this.attr(attr);
      if (!attr) return null;
      var m = attr.match(reference);
      return m ? makeInstance(m[1]) : null;
    } // set given data to the elements data property

  }, {
    key: "setData",
    value: function setData(o) {
      this.dom = o;
      return this;
    } // Set element size to given width and height

  }, {
    key: "size",
    value: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height));
    } // Set width of element

  }, {
    key: "width",
    value: function width(_width) {
      return this.attr('width', _width);
    } // write svgjs data to the dom

  }, {
    key: "writeDataToDom",
    value: function writeDataToDom() {
      // remove previously set data
      this.node.removeAttribute('svgjs:data');

      if (Object.keys(this.dom).length) {
        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)); // see #428
      }

      return _get(_getPrototypeOf(Element.prototype), "writeDataToDom", this).call(this);
    } // Move over x-axis

  }, {
    key: "x",
    value: function x(_x) {
      return this.attr('x', _x);
    } // Move over y-axis

  }, {
    key: "y",
    value: function y(_y) {
      return this.attr('y', _y);
    }
  }]);

  return Element;
}(Dom);

exports.Element = Element;
extend(Element, {
  bbox: bbox,
  rbox: rbox,
  point: point,
  ctm: ctm,
  screenCTM: screenCTM
});
register(Element, 'Element');
var sugar = {
  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],
  fill: ['color', 'opacity', 'rule'],
  prefix: function prefix(t, a) {
    return a === 'color' ? t : t + '-' + a;
  }
} // Add sugar for fill and stroke
;
['fill', 'stroke'].forEach(function (m) {
  var extension = {};
  var i;

  extension[m] = function (o) {
    if (typeof o === 'undefined') {
      return this.attr(m);
    }

    if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || o instanceof Element) {
      this.attr(m, o);
    } else {
      // set all attributes from sugar.fill and sugar.stroke list
      for (i = sugar[m].length - 1; i >= 0; i--) {
        if (o[sugar[m][i]] != null) {
          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
        }
      }
    }

    return this;
  };

  registerMethods(['Element', 'Runner'], extension);
});
registerMethods(['Element', 'Runner'], {
  // Let the user set the matrix directly
  matrix: function matrix(mat, b, c, d, e, f) {
    // Act as a getter
    if (mat == null) {
      return new Matrix(this);
    } // Act as a setter, the user can pass a matrix or a set of numbers


    return this.attr('transform', new Matrix(mat, b, c, d, e, f));
  },
  // Map rotation to transform
  rotate: function rotate(angle, cx, cy) {
    return this.transform({
      rotate: angle,
      ox: cx,
      oy: cy
    }, true);
  },
  // Map skew to transform
  skew: function skew(x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({
      skew: x,
      ox: y,
      oy: cx
    }, true) : this.transform({
      skew: [x, y],
      ox: cx,
      oy: cy
    }, true);
  },
  shear: function shear(lam, cx, cy) {
    return this.transform({
      shear: lam,
      ox: cx,
      oy: cy
    }, true);
  },
  // Map scale to transform
  scale: function scale(x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({
      scale: x,
      ox: y,
      oy: cx
    }, true) : this.transform({
      scale: [x, y],
      ox: cx,
      oy: cy
    }, true);
  },
  // Map translate to transform
  translate: function translate(x, y) {
    return this.transform({
      translate: [x, y]
    }, true);
  },
  // Map relative translations to transform
  relative: function relative(x, y) {
    return this.transform({
      relative: [x, y]
    }, true);
  },
  // Map flip to transform
  flip: function flip(direction, around) {
    var directionString = typeof direction === 'string' ? direction : isFinite(direction) ? 'both' : 'both';
    var origin = direction === 'both' && isFinite(around) ? [around, around] : direction === 'x' ? [around, 0] : direction === 'y' ? [0, around] : isFinite(direction) ? [direction, direction] : [0, 0];
    return this.transform({
      flip: directionString,
      origin: origin
    }, true);
  },
  // Opacity
  opacity: function opacity(value) {
    return this.attr('opacity', value);
  }
});
registerMethods('radius', {
  // Add x and y radius
  radius: function radius(x, y) {
    var type = (this._element || this).type;
    return type === 'radialGradient' || type === 'radialGradient' ? this.attr('r', new SVGNumber(x)) : this.rx(x).ry(y == null ? x : y);
  }
});
registerMethods('Path', {
  // Get path length
  length: function length() {
    return this.node.getTotalLength();
  },
  // Get point at length
  pointAt: function pointAt(length) {
    return new Point(this.node.getPointAtLength(length));
  }
});
registerMethods(['Element', 'Runner'], {
  // Set font
  font: function font(a, v) {
    if (_typeof(a) === 'object') {
      for (v in a) {
        this.font(v, a[v]);
      }

      return this;
    }

    return a === 'leading' ? this.leading(v) : a === 'anchor' ? this.attr('text-anchor', v) : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style' ? this.attr('font-' + a, v) : this.attr(a, v);
  }
});
registerMethods('Text', {
  ax: function ax(x) {
    return this.attr('x', x);
  },
  ay: function ay(y) {
    return this.attr('y', y);
  },
  amove: function amove(x, y) {
    return this.ax(x).ay(y);
  }
}); // Add events to elements

var methods$1 = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].reduce(function (last, event) {
  // add event to Element
  var fn = function fn(f) {
    if (f === null) {
      off(this, event);
    } else {
      on(this, event, f);
    }

    return this;
  };

  last[event] = fn;
  return last;
}, {});
registerMethods('Element', methods$1);
var nativeReverse = [].reverse;
var test$1 = [1, 2]; // `Array.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794

_export({
  target: 'Array',
  proto: true,
  forced: String(test$1) === String(test$1.reverse())
}, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign
    if (isArray(this)) this.length = this.length;
    return nativeReverse.call(this);
  }
}); // `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties


_export({
  target: 'Object',
  stat: true,
  forced: !descriptors,
  sham: !descriptors
}, {
  defineProperties: objectDefineProperties
}); // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty


_export({
  target: 'Object',
  stat: true,
  forced: !descriptors,
  sham: !descriptors
}, {
  defineProperty: objectDefineProperty.f
});

var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var FAILS_ON_PRIMITIVES$2 = fails(function () {
  nativeGetOwnPropertyDescriptor$2(1);
});
var FORCED$3 = !descriptors || FAILS_ON_PRIMITIVES$2; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

_export({
  target: 'Object',
  stat: true,
  forced: FORCED$3,
  sham: !descriptors
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
  }
}); // `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors


_export({
  target: 'Object',
  stat: true,
  sham: !descriptors
}, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;

    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }

    return result;
  }
});

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function untransform() {
  return this.attr('transform', null);
} // merge the whole transformation chain into one matrix and returns it


function matrixify() {
  var matrix = (this.attr('transform') || ''). // split transformations
  split(transforms).slice(0, -1).map(function (str) {
    // generate key => value pairs
    var kv = str.trim().split('(');
    return [kv[0], kv[1].split(delimiter).map(function (str) {
      return parseFloat(str);
    })];
  }).reverse() // merge every transformation into one matrix
  .reduce(function (matrix, transform) {
    if (transform[0] === 'matrix') {
      return matrix.lmultiply(Matrix.fromArray(transform[1]));
    }

    return matrix[transform[0]].apply(matrix, transform[1]);
  }, new Matrix());
  return matrix;
} // add an element to another parent without changing the visual representation on the screen


function toParent(parent) {
  if (this === parent) return this;
  var ctm = this.screenCTM();
  var pCtm = parent.screenCTM().inverse();
  this.addTo(parent).untransform().transform(pCtm.multiply(ctm));
  return this;
} // same as above with parent equals root-svg


function toRoot() {
  return this.toParent(this.root());
} // Add transformations


function transform(o, relative) {
  // Act as a getter if no object was passed
  if (o == null || typeof o === 'string') {
    var decomposed = new Matrix(this).decompose();
    return o == null ? decomposed : decomposed[o];
  }

  if (!Matrix.isMatrixLike(o)) {
    // Set the origin according to the defined transform
    o = _objectSpread({}, o, {
      origin: getOrigin(o, this)
    });
  } // The user can pass a boolean, an Element or an Matrix or nothing


  var cleanRelative = relative === true ? this : relative || false;
  var result = new Matrix(cleanRelative).transform(o);
  return this.attr('transform', result);
}

registerMethods('Element', {
  untransform: untransform,
  matrixify: matrixify,
  toParent: toParent,
  toRoot: toRoot,
  transform: transform
});

function rx(rx) {
  return this.attr('rx', rx);
} // Radius y value


function ry(ry) {
  return this.attr('ry', ry);
} // Move over x-axis


function x(x) {
  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx());
} // Move over y-axis


function y(y) {
  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());
} // Move by center over x-axis


function cx(x) {
  return x == null ? this.attr('cx') : this.attr('cx', x);
} // Move by center over y-axis


function cy(y) {
  return y == null ? this.attr('cy') : this.attr('cy', y);
} // Set width of element


function width(width) {
  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2));
} // Set height of element


function height(height) {
  return height == null ? this.ry() * 2 : this.ry(new SVGNumber(height).divide(2));
}

var circled = {
  __proto__: null,
  rx: rx,
  ry: ry,
  x: x,
  y: y,
  cx: cx,
  cy: cy,
  width: width,
  height: height
};

var Shape = /*#__PURE__*/function (_Element) {
  _inherits(Shape, _Element);

  function Shape() {
    _classCallCheck(this, Shape);

    return _possibleConstructorReturn(this, _getPrototypeOf(Shape).apply(this, arguments));
  }

  return Shape;
}(Element);

exports.Shape = Shape;
register(Shape, 'Shape');

var Circle = /*#__PURE__*/function (_Shape) {
  _inherits(Circle, _Shape);

  function Circle(node) {
    _classCallCheck(this, Circle);

    return _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, nodeOrNew('circle', node), node));
  }

  _createClass(Circle, [{
    key: "radius",
    value: function radius(r) {
      return this.attr('r', r);
    } // Radius x value

  }, {
    key: "rx",
    value: function rx(_rx) {
      return this.attr('r', _rx);
    } // Alias radius x value

  }, {
    key: "ry",
    value: function ry(_ry) {
      return this.rx(_ry);
    }
  }, {
    key: "size",
    value: function size(_size) {
      return this.radius(new SVGNumber(_size).divide(2));
    }
  }]);

  return Circle;
}(Shape);

exports.Circle = Circle;
extend(Circle, {
  x: x,
  y: y,
  cx: cx,
  cy: cy,
  width: width,
  height: height
});
registerMethods({
  Container: {
    // Create circle element
    circle: wrapWithAttrCheck(function (size) {
      return this.put(new Circle()).size(size).move(0, 0);
    })
  }
});
register(Circle, 'Circle');

var Container = /*#__PURE__*/function (_Element) {
  _inherits(Container, _Element);

  function Container() {
    _classCallCheck(this, Container);

    return _possibleConstructorReturn(this, _getPrototypeOf(Container).apply(this, arguments));
  }

  _createClass(Container, [{
    key: "flatten",
    value: function flatten(parent) {
      this.each(function () {
        if (this instanceof Container) return this.flatten(parent).ungroup(parent);
        return this.toParent(parent);
      }); // we need this so that the root does not get removed

      this.node.firstElementChild || this.remove();
      return this;
    }
  }, {
    key: "ungroup",
    value: function ungroup(parent) {
      parent = parent || this.parent();
      this.each(function () {
        return this.toParent(parent);
      });
      this.remove();
      return this;
    }
  }]);

  return Container;
}(Element);

exports.Container = Container;
register(Container, 'Container');

var Defs = /*#__PURE__*/function (_Container) {
  _inherits(Defs, _Container);

  function Defs(node) {
    _classCallCheck(this, Defs);

    return _possibleConstructorReturn(this, _getPrototypeOf(Defs).call(this, nodeOrNew('defs', node), node));
  }

  _createClass(Defs, [{
    key: "flatten",
    value: function flatten() {
      return this;
    }
  }, {
    key: "ungroup",
    value: function ungroup() {
      return this;
    }
  }]);

  return Defs;
}(Container);

exports.Defs = Defs;
register(Defs, 'Defs');

var Ellipse = /*#__PURE__*/function (_Shape) {
  _inherits(Ellipse, _Shape);

  function Ellipse(node) {
    _classCallCheck(this, Ellipse);

    return _possibleConstructorReturn(this, _getPrototypeOf(Ellipse).call(this, nodeOrNew('ellipse', node), node));
  }

  _createClass(Ellipse, [{
    key: "size",
    value: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.rx(new SVGNumber(p.width).divide(2)).ry(new SVGNumber(p.height).divide(2));
    }
  }]);

  return Ellipse;
}(Shape);

exports.Ellipse = Ellipse;
extend(Ellipse, circled);
registerMethods('Container', {
  // Create an ellipse
  ellipse: wrapWithAttrCheck(function () {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
    return this.put(new Ellipse()).size(width, height).move(0, 0);
  })
});
register(Ellipse, 'Ellipse');

var Stop = /*#__PURE__*/function (_Element) {
  _inherits(Stop, _Element);

  function Stop(node) {
    _classCallCheck(this, Stop);

    return _possibleConstructorReturn(this, _getPrototypeOf(Stop).call(this, nodeOrNew('stop', node), node));
  } // add color stops


  _createClass(Stop, [{
    key: "update",
    value: function update(o) {
      if (typeof o === 'number' || o instanceof SVGNumber) {
        o = {
          offset: arguments[0],
          color: arguments[1],
          opacity: arguments[2]
        };
      } // set attributes


      if (o.opacity != null) this.attr('stop-opacity', o.opacity);
      if (o.color != null) this.attr('stop-color', o.color);
      if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));
      return this;
    }
  }]);

  return Stop;
}(Element);

exports.Stop = Stop;
register(Stop, 'Stop');

function from(x, y) {
  return (this._element || this).type === 'radialGradient' ? this.attr({
    fx: new SVGNumber(x),
    fy: new SVGNumber(y)
  }) : this.attr({
    x1: new SVGNumber(x),
    y1: new SVGNumber(y)
  });
}

function to(x, y) {
  return (this._element || this).type === 'radialGradient' ? this.attr({
    cx: new SVGNumber(x),
    cy: new SVGNumber(y)
  }) : this.attr({
    x2: new SVGNumber(x),
    y2: new SVGNumber(y)
  });
}

var gradiented = {
  __proto__: null,
  from: from,
  to: to
};

var Gradient = /*#__PURE__*/function (_Container) {
  _inherits(Gradient, _Container);

  function Gradient(type, attrs) {
    _classCallCheck(this, Gradient);

    return _possibleConstructorReturn(this, _getPrototypeOf(Gradient).call(this, nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type), attrs));
  } // Add a color stop


  _createClass(Gradient, [{
    key: "stop",
    value: function stop(offset, color, opacity) {
      return this.put(new Stop()).update(offset, color, opacity);
    } // Update gradient

  }, {
    key: "update",
    value: function update(block) {
      // remove all stops
      this.clear(); // invoke passed block

      if (typeof block === 'function') {
        block.call(this, this);
      }

      return this;
    } // Return the fill id

  }, {
    key: "url",
    value: function url() {
      return 'url(#' + this.id() + ')';
    } // Alias string convertion to fill

  }, {
    key: "toString",
    value: function toString() {
      return this.url();
    } // custom attr to handle transform

  }, {
    key: "attr",
    value: function attr(a, b, c) {
      if (a === 'transform') a = 'gradientTransform';
      return _get(_getPrototypeOf(Gradient.prototype), "attr", this).call(this, a, b, c);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg [fill*="' + this.id() + '"]');
    }
  }, {
    key: "bbox",
    value: function bbox() {
      return new Box();
    }
  }]);

  return Gradient;
}(Container);

exports.Gradient = Gradient;
extend(Gradient, gradiented);
registerMethods({
  Container: {
    // Create gradient element in defs
    gradient: wrapWithAttrCheck(function (type, block) {
      return this.defs().gradient(type, block);
    })
  },
  // define gradient
  Defs: {
    gradient: wrapWithAttrCheck(function (type, block) {
      return this.put(new Gradient(type)).update(block);
    })
  }
});
register(Gradient, 'Gradient');

var Pattern = /*#__PURE__*/function (_Container) {
  _inherits(Pattern, _Container); // Initialize node


  function Pattern(node) {
    _classCallCheck(this, Pattern);

    return _possibleConstructorReturn(this, _getPrototypeOf(Pattern).call(this, nodeOrNew('pattern', node), node));
  } // Return the fill id


  _createClass(Pattern, [{
    key: "url",
    value: function url() {
      return 'url(#' + this.id() + ')';
    } // Update pattern by rebuilding

  }, {
    key: "update",
    value: function update(block) {
      // remove content
      this.clear(); // invoke passed block

      if (typeof block === 'function') {
        block.call(this, this);
      }

      return this;
    } // Alias string convertion to fill

  }, {
    key: "toString",
    value: function toString() {
      return this.url();
    } // custom attr to handle transform

  }, {
    key: "attr",
    value: function attr(a, b, c) {
      if (a === 'transform') a = 'patternTransform';
      return _get(_getPrototypeOf(Pattern.prototype), "attr", this).call(this, a, b, c);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg [fill*="' + this.id() + '"]');
    }
  }, {
    key: "bbox",
    value: function bbox() {
      return new Box();
    }
  }]);

  return Pattern;
}(Container);

exports.Pattern = Pattern;
registerMethods({
  Container: {
    // Create pattern element in defs
    pattern: function pattern() {
      var _this$defs;

      return (_this$defs = this.defs()).pattern.apply(_this$defs, arguments);
    }
  },
  Defs: {
    pattern: wrapWithAttrCheck(function (width, height, block) {
      return this.put(new Pattern()).update(block).attr({
        x: 0,
        y: 0,
        width: width,
        height: height,
        patternUnits: 'userSpaceOnUse'
      });
    })
  }
});
register(Pattern, 'Pattern');

var Image = /*#__PURE__*/function (_Shape) {
  _inherits(Image, _Shape);

  function Image(node) {
    _classCallCheck(this, Image);

    return _possibleConstructorReturn(this, _getPrototypeOf(Image).call(this, nodeOrNew('image', node), node));
  } // (re)load image


  _createClass(Image, [{
    key: "load",
    value: function load(url, callback) {
      if (!url) return this;
      var img = new globals.window.Image();
      on(img, 'load', function (e) {
        var p = this.parent(Pattern); // ensure image size

        if (this.width() === 0 && this.height() === 0) {
          this.size(img.width, img.height);
        }

        if (p instanceof Pattern) {
          // ensure pattern size if not set
          if (p.width() === 0 && p.height() === 0) {
            p.size(this.width(), this.height());
          }
        }

        if (typeof callback === 'function') {
          callback.call(this, e);
        }
      }, this);
      on(img, 'load error', function () {
        // dont forget to unbind memory leaking events
        off(img);
      });
      return this.attr('href', img.src = url, xlink);
    }
  }]);

  return Image;
}(Shape);

exports.Image = Image;
registerAttrHook(function (attr, val, _this) {
  // convert image fill and stroke to patterns
  if (attr === 'fill' || attr === 'stroke') {
    if (isImage.test(val)) {
      val = _this.root().defs().image(val);
    }
  }

  if (val instanceof Image) {
    val = _this.root().defs().pattern(0, 0, function (pattern) {
      pattern.add(val);
    });
  }

  return val;
});
registerMethods({
  Container: {
    // create image element, load image and set its size
    image: wrapWithAttrCheck(function (source, callback) {
      return this.put(new Image()).size(0, 0).load(source, callback);
    })
  }
});
register(Image, 'Image');
var PointArray = subClassArray('PointArray', SVGArray);
exports.PointArray = PointArray;
extend(PointArray, {
  // Convert array to string
  toString: function toString() {
    // convert to a poly point string
    for (var i = 0, il = this.length, array = []; i < il; i++) {
      array.push(this[i].join(','));
    }

    return array.join(' ');
  },
  // Convert array to line object
  toLine: function toLine() {
    return {
      x1: this[0][0],
      y1: this[0][1],
      x2: this[1][0],
      y2: this[1][1]
    };
  },
  // Get morphed array at given position
  at: function at(pos) {
    // make sure a destination is defined
    if (!this.destination) return this; // generate morphed point string

    for (var i = 0, il = this.length, array = []; i < il; i++) {
      array.push([this[i][0] + (this.destination[i][0] - this[i][0]) * pos, this[i][1] + (this.destination[i][1] - this[i][1]) * pos]);
    }

    return new PointArray(array);
  },
  // Parse point string and flat array
  parse: function parse() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[0, 0]];
    var points = []; // if it is an array

    if (array instanceof Array) {
      // and it is not flat, there is no need to parse it
      if (array[0] instanceof Array) {
        return array;
      }
    } else {
      // Else, it is considered as a string
      // parse points
      array = array.trim().split(delimiter).map(parseFloat);
    } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.


    if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples

    for (var i = 0, len = array.length; i < len; i = i + 2) {
      points.push([array[i], array[i + 1]]);
    }

    return points;
  },
  // transform points with matrix (similar to Point.transform)
  transform: function transform(m) {
    var points = [];

    for (var i = 0; i < this.length; i++) {
      var point = this[i]; // Perform the matrix multiplication

      points.push([m.a * point[0] + m.c * point[1] + m.e, m.b * point[0] + m.d * point[1] + m.f]);
    } // Return the required point


    return new PointArray(points);
  },
  // Move point string
  move: function move(x, y) {
    var box = this.bbox(); // get relative offset

    x -= box.x;
    y -= box.y; // move every point

    if (!isNaN(x) && !isNaN(y)) {
      for (var i = this.length - 1; i >= 0; i--) {
        this[i] = [this[i][0] + x, this[i][1] + y];
      }
    }

    return this;
  },
  // Resize poly string
  size: function size(width, height) {
    var i;
    var box = this.bbox(); // recalculate position of all points according to new size

    for (i = this.length - 1; i >= 0; i--) {
      if (box.width) this[i][0] = (this[i][0] - box.x) * width / box.width + box.x;
      if (box.height) this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
    }

    return this;
  },
  // Get bounding box of points
  bbox: function bbox() {
    var maxX = -Infinity;
    var maxY = -Infinity;
    var minX = Infinity;
    var minY = Infinity;
    this.forEach(function (el) {
      maxX = Math.max(el[0], maxX);
      maxY = Math.max(el[1], maxY);
      minX = Math.min(el[0], minX);
      minY = Math.min(el[1], minY);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
});
var MorphArray = PointArray; // Move by left top corner over x-axis

function x$1(x) {
  return x == null ? this.bbox().x : this.move(x, this.bbox().y);
} // Move by left top corner over y-axis


function y$1(y) {
  return y == null ? this.bbox().y : this.move(this.bbox().x, y);
} // Set width of element


function width$1(width) {
  var b = this.bbox();
  return width == null ? b.width : this.size(width, b.height);
} // Set height of element


function height$1(height) {
  var b = this.bbox();
  return height == null ? b.height : this.size(b.width, height);
}

var pointed = {
  __proto__: null,
  MorphArray: MorphArray,
  x: x$1,
  y: y$1,
  width: width$1,
  height: height$1
};

var Line = /*#__PURE__*/function (_Shape) {
  _inherits(Line, _Shape); // Initialize node


  function Line(node) {
    _classCallCheck(this, Line);

    return _possibleConstructorReturn(this, _getPrototypeOf(Line).call(this, nodeOrNew('line', node), node));
  } // Get array


  _createClass(Line, [{
    key: "array",
    value: function array() {
      return new PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);
    } // Overwrite native plot() method

  }, {
    key: "plot",
    value: function plot(x1, y1, x2, y2) {
      if (x1 == null) {
        return this.array();
      } else if (typeof y1 !== 'undefined') {
        x1 = {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        };
      } else {
        x1 = new PointArray(x1).toLine();
      }

      return this.attr(x1);
    } // Move by left top corner

  }, {
    key: "move",
    value: function move(x, y) {
      return this.attr(this.array().move(x, y).toLine());
    } // Set element size to given width and height

  }, {
    key: "size",
    value: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.attr(this.array().size(p.width, p.height).toLine());
    }
  }]);

  return Line;
}(Shape);

exports.Line = Line;
extend(Line, pointed);
registerMethods({
  Container: {
    // Create a line element
    line: wrapWithAttrCheck(function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      } // make sure plot is called as a setter
      // x1 is not necessarily a number, it can also be an array, a string and a PointArray


      return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);
    })
  }
});
register(Line, 'Line');

var Marker = /*#__PURE__*/function (_Container) {
  _inherits(Marker, _Container); // Initialize node


  function Marker(node) {
    _classCallCheck(this, Marker);

    return _possibleConstructorReturn(this, _getPrototypeOf(Marker).call(this, nodeOrNew('marker', node), node));
  } // Set width of element


  _createClass(Marker, [{
    key: "width",
    value: function width(_width) {
      return this.attr('markerWidth', _width);
    } // Set height of element

  }, {
    key: "height",
    value: function height(_height) {
      return this.attr('markerHeight', _height);
    } // Set marker refX and refY

  }, {
    key: "ref",
    value: function ref(x, y) {
      return this.attr('refX', x).attr('refY', y);
    } // Update marker

  }, {
    key: "update",
    value: function update(block) {
      // remove all content
      this.clear(); // invoke passed block

      if (typeof block === 'function') {
        block.call(this, this);
      }

      return this;
    } // Return the fill id

  }, {
    key: "toString",
    value: function toString() {
      return 'url(#' + this.id() + ')';
    }
  }]);

  return Marker;
}(Container);

exports.Marker = Marker;
registerMethods({
  Container: {
    marker: function marker() {
      var _this$defs; // Create marker element in defs


      return (_this$defs = this.defs()).marker.apply(_this$defs, arguments);
    }
  },
  Defs: {
    // Create marker
    marker: wrapWithAttrCheck(function (width, height, block) {
      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
      return this.put(new Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);
    })
  },
  marker: {
    // Create and attach markers
    marker: function marker(_marker, width, height, block) {
      var attr = ['marker']; // Build attribute name

      if (_marker !== 'all') attr.push(_marker);
      attr = attr.join('-'); // Set marker attribute

      _marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width, height, block);
      return this.attr(attr, _marker);
    }
  }
});
register(Marker, 'Marker');
var nativeSort = [].sort;
var test$2 = [1, 2, 3]; // IE8-

var FAILS_ON_UNDEFINED = fails(function () {
  test$2.sort(undefined);
}); // V8 bug

var FAILS_ON_NULL = fails(function () {
  test$2.sort(null);
}); // Old WebKit

var SLOPPY_METHOD$2 = sloppyArrayMethod('sort');
var FORCED$4 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD$2; // `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort

_export({
  target: 'Array',
  proto: true,
  forced: FORCED$4
}, {
  sort: function sort(comparefn) {
    return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction$1(comparefn));
  }
});
/***
Base Class
==========
The base stepper class that will be
***/


function makeSetterGetter(k, f) {
  return function (v) {
    if (v == null) return this[v];
    this[k] = v;
    if (f) f.call(this);
    return this;
  };
}

var easing = {
  '-': function _(pos) {
    return pos;
  },
  '<>': function _(pos) {
    return -Math.cos(pos * Math.PI) / 2 + 0.5;
  },
  '>': function _(pos) {
    return Math.sin(pos * Math.PI / 2);
  },
  '<': function _(pos) {
    return -Math.cos(pos * Math.PI / 2) + 1;
  },
  bezier: function bezier(x1, y1, x2, y2) {
    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo
    return function (t) {
      if (t < 0) {
        if (x1 > 0) {
          return y1 / x1 * t;
        } else if (x2 > 0) {
          return y2 / x2 * t;
        } else {
          return 0;
        }
      } else if (t > 1) {
        if (x2 < 1) {
          return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2);
        } else if (x1 < 1) {
          return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);
        } else {
          return 1;
        }
      } else {
        return 3 * t * Math.pow(1 - t, 2) * y1 + 3 * Math.pow(t, 2) * (1 - t) * y2 + Math.pow(t, 3);
      }
    };
  },
  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo
  steps: function steps(_steps) {
    var stepPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'end'; // deal with "jump-" prefix

    stepPosition = stepPosition.split('-').reverse()[0];
    var jumps = _steps;

    if (stepPosition === 'none') {
      --jumps;
    } else if (stepPosition === 'both') {
      ++jumps;
    } // The beforeFlag is essentially useless


    return function (t) {
      var beforeFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // Step is called currentStep in referenced url

      var step = Math.floor(t * _steps);
      var jumping = t * step % 1 === 0;

      if (stepPosition === 'start' || stepPosition === 'both') {
        ++step;
      }

      if (beforeFlag && jumping) {
        --step;
      }

      if (t >= 0 && step < 0) {
        step = 0;
      }

      if (t <= 1 && step > jumps) {
        step = jumps;
      }

      return step / jumps;
    };
  }
};
exports.easing = easing;

var Stepper = /*#__PURE__*/function () {
  function Stepper() {
    _classCallCheck(this, Stepper);
  }

  _createClass(Stepper, [{
    key: "done",
    value: function done() {
      return false;
    }
  }]);

  return Stepper;
}();
/***
Easing Functions
================
***/


var Ease = /*#__PURE__*/function (_Stepper) {
  _inherits(Ease, _Stepper);

  function Ease(fn) {
    var _this;

    _classCallCheck(this, Ease);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Ease).call(this));
    _this.ease = easing[fn || timeline.ease] || fn;
    return _this;
  }

  _createClass(Ease, [{
    key: "step",
    value: function step(from, to, pos) {
      if (typeof from !== 'number') {
        return pos < 1 ? from : to;
      }

      return from + (to - from) * this.ease(pos);
    }
  }]);

  return Ease;
}(Stepper);
/***
Controller Types
================
***/


exports.Ease = Ease;

var Controller = /*#__PURE__*/function (_Stepper2) {
  _inherits(Controller, _Stepper2);

  function Controller(fn) {
    var _this2;

    _classCallCheck(this, Controller);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Controller).call(this));
    _this2.stepper = fn;
    return _this2;
  }

  _createClass(Controller, [{
    key: "step",
    value: function step(current, target, dt, c) {
      return this.stepper(current, target, dt, c);
    }
  }, {
    key: "done",
    value: function done(c) {
      return c.done;
    }
  }]);

  return Controller;
}(Stepper);

exports.Controller = Controller;

function recalculate() {
  // Apply the default parameters
  var duration = (this._duration || 500) / 1000;
  var overshoot = this._overshoot || 0; // Calculate the PID natural response

  var eps = 1e-10;
  var pi = Math.PI;
  var os = Math.log(overshoot / 100 + eps);
  var zeta = -os / Math.sqrt(pi * pi + os * os);
  var wn = 3.9 / (zeta * duration); // Calculate the Spring values

  this.d = 2 * zeta * wn;
  this.k = wn * wn;
}

var Spring = /*#__PURE__*/function (_Controller) {
  _inherits(Spring, _Controller);

  function Spring(duration, overshoot) {
    var _this3;

    _classCallCheck(this, Spring);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Spring).call(this));

    _this3.duration(duration || 500).overshoot(overshoot || 0);

    return _this3;
  }

  _createClass(Spring, [{
    key: "step",
    value: function step(current, target, dt, c) {
      if (typeof current === 'string') return current;
      c.done = dt === Infinity;
      if (dt === Infinity) return target;
      if (dt === 0) return current;
      if (dt > 100) dt = 16;
      dt /= 1000; // Get the previous velocity

      var velocity = c.velocity || 0; // Apply the control to get the new position and store it

      var acceleration = -this.d * velocity - this.k * (current - target);
      var newPosition = current + velocity * dt + acceleration * dt * dt / 2; // Store the velocity

      c.velocity = velocity + acceleration * dt; // Figure out if we have converged, and if so, pass the value

      c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;
      return c.done ? target : newPosition;
    }
  }]);

  return Spring;
}(Controller);

exports.Spring = Spring;
extend(Spring, {
  duration: makeSetterGetter('_duration', recalculate),
  overshoot: makeSetterGetter('_overshoot', recalculate)
});

var PID = /*#__PURE__*/function (_Controller2) {
  _inherits(PID, _Controller2);

  function PID(p, i, d, windup) {
    var _this4;

    _classCallCheck(this, PID);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PID).call(this));
    p = p == null ? 0.1 : p;
    i = i == null ? 0.01 : i;
    d = d == null ? 0 : d;
    windup = windup == null ? 1000 : windup;

    _this4.p(p).i(i).d(d).windup(windup);

    return _this4;
  }

  _createClass(PID, [{
    key: "step",
    value: function step(current, target, dt, c) {
      if (typeof current === 'string') return current;
      c.done = dt === Infinity;
      if (dt === Infinity) return target;
      if (dt === 0) return current;
      var p = target - current;
      var i = (c.integral || 0) + p * dt;
      var d = (p - (c.error || 0)) / dt;
      var windup = this.windup; // antiwindup

      if (windup !== false) {
        i = Math.max(-windup, Math.min(i, windup));
      }

      c.error = p;
      c.integral = i;
      c.done = Math.abs(p) < 0.001;
      return c.done ? target : current + (this.P * p + this.I * i + this.D * d);
    }
  }]);

  return PID;
}(Controller);

exports.PID = PID;
extend(PID, {
  windup: makeSetterGetter('windup'),
  p: makeSetterGetter('P'),
  i: makeSetterGetter('I'),
  d: makeSetterGetter('D')
});
var PathArray = subClassArray('PathArray', SVGArray);
exports.PathArray = PathArray;

function pathRegReplace(a, b, c, d) {
  return c + d.replace(dots, ' .');
}

function arrayToString(a) {
  for (var i = 0, il = a.length, s = ''; i < il; i++) {
    s += a[i][0];

    if (a[i][1] != null) {
      s += a[i][1];

      if (a[i][2] != null) {
        s += ' ';
        s += a[i][2];

        if (a[i][3] != null) {
          s += ' ';
          s += a[i][3];
          s += ' ';
          s += a[i][4];

          if (a[i][5] != null) {
            s += ' ';
            s += a[i][5];
            s += ' ';
            s += a[i][6];

            if (a[i][7] != null) {
              s += ' ';
              s += a[i][7];
            }
          }
        }
      }
    }
  }

  return s + ' ';
}

var pathHandlers = {
  M: function M(c, p, p0) {
    p.x = p0.x = c[0];
    p.y = p0.y = c[1];
    return ['M', p.x, p.y];
  },
  L: function L(c, p) {
    p.x = c[0];
    p.y = c[1];
    return ['L', c[0], c[1]];
  },
  H: function H(c, p) {
    p.x = c[0];
    return ['H', c[0]];
  },
  V: function V(c, p) {
    p.y = c[0];
    return ['V', c[0]];
  },
  C: function C(c, p) {
    p.x = c[4];
    p.y = c[5];
    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];
  },
  S: function S(c, p) {
    p.x = c[2];
    p.y = c[3];
    return ['S', c[0], c[1], c[2], c[3]];
  },
  Q: function Q(c, p) {
    p.x = c[2];
    p.y = c[3];
    return ['Q', c[0], c[1], c[2], c[3]];
  },
  T: function T(c, p) {
    p.x = c[0];
    p.y = c[1];
    return ['T', c[0], c[1]];
  },
  Z: function Z(c, p, p0) {
    p.x = p0.x;
    p.y = p0.y;
    return ['Z'];
  },
  A: function A(c, p) {
    p.x = c[5];
    p.y = c[6];
    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];
  }
};
var mlhvqtcsaz = 'mlhvqtcsaz'.split('');

for (var i = 0, il = mlhvqtcsaz.length; i < il; ++i) {
  pathHandlers[mlhvqtcsaz[i]] = function (i) {
    return function (c, p, p0) {
      if (i === 'H') c[0] = c[0] + p.x;else if (i === 'V') c[0] = c[0] + p.y;else if (i === 'A') {
        c[5] = c[5] + p.x;
        c[6] = c[6] + p.y;
      } else {
        for (var j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j % 2 ? p.y : p.x);
        }
      }
      return pathHandlers[i](c, p, p0);
    };
  }(mlhvqtcsaz[i].toUpperCase());
}

extend(PathArray, {
  // Convert array to string
  toString: function toString() {
    return arrayToString(this);
  },
  // Move path string
  move: function move(x, y) {
    // get bounding box of current situation
    var box = this.bbox(); // get relative offset

    x -= box.x;
    y -= box.y;

    if (!isNaN(x) && !isNaN(y)) {
      // move every point
      for (var l, i = this.length - 1; i >= 0; i--) {
        l = this[i][0];

        if (l === 'M' || l === 'L' || l === 'T') {
          this[i][1] += x;
          this[i][2] += y;
        } else if (l === 'H') {
          this[i][1] += x;
        } else if (l === 'V') {
          this[i][1] += y;
        } else if (l === 'C' || l === 'S' || l === 'Q') {
          this[i][1] += x;
          this[i][2] += y;
          this[i][3] += x;
          this[i][4] += y;

          if (l === 'C') {
            this[i][5] += x;
            this[i][6] += y;
          }
        } else if (l === 'A') {
          this[i][6] += x;
          this[i][7] += y;
        }
      }
    }

    return this;
  },
  // Resize path string
  size: function size(width, height) {
    // get bounding box of current situation
    var box = this.bbox();
    var i, l; // If the box width or height is 0 then we ignore
    // transformations on the respective axis

    box.width = box.width === 0 ? 1 : box.width;
    box.height = box.height === 0 ? 1 : box.height; // recalculate position of all points according to new size

    for (i = this.length - 1; i >= 0; i--) {
      l = this[i][0];

      if (l === 'M' || l === 'L' || l === 'T') {
        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
      } else if (l === 'H') {
        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
      } else if (l === 'V') {
        this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
      } else if (l === 'C' || l === 'S' || l === 'Q') {
        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
        this[i][3] = (this[i][3] - box.x) * width / box.width + box.x;
        this[i][4] = (this[i][4] - box.y) * height / box.height + box.y;

        if (l === 'C') {
          this[i][5] = (this[i][5] - box.x) * width / box.width + box.x;
          this[i][6] = (this[i][6] - box.y) * height / box.height + box.y;
        }
      } else if (l === 'A') {
        // resize radii
        this[i][1] = this[i][1] * width / box.width;
        this[i][2] = this[i][2] * height / box.height; // move position values

        this[i][6] = (this[i][6] - box.x) * width / box.width + box.x;
        this[i][7] = (this[i][7] - box.y) * height / box.height + box.y;
      }
    }

    return this;
  },
  // Test if the passed path array use the same path data commands as this path array
  equalCommands: function equalCommands(pathArray) {
    var i, il, equalCommands;
    pathArray = new PathArray(pathArray);
    equalCommands = this.length === pathArray.length;

    for (i = 0, il = this.length; equalCommands && i < il; i++) {
      equalCommands = this[i][0] === pathArray[i][0];
    }

    return equalCommands;
  },
  // Make path array morphable
  morph: function morph(pathArray) {
    pathArray = new PathArray(pathArray);

    if (this.equalCommands(pathArray)) {
      this.destination = pathArray;
    } else {
      this.destination = null;
    }

    return this;
  },
  // Get morphed path array at given position
  at: function at(pos) {
    // make sure a destination is defined
    if (!this.destination) return this;
    var sourceArray = this;
    var destinationArray = this.destination.value;
    var array = [];
    var pathArray = new PathArray();
    var i, il, j, jl; // Animate has specified in the SVG spec
    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement

    for (i = 0, il = sourceArray.length; i < il; i++) {
      array[i] = [sourceArray[i][0]];

      for (j = 1, jl = sourceArray[i].length; j < jl; j++) {
        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;
      } // For the two flags of the elliptical arc command, the SVG spec say:
      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true
      // Elliptical arc command as an array followed by corresponding indexes:
      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
      //   0    1   2        3                 4             5      6  7


      if (array[i][0] === 'A') {
        array[i][4] = +(array[i][4] !== 0);
        array[i][5] = +(array[i][5] !== 0);
      }
    } // Directly modify the value of a path array, this is done this way for performance


    pathArray.value = array;
    return pathArray;
  },
  // Absolutize and parse path to array
  parse: function parse() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [['M', 0, 0]]; // if it's already a patharray, no need to parse it

    if (array instanceof PathArray) return array; // prepare for parsing

    var s;
    var paramCnt = {
      M: 2,
      L: 2,
      H: 1,
      V: 1,
      C: 6,
      S: 4,
      Q: 4,
      T: 2,
      A: 7,
      Z: 0
    };

    if (typeof array === 'string') {
      array = array.replace(numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123
      .replace(pathLetters, ' $& ') // put some room between letters and numbers
      .replace(hyphen, '$1 -') // add space before hyphen
      .trim() // trim
      .split(delimiter); // split into array
    } else {
      array = array.reduce(function (prev, curr) {
        return [].concat.call(prev, curr);
      }, []);
    } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]


    var result = [];
    var p = new Point();
    var p0 = new Point();
    var index = 0;
    var len = array.length;

    do {
      // Test if we have a path letter
      if (isPathLetter.test(array[index])) {
        s = array[index];
        ++index; // If last letter was a move command and we got no new, it defaults to [L]ine
      } else if (s === 'M') {
        s = 'L';
      } else if (s === 'm') {
        s = 'l';
      }

      result.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));
    } while (len > index);

    return result;
  },
  // Get bounding box of path
  bbox: function bbox() {
    parser().path.setAttribute('d', this.toString());
    return parser.nodes.path.getBBox();
  }
});

var Morphable = /*#__PURE__*/function () {
  function Morphable(stepper) {
    _classCallCheck(this, Morphable);

    this._stepper = stepper || new Ease('-');
    this._from = null;
    this._to = null;
    this._type = null;
    this._context = null;
    this._morphObj = null;
  }

  _createClass(Morphable, [{
    key: "from",
    value: function from(val) {
      if (val == null) {
        return this._from;
      }

      this._from = this._set(val);
      return this;
    }
  }, {
    key: "to",
    value: function to(val) {
      if (val == null) {
        return this._to;
      }

      this._to = this._set(val);
      return this;
    }
  }, {
    key: "type",
    value: function type(_type) {
      // getter
      if (_type == null) {
        return this._type;
      } // setter


      this._type = _type;
      return this;
    }
  }, {
    key: "_set",
    value: function _set(value) {
      if (!this._type) {
        var type = _typeof(value);

        if (type === 'number') {
          this.type(SVGNumber);
        } else if (type === 'string') {
          if (Color.isColor(value)) {
            this.type(Color);
          } else if (delimiter.test(value)) {
            this.type(pathLetters.test(value) ? PathArray : SVGArray);
          } else if (numberAndUnit.test(value)) {
            this.type(SVGNumber);
          } else {
            this.type(NonMorphable);
          }
        } else if (morphableTypes.indexOf(value.constructor) > -1) {
          this.type(value.constructor);
        } else if (Array.isArray(value)) {
          this.type(SVGArray);
        } else if (type === 'object') {
          this.type(ObjectBag);
        } else {
          this.type(NonMorphable);
        }
      }

      var result = new this._type(value);

      if (this._type === Color) {
        result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;
      }

      result = result.toArray();
      this._morphObj = this._morphObj || new this._type();
      this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function (o) {
        o.done = true;
        return o;
      });
      return result;
    }
  }, {
    key: "stepper",
    value: function stepper(_stepper) {
      if (_stepper == null) return this._stepper;
      this._stepper = _stepper;
      return this;
    }
  }, {
    key: "done",
    value: function done() {
      var complete = this._context.map(this._stepper.done).reduce(function (last, curr) {
        return last && curr;
      }, true);

      return complete;
    }
  }, {
    key: "at",
    value: function at(pos) {
      var _this = this;

      return this._morphObj.fromArray(this._from.map(function (i, index) {
        return _this._stepper.step(i, _this._to[index], pos, _this._context[index], _this._context);
      }));
    }
  }]);

  return Morphable;
}();

exports.Morphable = Morphable;

var NonMorphable = /*#__PURE__*/function () {
  function NonMorphable() {
    _classCallCheck(this, NonMorphable);

    this.init.apply(this, arguments);
  }

  _createClass(NonMorphable, [{
    key: "init",
    value: function init(val) {
      val = Array.isArray(val) ? val[0] : val;
      this.value = val;
      return this;
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.value];
    }
  }]);

  return NonMorphable;
}();

exports.NonMorphable = NonMorphable;

var TransformBag = /*#__PURE__*/function () {
  function TransformBag() {
    _classCallCheck(this, TransformBag);

    this.init.apply(this, arguments);
  }

  _createClass(TransformBag, [{
    key: "init",
    value: function init(obj) {
      if (Array.isArray(obj)) {
        obj = {
          scaleX: obj[0],
          scaleY: obj[1],
          shear: obj[2],
          rotate: obj[3],
          translateX: obj[4],
          translateY: obj[5],
          originX: obj[6],
          originY: obj[7]
        };
      }

      Object.assign(this, TransformBag.defaults, obj);
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var v = this;
      return [v.scaleX, v.scaleY, v.shear, v.rotate, v.translateX, v.translateY, v.originX, v.originY];
    }
  }]);

  return TransformBag;
}();

exports.TransformBag = TransformBag;
TransformBag.defaults = {
  scaleX: 1,
  scaleY: 1,
  shear: 0,
  rotate: 0,
  translateX: 0,
  translateY: 0,
  originX: 0,
  originY: 0
};

var ObjectBag = /*#__PURE__*/function () {
  function ObjectBag() {
    _classCallCheck(this, ObjectBag);

    this.init.apply(this, arguments);
  }

  _createClass(ObjectBag, [{
    key: "init",
    value: function init(objOrArr) {
      this.values = [];

      if (Array.isArray(objOrArr)) {
        this.values = objOrArr;
        return;
      }

      objOrArr = objOrArr || {};
      var entries = [];

      for (var i in objOrArr) {
        entries.push([i, objOrArr[i]]);
      }

      entries.sort(function (a, b) {
        return a[0] - b[0];
      });
      this.values = entries.reduce(function (last, curr) {
        return last.concat(curr);
      }, []);
      return this;
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      var obj = {};
      var arr = this.values;

      for (var i = 0, len = arr.length; i < len; i += 2) {
        obj[arr[i]] = arr[i + 1];
      }

      return obj;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return this.values;
    }
  }]);

  return ObjectBag;
}();

exports.ObjectBag = ObjectBag;
var morphableTypes = [NonMorphable, TransformBag, ObjectBag];

function registerMorphableType() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  morphableTypes.push.apply(morphableTypes, _toConsumableArray([].concat(type)));
}

function makeMorphable() {
  extend(morphableTypes, {
    to: function to(val) {
      return new Morphable().type(this.constructor).from(this.valueOf()).to(val);
    },
    fromArray: function fromArray(arr) {
      this.init(arr);
      return this;
    }
  });
}

var Path = /*#__PURE__*/function (_Shape) {
  _inherits(Path, _Shape); // Initialize node


  function Path(node) {
    _classCallCheck(this, Path);

    return _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, nodeOrNew('path', node), node));
  } // Get array


  _createClass(Path, [{
    key: "array",
    value: function array() {
      return this._array || (this._array = new PathArray(this.attr('d')));
    } // Plot new path

  }, {
    key: "plot",
    value: function plot(d) {
      return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new PathArray(d));
    } // Clear array cache

  }, {
    key: "clear",
    value: function clear() {
      delete this._array;
      return this;
    } // Move by left top corner

  }, {
    key: "move",
    value: function move(x, y) {
      return this.attr('d', this.array().move(x, y));
    } // Move by left top corner over x-axis

  }, {
    key: "x",
    value: function x(_x) {
      return _x == null ? this.bbox().x : this.move(_x, this.bbox().y);
    } // Move by left top corner over y-axis

  }, {
    key: "y",
    value: function y(_y) {
      return _y == null ? this.bbox().y : this.move(this.bbox().x, _y);
    } // Set element size to given width and height

  }, {
    key: "size",
    value: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.attr('d', this.array().size(p.width, p.height));
    } // Set width of element

  }, {
    key: "width",
    value: function width(_width) {
      return _width == null ? this.bbox().width : this.size(_width, this.bbox().height);
    } // Set height of element

  }, {
    key: "height",
    value: function height(_height) {
      return _height == null ? this.bbox().height : this.size(this.bbox().width, _height);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg textpath [href*="' + this.id() + '"]');
    }
  }]);

  return Path;
}(Shape); // Define morphable array


exports.Path = Path;
Path.prototype.MorphArray = PathArray; // Add parent method

registerMethods({
  Container: {
    // Create a wrapped path element
    path: wrapWithAttrCheck(function (d) {
      // make sure plot is called as a setter
      return this.put(new Path()).plot(d || new PathArray());
    })
  }
});
register(Path, 'Path');

function array() {
  return this._array || (this._array = new PointArray(this.attr('points')));
} // Plot new path


function plot(p) {
  return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new PointArray(p));
} // Clear array cache


function clear() {
  delete this._array;
  return this;
} // Move by left top corner


function move(x, y) {
  return this.attr('points', this.array().move(x, y));
} // Set element size to given width and height


function size(width, height) {
  var p = proportionalSize(this, width, height);
  return this.attr('points', this.array().size(p.width, p.height));
}

var poly = {
  __proto__: null,
  array: array,
  plot: plot,
  clear: clear,
  move: move,
  size: size
};

var Polygon = /*#__PURE__*/function (_Shape) {
  _inherits(Polygon, _Shape); // Initialize node


  function Polygon(node) {
    _classCallCheck(this, Polygon);

    return _possibleConstructorReturn(this, _getPrototypeOf(Polygon).call(this, nodeOrNew('polygon', node), node));
  }

  return Polygon;
}(Shape);

exports.Polygon = Polygon;
registerMethods({
  Container: {
    // Create a wrapped polygon element
    polygon: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polygon()).plot(p || new PointArray());
    })
  }
});
extend(Polygon, pointed);
extend(Polygon, poly);
register(Polygon, 'Polygon');

var Polyline = /*#__PURE__*/function (_Shape) {
  _inherits(Polyline, _Shape); // Initialize node


  function Polyline(node) {
    _classCallCheck(this, Polyline);

    return _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this, nodeOrNew('polyline', node), node));
  }

  return Polyline;
}(Shape);

exports.Polyline = Polyline;
registerMethods({
  Container: {
    // Create a wrapped polygon element
    polyline: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polyline()).plot(p || new PointArray());
    })
  }
});
extend(Polyline, pointed);
extend(Polyline, poly);
register(Polyline, 'Polyline');

var Rect = /*#__PURE__*/function (_Shape) {
  _inherits(Rect, _Shape); // Initialize node


  function Rect(node) {
    _classCallCheck(this, Rect);

    return _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, nodeOrNew('rect', node), node));
  }

  return Rect;
}(Shape);

exports.Rect = Rect;
extend(Rect, {
  rx: rx,
  ry: ry
});
registerMethods({
  Container: {
    // Create a rect element
    rect: wrapWithAttrCheck(function (width, height) {
      return this.put(new Rect()).size(width, height);
    })
  }
});
register(Rect, 'Rect');
var max$3 = Math.max;
var min$4 = Math.min;
var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('splice')
}, {
  splice: function splice(start, deleteCount
  /* , ...items */
  ) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;

    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$4(max$3(toInteger(deleteCount), 0), len - actualStart);
    }

    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }

    A = arraySpeciesCreate(O, actualDeleteCount);

    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }

    A.length = actualDeleteCount;

    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];else delete O[to];
      }

      for (k = len; k > len - actualDeleteCount + insertCount; k--) {
        delete O[k - 1];
      }
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];else delete O[to];
      }
    }

    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }

    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

var Queue = /*#__PURE__*/function () {
  function Queue() {
    _classCallCheck(this, Queue);

    this._first = null;
    this._last = null;
  }

  _createClass(Queue, [{
    key: "push",
    value: function push(value) {
      // An item stores an id and the provided value
      var item = value.next ? value : {
        value: value,
        next: null,
        prev: null
      }; // Deal with the queue being empty or populated

      if (this._last) {
        item.prev = this._last;
        this._last.next = item;
        this._last = item;
      } else {
        this._last = item;
        this._first = item;
      } // Return the current item


      return item;
    }
  }, {
    key: "shift",
    value: function shift() {
      // Check if we have a value
      var remove = this._first;
      if (!remove) return null; // If we do, remove it and relink things

      this._first = remove.next;
      if (this._first) this._first.prev = null;
      this._last = this._first ? this._last : null;
      return remove.value;
    } // Shows us the first item in the list

  }, {
    key: "first",
    value: function first() {
      return this._first && this._first.value;
    } // Shows us the last item in the list

  }, {
    key: "last",
    value: function last() {
      return this._last && this._last.value;
    } // Removes the item that was returned from the push

  }, {
    key: "remove",
    value: function remove(item) {
      // Relink the previous item
      if (item.prev) item.prev.next = item.next;
      if (item.next) item.next.prev = item.prev;
      if (item === this._last) this._last = item.prev;
      if (item === this._first) this._first = item.next; // Invalidate item

      item.prev = null;
      item.next = null;
    }
  }]);

  return Queue;
}();

exports.Queue = Queue;
var Animator = {
  nextDraw: null,
  frames: new Queue(),
  timeouts: new Queue(),
  immediates: new Queue(),
  timer: function timer() {
    return globals.window.performance || globals.window.Date;
  },
  transforms: [],
  frame: function frame(fn) {
    // Store the node
    var node = Animator.frames.push({
      run: fn
    }); // Request an animation frame if we don't have one

    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    } // Return the node so we can remove it easily


    return node;
  },
  timeout: function timeout(fn, delay) {
    delay = delay || 0; // Work out when the event should fire

    var time = Animator.timer().now() + delay; // Add the timeout to the end of the queue

    var node = Animator.timeouts.push({
      run: fn,
      time: time
    }); // Request another animation frame if we need one

    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node;
  },
  immediate: function immediate(fn) {
    // Add the immediate fn to the end of the queue
    var node = Animator.immediates.push(fn); // Request another animation frame if we need one

    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node;
  },
  cancelFrame: function cancelFrame(node) {
    node != null && Animator.frames.remove(node);
  },
  clearTimeout: function clearTimeout(node) {
    node != null && Animator.timeouts.remove(node);
  },
  cancelImmediate: function cancelImmediate(node) {
    node != null && Animator.immediates.remove(node);
  },
  _draw: function _draw(now) {
    // Run all the timeouts we can run, if they are not ready yet, add them
    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])
    var nextTimeout = null;
    var lastTimeout = Animator.timeouts.last();

    while (nextTimeout = Animator.timeouts.shift()) {
      // Run the timeout if its time, or push it to the end
      if (now >= nextTimeout.time) {
        nextTimeout.run();
      } else {
        Animator.timeouts.push(nextTimeout);
      } // If we hit the last item, we should stop shifting out more items


      if (nextTimeout === lastTimeout) break;
    } // Run all of the animation frames


    var nextFrame = null;
    var lastFrame = Animator.frames.last();

    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {
      nextFrame.run(now);
    }

    var nextImmediate = null;

    while (nextImmediate = Animator.immediates.shift()) {
      nextImmediate();
    } // If we have remaining timeouts or frames, draw until we don't anymore


    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;
  }
};
exports.Animator = Animator;

var makeSchedule = function makeSchedule(runnerInfo) {
  var start = runnerInfo.start;
  var duration = runnerInfo.runner.duration();
  var end = start + duration;
  return {
    start: start,
    duration: duration,
    end: end,
    runner: runnerInfo.runner
  };
};

var defaultSource = function defaultSource() {
  var w = globals.window;
  return (w.performance || w.Date).now();
};

var Timeline = /*#__PURE__*/function (_EventTarget) {
  _inherits(Timeline, _EventTarget); // Construct a new timeline on the given element


  function Timeline() {
    var _this;

    var timeSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSource;

    _classCallCheck(this, Timeline);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Timeline).call(this));
    _this._timeSource = timeSource; // Store the timing variables

    _this._startTime = 0;
    _this._speed = 1.0; // Determines how long a runner is hold in memory. Can be a dt or true/false

    _this._persist = 0; // Keep track of the running animations and their starting parameters

    _this._nextFrame = null;
    _this._paused = true;
    _this._runners = [];
    _this._runnerIds = [];
    _this._lastRunnerId = -1;
    _this._time = 0;
    _this._lastSourceTime = 0;
    _this._lastStepTime = 0; // Make sure that step is always called in class context

    _this._step = _this._stepFn.bind(_assertThisInitialized(_this), false);
    _this._stepImmediate = _this._stepFn.bind(_assertThisInitialized(_this), true);
    return _this;
  } // schedules a runner on the timeline


  _createClass(Timeline, [{
    key: "schedule",
    value: function schedule(runner, delay, when) {
      if (runner == null) {
        return this._runners.map(makeSchedule);
      } // The start time for the next animation can either be given explicitly,
      // derived from the current timeline time or it can be relative to the
      // last start time to chain animations direclty


      var absoluteStartTime = 0;
      var endTime = this.getEndTime();
      delay = delay || 0; // Work out when to start the animation

      if (when == null || when === 'last' || when === 'after') {
        // Take the last time and increment
        absoluteStartTime = endTime;
      } else if (when === 'absolute' || when === 'start') {
        absoluteStartTime = delay;
        delay = 0;
      } else if (when === 'now') {
        absoluteStartTime = this._time;
      } else if (when === 'relative') {
        var _runnerInfo = this._runners[runner.id];

        if (_runnerInfo) {
          absoluteStartTime = _runnerInfo.start + delay;
          delay = 0;
        }
      } else {
        throw new Error('Invalid value for the "when" parameter');
      } // Manage runner


      runner.unschedule();
      runner.timeline(this);
      var persist = runner.persist();
      var runnerInfo = {
        persist: persist === null ? this._persist : persist,
        start: absoluteStartTime + delay,
        runner: runner
      };
      this._lastRunnerId = runner.id;

      this._runners.push(runnerInfo);

      this._runners.sort(function (a, b) {
        return a.start - b.start;
      });

      this._runnerIds = this._runners.map(function (info) {
        return info.runner.id;
      });

      this.updateTime()._continue();

      return this;
    } // Remove the runner from this timeline

  }, {
    key: "unschedule",
    value: function unschedule(runner) {
      var index = this._runnerIds.indexOf(runner.id);

      if (index < 0) return this;

      this._runners.splice(index, 1);

      this._runnerIds.splice(index, 1);

      runner.timeline(null);
      return this;
    } // Calculates the end of the timeline

  }, {
    key: "getEndTime",
    value: function getEndTime() {
      var lastRunnerInfo = this._runners[this._runnerIds.indexOf(this._lastRunnerId)];

      var lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
      var lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : 0;
      return lastStartTime + lastDuration;
    }
  }, {
    key: "getEndTimeOfTimeline",
    value: function getEndTimeOfTimeline() {
      var lastEndTime = 0;

      for (var i = 0; i < this._runners.length; i++) {
        var runnerInfo = this._runners[i];
        var duration = runnerInfo ? runnerInfo.runner.duration() : 0;
        var startTime = runnerInfo ? runnerInfo.start : 0;
        var endTime = startTime + duration;

        if (endTime > lastEndTime) {
          lastEndTime = endTime;
        }
      }

      return lastEndTime;
    } // Makes sure, that after pausing the time doesn't jump

  }, {
    key: "updateTime",
    value: function updateTime() {
      if (!this.active()) {
        this._lastSourceTime = this._timeSource();
      }

      return this;
    }
  }, {
    key: "play",
    value: function play() {
      // Now make sure we are not paused and continue the animation
      this._paused = false;
      return this.updateTime()._continue();
    }
  }, {
    key: "pause",
    value: function pause() {
      this._paused = true;
      return this._continue();
    }
  }, {
    key: "stop",
    value: function stop() {
      // Go to start and pause
      this.time(0);
      return this.pause();
    }
  }, {
    key: "finish",
    value: function finish() {
      // Go to end and pause
      this.time(this.getEndTimeOfTimeline() + 1);
      return this.pause();
    }
  }, {
    key: "speed",
    value: function speed(_speed) {
      if (_speed == null) return this._speed;
      this._speed = _speed;
      return this;
    }
  }, {
    key: "reverse",
    value: function reverse(yes) {
      var currentSpeed = this.speed();
      if (yes == null) return this.speed(-currentSpeed);
      var positive = Math.abs(currentSpeed);
      return this.speed(yes ? positive : -positive);
    }
  }, {
    key: "seek",
    value: function seek(dt) {
      return this.time(this._time + dt);
    }
  }, {
    key: "time",
    value: function time(_time) {
      if (_time == null) return this._time;
      this._time = _time;
      return this._continue(true);
    }
  }, {
    key: "persist",
    value: function persist(dtOrForever) {
      if (dtOrForever == null) return this._persist;
      this._persist = dtOrForever;
      return this;
    }
  }, {
    key: "source",
    value: function source(fn) {
      if (fn == null) return this._timeSource;
      this._timeSource = fn;
      return this;
    }
  }, {
    key: "_stepFn",
    value: function _stepFn() {
      var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; // Get the time delta from the last time and update the time

      var time = this._timeSource();

      var dtSource = time - this._lastSourceTime;
      if (immediateStep) dtSource = 0;
      var dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
      this._lastSourceTime = time; // Only update the time if we use the timeSource.
      // Otherwise use the current time

      if (!immediateStep) {
        // Update the time
        this._time += dtTime;
        this._time = this._time < 0 ? 0 : this._time;
      }

      this._lastStepTime = this._time;
      this.fire('time', this._time); // This is for the case that the timeline was seeked so that the time
      // is now before the startTime of the runner. Thats why we need to set
      // the runner to position 0
      // FIXME:
      // However, reseting in insertion order leads to bugs. Considering the case,
      // where 2 runners change the same attriute but in different times,
      // reseting both of them will lead to the case where the later defined
      // runner always wins the reset even if the other runner started earlier
      // and therefore should win the attribute battle
      // this can be solved by reseting them backwards

      for (var k = this._runners.length; k--;) {
        // Get and run the current runner and ignore it if its inactive
        var runnerInfo = this._runners[k];
        var runner = runnerInfo.runner; // Make sure that we give the actual difference
        // between runner start time and now

        var dtToStart = this._time - runnerInfo.start; // Dont run runner if not started yet
        // and try to reset it

        if (dtToStart <= 0) {
          runner.reset();
        }
      } // Run all of the runners directly


      var runnersLeft = false;

      for (var i = 0, len = this._runners.length; i < len; i++) {
        // Get and run the current runner and ignore it if its inactive
        var _runnerInfo2 = this._runners[i];
        var _runner = _runnerInfo2.runner;
        var dt = dtTime; // Make sure that we give the actual difference
        // between runner start time and now

        var _dtToStart = this._time - _runnerInfo2.start; // Dont run runner if not started yet


        if (_dtToStart <= 0) {
          runnersLeft = true;
          continue;
        } else if (_dtToStart < dt) {
          // Adjust dt to make sure that animation is on point
          dt = _dtToStart;
        }

        if (!_runner.active()) continue; // If this runner is still going, signal that we need another animation
        // frame, otherwise, remove the completed runner

        var finished = _runner.step(dt).done;

        if (!finished) {
          runnersLeft = true; // continue
        } else if (_runnerInfo2.persist !== true) {
          // runner is finished. And runner might get removed
          var endTime = _runner.duration() - _runner.time() + this._time;

          if (endTime + _runnerInfo2.persist < this._time) {
            // Delete runner and correct index
            _runner.unschedule();

            --i;
            --len;
          }
        }
      } // Basically: we continue when there are runners right from us in time
      // when -->, and when runners are left from us when <--


      if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {
        this._continue();
      } else {
        this.pause();
        this.fire('finished');
      }

      return this;
    } // Checks if we are running and continues the animation

  }, {
    key: "_continue",
    value: function _continue() {
      var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      Animator.cancelFrame(this._nextFrame);
      this._nextFrame = null;
      if (immediateStep) return this._stepImmediate();
      if (this._paused) return this;
      this._nextFrame = Animator.frame(this._step);
      return this;
    }
  }, {
    key: "active",
    value: function active() {
      return !!this._nextFrame;
    }
  }]);

  return Timeline;
}(EventTarget);

exports.Timeline = Timeline;
registerMethods({
  Element: {
    timeline: function timeline(_timeline) {
      if (_timeline == null) {
        this._timeline = this._timeline || new Timeline();
        return this._timeline;
      } else {
        this._timeline = _timeline;
        return this;
      }
    }
  }
});

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$2(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var Runner = /*#__PURE__*/function (_EventTarget) {
  _inherits(Runner, _EventTarget);

  function Runner(options) {
    var _this;

    _classCallCheck(this, Runner);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Runner).call(this)); // Store a unique id on the runner, so that we can identify it later

    _this.id = Runner.id++; // Ensure a default value

    options = options == null ? timeline.duration : options; // Ensure that we get a controller

    options = typeof options === 'function' ? new Controller(options) : options; // Declare all of the variables

    _this._element = null;
    _this._timeline = null;
    _this.done = false;
    _this._queue = []; // Work out the stepper and the duration

    _this._duration = typeof options === 'number' && options;
    _this._isDeclarative = options instanceof Controller;
    _this._stepper = _this._isDeclarative ? options : new Ease(); // We copy the current values from the timeline because they can change

    _this._history = {}; // Store the state of the runner

    _this.enabled = true;
    _this._time = 0;
    _this._lastTime = 0; // At creation, the runner is in reseted state

    _this._reseted = true; // Save transforms applied to this runner

    _this.transforms = new Matrix();
    _this.transformId = 1; // Looping variables

    _this._haveReversed = false;
    _this._reverse = false;
    _this._loopsDone = 0;
    _this._swing = false;
    _this._wait = 0;
    _this._times = 1;
    _this._frameId = null; // Stores how long a runner is stored after beeing done

    _this._persist = _this._isDeclarative ? true : null;
    return _this;
  }
  /*
  Runner Definitions
  ==================
  These methods help us define the runtime behaviour of the Runner or they
  help us make new runners from the current runner
  */


  _createClass(Runner, [{
    key: "element",
    value: function element(_element) {
      if (_element == null) return this._element;
      this._element = _element;

      _element._prepareRunner();

      return this;
    }
  }, {
    key: "timeline",
    value: function timeline(_timeline) {
      // check explicitly for undefined so we can set the timeline to null
      if (typeof _timeline === 'undefined') return this._timeline;
      this._timeline = _timeline;
      return this;
    }
  }, {
    key: "animate",
    value: function animate(duration, delay, when) {
      var o = Runner.sanitise(duration, delay, when);
      var runner = new Runner(o.duration);
      if (this._timeline) runner.timeline(this._timeline);
      if (this._element) runner.element(this._element);
      return runner.loop(o).schedule(o.delay, o.when);
    }
  }, {
    key: "schedule",
    value: function schedule(timeline, delay, when) {
      // The user doesn't need to pass a timeline if we already have one
      if (!(timeline instanceof Timeline)) {
        when = delay;
        delay = timeline;
        timeline = this.timeline();
      } // If there is no timeline, yell at the user...


      if (!timeline) {
        throw Error('Runner cannot be scheduled without timeline');
      } // Schedule the runner on the timeline provided


      timeline.schedule(this, delay, when);
      return this;
    }
  }, {
    key: "unschedule",
    value: function unschedule() {
      var timeline = this.timeline();
      timeline && timeline.unschedule(this);
      return this;
    }
  }, {
    key: "loop",
    value: function loop(times, swing, wait) {
      // Deal with the user passing in an object
      if (_typeof(times) === 'object') {
        swing = times.swing;
        wait = times.wait;
        times = times.times;
      } // Sanitise the values and store them


      this._times = times || Infinity;
      this._swing = swing || false;
      this._wait = wait || 0; // Allow true to be passed

      if (this._times === true) {
        this._times = Infinity;
      }

      return this;
    }
  }, {
    key: "delay",
    value: function delay(_delay) {
      return this.animate(0, _delay);
    }
    /*
    Basic Functionality
    ===================
    These methods allow us to attach basic functions to the runner directly
    */

  }, {
    key: "queue",
    value: function queue(initFn, runFn, retargetFn, isTransform) {
      this._queue.push({
        initialiser: initFn || noop,
        runner: runFn || noop,
        retarget: retargetFn,
        isTransform: isTransform,
        initialised: false,
        finished: false
      });

      var timeline = this.timeline();
      timeline && this.timeline()._continue();
      return this;
    }
  }, {
    key: "during",
    value: function during(fn) {
      return this.queue(null, fn);
    }
  }, {
    key: "after",
    value: function after(fn) {
      return this.on('finished', fn);
    }
    /*
    Runner animation methods
    ========================
    Control how the animation plays
    */

  }, {
    key: "time",
    value: function time(_time) {
      if (_time == null) {
        return this._time;
      }

      var dt = _time - this._time;
      this.step(dt);
      return this;
    }
  }, {
    key: "duration",
    value: function duration() {
      return this._times * (this._wait + this._duration) - this._wait;
    }
  }, {
    key: "loops",
    value: function loops(p) {
      var loopDuration = this._duration + this._wait;

      if (p == null) {
        var loopsDone = Math.floor(this._time / loopDuration);
        var relativeTime = this._time - loopsDone * loopDuration;
        var position = relativeTime / this._duration;
        return Math.min(loopsDone + position, this._times);
      }

      var whole = Math.floor(p);
      var partial = p % 1;
      var time = loopDuration * whole + this._duration * partial;
      return this.time(time);
    }
  }, {
    key: "persist",
    value: function persist(dtOrForever) {
      if (dtOrForever == null) return this._persist;
      this._persist = dtOrForever;
      return this;
    }
  }, {
    key: "position",
    value: function position(p) {
      // Get all of the variables we need
      var x = this._time;
      var d = this._duration;
      var w = this._wait;
      var t = this._times;
      var s = this._swing;
      var r = this._reverse;
      var position;

      if (p == null) {
        /*
        This function converts a time to a position in the range [0, 1]
        The full explanation can be found in this desmos demonstration
          https://www.desmos.com/calculator/u4fbavgche
        The logic is slightly simplified here because we can use booleans
        */
        // Figure out the value without thinking about the start or end time
        var f = function f(x) {
          var swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));
          var backwards = swinging && !r || !swinging && r;
          var uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;
          var clipped = Math.max(Math.min(uncliped, 1), 0);
          return clipped;
        }; // Figure out the value by incorporating the start time


        var endTime = t * (w + d) - w;
        position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));
        return position;
      } // Work out the loops done and add the position to the loops done


      var loopsDone = Math.floor(this.loops());
      var swingForward = s && loopsDone % 2 === 0;
      var forwards = swingForward && !r || r && swingForward;
      position = loopsDone + (forwards ? p : 1 - p);
      return this.loops(position);
    }
  }, {
    key: "progress",
    value: function progress(p) {
      if (p == null) {
        return Math.min(1, this._time / this.duration());
      }

      return this.time(p * this.duration());
    }
  }, {
    key: "step",
    value: function step(dt) {
      // If we are inactive, this stepper just gets skipped
      if (!this.enabled) return this; // Update the time and get the new position

      dt = dt == null ? 16 : dt;
      this._time += dt;
      var position = this.position(); // Figure out if we need to run the stepper in this frame

      var running = this._lastPosition !== position && this._time >= 0;
      this._lastPosition = position; // Figure out if we just started

      var duration = this.duration();
      var justStarted = this._lastTime <= 0 && this._time > 0;
      var justFinished = this._lastTime < duration && this._time >= duration;
      this._lastTime = this._time;

      if (justStarted) {
        this.fire('start', this);
      } // Work out if the runner is finished set the done flag here so animations
      // know, that they are running in the last step (this is good for
      // transformations which can be merged)


      var declarative = this._isDeclarative;
      this.done = !declarative && !justFinished && this._time >= duration; // Runner is running. So its not in reseted state anymore

      this._reseted = false; // Call initialise and the run function

      if (running || declarative) {
        this._initialise(running); // clear the transforms on this runner so they dont get added again and again


        this.transforms = new Matrix();

        var converged = this._run(declarative ? dt : position);

        this.fire('step', this);
      } // correct the done flag here
      // declaritive animations itself know when they converged


      this.done = this.done || converged && declarative;

      if (justFinished) {
        this.fire('finished', this);
      }

      return this;
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this._reseted) return this;
      this.time(0);
      this._reseted = true;
      return this;
    }
  }, {
    key: "finish",
    value: function finish() {
      return this.step(Infinity);
    }
  }, {
    key: "reverse",
    value: function reverse(_reverse) {
      this._reverse = _reverse == null ? !this._reverse : _reverse;
      return this;
    }
  }, {
    key: "ease",
    value: function ease(fn) {
      this._stepper = new Ease(fn);
      return this;
    }
  }, {
    key: "active",
    value: function active(enabled) {
      if (enabled == null) return this.enabled;
      this.enabled = enabled;
      return this;
    }
    /*
    Private Methods
    ===============
    Methods that shouldn't be used externally
    */
    // Save a morpher to the morpher list so that we can retarget it later

  }, {
    key: "_rememberMorpher",
    value: function _rememberMorpher(method, morpher) {
      this._history[method] = {
        morpher: morpher,
        caller: this._queue[this._queue.length - 1]
      }; // We have to resume the timeline in case a controller
      // is already done without beeing ever run
      // This can happen when e.g. this is done:
      //    anim = el.animate(new SVG.Spring)
      // and later
      //    anim.move(...)

      if (this._isDeclarative) {
        var timeline = this.timeline();
        timeline && timeline.play();
      }
    } // Try to set the target for a morpher if the morpher exists, otherwise
    // do nothing and return false

  }, {
    key: "_tryRetarget",
    value: function _tryRetarget(method, target, extra) {
      if (this._history[method]) {
        // if the last method wasnt even initialised, throw it away
        if (!this._history[method].caller.initialised) {
          var index = this._queue.indexOf(this._history[method].caller);

          this._queue.splice(index, 1);

          return false;
        } // for the case of transformations, we use the special retarget function
        // which has access to the outer scope


        if (this._history[method].caller.retarget) {
          this._history[method].caller.retarget(target, extra); // for everything else a simple morpher change is sufficient

        } else {
          this._history[method].morpher.to(target);
        }

        this._history[method].caller.finished = false;
        var timeline = this.timeline();
        timeline && timeline.play();
        return true;
      }

      return false;
    } // Run each initialise function in the runner if required

  }, {
    key: "_initialise",
    value: function _initialise(running) {
      // If we aren't running, we shouldn't initialise when not declarative
      if (!running && !this._isDeclarative) return; // Loop through all of the initialisers

      for (var i = 0, len = this._queue.length; i < len; ++i) {
        // Get the current initialiser
        var current = this._queue[i]; // Determine whether we need to initialise

        var needsIt = this._isDeclarative || !current.initialised && running;
        running = !current.finished; // Call the initialiser if we need to

        if (needsIt && running) {
          current.initialiser.call(this);
          current.initialised = true;
        }
      }
    } // Run each run function for the position or dt given

  }, {
    key: "_run",
    value: function _run(positionOrDt) {
      // Run all of the _queue directly
      var allfinished = true;

      for (var i = 0, len = this._queue.length; i < len; ++i) {
        // Get the current function to run
        var current = this._queue[i]; // Run the function if its not finished, we keep track of the finished
        // flag for the sake of declarative _queue

        var converged = current.runner.call(this, positionOrDt);
        current.finished = current.finished || converged === true;
        allfinished = allfinished && current.finished;
      } // We report when all of the constructors are finished


      return allfinished;
    }
  }, {
    key: "addTransform",
    value: function addTransform(transform, index) {
      this.transforms.lmultiplyO(transform);
      return this;
    }
  }, {
    key: "clearTransform",
    value: function clearTransform() {
      this.transforms = new Matrix();
      return this;
    } // TODO: Keep track of all transformations so that deletion is faster

  }, {
    key: "clearTransformsFromQueue",
    value: function clearTransformsFromQueue() {
      if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {
        this._queue = this._queue.filter(function (item) {
          return !item.isTransform;
        });
      }
    }
  }], [{
    key: "sanitise",
    value: function sanitise(duration, delay, when) {
      // Initialise the default parameters
      var times = 1;
      var swing = false;
      var wait = 0;
      duration = duration || timeline.duration;
      delay = delay || timeline.delay;
      when = when || 'last'; // If we have an object, unpack the values

      if (_typeof(duration) === 'object' && !(duration instanceof Stepper)) {
        delay = duration.delay || delay;
        when = duration.when || when;
        swing = duration.swing || swing;
        times = duration.times || times;
        wait = duration.wait || wait;
        duration = duration.duration || timeline.duration;
      }

      return {
        duration: duration,
        delay: delay,
        swing: swing,
        times: times,
        wait: wait,
        when: when
      };
    }
  }]);

  return Runner;
}(EventTarget);

exports.Runner = Runner;
Runner.id = 0;

var FakeRunner = /*#__PURE__*/function () {
  function FakeRunner() {
    var transforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();
    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var done = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    _classCallCheck(this, FakeRunner);

    this.transforms = transforms;
    this.id = id;
    this.done = done;
  }

  _createClass(FakeRunner, [{
    key: "clearTransformsFromQueue",
    value: function clearTransformsFromQueue() {}
  }]);

  return FakeRunner;
}();

extend([Runner, FakeRunner], {
  mergeWith: function mergeWith(runner) {
    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);
  }
}); // FakeRunner.emptyRunner = new FakeRunner()

var lmultiply = function lmultiply(last, curr) {
  return last.lmultiplyO(curr);
};

var getRunnerTransform = function getRunnerTransform(runner) {
  return runner.transforms;
};

function mergeTransforms() {
  // Find the matrix to apply to the element and apply it
  var runners = this._transformationRunners.runners;
  var netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());
  this.transform(netTransform);

  this._transformationRunners.merge();

  if (this._transformationRunners.length() === 1) {
    this._frameId = null;
  }
}

var RunnerArray = /*#__PURE__*/function () {
  function RunnerArray() {
    _classCallCheck(this, RunnerArray);

    this.runners = [];
    this.ids = [];
  }

  _createClass(RunnerArray, [{
    key: "add",
    value: function add(runner) {
      if (this.runners.includes(runner)) return;
      var id = runner.id + 1;
      this.runners.push(runner);
      this.ids.push(id);
      return this;
    }
  }, {
    key: "getByID",
    value: function getByID(id) {
      return this.runners[this.ids.indexOf(id + 1)];
    }
  }, {
    key: "remove",
    value: function remove(id) {
      var index = this.ids.indexOf(id + 1);
      this.ids.splice(index, 1);
      this.runners.splice(index, 1);
      return this;
    }
  }, {
    key: "merge",
    value: function merge() {
      var _this2 = this;

      var lastRunner = null;
      this.runners.forEach(function (runner, i) {
        var condition = lastRunner && runner.done && lastRunner.done // don't merge runner when persisted on timeline
        && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));

        if (condition) {
          // the +1 happens in the function
          _this2.remove(runner.id);

          _this2.edit(lastRunner.id, runner.mergeWith(lastRunner));
        }

        lastRunner = runner;
      });
      return this;
    }
  }, {
    key: "edit",
    value: function edit(id, newRunner) {
      var index = this.ids.indexOf(id + 1);
      this.ids.splice(index, 1, id + 1);
      this.runners.splice(index, 1, newRunner);
      return this;
    }
  }, {
    key: "length",
    value: function length() {
      return this.ids.length;
    }
  }, {
    key: "clearBefore",
    value: function clearBefore(id) {
      var deleteCnt = this.ids.indexOf(id + 1) || 1;
      this.ids.splice(0, deleteCnt, 0);
      this.runners.splice(0, deleteCnt, new FakeRunner()).forEach(function (r) {
        return r.clearTransformsFromQueue();
      });
      return this;
    }
  }]);

  return RunnerArray;
}();

registerMethods({
  Element: {
    animate: function animate(duration, delay, when) {
      var o = Runner.sanitise(duration, delay, when);
      var timeline = this.timeline();
      return new Runner(o.duration).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);
    },
    delay: function delay(by, when) {
      return this.animate(0, by, when);
    },
    // this function searches for all runners on the element and deletes the ones
    // which run before the current one. This is because absolute transformations
    // overwfrite anything anyway so there is no need to waste time computing
    // other runners
    _clearTransformRunnersBefore: function _clearTransformRunnersBefore(currentRunner) {
      this._transformationRunners.clearBefore(currentRunner.id);
    },
    _currentTransform: function _currentTransform(current) {
      return this._transformationRunners.runners // we need the equal sign here to make sure, that also transformations
      // on the same runner which execute before the current transformation are
      // taken into account
      .filter(function (runner) {
        return runner.id <= current.id;
      }).map(getRunnerTransform).reduce(lmultiply, new Matrix());
    },
    _addRunner: function _addRunner(runner) {
      this._transformationRunners.add(runner); // Make sure that the runner merge is executed at the very end of
      // all Animator functions. Thats why we use immediate here to execute
      // the merge right after all frames are run


      Animator.cancelImmediate(this._frameId);
      this._frameId = Animator.immediate(mergeTransforms.bind(this));
    },
    _prepareRunner: function _prepareRunner() {
      if (this._frameId == null) {
        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));
      }
    }
  }
});
extend(Runner, {
  attr: function attr(a, v) {
    return this.styleAttr('attr', a, v);
  },
  // Add animatable styles
  css: function css(s, v) {
    return this.styleAttr('css', s, v);
  },
  styleAttr: function styleAttr(type, name, val) {
    // apply attributes individually
    if (_typeof(name) === 'object') {
      for (var key in name) {
        this.styleAttr(type, key, name[key]);
      }

      return this;
    }

    var morpher = new Morphable(this._stepper).to(val);
    this.queue(function () {
      morpher = morpher.from(this.element()[type](name));
    }, function (pos) {
      this.element()[type](name, morpher.at(pos));
      return morpher.done();
    });
    return this;
  },
  zoom: function zoom(level, point) {
    if (this._tryRetarget('zoom', to, point)) return this;
    var morpher = new Morphable(this._stepper).to(new SVGNumber(level));
    this.queue(function () {
      morpher = morpher.from(this.element().zoom());
    }, function (pos) {
      this.element().zoom(morpher.at(pos), point);
      return morpher.done();
    }, function (newLevel, newPoint) {
      point = newPoint;
      morpher.to(newLevel);
    });

    this._rememberMorpher('zoom', morpher);

    return this;
  },

  /**
   ** absolute transformations
   **/
  //
  // M v -----|-----(D M v = F v)------|----->  T v
  //
  // 1. define the final state (T) and decompose it (once)
  //    t = [tx, ty, the, lam, sy, sx]
  // 2. on every frame: pull the current state of all previous transforms
  //    (M - m can change)
  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]
  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)
  //   - Note F(0) = M
  //   - Note F(1) = T
  // 4. Now you get the delta matrix as a result: D = F * inv(M)
  transform: function transform(transforms, relative, affine) {
    // If we have a declarative function, we should retarget it if possible
    relative = transforms.relative || relative;

    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {
      return this;
    } // Parse the parameters


    var isMatrix = Matrix.isMatrixLike(transforms);
    affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix; // Create a morepher and set its type

    var morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);
    var origin;
    var element;
    var current;
    var currentAngle;
    var startTransform;

    function setup() {
      // make sure element and origin is defined
      element = element || this.element();
      origin = origin || getOrigin(transforms, element);
      startTransform = new Matrix(relative ? undefined : element); // add the runner to the element so it can merge transformations

      element._addRunner(this); // Deactivate all transforms that have run so far if we are absolute


      if (!relative) {
        element._clearTransformRunnersBefore(this);
      }
    }

    function run(pos) {
      // clear all other transforms before this in case something is saved
      // on this runner. We are absolute. We dont need these!
      if (!relative) this.clearTransform();

      var _transform = new Point(origin).transform(element._currentTransform(this)),
          x = _transform.x,
          y = _transform.y;

      var target = new Matrix(_objectSpread$1({}, transforms, {
        origin: [x, y]
      }));
      var start = this._isDeclarative && current ? current : startTransform;

      if (affine) {
        target = target.decompose(x, y);
        start = start.decompose(x, y); // Get the current and target angle as it was set

        var rTarget = target.rotate;
        var rCurrent = start.rotate; // Figure out the shortest path to rotate directly

        var possibilities = [rTarget - 360, rTarget, rTarget + 360];
        var distances = possibilities.map(function (a) {
          return Math.abs(a - rCurrent);
        });
        var shortest = Math.min.apply(Math, _toConsumableArray(distances));
        var index = distances.indexOf(shortest);
        target.rotate = possibilities[index];
      }

      if (relative) {
        // we have to be careful here not to overwrite the rotation
        // with the rotate method of Matrix
        if (!isMatrix) {
          target.rotate = transforms.rotate || 0;
        }

        if (this._isDeclarative && currentAngle) {
          start.rotate = currentAngle;
        }
      }

      morpher.from(start);
      morpher.to(target);
      var affineParameters = morpher.at(pos);
      currentAngle = affineParameters.rotate;
      current = new Matrix(affineParameters);
      this.addTransform(current);

      element._addRunner(this);

      return morpher.done();
    }

    function retarget(newTransforms) {
      // only get a new origin if it changed since the last call
      if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) {
        origin = getOrigin(transforms, element);
      } // overwrite the old transformations with the new ones


      transforms = _objectSpread$1({}, newTransforms, {
        origin: origin
      });
    }

    this.queue(setup, run, retarget, true);
    this._isDeclarative && this._rememberMorpher('transform', morpher);
    return this;
  },
  // Animatable x-axis
  x: function x(_x, relative) {
    return this._queueNumber('x', _x);
  },
  // Animatable y-axis
  y: function y(_y) {
    return this._queueNumber('y', _y);
  },
  dx: function dx() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return this._queueNumberDelta('x', x);
  },
  dy: function dy() {
    var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return this._queueNumberDelta('y', y);
  },
  dmove: function dmove(x, y) {
    return this.dx(x).dy(y);
  },
  _queueNumberDelta: function _queueNumberDelta(method, to) {
    to = new SVGNumber(to); // Try to change the target if we have this method already registerd

    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation

    var morpher = new Morphable(this._stepper).to(to);
    var from = null;
    this.queue(function () {
      from = this.element()[method]();
      morpher.from(from);
      morpher.to(from + to);
    }, function (pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    }, function (newTo) {
      morpher.to(from + new SVGNumber(newTo));
    }); // Register the morpher so that if it is changed again, we can retarget it

    this._rememberMorpher(method, morpher);

    return this;
  },
  _queueObject: function _queueObject(method, to) {
    // Try to change the target if we have this method already registerd
    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation

    var morpher = new Morphable(this._stepper).to(to);
    this.queue(function () {
      morpher.from(this.element()[method]());
    }, function (pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    }); // Register the morpher so that if it is changed again, we can retarget it

    this._rememberMorpher(method, morpher);

    return this;
  },
  _queueNumber: function _queueNumber(method, value) {
    return this._queueObject(method, new SVGNumber(value));
  },
  // Animatable center x-axis
  cx: function cx(x) {
    return this._queueNumber('cx', x);
  },
  // Animatable center y-axis
  cy: function cy(y) {
    return this._queueNumber('cy', y);
  },
  // Add animatable move
  move: function move(x, y) {
    return this.x(x).y(y);
  },
  // Add animatable center
  center: function center(x, y) {
    return this.cx(x).cy(y);
  },
  // Add animatable size
  size: function size(width, height) {
    // animate bbox based size for all other elements
    var box;

    if (!width || !height) {
      box = this._element.bbox();
    }

    if (!width) {
      width = box.width / box.height * height;
    }

    if (!height) {
      height = box.height / box.width * width;
    }

    return this.width(width).height(height);
  },
  // Add animatable width
  width: function width(_width) {
    return this._queueNumber('width', _width);
  },
  // Add animatable height
  height: function height(_height) {
    return this._queueNumber('height', _height);
  },
  // Add animatable plot
  plot: function plot(a, b, c, d) {
    // Lines can be plotted with 4 arguments
    if (arguments.length === 4) {
      return this.plot([a, b, c, d]);
    }

    if (this._tryRetarget('plot', a)) return this;
    var morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);
    this.queue(function () {
      morpher.from(this._element.array());
    }, function (pos) {
      this._element.plot(morpher.at(pos));

      return morpher.done();
    });

    this._rememberMorpher('plot', morpher);

    return this;
  },
  // Add leading method
  leading: function leading(value) {
    return this._queueNumber('leading', value);
  },
  // Add animatable viewbox
  viewbox: function viewbox(x, y, width, height) {
    return this._queueObject('viewbox', new Box(x, y, width, height));
  },
  update: function update(o) {
    if (_typeof(o) !== 'object') {
      return this.update({
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      });
    }

    if (o.opacity != null) this.attr('stop-opacity', o.opacity);
    if (o.color != null) this.attr('stop-color', o.color);
    if (o.offset != null) this.attr('offset', o.offset);
    return this;
  }
});
extend(Runner, {
  rx: rx,
  ry: ry,
  from: from,
  to: to
});
register(Runner, 'Runner');

var Svg = /*#__PURE__*/function (_Container) {
  _inherits(Svg, _Container);

  function Svg(node) {
    var _this;

    _classCallCheck(this, Svg);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Svg).call(this, nodeOrNew('svg', node), node));

    _this.namespace();

    return _this;
  }

  _createClass(Svg, [{
    key: "isRoot",
    value: function isRoot() {
      return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) || this.node.parentNode.nodeName === '#document';
    } // Check if this is a root svg
    // If not, call docs from this element

  }, {
    key: "root",
    value: function root() {
      if (this.isRoot()) return this;
      return _get(_getPrototypeOf(Svg.prototype), "root", this).call(this);
    } // Add namespaces

  }, {
    key: "namespace",
    value: function namespace() {
      if (!this.isRoot()) return this.root().namespace();
      return this.attr({
        xmlns: ns,
        version: '1.1'
      }).attr('xmlns:xlink', xlink, xmlns).attr('xmlns:svgjs', svgjs, xmlns);
    } // Creates and returns defs element

  }, {
    key: "defs",
    value: function defs() {
      if (!this.isRoot()) return this.root().defs();
      return adopt(this.node.querySelector('defs')) || this.put(new Defs());
    } // custom parent method

  }, {
    key: "parent",
    value: function parent(type) {
      if (this.isRoot()) {
        return this.node.parentNode.nodeName === '#document' ? null : adopt(this.node.parentNode);
      }

      return _get(_getPrototypeOf(Svg.prototype), "parent", this).call(this, type);
    }
  }, {
    key: "clear",
    value: function clear() {
      // remove children
      while (this.node.hasChildNodes()) {
        this.node.removeChild(this.node.lastChild);
      } // remove defs reference


      delete this._defs;
      return this;
    }
  }]);

  return Svg;
}(Container);

exports.Svg = Svg;
registerMethods({
  Container: {
    // Create nested svg document
    nested: wrapWithAttrCheck(function () {
      return this.put(new Svg());
    })
  }
});
register(Svg, 'Svg', true);

var _Symbol = /*#__PURE__*/function (_Container) {
  _inherits(_Symbol, _Container); // Initialize node


  function _Symbol(node) {
    _classCallCheck(this, _Symbol);

    return _possibleConstructorReturn(this, _getPrototypeOf(_Symbol).call(this, nodeOrNew('symbol', node), node));
  }

  return _Symbol;
}(Container);

exports.Symbol = _Symbol;
registerMethods({
  Container: {
    symbol: wrapWithAttrCheck(function () {
      return this.put(new _Symbol());
    })
  }
});
register(_Symbol, 'Symbol');

function plain(text) {
  // clear if build mode is disabled
  if (this._build === false) {
    this.clear();
  } // create text node


  this.node.appendChild(globals.document.createTextNode(text));
  return this;
} // Get length of text element


function length() {
  return this.node.getComputedTextLength();
}

var textable = {
  __proto__: null,
  plain: plain,
  length: length
};

var Text = /*#__PURE__*/function (_Shape) {
  _inherits(Text, _Shape); // Initialize node


  function Text(node) {
    var _this;

    _classCallCheck(this, Text);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this, nodeOrNew('text', node), node));
    _this.dom.leading = new SVGNumber(1.3); // store leading value for rebuilding

    _this._rebuild = true; // enable automatic updating of dy values

    _this._build = false; // disable build mode for adding multiple lines

    return _this;
  } // Move over x-axis
  // Text is moved its bounding box
  // text-anchor does NOT matter


  _createClass(Text, [{
    key: "x",
    value: function x(_x) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

      if (_x == null) {
        return box.x;
      }

      return this.attr('x', this.attr('x') + _x - box.x);
    } // Move over y-axis

  }, {
    key: "y",
    value: function y(_y) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

      if (_y == null) {
        return box.y;
      }

      return this.attr('y', this.attr('y') + _y - box.y);
    }
  }, {
    key: "move",
    value: function move(x, y) {
      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
      return this.x(x, box).y(y, box);
    } // Move center over x-axis

  }, {
    key: "cx",
    value: function cx(x) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

      if (x == null) {
        return box.cx;
      }

      return this.attr('x', this.attr('x') + x - box.cx);
    } // Move center over y-axis

  }, {
    key: "cy",
    value: function cy(y) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

      if (y == null) {
        return box.cy;
      }

      return this.attr('y', this.attr('y') + y - box.cy);
    }
  }, {
    key: "center",
    value: function center(x, y) {
      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
      return this.cx(x, box).cy(y, box);
    } // Set the text content

  }, {
    key: "text",
    value: function text(_text) {
      // act as getter
      if (_text === undefined) {
        var children = this.node.childNodes;
        var firstLine = 0;
        _text = '';

        for (var i = 0, len = children.length; i < len; ++i) {
          // skip textPaths - they are no lines
          if (children[i].nodeName === 'textPath') {
            if (i === 0) firstLine = 1;
            continue;
          } // add newline if its not the first child and newLined is set to true


          if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {
            _text += '\n';
          } // add content of this node


          _text += children[i].textContent;
        }

        return _text;
      } // remove existing content


      this.clear().build(true);

      if (typeof _text === 'function') {
        // call block
        _text.call(this, this);
      } else {
        // store text and make sure text is not blank
        _text = _text.split('\n'); // build new lines

        for (var j = 0, jl = _text.length; j < jl; j++) {
          this.tspan(_text[j]).newLine();
        }
      } // disable build mode and rebuild lines


      return this.build(false).rebuild();
    } // Set / get leading

  }, {
    key: "leading",
    value: function leading(value) {
      // act as getter
      if (value == null) {
        return this.dom.leading;
      } // act as setter


      this.dom.leading = new SVGNumber(value);
      return this.rebuild();
    } // Rebuild appearance type

  }, {
    key: "rebuild",
    value: function rebuild(_rebuild) {
      // store new rebuild flag if given
      if (typeof _rebuild === 'boolean') {
        this._rebuild = _rebuild;
      } // define position of all lines


      if (this._rebuild) {
        var self = this;
        var blankLineOffset = 0;
        var leading = this.dom.leading;
        this.each(function () {
          var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
          var dy = leading * new SVGNumber(fontSize);

          if (this.dom.newLined) {
            this.attr('x', self.attr('x'));

            if (this.text() === '\n') {
              blankLineOffset += dy;
            } else {
              this.attr('dy', dy + blankLineOffset);
              blankLineOffset = 0;
            }
          }
        });
        this.fire('rebuild');
      }

      return this;
    } // Enable / disable build mode

  }, {
    key: "build",
    value: function build(_build) {
      this._build = !!_build;
      return this;
    } // overwrite method from parent to set data properly

  }, {
    key: "setData",
    value: function setData(o) {
      this.dom = o;
      this.dom.leading = new SVGNumber(o.leading || 1.3);
      return this;
    }
  }]);

  return Text;
}(Shape);

exports.Text = Text;
extend(Text, textable);
registerMethods({
  Container: {
    // Create text element
    text: wrapWithAttrCheck(function (text) {
      return this.put(new Text()).text(text);
    }),
    // Create plain text element
    plain: wrapWithAttrCheck(function (text) {
      return this.put(new Text()).plain(text);
    })
  }
});
register(Text, 'Text');

var Tspan = /*#__PURE__*/function (_Text) {
  _inherits(Tspan, _Text); // Initialize node


  function Tspan(node) {
    _classCallCheck(this, Tspan);

    return _possibleConstructorReturn(this, _getPrototypeOf(Tspan).call(this, nodeOrNew('tspan', node), node));
  } // Set text content


  _createClass(Tspan, [{
    key: "text",
    value: function text(_text) {
      if (_text == null) return this.node.textContent + (this.dom.newLined ? '\n' : '');
      typeof _text === 'function' ? _text.call(this, this) : this.plain(_text);
      return this;
    } // Shortcut dx

  }, {
    key: "dx",
    value: function dx(_dx) {
      return this.attr('dx', _dx);
    } // Shortcut dy

  }, {
    key: "dy",
    value: function dy(_dy) {
      return this.attr('dy', _dy);
    }
  }, {
    key: "x",
    value: function x(_x) {
      return this.attr('x', _x);
    }
  }, {
    key: "y",
    value: function y(_y) {
      return this.attr('x', _y);
    }
  }, {
    key: "move",
    value: function move(x, y) {
      return this.x(x).y(y);
    } // Create new line

  }, {
    key: "newLine",
    value: function newLine() {
      // fetch text parent
      var t = this.parent(Text); // mark new line

      this.dom.newLined = true;
      var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
      var dy = t.dom.leading * new SVGNumber(fontSize); // apply new position

      return this.dy(dy).attr('x', t.x());
    }
  }]);

  return Tspan;
}(Text);

exports.Tspan = Tspan;
extend(Tspan, textable);
registerMethods({
  Tspan: {
    tspan: wrapWithAttrCheck(function (text) {
      var tspan = new Tspan(); // clear if build mode is disabled

      if (!this._build) {
        this.clear();
      } // add new tspan


      this.node.appendChild(tspan.node);
      return tspan.text(text);
    })
  }
});
register(Tspan, 'Tspan');

var ClipPath = /*#__PURE__*/function (_Container) {
  _inherits(ClipPath, _Container);

  function ClipPath(node) {
    _classCallCheck(this, ClipPath);

    return _possibleConstructorReturn(this, _getPrototypeOf(ClipPath).call(this, nodeOrNew('clipPath', node), node));
  } // Unclip all clipped elements and remove itself


  _createClass(ClipPath, [{
    key: "remove",
    value: function remove() {
      // unclip all targets
      this.targets().forEach(function (el) {
        el.unclip();
      }); // remove clipPath from parent

      return _get(_getPrototypeOf(ClipPath.prototype), "remove", this).call(this);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg [clip-path*="' + this.id() + '"]');
    }
  }]);

  return ClipPath;
}(Container);

exports.ClipPath = ClipPath;
registerMethods({
  Container: {
    // Create clipping element
    clip: wrapWithAttrCheck(function () {
      return this.defs().put(new ClipPath());
    })
  },
  Element: {
    // Distribute clipPath to svg element
    clipWith: function clipWith(element) {
      // use given clip or create a new one
      var clipper = element instanceof ClipPath ? element : this.parent().clip().add(element); // apply mask

      return this.attr('clip-path', 'url("#' + clipper.id() + '")');
    },
    // Unclip element
    unclip: function unclip() {
      return this.attr('clip-path', null);
    },
    clipper: function clipper() {
      return this.reference('clip-path');
    }
  }
});
register(ClipPath, 'ClipPath');

var ForeignObject = /*#__PURE__*/function (_Element) {
  _inherits(ForeignObject, _Element);

  function ForeignObject(node) {
    _classCallCheck(this, ForeignObject);

    return _possibleConstructorReturn(this, _getPrototypeOf(ForeignObject).call(this, nodeOrNew('foreignObject', node), node));
  }

  return ForeignObject;
}(Element);

exports.ForeignObject = ForeignObject;
registerMethods({
  Container: {
    foreignObject: wrapWithAttrCheck(function (width, height) {
      return this.put(new ForeignObject()).size(width, height);
    })
  }
});
register(ForeignObject, 'ForeignObject');

var G = /*#__PURE__*/function (_Container) {
  _inherits(G, _Container);

  function G(node) {
    _classCallCheck(this, G);

    return _possibleConstructorReturn(this, _getPrototypeOf(G).call(this, nodeOrNew('g', node), node));
  }

  _createClass(G, [{
    key: "x",
    value: function x(_x) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
      if (_x == null) return box.x;
      return this.move(_x, box.y, box);
    }
  }, {
    key: "y",
    value: function y(_y) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
      if (_y == null) return box.y;
      return this.move(box.x, _y, box);
    }
  }, {
    key: "move",
    value: function move() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
      var dx = x - box.x;
      var dy = y - box.y;
      return this.dmove(dx, dy);
    }
  }, {
    key: "dx",
    value: function dx(_dx) {
      return this.dmove(_dx, 0);
    }
  }, {
    key: "dy",
    value: function dy(_dy) {
      return this.dmove(0, _dy);
    }
  }, {
    key: "dmove",
    value: function dmove(dx, dy) {
      this.children().forEach(function (child, i) {
        // Get the childs bbox
        var bbox = child.bbox(); // Get childs matrix

        var m = new Matrix(child); // Translate childs matrix by amount and
        // transform it back into parents space

        var matrix = m.translate(dx, dy).transform(m.inverse()); // Calculate new x and y from old box

        var p = new Point(bbox.x, bbox.y).transform(matrix); // Move element

        child.move(p.x, p.y);
      });
      return this;
    }
  }, {
    key: "width",
    value: function width(_width) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
      if (_width == null) return box.width;
      return this.size(_width, box.height, box);
    }
  }, {
    key: "height",
    value: function height(_height) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
      if (_height == null) return box.height;
      return this.size(box.width, _height, box);
    }
  }, {
    key: "size",
    value: function size(width, height) {
      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
      var p = proportionalSize(this, width, height, box);
      var scaleX = p.width / box.width;
      var scaleY = p.height / box.height;
      this.children().forEach(function (child, i) {
        var o = new Point(box).transform(new Matrix(child).inverse());
        child.scale(scaleX, scaleY, o.x, o.y);
      });
      return this;
    }
  }]);

  return G;
}(Container);

exports.G = G;
registerMethods({
  Container: {
    // Create a group element
    group: wrapWithAttrCheck(function () {
      return this.put(new G());
    })
  }
});
register(G, 'G');

var A = /*#__PURE__*/function (_Container) {
  _inherits(A, _Container);

  function A(node) {
    _classCallCheck(this, A);

    return _possibleConstructorReturn(this, _getPrototypeOf(A).call(this, nodeOrNew('a', node), node));
  } // Link url


  _createClass(A, [{
    key: "to",
    value: function to(url) {
      return this.attr('href', url, xlink);
    } // Link target attribute

  }, {
    key: "target",
    value: function target(_target) {
      return this.attr('target', _target);
    }
  }]);

  return A;
}(Container);

exports.A = A;
registerMethods({
  Container: {
    // Create a hyperlink element
    link: wrapWithAttrCheck(function (url) {
      return this.put(new A()).to(url);
    })
  },
  Element: {
    // Create a hyperlink element
    linkTo: function linkTo(url) {
      var link = new A();

      if (typeof url === 'function') {
        url.call(link, link);
      } else {
        link.to(url);
      }

      return this.parent().put(link).put(this);
    }
  }
});
register(A, 'A');

var Mask = /*#__PURE__*/function (_Container) {
  _inherits(Mask, _Container); // Initialize node


  function Mask(node) {
    _classCallCheck(this, Mask);

    return _possibleConstructorReturn(this, _getPrototypeOf(Mask).call(this, nodeOrNew('mask', node), node));
  } // Unmask all masked elements and remove itself


  _createClass(Mask, [{
    key: "remove",
    value: function remove() {
      // unmask all targets
      this.targets().forEach(function (el) {
        el.unmask();
      }); // remove mask from parent

      return _get(_getPrototypeOf(Mask.prototype), "remove", this).call(this);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg [mask*="' + this.id() + '"]');
    }
  }]);

  return Mask;
}(Container);

exports.Mask = Mask;
registerMethods({
  Container: {
    mask: wrapWithAttrCheck(function () {
      return this.defs().put(new Mask());
    })
  },
  Element: {
    // Distribute mask to svg element
    maskWith: function maskWith(element) {
      // use given mask or create a new one
      var masker = element instanceof Mask ? element : this.parent().mask().add(element); // apply mask

      return this.attr('mask', 'url("#' + masker.id() + '")');
    },
    // Unmask element
    unmask: function unmask() {
      return this.attr('mask', null);
    },
    masker: function masker() {
      return this.reference('mask');
    }
  }
});
register(Mask, 'Mask');

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$3(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function cssRule(selector, rule) {
  if (!selector) return '';
  if (!rule) return selector;
  var ret = selector + '{';

  for (var i in rule) {
    ret += unCamelCase(i) + ':' + rule[i] + ';';
  }

  ret += '}';
  return ret;
}

var Style = /*#__PURE__*/function (_Element) {
  _inherits(Style, _Element);

  function Style(node) {
    _classCallCheck(this, Style);

    return _possibleConstructorReturn(this, _getPrototypeOf(Style).call(this, nodeOrNew('style', node), node));
  }

  _createClass(Style, [{
    key: "addText",
    value: function addText() {
      var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      this.node.textContent += w;
      return this;
    }
  }, {
    key: "font",
    value: function font(name, src) {
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.rule('@font-face', _objectSpread$2({
        fontFamily: name,
        src: src
      }, params));
    }
  }, {
    key: "rule",
    value: function rule(selector, obj) {
      return this.addText(cssRule(selector, obj));
    }
  }]);

  return Style;
}(Element);

exports.Style = Style;
registerMethods('Dom', {
  style: wrapWithAttrCheck(function (selector, obj) {
    return this.put(new Style()).rule(selector, obj);
  }),
  fontface: wrapWithAttrCheck(function (name, src, params) {
    return this.put(new Style()).font(name, src, params);
  })
});
register(Style, 'Style');

var TextPath = /*#__PURE__*/function (_Text) {
  _inherits(TextPath, _Text); // Initialize node


  function TextPath(node) {
    _classCallCheck(this, TextPath);

    return _possibleConstructorReturn(this, _getPrototypeOf(TextPath).call(this, nodeOrNew('textPath', node), node));
  } // return the array of the path track element


  _createClass(TextPath, [{
    key: "array",
    value: function array() {
      var track = this.track();
      return track ? track.array() : null;
    } // Plot path if any

  }, {
    key: "plot",
    value: function plot(d) {
      var track = this.track();
      var pathArray = null;

      if (track) {
        pathArray = track.plot(d);
      }

      return d == null ? pathArray : this;
    } // Get the path element

  }, {
    key: "track",
    value: function track() {
      return this.reference('href');
    }
  }]);

  return TextPath;
}(Text);

exports.TextPath = TextPath;
registerMethods({
  Container: {
    textPath: wrapWithAttrCheck(function (text, path) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = this.text(text);
      }

      return text.path(path);
    })
  },
  Text: {
    // Create path for text to run on
    path: wrapWithAttrCheck(function (track) {
      var importNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var textPath = new TextPath(); // if track is a path, reuse it

      if (!(track instanceof Path)) {
        // create path element
        track = this.defs().path(track);
      } // link textPath to path and add content


      textPath.attr('href', '#' + track, xlink); // Transplant all nodes from text to textPath

      var node;

      if (importNodes) {
        while (node = this.node.firstChild) {
          textPath.node.appendChild(node);
        }
      } // add textPath element as child node and return textPath


      return this.put(textPath);
    }),
    // Get the textPath children
    textPath: function textPath() {
      return this.findOne('textPath');
    }
  },
  Path: {
    // creates a textPath from this path
    text: wrapWithAttrCheck(function (text) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = new Text().addTo(this.parent()).text(text);
      } // Create textPath from text and path and return


      return text.path(this);
    }),
    targets: function targets() {
      return baseFind('svg [href*="' + this.id() + '"]');
    }
  }
});
TextPath.prototype.MorphArray = PathArray;
register(TextPath, 'TextPath');

var Use = /*#__PURE__*/function (_Shape) {
  _inherits(Use, _Shape);

  function Use(node) {
    _classCallCheck(this, Use);

    return _possibleConstructorReturn(this, _getPrototypeOf(Use).call(this, nodeOrNew('use', node), node));
  } // Use element as a reference


  _createClass(Use, [{
    key: "element",
    value: function element(_element, file) {
      // Set lined element
      return this.attr('href', (file || '') + '#' + _element, xlink);
    }
  }]);

  return Use;
}(Shape);

exports.Use = Use;
registerMethods({
  Container: {
    // Create a use element
    use: wrapWithAttrCheck(function (element, file) {
      return this.put(new Use()).element(element, file);
    })
  }
});
register(Use, 'Use');
/* Optional Modules */

var SVG = makeInstance;
exports.SVG = SVG;
extend([Svg, _Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'));
extend([Line, Polyline, Polygon, Path], getMethodsFor('marker'));
extend(Text, getMethodsFor('Text'));
extend(Path, getMethodsFor('Path'));
extend(Defs, getMethodsFor('Defs'));
extend([Text, Tspan], getMethodsFor('Tspan'));
extend([Rect, Ellipse, Circle, Gradient], getMethodsFor('radius'));
extend(EventTarget, getMethodsFor('EventTarget'));
extend(Dom, getMethodsFor('Dom'));
extend(Element, getMethodsFor('Element'));
extend(Shape, getMethodsFor('Shape')); // extend(Element, getConstructor('Memory'))

extend(Container, getMethodsFor('Container'));
extend(Runner, getMethodsFor('Runner'));
List.extend(getMethodNames());
registerMorphableType([SVGNumber, Color, Box, Matrix, SVGArray, PointArray, PathArray]);
makeMorphable();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
// https://d3js.org/d3-quadtree/ v1.0.7 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function tree_add(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries donât change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant canât contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isnât necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

exports.quadtree = quadtree;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],3:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.dat = {})));
}(this, (function (exports) { 'use strict';

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (!this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function ()        {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function ()        {
      dom.addClass(this, 'drag').bind(window, 'touchend', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller,                                   {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};

exports.color = color;
exports.controllers = controllers;
exports.dom = dom$1;
exports.gui = gui;
exports.GUI = GUI$1;
exports['default'] = index;

Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],4:[function(require,module,exports){
(function (global){
/* interact.js 1.9.8 | https://raw.github.com/taye/interact.js/master/LICENSE */
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).interact=t()}}(function(){function t(e){var n;return function(t){return n||e(n={exports:{},parent:t},n.exports),n.exports}}var k=t(function(t,e){"use strict";function a(t){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.Interactable=void 0;var u=r(S),l=n(C),s=n(V),c=n(ct),f=r(w),p=n(ft),i=n(bt),d=m({});function n(t){return t&&t.__esModule?t:{default:t}}function v(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return v=function(){return t},t}function r(t){if(t&&t.__esModule)return t;if(null===t||"object"!==a(t)&&"function"!=typeof t)return{default:t};var e=v();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function o(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function y(t,e,n){return e&&o(t.prototype,e),n&&o(t,n),t}function h(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var g=function(){function o(t,e,n,r){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),this._scopeEvents=r,h(this,"options",void 0),h(this,"_actions",void 0),h(this,"target",void 0),h(this,"events",new i.default),h(this,"_context",void 0),h(this,"_win",void 0),h(this,"_doc",void 0),this._actions=e.actions,this.target=t,this._context=e.context||n,this._win=(0,O.getWindow)((0,$.trySelector)(t)?this._context:t),this._doc=this._win.document,this.set(e)}return y(o,[{key:"_defaults",get:function(){return{base:{},perAction:{},actions:{}}}}]),y(o,[{key:"setOnEvents",value:function(t,e){return f.func(e.onstart)&&this.on("".concat(t,"start"),e.onstart),f.func(e.onmove)&&this.on("".concat(t,"move"),e.onmove),f.func(e.onend)&&this.on("".concat(t,"end"),e.onend),f.func(e.oninertiastart)&&this.on("".concat(t,"inertiastart"),e.oninertiastart),this}},{key:"updatePerActionListeners",value:function(t,e,n){(f.array(e)||f.object(e))&&this.off(t,e),(f.array(n)||f.object(n))&&this.on(t,n)}},{key:"setPerAction",value:function(t,e){var n=this._defaults;for(var r in e){var o=r,i=this.options[t],a=e[o];"listeners"===o&&this.updatePerActionListeners(t,i.listeners,a),f.array(a)?i[o]=u.from(a):f.plainObject(a)?(i[o]=(0,c.default)(i[o]||{},(0,s.default)(a)),f.object(n.perAction[o])&&"enabled"in n.perAction[o]&&(i[o].enabled=!1!==a.enabled)):f.bool(a)&&f.object(n.perAction[o])?i[o].enabled=a:i[o]=a}}},{key:"getRect",value:function(t){return t=t||(f.element(this.target)?this.target:null),f.string(this.target)&&(t=t||this._context.querySelector(this.target)),(0,$.getElementRect)(t)}},{key:"rectChecker",value:function(t){return f.func(t)?(this.getRect=t,this):null===t?(delete this.getRect,this):this.getRect}},{key:"_backCompatOption",value:function(t,e){if((0,$.trySelector)(e)||f.object(e)){for(var n in this.options[t]=e,this._actions.map)this.options[n][t]=e;return this}return this.options[t]}},{key:"origin",value:function(t){return this._backCompatOption("origin",t)}},{key:"deltaSource",value:function(t){return"page"===t||"client"===t?(this.options.deltaSource=t,this):this.options.deltaSource}},{key:"context",value:function(){return this._context}},{key:"inContext",value:function(t){return this._context===t.ownerDocument||(0,$.nodeContains)(this._context,t)}},{key:"testIgnoreAllow",value:function(t,e,n){return!this.testIgnore(t.ignoreFrom,e,n)&&this.testAllow(t.allowFrom,e,n)}},{key:"testAllow",value:function(t,e,n){return!t||!!f.element(n)&&(f.string(t)?(0,$.matchesUpTo)(n,t,e):!!f.element(t)&&(0,$.nodeContains)(t,n))}},{key:"testIgnore",value:function(t,e,n){return!(!t||!f.element(n))&&(f.string(t)?(0,$.matchesUpTo)(n,t,e):!!f.element(t)&&(0,$.nodeContains)(t,n))}},{key:"fire",value:function(t){return this.events.fire(t),this}},{key:"_onOff",value:function(t,e,n,r){f.object(e)&&!f.array(e)&&(r=n,n=null);var o="on"===t?"add":"remove",i=(0,p.default)(e,n);for(var a in i){"wheel"===a&&(a=l.default.wheelEvent);for(var u=0;u<i[a].length;u++){var s=i[a][u];(0,d.isNonNativeEvent)(a,this._actions)?this.events[t](a,s):f.string(this.target)?this._scopeEvents["".concat(o,"Delegate")](this.target,this._context,a,s,r):this._scopeEvents[o](this.target,a,s,r)}}return this}},{key:"on",value:function(t,e,n){return this._onOff("on",t,e,n)}},{key:"off",value:function(t,e,n){return this._onOff("off",t,e,n)}},{key:"set",value:function(t){var e=this._defaults;for(var n in f.object(t)||(t={}),this.options=(0,s.default)(e.base),this._actions.methodDict){var r=n,o=this._actions.methodDict[r];this.options[r]={},this.setPerAction(r,(0,c.default)((0,c.default)({},e.perAction),e.actions[r])),this[o](t[r])}for(var i in t)f.func(this[i])&&this[i](t[i]);return this}},{key:"unset",value:function(){if(f.string(this.target))for(var t in this._scopeEvents.delegatedEvents)for(var e=this._scopeEvents.delegatedEvents[t],n=e.length-1;0<=n;n--){var r=e[n],o=r.selector,i=r.context,a=r.listeners;o===this.target&&i===this._context&&e.splice(n,1);for(var u=a.length-1;0<=u;u--)this._scopeEvents.removeDelegate(this.target,this._context,t,a[u][0],a[u][1])}else this._scopeEvents.remove(this.target,"all")}}]),o}(),b=e.Interactable=g;e.default=b}),m=t(function(t,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNonNativeEvent=function(t,e){if(e.phaselessTypes[t])return!0;for(var n in e.map)if(0===t.indexOf(n)&&t.substr(n.length)in e.phases)return!0;return!1},e.initScope=M,e.Scope=e.default=void 0;var n=d(D),r=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==v(t)&&"function"!=typeof t)return{default:t};var e=p();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),o=d(bt),i=d(We),a=d(T({})),u=d(k({})),s=d(Ze),l=d(ze),c=d(cn),f=d(E({}));function p(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return p=function(){return t},t}function d(t){return t&&t.__esModule?t:{default:t}}function v(t){return(v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function y(t,e){return!e||"object"!==v(e)&&"function"!=typeof e?function(t){if(void 0!==t)return t;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(t):e}function h(t,e,n){return(h="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=g(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function g(t){return(g=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function b(t,e){return(b=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function m(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function O(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function w(t,e,n){return e&&O(t.prototype,e),n&&O(t,n),t}function _(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var P=r.win,x=r.browser,S=r.raf,j=function(){function t(){var e=this;m(this,t),_(this,"id","__interact_scope_".concat(Math.floor(100*Math.random()))),_(this,"isInitialized",!1),_(this,"listenerMaps",[]),_(this,"browser",x),_(this,"utils",r),_(this,"defaults",r.clone(l.default)),_(this,"Eventable",o.default),_(this,"actions",{map:{},phases:{start:!0,move:!0,end:!0},methodDict:{},phaselessTypes:{}}),_(this,"interactStatic",new a.default(this)),_(this,"InteractEvent",i.default),_(this,"Interactable",void 0),_(this,"interactables",new s.default(this)),_(this,"_win",void 0),_(this,"document",void 0),_(this,"window",void 0),_(this,"documents",[]),_(this,"_plugins",{list:[],map:{}}),_(this,"onWindowUnload",function(t){return e.removeDocument(t.target)});var n=this;this.Interactable=function(){function e(){return m(this,e),y(this,g(e).apply(this,arguments))}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&b(t,e)}(e,u["default"]),w(e,[{key:"set",value:function(t){return h(g(e.prototype),"set",this).call(this,t),n.fire("interactable:set",{options:t,interactable:this}),this}},{key:"unset",value:function(){h(g(e.prototype),"unset",this).call(this),n.interactables.list.splice(n.interactables.list.indexOf(this),1),n.fire("interactable:unset",{interactable:this})}},{key:"_defaults",get:function(){return n.defaults}}]),e}()}return w(t,[{key:"addListeners",value:function(t,e){this.listenerMaps.push({id:e,map:t})}},{key:"fire",value:function(t,e){for(var n=0;n<this.listenerMaps.length;n++){var r=this.listenerMaps[n].map[t];if(r&&!1===r(e,this,t))return!1}}},{key:"init",value:function(t){return this.isInitialized?this:M(this,t)}},{key:"pluginIsInstalled",value:function(t){return this._plugins.map[t.id]||-1!==this._plugins.list.indexOf(t)}},{key:"usePlugin",value:function(t,e){if(this.pluginIsInstalled(t))return this;if(t.id&&(this._plugins.map[t.id]=t),this._plugins.list.push(t),t.install&&t.install(this,e),t.listeners&&t.before){for(var n=0,r=this.listenerMaps.length,o=t.before.reduce(function(t,e){return t[e]=!0,t},{});n<r;n++){if(o[this.listenerMaps[n].id])break}this.listenerMaps.splice(n,0,{id:t.id,map:t.listeners})}else t.listeners&&this.listenerMaps.push({id:t.id,map:t.listeners});return this}},{key:"addDocument",value:function(t,e){if(-1!==this.getDocIndex(t))return!1;var n=P.getWindow(t);e=e?r.extend({},e):{},this.documents.push({doc:t,options:e}),this.events.documents.push(t),t!==this.document&&this.events.add(n,"unload",this.onWindowUnload),this.fire("scope:add-document",{doc:t,window:n,scope:this,options:e})}},{key:"removeDocument",value:function(t){var e=this.getDocIndex(t),n=P.getWindow(t),r=this.documents[e].options;this.events.remove(n,"unload",this.onWindowUnload),this.documents.splice(e,1),this.events.documents.splice(e,1),this.fire("scope:remove-document",{doc:t,window:n,scope:this,options:r})}},{key:"getDocIndex",value:function(t){for(var e=0;e<this.documents.length;e++)if(this.documents[e].doc===t)return e;return-1}},{key:"getDocOptions",value:function(t){var e=this.getDocIndex(t);return-1===e?null:this.documents[e].options}},{key:"now",value:function(){return(this.window.Date||Date).now()}}]),t}();function M(t,e){return t.isInitialized=!0,P.init(e),n.default.init(e),x.init(e),S.init(e),t.window=e,t.document=e.document,t.usePlugin(f.default),t.usePlugin(c.default),t}e.Scope=e.default=j}),E=t(function(t,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var _=n(C),u=n(D),P=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==c(t)&&"function"!=typeof t)return{default:t};var e=a();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(zt),s=n(En),l=n(Un),o=n(tr);n(m({}));function a(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return a=function(){return t},t}function n(t){return t&&t.__esModule?t:{default:t}}function c(t){return(c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function x(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function f(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function p(t,e){return!e||"object"!==c(e)&&"function"!=typeof e?function(t){if(void 0!==t)return t;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(t):e}function d(t){return(d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function v(t,e){return(v=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var y=["pointerDown","pointerMove","pointerUp","updatePointer","removePointer","windowBlur"];function h(O,w){return function(t){var e=w.interactions.list,n=P.getPointerType(t),r=x(P.getEventTargets(t),2),o=r[0],i=r[1],a=[];if(/^touch/.test(t.type)){w.prevTouchTime=w.now();for(var u=0;u<t.changedTouches.length;u++){s=t.changedTouches[u];var s,l={pointer:s,pointerId:P.getPointerId(s),pointerType:n,eventType:t.type,eventTarget:o,curEventTarget:i,scope:w},c=S(l);a.push([l.pointer,l.eventTarget,l.curEventTarget,c])}}else{var f=!1;if(!_.default.supportsPointerEvent&&/mouse/.test(t.type)){for(var p=0;p<e.length&&!f;p++)f="mouse"!==e[p].pointerType&&e[p].pointerIsDown;f=f||w.now()-w.prevTouchTime<500||0===t.timeStamp}if(!f){var d={pointer:t,pointerId:P.getPointerId(t),pointerType:n,eventType:t.type,curEventTarget:i,eventTarget:o,scope:w},v=S(d);a.push([d.pointer,d.eventTarget,d.curEventTarget,v])}}for(var y=0;y<a.length;y++){var h=x(a[y],4),g=h[0],b=h[1],m=h[2];h[3][O](g,t,b,m)}}}function S(t){var e=t.pointerType,n=t.scope,r={interaction:o.default.search(t),searchDetails:t};return n.fire("interactions:find",r),r.interaction||n.interactions.new({pointerType:e})}function r(t,e){var n=t.doc,r=t.scope,o=t.options,i=r.interactions.docEvents,a=r.events,u=a[e];for(var s in r.browser.isIOS&&!o.events&&(o.events={passive:!1}),a.delegatedEvents)u(n,s,a.delegateListener),u(n,s,a.delegateUseCapture,!0);for(var l=o&&o.events,c=0;c<i.length;c++){var f;f=i[c];u(n,f.type,f.listener,l)}}var i={id:"core/interactions",install:function(o){for(var t={},e=0;e<y.length;e++){var n;n=y[e];t[n]=h(n,o)}var r,i=_.default.pEventTypes;function a(){for(var t=0;t<o.interactions.list.length;t++){var e=o.interactions.list[t];if(e.pointerIsDown&&"touch"===e.pointerType&&!e._interacting)for(var n=function(){var n=e.pointers[r];o.documents.some(function(t){var e=t.doc;return(0,$.nodeContains)(e,n.downTarget)})||e.removePointer(n.pointer,n.event)},r=0;r<e.pointers.length;r++){n()}}}(r=u.default.PointerEvent?[{type:i.down,listener:a},{type:i.down,listener:t.pointerDown},{type:i.move,listener:t.pointerMove},{type:i.up,listener:t.pointerUp},{type:i.cancel,listener:t.pointerUp}]:[{type:"mousedown",listener:t.pointerDown},{type:"mousemove",listener:t.pointerMove},{type:"mouseup",listener:t.pointerUp},{type:"touchstart",listener:a},{type:"touchstart",listener:t.pointerDown},{type:"touchmove",listener:t.pointerMove},{type:"touchend",listener:t.pointerUp},{type:"touchcancel",listener:t.pointerUp}]).push({type:"blur",listener:function(t){for(var e=0;e<o.interactions.list.length;e++){o.interactions.list[e].documentBlur(t)}}}),o.prevTouchTime=0,o.Interaction=function(){function t(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),p(this,d(t).apply(this,arguments))}var e,n,r;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&v(t,e)}(t,s["default"]),e=t,(n=[{key:"_now",value:function(){return o.now()}},{key:"pointerMoveTolerance",get:function(){return o.interactions.pointerMoveTolerance},set:function(t){o.interactions.pointerMoveTolerance=t}}])&&f(e.prototype,n),r&&f(e,r),t}(),o.interactions={list:[],new:function(t){t.scopeFire=function(t,e){return o.fire(t,e)};var e=new o.Interaction(t);return o.interactions.list.push(e),e},listeners:t,docEvents:r,pointerMoveTolerance:1},o.usePlugin(l.default)},listeners:{"scope:add-document":function(t){return r(t,"add")},"scope:remove-document":function(t){return r(t,"remove")},"interactable:unset":function(t,e){for(var n=t.interactable,r=e.interactions.list.length-1;0<=r;r--){var o=e.interactions.list[r];o.interactable===n&&(o.stop(),e.fire("interactions:destroy",{interaction:o}),o.destroy(),2<e.interactions.list.length&&e.interactions.list.splice(r,1))}}},onDocSignal:r,doOnInteractions:h,methodNames:y};e.default=i}),T=t(function(t,e){"use strict";function a(t){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.InteractStatic=void 0;var n,r=(n=C)&&n.__esModule?n:{default:n},u=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==a(t)&&"function"!=typeof t)return{default:t};var e=l();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),s=m({});function l(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return l=function(){return t},t}function o(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function c(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var i=function(){function a(r){var o=this;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,a),this.scope=r,c(this,"getPointerAverage",u.pointer.pointerAverage),c(this,"getTouchBBox",u.pointer.touchBBox),c(this,"getTouchDistance",u.pointer.touchDistance),c(this,"getTouchAngle",u.pointer.touchAngle),c(this,"getElementRect",u.dom.getElementRect),c(this,"getElementClientRect",u.dom.getElementClientRect),c(this,"matchesSelector",u.dom.matchesSelector),c(this,"closest",u.dom.closest),c(this,"globalEvents",{}),c(this,"dynamicDrop",void 0),c(this,"version","1.9.8"),c(this,"interact",void 0);for(var t=this.constructor.prototype,e=function(t,e){var n=r.interactables.get(t,e);return n||((n=r.interactables.new(t,e)).events.global=o.globalEvents),n},n=0;n<Object.getOwnPropertyNames(this.constructor.prototype).length;n++){var i;i=Object.getOwnPropertyNames(this.constructor.prototype)[n];e[i]=t[i]}return u.extend(e,this),e.constructor=this.constructor,this.interact=e}var t,e,n;return t=a,(e=[{key:"use",value:function(t,e){return this.scope.usePlugin(t,e),this}},{key:"isSet",value:function(t,e){return!!this.scope.interactables.get(t,e&&e.context)}},{key:"on",value:function(t,e,n){if(u.is.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),u.is.array(t)){for(var r=0;r<t.length;r++){var o=t[r];this.on(o,e,n)}return this}if(u.is.object(t)){for(var i in t)this.on(i,t[i],e);return this}return(0,s.isNonNativeEvent)(t,this.scope.actions)?this.globalEvents[t]?this.globalEvents[t].push(e):this.globalEvents[t]=[e]:this.scope.events.add(this.scope.document,t,e,{options:n}),this}},{key:"off",value:function(t,e,n){if(u.is.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),u.is.array(t)){for(var r=0;r<t.length;r++){var o=t[r];this.off(o,e,n)}return this}if(u.is.object(t)){for(var i in t)this.off(i,t[i],e);return this}var a;(0,s.isNonNativeEvent)(t,this.scope.actions)?t in this.globalEvents&&-1!==(a=this.globalEvents[t].indexOf(e))&&this.globalEvents[t].splice(a,1):this.scope.events.remove(this.scope.document,t,e,n);return this}},{key:"debug",value:function(){return this.scope}},{key:"supportsTouch",value:function(){return r.default.supportsTouch}},{key:"supportsPointerEvent",value:function(){return r.default.supportsPointerEvent}},{key:"stop",value:function(){for(var t=0;t<this.scope.interactions.list.length;t++){this.scope.interactions.list[t].stop()}return this}},{key:"pointerMoveTolerance",value:function(t){return u.is.number(t)?(this.scope.interactions.pointerMoveTolerance=t,this):this.scope.interactions.pointerMoveTolerance}},{key:"addDocument",value:function(t,e){this.scope.addDocument(t,e)}},{key:"removeDocument",value:function(t){this.scope.removeDocument(t)}}])&&o(t.prototype,e),n&&o(t,n),a}(),f=e.InteractStatic=i;e.default=f}),e={};Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;e.default=function(t){return!(!t||!t.Window)&&t instanceof t.Window};var O={};Object.defineProperty(O,"__esModule",{value:!0}),O.init=i,O.getWindow=a,O.default=void 0;var n,r=(n=e)&&n.__esModule?n:{default:n};var o={realWindow:void 0,window:void 0,getWindow:a,init:i};function i(t){var e=(o.realWindow=t).document.createTextNode("");e.ownerDocument!==t.document&&"function"==typeof t.wrap&&t.wrap(e)===e&&(t=t.wrap(t)),o.window=t}function a(t){return(0,r.default)(t)?t:(t.ownerDocument||t).defaultView||o.window}"undefined"==typeof window?(o.window=void 0,o.realWindow=void 0):i(window),o.init=i;var u=o;O.default=u;var w={};Object.defineProperty(w,"__esModule",{value:!0}),w.array=w.plainObject=w.element=w.string=w.bool=w.number=w.func=w.object=w.docFrag=w.window=void 0;var s=c(e),l=c(O);function c(t){return t&&t.__esModule?t:{default:t}}function f(t){return(f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}w.window=function(t){return t===l.default.window||(0,s.default)(t)};w.docFrag=function(t){return p(t)&&11===t.nodeType};var p=function(t){return!!t&&"object"===f(t)};w.object=p;function d(t){return"function"==typeof t}w.func=d;w.number=function(t){return"number"==typeof t};w.bool=function(t){return"boolean"==typeof t};w.string=function(t){return"string"==typeof t};w.element=function(t){if(!t||"object"!==f(t))return!1;var e=l.default.getWindow(t)||l.default.window;return/object|function/.test(f(e.Element))?t instanceof e.Element:1===t.nodeType&&"string"==typeof t.nodeName};w.plainObject=function(t){return p(t)&&!!t.constructor&&/function Object\b/.test(t.constructor.toString())};w.array=function(t){return p(t)&&void 0!==t.length&&d(t.splice)};var v={};function y(t){return(y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(v,"__esModule",{value:!0}),v.default=void 0;var h=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==y(t)&&"function"!=typeof t)return{default:t};var e=g();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function g(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return g=function(){return t},t}function b(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.prepared.axis;"x"===n?(e.coords.cur.page.y=e.coords.start.page.y,e.coords.cur.client.y=e.coords.start.client.y,e.coords.velocity.client.y=0,e.coords.velocity.page.y=0):"y"===n&&(e.coords.cur.page.x=e.coords.start.page.x,e.coords.cur.client.x=e.coords.start.client.x,e.coords.velocity.client.x=0,e.coords.velocity.page.x=0)}}function _(t){var e=t.iEvent,n=t.interaction;if("drag"===n.prepared.name){var r=n.prepared.axis;if("x"===r||"y"===r){var o="x"===r?"y":"x";e.page[o]=n.coords.start.page[o],e.client[o]=n.coords.start.client[o],e.delta[o]=0}}}var P={id:"actions/drag",install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.draggable=P.draggable,e.map.drag=P,e.methodDict.drag="draggable",r.actions.drag=P.defaults},listeners:{"interactions:before-action-move":b,"interactions:action-resume":b,"interactions:action-move":_,"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.buttons,o=n.options.drag;if(o&&o.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(r&n.options.drag.mouseButtons)))return!(t.action={name:"drag",axis:"start"===o.lockAxis?o.startAxis:o.lockAxis})}},draggable:function(t){return h.object(t)?(this.options.drag.enabled=!1!==t.enabled,this.setPerAction("drag",t),this.setOnEvents("drag",t),/^(xy|x|y|start)$/.test(t.lockAxis)&&(this.options.drag.lockAxis=t.lockAxis),/^(xy|x|y)$/.test(t.startAxis)&&(this.options.drag.startAxis=t.startAxis),this):h.bool(t)?(this.options.drag.enabled=t,this):this.options.drag},beforeMove:b,move:_,defaults:{startAxis:"xy",lockAxis:"xy"},getCursor:function(){return"move"}},x=P;v.default=x;var S={};Object.defineProperty(S,"__esModule",{value:!0}),S.find=S.findIndex=S.from=S.merge=S.remove=S.contains=void 0;S.contains=function(t,e){return-1!==t.indexOf(e)};S.remove=function(t,e){return t.splice(t.indexOf(e),1)};function j(t,e){for(var n=0;n<e.length;n++){var r=e[n];t.push(r)}return t}S.merge=j;S.from=function(t){return j([],t)};function M(t,e){for(var n=0;n<t.length;n++)if(e(t[n],n,t))return n;return-1}S.findIndex=M;S.find=function(t,e){return t[M(t,e)]};var D={};Object.defineProperty(D,"__esModule",{value:!0}),D.default=void 0;var I={init:function(t){var e=t;I.document=e.document,I.DocumentFragment=e.DocumentFragment||z,I.SVGElement=e.SVGElement||z,I.SVGSVGElement=e.SVGSVGElement||z,I.SVGElementInstance=e.SVGElementInstance||z,I.Element=e.Element||z,I.HTMLElement=e.HTMLElement||I.Element,I.Event=e.Event,I.Touch=e.Touch||z,I.PointerEvent=e.PointerEvent||e.MSPointerEvent},document:null,DocumentFragment:null,SVGElement:null,SVGSVGElement:null,SVGElementInstance:null,Element:null,HTMLElement:null,Event:null,Touch:null,PointerEvent:null};function z(){}var A=I;D.default=A;var C={};function W(t){return(W="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(C,"__esModule",{value:!0}),C.default=void 0;var R=N(D),F=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==W(t)&&"function"!=typeof t)return{default:t};var e=Y();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w),X=N(O);function Y(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Y=function(){return t},t}function N(t){return t&&t.__esModule?t:{default:t}}var L={init:function(t){var e=R.default.Element,n=X.default.window.navigator;L.supportsTouch="ontouchstart"in t||F.func(t.DocumentTouch)&&R.default.document instanceof t.DocumentTouch,L.supportsPointerEvent=!1!==n.pointerEnabled&&!!R.default.PointerEvent,L.isIOS=/iP(hone|od|ad)/.test(n.platform),L.isIOS7=/iP(hone|od|ad)/.test(n.platform)&&/OS 7[^\d]/.test(n.appVersion),L.isIe9=/MSIE 9/.test(n.userAgent),L.isOperaMobile="Opera"===n.appName&&L.supportsTouch&&/Presto/.test(n.userAgent),L.prefixedMatchesSelector="matches"in e.prototype?"matches":"webkitMatchesSelector"in e.prototype?"webkitMatchesSelector":"mozMatchesSelector"in e.prototype?"mozMatchesSelector":"oMatchesSelector"in e.prototype?"oMatchesSelector":"msMatchesSelector",L.pEventTypes=L.supportsPointerEvent?R.default.PointerEvent===t.MSPointerEvent?{up:"MSPointerUp",down:"MSPointerDown",over:"mouseover",out:"mouseout",move:"MSPointerMove",cancel:"MSPointerCancel"}:{up:"pointerup",down:"pointerdown",over:"pointerover",out:"pointerout",move:"pointermove",cancel:"pointercancel"}:null,L.wheelEvent="onmousewheel"in R.default.document?"mousewheel":"wheel"},supportsTouch:null,supportsPointerEvent:null,isIOS7:null,isIOS:null,isIe9:null,isOperaMobile:null,prefixedMatchesSelector:null,pEventTypes:null,wheelEvent:null};var B=L;C.default=B;var V={};function q(t){return(q="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(V,"__esModule",{value:!0}),V.default=function t(e){var n={};for(var r in e){var o=e[r];G.plainObject(o)?n[r]=t(o):G.array(o)?n[r]=U.from(o):n[r]=o}return n};var U=K(S),G=K(w);function H(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return H=function(){return t},t}function K(t){if(t&&t.__esModule)return t;if(null===t||"object"!==q(t)&&"function"!=typeof t)return{default:t};var e=H();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}var $={};function Z(t){return(Z="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty($,"__esModule",{value:!0}),$.nodeContains=function(t,e){for(;e;){if(e===t)return!0;e=e.parentNode}return!1},$.closest=function(t,e){for(;tt.element(t);){if(at(t,e))return t;t=it(t)}return null},$.parentNode=it,$.matchesSelector=at,$.indexOfDeepestElement=function(t){var e,n,r=[],o=t[0],i=o?0:-1;for(e=1;e<t.length;e++){var a=t[e];if(a&&a!==o)if(o){if(a.parentNode!==a.ownerDocument)if(o.parentNode!==a.ownerDocument)if(a.parentNode!==o.parentNode){if(!r.length)for(var u=o,s=void 0;(s=ut(u))&&s!==u.ownerDocument;)r.unshift(u),u=s;var l=void 0;if(o instanceof Q.default.HTMLElement&&a instanceof Q.default.SVGElement&&!(a instanceof Q.default.SVGSVGElement)){if(a===o.parentNode)continue;l=a.ownerSVGElement}else l=a;for(var c=[];l.parentNode!==l.ownerDocument;)c.unshift(l),l=ut(l);for(n=0;c[n]&&c[n]===r[n];)n++;for(var f=[c[n-1],c[n],r[n]],p=f[0].lastChild;p;){if(p===f[1]){o=a,i=e,r=c;break}if(p===f[2])break;p=p.previousSibling}}else{var d=parseInt((0,et.getWindow)(o).getComputedStyle(o).zIndex,10)||0,v=parseInt((0,et.getWindow)(a).getComputedStyle(a).zIndex,10)||0;d<=v&&(o=a,i=e)}else o=a,i=e}else o=a,i=e}return i},$.matchesUpTo=function(t,e,n){for(;tt.element(t);){if(at(t,e))return!0;if((t=it(t))===n)return at(t,e)}return!1},$.getActualElement=function(t){return t instanceof Q.default.SVGElementInstance?t.correspondingUseElement:t},$.getScrollXY=st,$.getElementClientRect=lt,$.getElementRect=function(t){var e=lt(t);if(!J.default.isIOS7&&e){var n=st(et.default.getWindow(t));e.left+=n.x,e.right+=n.x,e.top+=n.y,e.bottom+=n.y}return e},$.getPath=function(t){var e=[];for(;t;)e.push(t),t=it(t);return e},$.trySelector=function(t){return!!tt.string(t)&&(Q.default.document.querySelector(t),!0)};var J=ot(C),Q=ot(D),tt=rt(w),et=rt(O);function nt(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return nt=function(){return t},t}function rt(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Z(t)&&"function"!=typeof t)return{default:t};var e=nt();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function ot(t){return t&&t.__esModule?t:{default:t}}function it(t){var e=t.parentNode;if(tt.docFrag(e)){for(;(e=e.host)&&tt.docFrag(e););return e}return e}function at(t,e){return et.default.window!==et.default.realWindow&&(e=e.replace(/\/deep\//g," ")),t[J.default.prefixedMatchesSelector](e)}var ut=function(t){return t.parentNode?t.parentNode:t.host};function st(t){return{x:(t=t||et.default.window).scrollX||t.document.documentElement.scrollLeft,y:t.scrollY||t.document.documentElement.scrollTop}}function lt(t){var e=t instanceof Q.default.SVGElement?t.getBoundingClientRect():t.getClientRects()[0];return e&&{left:e.left,right:e.right,top:e.top,bottom:e.bottom,width:e.width||e.right-e.left,height:e.height||e.bottom-e.top}}var ct={};Object.defineProperty(ct,"__esModule",{value:!0}),ct.default=function(t,e){for(var n in e)t[n]=e[n];return t};var ft={};function pt(t){return(pt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(ft,"__esModule",{value:!0}),ft.default=function n(e,r,o){o=o||{};yt.string(e)&&-1!==e.search(" ")&&(e=gt(e));if(yt.array(e))return e.reduce(function(t,e){return(0,vt.default)(t,n(e,r,o))},o);yt.object(e)&&(r=e,e="");if(yt.func(r))o[e]=o[e]||[],o[e].push(r);else if(yt.array(r))for(var t=0;t<r.length;t++){var i=r[t];n(e,i,o)}else if(yt.object(r))for(var a in r){var u=gt(a).map(function(t){return"".concat(e).concat(t)});n(u,r[a],o)}return o};var dt,vt=(dt=ct)&&dt.__esModule?dt:{default:dt},yt=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==pt(t)&&"function"!=typeof t)return{default:t};var e=ht();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function ht(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ht=function(){return t},t}function gt(t){return t.trim().split(/ +/)}var bt={};function mt(t){return(mt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(bt,"__esModule",{value:!0}),bt.default=void 0;var Ot=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==mt(t)&&"function"!=typeof t)return{default:t};var e=xt();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(S),wt=Pt(ct),_t=Pt(ft);function Pt(t){return t&&t.__esModule?t:{default:t}}function xt(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return xt=function(){return t},t}function St(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function jt(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function Mt(t,e){for(var n=0;n<e.length;n++){var r=e[n];if(t.immediatePropagationStopped)break;r(t)}}var kt=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),jt(this,"options",void 0),jt(this,"types",{}),jt(this,"propagationStopped",!1),jt(this,"immediatePropagationStopped",!1),jt(this,"global",void 0),this.options=(0,wt.default)({},t||{})}var t,n,r;return t=e,(n=[{key:"fire",value:function(t){var e,n=this.global;(e=this.types[t.type])&&Mt(t,e),!t.propagationStopped&&n&&(e=n[t.type])&&Mt(t,e)}},{key:"on",value:function(t,e){var n=(0,_t.default)(t,e);for(t in n)this.types[t]=Ot.merge(this.types[t]||[],n[t])}},{key:"off",value:function(t,e){var n=(0,_t.default)(t,e);for(t in n){var r=this.types[t];if(r&&r.length)for(var o=0;o<n[t].length;o++){var i=n[t][o],a=r.indexOf(i);-1!==a&&r.splice(a,1)}}}},{key:"getRect",value:function(){return null}}])&&St(t.prototype,n),r&&St(t,r),e}();bt.default=kt;var Et={};Object.defineProperty(Et,"__esModule",{value:!0}),Et.default=void 0;Et.default=function(t,e){return Math.sqrt(t*t+e*e)};var Tt={};function Dt(t,e){for(var n in e){var r=Dt.prefixedPropREs,o=!1;for(var i in r)if(0===n.indexOf(i)&&r[i].test(n)){o=!0;break}o||"function"==typeof e[n]||(t[n]=e[n])}return t}Object.defineProperty(Tt,"__esModule",{value:!0}),Tt.default=void 0,Dt.prefixedPropREs={webkit:/(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,moz:/(Pressure)$/};var It=Dt;Tt.default=It;var zt={};function At(t){return(At="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(zt,"__esModule",{value:!0}),zt.copyCoords=function(t,e){t.page=t.page||{},t.page.x=e.page.x,t.page.y=e.page.y,t.client=t.client||{},t.client.x=e.client.x,t.client.y=e.client.y,t.timeStamp=e.timeStamp},zt.setCoordDeltas=function(t,e,n){t.page.x=n.page.x-e.page.x,t.page.y=n.page.y-e.page.y,t.client.x=n.client.x-e.client.x,t.client.y=n.client.y-e.client.y,t.timeStamp=n.timeStamp-e.timeStamp},zt.setCoordVelocity=function(t,e){var n=Math.max(e.timeStamp/1e3,.001);t.page.x=e.page.x/n,t.page.y=e.page.y/n,t.client.x=e.client.x/n,t.client.y=e.client.y/n,t.timeStamp=n},zt.setZeroCoords=function(t){t.page.x=0,t.page.y=0,t.client.x=0,t.client.y=0},zt.isNativePointer=Vt,zt.getXY=qt,zt.getPageXY=Ut,zt.getClientXY=Gt,zt.getPointerId=function(t){return Xt.number(t.pointerId)?t.pointerId:t.identifier},zt.setCoords=function(t,e,n){var r=1<e.length?Kt(e):e[0],o={};Ut(r,o),t.page.x=o.x,t.page.y=o.y,Gt(r,o),t.client.x=o.x,t.client.y=o.y,t.timeStamp=n},zt.getTouchPair=Ht,zt.pointerAverage=Kt,zt.touchBBox=function(t){if(!(t.length||t.touches&&1<t.touches.length))return null;var e=Ht(t),n=Math.min(e[0].pageX,e[1].pageX),r=Math.min(e[0].pageY,e[1].pageY),o=Math.max(e[0].pageX,e[1].pageX),i=Math.max(e[0].pageY,e[1].pageY);return{x:n,y:r,left:n,top:r,right:o,bottom:i,width:o-n,height:i-r}},zt.touchDistance=function(t,e){var n=e+"X",r=e+"Y",o=Ht(t),i=o[0][n]-o[1][n],a=o[0][r]-o[1][r];return(0,Ft.default)(i,a)},zt.touchAngle=function(t,e){var n=e+"X",r=e+"Y",o=Ht(t),i=o[1][n]-o[0][n],a=o[1][r]-o[0][r];return 180*Math.atan2(a,i)/Math.PI},zt.getPointerType=function(t){return Xt.string(t.pointerType)?t.pointerType:Xt.number(t.pointerType)?[void 0,void 0,"touch","pen","mouse"][t.pointerType]:/touch/.test(t.type)||t instanceof Wt.default.Touch?"touch":"mouse"},zt.getEventTargets=function(t){var e=Xt.func(t.composedPath)?t.composedPath():t.path;return[Rt.getActualElement(e?e[0]:t.target),Rt.getActualElement(t.currentTarget)]},zt.newCoords=function(){return{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0}},zt.coordsToEvent=function(t){return{coords:t,get page(){return this.coords.page},get client(){return this.coords.client},get timeStamp(){return this.coords.timeStamp},get pageX(){return this.coords.page.x},get pageY(){return this.coords.page.y},get clientX(){return this.coords.client.x},get clientY(){return this.coords.client.y},get pointerId(){return this.coords.pointerId},get target(){return this.coords.target},get type(){return this.coords.type},get pointerType(){return this.coords.pointerType},get buttons(){return this.coords.buttons},preventDefault:function(){}}},Object.defineProperty(zt,"pointerExtend",{enumerable:!0,get:function(){return Yt.default}});var Ct=Bt(C),Wt=Bt(D),Rt=Lt($),Ft=Bt(Et),Xt=Lt(w),Yt=Bt(Tt);function Nt(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Nt=function(){return t},t}function Lt(t){if(t&&t.__esModule)return t;if(null===t||"object"!==At(t)&&"function"!=typeof t)return{default:t};var e=Nt();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function Bt(t){return t&&t.__esModule?t:{default:t}}function Vt(t){return t instanceof Wt.default.Event||t instanceof Wt.default.Touch}function qt(t,e,n){return(n=n||{}).x=e[(t=t||"page")+"X"],n.y=e[t+"Y"],n}function Ut(t,e){return e=e||{x:0,y:0},Ct.default.isOperaMobile&&Vt(t)?(qt("screen",t,e),e.x+=window.scrollX,e.y+=window.scrollY):qt("page",t,e),e}function Gt(t,e){return e=e||{},Ct.default.isOperaMobile&&Vt(t)?qt("screen",t,e):qt("client",t,e),e}function Ht(t){var e=[];return Xt.array(t)?(e[0]=t[0],e[1]=t[1]):"touchend"===t.type?1===t.touches.length?(e[0]=t.touches[0],e[1]=t.changedTouches[0]):0===t.touches.length&&(e[0]=t.changedTouches[0],e[1]=t.changedTouches[1]):(e[0]=t.touches[0],e[1]=t.touches[1]),e}function Kt(t){for(var e={pageX:0,pageY:0,clientX:0,clientY:0,screenX:0,screenY:0},n=0;n<t.length;n++){var r=t[n];for(var o in e)e[o]+=r[o]}for(var i in e)e[i]/=t.length;return e}var $t={};function Zt(t){return(Zt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty($t,"__esModule",{value:!0}),$t.getStringOptionResult=ne,$t.resolveRectLike=function(t,e,n,r){var o=t;te.string(o)?o=ne(o,e,n):te.func(o)&&(o=o.apply(void 0,function(t){return function(t){if(Array.isArray(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}}(t)||function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}(r)));te.element(o)&&(o=(0,$.getElementRect)(o));return o},$t.rectToXY=function(t){return t&&{x:"x"in t?t.x:t.left,y:"y"in t?t.y:t.top}},$t.xywhToTlbr=function(t){!t||"left"in t&&"top"in t||((t=(0,Qt.default)({},t)).left=t.x||0,t.top=t.y||0,t.right=t.right||t.left+t.width,t.bottom=t.bottom||t.top+t.height);return t},$t.tlbrToXywh=function(t){!t||"x"in t&&"y"in t||((t=(0,Qt.default)({},t)).x=t.left||0,t.y=t.top||0,t.width=t.width||t.right||0-t.x,t.height=t.height||t.bottom||0-t.y);return t},$t.addEdges=function(t,e,n){t.left&&(e.left+=n.x);t.right&&(e.right+=n.x);t.top&&(e.top+=n.y);t.bottom&&(e.bottom+=n.y);e.width=e.right-e.left,e.height=e.bottom-e.top};var Jt,Qt=(Jt=ct)&&Jt.__esModule?Jt:{default:Jt},te=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Zt(t)&&"function"!=typeof t)return{default:t};var e=ee();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function ee(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ee=function(){return t},t}function ne(t,e,n){return"parent"===t?(0,$.parentNode)(n):"self"===t?e.getRect(n):(0,$.closest)(n,t)}var re={};Object.defineProperty(re,"__esModule",{value:!0}),re.default=function(t,e,n){var r=t.options[n],o=r&&r.origin||t.options.origin,i=(0,$t.resolveRectLike)(o,t,e,[t&&e]);return(0,$t.rectToXY)(i)||{x:0,y:0}};var oe={};Object.defineProperty(oe,"__esModule",{value:!0}),oe.default=void 0;var ie,ae,ue=0;var se={request:function(t){return ie(t)},cancel:function(t){return ae(t)},init:function(t){if(ie=t.requestAnimationFrame,ae=t.cancelAnimationFrame,!ie)for(var e=["ms","moz","webkit","o"],n=0;n<e.length;n++){var r=e[n];ie=t["".concat(r,"RequestAnimationFrame")],ae=t["".concat(r,"CancelAnimationFrame")]||t["".concat(r,"CancelRequestAnimationFrame")]}ie||(ie=function(t){var e=Date.now(),n=Math.max(0,16-(e-ue)),r=setTimeout(function(){t(e+n)},n);return ue=e+n,r},ae=function(t){return clearTimeout(t)})}};oe.default=se;var le={};function ce(t){return(ce="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(le,"__esModule",{value:!0}),le.warnOnce=function(t,e){var n=!1;return function(){return n||(he.default.window.console.warn(e),n=!0),t.apply(this,arguments)}},le.copyAction=function(t,e){return t.name=e.name,t.axis=e.axis,t.edges=e.edges,t},Object.defineProperty(le,"win",{enumerable:!0,get:function(){return he.default}}),Object.defineProperty(le,"browser",{enumerable:!0,get:function(){return ge.default}}),Object.defineProperty(le,"clone",{enumerable:!0,get:function(){return be.default}}),Object.defineProperty(le,"extend",{enumerable:!0,get:function(){return me.default}}),Object.defineProperty(le,"getOriginXY",{enumerable:!0,get:function(){return Oe.default}}),Object.defineProperty(le,"hypot",{enumerable:!0,get:function(){return we.default}}),Object.defineProperty(le,"normalizeListeners",{enumerable:!0,get:function(){return _e.default}}),Object.defineProperty(le,"raf",{enumerable:!0,get:function(){return Pe.default}}),le.rect=le.pointer=le.is=le.dom=le.arr=void 0;var fe=je(S);le.arr=fe;var pe=je($);le.dom=pe;var de=je(w);le.is=de;var ve=je(zt);le.pointer=ve;var ye=je($t);le.rect=ye;var he=xe(O),ge=xe(C),be=xe(V),me=xe(ct),Oe=xe(re),we=xe(Et),_e=xe(ft),Pe=xe(oe);function xe(t){return t&&t.__esModule?t:{default:t}}function Se(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Se=function(){return t},t}function je(t){if(t&&t.__esModule)return t;if(null===t||"object"!==ce(t)&&"function"!=typeof t)return{default:t};var e=Se();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}var Me={};function ke(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Ee(t,e,n){return e&&ke(t.prototype,e),n&&ke(t,n),t}function Te(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}Object.defineProperty(Me,"__esModule",{value:!0}),Me.default=Me.BaseEvent=void 0;var De=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Te(this,"type",void 0),Te(this,"target",void 0),Te(this,"currentTarget",void 0),Te(this,"interactable",void 0),Te(this,"_interaction",void 0),Te(this,"timeStamp",void 0),Te(this,"immediatePropagationStopped",!1),Te(this,"propagationStopped",!1),this._interaction=t}return Ee(e,[{key:"interaction",get:function(){return this._interaction._proxy}}]),Ee(e,[{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}]),e}(),Ie=Me.BaseEvent=De;Me.default=Ie;var ze={};Object.defineProperty(ze,"__esModule",{value:!0}),ze.default=ze.defaults=void 0;var Ae={base:{preventDefault:"auto",deltaSource:"page"},perAction:{enabled:!1,origin:{x:0,y:0}},actions:{}},Ce=ze.defaults=Ae;ze.default=Ce;var We={};Object.defineProperty(We,"__esModule",{value:!0}),We.default=We.InteractEvent=void 0;var Re=Le(ct),Fe=Le(re),Xe=Le(Et),Ye=Le(Me),Ne=Le(ze);function Le(t){return t&&t.__esModule?t:{default:t}}function Be(t){return(Be="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Ve(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function qe(t){return(qe=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ue(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ge(t,e){return(Ge=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function He(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Ke=function(){function g(t,e,n,r,o,i,a){var u,s,l;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,g),s=this,u=!(l=qe(g).call(this,t))||"object"!==Be(l)&&"function"!=typeof l?Ue(s):l,He(Ue(u),"target",void 0),He(Ue(u),"currentTarget",void 0),He(Ue(u),"relatedTarget",null),He(Ue(u),"screenX",void 0),He(Ue(u),"screenY",void 0),He(Ue(u),"button",void 0),He(Ue(u),"buttons",void 0),He(Ue(u),"ctrlKey",void 0),He(Ue(u),"shiftKey",void 0),He(Ue(u),"altKey",void 0),He(Ue(u),"metaKey",void 0),He(Ue(u),"page",void 0),He(Ue(u),"client",void 0),He(Ue(u),"delta",void 0),He(Ue(u),"rect",void 0),He(Ue(u),"x0",void 0),He(Ue(u),"y0",void 0),He(Ue(u),"t0",void 0),He(Ue(u),"dt",void 0),He(Ue(u),"duration",void 0),He(Ue(u),"clientX0",void 0),He(Ue(u),"clientY0",void 0),He(Ue(u),"velocity",void 0),He(Ue(u),"speed",void 0),He(Ue(u),"swipe",void 0),He(Ue(u),"timeStamp",void 0),He(Ue(u),"dragEnter",void 0),He(Ue(u),"dragLeave",void 0),He(Ue(u),"axes",void 0),He(Ue(u),"preEnd",void 0),o=o||t.element;var c=t.interactable,f=(c&&c.options||Ne.default).deltaSource,p=(0,Fe.default)(c,o,n),d="start"===r,v="end"===r,y=d?Ue(u):t.prevEvent,h=d?t.coords.start:v?{page:y.page,client:y.client,timeStamp:t.coords.cur.timeStamp}:t.coords.cur;return u.page=(0,Re.default)({},h.page),u.client=(0,Re.default)({},h.client),u.rect=(0,Re.default)({},t.rect),u.timeStamp=h.timeStamp,v||(u.page.x-=p.x,u.page.y-=p.y,u.client.x-=p.x,u.client.y-=p.y),u.ctrlKey=e.ctrlKey,u.altKey=e.altKey,u.shiftKey=e.shiftKey,u.metaKey=e.metaKey,u.button=e.button,u.buttons=e.buttons,u.target=o,u.currentTarget=o,u.preEnd=i,u.type=a||n+(r||""),u.interactable=c,u.t0=d?t.pointers[t.pointers.length-1].downTime:y.t0,u.x0=t.coords.start.page.x-p.x,u.y0=t.coords.start.page.y-p.y,u.clientX0=t.coords.start.client.x-p.x,u.clientY0=t.coords.start.client.y-p.y,u.delta=d||v?{x:0,y:0}:{x:u[f].x-y[f].x,y:u[f].y-y[f].y},u.dt=t.coords.delta.timeStamp,u.duration=u.timeStamp-u.t0,u.velocity=(0,Re.default)({},t.coords.velocity[f]),u.speed=(0,Xe.default)(u.velocity.x,u.velocity.y),u.swipe=v||"inertiastart"===r?u.getSwipe():null,u}var t,e,n;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ge(t,e)}(g,Ye["default"]),t=g,(e=[{key:"getSwipe",value:function(){var t=this._interaction;if(t.prevEvent.speed<600||150<this.timeStamp-t.prevEvent.timeStamp)return null;var e=180*Math.atan2(t.prevEvent.velocityY,t.prevEvent.velocityX)/Math.PI;e<0&&(e+=360);var n=112.5<=e&&e<247.5,r=202.5<=e&&e<337.5;return{up:r,down:!r&&22.5<=e&&e<157.5,left:n,right:!n&&(292.5<=e||e<67.5),angle:e,speed:t.prevEvent.speed,velocity:{x:t.prevEvent.velocityX,y:t.prevEvent.velocityY}}}},{key:"preventDefault",value:function(){}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"pageX",get:function(){return this.page.x},set:function(t){this.page.x=t}},{key:"pageY",get:function(){return this.page.y},set:function(t){this.page.y=t}},{key:"clientX",get:function(){return this.client.x},set:function(t){this.client.x=t}},{key:"clientY",get:function(){return this.client.y},set:function(t){this.client.y=t}},{key:"dx",get:function(){return this.delta.x},set:function(t){this.delta.x=t}},{key:"dy",get:function(){return this.delta.y},set:function(t){this.delta.y=t}},{key:"velocityX",get:function(){return this.velocity.x},set:function(t){this.velocity.x=t}},{key:"velocityY",get:function(){return this.velocity.y},set:function(t){this.velocity.y=t}}])&&Ve(t.prototype,e),n&&Ve(t,n),g}(),$e=We.InteractEvent=Ke;We.default=$e;var Ze={};function Je(t){return(Je="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ze,"__esModule",{value:!0}),Ze.default=void 0;var Qe,tn=an(S),en=an($),nn=(Qe=ct)&&Qe.__esModule?Qe:{default:Qe},rn=an(w);function on(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return on=function(){return t},t}function an(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Je(t)&&"function"!=typeof t)return{default:t};var e=on();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function un(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function sn(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var ln=function(){function e(t){var a=this;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.scope=t,sn(this,"list",[]),sn(this,"selectorMap",{}),t.addListeners({"interactable:unset":function(t){var e=t.interactable,n=e.target,r=e._context,o=rn.string(n)?a.selectorMap[n]:n[a.scope.id],i=o.findIndex(function(t){return t.context===r});o[i]&&(o[i].context=null,o[i].interactable=null),o.splice(i,1)}})}var t,n,r;return t=e,(n=[{key:"new",value:function(t,e){e=(0,nn.default)(e||{},{actions:this.scope.actions});var n=new this.scope.Interactable(t,e,this.scope.document,this.scope.events),r={context:n._context,interactable:n};return this.scope.addDocument(n._doc),this.list.push(n),rn.string(t)?(this.selectorMap[t]||(this.selectorMap[t]=[]),this.selectorMap[t].push(r)):(n.target[this.scope.id]||Object.defineProperty(t,this.scope.id,{value:[],configurable:!0}),t[this.scope.id].push(r)),this.scope.fire("interactable:new",{target:t,options:e,interactable:n,win:this.scope._win}),n}},{key:"get",value:function(e,t){var n=t&&t.context||this.scope.document,r=rn.string(e),o=r?this.selectorMap[e]:e[this.scope.id];if(!o)return null;var i=tn.find(o,function(t){return t.context===n&&(r||t.interactable.inContext(e))});return i&&i.interactable}},{key:"forEachMatch",value:function(t,e){for(var n=0;n<this.list.length;n++){var r=this.list[n],o=void 0;if((rn.string(r.target)?rn.element(t)&&en.matchesSelector(t,r.target):t===r.target)&&r.inContext(t)&&(o=e(r)),void 0!==o)return o}}}])&&un(t.prototype,n),r&&un(t,r),e}();Ze.default=ln;var cn={};function fn(t){return(fn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(cn,"__esModule",{value:!0}),cn.default=cn.FakeEvent=void 0;var pn=On(S),dn=On($),vn=bn(ct),yn=On(w),hn=bn(Tt),gn=On(zt);function bn(t){return t&&t.__esModule?t:{default:t}}function mn(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return mn=function(){return t},t}function On(t){if(t&&t.__esModule)return t;if(null===t||"object"!==fn(t)&&"function"!=typeof t)return{default:t};var e=mn();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function wn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function _n(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var Pn=function(){function o(t){var e,n,r;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),this.originalEvent=t,r=void 0,(n="currentTarget")in(e=this)?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,(0,hn.default)(this,t)}var t,e,n;return t=o,(e=[{key:"preventOriginalDefault",value:function(){this.originalEvent.preventDefault()}},{key:"stopPropagation",value:function(){this.originalEvent.stopPropagation()}},{key:"stopImmediatePropagation",value:function(){this.originalEvent.stopImmediatePropagation()}}])&&wn(t.prototype,e),n&&wn(t,n),o}();function xn(t){if(!yn.object(t))return{capture:!!t,passive:!1};var e=(0,vn.default)({},t);return e.capture=!!t.capture,e.passive=!!t.passive,e}cn.FakeEvent=Pn;var Sn={id:"events",install:function(t){var f=[],b={},c=[],p={add:d,remove:g,addDelegate:function(e,n,t,r,o){var i=xn(o);if(!b[t]){b[t]=[];for(var a=0;a<c.length;a++){var u=c[a];d(u,t,m),d(u,t,O,!0)}}var s=b[t],l=pn.find(s,function(t){return t.selector===e&&t.context===n});l||(l={selector:e,context:n,listeners:[]},s.push(l));l.listeners.push([r,i])},removeDelegate:function(t,e,n,r,o){var i,a=xn(o),u=b[n],s=!1;if(!u)return;for(i=u.length-1;0<=i;i--){var l=u[i];if(l.selector===t&&l.context===e){for(var c=l.listeners,f=c.length-1;0<=f;f--){var p=_n(c[f],2),d=p[0],v=p[1],y=v.capture,h=v.passive;if(d===r&&y===a.capture&&h===a.passive){c.splice(f,1),c.length||(u.splice(i,1),g(e,n,m),g(e,n,O,!0)),s=!0;break}}if(s)break}}},delegateListener:m,delegateUseCapture:O,delegatedEvents:b,documents:c,targets:f,supportsOptions:!1,supportsPassive:!1};function d(e,t,n,r){var o=xn(r),i=pn.find(f,function(t){return t.eventTarget===e});i||(i={eventTarget:e,events:{}},f.push(i)),i.events[t]||(i.events[t]=[]),e.addEventListener&&!pn.contains(i.events[t],n)&&(e.addEventListener(t,n,p.supportsOptions?o:o.capture),i.events[t].push(n))}function g(e,t,n,r){var o=xn(r),i=pn.findIndex(f,function(t){return t.eventTarget===e}),a=f[i];if(a&&a.events)if("all"!==t){var u=!1,s=a.events[t];if(s){if("all"===n){for(var l=s.length-1;0<=l;l--)g(e,t,s[l],o);return}for(var c=0;c<s.length;c++)if(s[c]===n){e.removeEventListener(t,n,p.supportsOptions?o:o.capture),s.splice(c,1),0===s.length&&(delete a.events[t],u=!0);break}}u&&!Object.keys(a.events).length&&f.splice(i,1)}else for(t in a.events)a.events.hasOwnProperty(t)&&g(e,t,"all")}function m(t,e){for(var n=xn(e),r=new Pn(t),o=b[t.type],i=_n(gn.getEventTargets(t),1)[0],a=i;yn.element(a);){for(var u=0;u<o.length;u++){var s=o[u],l=s.selector,c=s.context;if(dn.matchesSelector(a,l)&&dn.nodeContains(c,i)&&dn.nodeContains(c,a)){var f=s.listeners;r.currentTarget=a;for(var p=0;p<f.length;p++){var d=_n(f[p],2),v=d[0],y=d[1],h=y.capture,g=y.passive;h===n.capture&&g===n.passive&&v(r)}}}a=dn.parentNode(a)}}function O(t){return m.call(this,t,!0)}return t.document.createElement("div").addEventListener("test",null,{get capture(){return p.supportsOptions=!0},get passive(){return p.supportsPassive=!0}}),t.events=p}};cn.default=Sn;var jn={};Object.defineProperty(jn,"__esModule",{value:!0}),jn.default=jn.PointerInfo=void 0;function Mn(t,e,n,r,o){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,Mn),this.id=t,this.pointer=e,this.event=n,this.downTime=r,this.downTarget=o}var kn=jn.PointerInfo=Mn;jn.default=kn;var En={};function Tn(t){return(Tn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(En,"__esModule",{value:!0}),Object.defineProperty(En,"PointerInfo",{enumerable:!0,get:function(){return Rn.default}}),En.default=En.Interaction=En._ProxyMethods=En._ProxyValues=void 0;var Dn,In,zn,An,Cn=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Tn(t)&&"function"!=typeof t)return{default:t};var e=Xn();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),Wn=Fn(We),Rn=Fn(jn);function Fn(t){return t&&t.__esModule?t:{default:t}}function Xn(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Xn=function(){return t},t}function Yn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Nn(t,e,n){return e&&Yn(t.prototype,e),n&&Yn(t,n),t}function Ln(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}En._ProxyValues=Dn,(In=Dn||(En._ProxyValues=Dn={})).interactable="",In.element="",In.prepared="",In.pointerIsDown="",In.pointerWasMoved="",In._proxy="",En._ProxyMethods=zn,(An=zn||(En._ProxyMethods=zn={})).start="",An.move="",An.end="",An.stop="",An.interacting="";var Bn=0,Vn=function(){function l(t){var e=this,n=t.pointerType,r=t.scopeFire;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,l),Ln(this,"interactable",null),Ln(this,"element",null),Ln(this,"rect",void 0),Ln(this,"_rects",void 0),Ln(this,"edges",void 0),Ln(this,"_scopeFire",void 0),Ln(this,"prepared",{name:null,axis:null,edges:null}),Ln(this,"pointerType",void 0),Ln(this,"pointers",[]),Ln(this,"downEvent",null),Ln(this,"downPointer",{}),Ln(this,"_latestPointer",{pointer:null,event:null,eventTarget:null}),Ln(this,"prevEvent",null),Ln(this,"pointerIsDown",!1),Ln(this,"pointerWasMoved",!1),Ln(this,"_interacting",!1),Ln(this,"_ending",!1),Ln(this,"_stopped",!0),Ln(this,"_proxy",null),Ln(this,"simulation",null),Ln(this,"doMove",Cn.warnOnce(function(t){this.move(t)},"The interaction.doMove() method has been renamed to interaction.move()")),Ln(this,"coords",{start:Cn.pointer.newCoords(),prev:Cn.pointer.newCoords(),cur:Cn.pointer.newCoords(),delta:Cn.pointer.newCoords(),velocity:Cn.pointer.newCoords()}),Ln(this,"_id",Bn++),this._scopeFire=r,this.pointerType=n;var o=this;this._proxy={};function i(t){Object.defineProperty(e._proxy,t,{get:function(){return o[t]}})}for(var a in Dn)i(a);function u(t){Object.defineProperty(e._proxy,t,{value:function(){return o[t].apply(o,arguments)}})}for(var s in zn)u(s);this._scopeFire("interactions:new",{interaction:this})}return Nn(l,[{key:"pointerMoveTolerance",get:function(){return 1}}]),Nn(l,[{key:"pointerDown",value:function(t,e,n){var r=this.updatePointer(t,e,n,!0),o=this.pointers[r];this._scopeFire("interactions:down",{pointer:t,event:e,eventTarget:n,pointerIndex:r,pointerInfo:o,type:"down",interaction:this})}},{key:"start",value:function(t,e,n){return!(this.interacting()||!this.pointerIsDown||this.pointers.length<("gesture"===t.name?2:1)||!e.options[t.name].enabled)&&(Cn.copyAction(this.prepared,t),this.interactable=e,this.element=n,this.rect=e.getRect(n),this.edges=this.prepared.edges?Cn.extend({},this.prepared.edges):{left:!0,right:!0,top:!0,bottom:!0},this._stopped=!1,this._interacting=this._doPhase({interaction:this,event:this.downEvent,phase:"start"})&&!this._stopped,this._interacting)}},{key:"pointerMove",value:function(t,e,n){this.simulation||this.modification&&this.modification.endResult||this.updatePointer(t,e,n,!1);var r,o,i=this.coords.cur.page.x===this.coords.prev.page.x&&this.coords.cur.page.y===this.coords.prev.page.y&&this.coords.cur.client.x===this.coords.prev.client.x&&this.coords.cur.client.y===this.coords.prev.client.y;this.pointerIsDown&&!this.pointerWasMoved&&(r=this.coords.cur.client.x-this.coords.start.client.x,o=this.coords.cur.client.y-this.coords.start.client.y,this.pointerWasMoved=Cn.hypot(r,o)>this.pointerMoveTolerance);var a=this.getPointerIndex(t),u={pointer:t,pointerIndex:a,pointerInfo:this.pointers[a],event:e,type:"move",eventTarget:n,dx:r,dy:o,duplicate:i,interaction:this};i||Cn.pointer.setCoordVelocity(this.coords.velocity,this.coords.delta),this._scopeFire("interactions:move",u),i||this.simulation||(this.interacting()&&(u.type=null,this.move(u)),this.pointerWasMoved&&Cn.pointer.copyCoords(this.coords.prev,this.coords.cur))}},{key:"move",value:function(t){t&&t.event||Cn.pointer.setZeroCoords(this.coords.delta),(t=Cn.extend({pointer:this._latestPointer.pointer,event:this._latestPointer.event,eventTarget:this._latestPointer.eventTarget,interaction:this},t||{})).phase="move",this._doPhase(t)}},{key:"pointerUp",value:function(t,e,n,r){var o=this.getPointerIndex(t);-1===o&&(o=this.updatePointer(t,e,n,!1));var i=/cancel$/i.test(e.type)?"cancel":"up";this._scopeFire("interactions:".concat(i),{pointer:t,pointerIndex:o,pointerInfo:this.pointers[o],event:e,eventTarget:n,type:i,curEventTarget:r,interaction:this}),this.simulation||this.end(e),this.pointerIsDown=!1,this.removePointer(t,e)}},{key:"documentBlur",value:function(t){this.end(t),this._scopeFire("interactions:blur",{event:t,type:"blur",interaction:this})}},{key:"end",value:function(t){var e;this._ending=!0,t=t||this._latestPointer.event,this.interacting()&&(e=this._doPhase({event:t,interaction:this,phase:"end"})),!(this._ending=!1)===e&&this.stop()}},{key:"currentAction",value:function(){return this._interacting?this.prepared.name:null}},{key:"interacting",value:function(){return this._interacting}},{key:"stop",value:function(){this._scopeFire("interactions:stop",{interaction:this}),this.interactable=this.element=null,this._interacting=!1,this._stopped=!0,this.prepared.name=this.prevEvent=null}},{key:"getPointerIndex",value:function(t){var e=Cn.pointer.getPointerId(t);return"mouse"===this.pointerType||"pen"===this.pointerType?this.pointers.length-1:Cn.arr.findIndex(this.pointers,function(t){return t.id===e})}},{key:"getPointerInfo",value:function(t){return this.pointers[this.getPointerIndex(t)]}},{key:"updatePointer",value:function(t,e,n,r){var o=Cn.pointer.getPointerId(t),i=this.getPointerIndex(t),a=this.pointers[i];return r=!1!==r&&(r||/(down|start)$/i.test(e.type)),a?a.pointer=t:(a=new Rn.default(o,t,e,null,null),i=this.pointers.length,this.pointers.push(a)),Cn.pointer.setCoords(this.coords.cur,this.pointers.map(function(t){return t.pointer}),this._now()),Cn.pointer.setCoordDeltas(this.coords.delta,this.coords.prev,this.coords.cur),r&&(this.pointerIsDown=!0,a.downTime=this.coords.cur.timeStamp,a.downTarget=n,Cn.pointer.pointerExtend(this.downPointer,t),this.interacting()||(Cn.pointer.copyCoords(this.coords.start,this.coords.cur),Cn.pointer.copyCoords(this.coords.prev,this.coords.cur),this.downEvent=e,this.pointerWasMoved=!1)),this._updateLatestPointer(t,e,n),this._scopeFire("interactions:update-pointer",{pointer:t,event:e,eventTarget:n,down:r,pointerInfo:a,pointerIndex:i,interaction:this}),i}},{key:"removePointer",value:function(t,e){var n=this.getPointerIndex(t);if(-1!==n){var r=this.pointers[n];this._scopeFire("interactions:remove-pointer",{pointer:t,event:e,eventTarget:null,pointerIndex:n,pointerInfo:r,interaction:this}),this.pointers.splice(n,1)}}},{key:"_updateLatestPointer",value:function(t,e,n){this._latestPointer.pointer=t,this._latestPointer.event=e,this._latestPointer.eventTarget=n}},{key:"destroy",value:function(){this._latestPointer.pointer=null,this._latestPointer.event=null,this._latestPointer.eventTarget=null}},{key:"_createPreparedEvent",value:function(t,e,n,r){return new Wn.default(this,t,this.prepared.name,e,this.element,n,r)}},{key:"_fireEvent",value:function(t){this.interactable.fire(t),(!this.prevEvent||t.timeStamp>=this.prevEvent.timeStamp)&&(this.prevEvent=t)}},{key:"_doPhase",value:function(t){var e=t.event,n=t.phase,r=t.preEnd,o=t.type,i=this.rect;if(i&&"move"===n&&(Cn.rect.addEdges(this.edges,i,this.coords.delta[this.interactable.options.deltaSource]),i.width=i.right-i.left,i.height=i.bottom-i.top),!1===this._scopeFire("interactions:before-action-".concat(n),t))return!1;var a=t.iEvent=this._createPreparedEvent(e,n,r,o);return this._scopeFire("interactions:action-".concat(n),t),"start"===n&&(this.prevEvent=a),this._fireEvent(a),this._scopeFire("interactions:after-action-".concat(n),t),!0}},{key:"_now",value:function(){return Date.now()}}]),l}(),qn=En.Interaction=Vn;En.default=qn;var Un={};function Gn(t){return(Gn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Un,"__esModule",{value:!0}),Un.install=Jn,Un.default=void 0;var Hn=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Gn(t)&&"function"!=typeof t)return{default:t};var e=Kn();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function Kn(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Kn=function(){return t},t}function $n(t){return/^(always|never|auto)$/.test(t)?(this.options.preventDefault=t,this):Hn.bool(t)?(this.options.preventDefault=t?"always":"never",this):this.options.preventDefault}function Zn(t){var e=t.interaction,n=t.event;e.interactable&&e.interactable.checkAndPreventDefault(n)}function Jn(r){var t=r.Interactable;t.prototype.preventDefault=$n,t.prototype.checkAndPreventDefault=function(t){return function(t,e,n){var r=t.options.preventDefault;if("never"!==r)if("always"!==r){if(e.events.supportsPassive&&/^touch(start|move)$/.test(n.type)){var o=(0,O.getWindow)(n.target).document,i=e.getDocOptions(o);if(!i||!i.events||!1!==i.events.passive)return}/^(mouse|pointer|touch)*(down|start)/i.test(n.type)||Hn.element(n.target)&&(0,$.matchesSelector)(n.target,"input,select,textarea,[contenteditable=true],[contenteditable=true] *")||n.preventDefault()}else n.preventDefault()}(this,r,t)},r.interactions.docEvents.push({type:"dragstart",listener:function(t){for(var e=0;e<r.interactions.list.length;e++){var n=r.interactions.list[e];if(n.element&&(n.element===t.target||(0,$.nodeContains)(n.element,t.target)))return void n.interactable.checkAndPreventDefault(t)}}})}var Qn={id:"core/interactablePreventDefault",install:Jn,listeners:["down","move","up","cancel"].reduce(function(t,e){return t["interactions:".concat(e)]=Zn,t},{})};Un.default=Qn;var tr={};function er(t){return(er="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(tr,"__esModule",{value:!0}),tr.default=void 0;var nr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==er(t)&&"function"!=typeof t)return{default:t};var e=rr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($);function rr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return rr=function(){return t},t}var or={methodOrder:["simulationResume","mouseOrPen","hasPointer","idle"],search:function(t){for(var e=0;e<or.methodOrder.length;e++){var n;n=or.methodOrder[e];var r=or[n](t);if(r)return r}return null},simulationResume:function(t){var e=t.pointerType,n=t.eventType,r=t.eventTarget,o=t.scope;if(!/down|start/i.test(n))return null;for(var i=0;i<o.interactions.list.length;i++){var a=o.interactions.list[i],u=r;if(a.simulation&&a.simulation.allowResume&&a.pointerType===e)for(;u;){if(u===a.element)return a;u=nr.parentNode(u)}}return null},mouseOrPen:function(t){var e,n=t.pointerId,r=t.pointerType,o=t.eventType,i=t.scope;if("mouse"!==r&&"pen"!==r)return null;for(var a=0;a<i.interactions.list.length;a++){var u=i.interactions.list[a];if(u.pointerType===r){if(u.simulation&&!ir(u,n))continue;if(u.interacting())return u;e=e||u}}if(e)return e;for(var s=0;s<i.interactions.list.length;s++){var l=i.interactions.list[s];if(!(l.pointerType!==r||/down/i.test(o)&&l.simulation))return l}return null},hasPointer:function(t){for(var e=t.pointerId,n=t.scope,r=0;r<n.interactions.list.length;r++){var o=n.interactions.list[r];if(ir(o,e))return o}return null},idle:function(t){for(var e=t.pointerType,n=t.scope,r=0;r<n.interactions.list.length;r++){var o=n.interactions.list[r];if(1===o.pointers.length){var i=o.interactable;if(i&&(!i.options.gesture||!i.options.gesture.enabled))continue}else if(2<=o.pointers.length)continue;if(!o.interacting()&&e===o.pointerType)return o}return null}};function ir(t,e){return t.pointers.some(function(t){return t.id===e})}var ar=or;tr.default=ar;var ur={};Object.defineProperty(ur,"__esModule",{value:!0}),ur.default=void 0;var sr,lr=(sr=Me)&&sr.__esModule?sr:{default:sr},cr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==pr(t)&&"function"!=typeof t)return{default:t};var e=fr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(S);function fr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return fr=function(){return t},t}function pr(t){return(pr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function dr(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function vr(t){return(vr=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function yr(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function hr(t,e){return(hr=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function gr(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var br=function(){function l(t,e,n){var r,o,i;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,l),o=this,r=!(i=vr(l).call(this,e._interaction))||"object"!==pr(i)&&"function"!=typeof i?yr(o):i,gr(yr(r),"target",void 0),gr(yr(r),"dropzone",void 0),gr(yr(r),"dragEvent",void 0),gr(yr(r),"relatedTarget",void 0),gr(yr(r),"draggable",void 0),gr(yr(r),"timeStamp",void 0),gr(yr(r),"propagationStopped",!1),gr(yr(r),"immediatePropagationStopped",!1);var a="dragleave"===n?t.prev:t.cur,u=a.element,s=a.dropzone;return r.type=n,r.target=u,r.currentTarget=u,r.dropzone=s,r.dragEvent=e,r.relatedTarget=e.target,r.draggable=e.interactable,r.timeStamp=e.timeStamp,r}var t,e,n;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&hr(t,e)}(l,lr["default"]),t=l,(e=[{key:"reject",value:function(){var r=this,t=this._interaction.dropState;if("dropactivate"===this.type||this.dropzone&&t.cur.dropzone===this.dropzone&&t.cur.element===this.target)if(t.prev.dropzone=this.dropzone,t.prev.element=this.target,t.rejected=!0,t.events.enter=null,this.stopImmediatePropagation(),"dropactivate"===this.type){var e=t.activeDrops,n=cr.findIndex(e,function(t){var e=t.dropzone,n=t.element;return e===r.dropzone&&n===r.target});t.activeDrops.splice(n,1);var o=new l(t,this.dragEvent,"dropdeactivate");o.dropzone=this.dropzone,o.target=this.target,this.dropzone.fire(o)}else this.dropzone.fire(new l(t,this.dragEvent,"dragleave"))}},{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}])&&dr(t.prototype,e),n&&dr(t,n),l}();ur.default=br;var mr={};function Or(t){return(Or="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(mr,"__esModule",{value:!0}),mr.default=void 0;Sr(k({})),Sr(m({}));var wr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Or(t)&&"function"!=typeof t)return{default:t};var e=xr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),_r=Sr(v),Pr=Sr(ur);function xr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return xr=function(){return t},t}function Sr(t){return t&&t.__esModule?t:{default:t}}function jr(t,e){for(var n=0;n<t.slice().length;n++){r=t.slice()[n];var r,o=r.dropzone,i=r.element;e.dropzone=o,e.target=i,o.fire(e),e.propagationStopped=e.immediatePropagationStopped=!1}}function Mr(t,e){for(var n=function(t,e){for(var n=t.interactables,r=[],o=0;o<n.list.length;o++){var i=n.list[o];if(i.options.drop.enabled){var a=i.options.drop.accept;if(!(wr.is.element(a)&&a!==e||wr.is.string(a)&&!wr.dom.matchesSelector(e,a)||wr.is.func(a)&&!a({dropzone:i,draggableElement:e})))for(var u=wr.is.string(i.target)?i._context.querySelectorAll(i.target):wr.is.array(i.target)?i.target:[i.target],s=0;s<u.length;s++){var l;l=u[s];l!==e&&r.push({dropzone:i,element:l})}}}return r}(t,e),r=0;r<n.length;r++){var o;o=n[r];o.rect=o.dropzone.getRect(o.element)}return n}function kr(t,e,n){for(var r=t.dropState,o=t.interactable,i=t.element,a=[],u=0;u<r.activeDrops.length;u++){s=r.activeDrops[u];var s,l=s.dropzone,c=s.element,f=s.rect;a.push(l.dropCheck(e,n,o,i,c,f)?c:null)}var p=wr.dom.indexOfDeepestElement(a);return r.activeDrops[p]||null}function Er(t,e,n){var r=t.dropState,o={enter:null,leave:null,activate:null,deactivate:null,move:null,drop:null};return"dragstart"===n.type&&(o.activate=new Pr.default(r,n,"dropactivate"),o.activate.target=null,o.activate.dropzone=null),"dragend"===n.type&&(o.deactivate=new Pr.default(r,n,"dropdeactivate"),o.deactivate.target=null,o.deactivate.dropzone=null),r.rejected||(r.cur.element!==r.prev.element&&(r.prev.dropzone&&(o.leave=new Pr.default(r,n,"dragleave"),n.dragLeave=o.leave.target=r.prev.element,n.prevDropzone=o.leave.dropzone=r.prev.dropzone),r.cur.dropzone&&(o.enter=new Pr.default(r,n,"dragenter"),n.dragEnter=r.cur.element,n.dropzone=r.cur.dropzone)),"dragend"===n.type&&r.cur.dropzone&&(o.drop=new Pr.default(r,n,"drop"),n.dropzone=r.cur.dropzone,n.relatedTarget=r.cur.element),"dragmove"===n.type&&r.cur.dropzone&&(o.move=new Pr.default(r,n,"dropmove"),(o.move.dragmove=n).dropzone=r.cur.dropzone)),o}function Tr(t,e){var n=t.dropState,r=n.activeDrops,o=n.cur,i=n.prev;e.leave&&i.dropzone.fire(e.leave),e.move&&o.dropzone.fire(e.move),e.enter&&o.dropzone.fire(e.enter),e.drop&&o.dropzone.fire(e.drop),e.deactivate&&jr(r,e.deactivate),n.prev.dropzone=o.dropzone,n.prev.element=o.element}function Dr(t,e){var n=t.interaction,r=t.iEvent,o=t.event;if("dragmove"===r.type||"dragend"===r.type){var i=n.dropState;e.dynamicDrop&&(i.activeDrops=Mr(e,n.element));var a=r,u=kr(n,a,o);i.rejected=i.rejected&&!!u&&u.dropzone===i.cur.dropzone&&u.element===i.cur.element,i.cur.dropzone=u&&u.dropzone,i.cur.element=u&&u.element,i.events=Er(n,0,a)}}var Ir={id:"actions/drop",install:function(e){var t=e.actions,n=e.interactStatic,r=e.Interactable,o=e.defaults;e.usePlugin(_r.default),r.prototype.dropzone=function(t){return function(t,e){if(wr.is.object(e)){if(t.options.drop.enabled=!1!==e.enabled,e.listeners){var n=wr.normalizeListeners(e.listeners),r=Object.keys(n).reduce(function(t,e){return t[/^(enter|leave)/.test(e)?"drag".concat(e):/^(activate|deactivate|move)/.test(e)?"drop".concat(e):e]=n[e],t},{});t.off(t.options.drop.listeners),t.on(r),t.options.drop.listeners=r}return wr.is.func(e.ondrop)&&t.on("drop",e.ondrop),wr.is.func(e.ondropactivate)&&t.on("dropactivate",e.ondropactivate),wr.is.func(e.ondropdeactivate)&&t.on("dropdeactivate",e.ondropdeactivate),wr.is.func(e.ondragenter)&&t.on("dragenter",e.ondragenter),wr.is.func(e.ondragleave)&&t.on("dragleave",e.ondragleave),wr.is.func(e.ondropmove)&&t.on("dropmove",e.ondropmove),/^(pointer|center)$/.test(e.overlap)?t.options.drop.overlap=e.overlap:wr.is.number(e.overlap)&&(t.options.drop.overlap=Math.max(Math.min(1,e.overlap),0)),"accept"in e&&(t.options.drop.accept=e.accept),"checker"in e&&(t.options.drop.checker=e.checker),t}if(wr.is.bool(e))return t.options.drop.enabled=e,t;return t.options.drop}(this,t)},r.prototype.dropCheck=function(t,e,n,r,o,i){return function(t,e,n,r,o,i,a){var u=!1;if(!(a=a||t.getRect(i)))return!!t.options.drop.checker&&t.options.drop.checker(e,n,u,t,i,r,o);var s=t.options.drop.overlap;if("pointer"===s){var l=wr.getOriginXY(r,o,"drag"),c=wr.pointer.getPageXY(e);c.x+=l.x,c.y+=l.y;var f=c.x>a.left&&c.x<a.right,p=c.y>a.top&&c.y<a.bottom;u=f&&p}var d=r.getRect(o);if(d&&"center"===s){var v=d.left+d.width/2,y=d.top+d.height/2;u=v>=a.left&&v<=a.right&&y>=a.top&&y<=a.bottom}if(d&&wr.is.number(s)){var h=Math.max(0,Math.min(a.right,d.right)-Math.max(a.left,d.left))*Math.max(0,Math.min(a.bottom,d.bottom)-Math.max(a.top,d.top))/(d.width*d.height);u=s<=h}t.options.drop.checker&&(u=t.options.drop.checker(e,n,u,t,i,r,o));return u}(this,t,e,n,r,o,i)},n.dynamicDrop=function(t){return wr.is.bool(t)?(e.dynamicDrop=t,n):e.dynamicDrop},wr.extend(t.phaselessTypes,{dragenter:!0,dragleave:!0,dropactivate:!0,dropdeactivate:!0,dropmove:!0,drop:!0}),t.methodDict.drop="dropzone",e.dynamicDrop=!1,o.actions.drop=Ir.defaults},listeners:{"interactions:before-action-start":function(t){var e=t.interaction;"drag"===e.prepared.name&&(e.dropState={cur:{dropzone:null,element:null},prev:{dropzone:null,element:null},rejected:null,events:null,activeDrops:[]})},"interactions:after-action-start":function(t,e){var n=t.interaction,r=(t.event,t.iEvent);if("drag"===n.prepared.name){var o=n.dropState;o.activeDrops=null,o.events=null,o.activeDrops=Mr(e,n.element),o.events=Er(n,0,r),o.events.activate&&(jr(o.activeDrops,o.events.activate),e.fire("actions/drop:start",{interaction:n,dragEvent:r}))}},"interactions:action-move":Dr,"interactions:action-end":Dr,"interactions:after-action-move":function(t,e){var n=t.interaction,r=t.iEvent;"drag"===n.prepared.name&&(Tr(n,n.dropState.events),e.fire("actions/drop:move",{interaction:n,dragEvent:r}),n.dropState.events={})},"interactions:after-action-end":function(t,e){var n=t.interaction,r=t.iEvent;"drag"===n.prepared.name&&(Tr(n,n.dropState.events),e.fire("actions/drop:end",{interaction:n,dragEvent:r}))},"interactions:stop":function(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.dropState;n&&(n.activeDrops=null,n.events=null,n.cur.dropzone=null,n.cur.element=null,n.prev.dropzone=null,n.prev.element=null,n.rejected=!1)}}},getActiveDrops:Mr,getDrop:kr,getDropEvents:Er,fireDropEvents:Tr,defaults:{enabled:!1,accept:null,overlap:"pointer"}},zr=Ir;mr.default=zr;var Ar={};function Cr(t){return(Cr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ar,"__esModule",{value:!0}),Ar.default=void 0;var Wr=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Cr(t)&&"function"!=typeof t)return{default:t};var e=Rr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le);function Rr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Rr=function(){return t},t}function Fr(t){var e=t.interaction,n=t.iEvent,r=t.phase;if("gesture"===e.prepared.name){var o=e.pointers.map(function(t){return t.pointer}),i="start"===r,a="end"===r,u=e.interactable.options.deltaSource;if(n.touches=[o[0],o[1]],i)n.distance=Wr.pointer.touchDistance(o,u),n.box=Wr.pointer.touchBBox(o),n.scale=1,n.ds=0,n.angle=Wr.pointer.touchAngle(o,u),n.da=0,e.gesture.startDistance=n.distance,e.gesture.startAngle=n.angle;else if(a){var s=e.prevEvent;n.distance=s.distance,n.box=s.box,n.scale=s.scale,n.ds=0,n.angle=s.angle,n.da=0}else n.distance=Wr.pointer.touchDistance(o,u),n.box=Wr.pointer.touchBBox(o),n.scale=n.distance/e.gesture.startDistance,n.angle=Wr.pointer.touchAngle(o,u),n.ds=n.scale-e.gesture.scale,n.da=n.angle-e.gesture.angle;e.gesture.distance=n.distance,e.gesture.angle=n.angle,Wr.is.number(n.scale)&&n.scale!==1/0&&!isNaN(n.scale)&&(e.gesture.scale=n.scale)}}var Xr={id:"actions/gesture",before:["actions/drag","actions/resize"],install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.gesturable=function(t){return Wr.is.object(t)?(this.options.gesture.enabled=!1!==t.enabled,this.setPerAction("gesture",t),this.setOnEvents("gesture",t),this):Wr.is.bool(t)?(this.options.gesture.enabled=t,this):this.options.gesture},e.map.gesture=Xr,e.methodDict.gesture="gesturable",r.actions.gesture=Xr.defaults},listeners:{"interactions:action-start":Fr,"interactions:action-move":Fr,"interactions:action-end":Fr,"interactions:new":function(t){t.interaction.gesture={angle:0,distance:0,scale:1,startAngle:0,startDistance:0}},"auto-start:check":function(t){if(!(t.interaction.pointers.length<2)){var e=t.interactable.options.gesture;if(e&&e.enabled)return!(t.action={name:"gesture"})}}},defaults:{},getCursor:function(){return""}},Yr=Xr;Ar.default=Yr;var Nr={};function Lr(t){return(Lr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Nr,"__esModule",{value:!0}),Nr.default=void 0;var Br,Vr=Hr($),qr=(Br=ct)&&Br.__esModule?Br:{default:Br},Ur=Hr(w);function Gr(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Gr=function(){return t},t}function Hr(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Lr(t)&&"function"!=typeof t)return{default:t};var e=Gr();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function Kr(t,e,n,r,o,i,a){if(!e)return!1;if(!0===e){var u=Ur.number(i.width)?i.width:i.right-i.left,s=Ur.number(i.height)?i.height:i.bottom-i.top;if(a=Math.min(a,("left"===t||"right"===t?u:s)/2),u<0&&("left"===t?t="right":"right"===t&&(t="left")),s<0&&("top"===t?t="bottom":"bottom"===t&&(t="top")),"left"===t)return n.x<(0<=u?i.left:i.right)+a;if("top"===t)return n.y<(0<=s?i.top:i.bottom)+a;if("right"===t)return n.x>(0<=u?i.right:i.left)-a;if("bottom"===t)return n.y>(0<=s?i.bottom:i.top)-a}return!!Ur.element(r)&&(Ur.element(e)?e===r:Vr.matchesUpTo(r,e,o))}function $r(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.resizeAxes){var r=e;n.interactable.options.resize.square?("y"===n.resizeAxes?r.delta.x=r.delta.y:r.delta.y=r.delta.x,r.axes="xy"):(r.axes=n.resizeAxes,"x"===n.resizeAxes?r.delta.y=0:"y"===n.resizeAxes&&(r.delta.x=0))}}var Zr={id:"actions/resize",before:["actions/drag"],install:function(e){var t=e.actions,n=e.browser,r=e.Interactable,o=e.defaults;Zr.cursors=n.isIe9?{x:"e-resize",y:"s-resize",xy:"se-resize",top:"n-resize",left:"w-resize",bottom:"s-resize",right:"e-resize",topleft:"se-resize",bottomright:"se-resize",topright:"ne-resize",bottomleft:"ne-resize"}:{x:"ew-resize",y:"ns-resize",xy:"nwse-resize",top:"ns-resize",left:"ew-resize",bottom:"ns-resize",right:"ew-resize",topleft:"nwse-resize",bottomright:"nwse-resize",topright:"nesw-resize",bottomleft:"nesw-resize"},Zr.defaultMargin=n.supportsTouch||n.supportsPointerEvent?20:10,r.prototype.resizable=function(t){return function(t,e,n){if(Ur.object(e))return t.options.resize.enabled=!1!==e.enabled,t.setPerAction("resize",e),t.setOnEvents("resize",e),Ur.string(e.axis)&&/^x$|^y$|^xy$/.test(e.axis)?t.options.resize.axis=e.axis:null===e.axis&&(t.options.resize.axis=n.defaults.actions.resize.axis),Ur.bool(e.preserveAspectRatio)?t.options.resize.preserveAspectRatio=e.preserveAspectRatio:Ur.bool(e.square)&&(t.options.resize.square=e.square),t;if(Ur.bool(e))return t.options.resize.enabled=e,t;return t.options.resize}(this,t,e)},t.map.resize=Zr,t.methodDict.resize="resizable",o.actions.resize=Zr.defaults},listeners:{"interactions:new":function(t){t.interaction.resizeAxes="xy"},"interactions:action-start":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,o=n.rect;n._rects={start:(0,qr.default)({},o),corrected:(0,qr.default)({},o),previous:(0,qr.default)({},o),delta:{left:0,right:0,width:0,top:0,bottom:0,height:0}},r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}}(t),$r(t)},"interactions:action-move":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,o=n.interactable.options.resize.invert,i="reposition"===o||"negate"===o,a=n.rect,u=n._rects,s=u.start,l=u.corrected,c=u.delta,f=u.previous;if((0,qr.default)(f,l),i){if((0,qr.default)(l,a),"reposition"===o){if(l.top>l.bottom){var p=l.top;l.top=l.bottom,l.bottom=p}if(l.left>l.right){var d=l.left;l.left=l.right,l.right=d}}}else l.top=Math.min(a.top,s.bottom),l.bottom=Math.max(a.bottom,s.top),l.left=Math.min(a.left,s.right),l.right=Math.max(a.right,s.left);for(var v in l.width=l.right-l.left,l.height=l.bottom-l.top,l)c[v]=l[v]-f[v];r.edges=n.prepared.edges,r.rect=l,r.deltaRect=c}}(t),$r(t)},"interactions:action-end":function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e;r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}},"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.element,o=t.rect,i=t.buttons;if(o){var a=(0,qr.default)({},e.coords.cur.page),u=n.options.resize;if(u&&u.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(i&u.mouseButtons))){if(Ur.object(u.edges)){var s={left:!1,right:!1,top:!1,bottom:!1};for(var l in s)s[l]=Kr(l,u.edges[l],a,e._latestPointer.eventTarget,r,o,u.margin||Zr.defaultMargin);s.left=s.left&&!s.right,s.top=s.top&&!s.bottom,(s.left||s.right||s.top||s.bottom)&&(t.action={name:"resize",edges:s})}else{var c="y"!==u.axis&&a.x>o.right-Zr.defaultMargin,f="x"!==u.axis&&a.y>o.bottom-Zr.defaultMargin;(c||f)&&(t.action={name:"resize",axes:(c?"x":"")+(f?"y":"")})}return!t.action&&void 0}}}},defaults:{square:!1,preserveAspectRatio:!1,axis:"xy",margin:NaN,edges:null,invert:"none"},cursors:null,getCursor:function(t){var e=t.edges,n=t.axis,r=t.name,o=Zr.cursors,i=null;if(n)i=o[r+n];else if(e){for(var a="",u=["top","bottom","left","right"],s=0;s<u.length;s++){var l=u[s];e[l]&&(a+=l)}i=o[a]}return i},defaultMargin:null},Jr=Zr;Nr.default=Jr;var Qr={};Object.defineProperty(Qr,"__esModule",{value:!0}),Object.defineProperty(Qr,"drag",{enumerable:!0,get:function(){return to.default}}),Object.defineProperty(Qr,"drop",{enumerable:!0,get:function(){return eo.default}}),Object.defineProperty(Qr,"gesture",{enumerable:!0,get:function(){return no.default}}),Object.defineProperty(Qr,"resize",{enumerable:!0,get:function(){return ro.default}}),Qr.default=void 0;var to=oo(v),eo=oo(mr),no=oo(Ar),ro=oo(Nr);function oo(t){return t&&t.__esModule?t:{default:t}}var io={id:"actions",install:function(t){t.usePlugin(no.default),t.usePlugin(ro.default),t.usePlugin(to.default),t.usePlugin(eo.default)}};Qr.default=io;var ao={};Object.defineProperty(ao,"__esModule",{value:!0}),ao.default=void 0;ao.default={};var uo={};function so(t){return(so="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(uo,"__esModule",{value:!0}),uo.getContainer=go,uo.getScroll=bo,uo.getScrollSize=function(t){fo.window(t)&&(t=window.document.body);return{x:t.scrollWidth,y:t.scrollHeight}},uo.getScrollSizeDelta=function(t,e){var n=t.interaction,r=t.element,o=n&&n.interactable.options[n.prepared.name].autoScroll;if(!o||!o.enabled)return e(),{x:0,y:0};var i=go(o.container,n.interactable,r),a=bo(i);e();var u=bo(i);return{x:u.x-a.x,y:u.y-a.y}},uo.default=void 0;var lo,co=yo($),fo=yo(w),po=(lo=oe)&&lo.__esModule?lo:{default:lo};function vo(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return vo=function(){return t},t}function yo(t){if(t&&t.__esModule)return t;if(null===t||"object"!==so(t)&&"function"!=typeof t)return{default:t};var e=vo();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}var ho={defaults:{enabled:!1,margin:60,container:null,speed:300},now:Date.now,interaction:null,i:0,x:0,y:0,isScrolling:!1,prevTime:0,margin:0,speed:0,start:function(t){ho.isScrolling=!0,po.default.cancel(ho.i),(t.autoScroll=ho).interaction=t,ho.prevTime=ho.now(),ho.i=po.default.request(ho.scroll)},stop:function(){ho.isScrolling=!1,ho.interaction&&(ho.interaction.autoScroll=null),po.default.cancel(ho.i)},scroll:function(){var t=ho.interaction,e=t.interactable,n=t.element,r=t.prepared.name,o=e.options[r].autoScroll,i=go(o.container,e,n),a=ho.now(),u=(a-ho.prevTime)/1e3,s=o.speed*u;if(1<=s){var l={x:ho.x*s,y:ho.y*s};if(l.x||l.y){var c=bo(i);fo.window(i)?i.scrollBy(l.x,l.y):i&&(i.scrollLeft+=l.x,i.scrollTop+=l.y);var f=bo(i),p={x:f.x-c.x,y:f.y-c.y};(p.x||p.y)&&e.fire({type:"autoscroll",target:n,interactable:e,delta:p,interaction:t,container:i})}ho.prevTime=a}ho.isScrolling&&(po.default.cancel(ho.i),ho.i=po.default.request(ho.scroll))},check:function(t,e){var n=t.options;return n[e].autoScroll&&n[e].autoScroll.enabled},onInteractionMove:function(t){var e=t.interaction,n=t.pointer;if(e.interacting()&&ho.check(e.interactable,e.prepared.name))if(e.simulation)ho.x=ho.y=0;else{var r,o,i,a,u=e.interactable,s=e.element,l=e.prepared.name,c=u.options[l].autoScroll,f=go(c.container,u,s);if(fo.window(f))a=n.clientX<ho.margin,r=n.clientY<ho.margin,o=n.clientX>f.innerWidth-ho.margin,i=n.clientY>f.innerHeight-ho.margin;else{var p=co.getElementClientRect(f);a=n.clientX<p.left+ho.margin,r=n.clientY<p.top+ho.margin,o=n.clientX>p.right-ho.margin,i=n.clientY>p.bottom-ho.margin}ho.x=o?1:a?-1:0,ho.y=i?1:r?-1:0,ho.isScrolling||(ho.margin=c.margin,ho.speed=c.speed,ho.start(e))}}};function go(t,e,n){return(fo.string(t)?(0,$t.getStringOptionResult)(t,e,n):t)||(0,O.getWindow)(n)}function bo(t){return fo.window(t)&&(t=window.document.body),{x:t.scrollLeft,y:t.scrollTop}}var mo={id:"auto-scroll",install:function(t){var e=t.defaults,n=t.actions;(t.autoScroll=ho).now=function(){return t.now()},n.phaselessTypes.autoscroll=!0,e.perAction.autoScroll=ho.defaults},listeners:{"interactions:new":function(t){t.interaction.autoScroll=null},"interactions:destroy":function(t){t.interaction.autoScroll=null,ho.stop(),ho.interaction&&(ho.interaction=null)},"interactions:stop":ho.stop,"interactions:action-move":function(t){return ho.onInteractionMove(t)}}};uo.default=mo;var Oo={};function wo(t){return(wo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Oo,"__esModule",{value:!0}),Oo.default=void 0;var _o=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==wo(t)&&"function"!=typeof t)return{default:t};var e=Po();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function Po(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Po=function(){return t},t}function xo(t){return _o.bool(t)?(this.options.styleCursor=t,this):null===t?(delete this.options.styleCursor,this):this.options.styleCursor}function So(t){return _o.func(t)?(this.options.actionChecker=t,this):null===t?(delete this.options.actionChecker,this):this.options.actionChecker}var jo={id:"auto-start/interactableMethods",install:function(d){var t=d.Interactable;t.prototype.getAction=function(t,e,n,r){var o,i,a,u,s,l,c,f,p=(i=e,a=n,u=r,s=d,l=(o=this).getRect(u),c=i.buttons||{0:1,1:4,3:8,4:16}[i.button],f={action:null,interactable:o,interaction:a,element:u,rect:l,buttons:c},s.fire("auto-start:check",f),f.action);return this.options.actionChecker?this.options.actionChecker(t,e,p,this,r,n):p},t.prototype.ignoreFrom=(0,le.warnOnce)(function(t){return this._backCompatOption("ignoreFrom",t)},"Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."),t.prototype.allowFrom=(0,le.warnOnce)(function(t){return this._backCompatOption("allowFrom",t)},"Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."),t.prototype.actionChecker=So,t.prototype.styleCursor=xo}};Oo.default=jo;var Mo={};function ko(t){return(ko="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Mo,"__esModule",{value:!0}),Mo.default=void 0;var Eo,To=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==ko(t)&&"function"!=typeof t)return{default:t};var e=Io();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),Do=(Eo=Oo)&&Eo.__esModule?Eo:{default:Eo};function Io(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Io=function(){return t},t}function zo(t,e,n,r,o){return e.testIgnoreAllow(e.options[t.name],n,r)&&e.options[t.name].enabled&&Ro(e,n,t,o)?t:null}function Ao(t,e,n,r,o,i,a){for(var u=0,s=r.length;u<s;u++){var l=r[u],c=o[u],f=l.getAction(e,n,t,c);if(f){var p=zo(f,l,c,i,a);if(p)return{action:p,interactable:l,element:c}}}return{action:null,interactable:null,element:null}}function Co(t,e,n,r,o){var i=[],a=[],u=r;function s(t){i.push(t),a.push(u)}for(;To.is.element(u);){i=[],a=[],o.interactables.forEachMatch(u,s);var l=Ao(t,e,n,i,a,r,o);if(l.action&&!l.interactable.options[l.action.name].manualStart)return l;u=To.dom.parentNode(u)}return{action:null,interactable:null,element:null}}function Wo(t,e,n){var r=e.action,o=e.interactable,i=e.element;r=r||{name:null},t.interactable=o,t.element=i,To.copyAction(t.prepared,r),t.rect=o&&r.name?o.getRect(i):null,Yo(t,n),n.fire("autoStart:prepared",{interaction:t})}function Ro(t,e,n,r){var o=t.options,i=o[n.name].max,a=o[n.name].maxPerElement,u=r.autoStart.maxInteractions,s=0,l=0,c=0;if(!(i&&a&&u))return!1;for(var f=0;f<r.interactions.list.length;f++){var p=r.interactions.list[f],d=p.prepared.name;if(p.interacting()){if(u<=++s)return!1;if(p.interactable===t){if(i<=(l+=d===n.name?1:0))return!1;if(p.element===e&&(c++,d===n.name&&a<=c))return!1}}}return 0<u}function Fo(t,e){return To.is.number(t)?(e.autoStart.maxInteractions=t,this):e.autoStart.maxInteractions}function Xo(t,e,n){var r=n.autoStart.cursorElement;r&&r!==t&&(r.style.cursor=""),t.ownerDocument.documentElement.style.cursor=e,t.style.cursor=e,n.autoStart.cursorElement=e?t:null}function Yo(t,e){var n=t.interactable,r=t.element,o=t.prepared;if("mouse"===t.pointerType&&n&&n.options.styleCursor){var i="";if(o.name){var a=n.options[o.name].cursorChecker;i=To.is.func(a)?a(o,n,r,t._interacting):e.actions.map[o.name].getCursor(o)}Xo(t.element,i||"",e)}else e.autoStart.cursorElement&&Xo(e.autoStart.cursorElement,"",e)}var No={id:"auto-start/base",before:["actions","actions/drag","actions/resize","actions/gesture"],install:function(e){var t=e.interactStatic,n=e.defaults;e.usePlugin(Do.default),n.base.actionChecker=null,n.base.styleCursor=!0,To.extend(n.perAction,{manualStart:!1,max:1/0,maxPerElement:1,allowFrom:null,ignoreFrom:null,mouseButtons:1}),t.maxInteractions=function(t){return Fo(t,e)},e.autoStart={maxInteractions:1/0,withinInteractionLimit:Ro,cursorElement:null}},listeners:{"interactions:down":function(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget;n.interacting()||Wo(n,Co(n,r,o,i,e),e)},"interactions:move":function(t,e){var n,r,o,i,a,u;r=e,o=(n=t).interaction,i=n.pointer,a=n.event,u=n.eventTarget,"mouse"!==o.pointerType||o.pointerIsDown||o.interacting()||Wo(o,Co(o,i,a,u,r),r),function(t,e){var n=t.interaction;if(n.pointerIsDown&&!n.interacting()&&n.pointerWasMoved&&n.prepared.name){e.fire("autoStart:before-start",t);var r=n.interactable,o=n.prepared.name;o&&r&&(r.options[o].manualStart||!Ro(r,n.element,n.prepared,e)?n.stop():(n.start(n.prepared,r,n.element),Yo(n,e)))}}(t,e)},"interactions:stop":function(t,e){var n=t.interaction,r=n.interactable;r&&r.options.styleCursor&&Xo(n.element,"",e)}},maxInteractions:Fo,withinInteractionLimit:Ro,validateAction:zo};Mo.default=No;var Lo={};function Bo(t){return(Bo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Lo,"__esModule",{value:!0}),Lo.default=void 0;var Vo,qo=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Bo(t)&&"function"!=typeof t)return{default:t};var e=Go();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w),Uo=(Vo=Mo)&&Vo.__esModule?Vo:{default:Vo};function Go(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Go=function(){return t},t}var Ho={id:"auto-start/dragAxis",listeners:{"autoStart:before-start":function(t,r){var o=t.interaction,i=t.eventTarget,e=t.dx,n=t.dy;if("drag"===o.prepared.name){var a=Math.abs(e),u=Math.abs(n),s=o.interactable.options.drag,l=s.startAxis,c=u<a?"x":a<u?"y":"xy";if(o.prepared.axis="start"===s.lockAxis?c[0]:s.lockAxis,"xy"!=c&&"xy"!==l&&l!==c){o.prepared.name=null;function f(t){if(t!==o.interactable){var e=o.interactable.options.drag;if(!e.manualStart&&t.testIgnoreAllow(e,p,i)){var n=t.getAction(o.downPointer,o.downEvent,o,p);if(n&&"drag"===n.name&&function(t,e){if(!e)return;var n=e.options.drag.startAxis;return"xy"===t||"xy"===n||n===t}(c,t)&&Uo.default.validateAction(n,t,p,i,r))return t}}}for(var p=i;qo.element(p);){var d=r.interactables.forEachMatch(p,f);if(d){o.prepared.name="drag",o.interactable=d,o.element=p;break}p=(0,$.parentNode)(p)}}}}}};Lo.default=Ho;var Ko={};Object.defineProperty(Ko,"__esModule",{value:!0}),Ko.default=void 0;var $o,Zo=($o=Mo)&&$o.__esModule?$o:{default:$o};function Jo(t){var e=t.prepared&&t.prepared.name;if(!e)return null;var n=t.interactable.options;return n[e].hold||n[e].delay}var Qo={id:"auto-start/hold",install:function(t){var e=t.defaults;t.usePlugin(Zo.default),e.perAction.hold=0,e.perAction.delay=0},listeners:{"interactions:new":function(t){t.interaction.autoStartHoldTimer=null},"autoStart:prepared":function(t){var e=t.interaction,n=Jo(e);0<n&&(e.autoStartHoldTimer=setTimeout(function(){e.start(e.prepared,e.interactable,e.element)},n))},"interactions:move":function(t){var e=t.interaction,n=t.duplicate;e.pointerWasMoved&&!n&&clearTimeout(e.autoStartHoldTimer)},"autoStart:before-start":function(t){var e=t.interaction;0<Jo(e)&&(e.prepared.name=null)}},getHoldDuration:Jo};Ko.default=Qo;var ti={};Object.defineProperty(ti,"__esModule",{value:!0}),Object.defineProperty(ti,"autoStart",{enumerable:!0,get:function(){return ei.default}}),Object.defineProperty(ti,"dragAxis",{enumerable:!0,get:function(){return ni.default}}),Object.defineProperty(ti,"hold",{enumerable:!0,get:function(){return ri.default}}),ti.default=void 0;var ei=oi(Mo),ni=oi(Lo),ri=oi(Ko);function oi(t){return t&&t.__esModule?t:{default:t}}var ii={id:"auto-start",install:function(t){t.usePlugin(ei.default),t.usePlugin(ri.default),t.usePlugin(ni.default)}};ti.default=ii;var ai={};Object.defineProperty(ai,"__esModule",{value:!0}),ai.default=void 0;ai.default={};var ui={};Object.defineProperty(ui,"__esModule",{value:!0}),ui.default=void 0;ui.default={};var si={};function li(t){return(li="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(si,"__esModule",{value:!0}),si.default=void 0;var ci,fi,pi=hi(D),di=(hi(ct),function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==li(t)&&"function"!=typeof t)return{default:t};var e=yi();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w)),vi=hi(O);function yi(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return yi=function(){return t},t}function hi(t){return t&&t.__esModule?t:{default:t}}(fi=ci=ci||{}).touchAction="touchAction",fi.boxSizing="boxSizing",fi.noListeners="noListeners";var gi={touchAction:"https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action",boxSizing:"https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing"};ci.touchAction,ci.boxSizing,ci.noListeners;function bi(t,e,n){return n.test(t.style[e]||vi.default.window.getComputedStyle(t)[e])}var mi="dev-tools",Oi={id:mi,install:function(){}};si.default=Oi;var wi={};Object.defineProperty(wi,"__esModule",{value:!0}),wi.default=void 0;wi.default={};var _i={};function Pi(t){return(Pi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(_i,"__esModule",{value:!0}),_i.getRectOffset=Ai,_i.default=void 0;var xi=ki(V),Si=ki(ct),ji=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Pi(t)&&"function"!=typeof t)return{default:t};var e=Mi();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function Mi(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Mi=function(){return t},t}function ki(t){return t&&t.__esModule?t:{default:t}}function Ei(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function Ti(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Di(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Ii=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.interaction=t,Di(this,"states",[]),Di(this,"startOffset",{left:0,right:0,top:0,bottom:0}),Di(this,"startDelta",null),Di(this,"result",null),Di(this,"endResult",null),Di(this,"edges",void 0),this.result=zi()}var t,n,r;return t=e,(n=[{key:"start",value:function(t,e){var n=t.phase,r=this.interaction,o=function(t){var n=t.interactable.options[t.prepared.name],e=n.modifiers;if(e&&e.length)return e.filter(function(t){return!t.options||!1!==t.options.enabled});return["snap","snapSize","snapEdges","restrict","restrictEdges","restrictSize"].map(function(t){var e=n[t];return e&&e.enabled&&{options:e,methods:e._methods}}).filter(function(t){return!!t})}(r);this.prepareStates(o),this.edges=(0,Si.default)({},r.edges),this.startOffset=Ai(r.rect,e);var i={phase:n,pageCoords:e,preEnd:!(this.startDelta={x:0,y:0})};return this.result=zi(),this.startAll(i),this.result=this.setAll(i)}},{key:"fillArg",value:function(t){var e=this.interaction;t.interaction=e,t.interactable=e.interactable,t.element=e.element,t.rect=t.rect||e.rect,t.edges=this.edges,t.startOffset=this.startOffset}},{key:"startAll",value:function(t){this.fillArg(t);for(var e=0;e<this.states.length;e++){var n=this.states[e];n.methods.start&&(t.state=n).methods.start(t)}}},{key:"setAll",value:function(t){this.fillArg(t);var e=t.phase,n=t.preEnd,r=t.skipModifiers,o=t.rect;t.coords=(0,Si.default)({},t.pageCoords),t.rect=(0,Si.default)({},o);for(var i=r?this.states.slice(r):this.states,a=zi(t.coords,t.rect),u=0;u<i.length;u++){var s=i[u],l=s.options,c=(0,Si.default)({},t.coords),f=null;s.methods.set&&this.shouldDo(l,n,e)&&(f=(t.state=s).methods.set(t),ji.addEdges(this.interaction.edges,t.rect,{x:t.coords.x-c.x,y:t.coords.y-c.y})),a.eventProps.push(f)}a.delta.x=t.coords.x-t.pageCoords.x,a.delta.y=t.coords.y-t.pageCoords.y,a.rectDelta.left=t.rect.left-o.left,a.rectDelta.right=t.rect.right-o.right,a.rectDelta.top=t.rect.top-o.top,a.rectDelta.bottom=t.rect.bottom-o.bottom;var p=this.result.coords,d=this.result.rect;if(p&&d){var v=a.rect.left!==d.left||a.rect.right!==d.right||a.rect.top!==d.top||a.rect.bottom!==d.bottom;a.changed=v||p.x!==a.coords.x||p.y!==a.coords.y}return a}},{key:"applyToInteraction",value:function(t){var e=this.interaction,n=t.phase,r=e.coords.cur,o=e.coords.start,i=this.result,a=this.startDelta,u=i.delta;"start"===n&&(0,Si.default)(this.startDelta,i.delta);for(var s=0;s<[[o,a],[r,u]].length;s++){var l=Ei([[o,a],[r,u]][s],2),c=l[0],f=l[1];c.page.x+=f.x,c.page.y+=f.y,c.client.x+=f.x,c.client.y+=f.y}var p=this.result.rectDelta,d=t.rect||e.rect;d.left+=p.left,d.right+=p.right,d.top+=p.top,d.bottom+=p.bottom,d.width=d.right-d.left,d.height=d.bottom-d.top}},{key:"setAndApply",value:function(t){var e=this.interaction,n=t.phase,r=t.preEnd,o=t.skipModifiers,i=this.setAll({preEnd:r,phase:n,pageCoords:t.modifiedCoords||e.coords.cur.page});if(!(this.result=i).changed&&(!o||o<this.states.length)&&e.interacting())return!1;if(t.modifiedCoords){var a=e.coords.cur.page,u=t.modifiedCoords.x-a.x,s=t.modifiedCoords.y-a.y;i.coords.x+=u,i.coords.y+=s,i.delta.x+=u,i.delta.y+=s}this.applyToInteraction(t)}},{key:"beforeEnd",value:function(t){var e=t.interaction,n=t.event,r=this.states;if(r&&r.length){for(var o=!1,i=0;i<r.length;i++){var a=r[i],u=(t.state=a).options,s=a.methods,l=s.beforeEnd&&s.beforeEnd(t);if(l)return this.endResult=l,!1;o=o||!o&&this.shouldDo(u,!0,t.phase,!0)}o&&e.move({event:n,preEnd:!0})}}},{key:"stop",value:function(t){var e=t.interaction;if(this.states&&this.states.length){var n=(0,Si.default)({states:this.states,interactable:e.interactable,element:e.element,rect:null},t);this.fillArg(n);for(var r=0;r<this.states.length;r++){var o=this.states[r];(n.state=o).methods.stop&&o.methods.stop(n)}this.states=null,this.endResult=null}}},{key:"prepareStates",value:function(t){this.states=[];for(var e=0;e<t.length;e++){var n=t[e],r=n.options,o=n.methods,i=n.name;r&&!1===r.enabled||this.states.push({options:r,methods:o,index:e,name:i})}return this.states}},{key:"restoreInteractionCoords",value:function(t){var e=t.interaction,n=e.coords,r=e.rect,o=e.modification;if(o.result){for(var i=o.startDelta,a=o.result,u=a.delta,s=a.rectDelta,l=[[n.start,i],[n.cur,u]],c=0;c<l.length;c++){var f=Ei(l[c],2),p=f[0],d=f[1];p.page.x-=d.x,p.page.y-=d.y,p.client.x-=d.x,p.client.y-=d.y}r.left-=s.left,r.right-=s.right,r.top-=s.top,r.bottom-=s.bottom}}},{key:"shouldDo",value:function(t,e,n,r){return!(!t||!1===t.enabled||r&&!t.endOnly||t.endOnly&&!e||"start"===n&&!t.setStart)}},{key:"copyFrom",value:function(t){this.startOffset=t.startOffset,this.startDelta=t.startDelta,this.edges=t.edges,this.states=t.states.map(function(t){return(0,xi.default)(t)}),this.result=zi((0,Si.default)({},t.result.coords),(0,Si.default)({},t.result.rect))}},{key:"destroy",value:function(){for(var t in this)this[t]=null}}])&&Ti(t.prototype,n),r&&Ti(t,r),e}();function zi(t,e){return{rect:e,coords:t,delta:{x:0,y:0},rectDelta:{left:0,right:0,top:0,bottom:0},eventProps:[],changed:!0}}function Ai(t,e){return t?{left:e.x-t.left,top:e.y-t.top,right:t.right-e.x,bottom:t.bottom-e.y}:{left:0,top:0,right:0,bottom:0}}_i.default=Ii;var Ci={};Object.defineProperty(Ci,"__esModule",{value:!0}),Ci.makeModifier=function(t,r){function e(t){var e=t||{};for(var n in e.enabled=!1!==e.enabled,o)n in e||(e[n]=o[n]);return{options:e,methods:i,name:r}}var o=t.defaults,i={start:t.start,set:t.set,beforeEnd:t.beforeEnd,stop:t.stop};r&&"string"==typeof r&&(e._defaults=o,e._methods=i);return e},Ci.addEventModifiers=Fi,Ci.default=void 0;var Wi,Ri=(Wi=_i)&&Wi.__esModule?Wi:{default:Wi};function Fi(t){var e=t.iEvent,n=t.interaction.modification.result;n&&(e.modifiers=n.eventProps)}var Xi={id:"modifiers/base",install:function(t){t.defaults.perAction.modifiers=[]},listeners:{"interactions:new":function(t){var e=t.interaction;e.modification=new Ri.default(e)},"interactions:before-action-start":function(t){var e=t.interaction.modification;e.start(t,t.interaction.coords.start.page),t.interaction.edges=e.edges,e.applyToInteraction(t)},"interactions:before-action-move":function(t){return t.interaction.modification.setAndApply(t)},"interactions:before-action-end":function(t){return t.interaction.modification.beforeEnd(t)},"interactions:action-start":Fi,"interactions:action-move":Fi,"interactions:action-end":Fi,"interactions:after-action-start":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-move":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:stop":function(t){return t.interaction.modification.stop(t)}},before:["actions","action/drag","actions/resize","actions/gesture"]};Ci.default=Xi;var Yi={};function Ni(t){return(Ni="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Yi,"__esModule",{value:!0}),Yi.addTotal=Vi,Yi.applyPending=Ui,Yi.default=void 0;var Li=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Ni(t)&&"function"!=typeof t)return{default:t};var e=Bi();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function Bi(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Bi=function(){return t},t}function Vi(t){t.pointerIsDown&&(Hi(t.coords.cur,t.offset.total),t.offset.pending.x=0,t.offset.pending.y=0)}function qi(t){Ui(t.interaction)}function Ui(t){if(!(e=t).offset.pending.x&&!e.offset.pending.y)return!1;var e,n=t.offset.pending;return Hi(t.coords.cur,n),Hi(t.coords.delta,n),Li.addEdges(t.edges,t.rect,n),n.x=0,!(n.y=0)}function Gi(t){var e=t.x,n=t.y;this.offset.pending.x+=e,this.offset.pending.y+=n,this.offset.total.x+=e,this.offset.total.y+=n}function Hi(t,e){var n=t.page,r=t.client,o=e.x,i=e.y;n.x+=o,n.y+=i,r.x+=o,r.y+=i}En._ProxyMethods.offsetBy="";var Ki={id:"offset",install:function(t){t.Interaction.prototype.offsetBy=Gi},listeners:{"interactions:new":function(t){t.interaction.offset={total:{x:0,y:0},pending:{x:0,y:0}}},"interactions:update-pointer":function(t){return Vi(t.interaction)},"interactions:before-action-start":qi,"interactions:before-action-move":qi,"interactions:before-action-end":function(t){var e=t.interaction;if(Ui(e))return e.move({offset:!0}),e.end(),!1},"interactions:stop":function(t){var e=t.interaction;e.offset.total.x=0,e.offset.total.y=0,e.offset.pending.x=0,e.offset.pending.y=0}}};Yi.default=Ki;var $i={};function Zi(t){return(Zi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty($i,"__esModule",{value:!0}),$i.default=$i.InertiaState=void 0;var Ji=ua(_i),Qi=aa(Ci),ta=ua(Yi),ea=aa($),na=ua(Et),ra=aa(w),oa=ua(oe);function ia(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ia=function(){return t},t}function aa(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Zi(t)&&"function"!=typeof t)return{default:t};var e=ia();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function ua(t){return t&&t.__esModule?t:{default:t}}function sa(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function la(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var ca=function(){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.interaction=t,la(this,"active",!1),la(this,"isModified",!1),la(this,"smoothEnd",!1),la(this,"allowResume",!1),la(this,"modification",null),la(this,"modifierCount",0),la(this,"modifierArg",null),la(this,"startCoords",null),la(this,"t0",0),la(this,"v0",0),la(this,"te",0),la(this,"targetOffset",null),la(this,"modifiedOffset",null),la(this,"currentOffset",null),la(this,"lambda_v0",0),la(this,"one_ve_v0",0),la(this,"timeout",null)}var t,n,r;return t=e,(n=[{key:"start",value:function(t){var e=this.interaction,n=fa(e);if(!n||!n.enabled)return!1;var r=e.coords.velocity.client,o=(0,na.default)(r.x,r.y),i=this.modification||(this.modification=new Ji.default(e));if(i.copyFrom(e.modification),this.t0=e._now(),this.allowResume=n.allowResume,this.v0=o,this.currentOffset={x:0,y:0},this.startCoords=e.coords.cur.page,this.modifierArg={interaction:e,interactable:e.interactable,element:e.element,rect:e.rect,edges:e.edges,pageCoords:this.startCoords,preEnd:!0,phase:"inertiastart"},this.t0-e.coords.cur.timeStamp<50&&o>n.minSpeed&&o>n.endSpeed)this.startInertia();else{if(i.result=i.setAll(this.modifierArg),!i.result.changed)return!1;this.startSmoothEnd()}return e.modification.result.rect=null,e.offsetBy(this.targetOffset),e._doPhase({interaction:e,event:t,phase:"inertiastart"}),e.offsetBy({x:-this.targetOffset.x,y:-this.targetOffset.y}),e.modification.result.rect=null,this.active=!0,e.simulation=this,!0}},{key:"startInertia",value:function(){var t=this,e=this.interaction.coords.velocity.client,n=fa(this.interaction),r=n.resistance,o=-Math.log(n.endSpeed/this.v0)/r;this.targetOffset={x:(e.x-o)/r,y:(e.y-o)/r},this.te=o,this.lambda_v0=r/this.v0,this.one_ve_v0=1-n.endSpeed/this.v0;var i=this.modification,a=this.modifierArg;a.pageCoords={x:this.startCoords.x+this.targetOffset.x,y:this.startCoords.y+this.targetOffset.y},i.result=i.setAll(a),i.result.changed&&(this.isModified=!0,this.modifiedOffset={x:this.targetOffset.x+i.result.delta.x,y:this.targetOffset.y+i.result.delta.y}),this.timeout=oa.default.request(function(){return t.inertiaTick()})}},{key:"startSmoothEnd",value:function(){var t=this;this.smoothEnd=!0,this.isModified=!0,this.targetOffset={x:this.modification.result.delta.x,y:this.modification.result.delta.y},this.timeout=oa.default.request(function(){return t.smoothEndTick()})}},{key:"inertiaTick",value:function(){var t,e,n,r,o,i,a,u=this,s=this.interaction,l=fa(s).resistance,c=(s._now()-this.t0)/1e3;if(c<this.te){var f,p=1-(Math.exp(-l*c)-this.lambda_v0)/this.one_ve_v0,d={x:(f=this.isModified?(e=t=0,n=this.targetOffset.x,r=this.targetOffset.y,o=this.modifiedOffset.x,i=this.modifiedOffset.y,{x:pa(a=p,t,n,o),y:pa(a,e,r,i)}):{x:this.targetOffset.x*p,y:this.targetOffset.y*p}).x-this.currentOffset.x,y:f.y-this.currentOffset.y};this.currentOffset.x+=d.x,this.currentOffset.y+=d.y,s.offsetBy(d),s.move(),this.timeout=oa.default.request(function(){return u.inertiaTick()})}else s.offsetBy({x:this.modifiedOffset.x-this.currentOffset.x,y:this.modifiedOffset.y-this.currentOffset.y}),this.end()}},{key:"smoothEndTick",value:function(){var t=this,e=this.interaction,n=e._now()-this.t0,r=fa(e).smoothEndDuration;if(n<r){var o=da(n,0,this.targetOffset.x,r),i=da(n,0,this.targetOffset.y,r),a={x:o-this.currentOffset.x,y:i-this.currentOffset.y};this.currentOffset.x+=a.x,this.currentOffset.y+=a.y,e.offsetBy(a),e.move({skipModifiers:this.modifierCount}),this.timeout=oa.default.request(function(){return t.smoothEndTick()})}else e.offsetBy({x:this.targetOffset.x-this.currentOffset.x,y:this.targetOffset.y-this.currentOffset.y}),this.end()}},{key:"resume",value:function(t){var e=t.pointer,n=t.event,r=t.eventTarget,o=this.interaction;o.offsetBy({x:-this.currentOffset.x,y:-this.currentOffset.y}),o.updatePointer(e,n,r,!0),o._doPhase({interaction:o,event:n,phase:"resume"}),(0,zt.copyCoords)(o.coords.prev,o.coords.cur),this.stop()}},{key:"end",value:function(){this.interaction.move(),this.interaction.end(),this.stop()}},{key:"stop",value:function(){this.active=this.smoothEnd=!1,this.interaction.simulation=null,oa.default.cancel(this.timeout)}}])&&sa(t.prototype,n),r&&sa(t,r),e}();function fa(t){var e=t.interactable,n=t.prepared;return e&&e.options&&n.name&&e.options[n.name].inertia}function pa(t,e,n,r){var o=1-t;return o*o*e+2*o*t*n+t*t*r}function da(t,e,n,r){return-n*(t/=r)*(t-2)+e}$i.InertiaState=ca;var va={id:"inertia",before:["modifiers/base"],install:function(t){var e=t.defaults;t.usePlugin(ta.default),t.usePlugin(Qi.default),t.actions.phases.inertiastart=!0,t.actions.phases.resume=!0,e.perAction.inertia={enabled:!1,resistance:10,minSpeed:100,endSpeed:10,allowResume:!0,smoothEndDuration:300}},listeners:{"interactions:new":function(t){var e=t.interaction;e.inertia=new ca(e)},"interactions:before-action-end":function(t){var e=t.interaction,n=t.event;return(!e._interacting||e.simulation||!e.inertia.start(n))&&null},"interactions:down":function(t){var e=t.interaction,n=t.eventTarget,r=e.inertia;if(r.active)for(var o=n;ra.element(o);){if(o===e.element){r.resume(t);break}o=ea.parentNode(o)}},"interactions:stop":function(t){var e=t.interaction.inertia;e.active&&e.stop()},"interactions:before-action-resume":function(t){var e=t.interaction.modification;e.stop(t),e.start(t,t.interaction.coords.cur.page),e.applyToInteraction(t)},"interactions:before-action-inertiastart":function(t){return t.interaction.modification.setAndApply(t)},"interactions:action-resume":Qi.addEventModifiers,"interactions:action-inertiastart":Qi.addEventModifiers,"interactions:after-action-inertiastart":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-resume":function(t){return t.interaction.modification.restoreInteractionCoords(t)}}};$i.default=va;var ya,ha={};function ga(t){return(ga="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(ha,"__esModule",{value:!0}),ha.init=ha.default=void 0;var ba=new(((ya=m({}))&&ya.__esModule?ya:{default:ya}).default),ma=ba.interactStatic;ha.default=ma;function Oa(t){return ba.init(t)}ha.init=Oa,"object"===("undefined"==typeof window?"undefined":ga(window))&&window&&Oa(window);var wa={};Object.defineProperty(wa,"__esModule",{value:!0}),wa.default=void 0;wa.default={};var _a={};Object.defineProperty(_a,"__esModule",{value:!0}),_a.default=void 0;_a.default={};var Pa={};function xa(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}Object.defineProperty(Pa,"__esModule",{value:!0}),Pa.default=void 0;Pa.default=function(v){function t(t,e){for(var n=v.range,r=v.limits,o=void 0===r?{left:-1/0,right:1/0,top:-1/0,bottom:1/0}:r,i=v.offset,a=void 0===i?{x:0,y:0}:i,u={range:n,grid:v,x:null,y:null},s=0;s<y.length;s++){var l=xa(y[s],2),c=l[0],f=l[1],p=Math.round((t-a.x)/v[c]),d=Math.round((e-a.y)/v[f]);u[c]=Math.max(o.left,Math.min(o.right,p*v[c]+a.x)),u[f]=Math.max(o.top,Math.min(o.bottom,d*v[f]+a.y))}return u}var y=[["x","y"],["left","top"],["right","bottom"],["width","height"]].filter(function(t){var e=xa(t,2),n=e[0],r=e[1];return n in v||r in v});return t.grid=v,t.coordFields=y,t};var Sa={};Object.defineProperty(Sa,"__esModule",{value:!0}),Object.defineProperty(Sa,"edgeTarget",{enumerable:!0,get:function(){return ja.default}}),Object.defineProperty(Sa,"elements",{enumerable:!0,get:function(){return Ma.default}}),Object.defineProperty(Sa,"grid",{enumerable:!0,get:function(){return ka.default}});var ja=Ea(wa),Ma=Ea(_a),ka=Ea(Pa);function Ea(t){return t&&t.__esModule?t:{default:t}}var Ta={};function Da(t){return(Da="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ta,"__esModule",{value:!0}),Ta.default=void 0;var Ia,za=(Ia=ct)&&Ia.__esModule?Ia:{default:Ia},Aa=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Da(t)&&"function"!=typeof t)return{default:t};var e=Ca();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(Sa);function Ca(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Ca=function(){return t},t}var Wa={id:"snappers",install:function(t){var e=t.interactStatic;e.snappers=(0,za.default)(e.snappers||{},Aa),e.createSnapGrid=e.snappers.grid}};Ta.default=Wa;var Ra={};Object.defineProperty(Ra,"__esModule",{value:!0}),Ra.aspectRatio=Ra.default=void 0;var Fa=Ya(ct),Xa=Ya(_i);function Ya(t){return t&&t.__esModule?t:{default:t}}function Na(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function La(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Na(Object(n),!0).forEach(function(t){Ba(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Na(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function Ba(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Va={start:function(t){var e=t.state,n=t.rect,r=t.edges,o=t.pageCoords,i=e.options.ratio,a=e.options,u=a.equalDelta,s=a.modifiers;"preserve"===i&&(i=n.width/n.height),e.startCoords=(0,Fa.default)({},o),e.startRect=(0,Fa.default)({},n),e.ratio=i,e.equalDelta=u;var l=e.linkedEdges={top:r.top||r.left&&!r.bottom,left:r.left||r.top&&!r.right,bottom:r.bottom||r.right&&!r.top,right:r.right||r.bottom&&!r.left};if(e.xIsPrimaryAxis=!(!r.left&&!r.right),e.equalDelta)e.edgeSign=(l.left?1:-1)*(l.top?1:-1);else{var c=e.xIsPrimaryAxis?l.top:l.left;e.edgeSign=c?-1:1}if((0,Fa.default)(t.edges,l),s&&s.length){var f=new Xa.default(t.interaction);f.copyFrom(t.interaction.modification),f.prepareStates(s),(e.subModification=f).startAll(La({},t))}},set:function(t){var e=t.state,n=t.rect,r=t.coords,o=(0,Fa.default)({},r),i=e.equalDelta?qa:Ua;if(i(e,e.xIsPrimaryAxis,r,n),!e.subModification)return null;var a=(0,Fa.default)({},n);(0,$t.addEdges)(e.linkedEdges,a,{x:r.x-o.x,y:r.y-o.y});var u=e.subModification.setAll(La({},t,{rect:a,edges:e.linkedEdges,pageCoords:r,prevCoords:r,prevRect:a})),s=u.delta;u.changed&&(i(e,Math.abs(s.x)>Math.abs(s.y),u.coords,u.rect),(0,Fa.default)(r,u.coords));return u.eventProps},defaults:{ratio:"preserve",equalDelta:!1,modifiers:[],enabled:!1}};function qa(t,e,n){var r=t.startCoords,o=t.edgeSign;e?n.y=r.y+(n.x-r.x)*o:n.x=r.x+(n.y-r.y)*o}function Ua(t,e,n,r){var o=t.startRect,i=t.startCoords,a=t.ratio,u=t.edgeSign;if(e){var s=r.width/a;n.y=i.y+(s-o.height)*u}else{var l=r.height*a;n.x=i.x+(l-o.width)*u}}Ra.aspectRatio=Va;var Ga=(0,Ci.makeModifier)(Va,"aspectRatio");Ra.default=Ga;var Ha={};Object.defineProperty(Ha,"__esModule",{value:!0}),Ha.default=void 0;function Ka(){}Ka._defaults={};var $a=Ka;Ha.default=$a;var Za={};function Ja(t){return(Ja="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Za,"__esModule",{value:!0}),Za.getRestrictionRect=iu,Za.restrict=Za.default=void 0;var Qa,tu=(Qa=ct)&&Qa.__esModule?Qa:{default:Qa},eu=ou(w),nu=ou($t);function ru(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return ru=function(){return t},t}function ou(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Ja(t)&&"function"!=typeof t)return{default:t};var e=ru();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function iu(t,e,n){return eu.func(t)?nu.resolveRectLike(t,e.interactable,e.element,[n.x,n.y,e]):nu.resolveRectLike(t,e.interactable,e.element)}var au={start:function(t){var e=t.rect,n=t.startOffset,r=t.state,o=t.interaction,i=t.pageCoords,a=r.options,u=a.elementRect,s=(0,tu.default)({left:0,top:0,right:0,bottom:0},a.offset||{});if(e&&u){var l=iu(a.restriction,o,i);if(l){var c=l.right-l.left-e.width,f=l.bottom-l.top-e.height;c<0&&(s.left+=c,s.right+=c),f<0&&(s.top+=f,s.bottom+=f)}s.left+=n.left-e.width*u.left,s.top+=n.top-e.height*u.top,s.right+=n.right-e.width*(1-u.right),s.bottom+=n.bottom-e.height*(1-u.bottom)}r.offset=s},set:function(t){var e=t.coords,n=t.interaction,r=t.state,o=r.options,i=r.offset,a=iu(o.restriction,n,e);if(a){var u=nu.xywhToTlbr(a);e.x=Math.max(Math.min(u.right-i.right,e.x),u.left+i.left),e.y=Math.max(Math.min(u.bottom-i.bottom,e.y),u.top+i.top)}},defaults:{restriction:null,elementRect:null,offset:null,endOnly:!1,enabled:!1}};Za.restrict=au;var uu=(0,Ci.makeModifier)(au,"restrict");Za.default=uu;var su={};function lu(t){return(lu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(su,"__esModule",{value:!0}),su.restrictEdges=su.default=void 0;var cu,fu=(cu=ct)&&cu.__esModule?cu:{default:cu},pu=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==lu(t)&&"function"!=typeof t)return{default:t};var e=du();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function du(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return du=function(){return t},t}var vu={top:1/0,left:1/0,bottom:-1/0,right:-1/0},yu={top:-1/0,left:-1/0,bottom:1/0,right:1/0};function hu(t,e){for(var n=["top","left","bottom","right"],r=0;r<n.length;r++){var o=n[r];o in t||(t[o]=e[o])}return t}var gu={noInner:vu,noOuter:yu,start:function(t){var e,n=t.interaction,r=t.startOffset,o=t.state,i=o.options;if(i){var a=(0,Za.getRestrictionRect)(i.offset,n,n.coords.start.page);e=pu.rectToXY(a)}e=e||{x:0,y:0},o.offset={top:e.y+r.top,left:e.x+r.left,bottom:e.y-r.bottom,right:e.x-r.right}},set:function(t){var e=t.coords,n=t.edges,r=t.interaction,o=t.state,i=o.offset,a=o.options;if(n){var u=(0,fu.default)({},e),s=(0,Za.getRestrictionRect)(a.inner,r,u)||{},l=(0,Za.getRestrictionRect)(a.outer,r,u)||{};hu(s,vu),hu(l,yu),n.top?e.y=Math.min(Math.max(l.top+i.top,u.y),s.top+i.top):n.bottom&&(e.y=Math.max(Math.min(l.bottom+i.bottom,u.y),s.bottom+i.bottom)),n.left?e.x=Math.min(Math.max(l.left+i.left,u.x),s.left+i.left):n.right&&(e.x=Math.max(Math.min(l.right+i.right,u.x),s.right+i.right))}},defaults:{inner:null,outer:null,offset:null,endOnly:!1,enabled:!1}};su.restrictEdges=gu;var bu=(0,Ci.makeModifier)(gu,"restrictEdges");su.default=bu;var mu,Ou={};Object.defineProperty(Ou,"__esModule",{value:!0}),Ou.restrictRect=Ou.default=void 0;var wu=(0,((mu=ct)&&mu.__esModule?mu:{default:mu}).default)({get elementRect(){return{top:0,left:0,bottom:1,right:1}},set elementRect(t){}},Za.restrict.defaults),_u={start:Za.restrict.start,set:Za.restrict.set,defaults:wu};Ou.restrictRect=_u;var Pu=(0,Ci.makeModifier)(_u,"restrictRect");Ou.default=Pu;var xu={};function Su(t){return(Su="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(xu,"__esModule",{value:!0}),xu.restrictSize=xu.default=void 0;var ju,Mu=(ju=ct)&&ju.__esModule?ju:{default:ju},ku=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Su(t)&&"function"!=typeof t)return{default:t};var e=Eu();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}($t);function Eu(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Eu=function(){return t},t}var Tu={width:-1/0,height:-1/0},Du={width:1/0,height:1/0};var Iu={start:function(t){return su.restrictEdges.start(t)},set:function(t){var e=t.interaction,n=t.state,r=t.rect,o=t.edges,i=n.options;if(o){var a=ku.tlbrToXywh((0,Za.getRestrictionRect)(i.min,e,t.coords))||Tu,u=ku.tlbrToXywh((0,Za.getRestrictionRect)(i.max,e,t.coords))||Du;n.options={endOnly:i.endOnly,inner:(0,Mu.default)({},su.restrictEdges.noInner),outer:(0,Mu.default)({},su.restrictEdges.noOuter)},o.top?(n.options.inner.top=r.bottom-a.height,n.options.outer.top=r.bottom-u.height):o.bottom&&(n.options.inner.bottom=r.top+a.height,n.options.outer.bottom=r.top+u.height),o.left?(n.options.inner.left=r.right-a.width,n.options.outer.left=r.right-u.width):o.right&&(n.options.inner.right=r.left+a.width,n.options.outer.right=r.left+u.width),su.restrictEdges.set(t),n.options=i}},defaults:{min:null,max:null,endOnly:!1,enabled:!1}};xu.restrictSize=Iu;var zu=(0,Ci.makeModifier)(Iu,"restrictSize");xu.default=zu;var Au={};Object.defineProperty(Au,"__esModule",{value:!0}),Au.default=void 0;function Cu(){}Cu._defaults={};var Wu=Cu;Au.default=Wu;var Ru={};function Fu(t){return(Fu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Ru,"__esModule",{value:!0}),Ru.snap=Ru.default=void 0;var Xu=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Fu(t)&&"function"!=typeof t)return{default:t};var e=Yu();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le);function Yu(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Yu=function(){return t},t}var Nu={start:function(t){var e,n,r,o=t.interaction,i=t.interactable,a=t.element,u=t.rect,s=t.state,l=t.startOffset,c=s.options,f=c.offsetWithOrigin?(n=(e=t).interaction.element,Xu.rect.rectToXY(Xu.rect.resolveRectLike(e.state.options.origin,null,null,[n]))||Xu.getOriginXY(e.interactable,n,e.interaction.prepared.name)):{x:0,y:0};if("startCoords"===c.offset)r={x:o.coords.start.page.x,y:o.coords.start.page.y};else{var p=Xu.rect.resolveRectLike(c.offset,i,a,[o]);(r=Xu.rect.rectToXY(p)||{x:0,y:0}).x+=f.x,r.y+=f.y}var d=c.relativePoints;s.offsets=u&&d&&d.length?d.map(function(t,e){return{index:e,relativePoint:t,x:l.left-u.width*t.x+r.x,y:l.top-u.height*t.y+r.y}}):[Xu.extend({index:0,relativePoint:null},r)]},set:function(t){var e=t.interaction,n=t.coords,r=t.state,o=r.options,i=r.offsets,a=Xu.getOriginXY(e.interactable,e.element,e.prepared.name),u=Xu.extend({},n),s=[];o.offsetWithOrigin||(u.x-=a.x,u.y-=a.y);for(var l=0;l<i.length;l++)for(var c=i[l],f=u.x-c.x,p=u.y-c.y,d=0,v=o.targets.length;d<v;d++){var y=o.targets[d],h=void 0;(h=Xu.is.func(y)?y(f,p,e,c,d):y)&&s.push({x:(Xu.is.number(h.x)?h.x:f)+c.x,y:(Xu.is.number(h.y)?h.y:p)+c.y,range:Xu.is.number(h.range)?h.range:o.range,source:y,index:d,offset:c})}for(var g={target:null,inRange:!1,distance:0,range:0,delta:{x:0,y:0}},b=0;b<s.length;b++){var m=s[b],O=m.range,w=m.x-u.x,_=m.y-u.y,P=Xu.hypot(w,_),x=P<=O;O===1/0&&g.inRange&&g.range!==1/0&&(x=!1),g.target&&!(x?g.inRange&&O!==1/0?P/O<g.distance/g.range:O===1/0&&g.range!==1/0||P<g.distance:!g.inRange&&P<g.distance)||(g.target=m,g.distance=P,g.range=O,g.inRange=x,g.delta.x=w,g.delta.y=_)}return g.inRange&&(n.x=g.target.x,n.y=g.target.y),r.closest=g},defaults:{range:1/0,targets:null,offset:null,offsetWithOrigin:!0,origin:null,relativePoints:null,endOnly:!1,enabled:!1}};Ru.snap=Nu;var Lu=(0,Ci.makeModifier)(Nu,"snap");Ru.default=Lu;var Bu={};function Vu(t){return(Vu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Bu,"__esModule",{value:!0}),Bu.snapSize=Bu.default=void 0;var qu,Uu=(qu=ct)&&qu.__esModule?qu:{default:qu},Gu=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Vu(t)&&"function"!=typeof t)return{default:t};var e=Hu();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(w);function Hu(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Hu=function(){return t},t}function Ku(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)))return;var n=[],r=!0,o=!1,i=void 0;try{for(var a,u=t[Symbol.iterator]();!(r=(a=u.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==u.return||u.return()}finally{if(o)throw i}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var $u={start:function(t){var e=t.state,n=t.edges,r=e.options;if(!n)return null;t.state={options:{targets:null,relativePoints:[{x:n.left?0:1,y:n.top?0:1}],offset:r.offset||"self",origin:{x:0,y:0},range:r.range}},e.targetFields=e.targetFields||[["width","height"],["x","y"]],Ru.snap.start(t),e.offsets=t.state.offsets,t.state=e},set:function(t){var e=t.interaction,n=t.state,r=t.coords,o=n.options,i=n.offsets,a={x:r.x-i[0].x,y:r.y-i[0].y};n.options=(0,Uu.default)({},o),n.options.targets=[];for(var u=0;u<(o.targets||[]).length;u++){var s=(o.targets||[])[u],l=void 0;if(l=Gu.func(s)?s(a.x,a.y,e):s){for(var c=0;c<n.targetFields.length;c++){var f=Ku(n.targetFields[c],2),p=f[0],d=f[1];if(p in l||d in l){l.x=l[p],l.y=l[d];break}}n.options.targets.push(l)}}var v=Ru.snap.set(t);return n.options=o,v},defaults:{range:1/0,targets:null,offset:null,endOnly:!1,enabled:!1}};Bu.snapSize=$u;var Zu=(0,Ci.makeModifier)($u,"snapSize");Bu.default=Zu;var Ju={};Object.defineProperty(Ju,"__esModule",{value:!0}),Ju.snapEdges=Ju.default=void 0;var Qu=es(V),ts=es(ct);function es(t){return t&&t.__esModule?t:{default:t}}var ns={start:function(t){var e=t.edges;return e?(t.state.targetFields=t.state.targetFields||[[e.left?"left":"right",e.top?"top":"bottom"]],Bu.snapSize.start(t)):null},set:Bu.snapSize.set,defaults:(0,ts.default)((0,Qu.default)(Bu.snapSize.defaults),{targets:null,range:null,offset:{x:0,y:0}})};Ju.snapEdges=ns;var rs=(0,Ci.makeModifier)(ns,"snapEdges");Ju.default=rs;var os={};Object.defineProperty(os,"__esModule",{value:!0}),os.default=void 0;function is(){}is._defaults={};var as=is;os.default=as;var us={};Object.defineProperty(us,"__esModule",{value:!0}),us.default=void 0;function ss(){}ss._defaults={};var ls=ss;us.default=ls;var cs={};Object.defineProperty(cs,"__esModule",{value:!0}),cs.default=void 0;var fs=Ps(Ra),ps=Ps(Ha),ds=Ps(su),vs=Ps(Za),ys=Ps(Ou),hs=Ps(xu),gs=Ps(Au),bs=Ps(Ju),ms=Ps(Ru),Os=Ps(Bu),ws=Ps(os),_s=Ps(us);function Ps(t){return t&&t.__esModule?t:{default:t}}var xs={aspectRatio:fs.default,restrictEdges:ds.default,restrict:vs.default,restrictRect:ys.default,restrictSize:hs.default,snapEdges:bs.default,snap:ms.default,snapSize:Os.default,spring:ws.default,avoid:ps.default,transform:_s.default,rubberband:gs.default};cs.default=xs;var Ss={};Object.defineProperty(Ss,"__esModule",{value:!0}),Ss.default=void 0;var js=Es(Ta),Ms=Es(cs),ks=Es(Ci);function Es(t){return t&&t.__esModule?t:{default:t}}var Ts={id:"modifiers",install:function(t){var e=t.interactStatic;for(var n in t.usePlugin(ks.default),t.usePlugin(js.default),e.modifiers=Ms.default,Ms.default){var r=Ms.default[n],o=r._defaults,i=r._methods;o._methods=i,t.defaults.perAction[n]=o}}};Ss.default=Ts;var Ds={};Object.defineProperty(Ds,"__esModule",{value:!0}),Ds.default=void 0;Ds.default={};var Is={};Object.defineProperty(Is,"__esModule",{value:!0}),Is.PointerEvent=Is.default=void 0;var zs,As=(zs=Me)&&zs.__esModule?zs:{default:zs},Cs=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Rs(t)&&"function"!=typeof t)return{default:t};var e=Ws();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(zt);function Ws(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Ws=function(){return t},t}function Rs(t){return(Rs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Fs(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Xs(t){return(Xs=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ys(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ns(t,e){return(Ns=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Ls(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var Bs=function(){function f(t,e,n,r,o,i){var a,u,s;if(!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,f),u=this,a=!(s=Xs(f).call(this,o))||"object"!==Rs(s)&&"function"!=typeof s?Ys(u):s,Ls(Ys(a),"type",void 0),Ls(Ys(a),"originalEvent",void 0),Ls(Ys(a),"pointerId",void 0),Ls(Ys(a),"pointerType",void 0),Ls(Ys(a),"double",void 0),Ls(Ys(a),"pageX",void 0),Ls(Ys(a),"pageY",void 0),Ls(Ys(a),"clientX",void 0),Ls(Ys(a),"clientY",void 0),Ls(Ys(a),"dt",void 0),Ls(Ys(a),"eventable",void 0),Cs.pointerExtend(Ys(a),n),n!==e&&Cs.pointerExtend(Ys(a),e),a.timeStamp=i,a.originalEvent=n,a.type=t,a.pointerId=Cs.getPointerId(e),a.pointerType=Cs.getPointerType(e),a.target=r,a.currentTarget=null,"tap"===t){var l=o.getPointerIndex(e);a.dt=a.timeStamp-o.pointers[l].downTime;var c=a.timeStamp-o.tapTime;a.double=!!(o.prevTap&&"doubletap"!==o.prevTap.type&&o.prevTap.target===a.target&&c<500)}else"doubletap"===t&&(a.dt=e.timeStamp-o.tapTime);return a}var t,e,n;return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ns(t,e)}(f,As["default"]),t=f,(e=[{key:"_subtractOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX-=e,this.pageY-=n,this.clientX-=e,this.clientY-=n,this}},{key:"_addOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX+=e,this.pageY+=n,this.clientX+=e,this.clientY+=n,this}},{key:"preventDefault",value:function(){this.originalEvent.preventDefault()}}])&&Fs(t.prototype,e),n&&Fs(t,n),f}();Is.PointerEvent=Is.default=Bs;var Vs={};function qs(t){return(qs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(Vs,"__esModule",{value:!0}),Vs.default=void 0;Ks(En),Ks(m({}));var Us=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==qs(t)&&"function"!=typeof t)return{default:t};var e=Hs();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(le),Gs=Ks(Is);function Hs(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Hs=function(){return t},t}function Ks(t){return t&&t.__esModule?t:{default:t}}var $s={id:"pointer-events/base",install:function(t){t.pointerEvents=$s,t.defaults.actions.pointerEvents=$s.defaults,Us.extend(t.actions.phaselessTypes,$s.types)},listeners:{"interactions:new":function(t){var e=t.interaction;e.prevTap=null,e.tapTime=0},"interactions:update-pointer":function(t){var e=t.down,n=t.pointerInfo;if(!e&&n.hold)return;n.hold={duration:1/0,timeout:null}},"interactions:move":function(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.duplicate,u=n.getPointerIndex(r);a||n.pointerIsDown&&!n.pointerWasMoved||(n.pointerIsDown&&clearTimeout(n.pointers[u].hold.timeout),Zs({interaction:n,pointer:r,event:o,eventTarget:i,type:"move"},e))},"interactions:down":function(t,e){!function(t,e){for(var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.pointerIndex,u=n.pointers[a].hold,s=Us.dom.getPath(i),l={interaction:n,pointer:r,event:o,eventTarget:i,type:"hold",targets:[],path:s,node:null},c=0;c<s.length;c++){var f=s[c];l.node=f,e.fire("pointerEvents:collect-targets",l)}if(!l.targets.length)return;for(var p=1/0,d=0;d<l.targets.length;d++){var v=l.targets[d].eventable.options.holdDuration;v<p&&(p=v)}u.duration=p,u.timeout=setTimeout(function(){Zs({interaction:n,eventTarget:i,pointer:r,event:o,type:"hold"},e)},p)}(t,e),Zs(t,e)},"interactions:up":function(t,e){var n,r,o,i,a,u;Qs(t),Zs(t,e),r=e,o=(n=t).interaction,i=n.pointer,a=n.event,u=n.eventTarget,o.pointerWasMoved||Zs({interaction:o,eventTarget:u,pointer:i,event:a,type:"tap"},r)},"interactions:cancel":function(t,e){Qs(t),Zs(t,e)}},PointerEvent:Gs.default,fire:Zs,collectEventTargets:Js,defaults:{holdDuration:600,ignoreFrom:null,allowFrom:null,origin:{x:0,y:0}},types:{down:!0,move:!0,up:!0,cancel:!0,tap:!0,doubletap:!0,hold:!0}};function Zs(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.type,u=t.targets,s=void 0===u?Js(t,e):u,l=new Gs.default(a,r,o,i,n,e.now());e.fire("pointerEvents:new",{pointerEvent:l});for(var c={interaction:n,pointer:r,event:o,eventTarget:i,targets:s,type:a,pointerEvent:l},f=0;f<s.length;f++){var p=s[f];for(var d in p.props||{})l[d]=p.props[d];var v=Us.getOriginXY(p.eventable,p.node);if(l._subtractOrigin(v),l.eventable=p.eventable,l.currentTarget=p.node,p.eventable.fire(l),l._addOrigin(v),l.immediatePropagationStopped||l.propagationStopped&&f+1<s.length&&s[f+1].node!==l.currentTarget)break}if(e.fire("pointerEvents:fired",c),"tap"===a){var y=l.double?Zs({interaction:n,pointer:r,event:o,eventTarget:i,type:"doubletap"},e):l;n.prevTap=y,n.tapTime=y.timeStamp}return l}function Js(t,e){var n=t.interaction,r=t.pointer,o=t.event,i=t.eventTarget,a=t.type,u=n.getPointerIndex(r),s=n.pointers[u];if("tap"===a&&(n.pointerWasMoved||!s||s.downTarget!==i))return[];for(var l=Us.dom.getPath(i),c={interaction:n,pointer:r,event:o,eventTarget:i,type:a,path:l,targets:[],node:null},f=0;f<l.length;f++){var p=l[f];c.node=p,e.fire("pointerEvents:collect-targets",c)}return"hold"===a&&(c.targets=c.targets.filter(function(t){return t.eventable.options.holdDuration===n.pointers[u].hold.duration})),c.targets}function Qs(t){var e=t.interaction,n=t.pointerIndex;e.pointers[n].hold&&clearTimeout(e.pointers[n].hold.timeout)}var tl=$s;Vs.default=tl;var el={};Object.defineProperty(el,"__esModule",{value:!0}),el.default=void 0;rl(Is);var nl=rl(Vs);function rl(t){return t&&t.__esModule?t:{default:t}}function ol(t){var e=t.interaction;e.holdIntervalHandle&&(clearInterval(e.holdIntervalHandle),e.holdIntervalHandle=null)}var il={id:"pointer-events/holdRepeat",install:function(t){t.usePlugin(nl.default);var e=t.pointerEvents;e.defaults.holdRepeatInterval=0,e.types.holdrepeat=t.actions.phaselessTypes.holdrepeat=!0},listeners:["move","up","cancel","endall"].reduce(function(t,e){return t["pointerEvents:".concat(e)]=ol,t},{"pointerEvents:new":function(t){var e=t.pointerEvent;"hold"===e.type&&(e.count=(e.count||0)+1)},"pointerEvents:fired":function(t,e){var n=t.interaction,r=t.pointerEvent,o=t.eventTarget,i=t.targets;if("hold"===r.type&&i.length){var a=i[0].eventable.options.holdRepeatInterval;a<=0||(n.holdIntervalHandle=setTimeout(function(){e.pointerEvents.fire({interaction:n,eventTarget:o,type:"hold",pointer:r,event:r},e)},a))}}})};el.default=il;var al={};Object.defineProperty(al,"__esModule",{value:!0}),al.default=void 0;var ul,sl=(ul=ct)&&ul.__esModule?ul:{default:ul};function ll(t){return(0,sl.default)(this.events.options,t),this}var cl={id:"pointer-events/interactableTargets",install:function(t){var e=t.Interactable;e.prototype.pointerEvents=ll;var r=e.prototype._backCompatOption;e.prototype._backCompatOption=function(t,e){var n=r.call(this,t,e);return n===this&&(this.events.options[t]=e),n}},listeners:{"pointerEvents:collect-targets":function(t,e){var r=t.targets,o=t.node,i=t.type,a=t.eventTarget;e.interactables.forEachMatch(o,function(t){var e=t.events,n=e.options;e.types[i]&&e.types[i].length&&t.testIgnoreAllow(n,o,a)&&r.push({node:o,eventable:e,props:{interactable:t}})})},"interactable:new":function(t){var e=t.interactable;e.events.getRect=function(t){return e.getRect(t)}},"interactable:set":function(t,e){var n=t.interactable,r=t.options;(0,sl.default)(n.events.options,e.pointerEvents.defaults),(0,sl.default)(n.events.options,r.pointerEvents||{})}}};al.default=cl;var fl={};function pl(t){return(pl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(fl,"__esModule",{value:!0}),Object.defineProperty(fl,"holdRepeat",{enumerable:!0,get:function(){return vl.default}}),Object.defineProperty(fl,"interactableTargets",{enumerable:!0,get:function(){return yl.default}}),fl.pointerEvents=fl.default=void 0;var dl=function(t){if(t&&t.__esModule)return t;if(null===t||"object"!==pl(t)&&"function"!=typeof t)return{default:t};var e=gl();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}n.default=t,e&&e.set(t,n);return n}(Vs);fl.pointerEvents=dl;var vl=hl(el),yl=hl(al);function hl(t){return t&&t.__esModule?t:{default:t}}function gl(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return gl=function(){return t},t}var bl={id:"pointer-events",install:function(t){t.usePlugin(dl),t.usePlugin(vl.default),t.usePlugin(yl.default)}};fl.default=bl;var ml={};Object.defineProperty(ml,"__esModule",{value:!0}),ml.install=wl,ml.default=void 0;var Ol;(Ol=k({}))&&Ol.__esModule;function wl(e){var t=e.Interactable;e.actions.phases.reflow=!0,t.prototype.reflow=function(t){return function(u,s,l){function t(){var e=c[d],t=u.getRect(e);if(!t)return"break";var n=le.arr.find(l.interactions.list,function(t){return t.interacting()&&t.interactable===u&&t.element===e&&t.prepared.name===s.name}),r=void 0;if(n)n.move(),p&&(r=n._reflowPromise||new f(function(t){n._reflowResolve=t}));else{var o=le.rect.tlbrToXywh(t),i={page:{x:o.x,y:o.y},client:{x:o.x,y:o.y},timeStamp:l.now()},a=le.pointer.coordsToEvent(i);r=function(t,e,n,r,o){var i=t.interactions.new({pointerType:"reflow"}),a={interaction:i,event:o,pointer:o,eventTarget:n,phase:"reflow"};i.interactable=e,i.element=n,i.prepared=(0,le.extend)({},r),i.prevEvent=o,i.updatePointer(o,o,n,!0),i._doPhase(a);var u=le.win.window.Promise?new le.win.window.Promise(function(t){i._reflowResolve=t}):null;i._reflowPromise=u,i.start(r,e,n),i._interacting?(i.move(a),i.end(o)):i.stop();return i.removePointer(o,o),i.pointerIsDown=!1,u}(l,u,e,s,a)}p&&p.push(r)}for(var c=le.is.string(u.target)?le.arr.from(u._context.querySelectorAll(u.target)):[u.target],f=le.win.window.Promise,p=f?[]:null,d=0;d<c.length;d++){if("break"===t())break}return p&&f.all(p).then(function(){return u})}(this,t,e)}}var _l={id:"reflow",install:wl,listeners:{"interactions:stop":function(t,e){var n=t.interaction;"reflow"===n.pointerType&&(n._reflowResolve&&n._reflowResolve(),le.arr.remove(e.interactions.list,n))}}};ml.default=_l;var Pl={};Object.defineProperty(Pl,"__esModule",{value:!0}),Pl.default=void 0;Pl.default={};var xl={};Object.defineProperty(xl,"__esModule",{value:!0}),xl.exchange=void 0;xl.exchange={};var Sl={};Object.defineProperty(Sl,"__esModule",{value:!0}),Sl.default=void 0;Sl.default={};var jl={};function Ml(t){return(Ml="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}Object.defineProperty(jl,"__esModule",{value:!0}),jl.default=void 0;var kl=Hl(Qr),El=Hl(ao),Tl=Hl(uo),Dl=Hl(ti),Il=Hl(ai),zl=Hl(ui),Al=Hl(Un),Cl=(Hl(si),Gl(wi)),Wl=Hl($i),Rl=Hl(ha),Fl=Hl(Ss),Xl=Hl(Ds),Yl=Hl(Yi),Nl=Hl(fl),Ll=Hl(ml),Bl=Gl(Pl),Vl=Gl(zt),ql=Gl(Sl);function Ul(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return Ul=function(){return t},t}function Gl(t){if(t&&t.__esModule)return t;if(null===t||"object"!==Ml(t)&&"function"!=typeof t)return{default:t};var e=Ul();if(e&&e.has(t))return e.get(t);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in t)if(Object.prototype.hasOwnProperty.call(t,o)){var i=r?Object.getOwnPropertyDescriptor(t,o):null;i&&(i.get||i.set)?Object.defineProperty(n,o,i):n[o]=t[o]}return n.default=t,e&&e.set(t,n),n}function Hl(t){return t&&t.__esModule?t:{default:t}}Rl.default.use(Xl.default),Rl.default.use(Al.default),Rl.default.use(Yl.default),Rl.default.use(Il.default),Rl.default.use(El.default),Rl.default.use(Nl.default),Rl.default.use(Wl.default),Rl.default.use(Fl.default),Rl.default.use(Dl.default),Rl.default.use(kl.default),Rl.default.use(Tl.default),Rl.default.use(Ll.default),Rl.default.feedback=Cl,Rl.default.use(zl.default),Rl.default.vue={components:ql},Rl.default.__utils={exchange:xl.exchange,displace:Bl,pointer:Vl};var Kl=Rl.default;jl.default=Kl;var $l={exports:{}};Object.defineProperty($l.exports,"__esModule",{value:!0}),$l.exports.default=void 0;var Zl,Jl=(Zl=jl)&&Zl.__esModule?Zl:{default:Zl};function Ql(t){return(Ql="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}if("object"===Ql($l)&&$l)try{$l.exports=Jl.default}catch(t){}Jl.default.default=Jl.default;var tc=Jl.default;return $l.exports.default=tc,$l=$l.exports});



}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
/*!
 * isect v3.0.0
 * (c) 2018 Andrei Kashcha.
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.isect = {})));
}(this, (function (exports) { 'use strict';

  /* follows "An implementation of top-down splaying"
   * by D. Sleator <sleator@cs.cmu.edu> March 1992
   */

  /**
   * @typedef {*} Key
   */


  /**
   * @typedef {*} Value
   */


  /**
   * @typedef {function(node:Node):void} Visitor
   */


  /**
   * @typedef {function(a:Key, b:Key):number} Comparator
   */


  /**
   * @param {function(node:Node):string} NodePrinter
   */


  /**
   * @typedef {Object}  Node
   * @property {Key}    Key
   * @property {Value=} data
   * @property {Node}   left
   * @property {Node}   right
   */

  var Node = function Node (key, data) {
    this.key  = key;
    this.data = data;
    this.left = null;
    this.right= null;
  };

  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }


  /**
   * Simple top down splay, not requiring i to be in the tree t.
   * @param {Key} i
   * @param {Node?} t
   * @param {Comparator} comparator
   */
  function splay (i, t, comparator) {
    if (t === null) { return t; }
    var l, r, y;
    var N = new Node();
    l = r = N;

    while (true) {
      var cmp = comparator(i, t.key);
      //if (i < t.key) {
      if (cmp < 0) {
        if (t.left === null) { break; }
        //if (i < t.left.key) {
        if (comparator(i, t.left.key) < 0) {
          y = t.left;                           /* rotate right */
          t.left = y.right;
          y.right = t;
          t = y;
          if (t.left === null) { break; }
        }
        r.left = t;                               /* link right */
        r = t;
        t = t.left;
      //} else if (i > t.key) {
      } else if (cmp > 0) {
        if (t.right === null) { break; }
        //if (i > t.right.key) {
        if (comparator(i, t.right.key) > 0) {
          y = t.right;                          /* rotate left */
          t.right = y.left;
          y.left = t;
          t = y;
          if (t.right === null) { break; }
        }
        l.right = t;                              /* link left */
        l = t;
        t = t.right;
      } else {
        break;
      }
    }
    /* assemble */
    l.right = t.left;
    r.left = t.right;
    t.left = N.right;
    t.right = N.left;
    return t;
  }


  /**
   * @param  {Key}        i
   * @param  {Value}      data
   * @param  {Comparator} comparator
   * @param  {Tree}       tree
   * @return {Node}      root
   */
  function insert (i, data, t, comparator, tree) {
    var node = new Node(i, data);

    tree._size++;

    if (t === null) {
      node.left = node.right = null;
      return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp < 0) {
      node.left = t.left;
      node.right = t;
      t.left = null;
    } else if (cmp >= 0) {
      node.right = t.right;
      node.left = t;
      t.right = null;
    }
    return node;
  }


  /**
   * Insert i into the tree t, unless it's already there.
   * @param  {Key}        i
   * @param  {Value}      data
   * @param  {Comparator} comparator
   * @param  {Tree}       tree
   * @return {Node}       root
   */
  function add (i, data, t, comparator, tree) {
    var node = new Node(i, data);

    if (t === null) {
      node.left = node.right = null;
      tree._size++;
      return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp === 0) { return t; }
    else {
      if (cmp < 0) {
        node.left = t.left;
        node.right = t;
        t.left = null;
      } else if (cmp > 0) {
        node.right = t.right;
        node.left = t;
        t.right = null;
      }
      tree._size++;
      return node;
    }
  }


  /**
   * Deletes i from the tree if it's there
   * @param {Key}        i
   * @param {Tree}       tree
   * @param {Comparator} comparator
   * @param {Tree}       tree
   * @return {Node}      new root
   */
  function remove (i, t, comparator, tree) {
    var x;
    if (t === null) { return null; }
    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp === 0) {               /* found it */
      if (t.left === null) {
        x = t.right;
      } else {
        x = splay(i, t.left, comparator);
        x.right = t.right;
      }
      tree._size--;
      return x;
    }
    return t;                         /* It wasn't there */
  }


  function split (key, v, comparator) {
    var left, right;
    if (v === null) {
      left = right = null;
    } else {
      v = splay(key, v, comparator);

      var cmp = comparator(v.key, key);
      if (cmp === 0) {
        left  = v.left;
        right = v.right;
      } else if (cmp < 0) {
        right   = v.right;
        v.right = null;
        left    = v;
      } else {
        left   = v.left;
        v.left = null;
        right  = v;
      }
    }
    return { left: left, right: right };
  }


  function merge (left, right, comparator) {
    if (right === null) { return left; }
    if (left  === null) { return right; }

    right = splay(left.key, right, comparator);
    right.left = left;
    return right;
  }


  /**
   * Prints level of the tree
   * @param  {Node}                        root
   * @param  {String}                      prefix
   * @param  {Boolean}                     isTail
   * @param  {Array<string>}               out
   * @param  {Function(node:Node):String}  printNode
   */
  function printRow (root, prefix, isTail, out, printNode) {
    if (root) {
      out(("" + prefix + (isTail ? 'âââ ' : 'âââ ') + (printNode(root)) + "\n"));
      var indent = prefix + (isTail ? '    ' : 'â   ');
      if (root.left)  { printRow(root.left,  indent, false, out, printNode); }
      if (root.right) { printRow(root.right, indent, true,  out, printNode); }
    }
  }


  var Tree = function Tree (comparator) {
    if ( comparator === void 0 ) comparator = DEFAULT_COMPARE;

    this._comparator = comparator;
    this._root = null;
    this._size = 0;
  };

  var prototypeAccessors = { size: { configurable: true } };


  /**
   * Inserts a key, allows duplicates
   * @param{Key}  key
   * @param{Value=} data
   * @return {Node|null}
   */
  Tree.prototype.insert = function insert$1 (key, data) {
    return this._root = insert(key, data, this._root, this._comparator, this);
  };


  /**
   * Adds a key, if it is not present in the tree
   * @param{Key}  key
   * @param{Value=} data
   * @return {Node|null}
   */
  Tree.prototype.add = function add$1 (key, data) {
    return this._root = add(key, data, this._root, this._comparator, this);
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.remove = function remove$1 (key) {
    this._root = remove(key, this._root, this._comparator, this);
  };


  /**
   * Removes and returns the node with smallest key
   * @return {?Node}
   */
  Tree.prototype.pop = function pop () {
    var node = this._root;
    if (node) {
      while (node.left) { node = node.left; }
      this._root = splay(node.key,this._root, this._comparator);
      this._root = remove(node.key, this._root, this._comparator, this);
      return { key: node.key, data: node.data };
    }
    return null;
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.findStatic = function findStatic (key) {
    var current = this._root;
    var compare = this._comparator;
    while (current) {
      var cmp = compare(key, current.key);
      if (cmp === 0)  { return current; }
      else if (cmp < 0) { current = current.left; }
      else            { current = current.right; }
    }
    return null;
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.find = function find (key) {
    if (this._root) {
      this._root = splay(key, this._root, this._comparator);
      if (this._comparator(key, this._root.key) !== 0) { return null; }
    }
    return this._root;
  };


  /**
   * @param{Key} key
   * @return {Boolean}
   */
  Tree.prototype.contains = function contains (key) {
    var current = this._root;
    var compare = this._comparator;
    while (current) {
      var cmp = compare(key, current.key);
      if (cmp === 0)  { return true; }
      else if (cmp < 0) { current = current.left; }
      else            { current = current.right; }
    }
    return false;
  };


  /**
   * @param{Visitor} visitor
   * @param{*=}    ctx
   * @return {SplayTree}
   */
  Tree.prototype.forEach = function forEach (visitor, ctx) {
    var current = this._root;
    var Q = [];/* Initialize stack s */
    var done = false;

    while (!done) {
      if (current !==null) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length !== 0) {
          current = Q.pop();
          visitor.call(ctx, current);

          current = current.right;
        } else { done = true; }
      }
    }
    return this;
  };


  /**
   * Walk key range from `low` to `high`. Stops if `fn` returns a value.
   * @param{Key}    low
   * @param{Key}    high
   * @param{Function} fn
   * @param{*?}     ctx
   * @return {SplayTree}
   */
  Tree.prototype.range = function range (low, high, fn, ctx) {
      var this$1 = this;

    var Q = [];
    var compare = this._comparator;
    var node = this._root, cmp;

    while (Q.length !== 0 || node) {
      if (node) {
        Q.push(node);
        node = node.left;
      } else {
        node = Q.pop();
        cmp = compare(node.key, high);
        if (cmp > 0) {
          break;
        } else if (compare(node.key, low) >= 0) {
          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned
        }
        node = node.right;
      }
    }
    return this;
  };


  /**
   * Returns array of keys
   * @return {Array<Key>}
   */
  Tree.prototype.keys = function keys () {
    var keys = [];
    this.forEach(function (ref) {
        var key = ref.key;

        return keys.push(key);
      });
    return keys;
  };


  /**
   * Returns array of all the data in the nodes
   * @return {Array<Value>}
   */
  Tree.prototype.values = function values () {
    var values = [];
    this.forEach(function (ref) {
        var data = ref.data;

        return values.push(data);
      });
    return values;
  };


  /**
   * @return {Key|null}
   */
  Tree.prototype.min = function min () {
    if (this._root) { return this.minNode(this._root).key; }
    return null;
  };


  /**
   * @return {Key|null}
   */
  Tree.prototype.max = function max () {
    if (this._root) { return this.maxNode(this._root).key; }
    return null;
  };


  /**
   * @return {Node|null}
   */
  Tree.prototype.minNode = function minNode (t) {
      if ( t === void 0 ) t = this._root;

    if (t) { while (t.left) { t = t.left; } }
    return t;
  };


  /**
   * @return {Node|null}
   */
  Tree.prototype.maxNode = function maxNode (t) {
      if ( t === void 0 ) t = this._root;

    if (t) { while (t.right) { t = t.right; } }
    return t;
  };


  /**
   * Returns node at given index
   * @param{number} index
   * @return {?Node}
   */
  Tree.prototype.at = function at (index) {
    var current = this._root, done = false, i = 0;
    var Q = [];

    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = Q.pop();
          if (i === index) { return current; }
          i++;
          current = current.right;
        } else { done = true; }
      }
    }
    return null;
  };


  /**
   * @param{Node} d
   * @return {Node|null}
   */
  Tree.prototype.next = function next (d) {
    var root = this._root;
    var successor = null;

    if (d.right) {
      successor = d.right;
      while (successor.left) { successor = successor.left; }
      return successor;
    }

    var comparator = this._comparator;
    while (root) {
      var cmp = comparator(d.key, root.key);
      if (cmp === 0) { break; }
      else if (cmp < 0) {
        successor = root;
        root = root.left;
      } else { root = root.right; }
    }

    return successor;
  };


  /**
   * @param{Node} d
   * @return {Node|null}
   */
  Tree.prototype.prev = function prev (d) {
    var root = this._root;
    var predecessor = null;

    if (d.left !== null) {
      predecessor = d.left;
      while (predecessor.right) { predecessor = predecessor.right; }
      return predecessor;
    }

    var comparator = this._comparator;
    while (root) {
      var cmp = comparator(d.key, root.key);
      if (cmp === 0) { break; }
      else if (cmp < 0) { root = root.left; }
      else {
        predecessor = root;
        root = root.right;
      }
    }
    return predecessor;
  };


  /**
   * @return {SplayTree}
   */
  Tree.prototype.clear = function clear () {
    this._root = null;
    this._size = 0;
    return this;
  };


  /**
   * @return {NodeList}
   */
  Tree.prototype.toList = function toList$1 () {
    return toList(this._root);
  };


  /**
   * Bulk-load items. Both array have to be same size
   * @param{Array<Key>}  keys
   * @param{Array<Value>}[values]
   * @param{Boolean}     [presort=false] Pre-sort keys and values, using
   *                                       tree's comparator. Sorting is done
   *                                       in-place
   * @return {AVLTree}
   */
  Tree.prototype.load = function load (keys, values, presort) {
      if ( keys === void 0 ) keys = [];
      if ( values === void 0 ) values = [];
      if ( presort === void 0 ) presort = false;

    var size = keys.length;
    var comparator = this._comparator;

    // sort if needed
    if (presort) { sort(keys, values, 0, size - 1, comparator); }

    if (this._root === null) { // empty tree
      this._root = loadRecursive(this._root, keys, values, 0, size);
      this._size = size;
    } else { // that re-builds the whole tree from two in-order traversals
      var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
      size = this._size + size;
      this._root = sortedListToBST({ head: mergedList }, 0, size);
    }
    return this;
  };


  /**
   * @return {Boolean}
   */
  Tree.prototype.isEmpty = function isEmpty () { return this._root === null; };

  prototypeAccessors.size.get = function () { return this._size; };


  /**
   * @param{NodePrinter=} printNode
   * @return {String}
   */
  Tree.prototype.toString = function toString (printNode) {
      if ( printNode === void 0 ) printNode = function (n) { return n.key; };

    var out = [];
    printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);
    return out.join('');
  };


  Tree.prototype.update = function update (key, newKey, newData) {
    var comparator = this._comparator;
    var ref = split(key, this._root, comparator);
      var left = ref.left;
      var right = ref.right;
    this._size--;
    if (comparator(key, newKey) < 0) {
      right = insert(newKey, newData, right, comparator, this);
    } else {
      left = insert(newKey, newData, left, comparator, this);
    }
    this._root = merge(left, right, comparator);
  };


  Tree.prototype.split = function split$1 (key) {
    return split(key, this._root, this._comparator);
  };

  Object.defineProperties( Tree.prototype, prototypeAccessors );


  function loadRecursive (parent, keys, values, start, end) {
    var size = end - start;
    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var key    = keys[middle];
      var data   = values[middle];
      var node   = { key: key, data: data, parent: parent };
      node.left    = loadRecursive(node, keys, values, start, middle);
      node.right   = loadRecursive(node, keys, values, middle + 1, end);
      return node;
    }
    return null;
  }


  function createList(keys, values) {
    var head = { next: null };
    var p = head;
    for (var i = 0; i < keys.length; i++) {
      p = p.next = { key: keys[i], data: values[i] };
    }
    p.next = null;
    return head.next;
  }


  function toList (root) {
    var current = root;
    var Q = [], done = false;

    var head = { next: null };
    var p = head;

    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = p = p.next = Q.pop();
          current = current.right;
        } else { done = true; }
      }
    }
    p.next = null; // that'll work even if the tree was empty
    return head.next;
  }


  function sortedListToBST(list, start, end) {
    var size = end - start;
    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var left = sortedListToBST(list, start, middle);

      var root = list.head;
      root.left = left;

      list.head = list.head.next;

      root.right = sortedListToBST(list, middle + 1, end);
      return root;
    }
    return null;
  }


  function mergeLists (l1, l2, compare) {
    if ( compare === void 0 ) compare = function (a, b) { return a - b; };

    var head = {}; // dummy
    var p = head;

    var p1 = l1;
    var p2 = l2;

    while (p1 !== null && p2 !== null) {
      if (compare(p1.key, p2.key) < 0) {
        p.next = p1;
        p1 = p1.next;
      } else {
        p.next = p2;
        p2 = p2.next;
      }
      p = p.next;
    }

    if (p1 !== null)      { p.next = p1; }
    else if (p2 !== null) { p.next = p2; }

    return head.next;
  }


  function sort(keys, values, left, right, compare) {
    if (left >= right) { return; }

    var pivot = keys[(left + right) >> 1];
    var i = left - 1;
    var j = right + 1;

    while (true) {
      do { i++; } while (compare(keys[i], pivot) < 0);
      do { j--; } while (compare(keys[j], pivot) > 0);
      if (i >= j) { break; }

      var tmp = keys[i];
      keys[i] = keys[j];
      keys[j] = tmp;

      tmp = values[i];
      values[i] = values[j];
      values[j] = tmp;
    }

    sort(keys, values,  left,     j, compare);
    sort(keys, values, j + 1, right, compare);
  }

  function createEventQueue(byY) {
    var q = new Tree(byY);

    return {
      isEmpty: isEmpty,
      size: size,
      pop: pop,
      find: find,
      insert: insert
    }

    function find(p) {
      return q.find(p);
    }

    function size() {
      return q.size;
    }

    function isEmpty() {
      return q.isEmpty();
    }

    function insert(event) {
      // debugger;
      q.add(event.point, event);
    }

    function pop() {
      var node = q.pop();
      return node && node.data;
    }
  }

  /**
   * Just a collection of geometry related utilities
   */

  // This is used for precision checking (e.g. two numbers are equal
  // if their difference is smaller than this number). The value is 
  // chosen empirically. We still may run into precision related issues.
  // TODO: we should allow consumers to configure this.
  var EPS = 1e-9;//10;

  function getIntersectionXPoint(segment, xPos, yPos) {
    var dy1 = segment.from.y - yPos;
    var dy2 = yPos - segment.to.y;
    var dy = segment.to.y - segment.from.y;
    if (Math.abs(dy1) < EPS) {
      // The segment starts on the sweep line
      if (Math.abs(dy) < EPS) {
        // the segment is horizontal. Intersection is at the point
        if (xPos <= segment.from.x) { return segment.from.x; }
        if (xPos > segment.to.x) { return segment.to.x; }
        return xPos;
      }
      return segment.from.x;
    }
    
    var dx = (segment.to.x - segment.from.x); 
    var xOffset; 
    if (dy1 >= dy2) {
      xOffset = dy1 * (dx / dy); 
      return (segment.from.x - xOffset);
    } 
    xOffset = dy2 * (dx / dy);
    return (segment.to.x + xOffset);
  }

  function angle(dx, dy) {
    // https://stackoverflow.com/questions/16542042/fastest-way-to-sort-vectors-by-angle-without-actually-computing-that-angle
    var p = dx/(Math.abs(dx) + Math.abs(dy)); // -1 .. 1 increasing with x

    if (dy < 0) { return p - 1; }  // -2 .. 0 increasing with x
    return 1 - p               //  0 .. 2 decreasing with x
  }

  function intersectSegments(a, b) {
    //  https://stackoverflow.com/a/1968345/125351
    var aStart = a.from, bStart = b.from;
    var p0_x = aStart.x, p0_y = aStart.y,
        p2_x = bStart.x, p2_y = bStart.y;

    var s1_x = a.dx, s1_y = a.dy, s2_x = b.dx, s2_y = b.dy;
    var div = s1_x * s2_y - s2_x * s1_y;

    var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
    if (s < 0 || s > 1) { return; }

    var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

    if (t >= 0 && t <= 1) {
      return {
        x: p0_x - (t * s1_x),
        y: p0_y - (t * s1_y)
      }
    }
  }

  function samePoint(a, b) {
    return Math.abs(a.x - b.x) < EPS && Math.abs(a.y - b.y) < EPS;
  }

  /**
   * Creates a new sweep status data structure.
   */
  function createSweepStatus(onError, EPS$$1) {
    var lastPointY, prevY;
    var lastPointX, prevX;
    var useBelow = false;
    var status = new Tree(compareSegments);

    // To save on GC we return mutable object.
    var currentBoundary = {
      beforeLeft: null,
      left: null,
      right: null,
      afterRight: null,
    };

    var currentLeftRight = {left: null, right: null};

    return {
      /**
       * Add new segments into the status tree.
       */
      insertSegments: insertSegments,

      /**
       * Remove segments from the status tree.
       */
      deleteSegments: deleteSegments,

      /**
       * Returns segments that are to the left and right from a given point.
       */
      getLeftRightPoint: getLeftRightPoint,

      /**
       * For a given collections of segments finds the most left and the most right
       * segments. Also returns segments immediately before left, and after right segments.
       */
      getBoundarySegments: getBoundarySegments,

      findSegmentsWithPoint: findSegmentsWithPoint,

      /**
       * Current binary search tree with segments
       */
      status: status,

      /**
       * Introspection method that verifies if there are duplicates in the segment tree.
       * If there are - `onError()` is called.
       */
      checkDuplicate: checkDuplicate,

      /**
       * Prints current segments in order of their intersection with sweep line. Introspection method.
       */
      printStatus: printStatus,

      /**
       * Returns current position of the sweep line.
       */
      getLastPoint: function getLastPoint() {
        return {x: lastPointX, y: lastPointY};
      }
    }

    function compareSegments(a, b) {
      if (a === b) { return 0; }

      var ak = getIntersectionXPoint(a, lastPointX, lastPointY);
      var bk = getIntersectionXPoint(b, lastPointX, lastPointY);

      var res = ak - bk;
      if (Math.abs(res) >= EPS$$1) {
        // We are okay fine. Intersection distance between two segments
        // is good to give conclusive answer
        return res;
      }

      var aIsHorizontal = Math.abs(a.dy) < EPS$$1;
      var bIsHorizontal = Math.abs(b.dy) < EPS$$1;
      if (aIsHorizontal && bIsHorizontal) {
        return b.to.x - a.to.x;
      }
      // TODO: What if both a and b is horizontal?
      // move horizontal to end
      if (aIsHorizontal) { 
        return useBelow ? -1 : 1;
      }

      if (bIsHorizontal) {
        if (useBelow) {
          return (b.from.x >= lastPointX) ? -1 : 1
        }
        return -1;
        // return useBelow ? 1 : -1;
      }
      var pa = a.angle;
      var pb = b.angle;
      if (Math.abs(pa - pb) >= EPS$$1) {
        return useBelow ? pa - pb : pb - pa;
      }

      var segDist = a.from.y - b.from.y;
      if (Math.abs(segDist) >= EPS$$1) {
        return -segDist;
      }
      segDist = a.to.y - b.to.y;
      if (Math.abs(segDist) >= EPS$$1) {
        // TODO: Is this accurate?
        return -segDist;
      }

      return 0;
      // Could also use:
      // var aAngle = Math.atan2(a.from.y - a.to.y, a.from.x - a.to.x);
      // var bAngle = Math.atan2(b.from.y - b.to.y, b.from.x - b.to.x);
      // return useBelow ? bAngle - aAngle : aAngle - bAngle;
    }

    function getBoundarySegments(upper, interior) {
      var leftMost, rightMost, i;
      var uLength = upper.length;

      if (uLength > 0) {
        leftMost = rightMost = upper[0];
      } else {
        leftMost = rightMost = interior[0];
      }

      for (i = 1; i < uLength; ++i) {
        var s = upper[i];
        var cmp = compareSegments(leftMost, s);
        if (cmp > 0) { leftMost = s; }

        cmp = compareSegments(rightMost, s);
        if (cmp < 0) { rightMost = s; }
      }

      var startFrom = uLength > 0 ? 0 : 1;
      for (i = startFrom; i < interior.length; ++i) {
        s = interior[i];
        cmp = compareSegments(leftMost, s);
        if (cmp > 0) { leftMost = s; }

        cmp = compareSegments(rightMost, s);
        if (cmp < 0) { rightMost = s; }
      }

      // at this point we have our left/right segments in the status.
      // Let's find their prev/next elements and report them back:
      var left = status.find(leftMost);
      if (!left) {
        onError('Left is missing. Precision error?');
      }

      var right = status.find(rightMost);
      if (!right) {
        onError('Right is missing. Precision error?');
      }

      var beforeLeft = left && status.prev(left);
      var afterRight = right && status.next(right);

      while (afterRight && right.key.dy === 0 && afterRight.key.dy === 0) {
        // horizontal segments are special :(
        afterRight = status.next(afterRight);
      }

      currentBoundary.beforeLeft = beforeLeft && beforeLeft.key;
      currentBoundary.left = left && left.key;
      currentBoundary.right = right && right.key;
      currentBoundary.afterRight = afterRight && afterRight.key;

      return currentBoundary;
    }

    function getLeftRightPoint(p) {
      // We are trying to find left and right segments that are nearest to the
      // point p. For this we traverse the binary search tree, and remember
      // node with the shortest distance to p.
      var lastLeft;
      var current = status._root;
      var minX = Number.POSITIVE_INFINITY;
      while (current) {
        var x = getIntersectionXPoint(current.key, p.x, p.y);
        var dx = p.x - x;
        if (dx >= 0) {
          if (dx < minX) {
            minX = dx;
            lastLeft = current;
            current = current.left;
          } else {
            break;
          }
        } else {
          if (-dx < minX) {
            minX = -dx;
            lastLeft = current;
            current = current.right;
          } else {
            break;
          }
        }
      }

      currentLeftRight.left = lastLeft && lastLeft.key;
      var next = lastLeft && status.next(lastLeft);
      currentLeftRight.right = next && next.key;
      return currentLeftRight;

      // Conceptually, the code above should be equivalent to the code below;
      // The code below is easier to understand, but intuitively, the code above
      // should have better performance (as we do not traverse the entire status
      // tree)

      // var right, left,  x;
      // var all = status.keys()
      // for (var i = 0; i < all.length; ++i) {
      //   var segment = all[i];
      //   x = getIntersectionXPoint(segment, p.x, p.y);
      //   if (x > p.x && !right) {
      //     right = segment;
      //     break;
      //   } else if (x < p.x) {
      //     left = segment;
      //   }
      // }

      // currentLeftRight.left = left;
      // currentLeftRight.right = right;

      // return currentLeftRight;
    }

    function findSegmentsWithPoint(p, onFound) {
      // Option 1.
      // var arrResults = [];
      // status.forEach(current => {
      //   var x = getIntersectionXPoint(current.key, p.x, p.y);
      //   var dx = p.x - x;
      //   if (Math.abs(dx) < EPS) {
      //     onFound(current.key);
      //    // arrResults.push(current.key)
      //   }
      // });
      // return arrResults;

      // Option 2.

      // let current = status._root;
      // const Q = [];  /* Initialize stack s */
      // let done = false;
      // var res = [];
      // var breakEarly = false;

      // while (!done) {
      //   if (current !==  null) {
      //     Q.push(current);
      //     current = current.left;
      //   } else {
      //     if (Q.length !== 0) {
      //       current = Q.pop();

      //       var x = getIntersectionXPoint(current.key, p.x, p.y);
      //       var dx = p.x - x;
      //       if (Math.abs(dx) < EPS) {
      //         res.push(current.key)
      //         breakEarly = true;
      //       } else if (breakEarly) {
      //         done = true;
      //       }

      //       current = current.right;
      //     } else done = true;
      //   }
      // }

      // return res;

      // option 3.
      var current = status._root;

      while (current) {
        var x = getIntersectionXPoint(current.key, p.x, p.y);
        var dx = p.x - x;
        if (Math.abs(dx) < EPS$$1) {
          collectAdjacentNodes(current, p, onFound);
          break;
        } else if (dx < 0) {
          current = current.left;
        } else {
          current = current.right;
        }
      }
    }

    function collectAdjacentNodes(root, p, onFound) {
      onFound(root.key);
      goOverPredecessors(root.left, p, onFound);
      goOverSuccessors(root.right, p, onFound);
    }

    function goOverPredecessors(root, p, res) {
      if (!root) { return; }
      var x = getIntersectionXPoint(root.key, p.x, p.y);
      var dx = p.x - x;
      if (Math.abs(dx) < EPS$$1) {
        collectAdjacentNodes(root, p, res);
      } else {
        goOverPredecessors(root.right, p, res);
      }
    }

    function goOverSuccessors(root, p, res) {
      if (!root) { return; }
      var x = getIntersectionXPoint(root.key, p.x, p.y);
      var dx = p.x - x;
      if (Math.abs(dx) < EPS$$1) {
        collectAdjacentNodes(root, p, res);
      } else {
        goOverSuccessors(root.left, p, res);
      }
    }

    function checkDuplicate() {
      var prev;
      status.forEach(function (node) {
        var current = node.key;

        if (prev) {
          if (samePoint(prev.from, current.from) && samePoint(prev.to, current.to)) {
            // Likely you have received error before during segment removal.
            onError('Duplicate key in the status! This may be caused by Floating Point rounding error');
          }
        }
        prev = current;
      });
    }

    function printStatus(prefix) {
      if ( prefix === void 0 ) prefix = '';

      // eslint-disable-next-line
      console.log(prefix, 'status line: ', lastPointX, lastPointY);
      status.forEach(function (node) {
        var x = getIntersectionXPoint(node.key, lastPointX, lastPointY);
        // eslint-disable-next-line
        console.log(x + ' ' + node.key.name);
      });
    }

    function insertSegments(interior, upper, sweepLinePos) {
      lastPointY = sweepLinePos.y;
      lastPointX = sweepLinePos.x;
      var key;

      for (var i = 0; i < interior.length; ++i) {
        key = interior[i];
        status.add(key);
      }
      for (i = 0; i < upper.length; ++i) {
        key = upper[i];
        status.add(key);
      }
    }

    function deleteSegments(lower, interior, sweepLinePos) {
      // I spent most of the time debugging this method. Depending on the
      // algorithm state we can run into situation when dynamic keys of the
      // `status` tree predict wrong branch, and thus we are not able to find
      // the segment that needs to be deleted. If that happens I'm trying to
      // use previous point and repeat the process. This may result in 
      // incorrect state. In that case I report an error. 
      var i;
      var prevCount = status._size;
      prevX = lastPointX;
      prevY = lastPointY;
      lastPointY = sweepLinePos.y;
      lastPointX = sweepLinePos.x;

      useBelow = true;
      for(i = 0; i < lower.length; ++i) {
        removeSegment(lower[i], sweepLinePos);
      }
      for(i = 0; i < interior.length; ++i) {
        removeSegment(interior[i], sweepLinePos);
      }
      useBelow = false;

      if (status._size !== prevCount - interior.length - lower.length) {
        // This can happen when rounding error occurs. You can try scaling your input
        onError('Segments were not removed from a tree properly. Precision error?');
      }
    }

    function removeSegment(key, sweepLinePos) {
      if (status.find(key)) {
        status.remove(key);
      } else {
        lastPointX = prevX;
        lastPointY = prevY;
        if (status.find(key)) {
          status.remove(key);
        }
        lastPointY = sweepLinePos.y;
        lastPointX = sweepLinePos.x;
      }
    }
  }

  /**
   * Represents a single event in the sweep-line algorithm
   */
  var SweepEvent = function SweepEvent(point, segment) {
    this.point = point;
    if (segment) { this.from = [segment]; }
  };

  /**
   * A point on a line
   * 
   * @typedef {Object} Point
   * @property {number} x coordinate
   * @property {number} y coordinate
   */


  /**
   * @typedef {Object} Segment 
   * @property {Point} from start of the segment
   * @property {Point} to end of the segment
   */

  /**
   * @typedef {function(point : Point, interior : Segment[], lower : Segment[], upper : Segment[])} ReportIntersectionCallback
   */

  /**
   * @typedef {Object} ISectOptions 
   * @property {ReportIntersectionCallback} onFound 
   */

   /**
    * @typedef {Object} ISectResult
    */

  // We use EMPTY array to avoid pressure on garbage collector. Need to be
  // very cautious to not mutate this array.
  var EMPTY = [];

  /**
   * Finds all intersections among given segments.
   * 
   * The algorithm follows "Computation Geometry, Algorithms and Applications" book
   * by Mark de Berg, Otfried Cheong, Marc van Kreveld, and Mark Overmars.
   * 
   * Line is swept top-down
   * 
   * @param {Segment[]} segments
   * @param {ISectOptions=} options
   * @returns {ISectResult}
   */
  function isect(segments, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || defaultIntersectionReporter;

    var onError = (options && options.onError) || defaultErrorReporter;

    var eventQueue = createEventQueue(byY);
    var sweepStatus = createSweepStatus(onError, EPS);
    var lower, interior, lastPoint;

    segments.forEach(addSegment);

    return {
      /**
       * Find all intersections synchronously.
       * 
       * @returns array of found intersections.
       */
      run: run,

      /**
       * Performs a single step in the sweep line algorithm
       * 
       * @returns true if there was something to process; False if no more work to do
       */
      step: step,

      // Methods below are low level API for fine-grained control.
      // Don't use it unless you understand this code thoroughly

      /**
       * Add segment into the 
       */
      addSegment: addSegment,

      /**
       * Direct access to event queue. Queue contains segment endpoints and
       * pending detected intersections.
       */
      eventQueue: eventQueue, 

      /**
       * Direct access to sweep line status. "Status" holds information about
       * all intersected segments.
       */
      sweepStatus: sweepStatus,

      /**
       * Access to results array. Works only when you use default onFound() handler
       */
      results: results
    }

    function run() {
      while (!eventQueue.isEmpty()) {
        var eventPoint = eventQueue.pop();
        if (handleEventPoint(eventPoint)) {
          // they decided to stop.
          return;
        }    }

      return results;
    }

    function step() {
      if (!eventQueue.isEmpty()) {
        var eventPoint = eventQueue.pop();
        handleEventPoint(eventPoint);
        // Note: we don't check results of `handleEventPoint()`
        // assumption is that client controls `step()` and thus they 
        // know better if they want to stop.
        return true;
      }
      return false;
    }

    function handleEventPoint(p) {
      lastPoint = p.point;
      var upper = p.from || EMPTY;

      lower = interior = undefined;
      // TODO: move lower/interior into sweep status method?

      sweepStatus.findSegmentsWithPoint(lastPoint, addLowerOrInterior);
      // if (segmentsWithPoint) {
      //   segmentsWithPoint.forEach()
      // } 

      if (!lower) { lower = EMPTY; }
      if (!interior) { interior = EMPTY; }

      var uLength = upper.length;
      var iLength = interior.length;
      var lLength = lower.length;
      var hasIntersection = uLength + iLength + lLength > 1;
      var hasPointIntersection = !hasIntersection && (uLength === 0 && lLength === 0 && iLength > 0);

      if (hasIntersection || hasPointIntersection) {
        p.isReported = true;
        if (reportIntersection(lastPoint, union(interior, union(lower, upper)))) {
          return true;
        }
      }

      sweepStatus.deleteSegments(lower, interior, lastPoint);
      sweepStatus.insertSegments(interior, upper, lastPoint);

      var sLeft, sRight;

      var hasNoCrossing = (uLength + iLength === 0);

      if (hasNoCrossing) {
        var leftRight = sweepStatus.getLeftRightPoint(lastPoint);
        sLeft = leftRight.left;
        if (!sLeft) { return; }

        sRight = leftRight.right;
        if (!sRight) { return; }

        findNewEvent(sLeft, sRight, p);
      } else {
        var boundarySegments = sweepStatus.getBoundarySegments(upper, interior);

        findNewEvent(boundarySegments.beforeLeft, boundarySegments.left, p);
        findNewEvent(boundarySegments.right, boundarySegments.afterRight, p);
      }

      return false;
    }

    function addLowerOrInterior(s) {
      if (samePoint(s.to, lastPoint)) {
        if (!lower) { lower = [s]; }
        else { lower.push(s); }
      } else if (!samePoint(s.from, lastPoint)) {
        if (!interior) { interior = [s]; }
        else { interior.push(s); }
      }
    }

    function findNewEvent(left, right, p) {
      if (!left || !right) { return; }

      var intersection = intersectSegments(left, right);
      if (!intersection) {
          return;
      }

      var dy = p.point.y - intersection.y;
      // TODO: should I add dy to intersection.y?
      if (dy < -EPS) {
        // this means intersection happened after the sweep line. 
        // We already processed it.
        return;
      }
      if (Math.abs(dy) < EPS && intersection.x <= p.point.x) {
        return;
      }

      // Need to adjust floating point for this special case,
      // since otherwise it gives rounding errors:
      roundNearZero(intersection);

      var current = eventQueue.find(intersection);

      if (current && current.isReported) {
        // We already reported this event. No need to add it one more time
        // TODO: Is this case even possible?
        onError('We already reported this event.');
        return;
      }

      if (!current) {
        var event = new SweepEvent(intersection);
        eventQueue.insert(event);
      }
    }

    function defaultIntersectionReporter(p, segments) {
      results.push({
        point: p, 
        segments: segments
      });
    }

    function addSegment(segment) {
      var from = segment.from;
      var to = segment.to;

      // Small numbers give more precision errors. Rounding them to 0.
      roundNearZero(from);
      roundNearZero(to);

      var dy = from.y - to.y;

      // Note: dy is much smaller then EPS on purpose. I found that higher
      // precision here does less good - getting way more rounding errors.
      if (Math.abs(dy) < 1e-5) {
        from.y = to.y;
        segment.dy = 0;
      }
      if ((from.y < to.y) || (
          (from.y === to.y) && (from.x > to.x))
        ) {
        var temp = from;
        from = segment.from = to; 
        to = segment.to = temp;
      }

      // We pre-compute some immutable properties of the segment
      // They are used quite often in the tree traversal, and pre-computation
      // gives significant boost:
      segment.dy = from.y - to.y;
      segment.dx = from.x - to.x;
      segment.angle = angle(segment.dy, segment.dx);

      var isPoint = segment.dy === segment.dx && segment.dy === 0;
      var prev = eventQueue.find(from);
      if (prev && !isPoint) {
        // this detects identical segments early. Without this check
        // the algorithm would break since sweep line has no means to
        // detect identical segments.
        var prevFrom = prev.data.from;
        if (prevFrom) {
          for (var i = 0; i < prevFrom.length; ++i) {
            var s = prevFrom[i];
            if (samePoint(s.to, to)) {
              reportIntersection(s.from, [s.from, s.to]);
              reportIntersection(s.to, [s.from, s.to]);
              return;
            }
          }
        }
      }

      if (!isPoint) {
        if (prev) {
          if (prev.data.from) { prev.data.from.push(segment); }
          else { prev.data.from = [segment]; }
        } else {
          var e = new SweepEvent(from, segment);
          eventQueue.insert(e);
        }
        var event = new SweepEvent(to);
        eventQueue.insert(event);
      } else {
        var event = new SweepEvent(to);
        eventQueue.insert(event);
      }
    } 
  }

  function roundNearZero(point) {
    if (Math.abs(point.x) < EPS) { point.x = 0; }
    if (Math.abs(point.y) < EPS) { point.y = 0; }
  }

  function defaultErrorReporter(errorMessage) {
    throw new Error(errorMessage);
  }

  function union(a, b) {
    if (!a) { return b; }
    if (!b) { return a; }

    return a.concat(b);
  }

  function byY(a, b) {
    // decreasing Y 
    var res = b.y - a.y;
    // TODO: This might mess up the status tree.
    if (Math.abs(res) < EPS) {
      // increasing x.
      res = a.x - b.x;
      if (Math.abs(res) < EPS) { res = 0; }
    }

    return res;
  }

  function intersectSegments$1(a, b) {
    // Note: this is almost the same as geom.intersectSegments()
    // The main difference is that we don't have a pre-computed
    // value for dx/dy on the segments.
    //  https://stackoverflow.com/a/1968345/125351
    var aStart = a.from, bStart = b.from;
    var p0_x = aStart.x, p0_y = aStart.y,
        p2_x = bStart.x, p2_y = bStart.y;

    var s1_x = a.from.x - a.to.x, s1_y = a.from.y - a.to.y, s2_x = b.from.x - b.to.x, s2_y = b.from.y - b.to.y;
    var div = s1_x * s2_y - s2_x * s1_y;

    var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
    if (s < 0 || s > 1) { return; }

    var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

    if (t >= 0 && t <= 1) {
      return {
        x: p0_x - (t * s1_x),
        y: p0_y - (t * s1_y)
      }
    }
  }

  /**
   * This is a brute force solution with O(n^2) performance.
   * (`n` is number of segments).
   * 
   * Use this when number of lines is low, and number of intersections
   * is high.
   */
  function brute(lines, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || 
                              defaultIntersectionReporter;
    var asyncState;

    return {
      /**
       * Execute brute force of the segment intersection search
       */
      run: run,
      /**
       * Access to results array. Works only when you use default onFound() handler
       */
      results: results,

      /**
       * Performs a single step in the brute force algorithm ()
       */
      step: step
    }

    function step() {
      if (!asyncState) {
        asyncState = {
          i: 0
        };
      }
      var test = lines[asyncState.i];
      for (var j = asyncState.i + 1; j < lines.length; ++j) {
        var other = lines[j];
        var pt = intersectSegments$1(test, other);
        if (pt) {
          if (reportIntersection(pt, [test, other])) {
            return;
          }
        }
      }
      asyncState.i += 1;
      return asyncState.i < lines.length;
    }

    function run() {
      for(var i = 0; i < lines.length; ++i) {
        var test = lines[i];
        for (var j = i + 1; j < lines.length; ++j) {
          var other = lines[j];
          var pt = intersectSegments$1(test, other);
          if (pt) {
            if (reportIntersection(pt, [test, other])) {
              return;
            }
          }
        }
      }
      return results;
    }

    function defaultIntersectionReporter(p, interior) {
      results.push({
        point: p, 
        segments: interior
      });
    }
  }

  var ARRAY_TYPES = [
      Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
      Int32Array, Uint32Array, Float32Array, Float64Array
  ];

  var VERSION = 3; // serialized format version

  var Flatbush = function Flatbush(numItems, nodeSize, ArrayType, data) {
      var this$1 = this;

      if (numItems === undefined) { throw new Error('Missing required argument: numItems.'); }
      if (isNaN(numItems) || numItems <= 0) { throw new Error(("Unpexpected numItems value: " + numItems + ".")); }

      this.numItems = +numItems;
      this.nodeSize = Math.min(Math.max(+nodeSize || 16, 2), 65535);

      // calculate the total number of nodes in the R-tree to allocate space for
      // and the index of each tree level (used in search later)
      var n = numItems;
      var numNodes = n;
      this._levelBounds = [n * 4];
      do {
          n = Math.ceil(n / this$1.nodeSize);
          numNodes += n;
          this$1._levelBounds.push(numNodes * 4);
      } while (n !== 1);

      this.ArrayType = ArrayType || Float64Array;
      this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;

      var arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
      var nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;

      if (arrayTypeIndex < 0) {
          throw new Error(("Unexpected typed array class: " + ArrayType + "."));
      }

      if (data && (data instanceof ArrayBuffer)) {
          this.data = data;
          this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
          this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);

          this._pos = numNodes * 4;
          this.minX = this._boxes[this._pos - 4];
          this.minY = this._boxes[this._pos - 3];
          this.maxX = this._boxes[this._pos - 2];
          this.maxY = this._boxes[this._pos - 1];

      } else {
          this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
          this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
          this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
          this._pos = 0;
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;

          new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);
          new Uint16Array(this.data, 2, 1)[0] = nodeSize;
          new Uint32Array(this.data, 4, 1)[0] = numItems;
      }
  };

  Flatbush.from = function from (data) {
      if (!(data instanceof ArrayBuffer)) {
          throw new Error('Data must be an instance of ArrayBuffer.');
      }
      var ref = new Uint8Array(data, 0, 2);
          var magic = ref[0];
          var versionAndType = ref[1];
      if (magic !== 0xfb) {
          throw new Error('Data does not appear to be in a Flatbush format.');
      }
      if (versionAndType >> 4 !== VERSION) {
          throw new Error(("Got v" + (versionAndType >> 4) + " data when expected v" + VERSION + "."));
      }
      var ref$1 = new Uint16Array(data, 2, 1);
          var nodeSize = ref$1[0];
      var ref$2 = new Uint32Array(data, 4, 1);
          var numItems = ref$2[0];

      return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);
  };

  Flatbush.prototype.add = function add (minX, minY, maxX, maxY) {
      var index = this._pos >> 2;
      this._indices[index] = index;
      this._boxes[this._pos++] = minX;
      this._boxes[this._pos++] = minY;
      this._boxes[this._pos++] = maxX;
      this._boxes[this._pos++] = maxY;

      if (minX < this.minX) { this.minX = minX; }
      if (minY < this.minY) { this.minY = minY; }
      if (maxX > this.maxX) { this.maxX = maxX; }
      if (maxY > this.maxY) { this.maxY = maxY; }
  };

  Flatbush.prototype.finish = function finish () {
          var this$1 = this;

      if (this._pos >> 2 !== this.numItems) {
          throw new Error(("Added " + (this._pos >> 2) + " items when expected " + (this.numItems) + "."));
      }

      var width = this.maxX - this.minX;
      var height = this.maxY - this.minY;
      var hilbertValues = new Uint32Array(this.numItems);
      var hilbertMax = (1 << 16) - 1;

      // map item centers into Hilbert coordinate space and calculate Hilbert values
      for (var i = 0; i < this.numItems; i++) {
          var pos = 4 * i;
          var minX = this$1._boxes[pos++];
          var minY = this$1._boxes[pos++];
          var maxX = this$1._boxes[pos++];
          var maxY = this$1._boxes[pos++];
          var x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this$1.minX) / width);
          var y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this$1.minY) / height);
          hilbertValues[i] = hilbert(x, y);
      }

      // sort items by their Hilbert value (for packing later)
      sort$1(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1);

      // generate nodes at each tree level, bottom-up
      for (var i$1 = 0, pos$1 = 0; i$1 < this._levelBounds.length - 1; i$1++) {
          var end = this$1._levelBounds[i$1];

          // generate a parent node for each block of consecutive <nodeSize> nodes
          while (pos$1 < end) {
              var nodeMinX = Infinity;
              var nodeMinY = Infinity;
              var nodeMaxX = -Infinity;
              var nodeMaxY = -Infinity;
              var nodeIndex = pos$1;

              // calculate bbox for the new node
              for (var i$2 = 0; i$2 < this.nodeSize && pos$1 < end; i$2++) {
                  var minX$1 = this$1._boxes[pos$1++];
                  var minY$1 = this$1._boxes[pos$1++];
                  var maxX$1 = this$1._boxes[pos$1++];
                  var maxY$1 = this$1._boxes[pos$1++];
                  if (minX$1 < nodeMinX) { nodeMinX = minX$1; }
                  if (minY$1 < nodeMinY) { nodeMinY = minY$1; }
                  if (maxX$1 > nodeMaxX) { nodeMaxX = maxX$1; }
                  if (maxY$1 > nodeMaxY) { nodeMaxY = maxY$1; }
              }

              // add the new node to the tree data
              this$1._indices[this$1._pos >> 2] = nodeIndex;
              this$1._boxes[this$1._pos++] = nodeMinX;
              this$1._boxes[this$1._pos++] = nodeMinY;
              this$1._boxes[this$1._pos++] = nodeMaxX;
              this$1._boxes[this$1._pos++] = nodeMaxY;
          }
      }
  };

  Flatbush.prototype.search = function search (minX, minY, maxX, maxY, filterFn) {
          var this$1 = this;

      if (this._pos !== this._boxes.length) {
          throw new Error('Data not yet indexed - call index.finish().');
      }

      var nodeIndex = this._boxes.length - 4;
      var level = this._levelBounds.length - 1;
      var queue = [];
      var results = [];

      while (nodeIndex !== undefined) {
          // find the end index of the node
          var end = Math.min(nodeIndex + this$1.nodeSize * 4, this$1._levelBounds[level]);

          // search through child nodes
          for (var pos = nodeIndex; pos < end; pos += 4) {
              var index = this$1._indices[pos >> 2];

              // check if node bbox intersects with query bbox
              if (maxX < this$1._boxes[pos]) { continue; } // maxX < nodeMinX
              if (maxY < this$1._boxes[pos + 1]) { continue; } // maxY < nodeMinY
              if (minX > this$1._boxes[pos + 2]) { continue; } // minX > nodeMaxX
              if (minY > this$1._boxes[pos + 3]) { continue; } // minY > nodeMaxY

              if (nodeIndex < this$1.numItems * 4) {
                  if (filterFn === undefined || filterFn(index)) {
                      results.push(index); // leaf item
                  }

              } else {
                  queue.push(index); // node; add it to the search queue
                  queue.push(level - 1);
              }
          }

          level = queue.pop();
          nodeIndex = queue.pop();
      }

      return results;
  };

  // custom quicksort that sorts bbox data alongside the hilbert values
  function sort$1(values, boxes, indices, left, right) {
      if (left >= right) { return; }

      var pivot = values[(left + right) >> 1];
      var i = left - 1;
      var j = right + 1;

      while (true) {
          do { i++; } while (values[i] < pivot);
          do { j--; } while (values[j] > pivot);
          if (i >= j) { break; }
          swap(values, boxes, indices, i, j);
      }

      sort$1(values, boxes, indices, left, j);
      sort$1(values, boxes, indices, j + 1, right);
  }

  // swap two values and two corresponding boxes
  function swap(values, boxes, indices, i, j) {
      var temp = values[i];
      values[i] = values[j];
      values[j] = temp;

      var k = 4 * i;
      var m = 4 * j;

      var a = boxes[k];
      var b = boxes[k + 1];
      var c = boxes[k + 2];
      var d = boxes[k + 3];
      boxes[k] = boxes[m];
      boxes[k + 1] = boxes[m + 1];
      boxes[k + 2] = boxes[m + 2];
      boxes[k + 3] = boxes[m + 3];
      boxes[m] = a;
      boxes[m + 1] = b;
      boxes[m + 2] = c;
      boxes[m + 3] = d;

      var e = indices[i];
      indices[i] = indices[j];
      indices[j] = e;
  }

  // Fast Hilbert curve algorithm by http://threadlocalmutex.com/
  // Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)
  function hilbert(x, y) {
      var a = x ^ y;
      var b = 0xFFFF ^ a;
      var c = 0xFFFF ^ (x | y);
      var d = x & (y ^ 0xFFFF);

      var A = a | (b >> 1);
      var B = (a >> 1) ^ a;
      var C = ((c >> 1) ^ (b & (d >> 1))) ^ c;
      var D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;

      a = A; b = B; c = C; d = D;
      A = ((a & (a >> 2)) ^ (b & (b >> 2)));
      B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));
      C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));
      D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));

      a = A; b = B; c = C; d = D;
      A = ((a & (a >> 4)) ^ (b & (b >> 4)));
      B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));
      C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));
      D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));

      a = A; b = B; c = C; d = D;
      C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));
      D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));

      a = C ^ (C >> 1);
      b = D ^ (D >> 1);

      var i0 = x ^ y;
      var i1 = b | (0xFFFF ^ (i0 | a));

      i0 = (i0 | (i0 << 8)) & 0x00FF00FF;
      i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;
      i0 = (i0 | (i0 << 2)) & 0x33333333;
      i0 = (i0 | (i0 << 1)) & 0x55555555;

      i1 = (i1 | (i1 << 8)) & 0x00FF00FF;
      i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;
      i1 = (i1 | (i1 << 2)) & 0x33333333;
      i1 = (i1 | (i1 << 1)) & 0x55555555;

      return ((i1 << 1) | i0) >>> 0;
  }

  /**
   * This implementation is inspired by discussion here 
   * https://twitter.com/mourner/status/1049325199617921024 and 
   * here https://github.com/anvaka/isect/issues/1
   * 
   * It builds an index of all segments using static spatial index
   * and then for each segment it queries overlapping rectangles.
   */
  function bush(lines, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || 
                              defaultIntersectionReporter;
    var asyncState;

    var index = new Flatbush(lines.length);
    lines.forEach(addToIndex);
    index.finish();

    return {
      run: run,
      step: step,
      results: results,

      // undocumented, don't use unless you know what you are doing:
      checkIntersection: checkIntersection
    }

    function run() {
      for (var i = 0; i < lines.length; ++i) {
        if (checkIntersection(lines[i], i)) {
          return; // stop early
        }
      }
      return results;
    }

    function checkIntersection(currentSegment, currentId) {
      // sorry about code duplication.
      var minX = currentSegment.from.x; var maxX = currentSegment.to.x;
      var minY = currentSegment.from.y; var maxY = currentSegment.to.y;
      var t;
      if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
      if (minY > maxY) { t = minY; minY = maxY; maxY = t; }

      var ids = index.search(minX, minY, maxX, maxY);

      for (var i = 0; i < ids.length; ++i) {
        var segmentIndex = ids[i];
        if (segmentIndex <= currentId) { continue; } // we have either reported it, or it is current.

        var otherSegment = lines[segmentIndex];
        var point = intersectSegments$1(otherSegment, currentSegment);

        if (point) {
          if (reportIntersection(point, [currentSegment, otherSegment])) {
            // stop early
            return true;
          }
        }
      }
    }

    function step() {
      if (!asyncState) {
        asyncState = {i: 0};
      }
      var test = lines[asyncState.i];
      checkIntersection(test, asyncState.i);
      asyncState.i += 1;
      return asyncState.i < lines.length;
    }


    function addToIndex(line) {
      var minX = line.from.x; var maxX = line.to.x;
      var minY = line.from.y; var maxY = line.to.y;
      var t;
      if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
      if (minY > maxY) { t = minY; minY = maxY; maxY = t; }
      index.add(minX, minY, maxX, maxY);
    }

    function defaultIntersectionReporter(p, interior) {
      results.push({
        point: p, 
        segments: interior
      });
    }
  }

  exports.sweep = isect;
  exports.brute = brute;
  exports.bush = bush;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],6:[function(require,module,exports){
/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
 * @license
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).jsts={})}(this,(function(t){"use strict";class e{constructor(){e.constructor_.apply(this,arguments)}static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}getClass(){return e}get interfaces_(){return[]}}function n(t){this.message=t}function s(t,e){this.low=0|e,this.high=0|t}function i(){}function r(){}function o(){}function l(){}function a(){}function c(t){this.name="RuntimeException",this.message=t,this.stack=(new Error).stack,Error.call(this,t)}e.constructor_=function(){},s.toBinaryString=function(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n},i.isNaN=t=>Number.isNaN(t),i.isInfinite=t=>!Number.isFinite(t),i.MAX_VALUE=Number.MAX_VALUE,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=new Float64Array(1),e=new Int32Array(t.buffer);i.doubleToLongBits=function(n){t[0]=n;let i=0|e[0],r=0|e[1];return 2146435072==(2146435072&r)&&0!=(1048575&r)&&0!==i&&(i=0,r=2146959360),new s(r,i)},i.longBitsToDouble=function(n){return e[0]=n.low,e[1]=n.high,t[0]}}():function(){const t=Math.log2,e=Math.floor,n=Math.pow,r=function(){for(let s=53;s>0;s--){const i=n(2,s)-1;if(e(t(i))+1===s)return i}return 0}();i.doubleToLongBits=function(i){let o,l,a,c,h,u,g,d,_;if(i<0||1/i===Number.NEGATIVE_INFINITY?(u=1<<31,i=-i):u=0,0===i)return _=0,d=u,new s(d,_);if(i===1/0)return _=0,d=2146435072|u,new s(d,_);if(i!=i)return _=0,d=2146959360,new s(d,_);if(c=0,_=0,o=e(i),o>1)if(o<=r)c=e(t(o)),c<=20?(_=0,d=o<<20-c&1048575):(a=c-20,l=n(2,a),_=o%l<<32-a,d=o/l&1048575);else for(a=o,_=0;l=a/2,a=e(l),0!==a;)c++,_>>>=1,_|=(1&d)<<31,d>>>=1,l!==a&&(d|=524288);if(g=c+1023,h=0===o,o=i-o,c<52&&0!==o)for(a=0;;){if(l=2*o,l>=1?(o=l-1,h?(g--,h=!1):(a<<=1,a|=1,c++)):(o=l,h?0==--g&&(c++,h=!1):(a<<=1,c++)),20===c)d|=a,a=0;else if(52===c){_|=a;break}if(1===l){c<20?d|=a<<20-c:c<52&&(_|=a<<52-c);break}}return d|=g<<20,d|=u,new s(d,_)},i.longBitsToDouble=function(t){let e,s,i,r,o;const l=t.high,a=t.low;for(i=l&1<<31?-1:1,r=((2146435072&l)>>20)-1023,o=0,s=1<<19,e=1;e<=20;e++)l&s&&(o+=n(2,-e)),s>>>=1;for(s=1<<31,e=21;e<=52;e++)a&s&&(o+=n(2,-e)),s>>>=1;if(-1023===r){if(0===o)return 0*i;r=-1022}else{if(1024===r)return 0===o?i/0:NaN;o+=1}return i*o*n(2,r)}}(),c.prototype=Object.create(Error.prototype),c.prototype.constructor=Error;class h extends c{constructor(){super(),h.constructor_.apply(this,arguments)}getClass(){return h}get interfaces_(){return[]}}h.constructor_=function(){if(0===arguments.length)c.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];c.constructor_.call(this,t)}};class u{constructor(){u.constructor_.apply(this,arguments)}static shouldNeverReachHere(){if(0===arguments.length)u.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new h("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];u.isTrue(t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(!t)throw null===e?new h:new h(e)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];u.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new h("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}getClass(){return u}get interfaces_(){return[]}}u.constructor_=function(){};class g{constructor(){g.constructor_.apply(this,arguments)}static hashCode(){if(1===arguments.length&&"number"==typeof arguments[0]){const t=arguments[0],e=i.doubleToLongBits(t);return Math.trunc(e^e>>>32)}}setOrdinate(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new n("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}getOrdinate(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new n("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||i.isNaN(this.z)&&i.isNaN(t.z))}equals(t){return t instanceof g&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.z,t.z,n)}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return u.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new g(this)}toString(){return"("+this.x+", "+this.y+", "+this.z+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,s=this.z-t.z;return Math.sqrt(e*e+n*n+s*s)}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.z}getClass(){return g}get interfaces_(){return[r,o,a]}}class d{constructor(){d.constructor_.apply(this,arguments)}static compare(t,e){return t<e?-1:t>e?1:i.isNaN(t)?i.isNaN(e)?0:-1:i.isNaN(e)?1:0}compare(t,e){const n=t,s=e,i=d.compare(n.x,s.x);if(0!==i)return i;const r=d.compare(n.y,s.y);return 0!==r?r:this._dimensionsToTest<=2?0:d.compare(n.z,s.z)}getClass(){return d}get interfaces_(){return[l]}}function _(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}function f(){}function p(t){this.message=t||""}function m(){}function y(t){this.message=t||""}function x(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}d.constructor_=function(){if(this._dimensionsToTest=2,0===arguments.length)d.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new n("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}},g.DimensionalComparator=d,g.constructor_=function(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];g.constructor_.call(this,t.x,t.y,t.z)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];g.constructor_.call(this,t,e,g.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}},g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=i.NaN,g.X=0,g.Y=1,g.Z=2,f.prototype.add=function(){},f.prototype.addAll=function(){},f.prototype.isEmpty=function(){},f.prototype.iterator=function(){},f.prototype.size=function(){},f.prototype.toArray=function(){},f.prototype.remove=function(){},p.prototype=new Error,p.prototype.name="IndexOutOfBoundsException",m.prototype=Object.create(f.prototype),m.prototype.constructor=m,m.prototype.get=function(){},m.prototype.set=function(){},m.prototype.isEmpty=function(){},y.prototype=new Error,y.prototype.name="NoSuchElementException",x.prototype=Object.create(m.prototype),x.prototype.constructor=x,x.prototype.ensureCapacity=function(){},x.prototype.interfaces_=[m,f],x.prototype.add=function(t){return 1===arguments.length?this.array_.push(t):this.array_.splice(arguments[0],0,arguments[1]),!0},x.prototype.clear=function(){this.array_=[]},x.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},x.prototype.set=function(t,e){const n=this.array_[t];return this.array_[t]=e,n},x.prototype.iterator=function(){return new E(this)},x.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},x.prototype.isEmpty=function(){return 0===this.array_.length},x.prototype.size=function(){return this.array_.length},x.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},x.prototype.remove=function(t){let e=!1;for(let n=0,s=this.array_.length;n<s;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e},x.prototype.removeAll=function(t){for(let e=t.iterator();e.hasNext();)this.remove(e.next());return!0};const E=function(t){this.arrayList_=t,this.position_=0};E.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new y;return this.arrayList_.get(this.position_++)},E.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},E.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},E.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))};class I extends x{constructor(){super(),I.constructor_.apply(this,arguments)}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&_(arguments[0],f)){const t=arguments[0],e=arguments[1];let n=!1;for(let s=t.iterator();s.hasNext();)this.add(s.next(),e),n=!0;return n}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){return this.toArray(I.coordArrayType)}add(){if(1===arguments.length){const t=arguments[0];super.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=1;n>s&&(i=-1);for(let r=n;r!==s;r+=i)this.add(t[r],e);return!0}}closeRing(){this.size()>0&&this.add(new g(this.get(0)),!1)}getClass(){return I}get interfaces_(){return[]}}I.constructor_=function(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}},I.coordArrayType=new Array(0).fill(null);class N{constructor(){N.constructor_.apply(this,arguments)}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<i)&&(i=Math.min(n.y,s.y),r=Math.max(n.y,s.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<i)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof N))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new N;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,s=this._maxx<t._maxx?this._maxx:t._maxx,i=this._maxy<t._maxy?this._maxy:t._maxy;return new N(e,s,n,i)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof N){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof N){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof g){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];return!this.isNull()&&(!((t.x<e.x?t.x:e.x)>this._maxx)&&(!((t.x>e.x?t.x:e.x)<this._minx)&&(!((t.y<e.y?t.y:e.y)>this._maxy)&&!((t.y>e.y?t.y:e.y)<this._miny))))}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof N){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<s?(this._miny=n,this._maxy=s):(this._miny=s,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+g.hashCode(this._minx),t=37*t+g.hashCode(this._maxx),t=37*t+g.hashCode(this._miny),t=37*t+g.hashCode(this._maxy),t}getClass(){return N}get interfaces_(){return[r,a]}}function C(){}N.constructor_=function(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.init(t,e,n,s)}},N.serialVersionUID=0x51845cd552189800;class S extends C{constructor(){super(),S.constructor_.apply(this,arguments)}getClass(){return S}get interfaces_(){return[]}}function w(t){this.str=t}function L(t){this.value=t}function T(){}S.constructor_=function(){C.constructor_.call(this,"Projective point not representable on the Cartesian plane.")},w.prototype.append=function(t){this.str+=t},w.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},w.prototype.toString=function(t){return this.str},L.prototype.intValue=function(){return this.value},L.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},L.isNaN=t=>Number.isNaN(t),T.isWhitespace=t=>t<=32&&t>=0||127===t,T.toUpperCase=t=>t.toUpperCase();class R{constructor(){R.constructor_.apply(this,arguments)}static sqr(t){return R.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return R.parse(t)}if("number"==typeof arguments[0]){const t=arguments[0];return new R(t)}}static sqrt(t){return R.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;T.isWhitespace(t.charAt(e));)e++;let s=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(s=!0))}const i=new R;let r=0,o=0,l=0;for(;!(e>=n);){const n=t.charAt(e);if(e++,T.isDigit(n)){const t=n-"0";i.selfMultiply(R.TEN),i.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=L.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r}}let a=i;const c=r-o-l;if(0===c)a=i;else if(c>0){const t=R.TEN.pow(c);a=i.divide(t)}else if(c<0){const t=R.TEN.pow(-c);a=i.multiply(t)}return s?a.negate():a}static createNaN(){return new R(i.NaN,i.NaN)}static copy(t){return new R(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let s=Math.trunc(Math.floor(n));return 10*Math.pow(10,s)<=e&&(s+=1),s}static stringOfChar(t,e){const n=new w;for(let s=0;s<e;s++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),s=R.magnitude(n._hi);const i=R.TEN.pow(s);n=n.divide(i),n.gt(R.TEN)?(n=n.divide(R.TEN),s+=1):n.lt(R.ONE)&&(n=n.multiply(R.TEN),s-=1);const r=s+1,o=new w,l=R.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const s=Math.trunc(n._hi);if(s<0)break;let i=!1,a=0;s>9?(i=!0,a="9"):a="0"+s,o.append(a),n=n.subtract(R.valueOf(s)).multiply(R.TEN),i&&n.selfAdd(R.TEN);let c=!0;const h=R.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=s,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof R){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof R){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof R){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=R.SPLIT*o,n=l-o,c=R.SPLIT*t,n=l-n,s=o-n,i=c-t,a=o*t,i=c-i,r=t-i,c=n*i-a+n*r+s*i+s*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof R){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null,l=null,a=null;return r=this._hi/t._hi,o=R.SPLIT*r,e=o-r,a=R.SPLIT*t._hi,e=o-e,n=r-e,s=a-t._hi,l=r*t._hi,s=a-s,i=t._hi-s,a=e*s-l+e*i+n*s+n*i,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o,new R(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return R.valueOf(1);let e=new R(this),n=R.valueOf(1),s=Math.abs(t);if(s>1)for(;s>0;)s%2==1&&n.selfMultiply(e),s/=2,s>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return R.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new R(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof R){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return R.valueOf(0);if(this.isNegative())return R.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=R.valueOf(e),s=this.subtract(n.sqr())._hi*(.5*t);return n.add(s)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null;return s=this._hi+t,r=s-this._hi,i=s-r,i=t-r+(this._hi-i),o=i+this._lo,e=s+o,n=o+(s-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,i=this._lo+e,a=o-this._hi,c=i-this._lo,l=o-a,r=i-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+i,n=o+a,s=a+(o-n),a=r+s;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null;o=R.SPLIT*this._hi,n=o-this._hi,l=R.SPLIT*t,n=o-n,s=this._hi-n,i=l-t,o=this._hi*t,i=l-i,r=t-i,l=n*i-o+n*r+s*i+s*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return R.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new R(t,e)}negate(){return this.isNaN()?this:new R(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof R){const t=arguments[0];return t.isNaN()?R.createNaN():R.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfMultiply(t,0)}}isNaN(){return i.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=R.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),s=e[0]+1;let i=n;if("."===n.charAt(0))i="0"+n;else if(s<0)i="0."+R.stringOfChar("0",-s)+n;else if(-1===n.indexOf(".")){const t=s-n.length;i=n+R.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+i:i}reciprocal(){let t=null,e=null,n=null,s=null,i=null,r=null,o=null,l=null;i=1/this._hi,r=R.SPLIT*i,t=r-i,l=R.SPLIT*this._hi,t=r-t,e=i-t,n=l-this._hi,o=i*this._hi,n=l-n,s=this._hi-n,l=t*n-o+t*s+e*n+e*s,r=(1-o-l-i*this._lo)/this._hi;const a=i+r;return new R(a,i-a+r)}toSciNotation(){if(this.isZero())return R.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),s=R.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);let i="";n.length>1&&(i=n.substring(1));const r=n.charAt(0)+"."+i;return this.isNegative()?"-"+r+s:r+s}abs(){return this.isNaN()?R.NaN:this.isNegative()?this.negate():new R(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof R){const t=arguments[0];return R.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return R.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof R){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?R.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}getClass(){return R}get interfaces_(){return[a,r,o]}}R.constructor_=function(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof R){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];R.constructor_.call(this,R.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}},R.PI=new R(3.141592653589793,12246467991473532e-32),R.TWO_PI=new R(6.283185307179586,24492935982947064e-32),R.PI_2=new R(1.5707963267948966,6123233995736766e-32),R.E=new R(2.718281828459045,14456468917292502e-32),R.NaN=new R(i.NaN,i.NaN),R.EPS=123259516440783e-46,R.SPLIT=134217729,R.MAX_PRINT_DIGITS=32,R.TEN=R.valueOf(10),R.ONE=R.valueOf(1),R.SCI_NOT_EXPONENT_CHAR="E",R.SCI_NOT_ZERO="0.0E0";class P{constructor(){P.constructor_.apply(this,arguments)}static orientationIndex(t,e,n){const s=P.orientationIndexFilter(t,e,n);if(s<=1)return s;const i=R.valueOf(e.x).selfAdd(-t.x),r=R.valueOf(e.y).selfAdd(-t.y),o=R.valueOf(n.x).selfAdd(-e.x),l=R.valueOf(n.y).selfAdd(-e.y);return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof R&&arguments[2]instanceof R&&arguments[0]instanceof R&&arguments[1]instanceof R){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return t.multiply(s).selfSubtract(e.multiply(n)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=R.valueOf(t),r=R.valueOf(e),o=R.valueOf(n),l=R.valueOf(s);return i.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,s){const i=R.valueOf(s.y).selfSubtract(n.y).selfMultiply(R.valueOf(e.x).selfSubtract(t.x)),r=R.valueOf(s.x).selfSubtract(n.x).selfMultiply(R.valueOf(e.y).selfSubtract(t.y)),o=i.subtract(r),l=R.valueOf(s.x).selfSubtract(n.x).selfMultiply(R.valueOf(t.y).selfSubtract(n.y)),a=R.valueOf(s.y).selfSubtract(n.y).selfMultiply(R.valueOf(t.x).selfSubtract(n.x)),c=l.subtract(a).selfDivide(o).doubleValue(),h=R.valueOf(t.x).selfAdd(R.valueOf(e.x).selfSubtract(t.x).selfMultiply(c)).doubleValue(),u=R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(t.y).selfSubtract(n.y)),d=R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(t.x).selfSubtract(n.x)),_=u.subtract(d).selfDivide(o).doubleValue(),f=R.valueOf(n.y).selfAdd(R.valueOf(s.y).selfSubtract(n.y).selfMultiply(_)).doubleValue();return new g(h,f)}static orientationIndexFilter(t,e,n){let s=null;const i=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=i-r;if(i>0){if(r<=0)return P.signum(o);s=i+r}else{if(!(i<0))return P.signum(o);if(r>=0)return P.signum(o);s=-i-r}const l=P.DP_SAFE_EPSILON*s;return o>=l||-o>=l?P.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}getClass(){return P}get interfaces_(){return[]}}P.constructor_=function(){},P.DP_SAFE_EPSILON=1e-15;class v{constructor(){v.constructor_.apply(this,arguments)}static index(t,e,n){return P.orientationIndex(t,e,n)}static isCCW(t){const e=t.length-1;if(e<3)throw new n("Ring has fewer than 4 points, so orientation cannot be determined");let s=t[0],i=0;for(let n=1;n<=e;n++){const e=t[n];e.y>s.y&&(s=e,i=n)}let r=i;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(s)&&r!==i);let o=i;do{o=(o+1)%e}while(t[o].equals2D(s)&&o!==i);const l=t[r],a=t[o];if(l.equals2D(s)||a.equals2D(s)||l.equals2D(a))return!1;const c=v.index(l,s,a);let h=null;return h=0===c?l.x>a.x:c>0,h}getClass(){return v}get interfaces_(){return[]}}function O(){}v.constructor_=function(){},v.CLOCKWISE=-1,v.RIGHT=v.CLOCKWISE,v.COUNTERCLOCKWISE=1,v.LEFT=v.COUNTERCLOCKWISE,v.COLLINEAR=0,v.STRAIGHT=v.COLLINEAR,O.arraycopy=(t,e,n,s,i)=>{let r=0;for(let o=e;o<e+i;o++)n[s+r]=t[o],r++},O.getProperty=t=>({"line.separator":"\n"}[t]);class b{constructor(){b.constructor_.apply(this,arguments)}static intersection(t,e,n,s){const r=t.y-e.y,o=e.x-t.x,l=t.x*e.y-e.x*t.y,a=n.y-s.y,c=s.x-n.x,h=n.x*s.y-s.x*n.y,u=r*c-a*o,d=(o*h-c*l)/u,_=(a*l-r*h)/u;if(i.isNaN(d)||i.isInfinite(d)||i.isNaN(_)||i.isInfinite(_))throw new S;return new g(d,_)}getY(){const t=this.y/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getX(){const t=this.x/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getCoordinate(){const t=new g;return t.x=this.getX(),t.y=this.getY(),t}getClass(){return b}get interfaces_(){return[]}}b.constructor_=function(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){const t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this.x=t,this.y=e,this.w=1}else if(arguments[0]instanceof b&&arguments[1]instanceof b){const t=arguments[0],e=arguments[1];this.x=t.y*e.w-e.y*t.w,this.y=e.x*t.w-t.x*e.w,this.w=t.x*e.y-e.x*t.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];this.x=t.y-e.y,this.y=e.x-t.x,this.w=t.x*e.y-e.x*t.y}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.w=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.y-e.y,r=e.x-t.x,o=t.x*e.y-e.x*t.y,l=n.y-s.y,a=s.x-n.x,c=n.x*s.y-s.x*n.y;this.x=r*c-a*o,this.y=l*o-i*c,this.w=i*a-l*r}};class M{constructor(){M.constructor_.apply(this,arguments)}static log10(t){const e=Math.log(t);return i.isInfinite(e)||i.isNaN(e)?e:e/M.LOG_10}static min(t,e,n,s){let i=t;return e<i&&(i=e),n<i&&(i=n),s<i&&(i=s),i}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=t;return e>s&&(s=e),n>s&&(s=n),s}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=t;return e>i&&(i=e),n>i&&(i=n),s>i&&(i=s),i}}static average(t,e){return(t+e)/2}getClass(){return M}get interfaces_(){return[]}}M.constructor_=function(){},M.LOG_10=Math.log(10);class D{constructor(){D.constructor_.apply(this,arguments)}static segmentToSegment(t,e,n,s){if(t.equals(e))return D.pointToSegment(t,n,s);if(n.equals(s))return D.pointToSegment(s,t,e);let i=!1;if(N.intersects(t,e,n,s)){const r=(e.x-t.x)*(s.y-n.y)-(e.y-t.y)*(s.x-n.x);if(0===r)i=!0;else{const o=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(i=!0)}}else i=!0;return i?M.min(D.pointToSegment(t,n,s),D.pointToSegment(e,n,s),D.pointToSegment(n,t,e),D.pointToSegment(s,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/s;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(r)*Math.sqrt(s)}static pointToLinePerpendicular(t,e,n){const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(i)*Math.sqrt(s)}static pointToSegmentString(t,e){if(0===e.length)throw new n("Line array must contain at least one vertex");let s=t.distance(e[0]);for(let n=0;n<e.length-1;n++){const i=D.pointToSegment(t,e[n],e[n+1]);i<s&&(s=i)}return s}getClass(){return D}get interfaces_(){return[]}}D.constructor_=function(){};class A{constructor(){A.constructor_.apply(this,arguments)}setOrdinate(t,e,n){}size(){}getOrdinate(t,e){}getCoordinate(){}getCoordinateCopy(t){}getDimension(){}getX(t){}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}getClass(){return A}get interfaces_(){return[o]}}A.constructor_=function(){},A.X=0,A.Y=1,A.Z=2,A.M=3;class F{constructor(){F.constructor_.apply(this,arguments)}create(){1===arguments.length&&(arguments[0]instanceof Array||_(arguments[0],A))}getClass(){return F}get interfaces_(){return[]}}F.constructor_=function(){};class G{constructor(){G.constructor_.apply(this,arguments)}filter(t){}getClass(){return G}get interfaces_(){return[]}}G.constructor_=function(){};class q{constructor(){q.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equals(){if(arguments[0]instanceof q){const t=arguments[0];return null!==t&&this.equalsTopo(t)}if(arguments[0]instanceof Object){const t=arguments[0];if(!(t instanceof q))return!1;const e=t;return this.equalsExact(e)}}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(q.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}checkNotGeometryCollection(t){if(t.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION)throw new n("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new N(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),s=e.iterator();for(;n.hasNext()&&s.hasNext();){const t=n.next(),e=s.next(),i=t.compareTo(e);if(0!==i)return i}return n.hasNext()?1:s.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isGeometryCollectionOrDerived(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION||this.getTypeCode()===q.TYPECODE_MULTIPOINT||this.getTypeCode()===q.TYPECODE_MULTILINESTRING||this.getTypeCode()===q.TYPECODE_MULTIPOLYGON}get interfaces_(){return[o,r,a]}getClass(){return q}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}q.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},q.serialVersionUID=0x799ea46522854c00,q.TYPECODE_POINT=0,q.TYPECODE_MULTIPOINT=1,q.TYPECODE_LINESTRING=2,q.TYPECODE_LINEARRING=3,q.TYPECODE_MULTILINESTRING=4,q.TYPECODE_POLYGON=5,q.TYPECODE_MULTIPOLYGON=6,q.TYPECODE_GEOMETRYCOLLECTION=7,q.TYPENAME_POINT="Point",q.TYPENAME_MULTIPOINT="MultiPoint",q.TYPENAME_LINESTRING="LineString",q.TYPENAME_LINEARRING="LinearRing",q.TYPENAME_MULTILINESTRING="MultiLineString",q.TYPENAME_POLYGON="Polygon",q.TYPENAME_MULTIPOLYGON="MultiPolygon",q.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",q.geometryChangedFilter={get interfaces_(){return[G]},filter(t){t.geometryChangedAction()}};class B{constructor(){B.constructor_.apply(this,arguments)}filter(t){}getClass(){return B}get interfaces_(){return[]}}B.constructor_=function(){};class V{constructor(){V.constructor_.apply(this,arguments)}isInBoundary(t){}getClass(){return V}get interfaces_(){return[]}}class z{constructor(){z.constructor_.apply(this,arguments)}isInBoundary(t){return t%2==1}getClass(){return z}get interfaces_(){return[V]}}z.constructor_=function(){};class Y{constructor(){Y.constructor_.apply(this,arguments)}isInBoundary(t){return t>0}getClass(){return Y}get interfaces_(){return[V]}}Y.constructor_=function(){};class U{constructor(){U.constructor_.apply(this,arguments)}isInBoundary(t){return t>1}getClass(){return U}get interfaces_(){return[V]}}U.constructor_=function(){};class k{constructor(){k.constructor_.apply(this,arguments)}isInBoundary(t){return 1===t}getClass(){return k}get interfaces_(){return[V]}}k.constructor_=function(){},V.Mod2BoundaryNodeRule=z,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=k,V.constructor_=function(){},V.MOD2_BOUNDARY_RULE=new z,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new k,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE;class X{constructor(){X.constructor_.apply(this,arguments)}static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(X.indexOf(s,e)<0)return s}return null}static scroll(t,e){const n=X.indexOf(e,t);if(n<0)return null;const s=new Array(t.length).fill(null);O.arraycopy(t,n,s,0,t.length-n),O.arraycopy(t,0,s,t.length-n,n),O.arraycopy(s,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(0!==n.compare(t[s],e[s]))return!1;return!0}}static intersection(t,e){const n=new I;for(let s=0;s<t.length;s++)e.intersects(t[s])&&n.add(t[s],!0);return n.toCoordinateArray()}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!X.hasRepeatedPoints(t))return t;return new I(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++){const n=t[s];t[s]=t[e-s],t[e-s]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let s=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[s++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4];for(let r=0;r<i;r++)n[s+r]=new g(t[e+r])}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const s=t[n],i=e[t.length-n-1];if(0!==s.compareTo(i))return!1}return!0}static envelope(t){const e=new N;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(X.coordArrayType)}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,s=t[e].compareTo(t[n]);if(0!==s)return s}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=t[n].compareTo(e[n]);if(0!==s)return s;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=M.clamp(e,0,t.length);let s=(n=M.clamp(n,-1,t.length))-e+1;n<0&&(s=0),e>=t.length&&(s=0),n<e&&(s=0);const i=new Array(s).fill(null);if(0===s)return i;let r=0;for(let s=e;s<=n;s++)i[r++]=t[s];return i}getClass(){return X}get interfaces_(){return[]}}class H{constructor(){H.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e;return X.compare(n,s)}getClass(){return H}get interfaces_(){return[l]}}H.constructor_=function(){};class W{constructor(){W.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=X.compare(n,s);return X.isEqualReversed(n,s)?0:i}OLDcompare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=X.increasingDirection(n),r=X.increasingDirection(s);let o=i>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(s[l]);if(0!==t)return t;o+=i,l+=r}return 0}getClass(){return W}get interfaces_(){return[l]}}function j(){}function K(){}function Z(t){this.message=t||""}function Q(){}function J(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}W.constructor_=function(){},X.ForwardComparator=H,X.BidirectionalComparator=W,X.constructor_=function(){},X.coordArrayType=new Array(0).fill(null),j.prototype.get=function(){},j.prototype.put=function(){},j.prototype.size=function(){},j.prototype.values=function(){},j.prototype.entrySet=function(){},K.prototype=new j,Z.prototype=new Error,Z.prototype.name="OperationNotSupported",Q.prototype=new f,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(let e=0,n=this.array_.length;e<n;e++){if(this.array_[e]===t)return!0}return!1},J.prototype.add=function(t){return!this.contains(t)&&(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new Z},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new $(this)};const $=function(t){this.hashSet_=t,this.position_=0};$.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new y;return this.hashSet_.array_[this.position_++]},$.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},$.prototype.remove=function(){throw new Z};function tt(t){return null==t?0:t.color}function et(t){return null==t?null:t.parent}function nt(t,e){null!==t&&(t.color=e)}function st(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}rt.prototype=new K,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;var n,s,i=this.root_;do{if(n=i,(s=t.compareTo(i.key))<0)i=i.left;else{if(!(s>0)){var r=i.value;return i.value=e,r}i=i.right}}while(null!==i);var o={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return s<0?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)et(t)===st(et(et(t)))?(e=it(et(et(t))),1===tt(e)?(nt(et(t),0),nt(e,0),nt(et(et(t)),1),t=et(et(t))):(t===it(et(t))&&(t=et(t),this.rotateLeft(t)),nt(et(t),0),nt(et(et(t)),1),this.rotateRight(et(et(t))))):(e=st(et(et(t))),1===tt(e)?(nt(et(t),0),nt(e,0),nt(et(et(t)),1),t=et(et(t))):(t===st(et(t))&&(t=et(t),this.rotateRight(t)),nt(et(t),0),nt(et(et(t)),1),this.rotateLeft(et(et(t)))));this.root_.color=0},rt.prototype.values=function(){var t=new x,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}e=t.parent;for(var n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},rt.prototype.containsKey=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1};class ot{constructor(){ot.constructor_.apply(this,arguments)}getClass(){return ot}get interfaces_(){return[]}}function lt(){}function at(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}ot.constructor_=function(){},lt.prototype=new Q,at.prototype=new lt,at.prototype.contains=function(t){for(let e=0,n=this.array_.length;e<n;e++){if(0===this.array_[e].compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(let e=0,n=this.array_.length;e<n;e++){if(1===this.array_[e].compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new Z},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new ct(this)};const ct=function(t){this.treeSet_=t,this.position_=0};function ht(){}ct.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new y;return this.treeSet_.array_[this.position_++]},ct.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},ct.prototype.remove=function(){throw new Z},ht.sort=function(){const t=arguments[0];let e,n,s,i;if(1===arguments.length)i=function(t,e){return t.compareTo(e)},t.sort(i);else if(2===arguments.length)s=arguments[1],i=function(t,e){return s.compare(t,e)},t.sort(i);else if(3===arguments.length){n=t.slice(arguments[1],arguments[2]),n.sort();const s=t.slice(0,arguments[1]).concat(n,t.slice(arguments[2],t.length));for(t.splice(0,t.length),e=0;e<s.length;e++)t.push(s[e])}else if(4===arguments.length){n=t.slice(arguments[1],arguments[2]),s=arguments[3],i=function(t,e){return s.compare(t,e)},n.sort(i);const r=t.slice(0,arguments[1]).concat(n,t.slice(arguments[2],t.length));for(t.splice(0,t.length),e=0;e<r.length;e++)t.push(r[e])}},ht.asList=function(t){const e=new x;for(let n=0,s=t.length;n<s;n++)e.add(t[n]);return e};class ut{constructor(){ut.constructor_.apply(this,arguments)}static toDimensionSymbol(t){switch(t){case ut.FALSE:return ut.SYM_FALSE;case ut.TRUE:return ut.SYM_TRUE;case ut.DONTCARE:return ut.SYM_DONTCARE;case ut.P:return ut.SYM_P;case ut.L:return ut.SYM_L;case ut.A:return ut.SYM_A}throw new n("Unknown dimension value: "+t)}static toDimensionValue(t){switch(T.toUpperCase(t)){case ut.SYM_FALSE:return ut.FALSE;case ut.SYM_TRUE:return ut.TRUE;case ut.SYM_DONTCARE:return ut.DONTCARE;case ut.SYM_P:return ut.P;case ut.SYM_L:return ut.L;case ut.SYM_A:return ut.A}throw new n("Unknown dimension symbol: "+t)}getClass(){return ut}get interfaces_(){return[]}}ut.constructor_=function(){},ut.P=0,ut.L=1,ut.A=2,ut.FALSE=-1,ut.TRUE=-2,ut.DONTCARE=-3,ut.SYM_FALSE="F",ut.SYM_TRUE="T",ut.SYM_DONTCARE="*",ut.SYM_P="0",ut.SYM_L="1",ut.SYM_A="2";class gt{constructor(){gt.constructor_.apply(this,arguments)}filter(t){}getClass(){return gt}get interfaces_(){return[]}}gt.constructor_=function(){};class dt{constructor(){dt.constructor_.apply(this,arguments)}filter(t,e){}isDone(){}isGeometryChanged(){}getClass(){return dt}get interfaces_(){return[]}}dt.constructor_=function(){};class _t extends q{constructor(){super(),_t.constructor_.apply(this,arguments)}computeEnvelopeInternal(){const t=new N;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const s=this._geometries[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();ht.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=ut.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}getTypeCode(){return q.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=ut.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)e[t]=this._geometries[t].reverse();return this.getFactory().createGeometryCollection(e)}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new at(ht.asList(this._geometries)),n=new at(ht.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t,s=this.getNumGeometries(),i=n.getNumGeometries();let r=0;for(;r<s&&r<i;){const t=this.getGeometryN(r),s=n.getGeometryN(r),i=t.compareToSameClass(s,e);if(0!==i)return i;r++}return r<s?1:r<i?-1:0}}apply(){if(_(arguments[0],B)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(_(arguments[0],dt)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(_(arguments[0],G)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return this.checkNotGeometryCollection(this),u.shouldNeverReachHere(),null}getGeometryType(){return q.TYPENAME_GEOMETRYCOLLECTION}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new _t(t,this._factory)}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}getClass(){return _t}get interfaces_(){return[]}}_t.constructor_=function(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0];const e=arguments[1];if(q.constructor_.call(this,e),null===t&&(t=[]),q.hasNullElements(t))throw new n("geometries must not contain null elements");this._geometries=t}},_t.serialVersionUID=-0x4f07bcb1f857d800;class ft extends _t{constructor(){super(),ft.constructor_.apply(this,arguments)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?ut.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return q.TYPECODE_MULTILINESTRING}getDimension(){return 1}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let n=0;n<this._geometries.length;n++)e[t-1-n]=this._geometries[n].reverse();return this.getFactory().createMultiLineString(e)}getBoundary(){return new pt(this).getBoundary()}getGeometryType(){return q.TYPENAME_MULTILINESTRING}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ft(t,this._factory)}getClass(){return ft}get interfaces_(){return[ot]}}ft.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},ft.serialVersionUID=0x7155d2ab4afa8000;class pt{constructor(){pt.constructor_.apply(this,arguments)}static getBoundary(){if(1===arguments.length){const t=arguments[0];return new pt(t).getBoundary()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new pt(t,e).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();const e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)}getBoundary(){return this._geom instanceof Tt?this.boundaryLineString(this._geom):this._geom instanceof ft?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){const e=new x;this._endpointMap=new rt;for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);0!==n.getNumPoints()&&(this.addEndpoint(n.getCoordinateN(0)),this.addEndpoint(n.getCoordinateN(n.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){const n=t.next(),s=n.getValue().count;this._bnRule.isInBoundary(s)&&e.add(n.getKey())}return X.toCoordinateArray(e)}addEndpoint(t){let e=this._endpointMap.get(t);null===e&&(e=new mt,this._endpointMap.put(t,e)),e.count++}getClass(){return pt}get interfaces_(){return[]}}pt.constructor_=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){const t=arguments[0];pt.constructor_.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}};class mt{constructor(){mt.constructor_.apply(this,arguments)}getClass(){return mt}get interfaces_(){return[]}}mt.constructor_=function(){this.count=null};class yt{constructor(){yt.constructor_.apply(this,arguments)}static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const s=new g;t.getCoordinate(0,s);let i=s.x,r=s.y;for(let o=1;o<e;o++){t.getCoordinate(o,s);const e=s.x,l=s.y,a=e-i,c=l-r;n+=Math.sqrt(a*a+c*c),i=e,r=l}return n}getClass(){return yt}get interfaces_(){return[]}}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}yt.constructor_=function(){};class St{constructor(){St.constructor_.apply(this,arguments)}static chars(t,e){const n=new Array(e).fill(null);for(let s=0;s<e;s++)n[s]=t;return new String(n)}static getStackTrace(){if(1===arguments.length){const t=arguments[0],e=new It,n=new xt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n="";const s=new Ct(new Et(St.getStackTrace(t)));for(let t=0;t<e;t++)try{n+=s.readLine()+St.NEWLINE}catch(t){if(!(t instanceof Nt))throw t;u.shouldNeverReachHere()}return n}}static split(t,e){const n=e.length,s=new x;let i=""+t,r=i.indexOf(e);for(;r>=0;){const t=i.substring(0,r);s.add(t),i=i.substring(r+n),r=i.indexOf(e)}i.length>0&&s.add(i);const o=new Array(s.size()).fill(null);for(let t=0;t<o.length;t++)o[t]=s.get(t);return o}static toString(){if(1===arguments.length&&"number"==typeof arguments[0]){const t=arguments[0];return St.SIMPLE_ORDINATE_FORMAT.format(t)}}static spaces(t){return St.chars(" ",t)}getClass(){return St}get interfaces_(){return[]}}function wt(t){this.str=t}St.constructor_=function(){},St.NEWLINE=O.getProperty("line.separator"),St.SIMPLE_ORDINATE_FORMAT=new function(){}("0.#"),wt.prototype.append=function(t){this.str+=t},wt.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},wt.prototype.toString=function(t){return this.str};class Lt{constructor(){Lt.constructor_.apply(this,arguments)}static copyCoord(t,e,n,s){const i=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<i;r++)n.setOrdinate(s,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,A.X)===t.getOrdinate(e-1,A.X)&&t.getOrdinate(0,A.Y)===t.getOrdinate(e-1,A.Y))}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const s=Math.min(t.getDimension(),e.getDimension());for(let r=0;r<n;r++)for(let n=0;n<s;n++){const s=t.getOrdinate(r,n),o=e.getOrdinate(r,n);if(t.getOrdinate(r,n)!==e.getOrdinate(r,n)&&(!i.isNaN(s)||!i.isNaN(o)))return!1}return!0}static extend(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();if(Lt.copy(e,0,s,0,i),i>0)for(let t=i;t<n;t++)Lt.copy(e,i-1,s,t,1);return s}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++)Lt.swap(t,s,e-s)}static swap(t,e,n){if(e===n)return null;for(let s=0;s<t.getDimension();s++){const i=t.getOrdinate(e,s);t.setOrdinate(e,s,t.getOrdinate(n,s)),t.setOrdinate(n,s,i)}}static copy(t,e,n,s,i){for(let r=0;r<i;r++)Lt.copyCoord(t,e+r,n,s+r)}static toString(){if(1===arguments.length&&_(arguments[0],A)){const t=arguments[0],e=t.size();if(0===e)return"()";const n=t.getDimension(),s=new wt;s.append("(");for(let i=0;i<e;i++){i>0&&s.append(" ");for(let e=0;e<n;e++)e>0&&s.append(","),s.append(St.toString(t.getOrdinate(i,e)))}return s.append(")"),s.toString()}}static ensureValidRing(t,e){const n=e.size();return 0===n?e:n<=3?Lt.createClosedRing(t,e,4):e.getOrdinate(0,A.X)===e.getOrdinate(n-1,A.X)&&e.getOrdinate(0,A.Y)===e.getOrdinate(n-1,A.Y)?e:Lt.createClosedRing(t,e,n+1)}static createClosedRing(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();Lt.copy(e,0,s,0,i);for(let t=i;t<n;t++)Lt.copy(e,0,s,t,1);return s}getClass(){return Lt}get interfaces_(){return[]}}Lt.constructor_=function(){};class Tt extends q{constructor(){super(),Tt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this.isEmpty()?new N:this._points.expandEnvelope(new N)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();Lt.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?ut.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return q.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return yt.ofLine(this._points)}getNumPoints(){return this._points.size()}reverse(){const t=this._points.copy();return Lt.reverse(t),this.getFactory().createLineString(t)}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const s=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==s)return s;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(_(arguments[0],B)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(_(arguments[0],dt)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){arguments[0].filter(this)}}getBoundary(){return new pt(this).getBoundary()}isEquivalentClass(t){return t instanceof Tt}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return q.TYPENAME_LINESTRING}copy(){return new Tt(this._points.copy(),this._factory)}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new n("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}getClass(){return Tt}get interfaces_(){return[ot]}}Tt.constructor_=function(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];q.constructor_.call(this,e),this.init(t)}},Tt.serialVersionUID=0x2b2b51ba435c8e00;class Rt{constructor(){Rt.constructor_.apply(this,arguments)}getClass(){return Rt}get interfaces_(){return[]}}Rt.constructor_=function(){};class Pt extends q{constructor(){super(),Pt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){if(this.isEmpty())return new N;const t=new N;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return ut.FALSE}getTypeCode(){return q.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}reverse(){return this.copy()}getX(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(_(arguments[0],B)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(_(arguments[0],dt)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_POINT}copy(){return new Pt(this._coordinates.copy(),this._factory)}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),u.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}getClass(){return Pt}get interfaces_(){return[Rt]}}Pt.constructor_=function(){this._coordinates=null;const t=arguments[0],e=arguments[1];q.constructor_.call(this,e),this.init(t)},Pt.serialVersionUID=0x44077bad161cbc00;class vt{constructor(){vt.constructor_.apply(this,arguments)}static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(vt.ofRingSigned(t))}if(_(arguments[0],A)){const t=arguments[0];return Math.abs(vt.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let s=1;s<t.length-1;s++){const i=t[s].x-n,r=t[s+1].y;e+=i*(t[s-1].y-r)}return e/2}if(_(arguments[0],A)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new g,s=new g,i=new g;t.getCoordinate(0,s),t.getCoordinate(1,i);const r=s.x;i.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=s.y,s.x=i.x,s.y=i.y,t.getCoordinate(l+1,i),i.x-=r,o+=s.x*(n.y-i.y);return o/2}}getClass(){return vt}get interfaces_(){return[]}}vt.constructor_=function(){};class Ot{constructor(){Ot.constructor_.apply(this,arguments)}getClass(){return Ot}get interfaces_(){return[]}}Ot.constructor_=function(){};class bt extends q{constructor(){super(),bt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let s=0;s<n.length;s++)e++,t[e]=n[s];for(let n=0;n<this._holes.length;n++){const s=this._holes[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;t+=vt.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=vt.ofRing(this._holes[e].getCoordinateSequence());return t}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const s=t.getX(n);if(s!==e.getMinX()&&s!==e.getMaxX())return!1;const i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}let n=t.getX(0),s=t.getY(0);for(let e=1;e<=4;e++){const i=t.getX(e),r=t.getY(e);if(i!==n===(r!==s))return!1;n=i,s=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,s=this._shell,i=n._shell;if(!s.equalsExact(i,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this.normalize(this._shell,!0);for(let t=0;t<this._holes.length;t++)this.normalize(this._holes[t],!1);ht.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=new Array(t.getCoordinates().length-1).fill(null);O.arraycopy(t.getCoordinates(),0,n,0,n.length);const s=X.minCoordinate(t.getCoordinates());X.scroll(n,s),O.arraycopy(n,0,t.getCoordinates(),0,n.length),t.getCoordinates()[n.length]=n[0],v.isCCW(t.getCoordinates())===e&&X.reverse(t.getCoordinates())}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}reverse(){const t=this.copy();t._shell=this._shell.copy().reverse(),t._holes=new Array(this._holes.length).fill(null);for(let e=0;e<this._holes.length;e++)t._holes[e]=this._holes[e].copy().reverse();return t}convexHull(){return this.getExteriorRing().convexHull()}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t,s=this._shell,i=n._shell,r=s.compareToSameClass(i,e);if(0!==r)return r;const o=this.getNumInteriorRing(),l=n.getNumInteriorRing();let a=0;for(;a<o&&a<l;){const t=this.getInteriorRingN(a),s=n.getInteriorRingN(a),i=t.compareToSameClass(s,e);if(0!==i)return i;a++}return a<o?1:a<l?-1:0}}apply(){if(_(arguments[0],B)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(_(arguments[0],dt)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return q.TYPENAME_POLYGON}copy(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new bt(t,e,this._factory)}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}getClass(){return bt}get interfaces_(){return[Ot]}}bt.constructor_=function(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1];const s=arguments[2];if(q.constructor_.call(this,s),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),q.hasNullElements(e))throw new n("holes must not contain null elements");if(t.isEmpty()&&q.hasNonEmptyElements(e))throw new n("shell is empty but holes are not");this._shell=t,this._holes=e},bt.serialVersionUID=-0x307ffefd8dc97200;class Mt extends _t{constructor(){super(),Mt.constructor_.apply(this,arguments)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return ut.FALSE}getTypeCode(){return q.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_MULTIPOINT}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Mt(t,this._factory)}getClass(){return Mt}get interfaces_(){return[Rt]}}Mt.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},Mt.serialVersionUID=-0x6fb1ed4162e0fc00;class Dt extends Tt{constructor(){super(),Dt.constructor_.apply(this,arguments)}getBoundaryDimension(){return ut.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}getTypeCode(){return q.TYPECODE_LINEARRING}reverse(){const t=this._points.copy();return Lt.reverse(t),this.getFactory().createLinearRing(t)}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new n("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<Dt.MINIMUM_VALID_SIZE)throw new n("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return q.TYPENAME_LINEARRING}copy(){return new Dt(this._points.copy(),this._factory)}getClass(){return Dt}get interfaces_(){return[]}}Dt.constructor_=function(){if(arguments[0]instanceof Array&&arguments[1]instanceof Ht){const t=arguments[0],e=arguments[1];Dt.constructor_.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(_(arguments[0],A)&&arguments[1]instanceof Ht){const t=arguments[0],e=arguments[1];Tt.constructor_.call(this,t,e),this.validateConstruction()}},Dt.MINIMUM_VALID_SIZE=4,Dt.serialVersionUID=-0x3b229e262367a600;class At extends _t{constructor(){super(),At.constructor_.apply(this,arguments)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_MULTIPOLYGON}getDimension(){return 2}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)e[t]=this._geometries[t].reverse();return this.getFactory().createMultiPolygon(e)}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new x;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return q.TYPENAME_MULTIPOLYGON}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new At(t,this._factory)}getClass(){return At}get interfaces_(){return[Ot]}}At.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},At.serialVersionUID=-0x7a5aa1369171980;class Ft{constructor(){Ft.constructor_.apply(this,arguments)}setCopyUserData(t){this._isUserDataCopied=t}edit(t,e){if(null===t)return null;const n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n}editInternal(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof _t?this.editGeometryCollection(t,e):t instanceof bt?this.editPolygon(t,e):t instanceof Pt||t instanceof Tt?e.edit(t,this._factory):(u.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)}editGeometryCollection(t,e){const n=e.edit(t,this._factory),s=new x;for(let t=0;t<n.getNumGeometries();t++){const i=this.edit(n.getGeometryN(t),e);null===i||i.isEmpty()||s.add(i)}return n.getClass()===Mt?this._factory.createMultiPoint(s.toArray([])):n.getClass()===ft?this._factory.createMultiLineString(s.toArray([])):n.getClass()===At?this._factory.createMultiPolygon(s.toArray([])):this._factory.createGeometryCollection(s.toArray([]))}editPolygon(t,e){let n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon()),n.isEmpty())return n;const s=this.edit(n.getExteriorRing(),e);if(null===s||s.isEmpty())return this._factory.createPolygon();const i=new x;for(let t=0;t<n.getNumInteriorRing();t++){const s=this.edit(n.getInteriorRingN(t),e);null===s||s.isEmpty()||i.add(s)}return this._factory.createPolygon(s,i.toArray([]))}getClass(){return Ft}get interfaces_(){return[]}}function Gt(){}Ft.GeometryEditorOperation=Gt;class qt{constructor(){qt.constructor_.apply(this,arguments)}edit(t,e){return t}getClass(){return qt}get interfaces_(){return[Gt]}}qt.constructor_=function(){};class Bt{constructor(){Bt.constructor_.apply(this,arguments)}edit(t,e){const n=this.edit(t.getCoordinates(),t);return t instanceof Dt?null===n?e.createLinearRing():e.createLinearRing(n):t instanceof Tt?null===n?e.createLineString():e.createLineString(n):t instanceof Pt?null===n||0===n.length?e.createPoint():e.createPoint(n[0]):t}getClass(){return Bt}get interfaces_(){return[Gt]}}Bt.constructor_=function(){};class Vt{constructor(){Vt.constructor_.apply(this,arguments)}edit(t,e){return t instanceof Dt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof Tt?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Pt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t}getClass(){return Vt}get interfaces_(){return[Gt]}}Vt.constructor_=function(){},Ft.NoOpGeometryOperation=qt,Ft.CoordinateOperation=Bt,Ft.CoordinateSequenceOperation=Vt,Ft.constructor_=function(){if(this._factory=null,this._isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._factory=t}};class zt{constructor(){zt.constructor_.apply(this,arguments)}setOrdinate(t,e,s){switch(e){case A.X:this._coordinates[t].x=s;break;case A.Y:this._coordinates[t].y=s;break;case A.Z:this._coordinates[t].z=s;break;default:throw new n("invalid ordinateIndex")}}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case A.X:return this._coordinates[t].x;case A.Y:return this._coordinates[t].y;case A.Z:return this._coordinates[t].z}return i.NaN}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0],e=arguments[1];e.x=this._coordinates[t].x,e.y=this._coordinates[t].y,e.z=this._coordinates[t].z}}getCoordinateCopy(t){return new g(this._coordinates[t])}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)t[e]=this._coordinates[e].copy();return new zt(t,this._dimension)}toString(){if(this._coordinates.length>0){const t=new wt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}getClass(){return zt}get interfaces_(){return[A,a]}}zt.constructor_=function(){if(this._dimension=3,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];zt.constructor_.call(this,t,3)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new g}else if(_(arguments[0],A)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=t,this._dimension=e,null===t&&(this._coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let e=0;e<t;e++)this._coordinates[e]=new g}},zt.serialVersionUID=-0xcb44a778db18e00;class Yt{constructor(){Yt.constructor_.apply(this,arguments)}static instance(){return Yt.instanceObject}readResolve(){return Yt.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return new zt(t)}if(_(arguments[0],A)){const t=arguments[0];return new zt(t)}}else if(2===arguments.length){const t=arguments[0];let e=arguments[1];return e>3&&(e=3),e<2?new zt(t):new zt(t,e)}}getClass(){return Yt}get interfaces_(){return[F,a]}}function Ut(){this.map_=new Map}Yt.constructor_=function(){},Yt.serialVersionUID=-0x38e49fa6cf6f2e00,Yt.instanceObject=new Yt,Ut.prototype=new j,Ut.prototype.get=function(t){return this.map_.get(t)||null},Ut.prototype.put=function(t,e){return this.map_.set(t,e),e},Ut.prototype.values=function(){const t=new x,e=this.map_.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t},Ut.prototype.entrySet=function(){const t=new J;return this.map_.entries().forEach(e=>t.add(e)),t},Ut.prototype.size=function(){return this.map_.size()};class kt{constructor(){kt.constructor_.apply(this,arguments)}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof kt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),s=e.getMaximumSignificantDigits();return new L(n).compareTo(new L(s))}getScale(){return this._scale}isFloating(){return this._modelType===kt.FLOATING||this._modelType===kt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===kt.FLOATING?t="Floating":this._modelType===kt.FLOATING_SINGLE?t="Floating-Single":this._modelType===kt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(i.isNaN(t))return t;if(this._modelType===kt.FLOATING_SINGLE){return t}return this._modelType===kt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof g){const t=arguments[0];if(this._modelType===kt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===kt.FLOATING?t=16:this._modelType===kt.FLOATING_SINGLE?t=6:this._modelType===kt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}getClass(){return kt}get interfaces_(){return[a,r]}}class Xt{constructor(){Xt.constructor_.apply(this,arguments)}readResolve(){return Xt.nameToTypeMap.get(this._name)}toString(){return this._name}getClass(){return Xt}get interfaces_(){return[a]}}Xt.constructor_=function(){this._name=null;const t=arguments[0];this._name=t,Xt.nameToTypeMap.put(t,this)},Xt.serialVersionUID=-552860263173159e4,Xt.nameToTypeMap=new Ut,kt.Type=Xt,kt.constructor_=function(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=kt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof Xt){const t=arguments[0];this._modelType=t,t===kt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=kt.FIXED,this.setScale(t)}else if(arguments[0]instanceof kt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}},kt.serialVersionUID=0x6bee6404e9a25c00,kt.FIXED=new Xt("FIXED"),kt.FLOATING=new Xt("FLOATING"),kt.FLOATING_SINGLE=new Xt("FLOATING SINGLE"),kt.maximumPreciseValue=9007199254740992;class Ht{constructor(){Ht.constructor_.apply(this,arguments)}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return Yt.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){const t=arguments[0];return new Tt(t,this)}}}createMultiLineString(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){const t=arguments[0];return new ft(t,this)}}buildGeometry(t){let e=null,n=!1,s=!1;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=t.getClass();null===e&&(e=r),r!==e&&(n=!0),t instanceof _t&&(s=!0)}if(null===e)return this.createGeometryCollection();if(n||s)return this.createGeometryCollection(Ht.toGeometryArray(t));const i=t.iterator().next();if(t.size()>1){if(i instanceof bt)return this.createMultiPolygon(Ht.toPolygonArray(t));if(i instanceof Tt)return this.createMultiLineString(Ht.toLineStringArray(t));if(i instanceof Pt)return this.createMultiPoint(Ht.toPointArray(t));u.shouldNeverReachHere("Unhandled class: "+i.getClass().getName())}return i}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(_(arguments[0],A)){const t=arguments[0];return new Pt(t,this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(_(arguments[0],A)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Dt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return new bt(t,e,this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new _t(null,this);if(1===arguments.length){const t=arguments[0];return new _t(t,this)}}createGeometry(t){return new Ft(this).edit(t,new Wt(this._coordinateSequenceFactory))}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){const t=arguments[0];return new Dt(t,this)}}}createMultiPolygon(){if(0===arguments.length)return new At(null,this);if(1===arguments.length){const t=arguments[0];return new At(t,this)}}createMultiPoint(){if(0===arguments.length)return new Mt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return new Mt(t,this)}if(_(arguments[0],A)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=this.getCoordinateSequenceFactory().create(1,t.getDimension());Lt.copy(t,n,s,0,1),e[n]=this.createPoint(s)}return this.createMultiPoint(e)}}}getClass(){return Ht}get interfaces_(){return[a]}}class Wt extends Ft.CoordinateSequenceOperation{constructor(){super(),Wt.constructor_.apply(this,arguments)}edit(){if(2===arguments.length&&arguments[1]instanceof q&&_(arguments[0],A)){const t=arguments[0];return this.coordinateSequenceFactory.create(t)}return super.edit.apply(this,arguments)}getClass(){return Wt}get interfaces_(){return[]}}Wt.constructor_=function(){this.coordinateSequenceFactory=null;const t=arguments[0];this.coordinateSequenceFactory=t},Ht.CloneOp=Wt,Ht.constructor_=function(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Ht.constructor_.call(this,new kt,0);else if(1===arguments.length){if(_(arguments[0],F)){const t=arguments[0];Ht.constructor_.call(this,new kt,0,t)}else if(arguments[0]instanceof kt){const t=arguments[0];Ht.constructor_.call(this,t,0,Ht.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Ht.constructor_.call(this,t,e,Ht.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}},Ht.serialVersionUID=-0x5ea75f2051eeb400;const jt={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};class Kt{constructor(t){this.geometryFactory=t||new Ht,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){var e,n,s;t=t.replace(/[\n\r]/g," ");var i=jt.typeStr.exec(t);if(-1!==t.search("EMPTY")&&((i=jt.emptyTypeStr.exec(t))[2]=void 0),i&&(n=i[1].toLowerCase(),s=i[2],Qt[n]&&(e=Qt[n].call(this,s))),void 0===e)throw new Error("Could not parse WKT "+t);return e}write(t){return this.extractGeometry(t)}extractGeometry(t){var e=t.getGeometryType().toLowerCase();if(!Zt[e])return null;var n=e.toUpperCase();return t.isEmpty()?n+" EMPTY":n+"("+Zt[e].call(this,t)+")"}}const Zt={coordinate(t){return this.precisionModel.makePrecise(t),t.x+" "+t.y},point(t){return Zt.coordinate.call(this,t._coordinates._coordinates[0])},multipoint(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.point.call(this,t._geometries[n])+")");return e.join(",")},linestring(t){var e=[];for(let n=0,s=t._points._coordinates.length;n<s;++n)e.push(Zt.coordinate.call(this,t._points._coordinates[n]));return e.join(",")},linearring(t){var e=[];for(let n=0,s=t._points._coordinates.length;n<s;++n)e.push(Zt.coordinate.call(this,t._points._coordinates[n]));return e.join(",")},multilinestring(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.linestring.call(this,t._geometries[n])+")");return e.join(",")},polygon(t){var e=[];e.push("("+Zt.linestring.call(this,t._shell)+")");for(let n=0,s=t._holes.length;n<s;++n)e.push("("+Zt.linestring.call(this,t._holes[n])+")");return e.join(",")},multipolygon(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.polygon.call(this,t._geometries[n])+")");return e.join(",")},geometrycollection(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push(this.extractGeometry(t._geometries[n]));return e.join(",")}},Qt={coord(t){var e=t.trim().split(jt.spaces),n=new g(Number.parseFloat(e[0]),Number.parseFloat(e[1]));return this.precisionModel.makePrecise(n),n},point(t){return void 0===t?this.geometryFactory.createPoint():this.geometryFactory.createPoint(Qt.coord.call(this,t))},multipoint(t){if(void 0===t)return this.geometryFactory.createMultiPoint();var e,n=t.trim().split(","),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.point.call(this,e));return this.geometryFactory.createMultiPoint(s)},linestring(t){if(void 0===t)return this.geometryFactory.createLineString();var e=t.trim().split(","),n=[];for(let t=0,s=e.length;t<s;++t)n.push(Qt.coord.call(this,e[t]));return this.geometryFactory.createLineString(n)},linearring(t){if(void 0===t)return this.geometryFactory.createLinearRing();var e=t.trim().split(","),n=[];for(let t=0,s=e.length;t<s;++t)n.push(Qt.coord.call(this,e[t]));return this.geometryFactory.createLinearRing(n)},multilinestring(t){if(void 0===t)return this.geometryFactory.createMultiLineString();var e,n=t.trim().split(jt.parenComma),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.linestring.call(this,e));return this.geometryFactory.createMultiLineString(s)},polygon(t){if(void 0===t)return this.geometryFactory.createPolygon();var e,n,s,i,r=t.trim().split(jt.parenComma),o=[];for(let t=0,l=r.length;t<l;++t)e=r[t].replace(jt.trimParens,"$1"),n=Qt.linestring.call(this,e),s=this.geometryFactory.createLinearRing(n._points),0===t?i=s:o.push(s);return this.geometryFactory.createPolygon(i,o)},multipolygon(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();var e,n=t.trim().split(jt.doubleParenComma),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.polygon.call(this,e));return this.geometryFactory.createMultiPolygon(s)},geometrycollection(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();var e=(t=t.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),n=[];for(let t=0,s=e.length;t<s;++t)n.push(this.read(e[t]));return this.geometryFactory.createGeometryCollection(n)}};class Jt{constructor(t){this.parser=new Kt(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class $t{constructor(){$t.constructor_.apply(this,arguments)}static computeEdgeDistance(t,e,n){const s=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=s>i?s:i;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=s>i?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return u.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const s=t.x-e.x,i=t.y-e.y,r=Math.sqrt(s*s+i*i);return u.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new wt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,s){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=s,this._result=this.computeIntersect(t,e,n,s)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(()=>Array(2)),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==$t.NO_INTERSECTION}getEdgeDistance(t,e){return $t.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===$t.COLLINEAR_INTERSECTION}toString(){return Jt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Jt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}getClass(){return $t}get interfaces_(){return[]}}$t.constructor_=function(){this._result=null,this._inputLines=Array(2).fill().map(()=>Array(2)),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new g,this._intPt[1]=new g,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0},$t.DONT_INTERSECT=0,$t.DO_INTERSECT=1,$t.COLLINEAR=2,$t.NO_INTERSECTION=0,$t.POINT_INTERSECTION=1,$t.COLLINEAR_INTERSECTION=2;class te extends $t{constructor(){super(),te.constructor_.apply(this,arguments)}static nearestEndpoint(t,e,n,s){let i=t,r=D.pointToSegment(t,n,s),o=D.pointToSegment(e,n,s);return o<r&&(r=o,i=e),o=D.pointToSegment(n,t,e),o<r&&(r=o,i=n),o=D.pointToSegment(s,t,e),o<r&&(r=o,i=s),i}isInSegmentEnvelopes(t){const e=new N(this._inputLines[0][0],this._inputLines[0][1]),n=new N(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,N.intersects(e,n,t)&&0===v.index(e,n,t)&&0===v.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=$t.POINT_INTERSECTION,null;this._result=$t.NO_INTERSECTION}}normalizeToMinimum(t,e,n,s,i){i.x=this.smallestInAbsValue(t.x,e.x,n.x,s.x),i.y=this.smallestInAbsValue(t.y,e.y,n.y,s.y),t.x-=i.x,t.y-=i.y,e.x-=i.x,e.y-=i.y,n.x-=i.x,n.y-=i.y,s.x-=i.x,s.y-=i.y}safeHCoordinateIntersection(t,e,n,s){let i=null;try{i=b.intersection(t,e,n,s)}catch(r){if(!(r instanceof S))throw r;i=te.nearestEndpoint(t,e,n,s)}return i}intersection(t,e,n,s){let i=this.intersectionWithNormalization(t,e,n,s);return this.isInSegmentEnvelopes(i)||(i=new g(te.nearestEndpoint(t,e,n,s))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}smallestInAbsValue(t,e,n,s){let i=t,r=Math.abs(i);return Math.abs(e)<r&&(i=e,r=Math.abs(e)),Math.abs(n)<r&&(i=n,r=Math.abs(n)),Math.abs(s)<r&&(i=s),i}checkDD(t,e,n,s,i){const r=P.intersection(t,e,n,s),o=this.isInSegmentEnvelopes(r);O.out.println("DD in env = "+o+"  --------------------- "+r),i.distance(r)>1e-4&&O.out.println("Distance = "+i.distance(r))}intersectionWithNormalization(t,e,n,s){const i=new g(t),r=new g(e),o=new g(n),l=new g(s),a=new g;this.normalizeToEnvCentre(i,r,o,l,a);const c=this.safeHCoordinateIntersection(i,r,o,l);return c.x+=a.x,c.y+=a.y,c}computeCollinearIntersection(t,e,n,s){const i=N.intersects(t,e,n),r=N.intersects(t,e,s),o=N.intersects(n,s,t),l=N.intersects(n,s,e);return i&&r?(this._intPt[0]=n,this._intPt[1]=s,$t.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,$t.COLLINEAR_INTERSECTION):i&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):i&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):r&&o?(this._intPt[0]=s,this._intPt[1]=t,!s.equals(t)||i||l?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):r&&l?(this._intPt[0]=s,this._intPt[1]=e,!s.equals(e)||i||o?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):$t.NO_INTERSECTION}normalizeToEnvCentre(t,e,n,s,i){const r=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,l=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,c=n.x<s.x?n.x:s.x,h=n.y<s.y?n.y:s.y,u=n.x>s.x?n.x:s.x,g=n.y>s.y?n.y:s.y,d=((r>c?r:c)+(l<u?l:u))/2,_=((o>h?o:h)+(a<g?a:g))/2;i.x=d,i.y=_,t.x-=i.x,t.y-=i.y,e.x-=i.x,e.y-=i.y,n.x-=i.x,n.y-=i.y,s.x-=i.x,s.y-=i.y}computeIntersect(t,e,n,s){if(this._isProper=!1,!N.intersects(t,e,n,s))return $t.NO_INTERSECTION;const i=v.index(t,e,n),r=v.index(t,e,s);if(i>0&&r>0||i<0&&r<0)return $t.NO_INTERSECTION;const o=v.index(n,s,t),l=v.index(n,s,e);return o>0&&l>0||o<0&&l<0?$t.NO_INTERSECTION:0===i&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,s):(0===i||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(s)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(s)?this._intPt[0]=e:0===i?this._intPt[0]=new g(n):0===r?this._intPt[0]=new g(s):0===o?this._intPt[0]=new g(t):0===l&&(this._intPt[0]=new g(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,s)),$t.POINT_INTERSECTION)}getClass(){return te}get interfaces_(){return[]}}te.constructor_=function(){};class ee{constructor(){ee.constructor_.apply(this,arguments)}static midPoint(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof ee){const t=arguments[0],e=v.index(this.p0,this.p1,t.p0),n=v.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof g){const t=arguments[0];return v.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof ee))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new te;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof g){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);const e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ee){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let s=this.project(t.p0);e<0&&(s=this.p0),e>1&&(s=this.p1);let i=this.project(t.p1);return n<0&&(i=this.p0),n>1&&(i=this.p1),new ee(s,i)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return D.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return ee.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,s=e*e+n*n;return s<=0?i.NaN:((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/s}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let s=i.MAX_VALUE,r=null;const o=this.closestPoint(t.p0);s=o.distance(t.p0),n[0]=o,n[1]=t.p0;const l=this.closestPoint(t.p1);r=l.distance(t.p1),r<s&&(s=r,n[0]=l,n[1]=t.p1);const a=t.closestPoint(this.p0);r=a.distance(this.p0),r<s&&(s=r,n[0]=this.p0,n[1]=a);const c=t.closestPoint(this.p1);return r=c.distance(this.p1),r<s&&(s=r,n[0]=this.p1,n[1]=c),n}closestPoint(t){const e=this.projectionFactor(t);return e>0&&e<1?this.project(t):this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){try{return b.intersection(this.p0,this.p1,t.p0,t.p1)}catch(t){if(!(t instanceof S))throw t}return null}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),s=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(i*i+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new IllegalStateException("Cannot compute offset from zero-length line segment");l=e*i/o,a=e*r/o}return new g(n-a,s+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||i.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}distance(){if(arguments[0]instanceof ee){const t=arguments[0];return D.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){const t=arguments[0];return D.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=java.lang.Double.doubleToLongBits(this.p1.x);return n^=31*java.lang.Double.doubleToLongBits(this.p1.y),e^(Math.trunc(n)^Math.trunc(n>>32))}getClass(){return ee}get interfaces_(){return[r,a]}}ee.constructor_=function(){if(this.p0=null,this.p1=null,0===arguments.length)ee.constructor_.call(this,new g,new g);else if(1===arguments.length){const t=arguments[0];ee.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ee.constructor_.call(this,new g(t,e),new g(n,s))}},ee.serialVersionUID=0x2d2172135f411c00;class ne{constructor(){ne.constructor_.apply(this,arguments)}static toLocationSymbol(t){switch(t){case ne.EXTERIOR:return"e";case ne.BOUNDARY:return"b";case ne.INTERIOR:return"i";case ne.NONE:return"-"}throw new n("Unknown location value: "+t)}getClass(){return ne}get interfaces_(){return[]}}ne.constructor_=function(){},ne.INTERIOR=0,ne.BOUNDARY=1,ne.EXTERIOR=2,ne.NONE=-1;class se{constructor(){se.constructor_.apply(this,arguments)}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===ut.SYM_DONTCARE||(e===ut.SYM_TRUE&&(t>=0||t===ut.TRUE)||(e===ut.SYM_FALSE&&t===ut.FALSE||(e===ut.SYM_P&&t===ut.P||(e===ut.SYM_L&&t===ut.L||e===ut.SYM_A&&t===ut.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return new se(t).matches(e)}}static isTrue(t){return t>=0||t===ut.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])||se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY]))&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE}isCoveredBy(){return(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])||se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY]))&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this._matrix[n][s]=ut.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this.setAtLeast(n,s,ut.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===ut.A&&e===ut.A||t===ut.L&&e===ut.L||t===ut.L&&e===ut.A||t===ut.P&&e===ut.A||t===ut.P&&e===ut.L)&&(this._matrix[ne.INTERIOR][ne.INTERIOR]===ut.FALSE&&(se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY])))}isOverlaps(t,e){return t===ut.P&&e===ut.P||t===ut.A&&e===ut.A?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]):t===ut.L&&e===ut.L&&(1===this._matrix[ne.INTERIOR][ne.INTERIOR]&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]))}isEquals(t,e){return t===e&&(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE)}toString(){const t=new wt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,ut.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new n("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!se.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[ne.INTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.INTERIOR][ne.BOUNDARY]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.BOUNDARY]===ut.FALSE}isCrosses(t,e){return t===ut.P&&e===ut.L||t===ut.P&&e===ut.A||t===ut.L&&e===ut.A?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR]):t===ut.L&&e===ut.P||t===ut.A&&e===ut.P||t===ut.A&&e===ut.L?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]):t===ut.L&&e===ut.L&&0===this._matrix[ne.INTERIOR][ne.INTERIOR]}getClass(){return se}get interfaces_(){return[o]}}se.constructor_=function(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map(()=>Array(3)),this.setAll(ut.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];se.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof se){const t=arguments[0];se.constructor_.call(this),this._matrix[ne.INTERIOR][ne.INTERIOR]=t._matrix[ne.INTERIOR][ne.INTERIOR],this._matrix[ne.INTERIOR][ne.BOUNDARY]=t._matrix[ne.INTERIOR][ne.BOUNDARY],this._matrix[ne.INTERIOR][ne.EXTERIOR]=t._matrix[ne.INTERIOR][ne.EXTERIOR],this._matrix[ne.BOUNDARY][ne.INTERIOR]=t._matrix[ne.BOUNDARY][ne.INTERIOR],this._matrix[ne.BOUNDARY][ne.BOUNDARY]=t._matrix[ne.BOUNDARY][ne.BOUNDARY],this._matrix[ne.BOUNDARY][ne.EXTERIOR]=t._matrix[ne.BOUNDARY][ne.EXTERIOR],this._matrix[ne.EXTERIOR][ne.INTERIOR]=t._matrix[ne.EXTERIOR][ne.INTERIOR],this._matrix[ne.EXTERIOR][ne.BOUNDARY]=t._matrix[ne.EXTERIOR][ne.BOUNDARY],this._matrix[ne.EXTERIOR][ne.EXTERIOR]=t._matrix[ne.EXTERIOR][ne.EXTERIOR]}};class ie{constructor(){ie.constructor_.apply(this,arguments)}static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=ie.PI_TIMES_2;for(;t<=-Math.PI;)t+=ie.PI_TIMES_2;return t}static angle(){if(1===arguments.length){const t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return Math.atan2(s,n)}}static isAcute(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)>0}static isObtuse(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)<0}static interiorAngle(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n);return Math.abs(i-s)}static normalizePositive(t){if(t<0){for(;t<0;)t+=ie.PI_TIMES_2;t>=ie.PI_TIMES_2&&(t=0)}else{for(;t>=ie.PI_TIMES_2;)t-=ie.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n);return ie.diff(s,i)}static diff(t,e){let n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n}static toRadians(t){return t*Math.PI/180}static getTurn(t,e){const n=Math.sin(e-t);return n>0?ie.COUNTERCLOCKWISE:n<0?ie.CLOCKWISE:ie.NONE}static angleBetweenOriented(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n)-s;return i<=-Math.PI?i+ie.PI_TIMES_2:i>Math.PI?i-ie.PI_TIMES_2:i}getClass(){return ie}get interfaces_(){return[]}}ie.constructor_=function(){},ie.PI_TIMES_2=2*Math.PI,ie.PI_OVER_2=Math.PI/2,ie.PI_OVER_4=Math.PI/4,ie.COUNTERCLOCKWISE=v.COUNTERCLOCKWISE,ie.CLOCKWISE=v.CLOCKWISE,ie.NONE=v.COLLINEAR;class re{constructor(){re.constructor_.apply(this,arguments)}static area(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}static signedArea(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}static det(t,e,n,s){return t*s-e*n}static interpolateZ(t,e,n,s){const i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.z+d*(n.z-e.z)+_*(s.z-e.z)}static longestSideLength(t,e,n){const s=t.distance(e),i=e.distance(n),r=n.distance(t);let o=s;return i>o&&(o=i),r>o&&(o=r),o}static isAcute(t,e,n){return!!ie.isAcute(t,e,n)&&(!!ie.isAcute(e,n,t)&&!!ie.isAcute(n,t,e))}static circumcentre(t,e,n){const s=n.x,i=n.y,r=t.x-s,o=t.y-i,l=e.x-s,a=e.y-i,c=2*re.det(r,o,l,a),h=re.det(o,r*r+o*o,a,l*l+a*a),u=re.det(r,r*r+o*o,l,l*l+a*a);return new g(s-h/c,i+u/c)}static perpendicularBisector(t,e){const n=e.x-t.x,s=e.y-t.y,i=new b(t.x+n/2,t.y+s/2,1),r=new b(t.x-s+n/2,t.y+n+s/2,1);return new b(i,r)}static angleBisector(t,e,n){const s=e.distance(t),i=s/(s+e.distance(n)),r=n.x-t.x,o=n.y-t.y;return new g(t.x+i*r,t.y+i*o)}static area3D(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=e.z-t.z,o=n.x-t.x,l=n.y-t.y,a=n.z-t.z,c=i*a-r*l,h=r*o-s*a,u=s*l-i*o,g=c*c+h*h+u*u;return Math.sqrt(g)/2}static centroid(t,e,n){const s=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new g(s,i)}static inCentre(t,e,n){const s=e.distance(n),i=t.distance(n),r=t.distance(e),o=s+i+r,l=(s*t.x+i*e.x+r*n.x)/o,a=(s*t.y+i*e.y+r*n.y)/o;return new g(l,a)}area(){return re.area(this.p0,this.p1,this.p2)}signedArea(){return re.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new n("Supplied point is null.");return re.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return re.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return re.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return re.circumcentre(this.p0,this.p1,this.p2)}area3D(){return re.area3D(this.p0,this.p1,this.p2)}centroid(){return re.centroid(this.p0,this.p1,this.p2)}inCentre(){return re.inCentre(this.p0,this.p1,this.p2)}getClass(){return re}get interfaces_(){return[]}}re.constructor_=function(){this.p0=null,this.p1=null,this.p2=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n};class oe extends C{constructor(){super(),oe.constructor_.apply(this,arguments)}getClass(){return oe}get interfaces_(){return[]}}oe.constructor_=function(){if(0===arguments.length)C.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];C.constructor_.call(this,t)}};class le{constructor(){le.constructor_.apply(this,arguments)}static translationInstance(t,e){const n=new le;return n.setToTranslation(t,e),n}static shearInstance(t,e){const n=new le;return n.setToShear(t,e),n}static reflectionInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToReflection(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.setToReflection(t,e,n,s),i}}static rotationInstance(){if(1===arguments.length){const t=arguments[0];return le.rotationInstance(Math.sin(t),Math.cos(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToRotation(t,e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return le.rotationInstance(Math.sin(t),Math.cos(t),e,n)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.setToRotation(t,e,n,s),i}}static scaleInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToScale(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.translate(-n,-s),i.scale(t,e),i.translate(n,s),i}}setToReflectionBasic(t,e,s,i){if(t===s&&e===i)throw new n("Reflection line points must be distinct");const r=s-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l,h=2*a*c,u=c*c-a*a;return this._m00=u,this._m01=h,this._m02=0,this._m10=h,this._m11=-u,this._m12=0,this}getInverse(){const t=this.getDeterminant();if(0===t)throw new oe("Transformation is non-invertible");const e=this._m11/t,n=-this._m10/t,s=-this._m01/t,i=this._m00/t,r=(this._m01*this._m12-this._m02*this._m11)/t,o=(-this._m00*this._m12+this._m10*this._m02)/t;return new le(e,s,r,n,i,o)}compose(t){const e=t._m00*this._m00+t._m01*this._m10,n=t._m00*this._m01+t._m01*this._m11,s=t._m00*this._m02+t._m01*this._m12+t._m02,i=t._m10*this._m00+t._m11*this._m10,r=t._m10*this._m01+t._m11*this._m11,o=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}equals(t){if(null===t)return!1;if(!(t instanceof le))return!1;const e=t;return this._m00===e._m00&&this._m01===e._m01&&this._m02===e._m02&&this._m10===e._m10&&this._m11===e._m11&&this._m12===e._m12}setToScale(t,e){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=e,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,e){return this.compose(le.scaleInstance(t,e)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1===arguments.length){const t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return this._m00=t,this._m01=e,this._m02=n,this._m10=s,this._m11=i,this._m12=r,this}}setToRotation(){if(1===arguments.length){const t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._m00=e,this._m01=-t,this._m02=0,this._m10=t,this._m11=e,this._m12=0,this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),e,n),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this._m00=e,this._m01=-t,this._m02=n-n*e+s*t,this._m10=t,this._m11=e,this._m12=s-n*t-s*e,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,e){this.transform(t,e)}rotate(){if(1===arguments.length){const t=arguments[0];return this.compose(le.rotationInstance(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.rotationInstance(t,e)),this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.compose(le.rotationInstance(t,e,n)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.rotationInstance(t,e)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){const e=this._m00*t._m00+this._m01*t._m10,n=this._m00*t._m01+this._m01*t._m11,s=this._m00*t._m02+this._m01*t._m12+this._m02,i=this._m10*t._m00+this._m11*t._m10,r=this._m10*t._m01+this._m11*t._m11,o=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}setToShear(t,e){return this._m00=1,this._m01=t,this._m02=0,this._m10=e,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){try{return null}catch(t){if(!(t instanceof C))throw t;u.shouldNeverReachHere()}return null}translate(t,e){return this.compose(le.translationInstance(t,e)),this}setToReflection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Reflection vector must be non-zero");if(t===e)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;const s=Math.sqrt(t*t+e*e),i=e/s,r=t/s;return this.rotate(-i,r),this.scale(1,-1),this.rotate(i,r),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],s=arguments[2],i=arguments[3];if(t===s&&e===i)throw new n("Reflection line points must be distinct");this.setToTranslation(-t,-e);const r=s-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l;return this.rotate(-a,c),this.scale(1,-1),this.rotate(a,c),this.translate(t,e),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,e){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=e,this}shear(t,e){return this.compose(le.shearInstance(t,e)),this}transform(){if(1===arguments.length){const t=arguments[0].copy();return t.apply(this),t}if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=this._m00*t.x+this._m01*t.y+this._m02,s=this._m10*t.x+this._m11*t.y+this._m12;return e.x=n,e.y=s,e}if(_(arguments[0],A)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=this._m00*t.getOrdinate(e,0)+this._m01*t.getOrdinate(e,1)+this._m02,s=this._m10*t.getOrdinate(e,0)+this._m11*t.getOrdinate(e,1)+this._m12;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}}}reflect(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.reflectionInstance(t,e)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(le.reflectionInstance(t,e,n,s)),this}}getClass(){return le}get interfaces_(){return[o,dt]}}le.constructor_=function(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0===arguments.length)this.setToIdentity();else if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof le){const t=arguments[0];this.setTransformation(t)}}else if(6===arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this.setTransformation(t,e,n,s,i,r)}};class ae{constructor(){ae.constructor_.apply(this,arguments)}static solve(t,e){const s=e.length;if(t.length!==s||t[0].length!==s)throw new n("Matrix A is incorrectly sized");for(let n=0;n<s;n++){let i=n;for(let e=n+1;e<s;e++)Math.abs(t[e][n])>Math.abs(t[i][n])&&(i=e);if(0===t[i][n])return null;ae.swapRows(t,n,i),ae.swapRows(e,n,i);for(let i=n+1;i<s;i++){const r=t[i][n]/t[n][n];for(let e=s-1;e>=n;e--)t[i][e]-=t[n][e]*r;e[i]-=e[n]*r}}const i=new Array(s).fill(null);for(let n=s-1;n>=0;n--){let r=0;for(let e=n+1;e<s;e++)r+=t[n][e]*i[e];i[n]=(e[n]-r)/t[n][n]}return i}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;for(let s=0;s<t[0].length;s++){const i=t[e][s];t[e][s]=t[n][s],t[n][s]=i}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;const s=t[e];t[e]=t[n],t[n]=s}}getClass(){return ae}get interfaces_(){return[]}}ae.constructor_=function(){};class ce{constructor(){ce.constructor_.apply(this,arguments)}solve(t){const e=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return ae.solve(e,t)}compute(){const t=[this._dest0.x,this._dest1.x,this._dest2.x],e=this.solve(t);if(null===e)return!1;this._m00=e[0],this._m01=e[1],this._m02=e[2];const n=[this._dest0.y,this._dest1.y,this._dest2.y],s=this.solve(n);return null!==s&&(this._m10=s[0],this._m11=s[1],this._m12=s[2],!0)}getTransformation(){return this.compute()?new le(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}getClass(){return ce}get interfaces_(){return[]}}ce.constructor_=function(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this._src0=t,this._src1=e,this._src2=n,this._dest0=s,this._dest1=i,this._dest2=r};class he{constructor(){he.constructor_.apply(this,arguments)}static createFromBaseLines(t,e,n,s){const i=new g(t.x+s.x-n.x,t.y+s.y-n.y),r=ie.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return new le;const a=l/o,c=le.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}static createFromControlVectors(){if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return le.translationInstance(n,s)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1];if(t.length!==e.length)throw new n("Src and Dest arrays are not the same length");if(t.length<=0)throw new n("Too few control points");if(t.length>3)throw new n("Too many control points");return 1===t.length?he.createFromControlVectors(t[0],e[0]):2===t.length?he.createFromControlVectors(t[0],t[1],e[0],e[1]):he.createFromControlVectors(t[0],t[1],t[2],e[0],e[1],e[2])}}else{if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new g(s.x-n.x,s.y-n.y),r=ie.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return null;const a=l/o,c=le.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return new ce(t,e,n,s,i,r).getTransformation()}}}getClass(){return he}get interfaces_(){return[]}}he.constructor_=function(){};class ue{constructor(){ue.constructor_.apply(this,arguments)}static getCoordinates(t){const e=new x;return t.apply(new ue(e)),e}filter(t){(t instanceof Tt||t instanceof Pt)&&this._coords.add(t.getCoordinate())}getClass(){return ue}get interfaces_(){return[G]}}ue.constructor_=function(){this._coords=null;const t=arguments[0];this._coords=t};class ge{constructor(){ge.constructor_.apply(this,arguments)}static map(t,e){return new ge(e).map(t)}map(t){const e=new x;for(let n=0;n<t.getNumGeometries();n++){const s=this._mapOp.map(t.getGeometryN(n));s.isEmpty()||e.add(s)}return t.getFactory().createGeometryCollection(Ht.toGeometryArray(e))}getClass(){return ge}get interfaces_(){return[]}}ge.constructor_=function(){this._mapOp=null;const t=arguments[0];this._mapOp=t};class de{constructor(){de.constructor_.apply(this,arguments)}static combine(){if(1===arguments.length){const t=arguments[0];return new de(t).combine()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new de(de.createList(t,e)).combine()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new de(de.createList(t,e,n)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new x;return n.add(t),n.add(e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new x;return s.add(t),s.add(e),s.add(n),s}}extractElements(t,e){if(null===t)return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);this._skipEmpty&&s.isEmpty()||e.add(s)}}combine(){const t=new x;for(let e=this._inputGeoms.iterator();e.hasNext();){const n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}getClass(){return de}get interfaces_(){return[]}}de.constructor_=function(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;const t=arguments[0];this._geomFactory=de.extractFactory(t),this._inputGeoms=t};class _e{constructor(){_e.constructor_.apply(this,arguments)}static isOfType(t,e){return t.getGeometryType()===e||e===q.TYPENAME_LINESTRING&&t.getGeometryType()===q.TYPENAME_LINEARRING}static extract(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return _e.extract(t,e,new x)}if(3===arguments.length){if(_(arguments[2],m)&&arguments[0]instanceof q&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t.getGeometryType()===e?n.add(t):t instanceof _t&&t.apply(new _e(e,n)),n}if(_(arguments[2],m)&&arguments[0]instanceof q&&arguments[1]instanceof Class){const t=arguments[0],e=arguments[1],n=arguments[2];return _e.extract(t,_e.toGeometryType(e),n)}}}filter(t){(null===this._geometryType||_e.isOfType(t,this._geometryType))&&this._comps.add(t)}getClass(){return _e}get interfaces_(){return[gt]}}_e.constructor_=function(){this._geometryType=null,this._comps=null;const t=arguments[0],e=arguments[1];this._geometryType=t,this._comps=e};class fe{constructor(){fe.constructor_.apply(this,arguments)}map(t){}getClass(){return fe}get interfaces_(){return[]}}fe.constructor_=function(){};class pe{constructor(){pe.constructor_.apply(this,arguments)}static map(){if(arguments[0]instanceof q&&_(arguments[1],fe)){const t=arguments[0],e=arguments[1],n=new x;for(let s=0;s<t.getNumGeometries();s++){const i=e.map(t.getGeometryN(s));null!==i&&n.add(i)}return t.getFactory().buildGeometry(n)}if(_(arguments[0],f)&&_(arguments[1],fe)){const t=arguments[0],e=arguments[1],n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e.map(t);null!==i&&n.add(i)}return n}}getClass(){return pe}get interfaces_(){return[]}}pe.constructor_=function(){};class me{constructor(){me.constructor_.apply(this,arguments)}transformPoint(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,e){let n=!0;const s=this.transformLinearRing(t.getExteriorRing(),t);null!==s&&s instanceof Dt&&!s.isEmpty()||(n=!1);const i=new x;for(let e=0;e<t.getNumInteriorRing();e++){const s=this.transformLinearRing(t.getInteriorRingN(e),t);null===s||s.isEmpty()||(s instanceof Dt||(n=!1),i.add(s))}if(n)return this._factory.createPolygon(s,i.toArray([]));{const t=new x;return null!==s&&t.add(s),t.addAll(i),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformLineString(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformCoordinates(t,e){return this.copy(t)}transformLineString(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPoint(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformMultiPolygon(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPolygon(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}copy(t){return t.copy()}transformGeometryCollection(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transform(t.getGeometryN(e));null!==s&&(this._pruneEmptyGeometry&&s.isEmpty()||n.add(s))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Ht.toGeometryArray(n)):this._factory.buildGeometry(n)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof Pt)return this.transformPoint(t,null);if(t instanceof Mt)return this.transformMultiPoint(t,null);if(t instanceof Dt)return this.transformLinearRing(t,null);if(t instanceof Tt)return this.transformLineString(t,null);if(t instanceof ft)return this.transformMultiLineString(t,null);if(t instanceof bt)return this.transformPolygon(t,null);if(t instanceof At)return this.transformMultiPolygon(t,null);if(t instanceof _t)return this.transformGeometryCollection(t,null);throw new n("Unknown Geometry subtype: "+t.getClass().getName())}transformLinearRing(t,e){const n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);const s=n.size();return s>0&&s<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)}getClass(){return me}get interfaces_(){return[]}}me.constructor_=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1};class ye{constructor(){ye.constructor_.apply(this,arguments)}static getGeometry(t){return t.getFactory().buildGeometry(ye.getLines(t))}static getLines(){if(1===arguments.length){const t=arguments[0];return ye.getLines(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof Tt?e.add(t):t instanceof _t&&t.apply(new ye(e)),e}}filter(t){t instanceof Tt&&this._comps.add(t)}getClass(){return ye}get interfaces_(){return[gt]}}ye.constructor_=function(){this._comps=null;const t=arguments[0];this._comps=t};class xe{constructor(){xe.constructor_.apply(this,arguments)}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(xe.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(xe.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return xe.getLines(t,!1)}if(2===arguments.length){if(_(arguments[0],f)&&_(arguments[1],f)){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){const t=n.next();xe.getLines(t,e)}return e}if(arguments[0]instanceof q&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new x;return t.apply(new xe(n,e)),n}if(arguments[0]instanceof q&&_(arguments[1],f)){const t=arguments[0],e=arguments[1];return t instanceof Tt?e.add(t):t.apply(new xe(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&_(arguments[0],f)&&_(arguments[1],f)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=t.iterator();s.hasNext();){const t=s.next();xe.getLines(t,e,n)}return e}if("boolean"==typeof arguments[2]&&arguments[0]instanceof q&&_(arguments[1],f)){const t=arguments[0],e=arguments[1],n=arguments[2];return t.apply(new xe(e,n)),e}}}filter(t){if(this._isForcedToLineString&&t instanceof Dt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof Tt&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}getClass(){return xe}get interfaces_(){return[G]}}xe.constructor_=function(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}};const Ee={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return Ee.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?ht.sort(n,e):ht.sort(n);const s=t.iterator();for(let t=0,e=n.length;t<e;t++)s.next(),s.set(n[t])},singletonList:function(t){const e=new x;return e.add(t),e}};class Ie{constructor(){Ie.constructor_.apply(this,arguments)}static getPoints(){if(1===arguments.length){const t=arguments[0];return t instanceof Pt?Ee.singletonList(t):Ie.getPoints(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof Pt?e.add(t):t instanceof _t&&t.apply(new Ie(e)),e}}filter(t){t instanceof Pt&&this._pts.add(t)}getClass(){return Ie}get interfaces_(){return[gt]}}Ie.constructor_=function(){this._pts=null;const t=arguments[0];this._pts=t};class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static getPolygons(){if(1===arguments.length){const t=arguments[0];return Ne.getPolygons(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof bt?e.add(t):t instanceof _t&&t.apply(new Ne(e)),e}}filter(t){t instanceof bt&&this._comps.add(t)}getClass(){return Ne}get interfaces_(){return[gt]}}Ne.constructor_=function(){this._comps=null;const t=arguments[0];this._comps=t};class Ce{constructor(){Ce.constructor_.apply(this,arguments)}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof _t)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}getClass(){return Ce}get interfaces_(){return[]}}Ce.constructor_=function(){this._isDone=!1};class Se{constructor(){Se.constructor_.apply(this,arguments)}createSupercircle(t){const e=1/t,n=this._dim.getMinSize()/2,s=this._dim.getCentre(),i=Math.pow(n,t),r=n,o=Math.pow(i/2,e),l=Math.trunc(this._nPts/8),a=new Array(8*l+1).fill(null),c=o/l;for(let n=0;n<=l;n++){let o=0,h=r;if(0!==n){o=c*n;const s=Math.pow(o,t);h=Math.pow(i-s,e)}a[n]=this.coordTrans(o,h,s),a[2*l-n]=this.coordTrans(h,o,s),a[2*l+n]=this.coordTrans(h,-o,s),a[4*l-n]=this.coordTrans(o,-h,s),a[4*l+n]=this.coordTrans(-o,-h,s),a[6*l-n]=this.coordTrans(-h,-o,s),a[6*l+n]=this.coordTrans(-h,o,s),a[8*l-n]=this.coordTrans(-o,h,s)}a[a.length-1]=new g(a[0]);const h=this._geomFact.createLinearRing(a),u=this._geomFact.createPolygon(h);return this.rotate(u)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){const t=this._dim.getEnvelope(),e=t.getWidth()/2,n=t.getHeight()/2,s=t.getMinX()+e,i=t.getMinY()+n,r=new Array(this._nPts+1).fill(null);let o=0;for(let t=0;t<this._nPts;t++){const l=t*(2*Math.PI/this._nPts),a=e*Math.cos(l)+s,c=n*Math.sin(l)+i;r[o++]=this.coord(a,c)}r[o]=new g(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}coordTrans(t,e,n){return this.coord(t+n.x,e+n.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts).fill(null);let h=0;for(let e=0;e<this._nPts;e++){const n=t+e*a,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}const u=this._geomFact.createLineString(c);return this.rotate(u)}rotate(t){if(0!==this._rotationAngle){const e=le.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(e)}return t}coord(t,e){const n=new g(t,e);return this._precModel.makePrecise(n),n}createArcPolygon(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts+2).fill(null);let h=0;c[h++]=this.coord(r,o);for(let e=0;e<this._nPts;e++){const n=t+a*e,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}c[h++]=this.coord(r,o);const u=this._geomFact.createLinearRing(c),g=this._geomFact.createPolygon(u);return this.rotate(g)}createRectangle(){let t=null,e=0,n=Math.trunc(this._nPts/4);n<1&&(n=1);const s=this._dim.getEnvelope().getWidth()/n,i=this._dim.getEnvelope().getHeight()/n,r=new Array(4*n+1).fill(null),o=this._dim.getEnvelope();for(t=0;t<n;t++){const n=o.getMinX()+t*s,i=o.getMinY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMaxX(),s=o.getMinY()+t*i;r[e++]=this.coord(n,s)}for(t=0;t<n;t++){const n=o.getMaxX()-t*s,i=o.getMaxY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMinX(),s=o.getMaxY()-t*i;r[e++]=this.coord(n,s)}r[e++]=new g(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}getClass(){return Se}get interfaces_(){return[]}}class we{constructor(){we.constructor_.apply(this,arguments)}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new g(t.getMinX(),t.getMinY()),this.centre=new g(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new N(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new N(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new N(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new g(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}getClass(){return we}get interfaces_(){return[]}}we.constructor_=function(){this.base=null,this.centre=null,this.width=null,this.height=null},Se.Dimensions=we,Se.constructor_=function(){if(this._geomFact=null,this._precModel=null,this._dim=new we,this._nPts=100,this._rotationAngle=0,0===arguments.length)Se.constructor_.call(this,new Ht);else if(1===arguments.length){const t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}};class Le extends Se{constructor(){super(),Le.constructor_.apply(this,arguments)}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){const t=this._dim.getEnvelope(),e=t.getWidth()/2;let n=this._armLengthRatio;n<0&&(n=0),n>1&&(n=1);const s=n*e,i=(1-n)*e,r=t.getMinX()+e,o=t.getMinY()+e,l=new Array(this._nPts+1).fill(null);let a=0;for(let t=0;t<this._nPts;t++){const e=t/this._nPts*this._numArms,n=e-Math.floor(e),c=2*Math.PI*n,h=i+s*((Math.cos(c)+1)/2),u=t*(2*Math.PI/this._nPts),g=h*Math.cos(u)+r,d=h*Math.sin(u)+o;l[a++]=this.coord(g,d)}l[a]=new g(l[0]);const c=this._geomFact.createLinearRing(l);return this._geomFact.createPolygon(c)}getClass(){return Le}get interfaces_(){return[]}}Le.constructor_=function(){if(this._numArms=8,this._armLengthRatio=.5,0===arguments.length)Se.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];Se.constructor_.call(this,t)}};var Te=Object.freeze({__proto__:null,AffineTransformation:le,AffineTransformationBuilder:ce,AffineTransformationFactory:he,ComponentCoordinateExtracter:ue,GeometryCollectionMapper:ge,GeometryCombiner:de,GeometryEditor:Ft,GeometryExtracter:_e,GeometryMapper:pe,GeometryTransformer:me,LineStringExtracter:ye,LinearComponentExtracter:xe,MapOp:fe,PointExtracter:Ie,PolygonExtracter:Ne,ShortCircuitedGeometryVisitor:Ce,SineStarFactory:Le}),Re=Object.freeze({__proto__:null,Coordinate:g,CoordinateList:I,Envelope:N,LineSegment:ee,GeometryFactory:Ht,Geometry:q,Point:Pt,LineString:Tt,LinearRing:Dt,Polygon:bt,GeometryCollection:_t,MultiPoint:Mt,MultiLineString:ft,MultiPolygon:At,Dimension:ut,IntersectionMatrix:se,PrecisionModel:kt,Location:ne,Triangle:re,util:Te});class Pe{constructor(){Pe.constructor_.apply(this,arguments)}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1===arguments.length){const t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n<this._distance&&this.initialize(t,e,n)}}initialize(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=n,this._isNull=!1}}toString(){return Jt.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1===arguments.length){const t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n>this._distance&&this.initialize(t,e,n)}}getClass(){return Pe}get interfaces_(){return[]}}Pe.constructor_=function(){this._pt=[new g,new g],this._distance=i.NaN,this._isNull=!0};class ve{constructor(){ve.constructor_.apply(this,arguments)}static computeDistance(){if(arguments[2]instanceof Pe&&arguments[0]instanceof Tt&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2],s=new ee,i=t.getCoordinates();for(let t=0;t<i.length-1;t++){s.setCoordinates(i[t],i[t+1]);const r=s.closestPoint(e);n.setMinimum(r,e)}}else if(arguments[2]instanceof Pe&&arguments[0]instanceof bt&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2];ve.computeDistance(t.getExteriorRing(),e,n);for(let s=0;s<t.getNumInteriorRing();s++)ve.computeDistance(t.getInteriorRingN(s),e,n)}else if(arguments[2]instanceof Pe&&arguments[0]instanceof q&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2];if(t instanceof Tt)ve.computeDistance(t,e,n);else if(t instanceof bt)ve.computeDistance(t,e,n);else if(t instanceof _t){const s=t;for(let t=0;t<s.getNumGeometries();t++){const i=s.getGeometryN(t);ve.computeDistance(i,e,n)}}else n.setMinimum(t.getCoordinate(),e)}else if(arguments[2]instanceof Pe&&arguments[0]instanceof ee&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.closestPoint(e);n.setMinimum(s,e)}}getClass(){return ve}get interfaces_(){return[]}}ve.constructor_=function(){};class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static distance(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Oe(t,e).distance()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Oe(t,e);return s.setDensifyFraction(n),s.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new n("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,e,n){const s=new be(e);if(t.apply(s),n.setMaximum(s.getMaxPointDistance()),this._densifyFrac>0){const s=new Me(e,this._densifyFrac);t.apply(s),n.setMaximum(s.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}getClass(){return Oe}get interfaces_(){return[]}}class be{constructor(){be.constructor_.apply(this,arguments)}filter(t){this._minPtDist.initialize(),ve.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}getClass(){return be}get interfaces_(){return[B]}}be.constructor_=function(){this._maxPtDist=new Pe,this._minPtDist=new Pe,this._euclideanDist=new ve,this._geom=null;const t=arguments[0];this._geom=t};class Me{constructor(){Me.constructor_.apply(this,arguments)}filter(t,e){if(0===e)return null;const n=t.getCoordinate(e-1),s=t.getCoordinate(e),i=(s.x-n.x)/this._numSubSegs,r=(s.y-n.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){const e=n.x+t*i,s=n.y+t*r,o=new g(e,s);this._minPtDist.initialize(),ve.computeDistance(this._geom,o,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}getClass(){return Me}get interfaces_(){return[dt]}}Me.constructor_=function(){this._maxPtDist=new Pe,this._minPtDist=new Pe,this._geom=null,this._numSubSegs=0;const t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))},Oe.MaxPointDistanceFilter=be,Oe.MaxDensifiedByFractionDistanceFilter=Me,Oe.constructor_=function(){this._g0=null,this._g1=null,this._ptDist=new Pe,this._densifyFrac=0;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e};var De=Object.freeze({__proto__:null,DiscreteHausdorffDistance:Oe,DistanceToPoint:ve,PointPairDistance:Pe});class Ae{constructor(){Ae.constructor_.apply(this,arguments)}visitItem(t){}getClass(){return Ae}get interfaces_(){return[]}}Ae.constructor_=function(){};class Fe{constructor(){Fe.constructor_.apply(this,arguments)}locate(t){}getClass(){return Fe}get interfaces_(){return[]}}Fe.constructor_=function(){};class Ge{constructor(){Ge.constructor_.apply(this,arguments)}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Jt.toLineString(new g(this._min,0),new g(this._max,0))}getClass(){return Ge}get interfaces_(){return[]}}class qe{constructor(){qe.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e,i=(n._min+n._max)/2,r=(s._min+s._max)/2;return i<r?-1:i>r?1:0}getClass(){return qe}get interfaces_(){return[l]}}qe.constructor_=function(){},Ge.NodeComparator=qe,Ge.constructor_=function(){this._min=i.POSITIVE_INFINITY,this._max=i.NEGATIVE_INFINITY};class Be extends Ge{constructor(){super(),Be.constructor_.apply(this,arguments)}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}getClass(){return Be}get interfaces_(){return[]}}Be.constructor_=function(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n};class Ve extends Ge{constructor(){super(),Ve.constructor_.apply(this,arguments)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}getClass(){return Ve}get interfaces_(){return[]}}Ve.constructor_=function(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)};class ze{constructor(){ze.constructor_.apply(this,arguments)}buildTree(){Ee.sort(this._leaves,new Ge.NodeComparator);let t=this._leaves,e=null,n=new x;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new IllegalStateException("Index cannot be added to once it has been queried");this._leaves.add(new Be(t,e,n))}query(t,e,n){this.init(),this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){O.out.println(Jt.toLineString(new g(t._min,this._level),new g(t._max,this._level)))}init(){if(null!==this._root)return null;this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const s=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(s);else{const s=new Ve(t.get(n),t.get(n+1));e.add(s)}}}getClass(){return ze}get interfaces_(){return[]}}ze.constructor_=function(){this._leaves=new x,this._root=null,this._level=0};class Ye{constructor(){Ye.constructor_.apply(this,arguments)}visitItem(t){this._items.add(t)}getItems(){return this._items}getClass(){return Ye}get interfaces_(){return[Ae]}}Ye.constructor_=function(){this._items=new x};class Ue{constructor(){Ue.constructor_.apply(this,arguments)}static locatePointInRing(){if(arguments[0]instanceof g&&_(arguments[1],A)){const t=arguments[0],e=arguments[1],n=new Ue(t),s=new g,i=new g;for(let t=1;t<e.size();t++)if(e.getCoordinate(t,s),e.getCoordinate(t-1,i),n.countSegment(s,i),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new Ue(t);for(let t=1;t<e.length;t++){const s=e[t],i=e[t-1];if(n.countSegment(s,i),n.isOnSegment())return n.getLocation()}return n.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,s=e.x;return n>s&&(n=e.x,s=t.x),this._p.x>=n&&this._p.x<=s&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=v.index(t,e,this._p);if(n===v.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===v.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==ne.EXTERIOR}getLocation(){return this._isPointOnSegment?ne.BOUNDARY:this._crossingCount%2==1?ne.INTERIOR:ne.EXTERIOR}isOnSegment(){return this._isPointOnSegment}getClass(){return Ue}get interfaces_(){return[]}}Ue.constructor_=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t};class ke{constructor(){ke.constructor_.apply(this,arguments)}locate(t){const e=new Ue(t),n=new Xe(e);return this._index.query(t.y,t.y,n),e.getLocation()}getClass(){return ke}get interfaces_(){return[Fe]}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}getClass(){return Xe}get interfaces_(){return[Ae]}}Xe.constructor_=function(){this._counter=null;const t=arguments[0];this._counter=t};class He{constructor(){He.constructor_.apply(this,arguments)}init(t){for(let e=xe.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new ee(t[e-1],t[e]),s=Math.min(n.p0.y,n.p1.y),i=Math.max(n.p0.y,n.p1.y);this._index.insert(s,i,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new Ye;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._index.query(t,e,n)}}getClass(){return He}get interfaces_(){return[]}}He.constructor_=function(){this._index=new ze;const t=arguments[0];this.init(t)},ke.SegmentVisitor=Xe,ke.IntervalIndexedGeometry=He,ke.constructor_=function(){this._index=null;const t=arguments[0];if(!(_(t,Ot)||t instanceof Dt))throw new n("Argument must be Polygonal or LinearRing");this._index=new He(t)};class We{constructor(){We.constructor_.apply(this,arguments)}static isOnLine(){if(arguments[0]instanceof g&&_(arguments[1],A)){const t=arguments[0],e=arguments[1],n=new te,s=new g,i=new g,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,s),e.getCoordinate(o,i),n.computeIntersection(t,s,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof g&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new te;for(let s=1;s<e.length;s++){const i=e[s-1],r=e[s];if(n.computeIntersection(t,i,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Ue.locatePointInRing(t,e)}static isInRing(t,e){return We.locateInRing(t,e)!==ne.EXTERIOR}getClass(){return We}get interfaces_(){return[]}}function je(){}We.constructor_=function(){},je.prototype.hasNext=function(){},je.prototype.next=function(){},je.prototype.remove=function(){};class Ke{constructor(){Ke.constructor_.apply(this,arguments)}static isAtomic(t){return!(t instanceof _t)}next(){if(this._atStart)return this._atStart=!1,Ke.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new y;const t=this._parent.getGeometryN(this._index++);return t instanceof _t?(this._subcollectionIterator=new Ke(t),this._subcollectionIterator.next()):t}remove(){throw new Z(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}getClass(){return Ke}get interfaces_(){return[je]}}Ke.constructor_=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()};class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static locatePointInPolygon(t,e){if(e.isEmpty())return ne.EXTERIOR;const n=e.getExteriorRing(),s=Ze.locatePointInRing(t,n);if(s!==ne.INTERIOR)return s;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=Ze.locatePointInRing(t,s);if(i===ne.BOUNDARY)return ne.BOUNDARY;if(i===ne.INTERIOR)return ne.EXTERIOR}return ne.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?We.locateInRing(t,e.getCoordinates()):ne.EXTERIOR}static containsPointInPolygon(t,e){return ne.EXTERIOR!==Ze.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof bt)return Ze.locatePointInPolygon(t,e);if(e instanceof _t){const n=new Ke(e);for(;n.hasNext();){const s=n.next();if(s!==e){const e=Ze.locateInGeometry(t,s);if(e!==ne.EXTERIOR)return e}}}return ne.EXTERIOR}static locate(t,e){return e.isEmpty()?ne.EXTERIOR:Ze.locateInGeometry(t,e)}locate(t){return Ze.locate(t,this._geom)}getClass(){return Ze}get interfaces_(){return[Fe]}}Ze.constructor_=function(){this._geom=null;const t=arguments[0];this._geom=t};var Qe=Object.freeze({__proto__:null,IndexedPointInAreaLocator:ke,PointOnGeometryLocator:Fe,SimplePointInAreaLocator:Ze});class Je{constructor(){Je.constructor_.apply(this,arguments)}measure(t,e){}getClass(){return Je}get interfaces_(){return[]}}Je.constructor_=function(){};class $e{constructor(){$e.constructor_.apply(this,arguments)}measure(t,e){return t.intersection(e).getArea()/t.union(e).getArea()}getClass(){return $e}get interfaces_(){return[Je]}}$e.constructor_=function(){};class tn{constructor(){tn.constructor_.apply(this,arguments)}static diagonalSize(t){if(t.isNull())return 0;const e=t.getWidth(),n=t.getHeight();return Math.sqrt(e*e+n*n)}measure(t,e){const n=Oe.distance(t,e,tn.DENSIFY_FRACTION),s=new N(t.getEnvelopeInternal());return s.expandToInclude(e.getEnvelopeInternal()),1-n/tn.diagonalSize(s)}getClass(){return tn}get interfaces_(){return[Je]}}tn.constructor_=function(){},tn.DENSIFY_FRACTION=.25;class en{constructor(){en.constructor_.apply(this,arguments)}static combine(t,e){return Math.min(t,e)}getClass(){return en}get interfaces_(){return[]}}en.constructor_=function(){};var nn=Object.freeze({__proto__:null,AreaSimilarityMeasure:$e,HausdorffSimilarityMeasure:tn,SimilarityMeasure:Je,SimilarityMeasureCombiner:en});class sn{constructor(){sn.constructor_.apply(this,arguments)}static area2(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}static centroid3(t,e,n,s){return s.x=t.x+e.x+n.x,s.y=t.y+e.y+n.y,null}static getCentroid(t){return new sn(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let e=0;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);if(0===s)continue;e+=s;const i=(t[n].x+t[n+1].x)/2;this._lineCentSum.x+=s*i;const r=(t[n].y+t[n+1].y)/2;this._lineCentSum.y+=s*r}this._totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])}addHole(t){const e=v.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}getCentroid(){const t=new g;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);const e=!v.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}addTriangle(t,e,n,s){const i=s?1:-1;sn.centroid3(t,e,n,this._triangleCent3);const r=sn.area2(t,e,n);this._cg3.x+=i*r*this._triangleCent3.x,this._cg3.y+=i*r*this._triangleCent3.y,this._areasum2+=i*r}add(){if(arguments[0]instanceof bt){const t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof q){const t=arguments[0];if(t.isEmpty())return null;if(t instanceof Pt)this.addPoint(t.getCoordinate());else if(t instanceof Tt)this.addLineSegments(t.getCoordinates());else if(t instanceof bt){const e=t;this.add(e)}else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}}getClass(){return sn}get interfaces_(){return[]}}function rn(t){this.message=t||""}function on(){this.array_=[]}sn.constructor_=function(){this._areaBasePt=null,this._triangleCent3=new g,this._areasum2=0,this._cg3=new g,this._lineCentSum=new g,this._totalLength=0,this._ptCount=0,this._ptCentSum=new g;const t=arguments[0];this._areaBasePt=null,this.add(t)},rn.prototype=new Error,rn.prototype.name="EmptyStackException",on.prototype=new m,on.prototype.add=function(t){return this.array_.push(t),!0},on.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},on.prototype.push=function(t){return this.array_.push(t),t},on.prototype.pop=function(t){if(0===this.array_.length)throw new rn;return this.array_.pop()},on.prototype.peek=function(){if(0===this.array_.length)throw new rn;return this.array_[this.array_.length-1]},on.prototype.empty=function(){return 0===this.array_.length},on.prototype.isEmpty=function(){return this.empty()},on.prototype.search=function(t){return this.array_.indexOf(t)},on.prototype.size=function(){return this.array_.length},on.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t};class ln{constructor(){ln.constructor_.apply(this,arguments)}static filterCoordinates(t){const e=new ln;for(let n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()}filter(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))}getCoordinates(){const t=new Array(this.list.size()).fill(null);return this.list.toArray(t)}getClass(){return ln}get interfaces_(){return[B]}}ln.constructor_=function(){this.treeSet=new at,this.list=new x};class an{constructor(){an.constructor_.apply(this,arguments)}static extractCoordinates(t){const e=new ln;return t.apply(e),e.getCoordinates()}preSort(t){let e=null;for(let n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ht.sort(t,1,t.length,new cn(t[0])),t}computeOctRing(t){const e=this.computeOctPts(t),n=new I;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);const e=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(e)}cleanRing(t){u.equals(t[0],t[t.length-1]);const e=new x;let n=null;for(let s=0;s<=t.length-2;s++){const i=t[s],r=t[s+1];i.equals(r)||(null!==n&&this.isBetween(n,i,r)||(e.add(i),n=i))}e.add(t[t.length-1]);const s=new Array(e.size()).fill(null);return e.toArray(s)}isBetween(t,e,n){if(0!==v.index(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1}reduce(t){const e=this.computeOctRing(t);if(null===e)return t;const n=new at;for(let t=0;t<e.length;t++)n.add(e[t]);for(let s=0;s<t.length;s++)We.isInRing(t[s],e)||n.add(t[s]);const s=X.toCoordinateArray(n);return s.length<3?this.padArray3(s):s}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));const e=this.preSort(t),n=this.grahamScan(e),s=this.toCoordinateArray(n);return this.lineOrPolygon(s)}padArray3(t){const e=new Array(3).fill(null);for(let n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e}computeOctPts(t){const e=new Array(8).fill(null);for(let n=0;n<e.length;n++)e[n]=t[0];for(let n=1;n<t.length;n++)t[n].x<e[0].x&&(e[0]=t[n]),t[n].x-t[n].y<e[1].x-e[1].y&&(e[1]=t[n]),t[n].y>e[2].y&&(e[2]=t[n]),t[n].x+t[n].y>e[3].x+e[3].y&&(e[3]=t[n]),t[n].x>e[4].x&&(e[4]=t[n]),t[n].x-t[n].y>e[5].x-e[5].y&&(e[5]=t[n]),t[n].y<e[6].y&&(e[6]=t[n]),t[n].x+t[n].y<e[7].x+e[7].y&&(e[7]=t[n]);return e}toCoordinateArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=t.get(n);e[n]=s}return e}grahamScan(t){let e=null;const n=new on;n.push(t[0]),n.push(t[1]),n.push(t[2]);for(let s=3;s<t.length;s++){for(e=n.pop();!n.empty()&&v.index(n.peek(),e,t[s])>0;)e=n.pop();n.push(e),n.push(t[s])}return n.push(t[0]),n}getClass(){return an}get interfaces_(){return[]}}class cn{constructor(){cn.constructor_.apply(this,arguments)}static polarCompare(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=n.x-t.x,o=n.y-t.y,l=v.index(t,e,n);if(l===v.COUNTERCLOCKWISE)return 1;if(l===v.CLOCKWISE)return-1;const a=s*s+i*i,c=r*r+o*o;return a<c?-1:a>c?1:0}compare(t,e){const n=t,s=e;return cn.polarCompare(this._origin,n,s)}getClass(){return cn}get interfaces_(){return[l]}}cn.constructor_=function(){this._origin=null;const t=arguments[0];this._origin=t},an.RadialComparator=cn,an.constructor_=function(){if(this._geomFactory=null,this._inputPts=null,1===arguments.length){const t=arguments[0];an.constructor_.call(this,an.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputPts=ln.filterCoordinates(t),this._geomFactory=e}};class hn{constructor(){hn.constructor_.apply(this,arguments)}static centre(t){return new g(hn.avg(t.getMinX(),t.getMaxX()),hn.avg(t.getMinY(),t.getMaxY()))}static avg(t,e){return(t+e)/2}addPolygon(t){if(t.isEmpty())return null;let e=null,n=null;const s=this.horizontalBisector(t);if(0===s.getLength())n=0,e=s.getCoordinate();else{const i=s.intersection(t),r=this.widestGeometry(i);n=r.getEnvelopeInternal().getWidth(),e=hn.centre(r.getEnvelopeInternal())}(null===this._interiorPoint||n>this._maxWidth)&&(this._interiorPoint=e,this._maxWidth=n)}getInteriorPoint(){return this._interiorPoint}widestGeometry(){if(arguments[0]instanceof _t){const t=arguments[0];if(t.isEmpty())return t;let e=t.getGeometryN(0);for(let n=1;n<t.getNumGeometries();n++)t.getGeometryN(n).getEnvelopeInternal().getWidth()>e.getEnvelopeInternal().getWidth()&&(e=t.getGeometryN(n));return e}if(arguments[0]instanceof q){const t=arguments[0];return t instanceof _t?this.widestGeometry(t):t}}horizontalBisector(t){const e=t.getEnvelopeInternal(),n=un.getBisectorY(t);return this._factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])}add(t){if(t instanceof bt)this.addPolygon(t);else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}getClass(){return hn}get interfaces_(){return[]}}class un{constructor(){un.constructor_.apply(this,arguments)}static getBisectorY(t){return new un(t).getBisectorY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getBisectorY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return hn.avg(this._hiY,this._loY)}process(t){const e=t.getCoordinateSequence();for(let t=0;t<e.size();t++){const n=e.getY(t);this.updateInterval(n)}}getClass(){return un}get interfaces_(){return[]}}un.constructor_=function(){this._poly=null,this._centreY=null,this._hiY=i.MAX_VALUE,this._loY=-i.MAX_VALUE;const t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=hn.avg(this._loY,this._hiY)},hn.SafeBisectorFinder=un,hn.constructor_=function(){this._factory=null,this._interiorPoint=null,this._maxWidth=0;const t=arguments[0];this._factory=t.getFactory(),this.add(t)};class gn{constructor(){gn.constructor_.apply(this,arguments)}addEndpoints(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Tt)this.addEndpoints(t.getCoordinates());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addEndpoints(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Tt)this.addInterior(t.getCoordinates());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addInterior(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=1;e<t.length-1;e++)this.add(t[e])}}add(t){const e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=e)}getClass(){return gn}get interfaces_(){return[]}}gn.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];t.isEmpty()?this._centroid=new g:this._centroid=sn.getCentroid(t),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)};class dn{constructor(){dn.constructor_.apply(this,arguments)}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Pt)this.add(t.getCoordinate());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}else if(arguments[0]instanceof g){const t=arguments[0],e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=e)}}getClass(){return dn}get interfaces_(){return[]}}dn.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];this._centroid=t.getCentroid().getCoordinate(),this.add(t)};class _n{constructor(){_n.constructor_.apply(this,arguments)}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?We.locateInRing(t,e.getCoordinates()):ne.EXTERIOR}intersects(t,e){return this.locate(t,e)!==ne.EXTERIOR}updateLocationInfo(t){t===ne.INTERIOR&&(this._isIn=!0),t===ne.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof Pt&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof Tt)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof bt)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof ft){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,s))}}else if(e instanceof At){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,s))}}else if(e instanceof _t){const n=new Ke(e);for(;n.hasNext();){const s=n.next();s!==e&&this.computeLocation(t,s)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?ne.INTERIOR:ne.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return ne.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?We.isOnLine(t,n)?ne.INTERIOR:ne.EXTERIOR:ne.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return ne.EXTERIOR;const n=e.getExteriorRing(),s=this.locateInPolygonRing(t,n);if(s===ne.EXTERIOR)return ne.EXTERIOR;if(s===ne.BOUNDARY)return ne.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=this.locateInPolygonRing(t,s);if(i===ne.INTERIOR)return ne.EXTERIOR;if(i===ne.BOUNDARY)return ne.BOUNDARY}return ne.INTERIOR}locate(t,e){return e.isEmpty()?ne.EXTERIOR:e instanceof Tt?this.locateOnLineString(t,e):e instanceof bt?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?ne.BOUNDARY:this._numBoundaries>0||this._isIn?ne.INTERIOR:ne.EXTERIOR)}getClass(){return _n}get interfaces_(){return[]}}_n.constructor_=function(){if(this._boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new n("Rule must be non-null");this._boundaryRule=t}};class fn{constructor(){fn.constructor_.apply(this,arguments)}static pointWitMinAngleWithX(t,e){let n=i.MAX_VALUE,s=null;for(let i=0;i<t.length;i++){const r=t[i];if(r===e)continue;const o=r.x-e.x;let l=r.y-e.y;l<0&&(l=-l);const a=l/Math.sqrt(o*o+l*l);a<n&&(n=a,s=r)}return s}static lowestPoint(t){let e=t[0];for(let n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e}static pointWithMinAngleWithSegment(t,e,n){let s=i.MAX_VALUE,r=null;for(let i=0;i<t.length;i++){const o=t[i];if(o===e)continue;if(o===n)continue;const l=ie.angleBetween(e,o,n);l<s&&(s=l,r=o)}return r}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[1];return this._input.getFactory().createLineString([t,e])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=new Array(0).fill(null),null;if(1===this._input.getNumPoints()){const t=this._input.getCoordinates();return this._extremalPts=[new g(t[0])],null}const t=this._input.convexHull().getCoordinates();let e=t;if(t[0].equals2D(t[t.length-1])&&(e=new Array(t.length-1).fill(null),X.copyDeep(t,0,e,0,t.length-1)),e.length<=2)return this._extremalPts=X.copyDeep(e),null;let n=fn.lowestPoint(e),s=fn.pointWitMinAngleWithX(e,n);for(let t=0;t<e.length;t++){const t=fn.pointWithMinAngleWithSegment(e,n,s);if(ie.isObtuse(n,t,s))return this._extremalPts=[new g(n),new g(s)],null;if(ie.isObtuse(t,n,s))n=t;else{if(!ie.isObtuse(t,s,n))return this._extremalPts=[new g(n),new g(s),new g(t)],null;s=t}}u.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getFarthestPoints(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[this._extremalPts.length-1];return this._input.getFactory().createLineString([t,e])}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();const t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new g((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=re.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}getClass(){return fn}get interfaces_(){return[]}}fn.constructor_=function(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;const t=arguments[0];this._input=t};class pn{constructor(){pn.constructor_.apply(this,arguments)}static nextIndex(t,e){return++e>=t.length&&(e=0),e}static computeC(t,e,n){return t*n.y-e*n.x}static getMinimumDiameter(t){return new pn(t).getDiameter()}static getMinimumRectangle(t){return new pn(t).getMinimumRectangle()}static computeSegmentForLine(t,e,n){let s=null,i=null;return Math.abs(e)>Math.abs(t)?(s=new g(0,n/e),i=new g(1,n/e-t/e)):(s=new g(n/t,0),i=new g(n/t-e/t,1)),new ee(s,i)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();const t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof bt?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=i.MAX_VALUE;let e=1;const n=new ee;for(let s=0;s<t.length-1;s++)n.p0=t[s],n.p1=t[s+1],e=this.findMaxPerpDistance(t,n,e)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{const t=new an(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,e,n){let s=e.distancePerpendicular(t[n]),i=s,r=n,o=r;for(;i>=s;)s=i,r=o,o=pn.nextIndex(t,r),i=e.distancePerpendicular(t[o]);return s<this._minWidth&&(this._minPtIndex=r,this._minWidth=s,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new ee(e)),r}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());const t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,e=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y;let n=i.MAX_VALUE,s=-i.MAX_VALUE,r=i.MAX_VALUE,o=-i.MAX_VALUE;for(let i=0;i<this._convexHullPts.length;i++){const l=pn.computeC(t,e,this._convexHullPts[i]);l>s&&(s=l),l<n&&(n=l);const a=pn.computeC(-e,t,this._convexHullPts[i]);a>o&&(o=a),a<r&&(r=a)}const l=pn.computeSegmentForLine(-t,-e,o),a=pn.computeSegmentForLine(-t,-e,r),c=pn.computeSegmentForLine(-e,t,s),h=pn.computeSegmentForLine(-e,t,n),u=c.lineIntersection(l),g=h.lineIntersection(l),d=h.lineIntersection(a),_=c.lineIntersection(a),f=this._inputGeom.getFactory().createLinearRing([u,g,d,_,u]);return this._inputGeom.getFactory().createPolygon(f)}getClass(){return pn}get interfaces_(){return[]}}pn.constructor_=function(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new ee,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1===arguments.length){const t=arguments[0];pn.constructor_.call(this,t,!1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isConvex=e}};var mn=Object.freeze({__proto__:null,distance:De,locate:Qe,match:nn,Angle:ie,Area:vt,Centroid:sn,ConvexHull:an,Distance:D,InteriorPointArea:hn,InteriorPointLine:gn,InteriorPointPoint:dn,Length:yt,Orientation:v,PointLocation:We,PointLocator:_n,RobustLineIntersector:te,MinimumBoundingCircle:fn,MinimumDiameter:pn});class yn{constructor(){yn.constructor_.apply(this,arguments)}static densifyPoints(t,e,n){const s=new ee,i=new I;for(let r=0;r<t.length-1;r++){s.p0=t[r],s.p1=t[r+1],i.add(s.p0,!1);const o=s.getLength(),l=Math.trunc(o/e)+1;if(l>1){const t=o/l;for(let e=1;e<l;e++){const r=e*t/o,l=s.pointAlong(r);n.makePrecise(l),i.add(l,!1)}}}return i.add(t[t.length-1],!1),i.toCoordinateArray()}static densify(t,e){const n=new yn(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){return new xn(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new n("Tolerance must be positive");this._distanceTolerance=t}getClass(){return yn}get interfaces_(){return[]}}class xn extends me{constructor(){super(),xn.constructor_.apply(this,arguments)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformPolygon(t,e){const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=yn.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof Tt&&1===s.length&&(s=new Array(0).fill(null)),this._factory.getCoordinateSequenceFactory().create(s)}createValidArea(t){return t.buffer(0)}getClass(){return xn}get interfaces_(){return[]}}xn.constructor_=function(){this.distanceTolerance=null;const t=arguments[0];this.distanceTolerance=t},yn.DensifyTransformer=xn,yn.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null;const t=arguments[0];this._inputGeom=t};var En=Object.freeze({__proto__:null,Densifier:yn});class In{constructor(){In.constructor_.apply(this,arguments)}static isNorthern(t){return t===In.NE||t===In.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===In.SE?t===In.SE||t===In.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?In.NE:In.SE:e>=0?In.NW:In.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new n("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?In.NE:In.SE:e.y>=t.y?In.NW:In.SW}}getClass(){return In}get interfaces_(){return[]}}In.constructor_=function(){},In.NE=0,In.NW=1,In.SW=2,In.SE=3;class Nn{constructor(){Nn.constructor_.apply(this,arguments)}static init(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t}static create(t,e){const n=new Nn(t),s=new Nn(e);return n.init(s),n}find(t){let e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null}dest(){return this._sym._orig}oNext(){return this._sym._next}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;const e=this.compareTo(t);let n=this;do{const s=n.oNext();if(s.compareTo(t)!==e||s===this)return n.insertAfter(t),null;n=s}while(n!==this);u.shouldNeverReachHere()}insertAfter(t){u.equals(this._orig,t.orig());const e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)}degree(){let t=0,e=this;do{t++,e=e.oNext()}while(e!==this);return t}equals(){if(2===arguments.length&&arguments[1]instanceof g&&arguments[0]instanceof g){const t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}}deltaY(){return this._sym._orig.y-this._orig.y}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){const e=this.deltaX(),n=this.deltaY(),s=t.deltaX(),i=t.deltaY();if(e===s&&n===i)return 0;const r=In.quadrant(e,n),o=In.quadrant(s,i);return r>o?1:r<o?-1:v.index(t._orig,t.dest(),this.dest())}prevNode(){let t=this;for(;2===t.degree();)if(t=t.prev(),t===this)return null;return t}compareTo(t){const e=t;return this.compareAngularDirection(e)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}setNext(t){this._next=t}init(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}deltaX(){return this._sym._orig.x-this._orig.x}getClass(){return Nn}get interfaces_(){return[]}}Nn.constructor_=function(){this._orig=null,this._sym=null,this._next=null;const t=arguments[0];this._orig=t};class Cn extends Nn{constructor(){super(),Cn.constructor_.apply(this,arguments)}static setMarkBoth(t,e){t.setMark(e),t.sym().setMark(e)}static isMarked(t){return t.isMarked()}static setMark(t,e){t.setMark(e)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}getClass(){return Cn}get interfaces_(){return[]}}Cn.constructor_=function(){this._isMarked=!1;const t=arguments[0];Nn.constructor_.call(this,t)};class Sn{constructor(){Sn.constructor_.apply(this,arguments)}static isValidEdge(t,e){return 0!==e.compareTo(t)}insert(t,e,n){const s=this.create(t,e);null!==n?n.insert(s):this._vertexMap.put(t,s);const i=this._vertexMap.get(e);return null!==i?i.insert(s.sym()):this._vertexMap.put(e,s.sym()),s}create(t,e){const n=this.createEdge(t),s=this.createEdge(e);return Nn.init(n,s),n}createEdge(t){return new Nn(t)}addEdge(t,e){if(!Sn.isValidEdge(t,e))return null;const n=this._vertexMap.get(t);let s=null;if(null!==n&&(s=n.find(e)),null!==s)return s;return this.insert(t,e,n)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,e){const n=this._vertexMap.get(t);return null===n?null:n.find(e)}getClass(){return Sn}get interfaces_(){return[]}}Sn.constructor_=function(){this._vertexMap=new Ut};class wn extends Cn{constructor(){super(),wn.constructor_.apply(this,arguments)}setStart(){this._isStart=!0}isStart(){return this._isStart}getClass(){return wn}get interfaces_(){return[]}}wn.constructor_=function(){this._isStart=!1;const t=arguments[0];Cn.constructor_.call(this,t)};class Ln extends Sn{constructor(){super(),Ln.constructor_.apply(this,arguments)}createEdge(t){return new wn(t)}getClass(){return Ln}get interfaces_(){return[]}}Ln.constructor_=function(){};class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static dissolve(t){const e=new Tn;return e.add(t),e.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(t.orig().compareTo(this._ringStartEdge.orig())<0&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()}buildRing(t){const e=new I;let n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){const s=n.next();if(s===t)break;e.add(s.orig().copy(),!1),n=s}e.add(n.dest().copy(),!1),this.addLine(e)}buildLine(t){const e=new I;let n=t;for(this._ringStartEdge=null,Cn.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);const s=n.next();if(s===t)return this.buildRing(this._ringStartEdge),null;e.add(s.orig().copy(),!1),n=s,Cn.markBoth(n)}e.add(n.dest().clone(),!1),this.stackEdges(n.sym()),this.addLine(e)}stackEdges(t){let e=t;do{Cn.isMarked(e)||this._nodeEdgeStack.add(e),e=e.oNext()}while(e!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){const e=t.next();Cn.isMarked(e)||this.process(e)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){const t=this._nodeEdgeStack.pop();Cn.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof q){arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Tt&&this.add(t)}})}else if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof Tt){const t=arguments[0];null===this._factory&&(this._factory=t.getFactory());const e=t.getCoordinateSequence();let n=!1;for(let t=1;t<e.size();t++){const s=this._graph.addEdge(e.getCoordinate(t-1),e.getCoordinate(t));null!==s&&(n||(s.setStart(),n=!0))}}}getClass(){return Tn}get interfaces_(){return[]}}Tn.constructor_=function(){this._result=null,this._factory=null,this._graph=null,this._lines=new x,this._nodeEdgeStack=new on,this._ringStartEdge=null,this._graph=new Ln};var Rn=Object.freeze({__proto__:null,LineDissolver:Tn});class Pn{constructor(){Pn.constructor_.apply(this,arguments)}static opposite(t){return t===Pn.LEFT?Pn.RIGHT:t===Pn.RIGHT?Pn.LEFT:t}getClass(){return Pn}get interfaces_(){return[]}}Pn.constructor_=function(){},Pn.ON=0,Pn.LEFT=1,Pn.RIGHT=2;class vn{constructor(){vn.constructor_.apply(this,arguments)}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}getClass(){return vn}get interfaces_(){return[]}}vn.constructor_=function(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e};class On{constructor(){On.constructor_.apply(this,arguments)}isDelete(){return this._eventType===On.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===On.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}getClass(){return On}get interfaces_(){return[r]}}On.constructor_=function(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=On.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=On.INSERT,this._label=t,this._xValue=e,this._obj=n}},On.INSERT=1,On.DELETE=2;class bn{constructor(){bn.constructor_.apply(this,arguments)}getClass(){return bn}get interfaces_(){return[]}}bn.constructor_=function(){};class Mn{constructor(){Mn.constructor_.apply(this,arguments)}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Mn.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}getClass(){return Mn}get interfaces_(){return[]}}Mn.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n};class Dn extends bn{constructor(){super(),Dn.constructor_.apply(this,arguments)}prepareEvents(){Ee.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof Mn&&_(arguments[0],m)&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&_(arguments[0],m)&&arguments[1]instanceof Mn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),s=n.getStartIndexes();for(let t=0;t<s.length-1;t++){const s=new vn(n,t),i=new On(e,n.getMinX(t),s);this.events.add(i),this.events.add(new On(n.getMaxX(t),i))}}processOverlaps(t,e,n,s){const i=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(i.computeIntersections(e,s),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){const t=n.next();this.addEdge(t,e)}}}getClass(){return Dn}get interfaces_(){return[]}}Dn.constructor_=function(){this.events=new x,this.nOverlaps=null};class An{constructor(){An.constructor_.apply(this,arguments)}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==ne.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===ne.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[Pn.ON]=this.location[Pn.ON],t[Pn.LEFT]=ne.NONE,t[Pn.RIGHT]=ne.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===ne.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[Pn.LEFT];this.location[Pn.LEFT]=this.location[Pn.RIGHT],this.location[Pn.RIGHT]=t}toString(){const t=new w;return this.location.length>1&&t.append(ne.toLocationSymbol(this.location[Pn.LEFT])),t.append(ne.toLocationSymbol(this.location[Pn.ON])),this.location.length>1&&t.append(ne.toLocationSymbol(this.location[Pn.RIGHT])),t.toString()}setLocations(t,e,n){this.location[Pn.ON]=t,this.location[Pn.LEFT]=e,this.location[Pn.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:ne.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===ne.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(Pn.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(ne.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}getClass(){return An}get interfaces_(){return[]}}An.constructor_=function(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[Pn.ON]=t}else if(arguments[0]instanceof An){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[Pn.ON]=t,this.location[Pn.LEFT]=e,this.location[Pn.RIGHT]=n}};class Fn{constructor(){Fn.constructor_.apply(this,arguments)}static toLineLabel(t){const e=new Fn(ne.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new An(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(Pn.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new w;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(Pn.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new An(this.elt[t].location[0]))}getClass(){return Fn}get interfaces_(){return[]}}Fn.constructor_=function(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new An(t),this.elt[1]=new An(t)}else if(arguments[0]instanceof Fn){const t=arguments[0];this.elt[0]=new An(t.elt[0]),this.elt[1]=new An(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new An(ne.NONE),this.elt[1]=new An(ne.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new An(t,e,n),this.elt[1]=new An(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.elt[0]=new An(ne.NONE,ne.NONE,ne.NONE),this.elt[1]=new An(ne.NONE,ne.NONE,ne.NONE),this.elt[t].setLocations(e,n,s)}};class Gn{constructor(){Gn.constructor_.apply(this,arguments)}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}getClass(){return Gn}get interfaces_(){return[r]}}Gn.constructor_=function(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n};class qn{constructor(){qn.constructor_.apply(this,arguments)}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new g(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return i&&(r[o]=e.coord),new Un(r,new Fn(this.edge._label))}add(t,e,n){const s=new Gn(t,e,n),i=this._nodeMap.get(s);return null!==i?i:(this._nodeMap.put(s,s),s)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}getClass(){return qn}get interfaces_(){return[]}}qn.constructor_=function(){this._nodeMap=new rt,this.edge=null;const t=arguments[0];this.edge=t};class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new x;n.add(new L(e));do{const s=this.findChainEnd(t,e);n.add(new L(s)),e=s}while(e<t.length-1);return Bn.toIntArray(n)}findChainEnd(t,e){const n=In.quadrant(t[e],t[e+1]);let s=e+1;for(;s<t.length;){if(In.quadrant(t[s-1],t[s])!==n)break;s++}return s-1}getClass(){return Bn}get interfaces_(){return[]}}Bn.constructor_=function(){};class Vn{constructor(){Vn.constructor_.apply(this,arguments)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],s)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.addIntersections(this.e,t,n.e,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeIntersectsForChain(t,o,n,s,l,r),l<i&&this.computeIntersectsForChain(t,o,n,l,i,r)),o<e&&(s<l&&this.computeIntersectsForChain(o,e,n,s,l,r),l<i&&this.computeIntersectsForChain(o,e,n,l,i,r))}}overlaps(t,e,n,s,i){return N.intersects(this.pts[t],this.pts[e],n.pts[s],n.pts[i])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let s=0;s<t.startIndex.length-1;s++)this.computeIntersectsForChain(n,t,s,e)}getClass(){return Vn}get interfaces_(){return[]}}Vn.constructor_=function(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new Bn;this.startIndex=e.getChainStartIndices(this.pts)};class zn{constructor(){zn.constructor_.apply(this,arguments)}static depthAtLocation(t){return t===ne.EXTERIOR?0:t===ne.INTERIOR?1:zn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==zn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===zn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===zn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let s=0;this._depth[t][n]>e&&(s=1),this._depth[t][n]=s}}}getDelta(t){return this._depth[t][Pn.RIGHT]-this._depth[t][Pn.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?ne.EXTERIOR:ne.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const s=t.getLocation(e,n);s!==ne.EXTERIOR&&s!==ne.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=zn.depthAtLocation(s):this._depth[e][n]+=zn.depthAtLocation(s))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===ne.INTERIOR&&this._depth[t][e]++}}getClass(){return zn}get interfaces_(){return[]}}zn.constructor_=function(){this._depth=Array(2).fill().map(()=>Array(3));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=zn.NULL_VALUE},zn.NULL_VALUE=-1;class Yn{constructor(){Yn.constructor_.apply(this,arguments)}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){u.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}getClass(){return Yn}get interfaces_(){return[]}}Yn.constructor_=function(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}};class Un extends Yn{constructor(){super(),Un.constructor_.apply(this,arguments)}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof se&&arguments[0]instanceof Fn))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,Pn.ON),t.getLocation(1,Pn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,Pn.LEFT),t.getLocation(1,Pn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,Pn.RIGHT),t.getLocation(1,Pn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);return t[0]=this.pts[0],t[1]=this.pts[1],new Un(t,Fn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof Un))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,s=!0,i=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--i])||(s=!1),!n&&!s)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){Un.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Vn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new N;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,s){const i=new g(t.getIntersection(s));let r=e,o=t.getEdgeDistance(n,s);const l=r+1;if(l<this.pts.length){const t=this.pts[l];i.equals2D(t)&&(r=l,o=0)}this.eiList.add(i,r,o)}toString(){const t=new wt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}getClass(){return Un}get interfaces_(){return[]}}Un.constructor_=function(){if(this.pts=null,this._env=null,this.eiList=new qn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new zn,this._depthDelta=0,1===arguments.length){const t=arguments[0];Un.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}};class kn extends Yn{constructor(){super(),kn.constructor_.apply(this,arguments)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=ne.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const s=t.getLocation(e);n!==ne.BOUNDARY&&(n=s)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Fn(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof kn){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Fn){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===ne.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=ne.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case ne.BOUNDARY:n=ne.INTERIOR;break;case ne.INTERIOR:default:n=ne.BOUNDARY}this._label.setLocation(t,n)}getClass(){return kn}get interfaces_(){return[]}}kn.constructor_=function(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Fn(0,ne.NONE)};class Xn{constructor(){Xn.constructor_.apply(this,arguments)}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof g){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof kn){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new x;for(let n=this.iterator();n.hasNext();){const s=n.next();s.getLabel().getLocation(t)===ne.BOUNDARY&&e.add(s)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}getClass(){return Xn}get interfaces_(){return[]}}Xn.constructor_=function(){this.nodeMap=new rt,this.nodeFact=null;const t=arguments[0];this.nodeFact=t};class Hn{constructor(){Hn.constructor_.apply(this,arguments)}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),s=n.lastIndexOf("."),i=n.substring(s+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=In.quadrant(this._dx,this._dy),u.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}getClass(){return Hn}get interfaces_(){return[r]}}Hn.constructor_=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Hn.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hn.constructor_.call(this,t),this.init(e,n),this._label=s}};class Wn extends c{constructor(){if(1===arguments.length){const t=arguments[0];super(t),c.call(this,t)}else{if(2!==arguments.length)throw Error();{const t=arguments[0],e=arguments[1];super(Wn.msgWithCoord(t,e)),this.name="TopologyException",this.pt=new g(e)}}}getCoordinate(){return this.pt}get interfaces_(){return[]}getClass(){return Wn}static msgWithCoord(t,e){return null!==e?t+" [ "+e+" ]":t}}class jn extends Hn{constructor(){super(),jn.constructor_.apply(this,arguments)}static depthFactor(t,e){return t===ne.EXTERIOR&&e===ne.INTERIOR?1:t===ne.INTERIOR&&e===ne.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new Fn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new Wn("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,Pn.LEFT)===ne.INTERIOR&&this._label.getLocation(e,Pn.RIGHT)===ne.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[Pn.LEFT]+"/"+this._depth[Pn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,ne.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,ne.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let s=1;t===Pn.LEFT&&(s=-1);const i=Pn.opposite(t),r=e+n*s;this.setDepth(t,e),this.setDepth(i,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}getClass(){return jn}get interfaces_(){return[]}}jn.constructor_=function(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(Hn.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()};class Kn{constructor(){Kn.constructor_.apply(this,arguments)}createNode(t){return new kn(t,null)}getClass(){return Kn}get interfaces_(){return[]}}Kn.constructor_=function(){};class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof kn){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof g){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){O.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const s=n.getLabel();return null!==s&&s.getLocation(t)===ne.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,s){return!!t.equals(n)&&(v.index(t,e,s)===v.COLLINEAR&&In.quadrant(t,e)===In.quadrant(n,s))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){O.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return s;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return s}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new jn(t,!0),s=new jn(t,!1);n.setSym(s),s.setSym(n),this.add(n),this.add(s)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return s}return null}getClass(){return Zn}get interfaces_(){return[]}}Zn.constructor_=function(){if(this._edges=new x,this._nodes=null,this._edgeEndList=new x,0===arguments.length)this._nodes=new Xn(new Kn);else if(1===arguments.length){const t=arguments[0];this._nodes=new Xn(t)}};class Qn extends Zn{constructor(){super(),Qn.constructor_.apply(this,arguments)}static determineBoundary(t,e){return t.isInBoundary(e)?ne.BOUNDARY:ne.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let s=1,i=ne.NONE;i=n.getLocation(t,Pn.ON),i===ne.BOUNDARY&&s++;const r=Qn.determineBoundary(this._boundaryNodeRule,s);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Mn(t,!0,!1);s.setIsDoneIfProperInt(n);const i=this.createEdgeSetIntersector(),r=this._parentGeom instanceof Dt||this._parentGeom instanceof bt||this._parentGeom instanceof At,o=e||!r;return i.computeIntersections(this._edges,s,o),this.addSelfIntersectionNodes(this._argIndex),s}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const s=new Mn(e,n,!0);return s.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,s),s}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof Pt){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,ne.INTERIOR)}else if(arguments[0]instanceof g){const t=arguments[0];this.insertPoint(this._argIndex,t,ne.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),ne.EXTERIOR,ne.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,ne.INTERIOR,ne.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],ne.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],ne.BOUNDARY)}addLineString(t){const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new Un(e,new Fn(this._argIndex,ne.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),u.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let s=t.iterator();s.hasNext();){const t=s.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===ne.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const s=X.removeRepeatedPoints(t.getCoordinates());if(s.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=s[0],null;let i=e,r=n;v.isCCW(s)&&(i=n,r=e);const o=new Un(s,new Fn(this._argIndex,ne.BOUNDARY,i,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,s[0],ne.BOUNDARY)}insertPoint(t,e,n){const s=this._nodes.addNode(e),i=s.getLabel();null===i?s._label=new Fn(t,n):i.setLocation(t,n)}createEdgeSetIntersector(){return new Dn}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,s)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof q))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof At&&(this._useBoundaryDeterminationRule=!1),t instanceof bt)this.addPolygon(t);else if(t instanceof Tt)this.addLineString(t);else if(t instanceof Pt)this.addPoint(t);else if(t instanceof Mt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else if(t instanceof At)this.addCollection(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return _(this._parentGeom,Ot)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new ke(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof Tt){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}getClass(){return Qn}get interfaces_(){return[]}}Qn.constructor_=function(){if(this._parentGeom=null,this._lineEdgeMap=new Ut,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new _n,2===arguments.length){const t=arguments[0],e=arguments[1];Qn.constructor_.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}};var Jn=Object.freeze({__proto__:null,GeometryGraph:Qn});class $n{constructor(){$n.constructor_.apply(this,arguments)}visit(t){}getClass(){return $n}get interfaces_(){return[]}}$n.constructor_=function(){};class ts{constructor(){ts.constructor_.apply(this,arguments)}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}getClass(){return ts}get interfaces_(){return[]}}ts.constructor_=function(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new g(t),this._left=null,this._right=null,this._count=1,this._data=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new g(t,e),this._left=null,this._right=null,this._count=1,this._data=n}};class es{constructor(){es.constructor_.apply(this,arguments)}static toCoordinates(){if(1===arguments.length){const t=arguments[0];return es.toCoordinates(t,!1)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new I;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e?t.getCount():1;for(let e=0;e<i;e++)n.add(t.getCoordinate(),!0)}return n.toCoordinateArray()}}insert(){if(1===arguments.length){const t=arguments[0];return this.insert(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(null===this._root)return this._root=new ts(t,e),this._root;if(this._tolerance>0){const e=this.findBestMatchNode(t);if(null!==e)return e.increment(),e}return this.insertExact(t,e)}}query(){if(1===arguments.length){const t=arguments[0],e=new x;return this.query(t,e),e}if(2===arguments.length)if(arguments[0]instanceof N&&_(arguments[1],m)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[$n]}visit(t){e.add(t)}})}else if(arguments[0]instanceof N&&_(arguments[1],$n)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,e)}}queryNode(t,e,n,s){if(null===t)return null;let i=null,r=null,o=null;n?(i=e.getMinX(),r=e.getMaxX(),o=t.getX()):(i=e.getMinY(),r=e.getMaxY(),o=t.getY());const l=o<=r;i<o&&this.queryNode(t.getLeft(),e,!n,s),e.contains(t.getCoordinate())&&s.visit(t),l&&this.queryNode(t.getRight(),e,!n,s)}findBestMatchNode(t){const e=new ns(t,this._tolerance);return this.query(e.queryEnvelope(),e),e.getNode()}isEmpty(){return null===this._root}insertExact(t,e){let n=this._root,s=this._root,i=!0,r=!0;for(;null!==n;){if(null!==n){if(t.distance(n.getCoordinate())<=this._tolerance)return n.increment(),n}r=i?t.x<n.getX():t.y<n.getY(),s=n,n=r?n.getLeft():n.getRight(),i=!i}this._numberOfNodes=this._numberOfNodes+1;const o=new ts(t,e);return r?s.setLeft(o):s.setRight(o),o}getClass(){return es}get interfaces_(){return[]}}class ns{constructor(){ns.constructor_.apply(this,arguments)}visit(t){const e=this._p.distance(t.getCoordinate());if(!(e<=this._tolerance))return null;let n=!1;(null===this._matchNode||e<this._matchDist||null!==this._matchNode&&e===this._matchDist&&t.getCoordinate().compareTo(this._matchNode.getCoordinate())<1)&&(n=!0),n&&(this._matchNode=t,this._matchDist=e)}queryEnvelope(){const t=new N(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}getClass(){return ns}get interfaces_(){return[$n]}}ns.constructor_=function(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;const t=arguments[0],e=arguments[1];this._p=t,this._tolerance=e},es.BestMatchVisitor=ns,es.constructor_=function(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0===arguments.length)es.constructor_.call(this,0);else if(1===arguments.length){const t=arguments[0];this._tolerance=t}};var ss=Object.freeze({__proto__:null,KdTree:es});class is{constructor(){is.constructor_.apply(this,arguments)}static getSubnodeIndex(t,e,n){let s=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(s=3),t.getMaxY()<=n&&(s=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(s=2),t.getMaxY()<=n&&(s=0)),s}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let e=0;e<4;e++)null!==this._subnode[e]&&this._subnode[e].addAllItems(t);return t}getNodeCount(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+1}size(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+this._items.size()}addAllItemsFromOverlapping(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this._items);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].addAllItemsFromOverlapping(t,e)}visitItems(t,e){for(let t=this._items.iterator();t.hasNext();)e.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,e){if(!this.isSearchMatch(t))return!1;let n=!1;for(let s=0;s<4;s++)if(null!==this._subnode[s]&&(n=this._subnode[s].remove(t,e),n)){this._subnode[s].isPrunable()&&(this._subnode[s]=null);break}return n||(n=this._items.remove(e),n)}visit(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].visit(t,e)}getItems(){return this._items}depth(){let t=0;for(let e=0;e<4;e++)if(null!==this._subnode[e]){const n=this._subnode[e].depth();n>t&&(t=n)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let e=0;e<4;e++)if(null!==this._subnode[e]&&!this._subnode[e].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}getClass(){return is}get interfaces_(){return[a]}}function rs(){}is.constructor_=function(){this._items=new x,this._subnode=new Array(4).fill(null)},rs.exponent=function(t){return function(t,e){let n,s,i,r;const o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},l={32:8,64:11}[t];r||(n=e<0||1/e<0,isFinite(e)||(r=o[t],n&&(r.d+=1<<t/4-1),s=Math.pow(2,l)-1,i=0));if(!r){for(s={32:127,64:1023}[t],i=Math.abs(e);i>=2;)s++,i/=2;for(;i<1&&s>0;)s--,i*=2;s<=0&&(i/=2),32===t&&s>254&&(r={d:n?255:127,c:128,b:0,a:0},s=Math.pow(2,l)-1,i=0)}return s}(64,t)-1023},rs.powerOf2=function(t){return Math.pow(2,t)};class os{constructor(){os.constructor_.apply(this,arguments)}static computeQuadLevel(t){const e=t.getWidth(),n=t.getHeight(),s=e>n?e:n;return rs.exponent(s)+1}getLevel(){return this._level}computeKey(){if(1===arguments.length){const t=arguments[0];for(this._level=os.computeQuadLevel(t),this._env=new N,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=rs.powerOf2(t);this._pt.x=Math.floor(e.getMinX()/n)*n,this._pt.y=Math.floor(e.getMinY()/n)*n,this._env.init(this._pt.x,this._pt.x+n,this._pt.y,this._pt.y+n)}}getEnvelope(){return this._env}getCentre(){return new g((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}getClass(){return os}get interfaces_(){return[]}}os.constructor_=function(){this._pt=new g,this._level=0,this._env=null;const t=arguments[0];this.computeKey(t)};class ls extends is{constructor(){super(),ls.constructor_.apply(this,arguments)}static createNode(t){const e=new os(t);return new ls(e.getEnvelope(),e.getLevel())}static createExpanded(t,e){const n=new N(e);null!==t&&n.expandToInclude(t._env);const s=ls.createNode(n);return null!==t&&s.insertNode(t),s}find(t){const e=is.getSubnodeIndex(t,this._centrex,this._centrey);if(-1===e)return this;if(null!==this._subnode[e]){return this._subnode[e].find(t)}return this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){const e=is.getSubnodeIndex(t,this._centrex,this._centrey);if(-1!==e){return this.getSubnode(e).getNode(t)}return this}createSubnode(t){let e=0,n=0,s=0,i=0;switch(t){case 0:e=this._env.getMinX(),n=this._centrex,s=this._env.getMinY(),i=this._centrey;break;case 1:e=this._centrex,n=this._env.getMaxX(),s=this._env.getMinY(),i=this._centrey;break;case 2:e=this._env.getMinX(),n=this._centrex,s=this._centrey,i=this._env.getMaxY();break;case 3:e=this._centrex,n=this._env.getMaxX(),s=this._centrey,i=this._env.getMaxY()}const r=new N(e,n,s,i);return new ls(r,this._level-1)}insertNode(t){u.isTrue(null===this._env||this._env.contains(t._env));const e=is.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[e]=t;else{const n=this.createSubnode(e);n.insertNode(t),this._subnode[e]=n}}getClass(){return ls}get interfaces_(){return[]}}ls.constructor_=function(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;const t=arguments[0],e=arguments[1];this._env=t,this._level=e,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2};class as{constructor(){as.constructor_.apply(this,arguments)}static isZeroWidth(t,e){const n=e-t;if(0===n)return!0;const s=n/Math.max(Math.abs(t),Math.abs(e));return rs.exponent(s)<=as.MIN_BINARY_EXPONENT}getClass(){return as}get interfaces_(){return[]}}as.constructor_=function(){},as.MIN_BINARY_EXPONENT=-50;class cs extends is{constructor(){super(),cs.constructor_.apply(this,arguments)}insert(t,e){const n=is.getSubnodeIndex(t,cs.origin.x,cs.origin.y);if(-1===n)return this.add(e),null;const s=this._subnode[n];if(null===s||!s.getEnvelope().contains(t)){const e=ls.createExpanded(s,t);this._subnode[n]=e}this.insertContained(this._subnode[n],t,e)}isSearchMatch(t){return!0}insertContained(t,e,n){u.isTrue(t.getEnvelope().contains(e));const s=as.isZeroWidth(e.getMinX(),e.getMaxX()),i=as.isZeroWidth(e.getMinY(),e.getMaxY());let r=null;r=s||i?t.find(e):t.getNode(e),r.add(n)}getClass(){return cs}get interfaces_(){return[]}}cs.constructor_=function(){},cs.origin=new g(0,0);class hs{constructor(){hs.constructor_.apply(this,arguments)}insert(t,e){}remove(t,e){}query(){}getClass(){return hs}get interfaces_(){return[]}}hs.constructor_=function(){};class us{constructor(){us.constructor_.apply(this,arguments)}static ensureExtent(t,e){let n=t.getMinX(),s=t.getMaxX(),i=t.getMinY(),r=t.getMaxY();return n!==s&&i!==r?t:(n===s&&(n-=e/2,s=n+e/2),i===r&&(i-=e/2,r=i+e/2),new N(n,s,i,r))}size(){return null!==this._root?this._root.size():0}insert(t,e){this.collectStats(t);const n=us.ensureExtent(t,this._minExtent);this._root.insert(n,e)}query(){if(1===arguments.length){const t=arguments[0],e=new Ye;return this.query(t,e),e.getItems()}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._root.visit(t,e)}}queryAll(){const t=new x;return this._root.addAllItems(t),t}remove(t,e){const n=us.ensureExtent(t,this._minExtent);return this._root.remove(n,e)}collectStats(t){const e=t.getWidth();e<this._minExtent&&e>0&&(this._minExtent=e);const n=t.getHeight();n<this._minExtent&&n>0&&(this._minExtent=n)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}getClass(){return us}get interfaces_(){return[hs,a]}}us.constructor_=function(){this._root=null,this._minExtent=1,this._root=new cs},us.serialVersionUID=-0x678b60c967a25400;var gs=Object.freeze({__proto__:null,Quadtree:us});class ds{constructor(){ds.constructor_.apply(this,arguments)}getBounds(){}getClass(){return ds}get interfaces_(){return[]}}ds.constructor_=function(){};class _s{constructor(){_s.constructor_.apply(this,arguments)}getItem(){return this._item}getBounds(){return this._bounds}getClass(){return _s}get interfaces_(){return[ds,a]}}_s.constructor_=function(){this._bounds=null,this._item=null;const t=arguments[0],e=arguments[1];this._bounds=t,this._item=e};class fs{constructor(){fs.constructor_.apply(this,arguments)}poll(){if(this.isEmpty())return null;const t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let e=null;const n=this._items.get(t);for(;2*t<=this._size&&(e=2*t,e!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}clear(){this._size=0,this._items.clear()}peek(){if(this.isEmpty())return null;return this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}getClass(){return fs}get interfaces_(){return[]}}fs.constructor_=function(){this._size=null,this._items=null,this._size=0,this._items=new x,this._items.add(null)};class ps{constructor(){ps.constructor_.apply(this,arguments)}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){u.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}getClass(){return ps}get interfaces_(){return[ds,a]}}ps.constructor_=function(){if(this._childBoundables=new x,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._level=t}},ps.serialVersionUID=0x5a1e55ec41369800;class ms{constructor(){ms.constructor_.apply(this,arguments)}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof ps}expandToQueue(t,e){const s=ms.isComposite(this._boundable1),i=ms.isComposite(this._boundable2);if(s&&i)return ms.area(this._boundable1)>ms.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,t,e),null):(this.expand(this._boundable2,this._boundable1,t,e),null);if(s)return this.expand(this._boundable1,this._boundable2,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,t,e),null;throw new n("neither boundable is composite")}isLeaves(){return!(ms.isComposite(this._boundable1)||ms.isComposite(this._boundable2))}compareTo(t){const e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}expand(t,e,n,s){for(let i=t.getChildBoundables().iterator();i.hasNext();){const t=i.next(),r=new ms(t,e,this._itemDistance);r.getDistance()<s&&n.add(r)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}getClass(){return ms}get interfaces_(){return[r]}}ms.constructor_=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()};class ys{constructor(){ys.constructor_.apply(this,arguments)}static compareDoubles(t,e){return t>e?1:t<e?-1:0}queryInternal(){if(_(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof ps){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getChildBoundables();for(let e=0;e<s.size();e++){const i=s.get(e);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof ps?this.queryInternal(t,i,n):i instanceof _s?n.visitItem(i.getItem()):u.shouldNeverReachHere())}}else if(_(arguments[2],m)&&arguments[0]instanceof Object&&arguments[1]instanceof ps){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getChildBoundables();for(let e=0;e<s.size();e++){const i=s.get(e);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof ps?this.queryInternal(t,i,n):i instanceof _s?n.add(i.getItem()):u.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();n instanceof ps?t+=this.size(n):n instanceof _s&&(t+=1)}return t}}removeItem(t,e){let n=null;for(let s=t.getChildBoundables().iterator();s.hasNext();){const t=s.next();t instanceof _s&&t.getItem()===e&&(n=t)}return null!==n&&(t.getChildBoundables().remove(n),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this._root);return null===t?new x:t}if(1===arguments.length){const t=arguments[0],e=new x;for(let n=t.getChildBoundables().iterator();n.hasNext();){const t=n.next();if(t instanceof ps){const n=this.itemsTree(t);null!==n&&e.add(n)}else t instanceof _s?e.add(t.getItem()):u.shouldNeverReachHere()}return e.size()<=0?null:e}}insert(t,e){u.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new _s(t,e))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],e=new x;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(u.isTrue(t>-2),e.getLevel()===t)return n.add(e),null;for(let s=e.getChildBoundables().iterator();s.hasNext();){const e=s.next();e instanceof ps?this.boundablesAtLevel(t,e,n):(u.isTrue(e instanceof _s),-1===t&&n.add(e))}return null}}query(){if(1===arguments.length){const t=arguments[0];this.build();const e=new x;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=this.removeItem(e,n);if(s)return!0;let i=null;for(let r=e.getChildBoundables().iterator();r.hasNext();){const e=r.next();if(this.getIntersectsOp().intersects(e.getBounds(),t)&&(e instanceof ps&&(s=this.remove(t,e,n),s))){i=e;break}}return null!==i&&i.getChildBoundables().isEmpty()&&e.getChildBoundables().remove(i),s}}createHigherLevels(t,e){u.isTrue(!t.isEmpty());const n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();if(n instanceof ps){const e=this.depth(n);e>t&&(t=e)}}return t+1}}createParentBoundables(t,e){u.isTrue(!t.isEmpty());const n=new x;n.add(this.createNode(e));const s=new x(t);Ee.sort(s,this.getComparator());for(let t=s.iterator();t.hasNext();){const s=t.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}getClass(){return ys}get interfaces_(){return[a]}}ys.IntersectsOp=function(){},ys.constructor_=function(){if(this._root=null,this._built=!1,this._itemBoundables=new x,this._nodeCapacity=null,0===arguments.length)ys.constructor_.call(this,ys.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];u.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}},ys.serialVersionUID=-0x35ef64c82d4c5400,ys.DEFAULT_NODE_CAPACITY=10;class xs{constructor(){xs.constructor_.apply(this,arguments)}distance(t,e){}getClass(){return xs}get interfaces_(){return[]}}xs.constructor_=function(){};class Es extends ys{constructor(){super(),Es.constructor_.apply(this,arguments)}static centreX(t){return Es.avg(t.getMinX(),t.getMaxX())}static avg(t,e){return(t+e)/2}static getItems(t){const e=new Array(t.size()).fill(null);let n=0;for(;!t.isEmpty();){const s=t.poll();e[n]=s.getBoundable(0).getItem(),n++}return e}static centreY(t){return Es.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,e){u.isTrue(t.length>0);const n=new x;for(let s=0;s<t.length;s++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[s],e));return n}createNode(t){return new Is(t)}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N))return super.insert.apply(this,arguments);{const t=arguments[0],e=arguments[1];if(t.isNull())return null;super.insert.call(this,t,e)}}getIntersectsOp(){return Es.intersectsOp}verticalSlices(t,e){const n=Math.trunc(Math.ceil(t.size()/e)),s=new Array(e).fill(null),i=t.iterator();for(let t=0;t<e;t++){s[t]=new x;let e=0;for(;i.hasNext()&&e<n;){const n=i.next();s[t].add(n),e++}}return s}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];super.query.call(this,t,e)}}getComparator(){return Es.yComparator}createParentBoundablesFromVerticalSlice(t,e){return super.createParentBoundables.call(this,t,e)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N){const t=arguments[0],e=arguments[1];return super.remove.call(this,t,e)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,e){u.isTrue(!t.isEmpty());const n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),s=new x(t);Ee.sort(s,Es.xComparator);const i=this.verticalSlices(s,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}nearestNeighbour(){if(1===arguments.length){if(_(arguments[0],xs)){const t=arguments[0],e=new ms(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof ms){const t=arguments[0];return this.nearestNeighbour(t,i.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof Es&&_(arguments[1],xs)){const t=arguments[0],e=arguments[1],n=new ms(this.getRoot(),t.getRoot(),e);return this.nearestNeighbour(n)}if(arguments[0]instanceof ms&&"number"==typeof arguments[1]){const t=arguments[0];let e=arguments[1],n=null;const s=new fs;for(s.add(t);!s.isEmpty()&&e>0;){const t=s.poll(),i=t.getDistance();if(i>=e)break;t.isLeaves()?(e=i,n=t):t.expandToQueue(s,e)}return[n.getBoundable(0).getItem(),n.getBoundable(1).getItem()]}if(arguments[0]instanceof ms&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];return this.nearestNeighbour(t,i.POSITIVE_INFINITY,e)}}else if(3===arguments.length){if(_(arguments[2],xs)&&arguments[0]instanceof N&&arguments[1]instanceof Object){const t=arguments[0],e=arguments[1],n=arguments[2],s=new _s(t,e),i=new ms(this.getRoot(),s,n);return this.nearestNeighbour(i)[0]}if(Number.isInteger(arguments[2])&&arguments[0]instanceof ms&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];let s=e;const i=new fs;i.add(t);const r=new fs;for(;!i.isEmpty()&&s>=0;){const t=i.poll(),e=t.getDistance();if(e>=s)break;if(t.isLeaves())if(r.size()<n)r.add(t);else{r.peek().getDistance()>e&&(r.poll(),r.add(t)),s=r.peek().getDistance()}else t.expandToQueue(i,s)}return Es.getItems(r)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new _s(t,e),r=new ms(this.getRoot(),i,n);return this.nearestNeighbour(r,s)}}getClass(){return Es}get interfaces_(){return[hs,a]}}class Is extends ps{constructor(){super(),Is.constructor_.apply(this,arguments)}computeBounds(){let t=null;for(let e=this.getChildBoundables().iterator();e.hasNext();){const n=e.next();null===t?t=new N(n.getBounds()):t.expandToInclude(n.getBounds())}return t}getClass(){return Is}get interfaces_(){return[]}}Is.constructor_=function(){const t=arguments[0];ps.constructor_.call(this,t)},Es.STRtreeNode=Is,Es.constructor_=function(){if(0===arguments.length)Es.constructor_.call(this,Es.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];ys.constructor_.call(this,t)}},Es.serialVersionUID=0x39920f7d5f261e0,Es.xComparator=new class{get interfaces_(){return[l]}compare(t,e){return ys.compareDoubles(Es.centreX(t.getBounds()),Es.centreX(e.getBounds()))}},Es.yComparator=new class{get interfaces_(){return[l]}compare(t,e){return ys.compareDoubles(Es.centreY(t.getBounds()),Es.centreY(e.getBounds()))}},Es.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,e){return t.intersects(e)}},Es.DEFAULT_NODE_CAPACITY=10;var Ns=Object.freeze({__proto__:null,STRtree:Es}),Cs=Object.freeze({__proto__:null,kdtree:ss,quadtree:gs,strtree:Ns});const Ss=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class ws{constructor(t){this.geometryFactory=t||new Ht}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!Ls[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==Ss.indexOf(n)?Ls[n].call(this,e.coordinates):"GeometryCollection"===n?Ls[n].call(this,e.geometries):Ls[n].call(this,e)}write(t){const e=t.getGeometryType();if(!Ts[e])throw new Error("Geometry is not supported");return Ts[e].call(this,t)}}const Ls={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!Ls[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Ls.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(new g(s[0],s[1]))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){const e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Ls.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=Ls.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Ls.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=Ls.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),s=[];for(let e=1;e<t.length;++e){const n=t[e],i=Ls.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(i);s.push(r)}return this.geometryFactory.createPolygon(n,s)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(Ls.Polygon.call(this,s))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(this.read(s))}return this.geometryFactory.createGeometryCollection(e)}},Ts={coordinate:function(t){return[t.x,t.y]},Point:function(t){return{type:"Point",coordinates:Ts.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.Point.call(this,s);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const s=n[t];e.push(Ts.coordinate.call(this,s))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.LineString.call(this,s);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=Ts.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const s=t._holes[n],i=Ts.LineString.call(this,s);e.push(i.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.Polygon.call(this,s);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=s.getGeometryType();e.push(Ts[i].call(this,s))}return{type:"GeometryCollection",geometries:e}}};function Rs(t){return[t.x,t.y]}var Ps=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new ws(t||new Ht)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new ws(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,e){this.geometryFactory=t||new Ht,this.ol=e||"undefined"!=typeof ol&&ol}inject(t,e,n,s,i,r,o,l){this.ol={geom:{Point:t,LineString:e,LinearRing:n,Polygon:s,MultiPoint:i,MultiLineString:r,MultiPolygon:o,GeometryCollection:l}}}read(t){const e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){const e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map((function(t){return new g(t[0],t[1])})))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t){return new g(t[0],t[1])})))}convertFromPolygon(t){const e=t.getLinearRings();let n=null;const s=[];for(let t=0;t<e.length;t++){const i=this.convertFromLinearRing(e[t]);0===t?n=i:s.push(i)}return this.geometryFactory.createPolygon(n,s)}convertFromMultiPoint(t){const e=t.getPoints().map((function(t){return this.convertFromPoint(t)}),this);return this.geometryFactory.createMultiPoint(e)}convertFromMultiLineString(t){const e=t.getLineStrings().map((function(t){return this.convertFromLineString(t)}),this);return this.geometryFactory.createMultiLineString(e)}convertFromMultiPolygon(t){const e=t.getPolygons().map((function(t){return this.convertFromPolygon(t)}),this);return this.geometryFactory.createMultiPolygon(e)}convertFromCollection(t){const e=t.getGeometries().map((function(t){return this.read(t)}),this);return this.geometryFactory.createGeometryCollection(e)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){const e=t._points._coordinates.map(Rs);return new this.ol.geom.LineString(e)}convertToLinearRing(t){const e=t._points._coordinates.map(Rs);return new this.ol.geom.LinearRing(e)}convertToPolygon(t){const e=[t._shell._points._coordinates.map(Rs)];for(let n=0;n<t._holes.length;n++)e.push(t._holes[n]._points._coordinates.map(Rs));return new this.ol.geom.Polygon(e)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Rs))}convertToMultiLineString(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)}convertToMultiPolygon(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)}convertToCollection(t){const e=[];for(let n=0;n<t._geometries.length;n++){const s=t._geometries[n];e.push(this.write(s))}return new this.ol.geom.GeometryCollection(e)}},WKTReader:class{constructor(t){this.parser=new Kt(t||new Ht)}read(t){return this.parser.read(t)}},WKTWriter:Jt});class vs{constructor(){vs.constructor_.apply(this,arguments)}static relativeSign(t,e){return t<e?-1:t>e?1:0}static compare(t,e,n){if(e.equals2D(n))return 0;const s=vs.relativeSign(e.x,n.x),i=vs.relativeSign(e.y,n.y);switch(t){case 0:return vs.compareValue(s,i);case 1:return vs.compareValue(i,s);case 2:return vs.compareValue(i,-s);case 3:return vs.compareValue(-s,i);case 4:return vs.compareValue(-s,-i);case 5:return vs.compareValue(-i,-s);case 6:return vs.compareValue(-i,s);case 7:return vs.compareValue(s,-i)}return u.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}getClass(){return vs}get interfaces_(){return[]}}vs.constructor_=function(){};class Os{constructor(){Os.constructor_.apply(this,arguments)}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){const e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:vs.compare(this._segmentOctant,this.coord,e.coord)}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}isInterior(){return this._isInterior}getClass(){return Os}get interfaces_(){return[r]}}Os.constructor_=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._segString=t,this.coord=new g(e),this.segmentIndex=n,this._segmentOctant=s,this._isInterior=!e.equals2D(t.getCoordinate(n))};class bs{constructor(){bs.constructor_.apply(this,arguments)}getSplitCoordinates(){const t=new I;this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next();this.addEdgeCoordinates(n,s,t),n=s}return t.toCoordinateArray()}addCollapsedNodes(){const t=new x;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let e=t.iterator();e.hasNext();){const t=e.next().intValue();this.add(this._edge.getCoordinate(t),t)}}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}findCollapsesFromExistingVertices(t){for(let e=0;e<this._edge.size()-2;e++){const n=this._edge.getCoordinate(e),s=(this._edge.getCoordinate(e+1),this._edge.getCoordinate(e+2));n.equals2D(s)&&t.add(new L(e+1))}}addEdgeCoordinates(t,e,n){e.segmentIndex,t.segmentIndex;const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);n.add(new g(t.coord),!1);for(let s=t.segmentIndex+1;s<=e.segmentIndex;s++)n.add(this._edge.getCoordinate(s));i&&n.add(new g(e.coord))}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}findCollapseIndex(t,e,n){if(!t.coord.equals2D(e.coord))return!1;let s=e.segmentIndex-t.segmentIndex;return e.isInterior()||s--,1===s&&(n[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){const e=new Array(1).fill(null),n=this.iterator();let s=n.next();for(;n.hasNext();){const i=n.next();this.findCollapseIndex(s,i,e)&&t.add(new L(e[0])),s=i}}getEdge(){return this._edge}addEndpoints(){const t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new g(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this._edge.getCoordinate(n);return i&&(r[o]=new g(e.coord)),new Fs(r,this._edge.getData())}add(t,e){const n=new Os(this._edge,t,e,this._edge.getSegmentOctant(e)),s=this._nodeMap.get(n);return null!==s?(u.isTrue(s.coord.equals2D(t),"Found equal nodes with different coordinates"),s):(this._nodeMap.put(n,n),n)}checkSplitEdgesCorrectness(t){const e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new c("bad split edge start point at "+n);const s=t.get(t.size()-1).getCoordinates(),i=s[s.length-1];if(!i.equals2D(e[e.length-1]))throw new c("bad split edge end point at "+i)}getClass(){return bs}get interfaces_(){return[]}}bs.constructor_=function(){this._nodeMap=new rt,this._edge=null;const t=arguments[0];this._edge=t};class Ms{constructor(){Ms.constructor_.apply(this,arguments)}static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Cannot compute the octant for point ( "+t+", "+e+" )");const s=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?s>=i?0:1:s>=i?7:6:e>=0?s>=i?3:2:s>=i?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],s=e.x-t.x,i=e.y-t.y;if(0===s&&0===i)throw new n("Cannot compute the octant for two identical points "+t);return Ms.octant(s,i)}}getClass(){return Ms}get interfaces_(){return[]}}Ms.constructor_=function(){};class Ds{constructor(){Ds.constructor_.apply(this,arguments)}getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}getClass(){return Ds}get interfaces_(){return[]}}Ds.constructor_=function(){};class As{constructor(){As.constructor_.apply(this,arguments)}addIntersection(t,e){}getClass(){return As}get interfaces_(){return[Ds]}}As.constructor_=function(){};class Fs{constructor(){Fs.constructor_.apply(this,arguments)}static getNodedSubstrings(){if(1===arguments.length){const t=arguments[0],e=new x;return Fs.getNodedSubstrings(t,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){n.next().getNodeList().addSplitEdges(e)}}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,e){return t.equals2D(e)?0:Ms.octant(t,e)}getData(){return this._data}addIntersection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[3],s=new g(t.getIntersection(n));this.addIntersection(s,e)}}toString(){return Jt.toLineString(new zt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,e){let n=e;const s=n+1;if(s<this._pts.length){const e=this._pts[s];t.equals2D(e)&&(n=s)}return this._nodeList.add(t,n)}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}getClass(){return Fs}get interfaces_(){return[As]}}Fs.constructor_=function(){this._nodeList=new bs(this),this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e};class Gs{constructor(){Gs.constructor_.apply(this,arguments)}overlap(){if(2===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t.getLineSegment(e,this._overlapSeg1),n.getLineSegment(s,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}getClass(){return Gs}get interfaces_(){return[]}}Gs.constructor_=function(){this._overlapSeg1=new ee,this._overlapSeg2=new ee};class qs{constructor(){qs.constructor_.apply(this,arguments)}getLineSegment(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}computeSelect(t,e,n,s){const i=this._pts[e],r=this._pts[n];if(n-e==1)return s.select(this,e),null;if(!t.intersects(i,r))return null;const o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,s),o<n&&this.computeSelect(t,o,n,s)}getCoordinates(){const t=new Array(this._end-this._start+1).fill(null);let e=0;for(let n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}computeOverlaps(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.overlap(this,t,n,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeOverlaps(t,o,n,s,l,r),l<i&&this.computeOverlaps(t,o,n,l,i,r)),o<e&&(s<l&&this.computeOverlaps(o,e,n,s,l,r),l<i&&this.computeOverlaps(o,e,n,l,i,r))}}setId(t){this._id=t}select(t,e){this.computeSelect(t,this._start,this._end,e)}getEnvelope(){if(null===this._env){const t=this._pts[this._start],e=this._pts[this._end];this._env=new N(t,e)}return this._env}overlaps(t,e,n,s,i){return N.intersects(this._pts[t],this._pts[e],n._pts[s],n._pts[i])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}getClass(){return qs}get interfaces_(){return[]}}qs.constructor_=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=s};class Bs{constructor(){Bs.constructor_.apply(this,arguments)}static getChainStartIndices(t){let e=0;const n=new x;n.add(new L(e));do{const s=Bs.findChainEnd(t,e);n.add(new L(s)),e=s}while(e<t.length-1);return Bs.toIntArray(n)}static findChainEnd(t,e){let n=e;for(;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;const s=In.quadrant(t[n],t[n+1]);let i=e+1;for(;i<t.length;){if(!t[i-1].equals2D(t[i])){if(In.quadrant(t[i-1],t[i])!==s)break}i++}return i-1}static getChains(){if(1===arguments.length){const t=arguments[0];return Bs.getChains(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new x,s=Bs.getChainStartIndices(t);for(let i=0;i<s.length-1;i++){const r=new qs(t,s[i],s[i+1],e);n.add(r)}return n}}static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getClass(){return Bs}get interfaces_(){return[]}}Bs.constructor_=function(){};class Vs{constructor(){Vs.constructor_.apply(this,arguments)}computeNodes(t){}getNodedSubstrings(){}getClass(){return Vs}get interfaces_(){return[]}}Vs.constructor_=function(){};class zs{constructor(){zs.constructor_.apply(this,arguments)}setSegmentIntersector(t){this._segInt=t}getClass(){return zs}get interfaces_(){return[Vs]}}zs.constructor_=function(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setSegmentIntersector(t)}};class Ys extends zs{constructor(){super(),Ys.constructor_.apply(this,arguments)}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Fs.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let e=Bs.getChains(t.getCoordinates(),t).iterator();e.hasNext();){const t=e.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}intersectChains(){const t=new Us(this._segInt);for(let e=this._monoChains.iterator();e.hasNext();){const n=e.next();for(let e=this._index.query(n.getEnvelope()).iterator();e.hasNext();){const s=e.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this._nOverlaps++),this._segInt.isDone())return null}}}getClass(){return Ys}get interfaces_(){return[]}}class Us extends Gs{constructor(){super(),Us.constructor_.apply(this,arguments)}overlap(){if(4!==arguments.length)return super.overlap.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.getContext(),r=n.getContext();this._si.processIntersections(i,e,r,s)}}getClass(){return Us}get interfaces_(){return[]}}Us.constructor_=function(){this._si=null;const t=arguments[0];this._si=t},Ys.SegmentOverlapAction=Us,Ys.constructor_=function(){if(this._monoChains=new x,this._index=new Es,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];zs.constructor_.call(this,t)}};class ks{constructor(){ks.constructor_.apply(this,arguments)}rescale(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.rescale(e.getCoordinates())}}else if(arguments[0]instanceof Array){const t=arguments[0];let e=null,n=null;2===t.length&&(e=new g(t[0]),n=new g(t[1]));for(let e=0;e<t.length;e++)t[e].x=t[e].x/this._scaleFactor+this._offsetX,t[e].y=t[e].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&O.out.println(t)}}scale(){if(_(arguments[0],f)){const t=arguments[0],e=new x(t.size());for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Fs(this.scale(t.getCoordinates()),t.getData()))}return e}if(arguments[0]instanceof Array){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new g(Math.round((t[n].x-this._offsetX)*this._scaleFactor),Math.round((t[n].y-this._offsetY)*this._scaleFactor),t[n].z);return X.removeRepeatedPoints(e)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){const t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}getClass(){return ks}get interfaces_(){return[Vs]}}ks.constructor_=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){const t=arguments[0],e=arguments[1];ks.constructor_.call(this,t,e,0,0)}else if(4===arguments.length){const t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._isScaled=!this.isIntegerPrecision()}};var Xs=Object.freeze({__proto__:null,MCIndexNoder:Ys,ScaledNoder:ks,SegmentString:Ds});class Hs{constructor(){Hs.constructor_.apply(this,arguments)}static isSimple(){if(1===arguments.length){const t=arguments[0];return new Hs(t).isSimple()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Hs(t,e).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;const e=new at;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getCoordinate();if(e.contains(s))return this._nonSimpleLocation=s,!1;e.add(s)}return!0}isSimplePolygonal(t){for(let e=xe.getLines(t).iterator();e.hasNext();){const t=e.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){const e=new rt;for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=(t.getMaximumSegmentIndex(),t.isClosed()),i=t.getCoordinate(0);this.addEndpoint(e,i,s);const r=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(e,r,s)}for(let t=e.values().iterator();t.hasNext();){const e=t.next();if(e.isClosed&&2!==e.degree)return this._nonSimpleLocation=e.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;const e=new Qn(0,t),n=new te,s=e.computeSelfNodes(n,!0);return!s.hasIntersection()||(s.hasProperIntersection()?(this._nonSimpleLocation=s.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))}hasNonEndpointIntersection(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next(),n=t.getMaximumSegmentIndex();for(let e=t.getEdgeIntersectionList().iterator();e.hasNext();){const t=e.next();if(!t.isEndPoint(n))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,e,n){let s=t.get(e);null===s&&(s=new Ws(e),t.put(e,s)),s.addEndpoint(n)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof Tt||t instanceof ft?this.isSimpleLinearGeometry(t):t instanceof Mt?this.isSimpleMultiPoint(t):_(t,Ot)?this.isSimplePolygonal(t):!(t instanceof _t)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0}getClass(){return Hs}get interfaces_(){return[]}}class Ws{constructor(){Ws.constructor_.apply(this,arguments)}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}getClass(){return Ws}get interfaces_(){return[]}}Ws.constructor_=function(){this.pt=null,this.isClosed=null,this.degree=null;const t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0},Hs.EndpointInfo=Ws,Hs.constructor_=function(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1===arguments.length){const t=arguments[0];this._inputGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!e.isInBoundary(2)}};class js{constructor(){js.constructor_.apply(this,arguments)}static bufferDistanceError(t){const e=Math.PI/2/t;return 1-Math.cos(e/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=js.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=js.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==js.JOIN_ROUND&&(this._quadrantSegments=js.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}getClass(){return js}get interfaces_(){return[]}}js.constructor_=function(){if(this._quadrantSegments=js.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=js.CAP_ROUND,this._joinStyle=js.JOIN_ROUND,this._mitreLimit=js.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=js.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(e),this.setJoinStyle(n),this.setMitreLimit(s)}},js.CAP_ROUND=1,js.CAP_FLAT=2,js.CAP_SQUARE=3,js.JOIN_ROUND=1,js.JOIN_MITRE=2,js.JOIN_BEVEL=3,js.DEFAULT_QUADRANT_SEGMENTS=8,js.DEFAULT_MITRE_LIMIT=5,js.DEFAULT_SIMPLIFY_FACTOR=.01;class Ks{constructor(){Ks.constructor_.apply(this,arguments)}getCoordinate(){return this._minCoord}getRightmostSide(t,e){let n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}findRightmostEdgeAtVertex(){const t=this._minDe.getEdge().getCoordinates();u.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");const e=t[this._minIndex-1],n=t[this._minIndex+1],s=v.index(this._minCoord,n,e);let i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&s===v.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&s===v.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,e){const n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;let s=Pn.LEFT;return n[e].y<n[e+1].y&&(s=Pn.RIGHT),s}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){const e=t.getEdge().getCoordinates();for(let n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}findRightmostEdgeAtNode(){const t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let e=t.iterator();e.hasNext();){const t=e.next();t.isForward()&&this.checkForRightmostCoordinate(t)}u.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe,this.getRightmostSide(this._minDe,this._minIndex)===Pn.LEFT&&(this._orientedDe=this._minDe.getSym())}getClass(){return Ks}get interfaces_(){return[]}}function Zs(){this.array_=[]}Ks.constructor_=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null},Zs.prototype.addLast=function(t){this.array_.push(t)},Zs.prototype.removeFirst=function(){return this.array_.shift()},Zs.prototype.isEmpty=function(){return 0===this.array_.length};class Qs{constructor(){Qs.constructor_.apply(this,arguments)}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let e=null;for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();if(t.isVisited()||t.getSym().isVisited()){e=t;break}}if(null===e)throw new Wn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(let e=t.getEdges().iterator();e.hasNext();){const t=e.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();const e=this._finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(Pn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){const e=t.next();e.getDepth(Pn.RIGHT)>=1&&e.getDepth(Pn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}computeDepths(t){const e=new J,n=new Zs,s=t.getNode();for(n.addLast(s),e.add(s),t.setVisited(!0);!n.isEmpty();){const t=n.removeFirst();e.add(t),this.computeNodeDepth(t);for(let s=t.getEdges().iterator();s.hasNext();){const t=s.next().getSym();if(t.isVisited())continue;const i=t.getNode();e.contains(i)||(n.addLast(i),e.add(i))}}}compareTo(t){const e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){const t=new N;for(let e=this._dirEdgeList.iterator();e.hasNext();){const n=e.next().getEdge().getCoordinates();for(let e=0;e<n.length-1;e++)t.expandToInclude(n[e])}this._env=t}return this._env}addReachable(t){const e=new on;for(e.add(t);!e.empty();){const t=e.pop();this.add(t,e)}}copySymDepths(t){const e=t.getSym();e.setDepth(Pn.LEFT,t.getDepth(Pn.RIGHT)),e.setDepth(Pn.RIGHT,t.getDepth(Pn.LEFT))}add(t,e){t.setVisited(!0),this._nodes.add(t);for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();this._dirEdgeList.add(t);const s=t.getSym().getNode();s.isVisited()||e.push(s)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}getClass(){return Qs}get interfaces_(){return[r]}}Qs.constructor_=function(){this._finder=null,this._dirEdgeList=new x,this._nodes=new x,this._rightMostCoord=null,this._env=null,this._finder=new Ks};class Js{constructor(){Js.constructor_.apply(this,arguments)}computeRing(){if(null!==this._ring)return null;const t=new Array(this._pts.size()).fill(null);for(let e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=v.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let e=t,n=!0;do{if(null===e)throw new Wn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new Wn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);const t=e.getLabel();u.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{const e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,e,n){const s=t.getCoordinates();if(e){let t=1;n&&(t=0);for(let e=t;e<s.length;e++)this._pts.add(s[e])}else{let t=s.length-2;n&&(t=s.length-1);for(let e=t;e>=0;e--)this._pts.add(s[e])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}containsPoint(t){const e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!We.isInRing(t,e.getCoordinates()))return!1;for(let e=this._holes.iterator();e.hasNext();){if(e.next().containsPoint(t))return!1}return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(e,Pn.RIGHT);if(n===ne.NONE)return null;if(this._label.getLocation(e)===ne.NONE)return this._label.setLocation(e,n),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){const e=new Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)e[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}getClass(){return Js}get interfaces_(){return[]}}Js.constructor_=function(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new x,this._pts=new x,this._label=new Fn(ne.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new x,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}};class $s extends Js{constructor(){super(),$s.constructor_.apply(this,arguments)}setEdgeRing(t,e){t.setMinEdgeRing(e)}getNext(t){return t.getNextMin()}getClass(){return $s}get interfaces_(){return[]}}$s.constructor_=function(){const t=arguments[0],e=arguments[1];Js.constructor_.call(this,t,e)};class ti extends Js{constructor(){super(),ti.constructor_.apply(this,arguments)}buildMinimalRings(){const t=new x;let e=this._startDe;do{if(null===e.getMinEdgeRing()){const n=new $s(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}setEdgeRing(t,e){t.setEdgeRing(e)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}getNext(t){return t.getNext()}getClass(){return ti}get interfaces_(){return[]}}ti.constructor_=function(){const t=arguments[0],e=arguments[1];Js.constructor_.call(this,t,e)};class ei{constructor(){ei.constructor_.apply(this,arguments)}sortShellsAndHoles(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()?n.add(t):e.add(t)}}computePolygons(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next().toPolygon(this._geometryFactory);e.add(t)}return e}placeFreeHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(null===e.getShell()){const n=this.findEdgeRingContaining(e,t);if(null===n)throw new Wn("unable to assign hole to a shell",e.getCoordinate(0));e.setShell(n)}}}buildMinimalEdgeRings(t,e,n){const s=new x;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();const s=t.buildMinimalRings(),i=this.findShell(s);null!==i?(this.placePolygonHoles(i,s),e.add(i)):n.addAll(s)}else s.add(t)}return s}containsPoint(t){for(let e=this._shellList.iterator();e.hasNext();){if(e.next().containsPoint(t))return!0}return!1}buildMaximalEdgeRings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){const n=new ti(t,this._geometryFactory);e.add(n),n.setInResult()}}return e}placePolygonHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();e.isHole()&&e.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findEdgeRingContaining(t,e){const n=t.getLinearRing(),s=n.getEnvelopeInternal(),i=n.getCoordinateN(0);let r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),n=e.getLinearRing(),l=n.getEnvelopeInternal();null!==r&&(o=r.getLinearRing().getEnvelopeInternal());let a=!1;l.contains(s)&&We.isInRing(i,n.getCoordinates())&&(a=!0),a&&(null===r||o.contains(l))&&(r=e)}return r}findShell(t){let e=0,n=null;for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()||(n=t,e++)}return u.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}add(){if(1===arguments.length){const t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Zn.linkResultDirectedEdges(e);const n=this.buildMaximalEdgeRings(t),s=new x,i=this.buildMinimalEdgeRings(n,this._shellList,s);this.sortShellsAndHoles(i,this._shellList,s),this.placeFreeHoles(this._shellList,s)}}getClass(){return ei}get interfaces_(){return[]}}ei.constructor_=function(){this._geometryFactory=null,this._shellList=new x;const t=arguments[0];this._geometryFactory=t};class ni{constructor(){ni.constructor_.apply(this,arguments)}static simplify(t,e){return new ni(t).simplify(e)}isDeletable(t,e,n,s){const i=this._inputLine[t],r=this._inputLine[e],o=this._inputLine[n];return!!this.isConcave(i,r,o)&&(!!this.isShallow(i,r,o,s)&&this.isShallowSampled(i,r,t,n,s))}deleteShallowConcavities(){let t=1;this._inputLine.length;let e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),s=!1;for(;n<this._inputLine.length;){let i=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=ni.DELETE,i=!0,s=!0),t=i?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return s}isShallowConcavity(t,e,n,s){return v.index(t,e,n)===this._angleOrientation&&D.pointToSegment(e,t,n)<s}isShallowSampled(t,e,n,s,i){let r=Math.trunc((s-n)/ni.NUM_PTS_TO_CHECK);r<=0&&(r=1);for(let o=n;o<s;o+=r)if(!this.isShallow(t,e,this._inputLine[o],i))return!1;return!0}isConcave(t,e,n){return v.index(t,e,n)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=v.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);let e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}findNextNonDeletedIndex(t){let e=t+1;for(;e<this._inputLine.length&&this._isDeleted[e]===ni.DELETE;)e++;return e}isShallow(t,e,n,s){return D.pointToSegment(e,t,n)<s}collapseLine(){const t=new I;for(let e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==ni.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()}getClass(){return ni}get interfaces_(){return[]}}ni.constructor_=function(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=v.COUNTERCLOCKWISE;const t=arguments[0];this._inputLine=t},ni.INIT=0,ni.DELETE=1,ni.KEEP=1,ni.NUM_PTS_TO_CHECK=10;class si{constructor(){si.constructor_.apply(this,arguments)}getCoordinates(){return this._ptList.toArray(si.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){const e=new g(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}reverse(){}addPts(t,e){if(e)for(let e=0;e<t.length;e++)this.addPt(t[e]);else for(let e=t.length-1;e>=0;e--)this.addPt(t[e])}isRedundant(t){if(this._ptList.size()<1)return!1;const e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}toString(){return(new Ht).createLineString(this.getCoordinates()).toString()}closeRing(){if(this._ptList.size()<1)return null;const t=new g(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);let n=null;if(this._ptList.size()>=2&&this._ptList.get(this._ptList.size()-2),t.equals(e))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}getClass(){return si}get interfaces_(){return[]}}si.constructor_=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new x},si.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);class ii{constructor(){ii.constructor_.apply(this,arguments)}addNextSegment(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;const n=v.index(this._s0,this._s1,this._s2),s=n===v.CLOCKWISE&&this._side===Pn.LEFT||n===v.COUNTERCLOCKWISE&&this._side===Pn.RIGHT;0===n?this.addCollinear(e):s?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}addLineEndCap(t,e){const n=new ee(t,e),s=new ee;this.computeOffsetSegment(n,Pn.LEFT,this._distance,s);const i=new ee;this.computeOffsetSegment(n,Pn.RIGHT,this._distance,i);const r=e.x-t.x,o=e.y-t.y,l=Math.atan2(o,r);switch(this._bufParams.getEndCapStyle()){case js.CAP_ROUND:this._segList.addPt(s.p1),this.addDirectedFillet(e,l+Math.PI/2,l-Math.PI/2,v.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case js.CAP_FLAT:this._segList.addPt(s.p1),this._segList.addPt(i.p1);break;case js.CAP_SQUARE:const t=new g;t.x=Math.abs(this._distance)*Math.cos(l),t.y=Math.abs(this._distance)*Math.sin(l);const n=new g(s.p1.x+t.x,s.p1.y+t.y),r=new g(i.p1.x+t.x,i.p1.y+t.y);this._segList.addPt(n),this._segList.addPt(r)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,e,n,s){let i=!0,r=null;try{r=b.intersection(e.p0,e.p1,n.p0,n.p1),(s<=0?1:r.distance(t)/Math.abs(s))>this._bufParams.getMitreLimit()&&(i=!1)}catch(t){if(!(t instanceof S))throw t;r=new g(0,0),i=!1}i?this._segList.addPt(r):this.addLimitedMitreJoin(e,n,s,this._bufParams.getMitreLimit())}addOutsideTurn(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*ii.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===js.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===js.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new g(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new g(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,e){this._segList.addPts(t,e)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,e,n,s,i){const r=e.x-t.x,o=e.y-t.y;let l=Math.atan2(o,r);const a=n.x-t.x,c=n.y-t.y,h=Math.atan2(c,a);s===v.CLOCKWISE?l<=h&&(l+=2*Math.PI):l>=h&&(l-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,l,h,s,i),this._segList.addPt(n)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}addLimitedMitreJoin(t,e,n,s){const i=this._seg0.p1,r=ie.angle(i,this._seg0.p0),o=(ie.angle(i,this._seg1.p1),ie.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2),l=ie.normalize(r+o),a=ie.normalize(l+Math.PI),c=s*n,h=n-c*Math.abs(Math.sin(o)),u=i.x+c*Math.cos(a),d=i.y+c*Math.sin(a),_=new g(u,d),f=new ee(i,_),p=f.pointAlongOffset(1,h),m=f.pointAlongOffset(1,-h);this._side===Pn.LEFT?(this._segList.addPt(p),this._segList.addPt(m)):(this._segList.addPt(m),this._segList.addPt(p))}addDirectedFillet(t,e,n,s,i){const r=s===v.CLOCKWISE?-1:1,o=Math.abs(e-n),l=Math.trunc(o/this._filletAngleQuantum+.5);if(l<1)return null;let a=null,c=null;a=0,c=o/l;let h=0;const u=new g;for(;h<o;){const n=e+r*h;u.x=t.x+i*Math.cos(n),u.y=t.y+i*Math.sin(n),this._segList.addPt(u),h+=c}}computeOffsetSegment(t,e,n,s){const i=e===Pn.LEFT?1:-1,r=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,l=Math.sqrt(r*r+o*o),a=i*n*r/l,c=i*n*o/l;s.p0.x=t.p0.x-c,s.p0.y=t.p0.y+a,s.p1.x=t.p1.x-c,s.p1.y=t.p1.y+a}addInsideTurn(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*ii.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){const t=new g((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);const e=new g((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(e)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){const e=new g(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new si,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*ii.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2),this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===js.JOIN_BEVEL||this._bufParams.getJoinStyle()===js.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,v.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}getClass(){return ii}get interfaces_(){return[]}}ii.constructor_=function(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new ee,this._seg1=new ee,this._offset0=new ee,this._offset1=new ee,this._side=0,this._hasNarrowConcaveAngle=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._bufParams=e,this._li=new te,this._filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===js.JOIN_ROUND&&(this._closingSegLengthFactor=ii.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)},ii.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,ii.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,ii.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,ii.MAX_CLOSING_SEG_LEN_FACTOR=80;class ri{constructor(){ri.constructor_.apply(this,arguments)}static copyCoordinates(t){const e=new Array(t.length).fill(null);for(let n=0;n<e.length;n++)e[n]=new g(t[n]);return e}getOffsetCurve(t,e){if(this._distance=e,0===e)return null;const n=e<0,s=Math.abs(e),i=this.getSegGen(s);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);const r=i.getCoordinates();return n&&X.reverse(r),r}computeSingleSidedBufferCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);const e=ni.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Pn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{n.addSegments(t,!1);const e=ni.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Pn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment(),n.closeRing()}computeRingBufferCurve(t,e,n){let s=this.simplifyTolerance(this._distance);e===Pn.RIGHT&&(s=-s);const i=ni.simplify(t,s),r=i.length-1;n.initSideSegments(i[r-1],i[0],e);for(let t=1;t<=r;t++){const e=1!==t;n.addNextSegment(i[t],e)}n.closeRing()}computeLineBufferCurve(t,e){const n=this.simplifyTolerance(this._distance),s=ni.simplify(t,n),i=s.length-1;e.initSideSegments(s[0],s[1],Pn.LEFT);for(let t=2;t<=i;t++)e.addNextSegment(s[t],!0);e.addLastSegment(),e.addLineEndCap(s[i-1],s[i]);const r=ni.simplify(t,-n),o=r.length-1;e.initSideSegments(r[o],r[o-1],Pn.LEFT);for(let t=o-2;t>=0;t--)e.addNextSegment(r[t],!0);e.addLastSegment(),e.addLineEndCap(r[1],r[0]),e.closeRing()}computePointCurve(t,e){switch(this._bufParams.getEndCapStyle()){case js.CAP_ROUND:e.createCircle(t);break;case js.CAP_SQUARE:e.createSquare(t)}}getLineCurve(t,e){if(this._distance=e,e<0&&!this._bufParams.isSingleSided())return null;if(0===e)return null;const n=Math.abs(e),s=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],s);else if(this._bufParams.isSingleSided()){const n=e<0;this.computeSingleSidedBufferCurve(t,n,s)}else this.computeLineBufferCurve(t,s);return s.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return ri.copyCoordinates(t);const s=this.getSegGen(n);return this.computeRingBufferCurve(t,e,s),s.getCoordinates()}computeOffsetCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){const e=ni.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Pn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{const e=ni.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Pn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment()}getSegGen(t){return new ii(this._precisionModel,this._bufParams,t)}getClass(){return ri}get interfaces_(){return[]}}ri.constructor_=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;const t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e};class oi{constructor(){oi.constructor_.apply(this,arguments)}findStabbedSegments(){if(1===arguments.length){const t=arguments[0],e=new x;for(let n=this._subgraphs.iterator();n.hasNext();){const s=n.next(),i=s.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,s.getDirectedEdges(),e)}return e}if(3===arguments.length)if(_(arguments[2],m)&&arguments[0]instanceof g&&arguments[1]instanceof jn){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getEdge().getCoordinates();for(let i=0;i<s.length-1;i++){if(this._seg.p0=s[i],this._seg.p1=s[i+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse(),Math.max(this._seg.p0.x,this._seg.p1.x)<t.x)continue;if(this._seg.isHorizontal())continue;if(t.y<this._seg.p0.y||t.y>this._seg.p1.y)continue;if(v.index(this._seg.p0,this._seg.p1,t)===v.RIGHT)continue;let r=e.getDepth(Pn.LEFT);this._seg.p0.equals(s[i])||(r=e.getDepth(Pn.RIGHT));const o=new li(this._seg,r);n.add(o)}}else if(_(arguments[2],m)&&arguments[0]instanceof g&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=e.iterator();s.hasNext();){const e=s.next();e.isForward()&&this.findStabbedSegments(t,e,n)}}}getDepth(t){const e=this.findStabbedSegments(t);return 0===e.size()?0:Ee.min(e)._leftDepth}getClass(){return oi}get interfaces_(){return[]}}class li{constructor(){li.constructor_.apply(this,arguments)}compareTo(t){const e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;let n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg),0!==n?n:this._upwardSeg.compareTo(e._upwardSeg))}compareX(t,e){const n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}toString(){return this._upwardSeg.toString()}getClass(){return li}get interfaces_(){return[r]}}li.constructor_=function(){this._upwardSeg=null,this._leftDepth=null;const t=arguments[0],e=arguments[1];this._upwardSeg=new ee(t),this._leftDepth=e},oi.DepthSegment=li,oi.constructor_=function(){this._subgraphs=null,this._seg=new ee;const t=arguments[0];this._subgraphs=t};class ai{constructor(){ai.constructor_.apply(this,arguments)}addPoint(t){if(this._distance<=0)return null;const e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,ne.EXTERIOR,ne.INTERIOR)}addPolygon(t){let e=this._distance,n=Pn.LEFT;this._distance<0&&(e=-this._distance,n=Pn.RIGHT);const s=t.getExteriorRing(),i=X.removeRepeatedPoints(s.getCoordinates());if(this._distance<0&&this.isErodedCompletely(s,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addPolygonRing(i,e,n,ne.EXTERIOR,ne.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s),r=X.removeRepeatedPoints(i.getCoordinates());this._distance>0&&this.isErodedCompletely(i,-this._distance)||this.addPolygonRing(r,e,Pn.opposite(n),ne.INTERIOR,ne.EXTERIOR)}}isTriangleErodedCompletely(t,e){const n=new re(t[0],t[1],t[2]),s=n.inCentre();return D.pointToSegment(s,n.p0,n.p1)<Math.abs(e)}addLineString(t){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;const e=X.removeRepeatedPoints(t.getCoordinates()),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,ne.EXTERIOR,ne.INTERIOR)}addCurve(t,e,n){if(null===t||t.length<2)return null;const s=new Fs(t,new Fn(0,ne.BOUNDARY,e,n));this._curveList.add(s)}getCurves(){return this.add(this._inputGeom),this._curveList}addPolygonRing(t,e,n,s,i){if(0===e&&t.length<Dt.MINIMUM_VALID_SIZE)return null;let r=s,o=i;t.length>=Dt.MINIMUM_VALID_SIZE&&v.isCCW(t)&&(r=i,o=s,n=Pn.opposite(n));const l=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(l,r,o)}add(t){if(t.isEmpty())return null;if(t instanceof bt)this.addPolygon(t);else if(t instanceof Tt)this.addLineString(t);else if(t instanceof Pt)this.addPoint(t);else if(t instanceof Mt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else if(t instanceof At)this.addCollection(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.addCollection(t)}}isErodedCompletely(t,e){const n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);const s=t.getEnvelopeInternal(),i=Math.min(s.getHeight(),s.getWidth());return e<0&&2*Math.abs(e)>i}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}getClass(){return ai}get interfaces_(){return[]}}ai.constructor_=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new x;const t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n};class ci{constructor(){ci.constructor_.apply(this,arguments)}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=ne.NONE;for(let n=this.iterator();n.hasNext();){const s=n.next().getLabel();s.isArea(t)&&s.getLocation(t,Pn.LEFT)!==ne.NONE&&(e=s.getLocation(t,Pn.LEFT))}if(e===ne.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const s=e.next(),i=s.getLabel();if(i.getLocation(t,Pn.ON)===ne.NONE&&i.setLocation(t,Pn.ON,n),i.isArea(t)){const e=i.getLocation(t,Pn.LEFT),r=i.getLocation(t,Pn.RIGHT);if(r!==ne.NONE){if(r!==n)throw new Wn("side location conflict",s.getCoordinate());e===ne.NONE&&u.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),n=e}else u.isTrue(i.getLocation(t,Pn.LEFT)===ne.NONE,"found single null side"),i.setLocation(t,Pn.RIGHT,n),i.setLocation(t,Pn.LEFT,n)}}}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}print(t){O.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,s=e.get(n).getLabel().getLocation(t,Pn.LEFT);u.isTrue(s!==ne.NONE,"Found unlabelled area edge");let i=s;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();u.isTrue(n.isArea(t),"Found non-area edge");const s=n.getLocation(t,Pn.LEFT),r=n.getLocation(t,Pn.RIGHT);if(s===r)return!1;if(r!==i)return!1;i=s}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new x(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===ne.NONE&&(this._ptInAreaLocation[t]=Ze.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new w;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===ne.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const s=n.next(),i=s.getLabel();for(let n=0;n<2;n++)if(i.isAnyNull(n)){let r=ne.NONE;if(e[n])r=ne.EXTERIOR;else{const e=s.getCoordinate();r=this.getLocation(n,e,t)}i.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}getClass(){return ci}get interfaces_(){return[]}}ci.constructor_=function(){this._edgeMap=new rt,this._edgeList=null,this._ptInAreaLocation=[ne.NONE,ne.NONE]};class hi extends ci{constructor(){super(),hi.constructor_.apply(this,arguments)}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,e=null,n=this._SCANNING_FOR_INCOMING;for(let s=0;s<this._resultAreaEdgeList.size();s++){const i=this._resultAreaEdgeList.get(s),r=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!r.isInResult())continue;e=r,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new Wn("no outgoing dirEdge found",this.getCoordinate());u.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}insert(t){const e=t;this.insertEdgeEnd(e,e)}getRightmostEdge(){const t=this.getEdges(),e=t.size();if(e<1)return null;const n=t.get(0);if(1===e)return n;const s=t.get(e-1),i=n.getQuadrant(),r=s.getQuadrant();return In.isNorthern(i)&&In.isNorthern(r)?n:In.isNorthern(i)||In.isNorthern(r)?0!==n.getDy()?n:0!==s.getDy()?s:(u.shouldNeverReachHere("found two horizontal edges incident on node"),null):s}print(t){O.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){const n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new x;for(let t=this.iterator();t.hasNext();){const e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}updateLabelling(t){for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,e=null;for(let n=this._edgeList.size()-1;n>=0;n--){const s=this._edgeList.get(n),i=s.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=s}e.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],e=this.findIndex(t),n=t.getDepth(Pn.LEFT),s=t.getDepth(Pn.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==s)throw new Wn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[0],e=arguments[1];let n=arguments[2];for(let s=t;s<e;s++){const t=this._edgeList.get(s);t.setEdgeDepths(Pn.RIGHT,n),n=t.getDepth(Pn.LEFT)}return n}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const e=t.next();e.getLabel().merge(e.getSym().getLabel())}}linkMinimalDirectedEdges(t){let e=null,n=null,s=this._SCANNING_FOR_INCOMING;for(let i=this._resultAreaEdgeList.size()-1;i>=0;i--){const r=this._resultAreaEdgeList.get(i),o=r.getSym();switch(null===e&&r.getEdgeRing()===t&&(e=r),s){case this._SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,s=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(r.getEdgeRing()!==t)continue;n.setNextMin(r),s=this._SCANNING_FOR_INCOMING}}s===this._LINKING_TO_OUTGOING&&(u.isTrue(null!==e,"found null for first outgoing dirEdge"),u.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){const t=arguments[0];let e=0;for(let n=this.iterator();n.hasNext();){n.next().getEdgeRing()===t&&e++}return e}}getLabel(){return this._label}findCoveredLineEdges(){let t=ne.NONE;for(let e=this.iterator();e.hasNext();){const n=e.next(),s=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=ne.INTERIOR;break}if(s.isInResult()){t=ne.EXTERIOR;break}}}if(t===ne.NONE)return null;let e=t;for(let t=this.iterator();t.hasNext();){const n=t.next(),s=n.getSym();n.isLineEdge()?n.getEdge().setCovered(e===ne.INTERIOR):(n.isInResult()&&(e=ne.EXTERIOR),s.isInResult()&&(e=ne.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new Fn(ne.NONE);for(let t=this.iterator();t.hasNext();){const e=t.next().getEdge().getLabel();for(let t=0;t<2;t++){const n=e.getLocation(t);n!==ne.INTERIOR&&n!==ne.BOUNDARY||this._label.setLocation(t,ne.INTERIOR)}}}getClass(){return hi}get interfaces_(){return[]}}hi.constructor_=function(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2};class ui extends Kn{constructor(){super(),ui.constructor_.apply(this,arguments)}createNode(t){return new kn(t,new hi)}getClass(){return ui}get interfaces_(){return[]}}ui.constructor_=function(){};class gi{constructor(){gi.constructor_.apply(this,arguments)}static orientation(t){return 1===X.increasingDirection(t)}static compareOriented(t,e,n,s){const i=e?1:-1,r=s?1:-1,o=e?t.length:-1,l=s?n.length:-1;let a=e?0:t.length-1,c=s?0:n.length-1;for(;;){const e=t[a].compareTo(n[c]);if(0!==e)return e;a+=i,c+=r;const s=a===o,h=c===l;if(s&&!h)return-1;if(!s&&h)return 1;if(s&&h)return 0}}compareTo(t){const e=t;return gi.compareOriented(this._pts,this._orientation,e._pts,e._orientation)}getClass(){return gi}get interfaces_(){return[r]}}gi.constructor_=function(){this._pts=null,this._orientation=null;const t=arguments[0];this._pts=t,this._orientation=gi.orientation(t)};class di{constructor(){di.constructor_.apply(this,arguments)}print(t){t.print("MULTILINESTRING ( ");for(let e=0;e<this._edges.size();e++){const n=this._edges.get(e);e>0&&t.print(","),t.print("(");const s=n.getCoordinates();for(let e=0;e<s.length;e++)e>0&&t.print(","),t.print(s[e].x+" "+s[e].y);t.println(")")}t.print(")  ")}addAll(t){for(let e=t.iterator();e.hasNext();)this.add(e.next())}findEdgeIndex(t){for(let e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){const e=new gi(t.getCoordinates());return this._ocaMap.get(e)}add(t){this._edges.add(t);const e=new gi(t.getCoordinates());this._ocaMap.put(e,t)}getClass(){return di}get interfaces_(){return[]}}di.constructor_=function(){this._edges=new x,this._ocaMap=new rt};class _i{constructor(){_i.constructor_.apply(this,arguments)}processIntersections(t,e,n,s){}isDone(){}getClass(){return _i}get interfaces_(){return[]}}_i.constructor_=function(){};class fi{constructor(){fi.constructor_.apply(this,arguments)}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(fi.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.size()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}getClass(){return fi}get interfaces_(){return[_i]}}fi.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;const t=arguments[0];this._li=t};class pi{constructor(){pi.constructor_.apply(this,arguments)}static depthDelta(t){const e=t.getLocation(0,Pn.LEFT),n=t.getLocation(0,Pn.RIGHT);return e===ne.INTERIOR&&n===ne.EXTERIOR?1:e===ne.EXTERIOR&&n===ne.INTERIOR?-1:0}static convertSegStrings(t){const e=new Ht,n=new x;for(;t.hasNext();){const s=t.next(),i=e.createLineString(s.getCoordinates());n.add(i)}return e.buildGeometry(n)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Fn(t.getLabel()),s.flip()),n.merge(s);const i=pi.depthDelta(s),r=e.getDepthDelta()+i;e.setDepthDelta(r)}else this._edgeList.add(t),t.setDepthDelta(pi.depthDelta(t.getLabel()))}buildSubgraphs(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=t.getRightmostCoordinate(),r=new oi(n).getDepth(i);t.computeDepth(r),t.findResultEdges(),n.add(t),e.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){const e=new x;for(let n=t.getNodes().iterator();n.hasNext();){const t=n.next();if(!t.isVisited()){const n=new Qs;n.create(t),e.add(n)}}return Ee.sort(e,Ee.reverseOrder()),e}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;const e=new Ys,n=new te;return n.setPrecisionModel(t),e.setSegmentIntersector(new fi(n)),e}buffer(t,e){let n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();const s=new ri(n,this._bufParams),i=new ai(t,e,s).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new Zn(new ui),this._graph.addEdges(this._edgeList.getEdges());const r=this.createSubgraphs(this._graph),o=new ei(this._geomFact);this.buildSubgraphs(r,o);const l=o.getPolygons();return l.size()<=0?this.createEmptyResultGeometry():this._geomFact.buildGeometry(l)}computeNodedEdges(t,e){const n=this.getNoder(e);n.computeNodes(t);for(let t=n.getNodedSubstrings().iterator();t.hasNext();){const e=t.next(),n=e.getCoordinates();if(2===n.length&&n[0].equals2D(n[1]))continue;const s=e.getData(),i=new Un(e.getCoordinates(),new Fn(s));this.insertUniqueEdge(i)}}setNoder(t){this._workingNoder=t}getClass(){return pi}get interfaces_(){return[]}}pi.constructor_=function(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new di;const t=arguments[0];this._bufParams=t};class mi{constructor(){mi.constructor_.apply(this,arguments)}checkEndPtVertexIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length){const t=arguments[0];for(let e=arguments[1].iterator();e.hasNext();){const n=e.next().getCoordinates();for(let e=1;e<n.length-1;e++)if(n[e].equals(t))throw new c("found endpt/interior pt intersection at index "+e+" :pt "+t)}}}checkInteriorIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();for(let t=this._segStrings.iterator();t.hasNext();){const n=t.next();this.checkInteriorIntersections(e,n)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates(),s=e.getCoordinates();for(let i=0;i<n.length-1;i++)for(let n=0;n<s.length-1;n++)this.checkInteriorIntersections(t,i,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,i,r)||this.hasInteriorIntersection(this._li,o,l)))throw new c("found non-noded intersection at "+i+"-"+r+" and "+o+"-"+l)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();this.checkCollapses(e)}else if(1===arguments.length){const t=arguments[0].getCoordinates();for(let e=0;e<t.length-2;e++)this.checkCollapse(t[e],t[e+1],t[e+2])}}hasInteriorIntersection(t,e,n){for(let s=0;s<t.getIntersectionNum();s++){const i=t.getIntersection(s);if(!i.equals(e)&&!i.equals(n))return!0}return!1}checkCollapse(t,e,n){if(t.equals(n))throw new c("found non-noded collapse at "+mi.fact.createLineString([t,e,n]))}getClass(){return mi}get interfaces_(){return[]}}mi.constructor_=function(){this._li=new te,this._segStrings=null;const t=arguments[0];this._segStrings=t},mi.fact=new Ht;class yi{constructor(){yi.constructor_.apply(this,arguments)}intersectsScaled(t,e){const n=Math.min(t.x,e.x),s=Math.max(t.x,e.x),i=Math.min(t.y,e.y),r=Math.max(t.y,e.y),o=this._maxx<n||this._minx>s||this._maxy<i||this._miny>r;if(o)return!1;const l=this.intersectsToleranceSquare(t,e);return u.isTrue(!(o&&l),"Found bad envelope test"),l}initCorners(t){this._minx=t.x-.5,this._maxx=t.x+.5,this._miny=t.y-.5,this._maxy=t.y+.5,this._corner[0]=new g(this._maxx,this._maxy),this._corner[1]=new g(this._minx,this._maxy),this._corner[2]=new g(this._minx,this._miny),this._corner[3]=new g(this._maxx,this._miny)}intersects(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){const t=yi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new N(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,e){let n=!1,s=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(s=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!s)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))}addSnappedNode(t,e){const n=t.getCoordinate(e),s=t.getCoordinate(e+1);return!!this.intersects(n,s)&&(t.addIntersection(this.getCoordinate(),e),!0)}getClass(){return yi}get interfaces_(){return[]}}yi.constructor_=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;const t=arguments[0],e=arguments[1],s=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=s,e<=0)throw new n("Scale factor must be non-zero");1!==e&&(this._pt=new g(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new g,this._p1Scaled=new g),this.initCorners(this._pt)},yi.SAFE_ENV_EXPANSION_FACTOR=.75;class xi{constructor(){xi.constructor_.apply(this,arguments)}select(){if(1===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}}getClass(){return xi}get interfaces_(){return[]}}xi.constructor_=function(){this.selectedSegment=new ee};class Ei{constructor(){Ei.constructor_.apply(this,arguments)}snap(){if(1===arguments.length){const t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getSafeEnvelope(),i=new Ii(t,e,n);return this._index.query(s,new class{get interfaces_(){return[Ae]}visitItem(t){t.select(s,i)}}),i.isNodeAdded()}}getClass(){return Ei}get interfaces_(){return[]}}class Ii extends xi{constructor(){super(),Ii.constructor_.apply(this,arguments)}isNodeAdded(){return this._isNodeAdded}select(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof qs))return super.select.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=t.getContext();if(null!==this._parentEdge&&n===this._parentEdge&&e===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(n,e)}}getClass(){return Ii}get interfaces_(){return[]}}Ii.constructor_=function(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n},Ei.HotPixelSnapAction=Ii,Ei.constructor_=function(){this._index=null;const t=arguments[0];this._index=t};class Ni{constructor(){Ni.constructor_.apply(this,arguments)}processIntersections(t,e,n,s){if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}getClass(){return Ni}get interfaces_(){return[_i]}}Ni.constructor_=function(){this._li=null,this._interiorIntersections=null;const t=arguments[0];this._li=t,this._interiorIntersections=new x};class Ci{constructor(){Ci.constructor_.apply(this,arguments)}checkCorrectness(t){const e=Fs.getNodedSubstrings(t),n=new mi(e);try{n.checkValid()}catch(t){if(!(t instanceof C))throw t;t.printStackTrace()}}getNodedSubstrings(){return Fs.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,e){const n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}findInteriorIntersections(t,e){const n=new Ni(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}computeVertexSnaps(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.computeVertexSnaps(e)}}else if(arguments[0]instanceof Fs){const t=arguments[0],e=t.getCoordinates();for(let n=0;n<e.length;n++){const s=new yi(e[n],this._scaleFactor,this._li);this._pointSnapper.snap(s,t,n)&&t.addIntersection(e[n],n)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new Ys,this._pointSnapper=new Ei(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=new yi(t,this._scaleFactor,this._li);this._pointSnapper.snap(n)}}getClass(){return Ci}get interfaces_(){return[Vs]}}Ci.constructor_=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;const t=arguments[0];this._pm=t,this._li=new te,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()};class Si{constructor(){Si.constructor_.apply(this,arguments)}static bufferOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Si(t).getResultGeometry(e)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof q&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Si(t);return s.setQuadrantSegments(n),s.getResultGeometry(e)}if(arguments[2]instanceof js&&arguments[0]instanceof q&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return new Si(t,n).getResultGeometry(e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new Si(t);return i.setQuadrantSegments(n),i.setEndCapStyle(s),i.getResultGeometry(e)}}static precisionScaleFactor(t,e,n){const s=t.getEnvelopeInternal(),i=M.max(Math.abs(s.getMaxX()),Math.abs(s.getMaxY()),Math.abs(s.getMinX()),Math.abs(s.getMinY()))+2*(e>0?e:0),r=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,r)}bufferFixedPrecision(t){const e=new ks(new Ci(new kt(1)),t.getScale()),n=new pi(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0===arguments.length){for(let t=Si.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof Wn))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){const t=arguments[0],e=Si.precisionScaleFactor(this._argGeom,this._distance,t),n=new kt(e);this.bufferFixedPrecision(n)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;const t=this._argGeom.getFactory().getPrecisionModel();t.getType()===kt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{const t=new pi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof c))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}getClass(){return Si}get interfaces_(){return[]}}Si.constructor_=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new js,this._resultGeometry=null,this._saveException=null,1===arguments.length){const t=arguments[0];this._argGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._argGeom=t,this._bufParams=e}},Si.CAP_ROUND=js.CAP_ROUND,Si.CAP_BUTT=js.CAP_FLAT,Si.CAP_FLAT=js.CAP_FLAT,Si.CAP_SQUARE=js.CAP_SQUARE,Si.MAX_PRECISION_DIGITS=12;var wi=Object.freeze({__proto__:null,BufferOp:Si,BufferParameters:js});class Li{constructor(){Li.constructor_.apply(this,arguments)}isInsideArea(){return this._segIndex===Li.INSIDE_AREA}getCoordinate(){return this._pt}getGeometryComponent(){return this._component}getSegmentIndex(){return this._segIndex}getClass(){return Li}get interfaces_(){return[]}}Li.constructor_=function(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){const t=arguments[0],e=arguments[1];Li.constructor_.call(this,t,Li.INSIDE_AREA,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._component=t,this._segIndex=e,this._pt=n}},Li.INSIDE_AREA=-1;class Ti{constructor(){Ti.constructor_.apply(this,arguments)}static getLocations(t){const e=new x;return t.apply(new Ti(e)),e}filter(t){(t instanceof Pt||t instanceof Tt||t instanceof bt)&&this._locations.add(new Li(t,0,t.getCoordinate()))}getClass(){return Ti}get interfaces_(){return[gt]}}Ti.constructor_=function(){this._locations=null;const t=arguments[0];this._locations=t};class Ri{constructor(){Ri.constructor_.apply(this,arguments)}static distance(t,e){return new Ri(t,e).distance()}static isWithinDistance(t,e,n){return!(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>n)&&new Ri(t,e,n).distance()<=n}static nearestPoints(t,e){return new Ri(t,e).nearestPoints()}computeContainmentDistance(){if(0===arguments.length){const t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._geom[t];if(n.getDimension()<2)return null;const s=1-t,i=Ne.getPolygons(n);if(i.size()>0){const n=Ti.getLocations(this._geom[s]);if(this.computeContainmentDistance(n,i,e),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[s]=e[0],this._minDistanceLocation[t]=e[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&_(arguments[0],m)&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++)if(this.computeContainmentDistance(i,e.get(t),n),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Li&&arguments[1]instanceof bt){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getCoordinate();if(ne.EXTERIOR!==this._ptLocator.locate(s,e))return this._minDistance=0,n[0]=t,n[1]=new Li(e,s),null}}computeMinDistanceLinesPoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){const t=new Array(2).fill(null),e=xe.getLines(this._geom[0]),n=xe.getLines(this._geom[1]),s=Ie.getPoints(this._geom[0]),i=Ie.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,i,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,s,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(s,i,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){return this.computeMinDistance(),[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof Tt&&arguments[1]instanceof Pt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinate();for(let r=0;r<s.length-1;r++){const o=D.pointToSegment(i,s[r],s[r+1]);if(o<this._minDistance){this._minDistance=o;const l=new ee(s[r],s[r+1]).closestPoint(i);n[0]=new Li(t,r,l),n[1]=new Li(e,0,i)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Tt&&arguments[1]instanceof Tt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinates();for(let r=0;r<s.length-1;r++)for(let o=0;o<i.length-1;o++){const l=D.segmentToSegment(s[r],s[r+1],i[o],i[o+1]);if(l<this._minDistance){this._minDistance=l;const a=new ee(s[r],s[r+1]),c=new ee(i[o],i[o+1]),h=a.closestPoints(c);n[0]=new Li(t,r,h[0]),n[1]=new Li(e,o,h[1])}if(this._minDistance<=this._terminateDistance)return null}}}computeMinDistancePoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t),r=i.getCoordinate().distance(s.getCoordinate());if(r<this._minDistance&&(this._minDistance=r,n[0]=new Li(i,0,i.getCoordinate()),n[1]=new Li(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new n("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}getClass(){return Ri}get interfaces_(){return[]}}Ri.constructor_=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new _n,this._minDistanceLocation=null,this._minDistance=i.MAX_VALUE,2===arguments.length){const t=arguments[0],e=arguments[1];Ri.constructor_.call(this,t,e,0)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e,this._terminateDistance=n}};var Pi=Object.freeze({__proto__:null,DistanceOp:Ri});class vi{constructor(){vi.constructor_.apply(this,arguments)}getCoordinates(){if(null===this._coordinates){let t=0,e=0;const n=new I;for(let s=this._directedEdges.iterator();s.hasNext();){const i=s.next();i.getEdgeDirection()?t++:e++,n.add(i.getEdge().getLine().getCoordinates(),!1,i.getEdgeDirection())}this._coordinates=n.toCoordinateArray(),e>t&&X.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}getClass(){return vi}get interfaces_(){return[]}}vi.constructor_=function(){this._factory=null,this._directedEdges=new x,this._coordinates=null;const t=arguments[0];this._factory=t};class Oi{constructor(){Oi.constructor_.apply(this,arguments)}static getComponentWithVisitedState(t,e){for(;t.hasNext();){const n=t.next();if(n.isVisited()===e)return n}return null}static setVisited(t,e){for(;t.hasNext();){t.next().setVisited(e)}}static setMarked(t,e){for(;t.hasNext();){t.next().setMarked(e)}}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}getClass(){return Oi}get interfaces_(){return[]}}Oi.constructor_=function(){this._isMarked=!1,this._isVisited=!1,this._data=null};class bi extends Oi{constructor(){super(),bi.constructor_.apply(this,arguments)}static toEdges(t){const e=new x;for(let n=t.iterator();n.hasNext();)e.add(n.next()._parentEdge);return e}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){const e=this.getClass().getName(),n=e.lastIndexOf("."),s=e.substring(n+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){const e=t;return this.compareDirection(e)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}getClass(){return bi}get interfaces_(){return[r]}}bi.constructor_=function(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._from=t,this._to=e,this._edgeDirection=s,this._p0=t.getCoordinate(),this._p1=n;const i=this._p1.x-this._p0.x,r=this._p1.y-this._p0.y;this._quadrant=In.quadrant(i,r),this._angle=Math.atan2(r,i)}};class Mi extends bi{constructor(){super(),Mi.constructor_.apply(this,arguments)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(u.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}getClass(){return Mi}get interfaces_(){return[]}}Mi.constructor_=function(){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];bi.constructor_.call(this,t,e,n,s)};class Di extends Oi{constructor(){super(),Di.constructor_.apply(this,arguments)}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,e){this._dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)}getDirEdge(){if(Number.isInteger(arguments[0])){const t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof Fi){const t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}getClass(){return Di}get interfaces_(){return[]}}Di.constructor_=function(){if(this._dirEdge=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}};class Ai{constructor(){Ai.constructor_.apply(this,arguments)}getNextEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e+1))}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(Ee.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e-1))}getIndex(){if(arguments[0]instanceof Di){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e).getEdge()===t)return e}return-1}if(arguments[0]instanceof bi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e)===t)return e}return-1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}getClass(){return Ai}get interfaces_(){return[]}}Ai.constructor_=function(){this._outEdges=new x,this._sorted=!1};class Fi extends Oi{constructor(){super(),Fi.constructor_.apply(this,arguments)}static getEdgesBetween(t,e){const n=new J(bi.toEdges(t.getOutEdges().getEdges())),s=bi.toEdges(e.getOutEdges().getEdges());return n.retainAll(s),n}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0===arguments.length)this._pt=null;else if(1===arguments.length){const t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}getClass(){return Fi}get interfaces_(){return[]}}Fi.constructor_=function(){if(this._pt=null,this._deStar=null,1===arguments.length){const t=arguments[0];Fi.constructor_.call(this,t,new Ai)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt=t,this._deStar=e}};class Gi extends Di{constructor(){super(),Gi.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return Gi}get interfaces_(){return[]}}Gi.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class qi{constructor(){qi.constructor_.apply(this,arguments)}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}getClass(){return qi}get interfaces_(){return[]}}qi.constructor_=function(){this._nodeMap=new rt};class Bi{constructor(){Bi.constructor_.apply(this,arguments)}findNodesOfDegree(t){const e=new x;for(let n=this.nodeIterator();n.hasNext();){const s=n.next();s.getDegree()===t&&e.add(s)}return e}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Di){const t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof bi){const t=arguments[0],e=t.getSym();null!==e&&e.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof Fi){const t=arguments[0];for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next(),n=t.getSym();null!==n&&this.remove(n),this._dirEdges.remove(t);const s=t.getEdge();null!==s&&this._edges.remove(s)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Di){const t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof bi){const t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof Fi){const t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Di){const t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof bi){const t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}getClass(){return Bi}get interfaces_(){return[]}}Bi.constructor_=function(){this._edges=new J,this._dirEdges=new J,this._nodeMap=new qi};class Vi extends Bi{constructor(){super(),Vi.constructor_.apply(this,arguments)}addEdge(t){if(t.isEmpty())return null;const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Mi(i,r,e[1],!0),l=new Mi(r,i,e[e.length-2],!1),a=new Gi(t);a.setDirectedEdges(o,l),this.add(a)}getNode(t){let e=this.findNode(t);return null===e&&(e=new Fi(t),this.add(e)),e}getClass(){return Vi}get interfaces_(){return[]}}Vi.constructor_=function(){};class zi{constructor(){zi.constructor_.apply(this,arguments)}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();e.isMarked()||(u.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let e=t.getOutEdges().iterator();e.hasNext();){const t=e.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;Oi.setMarked(this._graph.nodeIterator(),!1),Oi.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new x,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new x;for(let t=this._edgeStrings.iterator();t.hasNext();){const e=t.next();this._mergedLineStrings.add(e.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){const e=new vi(this._factory);let n=t;do{e.add(n),n.getEdge().setMarked(!0),n=n.getNext()}while(null!==n&&n!==t);return e}add(){if(arguments[0]instanceof q){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);n instanceof Tt&&this.addLineString(n)}}else if(_(arguments[0],f)){const t=arguments[0];this._mergedLineStrings=null;for(let e=t.iterator();e.hasNext();){const t=e.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}getClass(){return zi}get interfaces_(){return[]}}zi.constructor_=function(){this._graph=new Vi,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null};class Yi{constructor(){Yi.constructor_.apply(this,arguments)}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}getClass(){return Yi}get interfaces_(){return[]}}Yi.constructor_=function(){this._parentGraph=null,this._edges=new J,this._dirEdges=new x,this._nodeMap=new qi;const t=arguments[0];this._parentGraph=t};class Ui{constructor(){Ui.constructor_.apply(this,arguments)}addReachable(t,e){const n=new on;for(n.add(t);!n.empty();){const t=n.pop();this.addEdges(t,n,e)}}findSubgraph(t){const e=new Yi(this._graph);return this.addReachable(t,e),e}getConnectedSubgraphs(){const t=new x;Oi.setVisited(this._graph.nodeIterator(),!1);for(let e=this._graph.edgeIterator();e.hasNext();){const n=e.next().getDirEdge(0).getFromNode();n.isVisited()||t.add(this.findSubgraph(n))}return t}addEdges(t,e,n){t.setVisited(!0);for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();n.add(t.getEdge());const i=t.getToNode();i.isVisited()||e.push(i)}}getClass(){return Ui}get interfaces_(){return[]}}Ui.constructor_=function(){this._graph=null;const t=arguments[0];this._graph=t};class ki{constructor(){ki.constructor_.apply(this,arguments)}static findUnvisitedBestOrientedDE(t){let e=null,n=null;for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();t.getEdge().isVisited()||(n=t,t.getEdgeDirection()&&(e=t))}return null!==e?e:n}static findLowestDegreeNode(t){let e=L.MAX_VALUE,n=null;for(let s=t.nodeIterator();s.hasNext();){const t=s.next();(null===n||t.getDegree()<e)&&(e=t.getDegree(),n=t)}return n}static isSequenced(t){if(!(t instanceof ft))return!0;const e=t,n=new at;let s=null;const i=new x;for(let t=0;t<e.getNumGeometries();t++){const r=e.getGeometryN(t),o=r.getCoordinateN(0),l=r.getCoordinateN(r.getNumPoints()-1);if(n.contains(o))return!1;if(n.contains(l))return!1;null!==s&&(o.equals(s)||(n.addAll(i),i.clear())),i.add(o),i.add(l),s=l}return!0}static reverse(t){const e=t.getCoordinates(),n=new Array(e.length).fill(null),s=e.length;for(let t=0;t<s;t++)n[s-1-t]=new g(e[t]);return t.getFactory().createLineString(n)}static sequence(t){const e=new ki;return e.add(t),e.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let e=0;for(let n=t.nodeIterator();n.hasNext();){n.next().getDegree()%2==1&&e++}return e<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;const t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;const e=this._sequencedGeometry.getNumGeometries();u.isTrue(this._lineCount===e,"Lines were missing from result"),u.isTrue(this._sequencedGeometry instanceof Tt||this._sequencedGeometry instanceof ft,"Result is not lineal")}findSequences(){const t=new x;for(let e=new Ui(this._graph).getConnectedSubgraphs().iterator();e.hasNext();){const n=e.next();if(!this.hasSequence(n))return null;{const e=this.findSequence(n);t.add(e)}}return t}addReverseSubpath(t,e,n){const s=t.getToNode();let i=null;for(;;){e.add(t.getSym()),t.getEdge().setVisited(!0),i=t.getFromNode();const n=ki.findUnvisitedBestOrientedDE(i);if(null===n)break;t=n.getSym()}n&&u.isTrue(i===s,"path not contiguous")}findSequence(t){Oi.setVisited(t.edgeIterator(),!1);const e=ki.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),n=new Zs,s=n.listIterator();for(this.addReverseSubpath(e,s,!1);s.hasPrevious();){const t=s.previous(),e=ki.findUnvisitedBestOrientedDE(t.getFromNode());null!==e&&this.addReverseSubpath(e.getSym(),s,!0)}return this.orient(n)}reverse(t){const e=new Zs;for(let n=t.iterator();n.hasNext();){const t=n.next();e.addFirst(t.getSym())}return e}orient(t){const e=t.get(0),n=t.get(t.size()-1),s=e.getFromNode(),i=n.getToNode();let r=!1;if(1===s.getDegree()||1===i.getDegree()){let t=!1;1===n.getToNode().getDegree()&&!1===n.getEdgeDirection()&&(t=!0,r=!0),1===e.getFromNode().getDegree()&&!0===e.getEdgeDirection()&&(t=!0,r=!1),t||1===e.getFromNode().getDegree()&&(r=!0)}return r?this.reverse(t):t}buildSequencedGeometry(t){const e=new x;for(let n=t.iterator();n.hasNext();){for(let t=n.next().iterator();t.hasNext();){const n=t.next(),s=n.getEdge().getLine();let i=s;n.getEdgeDirection()||s.isClosed()||(i=ki.reverse(s)),e.add(i)}}return 0===e.size()?this._factory.createMultiLineString(new Array(0).fill(null)):this._factory.buildGeometry(e)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof q){arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Tt&&this.addLine(t)}})}}getClass(){return ki}get interfaces_(){return[]}}ki.constructor_=function(){this._graph=new Vi,this._factory=new Ht,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1};var Xi=Object.freeze({__proto__:null,LineMerger:zi,LineSequencer:ki});class Hi{constructor(){Hi.constructor_.apply(this,arguments)}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,e){const n=this._isClosed?t.size()-1:t.size();for(let s=0;s<n;s++){const n=t.get(s),i=this.findSnapForVertex(n,e);null!==i&&(t.set(s,new g(i)),0===s&&this._isClosed&&t.set(t.size()-1,new g(i)))}}findSnapForVertex(t,e){for(let n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null}snapTo(t){const e=new I(this._srcPts);return this.snapVertices(e,t),this.snapSegments(e,t),e.toCoordinateArray()}snapSegments(t,e){if(0===e.length)return null;let n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(let s=0;s<n;s++){const n=e[s],i=this.findSegmentIndexToSnap(n,t);i>=0&&t.add(i+1,new g(n),!1)}}findSegmentIndexToSnap(t,e){let n=i.MAX_VALUE,s=-1;for(let i=0;i<e.size()-1;i++){if(this._seg.p0=e.get(i),this._seg.p1=e.get(i+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}const r=this._seg.distance(t);r<this._snapTolerance&&r<n&&(n=r,s=i)}return s}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}getClass(){return Hi}get interfaces_(){return[]}}Hi.constructor_=function(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new ee,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Tt&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];Hi.constructor_.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this._srcPts=t,this._isClosed=Hi.isClosed(t),this._snapTolerance=e}};class Wi{constructor(){Wi.constructor_.apply(this,arguments)}static snap(t,e,n){const s=new Array(2).fill(null),i=new Wi(t);s[0]=i.snapTo(e,n);const r=new Wi(e);return s[1]=r.snapTo(s[0],n),s}static computeOverlaySnapTolerance(){if(1===arguments.length){const t=arguments[0];let e=Wi.computeSizeBasedSnapTolerance(t);const n=t.getPrecisionModel();if(n.getType()===kt.FIXED){const t=1/n.getScale()*2/1.415;t>e&&(e=t)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Math.min(Wi.computeOverlaySnapTolerance(t),Wi.computeOverlaySnapTolerance(e))}}static computeSizeBasedSnapTolerance(t){const e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*Wi.SNAP_PRECISION_FACTOR}static snapToSelf(t,e,n){return new Wi(t).snapToSelf(e,n)}snapTo(t,e){const n=this.extractTargetCoordinates(t);return new ji(e,n).transform(this._srcGeom)}snapToSelf(t,e){const n=this.extractTargetCoordinates(this._srcGeom),s=new ji(t,n,!0).transform(this._srcGeom);let i=s;return e&&_(i,Ot)&&(i=s.buffer(0)),i}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){const e=new at,n=t.getCoordinates();for(let t=0;t<n.length;t++)e.add(n[t]);return e.toArray(new Array(0).fill(null))}computeMinimumSegmentLength(t){let e=i.MAX_VALUE;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);s<e&&(e=s)}return e}getClass(){return Wi}get interfaces_(){return[]}}Wi.constructor_=function(){this._srcGeom=null;const t=arguments[0];this._srcGeom=t},Wi.SNAP_PRECISION_FACTOR=1e-9;class ji extends me{constructor(){super(),ji.constructor_.apply(this,arguments)}snapLine(t,e){const n=new Hi(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)}transformCoordinates(t,e){const n=t.toCoordinateArray(),s=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(s)}getClass(){return ji}get interfaces_(){return[]}}ji.constructor_=function(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2===arguments.length){const t=arguments[0],e=arguments[1];this._snapTolerance=t,this._snapPts=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._snapTolerance=t,this._snapPts=e,this._isSelfSnap=n}};var Ki=Object.freeze({__proto__:null,GeometrySnapper:Wi,LineStringSnapper:Hi});class Zi{constructor(){Zi.constructor_.apply(this,arguments)}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Ms.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return Jt.toLineString(new zt(this._pts))}getClass(){return Zi}get interfaces_(){return[Ds]}}Zi.constructor_=function(){this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e};class Qi{constructor(){Qi.constructor_.apply(this,arguments)}static createAllIntersectionsFinder(t){const e=new Qi(t);return e.setFindAllIntersections(!0),e}static createAnyIntersectionFinder(t){return new Qi(t)}static createIntersectionCounter(t){const e=new Qi(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}getInteriorIntersection(){return this._interiorIntersection}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}processIntersections(t,e,n,s){if(!this._findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===s)return null;if(this._isCheckEndSegmentsOnly){if(!(this.isEndSegment(t,e)||this.isEndSegment(n,s)))return null}const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=i,this._intSegments[1]=r,this._intSegments[2]=o,this._intSegments[3]=l,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}isEndSegment(t,e){return 0===e||e>=t.size()-2}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}getClass(){return Qi}get interfaces_(){return[_i]}}Qi.constructor_=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new x,this._intersectionCount=0,this._keepIntersections=!0;const t=arguments[0];this._li=t,this._interiorIntersection=null};class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static computeIntersections(t){const e=new Ji(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new Qi(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);const t=new Ys;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new Wn(this.getErrorMessage(),this._segInt.getInteriorIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";const t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Jt.toLineString(t[0],t[1])+" and "+Jt.toLineString(t[2],t[3])}getClass(){return Ji}get interfaces_(){return[]}}Ji.constructor_=function(){this._li=new te,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;const t=arguments[0];this._segStrings=t};class $i{constructor(){$i.constructor_.apply(this,arguments)}static toSegmentStrings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Zi(t.getCoordinates(),t))}return e}static checkValid(t){new $i(t).checkValid()}checkValid(){this._nv.checkValid()}getClass(){return $i}get interfaces_(){return[]}}$i.constructor_=function(){this._nv=null;const t=arguments[0];this._nv=new Ji($i.toSegmentStrings(t))};class tr{constructor(){tr.constructor_.apply(this,arguments)}collectLines(t){for(let e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){const n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}}labelIsolatedLine(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,e,n){const s=t.getLabel(),i=t.getEdge();t.isLineEdge()&&(t.isVisited()||!cr.isResultOfOp(s,e)||i.isCovered()||(n.add(i),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getEdge();if(e.isLineEdge()&&!n.isCoveredSet()){const t=this._op.isCoveredByA(e.getCoordinate());n.setCovered(t)}}}labelIsolatedLines(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel();t.isIsolated()&&(n.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){const e=t.next(),n=(e.getLabel(),this._geometryFactory.createLineString(e.getCoordinates()));this._resultLineList.add(n),e.setInResult(!0)}}collectBoundaryTouchEdge(t,e,n){const s=t.getLabel();return t.isLineEdge()||t.isVisited()||t.isInteriorAreaEdge()||t.getEdge().isInResult()?null:(u.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(cr.isResultOfOp(s,e)&&e===cr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))}getClass(){return tr}get interfaces_(){return[]}}tr.constructor_=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new x,this._resultLineList=new x;const t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n};class er{constructor(){er.constructor_.apply(this,arguments)}filterCoveredNodeToPoint(t){const e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){const t=this._geometryFactory.createPoint(e);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let e=this._op.getGraph().getNodes().iterator();e.hasNext();){const n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===cr.INTERSECTION))){const e=n.getLabel();cr.isResultOfOp(e,t)&&this.filterCoveredNodeToPoint(n)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}getClass(){return er}get interfaces_(){return[]}}er.constructor_=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new x;const t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e};class nr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new s,this._commonSignExp=null}getCommon(){return i.longBitsToDouble(this._commonBits)}add(t){const e=i.doubleToLongBits(t);return this._isFirst?(this._commonBits=e,this._commonSignExp=nr.signExpBits(this._commonBits),this._isFirst=!1,null):nr.signExpBits(e)!==this._commonSignExp?(this._commonBits.high=0,this._commonBits.low=0,null):(this._commonMantissaBitsCount=nr.numCommonMostSigMantissaBits(this._commonBits,e),void(this._commonBits=nr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))))}toString(){if(1===arguments.length){const t=arguments[0],e=i.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+s.toBinaryString(t),r=n.substring(n.length-64);return r.substring(0,1)+"  "+r.substring(1,12)+"(exp) "+r.substring(12)+" [ "+e+" ]"}}getClass(){return nr}get interfaces_(){return[]}static getBit(t,e){const n=1<<e%32;return e<32?0!=(t.low&n)?1:0:0!=(t.high&n)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,e){let n="low";if(e>32&&(t.low=0,e%=32,n="high"),e>0){const s=e<32?~((1<<e)-1):0;t[n]&=s}return t}static numCommonMostSigMantissaBits(t,e){let n=0;for(let s=52;s>=0;s--){if(nr.getBit(t,s)!==nr.getBit(e,s))return n;n++}return 52}}class sr{constructor(){sr.constructor_.apply(this,arguments)}addCommonBits(t){const e=new rr(this._commonCoord);t.apply(e),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;const e=new g(this._commonCoord);e.x=-e.x,e.y=-e.y;const n=new rr(e);return t.apply(n),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}getClass(){return sr}get interfaces_(){return[]}}class ir{constructor(){ir.constructor_.apply(this,arguments)}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new g(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}getClass(){return ir}get interfaces_(){return[B]}}ir.constructor_=function(){this._commonBitsX=new nr,this._commonBitsY=new nr};class rr{constructor(){rr.constructor_.apply(this,arguments)}filter(t,e){const n=t.getOrdinate(e,0)+this.trans.x,s=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}isDone(){return!1}isGeometryChanged(){return!0}getClass(){return rr}get interfaces_(){return[dt]}}rr.constructor_=function(){this.trans=null;const t=arguments[0];this.trans=t},sr.CommonCoordinateFilter=ir,sr.Translater=rr,sr.constructor_=function(){this._commonCoord=null,this._ccFilter=new ir};class or{constructor(){or.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new or(t,e).getResultGeometry(n)}static union(t,e){return or.overlayOp(t,e,cr.UNION)}static intersection(t,e){return or.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){return or.overlayOp(t,e,cr.SYMDIFFERENCE)}static difference(t,e){return or.overlayOp(t,e,cr.DIFFERENCE)}selfSnap(t){return new Wi(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new sr,this._cbr.add(t[0]),this._cbr.add(t[1]);const e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){const e=this.snap(this._geom),n=cr.overlayOp(e[0],e[1],t);return this.prepareResult(n)}checkValid(t){t.isValid()||O.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=Wi.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){const e=this.removeCommonBits(t);return Wi.snap(e[0],e[1],this._snapTolerance)}getClass(){return or}get interfaces_(){return[]}}or.constructor_=function(){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null;const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()};class lr{constructor(){lr.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new lr(t,e).getResultGeometry(n)}static union(t,e){return lr.overlayOp(t,e,cr.UNION)}static intersection(t,e){return lr.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){return lr.overlayOp(t,e,cr.SYMDIFFERENCE)}static difference(t,e){return lr.overlayOp(t,e,cr.DIFFERENCE)}getResultGeometry(t){let e=null,n=!1,s=null;try{e=cr.overlayOp(this._geom[0],this._geom[1],t),!0&&(n=!0)}catch(t){if(!(t instanceof c))throw t;s=t}if(!n)try{e=or.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof c?s:t}return e}getClass(){return lr}get interfaces_(){return[]}}lr.constructor_=function(){this._geom=new Array(2).fill(null);const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e};class ar{constructor(){ar.constructor_.apply(this,arguments)}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}getClass(){return ar}get interfaces_(){return[]}}ar.constructor_=function(){if(this._li=new te,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Qn(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Qn(0,t,n),this._arg[1]=new Qn(1,e,n)}};class cr extends ar{constructor(){super(),cr.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new cr(t,e).getResultGeometry(n)}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.UNION)}static intersection(t,e){if(t.isEmpty()||e.isEmpty())return cr.createEmptyResult(cr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){const n=e;return ge.map(t,new class{get interfaces_(){return[fe]}map(t){return cr.intersection(t,n)}})}return lr.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.SYMDIFFERENCE)}static resultDimension(t,e,n){const s=e.getDimension(),i=n.getDimension();let r=-1;switch(t){case cr.INTERSECTION:r=Math.min(s,i);break;case cr.UNION:r=Math.max(s,i);break;case cr.DIFFERENCE:r=s;break;case cr.SYMDIFFERENCE:r=Math.max(s,i)}return r}static createEmptyResult(t,e,n,s){let i=null;switch(cr.resultDimension(t,e,n)){case-1:i=s.createGeometryCollection();break;case 0:i=s.createPoint();break;case 1:i=s.createLineString();break;case 2:i=s.createPolygon()}return i}static difference(t,e){if(t.isEmpty())return cr.createEmptyResult(cr.DIFFERENCE,t,e,t.getFactory());if(e.isEmpty())return t.copy();if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.DIFFERENCE)}static isResultOfOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(0),s=t.getLocation(1);return cr.isResultOfOp(n,s,e)}if(3===arguments.length){let t=arguments[0],e=arguments[1];const n=arguments[2];switch(t===ne.BOUNDARY&&(t=ne.INTERIOR),e===ne.BOUNDARY&&(e=ne.INTERIOR),n){case cr.INTERSECTION:return t===ne.INTERIOR&&e===ne.INTERIOR;case cr.UNION:return t===ne.INTERIOR||e===ne.INTERIOR;case cr.DIFFERENCE:return t===ne.INTERIOR&&e!==ne.INTERIOR;case cr.SYMDIFFERENCE:return t===ne.INTERIOR&&e!==ne.INTERIOR||t!==ne.INTERIOR&&e===ne.INTERIOR}return!1}}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Fn(t.getLabel()),s.flip());const i=e.getDepth();i.isNull()&&i.add(n),i.add(s),n.merge(s)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,e,n,s){const i=new x;return i.addAll(t),i.addAll(e),i.addAll(n),i.isEmpty()?cr.createEmptyResult(s,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(i)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}}isCovered(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(this._ptLocator.locate(t,e)!==ne.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){const t=new x;for(let e=this._edgeList.iterator();e.hasNext();){const n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);const e=new x;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),$i.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();const n=new ei(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();const s=new tr(this,this._geomFact,this._ptLocator);this._resultLineList=s.build(t);const i=new er(this,this._geomFact,this._ptLocator);this._resultPointList=i.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)}copyPoints(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let e=this._graph.getEdgeEnds().iterator();e.hasNext();){const n=e.next(),s=n.getLabel();s.isArea()&&!n.isInteriorAreaEdge()&&cr.isResultOfOp(s.getLocation(0,Pn.RIGHT),s.getLocation(1,Pn.RIGHT),t)&&n.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){const e=t.next(),n=e.getLabel(),s=e.getDepth();if(!s.isNull()){s.normalize();for(let t=0;t<2;t++)n.isNull(t)||!n.isArea()||s.isNull(t)||(0===s.getDelta(t)?n.toLine(t):(u.isTrue(!s.isNull(t,Pn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(t,Pn.LEFT,s.getLocation(t,Pn.LEFT)),u.isTrue(!s.isNull(t,Pn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(t,Pn.RIGHT,s.getLocation(t,Pn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}getClass(){return cr}get interfaces_(){return[]}}cr.constructor_=function(){this._ptLocator=new _n,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new di,this._resultPolyList=new x,this._resultLineList=new x,this._resultPointList=new x;const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e),this._graph=new Zn(new ui),this._geomFact=t.getFactory()},cr.INTERSECTION=1,cr.UNION=2,cr.DIFFERENCE=3,cr.SYMDIFFERENCE=4;var hr=Object.freeze({__proto__:null,snap:Ki,OverlayOp:cr});class ur extends bi{constructor(){super(),ur.constructor_.apply(this,arguments)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}getClass(){return ur}get interfaces_(){return[]}}ur.constructor_=function(){this._edgeRing=null,this._next=null,this._label=-1;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];bi.constructor_.call(this,t,e,n,s)};class gr extends Di{constructor(){super(),gr.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return gr}get interfaces_(){return[]}}gr.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class dr{constructor(){dr.constructor_.apply(this,arguments)}static findDifferentPoint(t,e){for(let n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null}visitInteriorRing(t,e){const n=t.getCoordinates(),s=n[0],i=dr.findDifferentPoint(n,s),r=e.findEdgeInSameDirection(s,i),o=e.findEdgeEnd(r);let l=null;o.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR?l=o:o.getSym().getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR&&(l=o.getSym()),u.isTrue(null!==l,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(l)}visitShellInteriors(t,e){if(t instanceof bt){const n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof At){const n=t;for(let t=0;t<n.getNumGeometries();t++){const s=n.getGeometryN(t);this.visitInteriorRing(s.getExteriorRing(),e)}}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let e=t.getEdgeEnds().iterator();e.hasNext();){const t=e.next();t.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const e=t;let n=t;do{u.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext()}while(n!==e)}buildEdgeRings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&null===t.getEdgeRing()){const n=new ti(t,this._geometryFactory);n.linkDirectedEdgesForMinimalEdgeRings();const s=n.buildMinimalRings();e.addAll(s)}}return e}hasUnvisitedShellEdge(t){for(let e=0;e<t.size();e++){const n=t.get(e);if(n.isHole())continue;const s=n.getEdges();let i=s.get(0);if(i.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR)for(let t=0;t<s.size();t++)if(i=s.get(t),!i.isVisited())return this._disconnectedRingcoord=i.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new x;this._geomGraph.computeSplitEdges(t);const e=new Zn(new ui);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();const n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)}getClass(){return dr}get interfaces_(){return[]}}dr.constructor_=function(){this._geometryFactory=new Ht,this._geomGraph=null,this._disconnectedRingcoord=null;const t=arguments[0];this._geomGraph=t};class _r{constructor(){_r.constructor_.apply(this,arguments)}createEdgeEndForNext(t,e,n,s){const i=n.segmentIndex+1;if(i>=t.getNumPoints()&&null===s)return null;let r=t.getCoordinate(i);null!==s&&s.segmentIndex===n.segmentIndex&&(r=s.coord);const o=new Hn(t,n.coord,r,new Fn(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,s){let i=n.segmentIndex;if(0===n.dist){if(0===i)return null;i--}let r=t.getCoordinate(i);null!==s&&s.segmentIndex>=i&&(r=s.coord);const o=new Fn(t.getLabel());o.flip();const l=new Hn(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new x;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const s=n.iterator();let i=null,r=null;if(!s.hasNext())return null;let o=s.next();do{i=r,r=o,o=null,s.hasNext()&&(o=s.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,i),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}getClass(){return _r}get interfaces_(){return[]}}_r.constructor_=function(){};class fr extends Hn{constructor(){super(),fr.constructor_.apply(this,arguments)}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,s=!1;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel().getLocation(t);i===ne.BOUNDARY&&n++,i===ne.INTERIOR&&(s=!0)}let i=ne.NONE;s&&(i=ne.INTERIOR),n>0&&(i=Qn.determineBoundary(e,n)),this._label.setLocation(t,i)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const s=n.next();if(s.getLabel().isArea()){const n=s.getLabel().getLocation(t,e);if(n===ne.INTERIOR)return this._label.setLocation(t,e,ne.INTERIOR),null;n===ne.EXTERIOR&&this._label.setLocation(t,e,ne.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,Pn.LEFT),this.computeLabelSide(t,Pn.RIGHT)}updateIM(t){Un.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new Fn(ne.NONE,ne.NONE,ne.NONE):new Fn(ne.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}getClass(){return fr}get interfaces_(){return[]}}fr.constructor_=function(){if(this._edgeEnds=new x,1===arguments.length){const t=arguments[0];fr.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];Hn.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Fn(t.getLabel())),this.insert(t)}};class pr extends ci{constructor(){super(),pr.constructor_.apply(this,arguments)}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new fr(t),this.insertEdgeEnd(t,e)):e.insert(t)}getClass(){return pr}get interfaces_(){return[]}}pr.constructor_=function(){};class mr extends kn{constructor(){super(),mr.constructor_.apply(this,arguments)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}getClass(){return mr}get interfaces_(){return[]}}mr.constructor_=function(){const t=arguments[0],e=arguments[1];kn.constructor_.call(this,t,e)};class yr extends Kn{constructor(){super(),yr.constructor_.apply(this,arguments)}createNode(t){return new mr(t,new pr)}getClass(){return yr}get interfaces_(){return[]}}yr.constructor_=function(){};class xr{constructor(){xr.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,e){for(let n=t.getNodeIterator();n.hasNext();){const t=n.next();this._nodes.addNode(t.getCoordinate()).setLabel(e,t.getLabel().getLocation(e))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const e=(new _r).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(e)}computeIntersectionNodes(t,e){for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.getLabel().getLocation(e);for(let n=t.getEdgeIntersectionList().iterator();n.hasNext();){const t=n.next(),i=this._nodes.addNode(t.coord);s===ne.BOUNDARY?i.setLabelBoundary(e):i.getLabel().isNull(e)&&i.setLabel(e,ne.INTERIOR)}}}getClass(){return xr}get interfaces_(){return[]}}xr.constructor_=function(){this._nodes=new Xn(new yr)};class Er{constructor(){Er.constructor_.apply(this,arguments)}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){const e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=e.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){for(let e=t.next().getEdges().iterator();e.hasNext();){const t=e.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}}return!1}isNodeConsistentArea(){const t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}getClass(){return Er}get interfaces_(){return[]}}Er.constructor_=function(){this._li=new te,this._geomGraph=null,this._nodeGraph=new xr,this._invalidPoint=null;const t=arguments[0];this._geomGraph=t};class Ir{constructor(){Ir.constructor_.apply(this,arguments)}buildIndex(){this._index=new Es;for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getEnvelopeInternal();this._index.insert(n,e)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getCoordinates(),s=this._index.query(e.getEnvelopeInternal());for(let t=0;t<s.size();t++){const i=s.get(t),r=i.getCoordinates();if(e===i)continue;if(!e.getEnvelopeInternal().intersects(i.getEnvelopeInternal()))continue;const o=Cr.findPtNotNode(n,i,this._graph);if(null!==o&&We.isInRing(o,r))return this._nestedPt=o,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}getClass(){return Ir}get interfaces_(){return[]}}Ir.constructor_=function(){this._graph=null,this._rings=new x,this._totalEnv=new N,this._index=null,this._nestedPt=null;const t=arguments[0];this._graph=t};class Nr{constructor(){Nr.constructor_.apply(this,arguments)}getErrorType(){return this._errorType}getMessage(){return Nr.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}getClass(){return Nr}get interfaces_(){return[]}}Nr.constructor_=function(){if(this._errorType=null,this._pt=null,1===arguments.length){const t=arguments[0];Nr.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._errorType=t,null!==e&&(this._pt=e.copy())}},Nr.ERROR=0,Nr.REPEATED_POINT=1,Nr.HOLE_OUTSIDE_SHELL=2,Nr.NESTED_HOLES=3,Nr.DISCONNECTED_INTERIOR=4,Nr.SELF_INTERSECTION=5,Nr.RING_SELF_INTERSECTION=6,Nr.NESTED_SHELLS=7,Nr.DUPLICATE_RINGS=8,Nr.TOO_FEW_POINTS=9,Nr.INVALID_COORDINATE=10,Nr.RING_NOT_CLOSED=11,Nr.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class Cr{constructor(){Cr.constructor_.apply(this,arguments)}static findPtNotNode(t,e,n){const s=n.findEdge(e).getEdgeIntersectionList();for(let e=0;e<t.length;e++){const n=t[e];if(!s.isIntersection(n))return n}return null}static isValid(){if(arguments[0]instanceof q){const t=arguments[0];return new Cr(t).isValid()}if(arguments[0]instanceof g){const t=arguments[0];return!i.isNaN(t.x)&&(!i.isInfinite(t.x)&&(!i.isNaN(t.y)&&!i.isInfinite(t.y)))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)if(!Cr.isValid(t[e]))return this._validErr=new Nr(Nr.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof bt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,e){const n=new Ir(e);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);n.add(s)}n.isNonNested()||(this._validErr=new Nr(Nr.NESTED_HOLES,n.getNestedPoint()))}checkConsistentArea(t){const e=new Er(t);if(!e.isNodeConsistentArea())return this._validErr=new Nr(Nr.SELF_INTERSECTION,e.getInvalidPoint()),null;e.hasDuplicateRings()&&(this._validErr=new Nr(Nr.DUPLICATE_RINGS,e.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,e,n){const s=t.getCoordinates(),i=e.getCoordinates(),r=Cr.findPtNotNode(s,e,n);if(null!==r){if(!We.isInRing(r,i))return r}const o=Cr.findPtNotNode(i,t,n);if(null!==o){return We.isInRing(o,s)?o:null}return u.shouldNeverReachHere("points in shell and hole appear to be equal"),null}checkNoSelfIntersectingRings(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){const e=new dr(t);e.isInteriorsConnected()||(this._validErr=new Nr(Nr.DISCONNECTED_INTERIOR,e.getCoordinate()))}checkNoSelfIntersectingRing(t){const e=new at;let n=!0;for(let s=t.iterator();s.hasNext();){const t=s.next();if(n)n=!1;else{if(e.contains(t.coord))return this._validErr=new Nr(Nr.RING_SELF_INTERSECTION,t.coord),null;e.add(t.coord)}}}checkHolesInShell(t,e){const n=t.getExteriorRing(),s=new ke(n);for(let i=0;i<t.getNumInteriorRing();i++){const r=t.getInteriorRingN(i),o=Cr.findPtNotNode(r.getCoordinates(),n,e);if(null===o)return null;if(ne.EXTERIOR===s.locate(o))return this._validErr=new Nr(Nr.HOLE_OUTSIDE_SHELL,o),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Nr(Nr.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof Pt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Mt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Dt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;if(this.checkClosedRing(t),null!==this._validErr)return null;const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;const n=new te;e.computeSelfNodes(n,!0,!0),this.checkNoSelfIntersectingRings(e)}else if(arguments[0]instanceof Tt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;const e=new Qn(0,t);this.checkTooFewPoints(e)}else if(arguments[0]instanceof bt){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr)return null;if(this.checkClosedRings(t),null!==this._validErr)return null;const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;if(this.checkHolesInShell(t,e),null!==this._validErr)return null;if(this.checkHolesNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof At){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkInvalidCoordinates(n),null!==this._validErr)return null;if(this.checkClosedRings(n),null!==this._validErr)return null}const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesInShell(s,e),null!==this._validErr)return null}for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesNotNested(s,e),null!==this._validErr)return null}if(this.checkShellsNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof _t){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkValid(n),null!==this._validErr)return null}}else if(arguments[0]instanceof q){const t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof Pt)this.checkValid(t);else if(t instanceof Mt)this.checkValid(t);else if(t instanceof Dt)this.checkValid(t);else if(t instanceof Tt)this.checkValid(t);else if(t instanceof bt)this.checkValid(t);else if(t instanceof At)this.checkValid(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,e,n){const s=t.getCoordinates(),i=e.getExteriorRing(),r=i.getCoordinates(),o=Cr.findPtNotNode(s,i,n);if(null===o)return null;if(!We.isInRing(o,r))return null;if(e.getNumInteriorRing()<=0)return this._validErr=new Nr(Nr.NESTED_SHELLS,o),null;let l=null;for(let s=0;s<e.getNumInteriorRing();s++){const i=e.getInteriorRingN(s);if(l=this.checkShellInsideHole(t,i,n),null===l)return null}this._validErr=new Nr(Nr.NESTED_SHELLS,l)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this._validErr)return null}checkClosedRing(t){if(!t.isClosed()){let e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this._validErr=new Nr(Nr.RING_NOT_CLOSED,e)}}checkShellsNotNested(t,e){for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getExteriorRing();for(let i=0;i<t.getNumGeometries();i++){if(n===i)continue;const r=t.getGeometryN(i);if(this.checkShellNotNested(s,r,e),null!==this._validErr)return null}}}getClass(){return Cr}get interfaces_(){return[]}}Cr.constructor_=function(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;const t=arguments[0];this._parentGeometry=t};class Sr{constructor(){Sr.constructor_.apply(this,arguments)}static findDirEdgesInRing(t){let e=t;const n=new x;do{n.add(e),e=e.getNext(),u.isTrue(null!==e,"found null DE in ring"),u.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t);return n}static addEdge(t,e,n){if(e)for(let e=0;e<t.length;e++)n.add(t[e],!1);else for(let e=t.length-1;e>=0;e--)n.add(t[e],!1)}static findEdgeRingContaining(t,e){const n=t.getRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getRing(),a=l.getEnvelopeInternal();if(a.equals(s))continue;if(!a.contains(s))continue;i=X.ptNotInList(n.getCoordinates(),l.getCoordinates());let c=!1;We.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===r||o.contains(a))&&(r=e,o=r.getRing().getEnvelopeInternal())}return r}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){const t=new I;for(let e=this._deList.iterator();e.hasNext();){const n=e.next(),s=n.getEdge();Sr.addEdge(s.getLine().getCoordinates(),n.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Cr.isValid(this._ring))}build(t){let e=t;do{this.add(e),e.setRing(this),e=e.getNext(),u.isTrue(null!==e,"found null DE in ring"),u.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=new Array(this._holes.size()).fill(null);for(let e=0;e<this._holes.size();e++)t[e]=this._holes.get(e)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof Dt){const t=arguments[0];null===this._holes&&(this._holes=new x),this._holes.add(t)}else if(arguments[0]instanceof Sr){const t=arguments[0];t.setShell(this);const e=t.getRing();null===this._holes&&(this._holes=new x),this._holes.add(e)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing();if(e.isOuterHole())return e}return null}computeHole(){const t=this.getRing();this._isHole=v.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return Jt.toLineString(new zt(this.getCoordinates()))}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&O.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof C))throw t;O.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing().getShell();if(null!==e&&e.isIncludedSet())return this.setIncluded(!e.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}getClass(){return Sr}get interfaces_(){return[]}}class wr{constructor(){wr.constructor_.apply(this,arguments)}compare(t,e){const n=e;return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())}getClass(){return wr}get interfaces_(){return[l]}}wr.constructor_=function(){},Sr.EnvelopeComparator=wr,Sr.constructor_=function(){this._factory=null,this._deList=new x,this._lowestEdge=null,this._ring=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;const t=arguments[0];this._factory=t};class Lr extends Bi{constructor(){super(),Lr.constructor_.apply(this,arguments)}static findLabeledEdgeRings(t){const e=new x;let n=1;for(let s=t.iterator();s.hasNext();){const t=s.next();if(t.isMarked())continue;if(t.getLabel()>=0)continue;e.add(t);const i=Sr.findDirEdgesInRing(t);Lr.label(i,n),n++}return e}static getDegreeNonDeleted(t){let e=0;for(let n=t.getOutEdges().getEdges().iterator();n.hasNext();){n.next().isMarked()||e++}return e}static deleteAllEdges(t){for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next();t.setMarked(!0);const n=t.getSym();null!==n&&n.setMarked(!0)}}static label(t,e){for(let n=t.iterator();n.hasNext();){n.next().setLabel(e)}}static computeNextCWEdges(t){let e=null,n=null;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();if(!t.isMarked()){if(null===e&&(e=t),null!==n){n.getSym().setNext(t)}n=t}}if(null!==n){n.getSym().setNext(e)}}static computeNextCCWEdges(t,e){let n=null,s=null;const i=t.getOutEdges().getEdges();for(let t=i.size()-1;t>=0;t--){const r=i.get(t),o=r.getSym();let l=null;r.getLabel()===e&&(l=r);let a=null;o.getLabel()===e&&(a=o),null===l&&null===a||(null!==a&&(s=a),null!==l&&(null!==s&&(s.setNext(l),s=null),null===n&&(n=l)))}null!==s&&(u.isTrue(null!==n),s.setNext(n))}static getDegree(t,e){let n=0;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){s.next().getLabel()===e&&n++}return n}static findIntersectionNodes(t,e){let n=t,s=null;do{const i=n.getFromNode();Lr.getDegree(i,e)>1&&(null===s&&(s=new x),s.add(i)),n=n.getNext(),u.isTrue(null!==n,"found null DE in ring"),u.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return s}findEdgeRing(t){const e=new Sr(this._factory);return e.build(t),e}computeDepthParity(){if(0===arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){const e=t.next();Lr.computeNextCWEdges(e)}}addEdge(t){if(t.isEmpty())return null;const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new ur(i,r,e[1],!0),l=new ur(r,i,e[e.length-2],!1),a=new gr(t);a.setDirectedEdges(o,l),this.add(a)}deleteCutEdges(){this.computeNextCWEdges(),Lr.findLabeledEdgeRings(this._dirEdges);const t=new x;for(let e=this._dirEdges.iterator();e.hasNext();){const n=e.next();if(n.isMarked())continue;const s=n.getSym();if(n.getLabel()===s.getLabel()){n.setMarked(!0),s.setMarked(!0);const e=n.getEdge();t.add(e.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),Lr.label(this._dirEdges,-1);const t=Lr.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);const e=new x;for(let t=this._dirEdges.iterator();t.hasNext();){const n=t.next();if(n.isMarked())continue;if(n.isInRing())continue;const s=this.findEdgeRing(n);e.add(s)}return e}getNode(t){let e=this.findNode(t);return null===e&&(e=new Fi(t),this.add(e)),e}convertMaximalToMinimalEdgeRings(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel(),s=Lr.findIntersectionNodes(t,n);if(null!==s)for(let t=s.iterator();t.hasNext();){const e=t.next();Lr.computeNextCCWEdges(e,n)}}}deleteDangles(){const t=this.findNodesOfDegree(1),e=new J,n=new on;for(let e=t.iterator();e.hasNext();)n.push(e.next());for(;!n.isEmpty();){const t=n.pop();Lr.deleteAllEdges(t);for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();t.setMarked(!0);const i=t.getSym();null!==i&&i.setMarked(!0);const r=t.getEdge();e.add(r.getLine());const o=t.getToNode();1===Lr.getDegreeNonDeleted(o)&&n.push(o)}}return e}getClass(){return Lr}get interfaces_(){return[]}}Lr.constructor_=function(){this._factory=null;const t=arguments[0];this._factory=t};class Tr{constructor(){Tr.constructor_.apply(this,arguments)}static findOuterShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getOuterHole();null===n||n.isProcessed()||(t.setIncluded(!0),n.setProcessed(!0))}}static extractPolygons(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next();(e||t.isIncluded())&&n.add(t.getPolygon())}return n}static assignHolesToShells(t,e){for(let n=t.iterator();n.hasNext();){const t=n.next();Tr.assignHoleToShell(t,e)}}static assignHoleToShell(t,e){const n=Sr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)}static findDisjointShells(t){Tr.findOuterShells(t);let e=null;do{e=!1;for(let n=t.iterator();n.hasNext();){const t=n.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(e=!0))}}while(e)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Ht),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Ht.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isValid()?e.add(t):n.add(t.getLineString())}}polygonize(){if(null!==this._polyList)return null;if(this._polyList=new x,null===this._graph)return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();const t=this._graph.getEdgeRings();let e=new x;this._invalidRingLines=new x,this._isCheckingRingsValid?this.findValidRings(t,e,this._invalidRingLines):e=t,this.findShellsAndHoles(e),Tr.assignHolesToShells(this._holeList,this._shellList),Ee.sort(this._shellList,new Sr.EnvelopeComparator);let n=!0;this._extractOnlyPolygonal&&(Tr.findDisjointShells(this._shellList),n=!1),this._polyList=Tr.extractPolygons(this._shellList,n)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof Tt){const t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new Lr(this._geomFactory)),this._graph.addEdge(t)}else if(arguments[0]instanceof q){arguments[0].apply(this._lineStringAdder)}}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new x,this._shellList=new x;for(let e=t.iterator();e.hasNext();){const t=e.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}getClass(){return Tr}get interfaces_(){return[]}}class Rr{constructor(){Rr.constructor_.apply(this,arguments)}filter(t){t instanceof Tt&&this.p.add(t)}getClass(){return Rr}get interfaces_(){return[G]}}Rr.constructor_=function(){this.p=null;const t=arguments[0];this.p=t},Tr.LineStringAdder=Rr,Tr.constructor_=function(){if(this._lineStringAdder=new Rr(this),this._graph=null,this._dangles=new x,this._cutEdges=new x,this._invalidRingLines=new x,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0===arguments.length)Tr.constructor_.call(this,!1);else if(1===arguments.length){const t=arguments[0];this._extractOnlyPolygonal=t}};var Pr=Object.freeze({__proto__:null,Polygonizer:Tr});class vr{constructor(){vr.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),s=this._arg[1].getGeometry().getDimension(),i=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===s?i&&e.setAtLeast("212101212"):2===n&&1===s?(i&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===s?(i&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===s&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const s=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,s)}else t.getLabel().setAllLocations(e,ne.EXTERIOR)}computeIM(){const t=new se;if(t.set(ne.EXTERIOR,ne.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new _r,s=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(s);const i=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(i),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.find(n.coord);i.getLabel().isNull(t)&&(s===ne.BOUNDARY?i.setLabelBoundary(t):i.setLabel(t,ne.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.addNode(n.coord);s===ne.BOUNDARY?i.setLabelBoundary(t):i.getLabel().isNull(t)&&i.setLabel(t,ne.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();u.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(ne.INTERIOR,ne.EXTERIOR,e.getDimension()),t.set(ne.BOUNDARY,ne.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(ne.EXTERIOR,ne.INTERIOR,n.getDimension()),t.set(ne.EXTERIOR,ne.BOUNDARY,n.getBoundaryDimension()))}getClass(){return vr}get interfaces_(){return[]}}vr.constructor_=function(){this._li=new te,this._ptLocator=new _n,this._arg=null,this._nodes=new Xn(new yr),this._im=null,this._isolatedEdges=new x,this._invalidPoint=null;const t=arguments[0];this._arg=t};class Or{constructor(){Or.constructor_.apply(this,arguments)}static contains(t,e){return new Or(t).contains(e)}isContainedInBoundary(t){if(t instanceof bt)return!1;if(t instanceof Pt)return this.isPointContainedInBoundary(t);if(t instanceof Tt)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new g,s=new g;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,s),!this.isLineSegmentContainedInBoundary(n,s))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof Pt){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}getClass(){return Or}get interfaces_(){return[]}}Or.constructor_=function(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()};class br{constructor(){br.constructor_.apply(this,arguments)}intersects(t,e){const n=new N(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let s=!1;return e.y>t.y&&(s=!0),s?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}getClass(){return br}get interfaces_(){return[]}}br.constructor_=function(){this._li=new te,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new g(t.getMinX(),t.getMinY()),this._diagUp1=new g(t.getMaxX(),t.getMaxY()),this._diagDown0=new g(t.getMinX(),t.getMaxY()),this._diagDown1=new g(t.getMaxX(),t.getMinY())};class Mr{constructor(){Mr.constructor_.apply(this,arguments)}static intersects(t,e){return new Mr(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Dr(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new Ar(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const s=new Fr(this._rectangle);return s.applyTo(t),!!s.intersects()}getClass(){return Mr}get interfaces_(){return[]}}Mr.constructor_=function(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()};class Dr extends Ce{constructor(){super(),Dr.constructor_.apply(this,arguments)}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}getClass(){return Dr}get interfaces_(){return[]}}Dr.constructor_=function(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t};class Ar extends Ce{constructor(){super(),Ar.constructor_.apply(this,arguments)}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof bt))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new g;for(let s=0;s<4;s++)if(this._rectSeq.getCoordinate(s,n),e.contains(n)&&Ze.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}getClass(){return Ar}get interfaces_(){return[]}}Ar.constructor_=function(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()};class Fr extends Ce{constructor(){super(),Fr.constructor_.apply(this,arguments)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=xe.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}getClass(){return Fr}get interfaces_(){return[]}}Fr.constructor_=function(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new g,this._p1=new g;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new br(this._rectEnv)};class Gr extends ar{constructor(){super(),Gr.constructor_.apply(this,arguments)}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Gr(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Mr.intersects(t,e);if(e.isRectangle())return Mr.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let s=0;s<e.getNumGeometries();s++)if(t.getGeometryN(n).intersects(e.getGeometryN(s)))return!0;return!1}return new Gr(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Gr.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Gr(t,e).getIntersectionMatrix()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new Gr(t,e,n).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Or.contains(t,e):new Gr(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}getClass(){return Gr}get interfaces_(){return[]}}Gr.constructor_=function(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e),this._relate=new vr(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];ar.constructor_.call(this,t,e,n),this._relate=new vr(this._arg)}};var qr=Object.freeze({__proto__:null,RelateOp:Gr});class Br{constructor(){Br.constructor_.apply(this,arguments)}static union(t,e){return new Br(t,e).union()}union(){const t=new _n,e=new at;for(let n=0;n<this._pointGeom.getNumGeometries();n++){const s=this._pointGeom.getGeometryN(n).getCoordinate();t.locate(s,this._otherGeom)===ne.EXTERIOR&&e.add(s)}if(0===e.size())return this._otherGeom;let n=null;const s=X.toCoordinateArray(e);return n=1===s.length?this._geomFact.createPoint(s[0]):this._geomFact.createMultiPointFromCoords(s),de.combine(n,this._otherGeom)}getClass(){return Br}get interfaces_(){return[]}}Br.constructor_=function(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;const t=arguments[0],e=arguments[1];this._pointGeom=t,this._otherGeom=e,this._geomFact=e.getFactory()};class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static restrictToPolygons(t){if(_(t,Ot))return t;const e=Ne.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(Ht.toPolygonArray(e))}static getGeometry(t,e){return e>=t.size()?null:t.get(e)}static union(t){return new Vr(t).union()}reduceToGeometries(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();let s=null;_(t,m)?s=this.unionTree(t):t instanceof q&&(s=t),e.add(s)}return e}extractByEnvelope(t,e,n){const s=new x;for(let i=0;i<e.getNumGeometries();i++){const r=e.getGeometryN(i);r.getEnvelopeInternal().intersects(t)?s.add(r):n.add(r)}return this._geomFactory.buildGeometry(s)}unionOptimized(t,e){const n=t.getEnvelopeInternal(),s=e.getEnvelopeInternal();if(!n.intersects(s)){return de.combine(t,e)}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);const i=n.intersection(s);return this.unionUsingEnvelopeIntersection(t,e,i)}union(){if(null===this._inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();const t=new Es(Vr.STRTREE_NODE_CAPACITY);for(let e=this._inputPolys.iterator();e.hasNext();){const n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;const e=t.itemsTree();return this.unionTree(e)}binaryUnion(){if(1===arguments.length){const t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(n-e<=1){const n=Vr.getGeometry(t,e);return this.unionSafe(n,null)}if(n-e==2)return this.unionSafe(Vr.getGeometry(t,e),Vr.getGeometry(t,e+1));{const s=Math.trunc((n+e)/2),i=this.binaryUnion(t,e,s),r=this.binaryUnion(t,s,n);return this.unionSafe(i,r)}}}repeatedUnion(t){let e=null;for(let n=t.iterator();n.hasNext();){const t=n.next();e=null===e?t.copy():e.union(t)}return e}unionSafe(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)}unionActual(t,e){return Vr.restrictToPolygons(t.union(e))}unionTree(t){const e=this.reduceToGeometries(t);return this.binaryUnion(e)}unionUsingEnvelopeIntersection(t,e,n){const s=new x,i=this.extractByEnvelope(n,t,s),r=this.extractByEnvelope(n,e,s),o=this.unionActual(i,r);return s.add(o),de.combine(s)}bufferUnion(){if(1===arguments.length){const t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().createGeometryCollection([t,e]).buffer(0)}}getClass(){return Vr}get interfaces_(){return[]}}Vr.constructor_=function(){this._inputPolys=null,this._geomFactory=null;const t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new x)},Vr.STRTREE_NODE_CAPACITY=4;class zr{constructor(){zr.constructor_.apply(this,arguments)}static union(){if(1===arguments.length){if(_(arguments[0],f)){const t=arguments[0];return new zr(t).union()}if(arguments[0]instanceof q){const t=arguments[0];return new zr(t).union()}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return new zr(t,e).union()}}unionNoOpt(t){const e=this._geomFact.createPoint();return lr.overlayOp(t,e,cr.UNION)}unionWithNull(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)}extract(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.extract(e)}}else if(arguments[0]instanceof q){const t=arguments[0];null===this._geomFact&&(this._geomFact=t.getFactory()),_e.extract(t,q.TYPENAME_POLYGON,this._polygons),_e.extract(t,q.TYPENAME_LINESTRING,this._lines),_e.extract(t,q.TYPENAME_POINT,this._points)}}union(){if(null===this._geomFact)return null;let t=null;if(this._points.size()>0){const e=this._geomFact.buildGeometry(this._points);t=this.unionNoOpt(e)}let e=null;if(this._lines.size()>0){const t=this._geomFact.buildGeometry(this._lines);e=this.unionNoOpt(t)}let n=null;this._polygons.size()>0&&(n=Vr.union(this._polygons));const s=this.unionWithNull(e,n);let i=null;return i=null===t?s:null===s?t:Br.union(t,s),null===i?this._geomFact.createGeometryCollection():i}getClass(){return zr}get interfaces_(){return[]}}zr.constructor_=function(){if(this._polygons=new x,this._lines=new x,this._points=new x,this._geomFact=null,1===arguments.length){if(_(arguments[0],f)){const t=arguments[0];this.extract(t)}else if(arguments[0]instanceof q){const t=arguments[0];this.extract(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geomFact=e,this.extract(t)}};var Yr=Object.freeze({__proto__:null,UnaryUnionOp:zr}),Ur=Object.freeze({__proto__:null,IsValidOp:Cr,ConsistentAreaTester:Er}),kr=Object.freeze({__proto__:null,BoundaryOp:pt,IsSimpleOp:Hs,buffer:wi,distance:Pi,linemerge:Xi,overlay:hr,polygonize:Pr,relate:qr,union:Yr,valid:Ur});class Xr extends Ft.CoordinateOperation{constructor(){super(),Xr.constructor_.apply(this,arguments)}edit(){if(2===arguments.length&&arguments[1]instanceof q&&arguments[0]instanceof Array){const t=arguments[0],e=arguments[1];if(0===t.length)return null;const n=new Array(t.length).fill(null);for(let e=0;e<t.length;e++){const s=new g(t[e]);this._targetPM.makePrecise(s),n[e]=s}const s=new I(n,!1).toCoordinateArray();let i=0;e instanceof Tt&&(i=2),e instanceof Dt&&(i=4);let r=n;return this._removeCollapsed&&(r=null),s.length<i?r:s}return super.edit.apply(this,arguments)}getClass(){return Xr}get interfaces_(){return[]}}Xr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0;const t=arguments[0],e=arguments[1];this._targetPM=t,this._removeCollapsed=e};class Hr{constructor(){Hr.constructor_.apply(this,arguments)}static reduce(t,e){return new Hr(e).reduce(t)}static reducePointwise(t,e){const n=new Hr(e);return n.setPointwise(!0),n.reduce(t)}fixPolygonalTopology(t){let e=t;this._changePrecisionModel||(e=this.changePM(t,this._targetPM));const n=Si.bufferOp(e,0);let s=n;return this._changePrecisionModel||(s=t.getFactory().createGeometry(n)),s}reducePointwise(t){let e=null;if(this._changePrecisionModel){const n=this.createFactory(t.getFactory(),this._targetPM);e=new Ft(n)}else e=new Ft;let n=this._removeCollapsed;return t.getDimension()>=2&&(n=!0),e.edit(t,new Xr(this._targetPM,n))}changePM(t,e){return this.createEditor(t.getFactory(),e).edit(t,new Ft.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,e){return new Ht(e,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){const e=this.reducePointwise(t);return this._isPointwise?e:_(e,Ot)?Cr.isValid(e)?e:this.fixPolygonalTopology(e):e}setPointwise(t){this._isPointwise=t}createEditor(t,e){if(t.getPrecisionModel()===e)return new Ft;const n=this.createFactory(t,e);return new Ft(n)}getClass(){return Hr}get interfaces_(){return[]}}Hr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;const t=arguments[0];this._targetPM=t};var Wr=Object.freeze({__proto__:null,GeometryPrecisionReducer:Hr});class jr{constructor(){jr.constructor_.apply(this,arguments)}static simplify(t,e){const n=new jr(t);return n.setDistanceTolerance(e),n.simplify()}simplifySection(t,e){if(t+1===e)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[e];let n=-1,s=t;for(let i=t+1;i<e;i++){const t=this._seg.distance(this._pts[i]);t>n&&(n=t,s=i)}if(n<=this._distanceTolerance)for(let n=t+1;n<e;n++)this._usePt[n]=!1;else this.simplifySection(t,s),this.simplifySection(s,e)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=new Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);const t=new I;for(let e=0;e<this._pts.length;e++)this._usePt[e]&&t.add(new g(this._pts[e]));return t.toCoordinateArray()}getClass(){return jr}get interfaces_(){return[]}}jr.constructor_=function(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new ee;const t=arguments[0];this._pts=t};class Kr{constructor(){Kr.constructor_.apply(this,arguments)}static simplify(t,e){const n=new Kr(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Zr(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return Kr}get interfaces_(){return[]}}class Zr extends me{constructor(){super(),Zr.constructor_.apply(this,arguments)}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):jr.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof bt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof Dt?s:null}getClass(){return Zr}get interfaces_(){return[]}}Zr.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e},Kr.DPTransformer=Zr,Kr.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t};class Qr extends ee{constructor(){super(),Qr.constructor_.apply(this,arguments)}getIndex(){return this._index}getParent(){return this._parent}getClass(){return Qr}get interfaces_(){return[]}}Qr.constructor_=function(){if(this._parent=null,this._index=null,2===arguments.length){const t=arguments[0],e=arguments[1];Qr.constructor_.call(this,t,e,null,-1)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ee.constructor_.call(this,t,e),this._parent=n,this._index=s}};class Jr{constructor(){Jr.constructor_.apply(this,arguments)}static extractCoordinates(t){const e=new Array(t.size()+1).fill(null);let n=null;for(let s=0;s<t.size();s++)n=t.get(s),e[s]=n.p0;return e[e.length-1]=n.p1,e}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString(Jr.extractCoordinates(this._resultSegs))}getResultSize(){const t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing(Jr.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){const t=this._parentLine.getCoordinates();this._segs=new Array(t.length-1).fill(null);for(let e=0;e<t.length-1;e++){const n=new Qr(t[e],t[e+1],this._parentLine,e);this._segs[e]=n}}getResultCoordinates(){return Jr.extractCoordinates(this._resultSegs)}getClass(){return Jr}get interfaces_(){return[]}}Jr.constructor_=function(){if(this._parentLine=null,this._segs=null,this._resultSegs=new x,this._minimumSize=null,1===arguments.length){const t=arguments[0];Jr.constructor_.call(this,t,2)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._parentLine=t,this._minimumSize=e,this.init()}};class $r{constructor(){$r.constructor_.apply(this,arguments)}remove(t){this._index.remove(new N(t.p0,t.p1),t)}add(){if(arguments[0]instanceof Jr){const t=arguments[0].getSegments();for(let e=0;e<t.length;e++){const n=t[e];this.add(n)}}else if(arguments[0]instanceof ee){const t=arguments[0];this._index.insert(new N(t.p0,t.p1),t)}}query(t){const e=new N(t.p0,t.p1),n=new to(t);return this._index.query(e,n),n.getItems()}getClass(){return $r}get interfaces_(){return[]}}$r.constructor_=function(){this._index=new us};class to{constructor(){to.constructor_.apply(this,arguments)}visitItem(t){const e=t;N.intersects(e.p0,e.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}getClass(){return to}get interfaces_(){return[Ae]}}to.constructor_=function(){this._querySeg=null,this._items=new x;const t=arguments[0];this._querySeg=t};class eo{constructor(){eo.constructor_.apply(this,arguments)}static isInLineSection(t,e,n){if(n.getParent()!==t.getParent())return!1;const s=n.getIndex();return s>=e[0]&&s<e[1]}flatten(t,e){const n=this._linePts[t],s=this._linePts[e],i=new ee(n,s);return this.remove(this._line,t,e),this._outputIndex.add(i),i}hasBadIntersection(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,e,n){n+=1;const s=new Array(2).fill(null);if(t+1===e){const e=this._line.getSegment(t);return this._line.addToResult(e),null}let i=!0;if(this._line.getResultSize()<this._line.getMinimumSize()){n+1<this._line.getMinimumSize()&&(i=!1)}const r=new Array(1).fill(null),o=this.findFurthestPoint(this._linePts,t,e,r);r[0]>this._distanceTolerance&&(i=!1);const l=new ee;if(l.p0=this._linePts[t],l.p1=this._linePts[e],s[0]=t,s[1]=e,this.hasBadIntersection(this._line,s,l)&&(i=!1),i){const n=this.flatten(t,e);return this._line.addToResult(n),null}this.simplifySection(t,o,n),this.simplifySection(o,e,n)}hasBadOutputIntersection(t){for(let e=this._outputIndex.query(t).iterator();e.hasNext();){const n=e.next();if(this.hasInteriorIntersection(n,t))return!0}return!1}findFurthestPoint(t,e,n,s){const i=new ee;i.p0=t[e],i.p1=t[n];let r=-1,o=e;for(let s=e+1;s<n;s++){const e=t[s],n=i.distance(e);n>r&&(r=n,o=s)}return s[0]=r,o}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,e,n){for(let s=e;s<n;s++){const e=t.getSegment(s);this._inputIndex.remove(e)}}hasInteriorIntersection(t,e){return this._li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,e,n){for(let s=this._inputIndex.query(n).iterator();s.hasNext();){const i=s.next();if(this.hasInteriorIntersection(i,n)){if(eo.isInLineSection(t,e,i))continue;return!0}}return!1}getClass(){return eo}get interfaces_(){return[]}}eo.constructor_=function(){this._li=new te,this._inputIndex=new $r,this._outputIndex=new $r,this._line=null,this._linePts=null,this._distanceTolerance=0;const t=arguments[0],e=arguments[1];this._inputIndex=t,this._outputIndex=e};class no{constructor(){no.constructor_.apply(this,arguments)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let e=t.iterator();e.hasNext();)this._inputIndex.add(e.next());for(let e=t.iterator();e.hasNext();){const t=new eo(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(e.next())}}getClass(){return no}get interfaces_(){return[]}}no.constructor_=function(){this._inputIndex=new $r,this._outputIndex=new $r,this._distanceTolerance=0};class so{constructor(){so.constructor_.apply(this,arguments)}static simplify(t,e){const n=new so(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){if(this._inputGeom.isEmpty())return this._inputGeom.copy();return this._linestringMap=new Ut,this._inputGeom.apply(new ro(this)),this._lineSimplifier.simplify(this._linestringMap.values()),new io(this._linestringMap).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}getClass(){return so}get interfaces_(){return[]}}class io extends me{constructor(){super(),io.constructor_.apply(this,arguments)}transformCoordinates(t,e){if(0===t.size())return null;if(e instanceof Tt){const t=this._linestringMap.get(e);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,e)}getClass(){return io}get interfaces_(){return[]}}io.constructor_=function(){this._linestringMap=null;const t=arguments[0];this._linestringMap=t};class ro{constructor(){ro.constructor_.apply(this,arguments)}filter(t){if(t instanceof Tt){const e=t;if(e.isEmpty())return null;const n=e.isClosed()?4:2,s=new Jr(e,n);this.tps._linestringMap.put(e,s)}}getClass(){return ro}get interfaces_(){return[G]}}ro.constructor_=function(){this.tps=null;const t=arguments[0];this.tps=t},so.LineStringTransformer=io,so.LineStringMapBuilderFilter=ro,so.constructor_=function(){this._inputGeom=null,this._lineSimplifier=new no,this._linestringMap=null;const t=arguments[0];this._inputGeom=t};class oo{constructor(){oo.constructor_.apply(this,arguments)}static simplify(t,e){return new oo(t,e).simplify()}simplifyVertex(t){let e=t,n=e.getArea(),s=null;for(;null!==e;){const t=e.getArea();t<n&&(n=t,s=e),e=e._next}return null!==s&&n<this._tolerance&&s.remove(),t.isLive()?n:-1}simplify(){const t=lo.buildLine(this._pts);let e=this._tolerance;do{e=this.simplifyVertex(t)}while(e<this._tolerance);const n=t.getCoordinates();return n.length<2?[n[0],new g(n[0])]:n}getClass(){return oo}get interfaces_(){return[]}}class lo{constructor(){lo.constructor_.apply(this,arguments)}static buildLine(t){let e=null,n=null;for(let s=0;s<t.length;s++){const i=new lo(t[s]);null===e&&(e=i),i.setPrev(n),null!==n&&(n.setNext(i),n.updateArea()),n=i}return e}getCoordinates(){const t=new I;let e=this;do{t.add(e._pt,!1),e=e._next}while(null!==e);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=lo.MAX_AREA,null;this._area=Math.abs(re.area(this._prev._pt,this._pt,this._next._pt))}remove(){const t=this._prev,e=this._next;let n=null;return null!==this._prev&&(this._prev.setNext(e),this._prev.updateArea(),n=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===n&&(n=this._next)),this._isLive=!1,n}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}getClass(){return lo}get interfaces_(){return[]}}lo.constructor_=function(){this._pt=null,this._prev=null,this._next=null,this._area=lo.MAX_AREA,this._isLive=!0;const t=arguments[0];this._pt=t},lo.MAX_AREA=i.MAX_VALUE,oo.VWVertex=lo,oo.constructor_=function(){this._pts=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._pts=t,this._tolerance=e*e};class ao{constructor(){ao.constructor_.apply(this,arguments)}static simplify(t,e){const n=new ao(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new co(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return ao}get interfaces_(){return[]}}class co extends me{constructor(){super(),co.constructor_.apply(this,arguments)}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):oo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof bt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof Dt?s:null}getClass(){return co}get interfaces_(){return[]}}co.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e},ao.VWTransformer=co,ao.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t};var ho=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:Kr,TopologyPreservingSimplifier:so,VWSimplifier:ao});class uo{constructor(){uo.constructor_.apply(this,arguments)}static pointAlongReverse(t,e){const n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n}splitAt(){if(1===arguments.length){const t=arguments[0],e=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(e),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=uo.pointAlongReverse(this._seg,e),null;this._splitPt=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this.getConstrainedLength(t)/this._segLen;e.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(n):this._splitPt=uo.pointAlongReverse(this._seg,n)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}getClass(){return uo}get interfaces_(){return[]}}uo.constructor_=function(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;const t=arguments[0];this._seg=t,this._segLen=t.getLength()};class go{constructor(){go.constructor_.apply(this,arguments)}findSplitPoint(t,e){}getClass(){return go}get interfaces_(){return[]}}go.constructor_=function(){};class _o{constructor(){_o.constructor_.apply(this,arguments)}static projectedSplitPoint(t,e){return t.getLineSegment().project(e)}findSplitPoint(t,e){const n=t.getLineSegment(),s=n.getLength()/2,i=new uo(n),r=_o.projectedSplitPoint(t,e);let o=2*r.distance(e)*.8;return o>s&&(o=s),i.setMinimumLength(o),i.splitAt(r),i.getSplitPoint()}getClass(){return _o}get interfaces_(){return[go]}}_o.constructor_=function(){};class fo{constructor(){fo.constructor_.apply(this,arguments)}static triArea(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static isInCircleDDNormalized(t,e,n,s){const i=R.valueOf(t.x).selfSubtract(s.x),r=R.valueOf(t.y).selfSubtract(s.y),o=R.valueOf(e.x).selfSubtract(s.x),l=R.valueOf(e.y).selfSubtract(s.y),a=R.valueOf(n.x).selfSubtract(s.x),c=R.valueOf(n.y).selfSubtract(s.y),h=i.multiply(l).selfSubtract(o.multiply(r)),u=o.multiply(c).selfSubtract(a.multiply(l)),g=a.multiply(r).selfSubtract(i.multiply(c)),d=i.multiply(i).selfAdd(r.multiply(r)),_=o.multiply(o).selfAdd(l.multiply(l)),f=a.multiply(a).selfAdd(c.multiply(c));return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(f.selfMultiply(h)).doubleValue()>0}static checkRobustInCircle(t,e,n,s){const i=fo.isInCircleNonRobust(t,e,n,s),r=fo.isInCircleDDSlow(t,e,n,s),o=fo.isInCircleCC(t,e,n,s),l=re.circumcentre(t,e,n);O.out.println("p radius diff a = "+Math.abs(s.distance(l)-t.distance(l))/t.distance(l)),i===r&&i===o||(O.out.println("inCircle robustness failure (double result = "+i+", DD result = "+r+", CC result = "+o+")"),O.out.println(Jt.toLineString(new zt([t,e,n,s]))),O.out.println("Circumcentre = "+Jt.toPoint(l)+" radius = "+t.distance(l)),O.out.println("p radius diff a = "+Math.abs(s.distance(l)/t.distance(l)-1)),O.out.println("p radius diff b = "+Math.abs(s.distance(l)/e.distance(l)-1)),O.out.println("p radius diff c = "+Math.abs(s.distance(l)/n.distance(l)-1)),O.out.println())}static isInCircleDDFast(t,e,n,s){const i=R.sqr(t.x).selfAdd(R.sqr(t.y)).selfMultiply(fo.triAreaDDFast(e,n,s)),r=R.sqr(e.x).selfAdd(R.sqr(e.y)).selfMultiply(fo.triAreaDDFast(t,n,s)),o=R.sqr(n.x).selfAdd(R.sqr(n.y)).selfMultiply(fo.triAreaDDFast(t,e,s)),l=R.sqr(s.x).selfAdd(R.sqr(s.y)).selfMultiply(fo.triAreaDDFast(t,e,n));return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue()>0}static isInCircleCC(t,e,n,s){const i=re.circumcentre(t,e,n),r=t.distance(i);return s.distance(i)-r<=0}static isInCircleNormalized(t,e,n,s){const i=t.x-s.x,r=t.y-s.y,o=e.x-s.x,l=e.y-s.y,a=n.x-s.x,c=n.y-s.y;return(i*i+r*r)*(o*c-a*l)+(o*o+l*l)*(a*r-i*c)+(a*a+c*c)*(i*l-o*r)>0}static isInCircleDDSlow(t,e,n,s){const i=R.valueOf(s.x),r=R.valueOf(s.y),o=R.valueOf(t.x),l=R.valueOf(t.y),a=R.valueOf(e.x),c=R.valueOf(e.y),h=R.valueOf(n.x),u=R.valueOf(n.y),g=o.multiply(o).add(l.multiply(l)).multiply(fo.triAreaDDSlow(a,c,h,u,i,r)),d=a.multiply(a).add(c.multiply(c)).multiply(fo.triAreaDDSlow(o,l,h,u,i,r)),_=h.multiply(h).add(u.multiply(u)).multiply(fo.triAreaDDSlow(o,l,a,c,i,r)),f=i.multiply(i).add(r.multiply(r)).multiply(fo.triAreaDDSlow(o,l,a,c,h,u));return g.subtract(d).add(_).subtract(f).doubleValue()>0}static isInCircleNonRobust(t,e,n,s){return(t.x*t.x+t.y*t.y)*fo.triArea(e,n,s)-(e.x*e.x+e.y*e.y)*fo.triArea(t,n,s)+(n.x*n.x+n.y*n.y)*fo.triArea(t,e,s)-(s.x*s.x+s.y*s.y)*fo.triArea(t,e,n)>0}static isInCircleRobust(t,e,n,s){return fo.isInCircleNormalized(t,e,n,s)}static triAreaDDSlow(t,e,n,s,i,r){return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)))}static triAreaDDFast(t,e,n){const s=R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(n.y).selfSubtract(t.y)),i=R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(n.x).selfSubtract(t.x));return s.selfSubtract(i)}getClass(){return fo}get interfaces_(){return[]}}fo.constructor_=function(){};class po{constructor(){po.constructor_.apply(this,arguments)}static interpolateZ(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.distance(n),i=t.distance(e),r=n.z-e.z;return e.z+r*(i/s)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.z+d*(n.z-e.z)+_*(s.z-e.z)}}circleCenter(t,e){const n=new po(this.getX(),this.getY()),s=this.bisector(n,t),i=this.bisector(t,e),r=new b(s,i);let o=null;try{o=new po(r.getX(),r.getY())}catch(s){if(!(s instanceof S))throw s;O.err.println("a: "+n+"  b: "+t+"  c: "+e),O.err.println(s)}return o}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.z}bisector(t,e){const n=e.getX()-t.getX(),s=e.getY()-t.getY(),i=new b(t.getX()+n/2,t.getY()+s/2,1),r=new b(t.getX()-s+n/2,t.getY()+n+s/2,1);return new b(i,r)}equals(){if(1===arguments.length){const t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._p.distance(t.getCoordinate())<e}}getCoordinate(){return this._p}isInCircle(t,e,n){return fo.isInCircleRobust(t._p,e._p,n._p,this._p)}interpolateZValue(t,e,n){const s=t.getX(),i=t.getY(),r=e.getX()-s,o=n.getX()-s,l=e.getY()-i,a=n.getY()-i,c=r*a-o*l,h=this.getX()-s,u=this.getY()-i,g=(a*h-o*u)/c,d=(-l*h+r*u)/c;return t.getZ()+g*(e.getZ()-t.getZ())+d*(n.getZ()-t.getZ())}midPoint(t){const e=(this._p.x+t.getX())/2,n=(this._p.y+t.getY())/2,s=(this._p.z+t.getZ())/2;return new po(e,n,s)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,e){return(t._p.x-this._p.x)*(e._p.y-this._p.y)-(t._p.y-this._p.y)*(e._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.z=t}times(t){return new po(t*this._p.x,t*this._p.y)}cross(){return new po(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new po(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,e){const n=e.sub(t),s=this.sub(t),i=n.crossProduct(s);return i>0?po.LEFT:i<0?po.RIGHT:n.getX()*s.getX()<0||n.getY()*s.getY()<0?po.BEHIND:n.magn()<s.magn()?po.BEYOND:t.equals(this)?po.ORIGIN:e.equals(this)?po.DESTINATION:po.BETWEEN}sum(t){return new po(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))}circumRadiusRatio(t,e){const n=this.circleCenter(t,e),s=this.distance(n,t);let i=this.distance(this,t),r=this.distance(t,e);return r<i&&(i=r),r=this.distance(e,this),r<i&&(i=r),s/i}getClass(){return po}get interfaces_(){return[]}}po.constructor_=function(){if(this._p=null,1===arguments.length){const t=arguments[0];this._p=new g(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new g(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new g(t,e,n)}},po.LEFT=0,po.RIGHT=1,po.BEYOND=2,po.BEHIND=3,po.BETWEEN=4,po.ORIGIN=5,po.DESTINATION=6;class mo extends po{constructor(){super(),mo.constructor_.apply(this,arguments)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}getClass(){return mo}get interfaces_(){return[]}}mo.constructor_=function(){this._isOnConstraint=null,this._constraint=null;const t=arguments[0];po.constructor_.call(this,t)};class yo{constructor(){yo.constructor_.apply(this,arguments)}static makeEdge(t,e){const n=new yo,s=new yo,i=new yo,r=new yo;n._rot=s,s._rot=i,i._rot=r,r._rot=n,n.setNext(n),s.setNext(r),i.setNext(i),r.setNext(s);const o=n;return o.setOrig(t),o.setDest(e),o}static swap(t){const e=t.oPrev(),n=t.sym().oPrev();yo.splice(t,e),yo.splice(t.sym(),n),yo.splice(t,e.lNext()),yo.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())}static splice(t,e){const n=t.oNext().rot(),s=e.oNext().rot(),i=e.oNext(),r=t.oNext(),o=s.oNext(),l=n.oNext();t.setNext(i),e.setNext(r),n.setNext(o),s.setNext(l)}static connect(t,e){const n=yo.makeEdge(t.dest(),e.orig());return yo.splice(n,t.lNext()),yo.splice(n.sym(),e),n}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new ee(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){const t=this._vertex.getCoordinate(),e=this.dest().getCoordinate();return Jt.toLineString(t,e)}isLive(){return null!==this._rot}getPrimary(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}getClass(){return yo}get interfaces_(){return[]}}yo.constructor_=function(){this._rot=null,this._vertex=null,this._next=null,this._data=null};class xo{constructor(){xo.constructor_.apply(this,arguments)}insertSite(t){let e=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(e,t))return e;this._subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this._subdiv.delete(e.oNext()));let n=this._subdiv.makeEdge(e.orig(),t);yo.splice(n,e);const s=n;do{n=this._subdiv.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);for(;;){const i=e.oPrev();if(i.dest().rightOf(e)&&t.isInCircle(e.orig(),i.dest(),e.dest()))yo.swap(e),e=e.oPrev();else{if(e.oNext()===s)return n;e=e.oNext().lPrev()}}}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getClass(){return xo}get interfaces_(){return[]}}xo.constructor_=function(){this._subdiv=null,this._isUsingTolerance=!1;const t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0};class Eo{constructor(){Eo.constructor_.apply(this,arguments)}locate(t){}getClass(){return Eo}get interfaces_(){return[]}}Eo.constructor_=function(){};class Io{constructor(){Io.constructor_.apply(this,arguments)}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();const e=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=e,e}findEdge(){return this._subdiv.getEdges().iterator().next()}getClass(){return Io}get interfaces_(){return[Eo]}}Io.constructor_=function(){this._subdiv=null,this._lastEdge=null;const t=arguments[0];this._subdiv=t,this.init()};class No extends c{constructor(){super(),No.constructor_.apply(this,arguments)}static msgWithSpatial(t,e){return null!==e?t+" [ "+e+" ]":t}getSegment(){return this._seg}getClass(){return No}get interfaces_(){return[]}}No.constructor_=function(){if(this._seg=null,1===arguments.length){if("string"==typeof arguments[0]){const t=arguments[0];c.constructor_.call(this,t)}else if(arguments[0]instanceof ee){const t=arguments[0];c.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new ee(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];c.constructor_.call(this,No.msgWithSpatial(t,e)),this._seg=new ee(e)}};class Co{constructor(){Co.constructor_.apply(this,arguments)}visit(t){}getClass(){return Co}get interfaces_(){return[]}}Co.constructor_=function(){};class So{constructor(){So.constructor_.apply(this,arguments)}static getTriangleEdges(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new n("Edges do not form a triangle")}getTriangleVertices(t){const e=new To;return this.visitTriangles(e,t),e.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||(!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2]))}isVertexOfEdge(t,e){return!(!e.equals(t.orig(),this._tolerance)&&!e.equals(t.dest(),this._tolerance))}connect(t,e){const n=yo.connect(t,e);return this._quadEdges.add(n),n}getVoronoiCellPolygon(t,e){const n=new x,s=t;do{const e=t.rot().orig().getCoordinate();n.add(e),t=t.oPrev()}while(t!==s);const i=new I;i.addAll(n,!1),i.closeRing(),i.size()<4&&(O.out.println(i),i.add(i.get(i.size()-1),!0));const r=i.toCoordinateArray(),o=e.createPolygon(e.createLinearRing(r)),l=s.orig();return o.setUserData(l.getCoordinate()),o}setLocator(t){this._locator=t}initSubdiv(){const t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),e=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);yo.splice(t.sym(),e);const n=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return yo.splice(e.sym(),n),yo.splice(n.sym(),t),t}isFrameBorderEdge(t){const e=new Array(3).fill(null);So.getTriangleEdges(t,e);const n=new Array(3).fill(null);So.getTriangleEdges(t.sym(),n);const s=t.lNext().dest();if(this.isFrameVertex(s))return!0;const i=t.sym().lNext().dest();return!!this.isFrameVertex(i)}makeEdge(t,e){const n=yo.makeEdge(t,e);return this._quadEdges.add(n),n}visitTriangles(t,e){this._visitedKey++;const n=new on;n.push(this._startingEdge);const s=new J;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=this.fetchTriangleToVisit(i,n,e,s);null!==r&&t.visit(r)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,e){return this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate()),this._seg.distance(e)<this._edgeCoincidenceTolerance}getEnvelope(){return new N(this._frameEnv)}createFrame(t){const e=t.getWidth(),n=t.getHeight();let s=0;s=e>n?10*e:10*n,this._frameVertex[0]=new po((t.getMaxX()+t.getMinX())/2,t.getMaxY()+s),this._frameVertex[1]=new po(t.getMinX()-s,t.getMinY()-s),this._frameVertex[2]=new po(t.getMaxX()+s,t.getMinY()-s),this._frameEnv=new N(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){const e=new Ro;return this.visitTriangles(e,t),e.getTriangles()}getVertices(t){const e=new J;for(let n=this._quadEdges.iterator();n.hasNext();){const s=n.next(),i=s.orig();!t&&this.isFrameVertex(i)||e.add(i);const r=s.dest();!t&&this.isFrameVertex(r)||e.add(r)}return e}fetchTriangleToVisit(t,e,n,s){let i=t,r=0,o=!1;do{this._triEdges[r]=i,this.isFrameEdge(i)&&(o=!0);const t=i.sym();s.contains(t)||e.push(t),s.add(i),r++,i=i.lNext()}while(i!==t);return o&&!n?null:this._triEdges}getEdges(){if(0===arguments.length)return this._quadEdges;if(1===arguments.length){const t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createLineString([e.orig().getCoordinate(),e.dest().getCoordinate()])}return t.createMultiLineString(n)}}getVertexUniqueEdges(t){const e=new x,n=new J;for(let s=this._quadEdges.iterator();s.hasNext();){const i=s.next(),r=i.orig();n.contains(r)||(n.add(r),!t&&this.isFrameVertex(r)||e.add(i));const o=i.sym(),l=o.orig();n.contains(l)||(n.add(l),!t&&this.isFrameVertex(l)||e.add(o))}return e}getTriangleEdges(t){const e=new Lo;return this.visitTriangles(e,t),e.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;const e=new x,n=new on;n.push(this._startingEdge);const s=new J;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=i.getPrimary();!t&&this.isFrameEdge(r)||e.add(r),n.push(i.oNext()),n.push(i.sym().oNext()),s.add(i),s.add(i.sym())}}return e}delete(t){yo.splice(t,t.oPrev()),yo.splice(t.sym(),t.sym().oPrev());const e=t.sym(),n=t.rot(),s=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(e),this._quadEdges.remove(n),this._quadEdges.remove(s),t.delete(),e.delete(),n.delete(),s.delete()}locateFromEdge(t,e){let n=0;const s=this._quadEdges.size();let i=e;for(;;){if(n++,n>s)throw new No(i.toLineSegment());if(t.equals(i.orig())||t.equals(i.dest()))break;if(t.rightOf(i))i=i.sym();else if(t.rightOf(i.oNext())){if(t.rightOf(i.dPrev()))break;i=i.dPrev()}else i=i.oNext()}return i}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new wo,!0);const e=new x;for(let n=this.getVertexUniqueEdges(!1).iterator();n.hasNext();){const s=n.next();e.add(this.getVoronoiCellPolygon(s,t))}return e}getVoronoiDiagram(t){const e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Ht.toGeometryArray(e))}getTriangles(t){const e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createPolygon(t.createLinearRing(e))}return t.createGeometryCollection(n)}insertSite(t){let e=this.locate(t);if(t.equals(e.orig(),this._tolerance)||t.equals(e.dest(),this._tolerance))return e;let n=this.makeEdge(e.orig(),t);yo.splice(n,e);const s=n;do{n=this.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);return s}locate(){if(1===arguments.length){if(arguments[0]instanceof po){const t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof g){const t=arguments[0];return this._locator.locate(new po(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._locator.locate(new po(t));if(null===n)return null;let s=n;n.dest().getCoordinate().equals2D(t)&&(s=n.sym());let i=s;do{if(i.dest().getCoordinate().equals2D(e))return i;i=i.oNext()}while(i!==s);return null}}getClass(){return So}get interfaces_(){return[]}}class wo{constructor(){wo.constructor_.apply(this,arguments)}visit(t){const e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),s=t[2].orig().getCoordinate(),i=re.circumcentre(e,n,s),r=new po(i);for(let e=0;e<3;e++)t[e].rot().setOrig(r)}getClass(){return wo}get interfaces_(){return[Co]}}wo.constructor_=function(){};class Lo{constructor(){Lo.constructor_.apply(this,arguments)}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}getClass(){return Lo}get interfaces_(){return[Co]}}Lo.constructor_=function(){this._triList=new x};class To{constructor(){To.constructor_.apply(this,arguments)}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}getClass(){return To}get interfaces_(){return[Co]}}To.constructor_=function(){this._triList=new x};class Ro{constructor(){Ro.constructor_.apply(this,arguments)}checkTriangleSize(t){let e="";t.length>=2?e=Jt.toLineString(t[0],t[1]):t.length>=1&&(e=Jt.toPoint(t[0]))}visit(t){this._coordList.clear();for(let e=0;e<3;e++){const n=t[e].orig();this._coordList.add(n.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();const t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}getClass(){return Ro}get interfaces_(){return[Co]}}Ro.constructor_=function(){this._coordList=new I,this._triCoords=new x},So.TriangleCircumcentreVisitor=wo,So.TriangleEdgesListVisitor=Lo,So.TriangleVertexListVisitor=To,So.TriangleCoordinatesVisitor=Ro,So.constructor_=function(){this._visitedKey=0,this._quadEdges=new x,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=new Array(3).fill(null),this._frameEnv=null,this._locator=null,this._seg=new ee,this._triEdges=new Array(3).fill(null);const t=arguments[0],e=arguments[1];this._tolerance=e,this._edgeCoincidenceTolerance=e/So.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new Io(this)},So.EDGE_COINCIDENCE_TOL_FACTOR=1e3;class Po{constructor(){Po.constructor_.apply(this,arguments)}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).z}getStartZ(){return this._ls.getCoordinate(0).z}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}getClass(){return Po}get interfaces_(){return[]}}Po.constructor_=function(){if(this._ls=null,this._data=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._ls=new ee(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._ls=new ee(t,e),this._data=n}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];Po.constructor_.call(this,new g(t,e,n),new g(s,i,r))}else if(7===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6];Po.constructor_.call(this,new g(t,e,n),new g(s,i,r),o)}};class vo{constructor(){vo.constructor_.apply(this,arguments)}static computeVertexEnvelope(t){const e=new N;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t.getCoordinate())}return e}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,e=0;do{e=this.enforceGabriel(this._segments),t++}while(e>0&&t<vo.MAX_SPLIT_ITER)}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){const t=new Array(this._initialVertices.size()+this._segVertices.size()).fill(null);let e=0;for(let n=this._initialVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}for(let n=this._segVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}return t}setConstraints(t,e){this._segments=t,this._segVertices=e}computeConvexHull(){const t=new Ht,e=this.getPointArray(),n=new an(e,t);this._convexHull=n.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){const e=t.getStart(),n=t.getEnd(),s=new g((e.x+n.x)/2,(e.y+n.y)/2),r=e.distance(s),o=new N(s);o.expandBy(r);const l=this._kdt.query(o);let a=null,c=i.MAX_VALUE;for(let t=l.iterator();t.hasNext();){const i=t.next().getCoordinate();if(i.equals2D(e)||i.equals2D(n))continue;const o=s.distance(i);if(o<r){const t=o;(null===a||t<c)&&(a=i,c=t)}}return a}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){const e=new x;let n=0;const s=new x;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=this.findNonGabrielPoint(t);if(null===r)continue;this._splitPt=this._splitFinder.findSplitPoint(t,r);const o=this.createVertex(this._splitPt,t);this.insertSite(o).getCoordinate().equals2D(this._splitPt);const l=new Po(t.getStartX(),t.getStartY(),t.getStartZ(),o.getX(),o.getY(),o.getZ(),t.getData()),a=new Po(o.getX(),o.getY(),o.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());e.add(l),e.add(a),s.add(t),n+=1}return t.removeAll(s),t.addAll(e),n}createVertex(){if(1===arguments.length){const t=arguments[0];let e=null;return e=null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new mo(t),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null;return n=null!==this._vertexFactory?this._vertexFactory.createVertex(t,e):new mo(t),n.setOnConstraint(!0),n}}getSubdivision(){return this._subdiv}computeBoundingBox(){const t=vo.computeVertexEnvelope(this._initialVertices),e=vo.computeVertexEnvelope(this._segVertices),n=new N(t);n.expandToInclude(e);const s=.2*n.getWidth(),i=.2*n.getHeight(),r=Math.max(s,i);this._computeAreaEnv=new N(n),this._computeAreaEnv.expandBy(r)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new So(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new Io(this._subdiv)),this._incDel=new xo(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof mo){const t=arguments[0],e=this._kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){const n=e.getData();return n.merge(t),n}return this._incDel.insertSite(t),t}if(arguments[0]instanceof g){const t=arguments[0];this.insertSite(this.createVertex(t))}}getClass(){return vo}get interfaces_(){return[]}}vo.constructor_=function(){this._initialVertices=null,this._segVertices=null,this._segments=new x,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new _o,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._initialVertices=new x(t),this._tolerance=e,this._kdt=new es(e)},vo.MAX_SPLIT_ITER=99;class Oo{constructor(){Oo.constructor_.apply(this,arguments)}static extractUniqueCoordinates(t){if(null===t)return new I;const e=t.getCoordinates();return Oo.unique(e)}static envelope(t){const e=new N;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t)}return e}static unique(t){const e=X.copyDeep(t);return ht.sort(e),new I(e,!1)}static toVertices(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new po(t))}return e}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords),e=Oo.toVertices(this._siteCoords);this._subdiv=new So(t,this._tolerance),new xo(this._subdiv).insertSites(e)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){const t=arguments[0];this._siteCoords=Oo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){const t=arguments[0];this._siteCoords=Oo.unique(X.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}getClass(){return Oo}get interfaces_(){return[]}}Oo.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null};class bo{constructor(){bo.constructor_.apply(this,arguments)}static createConstraintSegments(){if(1===arguments.length){const t=arguments[0],e=xe.getLines(t),n=new x;for(let t=e.iterator();t.hasNext();){const e=t.next();bo.createConstraintSegments(e,n)}return n}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates();for(let t=1;t<n.length;t++)e.add(new Po(n[t-1],n[t]))}}createSiteVertices(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();this._constraintVertexMap.containsKey(t)||e.add(new mo(t))}return e}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords);let e=new x;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),e=bo.createConstraintSegments(this._constraintLines));const n=this.createSiteVertices(this._siteCoords),s=new vo(n,this._tolerance);s.setConstraints(e,new x(this._constraintVertexMap.values())),s.formInitialDelaunay(),s.enforceConstraints(),this._subdiv=s.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=Oo.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){const e=t.getCoordinates();for(let t=0;t<e.length;t++){const n=new mo(e[t]);this._constraintVertexMap.put(e[t],n)}}getClass(){return bo}get interfaces_(){return[]}}bo.constructor_=function(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new rt};class Mo{constructor(){Mo.constructor_.apply(this,arguments)}static clipGeometryCollection(t,e){const n=t.getFactory().toGeometry(e),s=new x;for(let i=0;i<t.getNumGeometries();i++){const r=t.getGeometryN(i);let o=null;e.contains(r.getEnvelopeInternal())?o=r:e.intersects(r.getEnvelopeInternal())&&(o=n.intersection(r),o.setUserData(r.getUserData())),null===o||o.isEmpty()||s.add(o)}return t.getFactory().createGeometryCollection(Ht.toGeometryArray(s))}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords);this._diagramEnv=t;const e=Math.max(this._diagramEnv.getWidth(),this._diagramEnv.getHeight());this._diagramEnv.expandBy(e),null!==this._clipEnv&&this._diagramEnv.expandToInclude(this._clipEnv);const n=Oo.toVertices(this._siteCoords);this._subdiv=new So(t,this._tolerance),new xo(this._subdiv).insertSites(n)}getDiagram(t){this.create();const e=this._subdiv.getVoronoiDiagram(t);return Mo.clipGeometryCollection(e,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){const t=arguments[0];this._siteCoords=Oo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){const t=arguments[0];this._siteCoords=Oo.unique(X.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}getClass(){return Mo}get interfaces_(){return[]}}Mo.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null};var Do=Object.freeze({__proto__:null,Vertex:po}),Ao=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:bo,DelaunayTriangulationBuilder:Oo,VoronoiDiagramBuilder:Mo,quadedge:Do});class Fo{constructor(){Fo.constructor_.apply(this,arguments)}static getEndLocation(t){const e=new Fo;return e.setToEnd(t),e}static pointAlongSegmentByFraction(t,e,n){if(n<=0)return t;if(n>=1)return e;const s=(e.x-t.x)*n+t.x,i=(e.y-t.y)*n+t.y,r=(e.z-t.z)*n+t.z;return new g(s,i,r)}static compareLocationValues(t,e,n,s,i,r){return t<s?-1:t>s?1:e<i?-1:e>i?1:n<r?-1:n>r?1:0}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){const e=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex>=e||this._segmentIndex===e&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;const e=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>e.getNumPoints())&&((this._segmentIndex!==e.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1))}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){const e=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex<e?this:new Fo(this._componentIndex,e,1,!1)}getCoordinate(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=e.getNumPoints()-1)return n;const s=e.getCoordinateN(this._segmentIndex+1);return Fo.pointAlongSegmentByFraction(n,s,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=e.getNumPoints()-1){const t=e.getCoordinateN(e.getNumPoints()-2);return new ee(t,n)}const s=e.getCoordinateN(this._segmentIndex+1);return new ee(n,s)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){const e=t.getGeometryN(this._componentIndex);this._segmentIndex=e.getNumPoints()-1,this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;const e=t.getGeometryN(this._componentIndex);this._segmentIndex=e.getNumPoints()-1,this._segmentFraction=1}compareTo(t){const e=t;return this._componentIndex<e._componentIndex?-1:this._componentIndex>e._componentIndex?1:this._segmentIndex<e._segmentIndex?-1:this._segmentIndex>e._segmentIndex?1:this._segmentFraction<e._segmentFraction?-1:this._segmentFraction>e._segmentFraction?1:0}copy(){return new Fo(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||(t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction))}snapToVertex(t,e){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;const n=this.getSegmentLength(t),s=this._segmentFraction*n,i=n-s;s<=i&&s<e?this._segmentFraction=0:i<=s&&i<e&&(this._segmentFraction=1)}compareLocationValues(t,e,n){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<e?-1:this._segmentIndex>e?1:this._segmentFraction<n?-1:this._segmentFraction>n?1:0}getSegmentLength(t){const e=t.getGeometryN(this._componentIndex);let n=this._segmentIndex;this._segmentIndex>=e.getNumPoints()-1&&(n=e.getNumPoints()-2);const s=e.getCoordinateN(n),i=e.getCoordinateN(n+1);return s.distance(i)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}getClass(){return Fo}get interfaces_(){return[r]}}Fo.constructor_=function(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Fo.constructor_.call(this,0,t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,this.normalize()}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,s&&this.normalize()}};class Go{constructor(){Go.constructor_.apply(this,arguments)}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}getClass(){return Go}get interfaces_(){return[]}}Go.constructor_=function(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1===arguments.length){const t=arguments[0];Go.constructor_.call(this,t,0,0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Go.constructor_.call(this,t,e.getComponentIndex(),Go.segmentEndVertexIndex(e))}else if(3===arguments.length){const t=arguments[0],e=arguments[1],s=arguments[2];if(!_(t,ot))throw new n("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=e,this._vertexIndex=s,this.loadCurrentLine()}};class qo{constructor(){qo.constructor_.apply(this,arguments)}static indexOf(t,e){return new qo(t).indexOf(e)}static indexOfAfter(t,e,n){return new qo(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,e){let n=i.MAX_VALUE,s=0,r=0,o=-1;const l=new ee;for(let i=new Go(this._linearGeom);i.hasNext();i.next())if(!i.isEndOfLine()){l.p0=i.getSegmentStart(),l.p1=i.getSegmentEnd();const a=l.distance(t),c=l.segmentFraction(t),h=i.getComponentIndex(),u=i.getVertexIndex();a<n&&(null===e||e.compareLocationValues(h,u,c)<0)&&(s=h,r=u,o=c,n=a)}return n===i.MAX_VALUE?new Fo(e):new Fo(s,r,o)}indexOfAfter(t,e){if(null===e)return this.indexOf(t);const n=Fo.getEndLocation(this._linearGeom);if(n.compareTo(e)<=0)return n;const s=this.indexOfFromStart(t,e);return u.isTrue(s.compareTo(e)>=0,"computed location is before specified minimum location"),s}getClass(){return qo}get interfaces_(){return[]}}qo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Bo{constructor(){Bo.constructor_.apply(this,arguments)}static indicesOf(t,e){return new Bo(t).indicesOf(e)}indicesOf(t){const e=t.getGeometryN(0).getCoordinateN(0),n=t.getGeometryN(t.getNumGeometries()-1),s=n.getCoordinateN(n.getNumPoints()-1),i=new qo(this._linearGeom),r=new Array(2).fill(null);return r[0]=i.indexOf(e),0===t.getLength()?r[1]=r[0].copy():r[1]=i.indexOfAfter(s,r[0]),r}getClass(){return Bo}get interfaces_(){return[]}}Bo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Vo{constructor(){Vo.constructor_.apply(this,arguments)}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&this._coordList.size()<2)return this._coordList=null,null;const t=this._coordList.toCoordinateArray();let e=t;this._fixInvalidLines&&(e=this.validCoordinateSequence(t)),this._coordList=null;let s=null;try{s=this._geomFact.createLineString(e)}catch(t){if(!(t instanceof n))throw t;if(!this._ignoreInvalidLines)throw t}null!==s&&this._lines.add(s)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1===arguments.length){const t=arguments[0];this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];null===this._coordList&&(this._coordList=new I),this._coordList.add(t,e),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){if(t.length>=2)return t;return[t[0],t[0]]}getClass(){return Vo}get interfaces_(){return[]}}Vo.constructor_=function(){this._geomFact=null,this._lines=new x,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;const t=arguments[0];this._geomFact=t};class zo{constructor(){zo.constructor_.apply(this,arguments)}static extract(t,e,n){return new zo(t).extract(e,n)}computeLinear(t,e){const n=new Vo(this._line.getFactory());n.setFixInvalidLines(!0),t.isVertex()||n.add(t.getCoordinate(this._line));for(let s=new Go(this._line,t);s.hasNext()&&!(e.compareLocationValues(s.getComponentIndex(),s.getVertexIndex(),0)<0);s.next()){const t=s.getSegmentStart();n.add(t),s.isEndOfLine()&&n.endLine()}return e.isVertex()||n.add(e.getCoordinate(this._line)),n.getGeometry()}computeLine(t,e){const n=this._line.getCoordinates(),s=new I;let i=t.getSegmentIndex();t.getSegmentFraction()>0&&(i+=1);let r=e.getSegmentIndex();1===e.getSegmentFraction()&&(r+=1),r>=n.length&&(r=n.length-1),t.isVertex()||s.add(t.getCoordinate(this._line));for(let t=i;t<=r;t++)s.add(n[t]);e.isVertex()||s.add(e.getCoordinate(this._line)),s.size()<=0&&s.add(t.getCoordinate(this._line));let o=s.toCoordinateArray();return o.length<=1&&(o=[o[0],o[0]]),this._line.getFactory().createLineString(o)}extract(t,e){return e.compareTo(t)<0?this.reverse(this.computeLinear(e,t)):this.computeLinear(t,e)}reverse(t){return t instanceof Tt||t instanceof ft?t.reverse():(u.shouldNeverReachHere("non-linear geometry encountered"),null)}getClass(){return zo}get interfaces_(){return[]}}zo.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class Yo{constructor(){Yo.constructor_.apply(this,arguments)}clampIndex(t){const e=t.copy();return e.clamp(this._linearGeom),e}project(t){return qo.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof Tt||this._linearGeom instanceof ft))throw new n("Input geometry must be linear")}extractPoint(){if(1===arguments.length){return arguments[0].getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return Fo.getEndLocation(this._linearGeom)}getStartIndex(){return new Fo}indexOfAfter(t,e){return qo.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){return zo.extract(this._linearGeom,t,e)}indexOf(t){return qo.indexOf(this._linearGeom,t)}indicesOf(t){return Bo.indicesOf(this._linearGeom,t)}getClass(){return Yo}get interfaces_(){return[]}}Yo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t,this.checkGeometryType()};class Uo{constructor(){Uo.constructor_.apply(this,arguments)}static indexOf(t,e){return new Uo(t).indexOf(e)}static indexOfAfter(t,e,n){return new Uo(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,e){let n=i.MAX_VALUE,s=e,r=0;const o=new ee,l=new Go(this._linearGeom);for(;l.hasNext();){if(!l.isEndOfLine()){o.p0=l.getSegmentStart(),o.p1=l.getSegmentEnd();const i=o.distance(t),a=this.segmentNearestMeasure(o,t,r);i<n&&a>e&&(s=a,n=i),r+=o.getLength()}l.next()}return s}indexOfAfter(t,e){if(e<0)return this.indexOf(t);const n=this._linearGeom.getLength();if(n<e)return n;const s=this.indexOfFromStart(t,e);return u.isTrue(s>=e,"computed index is before specified minimum index"),s}segmentNearestMeasure(t,e,n){const s=t.projectionFactor(e);return s<=0?n:s<=1?n+s*t.getLength():n+t.getLength()}getClass(){return Uo}get interfaces_(){return[]}}Uo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class ko{constructor(){ko.constructor_.apply(this,arguments)}static getLength(t,e){return new ko(t).getLength(e)}static getLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new ko(t).getLocation(e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new ko(t).getLocation(e,n)}}getLength(t){let e=0;const n=new Go(this._linearGeom);for(;n.hasNext();){if(!n.isEndOfLine()){const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(t.getComponentIndex()===n.getComponentIndex()&&t.getSegmentIndex()===n.getVertexIndex())return e+i*t.getSegmentFraction();e+=i}n.next()}return e}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let e=t.getComponentIndex();if(e>=this._linearGeom.getNumGeometries()-1)return t;do{e++}while(e<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(e).getLength());return new Fo(e,0,0)}getLocation(){if(1===arguments.length){const t=arguments[0];return this.getLocation(t,!0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=t;if(t<0){n=this._linearGeom.getLength()+t}const s=this.getLocationForward(n);return e?s:this.resolveHigher(s)}}getLocationForward(t){if(t<=0)return new Fo;let e=0;const n=new Go(this._linearGeom);for(;n.hasNext();){if(n.isEndOfLine()){if(e===t){const t=n.getComponentIndex(),e=n.getVertexIndex();return new Fo(t,e,0)}}else{const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(e+i>t){const s=(t-e)/i,r=n.getComponentIndex(),o=n.getVertexIndex();return new Fo(r,o,s)}e+=i}n.next()}return Fo.getEndLocation(this._linearGeom)}getClass(){return ko}get interfaces_(){return[]}}ko.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Xo{constructor(){Xo.constructor_.apply(this,arguments)}clampIndex(t){const e=this.positiveIndex(t),n=this.getStartIndex();if(e<n)return n;const s=this.getEndIndex();return e>s?s:e}locationOf(){if(1===arguments.length){const t=arguments[0];return ko.getLocation(this._linearGeom,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return ko.getLocation(this._linearGeom,t,e)}}project(t){return Uo.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1===arguments.length){const t=arguments[0];return ko.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=ko.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,e){return Uo.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){new Yo(this._linearGeom);const n=this.clampIndex(t),s=this.clampIndex(e),i=n===s,r=this.locationOf(n,i),o=this.locationOf(s);return zo.extract(this._linearGeom,r,o)}indexOf(t){return Uo.indexOf(this._linearGeom,t)}indicesOf(t){const e=Bo.indicesOf(this._linearGeom,t);return[ko.getLength(this._linearGeom,e[0]),ko.getLength(this._linearGeom,e[1])]}getClass(){return Xo}get interfaces_(){return[]}}Xo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};var Ho=Object.freeze({__proto__:null,LengthIndexedLine:Xo,LengthLocationMap:ko,LinearGeometryBuilder:Vo,LinearIterator:Go,LinearLocation:Fo,LocationIndexedLine:Yo});class Wo{constructor(){Wo.constructor_.apply(this,arguments)}static transform(t,e){const n=new x;for(let s=t.iterator();s.hasNext();)n.add(e.execute(s.next()));return n}static select(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next();Boolean.TRUE.equals(e.execute(t))&&n.add(t)}return n}static apply(t,e){for(let n=t.iterator();n.hasNext();)e.execute(n.next())}getClass(){return Wo}get interfaces_(){return[]}}Wo.Function=function(){},Wo.constructor_=function(){};class jo{constructor(){jo.constructor_.apply(this,arguments)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}getClass(){return jo}get interfaces_(){return[B]}}jo.constructor_=function(){this.pts=null,this.n=0;const t=arguments[0];this.pts=new Array(t).fill(null)};class Ko{constructor(){Ko.constructor_.apply(this,arguments)}filter(t){this._n++}getCount(){return this._n}getClass(){return Ko}get interfaces_(){return[B]}}Ko.constructor_=function(){this._n=0};class Zo{constructor(){Zo.constructor_.apply(this,arguments)}count(t){const e=this._counts.get(t);return null===e?0:e.count()}add(t){const e=this._counts.get(t);null===e?this._counts.put(t,new Qo(1)):e.increment()}getClass(){return Zo}get interfaces_(){return[]}}class Qo{constructor(){Qo.constructor_.apply(this,arguments)}count(){return this.count}increment(){this.count++}getClass(){return Qo}get interfaces_(){return[]}}Qo.constructor_=function(){if(this.count=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.count=t}},Zo.Counter=Qo,Zo.constructor_=function(){this._counts=new Ut};var Jo=Object.freeze({__proto__:null,CollectionUtil:Wo,CoordinateArrayFilter:jo,CoordinateCountFilter:Ko,GeometricShapeFactory:Se,NumberUtil:e,ObjectCounter:Zo,PriorityQueue:fs,StringUtil:St,UniqueCoordinateArrayFilter:ln});class $o{get interfaces_(){return[]}getClass(){return $o}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),lr.overlayOp(t,e,cr.UNION)}}q.prototype.equalsTopo=function(t){return!!this.getEnvelopeInternal().equals(t.getEnvelopeInternal())&&Gr.relate(this,t).isEquals(this.getDimension(),t.getDimension())},q.prototype.union=function(){if(0===arguments.length)return zr.union(this);if(1===arguments.length){const t=arguments[0];return $o.union(this,t)}},q.prototype.isValid=function(){return Cr.isValid(this)},q.prototype.intersection=function(t){return cr.intersection(this,t)},q.prototype.covers=function(t){return Gr.covers(this,t)},q.prototype.coveredBy=function(t){return Gr.covers(t,this)},q.prototype.touches=function(t){return Gr.touches(this,t)},q.prototype.intersects=function(t){return Gr.intersects(this,t)},q.prototype.within=function(t){return Gr.contains(t,this)},q.prototype.overlaps=function(t){return Gr.overlaps(this,t)},q.prototype.disjoint=function(t){return Gr.disjoint(this,t)},q.prototype.crosses=function(t){return Gr.crosses(this,t)},q.prototype.buffer=function(){if(1===arguments.length){const t=arguments[0];return Si.bufferOp(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Si.bufferOp(this,t,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return Si.bufferOp(this,t,e,n)}},q.prototype.convexHull=function(){return new an(this).getConvexHull()},q.prototype.relate=function(...t){if(1===arguments.length){const t=arguments[0];return Gr.relate(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Gr.relate(this,t).matches(e)}},q.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();const t=sn.getCentroid(this);return this.createPointFromInternalCoord(t,this)},q.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=null;const e=this.getDimension();t=0===e?new dn(this):1===e?new gn(this):new hn(this);const n=t.getInteriorPoint();return this.createPointFromInternalCoord(n,this)},q.prototype.symDifference=function(t){return cr.symDifference(this,t)},q.prototype.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},q.prototype.toText=function(){return(new Jt).write(this)},q.prototype.toString=function(){this.toText()},q.prototype.contains=function(t){return Gr.contains(this,t)},q.prototype.difference=function(t){return cr.difference(this,t)},q.prototype.isSimple=function(){return new Hs(this).isSimple()},q.prototype.isWithinDistance=function(t,e){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>e)&&Ri.isWithinDistance(this,t,e)},q.prototype.distance=function(t){return Ri.distance(this,t)},q.prototype.isEquivalentClass=function(t){return this.getClass()===t.getClass()};t.algorithm=mn,t.densify=En,t.dissolve=Rn,t.geom=Re,t.geomgraph=Jn,t.index=Cs,t.io=Ps,t.linearref=Ho,t.noding=Xs,t.operation=kr,t.precision=Wr,t.simplify=ho,t.triangulate=Ao,t.util=Jo,t.version="2.1.2 (83b5aee)",Object.defineProperty(t,"__esModule",{value:!0})}));

},{}],7:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],8:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

/**
 * Checks, if polygon is simple. Polygon is simple, when its edges don't cross each other.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean} true if Polygon is simple
 */
function IsSimple (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 4) return true
  var a1 = Point();
  var a2 = Point();
  var b1 = Point();
  var b2 = Point();
  var c = Point();

  for (var i = 0; i < n; i++) {
    a1.x = p[2 * i];
    a1.y = p[2 * i + 1];
    if (i == n - 1) {
      a2.x = p[0];
      a2.y = p[1];
    } else {
      a2.x = p[2 * i + 2];
      a2.y = p[2 * i + 3];
    }

    for (var j = 0; j < n; j++) {
      if (Math.abs(i - j) < 2) continue
      if (j == n - 1 && i == 0) continue
      if (i == n - 1 && j == 0) continue

      b1.x = p[2 * j];
      b1.y = p[2 * j + 1];
      if (j == n - 1) {
        b2.x = p[0];
        b2.y = p[1];
      } else {
        b2.x = p[2 * j + 2];
        b2.y = p[2 * j + 3];
      }

      if (GetLineIntersection(a1, a2, b1, b2, c) != null) return false
    }
  }
  return true
}
module.exports.IsSimple = IsSimple;

/**
 * Checks, if polygon is convex. Polygon is convex, when each inner angle is <= 180Â°.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean}
 */
function IsConvex (polygon) {
  var p = polygon;
  if (p.length < 6) return true
  var l = p.length - 4;
  for (var i = 0; i < l; i += 2) {
    if (!convex(p[i], p[i + 1], p[i + 2], p[i + 3], p[i + 4], p[i + 5])) return false
  }
  if (!convex(p[l], p[l + 1], p[l + 2], p[l + 3], p[0], p[1])) return false
  if (!convex(p[l + 2], p[l + 3], p[0], p[1], p[2], p[3])) return false
  return true
}
module.exports.IsConvex = IsConvex;

/**
 * Returns the area of polygon.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number}
 */
function GetArea (polygon) {
  var p = polygon;
  if (p.length < 6) return 0
  var l = p.length - 2;
  var sum = 0;
  for (var i = 0; i < l; i += 2) {
    sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
  }
  sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
  return -sum * 0.5
}
module.exports.GetArea = GetArea;

/**
 * Returns the Axis-aligned Bounding Box of polygon
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {AABB}
 * @example
 * //={x:0, y:0, width:0, height:0}
 */
function GetAABB (polygon) {
  var p = polygon;
  var minx = Infinity;
  var miny = Infinity;
  var maxx = -minx;
  var maxy = -miny;
  for (var i = 0; i < p.length; i += 2) {
    minx = Math.min(minx, p[i]);
    maxx = Math.max(maxx, p[i]);
    miny = Math.min(miny, p[i + 1]);
    maxy = Math.max(maxy, p[i + 1]);
  }
  return {x: minx, y: miny, width: maxx - minx, height: maxy - miny}
}
module.exports.GetAABB = GetAABB;

/**
 * Computes the triangulation. Output array is array of triangles (triangle = 3 indices of polygon vertices).
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number[]} array of triangles (triangle = 3 indices of polygon vertices)
 * @example
 * var ids = PolyK.Triangulate([0, 0, 1, 0, 1, 1, 0, 1]);
 * //=[0, 1, 2, 0, 2, 3]
 */
function Triangulate (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 3) return []
  var tgs = [];
  var avl = [];
  for (var i = 0; i < n; i++) { avl.push(i); }

  var i = 0;
  var al = n;
  while (al > 3) {
    var i0 = avl[(i + 0) % al];
    var i1 = avl[(i + 1) % al];
    var i2 = avl[(i + 2) % al];

    var ax = p[2 * i0];
    var ay = p[2 * i0 + 1];
    var bx = p[2 * i1];
    var by = p[2 * i1 + 1];
    var cx = p[2 * i2];
    var cy = p[2 * i2 + 1];

    var earFound = false;
    if (convex(ax, ay, bx, by, cx, cy)) {
      earFound = true;
      for (var j = 0; j < al; j++) {
        var vi = avl[j];
        if (vi == i0 || vi == i1 || vi == i2) continue
        if (PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
          earFound = false;
          break
        }
      }
    }
    if (earFound) {
      tgs.push(i0, i1, i2);
      avl.splice((i + 1) % al, 1);
      al--;
      i = 0;
    } else if (i++ > 3 * al) break    // no convex angles :(
  }
  tgs.push(avl[0], avl[1], avl[2]);
  return tgs
}
module.exports.Triangulate = Triangulate;

/**
 * Slices the polygon with line segment A-B, defined by [ax,ay] and [bx,by]. A, B must not lay inside a polygon. Returns an array of polygons.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} startX Start Coordinate [x]
 * @param {number} startY Start Coordinate [y]
 * @param {number} endX End Coordinate [x]
 * @param {number} endY End Coordinate [y]
 * @returns {number[][]} Array of Polygon
 */
function Slice (polygon, startX, startY, endX, endY) {
  var p = polygon;
  var ax = startX;
  var ay = startY;
  var bx = endX;
  var by = endY;
  if (ContainsPoint(p, ax, ay) || ContainsPoint(p, bx, by)) {
    return [p.slice(0)]
  }

  var a = Point(ax, ay);
  var b = Point(bx, by);
  var iscs = [];  // intersections
  var ps = [];  // points
  for (var i = 0; i < p.length; i += 2) {
    ps.push(Point(p[i], p[i + 1]));
  }
  for (var i = 0; i < ps.length; i++) {
    var isc = Point(0, 0);
    isc = GetLineIntersection(a, b, ps[i], ps[(i + 1) % ps.length], isc);
    var fisc = iscs[0];
    var lisc = iscs[iscs.length - 1];
    // && (isc.x!=ps[i].x || isc.y!=ps[i].y) )
    if (isc && (fisc == null || distance(isc, fisc) > 1e-10) && (lisc == null || distance(isc, lisc) > 1e-10)) {
      isc.flag = true;
      iscs.push(isc);
      ps.splice(i + 1, 0, isc);
      i++;
    }
  }

  if (iscs.length < 2) return [p.slice(0)]
  var comp = function (u, v) { return distance(a, u) - distance(a, v) };
  iscs.sort(comp);

  var pgs = [];
  var dir = 0;
  while (iscs.length > 0) {
    // var n = ps.length // is assigned a value but never used. (no-unused-vars)
    var i0 = iscs[0];
    var i1 = iscs[1];
    // if(i0.x==i1.x && i0.y==i1.y) { iscs.splice(0,2); continue;}
    var index0 = ps.indexOf(i0);
    var index1 = ps.indexOf(i1);
    var solved = false;

    if (firstWithFlag(ps, index0) === index1) {
      solved = true;
    } else {
      i0 = iscs[1];
      i1 = iscs[0];
      index0 = ps.indexOf(i0);
      index1 = ps.indexOf(i1);
      if (firstWithFlag(ps, index0) === index1) solved = true;
    }
    if (solved) {
      dir--;
      var pgn = getPoints(ps, index0, index1);
      pgs.push(pgn);
      ps = getPoints(ps, index1, index0);
      i0.flag = i1.flag = false;
      iscs.splice(0, 2);
      if (iscs.length == 0) pgs.push(ps);
    } else {
      dir++;
      iscs.reverse();
    }
    if (dir > 1) break
  }
  var result = [];
  for (var i = 0; i < pgs.length; i++) {
    var pg = pgs[i];
    var npg = [];
    for (var j = 0; j < pg.length; j++) { npg.push(pg[j].x, pg[j].y); }
    result.push(npg);
  }
  return result
}
module.exports.Slice = Slice;

/**
 * Checks, if polygon contains [x, y].
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} pointX Coordinate [x]
 * @param {number} pointY Coordinate [y]
 * @returns {boolean} depth
 */
function ContainsPoint (polygon, pointX, pointY) {
  var p = polygon;
  var px = pointX;
  var py = pointY;
  var n = p.length >> 1;
  var ax;
  var ay = p[2 * n - 3] - py;
  var bx = p[2 * n - 2] - px;
  var by = p[2 * n - 1] - py;

  // var lup = by > ay;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay === by) continue
    var lup = by > ay;
  }

  var depth = 0;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay < 0 && by < 0) continue  // both "up" or both "down"
    if (ay > 0 && by > 0) continue  // both "up" or both "down"
    if (ax < 0 && bx < 0) continue   // both points on the left

    if (ay === by && Math.min(ax, bx) <= 0) return true
    if (ay === by) continue

    var lx = ax + (bx - ax) * (-ay) / (by - ay);
    if (lx === 0) return true      // point on edge
    if (lx > 0) depth++;
    if (ay === 0 && lup && by > ay) depth--;  // hit vertex, both up
    if (ay === 0 && !lup && by < ay) depth--; // hit vertex, both down
    lup = by > ay;
  }
  return (depth & 1) === 1
}
module.exports.ContainsPoint = ContainsPoint;

/**
 * Finds the closest point of polygon, which lays on ray defined by [x,y] (origin) and [dx,dy] (direction).
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the edge, on which intersection occurs, "norm" is the normal in that place, "refl" is reflected direction.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} originX Origin [x]
 * @param {number} originY Origin [y]
 * @param {number} directionX Direction [x]
 * @param {number} directionY Direction [y]
 * @returns {Raycast}
 * @example
 * //={dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}}
 */
function Raycast (polygon, originX, originY, directionX, directionY, isc) {
  var p = polygon;
  var x = originX;
  var y = originY;
  var dx = directionX;
  var dy = directionY;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var a2 = empty[1];
  var b1 = empty[2];
  var b2 = empty[3];
  var c = empty[4];
  a1.x = x;
  a1.y = y;
  a2.x = x + dx;
  a2.y = y + dy;

  if (isc === null || isc === undefined) {
    isc = {dist: 0, edge: 0, norm: {x: 0, y: 0}, refl: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  var nisc;
  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    nisc = RayLineIntersection(a1, a2, b1, b2, c);
    if (nisc) {
      isc = updateISC(dx, dy, a1, b1, b2, c, i / 2, isc);
    }
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  nisc = RayLineIntersection(a1, a2, b1, b2, c);
  if (nisc) {
    isc = updateISC(dx, dy, a1, b1, b2, c, (p.length / 2) - 1, isc);
  }

  return (isc.dist !== Infinity) ? isc : null
}
module.exports.Raycast = Raycast;

/**
 * Finds the point on polygon edges, which is closest to [x,y]. Returns an object in this format
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the closest edge, "point" is the closest point on that edge, "norm" is the normal from "point" to [x,y].
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} x Coordinate [x]
 * @param {number} y Coordinate [y]
 * @returns {ClosestEdge}
 * @example
 * //={dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}}
 */
function ClosestEdge (polygon, x, y, isc) {
  var p = polygon;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var b1 = empty[2];
  var b2 = empty[3];
  // var c = tp[4] // is assigned a value but never used.
  a1.x = x;
  a1.y = y;

  if (isc == null) {
    isc = {dist: 0, edge: 0, point: {x: 0, y: 0}, norm: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    isc = pointLineDist(a1, b1, b2, i >> 1, isc);
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  isc = pointLineDist(a1, b1, b2, l >> 1, isc);

  var idst = 1 / isc.dist;
  isc.norm.x = (x - isc.point.x) * idst;
  isc.norm.y = (y - isc.point.y) * idst;
  return isc
}
module.exports.ClosestEdge = ClosestEdge;

/**
 * Reverse
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 */
function Reverse (polygon) {
  var p = polygon;
  var np = [];
  for (var j = p.length - 2; j >= 0; j -= 2) { np.push(p[j], p[j + 1]); }
  return np
}
module.exports.Reverse = Reverse;

/**
 * Point Line Distance
 *
 * @private
 * @param {Point} p
 * @param {Point} a
 * @param {Point} b
 * @param {??} edge
 * @param {??} isc
 * @returns {??} ISC
 */
function pointLineDist (p, a, b, edge, isc) {
  var x = p.x;
  var y = p.y;
  var x1 = a.x;
  var y1 = a.y;
  var x2 = b.x;
  var y2 = b.y;

  var A = x - x1;
  var B = y - y1;
  var C = x2 - x1;
  var D = y2 - y1;

  var dot = A * C + B * D;
  var lenSq = C * C + D * D;
  var param = dot / lenSq;

  var xx;
  var yy;

  if (param < 0 || (x1 == x2 && y1 == y2)) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  var dx = x - xx;
  var dy = y - yy;
  var dst = Math.sqrt(dx * dx + dy * dy);
  if (dst < isc.dist) {
    isc.dist = dst;
    isc.edge = edge;
    isc.point.x = xx;
    isc.point.y = yy;
  }
  return isc
}

/**
 * Update ISC
 *
 * @private
 * @param {number} dx
 * @param {number} dy
 * @param {Point} a1
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @param {??} edge
 * @param {??} isc
 * @returns {??}
 */
function updateISC (dx, dy, a1, b1, b2, c, edge, isc) {
  var nrl = distance(a1, c);
  if (nrl < isc.dist) {
    var ibl = 1 / distance(b1, b2);
    var nx = -(b2.y - b1.y) * ibl;
    var ny = (b2.x - b1.x) * ibl;
    var ddot = 2 * (dx * nx + dy * ny);
    isc.dist = nrl;
    isc.norm.x = nx;
    isc.norm.y = ny;
    isc.refl.x = -ddot * nx + dx;
    isc.refl.y = -ddot * ny + dy;
    isc.edge = edge;
  }
  return isc
}

/**
 * Get Points
 *
 * @private
 * @param {number[]} points
 * @param {number} index0
 * @param {number} index1
 * @returns {number[]} points
 */
function getPoints (points, index0, index1) {
  var n = points.length;
  var result = [];
  if (index1 < index0) index1 += n;
  for (var i = index0; i <= index1; i++) { result.push(points[i % n]); }
  return result
}

/**
 * First With Flag
 *
 * @private
 * @param {Point[]} points
 * @param {number} index
 * @returns {number}
 */
function firstWithFlag (points, index) {
  var n = points.length;
  while (true) {
    index = (index + 1) % n;
    if (points[index].flag) {
      return index
    }
  }
}

/**
 * Point in Triangle
 *
 * @private
 * @param {number} px
 * @param {number} py
 * @param {number} ax
 * @param {number} ay
 * @param {number} bx
 * @param {number} by
 * @param {number} cx
 * @param {number} cy
 * @returns {boolean}
 */
function PointInTriangle (px, py, ax, ay, bx, by, cx, cy) {
  var v0x = cx - ax;
  var v0y = cy - ay;
  var v1x = bx - ax;
  var v1y = by - ay;
  var v2x = px - ax;
  var v2y = py - ay;

  var dot00 = v0x * v0x + v0y * v0y;
  var dot01 = v0x * v1x + v0y * v1y;
  var dot02 = v0x * v2x + v0y * v2y;
  var dot11 = v1x * v1x + v1y * v1y;
  var dot12 = v1x * v2x + v1y * v2y;

  var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
  var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

  // Check if point is in triangle
  return (u >= 0) && (v >= 0) && (u + v < 1)
}

/**
 * RayLine Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 */
function RayLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;
  if (Den == 0) return null  // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  var iDen = 1 / Den;
  I.x = (A * dbx - dax * B) * iDen;
  I.y = (A * dby - day * B) * iDen;

  if (!InRectangle(I, b1, b2)) return null
  if ((day > 0 && I.y > a1.y) || (day < 0 && I.y < a1.y)) return null
  if ((dax > 0 && I.x > a1.x) || (dax < 0 && I.x < a1.x)) return null
  return I
}

/**
 * Get Line Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @returns {Point}
 */
function GetLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;

  if (Den === 0) { return null } // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  I.x = (A * dbx - dax * B) / Den;
  I.y = (A * dby - day * B) / Den;

  if (InRectangle(I, a1, a2) && InRectangle(I, b1, b2)) {
    return I
  }
  return null
}

/**
 * In Rectangle
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @param {Point} c
 * @return {boolean}
 */
function InRectangle (a, b, c) {
  var minx = Math.min(b.x, c.x);
  var maxx = Math.max(b.x, c.x);
  var miny = Math.min(b.y, c.y);
  var maxy = Math.max(b.y, c.y);

  if (minx === maxx) { return (miny <= a.y && a.y <= maxy) }
  if (miny === maxy) { return (minx <= a.x && a.x <= maxx) }

  // return (minx <= a.x && a.x <= maxx && miny <= a.y && a.y <= maxy)
  return (minx <= a.x + 1e-10 && a.x - 1e-10 <= maxx && miny <= a.y + 1e-10 && a.y - 1e-10 <= maxy)
}

/**
 * Convex
 *
 * @private
 * @param {Point} ax
 * @param {Point} ay
 * @param {Point} bx
 * @param {Point} by
 * @param {Point} cx
 * @param {Point} cy
 * @returns {boolean}
 */
function convex (ax, ay, bx, by, cx, cy) {
  return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0
}

/**
 * Point
 *
 * @private
 * @param {number} x
 * @param {number} y
 * @returns {Point}
 */
function Point (x, y) {
  return {
    x: x,
    y: y,
    flag: false,
    toString: function () { return 'Point [' + x + ', ' + y + ']' }
  }
}

/**
 * Distance
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @returns {number}
 */
function distance (a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy)
}

/**
 * Creates an array of empty Points
 *
 * @private
 * @param {number} [num=10] Number of points
 * @returns {Point[]}
 */
function emptyPoints (num) {
  num = num || 10;
  var container = [];
  for (var i = 0; i < num; i++) { container.push(Point(0, 0)); }
  return container
}

})));


},{}],9:[function(require,module,exports){
"use strict";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(e,n)};function e(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}function n(){for(var t=0,e=0,n=arguments.length;e<n;e++)t+=arguments[e].length;var r=Array(t),a=0;for(e=0;e<n;e++)for(var o=arguments[e],s=0,h=o.length;s<h;s++,a++)r[a]=o[s];return r}function r(t,e,n){if(t&&t.length){var r=e[0],a=e[1],o=Math.PI/180*n,s=Math.cos(o),h=Math.sin(o);t.forEach((function(t){var e=t[0],n=t[1];t[0]=(e-r)*s-(n-a)*h+r,t[1]=(e-r)*h+(n-a)*s+a}))}}function a(t){var e=t[0],n=t[1];return Math.sqrt(Math.pow(e[0]-n[0],2)+Math.pow(e[1]-n[1],2))}function o(t,e){var a=[0,0],o=Math.round(e.hachureAngle+90);o&&r(t,a,o);var s=function(t,e){var r=n(t);r[0].join(",")!==r[r.length-1].join(",")&&r.push([r[0][0],r[0][1]]);var a=[];if(r&&r.length>2){var o=e.hachureGap;o<0&&(o=4*e.strokeWidth),o=Math.max(o,.1);for(var s=[],h=0;h<r.length-1;h++){var i=r[h],u=r[h+1];if(i[1]!==u[1]){var p=Math.min(i[1],u[1]);s.push({ymin:p,ymax:Math.max(i[1],u[1]),x:p===i[1]?i[0]:u[0],islope:(u[0]-i[0])/(u[1]-i[1])})}}if(s.sort((function(t,e){return t.ymin<e.ymin?-1:t.ymin>e.ymin?1:t.x<e.x?-1:t.x>e.x?1:t.ymax===e.ymax?0:(t.ymax-e.ymax)/Math.abs(t.ymax-e.ymax)})),!s.length)return a;for(var c=[],l=s[0].ymin;c.length||s.length;){if(s.length){var f=-1;for(h=0;h<s.length&&!(s[h].ymin>l);h++)f=h;s.splice(0,f+1).forEach((function(t){c.push({s:l,edge:t})}))}if((c=c.filter((function(t){return!(t.edge.ymax<=l)}))).sort((function(t,e){return t.edge.x===e.edge.x?0:(t.edge.x-e.edge.x)/Math.abs(t.edge.x-e.edge.x)})),c.length>1)for(h=0;h<c.length;h+=2){var d=h+1;if(d>=c.length)break;var g=c[h].edge,y=c[d].edge;a.push([[Math.round(g.x),l],[Math.round(y.x),l]])}l+=o,c.forEach((function(t){t.edge.x=t.edge.x+o*t.edge.islope}))}}return a}(t,e);return o&&(r(t,a,-o),function(t,e,n){var a=[];t.forEach((function(t){return a.push.apply(a,t)})),r(a,e,n)}(s,a,-o)),s}var s=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){return this._fillPolygon(t,e)},t.prototype._fillPolygon=function(t,e,n){void 0===n&&(n=!1);var r=o(t,e);return{type:"fillSketch",ops:this.renderLines(r,e,n)}},t.prototype.renderLines=function(t,e,n){for(var r=[],a=null,o=0,s=t;o<s.length;o++){var h=s[o];r.push.apply(r,this.helper.doubleLineOps(h[0][0],h[0][1],h[1][0],h[1][1],e)),n&&a&&r.push.apply(r,this.helper.doubleLineOps(a[0],a[1],h[0][0],h[0][1],e)),a=h[1]}return r},t}(),h=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.fillPolygon=function(t,e){return this._fillPolygon(t,e,!0)},n}(s),i=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.fillPolygon=function(t,e){var n=this._fillPolygon(t,e),r=Object.assign({},e,{hachureAngle:e.hachureAngle+90}),a=this._fillPolygon(t,r);return n.ops=n.ops.concat(a.ops),n},n}(s),u=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){var n=o(t,e=Object.assign({},e,{curveStepCount:4,hachureAngle:0,roughness:1}));return this.dotsOnLines(n,e)},t.prototype.dotsOnLines=function(t,e){var n=[],r=e.hachureGap;r<0&&(r=4*e.strokeWidth),r=Math.max(r,.1);var o=e.fillWeight;o<0&&(o=e.strokeWidth/2);for(var s=r/4,h=0,i=t;h<i.length;h++)for(var u=i[h],p=a(u),c=p/r,l=Math.ceil(c)-1,f=p-l*r,d=(u[0][0]+u[1][0])/2-r/4,g=Math.min(u[0][1],u[1][1]),y=0;y<l;y++){var v=g+f+y*r,M=this.helper.randOffsetWithRange(d-s,d+s,e),k=this.helper.randOffsetWithRange(v-s,v+s,e),b=this.helper.ellipse(M,k,o,o,e);n.push.apply(n,b.ops)}return{type:"fillSketch",ops:n}},t}(),p=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){var n=o(t,e);return{type:"fillSketch",ops:this.dashedLine(n,e)}},t.prototype.dashedLine=function(t,e){var n=this,r=e.dashOffset<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashOffset,o=e.dashGap<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashGap,s=[];return t.forEach((function(t){var h=a(t),i=Math.floor(h/(r+o)),u=(h+o-i*(r+o))/2,p=t[0],c=t[1];p[0]>c[0]&&(p=t[1],c=t[0]);for(var l=Math.atan((c[1]-p[1])/(c[0]-p[0])),f=0;f<i;f++){var d=f*(r+o),g=d+r,y=[p[0]+d*Math.cos(l)+u*Math.cos(l),p[1]+d*Math.sin(l)+u*Math.sin(l)],v=[p[0]+g*Math.cos(l)+u*Math.cos(l),p[1]+g*Math.sin(l)+u*Math.sin(l)];s.push.apply(s,n.helper.doubleLineOps(y[0],y[1],v[0],v[1],e))}})),s},t}(),c=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){var n=e.hachureGap<0?4*e.strokeWidth:e.hachureGap,r=e.zigzagOffset<0?n:e.zigzagOffset,a=o(t,e=Object.assign({},e,{hachureGap:n+r}));return{type:"fillSketch",ops:this.zigzagLines(a,r,e)}},t.prototype.zigzagLines=function(t,e,r){var o=this,s=[];return t.forEach((function(t){var h=a(t),i=Math.round(h/(2*e)),u=t[0],p=t[1];u[0]>p[0]&&(u=t[1],p=t[0]);for(var c=Math.atan((p[1]-u[1])/(p[0]-u[0])),l=0;l<i;l++){var f=2*l*e,d=2*(l+1)*e,g=Math.sqrt(2*Math.pow(e,2)),y=[u[0]+f*Math.cos(c),u[1]+f*Math.sin(c)],v=[u[0]+d*Math.cos(c),u[1]+d*Math.sin(c)],M=[y[0]+g*Math.cos(c+Math.PI/4),y[1]+g*Math.sin(c+Math.PI/4)];s.push.apply(s,n(o.helper.doubleLineOps(y[0],y[1],M[0],M[1],r),o.helper.doubleLineOps(M[0],M[1],v[0],v[1],r)))}})),s},t}(),l={};var f=function(){function t(t){this.seed=t}return t.prototype.next=function(){return this.seed?(Math.pow(2,31)-1&(this.seed=Math.imul(48271,this.seed)))/Math.pow(2,31):Math.random()},t}();const d={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function g(t,e){return t.type===e}function y(t){const e=[],n=function(t){const e=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:0,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];e[e.length]={type:1,text:""+parseFloat(RegExp.$1)},t=t.substr(RegExp.$1.length)}return e[e.length]={type:2,text:""},e}(t);let r="BOD",a=0,o=n[a];for(;!g(o,2);){let s=0;const h=[];if("BOD"===r){if("M"!==o.text&&"m"!==o.text)return y("M0,0"+t);a++,s=d[o.text],r=o.text}else g(o,1)?s=d[r]:(a++,s=d[o.text],r=o.text);if(!(a+s<n.length))throw new Error("Path data ended short");for(let t=a;t<a+s;t++){const e=n[t];if(!g(e,1))throw new Error("Param not a number: "+r+","+e.text);h[h.length]=+e.text}if("number"!=typeof d[r])throw new Error("Bad segment: "+r);{const t={key:r,data:h};e.push(t),a+=s,o=n[a],"M"===r&&(r="L"),"m"===r&&(r="l")}}return e}function v(t){let e=0,n=0,r=0,a=0;const o=[];for(const{key:s,data:h}of t)switch(s){case"M":o.push({key:"M",data:[...h]}),[e,n]=h,[r,a]=h;break;case"m":e+=h[0],n+=h[1],o.push({key:"M",data:[e,n]}),r=e,a=n;break;case"L":o.push({key:"L",data:[...h]}),[e,n]=h;break;case"l":e+=h[0],n+=h[1],o.push({key:"L",data:[e,n]});break;case"C":o.push({key:"C",data:[...h]}),e=h[4],n=h[5];break;case"c":{const t=h.map((t,r)=>r%2?t+n:t+e);o.push({key:"C",data:t}),e=t[4],n=t[5];break}case"Q":o.push({key:"Q",data:[...h]}),e=h[2],n=h[3];break;case"q":{const t=h.map((t,r)=>r%2?t+n:t+e);o.push({key:"Q",data:t}),e=t[2],n=t[3];break}case"A":o.push({key:"A",data:[...h]}),e=h[5],n=h[6];break;case"a":e+=h[5],n+=h[6],o.push({key:"A",data:[h[0],h[1],h[2],h[3],h[4],e,n]});break;case"H":o.push({key:"H",data:[...h]}),e=h[0];break;case"h":e+=h[0],o.push({key:"H",data:[e]});break;case"V":o.push({key:"V",data:[...h]}),n=h[0];break;case"v":n+=h[0],o.push({key:"V",data:[n]});break;case"S":o.push({key:"S",data:[...h]}),e=h[2],n=h[3];break;case"s":{const t=h.map((t,r)=>r%2?t+n:t+e);o.push({key:"S",data:t}),e=t[2],n=t[3];break}case"T":o.push({key:"T",data:[...h]}),e=h[0],n=h[1];break;case"t":e+=h[0],n+=h[1],o.push({key:"T",data:[e,n]});break;case"Z":case"z":o.push({key:"Z",data:[]}),e=r,n=a}return o}function M(t){const e=[];let n="",r=0,a=0,o=0,s=0,h=0,i=0;for(const{key:u,data:p}of t){switch(u){case"M":e.push({key:"M",data:[...p]}),[r,a]=p,[o,s]=p;break;case"C":e.push({key:"C",data:[...p]}),r=p[4],a=p[5],h=p[2],i=p[3];break;case"L":e.push({key:"L",data:[...p]}),[r,a]=p;break;case"H":r=p[0],e.push({key:"L",data:[r,a]});break;case"V":a=p[0],e.push({key:"L",data:[r,a]});break;case"S":{let t=0,o=0;"C"===n||"S"===n?(t=r+(r-h),o=a+(a-i)):(t=r,o=a),e.push({key:"C",data:[t,o,...p]}),h=p[0],i=p[1],r=p[2],a=p[3];break}case"T":{const[t,o]=p;let s=0,u=0;"Q"===n||"T"===n?(s=r+(r-h),u=a+(a-i)):(s=r,u=a);const c=r+2*(s-r)/3,l=a+2*(u-a)/3,f=t+2*(s-t)/3,d=o+2*(u-o)/3;e.push({key:"C",data:[c,l,f,d,t,o]}),h=s,i=u,r=t,a=o;break}case"Q":{const[t,n,o,s]=p,u=r+2*(t-r)/3,c=a+2*(n-a)/3,l=o+2*(t-o)/3,f=s+2*(n-s)/3;e.push({key:"C",data:[u,c,l,f,o,s]}),h=t,i=n,r=o,a=s;break}case"A":{const t=Math.abs(p[0]),n=Math.abs(p[1]),o=p[2],s=p[3],h=p[4],i=p[5],u=p[6];if(0===t||0===n)e.push({key:"C",data:[r,a,i,u,i,u]}),r=i,a=u;else if(r!==i||a!==u){b(r,a,i,u,t,n,o,s,h).forEach((function(t){e.push({key:"C",data:t})})),r=i,a=u}break}case"Z":e.push({key:"Z",data:[]}),r=o,a=s}n=u}return e}function k(t,e,n){return[t*Math.cos(n)-e*Math.sin(n),t*Math.sin(n)+e*Math.cos(n)]}function b(t,e,n,r,a,o,s,h,i,u){const p=(c=s,Math.PI*c/180);var c;let l=[],f=0,d=0,g=0,y=0;if(u)[f,d,g,y]=u;else{[t,e]=k(t,e,-p),[n,r]=k(n,r,-p);const s=(t-n)/2,u=(e-r)/2;let c=s*s/(a*a)+u*u/(o*o);c>1&&(c=Math.sqrt(c),a*=c,o*=c);const l=a*a,v=o*o,M=l*v-l*u*u-v*s*s,b=l*u*u+v*s*s,m=(h===i?-1:1)*Math.sqrt(Math.abs(M/b));g=m*a*u/o+(t+n)/2,y=m*-o*s/a+(e+r)/2,f=Math.asin(parseFloat(((e-y)/o).toFixed(9))),d=Math.asin(parseFloat(((r-y)/o).toFixed(9))),t<g&&(f=Math.PI-f),n<g&&(d=Math.PI-d),f<0&&(f=2*Math.PI+f),d<0&&(d=2*Math.PI+d),i&&f>d&&(f-=2*Math.PI),!i&&d>f&&(d-=2*Math.PI)}let v=d-f;if(Math.abs(v)>120*Math.PI/180){const t=d,e=n,h=r;d=i&&d>f?f+120*Math.PI/180*1:f+120*Math.PI/180*-1,l=b(n=g+a*Math.cos(d),r=y+o*Math.sin(d),e,h,a,o,s,0,i,[d,t,g,y])}v=d-f;const M=Math.cos(f),m=Math.sin(f),w=Math.cos(d),P=Math.sin(d),x=Math.tan(v/4),O=4/3*a*x,S=4/3*o*x,T=[t,e],_=[t+O*m,e-S*M],C=[n+O*P,r-S*w],W=[n,r];if(_[0]=2*T[0]-_[0],_[1]=2*T[1]-_[1],u)return[_,C,W].concat(l);{l=[_,C,W].concat(l);const t=[];for(let e=0;e<l.length;e+=3){const n=k(l[e][0],l[e][1],p),r=k(l[e+1][0],l[e+1][1],p),a=k(l[e+2][0],l[e+2][1],p);t.push([n[0],n[1],r[0],r[1],a[0],a[1]])}return t}}var m={randOffset:function(t,e){return E(t,e)},randOffsetWithRange:function(t,e,n){return L(t,e,n)},ellipse:function(t,e,n,r,a){var o=O(n,r,a);return S(t,e,a,o).opset},doubleLineOps:function(t,e,n,r,a){return z(t,e,n,r,a)}};function w(t,e,n,r,a){return{type:"path",ops:z(t,e,n,r,a)}}function P(t,e,n){var r=(t||[]).length;if(r>2){for(var a=[],o=0;o<r-1;o++)a.push.apply(a,z(t[o][0],t[o][1],t[o+1][0],t[o+1][1],n));return e&&a.push.apply(a,z(t[r-1][0],t[r-1][1],t[0][0],t[0][1],n)),{type:"path",ops:a}}return 2===r?w(t[0][0],t[0][1],t[1][0],t[1][1],n):{type:"path",ops:[]}}function x(t,e,n,r,a){return function(t,e){return P(t,!0,e)}([[t,e],[t+n,e],[t+n,e+r],[t,e+r]],a)}function O(t,e,n){var r=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),a=Math.max(n.curveStepCount,n.curveStepCount/Math.sqrt(200)*r),o=2*Math.PI/a,s=Math.abs(t/2),h=Math.abs(e/2),i=1-n.curveFitting;return{increment:o,rx:s+=E(s*i,n),ry:h+=E(h*i,n)}}function S(t,e,n,r){var a=G(r.increment,t,e,r.rx,r.ry,1,r.increment*L(.1,L(.4,1,n),n),n),o=a[0],s=a[1],h=G(r.increment,t,e,r.rx,r.ry,1.5,0,n)[0],i=q(o,null,n),u=q(h,null,n);return{estimatedPoints:s,opset:{type:"path",ops:i.concat(u)}}}function T(t,e,r,a,o,s,h,i,u){var p=t,c=e,l=Math.abs(r/2),f=Math.abs(a/2);l+=E(.01*l,u),f+=E(.01*f,u);for(var d=o,g=s;d<0;)d+=2*Math.PI,g+=2*Math.PI;g-d>2*Math.PI&&(d=0,g=2*Math.PI);var y=2*Math.PI/u.curveStepCount,v=Math.min(y/2,(g-d)/2),M=j(v,p,c,l,f,d,g,1,u),k=j(v,p,c,l,f,d,g,1.5,u),b=M.concat(k);return h&&(i?b.push.apply(b,n(z(p,c,p+l*Math.cos(d),c+f*Math.sin(d),u),z(p,c,p+l*Math.cos(g),c+f*Math.sin(g),u))):b.push({op:"lineTo",data:[p,c]},{op:"lineTo",data:[p+l*Math.cos(d),c+f*Math.sin(d)]})),{type:"path",ops:b}}function _(t,e){for(var n=M(v(y(t))),r=[],a=[0,0],o=[0,0],s=function(t,n){switch(t){case"M":var s=1*(e.maxRandomnessOffset||0);r.push({op:"move",data:n.map((function(t){return t+E(s,e)}))}),o=[n[0],n[1]],a=[n[0],n[1]];break;case"L":r.push.apply(r,z(o[0],o[1],n[0],n[1],e)),o=[n[0],n[1]];break;case"C":var h=n[0],i=n[1],u=n[2],p=n[3],c=n[4],l=n[5];r.push.apply(r,function(t,e,n,r,a,o,s,h){for(var i=[],u=[h.maxRandomnessOffset||1,(h.maxRandomnessOffset||1)+.3],p=[0,0],c=0;c<2;c++)0===c?i.push({op:"move",data:[s[0],s[1]]}):i.push({op:"move",data:[s[0]+E(u[0],h),s[1]+E(u[0],h)]}),p=[a+E(u[c],h),o+E(u[c],h)],i.push({op:"bcurveTo",data:[t+E(u[c],h),e+E(u[c],h),n+E(u[c],h),r+E(u[c],h),p[0],p[1]]});return i}(h,i,u,p,c,l,o,e)),o=[c,l];break;case"Z":r.push.apply(r,z(o[0],o[1],a[0],a[1],e)),o=[a[0],a[1]]}},h=0,i=n;h<i.length;h++){var u=i[h];s(u.key,u.data)}return{type:"path",ops:r}}function C(t,e){var n=[];if(t.length){var r=e.maxRandomnessOffset||0,a=t.length;if(a>2){n.push({op:"move",data:[t[0][0]+E(r,e),t[0][1]+E(r,e)]});for(var o=1;o<a;o++)n.push({op:"lineTo",data:[t[o][0]+E(r,e),t[o][1]+E(r,e)]})}}return{type:"fillPath",ops:n}}function W(t,e){return function(t,e){var n=t.fillStyle||"hachure";if(!l[n])switch(n){case"zigzag":l[n]||(l[n]=new h(e));break;case"cross-hatch":l[n]||(l[n]=new i(e));break;case"dots":l[n]||(l[n]=new u(e));break;case"dashed":l[n]||(l[n]=new p(e));break;case"zigzag-line":l[n]||(l[n]=new c(e));break;case"hachure":default:l[n="hachure"]||(l[n]=new s(e))}return l[n]}(e,m).fillPolygon(t,e)}function I(t){return t.randomizer||(t.randomizer=new f(t.seed||0)),t.randomizer.next()}function L(t,e,n,r){return void 0===r&&(r=1),n.roughness*r*(I(n)*(e-t)+t)}function E(t,e,n){return void 0===n&&(n=1),L(-t,t,e,n)}function z(t,e,n,r,a){var o=A(t,e,n,r,a,!0,!1),s=A(t,e,n,r,a,!0,!0);return o.concat(s)}function A(t,e,n,r,a,o,s){var h=Math.pow(t-n,2)+Math.pow(e-r,2),i=Math.sqrt(h),u=1;u=i<200?1:i>500?.4:-.0016668*i+1.233334;var p=a.maxRandomnessOffset||0;p*p*100>h&&(p=i/10);var c=p/2,l=.2+.2*I(a),f=a.bowing*a.maxRandomnessOffset*(r-e)/200,d=a.bowing*a.maxRandomnessOffset*(t-n)/200;f=E(f,a,u),d=E(d,a,u);var g=[],y=function(){return E(c,a,u)},v=function(){return E(p,a,u)};return o&&(s?g.push({op:"move",data:[t+y(),e+y()]}):g.push({op:"move",data:[t+E(p,a,u),e+E(p,a,u)]})),s?g.push({op:"bcurveTo",data:[f+t+(n-t)*l+y(),d+e+(r-e)*l+y(),f+t+2*(n-t)*l+y(),d+e+2*(r-e)*l+y(),n+y(),r+y()]}):g.push({op:"bcurveTo",data:[f+t+(n-t)*l+v(),d+e+(r-e)*l+v(),f+t+2*(n-t)*l+v(),d+e+2*(r-e)*l+v(),n+v(),r+v()]}),g}function R(t,e,n){var r=[];r.push([t[0][0]+E(e,n),t[0][1]+E(e,n)]),r.push([t[0][0]+E(e,n),t[0][1]+E(e,n)]);for(var a=1;a<t.length;a++)r.push([t[a][0]+E(e,n),t[a][1]+E(e,n)]),a===t.length-1&&r.push([t[a][0]+E(e,n),t[a][1]+E(e,n)]);return q(r,null,n)}function q(t,e,n){var r=t.length,a=[];if(r>3){var o=[],s=1-n.curveTightness;a.push({op:"move",data:[t[1][0],t[1][1]]});for(var h=1;h+2<r;h++){var i=t[h];o[0]=[i[0],i[1]],o[1]=[i[0]+(s*t[h+1][0]-s*t[h-1][0])/6,i[1]+(s*t[h+1][1]-s*t[h-1][1])/6],o[2]=[t[h+1][0]+(s*t[h][0]-s*t[h+2][0])/6,t[h+1][1]+(s*t[h][1]-s*t[h+2][1])/6],o[3]=[t[h+1][0],t[h+1][1]],a.push({op:"bcurveTo",data:[o[1][0],o[1][1],o[2][0],o[2][1],o[3][0],o[3][1]]})}if(e&&2===e.length){var u=n.maxRandomnessOffset;a.push({op:"lineTo",data:[e[0]+E(u,n),e[1]+E(u,n)]})}}else 3===r?(a.push({op:"move",data:[t[1][0],t[1][1]]}),a.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===r&&a.push.apply(a,z(t[0][0],t[0][1],t[1][0],t[1][1],n));return a}function G(t,e,n,r,a,o,s,h){var i=[],u=[],p=E(.5,h)-Math.PI/2;u.push([E(o,h)+e+.9*r*Math.cos(p-t),E(o,h)+n+.9*a*Math.sin(p-t)]);for(var c=p;c<2*Math.PI+p-.01;c+=t){var l=[E(o,h)+e+r*Math.cos(c),E(o,h)+n+a*Math.sin(c)];i.push(l),u.push(l)}return u.push([E(o,h)+e+r*Math.cos(p+2*Math.PI+.5*s),E(o,h)+n+a*Math.sin(p+2*Math.PI+.5*s)]),u.push([E(o,h)+e+.98*r*Math.cos(p+s),E(o,h)+n+.98*a*Math.sin(p+s)]),u.push([E(o,h)+e+.9*r*Math.cos(p+.5*s),E(o,h)+n+.9*a*Math.sin(p+.5*s)]),[u,i]}function j(t,e,n,r,a,o,s,h,i){var u=o+E(.1,i),p=[];p.push([E(h,i)+e+.9*r*Math.cos(u-t),E(h,i)+n+.9*a*Math.sin(u-t)]);for(var c=u;c<=s;c+=t)p.push([E(h,i)+e+r*Math.cos(c),E(h,i)+n+a*Math.sin(c)]);return p.push([e+r*Math.cos(s),n+a*Math.sin(s)]),p.push([e+r*Math.cos(s),n+a*Math.sin(s)]),q(p,null,i)}function Z(t){return[...t]}function D(t,e){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function F(t,e,n){const r=D(e,n);if(0===r)return D(t,e);let a=((t[0]-e[0])*(n[0]-e[0])+(t[1]-e[1])*(n[1]-e[1]))/r;return a=Math.max(0,Math.min(1,a)),D(t,Q(e,n,a))}function Q(t,e,n){return[t[0]+(e[0]-t[0])*n,t[1]+(e[1]-t[1])*n]}function H(t,e,n,r){const a=r||[];if(function(t,e){const n=t[e+0],r=t[e+1],a=t[e+2],o=t[e+3];let s=3*r[0]-2*n[0]-o[0];s*=s;let h=3*r[1]-2*n[1]-o[1];h*=h;let i=3*a[0]-2*o[0]-n[0];i*=i;let u=3*a[1]-2*o[1]-n[1];return u*=u,s<i&&(s=i),h<u&&(h=u),s+h}(t,e)<n){const n=t[e+0];if(a.length){(o=a[a.length-1],s=n,Math.sqrt(D(o,s)))>1&&a.push(n)}else a.push(n);a.push(t[e+3])}else{const r=.5,o=t[e+0],s=t[e+1],h=t[e+2],i=t[e+3],u=Q(o,s,r),p=Q(s,h,r),c=Q(h,i,r),l=Q(u,p,r),f=Q(p,c,r),d=Q(l,f,r);H([o,u,l,d],0,n,a),H([d,f,c,i],0,n,a)}var o,s;return a}function N(t,e){return V(t,0,t.length,e)}function V(t,e,n,r,a){const o=a||[],s=t[e],h=t[n-1];let i=0,u=1;for(let r=e+1;r<n-1;++r){const e=F(t[r],s,h);e>i&&(i=e,u=r)}return Math.sqrt(i)>r?(V(t,e,u+1,r,o),V(t,u,n,r,o)):(o.length||o.push(s),o.push(h)),o}function $(t,e=.15,n){const r=[],a=(t.length-1)/3;for(let n=0;n<a;n++){H(t,3*n,e,r)}return n&&n>0?V(r,0,r.length,n):r}var B="none",J=function(){function t(t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,combineNestedSvgPaths:!1},this.config=t||{},this.config.options&&(this.defaultOptions=this._o(this.config.options))}return t.newSeed=function(){return Math.floor(Math.random()*Math.pow(2,31))},t.prototype._o=function(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions},t.prototype._d=function(t,e,n){return{shape:t,sets:e||[],options:n||this.defaultOptions}},t.prototype.line=function(t,e,n,r,a){var o=this._o(a);return this._d("line",[w(t,e,n,r,o)],o)},t.prototype.rectangle=function(t,e,n,r,a){var o=this._o(a),s=[],h=x(t,e,n,r,o);if(o.fill){var i=[[t,e],[t+n,e],[t+n,e+r],[t,e+r]];"solid"===o.fillStyle?s.push(C(i,o)):s.push(W(i,o))}return o.stroke!==B&&s.push(h),this._d("rectangle",s,o)},t.prototype.ellipse=function(t,e,n,r,a){var o=this._o(a),s=[],h=O(n,r,o),i=S(t,e,o,h);if(o.fill)if("solid"===o.fillStyle){var u=S(t,e,o,h).opset;u.type="fillPath",s.push(u)}else s.push(W(i.estimatedPoints,o));return o.stroke!==B&&s.push(i.opset),this._d("ellipse",s,o)},t.prototype.circle=function(t,e,n,r){var a=this.ellipse(t,e,n,n,r);return a.shape="circle",a},t.prototype.linearPath=function(t,e){var n=this._o(e);return this._d("linearPath",[P(t,!1,n)],n)},t.prototype.arc=function(t,e,n,r,a,o,s,h){void 0===s&&(s=!1);var i=this._o(h),u=[],p=T(t,e,n,r,a,o,s,!0,i);if(s&&i.fill)if("solid"===i.fillStyle){var c=T(t,e,n,r,a,o,!0,!1,i);c.type="fillPath",u.push(c)}else u.push(function(t,e,n,r,a,o,s){var h=t,i=e,u=Math.abs(n/2),p=Math.abs(r/2);u+=E(.01*u,s),p+=E(.01*p,s);for(var c=a,l=o;c<0;)c+=2*Math.PI,l+=2*Math.PI;l-c>2*Math.PI&&(c=0,l=2*Math.PI);for(var f=(l-c)/s.curveStepCount,d=[],g=c;g<=l;g+=f)d.push([h+u*Math.cos(g),i+p*Math.sin(g)]);return d.push([h+u*Math.cos(l),i+p*Math.sin(l)]),d.push([h,i]),W(d,s)}(t,e,n,r,a,o,i));return i.stroke!==B&&u.push(p),this._d("arc",u,i)},t.prototype.curve=function(t,e){var n=this._o(e),r=[],a=function(t,e){var n=R(t,1*(1+.2*e.roughness),e),r=R(t,1.5*(1+.22*e.roughness),e);return{type:"path",ops:n.concat(r)}}(t,n);if(n.fill&&n.fill!==B&&t.length>=3){var o=$(function(t,e=0){const n=t.length;if(n<3)throw new Error("A curve must have at least three points.");const r=[];if(3===n)r.push(Z(t[0]),Z(t[1]),Z(t[2]),Z(t[2]));else{const n=[];n.push(t[0],t[0]);for(let e=1;e<t.length;e++)n.push(t[e]),e===t.length-1&&n.push(t[e]);const a=[],o=1-e;r.push(Z(n[0]));for(let t=1;t+2<n.length;t++){const e=n[t];a[0]=[e[0],e[1]],a[1]=[e[0]+(o*n[t+1][0]-o*n[t-1][0])/6,e[1]+(o*n[t+1][1]-o*n[t-1][1])/6],a[2]=[n[t+1][0]+(o*n[t][0]-o*n[t+2][0])/6,n[t+1][1]+(o*n[t][1]-o*n[t+2][1])/6],a[3]=[n[t+1][0],n[t+1][1]],r.push(a[1],a[2],a[3])}}return r}(t),10,(1+n.roughness)/2);"solid"===n.fillStyle?r.push(C(o,n)):r.push(W(o,n))}return n.stroke!==B&&r.push(a),this._d("curve",r,n)},t.prototype.polygon=function(t,e){var n=this._o(e),r=[],a=P(t,!0,n);return n.fill&&("solid"===n.fillStyle?r.push(C(t,n)):r.push(W(t,n))),n.stroke!==B&&r.push(a),this._d("polygon",r,n)},t.prototype.path=function(t,e){var n=this._o(e),r=[];if(!t)return this._d("path",r,n);t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");var a=n.fill&&"transparent"!==n.fill&&n.fill!==B,o=n.stroke!==B,s=!!(n.simplification&&n.simplification<1),h=function(t,e,n){const r=M(v(y(t))),a=[];let o=[],s=[0,0],h=[];const i=()=>{h.length>=4&&o.push(...$(h,e)),h=[]},u=()=>{i(),o.length&&(a.push(o),o=[])};for(const{key:t,data:e}of r)switch(t){case"M":u(),s=[e[0],e[1]],o.push(s);break;case"L":i(),o.push([e[0],e[1]]);break;case"C":if(!h.length){const t=o.length?o[o.length-1]:s;h.push([t[0],t[1]])}h.push([e[0],e[1]]),h.push([e[2],e[3]]),h.push([e[4],e[5]]);break;case"Z":i(),o.push([s[0],s[1]])}if(u(),!n)return a;const p=[];for(const t of a){const e=N(t,n);e.length&&p.push(e)}return p}(t,1,s?4-4*n.simplification:(1+n.roughness)/2);if(a)if(n.combineNestedSvgPaths){var i=[];h.forEach((function(t){return i.push.apply(i,t)})),"solid"===n.fillStyle?r.push(C(i,n)):r.push(W(i,n))}else h.forEach((function(t){"solid"===n.fillStyle?r.push(C(t,n)):r.push(W(t,n))}));return o&&(s?h.forEach((function(t){r.push(P(t,!1,n))})):r.push(_(t,n))),this._d("path",r,n)},t.prototype.opsToPath=function(t){for(var e="",n=0,r=t.ops;n<r.length;n++){var a=r[n],o=a.data;switch(a.op){case"move":e+="M"+o[0]+" "+o[1]+" ";break;case"bcurveTo":e+="C"+o[0]+" "+o[1]+", "+o[2]+" "+o[3]+", "+o[4]+" "+o[5]+" ";break;case"lineTo":e+="L"+o[0]+" "+o[1]+" "}}return e.trim()},t.prototype.toPaths=function(t){for(var e=t.sets||[],n=t.options||this.defaultOptions,r=[],a=0,o=e;a<o.length;a++){var s=o[a],h=null;switch(s.type){case"path":h={d:this.opsToPath(s),stroke:n.stroke,strokeWidth:n.strokeWidth,fill:B};break;case"fillPath":h={d:this.opsToPath(s),stroke:B,strokeWidth:0,fill:n.fill||B};break;case"fillSketch":h=this.fillSketch(s,n)}h&&r.push(h)}return r},t.prototype.fillSketch=function(t,e){var n=e.fillWeight;return n<0&&(n=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill||B,strokeWidth:n,fill:B}},t}(),K=function(){function t(t,e){this.canvas=t,this.ctx=this.canvas.getContext("2d"),this.gen=new J(e)}return t.prototype.draw=function(t){for(var e=t.sets||[],n=t.options||this.getDefaultOptions(),r=this.ctx,a=0,o=e;a<o.length;a++){var s=o[a];switch(s.type){case"path":r.save(),r.strokeStyle="none"===n.stroke?"transparent":n.stroke,r.lineWidth=n.strokeWidth,this._drawToContext(r,s),r.restore();break;case"fillPath":r.save(),r.fillStyle=n.fill||"";var h="curve"===t.shape||"polygon"===t.shape?"evenodd":"nonzero";this._drawToContext(r,s,h),r.restore();break;case"fillSketch":this.fillSketch(r,s,n)}}},t.prototype.fillSketch=function(t,e,n){var r=n.fillWeight;r<0&&(r=n.strokeWidth/2),t.save(),t.strokeStyle=n.fill||"",t.lineWidth=r,this._drawToContext(t,e),t.restore()},t.prototype._drawToContext=function(t,e,n){void 0===n&&(n="nonzero"),t.beginPath();for(var r=0,a=e.ops;r<a.length;r++){var o=a[r],s=o.data;switch(o.op){case"move":t.moveTo(s[0],s[1]);break;case"bcurveTo":t.bezierCurveTo(s[0],s[1],s[2],s[3],s[4],s[5]);break;case"lineTo":t.lineTo(s[0],s[1])}}"fillPath"===e.type?t.fill(n):t.stroke()},Object.defineProperty(t.prototype,"generator",{get:function(){return this.gen},enumerable:!0,configurable:!0}),t.prototype.getDefaultOptions=function(){return this.gen.defaultOptions},t.prototype.line=function(t,e,n,r,a){var o=this.gen.line(t,e,n,r,a);return this.draw(o),o},t.prototype.rectangle=function(t,e,n,r,a){var o=this.gen.rectangle(t,e,n,r,a);return this.draw(o),o},t.prototype.ellipse=function(t,e,n,r,a){var o=this.gen.ellipse(t,e,n,r,a);return this.draw(o),o},t.prototype.circle=function(t,e,n,r){var a=this.gen.circle(t,e,n,r);return this.draw(a),a},t.prototype.linearPath=function(t,e){var n=this.gen.linearPath(t,e);return this.draw(n),n},t.prototype.polygon=function(t,e){var n=this.gen.polygon(t,e);return this.draw(n),n},t.prototype.arc=function(t,e,n,r,a,o,s,h){void 0===s&&(s=!1);var i=this.gen.arc(t,e,n,r,a,o,s,h);return this.draw(i),i},t.prototype.curve=function(t,e){var n=this.gen.curve(t,e);return this.draw(n),n},t.prototype.path=function(t,e){var n=this.gen.path(t,e);return this.draw(n),n},t}(),U="http://www.w3.org/2000/svg",X=function(){function t(t,e){this.svg=t,this.gen=new J(e)}return t.prototype.draw=function(t){for(var e=t.sets||[],n=t.options||this.getDefaultOptions(),r=this.svg.ownerDocument||window.document,a=r.createElementNS(U,"g"),o=0,s=e;o<s.length;o++){var h=s[o],i=null;switch(h.type){case"path":(i=r.createElementNS(U,"path")).setAttribute("d",this.opsToPath(h)),i.style.stroke=n.stroke,i.style.strokeWidth=n.strokeWidth+"",i.style.fill="none";break;case"fillPath":(i=r.createElementNS(U,"path")).setAttribute("d",this.opsToPath(h)),i.style.stroke="none",i.style.strokeWidth="0",i.style.fill=n.fill||"";break;case"fillSketch":i=this.fillSketch(r,h,n)}i&&a.appendChild(i)}return a},t.prototype.fillSketch=function(t,e,n){var r=n.fillWeight;r<0&&(r=n.strokeWidth/2);var a=t.createElementNS(U,"path");return a.setAttribute("d",this.opsToPath(e)),a.style.stroke=n.fill||"",a.style.strokeWidth=r+"",a.style.fill="none",a},Object.defineProperty(t.prototype,"generator",{get:function(){return this.gen},enumerable:!0,configurable:!0}),t.prototype.getDefaultOptions=function(){return this.gen.defaultOptions},t.prototype.opsToPath=function(t){return this.gen.opsToPath(t)},t.prototype.line=function(t,e,n,r,a){var o=this.gen.line(t,e,n,r,a);return this.draw(o)},t.prototype.rectangle=function(t,e,n,r,a){var o=this.gen.rectangle(t,e,n,r,a);return this.draw(o)},t.prototype.ellipse=function(t,e,n,r,a){var o=this.gen.ellipse(t,e,n,r,a);return this.draw(o)},t.prototype.circle=function(t,e,n,r){var a=this.gen.circle(t,e,n,r);return this.draw(a)},t.prototype.linearPath=function(t,e){var n=this.gen.linearPath(t,e);return this.draw(n)},t.prototype.polygon=function(t,e){var n=this.gen.polygon(t,e);return this.draw(n)},t.prototype.arc=function(t,e,n,r,a,o,s,h){void 0===s&&(s=!1);var i=this.gen.arc(t,e,n,r,a,o,s,h);return this.draw(i)},t.prototype.curve=function(t,e){var n=this.gen.curve(t,e);return this.draw(n)},t.prototype.path=function(t,e){var n=this.gen.path(t,e);return this.draw(n)},t}(),Y={canvas:function(t,e){return new K(t,e)},svg:function(t,e){return new X(t,e)},generator:function(t){return new J(t)},newSeed:function(){return J.newSeed()}};module.exports=Y;

},{}],10:[function(require,module,exports){
/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.


 Copyright (c) 2018 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
(function() {
  'use strict';

  var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
  var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
  var F3 = 1.0 / 3.0;
  var G3 = 1.0 / 6.0;
  var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
  var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;

  function SimplexNoise(randomOrSeed) {
    var random;
    if (typeof randomOrSeed == 'function') {
      random = randomOrSeed;
    }
    else if (randomOrSeed) {
      random = alea(randomOrSeed);
    } else {
      random = Math.random;
    }
    this.p = buildPermutationTable(random);
    this.perm = new Uint8Array(512);
    this.permMod12 = new Uint8Array(512);
    for (var i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }

  }
  SimplexNoise.prototype = {
    grad3: new Float32Array([1, 1, 0,
      -1, 1, 0,
      1, -1, 0,

      -1, -1, 0,
      1, 0, 1,
      -1, 0, 1,

      1, 0, -1,
      -1, 0, -1,
      0, 1, 1,

      0, -1, 1,
      0, 1, -1,
      0, -1, -1]),
    grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,
      0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,
      1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,
      -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,
      1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,
      -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,
      1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,
      -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
    noise2D: function(xin, yin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0 = 0; // Noise contributions from the three corners
      var n1 = 0;
      var n2 = 0;
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin) * F2; // Hairy factor for 2D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var t = (i + j) * G2;
      var X0 = i - t; // Unskew the cell origin back to (x,y) space
      var Y0 = j - t;
      var x0 = xin - X0; // The x,y distances from the cell origin
      var y0 = yin - Y0;
      // For the 2D case, the simplex shape is an equilateral triangle.
      // Determine which simplex we are in.
      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      else {
        i1 = 0;
        j1 = 1;
      } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
      // c = (3-sqrt(3))/6
      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
      var y1 = y0 - j1 + G2;
      var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
      var y2 = y0 - 1.0 + 2.0 * G2;
      // Work out the hashed gradient indices of the three simplex corners
      var ii = i & 255;
      var jj = j & 255;
      // Calculate the contribution from the three corners
      var t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 >= 0) {
        var gi0 = permMod12[ii + perm[jj]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 >= 0) {
        var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
      }
      var t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 >= 0) {
        var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 70.0 * (n0 + n1 + n2);
    },
    // 3D simplex noise
    noise3D: function(xin, yin, zin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0, n1, n2, n3; // Noise contributions from the four corners
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var k = Math.floor(zin + s);
      var t = (i + j + k) * G3;
      var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
      var Y0 = j - t;
      var Z0 = k - t;
      var x0 = xin - X0; // The x,y,z distances from the cell origin
      var y0 = yin - Y0;
      var z0 = zin - Z0;
      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
      // Determine which simplex we are in.
      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // X Y Z order
        else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // X Z Y order
        else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // Z X Y order
      }
      else { // x0<y0
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Z Y X order
        else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Y Z X order
        else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // Y X Z order
      }
      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
      // c = 1/6.
      var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;
      var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
      var y2 = y0 - j2 + 2.0 * G3;
      var z2 = z0 - k2 + 2.0 * G3;
      var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
      var y3 = y0 - 1.0 + 3.0 * G3;
      var z3 = z0 - 1.0 + 3.0 * G3;
      // Work out the hashed gradient indices of the four simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      // Calculate the contribution from the four corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
        t3 *= t3;
        n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to stay just inside [-1,1]
      return 32.0 * (n0 + n1 + n2 + n3);
    },
    // 4D simplex noise, better simplex rank ordering method 2012-03-09
    noise4D: function(x, y, z, w) {
      var perm = this.perm;
      var grad4 = this.grad4;

      var n0, n1, n2, n3, n4; // Noise contributions from the five corners
      // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
      var s = (x + y + z + w) * F4; // Factor for 4D skewing
      var i = Math.floor(x + s);
      var j = Math.floor(y + s);
      var k = Math.floor(z + s);
      var l = Math.floor(w + s);
      var t = (i + j + k + l) * G4; // Factor for 4D unskewing
      var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
      var Y0 = j - t;
      var Z0 = k - t;
      var W0 = l - t;
      var x0 = x - X0; // The x,y,z,w distances from the cell origin
      var y0 = y - Y0;
      var z0 = z - Z0;
      var w0 = w - W0;
      // For the 4D case, the simplex is a 4D shape I won't even try to describe.
      // To find out which of the 24 possible simplices we're in, we need to
      // determine the magnitude ordering of x0, y0, z0 and w0.
      // Six pair-wise comparisons are performed between each possible pair
      // of the four coordinates, and the results are used to rank the numbers.
      var rankx = 0;
      var ranky = 0;
      var rankz = 0;
      var rankw = 0;
      if (x0 > y0) rankx++;
      else ranky++;
      if (x0 > z0) rankx++;
      else rankz++;
      if (x0 > w0) rankx++;
      else rankw++;
      if (y0 > z0) ranky++;
      else rankz++;
      if (y0 > w0) ranky++;
      else rankw++;
      if (z0 > w0) rankz++;
      else rankw++;
      var i1, j1, k1, l1; // The integer offsets for the second simplex corner
      var i2, j2, k2, l2; // The integer offsets for the third simplex corner
      var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
      // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
      // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
      // impossible. Only the 24 indices which have non-zero entries make any sense.
      // We use a thresholding to set the coordinates in turn from the largest magnitude.
      // Rank 3 denotes the largest coordinate.
      i1 = rankx >= 3 ? 1 : 0;
      j1 = ranky >= 3 ? 1 : 0;
      k1 = rankz >= 3 ? 1 : 0;
      l1 = rankw >= 3 ? 1 : 0;
      // Rank 2 denotes the second largest coordinate.
      i2 = rankx >= 2 ? 1 : 0;
      j2 = ranky >= 2 ? 1 : 0;
      k2 = rankz >= 2 ? 1 : 0;
      l2 = rankw >= 2 ? 1 : 0;
      // Rank 1 denotes the second smallest coordinate.
      i3 = rankx >= 1 ? 1 : 0;
      j3 = ranky >= 1 ? 1 : 0;
      k3 = rankz >= 1 ? 1 : 0;
      l3 = rankw >= 1 ? 1 : 0;
      // The fifth corner has all coordinate offsets = 1, so no need to compute that.
      var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
      var y1 = y0 - j1 + G4;
      var z1 = z0 - k1 + G4;
      var w1 = w0 - l1 + G4;
      var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
      var y2 = y0 - j2 + 2.0 * G4;
      var z2 = z0 - k2 + 2.0 * G4;
      var w2 = w0 - l2 + 2.0 * G4;
      var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
      var y3 = y0 - j3 + 3.0 * G4;
      var z3 = z0 - k3 + 3.0 * G4;
      var w3 = w0 - l3 + 3.0 * G4;
      var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
      var y4 = y0 - 1.0 + 4.0 * G4;
      var z4 = z0 - 1.0 + 4.0 * G4;
      var w4 = w0 - 1.0 + 4.0 * G4;
      // Work out the hashed gradient indices of the five simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      var ll = l & 255;
      // Calculate the contribution from the five corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;
        t0 *= t0;
        n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;
        t1 *= t1;
        n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;
        t2 *= t2;
        n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;
        t3 *= t3;
        n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
      }
      var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0) n4 = 0.0;
      else {
        var gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;
        t4 *= t4;
        n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
      }
      // Sum up and scale the result to cover the range [-1,1]
      return 27.0 * (n0 + n1 + n2 + n3 + n4);
    }
  };

  function buildPermutationTable(random) {
    var i;
    var p = new Uint8Array(256);
    for (i = 0; i < 256; i++) {
      p[i] = i;
    }
    for (i = 0; i < 255; i++) {
      var r = i + ~~(random() * (256 - i));
      var aux = p[i];
      p[i] = p[r];
      p[r] = aux;
    }
    return p;
  }
  SimplexNoise._buildPermutationTable = buildPermutationTable;

  function alea() {
    // Johannes BaagÃ¸e <baagoe@baagoe.com>, 2010
    var s0 = 0;
    var s1 = 0;
    var s2 = 0;
    var c = 1;

    var mash = masher();
    s0 = mash(' ');
    s1 = mash(' ');
    s2 = mash(' ');

    for (var i = 0; i < arguments.length; i++) {
      s0 -= mash(arguments[i]);
      if (s0 < 0) {
        s0 += 1;
      }
      s1 -= mash(arguments[i]);
      if (s1 < 0) {
        s1 += 1;
      }
      s2 -= mash(arguments[i]);
      if (s2 < 0) {
        s2 += 1;
      }
    }
    mash = null;
    return function() {
      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
      s0 = s1;
      s1 = s2;
      return s2 = t - (c = t | 0);
    };
  }
  function masher() {
    var n = 0xefc8249d;
    return function(data) {
      data = data.toString();
      for (var i = 0; i < data.length; i++) {
        n += data.charCodeAt(i);
        var h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000; // 2^32
      }
      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    };
  }

  // amd
  if (typeof define !== 'undefined' && define.amd) define(function() {return SimplexNoise;});
  // common js
  if (typeof exports !== 'undefined') exports.SimplexNoise = SimplexNoise;
  // browser
  else if (typeof window !== 'undefined') window.SimplexNoise = SimplexNoise;
  // nodejs
  if (typeof module !== 'undefined') {
    module.exports = SimplexNoise;
  }

})();

},{}],11:[function(require,module,exports){
/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') {
    module.exports = simplify;
    module.exports.default = simplify;
} else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],12:[function(require,module,exports){
module.exports=// bgColour: string;
// bgColourIn?: string;
// buildingColour?: string;
// buildingStroke?: string;
// seaColour: string;
// grassColour?: string;
// minorRoadColour: string;
// minorRoadOutline?: string;
// majorRoadColour?: string;
// majorRoadOutline?: string;
// mainRoadColour?: string;
// mainRoadOutline?: string;  // Be careful, inherits majorRoadOutline, not mainRoadColour
// outlineSize?: number;      // Cascade semantics in style.ts
// zoomBuildings?: boolean;
// 
// Scheme name startsWith 'Drawn' means scheme will use RoughJS canvas

{
    "Default": {
        "bgColour": "rgb(236,229,219)",
        "buildingStroke": "#282828",
        "seaColour": "#a9d9fe",
        "grassColour": "#c5e8c5",
        "minorRoadOutline": "#020202",
        "minorRoadColour": "#F8F8F8",
        "mainRoadOutline": "#282828",
        "mainRoadColour": "#FAFA7A",
    },
    "Apple": {
        "bgColour": "rgb(248,245,238)",
        "buildingColour": "rgb(239,236,229)",
        "buildingStroke": "rgb(235,234,224)",
        "seaColour": "rgb(184,224,243)",
        "grassColour": "rgb(224,237,205)",
        "minorRoadColour": "rgb(255,255,255)",
        "minorRoadOutline": "rgb(215,208,198)",
        "majorRoadColour": "rgb(252,252,224)",
        "majorRoadOutline": "rgb(240,210,152)",
        "mainRoadColour": "rgb(250,224,98)",
        "mainRoadOutline": "rgb(238,199,132)",
        "zoomBuildings": true,
        "outlineSize": 2,
    },
    "AppleDark": {
        "bgColour": "rgb(43,45,47)",
        "buildingColour": "rgb(52,54,56)",
        "buildingStroke": "rgb(47,49,51)",
        "seaColour": "rgb(55,68,100)",
        "grassColour": "rgb(40,56,56)",
        "minorRoadColour": "rgb(65,68,71)",
        "minorRoadOutline": "rgb(43,45,47)",
        "majorRoadColour": "rgb(78,81,84)",
        "majorRoadOutline": "rgb(43,45,47)",
        "mainRoadColour": "rgb(149,108,62)",
        "mainRoadOutline": "rgb(51,51,51)",
        "zoomBuildings": true,
        "outlineSize": 1,
    },
    "Assassin": {
        "bgColour": "rgb(77,96,89)",
        "buildingStroke": "rgb(72,91,84)",
        "seaColour": "rgb(36,40,43)",
        "minorRoadColour": "rgb(127,141,137)",
        "mainRoadColour": "rgb(149,161,157)",
        "mainRoadOutline": "rgb(149,161,157)",
    },
    "Drawn (slow)": {  // Special canvas
        "bgColour": "rgb(242,236,222)",
        "seaColour": "#dbd2bd",
        "minorRoadColour": "#666666",
        "majorRoadColour": "#444444",
        "mainRoadColour": "#222222",
        "buildingStroke": "#333333",
        "buildingColour": "rgb(242,236,222)",
    },
    "Drawn2 (slow)": {  // Special canvas
        "bgColour": "white",
        "seaColour": "#c2c5bf",
        "minorRoadColour": "#666666",
        "majorRoadColour": "#444444",
        "mainRoadColour": "#222222",
        "buildingStroke": "#333333",
        "buildingColour": "rgb(242,236,222)",
    },
    "Google": {
        "bgColour": "rgb(236,236,236)",
        "bgColourIn": "rgb(248,249,250)",
        "buildingColour": "rgb(240,240,240)",
        "buildingSideColour": "rgb(200,200,200)",
        "buildingStroke": "rgb(220,220,220)",
        "seaColour": "rgb(166,213,249)",
        "grassColour": "rgb(198,232,198)",
        "minorRoadColour": "rgb(255,255,255)",
        "minorRoadOutline": "rgb(193,197,214)",
        "mainRoadColour": "rgb(255,242,175)",
        "mainRoadOutline": "rgb(246,207,101)",
        "zoomBuildings": true,
        "buildingModels": true,
        "outlineSize": 2,
    },
    "GoogleNoZoom": {
        "bgColour": "rgb(236,236,236)",
        "bgColourIn": "rgb(248,249,250)",
        "buildingColour": "rgb(240,240,240)",
        "buildingSideColour": "rgb(200,200,200)",
        "buildingStroke": "rgb(220,220,220)",
        "seaColour": "rgb(166,213,249)",
        "grassColour": "rgb(198,232,198)",
        "minorRoadColour": "rgb(255,255,255)",
        "minorRoadOutline": "rgb(193,197,214)",
        "mainRoadColour": "rgb(255,242,175)",
        "mainRoadOutline": "rgb(246,207,101)",
        "zoomBuildings": false,
        "buildingModels": true,
        "outlineSize": 2,
    },
    "Paper": {
        "bgColour": "white",
        "seaColour": "rgb(233,240,255)",
        "grassColour": "rgb(197,232,197)",
        "minorRoadColour": "white",
        "minorRoadOutline": "rgb(222,223,227)",
        "outlineSize": 2,
    },
    "SubtleGrey": {
        "bgColour": "rgb(247,247,247)",
        "buildingColour": "rgb(251,251,251)",
        "buildingStroke": "rgb(243,243,243)",
        "seaColour": "rgb(162,162,157)",
        "grassColour": "rgb(239,239,239)",
        "minorRoadOutline": "white",
        "minorRoadColour": "rgb(212,212,212)",
        "mainRoadOutline": "rgb(208,208,208)",
        "mainRoadColour": "rgb(208,208,208)",
        "frameTextColour": "rgb(162,162,157)",
    },
    "UltraLight": {
        "bgColour": "rgb(247,247,247)",
        "seaColour": "rgb(237,237,237)",
        "buildingStroke": "rgb(238,238,238)",
        "grassColour": "rgb(229,229,229)",
        "minorRoadColour": "white",
    },
    "Wy": {
        "bgColour": "white",
        "seaColour": "rgb(200,215,212)",
        "buildingStroke": "rgb(238,238,238)",
        "minorRoadOutline": "rgb(190,190,190)",
        "minorRoadColour": "rgb(238,238,238)",
    }
}

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var dat = require("dat.gui");

var tensor_field_gui_1 = require("./ts/ui/tensor_field_gui");

var main_gui_1 = require("./ts/ui/main_gui");

var canvas_wrapper_1 = require("./ts/ui/canvas_wrapper");

var util_1 = require("./ts/util");

var drag_controller_1 = require("./ts/ui/drag_controller");

var domain_controller_1 = require("./ts/ui/domain_controller");

var style_1 = require("./ts/ui/style");

var ColourSchemes = require("./colour_schemes.json");

var vector_1 = require("./ts/vector");

var svg_js_1 = require("@svgdotjs/svg.js");

var Main =
/** @class */
function () {
  function Main() {
    var _this = this;

    this.domainController = domain_controller_1["default"].getInstance();
    this.gui = new dat.GUI({
      width: 300
    });
    this.dragController = new drag_controller_1["default"](this.gui); // Options

    this.imageScale = 3; // To force draw if needed

    this.previousFrameDrawTensor = true;
    this.colourScheme = "Default";
    this.zoomBuildings = false;
    this.buildingModels = false;
    this.showFrame = false;
    this.highDPI = false; // 3D settings

    this.cameraX = 0;
    this.cameraY = 0;
    this.STARTING_WIDTH = 1440;
    this.firstGenerate = true; // Canvas setup

    this.canvas = document.getElementById(util_1["default"].CANVAS_ID);
    this.tensorCanvas = new canvas_wrapper_1.DefaultCanvasWrapper(this.canvas);
    var zoomController = this.gui.add(this.domainController, 'zoom');
    this.domainController.setZoomUpdate(function () {
      return zoomController.updateDisplay();
    }); // Make sure we're not too zoomed out for large resolutions

    var screenWidth = this.domainController.screenDimensions.x;

    if (screenWidth > this.STARTING_WIDTH) {
      this.domainController.zoom = screenWidth / this.STARTING_WIDTH;
    } // GUI Setup


    this.gui.add(this, 'generate');
    this.styleFolder = this.gui.addFolder('Style');
    this.styleFolder.add(this, 'colourScheme', Object.keys(ColourSchemes)).onChange(function (val) {
      return _this.changeColourScheme(val);
    });
    this.styleFolder.add(this, 'zoomBuildings').onChange(function (val) {
      // Force redraw
      _this.previousFrameDrawTensor = true;
      _this._style.zoomBuildings = val;
    });
    this.styleFolder.add(this, 'buildingModels').onChange(function (val) {
      // Force redraw
      _this.previousFrameDrawTensor = true;
      _this._style.showBuildingModels = val;
    });
    this.styleFolder.add(this, 'showFrame').onChange(function (val) {
      _this.previousFrameDrawTensor = true;
      _this._style.showFrame = val;
    });
    this.styleFolder.add(this.domainController, 'orthographic');
    this.styleFolder.add(this, 'cameraX', -15, 15).step(1).onChange(function () {
      return _this.setCameraDirection();
    });
    this.styleFolder.add(this, 'cameraY', -15, 15).step(1).onChange(function () {
      return _this.setCameraDirection();
    });
    var noiseParams = {
      globalNoise: false,
      noiseSizePark: 20,
      noiseAnglePark: 90,
      noiseSizeGlobal: 30,
      noiseAngleGlobal: 20
    };
    this.tensorFolder = this.gui.addFolder('Tensor Field');
    this.tensorField = new tensor_field_gui_1["default"](this.tensorFolder, this.dragController, true, noiseParams);
    this.roadsFolder = this.gui.addFolder('Map');
    this.mainGui = new main_gui_1["default"](this.roadsFolder, this.tensorField, function () {
      return _this.tensorFolder.close();
    });
    var optionsFolder = this.gui.addFolder('Options');
    optionsFolder.add(this.tensorField, 'drawCentre');
    var canvasScaleController = optionsFolder.add(this, 'highDPI');
    canvasScaleController.onChange(function (high) {
      return _this.changeCanvasScale(high);
    });
    optionsFolder.add(this, 'imageScale', 1, 5).step(1);
    optionsFolder.add(this, 'download');
    optionsFolder.add(this, 'downloadSVG');
    this.changeColourScheme(this.colourScheme);
    this.tensorField.setRecommended();
    requestAnimationFrame(this.update.bind(this));
  }

  Main.prototype.generate = function () {
    if (!this.firstGenerate) {
      this.tensorField.setRecommended();
    } else {
      this.firstGenerate = false;
    }

    this.mainGui.generateEverything();
  };

  Main.prototype.changeColourScheme = function (scheme) {
    var colourScheme = ColourSchemes[scheme];
    this.zoomBuildings = colourScheme.zoomBuildings;
    this.buildingModels = colourScheme.buildingModels;
    util_1["default"].updateGui(this.styleFolder);

    if (scheme.startsWith("Drawn")) {
      this._style = new style_1.RoughStyle(this.canvas, this.dragController, Object.assign({}, colourScheme));
    } else {
      this._style = new style_1.DefaultStyle(this.canvas, this.dragController, Object.assign({}, colourScheme));
    }

    this._style.showFrame = this.showFrame;
    this.changeCanvasScale(this.highDPI);
  };

  Main.prototype.changeCanvasScale = function (high) {
    var value = high ? 2 : 1;
    this._style.canvasScale = value;
    this.tensorCanvas.canvasScale = value;
  };

  Main.prototype.setCameraDirection = function () {
    this.domainController.cameraDirection = new vector_1["default"](this.cameraX / 10, this.cameraY / 10);
  };
  /**
   * Downloads image of map
   * Draws onto hidden canvas at requested resolution
   */


  Main.prototype.download = function () {
    var c = document.getElementById(util_1["default"].IMG_CANVAS_ID); // Draw

    if (this.showTensorField()) {
      this.tensorField.draw(new canvas_wrapper_1.DefaultCanvasWrapper(c, this.imageScale, false));
    } else {
      var imgCanvas = this._style.createCanvasWrapper(c, this.imageScale, false);

      this.mainGui.draw(this._style, true, imgCanvas);
    }

    var link = document.createElement('a');
    link.download = 'map.png';
    link.href = document.getElementById(util_1["default"].IMG_CANVAS_ID).toDataURL();
    link.click();
  };
  /**
   * Downloads svg of map
   * Draws onto hidden svg at requested resolution
   */


  Main.prototype.downloadSVG = function () {
    var c = document.getElementById(util_1["default"].IMG_CANVAS_ID);
    var svgElement = document.getElementById(util_1["default"].SVG_ID);

    if (this.showTensorField()) {
      var imgCanvas = new canvas_wrapper_1.DefaultCanvasWrapper(c, 1, false);
      imgCanvas.createSVG(svgElement);
      this.tensorField.draw(imgCanvas);
    } else {
      var imgCanvas = this._style.createCanvasWrapper(c, 1, false);

      imgCanvas.createSVG(svgElement);
      this.mainGui.draw(this._style, true, imgCanvas);
    }

    var serializer = new XMLSerializer();
    var source = serializer.serializeToString(svgElement); //add name spaces.

    if (!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
      source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
    }

    if (!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)) {
      source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
    } //add xml declaration


    source = '<?xml version="1.0" standalone="no"?>\r\n' + source; //convert svg source to URI data scheme.

    var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
    var link = document.createElement('a');
    link.download = 'map.svg';
    link.href = url;
    link.click(); // Clear SVG

    var element = svg_js_1.SVG(svgElement);
    element.clear();
  };

  Main.prototype.showTensorField = function () {
    return !this.tensorFolder.closed || this.mainGui.roadsEmpty();
  };

  Main.prototype.draw = function () {
    if (this.showTensorField()) {
      this.previousFrameDrawTensor = true;
      this.dragController.setDragDisabled(false);
      this.tensorField.draw(this.tensorCanvas);
    } else {
      // Disable field drag and drop
      this.dragController.setDragDisabled(true);

      if (this.previousFrameDrawTensor === true) {
        this.previousFrameDrawTensor = false; // Force redraw if switching from tensor field

        this.mainGui.draw(this._style, true);
      } else {
        this.mainGui.draw(this._style);
      }
    }
  };

  Main.prototype.update = function () {
    this._style.update();

    this.mainGui.update();
    this.draw();
    requestAnimationFrame(this.update.bind(this));
  };

  return Main;
}();

window.log = log;
window.addEventListener('load', function () {
  new Main();
});

},{"./colour_schemes.json":12,"./ts/ui/canvas_wrapper":26,"./ts/ui/domain_controller":27,"./ts/ui/drag_controller":28,"./ts/ui/main_gui":29,"./ts/ui/style":31,"./ts/ui/tensor_field_gui":32,"./ts/util":34,"./ts/vector":35,"@svgdotjs/svg.js":1,"dat.gui":3,"loglevel":7}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var Vector =
/** @class */
function () {
  function Vector(x, y) {
    this.x = x;
    this.y = y;
  }

  Vector.zeroVector = function () {
    return new Vector(0, 0);
  };

  Vector.fromScalar = function (s) {
    return new Vector(s, s);
  };
  /**
   * -pi to pi
   */


  Vector.angleBetween = function (v1, v2) {
    // -2pi to 2pi
    var angleBetween = v1.angle() - v2.angle();

    if (angleBetween > Math.PI) {
      angleBetween -= 2 * Math.PI;
    } else if (angleBetween <= -Math.PI) {
      angleBetween += 2 * Math.PI;
    }

    return angleBetween;
  };
  /**
   * Tests whether a point lies to the left of a line
   * @param  {Vector} linePoint     Point on the line
   * @param  {Vector} lineDirection
   * @param  {Vector} point
   * @return {Vector}               true if left, false otherwise
   */


  Vector.isLeft = function (linePoint, lineDirection, point) {
    var perpendicularVector = new Vector(lineDirection.y, -lineDirection.x);
    return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
  };

  Vector.prototype.add = function (v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  };
  /**
   * Angle in radians to positive x-axis between -pi and pi
   */


  Vector.prototype.angle = function () {
    return Math.atan2(this.y, this.x);
  };

  Vector.prototype.clone = function () {
    return new Vector(this.x, this.y);
  };

  Vector.prototype.copy = function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  };

  Vector.prototype.cross = function (v) {
    return this.x * v.y - this.y * v.x;
  };

  Vector.prototype.distanceTo = function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  };

  Vector.prototype.distanceToSquared = function (v) {
    var dx = this.x - v.x;
    var dy = this.y - v.y;
    return dx * dx + dy * dy;
  };

  Vector.prototype.divide = function (v) {
    if (v.x === 0 || v.y === 0) {
      log.warn("Division by zero");
      return this;
    }

    this.x /= v.x;
    this.y /= v.y;
    return this;
  };

  Vector.prototype.divideScalar = function (s) {
    if (s === 0) {
      log.warn("Division by zero");
      return this;
    }

    return this.multiplyScalar(1 / s);
  };

  Vector.prototype.dot = function (v) {
    return this.x * v.x + this.y * v.y;
  };

  Vector.prototype.equals = function (v) {
    return v.x === this.x && v.y === this.y;
  };

  Vector.prototype.length = function () {
    return Math.sqrt(this.lengthSq());
  };

  Vector.prototype.lengthSq = function () {
    return this.x * this.x + this.y * this.y;
  };

  Vector.prototype.multiply = function (v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  };

  Vector.prototype.multiplyScalar = function (s) {
    this.x *= s;
    this.y *= s;
    return this;
  };

  Vector.prototype.negate = function () {
    return this.multiplyScalar(-1);
  };

  Vector.prototype.normalize = function () {
    var l = this.length();

    if (l === 0) {
      log.warn("Zero Vector");
      return this;
    }

    return this.divideScalar(this.length());
  };
  /**
   * Angle in radians
   */


  Vector.prototype.rotateAround = function (center, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var x = this.x - center.x;
    var y = this.y - center.y;
    this.x = x * cos - y * sin + center.x;
    this.y = x * sin + y * cos + center.y;
    return this;
  };

  Vector.prototype.set = function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  };

  Vector.prototype.setX = function (x) {
    this.x = x;
    return this;
  };

  Vector.prototype.setY = function (y) {
    this.y = y;
    return this;
  };

  Vector.prototype.setLength = function (length) {
    return this.normalize().multiplyScalar(length);
  };

  Vector.prototype.sub = function (v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  };

  return Vector;
}();

exports["default"] = Vector;

},{"loglevel":7}],15:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tensor_1 = require("./tensor");

var BasisField =
/** @class */
function () {
  function BasisField(centre, _size, _decay) {
    this._size = _size;
    this._decay = _decay;
    this._centre = centre.clone();
  }

  Object.defineProperty(BasisField.prototype, "centre", {
    get: function get() {
      return this._centre.clone();
    },
    set: function set(centre) {
      this._centre.copy(centre);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(BasisField.prototype, "decay", {
    set: function set(decay) {
      this._decay = decay;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(BasisField.prototype, "size", {
    set: function set(size) {
      this._size = size;
    },
    enumerable: true,
    configurable: true
  });

  BasisField.prototype.dragMoveListener = function (delta) {
    // Delta assumed to be in world space (only relevant when zoomed)
    this._centre.add(delta);
  };

  BasisField.prototype.getWeightedTensor = function (point) {
    return this.getTensor(point).scale(this.getTensorWeight(point));
  };
  /**
   * Creates a folder and adds it to the GUI to control params
   */


  BasisField.prototype.setGui = function (gui) {
    gui.add(this._centre, 'x');
    gui.add(this._centre, 'y');
    gui.add(this, '_size');
    gui.add(this, '_decay', 0, 50);
  };
  /**
   * Interpolates between (0 and 1)^decay
   */


  BasisField.prototype.getTensorWeight = function (point) {
    var normDistanceToCentre = point.clone().sub(this._centre).length() / this._size; // Stop (** 0) turning weight into 1, filling screen even when outside 'size'


    if (this._decay === 0 && normDistanceToCentre >= 1) {
      return 0;
    }

    return Math.pow(Math.max(0, 1 - normDistanceToCentre), this._decay);
  };

  BasisField.folderNameIndex = 0;
  return BasisField;
}();

exports.BasisField = BasisField;

var Grid =
/** @class */
function (_super) {
  __extends(Grid, _super);

  function Grid(centre, size, decay, _theta) {
    var _this = _super.call(this, centre, size, decay) || this;

    _this._theta = _theta;
    _this.FOLDER_NAME = "Grid " + Grid.folderNameIndex++;
    return _this;
  }

  Object.defineProperty(Grid.prototype, "theta", {
    set: function set(theta) {
      this._theta = theta;
    },
    enumerable: true,
    configurable: true
  });

  Grid.prototype.setGui = function (gui) {
    var _this = this;

    _super.prototype.setGui.call(this, gui); // GUI in degrees, convert to rads


    var thetaProp = {
      theta: this._theta * 180 / Math.PI
    };
    var thetaController = gui.add(thetaProp, 'theta', -90, 90);
    thetaController.onChange(function (theta) {
      return _this._theta = theta * (Math.PI / 180);
    });
  };

  Grid.prototype.getTensor = function (point) {
    var cos = Math.cos(2 * this._theta);
    var sin = Math.sin(2 * this._theta);
    return new tensor_1["default"](1, [cos, sin]);
  };

  return Grid;
}(BasisField);

exports.Grid = Grid;

var Radial =
/** @class */
function (_super) {
  __extends(Radial, _super);

  function Radial(centre, size, decay) {
    var _this = _super.call(this, centre, size, decay) || this;

    _this.FOLDER_NAME = "Radial " + Radial.folderNameIndex++;
    return _this;
  }

  Radial.prototype.getTensor = function (point) {
    var t = point.clone().sub(this._centre);
    var t1 = Math.pow(t.y, 2) - Math.pow(t.x, 2);
    var t2 = -2 * t.x * t.y;
    return new tensor_1["default"](1, [t1, t2]);
  };

  return Radial;
}(BasisField);

exports.Radial = Radial;

},{"./tensor":22}],16:[function(require,module,exports){
"use strict";

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var isect = require("isect");

var d3 = require("d3-quadtree");

var vector_1 = require("../vector");

var Node =
/** @class */
function () {
  function Node(value, neighbors) {
    if (neighbors === void 0) {
      neighbors = new Set();
    }

    this.value = value;
    this.neighbors = neighbors;
    this.segments = new Set();
  }

  Node.prototype.addSegment = function (segment) {
    this.segments.add(segment);
  };

  Node.prototype.addNeighbor = function (node) {
    if (node !== this) {
      this.neighbors.add(node);
      node.neighbors.add(this);
    }
  };

  return Node;
}();

exports.Node = Node;

var Graph =
/** @class */
function () {
  function Graph(streamlines, dstep, deleteDangling) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e, e_6, _f;

    if (deleteDangling === void 0) {
      deleteDangling = false;
    }

    var intersections = isect.bush(this.streamlinesToSegment(streamlines)).run();
    var quadtree = d3.quadtree().x(function (n) {
      return n.value.x;
    }).y(function (n) {
      return n.value.y;
    });
    var nodeAddRadius = 0.001;

    try {
      // Add all segment start and endpoints
      for (var streamlines_1 = __values(streamlines), streamlines_1_1 = streamlines_1.next(); !streamlines_1_1.done; streamlines_1_1 = streamlines_1.next()) {
        var streamline = streamlines_1_1.value;

        for (var i = 0; i < streamline.length; i++) {
          var node = new Node(streamline[i]);

          if (i > 0) {
            node.addSegment(this.vectorsToSegment(streamline[i - 1], streamline[i]));
          }

          if (i < streamline.length - 1) {
            node.addSegment(this.vectorsToSegment(streamline[i], streamline[i + 1]));
          }

          this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (streamlines_1_1 && !streamlines_1_1.done && (_a = streamlines_1["return"])) _a.call(streamlines_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    try {
      // Add all intersections
      for (var intersections_1 = __values(intersections), intersections_1_1 = intersections_1.next(); !intersections_1_1.done; intersections_1_1 = intersections_1.next()) {
        var intersection = intersections_1_1.value;
        var node = new Node(new vector_1["default"](intersection.point.x, intersection.point.y));

        try {
          for (var _g = (e_3 = void 0, __values(intersection.segments)), _h = _g.next(); !_h.done; _h = _g.next()) {
            var s = _h.value;
            node.addSegment(s);
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (_h && !_h.done && (_c = _g["return"])) _c.call(_g);
          } finally {
            if (e_3) throw e_3.error;
          }
        }

        this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (intersections_1_1 && !intersections_1_1.done && (_b = intersections_1["return"])) _b.call(intersections_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    try {
      // For each simplified streamline, build list of nodes in order along streamline
      for (var streamlines_2 = __values(streamlines), streamlines_2_1 = streamlines_2.next(); !streamlines_2_1.done; streamlines_2_1 = streamlines_2.next()) {
        var streamline = streamlines_2_1.value;

        for (var i = 0; i < streamline.length - 1; i++) {
          var nodesAlongSegment = this.getNodesAlongSegment(this.vectorsToSegment(streamline[i], streamline[i + 1]), quadtree, nodeAddRadius, dstep);

          if (nodesAlongSegment.length > 1) {
            for (var j = 0; j < nodesAlongSegment.length - 1; j++) {
              nodesAlongSegment[j].addNeighbor(nodesAlongSegment[j + 1]);
            }
          } else {
            log.error("Error Graph.js: segment with less than 2 nodes");
          }
        }
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (streamlines_2_1 && !streamlines_2_1.done && (_d = streamlines_2["return"])) _d.call(streamlines_2);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    try {
      for (var _j = __values(quadtree.data()), _k = _j.next(); !_k.done; _k = _j.next()) {
        var n = _k.value;

        if (deleteDangling) {
          this.deleteDanglingNodes(n, quadtree);
        }

        n.adj = Array.from(n.neighbors);
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (_k && !_k.done && (_e = _j["return"])) _e.call(_j);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    this.nodes = quadtree.data();
    this.intersections = [];

    try {
      for (var intersections_2 = __values(intersections), intersections_2_1 = intersections_2.next(); !intersections_2_1.done; intersections_2_1 = intersections_2.next()) {
        var i = intersections_2_1.value;
        this.intersections.push(new vector_1["default"](i.point.x, i.point.y));
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (intersections_2_1 && !intersections_2_1.done && (_f = intersections_2["return"])) _f.call(intersections_2);
      } finally {
        if (e_6) throw e_6.error;
      }
    }
  }

  Graph.prototype.deleteDanglingNodes = function (n, quadtree) {
    var e_7, _a;

    if (n.neighbors.size === 1) {
      quadtree.remove(n);

      try {
        for (var _b = __values(n.neighbors), _c = _b.next(); !_c.done; _c = _b.next()) {
          var neighbor = _c.value;
          neighbor.neighbors["delete"](n);
          this.deleteDanglingNodes(neighbor, quadtree);
        }
      } catch (e_7_1) {
        e_7 = {
          error: e_7_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
        } finally {
          if (e_7) throw e_7.error;
        }
      }
    }
  };

  Graph.prototype.getNodesAlongSegment = function (segment, quadtree, radius, step) {
    // Walk dstep along each streamline, adding nodes within dstep/2
    // and connected to this streamline (fuzzy - nodeAddRadius) to list, removing from
    // quadtree and adding them all back at the end
    var e_8, _a;

    var _this = this;

    var foundNodes = [];
    var nodesAlongSegment = [];
    var start = new vector_1["default"](segment.from.x, segment.from.y);
    var end = new vector_1["default"](segment.to.x, segment.to.y);
    var differenceVector = end.clone().sub(start);
    step = Math.min(step, differenceVector.length() / 2); // Min of 2 step along vector

    var steps = Math.ceil(differenceVector.length() / step);
    var differenceVectorLength = differenceVector.length();

    for (var i = 0; i <= steps; i++) {
      var currentPoint = start.clone().add(differenceVector.clone().multiplyScalar(i / steps)); // Order nodes, not by 'closeness', but by dot product

      var nodesToAdd = [];
      var closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);

      while (closestNode !== undefined) {
        quadtree.remove(closestNode);
        foundNodes.push(closestNode);
        var nodeOnSegment = false;

        try {
          for (var _b = (e_8 = void 0, __values(closestNode.segments)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var s = _c.value;

            if (this.fuzzySegmentsEqual(s, segment)) {
              nodeOnSegment = true;
              break;
            }
          }
        } catch (e_8_1) {
          e_8 = {
            error: e_8_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
          } finally {
            if (e_8) throw e_8.error;
          }
        }

        if (nodeOnSegment) {
          nodesToAdd.push(closestNode);
        }

        closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);
      }

      nodesToAdd.sort(function (first, second) {
        return _this.dotProductToSegment(first, start, differenceVector) - _this.dotProductToSegment(second, start, differenceVector);
      });
      nodesAlongSegment.push.apply(nodesAlongSegment, __spread(nodesToAdd));
    }

    quadtree.addAll(foundNodes);
    return nodesAlongSegment;
  };

  Graph.prototype.fuzzySegmentsEqual = function (s1, s2, tolerance) {
    if (tolerance === void 0) {
      tolerance = 0.0001;
    } // From


    if (s1.from.x - s2.from.x > tolerance) {
      return false;
    }

    if (s1.from.y - s2.from.y > tolerance) {
      return false;
    } // To


    if (s1.to.x - s2.to.x > tolerance) {
      return false;
    }

    if (s1.to.y - s2.to.y > tolerance) {
      return false;
    }

    return true;
  };

  Graph.prototype.dotProductToSegment = function (node, start, differenceVector) {
    var dotVector = node.value.clone().sub(start);
    return differenceVector.dot(dotVector);
  };

  Graph.prototype.fuzzyAddToQuadtree = function (quadtree, node, radius) {
    var e_9, _a, e_10, _b; // Only add if there isn't a node within radius
    // Remember to check for double radius when querying tree, or point might be missed


    var existingNode = quadtree.find(node.value.x, node.value.y, radius);

    if (existingNode === undefined) {
      quadtree.add(node);
    } else {
      try {
        for (var _c = __values(node.neighbors), _d = _c.next(); !_d.done; _d = _c.next()) {
          var neighbor = _d.value;
          existingNode.addNeighbor(neighbor);
        }
      } catch (e_9_1) {
        e_9 = {
          error: e_9_1
        };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
        } finally {
          if (e_9) throw e_9.error;
        }
      }

      try {
        for (var _e = __values(node.segments), _f = _e.next(); !_f.done; _f = _e.next()) {
          var segment = _f.value;
          existingNode.addSegment(segment);
        }
      } catch (e_10_1) {
        e_10 = {
          error: e_10_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
        } finally {
          if (e_10) throw e_10.error;
        }
      }
    }
  };

  Graph.prototype.streamlinesToSegment = function (streamlines) {
    var e_11, _a;

    var out = [];

    try {
      for (var streamlines_3 = __values(streamlines), streamlines_3_1 = streamlines_3.next(); !streamlines_3_1.done; streamlines_3_1 = streamlines_3.next()) {
        var s = streamlines_3_1.value;

        for (var i = 0; i < s.length - 1; i++) {
          out.push(this.vectorsToSegment(s[i], s[i + 1]));
        }
      }
    } catch (e_11_1) {
      e_11 = {
        error: e_11_1
      };
    } finally {
      try {
        if (streamlines_3_1 && !streamlines_3_1.done && (_a = streamlines_3["return"])) _a.call(streamlines_3);
      } finally {
        if (e_11) throw e_11.error;
      }
    }

    return out;
  };

  Graph.prototype.vectorsToSegment = function (v1, v2) {
    return {
      from: v1,
      to: v2
    };
  };

  return Graph;
}();

exports["default"] = Graph;

},{"../vector":35,"d3-quadtree":2,"isect":5,"loglevel":7}],17:[function(require,module,exports){
"use strict";

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_1 = require("../vector");

var GridStorage =
/** @class */
function () {
  /**
   * worldDimensions assumes origin of 0,0
   * @param {number} dsep Separation distance between samples
   */
  function GridStorage(worldDimensions, origin, dsep) {
    this.worldDimensions = worldDimensions;
    this.origin = origin;
    this.dsep = dsep;
    this.dsepSq = this.dsep * this.dsep;
    this.gridDimensions = worldDimensions.clone().divideScalar(this.dsep);
    this.grid = [];

    for (var x = 0; x < this.gridDimensions.x; x++) {
      this.grid.push([]);

      for (var y = 0; y < this.gridDimensions.y; y++) {
        this.grid[x].push([]);
      }
    }
  }
  /**
   * Add all samples from another grid to this one
   */


  GridStorage.prototype.addAll = function (gridStorage) {
    var e_1, _a, e_2, _b, e_3, _c;

    try {
      for (var _d = __values(gridStorage.grid), _e = _d.next(); !_e.done; _e = _d.next()) {
        var row = _e.value;

        try {
          for (var row_1 = (e_2 = void 0, __values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
            var cell = row_1_1.value;

            try {
              for (var cell_1 = (e_3 = void 0, __values(cell)), cell_1_1 = cell_1.next(); !cell_1_1.done; cell_1_1 = cell_1.next()) {
                var sample = cell_1_1.value;
                this.addSample(sample);
              }
            } catch (e_3_1) {
              e_3 = {
                error: e_3_1
              };
            } finally {
              try {
                if (cell_1_1 && !cell_1_1.done && (_c = cell_1["return"])) _c.call(cell_1);
              } finally {
                if (e_3) throw e_3.error;
              }
            }
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (row_1_1 && !row_1_1.done && (_b = row_1["return"])) _b.call(row_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_e && !_e.done && (_a = _d["return"])) _a.call(_d);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  GridStorage.prototype.addPolyline = function (line) {
    var e_4, _a;

    try {
      for (var line_1 = __values(line), line_1_1 = line_1.next(); !line_1_1.done; line_1_1 = line_1.next()) {
        var v = line_1_1.value;
        this.addSample(v);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (line_1_1 && !line_1_1.done && (_a = line_1["return"])) _a.call(line_1);
      } finally {
        if (e_4) throw e_4.error;
      }
    }
  };
  /**
   * Does not enforce separation
   * Does not clone
   */


  GridStorage.prototype.addSample = function (v, coords) {
    if (!coords) {
      coords = this.getSampleCoords(v);
    }

    this.grid[coords.x][coords.y].push(v);
  };
  /**
   * Tests whether v is at least d away from samples
   * Performance very important - this is called at every integration step
   * @param dSq=this.dsepSq squared test distance
   * Could be dtest if we are integrating a streamline
   */


  GridStorage.prototype.isValidSample = function (v, dSq) {
    // Code duplication with this.getNearbyPoints but much slower when calling
    // this.getNearbyPoints due to array creation in that method
    if (dSq === void 0) {
      dSq = this.dsepSq;
    }

    var coords = this.getSampleCoords(v); // Check samples in 9 cells in 3x3 grid

    for (var x = -1; x <= 1; x++) {
      for (var y = -1; y <= 1; y++) {
        var cell = coords.clone().add(new vector_1["default"](x, y));

        if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
          if (!this.vectorFarFromVectors(v, this.grid[cell.x][cell.y], dSq)) {
            return false;
          }
        }
      }
    }

    return true;
  };
  /**
   * Test whether v is at least d away from vectors
   * Performance very important - this is called at every integration step
   * @param {number}   dSq     squared test distance
   */


  GridStorage.prototype.vectorFarFromVectors = function (v, vectors, dSq) {
    var e_5, _a;

    try {
      for (var vectors_1 = __values(vectors), vectors_1_1 = vectors_1.next(); !vectors_1_1.done; vectors_1_1 = vectors_1.next()) {
        var sample = vectors_1_1.value;

        if (sample !== v) {
          var distanceSq = sample.distanceToSquared(v);

          if (distanceSq < dSq) {
            return false;
          }
        }
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (vectors_1_1 && !vectors_1_1.done && (_a = vectors_1["return"])) _a.call(vectors_1);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    return true;
  };
  /**
   * Returns points in cells surrounding v
   * Results include v, if it exists in the grid
   * @param {number} returns samples (kind of) closer than distance - returns all samples in
   * cells so approximation (square to approximate circle)
   */


  GridStorage.prototype.getNearbyPoints = function (v, distance) {
    var e_6, _a;

    var radius = Math.ceil(distance / this.dsep - 0.5);
    var coords = this.getSampleCoords(v);
    var out = [];

    for (var x = -1 * radius; x <= 1 * radius; x++) {
      for (var y = -1 * radius; y <= 1 * radius; y++) {
        var cell = coords.clone().add(new vector_1["default"](x, y));

        if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
          try {
            for (var _b = (e_6 = void 0, __values(this.grid[cell.x][cell.y])), _c = _b.next(); !_c.done; _c = _b.next()) {
              var v2 = _c.value;
              out.push(v2);
            }
          } catch (e_6_1) {
            e_6 = {
              error: e_6_1
            };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            } finally {
              if (e_6) throw e_6.error;
            }
          }
        }
      }
    }

    return out;
  };

  GridStorage.prototype.worldToGrid = function (v) {
    return v.clone().sub(this.origin);
  };

  GridStorage.prototype.gridToWorld = function (v) {
    return v.clone().add(this.origin);
  };

  GridStorage.prototype.vectorOutOfBounds = function (gridV, bounds) {
    return gridV.x < 0 || gridV.y < 0 || gridV.x >= bounds.x || gridV.y >= bounds.y;
  };
  /**
   * @return {Vector}   Cell coords corresponding to vector
   * Performance important - called at every integration step
   */


  GridStorage.prototype.getSampleCoords = function (worldV) {
    var v = this.worldToGrid(worldV);

    if (this.vectorOutOfBounds(v, this.worldDimensions)) {
      // log.error("Tried to access out-of-bounds sample in grid");
      return vector_1["default"].zeroVector();
    }

    return new vector_1["default"](Math.floor(v.x / this.dsep), Math.floor(v.y / this.dsep));
  };

  return GridStorage;
}();

exports["default"] = GridStorage;

},{"../vector":35}],18:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_1 = require("../vector");

var FieldIntegrator =
/** @class */
function () {
  function FieldIntegrator(field) {
    this.field = field;
  }

  FieldIntegrator.prototype.sampleFieldVector = function (point, major) {
    var tensor = this.field.samplePoint(point);
    if (major) return tensor.getMajor();
    return tensor.getMinor();
  };

  FieldIntegrator.prototype.onLand = function (point) {
    return this.field.onLand(point);
  };

  return FieldIntegrator;
}();

exports["default"] = FieldIntegrator;

var EulerIntegrator =
/** @class */
function (_super) {
  __extends(EulerIntegrator, _super);

  function EulerIntegrator(field, params) {
    var _this = _super.call(this, field) || this;

    _this.params = params;
    return _this;
  }

  EulerIntegrator.prototype.integrate = function (point, major) {
    return this.sampleFieldVector(point, major).multiplyScalar(this.params.dstep);
  };

  return EulerIntegrator;
}(FieldIntegrator);

exports.EulerIntegrator = EulerIntegrator;

var RK4Integrator =
/** @class */
function (_super) {
  __extends(RK4Integrator, _super);

  function RK4Integrator(field, params) {
    var _this = _super.call(this, field) || this;

    _this.params = params;
    return _this;
  }

  RK4Integrator.prototype.integrate = function (point, major) {
    var k1 = this.sampleFieldVector(point, major);
    var k23 = this.sampleFieldVector(point.clone().add(vector_1["default"].fromScalar(this.params.dstep / 2)), major);
    var k4 = this.sampleFieldVector(point.clone().add(vector_1["default"].fromScalar(this.params.dstep)), major);
    return k1.add(k23.multiplyScalar(4)).add(k4).multiplyScalar(this.params.dstep / 6);
  };

  return RK4Integrator;
}(FieldIntegrator);

exports.RK4Integrator = RK4Integrator;

},{"../vector":35}],19:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var polygon_util_1 = require("./polygon_util");

var PolygonFinder =
/** @class */
function () {
  function PolygonFinder(nodes, params, tensorField) {
    this.nodes = nodes;
    this.params = params;
    this.tensorField = tensorField;
    this._polygons = [];
    this._shrunkPolygons = [];
    this._dividedPolygons = [];
    this.toShrink = [];
    this.toDivide = [];
  }

  Object.defineProperty(PolygonFinder.prototype, "polygons", {
    get: function get() {
      if (this._dividedPolygons.length > 0) {
        return this._dividedPolygons;
      }

      if (this._shrunkPolygons.length > 0) {
        return this._shrunkPolygons;
      }

      return this._polygons;
    },
    enumerable: true,
    configurable: true
  });

  PolygonFinder.prototype.reset = function () {
    this.toShrink = [];
    this.toDivide = [];
    this._polygons = [];
    this._shrunkPolygons = [];
    this._dividedPolygons = [];
  };

  PolygonFinder.prototype.update = function () {
    var change = false;

    if (this.toShrink.length > 0) {
      var resolve = this.toShrink.length === 1;

      if (this.stepShrink(this.toShrink.pop())) {
        change = true;
      }

      if (resolve) this.resolveShrink();
    }

    if (this.toDivide.length > 0) {
      var resolve = this.toDivide.length === 1;

      if (this.stepDivide(this.toDivide.pop())) {
        change = true;
      } // const divided = PolygonUtil.subdividePolygon(this.toDivide.pop(), this.params.minArea);
      // if (divided.length > 0) {
      //     this._dividedPolygons.push(...divided);
      //     change = true;    
      // }


      if (resolve) this.resolveDivide();
    }

    return change;
  };

  PolygonFinder.prototype.shrink = function (animate) {
    if (animate === void 0) {
      animate = false;
    }

    return __awaiter(this, void 0, void 0, function () {
      var _this = this;

      return __generator(this, function (_a) {
        return [2
        /*return*/
        , new Promise(function (resolve) {
          var e_1, _a;

          if (_this._polygons.length === 0) {
            _this.findPolygons();
          }

          if (animate) {
            if (_this._polygons.length === 0) {
              resolve();
              return;
            }

            _this.toShrink = _this._polygons.slice();
            _this.resolveShrink = resolve;
          } else {
            _this._shrunkPolygons = [];

            try {
              for (var _b = __values(_this._polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;

                _this.stepShrink(p);
              }
            } catch (e_1_1) {
              e_1 = {
                error: e_1_1
              };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
              } finally {
                if (e_1) throw e_1.error;
              }
            }

            resolve();
          }
        })];
      });
    });
  };

  PolygonFinder.prototype.stepShrink = function (polygon) {
    var shrunk = polygon_util_1["default"].resizeGeometry(polygon, -this.params.shrinkSpacing);

    if (shrunk.length > 0) {
      this._shrunkPolygons.push(shrunk);

      return true;
    }

    ;
    return false;
  };

  PolygonFinder.prototype.divide = function (animate) {
    if (animate === void 0) {
      animate = false;
    }

    return __awaiter(this, void 0, void 0, function () {
      var _this = this;

      return __generator(this, function (_a) {
        return [2
        /*return*/
        , new Promise(function (resolve) {
          var e_2, _a;

          if (_this._polygons.length === 0) {
            _this.findPolygons();
          }

          var polygons = _this._polygons;

          if (_this._shrunkPolygons.length > 0) {
            polygons = _this._shrunkPolygons;
          }

          if (animate) {
            if (polygons.length === 0) {
              resolve();
              return;
            }

            _this.toDivide = polygons.slice();
            _this.resolveDivide = resolve;
          } else {
            _this._dividedPolygons = [];

            try {
              for (var polygons_1 = __values(polygons), polygons_1_1 = polygons_1.next(); !polygons_1_1.done; polygons_1_1 = polygons_1.next()) {
                var p = polygons_1_1.value;

                _this.stepDivide(p);
              }
            } catch (e_2_1) {
              e_2 = {
                error: e_2_1
              };
            } finally {
              try {
                if (polygons_1_1 && !polygons_1_1.done && (_a = polygons_1["return"])) _a.call(polygons_1);
              } finally {
                if (e_2) throw e_2.error;
              }
            }

            resolve();
          }
        })];
      });
    });
  };

  PolygonFinder.prototype.stepDivide = function (polygon) {
    var _a; // TODO need to filter shrunk polygons using aspect ratio, area 
    // this skips the filter in PolygonUtil.subdividePolygon


    if (this.params.chanceNoDivide > 0 && Math.random() < this.params.chanceNoDivide) {
      this._dividedPolygons.push(polygon);

      return true;
    }

    var divided = polygon_util_1["default"].subdividePolygon(polygon, this.params.minArea);

    if (divided.length > 0) {
      (_a = this._dividedPolygons).push.apply(_a, __spread(divided));

      return true;
    }

    return false;
  };

  PolygonFinder.prototype.findPolygons = function () {
    // Node
    // x, y, value (Vector2), adj (list of node refs)
    // Gonna edit adj for now
    var e_3, _a, e_4, _b; // Walk a clockwise path until polygon found or limit reached
    // When we find a polygon, mark all edges as traversed (in particular direction)
    // Each edge separates two polygons
    // If edge already traversed in this direction, this polygon has already been found


    this._shrunkPolygons = [];
    this._dividedPolygons = [];
    var polygons = [];

    try {
      for (var _c = __values(this.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
        var node = _d.value;
        if (node.adj.length < 2) continue;

        try {
          for (var _e = (e_4 = void 0, __values(node.adj)), _f = _e.next(); !_f.done; _f = _e.next()) {
            var nextNode = _f.value;
            var polygon = this.recursiveWalk([node, nextNode]);

            if (polygon !== null && polygon.length < this.params.maxLength) {
              this.removePolygonAdjacencies(polygon);
              polygons.push(polygon.map(function (n) {
                return n.value.clone();
              }));
            }
          }
        } catch (e_4_1) {
          e_4 = {
            error: e_4_1
          };
        } finally {
          try {
            if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
          } finally {
            if (e_4) throw e_4.error;
          }
        }
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    this._polygons = this.filterPolygonsByWater(polygons);
  };

  PolygonFinder.prototype.filterPolygonsByWater = function (polygons) {
    var e_5, _a;

    var out = [];

    try {
      for (var polygons_2 = __values(polygons), polygons_2_1 = polygons_2.next(); !polygons_2_1.done; polygons_2_1 = polygons_2.next()) {
        var p = polygons_2_1.value;
        var averagePoint = polygon_util_1["default"].averagePoint(p);
        if (this.tensorField.onLand(averagePoint) && !this.tensorField.inParks(averagePoint)) out.push(p);
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (polygons_2_1 && !polygons_2_1.done && (_a = polygons_2["return"])) _a.call(polygons_2);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    return out;
  };

  PolygonFinder.prototype.removePolygonAdjacencies = function (polygon) {
    for (var i = 0; i < polygon.length; i++) {
      var current = polygon[i];
      var next = polygon[(i + 1) % polygon.length];
      var index = current.adj.indexOf(next);

      if (index >= 0) {
        current.adj.splice(index, 1);
      } else {
        log.error("PolygonFinder - node not in adj");
      }
    }
  };

  PolygonFinder.prototype.recursiveWalk = function (visited, count) {
    if (count === void 0) {
      count = 0;
    }

    if (count >= this.params.maxLength) return null; // TODO backtracking to find polygons with dead end roads inside them

    var nextNode = this.getRightmostNode(visited[visited.length - 2], visited[visited.length - 1]);

    if (nextNode === null) {
      return null; // Currently ignores polygons with dead end inside
    }

    var visitedIndex = visited.indexOf(nextNode);

    if (visitedIndex >= 0) {
      return visited.slice(visitedIndex);
    } else {
      visited.push(nextNode);
      return this.recursiveWalk(visited, count++);
    }
  };

  PolygonFinder.prototype.getRightmostNode = function (nodeFrom, nodeTo) {
    var e_6, _a; // We want to turn right at every junction


    if (nodeTo.adj.length === 0) return null;
    var backwardsDifferenceVector = nodeFrom.value.clone().sub(nodeTo.value);
    var transformAngle = Math.atan2(backwardsDifferenceVector.y, backwardsDifferenceVector.x);
    var rightmostNode = null;
    var smallestTheta = Math.PI * 2;

    try {
      for (var _b = __values(nodeTo.adj), _c = _b.next(); !_c.done; _c = _b.next()) {
        var nextNode = _c.value;

        if (nextNode !== nodeFrom) {
          var nextVector = nextNode.value.clone().sub(nodeTo.value);
          var nextAngle = Math.atan2(nextVector.y, nextVector.x) - transformAngle;

          if (nextAngle < 0) {
            nextAngle += Math.PI * 2;
          }

          if (nextAngle < smallestTheta) {
            smallestTheta = nextAngle;
            rightmostNode = nextNode;
          }
        }
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    return rightmostNode;
  };

  return PolygonFinder;
}();

exports["default"] = PolygonFinder;

},{"./polygon_util":20,"loglevel":7}],20:[function(require,module,exports){
"use strict";

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var PolyK = require("polyk");

var vector_1 = require("../vector");

var jsts = require("jsts");

var PolygonUtil =
/** @class */
function () {
  function PolygonUtil() {}
  /**
   * Slices rectangle by line, returning largest polygon
   */


  PolygonUtil.sliceRectangle = function (origin, worldDimensions, p1, p2) {
    var rectangle = [origin.x, origin.y, origin.x + worldDimensions.x, origin.y, origin.x + worldDimensions.x, origin.y + worldDimensions.y, origin.x, origin.y + worldDimensions.y];
    var sliced = PolyK.Slice(rectangle, p1.x, p1.y, p2.x, p2.y).map(function (p) {
      return PolygonUtil.polygonArrayToPolygon(p);
    });
    var minArea = PolygonUtil.calcPolygonArea(sliced[0]);

    if (sliced.length > 1 && PolygonUtil.calcPolygonArea(sliced[1]) < minArea) {
      return sliced[1];
    }

    return sliced[0];
  };

  PolygonUtil.calcPolygonArea = function (polygon) {
    var total = 0;

    for (var i = 0; i < polygon.length; i++) {
      var addX = polygon[i].x;
      var addY = polygon[i == polygon.length - 1 ? 0 : i + 1].y;
      var subX = polygon[i == polygon.length - 1 ? 0 : i + 1].x;
      var subY = polygon[i].y;
      total += addX * addY * 0.5;
      total -= subX * subY * 0.5;
    }

    return Math.abs(total);
  };

  PolygonUtil.subdividePolygon = function (p, minArea) {
    var e_1, _a;

    var area = PolygonUtil.calcPolygonArea(p);

    if (area < 0.5 * minArea) {
      return [];
    }

    var divided = []; // Array of polygons

    var longestSideLength = 0;
    var longestSide = [p[0], p[1]];
    var perimeter = 0;

    for (var i = 0; i < p.length; i++) {
      var sideLength = p[i].clone().sub(p[(i + 1) % p.length]).length();
      perimeter += sideLength;

      if (sideLength > longestSideLength) {
        longestSideLength = sideLength;
        longestSide = [p[i], p[(i + 1) % p.length]];
      }
    } // Shape index
    // Using rectangle ratio of 1:4 as limit
    // if (area / perimeter * perimeter < 0.04) {


    if (area / (perimeter * perimeter) < 0.04) {
      return [];
    }

    if (area < 2 * minArea) {
      return [p];
    } // Between 0.4 and 0.6


    var deviation = Math.random() * 0.2 + 0.4;
    var averagePoint = longestSide[0].clone().add(longestSide[1]).multiplyScalar(deviation);
    var differenceVector = longestSide[0].clone().sub(longestSide[1]);
    var perpVector = new vector_1["default"](differenceVector.y, -1 * differenceVector.x).normalize().multiplyScalar(100);
    var bisect = [averagePoint.clone().add(perpVector), averagePoint.clone().sub(perpVector)]; // Array of polygons

    try {
      var sliced = PolyK.Slice(PolygonUtil.polygonToPolygonArray(p), bisect[0].x, bisect[0].y, bisect[1].x, bisect[1].y);

      try {
        // Recursive call
        for (var sliced_1 = __values(sliced), sliced_1_1 = sliced_1.next(); !sliced_1_1.done; sliced_1_1 = sliced_1.next()) {
          var s = sliced_1_1.value;
          divided.push.apply(divided, __spread(PolygonUtil.subdividePolygon(PolygonUtil.polygonArrayToPolygon(s), minArea)));
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (sliced_1_1 && !sliced_1_1.done && (_a = sliced_1["return"])) _a.call(sliced_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      return divided;
    } catch (error) {
      log.error(error);
      return [];
    }
  };

  PolygonUtil.resizeGeometry = function (geometry, spacing, isPolygon) {
    if (isPolygon === void 0) {
      isPolygon = true;
    }

    try {
      var jstsGeometry = isPolygon ? PolygonUtil.polygonToJts(geometry) : PolygonUtil.lineToJts(geometry);
      var resized = jstsGeometry.buffer(spacing, undefined, undefined);

      if (!resized.isSimple()) {
        return [];
      }

      return resized.getCoordinates().map(function (c) {
        return new vector_1["default"](c.x, c.y);
      });
    } catch (error) {
      log.error(error);
      return [];
    }
  };

  PolygonUtil.averagePoint = function (polygon) {
    var e_2, _a;

    if (polygon.length === 0) return vector_1["default"].zeroVector();
    var sum = vector_1["default"].zeroVector();

    try {
      for (var polygon_1 = __values(polygon), polygon_1_1 = polygon_1.next(); !polygon_1_1.done; polygon_1_1 = polygon_1.next()) {
        var v = polygon_1_1.value;
        sum.add(v);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (polygon_1_1 && !polygon_1_1.done && (_a = polygon_1["return"])) _a.call(polygon_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    return sum.divideScalar(polygon.length);
  };

  PolygonUtil.insidePolygon = function (point, polygon) {
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    if (polygon.length === 0) {
      return false;
    }

    var inside = false;

    for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      var xi = polygon[i].x,
          yi = polygon[i].y;
      var xj = polygon[j].x,
          yj = polygon[j].y;
      var intersect = yi > point.y != yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }

    return inside;
  };

  PolygonUtil.pointInRectangle = function (point, origin, dimensions) {
    return point.x >= origin.x && point.y >= origin.y && point.x <= dimensions.x && point.y <= dimensions.y;
  };

  PolygonUtil.lineToJts = function (line) {
    var coords = line.map(function (v) {
      return new jsts.geom.Coordinate(v.x, v.y);
    });
    return PolygonUtil.geometryFactory.createLineString(coords);
  };

  PolygonUtil.polygonToJts = function (polygon) {
    var geoInput = polygon.map(function (v) {
      return new jsts.geom.Coordinate(v.x, v.y);
    });
    geoInput.push(geoInput[0]); // Create loop

    return PolygonUtil.geometryFactory.createPolygon(PolygonUtil.geometryFactory.createLinearRing(geoInput), []);
  };
  /**
   * [ v.x, v.y, v.x, v.y ]...
   */


  PolygonUtil.polygonToPolygonArray = function (p) {
    var e_3, _a;

    var outP = [];

    try {
      for (var p_1 = __values(p), p_1_1 = p_1.next(); !p_1_1.done; p_1_1 = p_1.next()) {
        var v = p_1_1.value;
        outP.push(v.x);
        outP.push(v.y);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (p_1_1 && !p_1_1.done && (_a = p_1["return"])) _a.call(p_1);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    return outP;
  };
  /**
   * [ v.x, v.y, v.x, v.y ]...
   */


  PolygonUtil.polygonArrayToPolygon = function (p) {
    var outP = [];

    for (var i = 0; i < p.length / 2; i++) {
      outP.push(new vector_1["default"](p[2 * i], p[2 * i + 1]));
    }

    return outP;
  };

  PolygonUtil.geometryFactory = new jsts.geom.GeometryFactory();
  return PolygonUtil;
}();

exports["default"] = PolygonUtil;

},{"../vector":35,"jsts":6,"loglevel":7,"polyk":8}],21:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var simplify = require("simplify-js");

var vector_1 = require("../vector");

var grid_storage_1 = require("./grid_storage");

var StreamlineGenerator =
/** @class */
function () {
  /**
   * Uses world-space coordinates
   */
  function StreamlineGenerator(integrator, origin, worldDimensions, params) {
    this.integrator = integrator;
    this.origin = origin;
    this.worldDimensions = worldDimensions;
    this.params = params;
    this.SEED_AT_ENDPOINTS = false;
    this.NEAR_EDGE = 3; // Sample near edge

    this.candidateSeedsMajor = [];
    this.candidateSeedsMinor = [];
    this.streamlinesDone = true;
    this.lastStreamlineMajor = true;
    this.allStreamlines = [];
    this.streamlinesMajor = [];
    this.streamlinesMinor = [];
    this.allStreamlinesSimple = []; // Reduced vertex count

    if (params.dstep > params.dsep) {
      log.error("STREAMLINE SAMPLE DISTANCE BIGGER THAN DSEP");
    } // Enforce test < sep


    params.dtest = Math.min(params.dtest, params.dsep); // Needs to be less than circlejoin

    this.dcollideselfSq = Math.pow(params.dcirclejoin / 2, 2);
    this.nStreamlineStep = Math.floor(params.dcirclejoin / params.dstep);
    this.nStreamlineLookBack = 2 * this.nStreamlineStep;
    this.majorGrid = new grid_storage_1["default"](this.worldDimensions, this.origin, params.dsep);
    this.minorGrid = new grid_storage_1["default"](this.worldDimensions, this.origin, params.dsep);
    this.setParamsSq();
  }

  StreamlineGenerator.prototype.clearStreamlines = function () {
    this.allStreamlinesSimple = [];
    this.streamlinesMajor = [];
    this.streamlinesMinor = [];
    this.allStreamlines = [];
  };
  /**
   * Edits streamlines
   */


  StreamlineGenerator.prototype.joinDanglingStreamlines = function () {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;

    try {
      // TODO do in update method
      for (var _f = __values([true, false]), _g = _f.next(); !_g.done; _g = _f.next()) {
        var major = _g.value;

        try {
          for (var _h = (e_2 = void 0, __values(this.streamlines(major))), _j = _h.next(); !_j.done; _j = _h.next()) {
            var streamline = _j.value; // Ignore circles

            if (streamline[0].equals(streamline[streamline.length - 1])) {
              continue;
            }

            var newStart = this.getBestNextPoint(streamline[0], streamline[4], streamline);

            if (newStart !== null) {
              try {
                for (var _k = (e_3 = void 0, __values(this.pointsBetween(streamline[0], newStart, this.params.dstep))), _l = _k.next(); !_l.done; _l = _k.next()) {
                  var p = _l.value;
                  streamline.unshift(p);
                  this.grid(major).addSample(p);
                }
              } catch (e_3_1) {
                e_3 = {
                  error: e_3_1
                };
              } finally {
                try {
                  if (_l && !_l.done && (_c = _k["return"])) _c.call(_k);
                } finally {
                  if (e_3) throw e_3.error;
                }
              }
            }

            var newEnd = this.getBestNextPoint(streamline[streamline.length - 1], streamline[streamline.length - 4], streamline);

            if (newEnd !== null) {
              try {
                for (var _m = (e_4 = void 0, __values(this.pointsBetween(streamline[streamline.length - 1], newEnd, this.params.dstep))), _o = _m.next(); !_o.done; _o = _m.next()) {
                  var p = _o.value;
                  streamline.push(p);
                  this.grid(major).addSample(p);
                }
              } catch (e_4_1) {
                e_4 = {
                  error: e_4_1
                };
              } finally {
                try {
                  if (_o && !_o.done && (_d = _m["return"])) _d.call(_m);
                } finally {
                  if (e_4) throw e_4.error;
                }
              }
            }
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_j && !_j.done && (_b = _h["return"])) _b.call(_h);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_g && !_g.done && (_a = _f["return"])) _a.call(_f);
      } finally {
        if (e_1) throw e_1.error;
      }
    } // Reset simplified streamlines


    this.allStreamlinesSimple = [];

    try {
      for (var _p = __values(this.allStreamlines), _q = _p.next(); !_q.done; _q = _p.next()) {
        var s = _q.value;
        this.allStreamlinesSimple.push(this.simplifyStreamline(s));
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (_q && !_q.done && (_e = _p["return"])) _e.call(_p);
      } finally {
        if (e_5) throw e_5.error;
      }
    }
  };
  /**
   * Returns array of points from v1 to v2 such that they are separated by at most dsep
   * not including v1
   */


  StreamlineGenerator.prototype.pointsBetween = function (v1, v2, dstep) {
    var d = v1.distanceTo(v2);
    var nPoints = Math.floor(d / dstep);
    if (nPoints === 0) return [];
    var stepVector = v2.clone().sub(v1);
    var out = [];
    var i = 1;
    var next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));

    for (i = 1; i <= nPoints; i++) {
      if (this.integrator.integrate(next, true).lengthSq() > 0.001) {
        // Test for degenerate point
        out.push(next);
      } else {
        return out;
      }

      next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));
    }

    return out;
  };
  /**
   * Gets next best point to join streamline
   * returns null if there are no good candidates
   */


  StreamlineGenerator.prototype.getBestNextPoint = function (point, previousPoint, streamline) {
    var e_6, _a;

    var nearbyPoints = this.majorGrid.getNearbyPoints(point, this.params.dlookahead);
    nearbyPoints.push.apply(nearbyPoints, __spread(this.minorGrid.getNearbyPoints(point, this.params.dlookahead)));
    var direction = point.clone().sub(previousPoint);
    var closestSample = null;
    var closestDistance = Infinity;

    try {
      for (var nearbyPoints_1 = __values(nearbyPoints), nearbyPoints_1_1 = nearbyPoints_1.next(); !nearbyPoints_1_1.done; nearbyPoints_1_1 = nearbyPoints_1.next()) {
        var sample = nearbyPoints_1_1.value;

        if (!sample.equals(point) && !sample.equals(previousPoint)) {
          // && !streamline.includes(sample)) {
          var differenceVector = sample.clone().sub(point);

          if (differenceVector.dot(direction) < 0) {
            // Backwards
            continue;
          } // Acute angle between vectors (agnostic of CW, ACW)


          var distanceToSample = point.distanceToSquared(sample);

          if (distanceToSample < 2 * this.paramsSq.dstep) {
            closestSample = sample;
            break;
          }

          var angleBetween = Math.abs(vector_1["default"].angleBetween(direction, differenceVector)); // Filter by angle

          if (angleBetween < this.params.joinangle && distanceToSample < closestDistance) {
            closestDistance = distanceToSample;
            closestSample = sample;
          }
        }
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (nearbyPoints_1_1 && !nearbyPoints_1_1.done && (_a = nearbyPoints_1["return"])) _a.call(nearbyPoints_1);
      } finally {
        if (e_6) throw e_6.error;
      }
    } // TODO is reimplement simplify-js to preserve intersection points
    //  - this is the primary reason polygons aren't found
    // If trying to find intersections in the simplified graph
    // prevent ends getting pulled away from simplified lines


    if (closestSample !== null) {
      closestSample = closestSample.clone().add(direction.setLength(this.params.simplifyTolerance * 4));
    }

    return closestSample;
  };
  /**
   * Assumes s has already generated
   */


  StreamlineGenerator.prototype.addExistingStreamlines = function (s) {
    this.majorGrid.addAll(s.majorGrid);
    this.minorGrid.addAll(s.minorGrid);
  };

  StreamlineGenerator.prototype.setGrid = function (s) {
    this.majorGrid = s.majorGrid;
    this.minorGrid = s.minorGrid;
  };
  /**
   * returns true if state updates
   */


  StreamlineGenerator.prototype.update = function () {
    if (!this.streamlinesDone) {
      this.lastStreamlineMajor = !this.lastStreamlineMajor;

      if (!this.createStreamline(this.lastStreamlineMajor)) {
        this.streamlinesDone = true;
        this.resolve();
      }

      return true;
    }

    return false;
  };
  /**
   * All at once - will freeze if dsep small
   */


  StreamlineGenerator.prototype.createAllStreamlines = function (animate) {
    if (animate === void 0) {
      animate = false;
    }

    return __awaiter(this, void 0, void 0, function () {
      var _this = this;

      return __generator(this, function (_a) {
        return [2
        /*return*/
        , new Promise(function (resolve) {
          _this.resolve = resolve;
          _this.streamlinesDone = false;

          if (!animate) {
            var major = true;

            while (_this.createStreamline(major)) {
              major = !major;
            }
          }
        }).then(function () {
          return _this.joinDanglingStreamlines();
        })];
      });
    });
  };

  StreamlineGenerator.prototype.simplifyStreamline = function (streamline) {
    var e_7, _a;

    var simplified = [];

    try {
      for (var _b = __values(simplify(streamline, this.params.simplifyTolerance)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var point = _c.value;
        simplified.push(new vector_1["default"](point.x, point.y));
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    return simplified;
  };
  /**
   * Finds seed and creates a streamline from that point
   * Pushes new candidate seeds to queue
   * @return {Vector[]} returns false if seed isn't found within params.seedTries
   */


  StreamlineGenerator.prototype.createStreamline = function (major) {
    var seed = this.getSeed(major);

    if (seed === null) {
      return false;
    }

    var streamline = this.integrateStreamline(seed, major);

    if (this.validStreamline(streamline)) {
      this.grid(major).addPolyline(streamline);
      this.streamlines(major).push(streamline);
      this.allStreamlines.push(streamline);
      this.allStreamlinesSimple.push(this.simplifyStreamline(streamline)); // Add candidate seeds

      if (!streamline[0].equals(streamline[streamline.length - 1])) {
        this.candidateSeeds(!major).push(streamline[0]);
        this.candidateSeeds(!major).push(streamline[streamline.length - 1]);
      }
    }

    return true;
  };

  StreamlineGenerator.prototype.validStreamline = function (s) {
    return s.length > 5;
  };

  StreamlineGenerator.prototype.setParamsSq = function () {
    this.paramsSq = Object.assign({}, this.params);

    for (var p in this.paramsSq) {
      if (typeof this.paramsSq[p] === "number") {
        this.paramsSq[p] *= this.paramsSq[p];
      }
    }
  };

  StreamlineGenerator.prototype.samplePoint = function () {
    // TODO better seeding scheme
    return new vector_1["default"](Math.random() * this.worldDimensions.x, Math.random() * this.worldDimensions.y).add(this.origin);
  };
  /**
   * Tries this.candidateSeeds first, then samples using this.samplePoint
   */


  StreamlineGenerator.prototype.getSeed = function (major) {
    // Candidate seeds first
    if (this.SEED_AT_ENDPOINTS && this.candidateSeeds(major).length > 0) {
      while (this.candidateSeeds(major).length > 0) {
        var seed_1 = this.candidateSeeds(major).pop();

        if (this.isValidSample(major, seed_1, this.paramsSq.dsep)) {
          return seed_1;
        }
      }
    }

    var seed = this.samplePoint();
    var i = 0;

    while (!this.isValidSample(major, seed, this.paramsSq.dsep)) {
      if (i >= this.params.seedTries) {
        return null;
      }

      seed = this.samplePoint();
      i++;
    }

    return seed;
  };

  StreamlineGenerator.prototype.isValidSample = function (major, point, dSq, bothGrids) {
    if (bothGrids === void 0) {
      bothGrids = false;
    } // dSq = dSq * point.distanceToSquared(Vector.zeroVector());


    var gridValid = this.grid(major).isValidSample(point, dSq);

    if (bothGrids) {
      gridValid = gridValid && this.grid(!major).isValidSample(point, dSq);
    }

    return this.integrator.onLand(point) && gridValid;
  };

  StreamlineGenerator.prototype.candidateSeeds = function (major) {
    return major ? this.candidateSeedsMajor : this.candidateSeedsMinor;
  };

  StreamlineGenerator.prototype.streamlines = function (major) {
    return major ? this.streamlinesMajor : this.streamlinesMinor;
  };

  StreamlineGenerator.prototype.grid = function (major) {
    return major ? this.majorGrid : this.minorGrid;
  };

  StreamlineGenerator.prototype.pointInBounds = function (v) {
    return v.x >= this.origin.x && v.y >= this.origin.y && v.x < this.worldDimensions.x + this.origin.x && v.y < this.worldDimensions.y + this.origin.y;
  };
  /**
   * Didn't end up using - bit expensive, used streamlineTurned instead
   * Stops spirals from forming
   * uses 0.5 dcirclejoin so that circles are still joined up
   * testSample is candidate to pushed on end of streamlineForwards
   * returns true if streamline collides with itself
   */


  StreamlineGenerator.prototype.doesStreamlineCollideSelf = function (testSample, streamlineForwards, streamlineBackwards) {
    // Streamline long enough
    if (streamlineForwards.length > this.nStreamlineLookBack) {
      // Forwards check
      for (var i = 0; i < streamlineForwards.length - this.nStreamlineLookBack; i += this.nStreamlineStep) {
        if (testSample.distanceToSquared(streamlineForwards[i]) < this.dcollideselfSq) {
          return true;
        }
      } // Backwards check


      for (var i = 0; i < streamlineBackwards.length; i += this.nStreamlineStep) {
        if (testSample.distanceToSquared(streamlineBackwards[i]) < this.dcollideselfSq) {
          return true;
        }
      }
    }

    return false;
  };
  /**
   * Tests whether streamline has turned through greater than 180 degrees
   */


  StreamlineGenerator.prototype.streamlineTurned = function (seed, originalDir, point, direction) {
    if (originalDir.dot(direction) < 0) {
      // TODO optimise
      var perpendicularVector = new vector_1["default"](originalDir.y, -originalDir.x);
      var isLeft = point.clone().sub(seed).dot(perpendicularVector) < 0;
      var directionUp = direction.dot(perpendicularVector) > 0;
      return isLeft === directionUp;
    }

    return false;
  };
  /**
   * // TODO this doesn't work well - consider something disallowing one direction (F/B) to turn more than 180 deg
   * One step of the streamline integration process
   */


  StreamlineGenerator.prototype.streamlineIntegrationStep = function (params, major, collideBoth) {
    if (params.valid) {
      params.streamline.push(params.previousPoint);
      var nextDirection = this.integrator.integrate(params.previousPoint, major); // Stop at degenerate point

      if (nextDirection.lengthSq() < 0.01) {
        params.valid = false;
        return;
      } // Make sure we travel in the same direction


      if (nextDirection.dot(params.previousDirection) < 0) {
        nextDirection.negate();
      }

      var nextPoint = params.previousPoint.clone().add(nextDirection); // Visualise stopping points
      // if (this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
      //     params.valid = false;
      //     params.streamline.push(Vector.zeroVector());
      // }

      if (this.pointInBounds(nextPoint) && this.isValidSample(major, nextPoint, this.paramsSq.dtest, collideBoth) && !this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
        params.previousPoint = nextPoint;
        params.previousDirection = nextDirection;
      } else {
        // One more step
        params.streamline.push(nextPoint);
        params.valid = false;
      }
    }
  };
  /**
   * By simultaneously integrating in both directions we reduce the impact of circles not joining
   * up as the error matches at the join
   */


  StreamlineGenerator.prototype.integrateStreamline = function (seed, major) {
    var _a;

    var count = 0;
    var pointsEscaped = false; // True once two integration fronts have moved dlookahead away
    // Whether or not to test validity using both grid storages
    // (Collide with both major and minor)

    var collideBoth = Math.random() < this.params.collideEarly;
    var d = this.integrator.integrate(seed, major);
    var forwardParams = {
      seed: seed,
      originalDir: d,
      streamline: [seed],
      previousDirection: d,
      previousPoint: seed.clone().add(d),
      valid: true
    };
    forwardParams.valid = this.pointInBounds(forwardParams.previousPoint);
    var negD = d.clone().negate();
    var backwardParams = {
      seed: seed,
      originalDir: negD,
      streamline: [],
      previousDirection: negD,
      previousPoint: seed.clone().add(negD),
      valid: true
    };
    backwardParams.valid = this.pointInBounds(backwardParams.previousPoint);

    while (count < this.params.pathIterations && (forwardParams.valid || backwardParams.valid)) {
      this.streamlineIntegrationStep(forwardParams, major, collideBoth);
      this.streamlineIntegrationStep(backwardParams, major, collideBoth); // Join up circles

      var sqDistanceBetweenPoints = forwardParams.previousPoint.distanceToSquared(backwardParams.previousPoint);

      if (!pointsEscaped && sqDistanceBetweenPoints > this.paramsSq.dcirclejoin) {
        pointsEscaped = true;
      }

      if (pointsEscaped && sqDistanceBetweenPoints <= this.paramsSq.dcirclejoin) {
        forwardParams.streamline.push(forwardParams.previousPoint);
        forwardParams.streamline.push(backwardParams.previousPoint);
        backwardParams.streamline.push(backwardParams.previousPoint);
        break;
      }

      count++;
    }

    (_a = backwardParams.streamline.reverse()).push.apply(_a, __spread(forwardParams.streamline));

    return backwardParams.streamline;
  };

  return StreamlineGenerator;
}();

exports["default"] = StreamlineGenerator;

},{"../vector":35,"./grid_storage":17,"loglevel":7,"simplify-js":11}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_1 = require("../vector");

var Tensor =
/** @class */
function () {
  function Tensor(r, matrix) {
    this.r = r;
    this.matrix = matrix; // Matrix is 2 element list
    // [ 0, 1
    //   1, -0 ]

    this.oldTheta = false;
    this._theta = this.calculateTheta();
  }

  Object.defineProperty(Tensor.prototype, "theta", {
    get: function get() {
      if (this.oldTheta) {
        this._theta = this.calculateTheta();
        this.oldTheta = false;
      }

      return this._theta;
    },
    enumerable: true,
    configurable: true
  });

  Tensor.prototype.add = function (tensor) {
    var _this = this;

    this.matrix = this.matrix.map(function (v, i) {
      return v * _this.r + tensor.matrix[i] * tensor.r;
    });
    this.r = 2;
    this.oldTheta = true;
    return this;
  };

  Tensor.prototype.scale = function (s) {
    this.r *= s;
    this.oldTheta = true;
    return this;
  }; // Radians


  Tensor.prototype.rotate = function (theta) {
    if (theta === 0) {
      return this;
    }

    var newTheta = this.theta + theta;

    if (newTheta < Math.PI) {
      newTheta += Math.PI;
    }

    if (newTheta >= Math.PI) {
      newTheta -= Math.PI;
    }

    this.matrix[0] = Math.cos(2 * newTheta) * this.r;
    this.matrix[1] = Math.sin(2 * newTheta) * this.r;
    this._theta = newTheta;
    return this;
  };

  Tensor.prototype.getMajor = function () {
    // Degenerate case
    if (this.r === 0) {
      return vector_1["default"].zeroVector();
    }

    return new vector_1["default"](Math.cos(this.theta), Math.sin(this.theta));
  };

  Tensor.prototype.getMinor = function () {
    // Degenerate case
    if (this.r === 0) {
      return vector_1["default"].zeroVector();
    }

    var angle = this.theta + Math.PI / 2;
    return new vector_1["default"](Math.cos(angle), Math.sin(angle));
  };

  Tensor.prototype.calculateTheta = function () {
    if (this.r === 0) {
      return 0;
    }

    return Math.atan2(this.matrix[1] / this.r, this.matrix[0] / this.r) / 2;
  };

  return Tensor;
}();

exports["default"] = Tensor;

},{"../vector":35}],23:[function(require,module,exports){
"use strict";

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
}); // import * as noise from 'noisejs';

var SimplexNoise = require("simplex-noise");

var tensor_1 = require("./tensor");

var basis_field_1 = require("./basis_field");

var polygon_util_1 = require("./polygon_util");

var TensorField =
/** @class */
function () {
  function TensorField(noiseParams) {
    this.noiseParams = noiseParams;
    this.basisFields = [];
    this.parks = [];
    this.sea = [];
    this.river = [];
    this.ignoreRiver = false;
    this.noise = new SimplexNoise();
  }

  TensorField.prototype.enableGlobalNoise = function (angle, size) {
    this.noiseParams.globalNoise = true;
    this.noiseParams.noiseAngleGlobal = angle;
    this.noiseParams.noiseSizeGlobal = size;
  };

  TensorField.prototype.disableGlobalNoise = function () {
    this.noiseParams.globalNoise = false;
  };

  TensorField.prototype.addGrid = function (centre, size, decay, theta) {
    var grid = new basis_field_1.Grid(centre, size, decay, theta);
    this.addField(grid);
  };

  TensorField.prototype.addRadial = function (centre, size, decay) {
    var radial = new basis_field_1.Radial(centre, size, decay);
    this.addField(radial);
  };

  TensorField.prototype.addField = function (field) {
    this.basisFields.push(field);
  };

  TensorField.prototype.removeField = function (field) {
    var index = this.basisFields.indexOf(field);

    if (index > -1) {
      this.basisFields.splice(index, 1);
    }
  };

  TensorField.prototype.reset = function () {
    this.basisFields = [];
    this.parks = [];
    this.sea = [];
    this.river = [];
  };

  TensorField.prototype.getCentrePoints = function () {
    return this.basisFields.map(function (field) {
      return field.centre;
    });
  };

  TensorField.prototype.samplePoint = function (point) {
    if (!this.onLand(point)) {
      // Degenerate point
      return new tensor_1["default"](0, [0, 0]);
    } // Default field is a grid


    if (this.basisFields.length === 0) {
      return new tensor_1["default"](1, [0, 0]);
    }

    var tensorAcc = new tensor_1["default"](0, [0, 0]);
    this.basisFields.forEach(function (field) {
      return tensorAcc.add(field.getWeightedTensor(point));
    }); // Add rotational noise for parks - range -pi/2 to pi/2

    if (this.parks.some(function (p) {
      return polygon_util_1["default"].insidePolygon(point, p);
    })) {
      // TODO optimise insidePolygon e.g. distance
      tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizePark, this.noiseParams.noiseAnglePark));
    }

    if (this.noiseParams.globalNoise) {
      tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizeGlobal, this.noiseParams.noiseAngleGlobal));
    }

    return tensorAcc;
  };
  /**
   * Noise Angle is in degrees
   */


  TensorField.prototype.getRotationalNoise = function (point, noiseSize, noiseAngle) {
    return this.noise.noise2D(point.x / noiseSize, point.y / noiseSize) * noiseAngle * Math.PI / 180;
  };

  TensorField.prototype.onLand = function (point) {
    var inSea = polygon_util_1["default"].insidePolygon(point, this.sea);

    if (this.ignoreRiver) {
      return !inSea;
    }

    return !inSea && !polygon_util_1["default"].insidePolygon(point, this.river);
  };

  TensorField.prototype.inParks = function (point) {
    var e_1, _a;

    try {
      for (var _b = __values(this.parks), _c = _b.next(); !_c.done; _c = _b.next()) {
        var p = _c.value;
        if (polygon_util_1["default"].insidePolygon(point, p)) return true;
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    return false;
  };

  return TensorField;
}();

exports["default"] = TensorField;

},{"./basis_field":15,"./polygon_util":20,"./tensor":22,"simplex-noise":10}],24:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var streamlines_1 = require("./streamlines");

var polygon_util_1 = require("./polygon_util");

var WaterGenerator =
/** @class */
function (_super) {
  __extends(WaterGenerator, _super);

  function WaterGenerator(integrator, origin, worldDimensions, params, tensorField) {
    var _this = _super.call(this, integrator, origin, worldDimensions, params) || this;

    _this.params = params;
    _this.tensorField = tensorField;
    _this.TRIES = 100;
    _this.coastlineMajor = true;
    _this._coastline = []; // Noisy line

    _this._seaPolygon = []; // Uses screen rectangle and simplified road

    _this._riverPolygon = []; // Simplified

    _this._riverSecondaryRoad = [];
    return _this;
  }

  Object.defineProperty(WaterGenerator.prototype, "coastline", {
    get: function get() {
      return this._coastline;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGenerator.prototype, "seaPolygon", {
    get: function get() {
      return this._seaPolygon;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGenerator.prototype, "riverPolygon", {
    get: function get() {
      return this._riverPolygon;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGenerator.prototype, "riverSecondaryRoad", {
    get: function get() {
      return this._riverSecondaryRoad;
    },
    enumerable: true,
    configurable: true
  });

  WaterGenerator.prototype.createCoast = function () {
    var coastStreamline;
    var seed;
    var major;

    if (this.params.coastNoise.noiseEnabled) {
      this.tensorField.enableGlobalNoise(this.params.coastNoise.noiseAngle, this.params.coastNoise.noiseSize);
    }

    for (var i = 0; i < this.TRIES; i++) {
      major = Math.random() < 0.5;
      seed = this.getSeed(major);
      coastStreamline = this.extendStreamline(this.integrateStreamline(seed, major));

      if (this.reachesEdges(coastStreamline)) {
        break;
      }
    }

    this.tensorField.disableGlobalNoise();
    this._coastline = coastStreamline;
    this.coastlineMajor = major;
    var road = this.simplifyStreamline(coastStreamline);
    this._seaPolygon = this.getSeaPolygon(road);
    this.allStreamlinesSimple.push(road);
    this.tensorField.sea = this._seaPolygon; // Create intermediate samples

    var complex = this.complexifyStreamline(road);
    this.grid(major).addPolyline(complex);
    this.streamlines(major).push(complex);
    this.allStreamlines.push(complex);
  };

  WaterGenerator.prototype.createRiver = function () {
    var _this = this;

    var riverStreamline;
    var seed; // Need to ignore sea when integrating for edge check

    var oldSea = this.tensorField.sea;
    this.tensorField.sea = [];

    if (this.params.riverNoise.noiseEnabled) {
      this.tensorField.enableGlobalNoise(this.params.riverNoise.noiseAngle, this.params.riverNoise.noiseSize);
    }

    for (var i = 0; i < this.TRIES; i++) {
      seed = this.getSeed(!this.coastlineMajor);
      riverStreamline = this.extendStreamline(this.integrateStreamline(seed, !this.coastlineMajor));

      if (this.reachesEdges(riverStreamline)) {
        break;
      } else if (i === this.TRIES - 1) {
        log.error('Failed to find river reaching edge');
      }
    }

    this.tensorField.sea = oldSea;
    this.tensorField.disableGlobalNoise(); // Create river roads

    var expandedNoisy = this.complexifyStreamline(polygon_util_1["default"].resizeGeometry(riverStreamline, this.params.riverSize, false));
    this._riverPolygon = polygon_util_1["default"].resizeGeometry(riverStreamline, this.params.riverSize - this.params.riverBankSize, false); // Make sure riverPolygon[0] is off screen

    var firstOffScreen = expandedNoisy.findIndex(function (v) {
      return _this.vectorOffScreen(v);
    });

    for (var i = 0; i < firstOffScreen; i++) {
      expandedNoisy.push(expandedNoisy.shift());
    } // Create river roads


    var riverSplitPoly = this.getSeaPolygon(riverStreamline);
    var road1 = expandedNoisy.filter(function (v) {
      return !polygon_util_1["default"].insidePolygon(v, _this._seaPolygon) && !_this.vectorOffScreen(v) && polygon_util_1["default"].insidePolygon(v, riverSplitPoly);
    });
    var road1Simple = this.simplifyStreamline(road1);
    var road2 = expandedNoisy.filter(function (v) {
      return !polygon_util_1["default"].insidePolygon(v, _this._seaPolygon) && !_this.vectorOffScreen(v) && !polygon_util_1["default"].insidePolygon(v, riverSplitPoly);
    });
    var road2Simple = this.simplifyStreamline(road2);
    if (road1.length === 0 || road2.length === 0) return;

    if (road1[0].distanceToSquared(road2[0]) < road1[0].distanceToSquared(road2[road2.length - 1])) {
      road2Simple.reverse();
    }

    this.tensorField.river = road1Simple.concat(road2Simple); // Road 1

    this.allStreamlinesSimple.push(road1Simple);
    this._riverSecondaryRoad = road2Simple;
    this.grid(!this.coastlineMajor).addPolyline(road1);
    this.grid(!this.coastlineMajor).addPolyline(road2);
    this.streamlines(!this.coastlineMajor).push(road1);
    this.streamlines(!this.coastlineMajor).push(road2);
    this.allStreamlines.push(road1);
    this.allStreamlines.push(road2);
  };
  /**
   * Assumes simplified
   * Used for adding river roads
   */


  WaterGenerator.prototype.manuallyAddStreamline = function (s, major) {
    this.allStreamlinesSimple.push(s); // Create intermediate samples

    var complex = this.complexifyStreamline(s);
    this.grid(major).addPolyline(complex);
    this.streamlines(major).push(complex);
    this.allStreamlines.push(complex);
  };
  /**
   * Might reverse input array
   */


  WaterGenerator.prototype.getSeaPolygon = function (polyline) {
    var seaPolygon = polygon_util_1["default"].sliceRectangle(this.origin, this.worldDimensions, polyline[0], polyline[polyline.length - 1]); // Replace the longest side with coastline

    var longestIndex = 0;
    var longestLength = 0;

    for (var i = 0; i < seaPolygon.length; i++) {
      var next = (i + 1) % seaPolygon.length;
      var d = seaPolygon[i].distanceToSquared(seaPolygon[next]);

      if (d > longestLength) {
        longestLength = d;
        longestIndex = i;
      }
    }

    var insertBackwards = seaPolygon[longestIndex].distanceToSquared(polyline[0]) > seaPolygon[longestIndex].distanceToSquared(polyline[polyline.length - 1]);

    if (insertBackwards) {
      polyline.reverse();
    }

    seaPolygon.splice.apply(seaPolygon, __spread([(longestIndex + 1) % seaPolygon.length, 0], polyline));
    return seaPolygon;
  };
  /**
   * Insert samples in streamline until separated by dstep
   */


  WaterGenerator.prototype.complexifyStreamline = function (s) {
    var out = [];

    for (var i = 0; i < s.length - 1; i++) {
      out.push.apply(out, __spread(this.complexifyStreamlineRecursive(s[i], s[i + 1])));
    }

    return out;
  };

  WaterGenerator.prototype.complexifyStreamlineRecursive = function (v1, v2) {
    if (v1.distanceToSquared(v2) <= this.paramsSq.dstep) {
      return [v1, v2];
    }

    var d = v2.clone().sub(v1);
    var halfway = v1.clone().add(d.multiplyScalar(0.5));
    var complex = this.complexifyStreamlineRecursive(v1, halfway);
    complex.push.apply(complex, __spread(this.complexifyStreamlineRecursive(halfway, v2)));
    return complex;
  };
  /**
   * Mutates streamline
   */


  WaterGenerator.prototype.extendStreamline = function (streamline) {
    streamline.unshift(streamline[0].clone().add(streamline[0].clone().sub(streamline[1]).setLength(this.params.dstep * 5)));
    streamline.push(streamline[streamline.length - 1].clone().add(streamline[streamline.length - 1].clone().sub(streamline[streamline.length - 2]).setLength(this.params.dstep * 5)));
    return streamline;
  };

  WaterGenerator.prototype.reachesEdges = function (streamline) {
    return this.vectorOffScreen(streamline[0]) && this.vectorOffScreen(streamline[streamline.length - 1]);
  };

  WaterGenerator.prototype.vectorOffScreen = function (v) {
    var toOrigin = v.clone().sub(this.origin);
    return toOrigin.x <= 0 || toOrigin.y <= 0 || toOrigin.x >= this.worldDimensions.x || toOrigin.y >= this.worldDimensions.y;
  };

  return WaterGenerator;
}(streamlines_1["default"]);

exports["default"] = WaterGenerator; // createCoastStreamline(): Vector[][] {
//         let coastStreamline;
//         let riverStreamline;
//         let seed;
//         let major;
//         const extendStreamline = (streamline: Vector[]) => {
//             streamline.unshift(streamline[0].clone().add(
//                 streamline[0].clone().sub(streamline[1]).setLength(this.params.dstep * 5)));
//             streamline.push(streamline[streamline.length - 1].clone().add(
//                 streamline[streamline.length - 1].clone().sub(streamline[streamline.length - 2]).setLength(this.params.dstep * 5)));
//             return streamline;
//         }
//         const reachesEdges = (streamline: Vector[]) => {
//             return this.vectorOffScreen(streamline[0]) && this.vectorOffScreen(streamline[streamline.length - 1]);
//         }
//         for (let i = 0; i < 100; i++) {
//             // TODO
//             major = true;
//             // major = Math.random() < 0.5;
//             seed = this.getSeed(major);
//             coastStreamline = extendStreamline(this.integrateStreamline(seed, major));
//             riverStreamline = extendStreamline(this.integrateStreamline(seed, !major));
//             if (reachesEdges(coastStreamline) && reachesEdges(riverStreamline)) {
//                 break;
//             }
//         }
//         // Streamline is coastal = noisy
//         const road = this.simplifyStreamline(coastStreamline);
//         this.allStreamlinesSimple.push(road);
//         // Create intermediate samples
//         const complex = this.complexifyStreamline(road);
//         this.grid(major).addPolyline(complex);
//         this.streamlines(major).push(complex);
//         this.allStreamlines.push(complex);
//         this.tensorField.addWater(this.getSeaPolygon(road));
//         // Return unsimplified streamlines
//         return [coastStreamline, riverStreamline];
//     }

},{"./polygon_util":20,"./streamlines":21,"loglevel":7}],25:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var domain_controller_1 = require("./domain_controller");

var graph_1 = require("../impl/graph");

var polygon_finder_1 = require("../impl/polygon_finder");

var BuildingModels =
/** @class */
function () {
  function BuildingModels(lots) {
    var e_1, _a;

    this.domainController = domain_controller_1["default"].getInstance();
    this._buildingModels = [];

    try {
      for (var lots_1 = __values(lots), lots_1_1 = lots_1.next(); !lots_1_1.done; lots_1_1 = lots_1.next()) {
        var lot = lots_1_1.value;

        this._buildingModels.push({
          height: Math.random() * 20 + 20,
          lotWorld: lot,
          lotScreen: [],
          roof: [],
          sides: []
        });
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (lots_1_1 && !lots_1_1.done && (_a = lots_1["return"])) _a.call(lots_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    this._buildingModels.sort(function (a, b) {
      return a.height - b.height;
    });
  }

  Object.defineProperty(BuildingModels.prototype, "buildingModels", {
    get: function get() {
      return this._buildingModels;
    },
    enumerable: true,
    configurable: true
  });

  BuildingModels.prototype.setBuildingProjections = function () {
    var e_2, _a;

    var _this = this;

    var d = 1000 / this.domainController.zoom;
    var cameraPos = this.domainController.getCameraPosition();

    var _loop_1 = function _loop_1(b) {
      b.lotScreen = b.lotWorld.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
      b.roof = b.lotScreen.map(function (v) {
        return _this.heightVectorToScreen(v, b.height, d, cameraPos);
      });
      b.sides = this_1.getBuildingSides(b);
    };

    var this_1 = this;

    try {
      for (var _b = __values(this._buildingModels), _c = _b.next(); !_c.done; _c = _b.next()) {
        var b = _c.value;

        _loop_1(b);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
  };

  BuildingModels.prototype.heightVectorToScreen = function (v, h, d, camera) {
    var scale = d / (d - h); // 0.1

    if (this.domainController.orthographic) {
      var diff = this.domainController.cameraDirection.multiplyScalar(-h * scale);
      return v.clone().add(diff);
    } else {
      return v.clone().sub(camera).multiplyScalar(scale).add(camera);
    }
  };

  BuildingModels.prototype.getBuildingSides = function (b) {
    var polygons = [];

    for (var i = 0; i < b.lotScreen.length; i++) {
      var next = (i + 1) % b.lotScreen.length;
      polygons.push([b.lotScreen[i], b.lotScreen[next], b.roof[next], b.roof[i]]);
    }

    return polygons;
  };

  return BuildingModels;
}();

var Buildings =
/** @class */
function () {
  function Buildings(tensorField, folder, redraw, dstep, _animate) {
    var _this = this;

    this.tensorField = tensorField;
    this.redraw = redraw;
    this.dstep = dstep;
    this._animate = _animate;
    this.allStreamlines = [];
    this.domainController = domain_controller_1["default"].getInstance();

    this.preGenerateCallback = function () {};

    this.postGenerateCallback = function () {};

    this._models = new BuildingModels([]);
    this.buildingParams = {
      maxLength: 20,
      minArea: 50,
      shrinkSpacing: 4,
      chanceNoDivide: 0.05
    };
    folder.add({
      'AddBuildings': function AddBuildings() {
        return _this.generate(_this._animate);
      }
    }, 'AddBuildings');
    folder.add(this.buildingParams, 'minArea');
    folder.add(this.buildingParams, 'shrinkSpacing');
    folder.add(this.buildingParams, 'chanceNoDivide');
    this.polygonFinder = new polygon_finder_1["default"]([], this.buildingParams, this.tensorField);
  }

  Object.defineProperty(Buildings.prototype, "animate", {
    set: function set(v) {
      this._animate = v;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Buildings.prototype, "lots", {
    get: function get() {
      var _this = this;

      return this.polygonFinder.polygons.map(function (p) {
        return p.map(function (v) {
          return _this.domainController.worldToScreen(v.clone());
        });
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Buildings.prototype, "models", {
    get: function get() {
      this._models.setBuildingProjections();

      return this._models.buildingModels;
    },
    enumerable: true,
    configurable: true
  });

  Buildings.prototype.setAllStreamlines = function (s) {
    this.allStreamlines = s;
  };

  Buildings.prototype.reset = function () {
    this.polygonFinder.reset();
    this._models = new BuildingModels([]);
  };

  Buildings.prototype.update = function () {
    return this.polygonFinder.update();
  };

  Buildings.prototype.generate = function (animate) {
    return __awaiter(this, void 0, void 0, function () {
      var g;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this.preGenerateCallback();
            this._models = new BuildingModels([]);
            g = new graph_1["default"](this.allStreamlines, this.dstep, true);
            this.polygonFinder = new polygon_finder_1["default"](g.nodes, this.buildingParams, this.tensorField);
            this.polygonFinder.findPolygons();
            return [4
            /*yield*/
            , this.polygonFinder.shrink(animate)];

          case 1:
            _a.sent();

            return [4
            /*yield*/
            , this.polygonFinder.divide(animate)];

          case 2:
            _a.sent();

            this.redraw();
            this._models = new BuildingModels(this.polygonFinder.polygons);
            this.postGenerateCallback();
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  Buildings.prototype.setPreGenerateCallback = function (callback) {
    this.preGenerateCallback = callback;
  };

  Buildings.prototype.setPostGenerateCallback = function (callback) {
    this.postGenerateCallback = callback;
  };

  return Buildings;
}();

exports["default"] = Buildings;

},{"../impl/graph":16,"../impl/polygon_finder":19,"./domain_controller":27}],26:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var svg_js_1 = require("@svgdotjs/svg.js");

var util_1 = require("../util");

var CanvasWrapper =
/** @class */
function () {
  function CanvasWrapper(canvas, _scale, resizeToWindow) {
    var _this = this;

    if (_scale === void 0) {
      _scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    this.canvas = canvas;
    this._scale = _scale;
    this.needsUpdate = false;
    this.setDimensions();
    this.resizeCanvas();

    if (resizeToWindow) {
      window.addEventListener('resize', function () {
        _this.setDimensions();

        _this.resizeCanvas();
      });
    }
  }

  CanvasWrapper.prototype.appendSvgNode = function (node) {
    if (this.svgNode) {
      this.svgNode.appendChild(node);
    }
  };

  CanvasWrapper.prototype.createSVG = function (svgElement) {
    this.svgNode = svgElement;
  };

  CanvasWrapper.prototype.setDimensions = function () {
    this._width = window.innerWidth * this._scale;
    this._height = window.innerHeight * this._scale;
  };

  Object.defineProperty(CanvasWrapper.prototype, "width", {
    get: function get() {
      return this._width;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(CanvasWrapper.prototype, "height", {
    get: function get() {
      return this._height;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(CanvasWrapper.prototype, "canvasScale", {
    get: function get() {
      return this._scale;
    },
    set: function set(s) {
      this._scale = s;
      this.setDimensions();
      this.resizeCanvas();
    },
    enumerable: true,
    configurable: true
  });

  CanvasWrapper.prototype.zoomVectors = function (vs) {
    var _this = this;

    if (this._scale === 1) return vs;
    return vs.map(function (v) {
      return v.clone().multiplyScalar(_this._scale);
    });
  };

  CanvasWrapper.prototype.resizeCanvas = function () {
    this.canvas.width = this._width;
    this.canvas.height = this._height;
    this.needsUpdate = true;
  };

  return CanvasWrapper;
}();

exports["default"] = CanvasWrapper;

var DefaultCanvasWrapper =
/** @class */
function (_super) {
  __extends(DefaultCanvasWrapper, _super);

  function DefaultCanvasWrapper(canvas, scale, resizeToWindow) {
    if (scale === void 0) {
      scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    var _this = _super.call(this, canvas, scale, resizeToWindow) || this;

    _this.ctx = canvas.getContext("2d");
    _this.ctx.fillStyle = 'black';

    _this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    return _this;
  }

  DefaultCanvasWrapper.prototype.createSVG = function (svgElement) {
    _super.prototype.createSVG.call(this, svgElement);

    this.svg = svg_js_1.SVG(svgElement);
  };

  DefaultCanvasWrapper.prototype.setFillStyle = function (colour) {
    this.ctx.fillStyle = colour;
  };

  DefaultCanvasWrapper.prototype.clearCanvas = function () {
    if (this.svgNode) {
      // Expanded to cover whole drawn area
      var startW = window.innerWidth * (util_1["default"].DRAW_INFLATE_AMOUNT - 1) / 2;
      var startH = window.innerHeight * (util_1["default"].DRAW_INFLATE_AMOUNT - 1) / 2;
      this.drawRectangle(-startW, -startH, window.innerWidth * util_1["default"].DRAW_INFLATE_AMOUNT, window.innerHeight * util_1["default"].DRAW_INFLATE_AMOUNT);
    } else {
      this.drawRectangle(0, 0, window.innerWidth, window.innerHeight);
    }
  };

  DefaultCanvasWrapper.prototype.drawFrame = function (left, right, up, down) {
    this.drawRectangle(0, 0, this._width / this._scale, up);
    this.drawRectangle(0, 0, left, this._height / this._scale);
    this.drawRectangle(this._width / this._scale - right, 0, right, this._height / this._scale);
    this.drawRectangle(0, this._height / this._scale - down, this._width / this._scale, down);
  };

  DefaultCanvasWrapper.prototype.drawCityName = function () {
    var fontSize = 50 * this._scale;
    this.ctx.font = "small-caps " + fontSize + "px Verdana";
    this.ctx.textAlign = "center";
    this.ctx.fillText("san francisco", this._width / 2, this._height - (80 * this._scale - fontSize));
  };

  DefaultCanvasWrapper.prototype.drawRectangle = function (x, y, width, height) {
    if (this._scale !== 1) {
      x *= this._scale;
      y *= this._scale;
      width *= this._scale;
      height *= this._scale;
    }

    this.ctx.fillRect(x, y, width, height);

    if (this.svg) {
      this.svg.rect({
        fill: this.ctx.fillStyle,
        'fill-opacity': 1,
        stroke: this.ctx.strokeStyle,
        'stroke-width': this.ctx.lineWidth,
        x: x,
        y: y,
        width: width,
        height: height
      });
    }
  };

  DefaultCanvasWrapper.prototype.drawPolygon = function (polygon) {
    if (polygon.length === 0) {
      return;
    }

    polygon = this.zoomVectors(polygon);
    this.ctx.beginPath();
    this.ctx.moveTo(polygon[0].x, polygon[0].y);

    for (var i = 1; i < polygon.length; i++) {
      this.ctx.lineTo(polygon[i].x, polygon[i].y);
    }

    this.ctx.lineTo(polygon[0].x, polygon[0].y);
    this.ctx.fill();
    this.ctx.stroke();

    if (this.svg) {
      var vectorArray = polygon.map(function (v) {
        return [v.x, v.y];
      });
      vectorArray.push(vectorArray[0]);
      this.svg.polyline(vectorArray).attr({
        fill: this.ctx.fillStyle,
        'fill-opacity': 1,
        stroke: this.ctx.strokeStyle,
        'stroke-width': this.ctx.lineWidth
      });
    }
  };

  DefaultCanvasWrapper.prototype.drawSquare = function (centre, radius) {
    this.drawRectangle(centre.x - radius, centre.y - radius, 2 * radius, 2 * radius);
  };

  DefaultCanvasWrapper.prototype.setLineWidth = function (width) {
    if (this._scale !== 1) {
      width *= this._scale;
    }

    this.ctx.lineWidth = width;
  };

  DefaultCanvasWrapper.prototype.setStrokeStyle = function (colour) {
    this.ctx.strokeStyle = colour;
  };

  DefaultCanvasWrapper.prototype.drawPolyline = function (line) {
    if (line.length < 2) {
      return;
    }

    line = this.zoomVectors(line);
    this.ctx.beginPath();
    this.ctx.moveTo(line[0].x, line[0].y);

    for (var i = 1; i < line.length; i++) {
      this.ctx.lineTo(line[i].x, line[i].y);
    }

    this.ctx.stroke();

    if (this.svg) {
      var vectorArray = line.map(function (v) {
        return [v.x, v.y];
      });
      this.svg.polyline(vectorArray).attr({
        'fill-opacity': 0,
        stroke: this.ctx.strokeStyle,
        'stroke-width': this.ctx.lineWidth
      });
    }
  };

  return DefaultCanvasWrapper;
}(CanvasWrapper);

exports.DefaultCanvasWrapper = DefaultCanvasWrapper;

var RoughCanvasWrapper =
/** @class */
function (_super) {
  __extends(RoughCanvasWrapper, _super);

  function RoughCanvasWrapper(canvas, scale, resizeToWindow) {
    if (scale === void 0) {
      scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    var _this = _super.call(this, canvas, scale, resizeToWindow) || this;

    _this.r = require('roughjs/bundled/rough.cjs');
    _this.options = {
      roughness: 1,
      bowing: 1,
      stroke: '#000000',
      strokeWidth: 1,
      fill: '#000000',
      fillStyle: 'solid'
    };
    _this.rc = _this.r.canvas(canvas);
    return _this;
  }

  RoughCanvasWrapper.prototype.createSVG = function (svgElement) {
    _super.prototype.createSVG.call(this, svgElement);

    this.rc = this.r.svg(this.svgNode);
  };

  RoughCanvasWrapper.prototype.drawFrame = function (left, right, up, down) {};

  RoughCanvasWrapper.prototype.setOptions = function (options) {
    if (options.strokeWidth) {
      options.strokeWidth *= this._scale;
    }

    Object.assign(this.options, options);
  };

  RoughCanvasWrapper.prototype.clearCanvas = function () {
    if (this.svgNode) {
      // Expanded to cover whole drawn area
      var startW = window.innerWidth * (util_1["default"].DRAW_INFLATE_AMOUNT - 1) / 2;
      var startH = window.innerHeight * (util_1["default"].DRAW_INFLATE_AMOUNT - 1) / 2;
      this.drawRectangle(-startW, -startH, window.innerWidth * util_1["default"].DRAW_INFLATE_AMOUNT, window.innerHeight * util_1["default"].DRAW_INFLATE_AMOUNT);
    } else {
      this.drawRectangle(0, 0, window.innerWidth, window.innerHeight);
    }
  };

  RoughCanvasWrapper.prototype.drawRectangle = function (x, y, width, height) {
    if (this._scale !== 1) {
      x *= this._scale;
      y *= this._scale;
      width *= this._scale;
      height *= this._scale;
    }

    this.appendSvgNode(this.rc.rectangle(x, y, width, height, this.options));
  };

  RoughCanvasWrapper.prototype.drawPolygon = function (polygon) {
    var _this = this;

    if (polygon.length === 0) {
      return;
    }

    if (this._scale !== 1) {
      polygon = polygon.map(function (v) {
        return v.clone().multiplyScalar(_this._scale);
      });
    }

    this.appendSvgNode(this.rc.polygon(polygon.map(function (v) {
      return [v.x, v.y];
    }), this.options));
  };

  RoughCanvasWrapper.prototype.drawSquare = function (centre, radius) {
    var prevStroke = this.options.stroke;
    this.options.stroke = 'none';
    this.drawRectangle(centre.x - radius, centre.y - radius, 2 * radius, 2 * radius);
    this.options.stroke = prevStroke;
  };

  RoughCanvasWrapper.prototype.drawPolyline = function (line) {
    var _this = this;

    if (line.length < 2) {
      return;
    }

    if (this._scale !== 1) {
      line = line.map(function (v) {
        return v.clone().multiplyScalar(_this._scale);
      });
    }

    this.appendSvgNode(this.rc.linearPath(line.map(function (v) {
      return [v.x, v.y];
    }), this.options));
  };

  return RoughCanvasWrapper;
}(CanvasWrapper);

exports.RoughCanvasWrapper = RoughCanvasWrapper;

},{"../util":34,"@svgdotjs/svg.js":1,"roughjs/bundled/rough.cjs":9}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_1 = require("../vector");

var util_1 = require("../util");
/**
 * Singleton
 * Controls panning and zooming
 */


var DomainController =
/** @class */
function () {
  function DomainController() {
    var _this = this;

    this.ZOOM_SPEED = 0.96;
    this.SCROLL_DELAY = 100; // Location of screen origin in world space

    this._origin = vector_1["default"].zeroVector(); // Screen-space width and height

    this._screenDimensions = vector_1["default"].zeroVector(); // Ratio of screen pixels to world pixels

    this._zoom = 1;

    this.zoomCallback = function () {};

    this.lastScrolltime = -this.SCROLL_DELAY;
    this.refreshedAfterScroll = false;
    this._cameraDirection = vector_1["default"].zeroVector();
    this._orthographic = false; // Set after pan or zoom

    this.moved = false;
    this.setScreenDimensions();
    window.addEventListener('resize', function () {
      return _this.setScreenDimensions();
    });
    window.addEventListener('wheel', function (e) {
      if (e.target.id === util_1["default"].CANVAS_ID) {
        _this.lastScrolltime = Date.now();
        _this.refreshedAfterScroll = false;
        var delta = e.deltaY; // TODO scale by value of delta

        if (delta > 0) {
          _this.zoom = _this._zoom * _this.ZOOM_SPEED;
        } else {
          _this.zoom = _this._zoom / _this.ZOOM_SPEED;
        }
      }
    });
  }

  Object.defineProperty(DomainController.prototype, "isScrolling", {
    get: function get() {
      return Date.now() - this.lastScrolltime < this.SCROLL_DELAY;
    },
    enumerable: true,
    configurable: true
  });

  DomainController.prototype.setScreenDimensions = function () {
    this.moved = true;

    this._screenDimensions.setX(window.innerWidth);

    this._screenDimensions.setY(window.innerHeight);
  };

  DomainController.getInstance = function () {
    if (!DomainController.instance) {
      DomainController.instance = new DomainController();
    }

    return DomainController.instance;
  };
  /**
   * @param {Vector} delta in world space
   */


  DomainController.prototype.pan = function (delta) {
    this.moved = true;

    this._origin.sub(delta);
  };

  Object.defineProperty(DomainController.prototype, "origin", {
    get: function get() {
      return this._origin.clone();
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DomainController.prototype, "zoom", {
    get: function get() {
      return this._zoom;
    },
    set: function set(z) {
      if (z >= 0.3 && z <= 20) {
        this.moved = true;
        var oldWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
        this._zoom = z;
        var newWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
        this.pan(newWorldSpaceMidpoint.sub(oldWorldSpaceMidpoint));
        this.zoomCallback();
      }
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DomainController.prototype, "screenDimensions", {
    get: function get() {
      return this._screenDimensions.clone();
    },
    set: function set(v) {
      this.moved = true;

      this._screenDimensions.copy(v);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DomainController.prototype, "worldDimensions", {
    /**
     * @return {Vector} world-space w/h visible on screen
     */
    get: function get() {
      return this.screenDimensions.divideScalar(this._zoom);
    },
    enumerable: true,
    configurable: true
  });

  DomainController.prototype.onScreen = function (v) {
    var screenSpace = this.worldToScreen(v.clone());
    return screenSpace.x >= 0 && screenSpace.y >= 0 && screenSpace.x <= this.screenDimensions.x && screenSpace.y <= this.screenDimensions.y;
  };

  Object.defineProperty(DomainController.prototype, "orthographic", {
    get: function get() {
      return this._orthographic;
    },
    set: function set(v) {
      this._orthographic = v;
      this.moved = true;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DomainController.prototype, "cameraDirection", {
    get: function get() {
      return this._cameraDirection.clone();
    },
    set: function set(v) {
      this._cameraDirection = v; // Screen update

      this.moved = true;
    },
    enumerable: true,
    configurable: true
  });

  DomainController.prototype.getCameraPosition = function () {
    var centre = new vector_1["default"](this._screenDimensions.x / 2, this._screenDimensions.y / 2);
    return centre.add(centre.clone().multiply(this._cameraDirection)); // this.screenDimensions.divideScalar(2);
  };

  DomainController.prototype.setZoomUpdate = function (callback) {
    this.zoomCallback = callback;
  };
  /**
   * Edits vector
   */


  DomainController.prototype.zoomToWorld = function (v) {
    return v.divideScalar(this._zoom);
  };
  /**
   * Edits vector
   */


  DomainController.prototype.zoomToScreen = function (v) {
    return v.multiplyScalar(this._zoom);
  };
  /**
   * Edits vector
   */


  DomainController.prototype.screenToWorld = function (v) {
    return this.zoomToWorld(v).add(this._origin);
  };
  /**
   * Edits vector
   */


  DomainController.prototype.worldToScreen = function (v) {
    return this.zoomToScreen(v.sub(this._origin));
  };

  return DomainController;
}();

exports["default"] = DomainController;

},{"../util":34,"../vector":35}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var interactjs_1 = require("interactjs");

var util_1 = require("../util");

var Vector_1 = require("../Vector");

var domain_controller_1 = require("./domain_controller");
/**
* Register multiple centre points
* Closest one to mouse click will be selected to drag
* Up to caller to actually move their centre point via callback
*/


var DragController =
/** @class */
function () {
  function DragController(gui) {
    this.gui = gui; // How close to drag handle pointer needs to be

    this.MIN_DRAG_DISTANCE = 50;
    this.draggables = [];
    this.currentlyDragging = null; // Tensor field

    this._isDragging = false;
    this.disabled = false;
    this.domainController = domain_controller_1["default"].getInstance();
    interactjs_1["default"]("#" + util_1["default"].CANVAS_ID).draggable({
      onstart: this.dragStart.bind(this),
      onmove: this.dragMove.bind(this),
      onend: this.dragEnd.bind(this),
      cursorChecker: this.getCursor.bind(this)
    });
  }

  DragController.prototype.setDragDisabled = function (disable) {
    this.disabled = disable;
  };

  DragController.prototype.getCursor = function (action, interactable, element, interacting) {
    if (interacting) return 'grabbing';
    return 'grab';
  };

  DragController.prototype.dragStart = function (event) {
    var _this = this;

    this._isDragging = true; // Transform screen space to world space

    var origin = this.domainController.screenToWorld(new Vector_1["default"](event.x0, event.y0));
    var closestDistance = Infinity;
    this.draggables.forEach(function (draggable) {
      var d = draggable.getCentre().distanceTo(origin);

      if (d < closestDistance) {
        closestDistance = d;
        _this.currentlyDragging = draggable;
      }
    }); // Zoom screen size to world size for consistent drag distance while zoomed in

    var scaledDragDistance = this.MIN_DRAG_DISTANCE / this.domainController.zoom;

    if (closestDistance > scaledDragDistance) {
      this.currentlyDragging = null;
    }
  };

  DragController.prototype.dragMove = function (event) {
    var delta = new Vector_1["default"](event.delta.x, event.delta.y);
    this.domainController.zoomToWorld(delta);

    if (!this.disabled && this.currentlyDragging !== null) {
      // Drag field
      this.currentlyDragging.callbackFn(delta);
    } else {
      // Move map
      this.domainController.pan(delta);
    }
  };

  DragController.prototype.dragEnd = function () {
    this._isDragging = false;
    this.domainController.pan(Vector_1["default"].zeroVector()); // Triggers canvas update

    this.currentlyDragging = null;
    util_1["default"].updateGui(this.gui);
  };

  Object.defineProperty(DragController.prototype, "isDragging", {
    get: function get() {
      return this._isDragging;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * @param {(() => Vector)} Gets centre point
   * @param {((v: Vector) => void)} Called on move with delta vector
   * @returns {(() => void)} Function to deregister callback
   */

  DragController.prototype.register = function (getCentre, onMove) {
    var _this = this;

    var draggable = {
      getCentre: getCentre,
      callbackFn: onMove
    };
    this.draggables.push(draggable);
    return function () {
      var index = _this.draggables.indexOf(draggable);

      if (index >= 0) {
        _this.draggables.splice(index, 1);
      }
    }.bind(this);
  };

  return DragController;
}();

exports["default"] = DragController;

},{"../Vector":14,"../util":34,"./domain_controller":27,"interactjs":4}],29:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var domain_controller_1 = require("./domain_controller");

var integrator_1 = require("../impl/integrator");

var graph_1 = require("../impl/graph");

var road_gui_1 = require("./road_gui");

var water_gui_1 = require("./water_gui");

var polygon_finder_1 = require("../impl/polygon_finder");

var style_1 = require("./style");

var buildings_1 = require("./buildings");

var MainGUI =
/** @class */
function () {
  function MainGUI(guiFolder, tensorField, closeTensorFolder) {
    var _this = this;

    this.guiFolder = guiFolder;
    this.tensorField = tensorField;
    this.closeTensorFolder = closeTensorFolder;
    this.numBigParks = 2;
    this.numSmallParks = 5;
    this.domainController = domain_controller_1["default"].getInstance();
    this.intersections = [];
    this.bigParks = [];
    this.smallParks = [];
    this.animate = true;
    this.animationSpeed = 30;
    this.minorParams = {
      dsep: 20,
      dtest: 15,
      dstep: 1,
      dlookahead: 40,
      dcirclejoin: 5,
      joinangle: 0.1,
      pathIterations: 1000,
      seedTries: 300,
      simplifyTolerance: 0.5,
      collideEarly: 0.7
    };
    this.redraw = true;
    guiFolder.add(this, 'generateEverything'); // guiFolder.add(this, 'simpleBenchMark');

    var animateController = guiFolder.add(this, 'animate');
    guiFolder.add(this, 'animationSpeed');
    this.coastlineParams = Object.assign({
      coastNoise: {
        noiseEnabled: true,
        noiseSize: 30,
        noiseAngle: 20
      },
      riverNoise: {
        noiseEnabled: true,
        noiseSize: 30,
        noiseAngle: 20
      },
      riverBankSize: 10,
      riverSize: 30
    }, this.minorParams);
    this.coastlineParams.pathIterations = 10000;
    this.coastlineParams.simplifyTolerance = 10;
    this.majorParams = Object.assign({}, this.minorParams);
    this.majorParams.dsep = 100;
    this.majorParams.dtest = 30;
    this.majorParams.dlookahead = 200;
    this.majorParams.collideEarly = 0;
    this.mainParams = Object.assign({}, this.minorParams);
    this.mainParams.dsep = 400;
    this.mainParams.dtest = 200;
    this.mainParams.dlookahead = 500;
    this.mainParams.collideEarly = 0;
    var integrator = new integrator_1.RK4Integrator(tensorField, this.minorParams);

    var redraw = function redraw() {
      return _this.redraw = true;
    };

    this.coastline = new water_gui_1["default"](tensorField, this.coastlineParams, integrator, this.guiFolder, closeTensorFolder, 'Water', redraw).initFolder();
    this.mainRoads = new road_gui_1["default"](this.mainParams, integrator, this.guiFolder, closeTensorFolder, 'Main', redraw).initFolder();
    this.majorRoads = new road_gui_1["default"](this.majorParams, integrator, this.guiFolder, closeTensorFolder, 'Major', redraw, this.animate).initFolder();
    this.minorRoads = new road_gui_1["default"](this.minorParams, integrator, this.guiFolder, closeTensorFolder, 'Minor', redraw, this.animate).initFolder();
    var parks = guiFolder.addFolder('Parks');
    parks.add({
      Generate: function Generate() {
        _this.buildings.reset();

        _this.addParks();

        _this.redraw = true;
      }
    }, 'Generate');
    parks.add(this, 'numBigParks');
    parks.add(this, 'numSmallParks');
    var buildingsFolder = guiFolder.addFolder('Buildings');
    this.buildings = new buildings_1["default"](tensorField, buildingsFolder, redraw, this.minorParams.dstep, this.animate);
    this.buildings.setPreGenerateCallback(function () {
      var allStreamlines = [];
      allStreamlines.push.apply(allStreamlines, __spread(_this.mainRoads.allStreamlines));
      allStreamlines.push.apply(allStreamlines, __spread(_this.majorRoads.allStreamlines));
      allStreamlines.push.apply(allStreamlines, __spread(_this.minorRoads.allStreamlines));
      allStreamlines.push.apply(allStreamlines, __spread(_this.coastline.streamlinesWithSecondaryRoad));

      _this.buildings.setAllStreamlines(allStreamlines);
    });
    animateController.onChange(function (b) {
      _this.majorRoads.animate = b;
      _this.minorRoads.animate = b;
      _this.buildings.animate = b;
    });
    this.minorRoads.setExistingStreamlines([this.coastline, this.mainRoads, this.majorRoads]);
    this.majorRoads.setExistingStreamlines([this.coastline, this.mainRoads]);
    this.mainRoads.setExistingStreamlines([this.coastline]);
    this.coastline.setPreGenerateCallback(function () {
      _this.mainRoads.clearStreamlines();

      _this.majorRoads.clearStreamlines();

      _this.minorRoads.clearStreamlines();

      _this.bigParks = [];
      _this.smallParks = [];

      _this.buildings.reset();

      tensorField.parks = [];
      tensorField.sea = [];
      tensorField.river = [];
    });
    this.mainRoads.setPreGenerateCallback(function () {
      _this.majorRoads.clearStreamlines();

      _this.minorRoads.clearStreamlines();

      _this.bigParks = [];
      _this.smallParks = [];

      _this.buildings.reset();

      tensorField.parks = [];
      tensorField.ignoreRiver = true;
    });
    this.mainRoads.setPostGenerateCallback(function () {
      tensorField.ignoreRiver = false;
    });
    this.majorRoads.setPreGenerateCallback(function () {
      _this.minorRoads.clearStreamlines();

      _this.bigParks = [];
      _this.smallParks = [];

      _this.buildings.reset();

      tensorField.parks = [];
      tensorField.ignoreRiver = true;
    });
    this.majorRoads.setPostGenerateCallback(function () {
      tensorField.ignoreRiver = false;

      _this.addParks();

      _this.redraw = true;
    });
    this.minorRoads.setPreGenerateCallback(function () {
      _this.buildings.reset();

      _this.smallParks = [];
      tensorField.parks = _this.bigParks;
    });
    this.minorRoads.setPostGenerateCallback(function () {
      _this.addParks();
    });
  }

  MainGUI.prototype.addParks = function () {
    var _a, _b, _c;

    var g = new graph_1["default"](this.majorRoads.allStreamlines.concat(this.mainRoads.allStreamlines).concat(this.minorRoads.allStreamlines), this.minorParams.dstep);
    this.intersections = g.intersections;
    var p = new polygon_finder_1["default"](g.nodes, {
      maxLength: 20,
      minArea: 80,
      shrinkSpacing: 4,
      chanceNoDivide: 1
    }, this.tensorField);
    p.findPolygons();
    var polygons = p.polygons;

    if (this.minorRoads.allStreamlines.length === 0) {
      // Big parks - add consecutive polygons
      this.bigParks = [];
      this.smallParks = [];

      if (polygons.length > this.numBigParks) {
        var parkIndex = Math.floor(Math.random() * (polygons.length - this.numBigParks));

        for (var i = parkIndex; i < parkIndex + this.numBigParks; i++) {
          this.bigParks.push(polygons[i]);
        }
      } else {
        (_a = this.bigParks).push.apply(_a, __spread(polygons));
      }
    } else {
      // Small parks
      this.smallParks = [];

      for (var i = 0; i < this.numSmallParks; i++) {
        var parkIndex = Math.floor(Math.random() * polygons.length);
        this.smallParks.push(polygons[parkIndex]);
      }
    }

    this.tensorField.parks = [];

    (_b = this.tensorField.parks).push.apply(_b, __spread(this.bigParks));

    (_c = this.tensorField.parks).push.apply(_c, __spread(this.smallParks));
  }; // async simpleBenchMark() {
  //     log.info(`Starting Benchmark...`);
  //     const tries = 10;
  //     let sum = 0;
  //     for (let i = 0; i < tries; i++) {
  //         const start = performance.now();
  //         await this.mainRoads.generateRoads();
  //         await this.majorRoads.generateRoads();
  //         await this.minorRoads.generateRoads();
  //         await this.addBuildings();
  //         sum += performance.now() - start;
  //     }
  //     log.info(`Generated ${tries} cities with average ${sum/tries}ms`);
  // }


  MainGUI.prototype.generateEverything = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this.coastline.generateRoads();
            return [4
            /*yield*/
            , this.mainRoads.generateRoads()];

          case 1:
            _a.sent();

            return [4
            /*yield*/
            , this.majorRoads.generateRoads(this.animate)];

          case 2:
            _a.sent();

            return [4
            /*yield*/
            , this.minorRoads.generateRoads(this.animate)];

          case 3:
            _a.sent();

            this.redraw = true;
            return [4
            /*yield*/
            , this.buildings.generate(this.animate)];

          case 4:
            _a.sent();

            return [2
            /*return*/
            ];
        }
      });
    });
  };

  MainGUI.prototype.update = function () {
    var continueUpdate = true;
    var start = performance.now();

    while (continueUpdate && performance.now() - start < this.animationSpeed) {
      var minorChanged = this.minorRoads.update();
      var majorChanged = this.majorRoads.update();
      var mainChanged = this.mainRoads.update();
      var buildingsChanged = this.buildings.update();
      continueUpdate = minorChanged || majorChanged || mainChanged || buildingsChanged;
    }

    this.redraw = this.redraw || continueUpdate;
  };

  MainGUI.prototype.draw = function (style, forceDraw, customCanvas) {
    var _a, _b;

    var _this = this;

    if (forceDraw === void 0) {
      forceDraw = false;
    }

    if (!style.needsUpdate && !forceDraw && !this.redraw && !this.domainController.moved) {
      return;
    }

    style.needsUpdate = false;
    this.domainController.moved = false;
    this.redraw = false;
    style.seaPolygon = this.coastline.seaPolygon;
    style.coastline = this.coastline.coastline;
    style.river = this.coastline.river;
    style.lots = this.buildings.lots;

    if (style instanceof style_1.DefaultStyle && style.showBuildingModels || style instanceof style_1.RoughStyle) {
      style.buildingModels = this.buildings.models;
    }

    style.parks = [];

    (_a = style.parks).push.apply(_a, __spread(this.bigParks.map(function (p) {
      return p.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    })));

    (_b = style.parks).push.apply(_b, __spread(this.smallParks.map(function (p) {
      return p.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    })));

    style.minorRoads = this.minorRoads.roads;
    style.majorRoads = this.majorRoads.roads;
    style.mainRoads = this.mainRoads.roads;
    style.coastlineRoads = this.coastline.roads;
    style.secondaryRiver = this.coastline.secondaryRiver;
    style.draw(customCanvas);
  };

  MainGUI.prototype.roadsEmpty = function () {
    return this.majorRoads.roadsEmpty() && this.minorRoads.roadsEmpty() && this.mainRoads.roadsEmpty() && this.coastline.roadsEmpty();
  };

  return MainGUI;
}();

exports["default"] = MainGUI;

},{"../impl/graph":16,"../impl/integrator":18,"../impl/polygon_finder":19,"./buildings":25,"./domain_controller":27,"./road_gui":30,"./style":31,"./water_gui":33}],30:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var domain_controller_1 = require("./domain_controller");

var util_1 = require("../util");

var streamlines_1 = require("../impl/streamlines");

var RoadGUI =
/** @class */
function () {
  function RoadGUI(params, integrator, guiFolder, closeTensorFolder, folderName, redraw, _animate) {
    var _this = this;

    if (_animate === void 0) {
      _animate = false;
    }

    this.params = params;
    this.integrator = integrator;
    this.guiFolder = guiFolder;
    this.closeTensorFolder = closeTensorFolder;
    this.folderName = folderName;
    this.redraw = redraw;
    this._animate = _animate;
    this.existingStreamlines = [];
    this.domainController = domain_controller_1["default"].getInstance();

    this.preGenerateCallback = function () {};

    this.postGenerateCallback = function () {};

    this.streamlinesInProgress = false;
    this.streamlines = new streamlines_1["default"](this.integrator, this.domainController.origin, this.domainController.worldDimensions, this.params); // Update path iterations based on window size

    this.setPathIterations();
    window.addEventListener('resize', function () {
      return _this.setPathIterations();
    });
  }

  RoadGUI.prototype.initFolder = function () {
    var _this = this;

    var roadGUI = {
      Generate: function Generate() {
        return _this.generateRoads(_this._animate).then(function () {
          return _this.redraw();
        });
      },
      JoinDangling: function JoinDangling() {
        _this.streamlines.joinDanglingStreamlines();

        _this.redraw();
      }
    };
    var folder = this.guiFolder.addFolder(this.folderName);
    folder.add(roadGUI, 'Generate'); // folder.add(roadGUI, 'JoinDangling');

    var paramsFolder = folder.addFolder('Params');
    paramsFolder.add(this.params, 'dsep');
    paramsFolder.add(this.params, 'dtest');
    var devParamsFolder = paramsFolder.addFolder('Dev');
    this.addDevParamsToFolder(this.params, devParamsFolder);
    return this;
  };

  Object.defineProperty(RoadGUI.prototype, "animate", {
    set: function set(b) {
      this._animate = b;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(RoadGUI.prototype, "allStreamlines", {
    get: function get() {
      return this.streamlines.allStreamlinesSimple;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(RoadGUI.prototype, "roads", {
    get: function get() {
      var _this = this; // For drawing not generation, probably fine to leave map


      return this.streamlines.allStreamlinesSimple.map(function (s) {
        return s.map(function (v) {
          return _this.domainController.worldToScreen(v.clone());
        });
      });
    },
    enumerable: true,
    configurable: true
  });

  RoadGUI.prototype.roadsEmpty = function () {
    return this.streamlines.allStreamlinesSimple.length === 0;
  };

  RoadGUI.prototype.setExistingStreamlines = function (existingStreamlines) {
    this.existingStreamlines = existingStreamlines;
  };

  RoadGUI.prototype.setPreGenerateCallback = function (callback) {
    this.preGenerateCallback = callback;
  };

  RoadGUI.prototype.setPostGenerateCallback = function (callback) {
    this.postGenerateCallback = callback;
  };

  RoadGUI.prototype.clearStreamlines = function () {
    this.streamlines.clearStreamlines();
  };

  RoadGUI.prototype.generateRoads = function (animate) {
    if (animate === void 0) {
      animate = false;
    }

    return __awaiter(this, void 0, void 0, function () {
      var _a, _b, s;

      var e_1, _c;

      var _this = this;

      return __generator(this, function (_d) {
        this.preGenerateCallback();
        this.domainController.zoom = this.domainController.zoom / util_1["default"].DRAW_INFLATE_AMOUNT;
        this.streamlines = new streamlines_1["default"](this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params));
        this.domainController.zoom = this.domainController.zoom * util_1["default"].DRAW_INFLATE_AMOUNT;

        try {
          for (_a = __values(this.existingStreamlines), _b = _a.next(); !_b.done; _b = _a.next()) {
            s = _b.value;
            this.streamlines.addExistingStreamlines(s.streamlines);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
          } finally {
            if (e_1) throw e_1.error;
          }
        }

        this.closeTensorFolder();
        this.redraw();
        return [2
        /*return*/
        , this.streamlines.createAllStreamlines(animate).then(function () {
          return _this.postGenerateCallback();
        })];
      });
    });
  };
  /**
   * Returns true if streamlines changes
   */


  RoadGUI.prototype.update = function () {
    return this.streamlines.update();
  };

  RoadGUI.prototype.addDevParamsToFolder = function (params, folder) {
    folder.add(params, 'pathIterations');
    folder.add(params, 'seedTries');
    folder.add(params, 'dstep');
    folder.add(params, 'dlookahead');
    folder.add(params, 'dcirclejoin');
    folder.add(params, 'joinangle');
    folder.add(params, 'simplifyTolerance');
    folder.add(params, 'collideEarly');
  };
  /**
   * Sets path iterations so that a road can cover the screen
   */


  RoadGUI.prototype.setPathIterations = function () {
    var max = 1.5 * Math.max(window.innerWidth, window.innerHeight);
    this.params.pathIterations = max / this.params.dstep;
    util_1["default"].updateGui(this.guiFolder);
  };

  return RoadGUI;
}();

exports["default"] = RoadGUI;

},{"../impl/streamlines":21,"../util":34,"./domain_controller":27}],31:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var canvas_wrapper_1 = require("./canvas_wrapper");

var util_1 = require("../util");

var domain_controller_1 = require("./domain_controller");

var Style =
/** @class */
function () {
  function Style(dragController, colourScheme) {
    this.dragController = dragController;
    this.colourScheme = colourScheme;
    this.domainController = domain_controller_1["default"].getInstance(); // Polygons

    this.seaPolygon = [];
    this.lots = [];
    this.buildingModels = [];
    this.parks = []; // Polylines

    this.coastline = [];
    this.river = [];
    this.secondaryRiver = [];
    this.minorRoads = [];
    this.majorRoads = [];
    this.mainRoads = [];
    this.coastlineRoads = [];
    if (!colourScheme.bgColour) log.error("ColourScheme Error - bgColour not defined");
    if (!colourScheme.seaColour) log.error("ColourScheme Error - seaColour not defined");
    if (!colourScheme.minorRoadColour) log.error("ColourScheme Error - minorRoadColour not defined"); // Default colourscheme cascade

    if (!colourScheme.bgColourIn) colourScheme.bgColourIn = colourScheme.bgColour;
    if (!colourScheme.buildingColour) colourScheme.buildingColour = colourScheme.bgColour;
    if (!colourScheme.buildingStroke) colourScheme.buildingStroke = colourScheme.bgColour;
    if (!colourScheme.grassColour) colourScheme.grassColour = colourScheme.bgColour;
    if (!colourScheme.minorRoadOutline) colourScheme.minorRoadOutline = colourScheme.minorRoadColour;
    if (!colourScheme.majorRoadColour) colourScheme.majorRoadColour = colourScheme.minorRoadColour;
    if (!colourScheme.majorRoadOutline) colourScheme.majorRoadOutline = colourScheme.minorRoadOutline;
    if (!colourScheme.mainRoadColour) colourScheme.mainRoadColour = colourScheme.majorRoadColour;
    if (!colourScheme.mainRoadOutline) colourScheme.mainRoadOutline = colourScheme.majorRoadOutline;
    if (!colourScheme.outlineSize) colourScheme.outlineSize = 1;
    if (!colourScheme.zoomBuildings) colourScheme.zoomBuildings = false;
    if (!colourScheme.buildingModels) colourScheme.buildingModels = false;
    if (!colourScheme.minorWidth) colourScheme.minorWidth = 2;
    if (!colourScheme.majorWidth) colourScheme.majorWidth = 4;
    if (!colourScheme.mainWidth) colourScheme.mainWidth = 5;
    if (!colourScheme.mainWidth) colourScheme.mainWidth = 5;
    if (!colourScheme.frameColour) colourScheme.frameColour = colourScheme.bgColour;
    if (!colourScheme.frameTextColour) colourScheme.frameTextColour = colourScheme.minorRoadOutline;

    if (!colourScheme.buildingSideColour) {
      var parsedRgb = util_1["default"].parseCSSColor(colourScheme.buildingColour).map(function (v) {
        return Math.max(0, v - 40);
      });

      if (parsedRgb) {
        colourScheme.buildingSideColour = "rgb(" + parsedRgb[0] + "," + parsedRgb[1] + "," + parsedRgb[2] + ")";
      } else {
        colourScheme.buildingSideColour = colourScheme.buildingColour;
      }
    }
  }

  Style.prototype.update = function () {};

  Object.defineProperty(Style.prototype, "zoomBuildings", {
    set: function set(b) {
      this.colourScheme.zoomBuildings = b;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Style.prototype, "showBuildingModels", {
    get: function get() {
      return this.colourScheme.buildingModels;
    },
    set: function set(b) {
      this.colourScheme.buildingModels = b;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Style.prototype, "canvasScale", {
    set: function set(scale) {
      this.canvas.canvasScale = scale;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Style.prototype, "needsUpdate", {
    get: function get() {
      return this.canvas.needsUpdate;
    },
    set: function set(n) {
      this.canvas.needsUpdate = n;
    },
    enumerable: true,
    configurable: true
  });
  return Style;
}();

exports["default"] = Style;

var DefaultStyle =
/** @class */
function (_super) {
  __extends(DefaultStyle, _super);

  function DefaultStyle(c, dragController, colourScheme) {
    var _this = _super.call(this, dragController, colourScheme) || this;

    _this.canvas = _this.createCanvasWrapper(c, 1, true);
    return _this;
  }

  DefaultStyle.prototype.createCanvasWrapper = function (c, scale, resizeToWindow) {
    if (scale === void 0) {
      scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    return new canvas_wrapper_1.DefaultCanvasWrapper(c, scale, resizeToWindow);
  };

  DefaultStyle.prototype.draw = function (canvas) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e, e_6, _f, e_7, _g, e_8, _h, e_9, _j, e_10, _k, e_11, _l, e_12, _m, e_13, _o;

    if (canvas === void 0) {
      canvas = this.canvas;
    }

    var bgColour;

    if (this.colourScheme.zoomBuildings) {
      bgColour = this.domainController.zoom >= 2 ? this.colourScheme.bgColourIn : this.colourScheme.bgColour;
    } else {
      bgColour = this.colourScheme.bgColour;
    }

    canvas.setFillStyle(bgColour);
    canvas.clearCanvas(); // Sea

    canvas.setFillStyle(this.colourScheme.seaColour);
    canvas.setStrokeStyle(this.colourScheme.seaColour);
    canvas.setLineWidth(0.1);
    canvas.drawPolygon(this.seaPolygon); // Coastline

    canvas.setStrokeStyle(bgColour);
    canvas.setLineWidth(30 * this.domainController.zoom);
    canvas.drawPolyline(this.coastline); // Parks

    canvas.setLineWidth(1);
    canvas.setFillStyle(this.colourScheme.grassColour);

    try {
      for (var _p = __values(this.parks), _q = _p.next(); !_q.done; _q = _p.next()) {
        var p = _q.value;
        canvas.drawPolygon(p);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_q && !_q.done && (_a = _p["return"])) _a.call(_p);
      } finally {
        if (e_1) throw e_1.error;
      }
    } // River


    canvas.setFillStyle(this.colourScheme.seaColour);
    canvas.setStrokeStyle(this.colourScheme.seaColour);
    canvas.setLineWidth(0.1);
    canvas.drawPolygon(this.river); // Road outline

    canvas.setStrokeStyle(this.colourScheme.minorRoadOutline);
    canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.minorWidth * this.domainController.zoom);

    try {
      for (var _r = __values(this.minorRoads), _s = _r.next(); !_s.done; _s = _r.next()) {
        var s = _s.value;
        canvas.drawPolyline(s);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_s && !_s.done && (_b = _r["return"])) _b.call(_r);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    canvas.setStrokeStyle(this.colourScheme.majorRoadOutline);
    canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.majorWidth * this.domainController.zoom);

    try {
      for (var _t = __values(this.majorRoads), _u = _t.next(); !_u.done; _u = _t.next()) {
        var s = _u.value;
        canvas.drawPolyline(s);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_u && !_u.done && (_c = _t["return"])) _c.call(_t);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    canvas.drawPolyline(this.secondaryRiver);
    canvas.setStrokeStyle(this.colourScheme.mainRoadOutline);
    canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.mainWidth * this.domainController.zoom);

    try {
      for (var _v = __values(this.mainRoads), _w = _v.next(); !_w.done; _w = _v.next()) {
        var s = _w.value;
        canvas.drawPolyline(s);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_w && !_w.done && (_d = _v["return"])) _d.call(_v);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    try {
      for (var _x = __values(this.coastlineRoads), _y = _x.next(); !_y.done; _y = _x.next()) {
        var s = _y.value;
        canvas.drawPolyline(s);
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (_y && !_y.done && (_e = _x["return"])) _e.call(_x);
      } finally {
        if (e_5) throw e_5.error;
      }
    } // Road inline


    canvas.setStrokeStyle(this.colourScheme.minorRoadColour);
    canvas.setLineWidth(this.colourScheme.minorWidth * this.domainController.zoom);

    try {
      for (var _z = __values(this.minorRoads), _0 = _z.next(); !_0.done; _0 = _z.next()) {
        var s = _0.value;
        canvas.drawPolyline(s);
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_0 && !_0.done && (_f = _z["return"])) _f.call(_z);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    canvas.setStrokeStyle(this.colourScheme.majorRoadColour);
    canvas.setLineWidth(this.colourScheme.majorWidth * this.domainController.zoom);

    try {
      for (var _1 = __values(this.majorRoads), _2 = _1.next(); !_2.done; _2 = _1.next()) {
        var s = _2.value;
        canvas.drawPolyline(s);
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_2 && !_2.done && (_g = _1["return"])) _g.call(_1);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    canvas.drawPolyline(this.secondaryRiver);
    canvas.setStrokeStyle(this.colourScheme.mainRoadColour);
    canvas.setLineWidth(this.colourScheme.mainWidth * this.domainController.zoom);

    try {
      for (var _3 = __values(this.mainRoads), _4 = _3.next(); !_4.done; _4 = _3.next()) {
        var s = _4.value;
        canvas.drawPolyline(s);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (_4 && !_4.done && (_h = _3["return"])) _h.call(_3);
      } finally {
        if (e_8) throw e_8.error;
      }
    }

    try {
      for (var _5 = __values(this.coastlineRoads), _6 = _5.next(); !_6.done; _6 = _5.next()) {
        var s = _6.value;
        canvas.drawPolyline(s);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (_6 && !_6.done && (_j = _5["return"])) _j.call(_5);
      } finally {
        if (e_9) throw e_9.error;
      }
    }

    canvas.setLineWidth(1); // Buildings

    if (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2) {
      canvas.setFillStyle(this.colourScheme.buildingColour);
      canvas.setStrokeStyle(this.colourScheme.buildingStroke);

      try {
        for (var _7 = __values(this.lots), _8 = _7.next(); !_8.done; _8 = _7.next()) {
          var b = _8.value;
          canvas.drawPolygon(b);
        }
      } catch (e_10_1) {
        e_10 = {
          error: e_10_1
        };
      } finally {
        try {
          if (_8 && !_8.done && (_k = _7["return"])) _k.call(_7);
        } finally {
          if (e_10) throw e_10.error;
        }
      }
    } // Pseudo-3D


    if (this.colourScheme.buildingModels && (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2.5)) {
      canvas.setFillStyle(this.colourScheme.buildingSideColour);
      canvas.setStrokeStyle(this.colourScheme.buildingSideColour);

      try {
        for (var _9 = __values(this.buildingModels), _10 = _9.next(); !_10.done; _10 = _9.next()) {
          var b = _10.value;

          try {
            for (var _11 = (e_12 = void 0, __values(b.sides)), _12 = _11.next(); !_12.done; _12 = _11.next()) {
              var s = _12.value;
              canvas.drawPolygon(s);
            }
          } catch (e_12_1) {
            e_12 = {
              error: e_12_1
            };
          } finally {
            try {
              if (_12 && !_12.done && (_m = _11["return"])) _m.call(_11);
            } finally {
              if (e_12) throw e_12.error;
            }
          }
        }
      } catch (e_11_1) {
        e_11 = {
          error: e_11_1
        };
      } finally {
        try {
          if (_10 && !_10.done && (_l = _9["return"])) _l.call(_9);
        } finally {
          if (e_11) throw e_11.error;
        }
      }

      canvas.setFillStyle(this.colourScheme.buildingColour);
      canvas.setStrokeStyle(this.colourScheme.buildingStroke);

      try {
        for (var _13 = __values(this.buildingModels), _14 = _13.next(); !_14.done; _14 = _13.next()) {
          var b = _14.value;
          canvas.drawPolygon(b.roof);
        }
      } catch (e_13_1) {
        e_13 = {
          error: e_13_1
        };
      } finally {
        try {
          if (_14 && !_14.done && (_o = _13["return"])) _o.call(_13);
        } finally {
          if (e_13) throw e_13.error;
        }
      }
    }

    if (this.showFrame) {
      canvas.setFillStyle(this.colourScheme.frameColour);
      canvas.setStrokeStyle(this.colourScheme.frameColour);
      canvas.drawFrame(30, 30, 30, 30); // canvas.setFillStyle(this.colourScheme.frameTextColour);
      // canvas.drawCityName();
    }
  };

  return DefaultStyle;
}(Style);

exports.DefaultStyle = DefaultStyle;

var RoughStyle =
/** @class */
function (_super) {
  __extends(RoughStyle, _super);

  function RoughStyle(c, dragController, colourScheme) {
    var _this = _super.call(this, dragController, colourScheme) || this;

    _this.dragging = false;
    _this.canvas = _this.createCanvasWrapper(c, 1, true);
    return _this;
  }

  RoughStyle.prototype.createCanvasWrapper = function (c, scale, resizeToWindow) {
    if (scale === void 0) {
      scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    return new canvas_wrapper_1.RoughCanvasWrapper(c, scale, resizeToWindow);
  };

  RoughStyle.prototype.update = function () {
    var dragging = this.dragController.isDragging || this.domainController.isScrolling;
    if (!dragging && this.dragging) this.canvas.needsUpdate = true;
    this.dragging = dragging;
  };

  RoughStyle.prototype.draw = function (canvas) {
    var e_14, _a, e_15, _b, e_16, _c, e_17, _d, e_18, _e;

    if (canvas === void 0) {
      canvas = this.canvas;
    }

    canvas.setOptions({
      fill: this.colourScheme.bgColour,
      roughness: 1,
      bowing: 1,
      fillStyle: 'solid',
      stroke: "none"
    });
    canvas.clearCanvas(); // Sea

    canvas.setOptions({
      roughness: 0,
      fillWeight: 1,
      fill: this.colourScheme.seaColour,
      fillStyle: 'solid',
      stroke: "none",
      strokeWidth: 1
    });
    canvas.drawPolygon(this.seaPolygon);
    canvas.setOptions({
      stroke: this.colourScheme.bgColour,
      strokeWidth: 30
    });
    canvas.drawPolyline(this.coastline);
    canvas.setOptions({
      roughness: 0,
      fillWeight: 1,
      fill: this.colourScheme.seaColour,
      fillStyle: 'solid',
      stroke: "none",
      strokeWidth: 1
    });
    canvas.drawPolygon(this.river); // Parks

    canvas.setOptions({
      fill: this.colourScheme.grassColour
    });
    this.parks.forEach(function (p) {
      return canvas.drawPolygon(p);
    }); // Roads

    canvas.setOptions({
      stroke: this.colourScheme.minorRoadColour,
      strokeWidth: 1,
      fill: 'none'
    });
    this.minorRoads.forEach(function (s) {
      return canvas.drawPolyline(s);
    });
    canvas.setOptions({
      strokeWidth: 2,
      stroke: this.colourScheme.majorRoadColour
    });
    this.majorRoads.forEach(function (s) {
      return canvas.drawPolyline(s);
    });
    canvas.drawPolyline(this.secondaryRiver);
    canvas.setOptions({
      strokeWidth: 3,
      stroke: this.colourScheme.mainRoadColour
    });
    this.mainRoads.forEach(function (s) {
      return canvas.drawPolyline(s);
    });
    this.coastlineRoads.forEach(function (s) {
      return canvas.drawPolyline(s);
    }); // Buildings

    if (!this.dragging) {
      // Lots
      if (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2) {
        // Lots
        canvas.setOptions({
          roughness: 1.2,
          stroke: this.colourScheme.buildingStroke,
          strokeWidth: 1,
          fill: ''
        });

        try {
          for (var _f = __values(this.lots), _g = _f.next(); !_g.done; _g = _f.next()) {
            var b = _g.value;
            canvas.drawPolygon(b);
          }
        } catch (e_14_1) {
          e_14 = {
            error: e_14_1
          };
        } finally {
          try {
            if (_g && !_g.done && (_a = _f["return"])) _a.call(_f);
          } finally {
            if (e_14) throw e_14.error;
          }
        }
      } // Pseudo-3D


      if (this.colourScheme.buildingModels && (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2.5)) {
        // Pseudo-3D
        canvas.setOptions({
          roughness: 1.2,
          stroke: this.colourScheme.buildingStroke,
          strokeWidth: 1,
          fill: this.colourScheme.buildingSideColour
        }); // TODO this can be hugely improved

        var allSidesDistances = [];
        var camera = this.domainController.getCameraPosition();

        try {
          for (var _h = __values(this.buildingModels), _j = _h.next(); !_j.done; _j = _h.next()) {
            var b = _j.value;

            try {
              for (var _k = (e_16 = void 0, __values(b.sides)), _l = _k.next(); !_l.done; _l = _k.next()) {
                var s = _l.value;
                var averagePoint = s[0].clone().add(s[1]).divideScalar(2);
                allSidesDistances.push([averagePoint.distanceToSquared(camera), s]);
              }
            } catch (e_16_1) {
              e_16 = {
                error: e_16_1
              };
            } finally {
              try {
                if (_l && !_l.done && (_c = _k["return"])) _c.call(_k);
              } finally {
                if (e_16) throw e_16.error;
              }
            }
          }
        } catch (e_15_1) {
          e_15 = {
            error: e_15_1
          };
        } finally {
          try {
            if (_j && !_j.done && (_b = _h["return"])) _b.call(_h);
          } finally {
            if (e_15) throw e_15.error;
          }
        }

        allSidesDistances.sort(function (a, b) {
          return b[0] - a[0];
        });

        try {
          for (var allSidesDistances_1 = __values(allSidesDistances), allSidesDistances_1_1 = allSidesDistances_1.next(); !allSidesDistances_1_1.done; allSidesDistances_1_1 = allSidesDistances_1.next()) {
            var p = allSidesDistances_1_1.value;
            canvas.drawPolygon(p[1]);
          }
        } catch (e_17_1) {
          e_17 = {
            error: e_17_1
          };
        } finally {
          try {
            if (allSidesDistances_1_1 && !allSidesDistances_1_1.done && (_d = allSidesDistances_1["return"])) _d.call(allSidesDistances_1);
          } finally {
            if (e_17) throw e_17.error;
          }
        }

        canvas.setOptions({
          roughness: 1.2,
          stroke: this.colourScheme.buildingStroke,
          strokeWidth: 1,
          fill: this.colourScheme.buildingColour
        });

        try {
          for (var _m = __values(this.buildingModels), _o = _m.next(); !_o.done; _o = _m.next()) {
            var b = _o.value;
            canvas.drawPolygon(b.roof);
          }
        } catch (e_18_1) {
          e_18 = {
            error: e_18_1
          };
        } finally {
          try {
            if (_o && !_o.done && (_e = _m["return"])) _e.call(_m);
          } finally {
            if (e_18) throw e_18.error;
          }
        }
      }
    }
  };

  return RoughStyle;
}(Style);

exports.RoughStyle = RoughStyle;

},{"../util":34,"./canvas_wrapper":26,"./domain_controller":27,"loglevel":7}],32:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var domain_controller_1 = require("./domain_controller");

var tensor_field_1 = require("../impl/tensor_field");

var util_1 = require("../util");

var vector_1 = require("../vector");

var TensorFieldGUI =
/** @class */
function (_super) {
  __extends(TensorFieldGUI, _super);

  function TensorFieldGUI(guiFolder, dragController, drawCentre, noiseParams) {
    var _this = _super.call(this, noiseParams) || this;

    _this.guiFolder = guiFolder;
    _this.dragController = dragController;
    _this.drawCentre = drawCentre;
    _this.TENSOR_LINE_DIAMETER = 20;
    _this.TENSOR_SPAWN_SCALE = 0.7; // How much to shrink worldDimensions to find spawn point

    _this.domainController = domain_controller_1["default"].getInstance(); // For custom naming of gui buttons

    var tensorFieldGuiObj = {
      reset: function reset() {
        return _this.reset();
      },
      setRecommended: function setRecommended() {
        return _this.setRecommended();
      },
      addRadial: function addRadial() {
        return _this.addRadialRandom();
      },
      addGrid: function addGrid() {
        return _this.addGridRandom();
      }
    };

    _this.guiFolder.add(tensorFieldGuiObj, 'reset');

    _this.guiFolder.add(tensorFieldGuiObj, 'setRecommended');

    _this.guiFolder.add(tensorFieldGuiObj, 'addRadial');

    _this.guiFolder.add(tensorFieldGuiObj, 'addGrid');

    return _this;
  }
  /**
   * 4 Grids, one radial
   */


  TensorFieldGUI.prototype.setRecommended = function () {
    this.reset();
    var size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
    var newOrigin = this.domainController.worldDimensions.multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2).add(this.domainController.origin);
    this.addGridAtLocation(newOrigin);
    this.addGridAtLocation(newOrigin.clone().add(size));
    this.addGridAtLocation(newOrigin.clone().add(new vector_1["default"](size.x, 0)));
    this.addGridAtLocation(newOrigin.clone().add(new vector_1["default"](0, size.y)));
    this.addRadialRandom();
  };

  TensorFieldGUI.prototype.addRadialRandom = function () {
    var width = this.domainController.worldDimensions.x;
    this.addRadial(this.randomLocation(), util_1["default"].randomRange(width / 10, width / 5), // Size
    util_1["default"].randomRange(50)); // Decay
  };

  TensorFieldGUI.prototype.addGridRandom = function () {
    this.addGridAtLocation(this.randomLocation());
  };

  TensorFieldGUI.prototype.addGridAtLocation = function (location) {
    var width = this.domainController.worldDimensions.x;
    this.addGrid(location, util_1["default"].randomRange(width / 4, width), // Size
    util_1["default"].randomRange(50), // Decay
    util_1["default"].randomRange(Math.PI / 2));
  };
  /**
   * World-space random location for tensor field spawn
   * Sampled from middle of screen (shrunk rectangle)
   */


  TensorFieldGUI.prototype.randomLocation = function () {
    var size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
    var location = new vector_1["default"](Math.random(), Math.random()).multiply(size);
    var newOrigin = this.domainController.worldDimensions.multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2);
    return location.add(this.domainController.origin).add(newOrigin);
  };

  TensorFieldGUI.prototype.getCrossLocations = function () {
    // Gets grid of points for vector field vis in world space
    var diameter = this.TENSOR_LINE_DIAMETER / this.domainController.zoom;
    var worldDimensions = this.domainController.worldDimensions;
    var nHor = Math.ceil(worldDimensions.x / diameter) + 1; // Prevent pop-in

    var nVer = Math.ceil(worldDimensions.y / diameter) + 1;
    var originX = diameter * Math.floor(this.domainController.origin.x / diameter);
    var originY = diameter * Math.floor(this.domainController.origin.y / diameter);
    var out = [];

    for (var x = 0; x <= nHor; x++) {
      for (var y = 0; y <= nVer; y++) {
        out.push(new vector_1["default"](originX + x * diameter, originY + y * diameter));
      }
    }

    return out;
  };

  TensorFieldGUI.prototype.getTensorLine = function (point, tensorV) {
    var transformedPoint = this.domainController.worldToScreen(point.clone());
    var diff = tensorV.multiplyScalar(this.TENSOR_LINE_DIAMETER / 2); // Assumes normalised

    var start = transformedPoint.clone().sub(diff);
    var end = transformedPoint.clone().add(diff);
    return [start, end];
  };

  TensorFieldGUI.prototype.draw = function (canvas) {
    var _this = this; // Draw tensor field


    canvas.setFillStyle('black');
    canvas.clearCanvas();
    canvas.setStrokeStyle('white');
    canvas.setLineWidth(1);
    var tensorPoints = this.getCrossLocations();
    tensorPoints.forEach(function (p) {
      var t = _this.samplePoint(p);

      canvas.drawPolyline(_this.getTensorLine(p, t.getMajor()));
      canvas.drawPolyline(_this.getTensorLine(p, t.getMinor()));
    }); // Draw centre points of fields

    if (this.drawCentre) {
      canvas.setFillStyle('red');
      this.getCentrePoints().forEach(function (v) {
        return canvas.drawSquare(_this.domainController.worldToScreen(v), 7);
      });
    }
  };

  TensorFieldGUI.prototype.addField = function (field) {
    var _this = this;

    _super.prototype.addField.call(this, field);

    var folder = this.guiFolder.addFolder("" + field.FOLDER_NAME); // Function to deregister from drag controller

    var deregisterDrag = this.dragController.register(function () {
      return field.centre;
    }, field.dragMoveListener.bind(field));
    var removeFieldObj = {
      remove: function remove() {
        return _this.removeFieldGUI.bind(_this)(field, folder, deregisterDrag);
      }
    }; // Give dat gui removeField button

    folder.add(removeFieldObj, 'remove');
    field.setGui(folder);
  };

  TensorFieldGUI.prototype.removeFieldGUI = function (field, folder, deregisterDrag) {
    _super.prototype.removeField.call(this, field);

    this.guiFolder.removeFolder(folder); // Deregister from drag controller

    deregisterDrag();
  };

  TensorFieldGUI.prototype.reset = function () {
    // TODO kind of hacky - calling remove callbacks from gui object, should store callbacks
    // in addfield and call them (requires making sure they're idempotent)
    for (var fieldFolderName in this.guiFolder.__folders) {
      var fieldFolder = this.guiFolder.__folders[fieldFolderName];

      fieldFolder.__controllers[0].initialValue();
    }

    _super.prototype.reset.call(this);
  };

  return TensorFieldGUI;
}(tensor_field_1["default"]);

exports["default"] = TensorFieldGUI;

},{"../impl/tensor_field":23,"../util":34,"../vector":35,"./domain_controller":27}],33:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = require("../util");

var water_generator_1 = require("../impl/water_generator");

var road_gui_1 = require("./road_gui");

var WaterGUI =
/** @class */
function (_super) {
  __extends(WaterGUI, _super);

  function WaterGUI(tensorField, params, integrator, guiFolder, closeTensorFolder, folderName, redraw) {
    var _this = _super.call(this, params, integrator, guiFolder, closeTensorFolder, folderName, redraw) || this;

    _this.tensorField = tensorField;
    _this.params = params;
    _this.streamlines = new water_generator_1["default"](_this.integrator, _this.domainController.origin, _this.domainController.worldDimensions, Object.assign({}, _this.params), _this.tensorField);
    return _this;
  }

  WaterGUI.prototype.initFolder = function () {
    var _this = this;

    var folder = this.guiFolder.addFolder(this.folderName);
    folder.add({
      Generate: function Generate() {
        return _this.generateRoads();
      }
    }, 'Generate');
    var coastParamsFolder = folder.addFolder('CoastParams');
    coastParamsFolder.add(this.params.coastNoise, 'noiseEnabled');
    coastParamsFolder.add(this.params.coastNoise, 'noiseSize');
    coastParamsFolder.add(this.params.coastNoise, 'noiseAngle');
    var riverParamsFolder = folder.addFolder('RiverParams');
    riverParamsFolder.add(this.params.riverNoise, 'noiseEnabled');
    riverParamsFolder.add(this.params.riverNoise, 'noiseSize');
    riverParamsFolder.add(this.params.riverNoise, 'noiseAngle');
    folder.add(this.params, 'simplifyTolerance');
    var devParamsFolder = folder.addFolder('Dev');
    this.addDevParamsToFolder(this.params, devParamsFolder);
    return this;
  };

  WaterGUI.prototype.generateRoads = function () {
    this.preGenerateCallback();
    this.domainController.zoom = this.domainController.zoom / util_1["default"].DRAW_INFLATE_AMOUNT;
    this.streamlines = new water_generator_1["default"](this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params), this.tensorField);
    this.domainController.zoom = this.domainController.zoom * util_1["default"].DRAW_INFLATE_AMOUNT;
    this.streamlines.createCoast();
    this.streamlines.createRiver();
    this.closeTensorFolder();
    this.redraw();
    this.postGenerateCallback();
    return new Promise(function (resolve) {
      return resolve();
    });
  };

  Object.defineProperty(WaterGUI.prototype, "streamlinesWithSecondaryRoad", {
    get: function get() {
      var withSecondary = this.streamlines.allStreamlinesSimple.slice();
      withSecondary.push(this.streamlines.riverSecondaryRoad);
      return withSecondary;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGUI.prototype, "river", {
    get: function get() {
      var _this = this;

      return this.streamlines.riverPolygon.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGUI.prototype, "secondaryRiver", {
    get: function get() {
      var _this = this;

      return this.streamlines.riverSecondaryRoad.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGUI.prototype, "coastline", {
    get: function get() {
      var _this = this; // Use unsimplified noisy streamline as coastline
      // Visual only, no road logic performed using this


      return this.streamlines.coastline.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGUI.prototype, "seaPolygon", {
    get: function get() {
      var _this = this;

      return this.streamlines.seaPolygon.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    },
    enumerable: true,
    configurable: true
  });

  WaterGUI.prototype.addDevParamsToFolder = function (params, folder) {
    folder.add(params, 'dsep');
    folder.add(params, 'dtest');
    folder.add(params, 'pathIterations');
    folder.add(params, 'seedTries');
    folder.add(params, 'dstep');
    folder.add(params, 'dlookahead');
    folder.add(params, 'dcirclejoin');
    folder.add(params, 'joinangle');
  };

  return WaterGUI;
}(road_gui_1["default"]);

exports["default"] = WaterGUI;

},{"../impl/water_generator":24,"../util":34,"./road_gui":30}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Util =
/** @class */
function () {
  function Util() {}

  Util.updateGui = function (gui) {
    if (gui.__controllers) {
      gui.__controllers.forEach(function (c) {
        return c.updateDisplay();
      });
    }

    if (gui.__folders) {
      for (var folderName in gui.__folders) {
        this.updateGui(gui.__folders[folderName]);
      }
    }
  };

  Util.removeAllFolders = function (gui) {
    if (gui.__folders) {
      for (var folderName in gui.__folders) {
        gui.removeFolder(gui.__folders[folderName]);
      }
    }
  };

  Util.randomRange = function (max, min) {
    if (min === void 0) {
      min = 0;
    }

    return Math.random() * (max - min) + min;
  };

  Util.clamp_css_byte = function (i) {
    i = Math.round(i); // Seems to be what Chrome does (vs truncation).

    return i < 0 ? 0 : i > 255 ? 255 : i;
  };

  Util.clamp_css_float = function (f) {
    return f < 0 ? 0 : f > 1 ? 1 : f;
  };

  Util.parse_css_int = function (str) {
    if (str[str.length - 1] === '%') return Util.clamp_css_byte(parseFloat(str) / 100 * 255);
    return Util.clamp_css_byte(parseInt(str));
  };

  Util.parse_css_float = function (str) {
    if (str[str.length - 1] === '%') return Util.clamp_css_float(parseFloat(str) / 100);
    return Util.clamp_css_float(parseFloat(str));
  };

  Util.css_hue_to_rgb = function (m1, m2, h) {
    if (h < 0) h += 1;else if (h > 1) h -= 1;
    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1) return m2;
    if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    return m1;
  };

  Util.parseCSSColor = function (css_str) {
    // Remove all whitespace, not compliant, but should just be more accepting.
    var str = css_str.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

    if (str in Util.kCSSColorTable) return Util.kCSSColorTable[str].slice(); // dup.
    // #abc and #abc123 syntax.

    if (str[0] === '#') {
      if (str.length === 4) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 0xfff)) return null; // Covers NaN.

        return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];
      } else if (str.length === 7) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 0xffffff)) return null; // Covers NaN.

        return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
      }

      return null;
    }

    var op = str.indexOf('('),
        ep = str.indexOf(')');

    if (op !== -1 && ep + 1 === str.length) {
      var fname = str.substr(0, op);
      var params = str.substr(op + 1, ep - (op + 1)).split(',');
      var alpha = 1; // To allow case fallthrough.

      switch (fname) {
        case 'rgba':
          if (params.length !== 4) return null;
          alpha = Util.parse_css_float(params.pop());
        // Fall through.

        case 'rgb':
          if (params.length !== 3) return null;
          return [Util.parse_css_int(params[0]), Util.parse_css_int(params[1]), Util.parse_css_int(params[2]), alpha];

        case 'hsla':
          if (params.length !== 4) return null;
          alpha = Util.parse_css_float(params.pop());
        // Fall through.

        case 'hsl':
          if (params.length !== 3) return null;
          var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1
          // NOTE(deanm): According to the CSS spec s/l should only be
          // percentages, but we don't bother and let float or percentage.

          var s = Util.parse_css_float(params[1]);
          var l = Util.parse_css_float(params[2]);
          var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          var m1 = l * 2 - m2;
          return [Util.clamp_css_byte(Util.css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), Util.clamp_css_byte(Util.css_hue_to_rgb(m1, m2, h) * 255), Util.clamp_css_byte(Util.css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];

        default:
          return null;
      }
    }

    return null;
  }; // Must match style.css


  Util.CANVAS_ID = 'map-canvas';
  Util.IMG_CANVAS_ID = 'img-canvas';
  Util.SVG_ID = 'map-svg'; // How far to integrate streamlines beyond screen - for making buildings reach the edge

  Util.DRAW_INFLATE_AMOUNT = 1.2; // (c) Dean McNamee <dean@gmail.com>, 2012.
  //
  // https://github.com/deanm/css-color-parser-js
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to
  // deal in the Software without restriction, including without limitation the
  // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  // sell copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  // IN THE SOFTWARE.
  // http://www.w3.org/TR/css3-color/

  Util.kCSSColorTable = {
    "transparent": [0, 0, 0, 0],
    "aliceblue": [240, 248, 255, 1],
    "antiquewhite": [250, 235, 215, 1],
    "aqua": [0, 255, 255, 1],
    "aquamarine": [127, 255, 212, 1],
    "azure": [240, 255, 255, 1],
    "beige": [245, 245, 220, 1],
    "bisque": [255, 228, 196, 1],
    "black": [0, 0, 0, 1],
    "blanchedalmond": [255, 235, 205, 1],
    "blue": [0, 0, 255, 1],
    "blueviolet": [138, 43, 226, 1],
    "brown": [165, 42, 42, 1],
    "burlywood": [222, 184, 135, 1],
    "cadetblue": [95, 158, 160, 1],
    "chartreuse": [127, 255, 0, 1],
    "chocolate": [210, 105, 30, 1],
    "coral": [255, 127, 80, 1],
    "cornflowerblue": [100, 149, 237, 1],
    "cornsilk": [255, 248, 220, 1],
    "crimson": [220, 20, 60, 1],
    "cyan": [0, 255, 255, 1],
    "darkblue": [0, 0, 139, 1],
    "darkcyan": [0, 139, 139, 1],
    "darkgoldenrod": [184, 134, 11, 1],
    "darkgray": [169, 169, 169, 1],
    "darkgreen": [0, 100, 0, 1],
    "darkgrey": [169, 169, 169, 1],
    "darkkhaki": [189, 183, 107, 1],
    "darkmagenta": [139, 0, 139, 1],
    "darkolivegreen": [85, 107, 47, 1],
    "darkorange": [255, 140, 0, 1],
    "darkorchid": [153, 50, 204, 1],
    "darkred": [139, 0, 0, 1],
    "darksalmon": [233, 150, 122, 1],
    "darkseagreen": [143, 188, 143, 1],
    "darkslateblue": [72, 61, 139, 1],
    "darkslategray": [47, 79, 79, 1],
    "darkslategrey": [47, 79, 79, 1],
    "darkturquoise": [0, 206, 209, 1],
    "darkviolet": [148, 0, 211, 1],
    "deeppink": [255, 20, 147, 1],
    "deepskyblue": [0, 191, 255, 1],
    "dimgray": [105, 105, 105, 1],
    "dimgrey": [105, 105, 105, 1],
    "dodgerblue": [30, 144, 255, 1],
    "firebrick": [178, 34, 34, 1],
    "floralwhite": [255, 250, 240, 1],
    "forestgreen": [34, 139, 34, 1],
    "fuchsia": [255, 0, 255, 1],
    "gainsboro": [220, 220, 220, 1],
    "ghostwhite": [248, 248, 255, 1],
    "gold": [255, 215, 0, 1],
    "goldenrod": [218, 165, 32, 1],
    "gray": [128, 128, 128, 1],
    "green": [0, 128, 0, 1],
    "greenyellow": [173, 255, 47, 1],
    "grey": [128, 128, 128, 1],
    "honeydew": [240, 255, 240, 1],
    "hotpink": [255, 105, 180, 1],
    "indianred": [205, 92, 92, 1],
    "indigo": [75, 0, 130, 1],
    "ivory": [255, 255, 240, 1],
    "khaki": [240, 230, 140, 1],
    "lavender": [230, 230, 250, 1],
    "lavenderblush": [255, 240, 245, 1],
    "lawngreen": [124, 252, 0, 1],
    "lemonchiffon": [255, 250, 205, 1],
    "lightblue": [173, 216, 230, 1],
    "lightcoral": [240, 128, 128, 1],
    "lightcyan": [224, 255, 255, 1],
    "lightgoldenrodyellow": [250, 250, 210, 1],
    "lightgray": [211, 211, 211, 1],
    "lightgreen": [144, 238, 144, 1],
    "lightgrey": [211, 211, 211, 1],
    "lightpink": [255, 182, 193, 1],
    "lightsalmon": [255, 160, 122, 1],
    "lightseagreen": [32, 178, 170, 1],
    "lightskyblue": [135, 206, 250, 1],
    "lightslategray": [119, 136, 153, 1],
    "lightslategrey": [119, 136, 153, 1],
    "lightsteelblue": [176, 196, 222, 1],
    "lightyellow": [255, 255, 224, 1],
    "lime": [0, 255, 0, 1],
    "limegreen": [50, 205, 50, 1],
    "linen": [250, 240, 230, 1],
    "magenta": [255, 0, 255, 1],
    "maroon": [128, 0, 0, 1],
    "mediumaquamarine": [102, 205, 170, 1],
    "mediumblue": [0, 0, 205, 1],
    "mediumorchid": [186, 85, 211, 1],
    "mediumpurple": [147, 112, 219, 1],
    "mediumseagreen": [60, 179, 113, 1],
    "mediumslateblue": [123, 104, 238, 1],
    "mediumspringgreen": [0, 250, 154, 1],
    "mediumturquoise": [72, 209, 204, 1],
    "mediumvioletred": [199, 21, 133, 1],
    "midnightblue": [25, 25, 112, 1],
    "mintcream": [245, 255, 250, 1],
    "mistyrose": [255, 228, 225, 1],
    "moccasin": [255, 228, 181, 1],
    "navajowhite": [255, 222, 173, 1],
    "navy": [0, 0, 128, 1],
    "oldlace": [253, 245, 230, 1],
    "olive": [128, 128, 0, 1],
    "olivedrab": [107, 142, 35, 1],
    "orange": [255, 165, 0, 1],
    "orangered": [255, 69, 0, 1],
    "orchid": [218, 112, 214, 1],
    "palegoldenrod": [238, 232, 170, 1],
    "palegreen": [152, 251, 152, 1],
    "paleturquoise": [175, 238, 238, 1],
    "palevioletred": [219, 112, 147, 1],
    "papayawhip": [255, 239, 213, 1],
    "peachpuff": [255, 218, 185, 1],
    "peru": [205, 133, 63, 1],
    "pink": [255, 192, 203, 1],
    "plum": [221, 160, 221, 1],
    "powderblue": [176, 224, 230, 1],
    "purple": [128, 0, 128, 1],
    "rebeccapurple": [102, 51, 153, 1],
    "red": [255, 0, 0, 1],
    "rosybrown": [188, 143, 143, 1],
    "royalblue": [65, 105, 225, 1],
    "saddlebrown": [139, 69, 19, 1],
    "salmon": [250, 128, 114, 1],
    "sandybrown": [244, 164, 96, 1],
    "seagreen": [46, 139, 87, 1],
    "seashell": [255, 245, 238, 1],
    "sienna": [160, 82, 45, 1],
    "silver": [192, 192, 192, 1],
    "skyblue": [135, 206, 235, 1],
    "slateblue": [106, 90, 205, 1],
    "slategray": [112, 128, 144, 1],
    "slategrey": [112, 128, 144, 1],
    "snow": [255, 250, 250, 1],
    "springgreen": [0, 255, 127, 1],
    "steelblue": [70, 130, 180, 1],
    "tan": [210, 180, 140, 1],
    "teal": [0, 128, 128, 1],
    "thistle": [216, 191, 216, 1],
    "tomato": [255, 99, 71, 1],
    "turquoise": [64, 224, 208, 1],
    "violet": [238, 130, 238, 1],
    "wheat": [245, 222, 179, 1],
    "white": [255, 255, 255, 1],
    "whitesmoke": [245, 245, 245, 1],
    "yellow": [255, 255, 0, 1],
    "yellowgreen": [154, 205, 50, 1]
  };
  return Util;
}();

exports["default"] = Util;

},{}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var Vector =
/** @class */
function () {
  function Vector(x, y) {
    this.x = x;
    this.y = y;
  }

  Vector.zeroVector = function () {
    return new Vector(0, 0);
  };

  Vector.fromScalar = function (s) {
    return new Vector(s, s);
  };
  /**
   * -pi to pi
   */


  Vector.angleBetween = function (v1, v2) {
    // -2pi to 2pi
    var angleBetween = v1.angle() - v2.angle();

    if (angleBetween > Math.PI) {
      angleBetween -= 2 * Math.PI;
    } else if (angleBetween <= -Math.PI) {
      angleBetween += 2 * Math.PI;
    }

    return angleBetween;
  };
  /**
   * Tests whether a point lies to the left of a line
   * @param  {Vector} linePoint     Point on the line
   * @param  {Vector} lineDirection
   * @param  {Vector} point
   * @return {Vector}               true if left, false otherwise
   */


  Vector.isLeft = function (linePoint, lineDirection, point) {
    var perpendicularVector = new Vector(lineDirection.y, -lineDirection.x);
    return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
  };

  Vector.prototype.add = function (v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  };
  /**
   * Angle in radians to positive x-axis between -pi and pi
   */


  Vector.prototype.angle = function () {
    return Math.atan2(this.y, this.x);
  };

  Vector.prototype.clone = function () {
    return new Vector(this.x, this.y);
  };

  Vector.prototype.copy = function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  };

  Vector.prototype.cross = function (v) {
    return this.x * v.y - this.y * v.x;
  };

  Vector.prototype.distanceTo = function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  };

  Vector.prototype.distanceToSquared = function (v) {
    var dx = this.x - v.x;
    var dy = this.y - v.y;
    return dx * dx + dy * dy;
  };

  Vector.prototype.divide = function (v) {
    if (v.x === 0 || v.y === 0) {
      log.warn("Division by zero");
      return this;
    }

    this.x /= v.x;
    this.y /= v.y;
    return this;
  };

  Vector.prototype.divideScalar = function (s) {
    if (s === 0) {
      log.warn("Division by zero");
      return this;
    }

    return this.multiplyScalar(1 / s);
  };

  Vector.prototype.dot = function (v) {
    return this.x * v.x + this.y * v.y;
  };

  Vector.prototype.equals = function (v) {
    return v.x === this.x && v.y === this.y;
  };

  Vector.prototype.length = function () {
    return Math.sqrt(this.lengthSq());
  };

  Vector.prototype.lengthSq = function () {
    return this.x * this.x + this.y * this.y;
  };

  Vector.prototype.multiply = function (v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  };

  Vector.prototype.multiplyScalar = function (s) {
    this.x *= s;
    this.y *= s;
    return this;
  };

  Vector.prototype.negate = function () {
    return this.multiplyScalar(-1);
  };

  Vector.prototype.normalize = function () {
    var l = this.length();

    if (l === 0) {
      log.warn("Zero Vector");
      return this;
    }

    return this.divideScalar(this.length());
  };
  /**
   * Angle in radians
   */


  Vector.prototype.rotateAround = function (center, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var x = this.x - center.x;
    var y = this.y - center.y;
    this.x = x * cos - y * sin + center.x;
    this.y = x * sin + y * cos + center.y;
    return this;
  };

  Vector.prototype.set = function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  };

  Vector.prototype.setX = function (x) {
    this.x = x;
    return this;
  };

  Vector.prototype.setY = function (y) {
    this.y = y;
    return this;
  };

  Vector.prototype.setLength = function (length) {
    return this.normalize().multiplyScalar(length);
  };

  Vector.prototype.sub = function (v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  };

  return Vector;
}();

exports["default"] = Vector;

},{"loglevel":7}]},{},[13,15,16,17,18,19,20,21,23,22,24,25,26,27,28,29,30,31,32,33,34,35])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZXItYWdlbnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC12ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dyYXBwZWQtd2VsbC1rbm93bi1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9iaW5kLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZyZWV6aW5nLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy91dGlscy9tZXRob2RzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ub3QtYS1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXRyaW0uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLXRyaW0tbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdXRpbHMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3V0aWxzL3dpbmRvdy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvQmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3V0aWxzL2Fkb3B0ZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL29wdGlvbmFsL2FycmFuZ2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvcmVnZXguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL29wdGlvbmFsL2NsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvb3B0aW9uYWwvY3NzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC9tZW1vcnkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvQ29sb3IuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc3VwZXJQcm9wQmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9Qb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL01hdHJpeC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9Cb3guanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9BcnJheVBvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL0V2ZW50VGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvU1ZHQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9TVkdOdW1iZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvYXR0ci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0RvbS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0VsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL29wdGlvbmFsL3N1Z2FyLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvY2lyY2xlZC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1NoYXBlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvQ2lyY2xlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvQ29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRGVmcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0VsbGlwc2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9TdG9wLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2dyYWRpZW50ZWQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9HcmFkaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1BhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9JbWFnZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL1BvaW50QXJyYXkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvcG9pbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0xpbmUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9NYXJrZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2FuaW1hdGlvbi9Db250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvUGF0aEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL01vcnBoYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1BhdGguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvcG9seS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1BvbHlnb24uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9Qb2x5bGluZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1JlY3QuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL1RpbWVsaW5lLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL1J1bm5lci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1N2Zy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS90ZXh0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1RleHQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9Uc3Bhbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0NsaXBQYXRoLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRm9yZWlnbk9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0cuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9BLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvTWFzay5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1N0eWxlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvVGV4dFBhdGguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9Vc2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL2Rpc3QvZDMtcXVhZHRyZWUuanMiLCJub2RlX21vZHVsZXMvZGF0Lmd1aS9idWlsZC9kYXQuZ3VpLmpzIiwibm9kZV9tb2R1bGVzL2ludGVyYWN0anMvZGlzdC9pbnRlcmFjdC5taW4uanMiLCJub2RlX21vZHVsZXMvaXNlY3QvYnVpbGQvaXNlY3QuanMiLCJub2RlX21vZHVsZXMvanN0cy9kaXN0L2pzdHMubWluLmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5ay9kaXN0L3BvbHlrLmpzIiwibm9kZV9tb2R1bGVzL3JvdWdoanMvYnVuZGxlZC9yb3VnaC5janMuanMiLCJub2RlX21vZHVsZXMvc2ltcGxleC1ub2lzZS9zaW1wbGV4LW5vaXNlLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWZ5LWpzL3NpbXBsaWZ5LmpzIiwic3JjL2NvbG91cl9zY2hlbWVzLmpzb24iLCJzcmMvbWFpbi50cyIsInNyYy90cy9WZWN0b3IudHMiLCJzcmMvdHMvaW1wbC9iYXNpc19maWVsZC50cyIsInNyYy90cy9pbXBsL2dyYXBoLnRzIiwic3JjL3RzL2ltcGwvZ3JpZF9zdG9yYWdlLnRzIiwic3JjL3RzL2ltcGwvaW50ZWdyYXRvci50cyIsInNyYy90cy9pbXBsL3BvbHlnb25fZmluZGVyLnRzIiwic3JjL3RzL2ltcGwvcG9seWdvbl91dGlsLnRzIiwic3JjL3RzL2ltcGwvc3RyZWFtbGluZXMudHMiLCJzcmMvdHMvaW1wbC90ZW5zb3IudHMiLCJzcmMvdHMvaW1wbC90ZW5zb3JfZmllbGQudHMiLCJzcmMvdHMvaW1wbC93YXRlcl9nZW5lcmF0b3IudHMiLCJzcmMvdHMvdWkvYnVpbGRpbmdzLnRzIiwic3JjL3RzL3VpL2NhbnZhc193cmFwcGVyLnRzIiwic3JjL3RzL3VpL2RvbWFpbl9jb250cm9sbGVyLnRzIiwic3JjL3RzL3VpL2RyYWdfY29udHJvbGxlci50cyIsInNyYy90cy91aS9tYWluX2d1aS50cyIsInNyYy90cy91aS9yb2FkX2d1aS50cyIsInNyYy90cy91aS9zdHlsZS50cyIsInNyYy90cy91aS90ZW5zb3JfZmllbGRfZ3VpLnRzIiwic3JjL3RzL3VpL3dhdGVyX2d1aS50cyIsInNyYy90cy91dGlsLnRzIiwic3JjL3RzL3ZlY3Rvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQSxJQUFJLEtBQUssR0FBRyxTQUFSLEtBQVEsQ0FBVSxFQUFWLEVBQWM7QUFDeEIsU0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLElBQUgsSUFBVyxJQUFqQixJQUF5QixFQUFoQztBQUNELENBRkQsQzs7O0FBS0EsSUFBQSxRQUFjLEc7QUFFWixLQUFLLENBQUMsUUFBTyxVQUFQLDBDQUFPLFVBQVAsTUFBcUIsUUFBckIsSUFBaUMsVUFBbEMsQ0FBTCxJQUNBLEtBQUssQ0FBQyxRQUFPLE1BQVAsMENBQU8sTUFBUCxNQUFpQixRQUFqQixJQUE2QixNQUE5QixDQURMLElBRUEsS0FBSyxDQUFDLFFBQU8sSUFBUCwwQ0FBTyxJQUFQLE1BQWUsUUFBZixJQUEyQixJQUE1QixDQUZMLElBR0EsS0FBSyxDQUFDLFNBQU8sY0FBUCxLQUFpQixRQUFqQixJQUE2QixjQUE5QixDQUhMLEk7QUFLQSxRQUFRLENBQUMsYUFBRCxDQUFSLEVBUEY7O0FDTEEsSUFBQSxLQUFjLEdBQUcsU0FBakIsS0FBaUIsQ0FBVSxJQUFWLEVBQWdCO0FBQy9CLE1BQUk7QUFDRixXQUFPLENBQUMsQ0FBQyxJQUFJLEVBQWI7QUFDRCxHQUZELENBRUUsT0FBTyxLQUFQLEVBQWM7QUFDZCxXQUFPLElBQVA7QUFDRDtBQUNGLENBTkQsQyxDQ0VBOzs7QUFDQSxJQUFBLFdBQWMsR0FBRyxDQUFDLEtBQUssQ0FBQyxZQUFZO0FBQ2xDLFNBQU8sTUFBTSxDQUFDLGNBQVAsQ0FBc0IsRUFBdEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFBRSxJ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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6K0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNybEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZKQSxJQUFBLEdBQUEsR0FBQSxPQUFBLENBQUEsVUFBQSxDQUFBOztBQUNBLElBQUEsR0FBQSxHQUFBLE9BQUEsQ0FBQSxTQUFBLENBQUE7O0FBQ0EsSUFBQSxrQkFBQSxHQUFBLE9BQUEsQ0FBQSwwQkFBQSxDQUFBOztBQUVBLElBQUEsVUFBQSxHQUFBLE9BQUEsQ0FBQSxrQkFBQSxDQUFBOztBQUVBLElBQUEsZ0JBQUEsR0FBQSxPQUFBLENBQUEs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QUFLLENBQUwsSUFBVSxDQUFDLENBQUMsQ0FBWjtBQUNBLFdBQU8sSUFBUDtBQUNILEdBSkQ7O0FBS0osU0FBQSxNQUFBO0FBQUMsQ0EvS0QsRUFBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsInZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICFuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbnZhciBzcGxpdCA9ICcnLnNwbGl0O1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG4iLCIvLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBQUkVGRVJSRURfU1RSSU5HKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpbnB1dC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG5cbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcblxudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbCwga2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG4iLCJ2YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4zLjYnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhcmVkKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBuYXRpdmVGdW5jdGlvblRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXRvLXN0cmluZycpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChuYXRpdmVGdW5jdGlvblRvU3RyaW5nLmNhbGwoV2Vha01hcCkpO1xuIiwidmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBvYmplY3RIYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQKSB7XG4gIHZhciBzdG9yZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciB3bWdldCA9IHN0b3JlLmdldDtcbiAgdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xuICB2YXIgd21zZXQgPSBzdG9yZS5zZXQ7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIFRFTVBMQVRFID0gU3RyaW5nKG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcpLnNwbGl0KCd0b1N0cmluZycpO1xuXG5zaGFyZWQoJ2luc3BlY3RTb3VyY2UnLCBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG59KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJyAmJiAhaGFzKHZhbHVlLCAnbmFtZScpKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodmFsdWUsICduYW1lJywga2V5KTtcbiAgICBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSkuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogJycpO1xuICB9XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICAgIHNpbXBsZSA9IHRydWU7XG4gIH1cbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBuYXRpdmVGdW5jdGlvblRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuIiwidmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoW25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSlcbiAgICA6IHBhdGhbbmFtZXNwYWNlXSAmJiBwYXRoW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcbiIsInZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYFRvSW50ZWdlcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2ludGVnZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc05hTihhcmd1bWVudCA9ICthcmd1bWVudCkgPyAwIDogKGFyZ3VtZW50ID4gMCA/IGZsb29yIDogY2VpbCkoYXJndW1lbnQpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGxlbmd0aCwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG4iLCJ2YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhcyh0YXJnZXQsIGtleSkpIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgfVxufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IHR5cGVvZiBkZXRlY3Rpb24gPT0gJ2Z1bmN0aW9uJyA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLm5vVGFyZ2V0R2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBzZXRHbG9iYWwoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG4vLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2FycmF5XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNsYXNzb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHJldHVybiAhU3RyaW5nKFN5bWJvbCgpKTtcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xuXG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBzdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9IE5BVElWRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdXG4gICAgfHwgKE5BVElWRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2VyLWFnZW50Jyk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgdmVyc2lvbiA9IG1hdGNoWzBdICsgbWF0Y2hbMV07XG59IGVsc2UgaWYgKHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9IG1hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbiAmJiArdmVyc2lvbjtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdjgtdmVyc2lvbicpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3N1xuICByZXR1cm4gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFycmF5LmNvbnN0cnVjdG9yID0ge307XG4gICAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBmb286IDEgfTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIG5hdGl2ZVNsaWNlID0gW10uc2xpY2U7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNsaWNlXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc2xpY2UnKSB9LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIC8vIGlubGluZSBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBmb3IgdXNhZ2UgbmF0aXZlIGBBcnJheSNzbGljZWAgd2hlcmUgaXQncyBwb3NzaWJsZVxuICAgIHZhciBDb25zdHJ1Y3RvciwgcmVzdWx0LCBuO1xuICAgIGlmIChpc0FycmF5KE8pKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IE8uY29uc3RydWN0b3I7XG4gICAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBDb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgaXNBcnJheShDb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3JbU1BFQ0lFU107XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gbnVsbCkgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IgPT09IEFycmF5IHx8IENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNsaWNlLmNhbGwoTywgaywgZmluKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ID0gbmV3IChDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDb25zdHJ1Y3RvcikobWF4KGZpbiAtIGssIDApKTtcbiAgICBmb3IgKG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgaWYgKGsgaW4gTykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZyA9IEZ1bmN0aW9uUHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnO1xuXG4vLyBGdW5jdGlvbiBpbnN0YW5jZXMgYC5uYW1lYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnVuY3Rpb24taW5zdGFuY2VzLW5hbWVcbmlmIChERVNDUklQVE9SUyAmJiAhKE5BTUUgaW4gRnVuY3Rpb25Qcm90b3R5cGUpKSB7XG4gIGRlZmluZVByb3BlcnR5KEZ1bmN0aW9uUHJvdG90eXBlLCBOQU1FLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmcuY2FsbCh0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4iLCJ2YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoaXQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XSdcbiAgICA/IGdldFdpbmRvd05hbWVzKGl0KVxuICAgIDogbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoaXQpKTtcbn07XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwnKS5mO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuICFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyB9LCB7XG4gIGdldE93blByb3BlcnR5TmFtZXM6IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXNcbn0pO1xuIiwiZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YyKG9iaik7IH1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59IiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuIiwidmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBQcm9wZXJ0aWVzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9odG1sJyk7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIHNjcmlwdCA9ICdzY3JpcHQnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBqcyA9ICdqYXZhJyArIHNjcmlwdCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gU3RyaW5nKGpzKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArIHNjcmlwdCArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy8nICsgc2NyaXB0ICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuIiwidmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dyYXBwZWQtd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICB2YXIgU3ltYm9sID0gcGF0aC5TeW1ib2wgfHwgKHBhdGguU3ltYm9sID0ge30pO1xuICBpZiAoIWhhcyhTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eShTeW1ib2wsIE5BTUUsIHtcbiAgICB2YWx1ZTogd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKE5BTUUpXG4gIH0pO1xufTtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShpdCwgVE9fU1RSSU5HX1RBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCk7XG4gICAgfTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIG5ldyAoQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG4iLCJ2YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbnZhciBwdXNoID0gW10ucHVzaDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWUsIHJlc3VsdDtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbHVlOyAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcHVzaC5jYWxsKHRhcmdldCwgdmFsdWUpOyAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHRhcmdldDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICBmb3JFYWNoOiBjcmVhdGVNZXRob2QoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kKDIpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuICBzb21lOiBjcmVhdGVNZXRob2QoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kKDUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QoNilcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbCcpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd3JhcHBlZC13ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xuXG52YXIgSElEREVOID0gc2hhcmVkS2V5KCdoaWRkZW4nKTtcbnZhciBTWU1CT0wgPSAnU3ltYm9sJztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTWU1CT0wpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBuYXRpdmVKU09OU3RyaW5naWZ5ID0gSlNPTiAmJiBKU09OLnN0cmluZ2lmeTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N0cmluZy10by1zeW1ib2wtcmVnaXN0cnknKTtcbnZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIFApO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcikgZGVsZXRlIE9iamVjdFByb3RvdHlwZVtQXTtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZSwgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG4gIH1cbn0gOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgaXNTeW1ib2wgPSBOQVRJVkVfU1lNQk9MICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoaXQpIGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGlmIChPID09PSBPYmplY3RQcm90b3R5cGUpICRkZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQLCBBdHRyaWJ1dGVzKTtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghQXR0cmlidXRlcy5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhPLCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBISURERU4sIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB7fSkpO1xuICAgICAgT1tISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKE8sIEhJRERFTikgJiYgT1tISURERU5dW2tleV0pIE9bSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBBdHRyaWJ1dGVzID0gbmF0aXZlT2JqZWN0Q3JlYXRlKEF0dHJpYnV0ZXMsIHsgZW51bWVyYWJsZTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjcmlwdG9yKE8sIGtleSwgQXR0cmlidXRlcyk7XG4gIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIGtleSwgQXR0cmlidXRlcyk7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMocHJvcGVydGllcykuY29uY2F0KCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvcGVydGllcykpO1xuICAkZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFERVNDUklQVE9SUyB8fCAkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChwcm9wZXJ0aWVzLCBrZXkpKSAkZGVmaW5lUHJvcGVydHkoTywga2V5LCBwcm9wZXJ0aWVzW2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyBuYXRpdmVPYmplY3RDcmVhdGUoTykgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoTyksIFByb3BlcnRpZXMpO1xufTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIFAgPSB0b1ByaW1pdGl2ZShWLCB0cnVlKTtcbiAgdmFyIGVudW1lcmFibGUgPSBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRoaXMsIFApO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhcyhBbGxTeW1ib2xzLCBQKSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFApKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbnVtZXJhYmxlIHx8ICFoYXModGhpcywgUCkgfHwgIWhhcyhBbGxTeW1ib2xzLCBQKSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1bUF0gPyBlbnVtZXJhYmxlIDogdHJ1ZTtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgdmFyIGl0ID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbiAgaWYgKGRlc2NyaXB0b3IgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkge1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKGhpZGRlbktleXMsIGtleSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTykge1xuICB2YXIgSVNfT0JKRUNUX1BST1RPVFlQRSA9IE8gPT09IE9iamVjdFByb3RvdHlwZTtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhJU19PQkpFQ1RfUFJPVE9UWVBFID8gT2JqZWN0UHJvdG90eXBlU3ltYm9scyA6IHRvSW5kZXhlZE9iamVjdChPKSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgJGZvckVhY2gobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgKCFJU19PQkpFQ1RfUFJPVE9UWVBFIHx8IGhhcyhPYmplY3RQcm90b3R5cGUsIGtleSkpKSB7XG4gICAgICByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBgU3ltYm9sYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLWNvbnN0cnVjdG9yXG5pZiAoIU5BVElWRV9TWU1CT0wpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gIWFyZ3VtZW50cy5sZW5ndGggfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgdGFnID0gdWlkKGRlc2NyaXB0aW9uKTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlKSBzZXR0ZXIuY2FsbChPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IodGhpcywgdGFnLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBzZXR0ZXIgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnLCBkZXNjcmlwdGlvbik7XG4gIH07XG5cbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gIH0pO1xuXG4gIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLVN5bWJvbC1kZXNjcmlwdGlvblxuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFJU19QVVJFKSB7XG4gICAgICByZWRlZmluZShPYmplY3RQcm90b3R5cGUsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuICB9XG5cbiAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wobmFtZSksIG5hbWUpO1xuICB9O1xufVxuXG4kKHsgZ2xvYmFsOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIFN5bWJvbDogJFN5bWJvbFxufSk7XG5cbiRmb3JFYWNoKG9iamVjdEtleXMoV2VsbEtub3duU3ltYm9sc1N0b3JlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sKG5hbWUpO1xufSk7XG5cbiQoeyB0YXJnZXQ6IFNZTUJPTCwgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIC8vIGBTeW1ib2wuZm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcoa2V5KTtcbiAgICBpZiAoaGFzKFN0cmluZ1RvU3ltYm9sUmVnaXN0cnksIHN0cmluZykpIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG4gICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woc3RyaW5nKTtcbiAgICBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ10gPSBzeW1ib2w7XG4gICAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1ib2xdID0gc3RyaW5nO1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH0sXG4gIC8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLmtleWZvclxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICAgIGlmIChoYXMoU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSwgc3ltKSkgcmV0dXJuIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltXTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IGZhbHNlOyB9XG59KTtcblxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG59KTtcblxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlzeW1ib2xzXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IGZhaWxzKGZ1bmN0aW9uICgpIHsgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYoMSk7IH0pIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbi8vIGBKU09OLnN0cmluZ2lmeWAgbWV0aG9kIGJlaGF2aW9yIHdpdGggc3ltYm9sc1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtanNvbi5zdHJpbmdpZnlcbkpTT04gJiYgJCh7IHRhcmdldDogJ0pTT04nLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgcmV0dXJuIG5hdGl2ZUpTT05TdHJpbmdpZnkoW3N5bWJvbF0pICE9ICdbbnVsbF0nXG4gICAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gICAgfHwgbmF0aXZlSlNPTlN0cmluZ2lmeSh7IGE6IHN5bWJvbCB9KSAhPSAne30nXG4gICAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgICB8fCBuYXRpdmVKU09OU3RyaW5naWZ5KE9iamVjdChzeW1ib2wpKSAhPSAne30nO1xufSkgfSwge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaW5kZXggPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaW5kZXgpIGFyZ3MucHVzaChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIG5hdGl2ZUpTT05TdHJpbmdpZnkuYXBwbHkoSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmlmICghJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0pIHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG59XG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgU1lNQk9MKTtcblxuaGlkZGVuS2V5c1tISURERU5dID0gdHJ1ZTtcbiIsIi8vIGBTeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uYCBnZXR0ZXJcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25cbid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xuXG52YXIgTmF0aXZlU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcblxuaWYgKERFU0NSSVBUT1JTICYmIHR5cGVvZiBOYXRpdmVTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAoISgnZGVzY3JpcHRpb24nIGluIE5hdGl2ZVN5bWJvbC5wcm90b3R5cGUpIHx8XG4gIC8vIFNhZmFyaSAxMiBidWdcbiAgTmF0aXZlU3ltYm9sKCkuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZFxuKSkge1xuICB2YXIgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlID0ge307XG4gIC8vIHdyYXAgU3ltYm9sIGNvbnN0cnVjdG9yIGZvciBjb3JyZWN0IHdvcmsgd2l0aCB1bmRlZmluZWQgZGVzY3JpcHRpb25cbiAgdmFyIFN5bWJvbFdyYXBwZXIgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcyBpbnN0YW5jZW9mIFN5bWJvbFdyYXBwZXJcbiAgICAgID8gbmV3IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbilcbiAgICAgIC8vIGluIEVkZ2UgMTMsIFN0cmluZyhTeW1ib2wodW5kZWZpbmVkKSkgPT09ICdTeW1ib2wodW5kZWZpbmVkKSdcbiAgICAgIDogZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/IE5hdGl2ZVN5bWJvbCgpIDogTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoZGVzY3JpcHRpb24gPT09ICcnKSBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmVbcmVzdWx0XSA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhTeW1ib2xXcmFwcGVyLCBOYXRpdmVTeW1ib2wpO1xuICB2YXIgc3ltYm9sUHJvdG90eXBlID0gU3ltYm9sV3JhcHBlci5wcm90b3R5cGUgPSBOYXRpdmVTeW1ib2wucHJvdG90eXBlO1xuICBzeW1ib2xQcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeW1ib2xXcmFwcGVyO1xuXG4gIHZhciBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIG5hdGl2ZSA9IFN0cmluZyhOYXRpdmVTeW1ib2woJ3Rlc3QnKSkgPT0gJ1N5bWJvbCh0ZXN0KSc7XG4gIHZhciByZWdleHAgPSAvXlN5bWJvbFxcKCguKilcXClbXildKyQvO1xuICBkZWZpbmVQcm9wZXJ0eShzeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBzeW1ib2wgPSBpc09iamVjdCh0aGlzKSA/IHRoaXMudmFsdWVPZigpIDogdGhpcztcbiAgICAgIHZhciBzdHJpbmcgPSBzeW1ib2xUb1N0cmluZy5jYWxsKHN5bWJvbCk7XG4gICAgICBpZiAoaGFzKEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSwgc3ltYm9sKSkgcmV0dXJuICcnO1xuICAgICAgdmFyIGRlc2MgPSBuYXRpdmUgPyBzdHJpbmcuc2xpY2UoNywgLTEpIDogc3RyaW5nLnJlcGxhY2UocmVnZXhwLCAnJDEnKTtcbiAgICAgIHJldHVybiBkZXNjID09PSAnJyA/IHVuZGVmaW5lZCA6IGRlc2M7XG4gICAgfVxuICB9KTtcblxuICAkKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgIFN5bWJvbDogU3ltYm9sV3JhcHBlclxuICB9KTtcbn1cbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbi8vIGBTeW1ib2wuaXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXRlcmF0b3JcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCBjcmVhdGUobnVsbCkpO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyJyk7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuaWYgKFtdLmtleXMpIHtcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IHRydWU7XG4gIGVsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG5pZiAoSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuaWYgKCFJU19QVVJFICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkge1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgJiYgaXQgIT09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmcoaXQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIHNldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldDtcbiAgICBzZXR0ZXIuY2FsbCh0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlci5jYWxsKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSXRlcmF0b3JzQ29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpO1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmICghSVNfUFVSRSAmJiBnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgICAgaWYgKElTX1BVUkUpIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuYXRpdmVJdGVyYXRvci5jYWxsKHRoaXMpOyB9O1xuICB9XG5cbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IsIGRlZmF1bHRJdGVyYXRvcik7XG4gIH1cbiAgSXRlcmF0b3JzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkKHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5rZXlzXG4vLyBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGVhcnJheWl0ZXJhdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogQVJSQVlfSVRFUkFUT1IsXG4gICAgdGFyZ2V0OiB0b0luZGV4ZWRPYmplY3QoaXRlcmF0ZWQpLCAvLyB0YXJnZXRcbiAgICBpbmRleDogMCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgICBraW5kOiBraW5kICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgfSk7XG4vLyBgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xuXG52YXIgbmF0aXZlQXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICFuYXRpdmVBc3NpZ24gfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiBuYXRpdmVBc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKG5hdGl2ZUFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gb2JqZWN0S2V5cyhTKS5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfSByZXR1cm4gVDtcbn0gOiBuYXRpdmVBc3NpZ247XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG4iLCJ2YXIgY2xhc3NvZlJhdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpICE9PSAnW29iamVjdCB6XScgPyBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xufSA6IHRlc3QudG9TdHJpbmc7XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nJyk7XG5cbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAodG9TdHJpbmcgIT09IE9iamVjdFByb3RvdHlwZS50b1N0cmluZykge1xuICByZWRlZmluZShPYmplY3RQcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG4iLCJ2YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgRlJFRVpJTkcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnJlZXppbmcnKTtcblxudmFyIE1FVEFEQVRBID0gdWlkKCdtZXRhJyk7XG52YXIgaWQgPSAwO1xuXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIGRlZmluZVByb3BlcnR5KGl0LCBNRVRBREFUQSwgeyB2YWx1ZToge1xuICAgIG9iamVjdElEOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3ZWFrRGF0YToge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG5cbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIGEgcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQURBVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGFkYXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBREFUQV0ub2JqZWN0SUQ7XG59O1xuXG52YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQURBVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGFkYXRhKGl0KTtcbiAgLy8gcmV0dXJuIHRoZSBzdG9yZSBvZiB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7XG59O1xuXG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpJTkcgJiYgbWV0YS5SRVFVSVJFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEFEQVRBKSkgc2V0TWV0YWRhdGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBSRVFVSVJFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWtEYXRhOiBnZXRXZWFrRGF0YSxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5oaWRkZW5LZXlzW01FVEFEQVRBXSA9IHRydWU7XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdmFyIHJldHVybk1ldGhvZCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0dXJuTWV0aG9kICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYmluZC1jb250ZXh0Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcnKTtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgaXRlcmF0ZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBmbiwgdGhhdCwgQVNfRU5UUklFUywgSVNfSVRFUkFUT1IpIHtcbiAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGZuLCB0aGF0LCBBU19FTlRSSUVTID8gMiA6IDEpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gIGlmIChJU19JVEVSQVRPUikge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG4gIH0gZWxzZSB7XG4gICAgaXRlckZuID0gZ2V0SXRlcmF0b3JNZXRob2QoaXRlcmFibGUpO1xuICAgIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gQVNfRU5UUklFU1xuICAgICAgICAgID8gYm91bmRGdW5jdGlvbihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSlcbiAgICAgICAgICA6IGJvdW5kRnVuY3Rpb24oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICB9XG4gICAgaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IG5leHQuY2FsbChpdGVyYXRvcikpLmRvbmUpIHtcbiAgICByZXN1bHQgPSBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBib3VuZEZ1bmN0aW9uLCBzdGVwLnZhbHVlLCBBU19FTlRSSUVTKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbml0ZXJhdGUuc3RvcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgcmVzdWx0KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuICAgIHR5cGVvZiAoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpID09ICdmdW5jdGlvbicgJiZcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcbiAgICBpc09iamVjdChOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJlxuICAgIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcbiAgKSBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiAgcmV0dXJuICR0aGlzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbFtDT05TVFJVQ1RPUl9OQU1FXTtcbiAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIENvbnN0cnVjdG9yID0gTmF0aXZlQ29uc3RydWN0b3I7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBleHBvcnRlZCA9IHt9O1xuXG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIG5hdGl2ZU1ldGhvZCA9IE5hdGl2ZVByb3RvdHlwZVtLRVldO1xuICAgIHJlZGVmaW5lKE5hdGl2ZVByb3RvdHlwZSwgS0VZLFxuICAgICAgS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICAgIG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIHZhbHVlID09PSAwID8gMCA6IHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IDogS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IGZhbHNlIDogbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IHVuZGVmaW5lZCA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuICAgICAgfSA6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBpZiAoaXNGb3JjZWQoQ09OU1RSVUNUT1JfTkFNRSwgdHlwZW9mIE5hdGl2ZUNvbnN0cnVjdG9yICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IE5hdGl2ZVByb3RvdHlwZS5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5SRVFVSVJFRCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNGb3JjZWQoQ09OU1RSVUNUT1JfTkFNRSwgdHJ1ZSkpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+IENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgaW5zdGFuY2UuaGFzKDEpOyB9KTtcbiAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkgeyBuZXcgTmF0aXZlQ29uc3RydWN0b3IoaXRlcmFibGUpOyB9KTtcbiAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuXG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKGR1bW15LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKGR1bW15LCBDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCksIGR1bW15LCBDb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB0aGF0LCBJU19NQVApO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gTmF0aXZlUHJvdG90eXBlO1xuICAgICAgTmF0aXZlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgaWYgKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pIHtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG5cbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmIChJU19XRUFLICYmIE5hdGl2ZVByb3RvdHlwZS5jbGVhcikgZGVsZXRlIE5hdGl2ZVByb3RvdHlwZS5jbGVhcjtcbiAgfVxuXG4gIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gQ29uc3RydWN0b3I7XG4gICQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogQ29uc3RydWN0b3IgIT0gTmF0aXZlQ29uc3RydWN0b3IgfSwgZXhwb3J0ZWQpO1xuXG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FKTtcblxuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufTtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lLWFsbCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYmluZC1jb250ZXh0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvcicpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKS5mYXN0S2V5O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgIGluZGV4OiBjcmVhdGUobnVsbCksXG4gICAgICAgIGZpcnN0OiB1bmRlZmluZWQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZTogMFxuICAgICAgfSk7XG4gICAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGF0LnNpemUgPSAwO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHRoYXQsIElTX01BUCk7XG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgdmFyIHByZXZpb3VzLCBpbmRleDtcbiAgICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0ID0gZW50cnkgPSB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxuICAgICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICByZW1vdmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXN0YXRlLmZpcnN0KSBzdGF0ZS5maXJzdCA9IGVudHJ5O1xuICAgICAgICBpZiAocHJldmlvdXMpIHByZXZpb3VzLm5leHQgPSBlbnRyeTtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplKys7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplKys7XG4gICAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgICBpZiAoaW5kZXggIT09ICdGJykgc3RhdGUuaW5kZXhbaW5kZXhdID0gZW50cnk7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgLy8gZmFzdCBjYXNlXG4gICAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gICAgICB2YXIgZW50cnk7XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTtcbiAgICAgIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICAgICAgZm9yIChlbnRyeSA9IHN0YXRlLmZpcnN0OyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uZXh0KSB7XG4gICAgICAgIGlmIChlbnRyeS5rZXkgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgIHZhciBkYXRhID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmZpcnN0O1xuICAgICAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucHJldmlvdXMpIGVudHJ5LnByZXZpb3VzID0gZW50cnkucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pbmRleF07XG4gICAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZpcnN0ID0gc3RhdGUubGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplID0gMDtcbiAgICAgICAgZWxzZSB0aGF0LnNpemUgPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgICBkZWxldGUgc3RhdGUuaW5kZXhbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnByZXZpb3VzID0gcHJldjtcbiAgICAgICAgICBpZiAoc3RhdGUuZmlyc3QgPT0gZW50cnkpIHN0YXRlLmZpcnN0ID0gbmV4dDtcbiAgICAgICAgICBpZiAoc3RhdGUubGFzdCA9PSBlbnRyeSkgc3RhdGUubGFzdCA9IHByZXY7XG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplLS07XG4gICAgICAgICAgZWxzZSB0aGF0LnNpemUtLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLmZpcnN0KSB7XG4gICAgICAgICAgYm91bmRGdW5jdGlvbihlbnRyeS52YWx1ZSwgZW50cnkua2V5LCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApIHtcbiAgICB2YXIgSVRFUkFUT1JfTkFNRSA9IENPTlNUUlVDVE9SX05BTUUgKyAnIEl0ZXJhdG9yJztcbiAgICB2YXIgZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuICAgIHZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKElURVJBVE9SX05BTUUpO1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICBkZWZpbmVJdGVyYXRvcihDLCBDT05TVFJVQ1RPUl9OQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgICB0eXBlOiBJVEVSQVRPUl9OQU1FLFxuICAgICAgICB0YXJnZXQ6IGl0ZXJhdGVkLFxuICAgICAgICBzdGF0ZTogZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUoaXRlcmF0ZWQpLFxuICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICBsYXN0OiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSh0aGlzKTtcbiAgICAgIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmxhc3Q7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yZW1vdmVkKSBlbnRyeSA9IGVudHJ5LnByZXZpb3VzO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghc3RhdGUudGFyZ2V0IHx8ICEoc3RhdGUubGFzdCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuc3RhdGUuZmlyc3QpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogZW50cnkua2V5LCBkb25lOiBmYWxzZSB9O1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiBlbnRyeS52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgIHJldHVybiB7IHZhbHVlOiBbZW50cnkua2V5LCBlbnRyeS52YWx1ZV0sIGRvbmU6IGZhbHNlIH07XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbicpO1xudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gYFNldGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNldC1vYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3Rpb24oJ1NldCcsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBjb2RlUG9pbnRBdCwgYXQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIvLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgRE9NSXRlcmFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMnKTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRob3V0SG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRob3V0SG9sZXNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vaXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIi4vbm9uSXRlcmFibGVTcHJlYWRcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn0iLCJjb25zdCBtZXRob2RzID0ge31cclxuY29uc3QgbmFtZXMgPSBbXVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyTWV0aG9kcyAobmFtZSwgbSkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XHJcbiAgICBmb3IgKGNvbnN0IF9uYW1lIG9mIG5hbWUpIHtcclxuICAgICAgcmVnaXN0ZXJNZXRob2RzKF9uYW1lLCBtKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICBmb3IgKGNvbnN0IF9uYW1lIGluIG5hbWUpIHtcclxuICAgICAgcmVnaXN0ZXJNZXRob2RzKF9uYW1lLCBuYW1lW19uYW1lXSlcclxuICAgIH1cclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgYWRkTWV0aG9kTmFtZXMoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobSkpXHJcbiAgbWV0aG9kc1tuYW1lXSA9IE9iamVjdC5hc3NpZ24obWV0aG9kc1tuYW1lXSB8fCB7fSwgbSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGhvZHNGb3IgKG5hbWUpIHtcclxuICByZXR1cm4gbWV0aG9kc1tuYW1lXSB8fCB7fVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0aG9kTmFtZXMgKCkge1xyXG4gIHJldHVybiBbIC4uLm5ldyBTZXQobmFtZXMpIF1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZE1ldGhvZE5hbWVzIChfbmFtZXMpIHtcclxuICBuYW1lcy5wdXNoKC4uLl9uYW1lcylcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmNsdWRlcztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2luY2x1ZGVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZ2V4cEZsYWdzID0gcmVxdWlyZSgnLi9yZWdleHAtZmxhZ3MnKTtcblxudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG4vLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxuLy8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxudmFyIG5hdGl2ZVJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG5cbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvO1xuICB2YXIgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTEubGFzdEluZGV4ICE9PSAwIHx8IHJlMi5sYXN0SW5kZXggIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwocmUsIHN0cik7XG5cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZS5sYXN0SW5kZXggPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgbmF0aXZlUmVwbGFjZS5jYWxsKG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hlZEV4ZWM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBleGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG5cbiQoeyB0YXJnZXQ6ICdSZWdFeHAnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAvLi8uZXhlYyAhPT0gZXhlYyB9LCB7XG4gIGV4ZWM6IGV4ZWNcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNyZWdleHBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG4iLCJ2YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcmVnZXhwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICB2YXIgcmVnZXhwID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChmKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgbm90QVJlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9ub3QtYS1yZWdleHAnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtaXMtcmVnZXhwLWxvZ2ljJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhY29ycmVjdElzUmVnRXhwTG9naWMoJ2luY2x1ZGVzJykgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhflN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKVxuICAgICAgLmluZGV4T2Yobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYycpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG4vLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbi8vIFdlZXggSlMgaGFzIGZyb3plbiBidWlsdC1pbiBwcm90b3R5cGVzLCBzbyB1c2UgdHJ5IC8gY2F0Y2ggd3JhcHBlclxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCByZXN1bHRbMF0gIT09ICdhJyB8fCByZXN1bHRbMV0gIT09ICdiJztcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYywgc2hhbSkge1xuICB2YXIgU1lNQk9MID0gd2VsbEtub3duU3ltYm9sKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBXZSBjYW4ndCB1c2UgcmVhbCByZWdleCBoZXJlIHNpbmNlIGl0IGNhdXNlcyBkZW9wdGltaXphdGlvblxuICAgICAgLy8gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24gaW4gVjhcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMDZcbiAgICAgIHJlID0ge307XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgICByZS5mbGFncyA9ICcnO1xuICAgICAgcmVbU1lNQk9MXSA9IC8uL1tTWU1CT0xdO1xuICAgIH1cblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcblxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSk7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUykgfHxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgbWV0aG9kcyA9IGV4ZWMoU1lNQk9MLCAnJ1tLRVldLCBmdW5jdGlvbiAobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZU1ldGhvZC5jYWxsKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcbiAgICB2YXIgc3RyaW5nTWV0aG9kID0gbWV0aG9kc1swXTtcbiAgICB2YXIgcmVnZXhNZXRob2QgPSBtZXRob2RzWzFdO1xuXG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJpbmdNZXRob2QpO1xuICAgIHJlZGVmaW5lKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcmVnZXhNZXRob2QuY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByZWdleE1ldGhvZC5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICAgIGlmIChzaGFtKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUmVnRXhwLnByb3RvdHlwZVtTWU1CT0xdLCAnc2hhbScsIHRydWUpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNoYXJBdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlJykuY2hhckF0O1xuXG4vLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9jbGFzc29mLXJhdycpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL3JlZ2V4cC1leGVjJyk7XG5cbi8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZ0V4cCBleGVjIG1ldGhvZCByZXR1cm5lZCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBPYmplY3Qgb3IgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cblxuICByZXR1cm4gcmVnZXhwRXhlYy5jYWxsKFIsIFMpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCYnYF18XFxkXFxkP3w8W14+XSo+KS9nO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEID0gL1xcJChbJCYnYF18XFxkXFxkPykvZztcblxudmFyIG1heWJlVG9TdHJpbmcgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xuXG4vLyBAQHJlcGxhY2UgbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKFJFUExBQ0UsIG5hdGl2ZVJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIHJlcGxhY2VyID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgICByZXR1cm4gcmVwbGFjZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHJlcGxhY2VyLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgICAgOiBuYXRpdmVSZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEByZXBsYWNlXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZVJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuXG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG5cbiAgICAgIHZhciBnbG9iYWwgPSByeC5nbG9iYWw7XG4gICAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG4gICAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSBicmVhaztcblxuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuXG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWNjdW11bGF0ZWRSZXN1bHQgPSAnJztcbiAgICAgIHZhciBuZXh0U291cmNlUG9zaXRpb24gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdHNbaV07XG5cbiAgICAgICAgdmFyIG1hdGNoZWQgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG4gIGZ1bmN0aW9uIGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgdGFpbFBvcyA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgdmFyIG0gPSBjYXB0dXJlcy5sZW5ndGg7XG4gICAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcbiAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBuYW1lZENhcHR1cmVzID0gdG9PYmplY3QobmFtZWRDYXB0dXJlcyk7XG4gICAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVSZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgIHZhciBjYXB0dXJlO1xuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgIH0pO1xuICB9XG59KTtcbiIsIi8vIGEgc3RyaW5nIG9mIGFsbCB2YWxpZCB1bmljb2RlIHdoaXRlc3BhY2VzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxubW9kdWxlLmV4cG9ydHMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCJ2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgd2hpdGVzcGFjZSA9ICdbJyArIHdoaXRlc3BhY2VzICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcykge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QoMylcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgbm9uID0gJ1xcdTIwMEJcXHUwMDg1XFx1MTgwRSc7XG5cbi8vIGNoZWNrIHRoYXQgYSBtZXRob2Qgd29ya3Mgd2l0aCB0aGUgY29ycmVjdCBsaXN0XG4vLyBvZiB3aGl0ZXNwYWNlcyBhbmQgaGFzIGEgY29ycmVjdCBuYW1lXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICByZXR1cm4gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpIHx8IG5vbltNRVRIT0RfTkFNRV0oKSAhPSBub24gfHwgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctdHJpbScpLnRyaW07XG52YXIgZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLXRyaW0tbWV0aG9kJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCgndHJpbScpIH0sIHtcbiAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcyk7XG4gIH1cbn0pO1xuIiwiLy8gTWFwIGZ1bmN0aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXAgKGFycmF5LCBibG9jaykge1xyXG4gIHZhciBpXHJcbiAgdmFyIGlsID0gYXJyYXkubGVuZ3RoXHJcbiAgdmFyIHJlc3VsdCA9IFtdXHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICByZXN1bHQucHVzaChibG9jayhhcnJheVtpXSkpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0XHJcbn1cclxuXHJcbi8vIEZpbHRlciBmdW5jdGlvblxyXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyIChhcnJheSwgYmxvY2spIHtcclxuICB2YXIgaVxyXG4gIHZhciBpbCA9IGFycmF5Lmxlbmd0aFxyXG4gIHZhciByZXN1bHQgPSBbXVxyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgaWw7IGkrKykge1xyXG4gICAgaWYgKGJsb2NrKGFycmF5W2ldKSkge1xyXG4gICAgICByZXN1bHQucHVzaChhcnJheVtpXSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHRcclxufVxyXG5cclxuLy8gRGVncmVlcyB0byByYWRpYW5zXHJcbmV4cG9ydCBmdW5jdGlvbiByYWRpYW5zIChkKSB7XHJcbiAgcmV0dXJuIGQgJSAzNjAgKiBNYXRoLlBJIC8gMTgwXHJcbn1cclxuXHJcbi8vIFJhZGlhbnMgdG8gZGVncmVlc1xyXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlcyAocikge1xyXG4gIHJldHVybiByICogMTgwIC8gTWF0aC5QSSAlIDM2MFxyXG59XHJcblxyXG4vLyBDb252ZXJ0IGRhc2gtc2VwYXJhdGVkLXN0cmluZyB0byBjYW1lbENhc2VcclxuZXhwb3J0IGZ1bmN0aW9uIGNhbWVsQ2FzZSAocykge1xyXG4gIHJldHVybiBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbiAobSwgZykge1xyXG4gICAgcmV0dXJuIGcudG9VcHBlckNhc2UoKVxyXG4gIH0pXHJcbn1cclxuXHJcbi8vIENvbnZlcnQgY2FtZWwgY2FzZWQgc3RyaW5nIHRvIHN0cmluZyBzZXBlcmF0ZWRcclxuZXhwb3J0IGZ1bmN0aW9uIHVuQ2FtZWxDYXNlIChzKSB7XHJcbiAgcmV0dXJuIHMucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAobSwgZykge1xyXG4gICAgcmV0dXJuICctJyArIGcudG9Mb3dlckNhc2UoKVxyXG4gIH0pXHJcbn1cclxuXHJcbi8vIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXHJcbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplIChzKSB7XHJcbiAgcmV0dXJuIHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpXHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZSBwcm9wb3J0aW9uYWwgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgd2hlbiBuZWNlc3NhcnlcclxuZXhwb3J0IGZ1bmN0aW9uIHByb3BvcnRpb25hbFNpemUgKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGJveCkge1xyXG4gIGlmICh3aWR0aCA9PSBudWxsIHx8IGhlaWdodCA9PSBudWxsKSB7XHJcbiAgICBib3ggPSBib3ggfHwgZWxlbWVudC5iYm94KClcclxuXHJcbiAgICBpZiAod2lkdGggPT0gbnVsbCkge1xyXG4gICAgICB3aWR0aCA9IGJveC53aWR0aCAvIGJveC5oZWlnaHQgKiBoZWlnaHRcclxuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwpIHtcclxuICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodCAvIGJveC53aWR0aCAqIHdpZHRoXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgaGVpZ2h0OiBoZWlnaHRcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmlnaW4gKG8sIGVsZW1lbnQpIHtcclxuICAvLyBBbGxvdyBvcmlnaW4gb3IgYXJvdW5kIGFzIHRoZSBuYW1lc1xyXG4gIGNvbnN0IG9yaWdpbiA9IG8ub3JpZ2luIC8vIG8uYXJvdW5kID09IG51bGwgPyBvLm9yaWdpbiA6IG8uYXJvdW5kXHJcbiAgbGV0IG94LCBveVxyXG5cclxuICAvLyBBbGxvdyB0aGUgdXNlciB0byBwYXNzIGEgc3RyaW5nIHRvIHJvdGF0ZSBhcm91bmQgYSBnaXZlbiBwb2ludFxyXG4gIGlmICh0eXBlb2Ygb3JpZ2luID09PSAnc3RyaW5nJyB8fCBvcmlnaW4gPT0gbnVsbCkge1xyXG4gICAgLy8gR2V0IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnQgd2l0aCBubyB0cmFuc2Zvcm1hdGlvbnMgYXBwbGllZFxyXG4gICAgY29uc3Qgc3RyaW5nID0gKG9yaWdpbiB8fCAnY2VudGVyJykudG9Mb3dlckNhc2UoKS50cmltKClcclxuICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCwgeCwgeSB9ID0gZWxlbWVudC5iYm94KClcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRyYW5zZm9ybWVkIHggYW5kIHkgY29vcmRpbmF0ZXNcclxuICAgIGNvbnN0IGJ4ID0gc3RyaW5nLmluY2x1ZGVzKCdsZWZ0JykgPyB4XHJcbiAgICAgIDogc3RyaW5nLmluY2x1ZGVzKCdyaWdodCcpID8geCArIHdpZHRoXHJcbiAgICAgIDogeCArIHdpZHRoIC8gMlxyXG4gICAgY29uc3QgYnkgPSBzdHJpbmcuaW5jbHVkZXMoJ3RvcCcpID8geVxyXG4gICAgICA6IHN0cmluZy5pbmNsdWRlcygnYm90dG9tJykgPyB5ICsgaGVpZ2h0XHJcbiAgICAgIDogeSArIGhlaWdodCAvIDJcclxuXHJcbiAgICAvLyBTZXQgdGhlIGJvdW5kcyBlZyA6IFwiYm90dG9tLWxlZnRcIiwgXCJUb3AgcmlnaHRcIiwgXCJtaWRkbGVcIiBldGMuLi5cclxuICAgIG94ID0gby5veCAhPSBudWxsID8gby5veCA6IGJ4XHJcbiAgICBveSA9IG8ub3kgIT0gbnVsbCA/IG8ub3kgOiBieVxyXG4gIH0gZWxzZSB7XHJcbiAgICBveCA9IG9yaWdpblswXVxyXG4gICAgb3kgPSBvcmlnaW5bMV1cclxuICB9XHJcblxyXG4gIC8vIFJldHVybiB0aGUgb3JpZ2luIGFzIGl0IGlzIGlmIGl0IHdhc24ndCBhIHN0cmluZ1xyXG4gIHJldHVybiBbIG94LCBveSBdXHJcbn1cclxuIiwiLy8gRGVmYXVsdCBuYW1lc3BhY2VzXHJcbmV4cG9ydCBjb25zdCBucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZydcclxuZXhwb3J0IGNvbnN0IHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJ1xyXG5leHBvcnQgY29uc3QgeGxpbmsgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcclxuZXhwb3J0IGNvbnN0IHN2Z2pzID0gJ2h0dHA6Ly9zdmdqcy5jb20vc3ZnanMnXHJcbiIsImV4cG9ydCBjb25zdCBnbG9iYWxzID0ge1xyXG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93LFxyXG4gIGRvY3VtZW50OiB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGRvY3VtZW50XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcldpbmRvdyAod2luID0gbnVsbCwgZG9jID0gbnVsbCkge1xyXG4gIGdsb2JhbHMud2luZG93ID0gd2luXHJcbiAgZ2xvYmFscy5kb2N1bWVudCA9IGRvY1xyXG59XHJcblxyXG5jb25zdCBzYXZlID0ge31cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzYXZlV2luZG93ICgpIHtcclxuICBzYXZlLndpbmRvdyA9IGdsb2JhbHMud2luZG93XHJcbiAgc2F2ZS5kb2N1bWVudCA9IGdsb2JhbHMuZG9jdW1lbnRcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVXaW5kb3cgKCkge1xyXG4gIGdsb2JhbHMud2luZG93ID0gc2F2ZS53aW5kb3dcclxuICBnbG9iYWxzLmRvY3VtZW50ID0gc2F2ZS5kb2N1bWVudFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gd2l0aFdpbmRvdyAod2luLCBmbikge1xyXG4gIHNhdmVXaW5kb3coKVxyXG4gIHJlZ2lzdGVyV2luZG93KHdpbiwgd2luLmRvY3VtZW50KVxyXG4gIGZuKHdpbiwgd2luLmRvY3VtZW50KVxyXG4gIHJlc3RvcmVXaW5kb3coKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2luZG93ICgpIHtcclxuICByZXR1cm4gZ2xvYmFscy53aW5kb3dcclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2Uge1xyXG4gIC8vIGNvbnN0cnVjdG9yIChub2RlLyosIHtleHRlbnNpb25zID0gW119ICovKSB7XHJcbiAgLy8gICAvLyB0aGlzLnRhZ3MgPSBbXVxyXG4gIC8vICAgLy9cclxuICAvLyAgIC8vIGZvciAobGV0IGV4dGVuc2lvbiBvZiBleHRlbnNpb25zKSB7XHJcbiAgLy8gICAvLyAgIGV4dGVuc2lvbi5zZXR1cC5jYWxsKHRoaXMsIG5vZGUpXHJcbiAgLy8gICAvLyAgIHRoaXMudGFncy5wdXNoKGV4dGVuc2lvbi5uYW1lKVxyXG4gIC8vICAgLy8gfVxyXG4gIC8vIH1cclxufVxyXG4iLCJpbXBvcnQgeyBhZGRNZXRob2ROYW1lcyB9IGZyb20gJy4vbWV0aG9kcy5qcydcclxuaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gJy4vdXRpbHMuanMnXHJcbmltcG9ydCB7IG5zIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXHJcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXHJcbmltcG9ydCBCYXNlIGZyb20gJy4uL3R5cGVzL0Jhc2UuanMnXHJcblxyXG5jb25zdCBlbGVtZW50cyA9IHt9XHJcbmV4cG9ydCBjb25zdCByb290ID0gJ19fX1NZTUJPTF9fX1JPT1RfX18nXHJcblxyXG4vLyBNZXRob2QgZm9yIGVsZW1lbnQgY3JlYXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSAobmFtZSkge1xyXG4gIC8vIGNyZWF0ZSBlbGVtZW50XHJcbiAgcmV0dXJuIGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCBuYW1lKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFrZUluc3RhbmNlIChlbGVtZW50KSB7XHJcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCYXNlKSByZXR1cm4gZWxlbWVudFxyXG5cclxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gYWRvcHRlcihlbGVtZW50KVxyXG4gIH1cclxuXHJcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG5ldyBlbGVtZW50c1tyb290XSgpXHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnICYmIGVsZW1lbnQuY2hhckF0KDApICE9PSAnPCcpIHtcclxuICAgIHJldHVybiBhZG9wdGVyKGdsb2JhbHMuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KSlcclxuICB9XHJcblxyXG4gIHZhciBub2RlID0gY3JlYXRlKCdzdmcnKVxyXG4gIG5vZGUuaW5uZXJIVE1MID0gZWxlbWVudFxyXG5cclxuICAvLyBXZSBjYW4gdXNlIGZpcnN0Q2hpbGQgaGVyZSBiZWNhdXNlIHdlIGtub3csXHJcbiAgLy8gdGhhdCB0aGUgZmlyc3QgY2hhciBpcyA8IGFuZCB0aHVzIGFuIGVsZW1lbnRcclxuICBlbGVtZW50ID0gYWRvcHRlcihub2RlLmZpcnN0Q2hpbGQpXHJcblxyXG4gIHJldHVybiBlbGVtZW50XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBub2RlT3JOZXcgKG5hbWUsIG5vZGUpIHtcclxuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGdsb2JhbHMud2luZG93Lk5vZGUgPyBub2RlIDogY3JlYXRlKG5hbWUpXHJcbn1cclxuXHJcbi8vIEFkb3B0IGV4aXN0aW5nIHN2ZyBlbGVtZW50c1xyXG5leHBvcnQgZnVuY3Rpb24gYWRvcHQgKG5vZGUpIHtcclxuICAvLyBjaGVjayBmb3IgcHJlc2VuY2Ugb2Ygbm9kZVxyXG4gIGlmICghbm9kZSkgcmV0dXJuIG51bGxcclxuXHJcbiAgLy8gbWFrZSBzdXJlIGEgbm9kZSBpc24ndCBhbHJlYWR5IGFkb3B0ZWRcclxuICBpZiAobm9kZS5pbnN0YW5jZSBpbnN0YW5jZW9mIEJhc2UpIHJldHVybiBub2RlLmluc3RhbmNlXHJcblxyXG4gIC8vIGluaXRpYWxpemUgdmFyaWFibGVzXHJcbiAgdmFyIGNsYXNzTmFtZSA9IGNhcGl0YWxpemUobm9kZS5ub2RlTmFtZSB8fCAnRG9tJylcclxuXHJcbiAgLy8gTWFrZSBzdXJlIHRoYXQgZ3JhZGllbnRzIGFyZSBhZG9wdGVkIGNvcnJlY3RseVxyXG4gIGlmIChjbGFzc05hbWUgPT09ICdMaW5lYXJHcmFkaWVudCcgfHwgY2xhc3NOYW1lID09PSAnUmFkaWFsR3JhZGllbnQnKSB7XHJcbiAgICBjbGFzc05hbWUgPSAnR3JhZGllbnQnXHJcblxyXG4gIC8vIEZhbGxiYWNrIHRvIERvbSBpZiBlbGVtZW50IGlzIG5vdCBrbm93blxyXG4gIH0gZWxzZSBpZiAoIWVsZW1lbnRzW2NsYXNzTmFtZV0pIHtcclxuICAgIGNsYXNzTmFtZSA9ICdEb20nXHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IGVsZW1lbnRzW2NsYXNzTmFtZV0obm9kZSlcclxufVxyXG5cclxubGV0IGFkb3B0ZXIgPSBhZG9wdFxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vY2tBZG9wdCAobW9jayA9IGFkb3B0KSB7XHJcbiAgYWRvcHRlciA9IG1vY2tcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyIChlbGVtZW50LCBuYW1lID0gZWxlbWVudC5uYW1lLCBhc1Jvb3QgPSBmYWxzZSkge1xyXG4gIGVsZW1lbnRzW25hbWVdID0gZWxlbWVudFxyXG4gIGlmIChhc1Jvb3QpIGVsZW1lbnRzW3Jvb3RdID0gZWxlbWVudFxyXG5cclxuICBhZGRNZXRob2ROYW1lcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlbGVtZW50LnByb3RvdHlwZSkpXHJcblxyXG4gIHJldHVybiBlbGVtZW50XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzcyAobmFtZSkge1xyXG4gIHJldHVybiBlbGVtZW50c1tuYW1lXVxyXG59XHJcblxyXG4vLyBFbGVtZW50IGlkIHNlcXVlbmNlXHJcbmxldCBkaWQgPSAxMDAwXHJcblxyXG4vLyBHZXQgbmV4dCBuYW1lZCBlbGVtZW50IGlkXHJcbmV4cG9ydCBmdW5jdGlvbiBlaWQgKG5hbWUpIHtcclxuICByZXR1cm4gJ1N2Z2pzJyArIGNhcGl0YWxpemUobmFtZSkgKyAoZGlkKyspXHJcbn1cclxuXHJcbi8vIERlZXAgbmV3IGlkIGFzc2lnbm1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbk5ld0lkIChub2RlKSB7XHJcbiAgLy8gZG8gdGhlIHNhbWUgZm9yIFNWRyBjaGlsZCBub2RlcyBhcyB3ZWxsXHJcbiAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgIGFzc2lnbk5ld0lkKG5vZGUuY2hpbGRyZW5baV0pXHJcbiAgfVxyXG5cclxuICBpZiAobm9kZS5pZCkge1xyXG4gICAgcmV0dXJuIGFkb3B0KG5vZGUpLmlkKGVpZChub2RlLm5vZGVOYW1lKSlcclxuICB9XHJcblxyXG4gIHJldHVybiBhZG9wdChub2RlKVxyXG59XHJcblxyXG4vLyBNZXRob2QgZm9yIGV4dGVuZGluZyBvYmplY3RzXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQgKG1vZHVsZXMsIG1ldGhvZHMsIGF0dHJDaGVjaykge1xyXG4gIHZhciBrZXksIGlcclxuXHJcbiAgbW9kdWxlcyA9IEFycmF5LmlzQXJyYXkobW9kdWxlcykgPyBtb2R1bGVzIDogWyBtb2R1bGVzIF1cclxuXHJcbiAgZm9yIChpID0gbW9kdWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgZm9yIChrZXkgaW4gbWV0aG9kcykge1xyXG4gICAgICBsZXQgbWV0aG9kID0gbWV0aG9kc1trZXldXHJcbiAgICAgIGlmIChhdHRyQ2hlY2spIHtcclxuICAgICAgICBtZXRob2QgPSB3cmFwV2l0aEF0dHJDaGVjayhtZXRob2RzW2tleV0pXHJcbiAgICAgIH1cclxuICAgICAgbW9kdWxlc1tpXS5wcm90b3R5cGVba2V5XSA9IG1ldGhvZFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFdpdGhBdHRyQ2hlY2sgKC4uLmFyZ3MpIHtcclxuLy8gICBleHRlbmQoLi4uYXJncywgdHJ1ZSlcclxuLy8gfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBXaXRoQXR0ckNoZWNrIChmbikge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgY29uc3QgbyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXVxyXG5cclxuICAgIGlmIChvICYmIG8uY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiAhKG8gaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3Muc2xpY2UoMCwgLTEpKS5hdHRyKG8pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncylcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnZlbnQgKGNvbmZpZykge1xyXG4gIC8vIENyZWF0ZSBlbGVtZW50IGluaXRpYWxpemVyXHJcbiAgdmFyIGluaXRpYWxpemVyID0gdHlwZW9mIGNvbmZpZy5jcmVhdGUgPT09ICdmdW5jdGlvbidcclxuICAgID8gY29uZmlnLmNyZWF0ZVxyXG4gICAgOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yKG5vZGUgfHwgY3JlYXRlKGNvbmZpZy5jcmVhdGUpKVxyXG4gICAgfVxyXG5cclxuICAvLyBJbmhlcml0IHByb3RvdHlwZVxyXG4gIGlmIChjb25maWcuaW5oZXJpdCkge1xyXG4gICAgLyogZXNsaW50IG5ldy1jYXA6IG9mZiAqL1xyXG4gICAgaW5pdGlhbGl6ZXIucHJvdG90eXBlID0gbmV3IGNvbmZpZy5pbmhlcml0KClcclxuICAgIGluaXRpYWxpemVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGluaXRpYWxpemVyXHJcbiAgfVxyXG5cclxuICAvLyBFeHRlbmQgd2l0aCBtZXRob2RzXHJcbiAgaWYgKGNvbmZpZy5leHRlbmQpIHsgZXh0ZW5kKGluaXRpYWxpemVyLCBjb25maWcuZXh0ZW5kKSB9XHJcblxyXG4gIC8vIEF0dGFjaCBjb25zdHJ1Y3QgbWV0aG9kIHRvIHBhcmVudFxyXG4gIGlmIChjb25maWcuY29uc3RydWN0KSB7IGV4dGVuZChjb25maWcucGFyZW50IHx8IGVsZW1lbnRzLkNvbnRhaW5lciwgY29uZmlnLmNvbnN0cnVjdCkgfVxyXG5cclxuICByZXR1cm4gaW5pdGlhbGl6ZXJcclxufVxyXG4iLCJpbXBvcnQgeyBtYWtlSW5zdGFuY2UgfSBmcm9tICcuLi8uLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xyXG5cclxuLy8gR2V0IGFsbCBzaWJsaW5ncywgaW5jbHVkaW5nIG15c2VsZlxyXG5leHBvcnQgZnVuY3Rpb24gc2libGluZ3MgKCkge1xyXG4gIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKClcclxufVxyXG5cclxuLy8gR2V0IHRoZSBjdXJlbnQgcG9zaXRpb24gc2libGluZ3NcclxuZXhwb3J0IGZ1bmN0aW9uIHBvc2l0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5wYXJlbnQoKS5pbmRleCh0aGlzKVxyXG59XHJcblxyXG4vLyBHZXQgdGhlIG5leHQgZWxlbWVudCAod2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBub25lKVxyXG5leHBvcnQgZnVuY3Rpb24gbmV4dCAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgKyAxXVxyXG59XHJcblxyXG4vLyBHZXQgdGhlIG5leHQgZWxlbWVudCAod2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBub25lKVxyXG5leHBvcnQgZnVuY3Rpb24gcHJldiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgLSAxXVxyXG59XHJcblxyXG4vLyBTZW5kIGdpdmVuIGVsZW1lbnQgb25lIHN0ZXAgZm9yd2FyZFxyXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZCAoKSB7XHJcbiAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKCkgKyAxXHJcbiAgdmFyIHAgPSB0aGlzLnBhcmVudCgpXHJcblxyXG4gIC8vIG1vdmUgbm9kZSBvbmUgc3RlcCBmb3J3YXJkXHJcbiAgcC5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCBpKVxyXG5cclxuICAvLyBtYWtlIHN1cmUgZGVmcyBub2RlIGlzIGFsd2F5cyBhdCB0aGUgdG9wXHJcbiAgaWYgKHR5cGVvZiBwLmlzUm9vdCA9PT0gJ2Z1bmN0aW9uJyAmJiBwLmlzUm9vdCgpKSB7XHJcbiAgICBwLm5vZGUuYXBwZW5kQ2hpbGQocC5kZWZzKCkubm9kZSlcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBiYWNrd2FyZFxyXG5leHBvcnQgZnVuY3Rpb24gYmFja3dhcmQgKCkge1xyXG4gIHZhciBpID0gdGhpcy5wb3NpdGlvbigpXHJcblxyXG4gIGlmIChpID4gMCkge1xyXG4gICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCBpIC0gMSlcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgZnJvbnRcclxuZXhwb3J0IGZ1bmN0aW9uIGZyb250ICgpIHtcclxuICB2YXIgcCA9IHRoaXMucGFyZW50KClcclxuXHJcbiAgLy8gTW92ZSBub2RlIGZvcndhcmRcclxuICBwLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxyXG5cclxuICAvLyBNYWtlIHN1cmUgZGVmcyBub2RlIGlzIGFsd2F5cyBhdCB0aGUgdG9wXHJcbiAgaWYgKHR5cGVvZiBwLmlzUm9vdCA9PT0gJ2Z1bmN0aW9uJyAmJiBwLmlzUm9vdCgpKSB7XHJcbiAgICBwLm5vZGUuYXBwZW5kQ2hpbGQocC5kZWZzKCkubm9kZSlcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgYmFja1xyXG5leHBvcnQgZnVuY3Rpb24gYmFjayAoKSB7XHJcbiAgaWYgKHRoaXMucG9zaXRpb24oKSA+IDApIHtcclxuICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKS5hZGQodGhpcywgMClcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8vIEluc2VydHMgYSBnaXZlbiBlbGVtZW50IGJlZm9yZSB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlIChlbGVtZW50KSB7XHJcbiAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KVxyXG4gIGVsZW1lbnQucmVtb3ZlKClcclxuXHJcbiAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKClcclxuXHJcbiAgdGhpcy5wYXJlbnQoKS5hZGQoZWxlbWVudCwgaSlcclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLy8gSW5zZXJ0cyBhIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIHRhcmdldGVkIGVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyIChlbGVtZW50KSB7XHJcbiAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KVxyXG4gIGVsZW1lbnQucmVtb3ZlKClcclxuXHJcbiAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKClcclxuXHJcbiAgdGhpcy5wYXJlbnQoKS5hZGQoZWxlbWVudCwgaSArIDEpXHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRCZWZvcmUgKGVsZW1lbnQpIHtcclxuICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXHJcbiAgZWxlbWVudC5iZWZvcmUodGhpcylcclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIgKGVsZW1lbnQpIHtcclxuICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXHJcbiAgZWxlbWVudC5hZnRlcih0aGlzKVxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xyXG4gIHNpYmxpbmdzLFxyXG4gIHBvc2l0aW9uLFxyXG4gIG5leHQsXHJcbiAgcHJldixcclxuICBmb3J3YXJkLFxyXG4gIGJhY2t3YXJkLFxyXG4gIGZyb250LFxyXG4gIGJhY2ssXHJcbiAgYmVmb3JlLFxyXG4gIGFmdGVyLFxyXG4gIGluc2VydEJlZm9yZSxcclxuICBpbnNlcnRBZnRlclxyXG59KVxyXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZpbHRlcjtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnZmlsdGVyJykgfSwge1xuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhbWV0aG9kIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCxuby10aHJvdy1saXRlcmFsXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyB0aHJvdyAxOyB9LCAxKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIHNsb3BweUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Nsb3BweS1hcnJheS1tZXRob2QnKTtcblxudmFyIG5hdGl2ZUluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhbmF0aXZlSW5kZXhPZiAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcbnZhciBTTE9QUFlfTUVUSE9EID0gc2xvcHB5QXJyYXlNZXRob2QoJ2luZGV4T2YnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBORUdBVElWRV9aRVJPIHx8IFNMT1BQWV9NRVRIT0QgfSwge1xuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gbmF0aXZlSW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBzbG9wcHlBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJyk7XG5cbnZhciBuYXRpdmVKb2luID0gW10uam9pbjtcblxudmFyIEVTM19TVFJJTkdTID0gSW5kZXhlZE9iamVjdCAhPSBPYmplY3Q7XG52YXIgU0xPUFBZX01FVEhPRCA9IHNsb3BweUFycmF5TWV0aG9kKCdqb2luJywgJywnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5qb2luYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5qb2luXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBFUzNfU1RSSU5HUyB8fCBTTE9QUFlfTUVUSE9EIH0sIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmF0aXZlSm9pbi5jYWxsKHRvSW5kZXhlZE9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNwZWNpZXNjb25zdHJ1Y3RvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBjYWxsUmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgYXJyYXlQdXNoID0gW10ucHVzaDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBNQVhfVUlOVDMyID0gMHhGRkZGRkZGRjtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCd4JywgJ3knKSAtPiAveC95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciBTVVBQT1JUU19ZID0gIWZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuICFSZWdFeHAoTUFYX1VJTlQzMiwgJ3knKTsgfSk7XG5cbi8vIEBAc3BsaXQgbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChTUExJVCwgbmF0aXZlU3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcbiAgaWYgKFxuICAgICdhYmJjJy5zcGxpdCgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT0gNCB8fFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT0gNCB8fFxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDEgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGhcbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHJldHVybiBbc3RyaW5nXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbSk7XG4gICAgICB9XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4cEV4ZWMuY2FsbChzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IHNlcGFyYXRvckNvcHkubGFzdEluZGV4O1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkgYXJyYXlQdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW0pIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltID8gb3V0cHV0LnNsaWNlKDAsIGxpbSkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJy5zcGxpdCh1bmRlZmluZWQsIDApLmxlbmd0aCkge1xuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBuYXRpdmVTcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH0gZWxzZSBpbnRlcm5hbFNwbGl0ID0gbmF0aXZlU3BsaXQ7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzcGxpdHRlci5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpXG4gICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09IG5hdGl2ZVNwbGl0KTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XG5cbiAgICAgIHZhciB1bmljb2RlTWF0Y2hpbmcgPSByeC51bmljb2RlO1xuICAgICAgdmFyIGZsYWdzID0gKHJ4Lmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoU1VQUE9SVFNfWSA/ICd5JyA6ICdnJyk7XG5cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBTIHNsaWNpbmcsIHRvXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgQyhTVVBQT1JUU19ZID8gcnggOiAnXig/OicgKyByeC5zb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgaWYgKFMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFMpID09PSBudWxsID8gW1NdIDogW107XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgcSA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgd2hpbGUgKHEgPCBTLmxlbmd0aCkge1xuICAgICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBTVVBQT1JUU19ZID8gcSA6IDA7XG4gICAgICAgIHZhciB6ID0gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFNVUFBPUlRTX1kgPyBTIDogUy5zbGljZShxKSk7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgeiA9PT0gbnVsbCB8fFxuICAgICAgICAgIChlID0gbWluKHRvTGVuZ3RoKHNwbGl0dGVyLmxhc3RJbmRleCArIChTVVBQT1JUU19ZID8gMCA6IHEpKSwgUy5sZW5ndGgpKSA9PT0gcFxuICAgICAgICApIHtcbiAgICAgICAgICBxID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHEsIHVuaWNvZGVNYXRjaGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQS5wdXNoKFMuc2xpY2UocCwgcSkpO1xuICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB6Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgQS5wdXNoKHpbaV0pO1xuICAgICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxID0gcCA9IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEEucHVzaChTLnNsaWNlKHApKTtcbiAgICAgIHJldHVybiBBO1xuICAgIH1cbiAgXTtcbn0sICFTVVBQT1JUU19ZKTtcbiIsIi8vIFBhcnNlIHVuaXQgdmFsdWVcclxuZXhwb3J0IGNvbnN0IG51bWJlckFuZFVuaXQgPSAvXihbKy1dPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8pKFthLXolXSopJC9pXHJcblxyXG4vLyBQYXJzZSBoZXggdmFsdWVcclxuZXhwb3J0IGNvbnN0IGhleCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2lcclxuXHJcbi8vIFBhcnNlIHJnYiB2YWx1ZVxyXG5leHBvcnQgY29uc3QgcmdiID0gL3JnYlxcKChcXGQrKSwoXFxkKyksKFxcZCspXFwpL1xyXG5cclxuLy8gUGFyc2UgcmVmZXJlbmNlIGlkXHJcbmV4cG9ydCBjb25zdCByZWZlcmVuY2UgPSAvKCNbYS16MC05XFwtX10rKS9pXHJcblxyXG4vLyBzcGxpdHMgYSB0cmFuc2Zvcm1hdGlvbiBjaGFpblxyXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtcyA9IC9cXClcXHMqLD9cXHMqL1xyXG5cclxuLy8gV2hpdGVzcGFjZVxyXG5leHBvcnQgY29uc3Qgd2hpdGVzcGFjZSA9IC9cXHMvZ1xyXG5cclxuLy8gVGVzdCBoZXggdmFsdWVcclxuZXhwb3J0IGNvbnN0IGlzSGV4ID0gL14jW2EtZjAtOV17Myw2fSQvaVxyXG5cclxuLy8gVGVzdCByZ2IgdmFsdWVcclxuZXhwb3J0IGNvbnN0IGlzUmdiID0gL15yZ2JcXCgvXHJcblxyXG4vLyBUZXN0IGNzcyBkZWNsYXJhdGlvblxyXG5leHBvcnQgY29uc3QgaXNDc3MgPSAvW146XSs6W147XSs7Py9cclxuXHJcbi8vIFRlc3QgZm9yIGJsYW5rIHN0cmluZ1xyXG5leHBvcnQgY29uc3QgaXNCbGFuayA9IC9eKFxccyspPyQvXHJcblxyXG4vLyBUZXN0IGZvciBudW1lcmljIHN0cmluZ1xyXG5leHBvcnQgY29uc3QgaXNOdW1iZXIgPSAvXlsrLV0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaVxyXG5cclxuLy8gVGVzdCBmb3IgcGVyY2VudCB2YWx1ZVxyXG5leHBvcnQgY29uc3QgaXNQZXJjZW50ID0gL14tP1tcXGQuXSslJC9cclxuXHJcbi8vIFRlc3QgZm9yIGltYWdlIHVybFxyXG5leHBvcnQgY29uc3QgaXNJbWFnZSA9IC9cXC4oanBnfGpwZWd8cG5nfGdpZnxzdmcpKFxcP1tePV0rLiopPy9pXHJcblxyXG4vLyBzcGxpdCBhdCB3aGl0ZXNwYWNlIGFuZCBjb21tYVxyXG5leHBvcnQgY29uc3QgZGVsaW1pdGVyID0gL1tcXHMsXSsvXHJcblxyXG4vLyBUaGUgZm9sbG93aW5nIHJlZ2V4IGFyZSB1c2VkIHRvIHBhcnNlIHRoZSBkIGF0dHJpYnV0ZSBvZiBhIHBhdGhcclxuXHJcbi8vIE1hdGNoZXMgYWxsIGh5cGhlbnMgd2hpY2ggYXJlIG5vdCBhZnRlciBhbiBleHBvbmVudFxyXG5leHBvcnQgY29uc3QgaHlwaGVuID0gLyhbXmVdKS0vZ2lcclxuXHJcbi8vIFJlcGxhY2VzIGFuZCB0ZXN0cyBmb3IgYWxsIHBhdGggbGV0dGVyc1xyXG5leHBvcnQgY29uc3QgcGF0aExldHRlcnMgPSAvW01MSFZDU1FUQVpdL2dpXHJcblxyXG4vLyB5ZXMgd2UgbmVlZCB0aGlzIG9uZSwgdG9vXHJcbmV4cG9ydCBjb25zdCBpc1BhdGhMZXR0ZXIgPSAvW01MSFZDU1FUQVpdL2lcclxuXHJcbi8vIG1hdGNoZXMgMC4xNTQuMjMuNDVcclxuZXhwb3J0IGNvbnN0IG51bWJlcnNXaXRoRG90cyA9IC8oKFxcZD9cXC5cXGQrKD86ZVsrLV0/XFxkKyk/KSgoPzpcXC5cXGQrKD86ZVsrLV0/XFxkKyk/KSspKSsvZ2lcclxuXHJcbi8vIG1hdGNoZXMgLlxyXG5leHBvcnQgY29uc3QgZG90cyA9IC9cXC4vZ1xyXG4iLCJpbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tICcuLi9jb3JlL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xyXG5cclxuLy8gUmV0dXJuIGFycmF5IG9mIGNsYXNzZXMgb24gdGhlIG5vZGVcclxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzZXMgKCkge1xyXG4gIHZhciBhdHRyID0gdGhpcy5hdHRyKCdjbGFzcycpXHJcbiAgcmV0dXJuIGF0dHIgPT0gbnVsbCA/IFtdIDogYXR0ci50cmltKCkuc3BsaXQoZGVsaW1pdGVyKVxyXG59XHJcblxyXG4vLyBSZXR1cm4gdHJ1ZSBpZiBjbGFzcyBleGlzdHMgb24gdGhlIG5vZGUsIGZhbHNlIG90aGVyd2lzZVxyXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MgKG5hbWUpIHtcclxuICByZXR1cm4gdGhpcy5jbGFzc2VzKCkuaW5kZXhPZihuYW1lKSAhPT0gLTFcclxufVxyXG5cclxuLy8gQWRkIGNsYXNzIHRvIHRoZSBub2RlXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyAobmFtZSkge1xyXG4gIGlmICghdGhpcy5oYXNDbGFzcyhuYW1lKSkge1xyXG4gICAgdmFyIGFycmF5ID0gdGhpcy5jbGFzc2VzKClcclxuICAgIGFycmF5LnB1c2gobmFtZSlcclxuICAgIHRoaXMuYXR0cignY2xhc3MnLCBhcnJheS5qb2luKCcgJykpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vLyBSZW1vdmUgY2xhc3MgZnJvbSB0aGUgbm9kZVxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKG5hbWUpIHtcclxuICBpZiAodGhpcy5oYXNDbGFzcyhuYW1lKSkge1xyXG4gICAgdGhpcy5hdHRyKCdjbGFzcycsIHRoaXMuY2xhc3NlcygpLmZpbHRlcihmdW5jdGlvbiAoYykge1xyXG4gICAgICByZXR1cm4gYyAhPT0gbmFtZVxyXG4gICAgfSkuam9pbignICcpKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLy8gVG9nZ2xlIHRoZSBwcmVzZW5jZSBvZiBhIGNsYXNzIG9uIHRoZSBub2RlXHJcbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVDbGFzcyAobmFtZSkge1xyXG4gIHJldHVybiB0aGlzLmhhc0NsYXNzKG5hbWUpID8gdGhpcy5yZW1vdmVDbGFzcyhuYW1lKSA6IHRoaXMuYWRkQ2xhc3MobmFtZSlcclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7XHJcbiAgY2xhc3NlcywgaGFzQ2xhc3MsIGFkZENsYXNzLCByZW1vdmVDbGFzcywgdG9nZ2xlQ2xhc3NcclxufSlcclxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZvckVhY2g7XG52YXIgc2xvcHB5QXJyYXlNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbm1vZHVsZS5leHBvcnRzID0gc2xvcHB5QXJyYXlNZXRob2QoJ2ZvckVhY2gnKSA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0gOiBbXS5mb3JFYWNoO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mb3ItZWFjaCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFtdLmZvckVhY2ggIT0gZm9yRWFjaCB9LCB7XG4gIGZvckVhY2g6IGZvckVhY2hcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBET01JdGVyYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcycpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2gnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUgJiYgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoICE9PSBmb3JFYWNoKSB0cnkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCAnZm9yRWFjaCcsIGZvckVhY2gpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCA9IGZvckVhY2g7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgeyBpc0JsYW5rIH0gZnJvbSAnLi4vY29yZS9yZWdleC5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuXHJcbi8vIER5bmFtaWMgc3R5bGUgZ2VuZXJhdG9yXHJcbmV4cG9ydCBmdW5jdGlvbiBjc3MgKHN0eWxlLCB2YWwpIHtcclxuICBjb25zdCByZXQgPSB7fVxyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAvLyBnZXQgZnVsbCBzdHlsZSBhcyBvYmplY3RcclxuICAgIHRoaXMubm9kZS5zdHlsZS5jc3NUZXh0LnNwbGl0KC9cXHMqO1xccyovKVxyXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHJldHVybiAhIWVsLmxlbmd0aFxyXG4gICAgICB9KVxyXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBjb25zdCB0ID0gZWwuc3BsaXQoL1xccyo6XFxzKi8pXHJcbiAgICAgICAgcmV0W3RbMF1dID0gdFsxXVxyXG4gICAgICB9KVxyXG4gICAgcmV0dXJuIHJldFxyXG4gIH1cclxuXHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAvLyBnZXQgc3R5bGUgcHJvcGVydGllcyBpbiB0aGUgYXJyYXlcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkge1xyXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc3R5bGUpIHtcclxuICAgICAgICBjb25zdCBjYXNlZCA9IGNhbWVsQ2FzZShuYW1lKVxyXG4gICAgICAgIHJldFtjYXNlZF0gPSB0aGlzLm5vZGUuc3R5bGVbY2FzZWRdXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJldFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCBzdHlsZSBmb3IgcHJvcGVydHlcclxuICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKHN0eWxlKV1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgc3R5bGVzIGluIG9iamVjdFxyXG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHN0eWxlKSB7XHJcbiAgICAgICAgLy8gc2V0IGVtcHR5IHN0cmluZyBpZiBudWxsL3VuZGVmaW5lZC8nJyB3YXMgZ2l2ZW5cclxuICAgICAgICB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKG5hbWUpXVxyXG4gICAgICAgICAgPSAoc3R5bGVbbmFtZV0gPT0gbnVsbCB8fCBpc0JsYW5rLnRlc3Qoc3R5bGVbbmFtZV0pKSA/ICcnIDogc3R5bGVbbmFtZV1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gc2V0IHN0eWxlIGZvciBwcm9wZXJ0eVxyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKHN0eWxlKV1cclxuICAgICAgPSAodmFsID09IG51bGwgfHwgaXNCbGFuay50ZXN0KHZhbCkpID8gJycgOiB2YWxcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8vIFNob3cgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gc2hvdyAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuY3NzKCdkaXNwbGF5JywgJycpXHJcbn1cclxuXHJcbi8vIEhpZGUgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gaGlkZSAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKVxyXG59XHJcblxyXG4vLyBJcyBlbGVtZW50IHZpc2libGU/XHJcbmV4cG9ydCBmdW5jdGlvbiB2aXNpYmxlICgpIHtcclxuICByZXR1cm4gdGhpcy5jc3MoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnXHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xyXG4gIGNzcywgc2hvdywgaGlkZSwgdmlzaWJsZVxyXG59KVxyXG4iLCJpbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xyXG5cclxuLy8gU3RvcmUgZGF0YSB2YWx1ZXMgb24gc3ZnIG5vZGVzXHJcbmV4cG9ydCBmdW5jdGlvbiBkYXRhIChhLCB2LCByKSB7XHJcbiAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xyXG4gICAgZm9yICh2IGluIGEpIHtcclxuICAgICAgdGhpcy5kYXRhKHYsIGFbdl0pXHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5hdHRyKCdkYXRhLScgKyBhKSlcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignZGF0YS0nICsgYSlcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5hdHRyKCdkYXRhLScgKyBhLFxyXG4gICAgICB2ID09PSBudWxsID8gbnVsbFxyXG4gICAgICA6IHIgPT09IHRydWUgfHwgdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IHZcclxuICAgICAgOiBKU09OLnN0cmluZ2lmeSh2KVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7IGRhdGEgfSlcclxuIiwiaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuXHJcbi8vIFJlbWVtYmVyIGFyYml0cmFyeSBkYXRhXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1lbWJlciAoaywgdikge1xyXG4gIC8vIHJlbWVtYmVyIGV2ZXJ5IGl0ZW0gaW4gYW4gb2JqZWN0IGluZGl2aWR1YWxseVxyXG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xyXG4gICAgZm9yICh2YXIga2V5IGluIGspIHtcclxuICAgICAgdGhpcy5yZW1lbWJlcihrZXksIGtba2V5XSlcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgIC8vIHJldHJpZXZlIG1lbW9yeVxyXG4gICAgcmV0dXJuIHRoaXMubWVtb3J5KClba11cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gc3RvcmUgbWVtb3J5XHJcbiAgICB0aGlzLm1lbW9yeSgpW2tdID0gdlxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLy8gRXJhc2UgYSBnaXZlbiBtZW1vcnlcclxuZXhwb3J0IGZ1bmN0aW9uIGZvcmdldCAoKSB7XHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgIHRoaXMuX21lbW9yeSA9IHt9XHJcbiAgfSBlbHNlIHtcclxuICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgZGVsZXRlIHRoaXMubWVtb3J5KClbYXJndW1lbnRzW2ldXVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vLyBUaGlzIHRyaWdnZXJzIGNyZWF0aW9uIG9mIGEgbmV3IGhpZGRlbiBjbGFzcyB3aGljaCBpcyBub3QgcGVyZm9ybWFudFxyXG4vLyBIb3dldmVyLCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCByYXJlbHkgdXNlZCBzbyBpdCB3aWxsIG5vdCBoYXBwZW4gZnJlcXVlbnRseVxyXG4vLyBSZXR1cm4gbG9jYWwgbWVtb3J5IG9iamVjdFxyXG5leHBvcnQgZnVuY3Rpb24gbWVtb3J5ICgpIHtcclxuICByZXR1cm4gKHRoaXMuX21lbW9yeSA9IHRoaXMuX21lbW9yeSB8fCB7fSlcclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7IHJlbWVtYmVyLCBmb3JnZXQsIG1lbW9yeSB9KVxyXG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgIHZhciBpID0gSVNfUklHSFQgPyAtMSA6IDE7XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7SVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiAgbGVmdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1yZWR1Y2UnKS5sZWZ0O1xudmFyIHNsb3BweUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Nsb3BweS1hcnJheS1tZXRob2QnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogc2xvcHB5QXJyYXlNZXRob2QoJ3JlZHVjZScpIH0sIHtcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCJpbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tICcuL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgeyBtYWtlSW5zdGFuY2UgfSBmcm9tICcuLi8uLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5cclxubGV0IGxpc3RlbmVySWQgPSAwXHJcbmNvbnN0IHdpbmRvd0V2ZW50cyA9IHt9XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudHMgKGluc3RhbmNlKSB7XHJcbiAgbGV0IG4gPSBpbnN0YW5jZS5nZXRFdmVudEhvbGRlcigpXHJcblxyXG4gIC8vIFdlIGRvbnQgd2FudCB0byBzYXZlIGV2ZW50cyBpbiBnbG9iYWwgc3BhY2VcclxuICBpZiAobiA9PT0gZ2xvYmFscy53aW5kb3cpIG4gPSB3aW5kb3dFdmVudHNcclxuICBpZiAoIW4uZXZlbnRzKSBuLmV2ZW50cyA9IHt9XHJcbiAgcmV0dXJuIG4uZXZlbnRzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0IChpbnN0YW5jZSkge1xyXG4gIHJldHVybiBpbnN0YW5jZS5nZXRFdmVudFRhcmdldCgpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsZWFyRXZlbnRzIChpbnN0YW5jZSkge1xyXG4gIGNvbnN0IG4gPSBpbnN0YW5jZS5nZXRFdmVudEhvbGRlcigpXHJcbiAgaWYgKG4uZXZlbnRzKSBuLmV2ZW50cyA9IHt9XHJcbn1cclxuXHJcbi8vIEFkZCBldmVudCBiaW5kZXIgaW4gdGhlIFNWRyBuYW1lc3BhY2VcclxuZXhwb3J0IGZ1bmN0aW9uIG9uIChub2RlLCBldmVudHMsIGxpc3RlbmVyLCBiaW5kaW5nLCBvcHRpb25zKSB7XHJcbiAgdmFyIGwgPSBsaXN0ZW5lci5iaW5kKGJpbmRpbmcgfHwgbm9kZSlcclxuICB2YXIgaW5zdGFuY2UgPSBtYWtlSW5zdGFuY2Uobm9kZSlcclxuICB2YXIgYmFnID0gZ2V0RXZlbnRzKGluc3RhbmNlKVxyXG4gIHZhciBuID0gZ2V0RXZlbnRUYXJnZXQoaW5zdGFuY2UpXHJcblxyXG4gIC8vIGV2ZW50cyBjYW4gYmUgYW4gYXJyYXkgb2YgZXZlbnRzIG9yIGEgc3RyaW5nIG9mIGV2ZW50c1xyXG4gIGV2ZW50cyA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdChkZWxpbWl0ZXIpXHJcblxyXG4gIC8vIGFkZCBpZCB0byBsaXN0ZW5lclxyXG4gIGlmICghbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZCkge1xyXG4gICAgbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZCA9ICsrbGlzdGVuZXJJZFxyXG4gIH1cclxuXHJcbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICB2YXIgZXYgPSBldmVudC5zcGxpdCgnLicpWzBdXHJcbiAgICB2YXIgbnMgPSBldmVudC5zcGxpdCgnLicpWzFdIHx8ICcqJ1xyXG5cclxuICAgIC8vIGVuc3VyZSB2YWxpZCBvYmplY3RcclxuICAgIGJhZ1tldl0gPSBiYWdbZXZdIHx8IHt9XHJcbiAgICBiYWdbZXZdW25zXSA9IGJhZ1tldl1bbnNdIHx8IHt9XHJcblxyXG4gICAgLy8gcmVmZXJlbmNlIGxpc3RlbmVyXHJcbiAgICBiYWdbZXZdW25zXVtsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkXSA9IGxcclxuXHJcbiAgICAvLyBhZGQgbGlzdGVuZXJcclxuICAgIG4uYWRkRXZlbnRMaXN0ZW5lcihldiwgbCwgb3B0aW9ucyB8fCBmYWxzZSlcclxuICB9KVxyXG59XHJcblxyXG4vLyBBZGQgZXZlbnQgdW5iaW5kZXIgaW4gdGhlIFNWRyBuYW1lc3BhY2VcclxuZXhwb3J0IGZ1bmN0aW9uIG9mZiAobm9kZSwgZXZlbnRzLCBsaXN0ZW5lciwgb3B0aW9ucykge1xyXG4gIHZhciBpbnN0YW5jZSA9IG1ha2VJbnN0YW5jZShub2RlKVxyXG4gIHZhciBiYWcgPSBnZXRFdmVudHMoaW5zdGFuY2UpXHJcbiAgdmFyIG4gPSBnZXRFdmVudFRhcmdldChpbnN0YW5jZSlcclxuXHJcbiAgLy8gbGlzdGVuZXIgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYSBudW1iZXJcclxuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWRcclxuICAgIGlmICghbGlzdGVuZXIpIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLy8gZXZlbnRzIGNhbiBiZSBhbiBhcnJheSBvZiBldmVudHMgb3IgYSBzdHJpbmcgb3IgdW5kZWZpbmVkXHJcbiAgZXZlbnRzID0gQXJyYXkuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogKGV2ZW50cyB8fCAnJykuc3BsaXQoZGVsaW1pdGVyKVxyXG5cclxuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHZhciBldiA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMF1cclxuICAgIHZhciBucyA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMV1cclxuICAgIHZhciBuYW1lc3BhY2UsIGxcclxuXHJcbiAgICBpZiAobGlzdGVuZXIpIHtcclxuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyIHJlZmVyZW5jZVxyXG4gICAgICBpZiAoYmFnW2V2XSAmJiBiYWdbZXZdW25zIHx8ICcqJ10pIHtcclxuICAgICAgICAvLyByZW1vdmVMaXN0ZW5lclxyXG4gICAgICAgIG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgYmFnW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXSwgb3B0aW9ucyB8fCBmYWxzZSlcclxuXHJcbiAgICAgICAgZGVsZXRlIGJhZ1tldl1bbnMgfHwgJyonXVtsaXN0ZW5lcl1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChldiAmJiBucykge1xyXG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYSBuYW1lc3BhY2VkIGV2ZW50XHJcbiAgICAgIGlmIChiYWdbZXZdICYmIGJhZ1tldl1bbnNdKSB7XHJcbiAgICAgICAgZm9yIChsIGluIGJhZ1tldl1bbnNdKSB7XHJcbiAgICAgICAgICBvZmYobiwgWyBldiwgbnMgXS5qb2luKCcuJyksIGwpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWxldGUgYmFnW2V2XVtuc11cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChucykge1xyXG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBuYW1lc3BhY2VcclxuICAgICAgZm9yIChldmVudCBpbiBiYWcpIHtcclxuICAgICAgICBmb3IgKG5hbWVzcGFjZSBpbiBiYWdbZXZlbnRdKSB7XHJcbiAgICAgICAgICBpZiAobnMgPT09IG5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICBvZmYobiwgWyBldmVudCwgbnMgXS5qb2luKCcuJykpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGV2KSB7XHJcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnRcclxuICAgICAgaWYgKGJhZ1tldl0pIHtcclxuICAgICAgICBmb3IgKG5hbWVzcGFjZSBpbiBiYWdbZXZdKSB7XHJcbiAgICAgICAgICBvZmYobiwgWyBldiwgbmFtZXNwYWNlIF0uam9pbignLicpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVsZXRlIGJhZ1tldl1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gYSBnaXZlbiBub2RlXHJcbiAgICAgIGZvciAoZXZlbnQgaW4gYmFnKSB7XHJcbiAgICAgICAgb2ZmKG4sIGV2ZW50KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjbGVhckV2ZW50cyhpbnN0YW5jZSlcclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2ggKG5vZGUsIGV2ZW50LCBkYXRhKSB7XHJcbiAgdmFyIG4gPSBnZXRFdmVudFRhcmdldChub2RlKVxyXG5cclxuICAvLyBEaXNwYXRjaCBldmVudFxyXG4gIGlmIChldmVudCBpbnN0YW5jZW9mIGdsb2JhbHMud2luZG93LkV2ZW50KSB7XHJcbiAgICBuLmRpc3BhdGNoRXZlbnQoZXZlbnQpXHJcbiAgfSBlbHNlIHtcclxuICAgIGV2ZW50ID0gbmV3IGdsb2JhbHMud2luZG93LkN1c3RvbUV2ZW50KGV2ZW50LCB7IGRldGFpbDogZGF0YSwgY2FuY2VsYWJsZTogdHJ1ZSB9KVxyXG4gICAgbi5kaXNwYXRjaEV2ZW50KGV2ZW50KVxyXG4gIH1cclxuICByZXR1cm4gZXZlbnRcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92OC12ZXJzaW9uJyk7XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHdlbGxLbm93blN5bWJvbCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7XG52YXIgTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCc7XG5cbi8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG59KTtcblxudmFyIFNQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2NvbmNhdCcpO1xuXG52YXIgaXNDb25jYXRTcHJlYWRhYmxlID0gZnVuY3Rpb24gKE8pIHtcbiAgaWYgKCFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3ByZWFkYWJsZSA9IE9bSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShPKTtcbn07XG5cbnZhciBGT1JDRUQgPSAhSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCB8fCAhU1BFQ0lFU19TVVBQT1JUO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29uY2F0XG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAaXNDb25jYXRTcHJlYWRhYmxlIGFuZCBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KGFyZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuICAgIGZvciAoaSA9IC0xLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoaXNDb25jYXRTcHJlYWRhYmxlKEUpKSB7XG4gICAgICAgIGxlbiA9IHRvTGVuZ3RoKEUubGVuZ3RoKTtcbiAgICAgICAgaWYgKG4gKyBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrLCBuKyspIGlmIChrIGluIEUpIGNyZWF0ZVByb3BlcnR5KEEsIG4sIEVba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG4gPj0gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KEEsIG4rKywgRSk7XG4gICAgICB9XG4gICAgfVxuICAgIEEubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkbWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLm1hcDtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnbWFwJykgfSwge1xuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcblxudmFyIERhdGVQcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIG5hdGl2ZURhdGVUb1N0cmluZyA9IERhdGVQcm90b3R5cGVbVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvdHlwZS5nZXRUaW1lO1xuXG4vLyBgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0ZS5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKSB7XG4gIHJlZGVmaW5lKERhdGVQcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gbmF0aXZlRGF0ZVRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgbmF0aXZlUGFyc2VJbnQgPSBnbG9iYWwucGFyc2VJbnQ7XG52YXIgaGV4ID0gL15bKy1dPzBbWHhdLztcbnZhciBGT1JDRUQgPSBuYXRpdmVQYXJzZUludCh3aGl0ZXNwYWNlcyArICcwOCcpICE9PSA4IHx8IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzB4MTYnKSAhPT0gMjI7XG5cbi8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcbm1vZHVsZS5leHBvcnRzID0gRk9SQ0VEID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCkge1xuICB2YXIgUyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoUywgKHJhZGl4ID4+PiAwKSB8fCAoaGV4LnRlc3QoUykgPyAxNiA6IDEwKSk7XG59IDogbmF0aXZlUGFyc2VJbnQ7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBwYXJzZUludEltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhcnNlLWludCcpO1xuXG4vLyBgcGFyc2VJbnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcGFyc2VpbnQtc3RyaW5nLXJhZGl4XG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlSW50ICE9IHBhcnNlSW50SW1wbGVtZW50YXRpb24gfSwge1xuICBwYXJzZUludDogcGFyc2VJbnRJbXBsZW1lbnRhdGlvblxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGZsYWdzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFncycpO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG5hdGl2ZVRvU3RyaW5nID0gUmVnRXhwUHJvdG90eXBlW1RPX1NUUklOR107XG5cbnZhciBOT1RfR0VORVJJQyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IG5hdGl2ZVRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoTk9UX0dFTkVSSUMgfHwgSU5DT1JSRUNUX05BTUUpIHtcbiAgcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwID0gU3RyaW5nKFIuc291cmNlKTtcbiAgICB2YXIgcmYgPSBSLmZsYWdzO1xuICAgIHZhciBmID0gU3RyaW5nKHJmID09PSB1bmRlZmluZWQgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlKSA/IGZsYWdzLmNhbGwoUikgOiByZik7XG4gICAgcmV0dXJuICcvJyArIHAgKyAnLycgKyBmO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICghKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59IiwiaW1wb3J0IGFycmF5V2l0aEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aEhvbGVzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5TGltaXQgZnJvbSBcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIjtcbmltcG9ydCBub25JdGVyYWJsZVJlc3QgZnJvbSBcIi4vbm9uSXRlcmFibGVSZXN0XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn0iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59IiwiXHJcbmltcG9ydCB7IGhleCwgaXNIZXgsIGlzUmdiLCByZ2IsIHdoaXRlc3BhY2UgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXHJcblxyXG5mdW5jdGlvbiBzaXhEaWdpdEhleCAoaGV4KSB7XHJcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDRcclxuICAgID8gWyAnIycsXHJcbiAgICAgIGhleC5zdWJzdHJpbmcoMSwgMiksIGhleC5zdWJzdHJpbmcoMSwgMiksXHJcbiAgICAgIGhleC5zdWJzdHJpbmcoMiwgMyksIGhleC5zdWJzdHJpbmcoMiwgMyksXHJcbiAgICAgIGhleC5zdWJzdHJpbmcoMywgNCksIGhleC5zdWJzdHJpbmcoMywgNClcclxuICAgIF0uam9pbignJylcclxuICAgIDogaGV4XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvbmVudEhleCAoY29tcG9uZW50KSB7XHJcbiAgY29uc3QgaW50ZWdlciA9IE1hdGgucm91bmQoY29tcG9uZW50KVxyXG4gIGNvbnN0IGJvdW5kZWQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGludGVnZXIpKVxyXG4gIGNvbnN0IGhleCA9IGJvdW5kZWQudG9TdHJpbmcoMTYpXHJcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXhcclxufVxyXG5cclxuZnVuY3Rpb24gaXMgKG9iamVjdCwgc3BhY2UpIHtcclxuICBmb3IgKGxldCBpID0gc3BhY2UubGVuZ3RoOyBpLS07KSB7XHJcbiAgICBpZiAob2JqZWN0W3NwYWNlW2ldXSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJzIChhLCBiKSB7XHJcbiAgY29uc3QgcGFyYW1zID0gaXMoYSwgJ3JnYicpID8geyBfYTogYS5yLCBfYjogYS5nLCBfYzogYS5iLCBzcGFjZTogJ3JnYicgfVxyXG4gICAgOiBpcyhhLCAneHl6JykgPyB7IF9hOiBhLngsIF9iOiBhLnksIF9jOiBhLnosIF9kOiAwLCBzcGFjZTogJ3h5eicgfVxyXG4gICAgOiBpcyhhLCAnaHNsJykgPyB7IF9hOiBhLmgsIF9iOiBhLnMsIF9jOiBhLmwsIF9kOiAwLCBzcGFjZTogJ2hzbCcgfVxyXG4gICAgOiBpcyhhLCAnbGFiJykgPyB7IF9hOiBhLmwsIF9iOiBhLmEsIF9jOiBhLmIsIF9kOiAwLCBzcGFjZTogJ2xhYicgfVxyXG4gICAgOiBpcyhhLCAnbGNoJykgPyB7IF9hOiBhLmwsIF9iOiBhLmMsIF9jOiBhLmgsIF9kOiAwLCBzcGFjZTogJ2xjaCcgfVxyXG4gICAgOiBpcyhhLCAnY215aycpID8geyBfYTogYS5jLCBfYjogYS5tLCBfYzogYS55LCBfZDogYS5rLCBzcGFjZTogJ2NteWsnIH1cclxuICAgIDogeyBfYTogMCwgX2I6IDAsIF9jOiAwLCBzcGFjZTogJ3JnYicgfVxyXG5cclxuICBwYXJhbXMuc3BhY2UgPSBiIHx8IHBhcmFtcy5zcGFjZVxyXG4gIHJldHVybiBwYXJhbXNcclxufVxyXG5cclxuZnVuY3Rpb24gY2llU3BhY2UgKHNwYWNlKSB7XHJcbiAgaWYgKHNwYWNlID09PSAnbGFiJyB8fCBzcGFjZSA9PT0gJ3h5eicgfHwgc3BhY2UgPT09ICdsY2gnKSB7XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGh1ZVRvUmdiIChwLCBxLCB0KSB7XHJcbiAgaWYgKHQgPCAwKSB0ICs9IDFcclxuICBpZiAodCA+IDEpIHQgLT0gMVxyXG4gIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0XHJcbiAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHFcclxuICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDZcclxuICByZXR1cm4gcFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvciB7XHJcbiAgY29uc3RydWN0b3IgKC4uLmlucHV0cykge1xyXG4gICAgdGhpcy5pbml0KC4uLmlucHV0cylcclxuICB9XHJcblxyXG4gIGluaXQgKGEgPSAwLCBiID0gMCwgYyA9IDAsIGQgPSAwLCBzcGFjZSA9ICdyZ2InKSB7XHJcbiAgICAvLyBUaGlzIGNhdGNoZXMgdGhlIGNhc2Ugd2hlbiBhIGZhbHN5IHZhbHVlIGlzIHBhc3NlZCBsaWtlICcnXHJcbiAgICBhID0gIWEgPyAwIDogYVxyXG5cclxuICAgIC8vIFJlc2V0IGFsbCB2YWx1ZXMgaW4gY2FzZSB0aGUgaW5pdCBmdW5jdGlvbiBpcyByZXJ1biB3aXRoIG5ldyBjb2xvciBzcGFjZVxyXG4gICAgaWYgKHRoaXMuc3BhY2UpIHtcclxuICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgaW4gdGhpcy5zcGFjZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzW3RoaXMuc3BhY2VbY29tcG9uZW50XV1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgLy8gQWxsb3cgZm9yIHRoZSBjYXNlIHRoYXQgd2UgZG9uJ3QgbmVlZCBkLi4uXHJcbiAgICAgIHNwYWNlID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6IHNwYWNlXHJcbiAgICAgIGQgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAwIDogZFxyXG5cclxuICAgICAgLy8gQXNzaWduIHRoZSB2YWx1ZXMgc3RyYWlnaHQgdG8gdGhlIGNvbG9yXHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBfYTogYSwgX2I6IGIsIF9jOiBjLCBfZDogZCwgc3BhY2UgfSlcclxuICAgIC8vIElmIHRoZSB1c2VyIGdhdmUgdXMgYW4gYXJyYXksIG1ha2UgdGhlIGNvbG9yIGZyb20gaXRcclxuICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgIHRoaXMuc3BhY2UgPSBiIHx8ICh0eXBlb2YgYVszXSA9PT0gJ3N0cmluZycgPyBhWzNdIDogYVs0XSkgfHwgJ3JnYidcclxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IF9hOiBhWzBdLCBfYjogYVsxXSwgX2M6IGFbMl0sIF9kOiBhWzNdIHx8IDAgfSlcclxuICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xyXG4gICAgICAvLyBTZXQgdGhlIG9iamVjdCB1cCBhbmQgYXNzaWduIGl0cyB2YWx1ZXMgZGlyZWN0bHlcclxuICAgICAgY29uc3QgdmFsdWVzID0gZ2V0UGFyYW1ldGVycyhhLCBiKVxyXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHZhbHVlcylcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGlmIChpc1JnYi50ZXN0KGEpKSB7XHJcbiAgICAgICAgY29uc3Qgbm9XaGl0ZXNwYWNlID0gYS5yZXBsYWNlKHdoaXRlc3BhY2UsICcnKVxyXG4gICAgICAgIGNvbnN0IFsgX2EsIF9iLCBfYyBdID0gcmdiLmV4ZWMobm9XaGl0ZXNwYWNlKVxyXG4gICAgICAgICAgLnNsaWNlKDEsIDQpLm1hcCh2ID0+IHBhcnNlSW50KHYpKVxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBfYSwgX2IsIF9jLCBfZDogMCwgc3BhY2U6ICdyZ2InIH0pXHJcbiAgICAgIH0gZWxzZSBpZiAoaXNIZXgudGVzdChhKSkge1xyXG4gICAgICAgIGNvbnN0IGhleFBhcnNlID0gdiA9PiBwYXJzZUludCh2LCAxNilcclxuICAgICAgICBjb25zdCBbICwgX2EsIF9iLCBfYyBdID0gaGV4LmV4ZWMoc2l4RGlnaXRIZXgoYSkpLm1hcChoZXhQYXJzZSlcclxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgX2EsIF9iLCBfYywgX2Q6IDAsIHNwYWNlOiAncmdiJyB9KVxyXG4gICAgICB9IGVsc2UgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0cmluZyBmb3JtYXQsIGNhblxcJ3QgY29uc3RydWN0IENvbG9yJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3cgYWRkIHRoZSBjb21wb25lbnRzIGFzIGEgY29udmVuaWVuY2VcclxuICAgIGNvbnN0IHsgX2EsIF9iLCBfYywgX2QgfSA9IHRoaXNcclxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLnNwYWNlID09PSAncmdiJyA/IHsgcjogX2EsIGc6IF9iLCBiOiBfYyB9XHJcbiAgICAgIDogdGhpcy5zcGFjZSA9PT0gJ3h5eicgPyB7IHg6IF9hLCB5OiBfYiwgejogX2MgfVxyXG4gICAgICA6IHRoaXMuc3BhY2UgPT09ICdoc2wnID8geyBoOiBfYSwgczogX2IsIGw6IF9jIH1cclxuICAgICAgOiB0aGlzLnNwYWNlID09PSAnbGFiJyA/IHsgbDogX2EsIGE6IF9iLCBiOiBfYyB9XHJcbiAgICAgIDogdGhpcy5zcGFjZSA9PT0gJ2xjaCcgPyB7IGw6IF9hLCBjOiBfYiwgaDogX2MgfVxyXG4gICAgICA6IHRoaXMuc3BhY2UgPT09ICdjbXlrJyA/IHsgYzogX2EsIG06IF9iLCB5OiBfYywgazogX2QgfVxyXG4gICAgICA6IHt9XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbXBvbmVudHMpXHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIENvbnZlcnNpb24gTWV0aG9kc1xyXG4gICovXHJcblxyXG4gIHJnYiAoKSB7XHJcbiAgICBpZiAodGhpcy5zcGFjZSA9PT0gJ3JnYicpIHtcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH0gZWxzZSBpZiAoY2llU3BhY2UodGhpcy5zcGFjZSkpIHtcclxuICAgICAgLy8gQ29udmVydCB0byB0aGUgeHl6IGNvbG9yIHNwYWNlXHJcbiAgICAgIGxldCB7IHgsIHksIHogfSA9IHRoaXNcclxuICAgICAgaWYgKHRoaXMuc3BhY2UgPT09ICdsYWInIHx8IHRoaXMuc3BhY2UgPT09ICdsY2gnKSB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZXMgaW4gdGhlIGxhYiBzcGFjZVxyXG4gICAgICAgIGxldCB7IGwsIGEsIGIgfSA9IHRoaXNcclxuICAgICAgICBpZiAodGhpcy5zcGFjZSA9PT0gJ2xjaCcpIHtcclxuICAgICAgICAgIGNvbnN0IHsgYywgaCB9ID0gdGhpc1xyXG4gICAgICAgICAgY29uc3QgZFRvUiA9IE1hdGguUEkgLyAxODBcclxuICAgICAgICAgIGEgPSBjICogTWF0aC5jb3MoZFRvUiAqIGgpXHJcbiAgICAgICAgICBiID0gYyAqIE1hdGguc2luKGRUb1IgKiBoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVW5kbyB0aGUgbm9ubGluZWFyIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3QgeUwgPSAobCArIDE2KSAvIDExNlxyXG4gICAgICAgIGNvbnN0IHhMID0gYSAvIDUwMCArIHlMXHJcbiAgICAgICAgY29uc3QgekwgPSB5TCAtIGIgLyAyMDBcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB4eXogdmFsdWVzXHJcbiAgICAgICAgY29uc3QgY3QgPSAxNiAvIDExNlxyXG4gICAgICAgIGNvbnN0IG14ID0gMC4wMDg4NTZcclxuICAgICAgICBjb25zdCBubSA9IDcuNzg3XHJcbiAgICAgICAgeCA9IDAuOTUwNDcgKiAoKHhMICoqIDMgPiBteCkgPyB4TCAqKiAzIDogKHhMIC0gY3QpIC8gbm0pXHJcbiAgICAgICAgeSA9IDEuMDAwMDAgKiAoKHlMICoqIDMgPiBteCkgPyB5TCAqKiAzIDogKHlMIC0gY3QpIC8gbm0pXHJcbiAgICAgICAgeiA9IDEuMDg4ODMgKiAoKHpMICoqIDMgPiBteCkgPyB6TCAqKiAzIDogKHpMIC0gY3QpIC8gbm0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgeHl6IHRvIHVuYm91bmRlZCByZ2IgdmFsdWVzXHJcbiAgICAgIGNvbnN0IHJVID0geCAqIDMuMjQwNiArIHkgKiAtMS41MzcyICsgeiAqIC0wLjQ5ODZcclxuICAgICAgY29uc3QgZ1UgPSB4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1XHJcbiAgICAgIGNvbnN0IGJVID0geCAqIDAuMDU1NyArIHkgKiAtMC4yMDQwICsgeiAqIDEuMDU3MFxyXG5cclxuICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHRvIHRydWUgcmdiIHZhbHVlc1xyXG4gICAgICBjb25zdCBwb3cgPSBNYXRoLnBvd1xyXG4gICAgICBjb25zdCBiZCA9IDAuMDAzMTMwOFxyXG4gICAgICBjb25zdCByID0gKHJVID4gYmQpID8gKDEuMDU1ICogcG93KHJVLCAxIC8gMi40KSAtIDAuMDU1KSA6IDEyLjkyICogclVcclxuICAgICAgY29uc3QgZyA9IChnVSA+IGJkKSA/ICgxLjA1NSAqIHBvdyhnVSwgMSAvIDIuNCkgLSAwLjA1NSkgOiAxMi45MiAqIGdVXHJcbiAgICAgIGNvbnN0IGIgPSAoYlUgPiBiZCkgPyAoMS4wNTUgKiBwb3coYlUsIDEgLyAyLjQpIC0gMC4wNTUpIDogMTIuOTIgKiBiVVxyXG5cclxuICAgICAgLy8gTWFrZSBhbmQgcmV0dXJuIHRoZSBjb2xvclxyXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigyNTUgKiByLCAyNTUgKiBnLCAyNTUgKiBiKVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zcGFjZSA9PT0gJ2hzbCcpIHtcclxuICAgICAgLy8gaHR0cHM6Ly9iZ3JpbnMuZ2l0aHViLmlvL1RpbnlDb2xvci9kb2NzL3Rpbnljb2xvci5odG1sXHJcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBoc2wgdmFsdWVzXHJcbiAgICAgIGxldCB7IGgsIHMsIGwgfSA9IHRoaXNcclxuICAgICAgaCAvPSAzNjBcclxuICAgICAgcyAvPSAxMDBcclxuICAgICAgbCAvPSAxMDBcclxuXHJcbiAgICAgIC8vIElmIHdlIGFyZSBncmV5LCB0aGVuIGp1c3QgbWFrZSB0aGUgY29sb3IgZGlyZWN0bHlcclxuICAgICAgaWYgKHMgPT09IDApIHtcclxuICAgICAgICBsICo9IDI1NVxyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGwsIGwpXHJcbiAgICAgICAgcmV0dXJuIGNvbG9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE8gSSBoYXZlIG5vIGlkZWEgd2hhdCB0aGlzIGRvZXMgOkQgSWYgeW91IGZpZ3VyZSBpdCBvdXQsIHRlbGwgbWUhXHJcbiAgICAgIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzXHJcbiAgICAgIGNvbnN0IHAgPSAyICogbCAtIHFcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlc1xyXG4gICAgICBjb25zdCByID0gMjU1ICogaHVlVG9SZ2IocCwgcSwgaCArIDEgLyAzKVxyXG4gICAgICBjb25zdCBnID0gMjU1ICogaHVlVG9SZ2IocCwgcSwgaClcclxuICAgICAgY29uc3QgYiA9IDI1NSAqIGh1ZVRvUmdiKHAsIHEsIGggLSAxIC8gMylcclxuXHJcbiAgICAgIC8vIE1ha2UgYSBuZXcgY29sb3JcclxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IociwgZywgYilcclxuICAgICAgcmV0dXJuIGNvbG9yXHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3BhY2UgPT09ICdjbXlrJykge1xyXG4gICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9mZWxpcGVzYWJpbm8vNTA2NjMzNlxyXG4gICAgICAvLyBHZXQgdGhlIG5vcm1hbGlzZWQgY215ayB2YWx1ZXNcclxuICAgICAgY29uc3QgeyBjLCBtLCB5LCBrIH0gPSB0aGlzXHJcblxyXG4gICAgICAvLyBHZXQgdGhlIHJnYiB2YWx1ZXNcclxuICAgICAgY29uc3QgciA9IDI1NSAqICgxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKSlcclxuICAgICAgY29uc3QgZyA9IDI1NSAqICgxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKSlcclxuICAgICAgY29uc3QgYiA9IDI1NSAqICgxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKSlcclxuXHJcbiAgICAgIC8vIEZvcm0gdGhlIGNvbG9yIGFuZCByZXR1cm4gaXRcclxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IociwgZywgYilcclxuICAgICAgcmV0dXJuIGNvbG9yXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbGFiICgpIHtcclxuICAgIC8vIEdldCB0aGUgeHl6IGNvbG9yXHJcbiAgICBjb25zdCB7IHgsIHksIHogfSA9IHRoaXMueHl6KClcclxuXHJcbiAgICAvLyBHZXQgdGhlIGxhYiBjb21wb25lbnRzXHJcbiAgICBjb25zdCBsID0gKDExNiAqIHkpIC0gMTZcclxuICAgIGNvbnN0IGEgPSA1MDAgKiAoeCAtIHkpXHJcbiAgICBjb25zdCBiID0gMjAwICogKHkgLSB6KVxyXG5cclxuICAgIC8vIENvbnN0cnVjdCBhbmQgcmV0dXJuIGEgbmV3IGNvbG9yXHJcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsLCBhLCBiLCAnbGFiJylcclxuICAgIHJldHVybiBjb2xvclxyXG4gIH1cclxuXHJcbiAgeHl6ICgpIHtcclxuXHJcbiAgICAvLyBOb3JtYWxpc2UgdGhlIHJlZCwgZ3JlZW4gYW5kIGJsdWUgdmFsdWVzXHJcbiAgICBjb25zdCB7IF9hOiByMjU1LCBfYjogZzI1NSwgX2M6IGIyNTUgfSA9IHRoaXMucmdiKClcclxuICAgIGNvbnN0IFsgciwgZywgYiBdID0gWyByMjU1LCBnMjU1LCBiMjU1IF0ubWFwKHYgPT4gdiAvIDI1NSlcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRvIHRoZSBsYWIgcmdiIHNwYWNlXHJcbiAgICBjb25zdCByTCA9IChyID4gMC4wNDA0NSkgPyBNYXRoLnBvdygociArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogciAvIDEyLjkyXHJcbiAgICBjb25zdCBnTCA9IChnID4gMC4wNDA0NSkgPyBNYXRoLnBvdygoZyArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogZyAvIDEyLjkyXHJcbiAgICBjb25zdCBiTCA9IChiID4gMC4wNDA0NSkgPyBNYXRoLnBvdygoYiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogYiAvIDEyLjkyXHJcblxyXG4gICAgLy8gQ29udmVydCB0byB0aGUgeHl6IGNvbG9yIHNwYWNlIHdpdGhvdXQgYm91bmRpbmcgdGhlIHZhbHVlc1xyXG4gICAgY29uc3QgeFUgPSAockwgKiAwLjQxMjQgKyBnTCAqIDAuMzU3NiArIGJMICogMC4xODA1KSAvIDAuOTUwNDdcclxuICAgIGNvbnN0IHlVID0gKHJMICogMC4yMTI2ICsgZ0wgKiAwLjcxNTIgKyBiTCAqIDAuMDcyMikgLyAxLjAwMDAwXHJcbiAgICBjb25zdCB6VSA9IChyTCAqIDAuMDE5MyArIGdMICogMC4xMTkyICsgYkwgKiAwLjk1MDUpIC8gMS4wODg4M1xyXG5cclxuICAgIC8vIEdldCB0aGUgcHJvcGVyIHh5eiB2YWx1ZXMgYnkgYXBwbHlpbmcgdGhlIGJvdW5kaW5nXHJcbiAgICBjb25zdCB4ID0gKHhVID4gMC4wMDg4NTYpID8gTWF0aC5wb3coeFUsIDEgLyAzKSA6ICg3Ljc4NyAqIHhVKSArIDE2IC8gMTE2XHJcbiAgICBjb25zdCB5ID0gKHlVID4gMC4wMDg4NTYpID8gTWF0aC5wb3coeVUsIDEgLyAzKSA6ICg3Ljc4NyAqIHlVKSArIDE2IC8gMTE2XHJcbiAgICBjb25zdCB6ID0gKHpVID4gMC4wMDg4NTYpID8gTWF0aC5wb3coelUsIDEgLyAzKSA6ICg3Ljc4NyAqIHpVKSArIDE2IC8gMTE2XHJcblxyXG4gICAgLy8gTWFrZSBhbmQgcmV0dXJuIHRoZSBjb2xvclxyXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoeCwgeSwgeiwgJ3h5eicpXHJcbiAgICByZXR1cm4gY29sb3JcclxuICB9XHJcblxyXG4gIGxjaCAoKSB7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBsYWIgY29sb3IgZGlyZWN0bHlcclxuICAgIGNvbnN0IHsgbCwgYSwgYiB9ID0gdGhpcy5sYWIoKVxyXG5cclxuICAgIC8vIEdldCB0aGUgY2hyb21hdGljaXR5IGFuZCB0aGUgaHVlIHVzaW5nIHBvbGFyIGNvb3JkaW5hdGVzXHJcbiAgICBjb25zdCBjID0gTWF0aC5zcXJ0KGEgKiogMiArIGIgKiogMilcclxuICAgIGxldCBoID0gMTgwICogTWF0aC5hdGFuMihiLCBhKSAvIE1hdGguUElcclxuICAgIGlmIChoIDwgMCkge1xyXG4gICAgICBoICo9IC0xXHJcbiAgICAgIGggPSAzNjAgLSBoXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFrZSBhIG5ldyBjb2xvciBhbmQgcmV0dXJuIGl0XHJcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsLCBjLCBoLCAnbGNoJylcclxuICAgIHJldHVybiBjb2xvclxyXG4gIH1cclxuXHJcbiAgaHNsICgpIHtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHJnYiB2YWx1ZXNcclxuICAgIGNvbnN0IHsgX2EsIF9iLCBfYyB9ID0gdGhpcy5yZ2IoKVxyXG4gICAgY29uc3QgWyByLCBnLCBiIF0gPSBbIF9hLCBfYiwgX2MgXS5tYXAodiA9PiB2IC8gMjU1KVxyXG5cclxuICAgIC8vIEZpbmQgdGhlIG1heGltdW0gYW5kIG1pbmltdW0gdmFsdWVzIHRvIGdldCB0aGUgbGlnaHRuZXNzXHJcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKVxyXG4gICAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYilcclxuICAgIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDJcclxuXHJcbiAgICAvLyBJZiB0aGUgciwgZywgdiB2YWx1ZXMgYXJlIGlkZW50aWNhbCB0aGVuIHdlIGFyZSBncmV5XHJcbiAgICBjb25zdCBpc0dyZXkgPSBtYXggPT09IG1pblxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaHVlIGFuZCBzYXR1cmF0aW9uXHJcbiAgICBjb25zdCBkZWx0YSA9IG1heCAtIG1pblxyXG4gICAgY29uc3QgcyA9IGlzR3JleSA/IDBcclxuICAgICAgOiBsID4gMC41ID8gZGVsdGEgLyAoMiAtIG1heCAtIG1pbilcclxuICAgICAgOiBkZWx0YSAvIChtYXggKyBtaW4pXHJcbiAgICBjb25zdCBoID0gaXNHcmV5ID8gMFxyXG4gICAgICA6IG1heCA9PT0gciA/ICgoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMCkpIC8gNlxyXG4gICAgICA6IG1heCA9PT0gZyA/ICgoYiAtIHIpIC8gZGVsdGEgKyAyKSAvIDZcclxuICAgICAgOiBtYXggPT09IGIgPyAoKHIgLSBnKSAvIGRlbHRhICsgNCkgLyA2XHJcbiAgICAgIDogMFxyXG5cclxuICAgIC8vIENvbnN0cnVjdCBhbmQgcmV0dXJuIHRoZSBuZXcgY29sb3JcclxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDM2MCAqIGgsIDEwMCAqIHMsIDEwMCAqIGwsICdoc2wnKVxyXG4gICAgcmV0dXJuIGNvbG9yXHJcbiAgfVxyXG5cclxuICBjbXlrICgpIHtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHJnYiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IGNvbG9yXHJcbiAgICBjb25zdCB7IF9hLCBfYiwgX2MgfSA9IHRoaXMucmdiKClcclxuICAgIGNvbnN0IFsgciwgZywgYiBdID0gWyBfYSwgX2IsIF9jIF0ubWFwKHYgPT4gdiAvIDI1NSlcclxuXHJcbiAgICAvLyBHZXQgdGhlIGNteWsgdmFsdWVzIGluIGFuIHVuYm91bmRlZCBmb3JtYXRcclxuICAgIGNvbnN0IGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKVxyXG5cclxuICAgIGlmIChrID09PSAxKSB7XHJcbiAgICAgIC8vIENhdGNoIHRoZSBibGFjayBjYXNlXHJcbiAgICAgIHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMSwgJ2NteWsnKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaylcclxuICAgIGNvbnN0IG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gaylcclxuICAgIGNvbnN0IHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaylcclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIG5ldyBjb2xvclxyXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoYywgbSwgeSwgaywgJ2NteWsnKVxyXG4gICAgcmV0dXJuIGNvbG9yXHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIElucHV0IGFuZCBPdXRwdXQgbWV0aG9kc1xyXG4gICovXHJcblxyXG4gIF9jbGFtcGVkICgpIHtcclxuICAgIGNvbnN0IHsgX2EsIF9iLCBfYyB9ID0gdGhpcy5yZ2IoKVxyXG4gICAgY29uc3QgeyBtYXgsIG1pbiwgcm91bmQgfSA9IE1hdGhcclxuICAgIGNvbnN0IGZvcm1hdCA9IHYgPT4gbWF4KDAsIG1pbihyb3VuZCh2KSwgMjU1KSlcclxuICAgIHJldHVybiBbIF9hLCBfYiwgX2MgXS5tYXAoZm9ybWF0KVxyXG4gIH1cclxuXHJcbiAgdG9IZXggKCkge1xyXG4gICAgY29uc3QgWyByLCBnLCBiIF0gPSB0aGlzLl9jbGFtcGVkKCkubWFwKGNvbXBvbmVudEhleClcclxuICAgIHJldHVybiBgIyR7cn0ke2d9JHtifWBcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiB0aGlzLnRvSGV4KClcclxuICB9XHJcblxyXG4gIHRvUmdiICgpIHtcclxuICAgIGNvbnN0IFsgclYsIGdWLCBiViBdID0gdGhpcy5fY2xhbXBlZCgpXHJcbiAgICBjb25zdCBzdHJpbmcgPSBgcmdiKCR7clZ9LCR7Z1Z9LCR7YlZ9KWBcclxuICAgIHJldHVybiBzdHJpbmdcclxuICB9XHJcblxyXG4gIHRvQXJyYXkgKCkge1xyXG4gICAgY29uc3QgeyBfYSwgX2IsIF9jLCBfZCwgc3BhY2UgfSA9IHRoaXNcclxuICAgIHJldHVybiBbIF9hLCBfYiwgX2MsIF9kLCBzcGFjZSBdXHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIEdlbmVyYXRpbmcgcmFuZG9tIGNvbG9yc1xyXG4gICovXHJcblxyXG4gIHN0YXRpYyByYW5kb20gKG1vZGUgPSAndmlicmFudCcsIHQsIHUpIHtcclxuXHJcbiAgICAvLyBHZXQgdGhlIG1hdGggbW9kdWxlc1xyXG4gICAgY29uc3QgeyByYW5kb20sIHJvdW5kLCBzaW4sIFBJOiBwaSB9ID0gTWF0aFxyXG5cclxuICAgIC8vIFJ1biB0aGUgY29ycmVjdCBnZW5lcmF0b3JcclxuICAgIGlmIChtb2RlID09PSAndmlicmFudCcpIHtcclxuXHJcbiAgICAgIGNvbnN0IGwgPSAoODEgLSA1NykgKiByYW5kb20oKSArIDU3XHJcbiAgICAgIGNvbnN0IGMgPSAoODMgLSA0NSkgKiByYW5kb20oKSArIDQ1XHJcbiAgICAgIGNvbnN0IGggPSAzNjAgKiByYW5kb20oKVxyXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsLCBjLCBoLCAnbGNoJylcclxuICAgICAgcmV0dXJuIGNvbG9yXHJcblxyXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnc2luZScpIHtcclxuXHJcbiAgICAgIHQgPSB0ID09IG51bGwgPyByYW5kb20oKSA6IHRcclxuICAgICAgY29uc3QgciA9IHJvdW5kKDgwICogc2luKDIgKiBwaSAqIHQgLyAwLjUgKyAwLjAxKSArIDE1MClcclxuICAgICAgY29uc3QgZyA9IHJvdW5kKDUwICogc2luKDIgKiBwaSAqIHQgLyAwLjUgKyA0LjYpICsgMjAwKVxyXG4gICAgICBjb25zdCBiID0gcm91bmQoMTAwICogc2luKDIgKiBwaSAqIHQgLyAwLjUgKyAyLjMpICsgMTUwKVxyXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuXHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdwYXN0ZWwnKSB7XHJcblxyXG4gICAgICBjb25zdCBsID0gKDk0IC0gODYpICogcmFuZG9tKCkgKyA4NlxyXG4gICAgICBjb25zdCBjID0gKDI2IC0gOSkgKiByYW5kb20oKSArIDlcclxuICAgICAgY29uc3QgaCA9IDM2MCAqIHJhbmRvbSgpXHJcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuXHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdkYXJrJykge1xyXG5cclxuICAgICAgY29uc3QgbCA9IDEwICsgMTAgKiByYW5kb20oKVxyXG4gICAgICBjb25zdCBjID0gKDEyNSAtIDc1KSAqIHJhbmRvbSgpICsgODZcclxuICAgICAgY29uc3QgaCA9IDM2MCAqIHJhbmRvbSgpXHJcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuXHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdyZ2InKSB7XHJcblxyXG4gICAgICBjb25zdCByID0gMjU1ICogcmFuZG9tKClcclxuICAgICAgY29uc3QgZyA9IDI1NSAqIHJhbmRvbSgpXHJcbiAgICAgIGNvbnN0IGIgPSAyNTUgKiByYW5kb20oKVxyXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuXHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdsYWInKSB7XHJcblxyXG4gICAgICBjb25zdCBsID0gMTAwICogcmFuZG9tKClcclxuICAgICAgY29uc3QgYSA9IDI1NiAqIHJhbmRvbSgpIC0gMTI4XHJcbiAgICAgIGNvbnN0IGIgPSAyNTYgKiByYW5kb20oKSAtIDEyOFxyXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsLCBhLCBiLCAnbGFiJylcclxuICAgICAgcmV0dXJuIGNvbG9yXHJcblxyXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnZ3JleScpIHtcclxuXHJcbiAgICAgIGNvbnN0IGdyZXkgPSAyNTUgKiByYW5kb20oKVxyXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihncmV5LCBncmV5LCBncmV5KVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIENvbnN0cnVjdGluZyBjb2xvcnNcclxuICAqL1xyXG5cclxuICAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3Igc3RyaW5nXHJcbiAgc3RhdGljIHRlc3QgKGNvbG9yKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpXHJcbiAgICAgICYmIChpc0hleC50ZXN0KGNvbG9yKSB8fCBpc1JnYi50ZXN0KGNvbG9yKSlcclxuICB9XHJcblxyXG4gIC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYW4gcmdiIG9iamVjdFxyXG4gIHN0YXRpYyBpc1JnYiAoY29sb3IpIHtcclxuICAgIHJldHVybiBjb2xvciAmJiB0eXBlb2YgY29sb3IuciA9PT0gJ251bWJlcidcclxuICAgICAgJiYgdHlwZW9mIGNvbG9yLmcgPT09ICdudW1iZXInXHJcbiAgICAgICYmIHR5cGVvZiBjb2xvci5iID09PSAnbnVtYmVyJ1xyXG4gIH1cclxuXHJcbiAgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIGNvbG9yXHJcbiAgc3RhdGljIGlzQ29sb3IgKGNvbG9yKSB7XHJcbiAgICByZXR1cm4gY29sb3IgJiYgKFxyXG4gICAgICBjb2xvciBpbnN0YW5jZW9mIENvbG9yXHJcbiAgICAgIHx8IHRoaXMuaXNSZ2IoY29sb3IpXHJcbiAgICAgIHx8IHRoaXMudGVzdChjb2xvcilcclxuICAgIClcclxuICB9XHJcbn1cclxuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVLZXlzKDEpOyB9KTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAga2V5czogZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcblxuLy8gQEBtYXRjaCBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ21hdGNoJywgMSwgZnVuY3Rpb24gKE1BVENILCBuYXRpdmVNYXRjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgICBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciBtYXRjaGVyID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgICByZXR1cm4gbWF0Y2hlciAhPT0gdW5kZWZpbmVkID8gbWF0Y2hlci5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQG1hdGNoXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVNYXRjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuXG4gICAgICBpZiAoIXJ4Lmdsb2JhbCkgcmV0dXJuIHJlZ0V4cEV4ZWMocngsIFMpO1xuXG4gICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBBID0gW107XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKSkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIEFbbl0gPSBtYXRjaFN0cjtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgICAgbisrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG4gPT09IDAgPyBudWxsIDogQTtcbiAgICB9XG4gIF07XG59KTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59IiwiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4uLy4uL2hlbHBlcnMvZXNtL3R5cGVvZlwiO1xuaW1wb3J0IGFzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufSIsImltcG9ydCBnZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9nZXRQcm90b3R5cGVPZlwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufSIsImltcG9ydCBzdXBlclByb3BCYXNlIGZyb20gXCIuL3N1cGVyUHJvcEJhc2VcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IHN1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufSIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZlwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgdHJpbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctdHJpbScpLnRyaW07XG5cbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciBOYXRpdmVOdW1iZXIgPSBnbG9iYWxbTlVNQkVSXTtcbnZhciBOdW1iZXJQcm90b3R5cGUgPSBOYXRpdmVOdW1iZXIucHJvdG90eXBlO1xuXG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ0xBU1NPRiA9IGNsYXNzb2YoY3JlYXRlKE51bWJlclByb3RvdHlwZSkpID09IE5VTUJFUjtcblxuLy8gYFRvTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbnVtYmVyXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgdmFyIGZpcnN0LCB0aGlyZCwgcmFkaXgsIG1heENvZGUsIGRpZ2l0cywgbGVuZ3RoLCBpbmRleCwgY29kZTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSB0cmltKGl0KTtcbiAgICBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgY2FzZSA2NjogY2FzZSA5ODogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIG9mIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5OiBjYXNlIDExMTogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIG9mIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGRpZ2l0cyA9IGl0LnNsaWNlKDIpO1xuICAgICAgbGVuZ3RoID0gZGlnaXRzLmxlbmd0aDtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuLy8gYE51bWJlcmAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci1jb25zdHJ1Y3RvclxuaWYgKGlzRm9yY2VkKE5VTUJFUiwgIU5hdGl2ZU51bWJlcignIDBvMScpIHx8ICFOYXRpdmVOdW1iZXIoJzBiMScpIHx8IE5hdGl2ZU51bWJlcignKzB4MScpKSkge1xuICB2YXIgTnVtYmVyV3JhcHBlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlO1xuICAgIHZhciBkdW1teSA9IHRoaXM7XG4gICAgcmV0dXJuIGR1bW15IGluc3RhbmNlb2YgTnVtYmVyV3JhcHBlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NMQVNTT0YgPyBmYWlscyhmdW5jdGlvbiAoKSB7IE51bWJlclByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZHVtbXkpOyB9KSA6IGNsYXNzb2YoZHVtbXkpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgTmF0aXZlTnVtYmVyKHRvTnVtYmVyKGl0KSksIGR1bW15LCBOdW1iZXJXcmFwcGVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IERFU0NSSVBUT1JTID8gZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVOdW1iZXIpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVMyMDE1IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVMyMDE1IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoTmF0aXZlTnVtYmVyLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKE51bWJlcldyYXBwZXIsIGtleSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5hdGl2ZU51bWJlciwga2V5KSk7XG4gICAgfVxuICB9XG4gIE51bWJlcldyYXBwZXIucHJvdG90eXBlID0gTnVtYmVyUHJvdG90eXBlO1xuICBOdW1iZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdW1iZXJXcmFwcGVyO1xuICByZWRlZmluZShnbG9iYWwsIE5VTUJFUiwgTnVtYmVyV3JhcHBlcik7XG59XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHRyaW0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIHdoaXRlc3BhY2VzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzJyk7XG5cbnZhciBuYXRpdmVQYXJzZUZsb2F0ID0gZ2xvYmFsLnBhcnNlRmxvYXQ7XG52YXIgRk9SQ0VEID0gMSAvIG5hdGl2ZVBhcnNlRmxvYXQod2hpdGVzcGFjZXMgKyAnLTAnKSAhPT0gLUluZmluaXR5O1xuXG4vLyBgcGFyc2VGbG9hdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWZsb2F0LXN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBGT1JDRUQgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cmluZykge1xuICB2YXIgdHJpbW1lZFN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuICB2YXIgcmVzdWx0ID0gbmF0aXZlUGFyc2VGbG9hdCh0cmltbWVkU3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiB0cmltbWVkU3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiBuYXRpdmVQYXJzZUZsb2F0O1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgcGFyc2VGbG9hdEltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhcnNlLWZsb2F0Jyk7XG5cbi8vIGBwYXJzZUZsb2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlRmxvYXQgIT0gcGFyc2VGbG9hdEltcGxlbWVudGF0aW9uIH0sIHtcbiAgcGFyc2VGbG9hdDogcGFyc2VGbG9hdEltcGxlbWVudGF0aW9uXG59KTtcbiIsImltcG9ydCBNYXRyaXggZnJvbSAnLi9NYXRyaXguanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludCB7XHJcbiAgLy8gSW5pdGlhbGl6ZVxyXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XHJcbiAgICB0aGlzLmluaXQoLi4uYXJncylcclxuICB9XHJcblxyXG4gIGluaXQgKHgsIHkpIHtcclxuICAgIGNvbnN0IGJhc2UgPSB7IHg6IDAsIHk6IDAgfVxyXG5cclxuICAgIC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XHJcbiAgICBjb25zdCBzb3VyY2UgPSBBcnJheS5pc0FycmF5KHgpID8geyB4OiB4WzBdLCB5OiB4WzFdIH1cclxuICAgICAgOiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyB7IHg6IHgueCwgeTogeC55IH1cclxuICAgICAgOiB7IHg6IHgsIHk6IHkgfVxyXG5cclxuICAgIC8vIG1lcmdlIHNvdXJjZVxyXG4gICAgdGhpcy54ID0gc291cmNlLnggPT0gbnVsbCA/IGJhc2UueCA6IHNvdXJjZS54XHJcbiAgICB0aGlzLnkgPSBzb3VyY2UueSA9PSBudWxsID8gYmFzZS55IDogc291cmNlLnlcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gQ2xvbmUgcG9pbnRcclxuICBjbG9uZSAoKSB7XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMpXHJcbiAgfVxyXG5cclxuICB0cmFuc2Zvcm0gKG0pIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkudHJhbnNmb3JtTyhtKVxyXG4gIH1cclxuXHJcbiAgLy8gVHJhbnNmb3JtIHBvaW50IHdpdGggbWF0cml4XHJcbiAgdHJhbnNmb3JtTyAobSkge1xyXG4gICAgaWYgKCFNYXRyaXguaXNNYXRyaXhMaWtlKG0pKSB7XHJcbiAgICAgIG0gPSBuZXcgTWF0cml4KG0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzXHJcblxyXG4gICAgLy8gUGVyZm9ybSB0aGUgbWF0cml4IG11bHRpcGxpY2F0aW9uXHJcbiAgICB0aGlzLnggPSBtLmEgKiB4ICsgbS5jICogeSArIG0uZVxyXG4gICAgdGhpcy55ID0gbS5iICogeCArIG0uZCAqIHkgKyBtLmZcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgdG9BcnJheSAoKSB7XHJcbiAgICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSBdXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnQgKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IFBvaW50KHgsIHkpLnRyYW5zZm9ybSh0aGlzLnNjcmVlbkNUTSgpLmludmVyc2UoKSlcclxufVxyXG4iLCJpbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXHJcbmltcG9ydCB7IHJhZGlhbnMgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9lbGVtZW50cy9FbGVtZW50LmpzJ1xyXG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcydcclxuXHJcbmZ1bmN0aW9uIGNsb3NlRW5vdWdoIChhLCBiLCB0aHJlc2hvbGQpIHtcclxuICByZXR1cm4gTWF0aC5hYnMoYiAtIGEpIDwgKHRocmVzaG9sZCB8fCAxZS02KVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXgge1xyXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XHJcbiAgICB0aGlzLmluaXQoLi4uYXJncylcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpemVcclxuICBpbml0IChzb3VyY2UpIHtcclxuICAgIHZhciBiYXNlID0gTWF0cml4LmZyb21BcnJheShbIDEsIDAsIDAsIDEsIDAsIDAgXSlcclxuXHJcbiAgICAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxyXG4gICAgc291cmNlID0gc291cmNlIGluc3RhbmNlb2YgRWxlbWVudCA/IHNvdXJjZS5tYXRyaXhpZnkoKVxyXG4gICAgICA6IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gTWF0cml4LmZyb21BcnJheShzb3VyY2Uuc3BsaXQoZGVsaW1pdGVyKS5tYXAocGFyc2VGbG9hdCkpXHJcbiAgICAgIDogQXJyYXkuaXNBcnJheShzb3VyY2UpID8gTWF0cml4LmZyb21BcnJheShzb3VyY2UpXHJcbiAgICAgIDogKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnICYmIE1hdHJpeC5pc01hdHJpeExpa2Uoc291cmNlKSkgPyBzb3VyY2VcclxuICAgICAgOiAodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpID8gbmV3IE1hdHJpeCgpLnRyYW5zZm9ybShzb3VyY2UpXHJcbiAgICAgIDogYXJndW1lbnRzLmxlbmd0aCA9PT0gNiA/IE1hdHJpeC5mcm9tQXJyYXkoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxyXG4gICAgICA6IGJhc2VcclxuXHJcbiAgICAvLyBNZXJnZSB0aGUgc291cmNlIG1hdHJpeCB3aXRoIHRoZSBiYXNlIG1hdHJpeFxyXG4gICAgdGhpcy5hID0gc291cmNlLmEgIT0gbnVsbCA/IHNvdXJjZS5hIDogYmFzZS5hXHJcbiAgICB0aGlzLmIgPSBzb3VyY2UuYiAhPSBudWxsID8gc291cmNlLmIgOiBiYXNlLmJcclxuICAgIHRoaXMuYyA9IHNvdXJjZS5jICE9IG51bGwgPyBzb3VyY2UuYyA6IGJhc2UuY1xyXG4gICAgdGhpcy5kID0gc291cmNlLmQgIT0gbnVsbCA/IHNvdXJjZS5kIDogYmFzZS5kXHJcbiAgICB0aGlzLmUgPSBzb3VyY2UuZSAhPSBudWxsID8gc291cmNlLmUgOiBiYXNlLmVcclxuICAgIHRoaXMuZiA9IHNvdXJjZS5mICE9IG51bGwgPyBzb3VyY2UuZiA6IGJhc2UuZlxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBDbG9uZXMgdGhpcyBtYXRyaXhcclxuICBjbG9uZSAoKSB7XHJcbiAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzKVxyXG4gIH1cclxuXHJcbiAgLy8gVHJhbnNmb3JtIGEgbWF0cml4IGludG8gYW5vdGhlciBtYXRyaXggYnkgbWFuaXB1bGF0aW5nIHRoZSBzcGFjZVxyXG4gIHRyYW5zZm9ybSAobykge1xyXG4gICAgLy8gQ2hlY2sgaWYgbyBpcyBhIG1hdHJpeCBhbmQgdGhlbiBsZWZ0IG11bHRpcGx5IGl0IGRpcmVjdGx5XHJcbiAgICBpZiAoTWF0cml4LmlzTWF0cml4TGlrZShvKSkge1xyXG4gICAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeChvKVxyXG4gICAgICByZXR1cm4gbWF0cml4Lm11bHRpcGx5Tyh0aGlzKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCB0aGUgcHJvcG9zZWQgdHJhbnNmb3JtYXRpb25zIGFuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnNcclxuICAgIHZhciB0ID0gTWF0cml4LmZvcm1hdFRyYW5zZm9ybXMobylcclxuICAgIHZhciBjdXJyZW50ID0gdGhpc1xyXG4gICAgY29uc3QgeyB4OiBveCwgeTogb3kgfSA9IG5ldyBQb2ludCh0Lm94LCB0Lm95KS50cmFuc2Zvcm0oY3VycmVudClcclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIHJlc3VsdGluZyBtYXRyaXhcclxuICAgIHZhciB0cmFuc2Zvcm1lciA9IG5ldyBNYXRyaXgoKVxyXG4gICAgICAudHJhbnNsYXRlTyh0LnJ4LCB0LnJ5KVxyXG4gICAgICAubG11bHRpcGx5TyhjdXJyZW50KVxyXG4gICAgICAudHJhbnNsYXRlTygtb3gsIC1veSlcclxuICAgICAgLnNjYWxlTyh0LnNjYWxlWCwgdC5zY2FsZVkpXHJcbiAgICAgIC5za2V3Tyh0LnNrZXdYLCB0LnNrZXdZKVxyXG4gICAgICAuc2hlYXJPKHQuc2hlYXIpXHJcbiAgICAgIC5yb3RhdGVPKHQudGhldGEpXHJcbiAgICAgIC50cmFuc2xhdGVPKG94LCBveSlcclxuXHJcbiAgICAvLyBJZiB3ZSB3YW50IHRoZSBvcmlnaW4gYXQgYSBwYXJ0aWN1bGFyIHBsYWNlLCB3ZSBmb3JjZSBpdCB0aGVyZVxyXG4gICAgaWYgKGlzRmluaXRlKHQucHgpIHx8IGlzRmluaXRlKHQucHkpKSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbiA9IG5ldyBQb2ludChveCwgb3kpLnRyYW5zZm9ybSh0cmFuc2Zvcm1lcilcclxuICAgICAgLy8gVE9ETzogUmVwbGFjZSB0LnB4IHdpdGggaXNGaW5pdGUodC5weClcclxuICAgICAgY29uc3QgZHggPSB0LnB4ID8gdC5weCAtIG9yaWdpbi54IDogMFxyXG4gICAgICBjb25zdCBkeSA9IHQucHkgPyB0LnB5IC0gb3JpZ2luLnkgOiAwXHJcbiAgICAgIHRyYW5zZm9ybWVyLnRyYW5zbGF0ZU8oZHgsIGR5KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyYW5zbGF0ZSBub3cgYWZ0ZXIgcG9zaXRpb25pbmdcclxuICAgIHRyYW5zZm9ybWVyLnRyYW5zbGF0ZU8odC50eCwgdC50eSlcclxuICAgIHJldHVybiB0cmFuc2Zvcm1lclxyXG4gIH1cclxuXHJcbiAgLy8gQXBwbGllcyBhIG1hdHJpeCBkZWZpbmVkIGJ5IGl0cyBhZmZpbmUgcGFyYW1ldGVyc1xyXG4gIGNvbXBvc2UgKG8pIHtcclxuICAgIGlmIChvLm9yaWdpbikge1xyXG4gICAgICBvLm9yaWdpblggPSBvLm9yaWdpblswXVxyXG4gICAgICBvLm9yaWdpblkgPSBvLm9yaWdpblsxXVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IHRoZSBwYXJhbWV0ZXJzXHJcbiAgICB2YXIgb3ggPSBvLm9yaWdpblggfHwgMFxyXG4gICAgdmFyIG95ID0gby5vcmlnaW5ZIHx8IDBcclxuICAgIHZhciBzeCA9IG8uc2NhbGVYIHx8IDFcclxuICAgIHZhciBzeSA9IG8uc2NhbGVZIHx8IDFcclxuICAgIHZhciBsYW0gPSBvLnNoZWFyIHx8IDBcclxuICAgIHZhciB0aGV0YSA9IG8ucm90YXRlIHx8IDBcclxuICAgIHZhciB0eCA9IG8udHJhbnNsYXRlWCB8fCAwXHJcbiAgICB2YXIgdHkgPSBvLnRyYW5zbGF0ZVkgfHwgMFxyXG5cclxuICAgIC8vIEFwcGx5IHRoZSBzdGFuZGFyZCBtYXRyaXhcclxuICAgIHZhciByZXN1bHQgPSBuZXcgTWF0cml4KClcclxuICAgICAgLnRyYW5zbGF0ZU8oLW94LCAtb3kpXHJcbiAgICAgIC5zY2FsZU8oc3gsIHN5KVxyXG4gICAgICAuc2hlYXJPKGxhbSlcclxuICAgICAgLnJvdGF0ZU8odGhldGEpXHJcbiAgICAgIC50cmFuc2xhdGVPKHR4LCB0eSlcclxuICAgICAgLmxtdWx0aXBseU8odGhpcylcclxuICAgICAgLnRyYW5zbGF0ZU8ob3gsIG95KVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLy8gRGVjb21wb3NlcyB0aGlzIG1hdHJpeCBpbnRvIGl0cyBhZmZpbmUgcGFyYW1ldGVyc1xyXG4gIGRlY29tcG9zZSAoY3ggPSAwLCBjeSA9IDApIHtcclxuICAgIC8vIEdldCB0aGUgcGFyYW1ldGVycyBmcm9tIHRoZSBtYXRyaXhcclxuICAgIHZhciBhID0gdGhpcy5hXHJcbiAgICB2YXIgYiA9IHRoaXMuYlxyXG4gICAgdmFyIGMgPSB0aGlzLmNcclxuICAgIHZhciBkID0gdGhpcy5kXHJcbiAgICB2YXIgZSA9IHRoaXMuZVxyXG4gICAgdmFyIGYgPSB0aGlzLmZcclxuXHJcbiAgICAvLyBGaWd1cmUgb3V0IGlmIHRoZSB3aW5kaW5nIGRpcmVjdGlvbiBpcyBjbG9ja3dpc2Ugb3IgY291bnRlcmNsb2Nrd2lzZVxyXG4gICAgdmFyIGRldGVybWluYW50ID0gYSAqIGQgLSBiICogY1xyXG4gICAgdmFyIGNjdyA9IGRldGVybWluYW50ID4gMCA/IDEgOiAtMVxyXG5cclxuICAgIC8vIFNpbmNlIHdlIG9ubHkgc2hlYXIgaW4geCwgd2UgY2FuIHVzZSB0aGUgeCBiYXNpcyB0byBnZXQgdGhlIHggc2NhbGVcclxuICAgIC8vIGFuZCB0aGUgcm90YXRpb24gb2YgdGhlIHJlc3VsdGluZyBtYXRyaXhcclxuICAgIHZhciBzeCA9IGNjdyAqIE1hdGguc3FydChhICogYSArIGIgKiBiKVxyXG4gICAgdmFyIHRoZXRhUmFkID0gTWF0aC5hdGFuMihjY3cgKiBiLCBjY3cgKiBhKVxyXG4gICAgdmFyIHRoZXRhID0gMTgwIC8gTWF0aC5QSSAqIHRoZXRhUmFkXHJcbiAgICB2YXIgY3QgPSBNYXRoLmNvcyh0aGV0YVJhZClcclxuICAgIHZhciBzdCA9IE1hdGguc2luKHRoZXRhUmFkKVxyXG5cclxuICAgIC8vIFdlIGNhbiB0aGVuIHNvbHZlIHRoZSB5IGJhc2lzIHZlY3RvciBzaW11bHRhbmVvdXNseSB0byBnZXQgdGhlIG90aGVyXHJcbiAgICAvLyB0d28gYWZmaW5lIHBhcmFtZXRlcnMgZGlyZWN0bHkgZnJvbSB0aGVzZSBwYXJhbWV0ZXJzXHJcbiAgICB2YXIgbGFtID0gKGEgKiBjICsgYiAqIGQpIC8gZGV0ZXJtaW5hbnRcclxuICAgIHZhciBzeSA9ICgoYyAqIHN4KSAvIChsYW0gKiBhIC0gYikpIHx8ICgoZCAqIHN4KSAvIChsYW0gKiBiICsgYSkpXHJcblxyXG4gICAgLy8gVXNlIHRoZSB0cmFuc2xhdGlvbnNcclxuICAgIGNvbnN0IHR4ID0gZSAtIGN4ICsgY3ggKiBjdCAqIHN4ICsgY3kgKiAobGFtICogY3QgKiBzeCAtIHN0ICogc3kpXHJcbiAgICBjb25zdCB0eSA9IGYgLSBjeSArIGN4ICogc3QgKiBzeCArIGN5ICogKGxhbSAqIHN0ICogc3ggKyBjdCAqIHN5KVxyXG5cclxuICAgIC8vIENvbnN0cnVjdCB0aGUgZGVjb21wb3NpdGlvbiBhbmQgcmV0dXJuIGl0XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyBSZXR1cm4gdGhlIGFmZmluZSBwYXJhbWV0ZXJzXHJcbiAgICAgIHNjYWxlWDogc3gsXHJcbiAgICAgIHNjYWxlWTogc3ksXHJcbiAgICAgIHNoZWFyOiBsYW0sXHJcbiAgICAgIHJvdGF0ZTogdGhldGEsXHJcbiAgICAgIHRyYW5zbGF0ZVg6IHR4LFxyXG4gICAgICB0cmFuc2xhdGVZOiB0eSxcclxuICAgICAgb3JpZ2luWDogY3gsXHJcbiAgICAgIG9yaWdpblk6IGN5LFxyXG5cclxuICAgICAgLy8gUmV0dXJuIHRoZSBtYXRyaXggcGFyYW1ldGVyc1xyXG4gICAgICBhOiB0aGlzLmEsXHJcbiAgICAgIGI6IHRoaXMuYixcclxuICAgICAgYzogdGhpcy5jLFxyXG4gICAgICBkOiB0aGlzLmQsXHJcbiAgICAgIGU6IHRoaXMuZSxcclxuICAgICAgZjogdGhpcy5mXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBMZWZ0IG11bHRpcGxpZXMgYnkgdGhlIGdpdmVuIG1hdHJpeFxyXG4gIG11bHRpcGx5IChtYXRyaXgpIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsdGlwbHlPKG1hdHJpeClcclxuICB9XHJcblxyXG4gIG11bHRpcGx5TyAobWF0cml4KSB7XHJcbiAgICAvLyBHZXQgdGhlIG1hdHJpY2VzXHJcbiAgICB2YXIgbCA9IHRoaXNcclxuICAgIHZhciByID0gbWF0cml4IGluc3RhbmNlb2YgTWF0cml4XHJcbiAgICAgID8gbWF0cml4XHJcbiAgICAgIDogbmV3IE1hdHJpeChtYXRyaXgpXHJcblxyXG4gICAgcmV0dXJuIE1hdHJpeC5tYXRyaXhNdWx0aXBseShsLCByLCB0aGlzKVxyXG4gIH1cclxuXHJcbiAgbG11bHRpcGx5IChtYXRyaXgpIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkubG11bHRpcGx5TyhtYXRyaXgpXHJcbiAgfVxyXG5cclxuICBsbXVsdGlwbHlPIChtYXRyaXgpIHtcclxuICAgIHZhciByID0gdGhpc1xyXG4gICAgdmFyIGwgPSBtYXRyaXggaW5zdGFuY2VvZiBNYXRyaXhcclxuICAgICAgPyBtYXRyaXhcclxuICAgICAgOiBuZXcgTWF0cml4KG1hdHJpeClcclxuXHJcbiAgICByZXR1cm4gTWF0cml4Lm1hdHJpeE11bHRpcGx5KGwsIHIsIHRoaXMpXHJcbiAgfVxyXG5cclxuICAvLyBJbnZlcnNlcyBtYXRyaXhcclxuICBpbnZlcnNlTyAoKSB7XHJcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGFyYW1ldGVycyBvdXQgb2YgdGhlIG1hdHJpeFxyXG4gICAgdmFyIGEgPSB0aGlzLmFcclxuICAgIHZhciBiID0gdGhpcy5iXHJcbiAgICB2YXIgYyA9IHRoaXMuY1xyXG4gICAgdmFyIGQgPSB0aGlzLmRcclxuICAgIHZhciBlID0gdGhpcy5lXHJcbiAgICB2YXIgZiA9IHRoaXMuZlxyXG5cclxuICAgIC8vIEludmVydCB0aGUgMngyIG1hdHJpeCBpbiB0aGUgdG9wIGxlZnRcclxuICAgIHZhciBkZXQgPSBhICogZCAtIGIgKiBjXHJcbiAgICBpZiAoIWRldCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52ZXJ0ICcgKyB0aGlzKVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdG9wIDJ4MiBtYXRyaXhcclxuICAgIHZhciBuYSA9IGQgLyBkZXRcclxuICAgIHZhciBuYiA9IC1iIC8gZGV0XHJcbiAgICB2YXIgbmMgPSAtYyAvIGRldFxyXG4gICAgdmFyIG5kID0gYSAvIGRldFxyXG5cclxuICAgIC8vIEFwcGx5IHRoZSBpbnZlcnRlZCBtYXRyaXggdG8gdGhlIHRvcCByaWdodFxyXG4gICAgdmFyIG5lID0gLShuYSAqIGUgKyBuYyAqIGYpXHJcbiAgICB2YXIgbmYgPSAtKG5iICogZSArIG5kICogZilcclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGludmVydGVkIG1hdHJpeFxyXG4gICAgdGhpcy5hID0gbmFcclxuICAgIHRoaXMuYiA9IG5iXHJcbiAgICB0aGlzLmMgPSBuY1xyXG4gICAgdGhpcy5kID0gbmRcclxuICAgIHRoaXMuZSA9IG5lXHJcbiAgICB0aGlzLmYgPSBuZlxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBpbnZlcnNlICgpIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW52ZXJzZU8oKVxyXG4gIH1cclxuXHJcbiAgLy8gVHJhbnNsYXRlIG1hdHJpeFxyXG4gIHRyYW5zbGF0ZSAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS50cmFuc2xhdGVPKHgsIHkpXHJcbiAgfVxyXG5cclxuICB0cmFuc2xhdGVPICh4LCB5KSB7XHJcbiAgICB0aGlzLmUgKz0geCB8fCAwXHJcbiAgICB0aGlzLmYgKz0geSB8fCAwXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gU2NhbGUgbWF0cml4XHJcbiAgc2NhbGUgKHgsIHksIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zY2FsZU8oLi4uYXJndW1lbnRzKVxyXG4gIH1cclxuXHJcbiAgc2NhbGVPICh4LCB5ID0geCwgY3ggPSAwLCBjeSA9IDApIHtcclxuICAgIC8vIFN1cHBvcnQgdW5pZm9ybSBzY2FsaW5nXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICBjeSA9IGN4XHJcbiAgICAgIGN4ID0geVxyXG4gICAgICB5ID0geFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgYSwgYiwgYywgZCwgZSwgZiB9ID0gdGhpc1xyXG5cclxuICAgIHRoaXMuYSA9IGEgKiB4XHJcbiAgICB0aGlzLmIgPSBiICogeVxyXG4gICAgdGhpcy5jID0gYyAqIHhcclxuICAgIHRoaXMuZCA9IGQgKiB5XHJcbiAgICB0aGlzLmUgPSBlICogeCAtIGN4ICogeCArIGN4XHJcbiAgICB0aGlzLmYgPSBmICogeSAtIGN5ICogeSArIGN5XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFJvdGF0ZSBtYXRyaXhcclxuICByb3RhdGUgKHIsIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5yb3RhdGVPKHIsIGN4LCBjeSlcclxuICB9XHJcblxyXG4gIHJvdGF0ZU8gKHIsIGN4ID0gMCwgY3kgPSAwKSB7XHJcbiAgICAvLyBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xyXG4gICAgciA9IHJhZGlhbnMocilcclxuXHJcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyKVxyXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocilcclxuXHJcbiAgICBjb25zdCB7IGEsIGIsIGMsIGQsIGUsIGYgfSA9IHRoaXNcclxuXHJcbiAgICB0aGlzLmEgPSBhICogY29zIC0gYiAqIHNpblxyXG4gICAgdGhpcy5iID0gYiAqIGNvcyArIGEgKiBzaW5cclxuICAgIHRoaXMuYyA9IGMgKiBjb3MgLSBkICogc2luXHJcbiAgICB0aGlzLmQgPSBkICogY29zICsgYyAqIHNpblxyXG4gICAgdGhpcy5lID0gZSAqIGNvcyAtIGYgKiBzaW4gKyBjeSAqIHNpbiAtIGN4ICogY29zICsgY3hcclxuICAgIHRoaXMuZiA9IGYgKiBjb3MgKyBlICogc2luIC0gY3ggKiBzaW4gLSBjeSAqIGNvcyArIGN5XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIEZsaXAgbWF0cml4IG9uIHggb3IgeSwgYXQgYSBnaXZlbiBvZmZzZXRcclxuICBmbGlwIChheGlzLCBhcm91bmQpIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuZmxpcE8oYXhpcywgYXJvdW5kKVxyXG4gIH1cclxuXHJcbiAgZmxpcE8gKGF4aXMsIGFyb3VuZCkge1xyXG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMuc2NhbGVPKC0xLCAxLCBhcm91bmQsIDApXHJcbiAgICAgIDogYXhpcyA9PT0gJ3knID8gdGhpcy5zY2FsZU8oMSwgLTEsIDAsIGFyb3VuZClcclxuICAgICAgOiB0aGlzLnNjYWxlTygtMSwgLTEsIGF4aXMsIGFyb3VuZCB8fCBheGlzKSAvLyBEZWZpbmUgYW4geCwgeSBmbGlwIHBvaW50XHJcbiAgfVxyXG5cclxuICAvLyBTaGVhciBtYXRyaXhcclxuICBzaGVhciAoYSwgY3gsIGN5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNoZWFyTyhhLCBjeCwgY3kpXHJcbiAgfVxyXG5cclxuICBzaGVhck8gKGx4LCBjeCA9IDAsIGN5ID0gMCkge1xyXG4gICAgY29uc3QgeyBhLCBiLCBjLCBkLCBlLCBmIH0gPSB0aGlzXHJcblxyXG4gICAgdGhpcy5hID0gYSArIGIgKiBseFxyXG4gICAgdGhpcy5jID0gYyArIGQgKiBseFxyXG4gICAgdGhpcy5lID0gZSArIGYgKiBseCAtIGN5ICogbHhcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gU2tldyBNYXRyaXhcclxuICBza2V3ICh4LCB5LCBjeCwgY3kpIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuc2tld08oLi4uYXJndW1lbnRzKVxyXG4gIH1cclxuXHJcbiAgc2tld08gKHgsIHkgPSB4LCBjeCA9IDAsIGN5ID0gMCkge1xyXG4gICAgLy8gc3VwcG9ydCB1bmlmb3JtYWwgc2tld1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcclxuICAgICAgY3kgPSBjeFxyXG4gICAgICBjeCA9IHlcclxuICAgICAgeSA9IHhcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xyXG4gICAgeCA9IHJhZGlhbnMoeClcclxuICAgIHkgPSByYWRpYW5zKHkpXHJcblxyXG4gICAgY29uc3QgbHggPSBNYXRoLnRhbih4KVxyXG4gICAgY29uc3QgbHkgPSBNYXRoLnRhbih5KVxyXG5cclxuICAgIGNvbnN0IHsgYSwgYiwgYywgZCwgZSwgZiB9ID0gdGhpc1xyXG5cclxuICAgIHRoaXMuYSA9IGEgKyBiICogbHhcclxuICAgIHRoaXMuYiA9IGIgKyBhICogbHlcclxuICAgIHRoaXMuYyA9IGMgKyBkICogbHhcclxuICAgIHRoaXMuZCA9IGQgKyBjICogbHlcclxuICAgIHRoaXMuZSA9IGUgKyBmICogbHggLSBjeSAqIGx4XHJcbiAgICB0aGlzLmYgPSBmICsgZSAqIGx5IC0gY3ggKiBseVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBTa2V3WFxyXG4gIHNrZXdYICh4LCBjeCwgY3kpIHtcclxuICAgIHJldHVybiB0aGlzLnNrZXcoeCwgMCwgY3gsIGN5KVxyXG4gIH1cclxuXHJcbiAgc2tld1hPICh4LCBjeCwgY3kpIHtcclxuICAgIHJldHVybiB0aGlzLnNrZXdPKHgsIDAsIGN4LCBjeSlcclxuICB9XHJcblxyXG4gIC8vIFNrZXdZXHJcbiAgc2tld1kgKHksIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2tldygwLCB5LCBjeCwgY3kpXHJcbiAgfVxyXG5cclxuICBza2V3WU8gKHksIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2tld08oMCwgeSwgY3gsIGN5KVxyXG4gIH1cclxuXHJcbiAgLy8gVHJhbnNmb3JtIGFyb3VuZCBhIGNlbnRlciBwb2ludFxyXG4gIGFyb3VuZE8gKGN4LCBjeSwgbWF0cml4KSB7XHJcbiAgICB2YXIgZHggPSBjeCB8fCAwXHJcbiAgICB2YXIgZHkgPSBjeSB8fCAwXHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPKC1keCwgLWR5KS5sbXVsdGlwbHlPKG1hdHJpeCkudHJhbnNsYXRlTyhkeCwgZHkpXHJcbiAgfVxyXG5cclxuICBhcm91bmQgKGN4LCBjeSwgbWF0cml4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmFyb3VuZE8oY3gsIGN5LCBtYXRyaXgpXHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiB0d28gbWF0cmljZXMgYXJlIGVxdWFsXHJcbiAgZXF1YWxzIChvdGhlcikge1xyXG4gICAgdmFyIGNvbXAgPSBuZXcgTWF0cml4KG90aGVyKVxyXG4gICAgcmV0dXJuIGNsb3NlRW5vdWdoKHRoaXMuYSwgY29tcC5hKSAmJiBjbG9zZUVub3VnaCh0aGlzLmIsIGNvbXAuYilcclxuICAgICAgJiYgY2xvc2VFbm91Z2godGhpcy5jLCBjb21wLmMpICYmIGNsb3NlRW5vdWdoKHRoaXMuZCwgY29tcC5kKVxyXG4gICAgICAmJiBjbG9zZUVub3VnaCh0aGlzLmUsIGNvbXAuZSkgJiYgY2xvc2VFbm91Z2godGhpcy5mLCBjb21wLmYpXHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IG1hdHJpeCB0byBzdHJpbmdcclxuICB0b1N0cmluZyAoKSB7XHJcbiAgICByZXR1cm4gJ21hdHJpeCgnICsgdGhpcy5hICsgJywnICsgdGhpcy5iICsgJywnICsgdGhpcy5jICsgJywnICsgdGhpcy5kICsgJywnICsgdGhpcy5lICsgJywnICsgdGhpcy5mICsgJyknXHJcbiAgfVxyXG5cclxuICB0b0FycmF5ICgpIHtcclxuICAgIHJldHVybiBbIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYgXVxyXG4gIH1cclxuXHJcbiAgdmFsdWVPZiAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhOiB0aGlzLmEsXHJcbiAgICAgIGI6IHRoaXMuYixcclxuICAgICAgYzogdGhpcy5jLFxyXG4gICAgICBkOiB0aGlzLmQsXHJcbiAgICAgIGU6IHRoaXMuZSxcclxuICAgICAgZjogdGhpcy5mXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbUFycmF5IChhKSB7XHJcbiAgICByZXR1cm4geyBhOiBhWzBdLCBiOiBhWzFdLCBjOiBhWzJdLCBkOiBhWzNdLCBlOiBhWzRdLCBmOiBhWzVdIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBpc01hdHJpeExpa2UgKG8pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIG8uYSAhPSBudWxsXHJcbiAgICAgIHx8IG8uYiAhPSBudWxsXHJcbiAgICAgIHx8IG8uYyAhPSBudWxsXHJcbiAgICAgIHx8IG8uZCAhPSBudWxsXHJcbiAgICAgIHx8IG8uZSAhPSBudWxsXHJcbiAgICAgIHx8IG8uZiAhPSBudWxsXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZm9ybWF0VHJhbnNmb3JtcyAobykge1xyXG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgcGFyYW1ldGVycyByZXF1aXJlZCB0byBmb3JtIHRoZSBtYXRyaXhcclxuICAgIHZhciBmbGlwQm90aCA9IG8uZmxpcCA9PT0gJ2JvdGgnIHx8IG8uZmxpcCA9PT0gdHJ1ZVxyXG4gICAgdmFyIGZsaXBYID0gby5mbGlwICYmIChmbGlwQm90aCB8fCBvLmZsaXAgPT09ICd4JykgPyAtMSA6IDFcclxuICAgIHZhciBmbGlwWSA9IG8uZmxpcCAmJiAoZmxpcEJvdGggfHwgby5mbGlwID09PSAneScpID8gLTEgOiAxXHJcbiAgICB2YXIgc2tld1ggPSBvLnNrZXcgJiYgby5za2V3Lmxlbmd0aCA/IG8uc2tld1swXVxyXG4gICAgICA6IGlzRmluaXRlKG8uc2tldykgPyBvLnNrZXdcclxuICAgICAgOiBpc0Zpbml0ZShvLnNrZXdYKSA/IG8uc2tld1hcclxuICAgICAgOiAwXHJcbiAgICB2YXIgc2tld1kgPSBvLnNrZXcgJiYgby5za2V3Lmxlbmd0aCA/IG8uc2tld1sxXVxyXG4gICAgICA6IGlzRmluaXRlKG8uc2tldykgPyBvLnNrZXdcclxuICAgICAgOiBpc0Zpbml0ZShvLnNrZXdZKSA/IG8uc2tld1lcclxuICAgICAgOiAwXHJcbiAgICB2YXIgc2NhbGVYID0gby5zY2FsZSAmJiBvLnNjYWxlLmxlbmd0aCA/IG8uc2NhbGVbMF0gKiBmbGlwWFxyXG4gICAgICA6IGlzRmluaXRlKG8uc2NhbGUpID8gby5zY2FsZSAqIGZsaXBYXHJcbiAgICAgIDogaXNGaW5pdGUoby5zY2FsZVgpID8gby5zY2FsZVggKiBmbGlwWFxyXG4gICAgICA6IGZsaXBYXHJcbiAgICB2YXIgc2NhbGVZID0gby5zY2FsZSAmJiBvLnNjYWxlLmxlbmd0aCA/IG8uc2NhbGVbMV0gKiBmbGlwWVxyXG4gICAgICA6IGlzRmluaXRlKG8uc2NhbGUpID8gby5zY2FsZSAqIGZsaXBZXHJcbiAgICAgIDogaXNGaW5pdGUoby5zY2FsZVkpID8gby5zY2FsZVkgKiBmbGlwWVxyXG4gICAgICA6IGZsaXBZXHJcbiAgICB2YXIgc2hlYXIgPSBvLnNoZWFyIHx8IDBcclxuICAgIHZhciB0aGV0YSA9IG8ucm90YXRlIHx8IG8udGhldGEgfHwgMFxyXG4gICAgdmFyIG9yaWdpbiA9IG5ldyBQb2ludChvLm9yaWdpbiB8fCBvLmFyb3VuZCB8fCBvLm94IHx8IG8ub3JpZ2luWCwgby5veSB8fCBvLm9yaWdpblkpXHJcbiAgICB2YXIgb3ggPSBvcmlnaW4ueFxyXG4gICAgdmFyIG95ID0gb3JpZ2luLnlcclxuICAgIHZhciBwb3NpdGlvbiA9IG5ldyBQb2ludChvLnBvc2l0aW9uIHx8IG8ucHggfHwgby5wb3NpdGlvblgsIG8ucHkgfHwgby5wb3NpdGlvblkpXHJcbiAgICB2YXIgcHggPSBwb3NpdGlvbi54XHJcbiAgICB2YXIgcHkgPSBwb3NpdGlvbi55XHJcbiAgICB2YXIgdHJhbnNsYXRlID0gbmV3IFBvaW50KG8udHJhbnNsYXRlIHx8IG8udHggfHwgby50cmFuc2xhdGVYLCBvLnR5IHx8IG8udHJhbnNsYXRlWSlcclxuICAgIHZhciB0eCA9IHRyYW5zbGF0ZS54XHJcbiAgICB2YXIgdHkgPSB0cmFuc2xhdGUueVxyXG4gICAgdmFyIHJlbGF0aXZlID0gbmV3IFBvaW50KG8ucmVsYXRpdmUgfHwgby5yeCB8fCBvLnJlbGF0aXZlWCwgby5yeSB8fCBvLnJlbGF0aXZlWSlcclxuICAgIHZhciByeCA9IHJlbGF0aXZlLnhcclxuICAgIHZhciByeSA9IHJlbGF0aXZlLnlcclxuXHJcbiAgICAvLyBQb3B1bGF0ZSBhbGwgb2YgdGhlIHZhbHVlc1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2NhbGVYLCBzY2FsZVksIHNrZXdYLCBza2V3WSwgc2hlYXIsIHRoZXRhLCByeCwgcnksIHR4LCB0eSwgb3gsIG95LCBweCwgcHlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGxlZnQgbWF0cml4LCByaWdodCBtYXRyaXgsIHRhcmdldCBtYXRyaXggd2hpY2ggaXMgb3ZlcndyaXR0ZW5cclxuICBzdGF0aWMgbWF0cml4TXVsdGlwbHkgKGwsIHIsIG8pIHtcclxuICAgIC8vIFdvcmsgb3V0IHRoZSBwcm9kdWN0IGRpcmVjdGx5XHJcbiAgICB2YXIgYSA9IGwuYSAqIHIuYSArIGwuYyAqIHIuYlxyXG4gICAgdmFyIGIgPSBsLmIgKiByLmEgKyBsLmQgKiByLmJcclxuICAgIHZhciBjID0gbC5hICogci5jICsgbC5jICogci5kXHJcbiAgICB2YXIgZCA9IGwuYiAqIHIuYyArIGwuZCAqIHIuZFxyXG4gICAgdmFyIGUgPSBsLmUgKyBsLmEgKiByLmUgKyBsLmMgKiByLmZcclxuICAgIHZhciBmID0gbC5mICsgbC5iICogci5lICsgbC5kICogci5mXHJcblxyXG4gICAgLy8gbWFrZSBzdXJlIHRvIHVzZSBsb2NhbCB2YXJpYWJsZXMgYmVjYXVzZSBsL3IgYW5kIG8gY291bGQgYmUgdGhlIHNhbWVcclxuICAgIG8uYSA9IGFcclxuICAgIG8uYiA9IGJcclxuICAgIG8uYyA9IGNcclxuICAgIG8uZCA9IGRcclxuICAgIG8uZSA9IGVcclxuICAgIG8uZiA9IGZcclxuXHJcbiAgICByZXR1cm4gb1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGN0bSAoKSB7XHJcbiAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5ub2RlLmdldENUTSgpKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2NyZWVuQ1RNICgpIHtcclxuICAvKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzQ0NTM3XHJcbiAgICAgVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBGRiBkb2VzIG5vdCByZXR1cm4gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG4gICAgIGZvciB0aGUgaW5uZXIgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlbiBnZXRTY3JlZW5DVE0oKSBpcyBjYWxsZWQgb24gbmVzdGVkIHN2Z3MuXHJcbiAgICAgSG93ZXZlciBhbGwgb3RoZXIgQnJvd3NlcnMgZG8gdGhhdCAqL1xyXG4gIGlmICh0eXBlb2YgdGhpcy5pc1Jvb3QgPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuaXNSb290KCkpIHtcclxuICAgIHZhciByZWN0ID0gdGhpcy5yZWN0KDEsIDEpXHJcbiAgICB2YXIgbSA9IHJlY3Qubm9kZS5nZXRTY3JlZW5DVE0oKVxyXG4gICAgcmVjdC5yZW1vdmUoKVxyXG4gICAgcmV0dXJuIG5ldyBNYXRyaXgobSlcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5ub2RlLmdldFNjcmVlbkNUTSgpKVxyXG59XHJcblxyXG5yZWdpc3RlcihNYXRyaXgsICdNYXRyaXgnKVxyXG4iLCJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5pbXBvcnQgeyBtYWtlSW5zdGFuY2UgfSBmcm9tICcuLi8uLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VyICgpIHtcclxuICAvLyBSZXVzZSBjYWNoZWQgZWxlbWVudCBpZiBwb3NzaWJsZVxyXG4gIGlmICghcGFyc2VyLm5vZGVzKSB7XHJcbiAgICBjb25zdCBzdmcgPSBtYWtlSW5zdGFuY2UoKS5zaXplKDIsIDApXHJcbiAgICBzdmcubm9kZS5zdHlsZS5jc3NUZXh0ID0gW1xyXG4gICAgICAnb3BhY2l0eTogMCcsXHJcbiAgICAgICdwb3NpdGlvbjogYWJzb2x1dGUnLFxyXG4gICAgICAnbGVmdDogLTEwMCUnLFxyXG4gICAgICAndG9wOiAtMTAwJScsXHJcbiAgICAgICdvdmVyZmxvdzogaGlkZGVuJ1xyXG4gICAgXS5qb2luKCc7JylcclxuXHJcbiAgICBzdmcuYXR0cignZm9jdXNhYmxlJywgJ2ZhbHNlJylcclxuICAgIHN2Zy5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJylcclxuXHJcbiAgICBjb25zdCBwYXRoID0gc3ZnLnBhdGgoKS5ub2RlXHJcblxyXG4gICAgcGFyc2VyLm5vZGVzID0geyBzdmcsIHBhdGggfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFwYXJzZXIubm9kZXMuc3ZnLm5vZGUucGFyZW50Tm9kZSkge1xyXG4gICAgY29uc3QgYiA9IGdsb2JhbHMuZG9jdW1lbnQuYm9keSB8fCBnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxyXG4gICAgcGFyc2VyLm5vZGVzLnN2Zy5hZGRUbyhiKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhcnNlci5ub2Rlc1xyXG59XHJcbiIsImltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcclxuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgTWF0cml4IGZyb20gJy4vTWF0cml4LmpzJ1xyXG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcydcclxuaW1wb3J0IHBhcnNlciBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcGFyc2VyLmpzJ1xyXG5cclxuZnVuY3Rpb24gaXNOdWxsZWRCb3ggKGJveCkge1xyXG4gIHJldHVybiAhYm94LndpZHRoICYmICFib3guaGVpZ2h0ICYmICFib3gueCAmJiAhYm94LnlcclxufVxyXG5cclxuZnVuY3Rpb24gZG9tQ29udGFpbnMgKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZSA9PT0gZ2xvYmFscy5kb2N1bWVudFxyXG4gICAgfHwgKGdsb2JhbHMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zIHx8IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgIC8vIFRoaXMgaXMgSUUgLSBpdCBkb2VzIG5vdCBzdXBwb3J0IGNvbnRhaW5zKCkgZm9yIHRvcC1sZXZlbCBTVkdzXHJcbiAgICAgIHdoaWxlIChub2RlLnBhcmVudE5vZGUpIHtcclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5vZGUgPT09IGdsb2JhbHMuZG9jdW1lbnRcclxuICAgIH0pLmNhbGwoZ2xvYmFscy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJveCB7XHJcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgaW5pdCAoc291cmNlKSB7XHJcbiAgICB2YXIgYmFzZSA9IFsgMCwgMCwgMCwgMCBdXHJcbiAgICBzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHNvdXJjZS5zcGxpdChkZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KVxyXG4gICAgICA6IEFycmF5LmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZVxyXG4gICAgICA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnID8gWyBzb3VyY2UubGVmdCAhPSBudWxsID8gc291cmNlLmxlZnRcclxuICAgICAgOiBzb3VyY2UueCwgc291cmNlLnRvcCAhPSBudWxsID8gc291cmNlLnRvcCA6IHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQgXVxyXG4gICAgICA6IGFyZ3VtZW50cy5sZW5ndGggPT09IDQgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuICAgICAgOiBiYXNlXHJcblxyXG4gICAgdGhpcy54ID0gc291cmNlWzBdIHx8IDBcclxuICAgIHRoaXMueSA9IHNvdXJjZVsxXSB8fCAwXHJcbiAgICB0aGlzLndpZHRoID0gdGhpcy53ID0gc291cmNlWzJdIHx8IDBcclxuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oID0gc291cmNlWzNdIHx8IDBcclxuXHJcbiAgICAvLyBBZGQgbW9yZSBib3VuZGluZyBib3ggcHJvcGVydGllc1xyXG4gICAgdGhpcy54MiA9IHRoaXMueCArIHRoaXMud1xyXG4gICAgdGhpcy55MiA9IHRoaXMueSArIHRoaXMuaFxyXG4gICAgdGhpcy5jeCA9IHRoaXMueCArIHRoaXMudyAvIDJcclxuICAgIHRoaXMuY3kgPSB0aGlzLnkgKyB0aGlzLmggLyAyXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIE1lcmdlIHJlY3QgYm94IHdpdGggYW5vdGhlciwgcmV0dXJuIGEgbmV3IGluc3RhbmNlXHJcbiAgbWVyZ2UgKGJveCkge1xyXG4gICAgY29uc3QgeCA9IE1hdGgubWluKHRoaXMueCwgYm94LngpXHJcbiAgICBjb25zdCB5ID0gTWF0aC5taW4odGhpcy55LCBib3gueSlcclxuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgYm94LnggKyBib3gud2lkdGgpIC0geFxyXG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIGJveC55ICsgYm94LmhlaWdodCkgLSB5XHJcblxyXG4gICAgcmV0dXJuIG5ldyBCb3goeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICB9XHJcblxyXG4gIHRyYW5zZm9ybSAobSkge1xyXG4gICAgaWYgKCEobSBpbnN0YW5jZW9mIE1hdHJpeCkpIHtcclxuICAgICAgbSA9IG5ldyBNYXRyaXgobSlcclxuICAgIH1cclxuXHJcbiAgICBsZXQgeE1pbiA9IEluZmluaXR5XHJcbiAgICBsZXQgeE1heCA9IC1JbmZpbml0eVxyXG4gICAgbGV0IHlNaW4gPSBJbmZpbml0eVxyXG4gICAgbGV0IHlNYXggPSAtSW5maW5pdHlcclxuXHJcbiAgICBjb25zdCBwdHMgPSBbXHJcbiAgICAgIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSksXHJcbiAgICAgIG5ldyBQb2ludCh0aGlzLngyLCB0aGlzLnkpLFxyXG4gICAgICBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkyKSxcclxuICAgICAgbmV3IFBvaW50KHRoaXMueDIsIHRoaXMueTIpXHJcbiAgICBdXHJcblxyXG4gICAgcHRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgcCA9IHAudHJhbnNmb3JtKG0pXHJcbiAgICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLCBwLngpXHJcbiAgICAgIHhNYXggPSBNYXRoLm1heCh4TWF4LCBwLngpXHJcbiAgICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLCBwLnkpXHJcbiAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCBwLnkpXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBuZXcgQm94KFxyXG4gICAgICB4TWluLCB5TWluLFxyXG4gICAgICB4TWF4IC0geE1pbixcclxuICAgICAgeU1heCAtIHlNaW5cclxuICAgIClcclxuICB9XHJcblxyXG4gIGFkZE9mZnNldCAoKSB7XHJcbiAgICAvLyBvZmZzZXQgYnkgd2luZG93IHNjcm9sbCBwb3NpdGlvbiwgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgY2hhbmdlcyB3aGVuIHdpbmRvdyBpcyBzY3JvbGxlZFxyXG4gICAgdGhpcy54ICs9IGdsb2JhbHMud2luZG93LnBhZ2VYT2Zmc2V0XHJcbiAgICB0aGlzLnkgKz0gZ2xvYmFscy53aW5kb3cucGFnZVlPZmZzZXRcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB0b1N0cmluZyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy54ICsgJyAnICsgdGhpcy55ICsgJyAnICsgdGhpcy53aWR0aCArICcgJyArIHRoaXMuaGVpZ2h0XHJcbiAgfVxyXG5cclxuICB0b0FycmF5ICgpIHtcclxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCBdXHJcbiAgfVxyXG5cclxuICBpc051bGxlZCAoKSB7XHJcbiAgICByZXR1cm4gaXNOdWxsZWRCb3godGhpcylcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEJveCAoY2IsIHJldHJ5KSB7XHJcbiAgbGV0IGJveFxyXG5cclxuICB0cnkge1xyXG4gICAgYm94ID0gY2IodGhpcy5ub2RlKVxyXG5cclxuICAgIGlmIChpc051bGxlZEJveChib3gpICYmICFkb21Db250YWlucyh0aGlzLm5vZGUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBub3QgaW4gdGhlIGRvbScpXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgYm94ID0gcmV0cnkodGhpcylcclxuICB9XHJcblxyXG4gIHJldHVybiBib3hcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJib3ggKCkge1xyXG4gIHJldHVybiBuZXcgQm94KGdldEJveC5jYWxsKHRoaXMsIChub2RlKSA9PiBub2RlLmdldEJCb3goKSwgKGVsKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lKCkuYWRkVG8ocGFyc2VyKCkuc3ZnKS5zaG93KClcclxuICAgICAgY29uc3QgYm94ID0gY2xvbmUubm9kZS5nZXRCQm94KClcclxuICAgICAgY2xvbmUucmVtb3ZlKClcclxuICAgICAgcmV0dXJuIGJveFxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldHRpbmcgYmJveCBvZiBlbGVtZW50IFwiJyArIGVsLm5vZGUubm9kZU5hbWUgKyAnXCIgaXMgbm90IHBvc3NpYmxlLiAnICsgZS50b1N0cmluZygpKVxyXG4gICAgfVxyXG4gIH0pKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmJveCAoZWwpIHtcclxuICBjb25zdCBib3ggPSBuZXcgQm94KGdldEJveC5jYWxsKHRoaXMsIChub2RlKSA9PiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCAoZWwpID0+IHtcclxuICAgIHRocm93IG5ldyBFcnJvcignR2V0dGluZyByYm94IG9mIGVsZW1lbnQgXCInICsgZWwubm9kZS5ub2RlTmFtZSArICdcIiBpcyBub3QgcG9zc2libGUnKVxyXG4gIH0pKVxyXG4gIGlmIChlbCkgcmV0dXJuIGJveC50cmFuc2Zvcm0oZWwuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpKVxyXG4gIHJldHVybiBib3guYWRkT2Zmc2V0KClcclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICB2aWV3Ym94OiB7XHJcbiAgICB2aWV3Ym94ICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcclxuICAgICAgaWYgKHggPT0gbnVsbCkgcmV0dXJuIG5ldyBCb3godGhpcy5hdHRyKCd2aWV3Qm94JykpXHJcblxyXG4gICAgICAvLyBhY3QgYXMgc2V0dGVyXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3ZpZXdCb3gnLCBuZXcgQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpKVxyXG4gICAgfSxcclxuXHJcbiAgICB6b29tIChsZXZlbCwgcG9pbnQpIHtcclxuICAgICAgbGV0IHdpZHRoID0gdGhpcy5ub2RlLmNsaWVudFdpZHRoXHJcbiAgICAgIGxldCBoZWlnaHQgPSB0aGlzLm5vZGUuY2xpZW50SGVpZ2h0XHJcbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZpZXdib3goKVxyXG5cclxuICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IGNsaWVudEhlaWdodCBhbmQgcmV0dXJucyAwXHJcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg3NDgxMVxyXG4gICAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcclxuICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5vZGUpXHJcbiAgICAgICAgd2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykpXHJcbiAgICAgICAgaGVpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKSlcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgem9vbVggPSB3aWR0aCAvIHYud2lkdGhcclxuICAgICAgY29uc3Qgem9vbVkgPSBoZWlnaHQgLyB2LmhlaWdodFxyXG4gICAgICBjb25zdCB6b29tID0gTWF0aC5taW4oem9vbVgsIHpvb21ZKVxyXG5cclxuICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gem9vbVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgem9vbUFtb3VudCA9IHpvb20gLyBsZXZlbFxyXG4gICAgICBpZiAoem9vbUFtb3VudCA9PT0gSW5maW5pdHkpIHpvb21BbW91bnQgPSBOdW1iZXIuTUlOX1ZBTFVFXHJcblxyXG4gICAgICBwb2ludCA9IHBvaW50IHx8IG5ldyBQb2ludCh3aWR0aCAvIDIgLyB6b29tWCArIHYueCwgaGVpZ2h0IC8gMiAvIHpvb21ZICsgdi55KVxyXG5cclxuICAgICAgY29uc3QgYm94ID0gbmV3IEJveCh2KS50cmFuc2Zvcm0oXHJcbiAgICAgICAgbmV3IE1hdHJpeCh7IHNjYWxlOiB6b29tQW1vdW50LCBvcmlnaW46IHBvaW50IH0pXHJcbiAgICAgIClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnZpZXdib3goYm94KVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKEJveCwgJ0JveCcpXHJcbiIsIi8qIGVzbGludCBuby1uZXctZnVuYzogXCJvZmZcIiAqL1xyXG5leHBvcnQgY29uc3Qgc3ViQ2xhc3NBcnJheSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIHRyeSBlczYgc3ViY2xhc3NpbmdcclxuICAgIHJldHVybiBGdW5jdGlvbignbmFtZScsICdiYXNlQ2xhc3MnLCAnX2NvbnN0cnVjdG9yJywgW1xyXG4gICAgICAnYmFzZUNsYXNzID0gYmFzZUNsYXNzIHx8IEFycmF5JyxcclxuICAgICAgJ3JldHVybiB7JyxcclxuICAgICAgJyAgW25hbWVdOiBjbGFzcyBleHRlbmRzIGJhc2VDbGFzcyB7JyxcclxuICAgICAgJyAgICBjb25zdHJ1Y3RvciAoLi4uYXJncykgeycsXHJcbiAgICAgICcgICAgICBzdXBlciguLi5hcmdzKScsXHJcbiAgICAgICcgICAgICBfY29uc3RydWN0b3IgJiYgX2NvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3MpJyxcclxuICAgICAgJyAgICB9JyxcclxuICAgICAgJyAgfScsXHJcbiAgICAgICd9W25hbWVdJ1xyXG4gICAgXS5qb2luKCdcXG4nKSlcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBVc2UgZXM1IGFwcHJvYWNoXHJcbiAgICByZXR1cm4gKG5hbWUsIGJhc2VDbGFzcyA9IEFycmF5LCBfY29uc3RydWN0b3IpID0+IHtcclxuICAgICAgY29uc3QgQXJyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGJhc2VDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXHJcbiAgICAgICAgX2NvbnN0cnVjdG9yICYmIF9jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIEFyci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VDbGFzcy5wcm90b3R5cGUpXHJcbiAgICAgIEFyci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJcclxuXHJcbiAgICAgIEFyci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IEFycigpXHJcbiAgICAgICAgYXJyLnB1c2guYXBwbHkoYXJyLCBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodGhpcywgZm4pKVxyXG4gICAgICAgIHJldHVybiBhcnJcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIEFyclxyXG4gICAgfVxyXG4gIH1cclxufSkoKVxyXG4iLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBzdWJDbGFzc0FycmF5IH0gZnJvbSAnLi9BcnJheVBvbHlmaWxsLmpzJ1xyXG5cclxuY29uc3QgTGlzdCA9IHN1YkNsYXNzQXJyYXkoJ0xpc3QnLCBBcnJheSwgZnVuY3Rpb24gKGFyciA9IFtdKSB7XHJcbiAgLy8gVGhpcyBjYXRjaGVzIHRoZSBjYXNlLCB0aGF0IG5hdGl2ZSBtYXAgdHJpZXMgdG8gY3JlYXRlIGFuIGFycmF5IHdpdGggbmV3IEFycmF5KDEpXHJcbiAgaWYgKHR5cGVvZiBhcnIgPT09ICdudW1iZXInKSByZXR1cm4gdGhpc1xyXG4gIHRoaXMubGVuZ3RoID0gMFxyXG4gIHRoaXMucHVzaCguLi5hcnIpXHJcbn0pXHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaXN0XHJcblxyXG5leHRlbmQoTGlzdCwge1xyXG4gIGVhY2ggKGZuT3JNZXRob2ROYW1lLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAodHlwZW9mIGZuT3JNZXRob2ROYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1hcCgoZWwpID0+IHtcclxuICAgICAgICByZXR1cm4gZm5Pck1ldGhvZE5hbWUuY2FsbChlbCwgZWwpXHJcbiAgICAgIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZWwgPT4ge1xyXG4gICAgICAgIHJldHVybiBlbFtmbk9yTWV0aG9kTmFtZV0oLi4uYXJncylcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB0b0FycmF5ICgpIHtcclxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0aGlzKVxyXG4gIH1cclxufSlcclxuXHJcbmNvbnN0IHJlc2VydmVkID0gWyAndG9BcnJheScsICdjb25zdHJ1Y3RvcicsICdlYWNoJyBdXHJcblxyXG5MaXN0LmV4dGVuZCA9IGZ1bmN0aW9uIChtZXRob2RzKSB7XHJcbiAgbWV0aG9kcyA9IG1ldGhvZHMucmVkdWNlKChvYmosIG5hbWUpID0+IHtcclxuICAgIC8vIERvbid0IG92ZXJ3cml0ZSBvd24gbWV0aG9kc1xyXG4gICAgaWYgKHJlc2VydmVkLmluY2x1ZGVzKG5hbWUpKSByZXR1cm4gb2JqXHJcblxyXG4gICAgLy8gRG9uJ3QgYWRkIHByaXZhdGUgbWV0aG9kc1xyXG4gICAgaWYgKG5hbWVbMF0gPT09ICdfJykgcmV0dXJuIG9ialxyXG5cclxuICAgIC8vIFJlbGF5IGV2ZXJ5IGNhbGwgdG8gZWFjaCgpXHJcbiAgICBvYmpbbmFtZV0gPSBmdW5jdGlvbiAoLi4uYXR0cnMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChuYW1lLCAuLi5hdHRycylcclxuICAgIH1cclxuICAgIHJldHVybiBvYmpcclxuICB9LCB7fSlcclxuXHJcbiAgZXh0ZW5kKExpc3QsIG1ldGhvZHMpXHJcbn1cclxuIiwiaW1wb3J0IHsgYWRvcHQgfSBmcm9tICcuLi8uLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuLi8uLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vdHlwZXMvTGlzdC5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhc2VGaW5kIChxdWVyeSwgcGFyZW50KSB7XHJcbiAgcmV0dXJuIG5ldyBMaXN0KG1hcCgocGFyZW50IHx8IGdsb2JhbHMuZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLCBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgcmV0dXJuIGFkb3B0KG5vZGUpXHJcbiAgfSkpXHJcbn1cclxuXHJcbi8vIFNjb3BlZCBmaW5kIG1ldGhvZFxyXG5leHBvcnQgZnVuY3Rpb24gZmluZCAocXVlcnkpIHtcclxuICByZXR1cm4gYmFzZUZpbmQocXVlcnksIHRoaXMubm9kZSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRPbmUgKHF1ZXJ5KSB7XHJcbiAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKHF1ZXJ5KSlcclxufVxyXG4iLCJpbXBvcnQgeyBkaXNwYXRjaCwgb2ZmLCBvbiB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9ldmVudC5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFRhcmdldCBleHRlbmRzIEJhc2Uge1xyXG4gIGNvbnN0cnVjdG9yICh7IGV2ZW50cyA9IHt9IH0gPSB7fSkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgdGhpcy5ldmVudHMgPSBldmVudHNcclxuICB9XHJcblxyXG4gIGFkZEV2ZW50TGlzdGVuZXIgKCkge31cclxuXHJcbiAgZGlzcGF0Y2ggKGV2ZW50LCBkYXRhKSB7XHJcbiAgICByZXR1cm4gZGlzcGF0Y2godGhpcywgZXZlbnQsIGRhdGEpXHJcbiAgfVxyXG5cclxuICBkaXNwYXRjaEV2ZW50IChldmVudCkge1xyXG4gICAgY29uc3QgYmFnID0gdGhpcy5nZXRFdmVudEhvbGRlcigpLmV2ZW50c1xyXG4gICAgaWYgKCFiYWcpIHJldHVybiB0cnVlXHJcblxyXG4gICAgY29uc3QgZXZlbnRzID0gYmFnW2V2ZW50LnR5cGVdXHJcblxyXG4gICAgZm9yIChjb25zdCBpIGluIGV2ZW50cykge1xyXG4gICAgICBmb3IgKGNvbnN0IGogaW4gZXZlbnRzW2ldKSB7XHJcbiAgICAgICAgZXZlbnRzW2ldW2pdKGV2ZW50KVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkXHJcbiAgfVxyXG5cclxuICAvLyBGaXJlIGdpdmVuIGV2ZW50XHJcbiAgZmlyZSAoZXZlbnQsIGRhdGEpIHtcclxuICAgIHRoaXMuZGlzcGF0Y2goZXZlbnQsIGRhdGEpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZ2V0RXZlbnRIb2xkZXIgKCkge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGdldEV2ZW50VGFyZ2V0ICgpIHtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBVbmJpbmQgZXZlbnQgZnJvbSBsaXN0ZW5lclxyXG4gIG9mZiAoZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICBvZmYodGhpcywgZXZlbnQsIGxpc3RlbmVyKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIEJpbmQgZ2l2ZW4gZXZlbnQgdG8gbGlzdGVuZXJcclxuICBvbiAoZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nLCBvcHRpb25zKSB7XHJcbiAgICBvbih0aGlzLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lciAoKSB7fVxyXG59XHJcblxyXG5yZWdpc3RlcihFdmVudFRhcmdldCwgJ0V2ZW50VGFyZ2V0JylcclxuIiwiXHJcbmV4cG9ydCBmdW5jdGlvbiBub29wICgpIHt9XHJcblxyXG4vLyBEZWZhdWx0IGFuaW1hdGlvbiB2YWx1ZXNcclxuZXhwb3J0IGNvbnN0IHRpbWVsaW5lID0ge1xyXG4gIGR1cmF0aW9uOiA0MDAsXHJcbiAgZWFzZTogJz4nLFxyXG4gIGRlbGF5OiAwXHJcbn1cclxuXHJcbi8vIERlZmF1bHQgYXR0cmlidXRlIHZhbHVlc1xyXG5leHBvcnQgY29uc3QgYXR0cnMgPSB7XHJcblxyXG4gIC8vIGZpbGwgYW5kIHN0cm9rZVxyXG4gICdmaWxsLW9wYWNpdHknOiAxLFxyXG4gICdzdHJva2Utb3BhY2l0eSc6IDEsXHJcbiAgJ3N0cm9rZS13aWR0aCc6IDAsXHJcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdtaXRlcicsXHJcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ2J1dHQnLFxyXG4gIGZpbGw6ICcjMDAwMDAwJyxcclxuICBzdHJva2U6ICcjMDAwMDAwJyxcclxuICBvcGFjaXR5OiAxLFxyXG5cclxuICAvLyBwb3NpdGlvblxyXG4gIHg6IDAsXHJcbiAgeTogMCxcclxuICBjeDogMCxcclxuICBjeTogMCxcclxuXHJcbiAgLy8gc2l6ZVxyXG4gIHdpZHRoOiAwLFxyXG4gIGhlaWdodDogMCxcclxuXHJcbiAgLy8gcmFkaXVzXHJcbiAgcjogMCxcclxuICByeDogMCxcclxuICByeTogMCxcclxuXHJcbiAgLy8gZ3JhZGllbnRcclxuICBvZmZzZXQ6IDAsXHJcbiAgJ3N0b3Atb3BhY2l0eSc6IDEsXHJcbiAgJ3N0b3AtY29sb3InOiAnIzAwMDAwMCcsXHJcblxyXG4gIC8vIHRleHRcclxuICAndGV4dC1hbmNob3InOiAnc3RhcnQnXHJcbn1cclxuIiwiaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBzdWJDbGFzc0FycmF5IH0gZnJvbSAnLi9BcnJheVBvbHlmaWxsLmpzJ1xyXG5cclxuY29uc3QgU1ZHQXJyYXkgPSBzdWJDbGFzc0FycmF5KCdTVkdBcnJheScsIEFycmF5LCBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgdGhpcy5pbml0KGFycilcclxufSlcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNWR0FycmF5XHJcblxyXG5leHRlbmQoU1ZHQXJyYXksIHtcclxuICBpbml0IChhcnIpIHtcclxuICAgIC8vIFRoaXMgY2F0Y2hlcyB0aGUgY2FzZSwgdGhhdCBuYXRpdmUgbWFwIHRyaWVzIHRvIGNyZWF0ZSBhbiBhcnJheSB3aXRoIG5ldyBBcnJheSgxKVxyXG4gICAgaWYgKHR5cGVvZiBhcnIgPT09ICdudW1iZXInKSByZXR1cm4gdGhpc1xyXG4gICAgdGhpcy5sZW5ndGggPSAwXHJcbiAgICB0aGlzLnB1c2goLi4udGhpcy5wYXJzZShhcnIpKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICB0b0FycmF5ICgpIHtcclxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0aGlzKVxyXG4gIH0sXHJcblxyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiB0aGlzLmpvaW4oJyAnKVxyXG4gIH0sXHJcblxyXG4gIC8vIEZsYXR0ZW5zIHRoZSBhcnJheSBpZiBuZWVkZWRcclxuICB2YWx1ZU9mICgpIHtcclxuICAgIGNvbnN0IHJldCA9IFtdXHJcbiAgICByZXQucHVzaCguLi50aGlzKVxyXG4gICAgcmV0dXJuIHJldFxyXG4gIH0sXHJcblxyXG4gIC8vIFBhcnNlIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIHN0cmluZ1xyXG4gIHBhcnNlIChhcnJheSA9IFtdKSB7XHJcbiAgICAvLyBJZiBhbHJlYWR5IGlzIGFuIGFycmF5LCBubyBuZWVkIHRvIHBhcnNlIGl0XHJcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGFycmF5XHJcblxyXG4gICAgcmV0dXJuIGFycmF5LnRyaW0oKS5zcGxpdChkZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KVxyXG4gIH0sXHJcblxyXG4gIGNsb25lICgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKVxyXG4gIH0sXHJcblxyXG4gIHRvU2V0ICgpIHtcclxuICAgIHJldHVybiBuZXcgU2V0KHRoaXMpXHJcbiAgfVxyXG59KVxyXG4iLCJpbXBvcnQgeyBudW1iZXJBbmRVbml0IH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xyXG5cclxuLy8gTW9kdWxlIGZvciB1bml0IGNvbnZlcnRpb25zXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNWR051bWJlciB7XHJcbiAgLy8gSW5pdGlhbGl6ZVxyXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XHJcbiAgICB0aGlzLmluaXQoLi4uYXJncylcclxuICB9XHJcblxyXG4gIGluaXQgKHZhbHVlLCB1bml0KSB7XHJcbiAgICB1bml0ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVsxXSA6IHVuaXRcclxuICAgIHZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVswXSA6IHZhbHVlXHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xyXG4gICAgdGhpcy52YWx1ZSA9IDBcclxuICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgJydcclxuXHJcbiAgICAvLyBwYXJzZSB2YWx1ZVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgLy8gZW5zdXJlIGEgdmFsaWQgbnVtZXJpYyB2YWx1ZVxyXG4gICAgICB0aGlzLnZhbHVlID0gaXNOYU4odmFsdWUpID8gMCA6ICFpc0Zpbml0ZSh2YWx1ZSkgPyAodmFsdWUgPCAwID8gLTMuNGUrMzggOiArMy40ZSszOCkgOiB2YWx1ZVxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHVuaXQgPSB2YWx1ZS5tYXRjaChudW1iZXJBbmRVbml0KVxyXG5cclxuICAgICAgaWYgKHVuaXQpIHtcclxuICAgICAgICAvLyBtYWtlIHZhbHVlIG51bWVyaWNcclxuICAgICAgICB0aGlzLnZhbHVlID0gcGFyc2VGbG9hdCh1bml0WzFdKVxyXG5cclxuICAgICAgICAvLyBub3JtYWxpemVcclxuICAgICAgICBpZiAodW5pdFs1XSA9PT0gJyUnKSB7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlIC89IDEwMFxyXG4gICAgICAgIH0gZWxzZSBpZiAodW5pdFs1XSA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlICo9IDEwMDBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHVuaXRcclxuICAgICAgICB0aGlzLnVuaXQgPSB1bml0WzVdXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNWR051bWJlcikge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS52YWx1ZU9mKClcclxuICAgICAgICB0aGlzLnVuaXQgPSB2YWx1ZS51bml0XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcgKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLnVuaXQgPT09ICclJyA/IH5+KHRoaXMudmFsdWUgKiAxZTgpIC8gMWU2XHJcbiAgICAgIDogdGhpcy51bml0ID09PSAncycgPyB0aGlzLnZhbHVlIC8gMWUzXHJcbiAgICAgIDogdGhpcy52YWx1ZVxyXG4gICAgKSArIHRoaXMudW5pdFxyXG4gIH1cclxuXHJcbiAgdG9KU09OICgpIHtcclxuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcclxuICB9XHJcblxyXG4gIHRvQXJyYXkgKCkge1xyXG4gICAgcmV0dXJuIFsgdGhpcy52YWx1ZSwgdGhpcy51bml0IF1cclxuICB9XHJcblxyXG4gIHZhbHVlT2YgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWVcclxuICB9XHJcblxyXG4gIC8vIEFkZCBudW1iZXJcclxuICBwbHVzIChudW1iZXIpIHtcclxuICAgIG51bWJlciA9IG5ldyBTVkdOdW1iZXIobnVtYmVyKVxyXG4gICAgcmV0dXJuIG5ldyBTVkdOdW1iZXIodGhpcyArIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KVxyXG4gIH1cclxuXHJcbiAgLy8gU3VidHJhY3QgbnVtYmVyXHJcbiAgbWludXMgKG51bWJlcikge1xyXG4gICAgbnVtYmVyID0gbmV3IFNWR051bWJlcihudW1iZXIpXHJcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzIC0gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpXHJcbiAgfVxyXG5cclxuICAvLyBNdWx0aXBseSBudW1iZXJcclxuICB0aW1lcyAobnVtYmVyKSB7XHJcbiAgICBudW1iZXIgPSBuZXcgU1ZHTnVtYmVyKG51bWJlcilcclxuICAgIHJldHVybiBuZXcgU1ZHTnVtYmVyKHRoaXMgKiBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdClcclxuICB9XHJcblxyXG4gIC8vIERpdmlkZSBudW1iZXJcclxuICBkaXZpZGUgKG51bWJlcikge1xyXG4gICAgbnVtYmVyID0gbmV3IFNWR051bWJlcihudW1iZXIpXHJcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzIC8gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpXHJcbiAgfVxyXG5cclxuICBjb252ZXJ0ICh1bml0KSB7XHJcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzLnZhbHVlLCB1bml0KVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBhdHRycyBhcyBkZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMuanMnXHJcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnLi9yZWdleC5qcydcclxuaW1wb3J0IENvbG9yIGZyb20gJy4uLy4uL3R5cGVzL0NvbG9yLmpzJ1xyXG5pbXBvcnQgU1ZHQXJyYXkgZnJvbSAnLi4vLi4vdHlwZXMvU1ZHQXJyYXkuanMnXHJcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xyXG5cclxuY29uc3QgaG9va3MgPSBbXVxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJBdHRySG9vayAoZm4pIHtcclxuICBob29rcy5wdXNoKGZuKVxyXG59XHJcblxyXG4vLyBTZXQgc3ZnIGVsZW1lbnQgYXR0cmlidXRlXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF0dHIgKGF0dHIsIHZhbCwgbnMpIHtcclxuICAvLyBhY3QgYXMgZnVsbCBnZXR0ZXJcclxuICBpZiAoYXR0ciA9PSBudWxsKSB7XHJcbiAgICAvLyBnZXQgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXNcclxuICAgIGF0dHIgPSB7fVxyXG4gICAgdmFsID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXNcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdmFsKSB7XHJcbiAgICAgIGF0dHJbbm9kZS5ub2RlTmFtZV0gPSBpc051bWJlci50ZXN0KG5vZGUubm9kZVZhbHVlKVxyXG4gICAgICAgID8gcGFyc2VGbG9hdChub2RlLm5vZGVWYWx1ZSlcclxuICAgICAgICA6IG5vZGUubm9kZVZhbHVlXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGF0dHJcclxuICB9IGVsc2UgaWYgKGF0dHIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFycmF5IGFuZCBnZXQgYWxsIHZhbHVlc1xyXG4gICAgcmV0dXJuIGF0dHIucmVkdWNlKChsYXN0LCBjdXJyKSA9PiB7XHJcbiAgICAgIGxhc3RbY3Vycl0gPSB0aGlzLmF0dHIoY3VycilcclxuICAgICAgcmV0dXJuIGxhc3RcclxuICAgIH0sIHt9KVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGF0dHIgPT09ICdvYmplY3QnICYmIGF0dHIuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgLy8gYXBwbHkgZXZlcnkgYXR0cmlidXRlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXHJcbiAgICBmb3IgKHZhbCBpbiBhdHRyKSB0aGlzLmF0dHIodmFsLCBhdHRyW3ZhbF0pXHJcbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcclxuICAgIC8vIHJlbW92ZSB2YWx1ZVxyXG4gICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxyXG4gIH0gZWxzZSBpZiAodmFsID09IG51bGwpIHtcclxuICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdFxyXG4gICAgdmFsID0gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShhdHRyKVxyXG4gICAgcmV0dXJuIHZhbCA9PSBudWxsID8gZGVmYXVsdHNbYXR0cl1cclxuICAgICAgOiBpc051bWJlci50ZXN0KHZhbCkgPyBwYXJzZUZsb2F0KHZhbClcclxuICAgICAgOiB2YWxcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gTG9vcCB0aHJvdWdoIGhvb2tzIGFuZCBleGVjdXRlIHRoZW0gdG8gY29udmVydCB2YWx1ZVxyXG4gICAgdmFsID0gaG9va3MucmVkdWNlKChfdmFsLCBob29rKSA9PiB7XHJcbiAgICAgIHJldHVybiBob29rKGF0dHIsIF92YWwsIHRoaXMpXHJcbiAgICB9LCB2YWwpXHJcblxyXG4gICAgLy8gZW5zdXJlIGNvcnJlY3QgbnVtZXJpYyB2YWx1ZXMgKGFsc28gYWNjZXB0cyBOYU4gYW5kIEluZmluaXR5KVxyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIHZhbCA9IG5ldyBTVkdOdW1iZXIodmFsKVxyXG4gICAgfSBlbHNlIGlmIChDb2xvci5pc0NvbG9yKHZhbCkpIHtcclxuICAgICAgLy8gZW5zdXJlIGZ1bGwgaGV4IGNvbG9yXHJcbiAgICAgIHZhbCA9IG5ldyBDb2xvcih2YWwpXHJcbiAgICB9IGVsc2UgaWYgKHZhbC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcclxuICAgICAgLy8gQ2hlY2sgZm9yIHBsYWluIGFycmF5cyBhbmQgcGFyc2UgYXJyYXkgdmFsdWVzXHJcbiAgICAgIHZhbCA9IG5ldyBTVkdBcnJheSh2YWwpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlIHBhc3NlZCBhdHRyaWJ1dGUgaXMgbGVhZGluZy4uLlxyXG4gICAgaWYgKGF0dHIgPT09ICdsZWFkaW5nJykge1xyXG4gICAgICAvLyAuLi4gY2FsbCB0aGUgbGVhZGluZyBtZXRob2QgaW5zdGVhZFxyXG4gICAgICBpZiAodGhpcy5sZWFkaW5nKSB7XHJcbiAgICAgICAgdGhpcy5sZWFkaW5nKHZhbClcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gc2V0IGdpdmVuIGF0dHJpYnV0ZSBvbiBub2RlXHJcbiAgICAgIHR5cGVvZiBucyA9PT0gJ3N0cmluZycgPyB0aGlzLm5vZGUuc2V0QXR0cmlidXRlTlMobnMsIGF0dHIsIHZhbC50b1N0cmluZygpKVxyXG4gICAgICAgIDogdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB2YWwudG9TdHJpbmcoKSlcclxuICAgIH1cclxuXHJcbiAgICAvLyByZWJ1aWxkIGlmIHJlcXVpcmVkXHJcbiAgICBpZiAodGhpcy5yZWJ1aWxkICYmIChhdHRyID09PSAnZm9udC1zaXplJyB8fCBhdHRyID09PSAneCcpKSB7XHJcbiAgICAgIHRoaXMucmVidWlsZCgpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgYWRvcHQsXHJcbiAgYXNzaWduTmV3SWQsXHJcbiAgZWlkLFxyXG4gIGV4dGVuZCxcclxuICBtYWtlSW5zdGFuY2UsXHJcbiAgY3JlYXRlLFxyXG4gIHJlZ2lzdGVyXHJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgZmluZCwgZmluZE9uZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcclxuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcclxuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXHJcbmltcG9ydCB7IG5zIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXHJcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi90eXBlcy9FdmVudFRhcmdldC5qcydcclxuaW1wb3J0IExpc3QgZnJvbSAnLi4vdHlwZXMvTGlzdC5qcydcclxuaW1wb3J0IGF0dHIgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2F0dHIuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb20gZXh0ZW5kcyBFdmVudFRhcmdldCB7XHJcbiAgY29uc3RydWN0b3IgKG5vZGUsIGF0dHJzKSB7XHJcbiAgICBzdXBlcihub2RlKVxyXG4gICAgdGhpcy5ub2RlID0gbm9kZVxyXG4gICAgdGhpcy50eXBlID0gbm9kZS5ub2RlTmFtZVxyXG5cclxuICAgIGlmIChhdHRycyAmJiBub2RlICE9PSBhdHRycykge1xyXG4gICAgICB0aGlzLmF0dHIoYXR0cnMpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgZ2l2ZW4gZWxlbWVudCBhdCBhIHBvc2l0aW9uXHJcbiAgYWRkIChlbGVtZW50LCBpKSB7XHJcbiAgICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXHJcblxyXG4gICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudC5ub2RlKVxyXG4gICAgfSBlbHNlIGlmIChlbGVtZW50Lm5vZGUgIT09IHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKSB7XHJcbiAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudC5ub2RlLCB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gc2VsZlxyXG4gIGFkZFRvIChwYXJlbnQpIHtcclxuICAgIHJldHVybiBtYWtlSW5zdGFuY2UocGFyZW50KS5wdXQodGhpcylcclxuICB9XHJcblxyXG4gIC8vIFJldHVybnMgYWxsIGNoaWxkIGVsZW1lbnRzXHJcbiAgY2hpbGRyZW4gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBMaXN0KG1hcCh0aGlzLm5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgIHJldHVybiBhZG9wdChub2RlKVxyXG4gICAgfSkpXHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgYWxsIGVsZW1lbnRzIGluIHRoaXMgY29udGFpbmVyXHJcbiAgY2xlYXIgKCkge1xyXG4gICAgLy8gcmVtb3ZlIGNoaWxkcmVuXHJcbiAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmxhc3RDaGlsZClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gQ2xvbmUgZWxlbWVudFxyXG4gIGNsb25lICgpIHtcclxuICAgIC8vIHdyaXRlIGRvbSBkYXRhIHRvIHRoZSBkb20gc28gdGhlIGNsb25lIGNhbiBwaWNrdXAgdGhlIGRhdGFcclxuICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKVxyXG5cclxuICAgIC8vIGNsb25lIGVsZW1lbnQgYW5kIGFzc2lnbiBuZXcgaWRcclxuICAgIHJldHVybiBhc3NpZ25OZXdJZCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKVxyXG4gIH1cclxuXHJcbiAgLy8gSXRlcmF0ZXMgb3ZlciBhbGwgY2hpbGRyZW4gYW5kIGludm9rZXMgYSBnaXZlbiBibG9ja1xyXG4gIGVhY2ggKGJsb2NrLCBkZWVwKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKClcclxuICAgIHZhciBpLCBpbFxyXG5cclxuICAgIGZvciAoaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xyXG4gICAgICBibG9jay5hcHBseShjaGlsZHJlbltpXSwgWyBpLCBjaGlsZHJlbiBdKVxyXG5cclxuICAgICAgaWYgKGRlZXApIHtcclxuICAgICAgICBjaGlsZHJlbltpXS5lYWNoKGJsb2NrLCBkZWVwKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGVsZW1lbnQgKG5vZGVOYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IERvbShjcmVhdGUobm9kZU5hbWUpKSlcclxuICB9XHJcblxyXG4gIC8vIEdldCBmaXJzdCBjaGlsZFxyXG4gIGZpcnN0ICgpIHtcclxuICAgIHJldHVybiBhZG9wdCh0aGlzLm5vZGUuZmlyc3RDaGlsZClcclxuICB9XHJcblxyXG4gIC8vIEdldCBhIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgZ2V0IChpKSB7XHJcbiAgICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pXHJcbiAgfVxyXG5cclxuICBnZXRFdmVudEhvbGRlciAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlXHJcbiAgfVxyXG5cclxuICBnZXRFdmVudFRhcmdldCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlXHJcbiAgfVxyXG5cclxuICAvLyBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYSBjaGlsZFxyXG4gIGhhcyAoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5kZXgoZWxlbWVudCkgPj0gMFxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IC8gc2V0IGlkXHJcbiAgaWQgKGlkKSB7XHJcbiAgICAvLyBnZW5lcmF0ZSBuZXcgaWQgaWYgbm8gaWQgc2V0XHJcbiAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJyAmJiAhdGhpcy5ub2RlLmlkKSB7XHJcbiAgICAgIHRoaXMubm9kZS5pZCA9IGVpZCh0aGlzLnR5cGUpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG9udCd0IHNldCBkaXJlY3RseSB3aWR0aCB0aGlzLm5vZGUuaWQgdG8gbWFrZSBgbnVsbGAgd29yayBjb3JyZWN0bHlcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2lkJywgaWQpXHJcbiAgfVxyXG5cclxuICAvLyBHZXRzIGluZGV4IG9mIGdpdmVuIGVsZW1lbnRcclxuICBpbmRleCAoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMpLmluZGV4T2YoZWxlbWVudC5ub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRoZSBsYXN0IGNoaWxkXHJcbiAgbGFzdCAoKSB7XHJcbiAgICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLmxhc3RDaGlsZClcclxuICB9XHJcblxyXG4gIC8vIG1hdGNoZXMgdGhlIGVsZW1lbnQgdnMgYSBjc3Mgc2VsZWN0b3JcclxuICBtYXRjaGVzIChzZWxlY3Rvcikge1xyXG4gICAgY29uc3QgZWwgPSB0aGlzLm5vZGVcclxuICAgIHJldHVybiAoZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3IgfHwgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbC5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGVsLCBzZWxlY3RvcilcclxuICB9XHJcblxyXG4gIC8vIFJldHVybnMgdGhlIHBhcmVudCBlbGVtZW50IGluc3RhbmNlXHJcbiAgcGFyZW50ICh0eXBlKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gdGhpc1xyXG5cclxuICAgIC8vIGNoZWNrIGZvciBwYXJlbnRcclxuICAgIGlmICghcGFyZW50Lm5vZGUucGFyZW50Tm9kZSkgcmV0dXJuIG51bGxcclxuXHJcbiAgICAvLyBnZXQgcGFyZW50IGVsZW1lbnRcclxuICAgIHBhcmVudCA9IGFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpXHJcblxyXG4gICAgaWYgKCF0eXBlKSByZXR1cm4gcGFyZW50XHJcblxyXG4gICAgLy8gbG9vcCB0cm91Z2ggYW5jZXN0b3JzIGlmIHR5cGUgaXMgZ2l2ZW5cclxuICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHBhcmVudC5tYXRjaGVzKHR5cGUpIDogcGFyZW50IGluc3RhbmNlb2YgdHlwZSkgcmV0dXJuIHBhcmVudFxyXG4gICAgICBpZiAoIXBhcmVudC5ub2RlLnBhcmVudE5vZGUgfHwgcGFyZW50Lm5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcgfHwgcGFyZW50Lm5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudC1mcmFnbWVudCcpIHJldHVybiBudWxsIC8vICM3NTksICM3MjBcclxuICAgICAgcGFyZW50ID0gYWRvcHQocGFyZW50Lm5vZGUucGFyZW50Tm9kZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJhc2ljYWxseSBkb2VzIHRoZSBzYW1lIGFzIGBhZGQoKWAgYnV0IHJldHVybnMgdGhlIGFkZGVkIGVsZW1lbnQgaW5zdGVhZFxyXG4gIHB1dCAoZWxlbWVudCwgaSkge1xyXG4gICAgdGhpcy5hZGQoZWxlbWVudCwgaSlcclxuICAgIHJldHVybiBlbGVtZW50XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBjb250YWluZXJcclxuICBwdXRJbiAocGFyZW50KSB7XHJcbiAgICByZXR1cm4gbWFrZUluc3RhbmNlKHBhcmVudCkuYWRkKHRoaXMpXHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgZWxlbWVudFxyXG4gIHJlbW92ZSAoKSB7XHJcbiAgICBpZiAodGhpcy5wYXJlbnQoKSkge1xyXG4gICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUVsZW1lbnQodGhpcylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGEgZ2l2ZW4gY2hpbGRcclxuICByZW1vdmVFbGVtZW50IChlbGVtZW50KSB7XHJcbiAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudC5ub2RlKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBSZXBsYWNlIHRoaXMgd2l0aCBlbGVtZW50XHJcbiAgcmVwbGFjZSAoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KVxyXG4gICAgdGhpcy5ub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsZW1lbnQubm9kZSwgdGhpcy5ub2RlKVxyXG4gICAgcmV0dXJuIGVsZW1lbnRcclxuICB9XHJcblxyXG4gIHJvdW5kIChwcmVjaXNpb24gPSAyLCBtYXApIHtcclxuICAgIGNvbnN0IGZhY3RvciA9IDEwICoqIHByZWNpc2lvblxyXG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmF0dHIoKVxyXG5cclxuICAgIC8vIElmIHdlIGhhdmUgbm8gbWFwLCBidWlsZCBvbmUgZnJvbSBhdHRyc1xyXG4gICAgaWYgKCFtYXApIHtcclxuICAgICAgbWFwID0gT2JqZWN0LmtleXMoYXR0cnMpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSG9sZHMgcm91bmRlZCBhdHRyaWJ1dGVzXHJcbiAgICBjb25zdCBuZXdBdHRycyA9IHt9XHJcbiAgICBtYXAuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgIG5ld0F0dHJzW2tleV0gPSBNYXRoLnJvdW5kKGF0dHJzW2tleV0gKiBmYWN0b3IpIC8gZmFjdG9yXHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMuYXR0cihuZXdBdHRycylcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gaWQgb24gc3RyaW5nIGNvbnZlcnNpb25cclxuICB0b1N0cmluZyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pZCgpXHJcbiAgfVxyXG5cclxuICAvLyBJbXBvcnQgcmF3IHN2Z1xyXG4gIHN2ZyAoc3ZnT3JGbiwgb3V0ZXJIVE1MKSB7XHJcbiAgICB2YXIgd2VsbCwgbGVuLCBmcmFnbWVudFxyXG5cclxuICAgIGlmIChzdmdPckZuID09PSBmYWxzZSkge1xyXG4gICAgICBvdXRlckhUTUwgPSBmYWxzZVxyXG4gICAgICBzdmdPckZuID0gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFjdCBhcyBnZXR0ZXIgaWYgbm8gc3ZnIHN0cmluZyBpcyBnaXZlblxyXG4gICAgaWYgKHN2Z09yRm4gPT0gbnVsbCB8fCB0eXBlb2Ygc3ZnT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAvLyBUaGUgZGVmYXVsdCBmb3IgZXhwb3J0cyBpcywgdGhhdCB0aGUgb3V0ZXJOb2RlIGlzIGluY2x1ZGVkXHJcbiAgICAgIG91dGVySFRNTCA9IG91dGVySFRNTCA9PSBudWxsID8gdHJ1ZSA6IG91dGVySFRNTFxyXG5cclxuICAgICAgLy8gd3JpdGUgc3ZnanMgZGF0YSB0byB0aGUgZG9tXHJcbiAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKVxyXG4gICAgICBsZXQgY3VycmVudCA9IHRoaXNcclxuXHJcbiAgICAgIC8vIEFuIGV4cG9ydCBtb2RpZmllciB3YXMgcGFzc2VkXHJcbiAgICAgIGlmIChzdmdPckZuICE9IG51bGwpIHtcclxuICAgICAgICBjdXJyZW50ID0gYWRvcHQoY3VycmVudC5ub2RlLmNsb25lTm9kZSh0cnVlKSlcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgd2FudHMgb3V0ZXJIVE1MIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGlzIG5vZGUsIHRvb1xyXG4gICAgICAgIGlmIChvdXRlckhUTUwpIHtcclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN2Z09yRm4oY3VycmVudClcclxuICAgICAgICAgIGN1cnJlbnQgPSByZXN1bHQgfHwgY3VycmVudFxyXG5cclxuICAgICAgICAgIC8vIFRoZSB1c2VyIGRvZXMgbm90IHdhbnQgdGhpcyBub2RlPyBXZWxsLCB0aGVuIGhlIGdldHMgbm90aGluZ1xyXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybiAnJ1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVlcCBsb29wIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFuZCBhcHBseSBtb2RpZmllclxyXG4gICAgICAgIGN1cnJlbnQuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdmdPckZuKHRoaXMpXHJcbiAgICAgICAgICBjb25zdCBfdGhpcyA9IHJlc3VsdCB8fCB0aGlzXHJcblxyXG4gICAgICAgICAgLy8gSWYgbW9kaWZpZXIgcmV0dXJucyBmYWxzZSwgZGlzY2FyZCBub2RlXHJcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpXHJcblxyXG4gICAgICAgICAgICAvLyBJZiBtb2RpZmllciByZXR1cm5zIG5ldyBub2RlLCB1c2UgaXRcclxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICYmIHRoaXMgIT09IF90aGlzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZShfdGhpcylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB0cnVlKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXR1cm4gb3V0ZXIgb3IgaW5uZXIgY29udGVudFxyXG4gICAgICByZXR1cm4gb3V0ZXJIVE1MXHJcbiAgICAgICAgPyBjdXJyZW50Lm5vZGUub3V0ZXJIVE1MXHJcbiAgICAgICAgOiBjdXJyZW50Lm5vZGUuaW5uZXJIVE1MXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWN0IGFzIHNldHRlciBpZiB3ZSBnb3QgYSBzdHJpbmdcclxuXHJcbiAgICAvLyBUaGUgZGVmYXVsdCBmb3IgaW1wb3J0IGlzLCB0aGF0IHRoZSBjdXJyZW50IG5vZGUgaXMgbm90IHJlcGxhY2VkXHJcbiAgICBvdXRlckhUTUwgPSBvdXRlckhUTUwgPT0gbnVsbCA/IGZhbHNlIDogb3V0ZXJIVE1MXHJcblxyXG4gICAgLy8gQ3JlYXRlIHRlbXBvcmFyeSBob2xkZXJcclxuICAgIHdlbGwgPSBnbG9iYWxzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ3N2ZycpXHJcbiAgICBmcmFnbWVudCA9IGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXHJcblxyXG4gICAgLy8gRHVtcCByYXcgc3ZnXHJcbiAgICB3ZWxsLmlubmVySFRNTCA9IHN2Z09yRm5cclxuXHJcbiAgICAvLyBUcmFuc3BsYW50IG5vZGVzIGludG8gdGhlIGZyYWdtZW50XHJcbiAgICBmb3IgKGxlbiA9IHdlbGwuY2hpbGRyZW4ubGVuZ3RoOyBsZW4tLTspIHtcclxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQod2VsbC5maXJzdEVsZW1lbnRDaGlsZClcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudCgpXHJcblxyXG4gICAgLy8gQWRkIHRoZSB3aG9sZSBmcmFnbWVudCBhdCBvbmNlXHJcbiAgICByZXR1cm4gb3V0ZXJIVE1MXHJcbiAgICAgID8gdGhpcy5yZXBsYWNlKGZyYWdtZW50KSAmJiBwYXJlbnRcclxuICAgICAgOiB0aGlzLmFkZChmcmFnbWVudClcclxuICB9XHJcblxyXG4gIHdvcmRzICh0ZXh0KSB7XHJcbiAgICAvLyBUaGlzIGlzIGZhc3RlciB0aGFuIHJlbW92aW5nIGFsbCBjaGlsZHJlbiBhbmQgYWRkaW5nIGEgbmV3IG9uZVxyXG4gICAgdGhpcy5ub2RlLnRleHRDb250ZW50ID0gdGV4dFxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIHdyaXRlIHN2Z2pzIGRhdGEgdG8gdGhlIGRvbVxyXG4gIHdyaXRlRGF0YVRvRG9tICgpIHtcclxuICAgIC8vIGR1bXAgdmFyaWFibGVzIHJlY3Vyc2l2ZWx5XHJcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKClcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbn1cclxuXHJcbmV4dGVuZChEb20sIHsgYXR0ciwgZmluZCwgZmluZE9uZSB9KVxyXG5yZWdpc3RlcihEb20sICdEb20nKVxyXG4iLCJpbXBvcnQgeyBiYm94LCByYm94IH0gZnJvbSAnLi4vdHlwZXMvQm94LmpzJ1xyXG5pbXBvcnQgeyBjdG0sIHNjcmVlbkNUTSB9IGZyb20gJy4uL3R5cGVzL01hdHJpeC5qcydcclxuaW1wb3J0IHtcclxuICBleHRlbmQsXHJcbiAgZ2V0Q2xhc3MsXHJcbiAgbWFrZUluc3RhbmNlLFxyXG4gIHJlZ2lzdGVyLFxyXG4gIHJvb3RcclxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5pbXBvcnQgeyBwb2ludCB9IGZyb20gJy4uL3R5cGVzL1BvaW50LmpzJ1xyXG5pbXBvcnQgeyBwcm9wb3J0aW9uYWxTaXplIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXHJcbmltcG9ydCB7IHJlZmVyZW5jZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcclxuaW1wb3J0IERvbSBmcm9tICcuL0RvbS5qcydcclxuaW1wb3J0IExpc3QgZnJvbSAnLi4vdHlwZXMvTGlzdC5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50IGV4dGVuZHMgRG9tIHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSwgYXR0cnMpIHtcclxuICAgIHN1cGVyKG5vZGUsIGF0dHJzKVxyXG5cclxuICAgIC8vIGluaXRpYWxpemUgZGF0YSBvYmplY3RcclxuICAgIHRoaXMuZG9tID0ge31cclxuXHJcbiAgICAvLyBjcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlXHJcbiAgICB0aGlzLm5vZGUuaW5zdGFuY2UgPSB0aGlzXHJcblxyXG4gICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHtcclxuICAgICAgLy8gcHVsbCBzdmdqcyBkYXRhIGZyb20gdGhlIGRvbSAoZ2V0QXR0cmlidXRlTlMgZG9lc24ndCB3b3JrIGluIGh0bWw1KVxyXG4gICAgICB0aGlzLnNldERhdGEoSlNPTi5wYXJzZShub2RlLmdldEF0dHJpYnV0ZSgnc3ZnanM6ZGF0YScpKSB8fCB7fSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE1vdmUgZWxlbWVudCBieSBpdHMgY2VudGVyXHJcbiAgY2VudGVyICh4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jeCh4KS5jeSh5KVxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcclxuICBjeCAoeCkge1xyXG4gICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMueCgpICsgdGhpcy53aWR0aCgpIC8gMiA6IHRoaXMueCh4IC0gdGhpcy53aWR0aCgpIC8gMilcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXHJcbiAgY3kgKHkpIHtcclxuICAgIHJldHVybiB5ID09IG51bGxcclxuICAgICAgPyB0aGlzLnkoKSArIHRoaXMuaGVpZ2h0KCkgLyAyXHJcbiAgICAgIDogdGhpcy55KHkgLSB0aGlzLmhlaWdodCgpIC8gMilcclxuICB9XHJcblxyXG4gIC8vIEdldCBkZWZzXHJcbiAgZGVmcyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290KCkuZGVmcygpXHJcbiAgfVxyXG5cclxuICAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeCBhbmQgeSBheGVzXHJcbiAgZG1vdmUgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmR4KHgpLmR5KHkpXHJcbiAgfVxyXG5cclxuICAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeCBheGlzXHJcbiAgZHggKHggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy54KG5ldyBTVkdOdW1iZXIoeCkucGx1cyh0aGlzLngoKSkpXHJcbiAgfVxyXG5cclxuICAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeSBheGlzXHJcbiAgZHkgKHkgPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy55KG5ldyBTVkdOdW1iZXIoeSkucGx1cyh0aGlzLnkoKSkpXHJcbiAgfVxyXG5cclxuICAvLyBHZXQgcGFyZW50IGRvY3VtZW50XHJcbiAgcm9vdCAoKSB7XHJcbiAgICBjb25zdCBwID0gdGhpcy5wYXJlbnQoZ2V0Q2xhc3Mocm9vdCkpXHJcbiAgICByZXR1cm4gcCAmJiBwLnJvb3QoKVxyXG4gIH1cclxuXHJcbiAgZ2V0RXZlbnRIb2xkZXIgKCkge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxyXG4gIGhlaWdodCAoaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXHJcbiAgfVxyXG5cclxuICAvLyBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgaW5zaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRcclxuICBpbnNpZGUgKHgsIHkpIHtcclxuICAgIGNvbnN0IGJveCA9IHRoaXMuYmJveCgpXHJcblxyXG4gICAgcmV0dXJuIHggPiBib3gueFxyXG4gICAgICAmJiB5ID4gYm94LnlcclxuICAgICAgJiYgeCA8IGJveC54ICsgYm94LndpZHRoXHJcbiAgICAgICYmIHkgPCBib3gueSArIGJveC5oZWlnaHRcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgZWxlbWVudCB0byBnaXZlbiB4IGFuZCB5IHZhbHVlc1xyXG4gIG1vdmUgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLngoeCkueSh5KVxyXG4gIH1cclxuXHJcbiAgLy8gcmV0dXJuIGFycmF5IG9mIGFsbCBhbmNlc3RvcnMgb2YgZ2l2ZW4gdHlwZSB1cCB0byB0aGUgcm9vdCBzdmdcclxuICBwYXJlbnRzICh1bnRpbCA9IGdsb2JhbHMuZG9jdW1lbnQpIHtcclxuICAgIHVudGlsID0gbWFrZUluc3RhbmNlKHVudGlsKVxyXG4gICAgY29uc3QgcGFyZW50cyA9IG5ldyBMaXN0KClcclxuICAgIGxldCBwYXJlbnQgPSB0aGlzXHJcblxyXG4gICAgd2hpbGUgKFxyXG4gICAgICAocGFyZW50ID0gcGFyZW50LnBhcmVudCgpKVxyXG4gICAgICAmJiBwYXJlbnQubm9kZSAhPT0gdW50aWwubm9kZVxyXG4gICAgICAmJiBwYXJlbnQubm9kZSAhPT0gZ2xvYmFscy5kb2N1bWVudFxyXG4gICAgKSB7XHJcbiAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcmVudHNcclxuICB9XHJcblxyXG4gIC8vIEdldCByZWZlcmVuY2VkIGVsZW1lbnQgZm9ybSBhdHRyaWJ1dGUgdmFsdWVcclxuICByZWZlcmVuY2UgKGF0dHIpIHtcclxuICAgIGF0dHIgPSB0aGlzLmF0dHIoYXR0cilcclxuICAgIGlmICghYXR0cikgcmV0dXJuIG51bGxcclxuXHJcbiAgICBjb25zdCBtID0gYXR0ci5tYXRjaChyZWZlcmVuY2UpXHJcbiAgICByZXR1cm4gbSA/IG1ha2VJbnN0YW5jZShtWzFdKSA6IG51bGxcclxuICB9XHJcblxyXG4gIC8vIHNldCBnaXZlbiBkYXRhIHRvIHRoZSBlbGVtZW50cyBkYXRhIHByb3BlcnR5XHJcbiAgc2V0RGF0YSAobykge1xyXG4gICAgdGhpcy5kb20gPSBvXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgc2l6ZSAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gICAgICAud2lkdGgobmV3IFNWR051bWJlcihwLndpZHRoKSlcclxuICAgICAgLmhlaWdodChuZXcgU1ZHTnVtYmVyKHAuaGVpZ2h0KSlcclxuICB9XHJcblxyXG4gIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XHJcbiAgd2lkdGggKHdpZHRoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd3aWR0aCcsIHdpZHRoKVxyXG4gIH1cclxuXHJcbiAgLy8gd3JpdGUgc3ZnanMgZGF0YSB0byB0aGUgZG9tXHJcbiAgd3JpdGVEYXRhVG9Eb20gKCkge1xyXG4gICAgLy8gcmVtb3ZlIHByZXZpb3VzbHkgc2V0IGRhdGFcclxuICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnKVxyXG5cclxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmRvbSkubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnLCBKU09OLnN0cmluZ2lmeSh0aGlzLmRvbSkpIC8vIHNlZSAjNDI4XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1cGVyLndyaXRlRGF0YVRvRG9tKClcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgb3ZlciB4LWF4aXNcclxuICB4ICh4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgeClcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgb3ZlciB5LWF4aXNcclxuICB5ICh5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgeSlcclxuICB9XHJcbn1cclxuXHJcbmV4dGVuZChFbGVtZW50LCB7XHJcbiAgYmJveCwgcmJveCwgcG9pbnQsIGN0bSwgc2NyZWVuQ1RNXHJcbn0pXHJcblxyXG5yZWdpc3RlcihFbGVtZW50LCAnRWxlbWVudCcpXHJcbiIsImltcG9ydCB7IG9uLCBvZmYgfSBmcm9tICcuLi9jb3JlL2V2ZW50LmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi4vLi4vdHlwZXMvQ29sb3IuanMnXHJcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uLy4uL2VsZW1lbnRzL0VsZW1lbnQuanMnXHJcbmltcG9ydCBNYXRyaXggZnJvbSAnLi4vLi4vdHlwZXMvTWF0cml4LmpzJ1xyXG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vLi4vdHlwZXMvUG9pbnQuanMnXHJcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xyXG5cclxuLy8gRGVmaW5lIGxpc3Qgb2YgYXZhaWxhYmxlIGF0dHJpYnV0ZXMgZm9yIHN0cm9rZSBhbmQgZmlsbFxyXG52YXIgc3VnYXIgPSB7XHJcbiAgc3Ryb2tlOiBbICdjb2xvcicsICd3aWR0aCcsICdvcGFjaXR5JywgJ2xpbmVjYXAnLCAnbGluZWpvaW4nLCAnbWl0ZXJsaW1pdCcsICdkYXNoYXJyYXknLCAnZGFzaG9mZnNldCcgXSxcclxuICBmaWxsOiBbICdjb2xvcicsICdvcGFjaXR5JywgJ3J1bGUnIF0sXHJcbiAgcHJlZml4OiBmdW5jdGlvbiAodCwgYSkge1xyXG4gICAgcmV0dXJuIGEgPT09ICdjb2xvcicgPyB0IDogdCArICctJyArIGFcclxuICB9XHJcbn1cclxuXHJcbi8vIEFkZCBzdWdhciBmb3IgZmlsbCBhbmQgc3Ryb2tlXHJcbjtbICdmaWxsJywgJ3N0cm9rZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XHJcbiAgdmFyIGV4dGVuc2lvbiA9IHt9XHJcbiAgdmFyIGlcclxuXHJcbiAgZXh0ZW5zaW9uW21dID0gZnVuY3Rpb24gKG8pIHtcclxuICAgIGlmICh0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cihtKVxyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJyB8fCBvIGluc3RhbmNlb2YgQ29sb3IgfHwgQ29sb3IuaXNSZ2IobykgfHwgKG8gaW5zdGFuY2VvZiBFbGVtZW50KSkge1xyXG4gICAgICB0aGlzLmF0dHIobSwgbylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHNldCBhbGwgYXR0cmlidXRlcyBmcm9tIHN1Z2FyLmZpbGwgYW5kIHN1Z2FyLnN0cm9rZSBsaXN0XHJcbiAgICAgIGZvciAoaSA9IHN1Z2FyW21dLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgaWYgKG9bc3VnYXJbbV1baV1dICE9IG51bGwpIHtcclxuICAgICAgICAgIHRoaXMuYXR0cihzdWdhci5wcmVmaXgobSwgc3VnYXJbbV1baV0pLCBvW3N1Z2FyW21dW2ldXSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJNZXRob2RzKFsgJ0VsZW1lbnQnLCAnUnVubmVyJyBdLCBleHRlbnNpb24pXHJcbn0pXHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoWyAnRWxlbWVudCcsICdSdW5uZXInIF0sIHtcclxuICAvLyBMZXQgdGhlIHVzZXIgc2V0IHRoZSBtYXRyaXggZGlyZWN0bHlcclxuICBtYXRyaXg6IGZ1bmN0aW9uIChtYXQsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgIC8vIEFjdCBhcyBhIGdldHRlclxyXG4gICAgaWYgKG1hdCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWN0IGFzIGEgc2V0dGVyLCB0aGUgdXNlciBjYW4gcGFzcyBhIG1hdHJpeCBvciBhIHNldCBvZiBudW1iZXJzXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBuZXcgTWF0cml4KG1hdCwgYiwgYywgZCwgZSwgZikpXHJcbiAgfSxcclxuXHJcbiAgLy8gTWFwIHJvdGF0aW9uIHRvIHRyYW5zZm9ybVxyXG4gIHJvdGF0ZTogZnVuY3Rpb24gKGFuZ2xlLCBjeCwgY3kpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7IHJvdGF0ZTogYW5nbGUsIG94OiBjeCwgb3k6IGN5IH0sIHRydWUpXHJcbiAgfSxcclxuXHJcbiAgLy8gTWFwIHNrZXcgdG8gdHJhbnNmb3JtXHJcbiAgc2tldzogZnVuY3Rpb24gKHgsIHksIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xyXG4gICAgICA/IHRoaXMudHJhbnNmb3JtKHsgc2tldzogeCwgb3g6IHksIG95OiBjeCB9LCB0cnVlKVxyXG4gICAgICA6IHRoaXMudHJhbnNmb3JtKHsgc2tldzogWyB4LCB5IF0sIG94OiBjeCwgb3k6IGN5IH0sIHRydWUpXHJcbiAgfSxcclxuXHJcbiAgc2hlYXI6IGZ1bmN0aW9uIChsYW0sIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgc2hlYXI6IGxhbSwgb3g6IGN4LCBveTogY3kgfSwgdHJ1ZSlcclxuICB9LFxyXG5cclxuICAvLyBNYXAgc2NhbGUgdG8gdHJhbnNmb3JtXHJcbiAgc2NhbGU6IGZ1bmN0aW9uICh4LCB5LCBjeCwgY3kpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDNcclxuICAgICAgPyB0aGlzLnRyYW5zZm9ybSh7IHNjYWxlOiB4LCBveDogeSwgb3k6IGN4IH0sIHRydWUpXHJcbiAgICAgIDogdGhpcy50cmFuc2Zvcm0oeyBzY2FsZTogWyB4LCB5IF0sIG94OiBjeCwgb3k6IGN5IH0sIHRydWUpXHJcbiAgfSxcclxuXHJcbiAgLy8gTWFwIHRyYW5zbGF0ZSB0byB0cmFuc2Zvcm1cclxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyB0cmFuc2xhdGU6IFsgeCwgeSBdIH0sIHRydWUpXHJcbiAgfSxcclxuXHJcbiAgLy8gTWFwIHJlbGF0aXZlIHRyYW5zbGF0aW9ucyB0byB0cmFuc2Zvcm1cclxuICByZWxhdGl2ZTogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7IHJlbGF0aXZlOiBbIHgsIHkgXSB9LCB0cnVlKVxyXG4gIH0sXHJcblxyXG4gIC8vIE1hcCBmbGlwIHRvIHRyYW5zZm9ybVxyXG4gIGZsaXA6IGZ1bmN0aW9uIChkaXJlY3Rpb24sIGFyb3VuZCkge1xyXG4gICAgdmFyIGRpcmVjdGlvblN0cmluZyA9IHR5cGVvZiBkaXJlY3Rpb24gPT09ICdzdHJpbmcnID8gZGlyZWN0aW9uXHJcbiAgICAgIDogaXNGaW5pdGUoZGlyZWN0aW9uKSA/ICdib3RoJ1xyXG4gICAgICA6ICdib3RoJ1xyXG4gICAgdmFyIG9yaWdpbiA9IChkaXJlY3Rpb24gPT09ICdib3RoJyAmJiBpc0Zpbml0ZShhcm91bmQpKSA/IFsgYXJvdW5kLCBhcm91bmQgXVxyXG4gICAgICA6IChkaXJlY3Rpb24gPT09ICd4JykgPyBbIGFyb3VuZCwgMCBdXHJcbiAgICAgIDogKGRpcmVjdGlvbiA9PT0gJ3knKSA/IFsgMCwgYXJvdW5kIF1cclxuICAgICAgOiBpc0Zpbml0ZShkaXJlY3Rpb24pID8gWyBkaXJlY3Rpb24sIGRpcmVjdGlvbiBdXHJcbiAgICAgIDogWyAwLCAwIF1cclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7IGZsaXA6IGRpcmVjdGlvblN0cmluZywgb3JpZ2luOiBvcmlnaW4gfSwgdHJ1ZSlcclxuICB9LFxyXG5cclxuICAvLyBPcGFjaXR5XHJcbiAgb3BhY2l0eTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdvcGFjaXR5JywgdmFsdWUpXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdyYWRpdXMnLCB7XHJcbiAgLy8gQWRkIHggYW5kIHkgcmFkaXVzXHJcbiAgcmFkaXVzOiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgdmFyIHR5cGUgPSAodGhpcy5fZWxlbWVudCB8fCB0aGlzKS50eXBlXHJcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3JhZGlhbEdyYWRpZW50JyB8fCB0eXBlID09PSAncmFkaWFsR3JhZGllbnQnXHJcbiAgICAgID8gdGhpcy5hdHRyKCdyJywgbmV3IFNWR051bWJlcih4KSlcclxuICAgICAgOiB0aGlzLnJ4KHgpLnJ5KHkgPT0gbnVsbCA/IHggOiB5KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcygnUGF0aCcsIHtcclxuICAvLyBHZXQgcGF0aCBsZW5ndGhcclxuICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgoKVxyXG4gIH0sXHJcbiAgLy8gR2V0IHBvaW50IGF0IGxlbmd0aFxyXG4gIHBvaW50QXQ6IGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5ub2RlLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoWyAnRWxlbWVudCcsICdSdW5uZXInIF0sIHtcclxuICAvLyBTZXQgZm9udFxyXG4gIGZvbnQ6IGZ1bmN0aW9uIChhLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGZvciAodiBpbiBhKSB0aGlzLmZvbnQodiwgYVt2XSlcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYSA9PT0gJ2xlYWRpbmcnXHJcbiAgICAgID8gdGhpcy5sZWFkaW5nKHYpXHJcbiAgICAgIDogYSA9PT0gJ2FuY2hvcidcclxuICAgICAgICA/IHRoaXMuYXR0cigndGV4dC1hbmNob3InLCB2KVxyXG4gICAgICAgIDogYSA9PT0gJ3NpemUnIHx8IGEgPT09ICdmYW1pbHknIHx8IGEgPT09ICd3ZWlnaHQnIHx8IGEgPT09ICdzdHJldGNoJyB8fCBhID09PSAndmFyaWFudCcgfHwgYSA9PT0gJ3N0eWxlJ1xyXG4gICAgICAgICAgPyB0aGlzLmF0dHIoJ2ZvbnQtJyArIGEsIHYpXHJcbiAgICAgICAgICA6IHRoaXMuYXR0cihhLCB2KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcygnVGV4dCcsIHtcclxuICBheCAoeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHgpXHJcbiAgfSxcclxuICBheSAoeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigneScsIHkpXHJcbiAgfSxcclxuICBhbW92ZSAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXgoeCkuYXkoeSlcclxuICB9XHJcbn0pXHJcblxyXG4vLyBBZGQgZXZlbnRzIHRvIGVsZW1lbnRzXHJcbmNvbnN0IG1ldGhvZHMgPSBbICdjbGljaycsXHJcbiAgJ2RibGNsaWNrJyxcclxuICAnbW91c2Vkb3duJyxcclxuICAnbW91c2V1cCcsXHJcbiAgJ21vdXNlb3ZlcicsXHJcbiAgJ21vdXNlb3V0JyxcclxuICAnbW91c2Vtb3ZlJyxcclxuICAnbW91c2VlbnRlcicsXHJcbiAgJ21vdXNlbGVhdmUnLFxyXG4gICd0b3VjaHN0YXJ0JyxcclxuICAndG91Y2htb3ZlJyxcclxuICAndG91Y2hsZWF2ZScsXHJcbiAgJ3RvdWNoZW5kJyxcclxuICAndG91Y2hjYW5jZWwnIF0ucmVkdWNlKGZ1bmN0aW9uIChsYXN0LCBldmVudCkge1xyXG4gIC8vIGFkZCBldmVudCB0byBFbGVtZW50XHJcbiAgY29uc3QgZm4gPSBmdW5jdGlvbiAoZikge1xyXG4gICAgaWYgKGYgPT09IG51bGwpIHtcclxuICAgICAgb2ZmKHRoaXMsIGV2ZW50KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb24odGhpcywgZXZlbnQsIGYpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgbGFzdFtldmVudF0gPSBmblxyXG4gIHJldHVybiBsYXN0XHJcbn0sIHt9KVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdFbGVtZW50JywgbWV0aG9kcylcclxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xuXG52YXIgbmF0aXZlUmV2ZXJzZSA9IFtdLnJldmVyc2U7XG52YXIgdGVzdCA9IFsxLCAyXTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZXZlcnNlXG4vLyBmaXggZm9yIFNhZmFyaSAxMi4wIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4ODc5NFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU3RyaW5nKHRlc3QpID09PSBTdHJpbmcodGVzdC5yZXZlcnNlKCkpIH0sIHtcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBpZiAoaXNBcnJheSh0aGlzKSkgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gbmF0aXZlUmV2ZXJzZS5jYWxsKHRoaXMpO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhREVTQ1JJUFRPUlMsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGRlZmluZVByb3BlcnRpZXM6IGRlZmluZVByb3BlcnRpZXNcbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eU1vZGlsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhREVTQ1JJUFRPUlMsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGRlZmluZVByb3BlcnR5OiBvYmplY3REZWZpbmVQcm9wZXJ0eU1vZGlsZS5mXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoMSk7IH0pO1xudmFyIEZPUkNFRCA9ICFERVNDUklQVE9SUyB8fCBGQUlMU19PTl9QUklNSVRJVkVTO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSW5kZXhlZE9iamVjdChpdCksIGtleSk7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iLCJpbXBvcnQgeyBnZXRPcmlnaW4gfSBmcm9tICcuLi8uLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgZGVsaW1pdGVyLCB0cmFuc2Zvcm1zIH0gZnJvbSAnLi4vY29yZS9yZWdleC5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi8uLi90eXBlcy9NYXRyaXguanMnXHJcblxyXG4vLyBSZXNldCBhbGwgdHJhbnNmb3JtYXRpb25zXHJcbmV4cG9ydCBmdW5jdGlvbiB1bnRyYW5zZm9ybSAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbnVsbClcclxufVxyXG5cclxuLy8gbWVyZ2UgdGhlIHdob2xlIHRyYW5zZm9ybWF0aW9uIGNoYWluIGludG8gb25lIG1hdHJpeCBhbmQgcmV0dXJucyBpdFxyXG5leHBvcnQgZnVuY3Rpb24gbWF0cml4aWZ5ICgpIHtcclxuICB2YXIgbWF0cml4ID0gKHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJycpXHJcbiAgICAvLyBzcGxpdCB0cmFuc2Zvcm1hdGlvbnNcclxuICAgIC5zcGxpdCh0cmFuc2Zvcm1zKS5zbGljZSgwLCAtMSkubWFwKGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgLy8gZ2VuZXJhdGUga2V5ID0+IHZhbHVlIHBhaXJzXHJcbiAgICAgIHZhciBrdiA9IHN0ci50cmltKCkuc3BsaXQoJygnKVxyXG4gICAgICByZXR1cm4gWyBrdlswXSxcclxuICAgICAgICBrdlsxXS5zcGxpdChkZWxpbWl0ZXIpXHJcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKVxyXG4gICAgICAgICAgfSlcclxuICAgICAgXVxyXG4gICAgfSlcclxuICAgIC5yZXZlcnNlKClcclxuICAgIC8vIG1lcmdlIGV2ZXJ5IHRyYW5zZm9ybWF0aW9uIGludG8gb25lIG1hdHJpeFxyXG4gICAgLnJlZHVjZShmdW5jdGlvbiAobWF0cml4LCB0cmFuc2Zvcm0pIHtcclxuICAgICAgaWYgKHRyYW5zZm9ybVswXSA9PT0gJ21hdHJpeCcpIHtcclxuICAgICAgICByZXR1cm4gbWF0cml4LmxtdWx0aXBseShNYXRyaXguZnJvbUFycmF5KHRyYW5zZm9ybVsxXSkpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hdHJpeFt0cmFuc2Zvcm1bMF1dLmFwcGx5KG1hdHJpeCwgdHJhbnNmb3JtWzFdKVxyXG4gICAgfSwgbmV3IE1hdHJpeCgpKVxyXG5cclxuICByZXR1cm4gbWF0cml4XHJcbn1cclxuXHJcbi8vIGFkZCBhbiBlbGVtZW50IHRvIGFub3RoZXIgcGFyZW50IHdpdGhvdXQgY2hhbmdpbmcgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2NyZWVuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1BhcmVudCAocGFyZW50KSB7XHJcbiAgaWYgKHRoaXMgPT09IHBhcmVudCkgcmV0dXJuIHRoaXNcclxuICB2YXIgY3RtID0gdGhpcy5zY3JlZW5DVE0oKVxyXG4gIHZhciBwQ3RtID0gcGFyZW50LnNjcmVlbkNUTSgpLmludmVyc2UoKVxyXG5cclxuICB0aGlzLmFkZFRvKHBhcmVudCkudW50cmFuc2Zvcm0oKS50cmFuc2Zvcm0ocEN0bS5tdWx0aXBseShjdG0pKVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vLyBzYW1lIGFzIGFib3ZlIHdpdGggcGFyZW50IGVxdWFscyByb290LXN2Z1xyXG5leHBvcnQgZnVuY3Rpb24gdG9Sb290ICgpIHtcclxuICByZXR1cm4gdGhpcy50b1BhcmVudCh0aGlzLnJvb3QoKSlcclxufVxyXG5cclxuLy8gQWRkIHRyYW5zZm9ybWF0aW9uc1xyXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtIChvLCByZWxhdGl2ZSkge1xyXG4gIC8vIEFjdCBhcyBhIGdldHRlciBpZiBubyBvYmplY3Qgd2FzIHBhc3NlZFxyXG4gIGlmIChvID09IG51bGwgfHwgdHlwZW9mIG8gPT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YXIgZGVjb21wb3NlZCA9IG5ldyBNYXRyaXgodGhpcykuZGVjb21wb3NlKClcclxuICAgIHJldHVybiBvID09IG51bGwgPyBkZWNvbXBvc2VkIDogZGVjb21wb3NlZFtvXVxyXG4gIH1cclxuXHJcbiAgaWYgKCFNYXRyaXguaXNNYXRyaXhMaWtlKG8pKSB7XHJcbiAgICAvLyBTZXQgdGhlIG9yaWdpbiBhY2NvcmRpbmcgdG8gdGhlIGRlZmluZWQgdHJhbnNmb3JtXHJcbiAgICBvID0geyAuLi5vLCBvcmlnaW46IGdldE9yaWdpbihvLCB0aGlzKSB9XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgdXNlciBjYW4gcGFzcyBhIGJvb2xlYW4sIGFuIEVsZW1lbnQgb3IgYW4gTWF0cml4IG9yIG5vdGhpbmdcclxuICB2YXIgY2xlYW5SZWxhdGl2ZSA9IHJlbGF0aXZlID09PSB0cnVlID8gdGhpcyA6IChyZWxhdGl2ZSB8fCBmYWxzZSlcclxuICB2YXIgcmVzdWx0ID0gbmV3IE1hdHJpeChjbGVhblJlbGF0aXZlKS50cmFuc2Zvcm0obylcclxuICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCByZXN1bHQpXHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcygnRWxlbWVudCcsIHtcclxuICB1bnRyYW5zZm9ybSwgbWF0cml4aWZ5LCB0b1BhcmVudCwgdG9Sb290LCB0cmFuc2Zvcm1cclxufSlcclxuIiwiaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi8uLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcblxyXG4vLyBSYWRpdXMgeCB2YWx1ZVxyXG5leHBvcnQgZnVuY3Rpb24gcnggKHJ4KSB7XHJcbiAgcmV0dXJuIHRoaXMuYXR0cigncngnLCByeClcclxufVxyXG5cclxuLy8gUmFkaXVzIHkgdmFsdWVcclxuZXhwb3J0IGZ1bmN0aW9uIHJ5IChyeSkge1xyXG4gIHJldHVybiB0aGlzLmF0dHIoJ3J5JywgcnkpXHJcbn1cclxuXHJcbi8vIE1vdmUgb3ZlciB4LWF4aXNcclxuZXhwb3J0IGZ1bmN0aW9uIHggKHgpIHtcclxuICByZXR1cm4geCA9PSBudWxsXHJcbiAgICA/IHRoaXMuY3goKSAtIHRoaXMucngoKVxyXG4gICAgOiB0aGlzLmN4KHggKyB0aGlzLnJ4KCkpXHJcbn1cclxuXHJcbi8vIE1vdmUgb3ZlciB5LWF4aXNcclxuZXhwb3J0IGZ1bmN0aW9uIHkgKHkpIHtcclxuICByZXR1cm4geSA9PSBudWxsXHJcbiAgICA/IHRoaXMuY3koKSAtIHRoaXMucnkoKVxyXG4gICAgOiB0aGlzLmN5KHkgKyB0aGlzLnJ5KCkpXHJcbn1cclxuXHJcbi8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXHJcbmV4cG9ydCBmdW5jdGlvbiBjeCAoeCkge1xyXG4gIHJldHVybiB4ID09IG51bGxcclxuICAgID8gdGhpcy5hdHRyKCdjeCcpXHJcbiAgICA6IHRoaXMuYXR0cignY3gnLCB4KVxyXG59XHJcblxyXG4vLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xyXG5leHBvcnQgZnVuY3Rpb24gY3kgKHkpIHtcclxuICByZXR1cm4geSA9PSBudWxsXHJcbiAgICA/IHRoaXMuYXR0cignY3knKVxyXG4gICAgOiB0aGlzLmF0dHIoJ2N5JywgeSlcclxufVxyXG5cclxuLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIHdpZHRoICh3aWR0aCkge1xyXG4gIHJldHVybiB3aWR0aCA9PSBudWxsXHJcbiAgICA/IHRoaXMucngoKSAqIDJcclxuICAgIDogdGhpcy5yeChuZXcgU1ZHTnVtYmVyKHdpZHRoKS5kaXZpZGUoMikpXHJcbn1cclxuXHJcbi8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gaGVpZ2h0IChoZWlnaHQpIHtcclxuICByZXR1cm4gaGVpZ2h0ID09IG51bGxcclxuICAgID8gdGhpcy5yeSgpICogMlxyXG4gICAgOiB0aGlzLnJ5KG5ldyBTVkdOdW1iZXIoaGVpZ2h0KS5kaXZpZGUoMikpXHJcbn1cclxuIiwiaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuL0VsZW1lbnQuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFwZSBleHRlbmRzIEVsZW1lbnQge31cclxuXHJcbnJlZ2lzdGVyKFNoYXBlLCAnU2hhcGUnKVxyXG4iLCJpbXBvcnQgeyBjeCwgY3ksIGhlaWdodCwgd2lkdGgsIHgsIHkgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvY2lyY2xlZC5qcydcclxuaW1wb3J0IHtcclxuICBleHRlbmQsXHJcbiAgbm9kZU9yTmV3LFxyXG4gIHJlZ2lzdGVyLFxyXG4gIHdyYXBXaXRoQXR0ckNoZWNrXHJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2hhcGUge1xyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ2NpcmNsZScsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgcmFkaXVzIChyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgcilcclxuICB9XHJcblxyXG4gIC8vIFJhZGl1cyB4IHZhbHVlXHJcbiAgcnggKHJ4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgcngpXHJcbiAgfVxyXG5cclxuICAvLyBBbGlhcyByYWRpdXMgeCB2YWx1ZVxyXG4gIHJ5IChyeSkge1xyXG4gICAgcmV0dXJuIHRoaXMucngocnkpXHJcbiAgfVxyXG5cclxuICBzaXplIChzaXplKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yYWRpdXMobmV3IFNWR051bWJlcihzaXplKS5kaXZpZGUoMikpXHJcbiAgfVxyXG59XHJcblxyXG5leHRlbmQoQ2lyY2xlLCB7IHgsIHksIGN4LCBjeSwgd2lkdGgsIGhlaWdodCB9KVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSBjaXJjbGUgZWxlbWVudFxyXG4gICAgY2lyY2xlOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IENpcmNsZSgpKVxyXG4gICAgICAgIC5zaXplKHNpemUpXHJcbiAgICAgICAgLm1vdmUoMCwgMClcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoQ2lyY2xlLCAnQ2lyY2xlJylcclxuIiwiaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuL0VsZW1lbnQuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250YWluZXIgZXh0ZW5kcyBFbGVtZW50IHtcclxuICBmbGF0dGVuIChwYXJlbnQpIHtcclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQ29udGFpbmVyKSByZXR1cm4gdGhpcy5mbGF0dGVuKHBhcmVudCkudW5ncm91cChwYXJlbnQpXHJcbiAgICAgIHJldHVybiB0aGlzLnRvUGFyZW50KHBhcmVudClcclxuICAgIH0pXHJcblxyXG4gICAgLy8gd2UgbmVlZCB0aGlzIHNvIHRoYXQgdGhlIHJvb3QgZG9lcyBub3QgZ2V0IHJlbW92ZWRcclxuICAgIHRoaXMubm9kZS5maXJzdEVsZW1lbnRDaGlsZCB8fCB0aGlzLnJlbW92ZSgpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHVuZ3JvdXAgKHBhcmVudCkge1xyXG4gICAgcGFyZW50ID0gcGFyZW50IHx8IHRoaXMucGFyZW50KClcclxuXHJcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50b1BhcmVudChwYXJlbnQpXHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMucmVtb3ZlKClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXIoQ29udGFpbmVyLCAnQ29udGFpbmVyJylcclxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZzIGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdkZWZzJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICBmbGF0dGVuICgpIHtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxuXHJcbiAgdW5ncm91cCAoKSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXIoRGVmcywgJ0RlZnMnKVxyXG4iLCJpbXBvcnQge1xyXG4gIGV4dGVuZCxcclxuICBub2RlT3JOZXcsXHJcbiAgcmVnaXN0ZXIsXHJcbiAgd3JhcFdpdGhBdHRyQ2hlY2tcclxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBwcm9wb3J0aW9uYWxTaXplIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xyXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcclxuaW1wb3J0ICogYXMgY2lyY2xlZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvY2lyY2xlZC5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsbGlwc2UgZXh0ZW5kcyBTaGFwZSB7XHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnZWxsaXBzZScsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgc2l6ZSAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICAgICAgLnJ4KG5ldyBTVkdOdW1iZXIocC53aWR0aCkuZGl2aWRlKDIpKVxyXG4gICAgICAucnkobmV3IFNWR051bWJlcihwLmhlaWdodCkuZGl2aWRlKDIpKVxyXG4gIH1cclxufVxyXG5cclxuZXh0ZW5kKEVsbGlwc2UsIGNpcmNsZWQpXHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoJ0NvbnRhaW5lcicsIHtcclxuICAvLyBDcmVhdGUgYW4gZWxsaXBzZVxyXG4gIGVsbGlwc2U6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh3aWR0aCA9IDAsIGhlaWdodCA9IHdpZHRoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IEVsbGlwc2UoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KS5tb3ZlKDAsIDApXHJcbiAgfSlcclxufSlcclxuXHJcbnJlZ2lzdGVyKEVsbGlwc2UsICdFbGxpcHNlJylcclxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vRWxlbWVudC5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9wIGV4dGVuZHMgRWxlbWVudCB7XHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnc3RvcCcsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gYWRkIGNvbG9yIHN0b3BzXHJcbiAgdXBkYXRlIChvKSB7XHJcbiAgICBpZiAodHlwZW9mIG8gPT09ICdudW1iZXInIHx8IG8gaW5zdGFuY2VvZiBTVkdOdW1iZXIpIHtcclxuICAgICAgbyA9IHtcclxuICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1swXSxcclxuICAgICAgICBjb2xvcjogYXJndW1lbnRzWzFdLFxyXG4gICAgICAgIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IGF0dHJpYnV0ZXNcclxuICAgIGlmIChvLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLW9wYWNpdHknLCBvLm9wYWNpdHkpXHJcbiAgICBpZiAoby5jb2xvciAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKVxyXG4gICAgaWYgKG8ub2Zmc2V0ICE9IG51bGwpIHRoaXMuYXR0cignb2Zmc2V0JywgbmV3IFNWR051bWJlcihvLm9mZnNldCkpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyKFN0b3AsICdTdG9wJylcclxuIiwiaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi8uLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZnJvbSAoeCwgeSkge1xyXG4gIHJldHVybiAodGhpcy5fZWxlbWVudCB8fCB0aGlzKS50eXBlID09PSAncmFkaWFsR3JhZGllbnQnXHJcbiAgICA/IHRoaXMuYXR0cih7IGZ4OiBuZXcgU1ZHTnVtYmVyKHgpLCBmeTogbmV3IFNWR051bWJlcih5KSB9KVxyXG4gICAgOiB0aGlzLmF0dHIoeyB4MTogbmV3IFNWR051bWJlcih4KSwgeTE6IG5ldyBTVkdOdW1iZXIoeSkgfSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvICh4LCB5KSB7XHJcbiAgcmV0dXJuICh0aGlzLl9lbGVtZW50IHx8IHRoaXMpLnR5cGUgPT09ICdyYWRpYWxHcmFkaWVudCdcclxuICAgID8gdGhpcy5hdHRyKHsgY3g6IG5ldyBTVkdOdW1iZXIoeCksIGN5OiBuZXcgU1ZHTnVtYmVyKHkpIH0pXHJcbiAgICA6IHRoaXMuYXR0cih7IHgyOiBuZXcgU1ZHTnVtYmVyKHgpLCB5MjogbmV3IFNWR051bWJlcih5KSB9KVxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgZXh0ZW5kLFxyXG4gIG5vZGVPck5ldyxcclxuICByZWdpc3RlcixcclxuICB3cmFwV2l0aEF0dHJDaGVja1xyXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBCb3ggZnJvbSAnLi4vdHlwZXMvQm94LmpzJ1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xyXG5pbXBvcnQgU3RvcCBmcm9tICcuL1N0b3AuanMnXHJcbmltcG9ydCBiYXNlRmluZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanMnXHJcbmltcG9ydCAqIGFzIGdyYWRpZW50ZWQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2dyYWRpZW50ZWQuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFkaWVudCBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgY29uc3RydWN0b3IgKHR5cGUsIGF0dHJzKSB7XHJcbiAgICBzdXBlcihcclxuICAgICAgbm9kZU9yTmV3KHR5cGUgKyAnR3JhZGllbnQnLCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBudWxsIDogdHlwZSksXHJcbiAgICAgIGF0dHJzXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvLyBBZGQgYSBjb2xvciBzdG9wXHJcbiAgc3RvcCAob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkge1xyXG4gICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdG9wKCkpLnVwZGF0ZShvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KVxyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIGdyYWRpZW50XHJcbiAgdXBkYXRlIChibG9jaykge1xyXG4gICAgLy8gcmVtb3ZlIGFsbCBzdG9wc1xyXG4gICAgdGhpcy5jbGVhcigpXHJcblxyXG4gICAgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xyXG4gICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiB0aGUgZmlsbCBpZFxyXG4gIHVybCAoKSB7XHJcbiAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJ1xyXG4gIH1cclxuXHJcbiAgLy8gQWxpYXMgc3RyaW5nIGNvbnZlcnRpb24gdG8gZmlsbFxyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiB0aGlzLnVybCgpXHJcbiAgfVxyXG5cclxuICAvLyBjdXN0b20gYXR0ciB0byBoYW5kbGUgdHJhbnNmb3JtXHJcbiAgYXR0ciAoYSwgYiwgYykge1xyXG4gICAgaWYgKGEgPT09ICd0cmFuc2Zvcm0nKSBhID0gJ2dyYWRpZW50VHJhbnNmb3JtJ1xyXG4gICAgcmV0dXJuIHN1cGVyLmF0dHIoYSwgYiwgYylcclxuICB9XHJcblxyXG4gIHRhcmdldHMgKCkge1xyXG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW2ZpbGwqPVwiJyArIHRoaXMuaWQoKSArICdcIl0nKVxyXG4gIH1cclxuXHJcbiAgYmJveCAoKSB7XHJcbiAgICByZXR1cm4gbmV3IEJveCgpXHJcbiAgfVxyXG59XHJcblxyXG5leHRlbmQoR3JhZGllbnQsIGdyYWRpZW50ZWQpXHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgLy8gQ3JlYXRlIGdyYWRpZW50IGVsZW1lbnQgaW4gZGVmc1xyXG4gICAgZ3JhZGllbnQ6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0eXBlLCBibG9jaykge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkuZ3JhZGllbnQodHlwZSwgYmxvY2spXHJcbiAgICB9KVxyXG4gIH0sXHJcbiAgLy8gZGVmaW5lIGdyYWRpZW50XHJcbiAgRGVmczoge1xyXG4gICAgZ3JhZGllbnQ6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0eXBlLCBibG9jaykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEdyYWRpZW50KHR5cGUpKS51cGRhdGUoYmxvY2spXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKEdyYWRpZW50LCAnR3JhZGllbnQnKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBCb3ggZnJvbSAnLi4vdHlwZXMvQm94LmpzJ1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xyXG5pbXBvcnQgYmFzZUZpbmQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3NlbGVjdG9yLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0dGVybiBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygncGF0dGVybicsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXHJcbiAgdXJsICgpIHtcclxuICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgcGF0dGVybiBieSByZWJ1aWxkaW5nXHJcbiAgdXBkYXRlIChibG9jaykge1xyXG4gICAgLy8gcmVtb3ZlIGNvbnRlbnRcclxuICAgIHRoaXMuY2xlYXIoKVxyXG5cclxuICAgIC8vIGludm9rZSBwYXNzZWQgYmxvY2tcclxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBBbGlhcyBzdHJpbmcgY29udmVydGlvbiB0byBmaWxsXHJcbiAgdG9TdHJpbmcgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudXJsKClcclxuICB9XHJcblxyXG4gIC8vIGN1c3RvbSBhdHRyIHRvIGhhbmRsZSB0cmFuc2Zvcm1cclxuICBhdHRyIChhLCBiLCBjKSB7XHJcbiAgICBpZiAoYSA9PT0gJ3RyYW5zZm9ybScpIGEgPSAncGF0dGVyblRyYW5zZm9ybSdcclxuICAgIHJldHVybiBzdXBlci5hdHRyKGEsIGIsIGMpXHJcbiAgfVxyXG5cclxuICB0YXJnZXRzICgpIHtcclxuICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIFtmaWxsKj1cIicgKyB0aGlzLmlkKCkgKyAnXCJdJylcclxuICB9XHJcblxyXG4gIGJib3ggKCkge1xyXG4gICAgcmV0dXJuIG5ldyBCb3goKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSBwYXR0ZXJuIGVsZW1lbnQgaW4gZGVmc1xyXG4gICAgcGF0dGVybiAoLi4uYXJncykge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucGF0dGVybiguLi5hcmdzKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgRGVmczoge1xyXG4gICAgcGF0dGVybjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUGF0dGVybigpKS51cGRhdGUoYmxvY2spLmF0dHIoe1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgcGF0dGVyblVuaXRzOiAndXNlclNwYWNlT25Vc2UnXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKFBhdHRlcm4sICdQYXR0ZXJuJylcclxuIiwiaW1wb3J0IHsgaXNJbWFnZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcclxuaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBvZmYsIG9uIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2V2ZW50LmpzJ1xyXG5pbXBvcnQgeyByZWdpc3RlckF0dHJIb29rIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2F0dHIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCB7IHhsaW5rIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXHJcbmltcG9ydCBQYXR0ZXJuIGZyb20gJy4vUGF0dGVybi5qcydcclxuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXHJcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZSBleHRlbmRzIFNoYXBlIHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdpbWFnZScsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gKHJlKWxvYWQgaW1hZ2VcclxuICBsb2FkICh1cmwsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIXVybCkgcmV0dXJuIHRoaXNcclxuXHJcbiAgICB2YXIgaW1nID0gbmV3IGdsb2JhbHMud2luZG93LkltYWdlKClcclxuXHJcbiAgICBvbihpbWcsICdsb2FkJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgdmFyIHAgPSB0aGlzLnBhcmVudChQYXR0ZXJuKVxyXG5cclxuICAgICAgLy8gZW5zdXJlIGltYWdlIHNpemVcclxuICAgICAgaWYgKHRoaXMud2lkdGgoKSA9PT0gMCAmJiB0aGlzLmhlaWdodCgpID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5zaXplKGltZy53aWR0aCwgaW1nLmhlaWdodClcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQYXR0ZXJuKSB7XHJcbiAgICAgICAgLy8gZW5zdXJlIHBhdHRlcm4gc2l6ZSBpZiBub3Qgc2V0XHJcbiAgICAgICAgaWYgKHAud2lkdGgoKSA9PT0gMCAmJiBwLmhlaWdodCgpID09PSAwKSB7XHJcbiAgICAgICAgICBwLnNpemUodGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZSlcclxuICAgICAgfVxyXG4gICAgfSwgdGhpcylcclxuXHJcbiAgICBvbihpbWcsICdsb2FkIGVycm9yJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAvLyBkb250IGZvcmdldCB0byB1bmJpbmQgbWVtb3J5IGxlYWtpbmcgZXZlbnRzXHJcbiAgICAgIG9mZihpbWcpXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoaW1nLnNyYyA9IHVybCksIHhsaW5rKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJBdHRySG9vayhmdW5jdGlvbiAoYXR0ciwgdmFsLCBfdGhpcykge1xyXG4gIC8vIGNvbnZlcnQgaW1hZ2UgZmlsbCBhbmQgc3Ryb2tlIHRvIHBhdHRlcm5zXHJcbiAgaWYgKGF0dHIgPT09ICdmaWxsJyB8fCBhdHRyID09PSAnc3Ryb2tlJykge1xyXG4gICAgaWYgKGlzSW1hZ2UudGVzdCh2YWwpKSB7XHJcbiAgICAgIHZhbCA9IF90aGlzLnJvb3QoKS5kZWZzKCkuaW1hZ2UodmFsKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEltYWdlKSB7XHJcbiAgICB2YWwgPSBfdGhpcy5yb290KCkuZGVmcygpLnBhdHRlcm4oMCwgMCwgKHBhdHRlcm4pID0+IHtcclxuICAgICAgcGF0dGVybi5hZGQodmFsKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHJldHVybiB2YWxcclxufSlcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBjcmVhdGUgaW1hZ2UgZWxlbWVudCwgbG9hZCBpbWFnZSBhbmQgc2V0IGl0cyBzaXplXHJcbiAgICBpbWFnZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBJbWFnZSgpKS5zaXplKDAsIDApLmxvYWQoc291cmNlLCBjYWxsYmFjaylcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoSW1hZ2UsICdJbWFnZScpXHJcbiIsImltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcclxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgc3ViQ2xhc3NBcnJheSB9IGZyb20gJy4vQXJyYXlQb2x5ZmlsbC5qcydcclxuaW1wb3J0IFNWR0FycmF5IGZyb20gJy4vU1ZHQXJyYXkuanMnXHJcblxyXG5jb25zdCBQb2ludEFycmF5ID0gc3ViQ2xhc3NBcnJheSgnUG9pbnRBcnJheScsIFNWR0FycmF5KVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUG9pbnRBcnJheVxyXG5cclxuZXh0ZW5kKFBvaW50QXJyYXksIHtcclxuICAvLyBDb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIC8vIGNvbnZlcnQgdG8gYSBwb2x5IHBvaW50IHN0cmluZ1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5sZW5ndGgsIGFycmF5ID0gW107IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgIGFycmF5LnB1c2godGhpc1tpXS5qb2luKCcsJykpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJyAnKVxyXG4gIH0sXHJcblxyXG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gbGluZSBvYmplY3RcclxuICB0b0xpbmUgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDE6IHRoaXNbMF1bMF0sXHJcbiAgICAgIHkxOiB0aGlzWzBdWzFdLFxyXG4gICAgICB4MjogdGhpc1sxXVswXSxcclxuICAgICAgeTI6IHRoaXNbMV1bMV1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBHZXQgbW9ycGhlZCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxyXG4gIGF0IChwb3MpIHtcclxuICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcclxuICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAvLyBnZW5lcmF0ZSBtb3JwaGVkIHBvaW50IHN0cmluZ1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5sZW5ndGgsIGFycmF5ID0gW107IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgIGFycmF5LnB1c2goW1xyXG4gICAgICAgIHRoaXNbaV1bMF0gKyAodGhpcy5kZXN0aW5hdGlvbltpXVswXSAtIHRoaXNbaV1bMF0pICogcG9zLFxyXG4gICAgICAgIHRoaXNbaV1bMV0gKyAodGhpcy5kZXN0aW5hdGlvbltpXVsxXSAtIHRoaXNbaV1bMV0pICogcG9zXHJcbiAgICAgIF0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQb2ludEFycmF5KGFycmF5KVxyXG4gIH0sXHJcblxyXG4gIC8vIFBhcnNlIHBvaW50IHN0cmluZyBhbmQgZmxhdCBhcnJheVxyXG4gIHBhcnNlIChhcnJheSA9IFsgWyAwLCAwIF0gXSkge1xyXG4gICAgdmFyIHBvaW50cyA9IFtdXHJcblxyXG4gICAgLy8gaWYgaXQgaXMgYW4gYXJyYXlcclxuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgIC8vIGFuZCBpdCBpcyBub3QgZmxhdCwgdGhlcmUgaXMgbm8gbmVlZCB0byBwYXJzZSBpdFxyXG4gICAgICBpZiAoYXJyYXlbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgeyAvLyBFbHNlLCBpdCBpcyBjb25zaWRlcmVkIGFzIGEgc3RyaW5nXHJcbiAgICAgIC8vIHBhcnNlIHBvaW50c1xyXG4gICAgICBhcnJheSA9IGFycmF5LnRyaW0oKS5zcGxpdChkZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHZhbGlkYXRlIHBvaW50cyAtIGh0dHBzOi8vc3Znd2cub3JnL3N2ZzItZHJhZnQvc2hhcGVzLmh0bWwjRGF0YVR5cGVQb2ludHNcclxuICAgIC8vIE9kZCBudW1iZXIgb2YgY29vcmRpbmF0ZXMgaXMgYW4gZXJyb3IuIEluIHN1Y2ggY2FzZXMsIGRyb3AgdGhlIGxhc3Qgb2RkIGNvb3JkaW5hdGUuXHJcbiAgICBpZiAoYXJyYXkubGVuZ3RoICUgMiAhPT0gMCkgYXJyYXkucG9wKClcclxuXHJcbiAgICAvLyB3cmFwIHBvaW50cyBpbiB0d28tdHVwbGVzXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpID0gaSArIDIpIHtcclxuICAgICAgcG9pbnRzLnB1c2goWyBhcnJheVtpXSwgYXJyYXlbaSArIDFdIF0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvaW50c1xyXG4gIH0sXHJcblxyXG4gIC8vIHRyYW5zZm9ybSBwb2ludHMgd2l0aCBtYXRyaXggKHNpbWlsYXIgdG8gUG9pbnQudHJhbnNmb3JtKVxyXG4gIHRyYW5zZm9ybSAobSkge1xyXG4gICAgY29uc3QgcG9pbnRzID0gW11cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgcG9pbnQgPSB0aGlzW2ldXHJcbiAgICAgIC8vIFBlcmZvcm0gdGhlIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICBwb2ludHMucHVzaChbXHJcbiAgICAgICAgbS5hICogcG9pbnRbMF0gKyBtLmMgKiBwb2ludFsxXSArIG0uZSxcclxuICAgICAgICBtLmIgKiBwb2ludFswXSArIG0uZCAqIHBvaW50WzFdICsgbS5mXHJcbiAgICAgIF0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSByZXF1aXJlZCBwb2ludFxyXG4gICAgcmV0dXJuIG5ldyBQb2ludEFycmF5KHBvaW50cylcclxuICB9LFxyXG5cclxuICAvLyBNb3ZlIHBvaW50IHN0cmluZ1xyXG4gIG1vdmUgKHgsIHkpIHtcclxuICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgIC8vIGdldCByZWxhdGl2ZSBvZmZzZXRcclxuICAgIHggLT0gYm94LnhcclxuICAgIHkgLT0gYm94LnlcclxuXHJcbiAgICAvLyBtb3ZlIGV2ZXJ5IHBvaW50XHJcbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHRoaXNbaV0gPSBbIHRoaXNbaV1bMF0gKyB4LCB0aGlzW2ldWzFdICsgeSBdXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH0sXHJcblxyXG4gIC8vIFJlc2l6ZSBwb2x5IHN0cmluZ1xyXG4gIHNpemUgKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciBpXHJcbiAgICB2YXIgYm94ID0gdGhpcy5iYm94KClcclxuXHJcbiAgICAvLyByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiBhbGwgcG9pbnRzIGFjY29yZGluZyB0byBuZXcgc2l6ZVxyXG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBpZiAoYm94LndpZHRoKSB0aGlzW2ldWzBdID0gKCh0aGlzW2ldWzBdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcclxuICAgICAgaWYgKGJveC5oZWlnaHQpIHRoaXNbaV1bMV0gPSAoKHRoaXNbaV1bMV0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICAvLyBHZXQgYm91bmRpbmcgYm94IG9mIHBvaW50c1xyXG4gIGJib3ggKCkge1xyXG4gICAgdmFyIG1heFggPSAtSW5maW5pdHlcclxuICAgIHZhciBtYXhZID0gLUluZmluaXR5XHJcbiAgICB2YXIgbWluWCA9IEluZmluaXR5XHJcbiAgICB2YXIgbWluWSA9IEluZmluaXR5XHJcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgIG1heFggPSBNYXRoLm1heChlbFswXSwgbWF4WClcclxuICAgICAgbWF4WSA9IE1hdGgubWF4KGVsWzFdLCBtYXhZKVxyXG4gICAgICBtaW5YID0gTWF0aC5taW4oZWxbMF0sIG1pblgpXHJcbiAgICAgIG1pblkgPSBNYXRoLm1pbihlbFsxXSwgbWluWSlcclxuICAgIH0pXHJcbiAgICByZXR1cm4geyB4OiBtaW5YLCB5OiBtaW5ZLCB3aWR0aDogbWF4WCAtIG1pblgsIGhlaWdodDogbWF4WSAtIG1pblkgfVxyXG4gIH1cclxufSlcclxuIiwiaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcclxuXHJcbmV4cG9ydCBjb25zdCBNb3JwaEFycmF5ID0gUG9pbnRBcnJheVxyXG5cclxuLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB4LWF4aXNcclxuZXhwb3J0IGZ1bmN0aW9uIHggKHgpIHtcclxuICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KVxyXG59XHJcblxyXG4vLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHktYXhpc1xyXG5leHBvcnQgZnVuY3Rpb24geSAoeSkge1xyXG4gIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmJib3goKS55IDogdGhpcy5tb3ZlKHRoaXMuYmJveCgpLngsIHkpXHJcbn1cclxuXHJcbi8vIFNldCB3aWR0aCBvZiBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiB3aWR0aCAod2lkdGgpIHtcclxuICBjb25zdCBiID0gdGhpcy5iYm94KClcclxuICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IGIud2lkdGggOiB0aGlzLnNpemUod2lkdGgsIGIuaGVpZ2h0KVxyXG59XHJcblxyXG4vLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIGhlaWdodCAoaGVpZ2h0KSB7XHJcbiAgY29uc3QgYiA9IHRoaXMuYmJveCgpXHJcbiAgcmV0dXJuIGhlaWdodCA9PSBudWxsID8gYi5oZWlnaHQgOiB0aGlzLnNpemUoYi53aWR0aCwgaGVpZ2h0KVxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgZXh0ZW5kLFxyXG4gIG5vZGVPck5ldyxcclxuICByZWdpc3RlcixcclxuICB3cmFwV2l0aEF0dHJDaGVja1xyXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHByb3BvcnRpb25hbFNpemUgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcclxuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXHJcbmltcG9ydCAqIGFzIHBvaW50ZWQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3BvaW50ZWQuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lIGV4dGVuZHMgU2hhcGUge1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ2xpbmUnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIC8vIEdldCBhcnJheVxyXG4gIGFycmF5ICgpIHtcclxuICAgIHJldHVybiBuZXcgUG9pbnRBcnJheShbXHJcbiAgICAgIFsgdGhpcy5hdHRyKCd4MScpLCB0aGlzLmF0dHIoJ3kxJykgXSxcclxuICAgICAgWyB0aGlzLmF0dHIoJ3gyJyksIHRoaXMuYXR0cigneTInKSBdXHJcbiAgICBdKVxyXG4gIH1cclxuXHJcbiAgLy8gT3ZlcndyaXRlIG5hdGl2ZSBwbG90KCkgbWV0aG9kXHJcbiAgcGxvdCAoeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgIGlmICh4MSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFycmF5KClcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHkxICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB4MSA9IHsgeDE6IHgxLCB5MTogeTEsIHgyOiB4MiwgeTI6IHkyIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHgxID0gbmV3IFBvaW50QXJyYXkoeDEpLnRvTGluZSgpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cih4MSlcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXHJcbiAgbW92ZSAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkubW92ZSh4LCB5KS50b0xpbmUoKSlcclxuICB9XHJcblxyXG4gIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxyXG4gIHNpemUgKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkudG9MaW5lKCkpXHJcbiAgfVxyXG59XHJcblxyXG5leHRlbmQoTGluZSwgcG9pbnRlZClcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgYSBsaW5lIGVsZW1lbnRcclxuICAgIGxpbmU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxyXG4gICAgICAvLyB4MSBpcyBub3QgbmVjZXNzYXJpbHkgYSBudW1iZXIsIGl0IGNhbiBhbHNvIGJlIGFuIGFycmF5LCBhIHN0cmluZyBhbmQgYSBQb2ludEFycmF5XHJcbiAgICAgIHJldHVybiBMaW5lLnByb3RvdHlwZS5wbG90LmFwcGx5KFxyXG4gICAgICAgIHRoaXMucHV0KG5ldyBMaW5lKCkpXHJcbiAgICAgICAgLCBhcmdzWzBdICE9IG51bGwgPyBhcmdzIDogWyAwLCAwLCAwLCAwIF1cclxuICAgICAgKVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihMaW5lLCAnTGluZScpXHJcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcmtlciBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnbWFya2VyJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxyXG4gIHdpZHRoICh3aWR0aCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignbWFya2VyV2lkdGgnLCB3aWR0aClcclxuICB9XHJcblxyXG4gIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxyXG4gIGhlaWdodCAoaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXJrZXJIZWlnaHQnLCBoZWlnaHQpXHJcbiAgfVxyXG5cclxuICAvLyBTZXQgbWFya2VyIHJlZlggYW5kIHJlZllcclxuICByZWYgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3JlZlgnLCB4KS5hdHRyKCdyZWZZJywgeSlcclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSBtYXJrZXJcclxuICB1cGRhdGUgKGJsb2NrKSB7XHJcbiAgICAvLyByZW1vdmUgYWxsIGNvbnRlbnRcclxuICAgIHRoaXMuY2xlYXIoKVxyXG5cclxuICAgIC8vIGludm9rZSBwYXNzZWQgYmxvY2tcclxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcclxuICB0b1N0cmluZyAoKSB7XHJcbiAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJ1xyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIG1hcmtlciAoLi4uYXJncykge1xyXG4gICAgICAvLyBDcmVhdGUgbWFya2VyIGVsZW1lbnQgaW4gZGVmc1xyXG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkubWFya2VyKC4uLmFyZ3MpXHJcbiAgICB9XHJcbiAgfSxcclxuICBEZWZzOiB7XHJcbiAgICAvLyBDcmVhdGUgbWFya2VyXHJcbiAgICBtYXJrZXI6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xyXG4gICAgICAvLyBTZXQgZGVmYXVsdCB2aWV3Ym94IHRvIG1hdGNoIHRoZSB3aWR0aCBhbmQgaGVpZ2h0LCBzZXQgcmVmIHRvIGN4IGFuZCBjeSBhbmQgc2V0IG9yaWVudCB0byBhdXRvXHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgTWFya2VyKCkpXHJcbiAgICAgICAgLnNpemUod2lkdGgsIGhlaWdodClcclxuICAgICAgICAucmVmKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMilcclxuICAgICAgICAudmlld2JveCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXHJcbiAgICAgICAgLnVwZGF0ZShibG9jaylcclxuICAgIH0pXHJcbiAgfSxcclxuICBtYXJrZXI6IHtcclxuICAgIC8vIENyZWF0ZSBhbmQgYXR0YWNoIG1hcmtlcnNcclxuICAgIG1hcmtlciAobWFya2VyLCB3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xyXG4gICAgICB2YXIgYXR0ciA9IFsgJ21hcmtlcicgXVxyXG5cclxuICAgICAgLy8gQnVpbGQgYXR0cmlidXRlIG5hbWVcclxuICAgICAgaWYgKG1hcmtlciAhPT0gJ2FsbCcpIGF0dHIucHVzaChtYXJrZXIpXHJcbiAgICAgIGF0dHIgPSBhdHRyLmpvaW4oJy0nKVxyXG5cclxuICAgICAgLy8gU2V0IG1hcmtlciBhdHRyaWJ1dGVcclxuICAgICAgbWFya2VyID0gYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgTWFya2VyXHJcbiAgICAgICAgPyBhcmd1bWVudHNbMV1cclxuICAgICAgICA6IHRoaXMuZGVmcygpLm1hcmtlcih3aWR0aCwgaGVpZ2h0LCBibG9jaylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoYXR0ciwgbWFya2VyKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKE1hcmtlciwgJ01hcmtlcicpXHJcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBzbG9wcHlBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJyk7XG5cbnZhciBuYXRpdmVTb3J0ID0gW10uc29ydDtcbnZhciB0ZXN0ID0gWzEsIDIsIDNdO1xuXG4vLyBJRTgtXG52YXIgRkFJTFNfT05fVU5ERUZJTkVEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pO1xuLy8gVjggYnVnXG52YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KG51bGwpO1xufSk7XG4vLyBPbGQgV2ViS2l0XG52YXIgU0xPUFBZX01FVEhPRCA9IHNsb3BweUFycmF5TWV0aG9kKCdzb3J0Jyk7XG5cbnZhciBGT1JDRUQgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgU0xPUFBZX01FVEhPRDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb3J0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyBuYXRpdmVTb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6IG5hdGl2ZVNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcbiIsImltcG9ydCB7IHRpbWVsaW5lIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2RlZmF1bHRzLmpzJ1xyXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5cclxuLyoqKlxyXG5CYXNlIENsYXNzXHJcbj09PT09PT09PT1cclxuVGhlIGJhc2Ugc3RlcHBlciBjbGFzcyB0aGF0IHdpbGwgYmVcclxuKioqL1xyXG5cclxuZnVuY3Rpb24gbWFrZVNldHRlckdldHRlciAoaywgZikge1xyXG4gIHJldHVybiBmdW5jdGlvbiAodikge1xyXG4gICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRoaXNbdl1cclxuICAgIHRoaXNba10gPSB2XHJcbiAgICBpZiAoZikgZi5jYWxsKHRoaXMpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGVhc2luZyA9IHtcclxuICAnLSc6IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgIHJldHVybiBwb3NcclxuICB9LFxyXG4gICc8Pic6IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgIHJldHVybiAtTWF0aC5jb3MocG9zICogTWF0aC5QSSkgLyAyICsgMC41XHJcbiAgfSxcclxuICAnPic6IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgIHJldHVybiBNYXRoLnNpbihwb3MgKiBNYXRoLlBJIC8gMilcclxuICB9LFxyXG4gICc8JzogZnVuY3Rpb24gKHBvcykge1xyXG4gICAgcmV0dXJuIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJIC8gMikgKyAxXHJcbiAgfSxcclxuICBiZXppZXI6IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtZWFzaW5nLTEvI2N1YmljLWJlemllci1hbGdvXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgaWYgKHQgPCAwKSB7XHJcbiAgICAgICAgaWYgKHgxID4gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHkxIC8geDEgKiB0XHJcbiAgICAgICAgfSBlbHNlIGlmICh4MiA+IDApIHtcclxuICAgICAgICAgIHJldHVybiB5MiAvIHgyICogdFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0ID4gMSkge1xyXG4gICAgICAgIGlmICh4MiA8IDEpIHtcclxuICAgICAgICAgIHJldHVybiAoMSAtIHkyKSAvICgxIC0geDIpICogdCArICh5MiAtIHgyKSAvICgxIC0geDIpXHJcbiAgICAgICAgfSBlbHNlIGlmICh4MSA8IDEpIHtcclxuICAgICAgICAgIHJldHVybiAoMSAtIHkxKSAvICgxIC0geDEpICogdCArICh5MSAtIHgxKSAvICgxIC0geDEpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiAxXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiogMiAqIHkxICsgMyAqIHQgKiogMiAqICgxIC0gdCkgKiB5MiArIHQgKiogM1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1lYXNpbmctMS8jc3RlcC10aW1pbmctZnVuY3Rpb24tYWxnb1xyXG4gIHN0ZXBzOiBmdW5jdGlvbiAoc3RlcHMsIHN0ZXBQb3NpdGlvbiA9ICdlbmQnKSB7XHJcbiAgICAvLyBkZWFsIHdpdGggXCJqdW1wLVwiIHByZWZpeFxyXG4gICAgc3RlcFBvc2l0aW9uID0gc3RlcFBvc2l0aW9uLnNwbGl0KCctJykucmV2ZXJzZSgpWzBdXHJcblxyXG4gICAgbGV0IGp1bXBzID0gc3RlcHNcclxuICAgIGlmIChzdGVwUG9zaXRpb24gPT09ICdub25lJykge1xyXG4gICAgICAtLWp1bXBzXHJcbiAgICB9IGVsc2UgaWYgKHN0ZXBQb3NpdGlvbiA9PT0gJ2JvdGgnKSB7XHJcbiAgICAgICsranVtcHNcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgYmVmb3JlRmxhZyBpcyBlc3NlbnRpYWxseSB1c2VsZXNzXHJcbiAgICByZXR1cm4gKHQsIGJlZm9yZUZsYWcgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAvLyBTdGVwIGlzIGNhbGxlZCBjdXJyZW50U3RlcCBpbiByZWZlcmVuY2VkIHVybFxyXG4gICAgICBsZXQgc3RlcCA9IE1hdGguZmxvb3IodCAqIHN0ZXBzKVxyXG4gICAgICBjb25zdCBqdW1waW5nID0gKHQgKiBzdGVwKSAlIDEgPT09IDBcclxuXHJcbiAgICAgIGlmIChzdGVwUG9zaXRpb24gPT09ICdzdGFydCcgfHwgc3RlcFBvc2l0aW9uID09PSAnYm90aCcpIHtcclxuICAgICAgICArK3N0ZXBcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJlZm9yZUZsYWcgJiYganVtcGluZykge1xyXG4gICAgICAgIC0tc3RlcFxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodCA+PSAwICYmIHN0ZXAgPCAwKSB7XHJcbiAgICAgICAgc3RlcCA9IDBcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHQgPD0gMSAmJiBzdGVwID4ganVtcHMpIHtcclxuICAgICAgICBzdGVwID0ganVtcHNcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0ZXAgLyBqdW1wc1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFN0ZXBwZXIge1xyXG4gIGRvbmUgKCkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG59XHJcblxyXG4vKioqXHJcbkVhc2luZyBGdW5jdGlvbnNcclxuPT09PT09PT09PT09PT09PVxyXG4qKiovXHJcblxyXG5leHBvcnQgY2xhc3MgRWFzZSBleHRlbmRzIFN0ZXBwZXIge1xyXG4gIGNvbnN0cnVjdG9yIChmbikge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgdGhpcy5lYXNlID0gZWFzaW5nW2ZuIHx8IHRpbWVsaW5lLmVhc2VdIHx8IGZuXHJcbiAgfVxyXG5cclxuICBzdGVwIChmcm9tLCB0bywgcG9zKSB7XHJcbiAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInKSB7XHJcbiAgICAgIHJldHVybiBwb3MgPCAxID8gZnJvbSA6IHRvXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogdGhpcy5lYXNlKHBvcylcclxuICB9XHJcbn1cclxuXHJcbi8qKipcclxuQ29udHJvbGxlciBUeXBlc1xyXG49PT09PT09PT09PT09PT09XHJcbioqKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBDb250cm9sbGVyIGV4dGVuZHMgU3RlcHBlciB7XHJcbiAgY29uc3RydWN0b3IgKGZuKSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLnN0ZXBwZXIgPSBmblxyXG4gIH1cclxuXHJcbiAgc3RlcCAoY3VycmVudCwgdGFyZ2V0LCBkdCwgYykge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RlcHBlcihjdXJyZW50LCB0YXJnZXQsIGR0LCBjKVxyXG4gIH1cclxuXHJcbiAgZG9uZSAoYykge1xyXG4gICAgcmV0dXJuIGMuZG9uZVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVjYWxjdWxhdGUgKCkge1xyXG4gIC8vIEFwcGx5IHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcclxuICB2YXIgZHVyYXRpb24gPSAodGhpcy5fZHVyYXRpb24gfHwgNTAwKSAvIDEwMDBcclxuICB2YXIgb3ZlcnNob290ID0gdGhpcy5fb3ZlcnNob290IHx8IDBcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSBQSUQgbmF0dXJhbCByZXNwb25zZVxyXG4gIHZhciBlcHMgPSAxZS0xMFxyXG4gIHZhciBwaSA9IE1hdGguUElcclxuICB2YXIgb3MgPSBNYXRoLmxvZyhvdmVyc2hvb3QgLyAxMDAgKyBlcHMpXHJcbiAgdmFyIHpldGEgPSAtb3MgLyBNYXRoLnNxcnQocGkgKiBwaSArIG9zICogb3MpXHJcbiAgdmFyIHduID0gMy45IC8gKHpldGEgKiBkdXJhdGlvbilcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSBTcHJpbmcgdmFsdWVzXHJcbiAgdGhpcy5kID0gMiAqIHpldGEgKiB3blxyXG4gIHRoaXMuayA9IHduICogd25cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNwcmluZyBleHRlbmRzIENvbnRyb2xsZXIge1xyXG4gIGNvbnN0cnVjdG9yIChkdXJhdGlvbiwgb3ZlcnNob290KSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLmR1cmF0aW9uKGR1cmF0aW9uIHx8IDUwMClcclxuICAgICAgLm92ZXJzaG9vdChvdmVyc2hvb3QgfHwgMClcclxuICB9XHJcblxyXG4gIHN0ZXAgKGN1cnJlbnQsIHRhcmdldCwgZHQsIGMpIHtcclxuICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ3N0cmluZycpIHJldHVybiBjdXJyZW50XHJcbiAgICBjLmRvbmUgPSBkdCA9PT0gSW5maW5pdHlcclxuICAgIGlmIChkdCA9PT0gSW5maW5pdHkpIHJldHVybiB0YXJnZXRcclxuICAgIGlmIChkdCA9PT0gMCkgcmV0dXJuIGN1cnJlbnRcclxuXHJcbiAgICBpZiAoZHQgPiAxMDApIGR0ID0gMTZcclxuXHJcbiAgICBkdCAvPSAxMDAwXHJcblxyXG4gICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2ZWxvY2l0eVxyXG4gICAgdmFyIHZlbG9jaXR5ID0gYy52ZWxvY2l0eSB8fCAwXHJcblxyXG4gICAgLy8gQXBwbHkgdGhlIGNvbnRyb2wgdG8gZ2V0IHRoZSBuZXcgcG9zaXRpb24gYW5kIHN0b3JlIGl0XHJcbiAgICB2YXIgYWNjZWxlcmF0aW9uID0gLXRoaXMuZCAqIHZlbG9jaXR5IC0gdGhpcy5rICogKGN1cnJlbnQgLSB0YXJnZXQpXHJcbiAgICB2YXIgbmV3UG9zaXRpb24gPSBjdXJyZW50XHJcbiAgICAgICsgdmVsb2NpdHkgKiBkdFxyXG4gICAgICArIGFjY2VsZXJhdGlvbiAqIGR0ICogZHQgLyAyXHJcblxyXG4gICAgLy8gU3RvcmUgdGhlIHZlbG9jaXR5XHJcbiAgICBjLnZlbG9jaXR5ID0gdmVsb2NpdHkgKyBhY2NlbGVyYXRpb24gKiBkdFxyXG5cclxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgaGF2ZSBjb252ZXJnZWQsIGFuZCBpZiBzbywgcGFzcyB0aGUgdmFsdWVcclxuICAgIGMuZG9uZSA9IE1hdGguYWJzKHRhcmdldCAtIG5ld1Bvc2l0aW9uKSArIE1hdGguYWJzKHZlbG9jaXR5KSA8IDAuMDAyXHJcbiAgICByZXR1cm4gYy5kb25lID8gdGFyZ2V0IDogbmV3UG9zaXRpb25cclxuICB9XHJcbn1cclxuXHJcbmV4dGVuZChTcHJpbmcsIHtcclxuICBkdXJhdGlvbjogbWFrZVNldHRlckdldHRlcignX2R1cmF0aW9uJywgcmVjYWxjdWxhdGUpLFxyXG4gIG92ZXJzaG9vdDogbWFrZVNldHRlckdldHRlcignX292ZXJzaG9vdCcsIHJlY2FsY3VsYXRlKVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFBJRCBleHRlbmRzIENvbnRyb2xsZXIge1xyXG4gIGNvbnN0cnVjdG9yIChwLCBpLCBkLCB3aW5kdXApIHtcclxuICAgIHN1cGVyKClcclxuXHJcbiAgICBwID0gcCA9PSBudWxsID8gMC4xIDogcFxyXG4gICAgaSA9IGkgPT0gbnVsbCA/IDAuMDEgOiBpXHJcbiAgICBkID0gZCA9PSBudWxsID8gMCA6IGRcclxuICAgIHdpbmR1cCA9IHdpbmR1cCA9PSBudWxsID8gMTAwMCA6IHdpbmR1cFxyXG4gICAgdGhpcy5wKHApLmkoaSkuZChkKS53aW5kdXAod2luZHVwKVxyXG4gIH1cclxuXHJcbiAgc3RlcCAoY3VycmVudCwgdGFyZ2V0LCBkdCwgYykge1xyXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIGN1cnJlbnRcclxuICAgIGMuZG9uZSA9IGR0ID09PSBJbmZpbml0eVxyXG5cclxuICAgIGlmIChkdCA9PT0gSW5maW5pdHkpIHJldHVybiB0YXJnZXRcclxuICAgIGlmIChkdCA9PT0gMCkgcmV0dXJuIGN1cnJlbnRcclxuXHJcbiAgICB2YXIgcCA9IHRhcmdldCAtIGN1cnJlbnRcclxuICAgIHZhciBpID0gKGMuaW50ZWdyYWwgfHwgMCkgKyBwICogZHRcclxuICAgIHZhciBkID0gKHAgLSAoYy5lcnJvciB8fCAwKSkgLyBkdFxyXG4gICAgdmFyIHdpbmR1cCA9IHRoaXMud2luZHVwXHJcblxyXG4gICAgLy8gYW50aXdpbmR1cFxyXG4gICAgaWYgKHdpbmR1cCAhPT0gZmFsc2UpIHtcclxuICAgICAgaSA9IE1hdGgubWF4KC13aW5kdXAsIE1hdGgubWluKGksIHdpbmR1cCkpXHJcbiAgICB9XHJcblxyXG4gICAgYy5lcnJvciA9IHBcclxuICAgIGMuaW50ZWdyYWwgPSBpXHJcblxyXG4gICAgYy5kb25lID0gTWF0aC5hYnMocCkgPCAwLjAwMVxyXG5cclxuICAgIHJldHVybiBjLmRvbmUgPyB0YXJnZXQgOiBjdXJyZW50ICsgKHRoaXMuUCAqIHAgKyB0aGlzLkkgKiBpICsgdGhpcy5EICogZClcclxuICB9XHJcbn1cclxuXHJcbmV4dGVuZChQSUQsIHtcclxuICB3aW5kdXA6IG1ha2VTZXR0ZXJHZXR0ZXIoJ3dpbmR1cCcpLFxyXG4gIHA6IG1ha2VTZXR0ZXJHZXR0ZXIoJ1AnKSxcclxuICBpOiBtYWtlU2V0dGVyR2V0dGVyKCdJJyksXHJcbiAgZDogbWFrZVNldHRlckdldHRlcignRCcpXHJcbn0pXHJcbiIsImltcG9ydCB7XHJcbiAgZGVsaW1pdGVyLFxyXG4gIGRvdHMsXHJcbiAgaHlwaGVuLFxyXG4gIGlzUGF0aExldHRlcixcclxuICBudW1iZXJzV2l0aERvdHMsXHJcbiAgcGF0aExldHRlcnNcclxufSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXHJcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHN1YkNsYXNzQXJyYXkgfSBmcm9tICcuL0FycmF5UG9seWZpbGwuanMnXHJcbmltcG9ydCBQb2ludCBmcm9tICcuL1BvaW50LmpzJ1xyXG5pbXBvcnQgU1ZHQXJyYXkgZnJvbSAnLi9TVkdBcnJheS5qcydcclxuaW1wb3J0IHBhcnNlciBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcGFyc2VyLmpzJ1xyXG5cclxuY29uc3QgUGF0aEFycmF5ID0gc3ViQ2xhc3NBcnJheSgnUGF0aEFycmF5JywgU1ZHQXJyYXkpXHJcblxyXG5leHBvcnQgZGVmYXVsdCBQYXRoQXJyYXlcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXRoUmVnUmVwbGFjZSAoYSwgYiwgYywgZCkge1xyXG4gIHJldHVybiBjICsgZC5yZXBsYWNlKGRvdHMsICcgLicpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFycmF5VG9TdHJpbmcgKGEpIHtcclxuICBmb3IgKHZhciBpID0gMCwgaWwgPSBhLmxlbmd0aCwgcyA9ICcnOyBpIDwgaWw7IGkrKykge1xyXG4gICAgcyArPSBhW2ldWzBdXHJcblxyXG4gICAgaWYgKGFbaV1bMV0gIT0gbnVsbCkge1xyXG4gICAgICBzICs9IGFbaV1bMV1cclxuXHJcbiAgICAgIGlmIChhW2ldWzJdICE9IG51bGwpIHtcclxuICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgIHMgKz0gYVtpXVsyXVxyXG5cclxuICAgICAgICBpZiAoYVtpXVszXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgICAgcyArPSBhW2ldWzNdXHJcbiAgICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgICAgcyArPSBhW2ldWzRdXHJcblxyXG4gICAgICAgICAgaWYgKGFbaV1bNV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgICAgICBzICs9IGFbaV1bNV1cclxuICAgICAgICAgICAgcyArPSAnICdcclxuICAgICAgICAgICAgcyArPSBhW2ldWzZdXHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXVs3XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgcyArPSAnICdcclxuICAgICAgICAgICAgICBzICs9IGFbaV1bN11cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHMgKyAnICdcclxufVxyXG5cclxuY29uc3QgcGF0aEhhbmRsZXJzID0ge1xyXG4gIE06IGZ1bmN0aW9uIChjLCBwLCBwMCkge1xyXG4gICAgcC54ID0gcDAueCA9IGNbMF1cclxuICAgIHAueSA9IHAwLnkgPSBjWzFdXHJcblxyXG4gICAgcmV0dXJuIFsgJ00nLCBwLngsIHAueSBdXHJcbiAgfSxcclxuICBMOiBmdW5jdGlvbiAoYywgcCkge1xyXG4gICAgcC54ID0gY1swXVxyXG4gICAgcC55ID0gY1sxXVxyXG4gICAgcmV0dXJuIFsgJ0wnLCBjWzBdLCBjWzFdIF1cclxuICB9LFxyXG4gIEg6IGZ1bmN0aW9uIChjLCBwKSB7XHJcbiAgICBwLnggPSBjWzBdXHJcbiAgICByZXR1cm4gWyAnSCcsIGNbMF0gXVxyXG4gIH0sXHJcbiAgVjogZnVuY3Rpb24gKGMsIHApIHtcclxuICAgIHAueSA9IGNbMF1cclxuICAgIHJldHVybiBbICdWJywgY1swXSBdXHJcbiAgfSxcclxuICBDOiBmdW5jdGlvbiAoYywgcCkge1xyXG4gICAgcC54ID0gY1s0XVxyXG4gICAgcC55ID0gY1s1XVxyXG4gICAgcmV0dXJuIFsgJ0MnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdLCBjWzRdLCBjWzVdIF1cclxuICB9LFxyXG4gIFM6IGZ1bmN0aW9uIChjLCBwKSB7XHJcbiAgICBwLnggPSBjWzJdXHJcbiAgICBwLnkgPSBjWzNdXHJcbiAgICByZXR1cm4gWyAnUycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM10gXVxyXG4gIH0sXHJcbiAgUTogZnVuY3Rpb24gKGMsIHApIHtcclxuICAgIHAueCA9IGNbMl1cclxuICAgIHAueSA9IGNbM11cclxuICAgIHJldHVybiBbICdRJywgY1swXSwgY1sxXSwgY1syXSwgY1szXSBdXHJcbiAgfSxcclxuICBUOiBmdW5jdGlvbiAoYywgcCkge1xyXG4gICAgcC54ID0gY1swXVxyXG4gICAgcC55ID0gY1sxXVxyXG4gICAgcmV0dXJuIFsgJ1QnLCBjWzBdLCBjWzFdIF1cclxuICB9LFxyXG4gIFo6IGZ1bmN0aW9uIChjLCBwLCBwMCkge1xyXG4gICAgcC54ID0gcDAueFxyXG4gICAgcC55ID0gcDAueVxyXG4gICAgcmV0dXJuIFsgJ1onIF1cclxuICB9LFxyXG4gIEE6IGZ1bmN0aW9uIChjLCBwKSB7XHJcbiAgICBwLnggPSBjWzVdXHJcbiAgICBwLnkgPSBjWzZdXHJcbiAgICByZXR1cm4gWyAnQScsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl0gXVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgbWxodnF0Y3NheiA9ICdtbGh2cXRjc2F6Jy5zcGxpdCgnJylcclxuXHJcbmZvciAodmFyIGkgPSAwLCBpbCA9IG1saHZxdGNzYXoubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gIHBhdGhIYW5kbGVyc1ttbGh2cXRjc2F6W2ldXSA9IChmdW5jdGlvbiAoaSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjLCBwLCBwMCkge1xyXG4gICAgICBpZiAoaSA9PT0gJ0gnKSBjWzBdID0gY1swXSArIHAueFxyXG4gICAgICBlbHNlIGlmIChpID09PSAnVicpIGNbMF0gPSBjWzBdICsgcC55XHJcbiAgICAgIGVsc2UgaWYgKGkgPT09ICdBJykge1xyXG4gICAgICAgIGNbNV0gPSBjWzVdICsgcC54XHJcbiAgICAgICAgY1s2XSA9IGNbNl0gKyBwLnlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSBjLmxlbmd0aDsgaiA8IGpsOyArK2opIHtcclxuICAgICAgICAgIGNbal0gPSBjW2pdICsgKGogJSAyID8gcC55IDogcC54KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHBhdGhIYW5kbGVyc1tpXShjLCBwLCBwMClcclxuICAgIH1cclxuICB9KShtbGh2cXRjc2F6W2ldLnRvVXBwZXJDYXNlKCkpXHJcbn1cclxuXHJcbmV4dGVuZChQYXRoQXJyYXksIHtcclxuICAvLyBDb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiBhcnJheVRvU3RyaW5nKHRoaXMpXHJcbiAgfSxcclxuXHJcbiAgLy8gTW92ZSBwYXRoIHN0cmluZ1xyXG4gIG1vdmUgKHgsIHkpIHtcclxuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cclxuICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgIC8vIGdldCByZWxhdGl2ZSBvZmZzZXRcclxuICAgIHggLT0gYm94LnhcclxuICAgIHkgLT0gYm94LnlcclxuXHJcbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xyXG4gICAgICAvLyBtb3ZlIGV2ZXJ5IHBvaW50XHJcbiAgICAgIGZvciAodmFyIGwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbCA9IHRoaXNbaV1bMF1cclxuXHJcbiAgICAgICAgaWYgKGwgPT09ICdNJyB8fCBsID09PSAnTCcgfHwgbCA9PT0gJ1QnKSB7XHJcbiAgICAgICAgICB0aGlzW2ldWzFdICs9IHhcclxuICAgICAgICAgIHRoaXNbaV1bMl0gKz0geVxyXG4gICAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0gnKSB7XHJcbiAgICAgICAgICB0aGlzW2ldWzFdICs9IHhcclxuICAgICAgICB9IGVsc2UgaWYgKGwgPT09ICdWJykge1xyXG4gICAgICAgICAgdGhpc1tpXVsxXSArPSB5XHJcbiAgICAgICAgfSBlbHNlIGlmIChsID09PSAnQycgfHwgbCA9PT0gJ1MnIHx8IGwgPT09ICdRJykge1xyXG4gICAgICAgICAgdGhpc1tpXVsxXSArPSB4XHJcbiAgICAgICAgICB0aGlzW2ldWzJdICs9IHlcclxuICAgICAgICAgIHRoaXNbaV1bM10gKz0geFxyXG4gICAgICAgICAgdGhpc1tpXVs0XSArPSB5XHJcblxyXG4gICAgICAgICAgaWYgKGwgPT09ICdDJykge1xyXG4gICAgICAgICAgICB0aGlzW2ldWzVdICs9IHhcclxuICAgICAgICAgICAgdGhpc1tpXVs2XSArPSB5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChsID09PSAnQScpIHtcclxuICAgICAgICAgIHRoaXNbaV1bNl0gKz0geFxyXG4gICAgICAgICAgdGhpc1tpXVs3XSArPSB5XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICAvLyBSZXNpemUgcGF0aCBzdHJpbmdcclxuICBzaXplICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAvLyBnZXQgYm91bmRpbmcgYm94IG9mIGN1cnJlbnQgc2l0dWF0aW9uXHJcbiAgICB2YXIgYm94ID0gdGhpcy5iYm94KClcclxuICAgIHZhciBpLCBsXHJcblxyXG4gICAgLy8gSWYgdGhlIGJveCB3aWR0aCBvciBoZWlnaHQgaXMgMCB0aGVuIHdlIGlnbm9yZVxyXG4gICAgLy8gdHJhbnNmb3JtYXRpb25zIG9uIHRoZSByZXNwZWN0aXZlIGF4aXNcclxuICAgIGJveC53aWR0aCA9IGJveC53aWR0aCA9PT0gMCA/IDEgOiBib3gud2lkdGhcclxuICAgIGJveC5oZWlnaHQgPSBib3guaGVpZ2h0ID09PSAwID8gMSA6IGJveC5oZWlnaHRcclxuXHJcbiAgICAvLyByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiBhbGwgcG9pbnRzIGFjY29yZGluZyB0byBuZXcgc2l6ZVxyXG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBsID0gdGhpc1tpXVswXVxyXG5cclxuICAgICAgaWYgKGwgPT09ICdNJyB8fCBsID09PSAnTCcgfHwgbCA9PT0gJ1QnKSB7XHJcbiAgICAgICAgdGhpc1tpXVsxXSA9ICgodGhpc1tpXVsxXSAtIGJveC54KSAqIHdpZHRoKSAvIGJveC53aWR0aCArIGJveC54XHJcbiAgICAgICAgdGhpc1tpXVsyXSA9ICgodGhpc1tpXVsyXSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgICAgfSBlbHNlIGlmIChsID09PSAnSCcpIHtcclxuICAgICAgICB0aGlzW2ldWzFdID0gKCh0aGlzW2ldWzFdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcclxuICAgICAgfSBlbHNlIGlmIChsID09PSAnVicpIHtcclxuICAgICAgICB0aGlzW2ldWzFdID0gKCh0aGlzW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG4gICAgICB9IGVsc2UgaWYgKGwgPT09ICdDJyB8fCBsID09PSAnUycgfHwgbCA9PT0gJ1EnKSB7XHJcbiAgICAgICAgdGhpc1tpXVsxXSA9ICgodGhpc1tpXVsxXSAtIGJveC54KSAqIHdpZHRoKSAvIGJveC53aWR0aCArIGJveC54XHJcbiAgICAgICAgdGhpc1tpXVsyXSA9ICgodGhpc1tpXVsyXSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgICAgICB0aGlzW2ldWzNdID0gKCh0aGlzW2ldWzNdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcclxuICAgICAgICB0aGlzW2ldWzRdID0gKCh0aGlzW2ldWzRdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG5cclxuICAgICAgICBpZiAobCA9PT0gJ0MnKSB7XHJcbiAgICAgICAgICB0aGlzW2ldWzVdID0gKCh0aGlzW2ldWzVdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcclxuICAgICAgICAgIHRoaXNbaV1bNl0gPSAoKHRoaXNbaV1bNl0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGwgPT09ICdBJykge1xyXG4gICAgICAgIC8vIHJlc2l6ZSByYWRpaVxyXG4gICAgICAgIHRoaXNbaV1bMV0gPSAodGhpc1tpXVsxXSAqIHdpZHRoKSAvIGJveC53aWR0aFxyXG4gICAgICAgIHRoaXNbaV1bMl0gPSAodGhpc1tpXVsyXSAqIGhlaWdodCkgLyBib3guaGVpZ2h0XHJcblxyXG4gICAgICAgIC8vIG1vdmUgcG9zaXRpb24gdmFsdWVzXHJcbiAgICAgICAgdGhpc1tpXVs2XSA9ICgodGhpc1tpXVs2XSAtIGJveC54KSAqIHdpZHRoKSAvIGJveC53aWR0aCArIGJveC54XHJcbiAgICAgICAgdGhpc1tpXVs3XSA9ICgodGhpc1tpXVs3XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfSxcclxuXHJcbiAgLy8gVGVzdCBpZiB0aGUgcGFzc2VkIHBhdGggYXJyYXkgdXNlIHRoZSBzYW1lIHBhdGggZGF0YSBjb21tYW5kcyBhcyB0aGlzIHBhdGggYXJyYXlcclxuICBlcXVhbENvbW1hbmRzIChwYXRoQXJyYXkpIHtcclxuICAgIHZhciBpLCBpbCwgZXF1YWxDb21tYW5kc1xyXG5cclxuICAgIHBhdGhBcnJheSA9IG5ldyBQYXRoQXJyYXkocGF0aEFycmF5KVxyXG5cclxuICAgIGVxdWFsQ29tbWFuZHMgPSB0aGlzLmxlbmd0aCA9PT0gcGF0aEFycmF5Lmxlbmd0aFxyXG4gICAgZm9yIChpID0gMCwgaWwgPSB0aGlzLmxlbmd0aDsgZXF1YWxDb21tYW5kcyAmJiBpIDwgaWw7IGkrKykge1xyXG4gICAgICBlcXVhbENvbW1hbmRzID0gdGhpc1tpXVswXSA9PT0gcGF0aEFycmF5W2ldWzBdXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVxdWFsQ29tbWFuZHNcclxuICB9LFxyXG5cclxuICAvLyBNYWtlIHBhdGggYXJyYXkgbW9ycGhhYmxlXHJcbiAgbW9ycGggKHBhdGhBcnJheSkge1xyXG4gICAgcGF0aEFycmF5ID0gbmV3IFBhdGhBcnJheShwYXRoQXJyYXkpXHJcblxyXG4gICAgaWYgKHRoaXMuZXF1YWxDb21tYW5kcyhwYXRoQXJyYXkpKSB7XHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBwYXRoQXJyYXlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICAvLyBHZXQgbW9ycGhlZCBwYXRoIGFycmF5IGF0IGdpdmVuIHBvc2l0aW9uXHJcbiAgYXQgKHBvcykge1xyXG4gICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxyXG4gICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIHZhciBzb3VyY2VBcnJheSA9IHRoaXNcclxuICAgIHZhciBkZXN0aW5hdGlvbkFycmF5ID0gdGhpcy5kZXN0aW5hdGlvbi52YWx1ZVxyXG4gICAgdmFyIGFycmF5ID0gW11cclxuICAgIHZhciBwYXRoQXJyYXkgPSBuZXcgUGF0aEFycmF5KClcclxuICAgIHZhciBpLCBpbCwgaiwgamxcclxuXHJcbiAgICAvLyBBbmltYXRlIGhhcyBzcGVjaWZpZWQgaW4gdGhlIFNWRyBzcGVjXHJcbiAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYXRocy5odG1sI1BhdGhFbGVtZW50XHJcbiAgICBmb3IgKGkgPSAwLCBpbCA9IHNvdXJjZUFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcclxuICAgICAgYXJyYXlbaV0gPSBbIHNvdXJjZUFycmF5W2ldWzBdIF1cclxuICAgICAgZm9yIChqID0gMSwgamwgPSBzb3VyY2VBcnJheVtpXS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XHJcbiAgICAgICAgYXJyYXlbaV1bal0gPSBzb3VyY2VBcnJheVtpXVtqXSArIChkZXN0aW5hdGlvbkFycmF5W2ldW2pdIC0gc291cmNlQXJyYXlbaV1bal0pICogcG9zXHJcbiAgICAgIH1cclxuICAgICAgLy8gRm9yIHRoZSB0d28gZmxhZ3Mgb2YgdGhlIGVsbGlwdGljYWwgYXJjIGNvbW1hbmQsIHRoZSBTVkcgc3BlYyBzYXk6XHJcbiAgICAgIC8vIEZsYWdzIGFuZCBib29sZWFucyBhcmUgaW50ZXJwb2xhdGVkIGFzIGZyYWN0aW9ucyBiZXR3ZWVuIHplcm8gYW5kIG9uZSwgd2l0aCBhbnkgbm9uLXplcm8gdmFsdWUgY29uc2lkZXJlZCB0byBiZSBhIHZhbHVlIG9mIG9uZS90cnVlXHJcbiAgICAgIC8vIEVsbGlwdGljYWwgYXJjIGNvbW1hbmQgYXMgYW4gYXJyYXkgZm9sbG93ZWQgYnkgY29ycmVzcG9uZGluZyBpbmRleGVzOlxyXG4gICAgICAvLyBbJ0EnLCByeCwgcnksIHgtYXhpcy1yb3RhdGlvbiwgbGFyZ2UtYXJjLWZsYWcsIHN3ZWVwLWZsYWcsIHgsIHldXHJcbiAgICAgIC8vICAgMCAgICAxICAgMiAgICAgICAgMyAgICAgICAgICAgICAgICAgNCAgICAgICAgICAgICA1ICAgICAgNiAgN1xyXG4gICAgICBpZiAoYXJyYXlbaV1bMF0gPT09ICdBJykge1xyXG4gICAgICAgIGFycmF5W2ldWzRdID0gKyhhcnJheVtpXVs0XSAhPT0gMClcclxuICAgICAgICBhcnJheVtpXVs1XSA9ICsoYXJyYXlbaV1bNV0gIT09IDApXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXJlY3RseSBtb2RpZnkgdGhlIHZhbHVlIG9mIGEgcGF0aCBhcnJheSwgdGhpcyBpcyBkb25lIHRoaXMgd2F5IGZvciBwZXJmb3JtYW5jZVxyXG4gICAgcGF0aEFycmF5LnZhbHVlID0gYXJyYXlcclxuICAgIHJldHVybiBwYXRoQXJyYXlcclxuICB9LFxyXG5cclxuICAvLyBBYnNvbHV0aXplIGFuZCBwYXJzZSBwYXRoIHRvIGFycmF5XHJcbiAgcGFyc2UgKGFycmF5ID0gWyBbICdNJywgMCwgMCBdIF0pIHtcclxuICAgIC8vIGlmIGl0J3MgYWxyZWFkeSBhIHBhdGhhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgUGF0aEFycmF5KSByZXR1cm4gYXJyYXlcclxuXHJcbiAgICAvLyBwcmVwYXJlIGZvciBwYXJzaW5nXHJcbiAgICB2YXIgc1xyXG4gICAgdmFyIHBhcmFtQ250ID0geyBNOiAyLCBMOiAyLCBIOiAxLCBWOiAxLCBDOiA2LCBTOiA0LCBROiA0LCBUOiAyLCBBOiA3LCBaOiAwIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGFycmF5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICBhcnJheSA9IGFycmF5XHJcbiAgICAgICAgLnJlcGxhY2UobnVtYmVyc1dpdGhEb3RzLCBwYXRoUmVnUmVwbGFjZSkgLy8gY29udmVydCA0NS4xMjMuMTIzIHRvIDQ1LjEyMyAuMTIzXHJcbiAgICAgICAgLnJlcGxhY2UocGF0aExldHRlcnMsICcgJCYgJykgLy8gcHV0IHNvbWUgcm9vbSBiZXR3ZWVuIGxldHRlcnMgYW5kIG51bWJlcnNcclxuICAgICAgICAucmVwbGFjZShoeXBoZW4sICckMSAtJykgLy8gYWRkIHNwYWNlIGJlZm9yZSBoeXBoZW5cclxuICAgICAgICAudHJpbSgpIC8vIHRyaW1cclxuICAgICAgICAuc3BsaXQoZGVsaW1pdGVyKSAvLyBzcGxpdCBpbnRvIGFycmF5XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhcnJheSA9IGFycmF5LnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuY2FsbChwcmV2LCBjdXJyKVxyXG4gICAgICB9LCBbXSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcnJheSBub3cgaXMgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgcGFydHMgb2YgYSBwYXRoIGUuZy4gWydNJywgJzAnLCAnMCcsICdMJywgJzMwJywgJzMwJyAuLi5dXHJcbiAgICB2YXIgcmVzdWx0ID0gW11cclxuICAgIHZhciBwID0gbmV3IFBvaW50KClcclxuICAgIHZhciBwMCA9IG5ldyBQb2ludCgpXHJcbiAgICB2YXIgaW5kZXggPSAwXHJcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoXHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAvLyBUZXN0IGlmIHdlIGhhdmUgYSBwYXRoIGxldHRlclxyXG4gICAgICBpZiAoaXNQYXRoTGV0dGVyLnRlc3QoYXJyYXlbaW5kZXhdKSkge1xyXG4gICAgICAgIHMgPSBhcnJheVtpbmRleF1cclxuICAgICAgICArK2luZGV4XHJcbiAgICAgICAgLy8gSWYgbGFzdCBsZXR0ZXIgd2FzIGEgbW92ZSBjb21tYW5kIGFuZCB3ZSBnb3Qgbm8gbmV3LCBpdCBkZWZhdWx0cyB0byBbTF1pbmVcclxuICAgICAgfSBlbHNlIGlmIChzID09PSAnTScpIHtcclxuICAgICAgICBzID0gJ0wnXHJcbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gJ20nKSB7XHJcbiAgICAgICAgcyA9ICdsJ1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXN1bHQucHVzaChwYXRoSGFuZGxlcnNbc10uY2FsbChudWxsLFxyXG4gICAgICAgIGFycmF5LnNsaWNlKGluZGV4LCAoaW5kZXggPSBpbmRleCArIHBhcmFtQ250W3MudG9VcHBlckNhc2UoKV0pKS5tYXAocGFyc2VGbG9hdCksXHJcbiAgICAgICAgcCwgcDBcclxuICAgICAgKVxyXG4gICAgICApXHJcbiAgICB9IHdoaWxlIChsZW4gPiBpbmRleClcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfSxcclxuXHJcbiAgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiBwYXRoXHJcbiAgYmJveCAoKSB7XHJcbiAgICBwYXJzZXIoKS5wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMudG9TdHJpbmcoKSlcclxuICAgIHJldHVybiBwYXJzZXIubm9kZXMucGF0aC5nZXRCQm94KClcclxuICB9XHJcbn0pXHJcbiIsImltcG9ydCB7IEVhc2UgfSBmcm9tICcuL0NvbnRyb2xsZXIuanMnXHJcbmltcG9ydCB7XHJcbiAgZGVsaW1pdGVyLFxyXG4gIG51bWJlckFuZFVuaXQsXHJcbiAgcGF0aExldHRlcnNcclxufSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXHJcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCBDb2xvciBmcm9tICcuLi90eXBlcy9Db2xvci5qcydcclxuaW1wb3J0IFBhdGhBcnJheSBmcm9tICcuLi90eXBlcy9QYXRoQXJyYXkuanMnXHJcbmltcG9ydCBTVkdBcnJheSBmcm9tICcuLi90eXBlcy9TVkdBcnJheS5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3JwaGFibGUge1xyXG4gIGNvbnN0cnVjdG9yIChzdGVwcGVyKSB7XHJcbiAgICB0aGlzLl9zdGVwcGVyID0gc3RlcHBlciB8fCBuZXcgRWFzZSgnLScpXHJcblxyXG4gICAgdGhpcy5fZnJvbSA9IG51bGxcclxuICAgIHRoaXMuX3RvID0gbnVsbFxyXG4gICAgdGhpcy5fdHlwZSA9IG51bGxcclxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsXHJcbiAgICB0aGlzLl9tb3JwaE9iaiA9IG51bGxcclxuICB9XHJcblxyXG4gIGZyb20gKHZhbCkge1xyXG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9mcm9tXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZnJvbSA9IHRoaXMuX3NldCh2YWwpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgdG8gKHZhbCkge1xyXG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl90b1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3RvID0gdGhpcy5fc2V0KHZhbClcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB0eXBlICh0eXBlKSB7XHJcbiAgICAvLyBnZXR0ZXJcclxuICAgIGlmICh0eXBlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3R5cGVcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXR0ZXJcclxuICAgIHRoaXMuX3R5cGUgPSB0eXBlXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgX3NldCAodmFsdWUpIHtcclxuICAgIGlmICghdGhpcy5fdHlwZSkge1xyXG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZVxyXG5cclxuICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdGhpcy50eXBlKFNWR051bWJlcilcclxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChDb2xvci5pc0NvbG9yKHZhbHVlKSkge1xyXG4gICAgICAgICAgdGhpcy50eXBlKENvbG9yKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVsaW1pdGVyLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgICB0aGlzLnR5cGUocGF0aExldHRlcnMudGVzdCh2YWx1ZSlcclxuICAgICAgICAgICAgPyBQYXRoQXJyYXlcclxuICAgICAgICAgICAgOiBTVkdBcnJheVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVyQW5kVW5pdC50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgdGhpcy50eXBlKFNWR051bWJlcilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy50eXBlKE5vbk1vcnBoYWJsZSlcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAobW9ycGhhYmxlVHlwZXMuaW5kZXhPZih2YWx1ZS5jb25zdHJ1Y3RvcikgPiAtMSkge1xyXG4gICAgICAgIHRoaXMudHlwZSh2YWx1ZS5jb25zdHJ1Y3RvcilcclxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHRoaXMudHlwZShTVkdBcnJheSlcclxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRoaXMudHlwZShPYmplY3RCYWcpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy50eXBlKE5vbk1vcnBoYWJsZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQgPSAobmV3IHRoaXMuX3R5cGUodmFsdWUpKVxyXG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IENvbG9yKSB7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuX3RvID8gcmVzdWx0W3RoaXMuX3RvWzRdXSgpXHJcbiAgICAgICAgOiB0aGlzLl9mcm9tID8gcmVzdWx0W3RoaXMuX2Zyb21bNF1dKClcclxuICAgICAgICA6IHJlc3VsdFxyXG4gICAgfVxyXG4gICAgcmVzdWx0ID0gcmVzdWx0LnRvQXJyYXkoKVxyXG5cclxuICAgIHRoaXMuX21vcnBoT2JqID0gdGhpcy5fbW9ycGhPYmogfHwgbmV3IHRoaXMuX3R5cGUoKVxyXG4gICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2NvbnRleHRcclxuICAgICAgfHwgQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkocmVzdWx0Lmxlbmd0aCkpXHJcbiAgICAgICAgLm1hcChPYmplY3QpXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobykge1xyXG4gICAgICAgICAgby5kb25lID0gdHJ1ZVxyXG4gICAgICAgICAgcmV0dXJuIG9cclxuICAgICAgICB9KVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgc3RlcHBlciAoc3RlcHBlcikge1xyXG4gICAgaWYgKHN0ZXBwZXIgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3N0ZXBwZXJcclxuICAgIHRoaXMuX3N0ZXBwZXIgPSBzdGVwcGVyXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZG9uZSAoKSB7XHJcbiAgICB2YXIgY29tcGxldGUgPSB0aGlzLl9jb250ZXh0XHJcbiAgICAgIC5tYXAodGhpcy5fc3RlcHBlci5kb25lKVxyXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uIChsYXN0LCBjdXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhc3QgJiYgY3VyclxyXG4gICAgICB9LCB0cnVlKVxyXG4gICAgcmV0dXJuIGNvbXBsZXRlXHJcbiAgfVxyXG5cclxuICBhdCAocG9zKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzXHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX21vcnBoT2JqLmZyb21BcnJheShcclxuICAgICAgdGhpcy5fZnJvbS5tYXAoZnVuY3Rpb24gKGksIGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLl9zdGVwcGVyLnN0ZXAoaSwgX3RoaXMuX3RvW2luZGV4XSwgcG9zLCBfdGhpcy5fY29udGV4dFtpbmRleF0sIF90aGlzLl9jb250ZXh0KVxyXG4gICAgICB9KVxyXG4gICAgKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE5vbk1vcnBoYWJsZSB7XHJcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgaW5pdCAodmFsKSB7XHJcbiAgICB2YWwgPSBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWxbMF0gOiB2YWxcclxuICAgIHRoaXMudmFsdWUgPSB2YWxcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB2YWx1ZU9mICgpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlXHJcbiAgfVxyXG5cclxuICB0b0FycmF5ICgpIHtcclxuICAgIHJldHVybiBbIHRoaXMudmFsdWUgXVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybUJhZyB7XHJcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgaW5pdCAob2JqKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgIG9iaiA9IHtcclxuICAgICAgICBzY2FsZVg6IG9ialswXSxcclxuICAgICAgICBzY2FsZVk6IG9ialsxXSxcclxuICAgICAgICBzaGVhcjogb2JqWzJdLFxyXG4gICAgICAgIHJvdGF0ZTogb2JqWzNdLFxyXG4gICAgICAgIHRyYW5zbGF0ZVg6IG9ials0XSxcclxuICAgICAgICB0cmFuc2xhdGVZOiBvYmpbNV0sXHJcbiAgICAgICAgb3JpZ2luWDogb2JqWzZdLFxyXG4gICAgICAgIG9yaWdpblk6IG9ials3XVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBUcmFuc2Zvcm1CYWcuZGVmYXVsdHMsIG9iailcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB0b0FycmF5ICgpIHtcclxuICAgIHZhciB2ID0gdGhpc1xyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgIHYuc2NhbGVYLFxyXG4gICAgICB2LnNjYWxlWSxcclxuICAgICAgdi5zaGVhcixcclxuICAgICAgdi5yb3RhdGUsXHJcbiAgICAgIHYudHJhbnNsYXRlWCxcclxuICAgICAgdi50cmFuc2xhdGVZLFxyXG4gICAgICB2Lm9yaWdpblgsXHJcbiAgICAgIHYub3JpZ2luWVxyXG4gICAgXVxyXG4gIH1cclxufVxyXG5cclxuVHJhbnNmb3JtQmFnLmRlZmF1bHRzID0ge1xyXG4gIHNjYWxlWDogMSxcclxuICBzY2FsZVk6IDEsXHJcbiAgc2hlYXI6IDAsXHJcbiAgcm90YXRlOiAwLFxyXG4gIHRyYW5zbGF0ZVg6IDAsXHJcbiAgdHJhbnNsYXRlWTogMCxcclxuICBvcmlnaW5YOiAwLFxyXG4gIG9yaWdpblk6IDBcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE9iamVjdEJhZyB7XHJcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgaW5pdCAob2JqT3JBcnIpIHtcclxuICAgIHRoaXMudmFsdWVzID0gW11cclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpPckFycikpIHtcclxuICAgICAgdGhpcy52YWx1ZXMgPSBvYmpPckFyclxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBvYmpPckFyciA9IG9iak9yQXJyIHx8IHt9XHJcbiAgICB2YXIgZW50cmllcyA9IFtdXHJcblxyXG4gICAgZm9yIChjb25zdCBpIGluIG9iak9yQXJyKSB7XHJcbiAgICAgIGVudHJpZXMucHVzaChbIGksIG9iak9yQXJyW2ldIF0pXHJcbiAgICB9XHJcblxyXG4gICAgZW50cmllcy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgIHJldHVybiBhWzBdIC0gYlswXVxyXG4gICAgfSlcclxuXHJcbiAgICB0aGlzLnZhbHVlcyA9IGVudHJpZXMucmVkdWNlKChsYXN0LCBjdXJyKSA9PiBsYXN0LmNvbmNhdChjdXJyKSwgW10pXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgdmFsdWVPZiAoKSB7XHJcbiAgICB2YXIgb2JqID0ge31cclxuICAgIHZhciBhcnIgPSB0aGlzLnZhbHVlc1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcclxuICAgICAgb2JqW2FycltpXV0gPSBhcnJbaSArIDFdXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9ialxyXG4gIH1cclxuXHJcbiAgdG9BcnJheSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IG1vcnBoYWJsZVR5cGVzID0gW1xyXG4gIE5vbk1vcnBoYWJsZSxcclxuICBUcmFuc2Zvcm1CYWcsXHJcbiAgT2JqZWN0QmFnXHJcbl1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlck1vcnBoYWJsZVR5cGUgKHR5cGUgPSBbXSkge1xyXG4gIG1vcnBoYWJsZVR5cGVzLnB1c2goLi4uW10uY29uY2F0KHR5cGUpKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1vcnBoYWJsZSAoKSB7XHJcbiAgZXh0ZW5kKG1vcnBoYWJsZVR5cGVzLCB7XHJcbiAgICB0byAodmFsKSB7XHJcbiAgICAgIHJldHVybiBuZXcgTW9ycGhhYmxlKClcclxuICAgICAgICAudHlwZSh0aGlzLmNvbnN0cnVjdG9yKVxyXG4gICAgICAgIC5mcm9tKHRoaXMudmFsdWVPZigpKVxyXG4gICAgICAgIC50byh2YWwpXHJcbiAgICB9LFxyXG4gICAgZnJvbUFycmF5IChhcnIpIHtcclxuICAgICAgdGhpcy5pbml0KGFycilcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9KVxyXG59XHJcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcHJvcG9ydGlvbmFsU2l6ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgUGF0aEFycmF5IGZyb20gJy4uL3R5cGVzL1BhdGhBcnJheS5qcydcclxuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXHJcbmltcG9ydCBiYXNlRmluZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoIGV4dGVuZHMgU2hhcGUge1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ3BhdGgnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIC8vIEdldCBhcnJheVxyXG4gIGFycmF5ICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgUGF0aEFycmF5KHRoaXMuYXR0cignZCcpKSlcclxuICB9XHJcblxyXG4gIC8vIFBsb3QgbmV3IHBhdGhcclxuICBwbG90IChkKSB7XHJcbiAgICByZXR1cm4gKGQgPT0gbnVsbCkgPyB0aGlzLmFycmF5KClcclxuICAgICAgOiB0aGlzLmNsZWFyKCkuYXR0cignZCcsIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IGQgOiAodGhpcy5fYXJyYXkgPSBuZXcgUGF0aEFycmF5KGQpKSlcclxuICB9XHJcblxyXG4gIC8vIENsZWFyIGFycmF5IGNhY2hlXHJcbiAgY2xlYXIgKCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2FycmF5XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcclxuICBtb3ZlICh4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLm1vdmUoeCwgeSkpXHJcbiAgfVxyXG5cclxuICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xyXG4gIHggKHgpIHtcclxuICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmJib3goKS54IDogdGhpcy5tb3ZlKHgsIHRoaXMuYmJveCgpLnkpXHJcbiAgfVxyXG5cclxuICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHktYXhpc1xyXG4gIHkgKHkpIHtcclxuICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmJib3goKS55IDogdGhpcy5tb3ZlKHRoaXMuYmJveCgpLngsIHkpXHJcbiAgfVxyXG5cclxuICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcclxuICBzaXplICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnLCB0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkpXHJcbiAgfVxyXG5cclxuICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxyXG4gIHdpZHRoICh3aWR0aCkge1xyXG4gICAgcmV0dXJuIHdpZHRoID09IG51bGwgPyB0aGlzLmJib3goKS53aWR0aCA6IHRoaXMuc2l6ZSh3aWR0aCwgdGhpcy5iYm94KCkuaGVpZ2h0KVxyXG4gIH1cclxuXHJcbiAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XHJcbiAgaGVpZ2h0IChoZWlnaHQpIHtcclxuICAgIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmhlaWdodCA6IHRoaXMuc2l6ZSh0aGlzLmJib3goKS53aWR0aCwgaGVpZ2h0KVxyXG4gIH1cclxuXHJcbiAgdGFyZ2V0cyAoKSB7XHJcbiAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyB0ZXh0cGF0aCBbaHJlZio9XCInICsgdGhpcy5pZCgpICsgJ1wiXScpXHJcbiAgfVxyXG59XHJcblxyXG4vLyBEZWZpbmUgbW9ycGhhYmxlIGFycmF5XHJcblBhdGgucHJvdG90eXBlLk1vcnBoQXJyYXkgPSBQYXRoQXJyYXlcclxuXHJcbi8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBhdGggZWxlbWVudFxyXG4gICAgcGF0aDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKGQpIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUGF0aCgpKS5wbG90KGQgfHwgbmV3IFBhdGhBcnJheSgpKVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihQYXRoLCAnUGF0aCcpXHJcbiIsImltcG9ydCB7IHByb3BvcnRpb25hbFNpemUgfSBmcm9tICcuLi8uLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcclxuXHJcbi8vIEdldCBhcnJheVxyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXkgKCkge1xyXG4gIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgUG9pbnRBcnJheSh0aGlzLmF0dHIoJ3BvaW50cycpKSlcclxufVxyXG5cclxuLy8gUGxvdCBuZXcgcGF0aFxyXG5leHBvcnQgZnVuY3Rpb24gcGxvdCAocCkge1xyXG4gIHJldHVybiAocCA9PSBudWxsKSA/IHRoaXMuYXJyYXkoKVxyXG4gICAgOiB0aGlzLmNsZWFyKCkuYXR0cigncG9pbnRzJywgdHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcFxyXG4gICAgOiAodGhpcy5fYXJyYXkgPSBuZXcgUG9pbnRBcnJheShwKSkpXHJcbn1cclxuXHJcbi8vIENsZWFyIGFycmF5IGNhY2hlXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhciAoKSB7XHJcbiAgZGVsZXRlIHRoaXMuX2FycmF5XHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmUgKHgsIHkpIHtcclxuICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSlcclxufVxyXG5cclxuLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XHJcbmV4cG9ydCBmdW5jdGlvbiBzaXplICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcclxuICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkpXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBleHRlbmQsXHJcbiAgbm9kZU9yTmV3LFxyXG4gIHJlZ2lzdGVyLFxyXG4gIHdyYXBXaXRoQXR0ckNoZWNrXHJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcclxuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXHJcbmltcG9ydCAqIGFzIHBvaW50ZWQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3BvaW50ZWQuanMnXHJcbmltcG9ydCAqIGFzIHBvbHkgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3BvbHkuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uIGV4dGVuZHMgU2hhcGUge1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ3BvbHlnb24nLCBub2RlKSwgbm9kZSlcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBvbHlnb24gZWxlbWVudFxyXG4gICAgcG9seWdvbjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHApIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUG9seWdvbigpKS5wbG90KHAgfHwgbmV3IFBvaW50QXJyYXkoKSlcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxuZXh0ZW5kKFBvbHlnb24sIHBvaW50ZWQpXHJcbmV4dGVuZChQb2x5Z29uLCBwb2x5KVxyXG5yZWdpc3RlcihQb2x5Z29uLCAnUG9seWdvbicpXHJcbiIsImltcG9ydCB7XHJcbiAgZXh0ZW5kLFxyXG4gIG5vZGVPck5ldyxcclxuICByZWdpc3RlcixcclxuICB3cmFwV2l0aEF0dHJDaGVja1xyXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBQb2ludEFycmF5IGZyb20gJy4uL3R5cGVzL1BvaW50QXJyYXkuanMnXHJcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xyXG5pbXBvcnQgKiBhcyBwb2ludGVkIGZyb20gJy4uL21vZHVsZXMvY29yZS9wb2ludGVkLmpzJ1xyXG5pbXBvcnQgKiBhcyBwb2x5IGZyb20gJy4uL21vZHVsZXMvY29yZS9wb2x5LmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWxpbmUgZXh0ZW5kcyBTaGFwZSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygncG9seWxpbmUnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBvbHlnb24gZWxlbWVudFxyXG4gICAgcG9seWxpbmU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBvbHlsaW5lKCkpLnBsb3QocCB8fCBuZXcgUG9pbnRBcnJheSgpKVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5leHRlbmQoUG9seWxpbmUsIHBvaW50ZWQpXHJcbmV4dGVuZChQb2x5bGluZSwgcG9seSlcclxucmVnaXN0ZXIoUG9seWxpbmUsICdQb2x5bGluZScpXHJcbiIsImltcG9ydCB7XHJcbiAgZXh0ZW5kLFxyXG4gIG5vZGVPck5ldyxcclxuICByZWdpc3RlcixcclxuICB3cmFwV2l0aEF0dHJDaGVja1xyXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCB7IHJ4LCByeSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9jaXJjbGVkLmpzJ1xyXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3QgZXh0ZW5kcyBTaGFwZSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygncmVjdCcsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxufVxyXG5cclxuZXh0ZW5kKFJlY3QsIHsgcngsIHJ5IH0pXHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgLy8gQ3JlYXRlIGEgcmVjdCBlbGVtZW50XHJcbiAgICByZWN0OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFJlY3QoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihSZWN0LCAnUmVjdCcpXHJcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7XG52YXIgTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGV4Y2VlZGVkJztcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zcGxpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNwbGljZVxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdzcGxpY2UnKSB9LCB7XG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCAvKiAsIC4uLml0ZW1zICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBhY3R1YWxTdGFydCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaW5zZXJ0Q291bnQsIGFjdHVhbERlbGV0ZUNvdW50LCBBLCBrLCBmcm9tLCB0bztcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAwKSB7XG4gICAgICBpbnNlcnRDb3VudCA9IGFjdHVhbERlbGV0ZUNvdW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMSkge1xuICAgICAgaW5zZXJ0Q291bnQgPSAwO1xuICAgICAgYWN0dWFsRGVsZXRlQ291bnQgPSBsZW4gLSBhY3R1YWxTdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhcmd1bWVudHNMZW5ndGggLSAyO1xuICAgICAgYWN0dWFsRGVsZXRlQ291bnQgPSBtaW4obWF4KHRvSW50ZWdlcihkZWxldGVDb3VudCksIDApLCBsZW4gLSBhY3R1YWxTdGFydCk7XG4gICAgfVxuICAgIGlmIChsZW4gKyBpbnNlcnRDb3VudCAtIGFjdHVhbERlbGV0ZUNvdW50ID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQpO1xuICAgIH1cbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIGFjdHVhbERlbGV0ZUNvdW50KTtcbiAgICBmb3IgKGsgPSAwOyBrIDwgYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgZnJvbSA9IGFjdHVhbFN0YXJ0ICsgaztcbiAgICAgIGlmIChmcm9tIGluIE8pIGNyZWF0ZVByb3BlcnR5KEEsIGssIE9bZnJvbV0pO1xuICAgIH1cbiAgICBBLmxlbmd0aCA9IGFjdHVhbERlbGV0ZUNvdW50O1xuICAgIGlmIChpbnNlcnRDb3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICBmb3IgKGsgPSBhY3R1YWxTdGFydDsgayA8IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQ7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgICB9XG4gICAgICBmb3IgKGsgPSBsZW47IGsgPiBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50OyBrLS0pIGRlbGV0ZSBPW2sgLSAxXTtcbiAgICB9IGVsc2UgaWYgKGluc2VydENvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrID4gYWN0dWFsU3RhcnQ7IGstLSkge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50IC0gMTtcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQgLSAxO1xuICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGsgPSAwOyBrIDwgaW5zZXJ0Q291bnQ7IGsrKykge1xuICAgICAgT1trICsgYWN0dWFsU3RhcnRdID0gYXJndW1lbnRzW2sgKyAyXTtcbiAgICB9XG4gICAgTy5sZW5ndGggPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50O1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlIHtcclxuICBjb25zdHJ1Y3RvciAoKSB7XHJcbiAgICB0aGlzLl9maXJzdCA9IG51bGxcclxuICAgIHRoaXMuX2xhc3QgPSBudWxsXHJcbiAgfVxyXG5cclxuICBwdXNoICh2YWx1ZSkge1xyXG4gICAgLy8gQW4gaXRlbSBzdG9yZXMgYW4gaWQgYW5kIHRoZSBwcm92aWRlZCB2YWx1ZVxyXG4gICAgdmFyIGl0ZW0gPSB2YWx1ZS5uZXh0ID8gdmFsdWUgOiB7IHZhbHVlOiB2YWx1ZSwgbmV4dDogbnVsbCwgcHJldjogbnVsbCB9XHJcblxyXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBxdWV1ZSBiZWluZyBlbXB0eSBvciBwb3B1bGF0ZWRcclxuICAgIGlmICh0aGlzLl9sYXN0KSB7XHJcbiAgICAgIGl0ZW0ucHJldiA9IHRoaXMuX2xhc3RcclxuICAgICAgdGhpcy5fbGFzdC5uZXh0ID0gaXRlbVxyXG4gICAgICB0aGlzLl9sYXN0ID0gaXRlbVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fbGFzdCA9IGl0ZW1cclxuICAgICAgdGhpcy5fZmlyc3QgPSBpdGVtXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBjdXJyZW50IGl0ZW1cclxuICAgIHJldHVybiBpdGVtXHJcbiAgfVxyXG5cclxuICBzaGlmdCAoKSB7XHJcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgdmFsdWVcclxuICAgIHZhciByZW1vdmUgPSB0aGlzLl9maXJzdFxyXG4gICAgaWYgKCFyZW1vdmUpIHJldHVybiBudWxsXHJcblxyXG4gICAgLy8gSWYgd2UgZG8sIHJlbW92ZSBpdCBhbmQgcmVsaW5rIHRoaW5nc1xyXG4gICAgdGhpcy5fZmlyc3QgPSByZW1vdmUubmV4dFxyXG4gICAgaWYgKHRoaXMuX2ZpcnN0KSB0aGlzLl9maXJzdC5wcmV2ID0gbnVsbFxyXG4gICAgdGhpcy5fbGFzdCA9IHRoaXMuX2ZpcnN0ID8gdGhpcy5fbGFzdCA6IG51bGxcclxuICAgIHJldHVybiByZW1vdmUudmFsdWVcclxuICB9XHJcblxyXG4gIC8vIFNob3dzIHVzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0XHJcbiAgZmlyc3QgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0ICYmIHRoaXMuX2ZpcnN0LnZhbHVlXHJcbiAgfVxyXG5cclxuICAvLyBTaG93cyB1cyB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0XHJcbiAgbGFzdCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGFzdCAmJiB0aGlzLl9sYXN0LnZhbHVlXHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmVzIHRoZSBpdGVtIHRoYXQgd2FzIHJldHVybmVkIGZyb20gdGhlIHB1c2hcclxuICByZW1vdmUgKGl0ZW0pIHtcclxuICAgIC8vIFJlbGluayB0aGUgcHJldmlvdXMgaXRlbVxyXG4gICAgaWYgKGl0ZW0ucHJldikgaXRlbS5wcmV2Lm5leHQgPSBpdGVtLm5leHRcclxuICAgIGlmIChpdGVtLm5leHQpIGl0ZW0ubmV4dC5wcmV2ID0gaXRlbS5wcmV2XHJcbiAgICBpZiAoaXRlbSA9PT0gdGhpcy5fbGFzdCkgdGhpcy5fbGFzdCA9IGl0ZW0ucHJldlxyXG4gICAgaWYgKGl0ZW0gPT09IHRoaXMuX2ZpcnN0KSB0aGlzLl9maXJzdCA9IGl0ZW0ubmV4dFxyXG5cclxuICAgIC8vIEludmFsaWRhdGUgaXRlbVxyXG4gICAgaXRlbS5wcmV2ID0gbnVsbFxyXG4gICAgaXRlbS5uZXh0ID0gbnVsbFxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5pbXBvcnQgUXVldWUgZnJvbSAnLi9RdWV1ZS5qcydcclxuXHJcbmNvbnN0IEFuaW1hdG9yID0ge1xyXG4gIG5leHREcmF3OiBudWxsLFxyXG4gIGZyYW1lczogbmV3IFF1ZXVlKCksXHJcbiAgdGltZW91dHM6IG5ldyBRdWV1ZSgpLFxyXG4gIGltbWVkaWF0ZXM6IG5ldyBRdWV1ZSgpLFxyXG4gIHRpbWVyOiAoKSA9PiBnbG9iYWxzLndpbmRvdy5wZXJmb3JtYW5jZSB8fCBnbG9iYWxzLndpbmRvdy5EYXRlLFxyXG4gIHRyYW5zZm9ybXM6IFtdLFxyXG5cclxuICBmcmFtZSAoZm4pIHtcclxuICAgIC8vIFN0b3JlIHRoZSBub2RlXHJcbiAgICB2YXIgbm9kZSA9IEFuaW1hdG9yLmZyYW1lcy5wdXNoKHsgcnVuOiBmbiB9KVxyXG5cclxuICAgIC8vIFJlcXVlc3QgYW4gYW5pbWF0aW9uIGZyYW1lIGlmIHdlIGRvbid0IGhhdmUgb25lXHJcbiAgICBpZiAoQW5pbWF0b3IubmV4dERyYXcgPT09IG51bGwpIHtcclxuICAgICAgQW5pbWF0b3IubmV4dERyYXcgPSBnbG9iYWxzLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoQW5pbWF0b3IuX2RyYXcpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBub2RlIHNvIHdlIGNhbiByZW1vdmUgaXQgZWFzaWx5XHJcbiAgICByZXR1cm4gbm9kZVxyXG4gIH0sXHJcblxyXG4gIHRpbWVvdXQgKGZuLCBkZWxheSkge1xyXG4gICAgZGVsYXkgPSBkZWxheSB8fCAwXHJcblxyXG4gICAgLy8gV29yayBvdXQgd2hlbiB0aGUgZXZlbnQgc2hvdWxkIGZpcmVcclxuICAgIHZhciB0aW1lID0gQW5pbWF0b3IudGltZXIoKS5ub3coKSArIGRlbGF5XHJcblxyXG4gICAgLy8gQWRkIHRoZSB0aW1lb3V0IHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXHJcbiAgICB2YXIgbm9kZSA9IEFuaW1hdG9yLnRpbWVvdXRzLnB1c2goeyBydW46IGZuLCB0aW1lOiB0aW1lIH0pXHJcblxyXG4gICAgLy8gUmVxdWVzdCBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZSBpZiB3ZSBuZWVkIG9uZVxyXG4gICAgaWYgKEFuaW1hdG9yLm5leHREcmF3ID09PSBudWxsKSB7XHJcbiAgICAgIEFuaW1hdG9yLm5leHREcmF3ID0gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub2RlXHJcbiAgfSxcclxuXHJcbiAgaW1tZWRpYXRlIChmbikge1xyXG4gICAgLy8gQWRkIHRoZSBpbW1lZGlhdGUgZm4gdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcclxuICAgIHZhciBub2RlID0gQW5pbWF0b3IuaW1tZWRpYXRlcy5wdXNoKGZuKVxyXG4gICAgLy8gUmVxdWVzdCBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZSBpZiB3ZSBuZWVkIG9uZVxyXG4gICAgaWYgKEFuaW1hdG9yLm5leHREcmF3ID09PSBudWxsKSB7XHJcbiAgICAgIEFuaW1hdG9yLm5leHREcmF3ID0gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub2RlXHJcbiAgfSxcclxuXHJcbiAgY2FuY2VsRnJhbWUgKG5vZGUpIHtcclxuICAgIG5vZGUgIT0gbnVsbCAmJiBBbmltYXRvci5mcmFtZXMucmVtb3ZlKG5vZGUpXHJcbiAgfSxcclxuXHJcbiAgY2xlYXJUaW1lb3V0IChub2RlKSB7XHJcbiAgICBub2RlICE9IG51bGwgJiYgQW5pbWF0b3IudGltZW91dHMucmVtb3ZlKG5vZGUpXHJcbiAgfSxcclxuXHJcbiAgY2FuY2VsSW1tZWRpYXRlIChub2RlKSB7XHJcbiAgICBub2RlICE9IG51bGwgJiYgQW5pbWF0b3IuaW1tZWRpYXRlcy5yZW1vdmUobm9kZSlcclxuICB9LFxyXG5cclxuICBfZHJhdyAobm93KSB7XHJcbiAgICAvLyBSdW4gYWxsIHRoZSB0aW1lb3V0cyB3ZSBjYW4gcnVuLCBpZiB0aGV5IGFyZSBub3QgcmVhZHkgeWV0LCBhZGQgdGhlbVxyXG4gICAgLy8gdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUgaW1tZWRpYXRlbHkhIChiYWQgdGltZW91dHMhISEgW3NhcmNhc21dKVxyXG4gICAgdmFyIG5leHRUaW1lb3V0ID0gbnVsbFxyXG4gICAgdmFyIGxhc3RUaW1lb3V0ID0gQW5pbWF0b3IudGltZW91dHMubGFzdCgpXHJcbiAgICB3aGlsZSAoKG5leHRUaW1lb3V0ID0gQW5pbWF0b3IudGltZW91dHMuc2hpZnQoKSkpIHtcclxuICAgICAgLy8gUnVuIHRoZSB0aW1lb3V0IGlmIGl0cyB0aW1lLCBvciBwdXNoIGl0IHRvIHRoZSBlbmRcclxuICAgICAgaWYgKG5vdyA+PSBuZXh0VGltZW91dC50aW1lKSB7XHJcbiAgICAgICAgbmV4dFRpbWVvdXQucnVuKClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBBbmltYXRvci50aW1lb3V0cy5wdXNoKG5leHRUaW1lb3V0KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB3ZSBoaXQgdGhlIGxhc3QgaXRlbSwgd2Ugc2hvdWxkIHN0b3Agc2hpZnRpbmcgb3V0IG1vcmUgaXRlbXNcclxuICAgICAgaWYgKG5leHRUaW1lb3V0ID09PSBsYXN0VGltZW91dCkgYnJlYWtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSdW4gYWxsIG9mIHRoZSBhbmltYXRpb24gZnJhbWVzXHJcbiAgICB2YXIgbmV4dEZyYW1lID0gbnVsbFxyXG4gICAgdmFyIGxhc3RGcmFtZSA9IEFuaW1hdG9yLmZyYW1lcy5sYXN0KClcclxuICAgIHdoaWxlICgobmV4dEZyYW1lICE9PSBsYXN0RnJhbWUpICYmIChuZXh0RnJhbWUgPSBBbmltYXRvci5mcmFtZXMuc2hpZnQoKSkpIHtcclxuICAgICAgbmV4dEZyYW1lLnJ1bihub3cpXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5leHRJbW1lZGlhdGUgPSBudWxsXHJcbiAgICB3aGlsZSAoKG5leHRJbW1lZGlhdGUgPSBBbmltYXRvci5pbW1lZGlhdGVzLnNoaWZ0KCkpKSB7XHJcbiAgICAgIG5leHRJbW1lZGlhdGUoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHdlIGhhdmUgcmVtYWluaW5nIHRpbWVvdXRzIG9yIGZyYW1lcywgZHJhdyB1bnRpbCB3ZSBkb24ndCBhbnltb3JlXHJcbiAgICBBbmltYXRvci5uZXh0RHJhdyA9IEFuaW1hdG9yLnRpbWVvdXRzLmZpcnN0KCkgfHwgQW5pbWF0b3IuZnJhbWVzLmZpcnN0KClcclxuICAgICAgPyBnbG9iYWxzLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoQW5pbWF0b3IuX2RyYXcpXHJcbiAgICAgIDogbnVsbFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0b3JcclxuIiwiaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IEFuaW1hdG9yIGZyb20gJy4vQW5pbWF0b3IuanMnXHJcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi90eXBlcy9FdmVudFRhcmdldC5qcydcclxuXHJcbnZhciBtYWtlU2NoZWR1bGUgPSBmdW5jdGlvbiAocnVubmVySW5mbykge1xyXG4gIHZhciBzdGFydCA9IHJ1bm5lckluZm8uc3RhcnRcclxuICB2YXIgZHVyYXRpb24gPSBydW5uZXJJbmZvLnJ1bm5lci5kdXJhdGlvbigpXHJcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgZHVyYXRpb25cclxuICByZXR1cm4geyBzdGFydDogc3RhcnQsIGR1cmF0aW9uOiBkdXJhdGlvbiwgZW5kOiBlbmQsIHJ1bm5lcjogcnVubmVySW5mby5ydW5uZXIgfVxyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0U291cmNlID0gZnVuY3Rpb24gKCkge1xyXG4gIGNvbnN0IHcgPSBnbG9iYWxzLndpbmRvd1xyXG4gIHJldHVybiAody5wZXJmb3JtYW5jZSB8fCB3LkRhdGUpLm5vdygpXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVsaW5lIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gIC8vIENvbnN0cnVjdCBhIG5ldyB0aW1lbGluZSBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxyXG4gIGNvbnN0cnVjdG9yICh0aW1lU291cmNlID0gZGVmYXVsdFNvdXJjZSkge1xyXG4gICAgc3VwZXIoKVxyXG5cclxuICAgIHRoaXMuX3RpbWVTb3VyY2UgPSB0aW1lU291cmNlXHJcblxyXG4gICAgLy8gU3RvcmUgdGhlIHRpbWluZyB2YXJpYWJsZXNcclxuICAgIHRoaXMuX3N0YXJ0VGltZSA9IDBcclxuICAgIHRoaXMuX3NwZWVkID0gMS4wXHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lcyBob3cgbG9uZyBhIHJ1bm5lciBpcyBob2xkIGluIG1lbW9yeS4gQ2FuIGJlIGEgZHQgb3IgdHJ1ZS9mYWxzZVxyXG4gICAgdGhpcy5fcGVyc2lzdCA9IDBcclxuXHJcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBydW5uaW5nIGFuaW1hdGlvbnMgYW5kIHRoZWlyIHN0YXJ0aW5nIHBhcmFtZXRlcnNcclxuICAgIHRoaXMuX25leHRGcmFtZSA9IG51bGxcclxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWVcclxuICAgIHRoaXMuX3J1bm5lcnMgPSBbXVxyXG4gICAgdGhpcy5fcnVubmVySWRzID0gW11cclxuICAgIHRoaXMuX2xhc3RSdW5uZXJJZCA9IC0xXHJcbiAgICB0aGlzLl90aW1lID0gMFxyXG4gICAgdGhpcy5fbGFzdFNvdXJjZVRpbWUgPSAwXHJcbiAgICB0aGlzLl9sYXN0U3RlcFRpbWUgPSAwXHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgc3RlcCBpcyBhbHdheXMgY2FsbGVkIGluIGNsYXNzIGNvbnRleHRcclxuICAgIHRoaXMuX3N0ZXAgPSB0aGlzLl9zdGVwRm4uYmluZCh0aGlzLCBmYWxzZSlcclxuICAgIHRoaXMuX3N0ZXBJbW1lZGlhdGUgPSB0aGlzLl9zdGVwRm4uYmluZCh0aGlzLCB0cnVlKVxyXG4gIH1cclxuXHJcbiAgLy8gc2NoZWR1bGVzIGEgcnVubmVyIG9uIHRoZSB0aW1lbGluZVxyXG4gIHNjaGVkdWxlIChydW5uZXIsIGRlbGF5LCB3aGVuKSB7XHJcbiAgICBpZiAocnVubmVyID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3J1bm5lcnMubWFwKG1ha2VTY2hlZHVsZSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgc3RhcnQgdGltZSBmb3IgdGhlIG5leHQgYW5pbWF0aW9uIGNhbiBlaXRoZXIgYmUgZ2l2ZW4gZXhwbGljaXRseSxcclxuICAgIC8vIGRlcml2ZWQgZnJvbSB0aGUgY3VycmVudCB0aW1lbGluZSB0aW1lIG9yIGl0IGNhbiBiZSByZWxhdGl2ZSB0byB0aGVcclxuICAgIC8vIGxhc3Qgc3RhcnQgdGltZSB0byBjaGFpbiBhbmltYXRpb25zIGRpcmVjbHR5XHJcblxyXG4gICAgdmFyIGFic29sdXRlU3RhcnRUaW1lID0gMFxyXG4gICAgdmFyIGVuZFRpbWUgPSB0aGlzLmdldEVuZFRpbWUoKVxyXG4gICAgZGVsYXkgPSBkZWxheSB8fCAwXHJcblxyXG4gICAgLy8gV29yayBvdXQgd2hlbiB0byBzdGFydCB0aGUgYW5pbWF0aW9uXHJcbiAgICBpZiAod2hlbiA9PSBudWxsIHx8IHdoZW4gPT09ICdsYXN0JyB8fCB3aGVuID09PSAnYWZ0ZXInKSB7XHJcbiAgICAgIC8vIFRha2UgdGhlIGxhc3QgdGltZSBhbmQgaW5jcmVtZW50XHJcbiAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gZW5kVGltZVxyXG4gICAgfSBlbHNlIGlmICh3aGVuID09PSAnYWJzb2x1dGUnIHx8IHdoZW4gPT09ICdzdGFydCcpIHtcclxuICAgICAgYWJzb2x1dGVTdGFydFRpbWUgPSBkZWxheVxyXG4gICAgICBkZWxheSA9IDBcclxuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ25vdycpIHtcclxuICAgICAgYWJzb2x1dGVTdGFydFRpbWUgPSB0aGlzLl90aW1lXHJcbiAgICB9IGVsc2UgaWYgKHdoZW4gPT09ICdyZWxhdGl2ZScpIHtcclxuICAgICAgY29uc3QgcnVubmVySW5mbyA9IHRoaXMuX3J1bm5lcnNbcnVubmVyLmlkXVxyXG4gICAgICBpZiAocnVubmVySW5mbykge1xyXG4gICAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gcnVubmVySW5mby5zdGFydCArIGRlbGF5XHJcbiAgICAgICAgZGVsYXkgPSAwXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgdGhlIFwid2hlblwiIHBhcmFtZXRlcicpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFuYWdlIHJ1bm5lclxyXG4gICAgcnVubmVyLnVuc2NoZWR1bGUoKVxyXG4gICAgcnVubmVyLnRpbWVsaW5lKHRoaXMpXHJcblxyXG4gICAgY29uc3QgcGVyc2lzdCA9IHJ1bm5lci5wZXJzaXN0KClcclxuICAgIGNvbnN0IHJ1bm5lckluZm8gPSB7XHJcbiAgICAgIHBlcnNpc3Q6IHBlcnNpc3QgPT09IG51bGwgPyB0aGlzLl9wZXJzaXN0IDogcGVyc2lzdCxcclxuICAgICAgc3RhcnQ6IGFic29sdXRlU3RhcnRUaW1lICsgZGVsYXksXHJcbiAgICAgIHJ1bm5lclxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2xhc3RSdW5uZXJJZCA9IHJ1bm5lci5pZFxyXG5cclxuICAgIHRoaXMuX3J1bm5lcnMucHVzaChydW5uZXJJbmZvKVxyXG4gICAgdGhpcy5fcnVubmVycy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydClcclxuICAgIHRoaXMuX3J1bm5lcklkcyA9IHRoaXMuX3J1bm5lcnMubWFwKGluZm8gPT4gaW5mby5ydW5uZXIuaWQpXHJcblxyXG4gICAgdGhpcy51cGRhdGVUaW1lKCkuX2NvbnRpbnVlKClcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdGhlIHJ1bm5lciBmcm9tIHRoaXMgdGltZWxpbmVcclxuICB1bnNjaGVkdWxlIChydW5uZXIpIHtcclxuICAgIHZhciBpbmRleCA9IHRoaXMuX3J1bm5lcklkcy5pbmRleE9mKHJ1bm5lci5pZClcclxuICAgIGlmIChpbmRleCA8IDApIHJldHVybiB0aGlzXHJcblxyXG4gICAgdGhpcy5fcnVubmVycy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICB0aGlzLl9ydW5uZXJJZHMuc3BsaWNlKGluZGV4LCAxKVxyXG5cclxuICAgIHJ1bm5lci50aW1lbGluZShudWxsKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIENhbGN1bGF0ZXMgdGhlIGVuZCBvZiB0aGUgdGltZWxpbmVcclxuICBnZXRFbmRUaW1lICgpIHtcclxuICAgIHZhciBsYXN0UnVubmVySW5mbyA9IHRoaXMuX3J1bm5lcnNbdGhpcy5fcnVubmVySWRzLmluZGV4T2YodGhpcy5fbGFzdFJ1bm5lcklkKV1cclxuICAgIHZhciBsYXN0RHVyYXRpb24gPSBsYXN0UnVubmVySW5mbyA/IGxhc3RSdW5uZXJJbmZvLnJ1bm5lci5kdXJhdGlvbigpIDogMFxyXG4gICAgdmFyIGxhc3RTdGFydFRpbWUgPSBsYXN0UnVubmVySW5mbyA/IGxhc3RSdW5uZXJJbmZvLnN0YXJ0IDogMFxyXG4gICAgcmV0dXJuIGxhc3RTdGFydFRpbWUgKyBsYXN0RHVyYXRpb25cclxuICB9XHJcblxyXG4gIGdldEVuZFRpbWVPZlRpbWVsaW5lICgpIHtcclxuICAgIGxldCBsYXN0RW5kVGltZSA9IDBcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcnVubmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBydW5uZXJJbmZvID0gdGhpcy5fcnVubmVyc1tpXVxyXG4gICAgICB2YXIgZHVyYXRpb24gPSBydW5uZXJJbmZvID8gcnVubmVySW5mby5ydW5uZXIuZHVyYXRpb24oKSA6IDBcclxuICAgICAgdmFyIHN0YXJ0VGltZSA9IHJ1bm5lckluZm8gPyBydW5uZXJJbmZvLnN0YXJ0IDogMFxyXG4gICAgICBjb25zdCBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb25cclxuICAgICAgaWYgKGVuZFRpbWUgPiBsYXN0RW5kVGltZSkge1xyXG4gICAgICAgIGxhc3RFbmRUaW1lID0gZW5kVGltZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGFzdEVuZFRpbWVcclxuICB9XHJcblxyXG4gIC8vIE1ha2VzIHN1cmUsIHRoYXQgYWZ0ZXIgcGF1c2luZyB0aGUgdGltZSBkb2Vzbid0IGp1bXBcclxuICB1cGRhdGVUaW1lICgpIHtcclxuICAgIGlmICghdGhpcy5hY3RpdmUoKSkge1xyXG4gICAgICB0aGlzLl9sYXN0U291cmNlVGltZSA9IHRoaXMuX3RpbWVTb3VyY2UoKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHBsYXkgKCkge1xyXG4gICAgLy8gTm93IG1ha2Ugc3VyZSB3ZSBhcmUgbm90IHBhdXNlZCBhbmQgY29udGludWUgdGhlIGFuaW1hdGlvblxyXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2VcclxuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRpbWUoKS5fY29udGludWUoKVxyXG4gIH1cclxuXHJcbiAgcGF1c2UgKCkge1xyXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZVxyXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRpbnVlKClcclxuICB9XHJcblxyXG4gIHN0b3AgKCkge1xyXG4gICAgLy8gR28gdG8gc3RhcnQgYW5kIHBhdXNlXHJcbiAgICB0aGlzLnRpbWUoMClcclxuICAgIHJldHVybiB0aGlzLnBhdXNlKClcclxuICB9XHJcblxyXG4gIGZpbmlzaCAoKSB7XHJcbiAgICAvLyBHbyB0byBlbmQgYW5kIHBhdXNlXHJcbiAgICB0aGlzLnRpbWUodGhpcy5nZXRFbmRUaW1lT2ZUaW1lbGluZSgpICsgMSlcclxuICAgIHJldHVybiB0aGlzLnBhdXNlKClcclxuICB9XHJcblxyXG4gIHNwZWVkIChzcGVlZCkge1xyXG4gICAgaWYgKHNwZWVkID09IG51bGwpIHJldHVybiB0aGlzLl9zcGVlZFxyXG4gICAgdGhpcy5fc3BlZWQgPSBzcGVlZFxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHJldmVyc2UgKHllcykge1xyXG4gICAgdmFyIGN1cnJlbnRTcGVlZCA9IHRoaXMuc3BlZWQoKVxyXG4gICAgaWYgKHllcyA9PSBudWxsKSByZXR1cm4gdGhpcy5zcGVlZCgtY3VycmVudFNwZWVkKVxyXG5cclxuICAgIHZhciBwb3NpdGl2ZSA9IE1hdGguYWJzKGN1cnJlbnRTcGVlZClcclxuICAgIHJldHVybiB0aGlzLnNwZWVkKHllcyA/IHBvc2l0aXZlIDogLXBvc2l0aXZlKVxyXG4gIH1cclxuXHJcbiAgc2VlayAoZHQpIHtcclxuICAgIHJldHVybiB0aGlzLnRpbWUodGhpcy5fdGltZSArIGR0KVxyXG4gIH1cclxuXHJcbiAgdGltZSAodGltZSkge1xyXG4gICAgaWYgKHRpbWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3RpbWVcclxuICAgIHRoaXMuX3RpbWUgPSB0aW1lXHJcbiAgICByZXR1cm4gdGhpcy5fY29udGludWUodHJ1ZSlcclxuICB9XHJcblxyXG4gIHBlcnNpc3QgKGR0T3JGb3JldmVyKSB7XHJcbiAgICBpZiAoZHRPckZvcmV2ZXIgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3BlcnNpc3RcclxuICAgIHRoaXMuX3BlcnNpc3QgPSBkdE9yRm9yZXZlclxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHNvdXJjZSAoZm4pIHtcclxuICAgIGlmIChmbiA9PSBudWxsKSByZXR1cm4gdGhpcy5fdGltZVNvdXJjZVxyXG4gICAgdGhpcy5fdGltZVNvdXJjZSA9IGZuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgX3N0ZXBGbiAoaW1tZWRpYXRlU3RlcCA9IGZhbHNlKSB7XHJcbiAgICAvLyBHZXQgdGhlIHRpbWUgZGVsdGEgZnJvbSB0aGUgbGFzdCB0aW1lIGFuZCB1cGRhdGUgdGhlIHRpbWVcclxuICAgIHZhciB0aW1lID0gdGhpcy5fdGltZVNvdXJjZSgpXHJcbiAgICB2YXIgZHRTb3VyY2UgPSB0aW1lIC0gdGhpcy5fbGFzdFNvdXJjZVRpbWVcclxuXHJcbiAgICBpZiAoaW1tZWRpYXRlU3RlcCkgZHRTb3VyY2UgPSAwXHJcblxyXG4gICAgdmFyIGR0VGltZSA9IHRoaXMuX3NwZWVkICogZHRTb3VyY2UgKyAodGhpcy5fdGltZSAtIHRoaXMuX2xhc3RTdGVwVGltZSlcclxuICAgIHRoaXMuX2xhc3RTb3VyY2VUaW1lID0gdGltZVxyXG5cclxuICAgIC8vIE9ubHkgdXBkYXRlIHRoZSB0aW1lIGlmIHdlIHVzZSB0aGUgdGltZVNvdXJjZS5cclxuICAgIC8vIE90aGVyd2lzZSB1c2UgdGhlIGN1cnJlbnQgdGltZVxyXG4gICAgaWYgKCFpbW1lZGlhdGVTdGVwKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZVxyXG4gICAgICB0aGlzLl90aW1lICs9IGR0VGltZVxyXG4gICAgICB0aGlzLl90aW1lID0gdGhpcy5fdGltZSA8IDAgPyAwIDogdGhpcy5fdGltZVxyXG4gICAgfVxyXG4gICAgdGhpcy5fbGFzdFN0ZXBUaW1lID0gdGhpcy5fdGltZVxyXG4gICAgdGhpcy5maXJlKCd0aW1lJywgdGhpcy5fdGltZSlcclxuXHJcbiAgICAvLyBUaGlzIGlzIGZvciB0aGUgY2FzZSB0aGF0IHRoZSB0aW1lbGluZSB3YXMgc2Vla2VkIHNvIHRoYXQgdGhlIHRpbWVcclxuICAgIC8vIGlzIG5vdyBiZWZvcmUgdGhlIHN0YXJ0VGltZSBvZiB0aGUgcnVubmVyLiBUaGF0cyB3aHkgd2UgbmVlZCB0byBzZXRcclxuICAgIC8vIHRoZSBydW5uZXIgdG8gcG9zaXRpb24gMFxyXG5cclxuICAgIC8vIEZJWE1FOlxyXG4gICAgLy8gSG93ZXZlciwgcmVzZXRpbmcgaW4gaW5zZXJ0aW9uIG9yZGVyIGxlYWRzIHRvIGJ1Z3MuIENvbnNpZGVyaW5nIHRoZSBjYXNlLFxyXG4gICAgLy8gd2hlcmUgMiBydW5uZXJzIGNoYW5nZSB0aGUgc2FtZSBhdHRyaXV0ZSBidXQgaW4gZGlmZmVyZW50IHRpbWVzLFxyXG4gICAgLy8gcmVzZXRpbmcgYm90aCBvZiB0aGVtIHdpbGwgbGVhZCB0byB0aGUgY2FzZSB3aGVyZSB0aGUgbGF0ZXIgZGVmaW5lZFxyXG4gICAgLy8gcnVubmVyIGFsd2F5cyB3aW5zIHRoZSByZXNldCBldmVuIGlmIHRoZSBvdGhlciBydW5uZXIgc3RhcnRlZCBlYXJsaWVyXHJcbiAgICAvLyBhbmQgdGhlcmVmb3JlIHNob3VsZCB3aW4gdGhlIGF0dHJpYnV0ZSBiYXR0bGVcclxuICAgIC8vIHRoaXMgY2FuIGJlIHNvbHZlZCBieSByZXNldGluZyB0aGVtIGJhY2t3YXJkc1xyXG4gICAgZm9yICh2YXIgayA9IHRoaXMuX3J1bm5lcnMubGVuZ3RoOyBrLS07KSB7XHJcbiAgICAgIC8vIEdldCBhbmQgcnVuIHRoZSBjdXJyZW50IHJ1bm5lciBhbmQgaWdub3JlIGl0IGlmIGl0cyBpbmFjdGl2ZVxyXG4gICAgICBjb25zdCBydW5uZXJJbmZvID0gdGhpcy5fcnVubmVyc1trXVxyXG4gICAgICBjb25zdCBydW5uZXIgPSBydW5uZXJJbmZvLnJ1bm5lclxyXG5cclxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgZ2l2ZSB0aGUgYWN0dWFsIGRpZmZlcmVuY2VcclxuICAgICAgLy8gYmV0d2VlbiBydW5uZXIgc3RhcnQgdGltZSBhbmQgbm93XHJcbiAgICAgIGNvbnN0IGR0VG9TdGFydCA9IHRoaXMuX3RpbWUgLSBydW5uZXJJbmZvLnN0YXJ0XHJcblxyXG4gICAgICAvLyBEb250IHJ1biBydW5uZXIgaWYgbm90IHN0YXJ0ZWQgeWV0XHJcbiAgICAgIC8vIGFuZCB0cnkgdG8gcmVzZXQgaXRcclxuICAgICAgaWYgKGR0VG9TdGFydCA8PSAwKSB7XHJcbiAgICAgICAgcnVubmVyLnJlc2V0KClcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJ1biBhbGwgb2YgdGhlIHJ1bm5lcnMgZGlyZWN0bHlcclxuICAgIHZhciBydW5uZXJzTGVmdCA9IGZhbHNlXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcnVubmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAvLyBHZXQgYW5kIHJ1biB0aGUgY3VycmVudCBydW5uZXIgYW5kIGlnbm9yZSBpdCBpZiBpdHMgaW5hY3RpdmVcclxuICAgICAgY29uc3QgcnVubmVySW5mbyA9IHRoaXMuX3J1bm5lcnNbaV1cclxuICAgICAgY29uc3QgcnVubmVyID0gcnVubmVySW5mby5ydW5uZXJcclxuICAgICAgbGV0IGR0ID0gZHRUaW1lXHJcblxyXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBnaXZlIHRoZSBhY3R1YWwgZGlmZmVyZW5jZVxyXG4gICAgICAvLyBiZXR3ZWVuIHJ1bm5lciBzdGFydCB0aW1lIGFuZCBub3dcclxuICAgICAgY29uc3QgZHRUb1N0YXJ0ID0gdGhpcy5fdGltZSAtIHJ1bm5lckluZm8uc3RhcnRcclxuXHJcbiAgICAgIC8vIERvbnQgcnVuIHJ1bm5lciBpZiBub3Qgc3RhcnRlZCB5ZXRcclxuICAgICAgaWYgKGR0VG9TdGFydCA8PSAwKSB7XHJcbiAgICAgICAgcnVubmVyc0xlZnQgPSB0cnVlXHJcbiAgICAgICAgY29udGludWVcclxuICAgICAgfSBlbHNlIGlmIChkdFRvU3RhcnQgPCBkdCkge1xyXG4gICAgICAgIC8vIEFkanVzdCBkdCB0byBtYWtlIHN1cmUgdGhhdCBhbmltYXRpb24gaXMgb24gcG9pbnRcclxuICAgICAgICBkdCA9IGR0VG9TdGFydFxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXJ1bm5lci5hY3RpdmUoKSkgY29udGludWVcclxuXHJcbiAgICAgIC8vIElmIHRoaXMgcnVubmVyIGlzIHN0aWxsIGdvaW5nLCBzaWduYWwgdGhhdCB3ZSBuZWVkIGFub3RoZXIgYW5pbWF0aW9uXHJcbiAgICAgIC8vIGZyYW1lLCBvdGhlcndpc2UsIHJlbW92ZSB0aGUgY29tcGxldGVkIHJ1bm5lclxyXG4gICAgICB2YXIgZmluaXNoZWQgPSBydW5uZXIuc3RlcChkdCkuZG9uZVxyXG4gICAgICBpZiAoIWZpbmlzaGVkKSB7XHJcbiAgICAgICAgcnVubmVyc0xlZnQgPSB0cnVlXHJcbiAgICAgICAgLy8gY29udGludWVcclxuICAgICAgfSBlbHNlIGlmIChydW5uZXJJbmZvLnBlcnNpc3QgIT09IHRydWUpIHtcclxuICAgICAgICAvLyBydW5uZXIgaXMgZmluaXNoZWQuIEFuZCBydW5uZXIgbWlnaHQgZ2V0IHJlbW92ZWRcclxuICAgICAgICB2YXIgZW5kVGltZSA9IHJ1bm5lci5kdXJhdGlvbigpIC0gcnVubmVyLnRpbWUoKSArIHRoaXMuX3RpbWVcclxuXHJcbiAgICAgICAgaWYgKGVuZFRpbWUgKyBydW5uZXJJbmZvLnBlcnNpc3QgPCB0aGlzLl90aW1lKSB7XHJcbiAgICAgICAgICAvLyBEZWxldGUgcnVubmVyIGFuZCBjb3JyZWN0IGluZGV4XHJcbiAgICAgICAgICBydW5uZXIudW5zY2hlZHVsZSgpXHJcbiAgICAgICAgICAtLWlcclxuICAgICAgICAgIC0tbGVuXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmFzaWNhbGx5OiB3ZSBjb250aW51ZSB3aGVuIHRoZXJlIGFyZSBydW5uZXJzIHJpZ2h0IGZyb20gdXMgaW4gdGltZVxyXG4gICAgLy8gd2hlbiAtLT4sIGFuZCB3aGVuIHJ1bm5lcnMgYXJlIGxlZnQgZnJvbSB1cyB3aGVuIDwtLVxyXG4gICAgaWYgKChydW5uZXJzTGVmdCAmJiAhKHRoaXMuX3NwZWVkIDwgMCAmJiB0aGlzLl90aW1lID09PSAwKSkgfHwgKHRoaXMuX3J1bm5lcklkcy5sZW5ndGggJiYgdGhpcy5fc3BlZWQgPCAwICYmIHRoaXMuX3RpbWUgPiAwKSkge1xyXG4gICAgICB0aGlzLl9jb250aW51ZSgpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBhdXNlKClcclxuICAgICAgdGhpcy5maXJlKCdmaW5pc2hlZCcpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIENoZWNrcyBpZiB3ZSBhcmUgcnVubmluZyBhbmQgY29udGludWVzIHRoZSBhbmltYXRpb25cclxuICBfY29udGludWUgKGltbWVkaWF0ZVN0ZXAgPSBmYWxzZSkge1xyXG4gICAgQW5pbWF0b3IuY2FuY2VsRnJhbWUodGhpcy5fbmV4dEZyYW1lKVxyXG4gICAgdGhpcy5fbmV4dEZyYW1lID0gbnVsbFxyXG5cclxuICAgIGlmIChpbW1lZGlhdGVTdGVwKSByZXR1cm4gdGhpcy5fc3RlcEltbWVkaWF0ZSgpXHJcbiAgICBpZiAodGhpcy5fcGF1c2VkKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIHRoaXMuX25leHRGcmFtZSA9IEFuaW1hdG9yLmZyYW1lKHRoaXMuX3N0ZXApXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgYWN0aXZlICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuX25leHRGcmFtZVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBFbGVtZW50OiB7XHJcbiAgICB0aW1lbGluZTogZnVuY3Rpb24gKHRpbWVsaW5lKSB7XHJcbiAgICAgIGlmICh0aW1lbGluZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmUgPSAodGhpcy5fdGltZWxpbmUgfHwgbmV3IFRpbWVsaW5lKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmUgPSB0aW1lbGluZVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0pXHJcbiIsImltcG9ydCB7IENvbnRyb2xsZXIsIEVhc2UsIFN0ZXBwZXIgfSBmcm9tICcuL0NvbnRyb2xsZXIuanMnXHJcbmltcG9ydCB7IGV4dGVuZCwgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBmcm9tLCB0byB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9ncmFkaWVudGVkLmpzJ1xyXG5pbXBvcnQgeyBnZXRPcmlnaW4gfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgbm9vcCwgdGltZWxpbmUgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvZGVmYXVsdHMuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCB7IHJ4LCByeSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9jaXJjbGVkLmpzJ1xyXG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9BbmltYXRvci5qcydcclxuaW1wb3J0IEJveCBmcm9tICcuLi90eXBlcy9Cb3guanMnXHJcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi90eXBlcy9FdmVudFRhcmdldC5qcydcclxuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi90eXBlcy9NYXRyaXguanMnXHJcbmltcG9ydCBNb3JwaGFibGUsIHsgVHJhbnNmb3JtQmFnIH0gZnJvbSAnLi9Nb3JwaGFibGUuanMnXHJcbmltcG9ydCBQb2ludCBmcm9tICcuLi90eXBlcy9Qb2ludC5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcbmltcG9ydCBUaW1lbGluZSBmcm9tICcuL1RpbWVsaW5lLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVubmVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XHJcbiAgICBzdXBlcigpXHJcblxyXG4gICAgLy8gU3RvcmUgYSB1bmlxdWUgaWQgb24gdGhlIHJ1bm5lciwgc28gdGhhdCB3ZSBjYW4gaWRlbnRpZnkgaXQgbGF0ZXJcclxuICAgIHRoaXMuaWQgPSBSdW5uZXIuaWQrK1xyXG5cclxuICAgIC8vIEVuc3VyZSBhIGRlZmF1bHQgdmFsdWVcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zID09IG51bGxcclxuICAgICAgPyB0aW1lbGluZS5kdXJhdGlvblxyXG4gICAgICA6IG9wdGlvbnNcclxuXHJcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBnZXQgYSBjb250cm9sbGVyXHJcbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbidcclxuICAgICAgPyBuZXcgQ29udHJvbGxlcihvcHRpb25zKVxyXG4gICAgICA6IG9wdGlvbnNcclxuXHJcbiAgICAvLyBEZWNsYXJlIGFsbCBvZiB0aGUgdmFyaWFibGVzXHJcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxyXG4gICAgdGhpcy5fdGltZWxpbmUgPSBudWxsXHJcbiAgICB0aGlzLmRvbmUgPSBmYWxzZVxyXG4gICAgdGhpcy5fcXVldWUgPSBbXVxyXG5cclxuICAgIC8vIFdvcmsgb3V0IHRoZSBzdGVwcGVyIGFuZCB0aGUgZHVyYXRpb25cclxuICAgIHRoaXMuX2R1cmF0aW9uID0gdHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInICYmIG9wdGlvbnNcclxuICAgIHRoaXMuX2lzRGVjbGFyYXRpdmUgPSBvcHRpb25zIGluc3RhbmNlb2YgQ29udHJvbGxlclxyXG4gICAgdGhpcy5fc3RlcHBlciA9IHRoaXMuX2lzRGVjbGFyYXRpdmUgPyBvcHRpb25zIDogbmV3IEVhc2UoKVxyXG5cclxuICAgIC8vIFdlIGNvcHkgdGhlIGN1cnJlbnQgdmFsdWVzIGZyb20gdGhlIHRpbWVsaW5lIGJlY2F1c2UgdGhleSBjYW4gY2hhbmdlXHJcbiAgICB0aGlzLl9oaXN0b3J5ID0ge31cclxuXHJcbiAgICAvLyBTdG9yZSB0aGUgc3RhdGUgb2YgdGhlIHJ1bm5lclxyXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZVxyXG4gICAgdGhpcy5fdGltZSA9IDBcclxuICAgIHRoaXMuX2xhc3RUaW1lID0gMFxyXG5cclxuICAgIC8vIEF0IGNyZWF0aW9uLCB0aGUgcnVubmVyIGlzIGluIHJlc2V0ZWQgc3RhdGVcclxuICAgIHRoaXMuX3Jlc2V0ZWQgPSB0cnVlXHJcblxyXG4gICAgLy8gU2F2ZSB0cmFuc2Zvcm1zIGFwcGxpZWQgdG8gdGhpcyBydW5uZXJcclxuICAgIHRoaXMudHJhbnNmb3JtcyA9IG5ldyBNYXRyaXgoKVxyXG4gICAgdGhpcy50cmFuc2Zvcm1JZCA9IDFcclxuXHJcbiAgICAvLyBMb29waW5nIHZhcmlhYmxlc1xyXG4gICAgdGhpcy5faGF2ZVJldmVyc2VkID0gZmFsc2VcclxuICAgIHRoaXMuX3JldmVyc2UgPSBmYWxzZVxyXG4gICAgdGhpcy5fbG9vcHNEb25lID0gMFxyXG4gICAgdGhpcy5fc3dpbmcgPSBmYWxzZVxyXG4gICAgdGhpcy5fd2FpdCA9IDBcclxuICAgIHRoaXMuX3RpbWVzID0gMVxyXG5cclxuICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsXHJcblxyXG4gICAgLy8gU3RvcmVzIGhvdyBsb25nIGEgcnVubmVyIGlzIHN0b3JlZCBhZnRlciBiZWVpbmcgZG9uZVxyXG4gICAgdGhpcy5fcGVyc2lzdCA9IHRoaXMuX2lzRGVjbGFyYXRpdmUgPyB0cnVlIDogbnVsbFxyXG4gIH1cclxuXHJcbiAgLypcclxuICBSdW5uZXIgRGVmaW5pdGlvbnNcclxuICA9PT09PT09PT09PT09PT09PT1cclxuICBUaGVzZSBtZXRob2RzIGhlbHAgdXMgZGVmaW5lIHRoZSBydW50aW1lIGJlaGF2aW91ciBvZiB0aGUgUnVubmVyIG9yIHRoZXlcclxuICBoZWxwIHVzIG1ha2UgbmV3IHJ1bm5lcnMgZnJvbSB0aGUgY3VycmVudCBydW5uZXJcclxuICAqL1xyXG5cclxuICBlbGVtZW50IChlbGVtZW50KSB7XHJcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSByZXR1cm4gdGhpcy5fZWxlbWVudFxyXG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcclxuICAgIGVsZW1lbnQuX3ByZXBhcmVSdW5uZXIoKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHRpbWVsaW5lICh0aW1lbGluZSkge1xyXG4gICAgLy8gY2hlY2sgZXhwbGljaXRseSBmb3IgdW5kZWZpbmVkIHNvIHdlIGNhbiBzZXQgdGhlIHRpbWVsaW5lIHRvIG51bGxcclxuICAgIGlmICh0eXBlb2YgdGltZWxpbmUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcy5fdGltZWxpbmVcclxuICAgIHRoaXMuX3RpbWVsaW5lID0gdGltZWxpbmVcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBhbmltYXRlIChkdXJhdGlvbiwgZGVsYXksIHdoZW4pIHtcclxuICAgIHZhciBvID0gUnVubmVyLnNhbml0aXNlKGR1cmF0aW9uLCBkZWxheSwgd2hlbilcclxuICAgIHZhciBydW5uZXIgPSBuZXcgUnVubmVyKG8uZHVyYXRpb24pXHJcbiAgICBpZiAodGhpcy5fdGltZWxpbmUpIHJ1bm5lci50aW1lbGluZSh0aGlzLl90aW1lbGluZSlcclxuICAgIGlmICh0aGlzLl9lbGVtZW50KSBydW5uZXIuZWxlbWVudCh0aGlzLl9lbGVtZW50KVxyXG4gICAgcmV0dXJuIHJ1bm5lci5sb29wKG8pLnNjaGVkdWxlKG8uZGVsYXksIG8ud2hlbilcclxuICB9XHJcblxyXG4gIHNjaGVkdWxlICh0aW1lbGluZSwgZGVsYXksIHdoZW4pIHtcclxuICAgIC8vIFRoZSB1c2VyIGRvZXNuJ3QgbmVlZCB0byBwYXNzIGEgdGltZWxpbmUgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxyXG4gICAgaWYgKCEodGltZWxpbmUgaW5zdGFuY2VvZiBUaW1lbGluZSkpIHtcclxuICAgICAgd2hlbiA9IGRlbGF5XHJcbiAgICAgIGRlbGF5ID0gdGltZWxpbmVcclxuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKClcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGVyZSBpcyBubyB0aW1lbGluZSwgeWVsbCBhdCB0aGUgdXNlci4uLlxyXG4gICAgaWYgKCF0aW1lbGluZSkge1xyXG4gICAgICB0aHJvdyBFcnJvcignUnVubmVyIGNhbm5vdCBiZSBzY2hlZHVsZWQgd2l0aG91dCB0aW1lbGluZScpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2NoZWR1bGUgdGhlIHJ1bm5lciBvbiB0aGUgdGltZWxpbmUgcHJvdmlkZWRcclxuICAgIHRpbWVsaW5lLnNjaGVkdWxlKHRoaXMsIGRlbGF5LCB3aGVuKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHVuc2NoZWR1bGUgKCkge1xyXG4gICAgdmFyIHRpbWVsaW5lID0gdGhpcy50aW1lbGluZSgpXHJcbiAgICB0aW1lbGluZSAmJiB0aW1lbGluZS51bnNjaGVkdWxlKHRoaXMpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgbG9vcCAodGltZXMsIHN3aW5nLCB3YWl0KSB7XHJcbiAgICAvLyBEZWFsIHdpdGggdGhlIHVzZXIgcGFzc2luZyBpbiBhbiBvYmplY3RcclxuICAgIGlmICh0eXBlb2YgdGltZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHN3aW5nID0gdGltZXMuc3dpbmdcclxuICAgICAgd2FpdCA9IHRpbWVzLndhaXRcclxuICAgICAgdGltZXMgPSB0aW1lcy50aW1lc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNhbml0aXNlIHRoZSB2YWx1ZXMgYW5kIHN0b3JlIHRoZW1cclxuICAgIHRoaXMuX3RpbWVzID0gdGltZXMgfHwgSW5maW5pdHlcclxuICAgIHRoaXMuX3N3aW5nID0gc3dpbmcgfHwgZmFsc2VcclxuICAgIHRoaXMuX3dhaXQgPSB3YWl0IHx8IDBcclxuXHJcbiAgICAvLyBBbGxvdyB0cnVlIHRvIGJlIHBhc3NlZFxyXG4gICAgaWYgKHRoaXMuX3RpbWVzID09PSB0cnVlKSB7IHRoaXMuX3RpbWVzID0gSW5maW5pdHkgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBkZWxheSAoZGVsYXkpIHtcclxuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoMCwgZGVsYXkpXHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIEJhc2ljIEZ1bmN0aW9uYWxpdHlcclxuICA9PT09PT09PT09PT09PT09PT09XHJcbiAgVGhlc2UgbWV0aG9kcyBhbGxvdyB1cyB0byBhdHRhY2ggYmFzaWMgZnVuY3Rpb25zIHRvIHRoZSBydW5uZXIgZGlyZWN0bHlcclxuICAqL1xyXG5cclxuICBxdWV1ZSAoaW5pdEZuLCBydW5GbiwgcmV0YXJnZXRGbiwgaXNUcmFuc2Zvcm0pIHtcclxuICAgIHRoaXMuX3F1ZXVlLnB1c2goe1xyXG4gICAgICBpbml0aWFsaXNlcjogaW5pdEZuIHx8IG5vb3AsXHJcbiAgICAgIHJ1bm5lcjogcnVuRm4gfHwgbm9vcCxcclxuICAgICAgcmV0YXJnZXQ6IHJldGFyZ2V0Rm4sXHJcbiAgICAgIGlzVHJhbnNmb3JtOiBpc1RyYW5zZm9ybSxcclxuICAgICAgaW5pdGlhbGlzZWQ6IGZhbHNlLFxyXG4gICAgICBmaW5pc2hlZDogZmFsc2VcclxuICAgIH0pXHJcbiAgICB2YXIgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKClcclxuICAgIHRpbWVsaW5lICYmIHRoaXMudGltZWxpbmUoKS5fY29udGludWUoKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGR1cmluZyAoZm4pIHtcclxuICAgIHJldHVybiB0aGlzLnF1ZXVlKG51bGwsIGZuKVxyXG4gIH1cclxuXHJcbiAgYWZ0ZXIgKGZuKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vbignZmluaXNoZWQnLCBmbilcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgUnVubmVyIGFuaW1hdGlvbiBtZXRob2RzXHJcbiAgPT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgQ29udHJvbCBob3cgdGhlIGFuaW1hdGlvbiBwbGF5c1xyXG4gICovXHJcblxyXG4gIHRpbWUgKHRpbWUpIHtcclxuICAgIGlmICh0aW1lID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RpbWVcclxuICAgIH1cclxuICAgIGNvbnN0IGR0ID0gdGltZSAtIHRoaXMuX3RpbWVcclxuICAgIHRoaXMuc3RlcChkdClcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBkdXJhdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdGltZXMgKiAodGhpcy5fd2FpdCArIHRoaXMuX2R1cmF0aW9uKSAtIHRoaXMuX3dhaXRcclxuICB9XHJcblxyXG4gIGxvb3BzIChwKSB7XHJcbiAgICB2YXIgbG9vcER1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKyB0aGlzLl93YWl0XHJcbiAgICBpZiAocCA9PSBudWxsKSB7XHJcbiAgICAgIHZhciBsb29wc0RvbmUgPSBNYXRoLmZsb29yKHRoaXMuX3RpbWUgLyBsb29wRHVyYXRpb24pXHJcbiAgICAgIHZhciByZWxhdGl2ZVRpbWUgPSAodGhpcy5fdGltZSAtIGxvb3BzRG9uZSAqIGxvb3BEdXJhdGlvbilcclxuICAgICAgdmFyIHBvc2l0aW9uID0gcmVsYXRpdmVUaW1lIC8gdGhpcy5fZHVyYXRpb25cclxuICAgICAgcmV0dXJuIE1hdGgubWluKGxvb3BzRG9uZSArIHBvc2l0aW9uLCB0aGlzLl90aW1lcylcclxuICAgIH1cclxuICAgIHZhciB3aG9sZSA9IE1hdGguZmxvb3IocClcclxuICAgIHZhciBwYXJ0aWFsID0gcCAlIDFcclxuICAgIHZhciB0aW1lID0gbG9vcER1cmF0aW9uICogd2hvbGUgKyB0aGlzLl9kdXJhdGlvbiAqIHBhcnRpYWxcclxuICAgIHJldHVybiB0aGlzLnRpbWUodGltZSlcclxuICB9XHJcblxyXG4gIHBlcnNpc3QgKGR0T3JGb3JldmVyKSB7XHJcbiAgICBpZiAoZHRPckZvcmV2ZXIgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3BlcnNpc3RcclxuICAgIHRoaXMuX3BlcnNpc3QgPSBkdE9yRm9yZXZlclxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHBvc2l0aW9uIChwKSB7XHJcbiAgICAvLyBHZXQgYWxsIG9mIHRoZSB2YXJpYWJsZXMgd2UgbmVlZFxyXG4gICAgdmFyIHggPSB0aGlzLl90aW1lXHJcbiAgICB2YXIgZCA9IHRoaXMuX2R1cmF0aW9uXHJcbiAgICB2YXIgdyA9IHRoaXMuX3dhaXRcclxuICAgIHZhciB0ID0gdGhpcy5fdGltZXNcclxuICAgIHZhciBzID0gdGhpcy5fc3dpbmdcclxuICAgIHZhciByID0gdGhpcy5fcmV2ZXJzZVxyXG4gICAgdmFyIHBvc2l0aW9uXHJcblxyXG4gICAgaWYgKHAgPT0gbnVsbCkge1xyXG4gICAgICAvKlxyXG4gICAgICBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgdGltZSB0byBhIHBvc2l0aW9uIGluIHRoZSByYW5nZSBbMCwgMV1cclxuICAgICAgVGhlIGZ1bGwgZXhwbGFuYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoaXMgZGVzbW9zIGRlbW9uc3RyYXRpb25cclxuICAgICAgICBodHRwczovL3d3dy5kZXNtb3MuY29tL2NhbGN1bGF0b3IvdTRmYmF2Z2NoZVxyXG4gICAgICBUaGUgbG9naWMgaXMgc2xpZ2h0bHkgc2ltcGxpZmllZCBoZXJlIGJlY2F1c2Ugd2UgY2FuIHVzZSBib29sZWFuc1xyXG4gICAgICAqL1xyXG5cclxuICAgICAgLy8gRmlndXJlIG91dCB0aGUgdmFsdWUgd2l0aG91dCB0aGlua2luZyBhYm91dCB0aGUgc3RhcnQgb3IgZW5kIHRpbWVcclxuICAgICAgY29uc3QgZiA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIHN3aW5naW5nID0gcyAqIE1hdGguZmxvb3IoeCAlICgyICogKHcgKyBkKSkgLyAodyArIGQpKVxyXG4gICAgICAgIHZhciBiYWNrd2FyZHMgPSAoc3dpbmdpbmcgJiYgIXIpIHx8ICghc3dpbmdpbmcgJiYgcilcclxuICAgICAgICB2YXIgdW5jbGlwZWQgPSBNYXRoLnBvdygtMSwgYmFja3dhcmRzKSAqICh4ICUgKHcgKyBkKSkgLyBkICsgYmFja3dhcmRzXHJcbiAgICAgICAgdmFyIGNsaXBwZWQgPSBNYXRoLm1heChNYXRoLm1pbih1bmNsaXBlZCwgMSksIDApXHJcbiAgICAgICAgcmV0dXJuIGNsaXBwZWRcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmlndXJlIG91dCB0aGUgdmFsdWUgYnkgaW5jb3Jwb3JhdGluZyB0aGUgc3RhcnQgdGltZVxyXG4gICAgICB2YXIgZW5kVGltZSA9IHQgKiAodyArIGQpIC0gd1xyXG4gICAgICBwb3NpdGlvbiA9IHggPD0gMCA/IE1hdGgucm91bmQoZigxZS01KSlcclxuICAgICAgICA6IHggPCBlbmRUaW1lID8gZih4KVxyXG4gICAgICAgIDogTWF0aC5yb3VuZChmKGVuZFRpbWUgLSAxZS01KSlcclxuICAgICAgcmV0dXJuIHBvc2l0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgLy8gV29yayBvdXQgdGhlIGxvb3BzIGRvbmUgYW5kIGFkZCB0aGUgcG9zaXRpb24gdG8gdGhlIGxvb3BzIGRvbmVcclxuICAgIHZhciBsb29wc0RvbmUgPSBNYXRoLmZsb29yKHRoaXMubG9vcHMoKSlcclxuICAgIHZhciBzd2luZ0ZvcndhcmQgPSBzICYmIChsb29wc0RvbmUgJSAyID09PSAwKVxyXG4gICAgdmFyIGZvcndhcmRzID0gKHN3aW5nRm9yd2FyZCAmJiAhcikgfHwgKHIgJiYgc3dpbmdGb3J3YXJkKVxyXG4gICAgcG9zaXRpb24gPSBsb29wc0RvbmUgKyAoZm9yd2FyZHMgPyBwIDogMSAtIHApXHJcbiAgICByZXR1cm4gdGhpcy5sb29wcyhwb3NpdGlvbilcclxuICB9XHJcblxyXG4gIHByb2dyZXNzIChwKSB7XHJcbiAgICBpZiAocCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudGltZShwICogdGhpcy5kdXJhdGlvbigpKVxyXG4gIH1cclxuXHJcbiAgc3RlcCAoZHQpIHtcclxuICAgIC8vIElmIHdlIGFyZSBpbmFjdGl2ZSwgdGhpcyBzdGVwcGVyIGp1c3QgZ2V0cyBza2lwcGVkXHJcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIHRpbWUgYW5kIGdldCB0aGUgbmV3IHBvc2l0aW9uXHJcbiAgICBkdCA9IGR0ID09IG51bGwgPyAxNiA6IGR0XHJcbiAgICB0aGlzLl90aW1lICs9IGR0XHJcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKClcclxuXHJcbiAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIG5lZWQgdG8gcnVuIHRoZSBzdGVwcGVyIGluIHRoaXMgZnJhbWVcclxuICAgIHZhciBydW5uaW5nID0gdGhpcy5fbGFzdFBvc2l0aW9uICE9PSBwb3NpdGlvbiAmJiB0aGlzLl90aW1lID49IDBcclxuICAgIHRoaXMuX2xhc3RQb3NpdGlvbiA9IHBvc2l0aW9uXHJcblxyXG4gICAgLy8gRmlndXJlIG91dCBpZiB3ZSBqdXN0IHN0YXJ0ZWRcclxuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKVxyXG4gICAgdmFyIGp1c3RTdGFydGVkID0gdGhpcy5fbGFzdFRpbWUgPD0gMCAmJiB0aGlzLl90aW1lID4gMFxyXG4gICAgdmFyIGp1c3RGaW5pc2hlZCA9IHRoaXMuX2xhc3RUaW1lIDwgZHVyYXRpb24gJiYgdGhpcy5fdGltZSA+PSBkdXJhdGlvblxyXG5cclxuICAgIHRoaXMuX2xhc3RUaW1lID0gdGhpcy5fdGltZVxyXG4gICAgaWYgKGp1c3RTdGFydGVkKSB7XHJcbiAgICAgIHRoaXMuZmlyZSgnc3RhcnQnLCB0aGlzKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFdvcmsgb3V0IGlmIHRoZSBydW5uZXIgaXMgZmluaXNoZWQgc2V0IHRoZSBkb25lIGZsYWcgaGVyZSBzbyBhbmltYXRpb25zXHJcbiAgICAvLyBrbm93LCB0aGF0IHRoZXkgYXJlIHJ1bm5pbmcgaW4gdGhlIGxhc3Qgc3RlcCAodGhpcyBpcyBnb29kIGZvclxyXG4gICAgLy8gdHJhbnNmb3JtYXRpb25zIHdoaWNoIGNhbiBiZSBtZXJnZWQpXHJcbiAgICB2YXIgZGVjbGFyYXRpdmUgPSB0aGlzLl9pc0RlY2xhcmF0aXZlXHJcbiAgICB0aGlzLmRvbmUgPSAhZGVjbGFyYXRpdmUgJiYgIWp1c3RGaW5pc2hlZCAmJiB0aGlzLl90aW1lID49IGR1cmF0aW9uXHJcblxyXG4gICAgLy8gUnVubmVyIGlzIHJ1bm5pbmcuIFNvIGl0cyBub3QgaW4gcmVzZXRlZCBzdGF0ZSBhbnltb3JlXHJcbiAgICB0aGlzLl9yZXNldGVkID0gZmFsc2VcclxuXHJcbiAgICAvLyBDYWxsIGluaXRpYWxpc2UgYW5kIHRoZSBydW4gZnVuY3Rpb25cclxuICAgIGlmIChydW5uaW5nIHx8IGRlY2xhcmF0aXZlKSB7XHJcbiAgICAgIHRoaXMuX2luaXRpYWxpc2UocnVubmluZylcclxuXHJcbiAgICAgIC8vIGNsZWFyIHRoZSB0cmFuc2Zvcm1zIG9uIHRoaXMgcnVubmVyIHNvIHRoZXkgZG9udCBnZXQgYWRkZWQgYWdhaW4gYW5kIGFnYWluXHJcbiAgICAgIHRoaXMudHJhbnNmb3JtcyA9IG5ldyBNYXRyaXgoKVxyXG4gICAgICB2YXIgY29udmVyZ2VkID0gdGhpcy5fcnVuKGRlY2xhcmF0aXZlID8gZHQgOiBwb3NpdGlvbilcclxuXHJcbiAgICAgIHRoaXMuZmlyZSgnc3RlcCcsIHRoaXMpXHJcbiAgICB9XHJcbiAgICAvLyBjb3JyZWN0IHRoZSBkb25lIGZsYWcgaGVyZVxyXG4gICAgLy8gZGVjbGFyaXRpdmUgYW5pbWF0aW9ucyBpdHNlbGYga25vdyB3aGVuIHRoZXkgY29udmVyZ2VkXHJcbiAgICB0aGlzLmRvbmUgPSB0aGlzLmRvbmUgfHwgKGNvbnZlcmdlZCAmJiBkZWNsYXJhdGl2ZSlcclxuICAgIGlmIChqdXN0RmluaXNoZWQpIHtcclxuICAgICAgdGhpcy5maXJlKCdmaW5pc2hlZCcsIHRoaXMpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgcmVzZXQgKCkge1xyXG4gICAgaWYgKHRoaXMuX3Jlc2V0ZWQpIHJldHVybiB0aGlzXHJcbiAgICB0aGlzLnRpbWUoMClcclxuICAgIHRoaXMuX3Jlc2V0ZWQgPSB0cnVlXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZmluaXNoICgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0ZXAoSW5maW5pdHkpXHJcbiAgfVxyXG5cclxuICByZXZlcnNlIChyZXZlcnNlKSB7XHJcbiAgICB0aGlzLl9yZXZlcnNlID0gcmV2ZXJzZSA9PSBudWxsID8gIXRoaXMuX3JldmVyc2UgOiByZXZlcnNlXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZWFzZSAoZm4pIHtcclxuICAgIHRoaXMuX3N0ZXBwZXIgPSBuZXcgRWFzZShmbilcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBhY3RpdmUgKGVuYWJsZWQpIHtcclxuICAgIGlmIChlbmFibGVkID09IG51bGwpIHJldHVybiB0aGlzLmVuYWJsZWRcclxuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWRcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIFByaXZhdGUgTWV0aG9kc1xyXG4gID09PT09PT09PT09PT09PVxyXG4gIE1ldGhvZHMgdGhhdCBzaG91bGRuJ3QgYmUgdXNlZCBleHRlcm5hbGx5XHJcbiAgKi9cclxuXHJcbiAgLy8gU2F2ZSBhIG1vcnBoZXIgdG8gdGhlIG1vcnBoZXIgbGlzdCBzbyB0aGF0IHdlIGNhbiByZXRhcmdldCBpdCBsYXRlclxyXG4gIF9yZW1lbWJlck1vcnBoZXIgKG1ldGhvZCwgbW9ycGhlcikge1xyXG4gICAgdGhpcy5faGlzdG9yeVttZXRob2RdID0ge1xyXG4gICAgICBtb3JwaGVyOiBtb3JwaGVyLFxyXG4gICAgICBjYWxsZXI6IHRoaXMuX3F1ZXVlW3RoaXMuX3F1ZXVlLmxlbmd0aCAtIDFdXHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2UgaGF2ZSB0byByZXN1bWUgdGhlIHRpbWVsaW5lIGluIGNhc2UgYSBjb250cm9sbGVyXHJcbiAgICAvLyBpcyBhbHJlYWR5IGRvbmUgd2l0aG91dCBiZWVpbmcgZXZlciBydW5cclxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGUuZy4gdGhpcyBpcyBkb25lOlxyXG4gICAgLy8gICAgYW5pbSA9IGVsLmFuaW1hdGUobmV3IFNWRy5TcHJpbmcpXHJcbiAgICAvLyBhbmQgbGF0ZXJcclxuICAgIC8vICAgIGFuaW0ubW92ZSguLi4pXHJcbiAgICBpZiAodGhpcy5faXNEZWNsYXJhdGl2ZSkge1xyXG4gICAgICB2YXIgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKClcclxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucGxheSgpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUcnkgdG8gc2V0IHRoZSB0YXJnZXQgZm9yIGEgbW9ycGhlciBpZiB0aGUgbW9ycGhlciBleGlzdHMsIG90aGVyd2lzZVxyXG4gIC8vIGRvIG5vdGhpbmcgYW5kIHJldHVybiBmYWxzZVxyXG4gIF90cnlSZXRhcmdldCAobWV0aG9kLCB0YXJnZXQsIGV4dHJhKSB7XHJcbiAgICBpZiAodGhpcy5faGlzdG9yeVttZXRob2RdKSB7XHJcbiAgICAgIC8vIGlmIHRoZSBsYXN0IG1ldGhvZCB3YXNudCBldmVuIGluaXRpYWxpc2VkLCB0aHJvdyBpdCBhd2F5XHJcbiAgICAgIGlmICghdGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5pbml0aWFsaXNlZCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcXVldWUuaW5kZXhPZih0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyKVxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLnNwbGljZShpbmRleCwgMSlcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZm9yIHRoZSBjYXNlIG9mIHRyYW5zZm9ybWF0aW9ucywgd2UgdXNlIHRoZSBzcGVjaWFsIHJldGFyZ2V0IGZ1bmN0aW9uXHJcbiAgICAgIC8vIHdoaWNoIGhhcyBhY2Nlc3MgdG8gdGhlIG91dGVyIHNjb3BlXHJcbiAgICAgIGlmICh0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLnJldGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5yZXRhcmdldCh0YXJnZXQsIGV4dHJhKVxyXG4gICAgICAgIC8vIGZvciBldmVyeXRoaW5nIGVsc2UgYSBzaW1wbGUgbW9ycGhlciBjaGFuZ2UgaXMgc3VmZmljaWVudFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX2hpc3RvcnlbbWV0aG9kXS5tb3JwaGVyLnRvKHRhcmdldClcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5maW5pc2hlZCA9IGZhbHNlXHJcbiAgICAgIHZhciB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKVxyXG4gICAgICB0aW1lbGluZSAmJiB0aW1lbGluZS5wbGF5KClcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgLy8gUnVuIGVhY2ggaW5pdGlhbGlzZSBmdW5jdGlvbiBpbiB0aGUgcnVubmVyIGlmIHJlcXVpcmVkXHJcbiAgX2luaXRpYWxpc2UgKHJ1bm5pbmcpIHtcclxuICAgIC8vIElmIHdlIGFyZW4ndCBydW5uaW5nLCB3ZSBzaG91bGRuJ3QgaW5pdGlhbGlzZSB3aGVuIG5vdCBkZWNsYXJhdGl2ZVxyXG4gICAgaWYgKCFydW5uaW5nICYmICF0aGlzLl9pc0RlY2xhcmF0aXZlKSByZXR1cm5cclxuXHJcbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIG9mIHRoZSBpbml0aWFsaXNlcnNcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgaW5pdGlhbGlzZXJcclxuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9xdWV1ZVtpXVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgd2UgbmVlZCB0byBpbml0aWFsaXNlXHJcbiAgICAgIHZhciBuZWVkc0l0ID0gdGhpcy5faXNEZWNsYXJhdGl2ZSB8fCAoIWN1cnJlbnQuaW5pdGlhbGlzZWQgJiYgcnVubmluZylcclxuICAgICAgcnVubmluZyA9ICFjdXJyZW50LmZpbmlzaGVkXHJcblxyXG4gICAgICAvLyBDYWxsIHRoZSBpbml0aWFsaXNlciBpZiB3ZSBuZWVkIHRvXHJcbiAgICAgIGlmIChuZWVkc0l0ICYmIHJ1bm5pbmcpIHtcclxuICAgICAgICBjdXJyZW50LmluaXRpYWxpc2VyLmNhbGwodGhpcylcclxuICAgICAgICBjdXJyZW50LmluaXRpYWxpc2VkID0gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSdW4gZWFjaCBydW4gZnVuY3Rpb24gZm9yIHRoZSBwb3NpdGlvbiBvciBkdCBnaXZlblxyXG4gIF9ydW4gKHBvc2l0aW9uT3JEdCkge1xyXG4gICAgLy8gUnVuIGFsbCBvZiB0aGUgX3F1ZXVlIGRpcmVjdGx5XHJcbiAgICB2YXIgYWxsZmluaXNoZWQgPSB0cnVlXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGZ1bmN0aW9uIHRvIHJ1blxyXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuX3F1ZXVlW2ldXHJcblxyXG4gICAgICAvLyBSdW4gdGhlIGZ1bmN0aW9uIGlmIGl0cyBub3QgZmluaXNoZWQsIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGZpbmlzaGVkXHJcbiAgICAgIC8vIGZsYWcgZm9yIHRoZSBzYWtlIG9mIGRlY2xhcmF0aXZlIF9xdWV1ZVxyXG4gICAgICB2YXIgY29udmVyZ2VkID0gY3VycmVudC5ydW5uZXIuY2FsbCh0aGlzLCBwb3NpdGlvbk9yRHQpXHJcbiAgICAgIGN1cnJlbnQuZmluaXNoZWQgPSBjdXJyZW50LmZpbmlzaGVkIHx8IChjb252ZXJnZWQgPT09IHRydWUpXHJcbiAgICAgIGFsbGZpbmlzaGVkID0gYWxsZmluaXNoZWQgJiYgY3VycmVudC5maW5pc2hlZFxyXG4gICAgfVxyXG5cclxuICAgIC8vIFdlIHJlcG9ydCB3aGVuIGFsbCBvZiB0aGUgY29uc3RydWN0b3JzIGFyZSBmaW5pc2hlZFxyXG4gICAgcmV0dXJuIGFsbGZpbmlzaGVkXHJcbiAgfVxyXG5cclxuICBhZGRUcmFuc2Zvcm0gKHRyYW5zZm9ybSwgaW5kZXgpIHtcclxuICAgIHRoaXMudHJhbnNmb3Jtcy5sbXVsdGlwbHlPKHRyYW5zZm9ybSlcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBjbGVhclRyYW5zZm9ybSAoKSB7XHJcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgTWF0cml4KClcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBLZWVwIHRyYWNrIG9mIGFsbCB0cmFuc2Zvcm1hdGlvbnMgc28gdGhhdCBkZWxldGlvbiBpcyBmYXN0ZXJcclxuICBjbGVhclRyYW5zZm9ybXNGcm9tUXVldWUgKCkge1xyXG4gICAgaWYgKCF0aGlzLmRvbmUgfHwgIXRoaXMuX3RpbWVsaW5lIHx8ICF0aGlzLl90aW1lbGluZS5fcnVubmVySWRzLmluY2x1ZGVzKHRoaXMuaWQpKSB7XHJcbiAgICAgIHRoaXMuX3F1ZXVlID0gdGhpcy5fcXVldWUuZmlsdGVyKChpdGVtKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuICFpdGVtLmlzVHJhbnNmb3JtXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgc2FuaXRpc2UgKGR1cmF0aW9uLCBkZWxheSwgd2hlbikge1xyXG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXHJcbiAgICB2YXIgdGltZXMgPSAxXHJcbiAgICB2YXIgc3dpbmcgPSBmYWxzZVxyXG4gICAgdmFyIHdhaXQgPSAwXHJcbiAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IHRpbWVsaW5lLmR1cmF0aW9uXHJcbiAgICBkZWxheSA9IGRlbGF5IHx8IHRpbWVsaW5lLmRlbGF5XHJcbiAgICB3aGVuID0gd2hlbiB8fCAnbGFzdCdcclxuXHJcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIG9iamVjdCwgdW5wYWNrIHRoZSB2YWx1ZXNcclxuICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICEoZHVyYXRpb24gaW5zdGFuY2VvZiBTdGVwcGVyKSkge1xyXG4gICAgICBkZWxheSA9IGR1cmF0aW9uLmRlbGF5IHx8IGRlbGF5XHJcbiAgICAgIHdoZW4gPSBkdXJhdGlvbi53aGVuIHx8IHdoZW5cclxuICAgICAgc3dpbmcgPSBkdXJhdGlvbi5zd2luZyB8fCBzd2luZ1xyXG4gICAgICB0aW1lcyA9IGR1cmF0aW9uLnRpbWVzIHx8IHRpbWVzXHJcbiAgICAgIHdhaXQgPSBkdXJhdGlvbi53YWl0IHx8IHdhaXRcclxuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbi5kdXJhdGlvbiB8fCB0aW1lbGluZS5kdXJhdGlvblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcclxuICAgICAgZGVsYXk6IGRlbGF5LFxyXG4gICAgICBzd2luZzogc3dpbmcsXHJcbiAgICAgIHRpbWVzOiB0aW1lcyxcclxuICAgICAgd2FpdDogd2FpdCxcclxuICAgICAgd2hlbjogd2hlblxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuUnVubmVyLmlkID0gMFxyXG5cclxuY2xhc3MgRmFrZVJ1bm5lciB7XHJcbiAgY29uc3RydWN0b3IgKHRyYW5zZm9ybXMgPSBuZXcgTWF0cml4KCksIGlkID0gLTEsIGRvbmUgPSB0cnVlKSB7XHJcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zXHJcbiAgICB0aGlzLmlkID0gaWRcclxuICAgIHRoaXMuZG9uZSA9IGRvbmVcclxuICB9XHJcblxyXG4gIGNsZWFyVHJhbnNmb3Jtc0Zyb21RdWV1ZSAoKSB7IH1cclxufVxyXG5cclxuZXh0ZW5kKFsgUnVubmVyLCBGYWtlUnVubmVyIF0sIHtcclxuICBtZXJnZVdpdGggKHJ1bm5lcikge1xyXG4gICAgcmV0dXJuIG5ldyBGYWtlUnVubmVyKFxyXG4gICAgICBydW5uZXIudHJhbnNmb3Jtcy5sbXVsdGlwbHkodGhpcy50cmFuc2Zvcm1zKSxcclxuICAgICAgcnVubmVyLmlkXHJcbiAgICApXHJcbiAgfVxyXG59KVxyXG5cclxuLy8gRmFrZVJ1bm5lci5lbXB0eVJ1bm5lciA9IG5ldyBGYWtlUnVubmVyKClcclxuXHJcbmNvbnN0IGxtdWx0aXBseSA9IChsYXN0LCBjdXJyKSA9PiBsYXN0LmxtdWx0aXBseU8oY3VycilcclxuY29uc3QgZ2V0UnVubmVyVHJhbnNmb3JtID0gKHJ1bm5lcikgPT4gcnVubmVyLnRyYW5zZm9ybXNcclxuXHJcbmZ1bmN0aW9uIG1lcmdlVHJhbnNmb3JtcyAoKSB7XHJcbiAgLy8gRmluZCB0aGUgbWF0cml4IHRvIGFwcGx5IHRvIHRoZSBlbGVtZW50IGFuZCBhcHBseSBpdFxyXG4gIGNvbnN0IHJ1bm5lcnMgPSB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMucnVubmVyc1xyXG4gIGNvbnN0IG5ldFRyYW5zZm9ybSA9IHJ1bm5lcnNcclxuICAgIC5tYXAoZ2V0UnVubmVyVHJhbnNmb3JtKVxyXG4gICAgLnJlZHVjZShsbXVsdGlwbHksIG5ldyBNYXRyaXgoKSlcclxuXHJcbiAgdGhpcy50cmFuc2Zvcm0obmV0VHJhbnNmb3JtKVxyXG5cclxuICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMubWVyZ2UoKVxyXG5cclxuICBpZiAodGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLmxlbmd0aCgpID09PSAxKSB7XHJcbiAgICB0aGlzLl9mcmFtZUlkID0gbnVsbFxyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgUnVubmVyQXJyYXkge1xyXG4gIGNvbnN0cnVjdG9yICgpIHtcclxuICAgIHRoaXMucnVubmVycyA9IFtdXHJcbiAgICB0aGlzLmlkcyA9IFtdXHJcbiAgfVxyXG5cclxuICBhZGQgKHJ1bm5lcikge1xyXG4gICAgaWYgKHRoaXMucnVubmVycy5pbmNsdWRlcyhydW5uZXIpKSByZXR1cm5cclxuICAgIGNvbnN0IGlkID0gcnVubmVyLmlkICsgMVxyXG5cclxuICAgIHRoaXMucnVubmVycy5wdXNoKHJ1bm5lcilcclxuICAgIHRoaXMuaWRzLnB1c2goaWQpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGdldEJ5SUQgKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ydW5uZXJzW3RoaXMuaWRzLmluZGV4T2YoaWQgKyAxKV1cclxuICB9XHJcblxyXG4gIHJlbW92ZSAoaWQpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pZHMuaW5kZXhPZihpZCArIDEpXHJcbiAgICB0aGlzLmlkcy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICB0aGlzLnJ1bm5lcnMuc3BsaWNlKGluZGV4LCAxKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIG1lcmdlICgpIHtcclxuICAgIGxldCBsYXN0UnVubmVyID0gbnVsbFxyXG4gICAgdGhpcy5ydW5uZXJzLmZvckVhY2goKHJ1bm5lciwgaSkgPT4ge1xyXG5cclxuICAgICAgY29uc3QgY29uZGl0aW9uID0gbGFzdFJ1bm5lclxyXG4gICAgICAgICYmIHJ1bm5lci5kb25lICYmIGxhc3RSdW5uZXIuZG9uZVxyXG4gICAgICAgIC8vIGRvbid0IG1lcmdlIHJ1bm5lciB3aGVuIHBlcnNpc3RlZCBvbiB0aW1lbGluZVxyXG4gICAgICAgICYmICghcnVubmVyLl90aW1lbGluZSB8fCAhcnVubmVyLl90aW1lbGluZS5fcnVubmVySWRzLmluY2x1ZGVzKHJ1bm5lci5pZCkpXHJcbiAgICAgICAgJiYgKCFsYXN0UnVubmVyLl90aW1lbGluZSB8fCAhbGFzdFJ1bm5lci5fdGltZWxpbmUuX3J1bm5lcklkcy5pbmNsdWRlcyhsYXN0UnVubmVyLmlkKSlcclxuXHJcbiAgICAgIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICAvLyB0aGUgKzEgaGFwcGVucyBpbiB0aGUgZnVuY3Rpb25cclxuICAgICAgICB0aGlzLnJlbW92ZShydW5uZXIuaWQpXHJcbiAgICAgICAgdGhpcy5lZGl0KGxhc3RSdW5uZXIuaWQsIHJ1bm5lci5tZXJnZVdpdGgobGFzdFJ1bm5lcikpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxhc3RSdW5uZXIgPSBydW5uZXJcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGVkaXQgKGlkLCBuZXdSdW5uZXIpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pZHMuaW5kZXhPZihpZCArIDEpXHJcbiAgICB0aGlzLmlkcy5zcGxpY2UoaW5kZXgsIDEsIGlkICsgMSlcclxuICAgIHRoaXMucnVubmVycy5zcGxpY2UoaW5kZXgsIDEsIG5ld1J1bm5lcilcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBsZW5ndGggKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaWRzLmxlbmd0aFxyXG4gIH1cclxuXHJcbiAgY2xlYXJCZWZvcmUgKGlkKSB7XHJcbiAgICBjb25zdCBkZWxldGVDbnQgPSB0aGlzLmlkcy5pbmRleE9mKGlkICsgMSkgfHwgMVxyXG4gICAgdGhpcy5pZHMuc3BsaWNlKDAsIGRlbGV0ZUNudCwgMClcclxuICAgIHRoaXMucnVubmVycy5zcGxpY2UoMCwgZGVsZXRlQ250LCBuZXcgRmFrZVJ1bm5lcigpKVxyXG4gICAgICAuZm9yRWFjaCgocikgPT4gci5jbGVhclRyYW5zZm9ybXNGcm9tUXVldWUoKSlcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIEVsZW1lbnQ6IHtcclxuICAgIGFuaW1hdGUgKGR1cmF0aW9uLCBkZWxheSwgd2hlbikge1xyXG4gICAgICB2YXIgbyA9IFJ1bm5lci5zYW5pdGlzZShkdXJhdGlvbiwgZGVsYXksIHdoZW4pXHJcbiAgICAgIHZhciB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKVxyXG4gICAgICByZXR1cm4gbmV3IFJ1bm5lcihvLmR1cmF0aW9uKVxyXG4gICAgICAgIC5sb29wKG8pXHJcbiAgICAgICAgLmVsZW1lbnQodGhpcylcclxuICAgICAgICAudGltZWxpbmUodGltZWxpbmUucGxheSgpKVxyXG4gICAgICAgIC5zY2hlZHVsZShvLmRlbGF5LCBvLndoZW4pXHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGF5IChieSwgd2hlbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKDAsIGJ5LCB3aGVuKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIHNlYXJjaGVzIGZvciBhbGwgcnVubmVycyBvbiB0aGUgZWxlbWVudCBhbmQgZGVsZXRlcyB0aGUgb25lc1xyXG4gICAgLy8gd2hpY2ggcnVuIGJlZm9yZSB0aGUgY3VycmVudCBvbmUuIFRoaXMgaXMgYmVjYXVzZSBhYnNvbHV0ZSB0cmFuc2Zvcm1hdGlvbnNcclxuICAgIC8vIG92ZXJ3ZnJpdGUgYW55dGhpbmcgYW55d2F5IHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gd2FzdGUgdGltZSBjb21wdXRpbmdcclxuICAgIC8vIG90aGVyIHJ1bm5lcnNcclxuICAgIF9jbGVhclRyYW5zZm9ybVJ1bm5lcnNCZWZvcmUgKGN1cnJlbnRSdW5uZXIpIHtcclxuICAgICAgdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLmNsZWFyQmVmb3JlKGN1cnJlbnRSdW5uZXIuaWQpXHJcbiAgICB9LFxyXG5cclxuICAgIF9jdXJyZW50VHJhbnNmb3JtIChjdXJyZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMucnVubmVyc1xyXG4gICAgICAgIC8vIHdlIG5lZWQgdGhlIGVxdWFsIHNpZ24gaGVyZSB0byBtYWtlIHN1cmUsIHRoYXQgYWxzbyB0cmFuc2Zvcm1hdGlvbnNcclxuICAgICAgICAvLyBvbiB0aGUgc2FtZSBydW5uZXIgd2hpY2ggZXhlY3V0ZSBiZWZvcmUgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXJlXHJcbiAgICAgICAgLy8gdGFrZW4gaW50byBhY2NvdW50XHJcbiAgICAgICAgLmZpbHRlcigocnVubmVyKSA9PiBydW5uZXIuaWQgPD0gY3VycmVudC5pZClcclxuICAgICAgICAubWFwKGdldFJ1bm5lclRyYW5zZm9ybSlcclxuICAgICAgICAucmVkdWNlKGxtdWx0aXBseSwgbmV3IE1hdHJpeCgpKVxyXG4gICAgfSxcclxuXHJcbiAgICBfYWRkUnVubmVyIChydW5uZXIpIHtcclxuICAgICAgdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLmFkZChydW5uZXIpXHJcblxyXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcnVubmVyIG1lcmdlIGlzIGV4ZWN1dGVkIGF0IHRoZSB2ZXJ5IGVuZCBvZlxyXG4gICAgICAvLyBhbGwgQW5pbWF0b3IgZnVuY3Rpb25zLiBUaGF0cyB3aHkgd2UgdXNlIGltbWVkaWF0ZSBoZXJlIHRvIGV4ZWN1dGVcclxuICAgICAgLy8gdGhlIG1lcmdlIHJpZ2h0IGFmdGVyIGFsbCBmcmFtZXMgYXJlIHJ1blxyXG4gICAgICBBbmltYXRvci5jYW5jZWxJbW1lZGlhdGUodGhpcy5fZnJhbWVJZClcclxuICAgICAgdGhpcy5fZnJhbWVJZCA9IEFuaW1hdG9yLmltbWVkaWF0ZShtZXJnZVRyYW5zZm9ybXMuYmluZCh0aGlzKSlcclxuICAgIH0sXHJcblxyXG4gICAgX3ByZXBhcmVSdW5uZXIgKCkge1xyXG4gICAgICBpZiAodGhpcy5fZnJhbWVJZCA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzID0gbmV3IFJ1bm5lckFycmF5KClcclxuICAgICAgICAgIC5hZGQobmV3IEZha2VSdW5uZXIobmV3IE1hdHJpeCh0aGlzKSkpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5leHRlbmQoUnVubmVyLCB7XHJcbiAgYXR0ciAoYSwgdikge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVBdHRyKCdhdHRyJywgYSwgdilcclxuICB9LFxyXG5cclxuICAvLyBBZGQgYW5pbWF0YWJsZSBzdHlsZXNcclxuICBjc3MgKHMsIHYpIHtcclxuICAgIHJldHVybiB0aGlzLnN0eWxlQXR0cignY3NzJywgcywgdilcclxuICB9LFxyXG5cclxuICBzdHlsZUF0dHIgKHR5cGUsIG5hbWUsIHZhbCkge1xyXG4gICAgLy8gYXBwbHkgYXR0cmlidXRlcyBpbmRpdmlkdWFsbHlcclxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcclxuICAgICAgICB0aGlzLnN0eWxlQXR0cih0eXBlLCBrZXksIG5hbWVba2V5XSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byh2YWwpXHJcblxyXG4gICAgdGhpcy5xdWV1ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG1vcnBoZXIgPSBtb3JwaGVyLmZyb20odGhpcy5lbGVtZW50KClbdHlwZV0obmFtZSkpXHJcbiAgICB9LCBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudCgpW3R5cGVdKG5hbWUsIG1vcnBoZXIuYXQocG9zKSlcclxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfSxcclxuXHJcbiAgem9vbSAobGV2ZWwsIHBvaW50KSB7XHJcbiAgICBpZiAodGhpcy5fdHJ5UmV0YXJnZXQoJ3pvb20nLCB0bywgcG9pbnQpKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIHZhciBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byhuZXcgU1ZHTnVtYmVyKGxldmVsKSlcclxuXHJcbiAgICB0aGlzLnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgbW9ycGhlciA9IG1vcnBoZXIuZnJvbSh0aGlzLmVsZW1lbnQoKS56b29tKCkpXHJcbiAgICB9LCBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudCgpLnpvb20obW9ycGhlci5hdChwb3MpLCBwb2ludClcclxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXHJcbiAgICB9LCBmdW5jdGlvbiAobmV3TGV2ZWwsIG5ld1BvaW50KSB7XHJcbiAgICAgIHBvaW50ID0gbmV3UG9pbnRcclxuICAgICAgbW9ycGhlci50byhuZXdMZXZlbClcclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKCd6b29tJywgbW9ycGhlcilcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICoqIGFic29sdXRlIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAqKi9cclxuXHJcbiAgLy9cclxuICAvLyBNIHYgLS0tLS18LS0tLS0oRCBNIHYgPSBGIHYpLS0tLS0tfC0tLS0tPiAgVCB2XHJcbiAgLy9cclxuICAvLyAxLiBkZWZpbmUgdGhlIGZpbmFsIHN0YXRlIChUKSBhbmQgZGVjb21wb3NlIGl0IChvbmNlKVxyXG4gIC8vICAgIHQgPSBbdHgsIHR5LCB0aGUsIGxhbSwgc3ksIHN4XVxyXG4gIC8vIDIuIG9uIGV2ZXJ5IGZyYW1lOiBwdWxsIHRoZSBjdXJyZW50IHN0YXRlIG9mIGFsbCBwcmV2aW91cyB0cmFuc2Zvcm1zXHJcbiAgLy8gICAgKE0gLSBtIGNhbiBjaGFuZ2UpXHJcbiAgLy8gICBhbmQgdGhlbiB3cml0ZSB0aGlzIGFzIG0gPSBbdHgwLCB0eTAsIHRoZTAsIGxhbTAsIHN5MCwgc3gwXVxyXG4gIC8vIDMuIEZpbmQgdGhlIGludGVycG9sYXRlZCBtYXRyaXggRihwb3MpID0gbSArIHBvcyAqICh0IC0gbSlcclxuICAvLyAgIC0gTm90ZSBGKDApID0gTVxyXG4gIC8vICAgLSBOb3RlIEYoMSkgPSBUXHJcbiAgLy8gNC4gTm93IHlvdSBnZXQgdGhlIGRlbHRhIG1hdHJpeCBhcyBhIHJlc3VsdDogRCA9IEYgKiBpbnYoTSlcclxuXHJcbiAgdHJhbnNmb3JtICh0cmFuc2Zvcm1zLCByZWxhdGl2ZSwgYWZmaW5lKSB7XHJcbiAgICAvLyBJZiB3ZSBoYXZlIGEgZGVjbGFyYXRpdmUgZnVuY3Rpb24sIHdlIHNob3VsZCByZXRhcmdldCBpdCBpZiBwb3NzaWJsZVxyXG4gICAgcmVsYXRpdmUgPSB0cmFuc2Zvcm1zLnJlbGF0aXZlIHx8IHJlbGF0aXZlXHJcbiAgICBpZiAodGhpcy5faXNEZWNsYXJhdGl2ZSAmJiAhcmVsYXRpdmUgJiYgdGhpcy5fdHJ5UmV0YXJnZXQoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybXMpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2UgdGhlIHBhcmFtZXRlcnNcclxuICAgIHZhciBpc01hdHJpeCA9IE1hdHJpeC5pc01hdHJpeExpa2UodHJhbnNmb3JtcylcclxuICAgIGFmZmluZSA9IHRyYW5zZm9ybXMuYWZmaW5lICE9IG51bGxcclxuICAgICAgPyB0cmFuc2Zvcm1zLmFmZmluZVxyXG4gICAgICA6IChhZmZpbmUgIT0gbnVsbCA/IGFmZmluZSA6ICFpc01hdHJpeClcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBtb3JlcGhlciBhbmQgc2V0IGl0cyB0eXBlXHJcbiAgICBjb25zdCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKVxyXG4gICAgICAudHlwZShhZmZpbmUgPyBUcmFuc2Zvcm1CYWcgOiBNYXRyaXgpXHJcblxyXG4gICAgbGV0IG9yaWdpblxyXG4gICAgbGV0IGVsZW1lbnRcclxuICAgIGxldCBjdXJyZW50XHJcbiAgICBsZXQgY3VycmVudEFuZ2xlXHJcbiAgICBsZXQgc3RhcnRUcmFuc2Zvcm1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXR1cCAoKSB7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSBlbGVtZW50IGFuZCBvcmlnaW4gaXMgZGVmaW5lZFxyXG4gICAgICBlbGVtZW50ID0gZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQoKVxyXG4gICAgICBvcmlnaW4gPSBvcmlnaW4gfHwgZ2V0T3JpZ2luKHRyYW5zZm9ybXMsIGVsZW1lbnQpXHJcblxyXG4gICAgICBzdGFydFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgocmVsYXRpdmUgPyB1bmRlZmluZWQgOiBlbGVtZW50KVxyXG5cclxuICAgICAgLy8gYWRkIHRoZSBydW5uZXIgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIG1lcmdlIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgICBlbGVtZW50Ll9hZGRSdW5uZXIodGhpcylcclxuXHJcbiAgICAgIC8vIERlYWN0aXZhdGUgYWxsIHRyYW5zZm9ybXMgdGhhdCBoYXZlIHJ1biBzbyBmYXIgaWYgd2UgYXJlIGFic29sdXRlXHJcbiAgICAgIGlmICghcmVsYXRpdmUpIHtcclxuICAgICAgICBlbGVtZW50Ll9jbGVhclRyYW5zZm9ybVJ1bm5lcnNCZWZvcmUodGhpcylcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJ1biAocG9zKSB7XHJcbiAgICAgIC8vIGNsZWFyIGFsbCBvdGhlciB0cmFuc2Zvcm1zIGJlZm9yZSB0aGlzIGluIGNhc2Ugc29tZXRoaW5nIGlzIHNhdmVkXHJcbiAgICAgIC8vIG9uIHRoaXMgcnVubmVyLiBXZSBhcmUgYWJzb2x1dGUuIFdlIGRvbnQgbmVlZCB0aGVzZSFcclxuICAgICAgaWYgKCFyZWxhdGl2ZSkgdGhpcy5jbGVhclRyYW5zZm9ybSgpXHJcblxyXG4gICAgICBjb25zdCB7IHgsIHkgfSA9IG5ldyBQb2ludChvcmlnaW4pLnRyYW5zZm9ybShlbGVtZW50Ll9jdXJyZW50VHJhbnNmb3JtKHRoaXMpKVxyXG5cclxuICAgICAgbGV0IHRhcmdldCA9IG5ldyBNYXRyaXgoeyAuLi50cmFuc2Zvcm1zLCBvcmlnaW46IFsgeCwgeSBdIH0pXHJcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgY3VycmVudFxyXG4gICAgICAgID8gY3VycmVudFxyXG4gICAgICAgIDogc3RhcnRUcmFuc2Zvcm1cclxuXHJcbiAgICAgIGlmIChhZmZpbmUpIHtcclxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuZGVjb21wb3NlKHgsIHkpXHJcbiAgICAgICAgc3RhcnQgPSBzdGFydC5kZWNvbXBvc2UoeCwgeSlcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGFuZCB0YXJnZXQgYW5nbGUgYXMgaXQgd2FzIHNldFxyXG4gICAgICAgIGNvbnN0IHJUYXJnZXQgPSB0YXJnZXQucm90YXRlXHJcbiAgICAgICAgY29uc3QgckN1cnJlbnQgPSBzdGFydC5yb3RhdGVcclxuXHJcbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgc2hvcnRlc3QgcGF0aCB0byByb3RhdGUgZGlyZWN0bHlcclxuICAgICAgICBjb25zdCBwb3NzaWJpbGl0aWVzID0gWyByVGFyZ2V0IC0gMzYwLCByVGFyZ2V0LCByVGFyZ2V0ICsgMzYwIF1cclxuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBwb3NzaWJpbGl0aWVzLm1hcChhID0+IE1hdGguYWJzKGEgLSByQ3VycmVudCkpXHJcbiAgICAgICAgY29uc3Qgc2hvcnRlc3QgPSBNYXRoLm1pbiguLi5kaXN0YW5jZXMpXHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBkaXN0YW5jZXMuaW5kZXhPZihzaG9ydGVzdClcclxuICAgICAgICB0YXJnZXQucm90YXRlID0gcG9zc2liaWxpdGllc1tpbmRleF1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBiZSBjYXJlZnVsIGhlcmUgbm90IHRvIG92ZXJ3cml0ZSB0aGUgcm90YXRpb25cclxuICAgICAgICAvLyB3aXRoIHRoZSByb3RhdGUgbWV0aG9kIG9mIE1hdHJpeFxyXG4gICAgICAgIGlmICghaXNNYXRyaXgpIHtcclxuICAgICAgICAgIHRhcmdldC5yb3RhdGUgPSB0cmFuc2Zvcm1zLnJvdGF0ZSB8fCAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pc0RlY2xhcmF0aXZlICYmIGN1cnJlbnRBbmdsZSkge1xyXG4gICAgICAgICAgc3RhcnQucm90YXRlID0gY3VycmVudEFuZ2xlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBtb3JwaGVyLmZyb20oc3RhcnQpXHJcbiAgICAgIG1vcnBoZXIudG8odGFyZ2V0KVxyXG5cclxuICAgICAgY29uc3QgYWZmaW5lUGFyYW1ldGVycyA9IG1vcnBoZXIuYXQocG9zKVxyXG4gICAgICBjdXJyZW50QW5nbGUgPSBhZmZpbmVQYXJhbWV0ZXJzLnJvdGF0ZVxyXG4gICAgICBjdXJyZW50ID0gbmV3IE1hdHJpeChhZmZpbmVQYXJhbWV0ZXJzKVxyXG5cclxuICAgICAgdGhpcy5hZGRUcmFuc2Zvcm0oY3VycmVudClcclxuICAgICAgZWxlbWVudC5fYWRkUnVubmVyKHRoaXMpXHJcbiAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJldGFyZ2V0IChuZXdUcmFuc2Zvcm1zKSB7XHJcbiAgICAgIC8vIG9ubHkgZ2V0IGEgbmV3IG9yaWdpbiBpZiBpdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGNhbGxcclxuICAgICAgaWYgKFxyXG4gICAgICAgIChuZXdUcmFuc2Zvcm1zLm9yaWdpbiB8fCAnY2VudGVyJykudG9TdHJpbmcoKVxyXG4gICAgICAgICE9PSAodHJhbnNmb3Jtcy5vcmlnaW4gfHwgJ2NlbnRlcicpLnRvU3RyaW5nKClcclxuICAgICAgKSB7XHJcbiAgICAgICAgb3JpZ2luID0gZ2V0T3JpZ2luKHRyYW5zZm9ybXMsIGVsZW1lbnQpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG92ZXJ3cml0ZSB0aGUgb2xkIHRyYW5zZm9ybWF0aW9ucyB3aXRoIHRoZSBuZXcgb25lc1xyXG4gICAgICB0cmFuc2Zvcm1zID0geyAuLi5uZXdUcmFuc2Zvcm1zLCBvcmlnaW4gfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucXVldWUoc2V0dXAsIHJ1biwgcmV0YXJnZXQsIHRydWUpXHJcbiAgICB0aGlzLl9pc0RlY2xhcmF0aXZlICYmIHRoaXMuX3JlbWVtYmVyTW9ycGhlcigndHJhbnNmb3JtJywgbW9ycGhlcilcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfSxcclxuXHJcbiAgLy8gQW5pbWF0YWJsZSB4LWF4aXNcclxuICB4ICh4LCByZWxhdGl2ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCd4JywgeClcclxuICB9LFxyXG5cclxuICAvLyBBbmltYXRhYmxlIHktYXhpc1xyXG4gIHkgKHkpIHtcclxuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcigneScsIHkpXHJcbiAgfSxcclxuXHJcbiAgZHggKHggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXJEZWx0YSgneCcsIHgpXHJcbiAgfSxcclxuXHJcbiAgZHkgKHkgPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXJEZWx0YSgneScsIHkpXHJcbiAgfSxcclxuXHJcbiAgZG1vdmUgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmR4KHgpLmR5KHkpXHJcbiAgfSxcclxuXHJcbiAgX3F1ZXVlTnVtYmVyRGVsdGEgKG1ldGhvZCwgdG8pIHtcclxuICAgIHRvID0gbmV3IFNWR051bWJlcih0bylcclxuXHJcbiAgICAvLyBUcnkgdG8gY2hhbmdlIHRoZSB0YXJnZXQgaWYgd2UgaGF2ZSB0aGlzIG1ldGhvZCBhbHJlYWR5IHJlZ2lzdGVyZFxyXG4gICAgaWYgKHRoaXMuX3RyeVJldGFyZ2V0KG1ldGhvZCwgdG8pKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIC8vIE1ha2UgYSBtb3JwaGVyIGFuZCBxdWV1ZSB0aGUgYW5pbWF0aW9uXHJcbiAgICB2YXIgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudG8odG8pXHJcbiAgICB2YXIgZnJvbSA9IG51bGxcclxuICAgIHRoaXMucXVldWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICBmcm9tID0gdGhpcy5lbGVtZW50KClbbWV0aG9kXSgpXHJcbiAgICAgIG1vcnBoZXIuZnJvbShmcm9tKVxyXG4gICAgICBtb3JwaGVyLnRvKGZyb20gKyB0bylcclxuICAgIH0sIGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgdGhpcy5lbGVtZW50KClbbWV0aG9kXShtb3JwaGVyLmF0KHBvcykpXHJcbiAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKVxyXG4gICAgfSwgZnVuY3Rpb24gKG5ld1RvKSB7XHJcbiAgICAgIG1vcnBoZXIudG8oZnJvbSArIG5ldyBTVkdOdW1iZXIobmV3VG8pKVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBSZWdpc3RlciB0aGUgbW9ycGhlciBzbyB0aGF0IGlmIGl0IGlzIGNoYW5nZWQgYWdhaW4sIHdlIGNhbiByZXRhcmdldCBpdFxyXG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKG1ldGhvZCwgbW9ycGhlcilcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfSxcclxuXHJcbiAgX3F1ZXVlT2JqZWN0IChtZXRob2QsIHRvKSB7XHJcbiAgICAvLyBUcnkgdG8gY2hhbmdlIHRoZSB0YXJnZXQgaWYgd2UgaGF2ZSB0aGlzIG1ldGhvZCBhbHJlYWR5IHJlZ2lzdGVyZFxyXG4gICAgaWYgKHRoaXMuX3RyeVJldGFyZ2V0KG1ldGhvZCwgdG8pKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIC8vIE1ha2UgYSBtb3JwaGVyIGFuZCBxdWV1ZSB0aGUgYW5pbWF0aW9uXHJcbiAgICB2YXIgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudG8odG8pXHJcbiAgICB0aGlzLnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgbW9ycGhlci5mcm9tKHRoaXMuZWxlbWVudCgpW21ldGhvZF0oKSlcclxuICAgIH0sIGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgdGhpcy5lbGVtZW50KClbbWV0aG9kXShtb3JwaGVyLmF0KHBvcykpXHJcbiAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBSZWdpc3RlciB0aGUgbW9ycGhlciBzbyB0aGF0IGlmIGl0IGlzIGNoYW5nZWQgYWdhaW4sIHdlIGNhbiByZXRhcmdldCBpdFxyXG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKG1ldGhvZCwgbW9ycGhlcilcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfSxcclxuXHJcbiAgX3F1ZXVlTnVtYmVyIChtZXRob2QsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcXVldWVPYmplY3QobWV0aG9kLCBuZXcgU1ZHTnVtYmVyKHZhbHVlKSlcclxuICB9LFxyXG5cclxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB4LWF4aXNcclxuICBjeCAoeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCdjeCcsIHgpXHJcbiAgfSxcclxuXHJcbiAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeS1heGlzXHJcbiAgY3kgKHkpIHtcclxuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignY3knLCB5KVxyXG4gIH0sXHJcblxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIG1vdmVcclxuICBtb3ZlICh4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy54KHgpLnkoeSlcclxuICB9LFxyXG5cclxuICAvLyBBZGQgYW5pbWF0YWJsZSBjZW50ZXJcclxuICBjZW50ZXIgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmN4KHgpLmN5KHkpXHJcbiAgfSxcclxuXHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgc2l6ZVxyXG4gIHNpemUgKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIC8vIGFuaW1hdGUgYmJveCBiYXNlZCBzaXplIGZvciBhbGwgb3RoZXIgZWxlbWVudHNcclxuICAgIHZhciBib3hcclxuXHJcbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcclxuICAgICAgYm94ID0gdGhpcy5fZWxlbWVudC5iYm94KClcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXdpZHRoKSB7XHJcbiAgICAgIHdpZHRoID0gYm94LndpZHRoIC8gYm94LmhlaWdodCAqIGhlaWdodFxyXG4gICAgfVxyXG5cclxuICAgIGlmICghaGVpZ2h0KSB7XHJcbiAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgICAgIC53aWR0aCh3aWR0aClcclxuICAgICAgLmhlaWdodChoZWlnaHQpXHJcbiAgfSxcclxuXHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgd2lkdGhcclxuICB3aWR0aCAod2lkdGgpIHtcclxuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignd2lkdGgnLCB3aWR0aClcclxuICB9LFxyXG5cclxuICAvLyBBZGQgYW5pbWF0YWJsZSBoZWlnaHRcclxuICBoZWlnaHQgKGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCdoZWlnaHQnLCBoZWlnaHQpXHJcbiAgfSxcclxuXHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgcGxvdFxyXG4gIHBsb3QgKGEsIGIsIGMsIGQpIHtcclxuICAgIC8vIExpbmVzIGNhbiBiZSBwbG90dGVkIHdpdGggNCBhcmd1bWVudHNcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBsb3QoWyBhLCBiLCBjLCBkIF0pXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3RyeVJldGFyZ2V0KCdwbG90JywgYSkpIHJldHVybiB0aGlzXHJcblxyXG4gICAgdmFyIG1vcnBoZXIgPSBuZXcgTW9ycGhhYmxlKHRoaXMuX3N0ZXBwZXIpXHJcbiAgICAgIC50eXBlKHRoaXMuX2VsZW1lbnQuTW9ycGhBcnJheSkudG8oYSlcclxuXHJcbiAgICB0aGlzLnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgbW9ycGhlci5mcm9tKHRoaXMuX2VsZW1lbnQuYXJyYXkoKSlcclxuICAgIH0sIGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgdGhpcy5fZWxlbWVudC5wbG90KG1vcnBoZXIuYXQocG9zKSlcclxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMuX3JlbWVtYmVyTW9ycGhlcigncGxvdCcsIG1vcnBoZXIpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH0sXHJcblxyXG4gIC8vIEFkZCBsZWFkaW5nIG1ldGhvZFxyXG4gIGxlYWRpbmcgKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2xlYWRpbmcnLCB2YWx1ZSlcclxuICB9LFxyXG5cclxuICAvLyBBZGQgYW5pbWF0YWJsZSB2aWV3Ym94XHJcbiAgdmlld2JveCAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlT2JqZWN0KCd2aWV3Ym94JywgbmV3IEJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSlcclxuICB9LFxyXG5cclxuICB1cGRhdGUgKG8pIHtcclxuICAgIGlmICh0eXBlb2YgbyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHtcclxuICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1swXSxcclxuICAgICAgICBjb2xvcjogYXJndW1lbnRzWzFdLFxyXG4gICAgICAgIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChvLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLW9wYWNpdHknLCBvLm9wYWNpdHkpXHJcbiAgICBpZiAoby5jb2xvciAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKVxyXG4gICAgaWYgKG8ub2Zmc2V0ICE9IG51bGwpIHRoaXMuYXR0cignb2Zmc2V0Jywgby5vZmZzZXQpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbn0pXHJcblxyXG5leHRlbmQoUnVubmVyLCB7IHJ4LCByeSwgZnJvbSwgdG8gfSlcclxucmVnaXN0ZXIoUnVubmVyLCAnUnVubmVyJylcclxuIiwiaW1wb3J0IHtcclxuICBhZG9wdCxcclxuICBub2RlT3JOZXcsXHJcbiAgcmVnaXN0ZXIsXHJcbiAgd3JhcFdpdGhBdHRyQ2hlY2tcclxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBucywgc3ZnanMsIHhsaW5rLCB4bWxucyB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xyXG5pbXBvcnQgRGVmcyBmcm9tICcuL0RlZnMuanMnXHJcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdmcgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ3N2ZycsIG5vZGUpLCBub2RlKVxyXG4gICAgdGhpcy5uYW1lc3BhY2UoKVxyXG4gIH1cclxuXHJcbiAgaXNSb290ICgpIHtcclxuICAgIHJldHVybiAhdGhpcy5ub2RlLnBhcmVudE5vZGVcclxuICAgICAgfHwgISh0aGlzLm5vZGUucGFyZW50Tm9kZSBpbnN0YW5jZW9mIGdsb2JhbHMud2luZG93LlNWR0VsZW1lbnQpXHJcbiAgICAgIHx8IHRoaXMubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50J1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJvb3Qgc3ZnXHJcbiAgLy8gSWYgbm90LCBjYWxsIGRvY3MgZnJvbSB0aGlzIGVsZW1lbnRcclxuICByb290ICgpIHtcclxuICAgIGlmICh0aGlzLmlzUm9vdCgpKSByZXR1cm4gdGhpc1xyXG4gICAgcmV0dXJuIHN1cGVyLnJvb3QoKVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIG5hbWVzcGFjZXNcclxuICBuYW1lc3BhY2UgKCkge1xyXG4gICAgaWYgKCF0aGlzLmlzUm9vdCgpKSByZXR1cm4gdGhpcy5yb290KCkubmFtZXNwYWNlKClcclxuICAgIHJldHVybiB0aGlzXHJcbiAgICAgIC5hdHRyKHsgeG1sbnM6IG5zLCB2ZXJzaW9uOiAnMS4xJyB9KVxyXG4gICAgICAuYXR0cigneG1sbnM6eGxpbmsnLCB4bGluaywgeG1sbnMpXHJcbiAgICAgIC5hdHRyKCd4bWxuczpzdmdqcycsIHN2Z2pzLCB4bWxucylcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZXMgYW5kIHJldHVybnMgZGVmcyBlbGVtZW50XHJcbiAgZGVmcyAoKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNSb290KCkpIHJldHVybiB0aGlzLnJvb3QoKS5kZWZzKClcclxuXHJcbiAgICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJ2RlZnMnKSlcclxuICAgICAgfHwgdGhpcy5wdXQobmV3IERlZnMoKSlcclxuICB9XHJcblxyXG4gIC8vIGN1c3RvbSBwYXJlbnQgbWV0aG9kXHJcbiAgcGFyZW50ICh0eXBlKSB7XHJcbiAgICBpZiAodGhpcy5pc1Jvb3QoKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ub2RlLnBhcmVudE5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnXHJcbiAgICAgICAgPyBudWxsXHJcbiAgICAgICAgOiBhZG9wdCh0aGlzLm5vZGUucGFyZW50Tm9kZSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3VwZXIucGFyZW50KHR5cGUpXHJcbiAgfVxyXG5cclxuICBjbGVhciAoKSB7XHJcbiAgICAvLyByZW1vdmUgY2hpbGRyZW5cclxuICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSBkZWZzIHJlZmVyZW5jZVxyXG4gICAgZGVsZXRlIHRoaXMuX2RlZnNcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSBuZXN0ZWQgc3ZnIGRvY3VtZW50XHJcbiAgICBuZXN0ZWQ6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdmcoKSlcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoU3ZnLCAnU3ZnJywgdHJ1ZSlcclxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ltYm9sIGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdzeW1ib2wnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICBzeW1ib2w6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTeW1ib2woKSlcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoU3ltYm9sLCAnU3ltYm9sJylcclxuIiwiaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uLy4uL3V0aWxzL3dpbmRvdy5qcydcclxuXHJcbi8vIENyZWF0ZSBwbGFpbiB0ZXh0IG5vZGVcclxuZXhwb3J0IGZ1bmN0aW9uIHBsYWluICh0ZXh0KSB7XHJcbiAgLy8gY2xlYXIgaWYgYnVpbGQgbW9kZSBpcyBkaXNhYmxlZFxyXG4gIGlmICh0aGlzLl9idWlsZCA9PT0gZmFsc2UpIHtcclxuICAgIHRoaXMuY2xlYXIoKVxyXG4gIH1cclxuXHJcbiAgLy8gY3JlYXRlIHRleHQgbm9kZVxyXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChnbG9iYWxzLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vLyBHZXQgbGVuZ3RoIG9mIHRleHQgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoICgpIHtcclxuICByZXR1cm4gdGhpcy5ub2RlLmdldENvbXB1dGVkVGV4dExlbmd0aCgpXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBhZG9wdCxcclxuICBleHRlbmQsXHJcbiAgbm9kZU9yTmV3LFxyXG4gIHJlZ2lzdGVyLFxyXG4gIHdyYXBXaXRoQXR0ckNoZWNrXHJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xyXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5pbXBvcnQgKiBhcyB0ZXh0YWJsZSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvdGV4dGFibGUuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0IGV4dGVuZHMgU2hhcGUge1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ3RleHQnLCBub2RlKSwgbm9kZSlcclxuXHJcbiAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWR051bWJlcigxLjMpIC8vIHN0b3JlIGxlYWRpbmcgdmFsdWUgZm9yIHJlYnVpbGRpbmdcclxuICAgIHRoaXMuX3JlYnVpbGQgPSB0cnVlIC8vIGVuYWJsZSBhdXRvbWF0aWMgdXBkYXRpbmcgb2YgZHkgdmFsdWVzXHJcbiAgICB0aGlzLl9idWlsZCA9IGZhbHNlIC8vIGRpc2FibGUgYnVpbGQgbW9kZSBmb3IgYWRkaW5nIG11bHRpcGxlIGxpbmVzXHJcbiAgfVxyXG5cclxuICAvLyBNb3ZlIG92ZXIgeC1heGlzXHJcbiAgLy8gVGV4dCBpcyBtb3ZlZCBpdHMgYm91bmRpbmcgYm94XHJcbiAgLy8gdGV4dC1hbmNob3IgZG9lcyBOT1QgbWF0dGVyXHJcbiAgeCAoeCwgYm94ID0gdGhpcy5iYm94KCkpIHtcclxuICAgIGlmICh4ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGJveC54XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHRoaXMuYXR0cigneCcpICsgeCAtIGJveC54KVxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBvdmVyIHktYXhpc1xyXG4gIHkgKHksIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICBpZiAoeSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBib3gueVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3knLCB0aGlzLmF0dHIoJ3knKSArIHkgLSBib3gueSlcclxuICB9XHJcblxyXG4gIG1vdmUgKHgsIHksIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICByZXR1cm4gdGhpcy54KHgsIGJveCkueSh5LCBib3gpXHJcbiAgfVxyXG5cclxuICAvLyBNb3ZlIGNlbnRlciBvdmVyIHgtYXhpc1xyXG4gIGN4ICh4LCBib3ggPSB0aGlzLmJib3goKSkge1xyXG4gICAgaWYgKHggPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gYm94LmN4XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHRoaXMuYXR0cigneCcpICsgeCAtIGJveC5jeClcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgY2VudGVyIG92ZXIgeS1heGlzXHJcbiAgY3kgKHksIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICBpZiAoeSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBib3guY3lcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgdGhpcy5hdHRyKCd5JykgKyB5IC0gYm94LmN5KVxyXG4gIH1cclxuXHJcbiAgY2VudGVyICh4LCB5LCBib3ggPSB0aGlzLmJib3goKSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY3goeCwgYm94KS5jeSh5LCBib3gpXHJcbiAgfVxyXG5cclxuICAvLyBTZXQgdGhlIHRleHQgY29udGVudFxyXG4gIHRleHQgKHRleHQpIHtcclxuICAgIC8vIGFjdCBhcyBnZXR0ZXJcclxuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ub2RlLmNoaWxkTm9kZXNcclxuICAgICAgdmFyIGZpcnN0TGluZSA9IDBcclxuICAgICAgdGV4dCA9ICcnXHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAvLyBza2lwIHRleHRQYXRocyAtIHRoZXkgYXJlIG5vIGxpbmVzXHJcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLm5vZGVOYW1lID09PSAndGV4dFBhdGgnKSB7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgZmlyc3RMaW5lID0gMVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkZCBuZXdsaW5lIGlmIGl0cyBub3QgdGhlIGZpcnN0IGNoaWxkIGFuZCBuZXdMaW5lZCBpcyBzZXQgdG8gdHJ1ZVxyXG4gICAgICAgIGlmIChpICE9PSBmaXJzdExpbmUgJiYgY2hpbGRyZW5baV0ubm9kZVR5cGUgIT09IDMgJiYgYWRvcHQoY2hpbGRyZW5baV0pLmRvbS5uZXdMaW5lZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgdGV4dCArPSAnXFxuJ1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRkIGNvbnRlbnQgb2YgdGhpcyBub2RlXHJcbiAgICAgICAgdGV4dCArPSBjaGlsZHJlbltpXS50ZXh0Q29udGVudFxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGV4dFxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSBleGlzdGluZyBjb250ZW50XHJcbiAgICB0aGlzLmNsZWFyKCkuYnVpbGQodHJ1ZSlcclxuXHJcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgLy8gY2FsbCBibG9ja1xyXG4gICAgICB0ZXh0LmNhbGwodGhpcywgdGhpcylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHN0b3JlIHRleHQgYW5kIG1ha2Ugc3VyZSB0ZXh0IGlzIG5vdCBibGFua1xyXG4gICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnXFxuJylcclxuXHJcbiAgICAgIC8vIGJ1aWxkIG5ldyBsaW5lc1xyXG4gICAgICBmb3IgKHZhciBqID0gMCwgamwgPSB0ZXh0Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcclxuICAgICAgICB0aGlzLnRzcGFuKHRleHRbal0pLm5ld0xpbmUoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGlzYWJsZSBidWlsZCBtb2RlIGFuZCByZWJ1aWxkIGxpbmVzXHJcbiAgICByZXR1cm4gdGhpcy5idWlsZChmYWxzZSkucmVidWlsZCgpXHJcbiAgfVxyXG5cclxuICAvLyBTZXQgLyBnZXQgbGVhZGluZ1xyXG4gIGxlYWRpbmcgKHZhbHVlKSB7XHJcbiAgICAvLyBhY3QgYXMgZ2V0dGVyXHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kb20ubGVhZGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFjdCBhcyBzZXR0ZXJcclxuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKHZhbHVlKVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJlYnVpbGQoKVxyXG4gIH1cclxuXHJcbiAgLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcclxuICByZWJ1aWxkIChyZWJ1aWxkKSB7XHJcbiAgICAvLyBzdG9yZSBuZXcgcmVidWlsZCBmbGFnIGlmIGdpdmVuXHJcbiAgICBpZiAodHlwZW9mIHJlYnVpbGQgPT09ICdib29sZWFuJykge1xyXG4gICAgICB0aGlzLl9yZWJ1aWxkID0gcmVidWlsZFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGRlZmluZSBwb3NpdGlvbiBvZiBhbGwgbGluZXNcclxuICAgIGlmICh0aGlzLl9yZWJ1aWxkKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICB2YXIgYmxhbmtMaW5lT2Zmc2V0ID0gMFxyXG4gICAgICB2YXIgbGVhZGluZyA9IHRoaXMuZG9tLmxlYWRpbmdcclxuXHJcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZvbnRTaXplID0gZ2xvYmFscy53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5vZGUpXHJcbiAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJylcclxuICAgICAgICB2YXIgZHkgPSBsZWFkaW5nICogbmV3IFNWR051bWJlcihmb250U2l6ZSlcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZG9tLm5ld0xpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLmF0dHIoJ3gnLCBzZWxmLmF0dHIoJ3gnKSlcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy50ZXh0KCkgPT09ICdcXG4nKSB7XHJcbiAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCArPSBkeVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKCdkeScsIGR5ICsgYmxhbmtMaW5lT2Zmc2V0KVxyXG4gICAgICAgICAgICBibGFua0xpbmVPZmZzZXQgPSAwXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgdGhpcy5maXJlKCdyZWJ1aWxkJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gRW5hYmxlIC8gZGlzYWJsZSBidWlsZCBtb2RlXHJcbiAgYnVpbGQgKGJ1aWxkKSB7XHJcbiAgICB0aGlzLl9idWlsZCA9ICEhYnVpbGRcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBvdmVyd3JpdGUgbWV0aG9kIGZyb20gcGFyZW50IHRvIHNldCBkYXRhIHByb3Blcmx5XHJcbiAgc2V0RGF0YSAobykge1xyXG4gICAgdGhpcy5kb20gPSBvXHJcbiAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWR051bWJlcihvLmxlYWRpbmcgfHwgMS4zKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbn1cclxuXHJcbmV4dGVuZChUZXh0LCB0ZXh0YWJsZSlcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgdGV4dCBlbGVtZW50XHJcbiAgICB0ZXh0OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFRleHQoKSkudGV4dCh0ZXh0KVxyXG4gICAgfSksXHJcblxyXG4gICAgLy8gQ3JlYXRlIHBsYWluIHRleHQgZWxlbWVudFxyXG4gICAgcGxhaW46IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgVGV4dCgpKS5wbGFpbih0ZXh0KVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihUZXh0LCAnVGV4dCcpXHJcbiIsImltcG9ydCB7XHJcbiAgZXh0ZW5kLFxyXG4gIG5vZGVPck5ldyxcclxuICByZWdpc3RlcixcclxuICB3cmFwV2l0aEF0dHJDaGVja1xyXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xyXG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnXHJcbmltcG9ydCAqIGFzIHRleHRhYmxlIGZyb20gJy4uL21vZHVsZXMvY29yZS90ZXh0YWJsZS5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRzcGFuIGV4dGVuZHMgVGV4dCB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygndHNwYW4nLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIC8vIFNldCB0ZXh0IGNvbnRlbnRcclxuICB0ZXh0ICh0ZXh0KSB7XHJcbiAgICBpZiAodGV4dCA9PSBudWxsKSByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50ICsgKHRoaXMuZG9tLm5ld0xpbmVkID8gJ1xcbicgOiAnJylcclxuXHJcbiAgICB0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IHRleHQuY2FsbCh0aGlzLCB0aGlzKSA6IHRoaXMucGxhaW4odGV4dClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gU2hvcnRjdXQgZHhcclxuICBkeCAoZHgpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2R4JywgZHgpXHJcbiAgfVxyXG5cclxuICAvLyBTaG9ydGN1dCBkeVxyXG4gIGR5IChkeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignZHknLCBkeSlcclxuICB9XHJcblxyXG4gIHggKHgpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB4KVxyXG4gIH1cclxuXHJcbiAgeSAoeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHkpXHJcbiAgfVxyXG5cclxuICBtb3ZlICh4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy54KHgpLnkoeSlcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBuZXcgbGluZVxyXG4gIG5ld0xpbmUgKCkge1xyXG4gICAgLy8gZmV0Y2ggdGV4dCBwYXJlbnRcclxuICAgIHZhciB0ID0gdGhpcy5wYXJlbnQoVGV4dClcclxuXHJcbiAgICAvLyBtYXJrIG5ldyBsaW5lXHJcbiAgICB0aGlzLmRvbS5uZXdMaW5lZCA9IHRydWVcclxuXHJcbiAgICB2YXIgZm9udFNpemUgPSBnbG9iYWxzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSlcclxuICAgICAgLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtc2l6ZScpXHJcbiAgICB2YXIgZHkgPSB0LmRvbS5sZWFkaW5nICogbmV3IFNWR051bWJlcihmb250U2l6ZSlcclxuXHJcbiAgICAvLyBhcHBseSBuZXcgcG9zaXRpb25cclxuICAgIHJldHVybiB0aGlzLmR5KGR5KS5hdHRyKCd4JywgdC54KCkpXHJcbiAgfVxyXG59XHJcblxyXG5leHRlbmQoVHNwYW4sIHRleHRhYmxlKVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBUc3Bhbjoge1xyXG4gICAgdHNwYW46IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgIHZhciB0c3BhbiA9IG5ldyBUc3BhbigpXHJcblxyXG4gICAgICAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXHJcbiAgICAgIGlmICghdGhpcy5fYnVpbGQpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWRkIG5ldyB0c3BhblxyXG4gICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodHNwYW4ubm9kZSlcclxuXHJcbiAgICAgIHJldHVybiB0c3Bhbi50ZXh0KHRleHQpXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKFRzcGFuLCAnVHNwYW4nKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXHJcbmltcG9ydCBiYXNlRmluZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDbGlwUGF0aCBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnY2xpcFBhdGgnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIC8vIFVuY2xpcCBhbGwgY2xpcHBlZCBlbGVtZW50cyBhbmQgcmVtb3ZlIGl0c2VsZlxyXG4gIHJlbW92ZSAoKSB7XHJcbiAgICAvLyB1bmNsaXAgYWxsIHRhcmdldHNcclxuICAgIHRoaXMudGFyZ2V0cygpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgIGVsLnVuY2xpcCgpXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIHJlbW92ZSBjbGlwUGF0aCBmcm9tIHBhcmVudFxyXG4gICAgcmV0dXJuIHN1cGVyLnJlbW92ZSgpXHJcbiAgfVxyXG5cclxuICB0YXJnZXRzICgpIHtcclxuICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIFtjbGlwLXBhdGgqPVwiJyArIHRoaXMuaWQoKSArICdcIl0nKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSBjbGlwcGluZyBlbGVtZW50XHJcbiAgICBjbGlwOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IENsaXBQYXRoKCkpXHJcbiAgICB9KVxyXG4gIH0sXHJcbiAgRWxlbWVudDoge1xyXG4gICAgLy8gRGlzdHJpYnV0ZSBjbGlwUGF0aCB0byBzdmcgZWxlbWVudFxyXG4gICAgY2xpcFdpdGggKGVsZW1lbnQpIHtcclxuICAgICAgLy8gdXNlIGdpdmVuIGNsaXAgb3IgY3JlYXRlIGEgbmV3IG9uZVxyXG4gICAgICBjb25zdCBjbGlwcGVyID0gZWxlbWVudCBpbnN0YW5jZW9mIENsaXBQYXRoXHJcbiAgICAgICAgPyBlbGVtZW50XHJcbiAgICAgICAgOiB0aGlzLnBhcmVudCgpLmNsaXAoKS5hZGQoZWxlbWVudClcclxuXHJcbiAgICAgIC8vIGFwcGx5IG1hc2tcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignY2xpcC1wYXRoJywgJ3VybChcIiMnICsgY2xpcHBlci5pZCgpICsgJ1wiKScpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFVuY2xpcCBlbGVtZW50XHJcbiAgICB1bmNsaXAgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCBudWxsKVxyXG4gICAgfSxcclxuXHJcbiAgICBjbGlwcGVyICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlKCdjbGlwLXBhdGgnKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKENsaXBQYXRoLCAnQ2xpcFBhdGgnKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vRWxlbWVudC5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcmVpZ25PYmplY3QgZXh0ZW5kcyBFbGVtZW50IHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdmb3JlaWduT2JqZWN0Jywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgZm9yZWlnbk9iamVjdDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBGb3JlaWduT2JqZWN0KCkpLnNpemUod2lkdGgsIGhlaWdodClcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoRm9yZWlnbk9iamVjdCwgJ0ZvcmVpZ25PYmplY3QnKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHByb3BvcnRpb25hbFNpemUgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lci5qcydcclxuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi90eXBlcy9NYXRyaXguanMnXHJcbmltcG9ydCBQb2ludCBmcm9tICcuLi90eXBlcy9Qb2ludC5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEcgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ2cnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIHggKHgsIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICBpZiAoeCA9PSBudWxsKSByZXR1cm4gYm94LnhcclxuICAgIHJldHVybiB0aGlzLm1vdmUoeCwgYm94LnksIGJveClcclxuICB9XHJcblxyXG4gIHkgKHksIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICBpZiAoeSA9PSBudWxsKSByZXR1cm4gYm94LnlcclxuICAgIHJldHVybiB0aGlzLm1vdmUoYm94LngsIHksIGJveClcclxuICB9XHJcblxyXG4gIG1vdmUgKHggPSAwLCB5ID0gMCwgYm94ID0gdGhpcy5iYm94KCkpIHtcclxuICAgIGNvbnN0IGR4ID0geCAtIGJveC54XHJcbiAgICBjb25zdCBkeSA9IHkgLSBib3gueVxyXG5cclxuICAgIHJldHVybiB0aGlzLmRtb3ZlKGR4LCBkeSlcclxuICB9XHJcblxyXG4gIGR4IChkeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG1vdmUoZHgsIDApXHJcbiAgfVxyXG5cclxuICBkeSAoZHkpIHtcclxuICAgIHJldHVybiB0aGlzLmRtb3ZlKDAsIGR5KVxyXG4gIH1cclxuXHJcbiAgZG1vdmUgKGR4LCBkeSkge1xyXG4gICAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XHJcbiAgICAgIC8vIEdldCB0aGUgY2hpbGRzIGJib3hcclxuICAgICAgY29uc3QgYmJveCA9IGNoaWxkLmJib3goKVxyXG4gICAgICAvLyBHZXQgY2hpbGRzIG1hdHJpeFxyXG4gICAgICBjb25zdCBtID0gbmV3IE1hdHJpeChjaGlsZClcclxuICAgICAgLy8gVHJhbnNsYXRlIGNoaWxkcyBtYXRyaXggYnkgYW1vdW50IGFuZFxyXG4gICAgICAvLyB0cmFuc2Zvcm0gaXQgYmFjayBpbnRvIHBhcmVudHMgc3BhY2VcclxuICAgICAgY29uc3QgbWF0cml4ID0gbS50cmFuc2xhdGUoZHgsIGR5KS50cmFuc2Zvcm0obS5pbnZlcnNlKCkpXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBuZXcgeCBhbmQgeSBmcm9tIG9sZCBib3hcclxuICAgICAgY29uc3QgcCA9IG5ldyBQb2ludChiYm94LngsIGJib3gueSkudHJhbnNmb3JtKG1hdHJpeClcclxuICAgICAgLy8gTW92ZSBlbGVtZW50XHJcbiAgICAgIGNoaWxkLm1vdmUocC54LCBwLnkpXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB3aWR0aCAod2lkdGgsIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICBpZiAod2lkdGggPT0gbnVsbCkgcmV0dXJuIGJveC53aWR0aFxyXG4gICAgcmV0dXJuIHRoaXMuc2l6ZSh3aWR0aCwgYm94LmhlaWdodCwgYm94KVxyXG4gIH1cclxuXHJcbiAgaGVpZ2h0IChoZWlnaHQsIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICBpZiAoaGVpZ2h0ID09IG51bGwpIHJldHVybiBib3guaGVpZ2h0XHJcbiAgICByZXR1cm4gdGhpcy5zaXplKGJveC53aWR0aCwgaGVpZ2h0LCBib3gpXHJcbiAgfVxyXG5cclxuICBzaXplICh3aWR0aCwgaGVpZ2h0LCBib3ggPSB0aGlzLmJib3goKSkge1xyXG4gICAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCwgYm94KVxyXG4gICAgY29uc3Qgc2NhbGVYID0gcC53aWR0aCAvIGJveC53aWR0aFxyXG4gICAgY29uc3Qgc2NhbGVZID0gcC5oZWlnaHQgLyBib3guaGVpZ2h0XHJcblxyXG4gICAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XHJcbiAgICAgIGNvbnN0IG8gPSBuZXcgUG9pbnQoYm94KS50cmFuc2Zvcm0obmV3IE1hdHJpeChjaGlsZCkuaW52ZXJzZSgpKVxyXG4gICAgICBjaGlsZC5zY2FsZShzY2FsZVgsIHNjYWxlWSwgby54LCBvLnkpXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgLy8gQ3JlYXRlIGEgZ3JvdXAgZWxlbWVudFxyXG4gICAgZ3JvdXA6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBHKCkpXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKEcsICdHJylcclxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgeyB4bGluayB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQSBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnYScsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gTGluayB1cmxcclxuICB0byAodXJsKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdocmVmJywgdXJsLCB4bGluaylcclxuICB9XHJcblxyXG4gIC8vIExpbmsgdGFyZ2V0IGF0dHJpYnV0ZVxyXG4gIHRhcmdldCAodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd0YXJnZXQnLCB0YXJnZXQpXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgLy8gQ3JlYXRlIGEgaHlwZXJsaW5rIGVsZW1lbnRcclxuICAgIGxpbms6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBBKCkpLnRvKHVybClcclxuICAgIH0pXHJcbiAgfSxcclxuICBFbGVtZW50OiB7XHJcbiAgICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxyXG4gICAgbGlua1RvOiBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgIHZhciBsaW5rID0gbmV3IEEoKVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB1cmwuY2FsbChsaW5rLCBsaW5rKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxpbmsudG8odXJsKVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5wdXQobGluaykucHV0KHRoaXMpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoQSwgJ0EnKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXHJcbmltcG9ydCBiYXNlRmluZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXNrIGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdtYXNrJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICAvLyBVbm1hc2sgYWxsIG1hc2tlZCBlbGVtZW50cyBhbmQgcmVtb3ZlIGl0c2VsZlxyXG4gIHJlbW92ZSAoKSB7XHJcbiAgICAvLyB1bm1hc2sgYWxsIHRhcmdldHNcclxuICAgIHRoaXMudGFyZ2V0cygpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgIGVsLnVubWFzaygpXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIHJlbW92ZSBtYXNrIGZyb20gcGFyZW50XHJcbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlKClcclxuICB9XHJcblxyXG4gIHRhcmdldHMgKCkge1xyXG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW21hc2sqPVwiJyArIHRoaXMuaWQoKSArICdcIl0nKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIG1hc2s6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnB1dChuZXcgTWFzaygpKVxyXG4gICAgfSlcclxuICB9LFxyXG4gIEVsZW1lbnQ6IHtcclxuICAgIC8vIERpc3RyaWJ1dGUgbWFzayB0byBzdmcgZWxlbWVudFxyXG4gICAgbWFza1dpdGggKGVsZW1lbnQpIHtcclxuICAgICAgLy8gdXNlIGdpdmVuIG1hc2sgb3IgY3JlYXRlIGEgbmV3IG9uZVxyXG4gICAgICB2YXIgbWFza2VyID0gZWxlbWVudCBpbnN0YW5jZW9mIE1hc2tcclxuICAgICAgICA/IGVsZW1lbnRcclxuICAgICAgICA6IHRoaXMucGFyZW50KCkubWFzaygpLmFkZChlbGVtZW50KVxyXG5cclxuICAgICAgLy8gYXBwbHkgbWFza1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgJ3VybChcIiMnICsgbWFza2VyLmlkKCkgKyAnXCIpJylcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVW5tYXNrIGVsZW1lbnRcclxuICAgIHVubWFzayAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hc2snLCBudWxsKVxyXG4gICAgfSxcclxuXHJcbiAgICBtYXNrZXIgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ21hc2snKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKE1hc2ssICdNYXNrJylcclxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgeyB1bkNhbWVsQ2FzZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuL0VsZW1lbnQuanMnXHJcblxyXG5mdW5jdGlvbiBjc3NSdWxlIChzZWxlY3RvciwgcnVsZSkge1xyXG4gIGlmICghc2VsZWN0b3IpIHJldHVybiAnJ1xyXG4gIGlmICghcnVsZSkgcmV0dXJuIHNlbGVjdG9yXHJcblxyXG4gIHZhciByZXQgPSBzZWxlY3RvciArICd7J1xyXG5cclxuICBmb3IgKHZhciBpIGluIHJ1bGUpIHtcclxuICAgIHJldCArPSB1bkNhbWVsQ2FzZShpKSArICc6JyArIHJ1bGVbaV0gKyAnOydcclxuICB9XHJcblxyXG4gIHJldCArPSAnfSdcclxuXHJcbiAgcmV0dXJuIHJldFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHlsZSBleHRlbmRzIEVsZW1lbnQge1xyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ3N0eWxlJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICBhZGRUZXh0ICh3ID0gJycpIHtcclxuICAgIHRoaXMubm9kZS50ZXh0Q29udGVudCArPSB3XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZm9udCAobmFtZSwgc3JjLCBwYXJhbXMgPSB7fSkge1xyXG4gICAgcmV0dXJuIHRoaXMucnVsZSgnQGZvbnQtZmFjZScsIHtcclxuICAgICAgZm9udEZhbWlseTogbmFtZSxcclxuICAgICAgc3JjOiBzcmMsXHJcbiAgICAgIC4uLnBhcmFtc1xyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHJ1bGUgKHNlbGVjdG9yLCBvYmopIHtcclxuICAgIHJldHVybiB0aGlzLmFkZFRleHQoY3NzUnVsZShzZWxlY3Rvciwgb2JqKSlcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xyXG4gIHN0eWxlOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoc2VsZWN0b3IsIG9iaikge1xyXG4gICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdHlsZSgpKS5ydWxlKHNlbGVjdG9yLCBvYmopXHJcbiAgfSksXHJcbiAgZm9udGZhY2U6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChuYW1lLCBzcmMsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdHlsZSgpKS5mb250KG5hbWUsIHNyYywgcGFyYW1zKVxyXG4gIH0pXHJcbn0pXHJcblxyXG5yZWdpc3RlcihTdHlsZSwgJ1N0eWxlJylcclxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgeyB4bGluayB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xyXG5pbXBvcnQgUGF0aCBmcm9tICcuL1BhdGguanMnXHJcbmltcG9ydCBQYXRoQXJyYXkgZnJvbSAnLi4vdHlwZXMvUGF0aEFycmF5LmpzJ1xyXG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnXHJcbmltcG9ydCBiYXNlRmluZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0UGF0aCBleHRlbmRzIFRleHQge1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ3RleHRQYXRoJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm4gdGhlIGFycmF5IG9mIHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcclxuICBhcnJheSAoKSB7XHJcbiAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrKClcclxuXHJcbiAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5hcnJheSgpIDogbnVsbFxyXG4gIH1cclxuXHJcbiAgLy8gUGxvdCBwYXRoIGlmIGFueVxyXG4gIHBsb3QgKGQpIHtcclxuICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2soKVxyXG4gICAgdmFyIHBhdGhBcnJheSA9IG51bGxcclxuXHJcbiAgICBpZiAodHJhY2spIHtcclxuICAgICAgcGF0aEFycmF5ID0gdHJhY2sucGxvdChkKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoZCA9PSBudWxsKSA/IHBhdGhBcnJheSA6IHRoaXNcclxuICB9XHJcblxyXG4gIC8vIEdldCB0aGUgcGF0aCBlbGVtZW50XHJcbiAgdHJhY2sgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlKCdocmVmJylcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICB0ZXh0UGF0aDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQsIHBhdGgpIHtcclxuICAgICAgLy8gQ29udmVydCB0ZXh0IHRvIGluc3RhbmNlIGlmIG5lZWRlZFxyXG4gICAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dCkpIHtcclxuICAgICAgICB0ZXh0ID0gdGhpcy50ZXh0KHRleHQpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0ZXh0LnBhdGgocGF0aClcclxuICAgIH0pXHJcbiAgfSxcclxuICBUZXh0OiB7XHJcbiAgICAvLyBDcmVhdGUgcGF0aCBmb3IgdGV4dCB0byBydW4gb25cclxuICAgIHBhdGg6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0cmFjaywgaW1wb3J0Tm9kZXMgPSB0cnVlKSB7XHJcbiAgICAgIHZhciB0ZXh0UGF0aCA9IG5ldyBUZXh0UGF0aCgpXHJcblxyXG4gICAgICAvLyBpZiB0cmFjayBpcyBhIHBhdGgsIHJldXNlIGl0XHJcbiAgICAgIGlmICghKHRyYWNrIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuICAgICAgICAvLyBjcmVhdGUgcGF0aCBlbGVtZW50XHJcbiAgICAgICAgdHJhY2sgPSB0aGlzLmRlZnMoKS5wYXRoKHRyYWNrKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBsaW5rIHRleHRQYXRoIHRvIHBhdGggYW5kIGFkZCBjb250ZW50XHJcbiAgICAgIHRleHRQYXRoLmF0dHIoJ2hyZWYnLCAnIycgKyB0cmFjaywgeGxpbmspXHJcblxyXG4gICAgICAvLyBUcmFuc3BsYW50IGFsbCBub2RlcyBmcm9tIHRleHQgdG8gdGV4dFBhdGhcclxuICAgICAgbGV0IG5vZGVcclxuICAgICAgaWYgKGltcG9ydE5vZGVzKSB7XHJcbiAgICAgICAgd2hpbGUgKChub2RlID0gdGhpcy5ub2RlLmZpcnN0Q2hpbGQpKSB7XHJcbiAgICAgICAgICB0ZXh0UGF0aC5ub2RlLmFwcGVuZENoaWxkKG5vZGUpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhZGQgdGV4dFBhdGggZWxlbWVudCBhcyBjaGlsZCBub2RlIGFuZCByZXR1cm4gdGV4dFBhdGhcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KHRleHRQYXRoKVxyXG4gICAgfSksXHJcblxyXG4gICAgLy8gR2V0IHRoZSB0ZXh0UGF0aCBjaGlsZHJlblxyXG4gICAgdGV4dFBhdGggKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5maW5kT25lKCd0ZXh0UGF0aCcpXHJcbiAgICB9XHJcbiAgfSxcclxuICBQYXRoOiB7XHJcbiAgICAvLyBjcmVhdGVzIGEgdGV4dFBhdGggZnJvbSB0aGlzIHBhdGhcclxuICAgIHRleHQ6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgIC8vIENvbnZlcnQgdGV4dCB0byBpbnN0YW5jZSBpZiBuZWVkZWRcclxuICAgICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHQpKSB7XHJcbiAgICAgICAgdGV4dCA9IG5ldyBUZXh0KCkuYWRkVG8odGhpcy5wYXJlbnQoKSkudGV4dCh0ZXh0KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGV4dFBhdGggZnJvbSB0ZXh0IGFuZCBwYXRoIGFuZCByZXR1cm5cclxuICAgICAgcmV0dXJuIHRleHQucGF0aCh0aGlzKVxyXG4gICAgfSksXHJcblxyXG4gICAgdGFyZ2V0cyAoKSB7XHJcbiAgICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIFtocmVmKj1cIicgKyB0aGlzLmlkKCkgKyAnXCJdJylcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5UZXh0UGF0aC5wcm90b3R5cGUuTW9ycGhBcnJheSA9IFBhdGhBcnJheVxyXG5yZWdpc3RlcihUZXh0UGF0aCwgJ1RleHRQYXRoJylcclxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgeyB4bGluayB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xyXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVzZSBleHRlbmRzIFNoYXBlIHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCd1c2UnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIC8vIFVzZSBlbGVtZW50IGFzIGEgcmVmZXJlbmNlXHJcbiAgZWxlbWVudCAoZWxlbWVudCwgZmlsZSkge1xyXG4gICAgLy8gU2V0IGxpbmVkIGVsZW1lbnRcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoZmlsZSB8fCAnJykgKyAnIycgKyBlbGVtZW50LCB4bGluaylcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgYSB1c2UgZWxlbWVudFxyXG4gICAgdXNlOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoZWxlbWVudCwgZmlsZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFVzZSgpKS5lbGVtZW50KGVsZW1lbnQsIGZpbGUpXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKFVzZSwgJ1VzZScpXHJcbiIsIi8qIE9wdGlvbmFsIE1vZHVsZXMgKi9cclxuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvYXJyYW5nZS5qcydcclxuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvY2xhc3MuanMnXHJcbmltcG9ydCAnLi9tb2R1bGVzL29wdGlvbmFsL2Nzcy5qcydcclxuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvZGF0YS5qcydcclxuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvbWVtb3J5LmpzJ1xyXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC9zdWdhci5qcydcclxuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvdHJhbnNmb3JtLmpzJ1xyXG5cclxuaW1wb3J0IHsgZXh0ZW5kLCBtYWtlSW5zdGFuY2UgfSBmcm9tICcuL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IGdldE1ldGhvZE5hbWVzLCBnZXRNZXRob2RzRm9yIH0gZnJvbSAnLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgQm94IGZyb20gJy4vdHlwZXMvQm94LmpzJ1xyXG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4vZWxlbWVudHMvQ2lyY2xlLmpzJ1xyXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi90eXBlcy9Db2xvci5qcydcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL2VsZW1lbnRzL0NvbnRhaW5lci5qcydcclxuaW1wb3J0IERlZnMgZnJvbSAnLi9lbGVtZW50cy9EZWZzLmpzJ1xyXG5pbXBvcnQgRG9tIGZyb20gJy4vZWxlbWVudHMvRG9tLmpzJ1xyXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL0VsZW1lbnQuanMnXHJcbmltcG9ydCBFbGxpcHNlIGZyb20gJy4vZWxlbWVudHMvRWxsaXBzZS5qcydcclxuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vdHlwZXMvRXZlbnRUYXJnZXQuanMnXHJcbmltcG9ydCBHcmFkaWVudCBmcm9tICcuL2VsZW1lbnRzL0dyYWRpZW50LmpzJ1xyXG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi9lbGVtZW50cy9JbWFnZS5qcydcclxuaW1wb3J0IExpbmUgZnJvbSAnLi9lbGVtZW50cy9MaW5lLmpzJ1xyXG5pbXBvcnQgTGlzdCBmcm9tICcuL3R5cGVzL0xpc3QuanMnXHJcbmltcG9ydCBNYXJrZXIgZnJvbSAnLi9lbGVtZW50cy9NYXJrZXIuanMnXHJcbmltcG9ydCBNYXRyaXggZnJvbSAnLi90eXBlcy9NYXRyaXguanMnXHJcbmltcG9ydCBNb3JwaGFibGUsIHtcclxuICBOb25Nb3JwaGFibGUsXHJcbiAgT2JqZWN0QmFnLFxyXG4gIFRyYW5zZm9ybUJhZyxcclxuICBtYWtlTW9ycGhhYmxlLFxyXG4gIHJlZ2lzdGVyTW9ycGhhYmxlVHlwZVxyXG59IGZyb20gJy4vYW5pbWF0aW9uL01vcnBoYWJsZS5qcydcclxuaW1wb3J0IFBhdGggZnJvbSAnLi9lbGVtZW50cy9QYXRoLmpzJ1xyXG5pbXBvcnQgUGF0aEFycmF5IGZyb20gJy4vdHlwZXMvUGF0aEFycmF5LmpzJ1xyXG5pbXBvcnQgUGF0dGVybiBmcm9tICcuL2VsZW1lbnRzL1BhdHRlcm4uanMnXHJcbmltcG9ydCBQb2ludEFycmF5IGZyb20gJy4vdHlwZXMvUG9pbnRBcnJheS5qcydcclxuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi9lbGVtZW50cy9Qb2x5Z29uLmpzJ1xyXG5pbXBvcnQgUG9seWxpbmUgZnJvbSAnLi9lbGVtZW50cy9Qb2x5bGluZS5qcydcclxuaW1wb3J0IFJlY3QgZnJvbSAnLi9lbGVtZW50cy9SZWN0LmpzJ1xyXG5pbXBvcnQgUnVubmVyIGZyb20gJy4vYW5pbWF0aW9uL1J1bm5lci5qcydcclxuaW1wb3J0IFNWR0FycmF5IGZyb20gJy4vdHlwZXMvU1ZHQXJyYXkuanMnXHJcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcbmltcG9ydCBTaGFwZSBmcm9tICcuL2VsZW1lbnRzL1NoYXBlLmpzJ1xyXG5pbXBvcnQgU3ZnIGZyb20gJy4vZWxlbWVudHMvU3ZnLmpzJ1xyXG5pbXBvcnQgU3ltYm9sIGZyb20gJy4vZWxlbWVudHMvU3ltYm9sLmpzJ1xyXG5pbXBvcnQgVGV4dCBmcm9tICcuL2VsZW1lbnRzL1RleHQuanMnXHJcbmltcG9ydCBUc3BhbiBmcm9tICcuL2VsZW1lbnRzL1RzcGFuLmpzJ1xyXG5pbXBvcnQgKiBhcyBkZWZhdWx0cyBmcm9tICcuL21vZHVsZXMvY29yZS9kZWZhdWx0cy5qcydcclxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0ICogYXMgbmFtZXNwYWNlcyBmcm9tICcuL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xyXG5pbXBvcnQgKiBhcyByZWdleCBmcm9tICcuL21vZHVsZXMvY29yZS9yZWdleC5qcydcclxuXHJcbmV4cG9ydCB7XHJcbiAgTW9ycGhhYmxlLFxyXG4gIHJlZ2lzdGVyTW9ycGhhYmxlVHlwZSxcclxuICBtYWtlTW9ycGhhYmxlLFxyXG4gIFRyYW5zZm9ybUJhZyxcclxuICBPYmplY3RCYWcsXHJcbiAgTm9uTW9ycGhhYmxlXHJcbn1cclxuXHJcbmV4cG9ydCB7IGRlZmF1bHRzLCB1dGlscywgbmFtZXNwYWNlcywgcmVnZXggfVxyXG5leHBvcnQgY29uc3QgU1ZHID0gbWFrZUluc3RhbmNlXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2VyIH0gZnJvbSAnLi9tb2R1bGVzL2NvcmUvcGFyc2VyLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbmQgfSBmcm9tICcuL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcclxuZXhwb3J0ICogZnJvbSAnLi9tb2R1bGVzL2NvcmUvZXZlbnQuanMnXHJcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvYWRvcHRlci5qcydcclxuZXhwb3J0IHsgcmVnaXN0ZXJXaW5kb3cgfSBmcm9tICcuL3V0aWxzL3dpbmRvdy5qcydcclxuXHJcbi8qIEFuaW1hdGlvbiBNb2R1bGVzICovXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdGlvbi9BbmltYXRvci5qcydcclxuZXhwb3J0IHsgQ29udHJvbGxlciwgRWFzZSwgUElELCBTcHJpbmcsIGVhc2luZyB9IGZyb20gJy4vYW5pbWF0aW9uL0NvbnRyb2xsZXIuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUXVldWUgfSBmcm9tICcuL2FuaW1hdGlvbi9RdWV1ZS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSdW5uZXIgfSBmcm9tICcuL2FuaW1hdGlvbi9SdW5uZXIuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGltZWxpbmUgfSBmcm9tICcuL2FuaW1hdGlvbi9UaW1lbGluZS5qcydcclxuXHJcbi8qIFR5cGVzICovXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXJyYXkgfSBmcm9tICcuL3R5cGVzL1NWR0FycmF5LmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJveCB9IGZyb20gJy4vdHlwZXMvQm94LmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbG9yIH0gZnJvbSAnLi90eXBlcy9Db2xvci5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBFdmVudFRhcmdldCB9IGZyb20gJy4vdHlwZXMvRXZlbnRUYXJnZXQuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWF0cml4IH0gZnJvbSAnLi90eXBlcy9NYXRyaXguanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTnVtYmVyIH0gZnJvbSAnLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGF0aEFycmF5IH0gZnJvbSAnLi90eXBlcy9QYXRoQXJyYXkuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9pbnQgfSBmcm9tICcuL3R5cGVzL1BvaW50LmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvaW50QXJyYXkgfSBmcm9tICcuL3R5cGVzL1BvaW50QXJyYXkuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdCB9IGZyb20gJy4vdHlwZXMvTGlzdC5qcydcclxuXHJcbi8qIEVsZW1lbnRzICovXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2lyY2xlIH0gZnJvbSAnLi9lbGVtZW50cy9DaXJjbGUuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2xpcFBhdGggfSBmcm9tICcuL2VsZW1lbnRzL0NsaXBQYXRoLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbnRhaW5lciB9IGZyb20gJy4vZWxlbWVudHMvQ29udGFpbmVyLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIERlZnMgfSBmcm9tICcuL2VsZW1lbnRzL0RlZnMuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRG9tIH0gZnJvbSAnLi9lbGVtZW50cy9Eb20uanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRWxlbWVudCB9IGZyb20gJy4vZWxlbWVudHMvRWxlbWVudC5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbGxpcHNlIH0gZnJvbSAnLi9lbGVtZW50cy9FbGxpcHNlLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcmVpZ25PYmplY3QgfSBmcm9tICcuL2VsZW1lbnRzL0ZvcmVpZ25PYmplY3QuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JhZGllbnQgfSBmcm9tICcuL2VsZW1lbnRzL0dyYWRpZW50LmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEcgfSBmcm9tICcuL2VsZW1lbnRzL0cuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQSB9IGZyb20gJy4vZWxlbWVudHMvQS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbWFnZSB9IGZyb20gJy4vZWxlbWVudHMvSW1hZ2UuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGluZSB9IGZyb20gJy4vZWxlbWVudHMvTGluZS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXJrZXIgfSBmcm9tICcuL2VsZW1lbnRzL01hcmtlci5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrIH0gZnJvbSAnLi9lbGVtZW50cy9NYXNrLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhdGggfSBmcm9tICcuL2VsZW1lbnRzL1BhdGguanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGF0dGVybiB9IGZyb20gJy4vZWxlbWVudHMvUGF0dGVybi5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2x5Z29uIH0gZnJvbSAnLi9lbGVtZW50cy9Qb2x5Z29uLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvbHlsaW5lIH0gZnJvbSAnLi9lbGVtZW50cy9Qb2x5bGluZS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWN0IH0gZnJvbSAnLi9lbGVtZW50cy9SZWN0LmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNoYXBlIH0gZnJvbSAnLi9lbGVtZW50cy9TaGFwZS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdG9wIH0gZnJvbSAnLi9lbGVtZW50cy9TdG9wLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0eWxlIH0gZnJvbSAnLi9lbGVtZW50cy9TdHlsZS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdmcgfSBmcm9tICcuL2VsZW1lbnRzL1N2Zy5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTeW1ib2wgfSBmcm9tICcuL2VsZW1lbnRzL1N5bWJvbC5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0IH0gZnJvbSAnLi9lbGVtZW50cy9UZXh0LmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRQYXRoIH0gZnJvbSAnLi9lbGVtZW50cy9UZXh0UGF0aC5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUc3BhbiB9IGZyb20gJy4vZWxlbWVudHMvVHNwYW4uanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVXNlIH0gZnJvbSAnLi9lbGVtZW50cy9Vc2UuanMnXHJcblxyXG5leHRlbmQoW1xyXG4gIFN2ZyxcclxuICBTeW1ib2wsXHJcbiAgSW1hZ2UsXHJcbiAgUGF0dGVybixcclxuICBNYXJrZXJcclxuXSwgZ2V0TWV0aG9kc0Zvcigndmlld2JveCcpKVxyXG5cclxuZXh0ZW5kKFtcclxuICBMaW5lLFxyXG4gIFBvbHlsaW5lLFxyXG4gIFBvbHlnb24sXHJcbiAgUGF0aFxyXG5dLCBnZXRNZXRob2RzRm9yKCdtYXJrZXInKSlcclxuXHJcbmV4dGVuZChUZXh0LCBnZXRNZXRob2RzRm9yKCdUZXh0JykpXHJcbmV4dGVuZChQYXRoLCBnZXRNZXRob2RzRm9yKCdQYXRoJykpXHJcblxyXG5leHRlbmQoRGVmcywgZ2V0TWV0aG9kc0ZvcignRGVmcycpKVxyXG5cclxuZXh0ZW5kKFtcclxuICBUZXh0LFxyXG4gIFRzcGFuXHJcbl0sIGdldE1ldGhvZHNGb3IoJ1RzcGFuJykpXHJcblxyXG5leHRlbmQoW1xyXG4gIFJlY3QsXHJcbiAgRWxsaXBzZSxcclxuICBDaXJjbGUsXHJcbiAgR3JhZGllbnRcclxuXSwgZ2V0TWV0aG9kc0ZvcigncmFkaXVzJykpXHJcblxyXG5leHRlbmQoRXZlbnRUYXJnZXQsIGdldE1ldGhvZHNGb3IoJ0V2ZW50VGFyZ2V0JykpXHJcbmV4dGVuZChEb20sIGdldE1ldGhvZHNGb3IoJ0RvbScpKVxyXG5leHRlbmQoRWxlbWVudCwgZ2V0TWV0aG9kc0ZvcignRWxlbWVudCcpKVxyXG5leHRlbmQoU2hhcGUsIGdldE1ldGhvZHNGb3IoJ1NoYXBlJykpXHJcbi8vIGV4dGVuZChFbGVtZW50LCBnZXRDb25zdHJ1Y3RvcignTWVtb3J5JykpXHJcbmV4dGVuZChDb250YWluZXIsIGdldE1ldGhvZHNGb3IoJ0NvbnRhaW5lcicpKVxyXG5cclxuZXh0ZW5kKFJ1bm5lciwgZ2V0TWV0aG9kc0ZvcignUnVubmVyJykpXHJcblxyXG5MaXN0LmV4dGVuZChnZXRNZXRob2ROYW1lcygpKVxyXG5cclxucmVnaXN0ZXJNb3JwaGFibGVUeXBlKFtcclxuICBTVkdOdW1iZXIsXHJcbiAgQ29sb3IsXHJcbiAgQm94LFxyXG4gIE1hdHJpeCxcclxuICBTVkdBcnJheSxcclxuICBQb2ludEFycmF5LFxyXG4gIFBhdGhBcnJheVxyXG5dKVxyXG5cclxubWFrZU1vcnBoYWJsZSgpXHJcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtcXVhZHRyZWUvIHYxLjAuNyBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHRyZWVfYWRkKGQpIHtcbiAgdmFyIHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpLFxuICAgICAgeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCk7XG4gIHJldHVybiBhZGQodGhpcy5jb3Zlcih4LCB5KSwgeCwgeSwgZCk7XG59XG5cbmZ1bmN0aW9uIGFkZCh0cmVlLCB4LCB5LCBkKSB7XG4gIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIHRyZWU7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdHJlZS5fcm9vdCxcbiAgICAgIGxlYWYgPSB7ZGF0YTogZH0sXG4gICAgICB4MCA9IHRyZWUuX3gwLFxuICAgICAgeTAgPSB0cmVlLl95MCxcbiAgICAgIHgxID0gdHJlZS5feDEsXG4gICAgICB5MSA9IHRyZWUuX3kxLFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHhwLFxuICAgICAgeXAsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gRmluZCB0aGUgZXhpc3RpbmcgbGVhZiBmb3IgdGhlIG5ldyBwb2ludCwgb3IgYWRkIGl0LlxuICB3aGlsZSAobm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAocGFyZW50ID0gbm9kZSwgIShub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbiAgfVxuXG4gIC8vIElzIHRoZSBuZXcgcG9pbnQgaXMgZXhhY3RseSBjb2luY2lkZW50IHdpdGggdGhlIGV4aXN0aW5nIHBvaW50P1xuICB4cCA9ICt0cmVlLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgeXAgPSArdHJlZS5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIGlmICh4ID09PSB4cCAmJiB5ID09PSB5cCkgcmV0dXJuIGxlYWYubmV4dCA9IG5vZGUsIHBhcmVudCA/IHBhcmVudFtpXSA9IGxlYWYgOiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBPdGhlcndpc2UsIHNwbGl0IHRoZSBsZWFmIG5vZGUgdW50aWwgdGhlIG9sZCBhbmQgbmV3IHBvaW50IGFyZSBzZXBhcmF0ZWQuXG4gIGRvIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQgPyBwYXJlbnRbaV0gPSBuZXcgQXJyYXkoNCkgOiB0cmVlLl9yb290ID0gbmV3IEFycmF5KDQpO1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICB9IHdoaWxlICgoaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHQpID09PSAoaiA9ICh5cCA+PSB5bSkgPDwgMSB8ICh4cCA+PSB4bSkpKTtcbiAgcmV0dXJuIHBhcmVudFtqXSA9IG5vZGUsIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG59XG5cbmZ1bmN0aW9uIGFkZEFsbChkYXRhKSB7XG4gIHZhciBkLCBpLCBuID0gZGF0YS5sZW5ndGgsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHh6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeXogPSBuZXcgQXJyYXkobiksXG4gICAgICB4MCA9IEluZmluaXR5LFxuICAgICAgeTAgPSBJbmZpbml0eSxcbiAgICAgIHgxID0gLUluZmluaXR5LFxuICAgICAgeTEgPSAtSW5maW5pdHk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgcG9pbnRzIGFuZCB0aGVpciBleHRlbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCA9IGRhdGFbaV0pKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIGNvbnRpbnVlO1xuICAgIHh6W2ldID0geDtcbiAgICB5eltpXSA9IHk7XG4gICAgaWYgKHggPCB4MCkgeDAgPSB4O1xuICAgIGlmICh4ID4geDEpIHgxID0geDtcbiAgICBpZiAoeSA8IHkwKSB5MCA9IHk7XG4gICAgaWYgKHkgPiB5MSkgeTEgPSB5O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgd2VyZSBubyAodmFsaWQpIHBvaW50cywgYWJvcnQuXG4gIGlmICh4MCA+IHgxIHx8IHkwID4geTEpIHJldHVybiB0aGlzO1xuXG4gIC8vIEV4cGFuZCB0aGUgdHJlZSB0byBjb3ZlciB0aGUgbmV3IHBvaW50cy5cbiAgdGhpcy5jb3Zlcih4MCwgeTApLmNvdmVyKHgxLCB5MSk7XG5cbiAgLy8gQWRkIHRoZSBuZXcgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgYWRkKHRoaXMsIHh6W2ldLCB5eltpXSwgZGF0YVtpXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdHJlZV9jb3Zlcih4LCB5KSB7XG4gIGlmIChpc05hTih4ID0gK3gpIHx8IGlzTmFOKHkgPSAreSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MTtcblxuICAvLyBJZiB0aGUgcXVhZHRyZWUgaGFzIG5vIGV4dGVudCwgaW5pdGlhbGl6ZSB0aGVtLlxuICAvLyBJbnRlZ2VyIGV4dGVudCBhcmUgbmVjZXNzYXJ5IHNvIHRoYXQgaWYgd2UgbGF0ZXIgZG91YmxlIHRoZSBleHRlbnQsXG4gIC8vIHRoZSBleGlzdGluZyBxdWFkcmFudCBib3VuZGFyaWVzIGRvbuKAmXQgY2hhbmdlIGR1ZSB0byBmbG9hdGluZyBwb2ludCBlcnJvciFcbiAgaWYgKGlzTmFOKHgwKSkge1xuICAgIHgxID0gKHgwID0gTWF0aC5mbG9vcih4KSkgKyAxO1xuICAgIHkxID0gKHkwID0gTWF0aC5mbG9vcih5KSkgKyAxO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkb3VibGUgcmVwZWF0ZWRseSB0byBjb3Zlci5cbiAgZWxzZSB7XG4gICAgdmFyIHogPSB4MSAtIHgwLFxuICAgICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKHgwID4geCB8fCB4ID49IHgxIHx8IHkwID4geSB8fCB5ID49IHkxKSB7XG4gICAgICBpID0gKHkgPCB5MCkgPDwgMSB8ICh4IDwgeDApO1xuICAgICAgcGFyZW50ID0gbmV3IEFycmF5KDQpLCBwYXJlbnRbaV0gPSBub2RlLCBub2RlID0gcGFyZW50LCB6ICo9IDI7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOiB4MSA9IHgwICsgeiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDE6IHgwID0geDEgLSB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogeDEgPSB4MCArIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgICAgY2FzZSAzOiB4MCA9IHgxIC0geiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0cmVlX2RhdGEoKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvIGRhdGEucHVzaChub2RlLmRhdGEpOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiB0cmVlX2V4dGVudChfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuY292ZXIoK19bMF1bMF0sICtfWzBdWzFdKS5jb3ZlcigrX1sxXVswXSwgK19bMV1bMV0pXG4gICAgICA6IGlzTmFOKHRoaXMuX3gwKSA/IHVuZGVmaW5lZCA6IFtbdGhpcy5feDAsIHRoaXMuX3kwXSwgW3RoaXMuX3gxLCB0aGlzLl95MV1dO1xufVxuXG5mdW5jdGlvbiBRdWFkKG5vZGUsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMueDAgPSB4MDtcbiAgdGhpcy55MCA9IHkwO1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbn1cblxuZnVuY3Rpb24gdHJlZV9maW5kKHgsIHksIHJhZGl1cykge1xuICB2YXIgZGF0YSxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTIsXG4gICAgICB4MyA9IHRoaXMuX3gxLFxuICAgICAgeTMgPSB0aGlzLl95MSxcbiAgICAgIHF1YWRzID0gW10sXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHEsXG4gICAgICBpO1xuXG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHgwLCB5MCwgeDMsIHkzKSk7XG4gIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gIGVsc2Uge1xuICAgIHgwID0geCAtIHJhZGl1cywgeTAgPSB5IC0gcmFkaXVzO1xuICAgIHgzID0geCArIHJhZGl1cywgeTMgPSB5ICsgcmFkaXVzO1xuICAgIHJhZGl1cyAqPSByYWRpdXM7XG4gIH1cblxuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG5cbiAgICAvLyBTdG9wIHNlYXJjaGluZyBpZiB0aGlzIHF1YWRyYW50IGNhbuKAmXQgY29udGFpbiBhIGNsb3NlciBub2RlLlxuICAgIGlmICghKG5vZGUgPSBxLm5vZGUpXG4gICAgICAgIHx8ICh4MSA9IHEueDApID4geDNcbiAgICAgICAgfHwgKHkxID0gcS55MCkgPiB5M1xuICAgICAgICB8fCAoeDIgPSBxLngxKSA8IHgwXG4gICAgICAgIHx8ICh5MiA9IHEueTEpIDwgeTApIGNvbnRpbnVlO1xuXG4gICAgLy8gQmlzZWN0IHRoZSBjdXJyZW50IHF1YWRyYW50LlxuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgxICsgeDIpIC8gMixcbiAgICAgICAgICB5bSA9ICh5MSArIHkyKSAvIDI7XG5cbiAgICAgIHF1YWRzLnB1c2goXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbM10sIHhtLCB5bSwgeDIsIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsyXSwgeDEsIHltLCB4bSwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzFdLCB4bSwgeTEsIHgyLCB5bSksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMF0sIHgxLCB5MSwgeG0sIHltKVxuICAgICAgKTtcblxuICAgICAgLy8gVmlzaXQgdGhlIGNsb3Nlc3QgcXVhZHJhbnQgZmlyc3QuXG4gICAgICBpZiAoaSA9ICh5ID49IHltKSA8PCAxIHwgKHggPj0geG0pKSB7XG4gICAgICAgIHEgPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV0gPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXSA9IHE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmlzaXQgdGhpcyBwb2ludC4gKFZpc2l0aW5nIGNvaW5jaWRlbnQgcG9pbnRzIGlzbuKAmXQgbmVjZXNzYXJ5ISlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBkeCA9IHggLSArdGhpcy5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZHkgPSB5IC0gK3RoaXMuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZDIgPCByYWRpdXMpIHtcbiAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQocmFkaXVzID0gZDIpO1xuICAgICAgICB4MCA9IHggLSBkLCB5MCA9IHkgLSBkO1xuICAgICAgICB4MyA9IHggKyBkLCB5MyA9IHkgKyBkO1xuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiB0cmVlX3JlbW92ZShkKSB7XG4gIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcmV0YWluZXIsXG4gICAgICBwcmV2aW91cyxcbiAgICAgIG5leHQsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRmluZCB0aGUgbGVhZiBub2RlIGZvciB0aGUgcG9pbnQuXG4gIC8vIFdoaWxlIGRlc2NlbmRpbmcsIGFsc28gcmV0YWluIHRoZSBkZWVwZXN0IHBhcmVudCB3aXRoIGEgbm9uLXJlbW92ZWQgc2libGluZy5cbiAgaWYgKG5vZGUubGVuZ3RoKSB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmICghKHBhcmVudCA9IG5vZGUsIG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiB0aGlzO1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGJyZWFrO1xuICAgIGlmIChwYXJlbnRbKGkgKyAxKSAmIDNdIHx8IHBhcmVudFsoaSArIDIpICYgM10gfHwgcGFyZW50WyhpICsgMykgJiAzXSkgcmV0YWluZXIgPSBwYXJlbnQsIGogPSBpO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgcG9pbnQgdG8gcmVtb3ZlLlxuICB3aGlsZSAobm9kZS5kYXRhICE9PSBkKSBpZiAoIShwcmV2aW91cyA9IG5vZGUsIG5vZGUgPSBub2RlLm5leHQpKSByZXR1cm4gdGhpcztcbiAgaWYgKG5leHQgPSBub2RlLm5leHQpIGRlbGV0ZSBub2RlLm5leHQ7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvaW5jaWRlbnQgcG9pbnRzLCByZW1vdmUganVzdCB0aGUgcG9pbnQuXG4gIGlmIChwcmV2aW91cykgcmV0dXJuIChuZXh0ID8gcHJldmlvdXMubmV4dCA9IG5leHQgOiBkZWxldGUgcHJldmlvdXMubmV4dCksIHRoaXM7XG5cbiAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBwb2ludCwgcmVtb3ZlIGl0LlxuICBpZiAoIXBhcmVudCkgcmV0dXJuIHRoaXMuX3Jvb3QgPSBuZXh0LCB0aGlzO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlYWYuXG4gIG5leHQgPyBwYXJlbnRbaV0gPSBuZXh0IDogZGVsZXRlIHBhcmVudFtpXTtcblxuICAvLyBJZiB0aGUgcGFyZW50IG5vdyBjb250YWlucyBleGFjdGx5IG9uZSBsZWFmLCBjb2xsYXBzZSBzdXBlcmZsdW91cyBwYXJlbnRzLlxuICBpZiAoKG5vZGUgPSBwYXJlbnRbMF0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbM10pXG4gICAgICAmJiBub2RlID09PSAocGFyZW50WzNdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzBdKVxuICAgICAgJiYgIW5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJldGFpbmVyKSByZXRhaW5lcltqXSA9IG5vZGU7XG4gICAgZWxzZSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiByZW1vdmVBbGwoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRyZWVfcm9vdCgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59XG5cbmZ1bmN0aW9uIHRyZWVfc2l6ZSgpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyArK3NpemU7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIHRyZWVfdmlzaXQoY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIHEsIG5vZGUgPSB0aGlzLl9yb290LCBjaGlsZCwgeDAsIHkwLCB4MSwgeTE7XG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICBpZiAoIWNhbGxiYWNrKG5vZGUgPSBxLm5vZGUsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSkgJiYgbm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0cmVlX3Zpc2l0QWZ0ZXIoY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIG5leHQgPSBbXSwgcTtcbiAgaWYgKHRoaXMuX3Jvb3QpIHF1YWRzLnB1c2gobmV3IFF1YWQodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIHZhciBub2RlID0gcS5ub2RlO1xuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEsIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICB9XG4gICAgbmV4dC5wdXNoKHEpO1xuICB9XG4gIHdoaWxlIChxID0gbmV4dC5wb3AoKSkge1xuICAgIGNhbGxiYWNrKHEubm9kZSwgcS54MCwgcS55MCwgcS54MSwgcS55MSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmZ1bmN0aW9uIHRyZWVfeChfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3ggPSBfLCB0aGlzKSA6IHRoaXMuX3g7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRZKGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbmZ1bmN0aW9uIHRyZWVfeShfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3kgPSBfLCB0aGlzKSA6IHRoaXMuX3k7XG59XG5cbmZ1bmN0aW9uIHF1YWR0cmVlKG5vZGVzLCB4LCB5KSB7XG4gIHZhciB0cmVlID0gbmV3IFF1YWR0cmVlKHggPT0gbnVsbCA/IGRlZmF1bHRYIDogeCwgeSA9PSBudWxsID8gZGVmYXVsdFkgOiB5LCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICByZXR1cm4gbm9kZXMgPT0gbnVsbCA/IHRyZWUgOiB0cmVlLmFkZEFsbChub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIFF1YWR0cmVlKHgsIHksIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgdGhpcy5fcm9vdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbGVhZl9jb3B5KGxlYWYpIHtcbiAgdmFyIGNvcHkgPSB7ZGF0YTogbGVhZi5kYXRhfSwgbmV4dCA9IGNvcHk7XG4gIHdoaWxlIChsZWFmID0gbGVhZi5uZXh0KSBuZXh0ID0gbmV4dC5uZXh0ID0ge2RhdGE6IGxlYWYuZGF0YX07XG4gIHJldHVybiBjb3B5O1xufVxuXG52YXIgdHJlZVByb3RvID0gcXVhZHRyZWUucHJvdG90eXBlID0gUXVhZHRyZWUucHJvdG90eXBlO1xuXG50cmVlUHJvdG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyBRdWFkdHJlZSh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSksXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIG5vZGVzLFxuICAgICAgY2hpbGQ7XG5cbiAgaWYgKCFub2RlKSByZXR1cm4gY29weTtcblxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcblxuICBub2RlcyA9IFt7c291cmNlOiBub2RlLCB0YXJnZXQ6IGNvcHkuX3Jvb3QgPSBuZXcgQXJyYXkoNCl9XTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlLnNvdXJjZVtpXSkge1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDQpfSk7XG4gICAgICAgIGVsc2Ugbm9kZS50YXJnZXRbaV0gPSBsZWFmX2NvcHkoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xudHJlZVByb3RvLmFkZEFsbCA9IGFkZEFsbDtcbnRyZWVQcm90by5jb3ZlciA9IHRyZWVfY292ZXI7XG50cmVlUHJvdG8uZGF0YSA9IHRyZWVfZGF0YTtcbnRyZWVQcm90by5leHRlbnQgPSB0cmVlX2V4dGVudDtcbnRyZWVQcm90by5maW5kID0gdHJlZV9maW5kO1xudHJlZVByb3RvLnJlbW92ZSA9IHRyZWVfcmVtb3ZlO1xudHJlZVByb3RvLnJlbW92ZUFsbCA9IHJlbW92ZUFsbDtcbnRyZWVQcm90by5yb290ID0gdHJlZV9yb290O1xudHJlZVByb3RvLnNpemUgPSB0cmVlX3NpemU7XG50cmVlUHJvdG8udmlzaXQgPSB0cmVlX3Zpc2l0O1xudHJlZVByb3RvLnZpc2l0QWZ0ZXIgPSB0cmVlX3Zpc2l0QWZ0ZXI7XG50cmVlUHJvdG8ueCA9IHRyZWVfeDtcbnRyZWVQcm90by55ID0gdHJlZV95O1xuXG5leHBvcnRzLnF1YWR0cmVlID0gcXVhZHRyZWU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8qKlxuICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZGF0ID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9fXyRpbnNlcnRTdHlsZShjc3MpIHtcbiAgaWYgKCFjc3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICByZXR1cm4gY3NzO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvU3RyaW5nIChjb2xvciwgZm9yY2VDU1NIZXgpIHtcbiAgdmFyIGNvbG9yRm9ybWF0ID0gY29sb3IuX19zdGF0ZS5jb252ZXJzaW9uTmFtZS50b1N0cmluZygpO1xuICB2YXIgciA9IE1hdGgucm91bmQoY29sb3Iucik7XG4gIHZhciBnID0gTWF0aC5yb3VuZChjb2xvci5nKTtcbiAgdmFyIGIgPSBNYXRoLnJvdW5kKGNvbG9yLmIpO1xuICB2YXIgYSA9IGNvbG9yLmE7XG4gIHZhciBoID0gTWF0aC5yb3VuZChjb2xvci5oKTtcbiAgdmFyIHMgPSBjb2xvci5zLnRvRml4ZWQoMSk7XG4gIHZhciB2ID0gY29sb3Iudi50b0ZpeGVkKDEpO1xuICBpZiAoZm9yY2VDU1NIZXggfHwgY29sb3JGb3JtYXQgPT09ICdUSFJFRV9DSEFSX0hFWCcgfHwgY29sb3JGb3JtYXQgPT09ICdTSVhfQ0hBUl9IRVgnKSB7XG4gICAgdmFyIHN0ciA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCA2KSB7XG4gICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiAnIycgKyBzdHI7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCJykge1xuICAgIHJldHVybiAncmdiKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCQScpIHtcbiAgICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIRVgnKSB7XG4gICAgcmV0dXJuICcweCcgKyBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnXSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdSR0JBX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJ10nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX09CSicpIHtcbiAgICByZXR1cm4gJ3tyOicgKyByICsgJyxnOicgKyBnICsgJyxiOicgKyBiICsgJ30nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCQV9PQkonKSB7XG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICcsYTonICsgYSArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVl9PQkonKSB7XG4gICAgcmV0dXJuICd7aDonICsgaCArICcsczonICsgcyArICcsdjonICsgdiArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVkFfT0JKJykge1xuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnLGE6JyArIGEgKyAnfSc7XG4gIH1cbiAgcmV0dXJuICd1bmtub3duIGZvcm1hdCc7XG59XG5cbnZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBDb21tb24gPSB7XG4gIEJSRUFLOiB7fSxcbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5pc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCkge1xuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgY29tcG9zZTogZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9LFxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRyLCBzY29wZSkge1xuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHtcbiAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAgIGZvciAoa2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtfa2V5XSwgX2tleSkgPT09IHRoaXMuQlJFQUspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlcihmbmMpIHtcbiAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gIH0sXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB0aHJlc2hvbGQsIGNhbGxJbW1lZGlhdGVseSkge1xuICAgIHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghY2FsbEltbWVkaWF0ZWx5KSBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgY2FsbE5vdyA9IGNhbGxJbW1lZGlhdGVseSB8fCAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHRocmVzaG9sZCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICB9LFxuICBpc1VuZGVmaW5lZDogZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9LFxuICBpc05hTjogZnVuY3Rpb24gKF9pc05hTikge1xuICAgIGZ1bmN0aW9uIGlzTmFOKF94KSB7XG4gICAgICByZXR1cm4gX2lzTmFOLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlzTmFOLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pc05hTi50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzTmFOO1xuICB9KGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gaXNOYU4ob2JqKTtcbiAgfSksXG4gIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gIH0sXG4gIGlzTnVtYmVyOiBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBvYmogKyAwO1xuICB9LFxuICBpc1N0cmluZzogZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgJyc7XG4gIH0sXG4gIGlzQm9vbGVhbjogZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgfSxcbiAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH1cbn07XG5cbnZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG57XG4gIGxpdG11czogQ29tbW9uLmlzU3RyaW5nLFxuICBjb252ZXJzaW9uczoge1xuICAgIFRIUkVFX0NIQVJfSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBTSVhfQ0hBUl9IRVg6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCQToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKSxcbiAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGNvbG9yVG9TdHJpbmdcbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzTnVtYmVyLFxuICBjb252ZXJzaW9uczoge1xuICAgIEhFWDoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICBoZXg6IG9yaWdpbmFsLFxuICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IuaGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNBcnJheSxcbiAgY29udmVyc2lvbnM6IHtcbiAgICBSR0JfQVJSQVk6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICBiOiBvcmlnaW5hbFsyXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xuICAgICAgfVxuICAgIH0sXG4gICAgUkdCQV9BUlJBWToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9PSA0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuICAgICAgICAgIGE6IG9yaWdpbmFsWzNdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV07XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc09iamVjdCxcbiAgY29udmVyc2lvbnM6IHtcbiAgICBSR0JBX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBSR0JfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgIGI6IG9yaWdpbmFsLmJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgSFNWQV9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXG4gICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgSFNWX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgIHY6IGNvbG9yLnZcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dO1xudmFyIHJlc3VsdCA9IHZvaWQgMDtcbnZhciB0b1JldHVybiA9IHZvaWQgMDtcbnZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiBpbnRlcnByZXQoKSB7XG4gIHRvUmV0dXJuID0gZmFsc2U7XG4gIHZhciBvcmlnaW5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gQ29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcbiAgQ29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG4gICAgICBDb21tb24uZWFjaChmYW1pbHkuY29udmVyc2lvbnMsIGZ1bmN0aW9uIChjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xuICAgICAgICBpZiAodG9SZXR1cm4gPT09IGZhbHNlICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcbiAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICByZXN1bHQuY29udmVyc2lvbiA9IGNvbnZlcnNpb247XG4gICAgICAgICAgcmV0dXJuIENvbW1vbi5CUkVBSztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29tbW9uLkJSRUFLO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0b1JldHVybjtcbn07XG5cbnZhciB0bXBDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgQ29sb3JNYXRoID0ge1xuICBoc3ZfdG9fcmdiOiBmdW5jdGlvbiBoc3ZfdG9fcmdiKGgsIHMsIHYpIHtcbiAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGggLyA2MCkgJSA2O1xuICAgIHZhciBmID0gaCAvIDYwIC0gTWF0aC5mbG9vcihoIC8gNjApO1xuICAgIHZhciBwID0gdiAqICgxLjAgLSBzKTtcbiAgICB2YXIgcSA9IHYgKiAoMS4wIC0gZiAqIHMpO1xuICAgIHZhciB0ID0gdiAqICgxLjAgLSAoMS4wIC0gZikgKiBzKTtcbiAgICB2YXIgYyA9IFtbdiwgdCwgcF0sIFtxLCB2LCBwXSwgW3AsIHYsIHRdLCBbcCwgcSwgdl0sIFt0LCBwLCB2XSwgW3YsIHAsIHFdXVtoaV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IGNbMF0gKiAyNTUsXG4gICAgICBnOiBjWzFdICogMjU1LFxuICAgICAgYjogY1syXSAqIDI1NVxuICAgIH07XG4gIH0sXG4gIHJnYl90b19oc3Y6IGZ1bmN0aW9uIHJnYl90b19oc3YociwgZywgYikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuICAgIHZhciBoID0gdm9pZCAwO1xuICAgIHZhciBzID0gdm9pZCAwO1xuICAgIGlmIChtYXggIT09IDApIHtcbiAgICAgIHMgPSBkZWx0YSAvIG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogTmFOLFxuICAgICAgICBzOiAwLFxuICAgICAgICB2OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAociA9PT0gbWF4KSB7XG4gICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgIH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG4gICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgfVxuICAgIGggLz0gNjtcbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGg6IGggKiAzNjAsXG4gICAgICBzOiBzLFxuICAgICAgdjogbWF4IC8gMjU1XG4gICAgfTtcbiAgfSxcbiAgcmdiX3RvX2hleDogZnVuY3Rpb24gcmdiX3RvX2hleChyLCBnLCBiKSB7XG4gICAgdmFyIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KDAsIDIsIHIpO1xuICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG4gICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICByZXR1cm4gaGV4O1xuICB9LFxuICBjb21wb25lbnRfZnJvbV9oZXg6IGZ1bmN0aW9uIGNvbXBvbmVudF9mcm9tX2hleChoZXgsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgcmV0dXJuIGhleCA+PiBjb21wb25lbnRJbmRleCAqIDggJiAweEZGO1xuICB9LFxuICBoZXhfd2l0aF9jb21wb25lbnQ6IGZ1bmN0aW9uIGhleF93aXRoX2NvbXBvbmVudChoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8PCAodG1wQ29tcG9uZW50ID0gY29tcG9uZW50SW5kZXggKiA4KSB8IGhleCAmIH4oMHhGRiA8PCB0bXBDb21wb25lbnQpO1xuICB9XG59O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgfVxufTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxudmFyIENvbG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2xvcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvcik7XG4gICAgdGhpcy5fX3N0YXRlID0gaW50ZXJwcmV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgdGhpcy5fX3N0YXRlLmEgPSB0aGlzLl9fc3RhdGUuYSB8fCAxO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENvbG9yLCBbe1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gY29sb3JUb1N0cmluZyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0hleFN0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSGV4U3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGNvbG9yVG9TdHJpbmcodGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9PcmlnaW5hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvT3JpZ2luYWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb2xvcjtcbn0oKTtcbmZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICB9XG4gICAgICBDb2xvci5yZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdSR0InKSB7XG4gICAgICAgIENvbG9yLnJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgfVxuICAgICAgQ29sb3IucmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSFNWJykge1xuICAgICAgICBDb2xvci5yZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XG4gICAgICB9XG4gICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG4gICAgfVxuICB9KTtcbn1cbkNvbG9yLnJlY2FsY3VsYXRlUkdCID0gZnVuY3Rpb24gKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG4gIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSEVYJykge1xuICAgIGNvbG9yLl9fc3RhdGVbY29tcG9uZW50XSA9IENvbG9yTWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuICAgIENvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwgQ29sb3JNYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29ycnVwdGVkIGNvbG9yIHN0YXRlJyk7XG4gIH1cbn07XG5Db2xvci5yZWNhbGN1bGF0ZUhTViA9IGZ1bmN0aW9uIChjb2xvcikge1xuICB2YXIgcmVzdWx0ID0gQ29sb3JNYXRoLnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIENvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwge1xuICAgIHM6IHJlc3VsdC5zLFxuICAgIHY6IHJlc3VsdC52XG4gIH0pO1xuICBpZiAoIUNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICBjb2xvci5fX3N0YXRlLmggPSByZXN1bHQuaDtcbiAgfSBlbHNlIGlmIChDb21tb24uaXNVbmRlZmluZWQoY29sb3IuX19zdGF0ZS5oKSkge1xuICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gIH1cbn07XG5Db2xvci5DT01QT05FTlRTID0gWydyJywgJ2cnLCAnYicsICdoJywgJ3MnLCAndicsICdoZXgnLCAnYSddO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3InLCAyKTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2gnKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgIHJldHVybiB0aGlzLl9fc3RhdGUuYTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICBpZiAoIXRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hFWCcpIHtcbiAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSBDb2xvck1hdGgucmdiX3RvX2hleCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcbiAgfVxufSk7XG5cbnZhciBDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sbGVyKTtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIHRoaXMuX19vbkNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdvbkNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlKGZuYykge1xuICAgICAgdGhpcy5fX29uQ2hhbmdlID0gZm5jO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GaW5pc2hDaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZpbmlzaENoYW5nZShmbmMpIHtcbiAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IGZuYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzTW9kaWZpZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc01vZGlmaWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlICE9PSB0aGlzLmdldFZhbHVlKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb250cm9sbGVyO1xufSgpO1xuXG52YXIgRVZFTlRfTUFQID0ge1xuICBIVE1MRXZlbnRzOiBbJ2NoYW5nZSddLFxuICBNb3VzZUV2ZW50czogWydjbGljaycsICdtb3VzZW1vdmUnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2VvdmVyJ10sXG4gIEtleWJvYXJkRXZlbnRzOiBbJ2tleWRvd24nXVxufTtcbnZhciBFVkVOVF9NQVBfSU5WID0ge307XG5Db21tb24uZWFjaChFVkVOVF9NQVAsIGZ1bmN0aW9uICh2LCBrKSB7XG4gIENvbW1vbi5lYWNoKHYsIGZ1bmN0aW9uIChlKSB7XG4gICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XG4gIH0pO1xufSk7XG52YXIgQ1NTX1ZBTFVFX1BJWEVMUyA9IC8oXFxkKyhcXC5cXGQrKT8pcHgvO1xuZnVuY3Rpb24gY3NzVmFsdWVUb1BpeGVscyh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gJzAnIHx8IENvbW1vbi5pc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKENTU19WQUxVRV9QSVhFTFMpO1xuICBpZiAoIUNvbW1vbi5pc051bGwobWF0Y2gpKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIGRvbSA9IHtcbiAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uIG1ha2VTZWxlY3RhYmxlKGVsZW0sIHNlbGVjdGFibGUpIHtcbiAgICBpZiAoZWxlbSA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uc3R5bGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGVsZW0ub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIGVsZW0uc3R5bGUuTW96VXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgZWxlbS5zdHlsZS5LaHRtbFVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIGVsZW0udW5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZSA/ICdvbicgOiAnb2ZmJztcbiAgfSxcbiAgbWFrZUZ1bGxzY3JlZW46IGZ1bmN0aW9uIG1ha2VGdWxsc2NyZWVuKGVsZW0sIGhvciwgdmVydCkge1xuICAgIHZhciB2ZXJ0aWNhbCA9IHZlcnQ7XG4gICAgdmFyIGhvcml6b250YWwgPSBob3I7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChob3Jpem9udGFsKSkge1xuICAgICAgaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQodmVydGljYWwpKSB7XG4gICAgICB2ZXJ0aWNhbCA9IHRydWU7XG4gICAgfVxuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICBlbGVtLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IDA7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgZWxlbS5zdHlsZS50b3AgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSAwO1xuICAgIH1cbiAgfSxcbiAgZmFrZUV2ZW50OiBmdW5jdGlvbiBmYWtlRXZlbnQoZWxlbSwgZXZlbnRUeXBlLCBwYXJzLCBhdXgpIHtcbiAgICB2YXIgcGFyYW1zID0gcGFycyB8fCB7fTtcbiAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgJyArIGV2ZW50VHlwZSArICcgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGNsYXNzTmFtZSk7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjbGllbnRYID0gcGFyYW1zLnggfHwgcGFyYW1zLmNsaWVudFggfHwgMDtcbiAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XG4gICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUsIHdpbmRvdywgcGFyYW1zLmNsaWNrQ291bnQgfHwgMSwgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ0tleWJvYXJkRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbml0ID0gZXZ0LmluaXRLZXlib2FyZEV2ZW50IHx8IGV2dC5pbml0S2V5RXZlbnQ7XG4gICAgICAgICAgQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAga2V5Q29kZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUsIHdpbmRvdywgcGFyYW1zLmN0cmxLZXksIHBhcmFtcy5hbHRLZXksIHBhcmFtcy5zaGlmdEtleSwgcGFyYW1zLm1ldGFLZXksIHBhcmFtcy5rZXlDb2RlLCBwYXJhbXMuY2hhckNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb21tb24uZGVmYXVsdHMoZXZ0LCBhdXgpO1xuICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9LFxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09PSAtMSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gY2xhc3NOYW1lKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpLnRlc3QoZWxlbS5jbGFzc05hbWUpIHx8IGZhbHNlO1xuICB9LFxuICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoZWxlbSkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1sZWZ0J10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1yaWdodCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUud2lkdGgpO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uIGdldEhlaWdodChlbGVtKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXRvcCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZS5oZWlnaHQpO1xuICB9LFxuICBnZXRPZmZzZXQ6IGZ1bmN0aW9uIGdldE9mZnNldChlbCkge1xuICAgIHZhciBlbGVtID0gZWw7XG4gICAgdmFyIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgaWYgKGVsZW0ub2Zmc2V0UGFyZW50KSB7XG4gICAgICBkbyB7XG4gICAgICAgIG9mZnNldC5sZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgICAgb2Zmc2V0LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAoZWxlbSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH0sXG4gIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZShlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYpO1xuICB9XG59O1xuXG52YXIgQm9vbGVhbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoQm9vbGVhbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJvb2xlYW5Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQm9vbGVhbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19wcmV2ID0gX3RoaXMyLmdldFZhbHVlKCk7XG4gICAgX3RoaXMyLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoIV90aGlzLl9fcHJldik7XG4gICAgfVxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2NoZWNrYm94LCAnY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19jaGVja2JveCk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKEJvb2xlYW5Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIHRvUmV0dXJuID0gZ2V0KEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIGlmICh0aGlzLmdldFZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG52YXIgT3B0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhPcHRpb25Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgb3B0cykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPcHRpb25Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBvcHRpb25zID0gb3B0cztcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgaWYgKENvbW1vbi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBtYXBbZWxlbWVudF0gPSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgICBvcHRpb25zID0gbWFwO1xuICAgIH1cbiAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0LmlubmVySFRNTCA9IGtleTtcbiAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgX3RoaXMuX19zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgIF90aGlzLnNldFZhbHVlKGRlc2lyZWRWYWx1ZSk7XG4gICAgfSk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2VsZWN0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE9wdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgdG9SZXR1cm4gPSBnZXQoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoZG9tLmlzQWN0aXZlKHRoaXMuX19zZWxlY3QpKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX19zZWxlY3QudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gZ2V0KE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBPcHRpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIFN0cmluZ0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoU3RyaW5nQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpbmdDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyaW5nQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ0NvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKFN0cmluZ0NvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoIWRvbS5pc0FjdGl2ZSh0aGlzLl9faW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XG4gIHZhciBfeCA9IHgudG9TdHJpbmcoKTtcbiAgaWYgKF94LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIF94Lmxlbmd0aCAtIF94LmluZGV4T2YoJy4nKSAtIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3BhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBfdGhpcy5fX21pbiA9IF9wYXJhbXMubWluO1xuICAgIF90aGlzLl9fbWF4ID0gX3BhcmFtcy5tYXg7XG4gICAgX3RoaXMuX19zdGVwID0gX3BhcmFtcy5zdGVwO1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoX3RoaXMuX19zdGVwKSkge1xuICAgICAgaWYgKF90aGlzLmluaXRpYWxWYWx1ZSA9PT0gMCkge1xuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyhfdGhpcy5pbml0aWFsVmFsdWUpKSAvIE1hdGguTE4xMCkpIC8gMTA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBfdGhpcy5fX3N0ZXA7XG4gICAgfVxuICAgIF90aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHMoX3RoaXMuX19pbXBsaWVkU3RlcCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgX3YgPSB2O1xuICAgICAgaWYgKHRoaXMuX19taW4gIT09IHVuZGVmaW5lZCAmJiBfdiA8IHRoaXMuX19taW4pIHtcbiAgICAgICAgX3YgPSB0aGlzLl9fbWluO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbWF4ICE9PSB1bmRlZmluZWQgJiYgX3YgPiB0aGlzLl9fbWF4KSB7XG4gICAgICAgIF92ID0gdGhpcy5fX21heDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fc3RlcCAhPT0gdW5kZWZpbmVkICYmIF92ICUgdGhpcy5fX3N0ZXAgIT09IDApIHtcbiAgICAgICAgX3YgPSBNYXRoLnJvdW5kKF92IC8gdGhpcy5fX3N0ZXApICogdGhpcy5fX3N0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIF92KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4obWluVmFsdWUpIHtcbiAgICAgIHRoaXMuX19taW4gPSBtaW5WYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21heCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heChtYXhWYWx1ZSkge1xuICAgICAgdGhpcy5fX21heCA9IG1heFZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RlcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXAoc3RlcFZhbHVlKSB7XG4gICAgICB0aGlzLl9fc3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyhzdGVwVmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gcm91bmRUb0RlY2ltYWwodmFsdWUsIGRlY2ltYWxzKSB7XG4gIHZhciB0ZW5UbyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogdGVuVG8pIC8gdGVuVG87XG59XG52YXIgTnVtYmVyQ29udHJvbGxlckJveCA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyQm94LCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlckJveCk7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXJCb3guX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyQm94KSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpKTtcbiAgICBfdGhpczIuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIHZhciBwcmV2WSA9IHZvaWQgMDtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHZhciBhdHRlbXB0ZWQgPSBwYXJzZUZsb2F0KF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgICAgaWYgKCFDb21tb24uaXNOYU4oYXR0ZW1wdGVkKSkge1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShhdHRlbXB0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkZpbmlzaCgpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcbiAgICAgIHZhciBkaWZmID0gcHJldlkgLSBlLmNsaWVudFk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5nZXRWYWx1ZSgpICsgZGlmZiAqIF90aGlzLl9faW1wbGllZFN0ZXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgb25GaW5pc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXJCb3gsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA/IHRoaXMuZ2V0VmFsdWUoKSA6IHJvdW5kVG9EZWNpbWFsKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fX3ByZWNpc2lvbik7XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94O1xufShOdW1iZXJDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gbWFwKHYsIGkxLCBpMiwgbzEsIG8yKSB7XG4gIHJldHVybiBvMSArIChvMiAtIG8xKSAqICgodiAtIGkxKSAvIChpMiAtIGkxKSk7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgbWluLCBtYXgsIHN0ZXApIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyU2xpZGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlclNsaWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJTbGlkZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwIH0pKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2ZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19iYWNrZ3JvdW5kLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2JhY2tncm91bmQsICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ3NsaWRlcicpO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19mb3JlZ3JvdW5kLCAnc2xpZGVyLWZnJyk7XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uTW91c2VEcmFnKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGUuY2xpZW50WCwgYmdSZWN0LmxlZnQsIGJnUmVjdC5yaWdodCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgICAgb25Ub3VjaE1vdmUoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICAgIHZhciBjbGllbnRYID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGNsaWVudFgsIGJnUmVjdC5sZWZ0LCBiZ1JlY3QucmlnaHQsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fZm9yZWdyb3VuZCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fYmFja2dyb3VuZCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdmFyIHBjdCA9ICh0aGlzLmdldFZhbHVlKCkgLSB0aGlzLl9fbWluKSAvICh0aGlzLl9fbWF4IC0gdGhpcy5fX21pbik7XG4gICAgICB0aGlzLl9fZm9yZWdyb3VuZC5zdHlsZS53aWR0aCA9IHBjdCAqIDEwMCArICclJztcbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXI7XG59KE51bWJlckNvbnRyb2xsZXIpO1xuXG52YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKEZ1bmN0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgdGV4dCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZ1bmN0aW9uQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19idXR0b24uaW5uZXJIVE1MID0gdGV4dCA9PT0gdW5kZWZpbmVkID8gJ0ZpcmUnIDogdGV4dDtcbiAgICBkb20uYmluZChfdGhpczIuX19idXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5maXJlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2J1dHRvbiwgJ2J1dHRvbicpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2J1dHRvbik7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhGdW5jdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZmlyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRWYWx1ZSgpLmNhbGwodGhpcy5vYmplY3QpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRnVuY3Rpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIENvbG9yQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhDb2xvckNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvckNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xvckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICBfdGhpczIuX19jb2xvciA9IG5ldyBDb2xvcihfdGhpczIuZ2V0VmFsdWUoKSk7XG4gICAgX3RoaXMyLl9fdGVtcCA9IG5ldyBDb2xvcigwKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20ubWFrZVNlbGVjdGFibGUoX3RoaXMyLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBfdGhpczIuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmNsYXNzTmFtZSA9ICdzZWxlY3Rvcic7XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lID0gJ3NhdHVyYXRpb24tZmllbGQnO1xuICAgIF90aGlzMi5fX2ZpZWxkX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19maWVsZF9rbm9iLmNsYXNzTmFtZSA9ICdmaWVsZC1rbm9iJztcbiAgICBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciA9ICcycHggc29saWQgJztcbiAgICBfdGhpczIuX19odWVfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2h1ZV9rbm9iLmNsYXNzTmFtZSA9ICdodWUta25vYic7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkLmNsYXNzTmFtZSA9ICdodWUtZmllbGQnO1xuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIF90aGlzMi5fX2lucHV0X3RleHRTaGFkb3cgPSAnMCAxcHggMXB4ICc7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIG9uQmx1ci5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSAgICAgICAge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMsICdkcmFnJykuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gKCkgICAgICAgIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19zZWxlY3RvciwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoKSAgICAgICAge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMsICdkcmFnJykuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZ1bmN0aW9uICgpICAgICAgICB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHZhbHVlRmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX3NlbGVjdG9yLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEyMnB4JyxcbiAgICAgIGhlaWdodDogJzEwMnB4JyxcbiAgICAgIHBhZGRpbmc6ICczcHgnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzIyMicsXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTJweCcsXG4gICAgICBoZWlnaHQ6ICcxMnB4JyxcbiAgICAgIGJvcmRlcjogX3RoaXMyLl9fZmllbGRfa25vYl9ib3JkZXIgKyAoX3RoaXMyLl9fY29sb3IudiA8IDAuNSA/ICcjZmZmJyA6ICcjMDAwJyksXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuNSknLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2h1ZV9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcycHgnLFxuICAgICAgYm9yZGVyUmlnaHQ6ICc0cHggc29saWQgI2ZmZicsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwcHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgbWFyZ2luUmlnaHQ6ICczcHgnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQodmFsdWVGaWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgYmFja2dyb3VuZDogJ25vbmUnXG4gICAgfSk7XG4gICAgbGluZWFyR3JhZGllbnQodmFsdWVGaWVsZCwgJ3RvcCcsICdyZ2JhKDAsMCwwLDApJywgJyMwMDAnKTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2h1ZV9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIGN1cnNvcjogJ25zLXJlc2l6ZScsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogJzNweCcsXG4gICAgICByaWdodDogJzNweCdcbiAgICB9KTtcbiAgICBodWVHcmFkaWVudChfdGhpczIuX19odWVfZmllbGQpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgdGV4dFNoYWRvdzogX3RoaXMyLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKDAsMCwwLDAuNyknXG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2ZpZWxkX2tub2IsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2ZpZWxkX2tub2IsICd0b3VjaHN0YXJ0JywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19odWVfZmllbGQsICdtb3VzZWRvd24nLCBmaWVsZERvd25IKTtcbiAgICBkb20uYmluZChfdGhpczIuX19odWVfZmllbGQsICd0b3VjaHN0YXJ0JywgZmllbGREb3duSCk7XG4gICAgZnVuY3Rpb24gZmllbGREb3duKGUpIHtcbiAgICAgIHNldFNWKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBTVik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkRG93bkgoZSkge1xuICAgICAgc2V0SChlKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcEgpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwSCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkVXBTVigpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwU1YpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBTVik7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaWVsZFVwSCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldEgpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcEgpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBIKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMudmFsdWUpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzLl9fY29sb3IuX19zdGF0ZSA9IGk7XG4gICAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBfdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRmluaXNoKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuYXBwZW5kQ2hpbGQodmFsdWVGaWVsZCk7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fZmllbGRfa25vYik7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faHVlX2ZpZWxkKTtcbiAgICBfdGhpczIuX19odWVfZmllbGQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faHVlX2tub2IpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19zZWxlY3Rvcik7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBmdW5jdGlvbiBzZXRTVihlKSB7XG4gICAgICBpZiAoZS50eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IC0xKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmaWVsZFJlY3QgPSBfdGhpcy5fX3NhdHVyYXRpb25fZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgX3JlZiA9IGUudG91Y2hlcyAmJiBlLnRvdWNoZXNbMF0gfHwgZSxcbiAgICAgICAgICBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmLmNsaWVudFk7XG4gICAgICB2YXIgcyA9IChjbGllbnRYIC0gZmllbGRSZWN0LmxlZnQpIC8gKGZpZWxkUmVjdC5yaWdodCAtIGZpZWxkUmVjdC5sZWZ0KTtcbiAgICAgIHZhciB2ID0gMSAtIChjbGllbnRZIC0gZmllbGRSZWN0LnRvcCkgLyAoZmllbGRSZWN0LmJvdHRvbSAtIGZpZWxkUmVjdC50b3ApO1xuICAgICAgaWYgKHYgPiAxKSB7XG4gICAgICAgIHYgPSAxO1xuICAgICAgfSBlbHNlIGlmICh2IDwgMCkge1xuICAgICAgICB2ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChzID4gMSkge1xuICAgICAgICBzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocyA8IDApIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICB9XG4gICAgICBfdGhpcy5fX2NvbG9yLnYgPSB2O1xuICAgICAgX3RoaXMuX19jb2xvci5zID0gcztcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0SChlKSB7XG4gICAgICBpZiAoZS50eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IC0xKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmaWVsZFJlY3QgPSBfdGhpcy5fX2h1ZV9maWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBfcmVmMiA9IGUudG91Y2hlcyAmJiBlLnRvdWNoZXNbMF0gfHwgZSxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZjIuY2xpZW50WTtcbiAgICAgIHZhciBoID0gMSAtIChjbGllbnRZIC0gZmllbGRSZWN0LnRvcCkgLyAoZmllbGRSZWN0LmJvdHRvbSAtIGZpZWxkUmVjdC50b3ApO1xuICAgICAgaWYgKGggPiAxKSB7XG4gICAgICAgIGggPSAxO1xuICAgICAgfSBlbHNlIGlmIChoIDwgMCkge1xuICAgICAgICBoID0gMDtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9fY29sb3IuaCA9IGggKiAzNjA7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29sb3JDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuICAgICAgICB2YXIgbWlzbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgQ29tbW9uLmVhY2goQ29sb3IuQ09NUE9ORU5UUywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgIGlmICghQ29tbW9uLmlzVW5kZWZpbmVkKGlbY29tcG9uZW50XSkgJiYgIUNvbW1vbi5pc1VuZGVmaW5lZCh0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSAmJiBpW2NvbXBvbmVudF0gIT09IHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pIHtcbiAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBpZiAobWlzbWF0Y2gpIHtcbiAgICAgICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19jb2xvci5fX3N0YXRlLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fdGVtcC5fX3N0YXRlLCB0aGlzLl9fY29sb3IuX19zdGF0ZSk7XG4gICAgICB0aGlzLl9fdGVtcC5hID0gMTtcbiAgICAgIHZhciBmbGlwID0gdGhpcy5fX2NvbG9yLnYgPCAwLjUgfHwgdGhpcy5fX2NvbG9yLnMgPiAwLjUgPyAyNTUgOiAwO1xuICAgICAgdmFyIF9mbGlwID0gMjU1IC0gZmxpcDtcbiAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgICAgbWFyZ2luTGVmdDogMTAwICogdGhpcy5fX2NvbG9yLnMgLSA3ICsgJ3B4JyxcbiAgICAgICAgbWFyZ2luVG9wOiAxMDAgKiAoMSAtIHRoaXMuX19jb2xvci52KSAtIDcgKyAncHgnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCksXG4gICAgICAgIGJvcmRlcjogdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyICsgJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX19odWVfa25vYi5zdHlsZS5tYXJnaW5Ub3AgPSAoMSAtIHRoaXMuX19jb2xvci5oIC8gMzYwKSAqIDEwMCArICdweCc7XG4gICAgICB0aGlzLl9fdGVtcC5zID0gMTtcbiAgICAgIHRoaXMuX190ZW1wLnYgPSAxO1xuICAgICAgbGluZWFyR3JhZGllbnQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQsICdsZWZ0JywgJyNmZmYnLCB0aGlzLl9fdGVtcC50b0hleFN0cmluZygpKTtcbiAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9fY29sb3IudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgY29sb3I6ICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArICcpJyxcbiAgICAgICAgdGV4dFNoYWRvdzogdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywuNyknXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbG9yQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG52YXIgdmVuZG9ycyA9IFsnLW1vei0nLCAnLW8tJywgJy13ZWJraXQtJywgJy1tcy0nLCAnJ107XG5mdW5jdGlvbiBsaW5lYXJHcmFkaWVudChlbGVtLCB4LCBhLCBiKSB7XG4gIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICBDb21tb24uZWFjaCh2ZW5kb3JzLCBmdW5jdGlvbiAodmVuZG9yKSB7XG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAnICsgdmVuZG9yICsgJ2xpbmVhci1ncmFkaWVudCgnICsgeCArICcsICcgKyBhICsgJyAwJSwgJyArIGIgKyAnIDEwMCUpOyAnO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGh1ZUdyYWRpZW50KGVsZW0pIHtcbiAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwgI2ZmMDBmZiAxNyUsICMwMDAwZmYgMzQlLCAjMDBmZmZmIDUwJSwgIzAwZmYwMCA2NyUsICNmZmZmMDAgODQlLCAjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xufVxuXG52YXIgY3NzID0ge1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKHVybCwgaW5kb2MpIHtcbiAgICB2YXIgZG9jID0gaW5kb2MgfHwgZG9jdW1lbnQ7XG4gICAgdmFyIGxpbmsgPSBkb2MuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgIGxpbmsudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgbGluay5ocmVmID0gdXJsO1xuICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGxpbmspO1xuICB9LFxuICBpbmplY3Q6IGZ1bmN0aW9uIGluamVjdChjc3NDb250ZW50LCBpbmRvYykge1xuICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcbiAgICB2YXIgaW5qZWN0ZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGluamVjdGVkLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIGluamVjdGVkLmlubmVySFRNTCA9IGNzc0NvbnRlbnQ7XG4gICAgdmFyIGhlYWQgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICB0cnkge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChpbmplY3RlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgfVxufTtcblxudmFyIHNhdmVEaWFsb2dDb250ZW50cyA9IFwiPGRpdiBpZD1cXFwiZGctc2F2ZVxcXCIgY2xhc3M9XFxcImRnIGRpYWxvZ3VlXFxcIj5cXG5cXG4gIEhlcmUncyB0aGUgbmV3IGxvYWQgcGFyYW1ldGVyIGZvciB5b3VyIDxjb2RlPkdVSTwvY29kZT4ncyBjb25zdHJ1Y3RvcjpcXG5cXG4gIDx0ZXh0YXJlYSBpZD1cXFwiZGctbmV3LWNvbnN0cnVjdG9yXFxcIj48L3RleHRhcmVhPlxcblxcbiAgPGRpdiBpZD1cXFwiZGctc2F2ZS1sb2NhbGx5XFxcIj5cXG5cXG4gICAgPGlucHV0IGlkPVxcXCJkZy1sb2NhbC1zdG9yYWdlXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIvPiBBdXRvbWF0aWNhbGx5IHNhdmVcXG4gICAgdmFsdWVzIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gb24gZXhpdC5cXG5cXG4gICAgPGRpdiBpZD1cXFwiZGctbG9jYWwtZXhwbGFpblxcXCI+VGhlIHZhbHVlcyBzYXZlZCB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IHdpbGxcXG4gICAgICBvdmVycmlkZSB0aG9zZSBwYXNzZWQgdG8gPGNvZGU+ZGF0LkdVSTwvY29kZT4ncyBjb25zdHJ1Y3Rvci4gVGhpcyBtYWtlcyBpdFxcbiAgICAgIGVhc2llciB0byB3b3JrIGluY3JlbWVudGFsbHksIGJ1dCA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IGlzIGZyYWdpbGUsXFxuICAgICAgYW5kIHlvdXIgZnJpZW5kcyBtYXkgbm90IHNlZSB0aGUgc2FtZSB2YWx1ZXMgeW91IGRvLlxcblxcbiAgICA8L2Rpdj5cXG5cXG4gIDwvZGl2PlxcblxcbjwvZGl2PlwiO1xuXG52YXIgQ29udHJvbGxlckZhY3RvcnkgPSBmdW5jdGlvbiBDb250cm9sbGVyRmFjdG9yeShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHZhciBpbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICBpZiAoQ29tbW9uLmlzQXJyYXkoYXJndW1lbnRzWzJdKSB8fCBDb21tb24uaXNPYmplY3QoYXJndW1lbnRzWzJdKSkge1xuICAgIHJldHVybiBuZXcgT3B0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0pO1xuICB9XG4gIGlmIChDb21tb24uaXNOdW1iZXIoaW5pdGlhbFZhbHVlKSkge1xuICAgIGlmIChDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzJdKSAmJiBDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzNdKSkge1xuICAgICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbNF0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSwgYXJndW1lbnRzWzRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgfVxuICAgIGlmIChDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzRdKSkge1xuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdLCBzdGVwOiBhcmd1bWVudHNbNF0gfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSB9KTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzU3RyaW5nKGluaXRpYWxWYWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc0Z1bmN0aW9uKGluaXRpYWxWYWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCAnJyk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc0Jvb2xlYW4oaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbn1cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbnZhciBDZW50ZXJlZERpdiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2VudGVyZWREaXYoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2VudGVyZWREaXYpO1xuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBDb21tb24uZXh0ZW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycyBsaW5lYXInLFxuICAgICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG4gICAgZG9tLm1ha2VGdWxsc2NyZWVuKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQodGhpcy5kb21FbGVtZW50LnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDEnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICctd2Via2l0LXRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJyxcbiAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGRvbS5iaW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmhpZGUoKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVDbGFzcyhDZW50ZXJlZERpdiwgW3tcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcbiAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgfTtcbiAgICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsYXlvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXlvdXQoKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUubGVmdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMiAtIGRvbS5nZXRXaWR0aCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gd2luZG93LmlubmVySGVpZ2h0IC8gMiAtIGRvbS5nZXRIZWlnaHQodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2VudGVyZWREaXY7XG59KCk7XG5cbnZhciBzdHlsZVNoZWV0ID0gX19fJGluc2VydFN0eWxlKFwiLmRnIHVse2xpc3Qtc3R5bGU6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7d2lkdGg6MTAwJTtjbGVhcjpib3RofS5kZy5hY3twb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtoZWlnaHQ6MDt6LWluZGV4OjB9LmRnOm5vdCguYWMpIC5tYWlue292ZXJmbG93OmhpZGRlbn0uZGcubWFpbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXJ9LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93e292ZXJmbG93LXk6YXV0b30uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3cgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjE7bWFyZ2luLXRvcDotMXB4O2JvcmRlci10b3A6MXB4IHNvbGlkICMyYzJjMmN9LmRnLm1haW4gdWwuY2xvc2VkIC5jbG9zZS1idXR0b257b3BhY2l0eToxICFpbXBvcnRhbnR9LmRnLm1haW46aG92ZXIgLmNsb3NlLWJ1dHRvbiwuZGcubWFpbiAuY2xvc2UtYnV0dG9uLmRyYWd7b3BhY2l0eToxfS5kZy5tYWluIC5jbG9zZS1idXR0b257LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyO2JvcmRlcjowO2xpbmUtaGVpZ2h0OjE5cHg7aGVpZ2h0OjIwcHg7Y3Vyc29yOnBvaW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojMDAwfS5kZy5tYWluIC5jbG9zZS1idXR0b24uY2xvc2UtdG9we3Bvc2l0aW9uOnJlbGF0aXZlfS5kZy5tYWluIC5jbG9zZS1idXR0b24uY2xvc2UtYm90dG9te3Bvc2l0aW9uOmFic29sdXRlfS5kZy5tYWluIC5jbG9zZS1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTExfS5kZy5he2Zsb2F0OnJpZ2h0O21hcmdpbi1yaWdodDoxNXB4O292ZXJmbG93LXk6dmlzaWJsZX0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZS10b3B7bWFyZ2luLXRvcDowfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLWJvdHRvbXttYXJnaW4tdG9wOjI3cHh9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2Vke21hcmdpbi10b3A6MH0uZGcuYSAuc2F2ZS1yb3d7dG9wOjA7ei1pbmRleDoxMDAyfS5kZy5hIC5zYXZlLXJvdy5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLmEgLnNhdmUtcm93LmNsb3NlLWJvdHRvbXtwb3NpdGlvbjpmaXhlZH0uZGcgbGl7LXdlYmtpdC10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW8tdHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy1tb3otdHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0O3RyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstd2Via2l0LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyfS5kZyBsaTpub3QoLmZvbGRlcil7Y3Vyc29yOmF1dG87aGVpZ2h0OjI3cHg7bGluZS1oZWlnaHQ6MjdweDtwYWRkaW5nOjAgNHB4IDAgNXB4fS5kZyBsaS5mb2xkZXJ7cGFkZGluZzowO2JvcmRlci1sZWZ0OjRweCBzb2xpZCByZ2JhKDAsMCwwLDApfS5kZyBsaS50aXRsZXtjdXJzb3I6cG9pbnRlcjttYXJnaW4tbGVmdDotNHB4fS5kZyAuY2xvc2VkIGxpOm5vdCgudGl0bGUpLC5kZyAuY2xvc2VkIHVsIGxpLC5kZyAuY2xvc2VkIHVsIGxpPip7aGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlcjowfS5kZyAuY3J7Y2xlYXI6Ym90aDtwYWRkaW5nLWxlZnQ6M3B4O2hlaWdodDoyN3B4O292ZXJmbG93OmhpZGRlbn0uZGcgLnByb3BlcnR5LW5hbWV7Y3Vyc29yOmRlZmF1bHQ7ZmxvYXQ6bGVmdDtjbGVhcjpsZWZ0O3dpZHRoOjQwJTtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCU7cG9zaXRpb246cmVsYXRpdmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjdweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuY3IuY29sb3J7b3ZlcmZsb3c6dmlzaWJsZX0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmNvbG9ye2JvcmRlci1sZWZ0OjNweCBzb2xpZH0uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMkZBMUQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJGQTFENn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJGQTFENjttYXgtd2lkdGg6MTAwJX0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XFxuXCIpO1xuXG5jc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xudmFyIENTU19OQU1FU1BBQ0UgPSAnZGcnO1xudmFyIEhJREVfS0VZX0NPREUgPSA3MjtcbnZhciBDTE9TRV9CVVRUT05fSEVJR0hUID0gMjA7XG52YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xudmFyIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSgpO1xudmFyIFNBVkVfRElBTE9HVUUgPSB2b2lkIDA7XG52YXIgYXV0b1BsYWNlVmlyZ2luID0gdHJ1ZTtcbnZhciBhdXRvUGxhY2VDb250YWluZXIgPSB2b2lkIDA7XG52YXIgaGlkZSA9IGZhbHNlO1xudmFyIGhpZGVhYmxlR3VpcyA9IFtdO1xudmFyIEdVSSA9IGZ1bmN0aW9uIEdVSShwYXJzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBwYXJhbXMgPSBwYXJzIHx8IHt9O1xuICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5fX3VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCk7XG4gIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIENTU19OQU1FU1BBQ0UpO1xuICB0aGlzLl9fZm9sZGVycyA9IHt9O1xuICB0aGlzLl9fY29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzID0gW107XG4gIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX2xpc3RlbmluZyA9IFtdO1xuICBwYXJhbXMgPSBDb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgY2xvc2VPblRvcDogZmFsc2UsXG4gICAgYXV0b1BsYWNlOiB0cnVlLFxuICAgIHdpZHRoOiBHVUkuREVGQVVMVF9XSURUSFxuICB9KTtcbiAgcGFyYW1zID0gQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgIHJlc2l6YWJsZTogcGFyYW1zLmF1dG9QbGFjZSxcbiAgICBoaWRlYWJsZTogcGFyYW1zLmF1dG9QbGFjZVxuICB9KTtcbiAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLmxvYWQpKSB7XG4gICAgaWYgKHBhcmFtcy5wcmVzZXQpIHtcbiAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHBhcmFtcy5wcmVzZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmFtcy5sb2FkID0geyBwcmVzZXQ6IERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSB9O1xuICB9XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLmhpZGVhYmxlKSB7XG4gICAgaGlkZWFibGVHdWlzLnB1c2godGhpcyk7XG4gIH1cbiAgcGFyYW1zLnJlc2l6YWJsZSA9IENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMucmVzaXphYmxlO1xuICBpZiAocGFyYW1zLmF1dG9QbGFjZSAmJiBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnNjcm9sbGFibGUpKSB7XG4gICAgcGFyYW1zLnNjcm9sbGFibGUgPSB0cnVlO1xuICB9XG4gIHZhciB1c2VMb2NhbFN0b3JhZ2UgPSBTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJztcbiAgdmFyIHNhdmVUb0xvY2FsU3RvcmFnZSA9IHZvaWQgMDtcbiAgdmFyIHRpdGxlUm93ID0gdm9pZCAwO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxuICB7XG4gICAgcGFyZW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXJlbnQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBzY3JvbGxhYmxlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5zY3JvbGxhYmxlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXV0b1BsYWNlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5hdXRvUGxhY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZU9uVG9wOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZU9uVG9wO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlc2V0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSb290KCkucHJlc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgX3RoaXMuZ2V0Um9vdCgpLnByZXNldCA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcmVzZXRTZWxlY3RJbmRleCh0aGlzKTtcbiAgICAgICAgX3RoaXMucmV2ZXJ0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMud2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMud2lkdGggPSB2O1xuICAgICAgICBzZXRXaWR0aChfdGhpcywgdik7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5uYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLm5hbWUgPSB2O1xuICAgICAgICBpZiAodGl0bGVSb3cpIHtcbiAgICAgICAgICB0aXRsZVJvdy5pbm5lckhUTUwgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMuY2xvc2VkID0gdjtcbiAgICAgICAgaWYgKHBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgaWYgKF90aGlzLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICBfdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IHYgPyBHVUkuVEVYVF9PUEVOIDogR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2FkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlTG9jYWxTdG9yYWdlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShib29sKSB7XG4gICAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlID0gYm9vbDtcbiAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgZG9tLmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpLCBib29sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHBhcmFtcy5jbG9zZWQgfHwgZmFsc2U7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX01BSU4pO1xuICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgaWYgKHVzZUxvY2FsU3RvcmFnZSkge1xuICAgICAgICBfdGhpcy51c2VMb2NhbFN0b3JhZ2UgPSB0cnVlO1xuICAgICAgICB2YXIgc2F2ZWRHdWkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdndWknKSk7XG4gICAgICAgIGlmIChzYXZlZEd1aSkge1xuICAgICAgICAgIHBhcmFtcy5sb2FkID0gSlNPTi5wYXJzZShzYXZlZEd1aSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IEdVSS5URVhUX0NMT1NFRDtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OKTtcbiAgICBpZiAocGFyYW1zLmNsb3NlT25Ub3ApIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9UT1ApO1xuICAgICAgdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9fY2xvc2VCdXR0b24sIHRoaXMuZG9tRWxlbWVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JPVFRPTSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2Nsb3NlQnV0dG9uKTtcbiAgICB9XG4gICAgZG9tLmJpbmQodGhpcy5fX2Nsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbXMuY2xvc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgdGl0bGVSb3dOYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFyYW1zLm5hbWUpO1xuICAgIGRvbS5hZGRDbGFzcyh0aXRsZVJvd05hbWUsICdjb250cm9sbGVyLW5hbWUnKTtcbiAgICB0aXRsZVJvdyA9IGFkZFJvdyhfdGhpcywgdGl0bGVSb3dOYW1lKTtcbiAgICB2YXIgb25DbGlja1RpdGxlID0gZnVuY3Rpb24gb25DbGlja1RpdGxlKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICBkb20uYWRkQ2xhc3ModGl0bGVSb3csICd0aXRsZScpO1xuICAgIGRvbS5iaW5kKHRpdGxlUm93LCAnY2xpY2snLCBvbkNsaWNrVGl0bGUpO1xuICAgIGlmICghcGFyYW1zLmNsb3NlZCkge1xuICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmFtcy5hdXRvUGxhY2UpIHtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG4gICAgICBpZiAoYXV0b1BsYWNlVmlyZ2luKSB7XG4gICAgICAgIGF1dG9QbGFjZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9QbGFjZUNvbnRhaW5lciwgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdXRvUGxhY2VDb250YWluZXIpO1xuICAgICAgICBhdXRvUGxhY2VWaXJnaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX0FVVE9fUExBQ0UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBzZXRXaWR0aChfdGhpcywgcGFyYW1zLndpZHRoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMub25SZXNpemVEZWJvdW5jZWQoKTtcbiAgfTtcbiAgZG9tLmJpbmQod2luZG93LCAncmVzaXplJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd0cmFuc2l0aW9uZW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICdvVHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgdGhpcy5vblJlc2l6ZSgpO1xuICBpZiAocGFyYW1zLnJlc2l6YWJsZSkge1xuICAgIGFkZFJlc2l6ZUhhbmRsZSh0aGlzKTtcbiAgfVxuICBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiBzYXZlVG9Mb2NhbFN0b3JhZ2UoKSB7XG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2d1aScpLCBKU09OLnN0cmluZ2lmeShfdGhpcy5nZXRTYXZlT2JqZWN0KCkpKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSA9IHNhdmVUb0xvY2FsU3RvcmFnZTtcbiAgZnVuY3Rpb24gcmVzZXRXaWR0aCgpIHtcbiAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICByb290LndpZHRoICs9IDE7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3Qud2lkdGggLT0gMTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXBhcmFtcy5wYXJlbnQpIHtcbiAgICByZXNldFdpZHRoKCk7XG4gIH1cbn07XG5HVUkudG9nZ2xlSGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgaGlkZSA9ICFoaWRlO1xuICBDb21tb24uZWFjaChoaWRlYWJsZUd1aXMsIGZ1bmN0aW9uIChndWkpIHtcbiAgICBndWkuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaGlkZSA/ICdub25lJyA6ICcnO1xuICB9KTtcbn07XG5HVUkuQ0xBU1NfQVVUT19QTEFDRSA9ICdhJztcbkdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUiA9ICdhYyc7XG5HVUkuQ0xBU1NfTUFJTiA9ICdtYWluJztcbkdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyA9ICdjcic7XG5HVUkuQ0xBU1NfVE9PX1RBTEwgPSAndGFsbGVyLXRoYW4td2luZG93JztcbkdVSS5DTEFTU19DTE9TRUQgPSAnY2xvc2VkJztcbkdVSS5DTEFTU19DTE9TRV9CVVRUT04gPSAnY2xvc2UtYnV0dG9uJztcbkdVSS5DTEFTU19DTE9TRV9UT1AgPSAnY2xvc2UtdG9wJztcbkdVSS5DTEFTU19DTE9TRV9CT1RUT00gPSAnY2xvc2UtYm90dG9tJztcbkdVSS5DTEFTU19EUkFHID0gJ2RyYWcnO1xuR1VJLkRFRkFVTFRfV0lEVEggPSAyNDU7XG5HVUkuVEVYVF9DTE9TRUQgPSAnQ2xvc2UgQ29udHJvbHMnO1xuR1VJLlRFWFRfT1BFTiA9ICdPcGVuIENvbnRyb2xzJztcbkdVSS5fa2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSAndGV4dCcgJiYgKGUud2hpY2ggPT09IEhJREVfS0VZX0NPREUgfHwgZS5rZXlDb2RlID09PSBISURFX0tFWV9DT0RFKSkge1xuICAgIEdVSS50b2dnbGVIaWRlKCk7XG4gIH1cbn07XG5kb20uYmluZCh3aW5kb3csICdrZXlkb3duJywgR1VJLl9rZXlkb3duSGFuZGxlciwgZmFsc2UpO1xuQ29tbW9uLmV4dGVuZChHVUkucHJvdG90eXBlLFxue1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIF9hZGQodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgZmFjdG9yeUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICB9KTtcbiAgfSxcbiAgYWRkQ29sb3I6IGZ1bmN0aW9uIGFkZENvbG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gX2FkZCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICBjb2xvcjogdHJ1ZVxuICAgIH0pO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjb250cm9sbGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGNvbnRyb2xsZXIuX19saSk7XG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzLnNwbGljZSh0aGlzLl9fY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSwgMSk7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0aGUgcm9vdCBHVUkgc2hvdWxkIGJlIHJlbW92ZWQgd2l0aCAuZGVzdHJveSgpLiAnICsgJ0ZvciBzdWJmb2xkZXJzLCB1c2UgZ3VpLnJlbW92ZUZvbGRlcihmb2xkZXIpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgYXV0b1BsYWNlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIF90aGlzLnJlbW92ZUZvbGRlcihzdWJmb2xkZXIpO1xuICAgIH0pO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAna2V5ZG93bicsIEdVSS5fa2V5ZG93bkhhbmRsZXIsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcnModGhpcyk7XG4gIH0sXG4gIGFkZEZvbGRlcjogZnVuY3Rpb24gYWRkRm9sZGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fX2ZvbGRlcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYWxyZWFkeSBoYXZlIGEgZm9sZGVyIGluIHRoaXMgR1VJIGJ5IHRoZScgKyAnIG5hbWUgXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cbiAgICB2YXIgbmV3R3VpUGFyYW1zID0geyBuYW1lOiBuYW1lLCBwYXJlbnQ6IHRoaXMgfTtcbiAgICBuZXdHdWlQYXJhbXMuYXV0b1BsYWNlID0gdGhpcy5hdXRvUGxhY2U7XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0pIHtcbiAgICAgIG5ld0d1aVBhcmFtcy5jbG9zZWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXS5jbG9zZWQ7XG4gICAgICBuZXdHdWlQYXJhbXMubG9hZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdO1xuICAgIH1cbiAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdHdWlQYXJhbXMpO1xuICAgIHRoaXMuX19mb2xkZXJzW25hbWVdID0gZ3VpO1xuICAgIHZhciBsaSA9IGFkZFJvdyh0aGlzLCBndWkuZG9tRWxlbWVudCk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnZm9sZGVyJyk7XG4gICAgcmV0dXJuIGd1aTtcbiAgfSxcbiAgcmVtb3ZlRm9sZGVyOiBmdW5jdGlvbiByZW1vdmVGb2xkZXIoZm9sZGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGZvbGRlci5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLl9fZm9sZGVyc1tmb2xkZXIubmFtZV07XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcnMoZm9sZGVyKTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKGZvbGRlci5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIGZvbGRlci5yZW1vdmVGb2xkZXIoc3ViZm9sZGVyKTtcbiAgICB9KTtcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9LFxuICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH0sXG4gIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuICAgIGlmIChyb290LnNjcm9sbGFibGUpIHtcbiAgICAgIHZhciB0b3AgPSBkb20uZ2V0T2Zmc2V0KHJvb3QuX191bCkudG9wO1xuICAgICAgdmFyIGggPSAwO1xuICAgICAgQ29tbW9uLmVhY2gocm9vdC5fX3VsLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghKHJvb3QuYXV0b1BsYWNlICYmIG5vZGUgPT09IHJvb3QuX19zYXZlX3JvdykpIHtcbiAgICAgICAgICBoICs9IGRvbS5nZXRIZWlnaHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgPCBoKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290Ll9fcmVzaXplX2hhbmRsZSkge1xuICAgICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUuaGVpZ2h0ID0gcm9vdC5fX3VsLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJvb3QuX19jbG9zZUJ1dHRvbikge1xuICAgICAgcm9vdC5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gcm9vdC53aWR0aCArICdweCc7XG4gICAgfVxuICB9LFxuICBvblJlc2l6ZURlYm91bmNlZDogQ29tbW9uLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gIH0sIDUwKSxcbiAgcmVtZW1iZXI6IGZ1bmN0aW9uIHJlbWVtYmVyKCkge1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoU0FWRV9ESUFMT0dVRSkpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUgPSBuZXcgQ2VudGVyZWREaXYoKTtcbiAgICAgIFNBVkVfRElBTE9HVUUuZG9tRWxlbWVudC5pbm5lckhUTUwgPSBzYXZlRGlhbG9nQ29udGVudHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG9ubHkgY2FsbCByZW1lbWJlciBvbiBhIHRvcCBsZXZlbCBHVUkuJyk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFkZFNhdmVNZW51KF90aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICBzZXRXaWR0aCh0aGlzLCB0aGlzLndpZHRoKTtcbiAgICB9XG4gIH0sXG4gIGdldFJvb3Q6IGZ1bmN0aW9uIGdldFJvb3QoKSB7XG4gICAgdmFyIGd1aSA9IHRoaXM7XG4gICAgd2hpbGUgKGd1aS5wYXJlbnQpIHtcbiAgICAgIGd1aSA9IGd1aS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBndWk7XG4gIH0sXG4gIGdldFNhdmVPYmplY3Q6IGZ1bmN0aW9uIGdldFNhdmVPYmplY3QoKSB7XG4gICAgdmFyIHRvUmV0dXJuID0gdGhpcy5sb2FkO1xuICAgIHRvUmV0dXJuLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgdG9SZXR1cm4ucHJlc2V0ID0gdGhpcy5wcmVzZXQ7XG4gICAgICBpZiAoIXRvUmV0dXJuLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgfVxuICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIH1cbiAgICB0b1JldHVybi5mb2xkZXJzID0ge307XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChlbGVtZW50LCBrZXkpIHtcbiAgICAgIHRvUmV0dXJuLmZvbGRlcnNba2V5XSA9IGVsZW1lbnQuZ2V0U2F2ZU9iamVjdCgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0b1JldHVybjtcbiAgfSxcbiAgc2F2ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKCk7XG4gIH0sXG4gIHNhdmVBczogZnVuY3Rpb24gc2F2ZUFzKHByZXNldE5hbWUpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3ByZXNldE5hbWVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICB0aGlzLnByZXNldCA9IHByZXNldE5hbWU7XG4gICAgYWRkUHJlc2V0T3B0aW9uKHRoaXMsIHByZXNldE5hbWUsIHRydWUpO1xuICAgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpO1xuICB9LFxuICByZXZlcnQ6IGZ1bmN0aW9uIHJldmVydChndWkpIHtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250cm9sbGVyLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlLmNhbGwoY29udHJvbGxlciwgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xuICAgICAgZm9sZGVyLnJldmVydChmb2xkZXIpO1xuICAgIH0pO1xuICAgIGlmICghZ3VpKSB7XG4gICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcy5nZXRSb290KCksIGZhbHNlKTtcbiAgICB9XG4gIH0sXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGNvbnRyb2xsZXIpIHtcbiAgICB2YXIgaW5pdCA9IHRoaXMuX19saXN0ZW5pbmcubGVuZ3RoID09PSAwO1xuICAgIHRoaXMuX19saXN0ZW5pbmcucHVzaChjb250cm9sbGVyKTtcbiAgICBpZiAoaW5pdCkge1xuICAgICAgdXBkYXRlRGlzcGxheXModGhpcy5fX2xpc3RlbmluZyk7XG4gICAgfVxuICB9LFxuICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZm9sZGVyKSB7XG4gICAgICBmb2xkZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICB9XG59KTtcbmZ1bmN0aW9uIGFkZFJvdyhndWksIG5ld0RvbSwgbGlCZWZvcmUpIHtcbiAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgaWYgKG5ld0RvbSkge1xuICAgIGxpLmFwcGVuZENoaWxkKG5ld0RvbSk7XG4gIH1cbiAgaWYgKGxpQmVmb3JlKSB7XG4gICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGxpLCBsaUJlZm9yZSk7XG4gIH0gZWxzZSB7XG4gICAgZ3VpLl9fdWwuYXBwZW5kQ2hpbGQobGkpO1xuICB9XG4gIGd1aS5vblJlc2l6ZSgpO1xuICByZXR1cm4gbGk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZ3VpKSB7XG4gIGRvbS51bmJpbmQod2luZG93LCAncmVzaXplJywgZ3VpLl9fcmVzaXplSGFuZGxlcik7XG4gIGlmIChndWkuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSkge1xuICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLCBtb2RpZmllZCkge1xuICB2YXIgb3B0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuICBpZiAobW9kaWZpZWQpIHtcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlICsgJyonO1xuICB9IGVsc2Uge1xuICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fX2xpID0gbGk7XG4gIGNvbnRyb2xsZXIuX19ndWkgPSBndWk7XG4gIENvbW1vbi5leHRlbmQoY29udHJvbGxlciwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKF9vcHRpb25zKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIF9hZGQoZ3VpLCBjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwge1xuICAgICAgICAgIGJlZm9yZTogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtDb21tb24udG9BcnJheShhcmd1bWVudHMpXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChDb21tb24uaXNBcnJheShfb3B0aW9ucykgfHwgQ29tbW9uLmlzT2JqZWN0KF9vcHRpb25zKSkge1xuICAgICAgICB2YXIgX25leHRTaWJsaW5nID0gY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIF9hZGQoZ3VpLCBjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwge1xuICAgICAgICAgIGJlZm9yZTogX25leHRTaWJsaW5nLFxuICAgICAgICAgIGZhY3RvcnlBcmdzOiBbX29wdGlvbnNdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZTogZnVuY3Rpb24gbmFtZShfbmFtZSkge1xuICAgICAgY29udHJvbGxlci5fX2xpLmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLmlubmVySFRNTCA9IF9uYW1lO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfSxcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICAgIGNvbnRyb2xsZXIuX19ndWkubGlzdGVuKGNvbnRyb2xsZXIpO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGNvbnRyb2xsZXIuX19ndWkucmVtb3ZlKGNvbnRyb2xsZXIpO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICB9KTtcbiAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyU2xpZGVyKSB7XG4gICAgdmFyIGJveCA9IG5ldyBOdW1iZXJDb250cm9sbGVyQm94KGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7IG1pbjogY29udHJvbGxlci5fX21pbiwgbWF4OiBjb250cm9sbGVyLl9fbWF4LCBzdGVwOiBjb250cm9sbGVyLl9fc3RlcCB9KTtcbiAgICBDb21tb24uZWFjaChbJ3VwZGF0ZURpc3BsYXknLCAnb25DaGFuZ2UnLCAnb25GaW5pc2hDaGFuZ2UnLCAnc3RlcCcsICdtaW4nLCAnbWF4J10sIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHZhciBwYyA9IGNvbnRyb2xsZXJbbWV0aG9kXTtcbiAgICAgIHZhciBwYiA9IGJveFttZXRob2RdO1xuICAgICAgY29udHJvbGxlclttZXRob2RdID0gYm94W21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcGIuYXBwbHkoYm94LCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHBjLmFwcGx5KGNvbnRyb2xsZXIsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBkb20uYWRkQ2xhc3MobGksICdoYXMtc2xpZGVyJyk7XG4gICAgY29udHJvbGxlci5kb21FbGVtZW50Lmluc2VydEJlZm9yZShib3guZG9tRWxlbWVudCwgY29udHJvbGxlci5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlckJveCkge1xuICAgIHZhciByID0gZnVuY3Rpb24gcihyZXR1cm5lZCkge1xuICAgICAgaWYgKENvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWluKSAmJiBDb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21heCkpIHtcbiAgICAgICAgdmFyIG9sZE5hbWUgPSBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgd2FzTGlzdGVuaW5nID0gY29udHJvbGxlci5fX2d1aS5fX2xpc3RlbmluZy5pbmRleE9mKGNvbnRyb2xsZXIpID4gLTE7XG4gICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgIHZhciBuZXdDb250cm9sbGVyID0gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgIGZhY3RvcnlBcmdzOiBbY29udHJvbGxlci5fX21pbiwgY29udHJvbGxlci5fX21heCwgY29udHJvbGxlci5fX3N0ZXBdXG4gICAgICAgIH0pO1xuICAgICAgICBuZXdDb250cm9sbGVyLm5hbWUob2xkTmFtZSk7XG4gICAgICAgIGlmICh3YXNMaXN0ZW5pbmcpIG5ld0NvbnRyb2xsZXIubGlzdGVuKCk7XG4gICAgICAgIHJldHVybiBuZXdDb250cm9sbGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybmVkO1xuICAgIH07XG4gICAgY29udHJvbGxlci5taW4gPSBDb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1pbik7XG4gICAgY29udHJvbGxlci5tYXggPSBDb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1heCk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEJvb2xlYW5Db250cm9sbGVyKSB7XG4gICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snKTtcbiAgICB9KTtcbiAgICBkb20uYmluZChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbkNvbnRyb2xsZXIpIHtcbiAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fYnV0dG9uLCAnY2xpY2snKTtcbiAgICB9KTtcbiAgICBkb20uYmluZChsaSwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICB9KTtcbiAgICBkb20uYmluZChsaSwgJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSA9IENvbW1vbi5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGxpLnN0eWxlLmJvcmRlckxlZnRDb2xvciA9IGNvbnRyb2xsZXIuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LCBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkpO1xuICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuICB9XG4gIGNvbnRyb2xsZXIuc2V0VmFsdWUgPSBDb21tb24uY29tcG9zZShmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKGd1aS5nZXRSb290KCkuX19wcmVzZXRfc2VsZWN0ICYmIGNvbnRyb2xsZXIuaXNNb2RpZmllZCgpKSB7XG4gICAgICBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLmdldFJvb3QoKSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH0sIGNvbnRyb2xsZXIuc2V0VmFsdWUpO1xufVxuZnVuY3Rpb24gcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpIHtcbiAgdmFyIHJvb3QgPSBndWkuZ2V0Um9vdCgpO1xuICB2YXIgbWF0Y2hlZEluZGV4ID0gcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2YoY29udHJvbGxlci5vYmplY3QpO1xuICBpZiAobWF0Y2hlZEluZGV4ICE9PSAtMSkge1xuICAgIHZhciBjb250cm9sbGVyTWFwID0gcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkSW5kZXhdO1xuICAgIGlmIChjb250cm9sbGVyTWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRyb2xsZXJNYXAgPSB7fTtcbiAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZEluZGV4XSA9IGNvbnRyb2xsZXJNYXA7XG4gICAgfVxuICAgIGNvbnRyb2xsZXJNYXBbY29udHJvbGxlci5wcm9wZXJ0eV0gPSBjb250cm9sbGVyO1xuICAgIGlmIChyb290LmxvYWQgJiYgcm9vdC5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgIHZhciBwcmVzZXRNYXAgPSByb290LmxvYWQucmVtZW1iZXJlZDtcbiAgICAgIHZhciBwcmVzZXQgPSB2b2lkIDA7XG4gICAgICBpZiAocHJlc2V0TWFwW2d1aS5wcmVzZXRdKSB7XG4gICAgICAgIHByZXNldCA9IHByZXNldE1hcFtndWkucHJlc2V0XTtcbiAgICAgIH0gZWxzZSBpZiAocHJlc2V0TWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0pIHtcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocHJlc2V0W21hdGNoZWRJbmRleF0gJiYgcHJlc2V0W21hdGNoZWRJbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwcmVzZXRbbWF0Y2hlZEluZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XTtcbiAgICAgICAgY29udHJvbGxlci5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfYWRkKGd1aSwgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gIGlmIChvYmplY3RbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBcIicgKyBvYmplY3QgKyAnXCIgaGFzIG5vIHByb3BlcnR5IFwiJyArIHByb3BlcnR5ICsgJ1wiJyk7XG4gIH1cbiAgdmFyIGNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gIGlmIChwYXJhbXMuY29sb3IpIHtcbiAgICBjb250cm9sbGVyID0gbmV3IENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmFjdG9yeUFyZ3MgPSBbb2JqZWN0LCBwcm9wZXJ0eV0uY29uY2F0KHBhcmFtcy5mYWN0b3J5QXJncyk7XG4gICAgY29udHJvbGxlciA9IENvbnRyb2xsZXJGYWN0b3J5LmFwcGx5KGd1aSwgZmFjdG9yeUFyZ3MpO1xuICB9XG4gIGlmIChwYXJhbXMuYmVmb3JlIGluc3RhbmNlb2YgQ29udHJvbGxlcikge1xuICAgIHBhcmFtcy5iZWZvcmUgPSBwYXJhbXMuYmVmb3JlLl9fbGk7XG4gIH1cbiAgcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpO1xuICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5kb21FbGVtZW50LCAnYycpO1xuICB2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgZG9tLmFkZENsYXNzKG5hbWUsICdwcm9wZXJ0eS1uYW1lJyk7XG4gIG5hbWUuaW5uZXJIVE1MID0gY29udHJvbGxlci5wcm9wZXJ0eTtcbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQobmFtZSk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sbGVyLmRvbUVsZW1lbnQpO1xuICB2YXIgbGkgPSBhZGRSb3coZ3VpLCBjb250YWluZXIsIHBhcmFtcy5iZWZvcmUpO1xuICBkb20uYWRkQ2xhc3MobGksIEdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyk7XG4gIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQ29sb3JDb250cm9sbGVyKSB7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnY29sb3InKTtcbiAgfSBlbHNlIHtcbiAgICBkb20uYWRkQ2xhc3MobGksIF90eXBlb2YoY29udHJvbGxlci5nZXRWYWx1ZSgpKSk7XG4gIH1cbiAgYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcik7XG4gIGd1aS5fX2NvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG4gIHJldHVybiBjb250cm9sbGVyO1xufVxuZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksIGtleSkge1xuICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiArICcuJyArIGtleTtcbn1cbmZ1bmN0aW9uIGFkZFByZXNldE9wdGlvbihndWksIG5hbWUsIHNldFNlbGVjdGVkKSB7XG4gIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgb3B0LmlubmVySFRNTCA9IG5hbWU7XG4gIG9wdC52YWx1ZSA9IG5hbWU7XG4gIGd1aS5fX3ByZXNldF9zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgaWYgKHNldFNlbGVjdGVkKSB7XG4gICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGggLSAxO1xuICB9XG59XG5mdW5jdGlvbiBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKSB7XG4gIGV4cGxhaW4uc3R5bGUuZGlzcGxheSA9IGd1aS51c2VMb2NhbFN0b3JhZ2UgPyAnYmxvY2snIDogJ25vbmUnO1xufVxuZnVuY3Rpb24gYWRkU2F2ZU1lbnUoZ3VpKSB7XG4gIHZhciBkaXYgPSBndWkuX19zYXZlX3JvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gIGRvbS5hZGRDbGFzcyhndWkuZG9tRWxlbWVudCwgJ2hhcy1zYXZlJyk7XG4gIGd1aS5fX3VsLmluc2VydEJlZm9yZShkaXYsIGd1aS5fX3VsLmZpcnN0Q2hpbGQpO1xuICBkb20uYWRkQ2xhc3MoZGl2LCAnc2F2ZS1yb3cnKTtcbiAgdmFyIGdlYXJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBnZWFycy5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgZG9tLmFkZENsYXNzKGdlYXJzLCAnYnV0dG9uIGdlYXJzJyk7XG4gIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGJ1dHRvbi5pbm5lckhUTUwgPSAnU2F2ZSc7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24sICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ3NhdmUnKTtcbiAgdmFyIGJ1dHRvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGJ1dHRvbjIuaW5uZXJIVE1MID0gJ05ldyc7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnYnV0dG9uJyk7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnc2F2ZS1hcycpO1xuICB2YXIgYnV0dG9uMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uMy5pbm5lckhUTUwgPSAnUmV2ZXJ0JztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdyZXZlcnQnKTtcbiAgdmFyIHNlbGVjdCA9IGd1aS5fX3ByZXNldF9zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgaWYgKGd1aS5sb2FkICYmIGd1aS5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICBDb21tb24uZWFjaChndWkubG9hZC5yZW1lbWJlcmVkLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwga2V5LCBrZXkgPT09IGd1aS5wcmVzZXQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGFkZFByZXNldE9wdGlvbihndWksIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSwgZmFsc2UpO1xuICB9XG4gIGRvbS5iaW5kKHNlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLmlubmVySFRNTCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlO1xuICAgIH1cbiAgICBndWkucHJlc2V0ID0gdGhpcy52YWx1ZTtcbiAgfSk7XG4gIGRpdi5hcHBlbmRDaGlsZChzZWxlY3QpO1xuICBkaXYuYXBwZW5kQ2hpbGQoZ2VhcnMpO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjIpO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMyk7XG4gIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgdmFyIGV4cGxhaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtZXhwbGFpbicpO1xuICAgIHZhciBsb2NhbFN0b3JhZ2VDaGVja0JveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1zdG9yYWdlJyk7XG4gICAgdmFyIHNhdmVMb2NhbGx5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLXNhdmUtbG9jYWxseScpO1xuICAgIHNhdmVMb2NhbGx5LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgbG9jYWxTdG9yYWdlQ2hlY2tCb3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICB9XG4gICAgc2hvd0hpZGVFeHBsYWluKGd1aSwgZXhwbGFpbik7XG4gICAgZG9tLmJpbmQobG9jYWxTdG9yYWdlQ2hlY2tCb3gsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBndWkudXNlTG9jYWxTdG9yYWdlID0gIWd1aS51c2VMb2NhbFN0b3JhZ2U7XG4gICAgICBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgbmV3Q29uc3RydWN0b3JUZXh0QXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1uZXctY29uc3RydWN0b3InKTtcbiAgZG9tLmJpbmQobmV3Q29uc3RydWN0b3JUZXh0QXJlYSwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLm1ldGFLZXkgJiYgKGUud2hpY2ggPT09IDY3IHx8IGUua2V5Q29kZSA9PT0gNjcpKSB7XG4gICAgICBTQVZFX0RJQUxPR1VFLmhpZGUoKTtcbiAgICB9XG4gIH0pO1xuICBkb20uYmluZChnZWFycywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuaW5uZXJIVE1MID0gSlNPTi5zdHJpbmdpZnkoZ3VpLmdldFNhdmVPYmplY3QoKSwgdW5kZWZpbmVkLCAyKTtcbiAgICBTQVZFX0RJQUxPR1VFLnNob3coKTtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmZvY3VzKCk7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5zZWxlY3QoKTtcbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGd1aS5zYXZlKCk7XG4gIH0pO1xuICBkb20uYmluZChidXR0b24yLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXNldE5hbWUgPSBwcm9tcHQoJ0VudGVyIGEgbmV3IHByZXNldCBuYW1lLicpO1xuICAgIGlmIChwcmVzZXROYW1lKSB7XG4gICAgICBndWkuc2F2ZUFzKHByZXNldE5hbWUpO1xuICAgIH1cbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbjMsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBndWkucmV2ZXJ0KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkUmVzaXplSGFuZGxlKGd1aSkge1xuICB2YXIgcG1vdXNlWCA9IHZvaWQgMDtcbiAgZ3VpLl9fcmVzaXplX2hhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBDb21tb24uZXh0ZW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUsIHtcbiAgICB3aWR0aDogJzZweCcsXG4gICAgbWFyZ2luTGVmdDogJy0zcHgnLFxuICAgIGhlaWdodDogJzIwMHB4JyxcbiAgICBjdXJzb3I6ICdldy1yZXNpemUnLFxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gIH0pO1xuICBmdW5jdGlvbiBkcmFnKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZ3VpLndpZHRoICs9IHBtb3VzZVggLSBlLmNsaWVudFg7XG4gICAgZ3VpLm9uUmVzaXplKCk7XG4gICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZHJhZ1N0b3AoKSB7XG4gICAgZG9tLnJlbW92ZUNsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG4gIH1cbiAgZnVuY3Rpb24gZHJhZ1N0YXJ0KGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICBkb20uYWRkQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkb20uYmluZChndWkuX19yZXNpemVfaGFuZGxlLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcbiAgZG9tLmJpbmQoZ3VpLl9fY2xvc2VCdXR0b24sICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICBndWkuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoZ3VpLl9fcmVzaXplX2hhbmRsZSwgZ3VpLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xufVxuZnVuY3Rpb24gc2V0V2lkdGgoZ3VpLCB3KSB7XG4gIGd1aS5kb21FbGVtZW50LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIGlmIChndWkuX19zYXZlX3JvdyAmJiBndWkuYXV0b1BsYWNlKSB7XG4gICAgZ3VpLl9fc2F2ZV9yb3cuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgfVxuICBpZiAoZ3VpLl9fY2xvc2VCdXR0b24pIHtcbiAgICBndWkuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50UHJlc2V0KGd1aSwgdXNlSW5pdGlhbFZhbHVlcykge1xuICB2YXIgdG9SZXR1cm4gPSB7fTtcbiAgQ29tbW9uLmVhY2goZ3VpLl9fcmVtZW1iZXJlZE9iamVjdHMsIGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XG4gICAgdmFyIHNhdmVkVmFsdWVzID0ge307XG4gICAgdmFyIGNvbnRyb2xsZXJNYXAgPSBndWkuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbaW5kZXhdO1xuICAgIENvbW1vbi5lYWNoKGNvbnRyb2xsZXJNYXAsIGZ1bmN0aW9uIChjb250cm9sbGVyLCBwcm9wZXJ0eSkge1xuICAgICAgc2F2ZWRWYWx1ZXNbcHJvcGVydHldID0gdXNlSW5pdGlhbFZhbHVlcyA/IGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlIDogY29udHJvbGxlci5nZXRWYWx1ZSgpO1xuICAgIH0pO1xuICAgIHRvUmV0dXJuW2luZGV4XSA9IHNhdmVkVmFsdWVzO1xuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufVxuZnVuY3Rpb24gc2V0UHJlc2V0U2VsZWN0SW5kZXgoZ3VpKSB7XG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlmIChndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZSA9PT0gZ3VpLnByZXNldCkge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpIHtcbiAgaWYgKGNvbnRyb2xsZXJBcnJheS5sZW5ndGggIT09IDApIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KTtcbiAgICB9KTtcbiAgfVxuICBDb21tb24uZWFjaChjb250cm9sbGVyQXJyYXksIGZ1bmN0aW9uIChjKSB7XG4gICAgYy51cGRhdGVEaXNwbGF5KCk7XG4gIH0pO1xufVxuXG52YXIgY29sb3IgPSB7XG4gIENvbG9yOiBDb2xvcixcbiAgbWF0aDogQ29sb3JNYXRoLFxuICBpbnRlcnByZXQ6IGludGVycHJldFxufTtcbnZhciBjb250cm9sbGVycyA9IHtcbiAgQ29udHJvbGxlcjogQ29udHJvbGxlcixcbiAgQm9vbGVhbkNvbnRyb2xsZXI6IEJvb2xlYW5Db250cm9sbGVyLFxuICBPcHRpb25Db250cm9sbGVyOiBPcHRpb25Db250cm9sbGVyLFxuICBTdHJpbmdDb250cm9sbGVyOiBTdHJpbmdDb250cm9sbGVyLFxuICBOdW1iZXJDb250cm9sbGVyOiBOdW1iZXJDb250cm9sbGVyLFxuICBOdW1iZXJDb250cm9sbGVyQm94OiBOdW1iZXJDb250cm9sbGVyQm94LFxuICBOdW1iZXJDb250cm9sbGVyU2xpZGVyOiBOdW1iZXJDb250cm9sbGVyU2xpZGVyLFxuICBGdW5jdGlvbkNvbnRyb2xsZXI6IEZ1bmN0aW9uQ29udHJvbGxlcixcbiAgQ29sb3JDb250cm9sbGVyOiBDb2xvckNvbnRyb2xsZXJcbn07XG52YXIgZG9tJDEgPSB7IGRvbTogZG9tIH07XG52YXIgZ3VpID0geyBHVUk6IEdVSSB9O1xudmFyIEdVSSQxID0gR1VJO1xudmFyIGluZGV4ID0ge1xuICBjb2xvcjogY29sb3IsXG4gIGNvbnRyb2xsZXJzOiBjb250cm9sbGVycyxcbiAgZG9tOiBkb20kMSxcbiAgZ3VpOiBndWksXG4gIEdVSTogR1VJJDFcbn07XG5cbmV4cG9ydHMuY29sb3IgPSBjb2xvcjtcbmV4cG9ydHMuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcbmV4cG9ydHMuZG9tID0gZG9tJDE7XG5leHBvcnRzLmd1aSA9IGd1aTtcbmV4cG9ydHMuR1VJID0gR1VJJDE7XG5leHBvcnRzWydkZWZhdWx0J10gPSBpbmRleDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdC5ndWkuanMubWFwXG4iLCIvKiBpbnRlcmFjdC5qcyAxLjkuOCB8IGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vdGF5ZS9pbnRlcmFjdC5qcy9tYXN0ZXIvTElDRU5TRSAqL1xuIWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPXQoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sdCk7ZWxzZXsoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzKS5pbnRlcmFjdD10KCl9fShmdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7dmFyIG47cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBufHxlKG49e2V4cG9ydHM6e30scGFyZW50OnR9LG4uZXhwb3J0cyksbi5leHBvcnRzfX12YXIgaz10KGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYSh0KXtyZXR1cm4oYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PWUuSW50ZXJhY3RhYmxlPXZvaWQgMDt2YXIgdT1yKFMpLGw9bihDKSxzPW4oViksYz1uKGN0KSxmPXIodykscD1uKGZ0KSxpPW4oYnQpLGQ9bSh7fSk7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gdigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIHY9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiByKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWEodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9digpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufWZ1bmN0aW9uIG8odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIHkodCxlLG4pe3JldHVybiBlJiZvKHQucHJvdG90eXBlLGUpLG4mJm8odCxuKSx0fWZ1bmN0aW9uIGgodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBnPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbyh0LGUsbixyKXshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLG8pLHRoaXMuX3Njb3BlRXZlbnRzPXIsaCh0aGlzLFwib3B0aW9uc1wiLHZvaWQgMCksaCh0aGlzLFwiX2FjdGlvbnNcIix2b2lkIDApLGgodGhpcyxcInRhcmdldFwiLHZvaWQgMCksaCh0aGlzLFwiZXZlbnRzXCIsbmV3IGkuZGVmYXVsdCksaCh0aGlzLFwiX2NvbnRleHRcIix2b2lkIDApLGgodGhpcyxcIl93aW5cIix2b2lkIDApLGgodGhpcyxcIl9kb2NcIix2b2lkIDApLHRoaXMuX2FjdGlvbnM9ZS5hY3Rpb25zLHRoaXMudGFyZ2V0PXQsdGhpcy5fY29udGV4dD1lLmNvbnRleHR8fG4sdGhpcy5fd2luPSgwLE8uZ2V0V2luZG93KSgoMCwkLnRyeVNlbGVjdG9yKSh0KT90aGlzLl9jb250ZXh0OnQpLHRoaXMuX2RvYz10aGlzLl93aW4uZG9jdW1lbnQsdGhpcy5zZXQoZSl9cmV0dXJuIHkobyxbe2tleTpcIl9kZWZhdWx0c1wiLGdldDpmdW5jdGlvbigpe3JldHVybntiYXNlOnt9LHBlckFjdGlvbjp7fSxhY3Rpb25zOnt9fX19XSkseShvLFt7a2V5Olwic2V0T25FdmVudHNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiBmLmZ1bmMoZS5vbnN0YXJ0KSYmdGhpcy5vbihcIlwiLmNvbmNhdCh0LFwic3RhcnRcIiksZS5vbnN0YXJ0KSxmLmZ1bmMoZS5vbm1vdmUpJiZ0aGlzLm9uKFwiXCIuY29uY2F0KHQsXCJtb3ZlXCIpLGUub25tb3ZlKSxmLmZ1bmMoZS5vbmVuZCkmJnRoaXMub24oXCJcIi5jb25jYXQodCxcImVuZFwiKSxlLm9uZW5kKSxmLmZ1bmMoZS5vbmluZXJ0aWFzdGFydCkmJnRoaXMub24oXCJcIi5jb25jYXQodCxcImluZXJ0aWFzdGFydFwiKSxlLm9uaW5lcnRpYXN0YXJ0KSx0aGlzfX0se2tleTpcInVwZGF0ZVBlckFjdGlvbkxpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXsoZi5hcnJheShlKXx8Zi5vYmplY3QoZSkpJiZ0aGlzLm9mZih0LGUpLChmLmFycmF5KG4pfHxmLm9iamVjdChuKSkmJnRoaXMub24odCxuKX19LHtrZXk6XCJzZXRQZXJBY3Rpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX2RlZmF1bHRzO2Zvcih2YXIgciBpbiBlKXt2YXIgbz1yLGk9dGhpcy5vcHRpb25zW3RdLGE9ZVtvXTtcImxpc3RlbmVyc1wiPT09byYmdGhpcy51cGRhdGVQZXJBY3Rpb25MaXN0ZW5lcnModCxpLmxpc3RlbmVycyxhKSxmLmFycmF5KGEpP2lbb109dS5mcm9tKGEpOmYucGxhaW5PYmplY3QoYSk/KGlbb109KDAsYy5kZWZhdWx0KShpW29dfHx7fSwoMCxzLmRlZmF1bHQpKGEpKSxmLm9iamVjdChuLnBlckFjdGlvbltvXSkmJlwiZW5hYmxlZFwiaW4gbi5wZXJBY3Rpb25bb10mJihpW29dLmVuYWJsZWQ9ITEhPT1hLmVuYWJsZWQpKTpmLmJvb2woYSkmJmYub2JqZWN0KG4ucGVyQWN0aW9uW29dKT9pW29dLmVuYWJsZWQ9YTppW29dPWF9fX0se2tleTpcImdldFJlY3RcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdD10fHwoZi5lbGVtZW50KHRoaXMudGFyZ2V0KT90aGlzLnRhcmdldDpudWxsKSxmLnN0cmluZyh0aGlzLnRhcmdldCkmJih0PXR8fHRoaXMuX2NvbnRleHQucXVlcnlTZWxlY3Rvcih0aGlzLnRhcmdldCkpLCgwLCQuZ2V0RWxlbWVudFJlY3QpKHQpfX0se2tleTpcInJlY3RDaGVja2VyXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGYuZnVuYyh0KT8odGhpcy5nZXRSZWN0PXQsdGhpcyk6bnVsbD09PXQ/KGRlbGV0ZSB0aGlzLmdldFJlY3QsdGhpcyk6dGhpcy5nZXRSZWN0fX0se2tleTpcIl9iYWNrQ29tcGF0T3B0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZigoMCwkLnRyeVNlbGVjdG9yKShlKXx8Zi5vYmplY3QoZSkpe2Zvcih2YXIgbiBpbiB0aGlzLm9wdGlvbnNbdF09ZSx0aGlzLl9hY3Rpb25zLm1hcCl0aGlzLm9wdGlvbnNbbl1bdF09ZTtyZXR1cm4gdGhpc31yZXR1cm4gdGhpcy5vcHRpb25zW3RdfX0se2tleTpcIm9yaWdpblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9iYWNrQ29tcGF0T3B0aW9uKFwib3JpZ2luXCIsdCl9fSx7a2V5OlwiZGVsdGFTb3VyY2VcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm5cInBhZ2VcIj09PXR8fFwiY2xpZW50XCI9PT10Pyh0aGlzLm9wdGlvbnMuZGVsdGFTb3VyY2U9dCx0aGlzKTp0aGlzLm9wdGlvbnMuZGVsdGFTb3VyY2V9fSx7a2V5OlwiY29udGV4dFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRleHR9fSx7a2V5OlwiaW5Db250ZXh0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NvbnRleHQ9PT10Lm93bmVyRG9jdW1lbnR8fCgwLCQubm9kZUNvbnRhaW5zKSh0aGlzLl9jb250ZXh0LHQpfX0se2tleTpcInRlc3RJZ25vcmVBbGxvd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4hdGhpcy50ZXN0SWdub3JlKHQuaWdub3JlRnJvbSxlLG4pJiZ0aGlzLnRlc3RBbGxvdyh0LmFsbG93RnJvbSxlLG4pfX0se2tleTpcInRlc3RBbGxvd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4hdHx8ISFmLmVsZW1lbnQobikmJihmLnN0cmluZyh0KT8oMCwkLm1hdGNoZXNVcFRvKShuLHQsZSk6ISFmLmVsZW1lbnQodCkmJigwLCQubm9kZUNvbnRhaW5zKSh0LG4pKX19LHtrZXk6XCJ0ZXN0SWdub3JlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiEoIXR8fCFmLmVsZW1lbnQobikpJiYoZi5zdHJpbmcodCk/KDAsJC5tYXRjaGVzVXBUbykobix0LGUpOiEhZi5lbGVtZW50KHQpJiYoMCwkLm5vZGVDb250YWlucykodCxuKSl9fSx7a2V5OlwiZmlyZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmV2ZW50cy5maXJlKHQpLHRoaXN9fSx7a2V5OlwiX29uT2ZmXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4scil7Zi5vYmplY3QoZSkmJiFmLmFycmF5KGUpJiYocj1uLG49bnVsbCk7dmFyIG89XCJvblwiPT09dD9cImFkZFwiOlwicmVtb3ZlXCIsaT0oMCxwLmRlZmF1bHQpKGUsbik7Zm9yKHZhciBhIGluIGkpe1wid2hlZWxcIj09PWEmJihhPWwuZGVmYXVsdC53aGVlbEV2ZW50KTtmb3IodmFyIHU9MDt1PGlbYV0ubGVuZ3RoO3UrKyl7dmFyIHM9aVthXVt1XTsoMCxkLmlzTm9uTmF0aXZlRXZlbnQpKGEsdGhpcy5fYWN0aW9ucyk/dGhpcy5ldmVudHNbdF0oYSxzKTpmLnN0cmluZyh0aGlzLnRhcmdldCk/dGhpcy5fc2NvcGVFdmVudHNbXCJcIi5jb25jYXQobyxcIkRlbGVnYXRlXCIpXSh0aGlzLnRhcmdldCx0aGlzLl9jb250ZXh0LGEscyxyKTp0aGlzLl9zY29wZUV2ZW50c1tvXSh0aGlzLnRhcmdldCxhLHMscil9fXJldHVybiB0aGlzfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLl9vbk9mZihcIm9uXCIsdCxlLG4pfX0se2tleTpcIm9mZlwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5fb25PZmYoXCJvZmZcIix0LGUsbil9fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fZGVmYXVsdHM7Zm9yKHZhciBuIGluIGYub2JqZWN0KHQpfHwodD17fSksdGhpcy5vcHRpb25zPSgwLHMuZGVmYXVsdCkoZS5iYXNlKSx0aGlzLl9hY3Rpb25zLm1ldGhvZERpY3Qpe3ZhciByPW4sbz10aGlzLl9hY3Rpb25zLm1ldGhvZERpY3Rbcl07dGhpcy5vcHRpb25zW3JdPXt9LHRoaXMuc2V0UGVyQWN0aW9uKHIsKDAsYy5kZWZhdWx0KSgoMCxjLmRlZmF1bHQpKHt9LGUucGVyQWN0aW9uKSxlLmFjdGlvbnNbcl0pKSx0aGlzW29dKHRbcl0pfWZvcih2YXIgaSBpbiB0KWYuZnVuYyh0aGlzW2ldKSYmdGhpc1tpXSh0W2ldKTtyZXR1cm4gdGhpc319LHtrZXk6XCJ1bnNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoZi5zdHJpbmcodGhpcy50YXJnZXQpKWZvcih2YXIgdCBpbiB0aGlzLl9zY29wZUV2ZW50cy5kZWxlZ2F0ZWRFdmVudHMpZm9yKHZhciBlPXRoaXMuX3Njb3BlRXZlbnRzLmRlbGVnYXRlZEV2ZW50c1t0XSxuPWUubGVuZ3RoLTE7MDw9bjtuLS0pe3ZhciByPWVbbl0sbz1yLnNlbGVjdG9yLGk9ci5jb250ZXh0LGE9ci5saXN0ZW5lcnM7bz09PXRoaXMudGFyZ2V0JiZpPT09dGhpcy5fY29udGV4dCYmZS5zcGxpY2UobiwxKTtmb3IodmFyIHU9YS5sZW5ndGgtMTswPD11O3UtLSl0aGlzLl9zY29wZUV2ZW50cy5yZW1vdmVEZWxlZ2F0ZSh0aGlzLnRhcmdldCx0aGlzLl9jb250ZXh0LHQsYVt1XVswXSxhW3VdWzFdKX1lbHNlIHRoaXMuX3Njb3BlRXZlbnRzLnJlbW92ZSh0aGlzLnRhcmdldCxcImFsbFwiKX19XSksb30oKSxiPWUuSW50ZXJhY3RhYmxlPWc7ZS5kZWZhdWx0PWJ9KSxtPXQoZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmlzTm9uTmF0aXZlRXZlbnQ9ZnVuY3Rpb24odCxlKXtpZihlLnBoYXNlbGVzc1R5cGVzW3RdKXJldHVybiEwO2Zvcih2YXIgbiBpbiBlLm1hcClpZigwPT09dC5pbmRleE9mKG4pJiZ0LnN1YnN0cihuLmxlbmd0aClpbiBlLnBoYXNlcylyZXR1cm4hMDtyZXR1cm4hMX0sZS5pbml0U2NvcGU9TSxlLlNjb3BlPWUuZGVmYXVsdD12b2lkIDA7dmFyIG49ZChEKSxyPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PXYodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9cCgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShsZSksbz1kKGJ0KSxpPWQoV2UpLGE9ZChUKHt9KSksdT1kKGsoe30pKSxzPWQoWmUpLGw9ZCh6ZSksYz1kKGNuKSxmPWQoRSh7fSkpO2Z1bmN0aW9uIHAoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBwPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gdih0KXtyZXR1cm4odj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9ZnVuY3Rpb24geSh0LGUpe3JldHVybiFlfHxcIm9iamVjdFwiIT09dihlKSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT9mdW5jdGlvbih0KXtpZih2b2lkIDAhPT10KXJldHVybiB0O3Rocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKX0odCk6ZX1mdW5jdGlvbiBoKHQsZSxuKXtyZXR1cm4oaD1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5nZXQ/UmVmbGVjdC5nZXQ6ZnVuY3Rpb24odCxlLG4pe3ZhciByPWZ1bmN0aW9uKHQsZSl7Zm9yKDshT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkmJm51bGwhPT0odD1nKHQpKTspO3JldHVybiB0fSh0LGUpO2lmKHIpe3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixlKTtyZXR1cm4gby5nZXQ/by5nZXQuY2FsbChuKTpvLnZhbHVlfX0pKHQsZSxufHx0KX1mdW5jdGlvbiBnKHQpe3JldHVybihnPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX1mdW5jdGlvbiBiKHQsZSl7cmV0dXJuKGI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIG0odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIE8odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIHcodCxlLG4pe3JldHVybiBlJiZPKHQucHJvdG90eXBlLGUpLG4mJk8odCxuKSx0fWZ1bmN0aW9uIF8odCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBQPXIud2luLHg9ci5icm93c2VyLFM9ci5yYWYsaj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt2YXIgZT10aGlzO20odGhpcyx0KSxfKHRoaXMsXCJpZFwiLFwiX19pbnRlcmFjdF9zY29wZV9cIi5jb25jYXQoTWF0aC5mbG9vcigxMDAqTWF0aC5yYW5kb20oKSkpKSxfKHRoaXMsXCJpc0luaXRpYWxpemVkXCIsITEpLF8odGhpcyxcImxpc3RlbmVyTWFwc1wiLFtdKSxfKHRoaXMsXCJicm93c2VyXCIseCksXyh0aGlzLFwidXRpbHNcIixyKSxfKHRoaXMsXCJkZWZhdWx0c1wiLHIuY2xvbmUobC5kZWZhdWx0KSksXyh0aGlzLFwiRXZlbnRhYmxlXCIsby5kZWZhdWx0KSxfKHRoaXMsXCJhY3Rpb25zXCIse21hcDp7fSxwaGFzZXM6e3N0YXJ0OiEwLG1vdmU6ITAsZW5kOiEwfSxtZXRob2REaWN0Ont9LHBoYXNlbGVzc1R5cGVzOnt9fSksXyh0aGlzLFwiaW50ZXJhY3RTdGF0aWNcIixuZXcgYS5kZWZhdWx0KHRoaXMpKSxfKHRoaXMsXCJJbnRlcmFjdEV2ZW50XCIsaS5kZWZhdWx0KSxfKHRoaXMsXCJJbnRlcmFjdGFibGVcIix2b2lkIDApLF8odGhpcyxcImludGVyYWN0YWJsZXNcIixuZXcgcy5kZWZhdWx0KHRoaXMpKSxfKHRoaXMsXCJfd2luXCIsdm9pZCAwKSxfKHRoaXMsXCJkb2N1bWVudFwiLHZvaWQgMCksXyh0aGlzLFwid2luZG93XCIsdm9pZCAwKSxfKHRoaXMsXCJkb2N1bWVudHNcIixbXSksXyh0aGlzLFwiX3BsdWdpbnNcIix7bGlzdDpbXSxtYXA6e319KSxfKHRoaXMsXCJvbldpbmRvd1VubG9hZFwiLGZ1bmN0aW9uKHQpe3JldHVybiBlLnJlbW92ZURvY3VtZW50KHQudGFyZ2V0KX0pO3ZhciBuPXRoaXM7dGhpcy5JbnRlcmFjdGFibGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cmV0dXJuIG0odGhpcyxlKSx5KHRoaXMsZyhlKS5hcHBseSh0aGlzLGFyZ3VtZW50cykpfXJldHVybiBmdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmYih0LGUpfShlLHVbXCJkZWZhdWx0XCJdKSx3KGUsW3trZXk6XCJzZXRcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gaChnKGUucHJvdG90eXBlKSxcInNldFwiLHRoaXMpLmNhbGwodGhpcyx0KSxuLmZpcmUoXCJpbnRlcmFjdGFibGU6c2V0XCIse29wdGlvbnM6dCxpbnRlcmFjdGFibGU6dGhpc30pLHRoaXN9fSx7a2V5OlwidW5zZXRcIix2YWx1ZTpmdW5jdGlvbigpe2goZyhlLnByb3RvdHlwZSksXCJ1bnNldFwiLHRoaXMpLmNhbGwodGhpcyksbi5pbnRlcmFjdGFibGVzLmxpc3Quc3BsaWNlKG4uaW50ZXJhY3RhYmxlcy5saXN0LmluZGV4T2YodGhpcyksMSksbi5maXJlKFwiaW50ZXJhY3RhYmxlOnVuc2V0XCIse2ludGVyYWN0YWJsZTp0aGlzfSl9fSx7a2V5OlwiX2RlZmF1bHRzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdHN9fV0pLGV9KCl9cmV0dXJuIHcodCxbe2tleTpcImFkZExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5saXN0ZW5lck1hcHMucHVzaCh7aWQ6ZSxtYXA6dH0pfX0se2tleTpcImZpcmVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dGhpcy5saXN0ZW5lck1hcHMubGVuZ3RoO24rKyl7dmFyIHI9dGhpcy5saXN0ZW5lck1hcHNbbl0ubWFwW3RdO2lmKHImJiExPT09cihlLHRoaXMsdCkpcmV0dXJuITF9fX0se2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0luaXRpYWxpemVkP3RoaXM6TSh0aGlzLHQpfX0se2tleTpcInBsdWdpbklzSW5zdGFsbGVkXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3BsdWdpbnMubWFwW3QuaWRdfHwtMSE9PXRoaXMuX3BsdWdpbnMubGlzdC5pbmRleE9mKHQpfX0se2tleTpcInVzZVBsdWdpblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5wbHVnaW5Jc0luc3RhbGxlZCh0KSlyZXR1cm4gdGhpcztpZih0LmlkJiYodGhpcy5fcGx1Z2lucy5tYXBbdC5pZF09dCksdGhpcy5fcGx1Z2lucy5saXN0LnB1c2godCksdC5pbnN0YWxsJiZ0Lmluc3RhbGwodGhpcyxlKSx0Lmxpc3RlbmVycyYmdC5iZWZvcmUpe2Zvcih2YXIgbj0wLHI9dGhpcy5saXN0ZW5lck1hcHMubGVuZ3RoLG89dC5iZWZvcmUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbZV09ITAsdH0se30pO248cjtuKyspe2lmKG9bdGhpcy5saXN0ZW5lck1hcHNbbl0uaWRdKWJyZWFrfXRoaXMubGlzdGVuZXJNYXBzLnNwbGljZShuLDAse2lkOnQuaWQsbWFwOnQubGlzdGVuZXJzfSl9ZWxzZSB0Lmxpc3RlbmVycyYmdGhpcy5saXN0ZW5lck1hcHMucHVzaCh7aWQ6dC5pZCxtYXA6dC5saXN0ZW5lcnN9KTtyZXR1cm4gdGhpc319LHtrZXk6XCJhZGREb2N1bWVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoLTEhPT10aGlzLmdldERvY0luZGV4KHQpKXJldHVybiExO3ZhciBuPVAuZ2V0V2luZG93KHQpO2U9ZT9yLmV4dGVuZCh7fSxlKTp7fSx0aGlzLmRvY3VtZW50cy5wdXNoKHtkb2M6dCxvcHRpb25zOmV9KSx0aGlzLmV2ZW50cy5kb2N1bWVudHMucHVzaCh0KSx0IT09dGhpcy5kb2N1bWVudCYmdGhpcy5ldmVudHMuYWRkKG4sXCJ1bmxvYWRcIix0aGlzLm9uV2luZG93VW5sb2FkKSx0aGlzLmZpcmUoXCJzY29wZTphZGQtZG9jdW1lbnRcIix7ZG9jOnQsd2luZG93Om4sc2NvcGU6dGhpcyxvcHRpb25zOmV9KX19LHtrZXk6XCJyZW1vdmVEb2N1bWVudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0RG9jSW5kZXgodCksbj1QLmdldFdpbmRvdyh0KSxyPXRoaXMuZG9jdW1lbnRzW2VdLm9wdGlvbnM7dGhpcy5ldmVudHMucmVtb3ZlKG4sXCJ1bmxvYWRcIix0aGlzLm9uV2luZG93VW5sb2FkKSx0aGlzLmRvY3VtZW50cy5zcGxpY2UoZSwxKSx0aGlzLmV2ZW50cy5kb2N1bWVudHMuc3BsaWNlKGUsMSksdGhpcy5maXJlKFwic2NvcGU6cmVtb3ZlLWRvY3VtZW50XCIse2RvYzp0LHdpbmRvdzpuLHNjb3BlOnRoaXMsb3B0aW9uczpyfSl9fSx7a2V5OlwiZ2V0RG9jSW5kZXhcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMuZG9jdW1lbnRzLmxlbmd0aDtlKyspaWYodGhpcy5kb2N1bWVudHNbZV0uZG9jPT09dClyZXR1cm4gZTtyZXR1cm4tMX19LHtrZXk6XCJnZXREb2NPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXREb2NJbmRleCh0KTtyZXR1cm4tMT09PWU/bnVsbDp0aGlzLmRvY3VtZW50c1tlXS5vcHRpb25zfX0se2tleTpcIm5vd1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMud2luZG93LkRhdGV8fERhdGUpLm5vdygpfX1dKSx0fSgpO2Z1bmN0aW9uIE0odCxlKXtyZXR1cm4gdC5pc0luaXRpYWxpemVkPSEwLFAuaW5pdChlKSxuLmRlZmF1bHQuaW5pdChlKSx4LmluaXQoZSksUy5pbml0KGUpLHQud2luZG93PWUsdC5kb2N1bWVudD1lLmRvY3VtZW50LHQudXNlUGx1Z2luKGYuZGVmYXVsdCksdC51c2VQbHVnaW4oYy5kZWZhdWx0KSx0fWUuU2NvcGU9ZS5kZWZhdWx0PWp9KSxFPXQoZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9dm9pZCAwO3ZhciBfPW4oQyksdT1uKEQpLFA9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09Yyh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1hKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHp0KSxzPW4oRW4pLGw9bihVbiksbz1uKHRyKTtuKG0oe30pKTtmdW5jdGlvbiBhKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gYT1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIG4odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIGModCl7cmV0dXJuKGM9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIHgodCxlKXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKSlyZXR1cm47dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEsdT10W1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO3I9ITApO31jYXRjaCh0KXtvPSEwLGk9dH1maW5hbGx5e3RyeXtyfHxudWxsPT11LnJldHVybnx8dS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgaX19cmV0dXJuIG59KHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9ZnVuY3Rpb24gZih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gcCh0LGUpe3JldHVybiFlfHxcIm9iamVjdFwiIT09YyhlKSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT9mdW5jdGlvbih0KXtpZih2b2lkIDAhPT10KXJldHVybiB0O3Rocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKX0odCk6ZX1mdW5jdGlvbiBkKHQpe3JldHVybihkPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX1mdW5jdGlvbiB2KHQsZSl7cmV0dXJuKHY9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfXZhciB5PVtcInBvaW50ZXJEb3duXCIsXCJwb2ludGVyTW92ZVwiLFwicG9pbnRlclVwXCIsXCJ1cGRhdGVQb2ludGVyXCIsXCJyZW1vdmVQb2ludGVyXCIsXCJ3aW5kb3dCbHVyXCJdO2Z1bmN0aW9uIGgoTyx3KXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dy5pbnRlcmFjdGlvbnMubGlzdCxuPVAuZ2V0UG9pbnRlclR5cGUodCkscj14KFAuZ2V0RXZlbnRUYXJnZXRzKHQpLDIpLG89clswXSxpPXJbMV0sYT1bXTtpZigvXnRvdWNoLy50ZXN0KHQudHlwZSkpe3cucHJldlRvdWNoVGltZT13Lm5vdygpO2Zvcih2YXIgdT0wO3U8dC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7dSsrKXtzPXQuY2hhbmdlZFRvdWNoZXNbdV07dmFyIHMsbD17cG9pbnRlcjpzLHBvaW50ZXJJZDpQLmdldFBvaW50ZXJJZChzKSxwb2ludGVyVHlwZTpuLGV2ZW50VHlwZTp0LnR5cGUsZXZlbnRUYXJnZXQ6byxjdXJFdmVudFRhcmdldDppLHNjb3BlOnd9LGM9UyhsKTthLnB1c2goW2wucG9pbnRlcixsLmV2ZW50VGFyZ2V0LGwuY3VyRXZlbnRUYXJnZXQsY10pfX1lbHNle3ZhciBmPSExO2lmKCFfLmRlZmF1bHQuc3VwcG9ydHNQb2ludGVyRXZlbnQmJi9tb3VzZS8udGVzdCh0LnR5cGUpKXtmb3IodmFyIHA9MDtwPGUubGVuZ3RoJiYhZjtwKyspZj1cIm1vdXNlXCIhPT1lW3BdLnBvaW50ZXJUeXBlJiZlW3BdLnBvaW50ZXJJc0Rvd247Zj1mfHx3Lm5vdygpLXcucHJldlRvdWNoVGltZTw1MDB8fDA9PT10LnRpbWVTdGFtcH1pZighZil7dmFyIGQ9e3BvaW50ZXI6dCxwb2ludGVySWQ6UC5nZXRQb2ludGVySWQodCkscG9pbnRlclR5cGU6bixldmVudFR5cGU6dC50eXBlLGN1ckV2ZW50VGFyZ2V0OmksZXZlbnRUYXJnZXQ6byxzY29wZTp3fSx2PVMoZCk7YS5wdXNoKFtkLnBvaW50ZXIsZC5ldmVudFRhcmdldCxkLmN1ckV2ZW50VGFyZ2V0LHZdKX19Zm9yKHZhciB5PTA7eTxhLmxlbmd0aDt5Kyspe3ZhciBoPXgoYVt5XSw0KSxnPWhbMF0sYj1oWzFdLG09aFsyXTtoWzNdW09dKGcsdCxiLG0pfX19ZnVuY3Rpb24gUyh0KXt2YXIgZT10LnBvaW50ZXJUeXBlLG49dC5zY29wZSxyPXtpbnRlcmFjdGlvbjpvLmRlZmF1bHQuc2VhcmNoKHQpLHNlYXJjaERldGFpbHM6dH07cmV0dXJuIG4uZmlyZShcImludGVyYWN0aW9uczpmaW5kXCIsciksci5pbnRlcmFjdGlvbnx8bi5pbnRlcmFjdGlvbnMubmV3KHtwb2ludGVyVHlwZTplfSl9ZnVuY3Rpb24gcih0LGUpe3ZhciBuPXQuZG9jLHI9dC5zY29wZSxvPXQub3B0aW9ucyxpPXIuaW50ZXJhY3Rpb25zLmRvY0V2ZW50cyxhPXIuZXZlbnRzLHU9YVtlXTtmb3IodmFyIHMgaW4gci5icm93c2VyLmlzSU9TJiYhby5ldmVudHMmJihvLmV2ZW50cz17cGFzc2l2ZTohMX0pLGEuZGVsZWdhdGVkRXZlbnRzKXUobixzLGEuZGVsZWdhdGVMaXN0ZW5lciksdShuLHMsYS5kZWxlZ2F0ZVVzZUNhcHR1cmUsITApO2Zvcih2YXIgbD1vJiZvLmV2ZW50cyxjPTA7YzxpLmxlbmd0aDtjKyspe3ZhciBmO2Y9aVtjXTt1KG4sZi50eXBlLGYubGlzdGVuZXIsbCl9fXZhciBpPXtpZDpcImNvcmUvaW50ZXJhY3Rpb25zXCIsaW5zdGFsbDpmdW5jdGlvbihvKXtmb3IodmFyIHQ9e30sZT0wO2U8eS5sZW5ndGg7ZSsrKXt2YXIgbjtuPXlbZV07dFtuXT1oKG4sbyl9dmFyIHIsaT1fLmRlZmF1bHQucEV2ZW50VHlwZXM7ZnVuY3Rpb24gYSgpe2Zvcih2YXIgdD0wO3Q8by5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7dCsrKXt2YXIgZT1vLmludGVyYWN0aW9ucy5saXN0W3RdO2lmKGUucG9pbnRlcklzRG93biYmXCJ0b3VjaFwiPT09ZS5wb2ludGVyVHlwZSYmIWUuX2ludGVyYWN0aW5nKWZvcih2YXIgbj1mdW5jdGlvbigpe3ZhciBuPWUucG9pbnRlcnNbcl07by5kb2N1bWVudHMuc29tZShmdW5jdGlvbih0KXt2YXIgZT10LmRvYztyZXR1cm4oMCwkLm5vZGVDb250YWlucykoZSxuLmRvd25UYXJnZXQpfSl8fGUucmVtb3ZlUG9pbnRlcihuLnBvaW50ZXIsbi5ldmVudCl9LHI9MDtyPGUucG9pbnRlcnMubGVuZ3RoO3IrKyl7bigpfX19KHI9dS5kZWZhdWx0LlBvaW50ZXJFdmVudD9be3R5cGU6aS5kb3duLGxpc3RlbmVyOmF9LHt0eXBlOmkuZG93bixsaXN0ZW5lcjp0LnBvaW50ZXJEb3dufSx7dHlwZTppLm1vdmUsbGlzdGVuZXI6dC5wb2ludGVyTW92ZX0se3R5cGU6aS51cCxsaXN0ZW5lcjp0LnBvaW50ZXJVcH0se3R5cGU6aS5jYW5jZWwsbGlzdGVuZXI6dC5wb2ludGVyVXB9XTpbe3R5cGU6XCJtb3VzZWRvd25cIixsaXN0ZW5lcjp0LnBvaW50ZXJEb3dufSx7dHlwZTpcIm1vdXNlbW92ZVwiLGxpc3RlbmVyOnQucG9pbnRlck1vdmV9LHt0eXBlOlwibW91c2V1cFwiLGxpc3RlbmVyOnQucG9pbnRlclVwfSx7dHlwZTpcInRvdWNoc3RhcnRcIixsaXN0ZW5lcjphfSx7dHlwZTpcInRvdWNoc3RhcnRcIixsaXN0ZW5lcjp0LnBvaW50ZXJEb3dufSx7dHlwZTpcInRvdWNobW92ZVwiLGxpc3RlbmVyOnQucG9pbnRlck1vdmV9LHt0eXBlOlwidG91Y2hlbmRcIixsaXN0ZW5lcjp0LnBvaW50ZXJVcH0se3R5cGU6XCJ0b3VjaGNhbmNlbFwiLGxpc3RlbmVyOnQucG9pbnRlclVwfV0pLnB1c2goe3R5cGU6XCJibHVyXCIsbGlzdGVuZXI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTxvLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDtlKyspe28uaW50ZXJhY3Rpb25zLmxpc3RbZV0uZG9jdW1lbnRCbHVyKHQpfX19KSxvLnByZXZUb3VjaFRpbWU9MCxvLkludGVyYWN0aW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3JldHVybiBmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsdCkscCh0aGlzLGQodCkuYXBwbHkodGhpcyxhcmd1bWVudHMpKX12YXIgZSxuLHI7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiZ2KHQsZSl9KHQsc1tcImRlZmF1bHRcIl0pLGU9dCwobj1be2tleTpcIl9ub3dcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBvLm5vdygpfX0se2tleTpcInBvaW50ZXJNb3ZlVG9sZXJhbmNlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uaW50ZXJhY3Rpb25zLnBvaW50ZXJNb3ZlVG9sZXJhbmNlfSxzZXQ6ZnVuY3Rpb24odCl7by5pbnRlcmFjdGlvbnMucG9pbnRlck1vdmVUb2xlcmFuY2U9dH19XSkmJmYoZS5wcm90b3R5cGUsbiksciYmZihlLHIpLHR9KCksby5pbnRlcmFjdGlvbnM9e2xpc3Q6W10sbmV3OmZ1bmN0aW9uKHQpe3Quc2NvcGVGaXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG8uZmlyZSh0LGUpfTt2YXIgZT1uZXcgby5JbnRlcmFjdGlvbih0KTtyZXR1cm4gby5pbnRlcmFjdGlvbnMubGlzdC5wdXNoKGUpLGV9LGxpc3RlbmVyczp0LGRvY0V2ZW50czpyLHBvaW50ZXJNb3ZlVG9sZXJhbmNlOjF9LG8udXNlUGx1Z2luKGwuZGVmYXVsdCl9LGxpc3RlbmVyczp7XCJzY29wZTphZGQtZG9jdW1lbnRcIjpmdW5jdGlvbih0KXtyZXR1cm4gcih0LFwiYWRkXCIpfSxcInNjb3BlOnJlbW92ZS1kb2N1bWVudFwiOmZ1bmN0aW9uKHQpe3JldHVybiByKHQsXCJyZW1vdmVcIil9LFwiaW50ZXJhY3RhYmxlOnVuc2V0XCI6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pbnRlcmFjdGFibGUscj1lLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aC0xOzA8PXI7ci0tKXt2YXIgbz1lLmludGVyYWN0aW9ucy5saXN0W3JdO28uaW50ZXJhY3RhYmxlPT09biYmKG8uc3RvcCgpLGUuZmlyZShcImludGVyYWN0aW9uczpkZXN0cm95XCIse2ludGVyYWN0aW9uOm99KSxvLmRlc3Ryb3koKSwyPGUuaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoJiZlLmludGVyYWN0aW9ucy5saXN0LnNwbGljZShyLDEpKX19fSxvbkRvY1NpZ25hbDpyLGRvT25JbnRlcmFjdGlvbnM6aCxtZXRob2ROYW1lczp5fTtlLmRlZmF1bHQ9aX0pLFQ9dChmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGEodCl7cmV0dXJuKGE9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD1lLkludGVyYWN0U3RhdGljPXZvaWQgMDt2YXIgbixyPShuPUMpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSx1PWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWEodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9bCgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShsZSkscz1tKHt9KTtmdW5jdGlvbiBsKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gbD1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIG8odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIGModCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShyKXt2YXIgbz10aGlzOyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsYSksdGhpcy5zY29wZT1yLGModGhpcyxcImdldFBvaW50ZXJBdmVyYWdlXCIsdS5wb2ludGVyLnBvaW50ZXJBdmVyYWdlKSxjKHRoaXMsXCJnZXRUb3VjaEJCb3hcIix1LnBvaW50ZXIudG91Y2hCQm94KSxjKHRoaXMsXCJnZXRUb3VjaERpc3RhbmNlXCIsdS5wb2ludGVyLnRvdWNoRGlzdGFuY2UpLGModGhpcyxcImdldFRvdWNoQW5nbGVcIix1LnBvaW50ZXIudG91Y2hBbmdsZSksYyh0aGlzLFwiZ2V0RWxlbWVudFJlY3RcIix1LmRvbS5nZXRFbGVtZW50UmVjdCksYyh0aGlzLFwiZ2V0RWxlbWVudENsaWVudFJlY3RcIix1LmRvbS5nZXRFbGVtZW50Q2xpZW50UmVjdCksYyh0aGlzLFwibWF0Y2hlc1NlbGVjdG9yXCIsdS5kb20ubWF0Y2hlc1NlbGVjdG9yKSxjKHRoaXMsXCJjbG9zZXN0XCIsdS5kb20uY2xvc2VzdCksYyh0aGlzLFwiZ2xvYmFsRXZlbnRzXCIse30pLGModGhpcyxcImR5bmFtaWNEcm9wXCIsdm9pZCAwKSxjKHRoaXMsXCJ2ZXJzaW9uXCIsXCIxLjkuOFwiKSxjKHRoaXMsXCJpbnRlcmFjdFwiLHZvaWQgMCk7Zm9yKHZhciB0PXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLGU9ZnVuY3Rpb24odCxlKXt2YXIgbj1yLmludGVyYWN0YWJsZXMuZ2V0KHQsZSk7cmV0dXJuIG58fCgobj1yLmludGVyYWN0YWJsZXMubmV3KHQsZSkpLmV2ZW50cy5nbG9iYWw9by5nbG9iYWxFdmVudHMpLG59LG49MDtuPE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKS5sZW5ndGg7bisrKXt2YXIgaTtpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKVtuXTtlW2ldPXRbaV19cmV0dXJuIHUuZXh0ZW5kKGUsdGhpcyksZS5jb25zdHJ1Y3Rvcj10aGlzLmNvbnN0cnVjdG9yLHRoaXMuaW50ZXJhY3Q9ZX12YXIgdCxlLG47cmV0dXJuIHQ9YSwoZT1be2tleTpcInVzZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc2NvcGUudXNlUGx1Z2luKHQsZSksdGhpc319LHtrZXk6XCJpc1NldFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuISF0aGlzLnNjb3BlLmludGVyYWN0YWJsZXMuZ2V0KHQsZSYmZS5jb250ZXh0KX19LHtrZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtpZih1LmlzLnN0cmluZyh0KSYmLTEhPT10LnNlYXJjaChcIiBcIikmJih0PXQudHJpbSgpLnNwbGl0KC8gKy8pKSx1LmlzLmFycmF5KHQpKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG89dFtyXTt0aGlzLm9uKG8sZSxuKX1yZXR1cm4gdGhpc31pZih1LmlzLm9iamVjdCh0KSl7Zm9yKHZhciBpIGluIHQpdGhpcy5vbihpLHRbaV0sZSk7cmV0dXJuIHRoaXN9cmV0dXJuKDAscy5pc05vbk5hdGl2ZUV2ZW50KSh0LHRoaXMuc2NvcGUuYWN0aW9ucyk/dGhpcy5nbG9iYWxFdmVudHNbdF0/dGhpcy5nbG9iYWxFdmVudHNbdF0ucHVzaChlKTp0aGlzLmdsb2JhbEV2ZW50c1t0XT1bZV06dGhpcy5zY29wZS5ldmVudHMuYWRkKHRoaXMuc2NvcGUuZG9jdW1lbnQsdCxlLHtvcHRpb25zOm59KSx0aGlzfX0se2tleTpcIm9mZlwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtpZih1LmlzLnN0cmluZyh0KSYmLTEhPT10LnNlYXJjaChcIiBcIikmJih0PXQudHJpbSgpLnNwbGl0KC8gKy8pKSx1LmlzLmFycmF5KHQpKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG89dFtyXTt0aGlzLm9mZihvLGUsbil9cmV0dXJuIHRoaXN9aWYodS5pcy5vYmplY3QodCkpe2Zvcih2YXIgaSBpbiB0KXRoaXMub2ZmKGksdFtpXSxlKTtyZXR1cm4gdGhpc312YXIgYTsoMCxzLmlzTm9uTmF0aXZlRXZlbnQpKHQsdGhpcy5zY29wZS5hY3Rpb25zKT90IGluIHRoaXMuZ2xvYmFsRXZlbnRzJiYtMSE9PShhPXRoaXMuZ2xvYmFsRXZlbnRzW3RdLmluZGV4T2YoZSkpJiZ0aGlzLmdsb2JhbEV2ZW50c1t0XS5zcGxpY2UoYSwxKTp0aGlzLnNjb3BlLmV2ZW50cy5yZW1vdmUodGhpcy5zY29wZS5kb2N1bWVudCx0LGUsbik7cmV0dXJuIHRoaXN9fSx7a2V5OlwiZGVidWdcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNjb3BlfX0se2tleTpcInN1cHBvcnRzVG91Y2hcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuc3VwcG9ydHNUb3VjaH19LHtrZXk6XCJzdXBwb3J0c1BvaW50ZXJFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5zdXBwb3J0c1BvaW50ZXJFdmVudH19LHtrZXk6XCJzdG9wXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMuc2NvcGUuaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO3QrKyl7dGhpcy5zY29wZS5pbnRlcmFjdGlvbnMubGlzdFt0XS5zdG9wKCl9cmV0dXJuIHRoaXN9fSx7a2V5OlwicG9pbnRlck1vdmVUb2xlcmFuY2VcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdS5pcy5udW1iZXIodCk/KHRoaXMuc2NvcGUuaW50ZXJhY3Rpb25zLnBvaW50ZXJNb3ZlVG9sZXJhbmNlPXQsdGhpcyk6dGhpcy5zY29wZS5pbnRlcmFjdGlvbnMucG9pbnRlck1vdmVUb2xlcmFuY2V9fSx7a2V5OlwiYWRkRG9jdW1lbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3RoaXMuc2NvcGUuYWRkRG9jdW1lbnQodCxlKX19LHtrZXk6XCJyZW1vdmVEb2N1bWVudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuc2NvcGUucmVtb3ZlRG9jdW1lbnQodCl9fV0pJiZvKHQucHJvdG90eXBlLGUpLG4mJm8odCxuKSxhfSgpLGY9ZS5JbnRlcmFjdFN0YXRpYz1pO2UuZGVmYXVsdD1mfSksZT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9dm9pZCAwO2UuZGVmYXVsdD1mdW5jdGlvbih0KXtyZXR1cm4hKCF0fHwhdC5XaW5kb3cpJiZ0IGluc3RhbmNlb2YgdC5XaW5kb3d9O3ZhciBPPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShPLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE8uaW5pdD1pLE8uZ2V0V2luZG93PWEsTy5kZWZhdWx0PXZvaWQgMDt2YXIgbixyPShuPWUpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTt2YXIgbz17cmVhbFdpbmRvdzp2b2lkIDAsd2luZG93OnZvaWQgMCxnZXRXaW5kb3c6YSxpbml0Oml9O2Z1bmN0aW9uIGkodCl7dmFyIGU9KG8ucmVhbFdpbmRvdz10KS5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtlLm93bmVyRG9jdW1lbnQhPT10LmRvY3VtZW50JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LndyYXAmJnQud3JhcChlKT09PWUmJih0PXQud3JhcCh0KSksby53aW5kb3c9dH1mdW5jdGlvbiBhKHQpe3JldHVybigwLHIuZGVmYXVsdCkodCk/dDoodC5vd25lckRvY3VtZW50fHx0KS5kZWZhdWx0Vmlld3x8by53aW5kb3d9XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz8oby53aW5kb3c9dm9pZCAwLG8ucmVhbFdpbmRvdz12b2lkIDApOmkod2luZG93KSxvLmluaXQ9aTt2YXIgdT1vO08uZGVmYXVsdD11O3ZhciB3PXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHcuYXJyYXk9dy5wbGFpbk9iamVjdD13LmVsZW1lbnQ9dy5zdHJpbmc9dy5ib29sPXcubnVtYmVyPXcuZnVuYz13Lm9iamVjdD13LmRvY0ZyYWc9dy53aW5kb3c9dm9pZCAwO3ZhciBzPWMoZSksbD1jKE8pO2Z1bmN0aW9uIGModCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIGYodCl7cmV0dXJuKGY9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfXcud2luZG93PWZ1bmN0aW9uKHQpe3JldHVybiB0PT09bC5kZWZhdWx0LndpbmRvd3x8KDAscy5kZWZhdWx0KSh0KX07dy5kb2NGcmFnPWZ1bmN0aW9uKHQpe3JldHVybiBwKHQpJiYxMT09PXQubm9kZVR5cGV9O3ZhciBwPWZ1bmN0aW9uKHQpe3JldHVybiEhdCYmXCJvYmplY3RcIj09PWYodCl9O3cub2JqZWN0PXA7ZnVuY3Rpb24gZCh0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fXcuZnVuYz1kO3cubnVtYmVyPWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0fTt3LmJvb2w9ZnVuY3Rpb24odCl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0fTt3LnN0cmluZz1mdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdH07dy5lbGVtZW50PWZ1bmN0aW9uKHQpe2lmKCF0fHxcIm9iamVjdFwiIT09Zih0KSlyZXR1cm4hMTt2YXIgZT1sLmRlZmF1bHQuZ2V0V2luZG93KHQpfHxsLmRlZmF1bHQud2luZG93O3JldHVybi9vYmplY3R8ZnVuY3Rpb24vLnRlc3QoZihlLkVsZW1lbnQpKT90IGluc3RhbmNlb2YgZS5FbGVtZW50OjE9PT10Lm5vZGVUeXBlJiZcInN0cmluZ1wiPT10eXBlb2YgdC5ub2RlTmFtZX07dy5wbGFpbk9iamVjdD1mdW5jdGlvbih0KXtyZXR1cm4gcCh0KSYmISF0LmNvbnN0cnVjdG9yJiYvZnVuY3Rpb24gT2JqZWN0XFxiLy50ZXN0KHQuY29uc3RydWN0b3IudG9TdHJpbmcoKSl9O3cuYXJyYXk9ZnVuY3Rpb24odCl7cmV0dXJuIHAodCkmJnZvaWQgMCE9PXQubGVuZ3RoJiZkKHQuc3BsaWNlKX07dmFyIHY9e307ZnVuY3Rpb24geSh0KXtyZXR1cm4oeT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHYsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdi5kZWZhdWx0PXZvaWQgMDt2YXIgaD1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT15KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPWcoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0odyk7ZnVuY3Rpb24gZygpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIGc9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBiKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247aWYoXCJkcmFnXCI9PT1lLnByZXBhcmVkLm5hbWUpe3ZhciBuPWUucHJlcGFyZWQuYXhpcztcInhcIj09PW4/KGUuY29vcmRzLmN1ci5wYWdlLnk9ZS5jb29yZHMuc3RhcnQucGFnZS55LGUuY29vcmRzLmN1ci5jbGllbnQueT1lLmNvb3Jkcy5zdGFydC5jbGllbnQueSxlLmNvb3Jkcy52ZWxvY2l0eS5jbGllbnQueT0wLGUuY29vcmRzLnZlbG9jaXR5LnBhZ2UueT0wKTpcInlcIj09PW4mJihlLmNvb3Jkcy5jdXIucGFnZS54PWUuY29vcmRzLnN0YXJ0LnBhZ2UueCxlLmNvb3Jkcy5jdXIuY2xpZW50Lng9ZS5jb29yZHMuc3RhcnQuY2xpZW50LngsZS5jb29yZHMudmVsb2NpdHkuY2xpZW50Lng9MCxlLmNvb3Jkcy52ZWxvY2l0eS5wYWdlLng9MCl9fWZ1bmN0aW9uIF8odCl7dmFyIGU9dC5pRXZlbnQsbj10LmludGVyYWN0aW9uO2lmKFwiZHJhZ1wiPT09bi5wcmVwYXJlZC5uYW1lKXt2YXIgcj1uLnByZXBhcmVkLmF4aXM7aWYoXCJ4XCI9PT1yfHxcInlcIj09PXIpe3ZhciBvPVwieFwiPT09cj9cInlcIjpcInhcIjtlLnBhZ2Vbb109bi5jb29yZHMuc3RhcnQucGFnZVtvXSxlLmNsaWVudFtvXT1uLmNvb3Jkcy5zdGFydC5jbGllbnRbb10sZS5kZWx0YVtvXT0wfX19dmFyIFA9e2lkOlwiYWN0aW9ucy9kcmFnXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmFjdGlvbnMsbj10LkludGVyYWN0YWJsZSxyPXQuZGVmYXVsdHM7bi5wcm90b3R5cGUuZHJhZ2dhYmxlPVAuZHJhZ2dhYmxlLGUubWFwLmRyYWc9UCxlLm1ldGhvZERpY3QuZHJhZz1cImRyYWdnYWJsZVwiLHIuYWN0aW9ucy5kcmFnPVAuZGVmYXVsdHN9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1tb3ZlXCI6YixcImludGVyYWN0aW9uczphY3Rpb24tcmVzdW1lXCI6YixcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOl8sXCJhdXRvLXN0YXJ0OmNoZWNrXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuaW50ZXJhY3RhYmxlLHI9dC5idXR0b25zLG89bi5vcHRpb25zLmRyYWc7aWYobyYmby5lbmFibGVkJiYoIWUucG9pbnRlcklzRG93bnx8IS9tb3VzZXxwb2ludGVyLy50ZXN0KGUucG9pbnRlclR5cGUpfHwwIT0ociZuLm9wdGlvbnMuZHJhZy5tb3VzZUJ1dHRvbnMpKSlyZXR1cm4hKHQuYWN0aW9uPXtuYW1lOlwiZHJhZ1wiLGF4aXM6XCJzdGFydFwiPT09by5sb2NrQXhpcz9vLnN0YXJ0QXhpczpvLmxvY2tBeGlzfSl9fSxkcmFnZ2FibGU6ZnVuY3Rpb24odCl7cmV0dXJuIGgub2JqZWN0KHQpPyh0aGlzLm9wdGlvbnMuZHJhZy5lbmFibGVkPSExIT09dC5lbmFibGVkLHRoaXMuc2V0UGVyQWN0aW9uKFwiZHJhZ1wiLHQpLHRoaXMuc2V0T25FdmVudHMoXCJkcmFnXCIsdCksL14oeHl8eHx5fHN0YXJ0KSQvLnRlc3QodC5sb2NrQXhpcykmJih0aGlzLm9wdGlvbnMuZHJhZy5sb2NrQXhpcz10LmxvY2tBeGlzKSwvXih4eXx4fHkpJC8udGVzdCh0LnN0YXJ0QXhpcykmJih0aGlzLm9wdGlvbnMuZHJhZy5zdGFydEF4aXM9dC5zdGFydEF4aXMpLHRoaXMpOmguYm9vbCh0KT8odGhpcy5vcHRpb25zLmRyYWcuZW5hYmxlZD10LHRoaXMpOnRoaXMub3B0aW9ucy5kcmFnfSxiZWZvcmVNb3ZlOmIsbW92ZTpfLGRlZmF1bHRzOntzdGFydEF4aXM6XCJ4eVwiLGxvY2tBeGlzOlwieHlcIn0sZ2V0Q3Vyc29yOmZ1bmN0aW9uKCl7cmV0dXJuXCJtb3ZlXCJ9fSx4PVA7di5kZWZhdWx0PXg7dmFyIFM9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KFMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksUy5maW5kPVMuZmluZEluZGV4PVMuZnJvbT1TLm1lcmdlPVMucmVtb3ZlPVMuY29udGFpbnM9dm9pZCAwO1MuY29udGFpbnM9ZnVuY3Rpb24odCxlKXtyZXR1cm4tMSE9PXQuaW5kZXhPZihlKX07Uy5yZW1vdmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5zcGxpY2UodC5pbmRleE9mKGUpLDEpfTtmdW5jdGlvbiBqKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07dC5wdXNoKHIpfXJldHVybiB0fVMubWVyZ2U9ajtTLmZyb209ZnVuY3Rpb24odCl7cmV0dXJuIGooW10sdCl9O2Z1bmN0aW9uIE0odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZihlKHRbbl0sbix0KSlyZXR1cm4gbjtyZXR1cm4tMX1TLmZpbmRJbmRleD1NO1MuZmluZD1mdW5jdGlvbih0LGUpe3JldHVybiB0W00odCxlKV19O3ZhciBEPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShELFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEQuZGVmYXVsdD12b2lkIDA7dmFyIEk9e2luaXQ6ZnVuY3Rpb24odCl7dmFyIGU9dDtJLmRvY3VtZW50PWUuZG9jdW1lbnQsSS5Eb2N1bWVudEZyYWdtZW50PWUuRG9jdW1lbnRGcmFnbWVudHx8eixJLlNWR0VsZW1lbnQ9ZS5TVkdFbGVtZW50fHx6LEkuU1ZHU1ZHRWxlbWVudD1lLlNWR1NWR0VsZW1lbnR8fHosSS5TVkdFbGVtZW50SW5zdGFuY2U9ZS5TVkdFbGVtZW50SW5zdGFuY2V8fHosSS5FbGVtZW50PWUuRWxlbWVudHx8eixJLkhUTUxFbGVtZW50PWUuSFRNTEVsZW1lbnR8fEkuRWxlbWVudCxJLkV2ZW50PWUuRXZlbnQsSS5Ub3VjaD1lLlRvdWNofHx6LEkuUG9pbnRlckV2ZW50PWUuUG9pbnRlckV2ZW50fHxlLk1TUG9pbnRlckV2ZW50fSxkb2N1bWVudDpudWxsLERvY3VtZW50RnJhZ21lbnQ6bnVsbCxTVkdFbGVtZW50Om51bGwsU1ZHU1ZHRWxlbWVudDpudWxsLFNWR0VsZW1lbnRJbnN0YW5jZTpudWxsLEVsZW1lbnQ6bnVsbCxIVE1MRWxlbWVudDpudWxsLEV2ZW50Om51bGwsVG91Y2g6bnVsbCxQb2ludGVyRXZlbnQ6bnVsbH07ZnVuY3Rpb24geigpe312YXIgQT1JO0QuZGVmYXVsdD1BO3ZhciBDPXt9O2Z1bmN0aW9uIFcodCl7cmV0dXJuKFc9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEMuZGVmYXVsdD12b2lkIDA7dmFyIFI9TihEKSxGPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PVcodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9WSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh3KSxYPU4oTyk7ZnVuY3Rpb24gWSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIFk9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBOKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX12YXIgTD17aW5pdDpmdW5jdGlvbih0KXt2YXIgZT1SLmRlZmF1bHQuRWxlbWVudCxuPVguZGVmYXVsdC53aW5kb3cubmF2aWdhdG9yO0wuc3VwcG9ydHNUb3VjaD1cIm9udG91Y2hzdGFydFwiaW4gdHx8Ri5mdW5jKHQuRG9jdW1lbnRUb3VjaCkmJlIuZGVmYXVsdC5kb2N1bWVudCBpbnN0YW5jZW9mIHQuRG9jdW1lbnRUb3VjaCxMLnN1cHBvcnRzUG9pbnRlckV2ZW50PSExIT09bi5wb2ludGVyRW5hYmxlZCYmISFSLmRlZmF1bHQuUG9pbnRlckV2ZW50LEwuaXNJT1M9L2lQKGhvbmV8b2R8YWQpLy50ZXN0KG4ucGxhdGZvcm0pLEwuaXNJT1M3PS9pUChob25lfG9kfGFkKS8udGVzdChuLnBsYXRmb3JtKSYmL09TIDdbXlxcZF0vLnRlc3Qobi5hcHBWZXJzaW9uKSxMLmlzSWU5PS9NU0lFIDkvLnRlc3Qobi51c2VyQWdlbnQpLEwuaXNPcGVyYU1vYmlsZT1cIk9wZXJhXCI9PT1uLmFwcE5hbWUmJkwuc3VwcG9ydHNUb3VjaCYmL1ByZXN0by8udGVzdChuLnVzZXJBZ2VudCksTC5wcmVmaXhlZE1hdGNoZXNTZWxlY3Rvcj1cIm1hdGNoZXNcImluIGUucHJvdG90eXBlP1wibWF0Y2hlc1wiOlwid2Via2l0TWF0Y2hlc1NlbGVjdG9yXCJpbiBlLnByb3RvdHlwZT9cIndlYmtpdE1hdGNoZXNTZWxlY3RvclwiOlwibW96TWF0Y2hlc1NlbGVjdG9yXCJpbiBlLnByb3RvdHlwZT9cIm1vek1hdGNoZXNTZWxlY3RvclwiOlwib01hdGNoZXNTZWxlY3RvclwiaW4gZS5wcm90b3R5cGU/XCJvTWF0Y2hlc1NlbGVjdG9yXCI6XCJtc01hdGNoZXNTZWxlY3RvclwiLEwucEV2ZW50VHlwZXM9TC5zdXBwb3J0c1BvaW50ZXJFdmVudD9SLmRlZmF1bHQuUG9pbnRlckV2ZW50PT09dC5NU1BvaW50ZXJFdmVudD97dXA6XCJNU1BvaW50ZXJVcFwiLGRvd246XCJNU1BvaW50ZXJEb3duXCIsb3ZlcjpcIm1vdXNlb3ZlclwiLG91dDpcIm1vdXNlb3V0XCIsbW92ZTpcIk1TUG9pbnRlck1vdmVcIixjYW5jZWw6XCJNU1BvaW50ZXJDYW5jZWxcIn06e3VwOlwicG9pbnRlcnVwXCIsZG93bjpcInBvaW50ZXJkb3duXCIsb3ZlcjpcInBvaW50ZXJvdmVyXCIsb3V0OlwicG9pbnRlcm91dFwiLG1vdmU6XCJwb2ludGVybW92ZVwiLGNhbmNlbDpcInBvaW50ZXJjYW5jZWxcIn06bnVsbCxMLndoZWVsRXZlbnQ9XCJvbm1vdXNld2hlZWxcImluIFIuZGVmYXVsdC5kb2N1bWVudD9cIm1vdXNld2hlZWxcIjpcIndoZWVsXCJ9LHN1cHBvcnRzVG91Y2g6bnVsbCxzdXBwb3J0c1BvaW50ZXJFdmVudDpudWxsLGlzSU9TNzpudWxsLGlzSU9TOm51bGwsaXNJZTk6bnVsbCxpc09wZXJhTW9iaWxlOm51bGwscHJlZml4ZWRNYXRjaGVzU2VsZWN0b3I6bnVsbCxwRXZlbnRUeXBlczpudWxsLHdoZWVsRXZlbnQ6bnVsbH07dmFyIEI9TDtDLmRlZmF1bHQ9Qjt2YXIgVj17fTtmdW5jdGlvbiBxKHQpe3JldHVybihxPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoVixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxWLmRlZmF1bHQ9ZnVuY3Rpb24gdChlKXt2YXIgbj17fTtmb3IodmFyIHIgaW4gZSl7dmFyIG89ZVtyXTtHLnBsYWluT2JqZWN0KG8pP25bcl09dChvKTpHLmFycmF5KG8pP25bcl09VS5mcm9tKG8pOm5bcl09b31yZXR1cm4gbn07dmFyIFU9SyhTKSxHPUsodyk7ZnVuY3Rpb24gSCgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIEg9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBLKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PXEodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9SCgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufXZhciAkPXt9O2Z1bmN0aW9uIFoodCl7cmV0dXJuKFo9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLCQubm9kZUNvbnRhaW5zPWZ1bmN0aW9uKHQsZSl7Zm9yKDtlOyl7aWYoZT09PXQpcmV0dXJuITA7ZT1lLnBhcmVudE5vZGV9cmV0dXJuITF9LCQuY2xvc2VzdD1mdW5jdGlvbih0LGUpe2Zvcig7dHQuZWxlbWVudCh0KTspe2lmKGF0KHQsZSkpcmV0dXJuIHQ7dD1pdCh0KX1yZXR1cm4gbnVsbH0sJC5wYXJlbnROb2RlPWl0LCQubWF0Y2hlc1NlbGVjdG9yPWF0LCQuaW5kZXhPZkRlZXBlc3RFbGVtZW50PWZ1bmN0aW9uKHQpe3ZhciBlLG4scj1bXSxvPXRbMF0saT1vPzA6LTE7Zm9yKGU9MTtlPHQubGVuZ3RoO2UrKyl7dmFyIGE9dFtlXTtpZihhJiZhIT09bylpZihvKXtpZihhLnBhcmVudE5vZGUhPT1hLm93bmVyRG9jdW1lbnQpaWYoby5wYXJlbnROb2RlIT09YS5vd25lckRvY3VtZW50KWlmKGEucGFyZW50Tm9kZSE9PW8ucGFyZW50Tm9kZSl7aWYoIXIubGVuZ3RoKWZvcih2YXIgdT1vLHM9dm9pZCAwOyhzPXV0KHUpKSYmcyE9PXUub3duZXJEb2N1bWVudDspci51bnNoaWZ0KHUpLHU9czt2YXIgbD12b2lkIDA7aWYobyBpbnN0YW5jZW9mIFEuZGVmYXVsdC5IVE1MRWxlbWVudCYmYSBpbnN0YW5jZW9mIFEuZGVmYXVsdC5TVkdFbGVtZW50JiYhKGEgaW5zdGFuY2VvZiBRLmRlZmF1bHQuU1ZHU1ZHRWxlbWVudCkpe2lmKGE9PT1vLnBhcmVudE5vZGUpY29udGludWU7bD1hLm93bmVyU1ZHRWxlbWVudH1lbHNlIGw9YTtmb3IodmFyIGM9W107bC5wYXJlbnROb2RlIT09bC5vd25lckRvY3VtZW50OyljLnVuc2hpZnQobCksbD11dChsKTtmb3Iobj0wO2Nbbl0mJmNbbl09PT1yW25dOyluKys7Zm9yKHZhciBmPVtjW24tMV0sY1tuXSxyW25dXSxwPWZbMF0ubGFzdENoaWxkO3A7KXtpZihwPT09ZlsxXSl7bz1hLGk9ZSxyPWM7YnJlYWt9aWYocD09PWZbMl0pYnJlYWs7cD1wLnByZXZpb3VzU2libGluZ319ZWxzZXt2YXIgZD1wYXJzZUludCgoMCxldC5nZXRXaW5kb3cpKG8pLmdldENvbXB1dGVkU3R5bGUobykuekluZGV4LDEwKXx8MCx2PXBhcnNlSW50KCgwLGV0LmdldFdpbmRvdykoYSkuZ2V0Q29tcHV0ZWRTdHlsZShhKS56SW5kZXgsMTApfHwwO2Q8PXYmJihvPWEsaT1lKX1lbHNlIG89YSxpPWV9ZWxzZSBvPWEsaT1lfXJldHVybiBpfSwkLm1hdGNoZXNVcFRvPWZ1bmN0aW9uKHQsZSxuKXtmb3IoO3R0LmVsZW1lbnQodCk7KXtpZihhdCh0LGUpKXJldHVybiEwO2lmKCh0PWl0KHQpKT09PW4pcmV0dXJuIGF0KHQsZSl9cmV0dXJuITF9LCQuZ2V0QWN0dWFsRWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFEuZGVmYXVsdC5TVkdFbGVtZW50SW5zdGFuY2U/dC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDp0fSwkLmdldFNjcm9sbFhZPXN0LCQuZ2V0RWxlbWVudENsaWVudFJlY3Q9bHQsJC5nZXRFbGVtZW50UmVjdD1mdW5jdGlvbih0KXt2YXIgZT1sdCh0KTtpZighSi5kZWZhdWx0LmlzSU9TNyYmZSl7dmFyIG49c3QoZXQuZGVmYXVsdC5nZXRXaW5kb3codCkpO2UubGVmdCs9bi54LGUucmlnaHQrPW4ueCxlLnRvcCs9bi55LGUuYm90dG9tKz1uLnl9cmV0dXJuIGV9LCQuZ2V0UGF0aD1mdW5jdGlvbih0KXt2YXIgZT1bXTtmb3IoO3Q7KWUucHVzaCh0KSx0PWl0KHQpO3JldHVybiBlfSwkLnRyeVNlbGVjdG9yPWZ1bmN0aW9uKHQpe3JldHVybiEhdHQuc3RyaW5nKHQpJiYoUS5kZWZhdWx0LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCksITApfTt2YXIgSj1vdChDKSxRPW90KEQpLHR0PXJ0KHcpLGV0PXJ0KE8pO2Z1bmN0aW9uIG50KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBydCh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1aKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPW50KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59ZnVuY3Rpb24gb3QodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIGl0KHQpe3ZhciBlPXQucGFyZW50Tm9kZTtpZih0dC5kb2NGcmFnKGUpKXtmb3IoOyhlPWUuaG9zdCkmJnR0LmRvY0ZyYWcoZSk7KTtyZXR1cm4gZX1yZXR1cm4gZX1mdW5jdGlvbiBhdCh0LGUpe3JldHVybiBldC5kZWZhdWx0LndpbmRvdyE9PWV0LmRlZmF1bHQucmVhbFdpbmRvdyYmKGU9ZS5yZXBsYWNlKC9cXC9kZWVwXFwvL2csXCIgXCIpKSx0W0ouZGVmYXVsdC5wcmVmaXhlZE1hdGNoZXNTZWxlY3Rvcl0oZSl9dmFyIHV0PWZ1bmN0aW9uKHQpe3JldHVybiB0LnBhcmVudE5vZGU/dC5wYXJlbnROb2RlOnQuaG9zdH07ZnVuY3Rpb24gc3QodCl7cmV0dXJue3g6KHQ9dHx8ZXQuZGVmYXVsdC53aW5kb3cpLnNjcm9sbFh8fHQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQseTp0LnNjcm9sbFl8fHQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcH19ZnVuY3Rpb24gbHQodCl7dmFyIGU9dCBpbnN0YW5jZW9mIFEuZGVmYXVsdC5TVkdFbGVtZW50P3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6dC5nZXRDbGllbnRSZWN0cygpWzBdO3JldHVybiBlJiZ7bGVmdDplLmxlZnQscmlnaHQ6ZS5yaWdodCx0b3A6ZS50b3AsYm90dG9tOmUuYm90dG9tLHdpZHRoOmUud2lkdGh8fGUucmlnaHQtZS5sZWZ0LGhlaWdodDplLmhlaWdodHx8ZS5ib3R0b20tZS50b3B9fXZhciBjdD17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoY3QsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksY3QuZGVmYXVsdD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKXRbbl09ZVtuXTtyZXR1cm4gdH07dmFyIGZ0PXt9O2Z1bmN0aW9uIHB0KHQpe3JldHVybihwdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGZ0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGZ0LmRlZmF1bHQ9ZnVuY3Rpb24gbihlLHIsbyl7bz1vfHx7fTt5dC5zdHJpbmcoZSkmJi0xIT09ZS5zZWFyY2goXCIgXCIpJiYoZT1ndChlKSk7aWYoeXQuYXJyYXkoZSkpcmV0dXJuIGUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuKDAsdnQuZGVmYXVsdCkodCxuKGUscixvKSl9LG8pO3l0Lm9iamVjdChlKSYmKHI9ZSxlPVwiXCIpO2lmKHl0LmZ1bmMocikpb1tlXT1vW2VdfHxbXSxvW2VdLnB1c2gocik7ZWxzZSBpZih5dC5hcnJheShyKSlmb3IodmFyIHQ9MDt0PHIubGVuZ3RoO3QrKyl7dmFyIGk9clt0XTtuKGUsaSxvKX1lbHNlIGlmKHl0Lm9iamVjdChyKSlmb3IodmFyIGEgaW4gcil7dmFyIHU9Z3QoYSkubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiXCIuY29uY2F0KGUpLmNvbmNhdCh0KX0pO24odSxyW2FdLG8pfXJldHVybiBvfTt2YXIgZHQsdnQ9KGR0PWN0KSYmZHQuX19lc01vZHVsZT9kdDp7ZGVmYXVsdDpkdH0seXQ9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09cHQodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9aHQoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0odyk7ZnVuY3Rpb24gaHQoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBodD1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIGd0KHQpe3JldHVybiB0LnRyaW0oKS5zcGxpdCgvICsvKX12YXIgYnQ9e307ZnVuY3Rpb24gbXQodCl7cmV0dXJuKG10PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoYnQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksYnQuZGVmYXVsdD12b2lkIDA7dmFyIE90PWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PW10KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPXh0KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KFMpLHd0PVB0KGN0KSxfdD1QdChmdCk7ZnVuY3Rpb24gUHQodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIHh0KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4geHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBTdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24ganQodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fWZ1bmN0aW9uIE10KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07aWYodC5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQpYnJlYWs7cih0KX19dmFyIGt0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLGp0KHRoaXMsXCJvcHRpb25zXCIsdm9pZCAwKSxqdCh0aGlzLFwidHlwZXNcIix7fSksanQodGhpcyxcInByb3BhZ2F0aW9uU3RvcHBlZFwiLCExKSxqdCh0aGlzLFwiaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCIsITEpLGp0KHRoaXMsXCJnbG9iYWxcIix2b2lkIDApLHRoaXMub3B0aW9ucz0oMCx3dC5kZWZhdWx0KSh7fSx0fHx7fSl9dmFyIHQsbixyO3JldHVybiB0PWUsKG49W3trZXk6XCJmaXJlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLmdsb2JhbDsoZT10aGlzLnR5cGVzW3QudHlwZV0pJiZNdCh0LGUpLCF0LnByb3BhZ2F0aW9uU3RvcHBlZCYmbiYmKGU9blt0LnR5cGVdKSYmTXQodCxlKX19LHtrZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49KDAsX3QuZGVmYXVsdCkodCxlKTtmb3IodCBpbiBuKXRoaXMudHlwZXNbdF09T3QubWVyZ2UodGhpcy50eXBlc1t0XXx8W10sblt0XSl9fSx7a2V5Olwib2ZmXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgbj0oMCxfdC5kZWZhdWx0KSh0LGUpO2Zvcih0IGluIG4pe3ZhciByPXRoaXMudHlwZXNbdF07aWYociYmci5sZW5ndGgpZm9yKHZhciBvPTA7bzxuW3RdLmxlbmd0aDtvKyspe3ZhciBpPW5bdF1bb10sYT1yLmluZGV4T2YoaSk7LTEhPT1hJiZyLnNwbGljZShhLDEpfX19fSx7a2V5OlwiZ2V0UmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9fV0pJiZTdCh0LnByb3RvdHlwZSxuKSxyJiZTdCh0LHIpLGV9KCk7YnQuZGVmYXVsdD1rdDt2YXIgRXQ9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KEV0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEV0LmRlZmF1bHQ9dm9pZCAwO0V0LmRlZmF1bHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5zcXJ0KHQqdCtlKmUpfTt2YXIgVHQ9e307ZnVuY3Rpb24gRHQodCxlKXtmb3IodmFyIG4gaW4gZSl7dmFyIHI9RHQucHJlZml4ZWRQcm9wUkVzLG89ITE7Zm9yKHZhciBpIGluIHIpaWYoMD09PW4uaW5kZXhPZihpKSYmcltpXS50ZXN0KG4pKXtvPSEwO2JyZWFrfW98fFwiZnVuY3Rpb25cIj09dHlwZW9mIGVbbl18fCh0W25dPWVbbl0pfXJldHVybiB0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShUdCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxUdC5kZWZhdWx0PXZvaWQgMCxEdC5wcmVmaXhlZFByb3BSRXM9e3dlYmtpdDovKE1vdmVtZW50W1hZXXxSYWRpdXNbWFldfFJvdGF0aW9uQW5nbGV8Rm9yY2UpJC8sbW96Oi8oUHJlc3N1cmUpJC99O3ZhciBJdD1EdDtUdC5kZWZhdWx0PUl0O3ZhciB6dD17fTtmdW5jdGlvbiBBdCh0KXtyZXR1cm4oQXQ9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh6dCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx6dC5jb3B5Q29vcmRzPWZ1bmN0aW9uKHQsZSl7dC5wYWdlPXQucGFnZXx8e30sdC5wYWdlLng9ZS5wYWdlLngsdC5wYWdlLnk9ZS5wYWdlLnksdC5jbGllbnQ9dC5jbGllbnR8fHt9LHQuY2xpZW50Lng9ZS5jbGllbnQueCx0LmNsaWVudC55PWUuY2xpZW50LnksdC50aW1lU3RhbXA9ZS50aW1lU3RhbXB9LHp0LnNldENvb3JkRGVsdGFzPWZ1bmN0aW9uKHQsZSxuKXt0LnBhZ2UueD1uLnBhZ2UueC1lLnBhZ2UueCx0LnBhZ2UueT1uLnBhZ2UueS1lLnBhZ2UueSx0LmNsaWVudC54PW4uY2xpZW50LngtZS5jbGllbnQueCx0LmNsaWVudC55PW4uY2xpZW50LnktZS5jbGllbnQueSx0LnRpbWVTdGFtcD1uLnRpbWVTdGFtcC1lLnRpbWVTdGFtcH0senQuc2V0Q29vcmRWZWxvY2l0eT1mdW5jdGlvbih0LGUpe3ZhciBuPU1hdGgubWF4KGUudGltZVN0YW1wLzFlMywuMDAxKTt0LnBhZ2UueD1lLnBhZ2UueC9uLHQucGFnZS55PWUucGFnZS55L24sdC5jbGllbnQueD1lLmNsaWVudC54L24sdC5jbGllbnQueT1lLmNsaWVudC55L24sdC50aW1lU3RhbXA9bn0senQuc2V0WmVyb0Nvb3Jkcz1mdW5jdGlvbih0KXt0LnBhZ2UueD0wLHQucGFnZS55PTAsdC5jbGllbnQueD0wLHQuY2xpZW50Lnk9MH0senQuaXNOYXRpdmVQb2ludGVyPVZ0LHp0LmdldFhZPXF0LHp0LmdldFBhZ2VYWT1VdCx6dC5nZXRDbGllbnRYWT1HdCx6dC5nZXRQb2ludGVySWQ9ZnVuY3Rpb24odCl7cmV0dXJuIFh0Lm51bWJlcih0LnBvaW50ZXJJZCk/dC5wb2ludGVySWQ6dC5pZGVudGlmaWVyfSx6dC5zZXRDb29yZHM9ZnVuY3Rpb24odCxlLG4pe3ZhciByPTE8ZS5sZW5ndGg/S3QoZSk6ZVswXSxvPXt9O1V0KHIsbyksdC5wYWdlLng9by54LHQucGFnZS55PW8ueSxHdChyLG8pLHQuY2xpZW50Lng9by54LHQuY2xpZW50Lnk9by55LHQudGltZVN0YW1wPW59LHp0LmdldFRvdWNoUGFpcj1IdCx6dC5wb2ludGVyQXZlcmFnZT1LdCx6dC50b3VjaEJCb3g9ZnVuY3Rpb24odCl7aWYoISh0Lmxlbmd0aHx8dC50b3VjaGVzJiYxPHQudG91Y2hlcy5sZW5ndGgpKXJldHVybiBudWxsO3ZhciBlPUh0KHQpLG49TWF0aC5taW4oZVswXS5wYWdlWCxlWzFdLnBhZ2VYKSxyPU1hdGgubWluKGVbMF0ucGFnZVksZVsxXS5wYWdlWSksbz1NYXRoLm1heChlWzBdLnBhZ2VYLGVbMV0ucGFnZVgpLGk9TWF0aC5tYXgoZVswXS5wYWdlWSxlWzFdLnBhZ2VZKTtyZXR1cm57eDpuLHk6cixsZWZ0Om4sdG9wOnIscmlnaHQ6byxib3R0b206aSx3aWR0aDpvLW4saGVpZ2h0Omktcn19LHp0LnRvdWNoRGlzdGFuY2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1lK1wiWFwiLHI9ZStcIllcIixvPUh0KHQpLGk9b1swXVtuXS1vWzFdW25dLGE9b1swXVtyXS1vWzFdW3JdO3JldHVybigwLEZ0LmRlZmF1bHQpKGksYSl9LHp0LnRvdWNoQW5nbGU9ZnVuY3Rpb24odCxlKXt2YXIgbj1lK1wiWFwiLHI9ZStcIllcIixvPUh0KHQpLGk9b1sxXVtuXS1vWzBdW25dLGE9b1sxXVtyXS1vWzBdW3JdO3JldHVybiAxODAqTWF0aC5hdGFuMihhLGkpL01hdGguUEl9LHp0LmdldFBvaW50ZXJUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiBYdC5zdHJpbmcodC5wb2ludGVyVHlwZSk/dC5wb2ludGVyVHlwZTpYdC5udW1iZXIodC5wb2ludGVyVHlwZSk/W3ZvaWQgMCx2b2lkIDAsXCJ0b3VjaFwiLFwicGVuXCIsXCJtb3VzZVwiXVt0LnBvaW50ZXJUeXBlXTovdG91Y2gvLnRlc3QodC50eXBlKXx8dCBpbnN0YW5jZW9mIFd0LmRlZmF1bHQuVG91Y2g/XCJ0b3VjaFwiOlwibW91c2VcIn0senQuZ2V0RXZlbnRUYXJnZXRzPWZ1bmN0aW9uKHQpe3ZhciBlPVh0LmZ1bmModC5jb21wb3NlZFBhdGgpP3QuY29tcG9zZWRQYXRoKCk6dC5wYXRoO3JldHVybltSdC5nZXRBY3R1YWxFbGVtZW50KGU/ZVswXTp0LnRhcmdldCksUnQuZ2V0QWN0dWFsRWxlbWVudCh0LmN1cnJlbnRUYXJnZXQpXX0senQubmV3Q29vcmRzPWZ1bmN0aW9uKCl7cmV0dXJue3BhZ2U6e3g6MCx5OjB9LGNsaWVudDp7eDowLHk6MH0sdGltZVN0YW1wOjB9fSx6dC5jb29yZHNUb0V2ZW50PWZ1bmN0aW9uKHQpe3JldHVybntjb29yZHM6dCxnZXQgcGFnZSgpe3JldHVybiB0aGlzLmNvb3Jkcy5wYWdlfSxnZXQgY2xpZW50KCl7cmV0dXJuIHRoaXMuY29vcmRzLmNsaWVudH0sZ2V0IHRpbWVTdGFtcCgpe3JldHVybiB0aGlzLmNvb3Jkcy50aW1lU3RhbXB9LGdldCBwYWdlWCgpe3JldHVybiB0aGlzLmNvb3Jkcy5wYWdlLnh9LGdldCBwYWdlWSgpe3JldHVybiB0aGlzLmNvb3Jkcy5wYWdlLnl9LGdldCBjbGllbnRYKCl7cmV0dXJuIHRoaXMuY29vcmRzLmNsaWVudC54fSxnZXQgY2xpZW50WSgpe3JldHVybiB0aGlzLmNvb3Jkcy5jbGllbnQueX0sZ2V0IHBvaW50ZXJJZCgpe3JldHVybiB0aGlzLmNvb3Jkcy5wb2ludGVySWR9LGdldCB0YXJnZXQoKXtyZXR1cm4gdGhpcy5jb29yZHMudGFyZ2V0fSxnZXQgdHlwZSgpe3JldHVybiB0aGlzLmNvb3Jkcy50eXBlfSxnZXQgcG9pbnRlclR5cGUoKXtyZXR1cm4gdGhpcy5jb29yZHMucG9pbnRlclR5cGV9LGdldCBidXR0b25zKCl7cmV0dXJuIHRoaXMuY29vcmRzLmJ1dHRvbnN9LHByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7fX19LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh6dCxcInBvaW50ZXJFeHRlbmRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gWXQuZGVmYXVsdH19KTt2YXIgQ3Q9QnQoQyksV3Q9QnQoRCksUnQ9THQoJCksRnQ9QnQoRXQpLFh0PUx0KHcpLFl0PUJ0KFR0KTtmdW5jdGlvbiBOdCgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIE50PWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gTHQodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09QXQodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9TnQoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn1mdW5jdGlvbiBCdCh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gVnQodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBXdC5kZWZhdWx0LkV2ZW50fHx0IGluc3RhbmNlb2YgV3QuZGVmYXVsdC5Ub3VjaH1mdW5jdGlvbiBxdCh0LGUsbil7cmV0dXJuKG49bnx8e30pLng9ZVsodD10fHxcInBhZ2VcIikrXCJYXCJdLG4ueT1lW3QrXCJZXCJdLG59ZnVuY3Rpb24gVXQodCxlKXtyZXR1cm4gZT1lfHx7eDowLHk6MH0sQ3QuZGVmYXVsdC5pc09wZXJhTW9iaWxlJiZWdCh0KT8ocXQoXCJzY3JlZW5cIix0LGUpLGUueCs9d2luZG93LnNjcm9sbFgsZS55Kz13aW5kb3cuc2Nyb2xsWSk6cXQoXCJwYWdlXCIsdCxlKSxlfWZ1bmN0aW9uIEd0KHQsZSl7cmV0dXJuIGU9ZXx8e30sQ3QuZGVmYXVsdC5pc09wZXJhTW9iaWxlJiZWdCh0KT9xdChcInNjcmVlblwiLHQsZSk6cXQoXCJjbGllbnRcIix0LGUpLGV9ZnVuY3Rpb24gSHQodCl7dmFyIGU9W107cmV0dXJuIFh0LmFycmF5KHQpPyhlWzBdPXRbMF0sZVsxXT10WzFdKTpcInRvdWNoZW5kXCI9PT10LnR5cGU/MT09PXQudG91Y2hlcy5sZW5ndGg/KGVbMF09dC50b3VjaGVzWzBdLGVbMV09dC5jaGFuZ2VkVG91Y2hlc1swXSk6MD09PXQudG91Y2hlcy5sZW5ndGgmJihlWzBdPXQuY2hhbmdlZFRvdWNoZXNbMF0sZVsxXT10LmNoYW5nZWRUb3VjaGVzWzFdKTooZVswXT10LnRvdWNoZXNbMF0sZVsxXT10LnRvdWNoZXNbMV0pLGV9ZnVuY3Rpb24gS3QodCl7Zm9yKHZhciBlPXtwYWdlWDowLHBhZ2VZOjAsY2xpZW50WDowLGNsaWVudFk6MCxzY3JlZW5YOjAsc2NyZWVuWTowfSxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07Zm9yKHZhciBvIGluIGUpZVtvXSs9cltvXX1mb3IodmFyIGkgaW4gZSllW2ldLz10Lmxlbmd0aDtyZXR1cm4gZX12YXIgJHQ9e307ZnVuY3Rpb24gWnQodCl7cmV0dXJuKFp0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoJHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksJHQuZ2V0U3RyaW5nT3B0aW9uUmVzdWx0PW5lLCR0LnJlc29sdmVSZWN0TGlrZT1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz10O3RlLnN0cmluZyhvKT9vPW5lKG8sZSxuKTp0ZS5mdW5jKG8pJiYobz1vLmFwcGx5KHZvaWQgMCxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSl7Zm9yKHZhciBlPTAsbj1uZXcgQXJyYXkodC5sZW5ndGgpO2U8dC5sZW5ndGg7ZSsrKW5bZV09dFtlXTtyZXR1cm4gbn19KHQpfHxmdW5jdGlvbih0KXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKXJldHVybiBBcnJheS5mcm9tKHQpfSh0KXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9KHIpKSk7dGUuZWxlbWVudChvKSYmKG89KDAsJC5nZXRFbGVtZW50UmVjdCkobykpO3JldHVybiBvfSwkdC5yZWN0VG9YWT1mdW5jdGlvbih0KXtyZXR1cm4gdCYme3g6XCJ4XCJpbiB0P3QueDp0LmxlZnQseTpcInlcImluIHQ/dC55OnQudG9wfX0sJHQueHl3aFRvVGxicj1mdW5jdGlvbih0KXshdHx8XCJsZWZ0XCJpbiB0JiZcInRvcFwiaW4gdHx8KCh0PSgwLFF0LmRlZmF1bHQpKHt9LHQpKS5sZWZ0PXQueHx8MCx0LnRvcD10Lnl8fDAsdC5yaWdodD10LnJpZ2h0fHx0LmxlZnQrdC53aWR0aCx0LmJvdHRvbT10LmJvdHRvbXx8dC50b3ArdC5oZWlnaHQpO3JldHVybiB0fSwkdC50bGJyVG9YeXdoPWZ1bmN0aW9uKHQpeyF0fHxcInhcImluIHQmJlwieVwiaW4gdHx8KCh0PSgwLFF0LmRlZmF1bHQpKHt9LHQpKS54PXQubGVmdHx8MCx0Lnk9dC50b3B8fDAsdC53aWR0aD10LndpZHRofHx0LnJpZ2h0fHwwLXQueCx0LmhlaWdodD10LmhlaWdodHx8dC5ib3R0b218fDAtdC55KTtyZXR1cm4gdH0sJHQuYWRkRWRnZXM9ZnVuY3Rpb24odCxlLG4pe3QubGVmdCYmKGUubGVmdCs9bi54KTt0LnJpZ2h0JiYoZS5yaWdodCs9bi54KTt0LnRvcCYmKGUudG9wKz1uLnkpO3QuYm90dG9tJiYoZS5ib3R0b20rPW4ueSk7ZS53aWR0aD1lLnJpZ2h0LWUubGVmdCxlLmhlaWdodD1lLmJvdHRvbS1lLnRvcH07dmFyIEp0LFF0PShKdD1jdCkmJkp0Ll9fZXNNb2R1bGU/SnQ6e2RlZmF1bHQ6SnR9LHRlPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PVp0KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPWVlKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHcpO2Z1bmN0aW9uIGVlKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gZWU9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBuZSh0LGUsbil7cmV0dXJuXCJwYXJlbnRcIj09PXQ/KDAsJC5wYXJlbnROb2RlKShuKTpcInNlbGZcIj09PXQ/ZS5nZXRSZWN0KG4pOigwLCQuY2xvc2VzdCkobix0KX12YXIgcmU9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHJlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHJlLmRlZmF1bHQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQub3B0aW9uc1tuXSxvPXImJnIub3JpZ2lufHx0Lm9wdGlvbnMub3JpZ2luLGk9KDAsJHQucmVzb2x2ZVJlY3RMaWtlKShvLHQsZSxbdCYmZV0pO3JldHVybigwLCR0LnJlY3RUb1hZKShpKXx8e3g6MCx5OjB9fTt2YXIgb2U9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KG9lLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG9lLmRlZmF1bHQ9dm9pZCAwO3ZhciBpZSxhZSx1ZT0wO3ZhciBzZT17cmVxdWVzdDpmdW5jdGlvbih0KXtyZXR1cm4gaWUodCl9LGNhbmNlbDpmdW5jdGlvbih0KXtyZXR1cm4gYWUodCl9LGluaXQ6ZnVuY3Rpb24odCl7aWYoaWU9dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsYWU9dC5jYW5jZWxBbmltYXRpb25GcmFtZSwhaWUpZm9yKHZhciBlPVtcIm1zXCIsXCJtb3pcIixcIndlYmtpdFwiLFwib1wiXSxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07aWU9dFtcIlwiLmNvbmNhdChyLFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpXSxhZT10W1wiXCIuY29uY2F0KHIsXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiKV18fHRbXCJcIi5jb25jYXQocixcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiKV19aWV8fChpZT1mdW5jdGlvbih0KXt2YXIgZT1EYXRlLm5vdygpLG49TWF0aC5tYXgoMCwxNi0oZS11ZSkpLHI9c2V0VGltZW91dChmdW5jdGlvbigpe3QoZStuKX0sbik7cmV0dXJuIHVlPWUrbixyfSxhZT1mdW5jdGlvbih0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KHQpfSl9fTtvZS5kZWZhdWx0PXNlO3ZhciBsZT17fTtmdW5jdGlvbiBjZSh0KXtyZXR1cm4oY2U9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShsZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxsZS53YXJuT25jZT1mdW5jdGlvbih0LGUpe3ZhciBuPSExO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBufHwoaGUuZGVmYXVsdC53aW5kb3cuY29uc29sZS53YXJuKGUpLG49ITApLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0sbGUuY29weUFjdGlvbj1mdW5jdGlvbih0LGUpe3JldHVybiB0Lm5hbWU9ZS5uYW1lLHQuYXhpcz1lLmF4aXMsdC5lZGdlcz1lLmVkZ2VzLHR9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsZSxcIndpblwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBoZS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsZSxcImJyb3dzZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZ2UuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJjbG9uZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBiZS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsZSxcImV4dGVuZFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBtZS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsZSxcImdldE9yaWdpblhZXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE9lLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGxlLFwiaHlwb3RcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gd2UuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJub3JtYWxpemVMaXN0ZW5lcnNcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gX2UuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobGUsXCJyYWZcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUGUuZGVmYXVsdH19KSxsZS5yZWN0PWxlLnBvaW50ZXI9bGUuaXM9bGUuZG9tPWxlLmFycj12b2lkIDA7dmFyIGZlPWplKFMpO2xlLmFycj1mZTt2YXIgcGU9amUoJCk7bGUuZG9tPXBlO3ZhciBkZT1qZSh3KTtsZS5pcz1kZTt2YXIgdmU9amUoenQpO2xlLnBvaW50ZXI9dmU7dmFyIHllPWplKCR0KTtsZS5yZWN0PXllO3ZhciBoZT14ZShPKSxnZT14ZShDKSxiZT14ZShWKSxtZT14ZShjdCksT2U9eGUocmUpLHdlPXhlKEV0KSxfZT14ZShmdCksUGU9eGUob2UpO2Z1bmN0aW9uIHhlKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBTZSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIFNlPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gamUodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09Y2UodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9U2UoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn12YXIgTWU9e307ZnVuY3Rpb24ga2UodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIEVlKHQsZSxuKXtyZXR1cm4gZSYma2UodC5wcm90b3R5cGUsZSksbiYma2UodCxuKSx0fWZ1bmN0aW9uIFRlKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH1PYmplY3QuZGVmaW5lUHJvcGVydHkoTWUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksTWUuZGVmYXVsdD1NZS5CYXNlRXZlbnQ9dm9pZCAwO3ZhciBEZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSxUZSh0aGlzLFwidHlwZVwiLHZvaWQgMCksVGUodGhpcyxcInRhcmdldFwiLHZvaWQgMCksVGUodGhpcyxcImN1cnJlbnRUYXJnZXRcIix2b2lkIDApLFRlKHRoaXMsXCJpbnRlcmFjdGFibGVcIix2b2lkIDApLFRlKHRoaXMsXCJfaW50ZXJhY3Rpb25cIix2b2lkIDApLFRlKHRoaXMsXCJ0aW1lU3RhbXBcIix2b2lkIDApLFRlKHRoaXMsXCJpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcIiwhMSksVGUodGhpcyxcInByb3BhZ2F0aW9uU3RvcHBlZFwiLCExKSx0aGlzLl9pbnRlcmFjdGlvbj10fXJldHVybiBFZShlLFt7a2V5OlwiaW50ZXJhY3Rpb25cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJhY3Rpb24uX3Byb3h5fX1dKSxFZShlLFt7a2V5OlwicHJldmVudERlZmF1bHRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJzdG9wUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX0se2tleTpcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fV0pLGV9KCksSWU9TWUuQmFzZUV2ZW50PURlO01lLmRlZmF1bHQ9SWU7dmFyIHplPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh6ZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx6ZS5kZWZhdWx0PXplLmRlZmF1bHRzPXZvaWQgMDt2YXIgQWU9e2Jhc2U6e3ByZXZlbnREZWZhdWx0OlwiYXV0b1wiLGRlbHRhU291cmNlOlwicGFnZVwifSxwZXJBY3Rpb246e2VuYWJsZWQ6ITEsb3JpZ2luOnt4OjAseTowfX0sYWN0aW9uczp7fX0sQ2U9emUuZGVmYXVsdHM9QWU7emUuZGVmYXVsdD1DZTt2YXIgV2U9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KFdlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFdlLmRlZmF1bHQ9V2UuSW50ZXJhY3RFdmVudD12b2lkIDA7dmFyIFJlPUxlKGN0KSxGZT1MZShyZSksWGU9TGUoRXQpLFllPUxlKE1lKSxOZT1MZSh6ZSk7ZnVuY3Rpb24gTGUodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIEJlKHQpe3JldHVybihCZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9ZnVuY3Rpb24gVmUodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIHFlKHQpe3JldHVybihxZT1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSkodCl9ZnVuY3Rpb24gVWUodCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9ZnVuY3Rpb24gR2UodCxlKXtyZXR1cm4oR2U9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIEhlKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgS2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBnKHQsZSxuLHIsbyxpLGEpe3ZhciB1LHMsbDshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGcpLHM9dGhpcyx1PSEobD1xZShnKS5jYWxsKHRoaXMsdCkpfHxcIm9iamVjdFwiIT09QmUobCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGw/VWUocyk6bCxIZShVZSh1KSxcInRhcmdldFwiLHZvaWQgMCksSGUoVWUodSksXCJjdXJyZW50VGFyZ2V0XCIsdm9pZCAwKSxIZShVZSh1KSxcInJlbGF0ZWRUYXJnZXRcIixudWxsKSxIZShVZSh1KSxcInNjcmVlblhcIix2b2lkIDApLEhlKFVlKHUpLFwic2NyZWVuWVwiLHZvaWQgMCksSGUoVWUodSksXCJidXR0b25cIix2b2lkIDApLEhlKFVlKHUpLFwiYnV0dG9uc1wiLHZvaWQgMCksSGUoVWUodSksXCJjdHJsS2V5XCIsdm9pZCAwKSxIZShVZSh1KSxcInNoaWZ0S2V5XCIsdm9pZCAwKSxIZShVZSh1KSxcImFsdEtleVwiLHZvaWQgMCksSGUoVWUodSksXCJtZXRhS2V5XCIsdm9pZCAwKSxIZShVZSh1KSxcInBhZ2VcIix2b2lkIDApLEhlKFVlKHUpLFwiY2xpZW50XCIsdm9pZCAwKSxIZShVZSh1KSxcImRlbHRhXCIsdm9pZCAwKSxIZShVZSh1KSxcInJlY3RcIix2b2lkIDApLEhlKFVlKHUpLFwieDBcIix2b2lkIDApLEhlKFVlKHUpLFwieTBcIix2b2lkIDApLEhlKFVlKHUpLFwidDBcIix2b2lkIDApLEhlKFVlKHUpLFwiZHRcIix2b2lkIDApLEhlKFVlKHUpLFwiZHVyYXRpb25cIix2b2lkIDApLEhlKFVlKHUpLFwiY2xpZW50WDBcIix2b2lkIDApLEhlKFVlKHUpLFwiY2xpZW50WTBcIix2b2lkIDApLEhlKFVlKHUpLFwidmVsb2NpdHlcIix2b2lkIDApLEhlKFVlKHUpLFwic3BlZWRcIix2b2lkIDApLEhlKFVlKHUpLFwic3dpcGVcIix2b2lkIDApLEhlKFVlKHUpLFwidGltZVN0YW1wXCIsdm9pZCAwKSxIZShVZSh1KSxcImRyYWdFbnRlclwiLHZvaWQgMCksSGUoVWUodSksXCJkcmFnTGVhdmVcIix2b2lkIDApLEhlKFVlKHUpLFwiYXhlc1wiLHZvaWQgMCksSGUoVWUodSksXCJwcmVFbmRcIix2b2lkIDApLG89b3x8dC5lbGVtZW50O3ZhciBjPXQuaW50ZXJhY3RhYmxlLGY9KGMmJmMub3B0aW9uc3x8TmUuZGVmYXVsdCkuZGVsdGFTb3VyY2UscD0oMCxGZS5kZWZhdWx0KShjLG8sbiksZD1cInN0YXJ0XCI9PT1yLHY9XCJlbmRcIj09PXIseT1kP1VlKHUpOnQucHJldkV2ZW50LGg9ZD90LmNvb3Jkcy5zdGFydDp2P3twYWdlOnkucGFnZSxjbGllbnQ6eS5jbGllbnQsdGltZVN0YW1wOnQuY29vcmRzLmN1ci50aW1lU3RhbXB9OnQuY29vcmRzLmN1cjtyZXR1cm4gdS5wYWdlPSgwLFJlLmRlZmF1bHQpKHt9LGgucGFnZSksdS5jbGllbnQ9KDAsUmUuZGVmYXVsdCkoe30saC5jbGllbnQpLHUucmVjdD0oMCxSZS5kZWZhdWx0KSh7fSx0LnJlY3QpLHUudGltZVN0YW1wPWgudGltZVN0YW1wLHZ8fCh1LnBhZ2UueC09cC54LHUucGFnZS55LT1wLnksdS5jbGllbnQueC09cC54LHUuY2xpZW50LnktPXAueSksdS5jdHJsS2V5PWUuY3RybEtleSx1LmFsdEtleT1lLmFsdEtleSx1LnNoaWZ0S2V5PWUuc2hpZnRLZXksdS5tZXRhS2V5PWUubWV0YUtleSx1LmJ1dHRvbj1lLmJ1dHRvbix1LmJ1dHRvbnM9ZS5idXR0b25zLHUudGFyZ2V0PW8sdS5jdXJyZW50VGFyZ2V0PW8sdS5wcmVFbmQ9aSx1LnR5cGU9YXx8bisocnx8XCJcIiksdS5pbnRlcmFjdGFibGU9Yyx1LnQwPWQ/dC5wb2ludGVyc1t0LnBvaW50ZXJzLmxlbmd0aC0xXS5kb3duVGltZTp5LnQwLHUueDA9dC5jb29yZHMuc3RhcnQucGFnZS54LXAueCx1LnkwPXQuY29vcmRzLnN0YXJ0LnBhZ2UueS1wLnksdS5jbGllbnRYMD10LmNvb3Jkcy5zdGFydC5jbGllbnQueC1wLngsdS5jbGllbnRZMD10LmNvb3Jkcy5zdGFydC5jbGllbnQueS1wLnksdS5kZWx0YT1kfHx2P3t4OjAseTowfTp7eDp1W2ZdLngteVtmXS54LHk6dVtmXS55LXlbZl0ueX0sdS5kdD10LmNvb3Jkcy5kZWx0YS50aW1lU3RhbXAsdS5kdXJhdGlvbj11LnRpbWVTdGFtcC11LnQwLHUudmVsb2NpdHk9KDAsUmUuZGVmYXVsdCkoe30sdC5jb29yZHMudmVsb2NpdHlbZl0pLHUuc3BlZWQ9KDAsWGUuZGVmYXVsdCkodS52ZWxvY2l0eS54LHUudmVsb2NpdHkueSksdS5zd2lwZT12fHxcImluZXJ0aWFzdGFydFwiPT09cj91LmdldFN3aXBlKCk6bnVsbCx1fXZhciB0LGUsbjtyZXR1cm4gZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJkdlKHQsZSl9KGcsWWVbXCJkZWZhdWx0XCJdKSx0PWcsKGU9W3trZXk6XCJnZXRTd2lwZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5faW50ZXJhY3Rpb247aWYodC5wcmV2RXZlbnQuc3BlZWQ8NjAwfHwxNTA8dGhpcy50aW1lU3RhbXAtdC5wcmV2RXZlbnQudGltZVN0YW1wKXJldHVybiBudWxsO3ZhciBlPTE4MCpNYXRoLmF0YW4yKHQucHJldkV2ZW50LnZlbG9jaXR5WSx0LnByZXZFdmVudC52ZWxvY2l0eVgpL01hdGguUEk7ZTwwJiYoZSs9MzYwKTt2YXIgbj0xMTIuNTw9ZSYmZTwyNDcuNSxyPTIwMi41PD1lJiZlPDMzNy41O3JldHVybnt1cDpyLGRvd246IXImJjIyLjU8PWUmJmU8MTU3LjUsbGVmdDpuLHJpZ2h0OiFuJiYoMjkyLjU8PWV8fGU8NjcuNSksYW5nbGU6ZSxzcGVlZDp0LnByZXZFdmVudC5zcGVlZCx2ZWxvY2l0eTp7eDp0LnByZXZFdmVudC52ZWxvY2l0eVgseTp0LnByZXZFdmVudC52ZWxvY2l0eVl9fX19LHtrZXk6XCJwcmV2ZW50RGVmYXVsdFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fSx7a2V5Olwic3RvcFByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19LHtrZXk6XCJwYWdlWFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhZ2UueH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMucGFnZS54PXR9fSx7a2V5OlwicGFnZVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYWdlLnl9LHNldDpmdW5jdGlvbih0KXt0aGlzLnBhZ2UueT10fX0se2tleTpcImNsaWVudFhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGllbnQueH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuY2xpZW50Lng9dH19LHtrZXk6XCJjbGllbnRZXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xpZW50Lnl9LHNldDpmdW5jdGlvbih0KXt0aGlzLmNsaWVudC55PXR9fSx7a2V5OlwiZHhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWx0YS54fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5kZWx0YS54PXR9fSx7a2V5OlwiZHlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWx0YS55fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5kZWx0YS55PXR9fSx7a2V5OlwidmVsb2NpdHlYXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmVsb2NpdHkueH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMudmVsb2NpdHkueD10fX0se2tleTpcInZlbG9jaXR5WVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlbG9jaXR5Lnl9LHNldDpmdW5jdGlvbih0KXt0aGlzLnZlbG9jaXR5Lnk9dH19XSkmJlZlKHQucHJvdG90eXBlLGUpLG4mJlZlKHQsbiksZ30oKSwkZT1XZS5JbnRlcmFjdEV2ZW50PUtlO1dlLmRlZmF1bHQ9JGU7dmFyIFplPXt9O2Z1bmN0aW9uIEplKHQpe3JldHVybihKZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KFplLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFplLmRlZmF1bHQ9dm9pZCAwO3ZhciBRZSx0bj1hbihTKSxlbj1hbigkKSxubj0oUWU9Y3QpJiZRZS5fX2VzTW9kdWxlP1FlOntkZWZhdWx0OlFlfSxybj1hbih3KTtmdW5jdGlvbiBvbigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIG9uPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gYW4odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09SmUodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9b24oKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn1mdW5jdGlvbiB1bih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gc24odCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fXZhciBsbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIGE9dGhpczshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMuc2NvcGU9dCxzbih0aGlzLFwibGlzdFwiLFtdKSxzbih0aGlzLFwic2VsZWN0b3JNYXBcIix7fSksdC5hZGRMaXN0ZW5lcnMoe1wiaW50ZXJhY3RhYmxlOnVuc2V0XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGFibGUsbj1lLnRhcmdldCxyPWUuX2NvbnRleHQsbz1ybi5zdHJpbmcobik/YS5zZWxlY3Rvck1hcFtuXTpuW2Euc2NvcGUuaWRdLGk9by5maW5kSW5kZXgoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udGV4dD09PXJ9KTtvW2ldJiYob1tpXS5jb250ZXh0PW51bGwsb1tpXS5pbnRlcmFjdGFibGU9bnVsbCksby5zcGxpY2UoaSwxKX19KX12YXIgdCxuLHI7cmV0dXJuIHQ9ZSwobj1be2tleTpcIm5ld1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7ZT0oMCxubi5kZWZhdWx0KShlfHx7fSx7YWN0aW9uczp0aGlzLnNjb3BlLmFjdGlvbnN9KTt2YXIgbj1uZXcgdGhpcy5zY29wZS5JbnRlcmFjdGFibGUodCxlLHRoaXMuc2NvcGUuZG9jdW1lbnQsdGhpcy5zY29wZS5ldmVudHMpLHI9e2NvbnRleHQ6bi5fY29udGV4dCxpbnRlcmFjdGFibGU6bn07cmV0dXJuIHRoaXMuc2NvcGUuYWRkRG9jdW1lbnQobi5fZG9jKSx0aGlzLmxpc3QucHVzaChuKSxybi5zdHJpbmcodCk/KHRoaXMuc2VsZWN0b3JNYXBbdF18fCh0aGlzLnNlbGVjdG9yTWFwW3RdPVtdKSx0aGlzLnNlbGVjdG9yTWFwW3RdLnB1c2gocikpOihuLnRhcmdldFt0aGlzLnNjb3BlLmlkXXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsdGhpcy5zY29wZS5pZCx7dmFsdWU6W10sY29uZmlndXJhYmxlOiEwfSksdFt0aGlzLnNjb3BlLmlkXS5wdXNoKHIpKSx0aGlzLnNjb3BlLmZpcmUoXCJpbnRlcmFjdGFibGU6bmV3XCIse3RhcmdldDp0LG9wdGlvbnM6ZSxpbnRlcmFjdGFibGU6bix3aW46dGhpcy5zY29wZS5fd2lufSksbn19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXQmJnQuY29udGV4dHx8dGhpcy5zY29wZS5kb2N1bWVudCxyPXJuLnN0cmluZyhlKSxvPXI/dGhpcy5zZWxlY3Rvck1hcFtlXTplW3RoaXMuc2NvcGUuaWRdO2lmKCFvKXJldHVybiBudWxsO3ZhciBpPXRuLmZpbmQobyxmdW5jdGlvbih0KXtyZXR1cm4gdC5jb250ZXh0PT09biYmKHJ8fHQuaW50ZXJhY3RhYmxlLmluQ29udGV4dChlKSl9KTtyZXR1cm4gaSYmaS5pbnRlcmFjdGFibGV9fSx7a2V5OlwiZm9yRWFjaE1hdGNoXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHRoaXMubGlzdC5sZW5ndGg7bisrKXt2YXIgcj10aGlzLmxpc3Rbbl0sbz12b2lkIDA7aWYoKHJuLnN0cmluZyhyLnRhcmdldCk/cm4uZWxlbWVudCh0KSYmZW4ubWF0Y2hlc1NlbGVjdG9yKHQsci50YXJnZXQpOnQ9PT1yLnRhcmdldCkmJnIuaW5Db250ZXh0KHQpJiYobz1lKHIpKSx2b2lkIDAhPT1vKXJldHVybiBvfX19XSkmJnVuKHQucHJvdG90eXBlLG4pLHImJnVuKHQsciksZX0oKTtaZS5kZWZhdWx0PWxuO3ZhciBjbj17fTtmdW5jdGlvbiBmbih0KXtyZXR1cm4oZm49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxjbi5kZWZhdWx0PWNuLkZha2VFdmVudD12b2lkIDA7dmFyIHBuPU9uKFMpLGRuPU9uKCQpLHZuPWJuKGN0KSx5bj1Pbih3KSxobj1ibihUdCksZ249T24oenQpO2Z1bmN0aW9uIGJuKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBtbigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIG1uPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gT24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09Zm4odCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9bW4oKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn1mdW5jdGlvbiB3bih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24gX24odCxlKXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKSlyZXR1cm47dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEsdT10W1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO3I9ITApO31jYXRjaCh0KXtvPSEwLGk9dH1maW5hbGx5e3RyeXtyfHxudWxsPT11LnJldHVybnx8dS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgaX19cmV0dXJuIG59KHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9dmFyIFBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbyh0KXt2YXIgZSxuLHI7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxvKSx0aGlzLm9yaWdpbmFsRXZlbnQ9dCxyPXZvaWQgMCwobj1cImN1cnJlbnRUYXJnZXRcIilpbihlPXRoaXMpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW25dPXIsKDAsaG4uZGVmYXVsdCkodGhpcyx0KX12YXIgdCxlLG47cmV0dXJuIHQ9bywoZT1be2tleTpcInByZXZlbnRPcmlnaW5hbERlZmF1bHRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpfX0se2tleTpcInN0b3BQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpfX0se2tleTpcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vcmlnaW5hbEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpfX1dKSYmd24odC5wcm90b3R5cGUsZSksbiYmd24odCxuKSxvfSgpO2Z1bmN0aW9uIHhuKHQpe2lmKCF5bi5vYmplY3QodCkpcmV0dXJue2NhcHR1cmU6ISF0LHBhc3NpdmU6ITF9O3ZhciBlPSgwLHZuLmRlZmF1bHQpKHt9LHQpO3JldHVybiBlLmNhcHR1cmU9ISF0LmNhcHR1cmUsZS5wYXNzaXZlPSEhdC5wYXNzaXZlLGV9Y24uRmFrZUV2ZW50PVBuO3ZhciBTbj17aWQ6XCJldmVudHNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBmPVtdLGI9e30sYz1bXSxwPXthZGQ6ZCxyZW1vdmU6ZyxhZGREZWxlZ2F0ZTpmdW5jdGlvbihlLG4sdCxyLG8pe3ZhciBpPXhuKG8pO2lmKCFiW3RdKXtiW3RdPVtdO2Zvcih2YXIgYT0wO2E8Yy5sZW5ndGg7YSsrKXt2YXIgdT1jW2FdO2QodSx0LG0pLGQodSx0LE8sITApfX12YXIgcz1iW3RdLGw9cG4uZmluZChzLGZ1bmN0aW9uKHQpe3JldHVybiB0LnNlbGVjdG9yPT09ZSYmdC5jb250ZXh0PT09bn0pO2x8fChsPXtzZWxlY3RvcjplLGNvbnRleHQ6bixsaXN0ZW5lcnM6W119LHMucHVzaChsKSk7bC5saXN0ZW5lcnMucHVzaChbcixpXSl9LHJlbW92ZURlbGVnYXRlOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGksYT14bihvKSx1PWJbbl0scz0hMTtpZighdSlyZXR1cm47Zm9yKGk9dS5sZW5ndGgtMTswPD1pO2ktLSl7dmFyIGw9dVtpXTtpZihsLnNlbGVjdG9yPT09dCYmbC5jb250ZXh0PT09ZSl7Zm9yKHZhciBjPWwubGlzdGVuZXJzLGY9Yy5sZW5ndGgtMTswPD1mO2YtLSl7dmFyIHA9X24oY1tmXSwyKSxkPXBbMF0sdj1wWzFdLHk9di5jYXB0dXJlLGg9di5wYXNzaXZlO2lmKGQ9PT1yJiZ5PT09YS5jYXB0dXJlJiZoPT09YS5wYXNzaXZlKXtjLnNwbGljZShmLDEpLGMubGVuZ3RofHwodS5zcGxpY2UoaSwxKSxnKGUsbixtKSxnKGUsbixPLCEwKSkscz0hMDticmVha319aWYocylicmVha319fSxkZWxlZ2F0ZUxpc3RlbmVyOm0sZGVsZWdhdGVVc2VDYXB0dXJlOk8sZGVsZWdhdGVkRXZlbnRzOmIsZG9jdW1lbnRzOmMsdGFyZ2V0czpmLHN1cHBvcnRzT3B0aW9uczohMSxzdXBwb3J0c1Bhc3NpdmU6ITF9O2Z1bmN0aW9uIGQoZSx0LG4scil7dmFyIG89eG4ociksaT1wbi5maW5kKGYsZnVuY3Rpb24odCl7cmV0dXJuIHQuZXZlbnRUYXJnZXQ9PT1lfSk7aXx8KGk9e2V2ZW50VGFyZ2V0OmUsZXZlbnRzOnt9fSxmLnB1c2goaSkpLGkuZXZlbnRzW3RdfHwoaS5ldmVudHNbdF09W10pLGUuYWRkRXZlbnRMaXN0ZW5lciYmIXBuLmNvbnRhaW5zKGkuZXZlbnRzW3RdLG4pJiYoZS5hZGRFdmVudExpc3RlbmVyKHQsbixwLnN1cHBvcnRzT3B0aW9ucz9vOm8uY2FwdHVyZSksaS5ldmVudHNbdF0ucHVzaChuKSl9ZnVuY3Rpb24gZyhlLHQsbixyKXt2YXIgbz14bihyKSxpPXBuLmZpbmRJbmRleChmLGZ1bmN0aW9uKHQpe3JldHVybiB0LmV2ZW50VGFyZ2V0PT09ZX0pLGE9ZltpXTtpZihhJiZhLmV2ZW50cylpZihcImFsbFwiIT09dCl7dmFyIHU9ITEscz1hLmV2ZW50c1t0XTtpZihzKXtpZihcImFsbFwiPT09bil7Zm9yKHZhciBsPXMubGVuZ3RoLTE7MDw9bDtsLS0pZyhlLHQsc1tsXSxvKTtyZXR1cm59Zm9yKHZhciBjPTA7YzxzLmxlbmd0aDtjKyspaWYoc1tjXT09PW4pe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LG4scC5zdXBwb3J0c09wdGlvbnM/bzpvLmNhcHR1cmUpLHMuc3BsaWNlKGMsMSksMD09PXMubGVuZ3RoJiYoZGVsZXRlIGEuZXZlbnRzW3RdLHU9ITApO2JyZWFrfX11JiYhT2JqZWN0LmtleXMoYS5ldmVudHMpLmxlbmd0aCYmZi5zcGxpY2UoaSwxKX1lbHNlIGZvcih0IGluIGEuZXZlbnRzKWEuZXZlbnRzLmhhc093blByb3BlcnR5KHQpJiZnKGUsdCxcImFsbFwiKX1mdW5jdGlvbiBtKHQsZSl7Zm9yKHZhciBuPXhuKGUpLHI9bmV3IFBuKHQpLG89Ylt0LnR5cGVdLGk9X24oZ24uZ2V0RXZlbnRUYXJnZXRzKHQpLDEpWzBdLGE9aTt5bi5lbGVtZW50KGEpOyl7Zm9yKHZhciB1PTA7dTxvLmxlbmd0aDt1Kyspe3ZhciBzPW9bdV0sbD1zLnNlbGVjdG9yLGM9cy5jb250ZXh0O2lmKGRuLm1hdGNoZXNTZWxlY3RvcihhLGwpJiZkbi5ub2RlQ29udGFpbnMoYyxpKSYmZG4ubm9kZUNvbnRhaW5zKGMsYSkpe3ZhciBmPXMubGlzdGVuZXJzO3IuY3VycmVudFRhcmdldD1hO2Zvcih2YXIgcD0wO3A8Zi5sZW5ndGg7cCsrKXt2YXIgZD1fbihmW3BdLDIpLHY9ZFswXSx5PWRbMV0saD15LmNhcHR1cmUsZz15LnBhc3NpdmU7aD09PW4uY2FwdHVyZSYmZz09PW4ucGFzc2l2ZSYmdihyKX19fWE9ZG4ucGFyZW50Tm9kZShhKX19ZnVuY3Rpb24gTyh0KXtyZXR1cm4gbS5jYWxsKHRoaXMsdCwhMCl9cmV0dXJuIHQuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLG51bGwse2dldCBjYXB0dXJlKCl7cmV0dXJuIHAuc3VwcG9ydHNPcHRpb25zPSEwfSxnZXQgcGFzc2l2ZSgpe3JldHVybiBwLnN1cHBvcnRzUGFzc2l2ZT0hMH19KSx0LmV2ZW50cz1wfX07Y24uZGVmYXVsdD1Tbjt2YXIgam49e307T2JqZWN0LmRlZmluZVByb3BlcnR5KGpuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGpuLmRlZmF1bHQ9am4uUG9pbnRlckluZm89dm9pZCAwO2Z1bmN0aW9uIE1uKHQsZSxuLHIsbyl7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxNbiksdGhpcy5pZD10LHRoaXMucG9pbnRlcj1lLHRoaXMuZXZlbnQ9bix0aGlzLmRvd25UaW1lPXIsdGhpcy5kb3duVGFyZ2V0PW99dmFyIGtuPWpuLlBvaW50ZXJJbmZvPU1uO2puLmRlZmF1bHQ9a247dmFyIEVuPXt9O2Z1bmN0aW9uIFRuKHQpe3JldHVybihUbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KEVuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbixcIlBvaW50ZXJJbmZvXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFJuLmRlZmF1bHR9fSksRW4uZGVmYXVsdD1Fbi5JbnRlcmFjdGlvbj1Fbi5fUHJveHlNZXRob2RzPUVuLl9Qcm94eVZhbHVlcz12b2lkIDA7dmFyIERuLEluLHpuLEFuLENuPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PVRuKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPVhuKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KGxlKSxXbj1GbihXZSksUm49Rm4oam4pO2Z1bmN0aW9uIEZuKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBYbigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIFhuPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gWW4odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIE5uKHQsZSxuKXtyZXR1cm4gZSYmWW4odC5wcm90b3R5cGUsZSksbiYmWW4odCxuKSx0fWZ1bmN0aW9uIExuKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH1Fbi5fUHJveHlWYWx1ZXM9RG4sKEluPURufHwoRW4uX1Byb3h5VmFsdWVzPURuPXt9KSkuaW50ZXJhY3RhYmxlPVwiXCIsSW4uZWxlbWVudD1cIlwiLEluLnByZXBhcmVkPVwiXCIsSW4ucG9pbnRlcklzRG93bj1cIlwiLEluLnBvaW50ZXJXYXNNb3ZlZD1cIlwiLEluLl9wcm94eT1cIlwiLEVuLl9Qcm94eU1ldGhvZHM9em4sKEFuPXpufHwoRW4uX1Byb3h5TWV0aG9kcz16bj17fSkpLnN0YXJ0PVwiXCIsQW4ubW92ZT1cIlwiLEFuLmVuZD1cIlwiLEFuLnN0b3A9XCJcIixBbi5pbnRlcmFjdGluZz1cIlwiO3ZhciBCbj0wLFZuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbCh0KXt2YXIgZT10aGlzLG49dC5wb2ludGVyVHlwZSxyPXQuc2NvcGVGaXJlOyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbCksTG4odGhpcyxcImludGVyYWN0YWJsZVwiLG51bGwpLExuKHRoaXMsXCJlbGVtZW50XCIsbnVsbCksTG4odGhpcyxcInJlY3RcIix2b2lkIDApLExuKHRoaXMsXCJfcmVjdHNcIix2b2lkIDApLExuKHRoaXMsXCJlZGdlc1wiLHZvaWQgMCksTG4odGhpcyxcIl9zY29wZUZpcmVcIix2b2lkIDApLExuKHRoaXMsXCJwcmVwYXJlZFwiLHtuYW1lOm51bGwsYXhpczpudWxsLGVkZ2VzOm51bGx9KSxMbih0aGlzLFwicG9pbnRlclR5cGVcIix2b2lkIDApLExuKHRoaXMsXCJwb2ludGVyc1wiLFtdKSxMbih0aGlzLFwiZG93bkV2ZW50XCIsbnVsbCksTG4odGhpcyxcImRvd25Qb2ludGVyXCIse30pLExuKHRoaXMsXCJfbGF0ZXN0UG9pbnRlclwiLHtwb2ludGVyOm51bGwsZXZlbnQ6bnVsbCxldmVudFRhcmdldDpudWxsfSksTG4odGhpcyxcInByZXZFdmVudFwiLG51bGwpLExuKHRoaXMsXCJwb2ludGVySXNEb3duXCIsITEpLExuKHRoaXMsXCJwb2ludGVyV2FzTW92ZWRcIiwhMSksTG4odGhpcyxcIl9pbnRlcmFjdGluZ1wiLCExKSxMbih0aGlzLFwiX2VuZGluZ1wiLCExKSxMbih0aGlzLFwiX3N0b3BwZWRcIiwhMCksTG4odGhpcyxcIl9wcm94eVwiLG51bGwpLExuKHRoaXMsXCJzaW11bGF0aW9uXCIsbnVsbCksTG4odGhpcyxcImRvTW92ZVwiLENuLndhcm5PbmNlKGZ1bmN0aW9uKHQpe3RoaXMubW92ZSh0KX0sXCJUaGUgaW50ZXJhY3Rpb24uZG9Nb3ZlKCkgbWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gaW50ZXJhY3Rpb24ubW92ZSgpXCIpKSxMbih0aGlzLFwiY29vcmRzXCIse3N0YXJ0OkNuLnBvaW50ZXIubmV3Q29vcmRzKCkscHJldjpDbi5wb2ludGVyLm5ld0Nvb3JkcygpLGN1cjpDbi5wb2ludGVyLm5ld0Nvb3JkcygpLGRlbHRhOkNuLnBvaW50ZXIubmV3Q29vcmRzKCksdmVsb2NpdHk6Q24ucG9pbnRlci5uZXdDb29yZHMoKX0pLExuKHRoaXMsXCJfaWRcIixCbisrKSx0aGlzLl9zY29wZUZpcmU9cix0aGlzLnBvaW50ZXJUeXBlPW47dmFyIG89dGhpczt0aGlzLl9wcm94eT17fTtmdW5jdGlvbiBpKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLl9wcm94eSx0LHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb1t0XX19KX1mb3IodmFyIGEgaW4gRG4paShhKTtmdW5jdGlvbiB1KHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLl9wcm94eSx0LHt2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBvW3RdLmFwcGx5KG8sYXJndW1lbnRzKX19KX1mb3IodmFyIHMgaW4gem4pdShzKTt0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6bmV3XCIse2ludGVyYWN0aW9uOnRoaXN9KX1yZXR1cm4gTm4obCxbe2tleTpcInBvaW50ZXJNb3ZlVG9sZXJhbmNlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDF9fV0pLE5uKGwsW3trZXk6XCJwb2ludGVyRG93blwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLnVwZGF0ZVBvaW50ZXIodCxlLG4sITApLG89dGhpcy5wb2ludGVyc1tyXTt0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6ZG93blwiLHtwb2ludGVyOnQsZXZlbnQ6ZSxldmVudFRhcmdldDpuLHBvaW50ZXJJbmRleDpyLHBvaW50ZXJJbmZvOm8sdHlwZTpcImRvd25cIixpbnRlcmFjdGlvbjp0aGlzfSl9fSx7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuISh0aGlzLmludGVyYWN0aW5nKCl8fCF0aGlzLnBvaW50ZXJJc0Rvd258fHRoaXMucG9pbnRlcnMubGVuZ3RoPChcImdlc3R1cmVcIj09PXQubmFtZT8yOjEpfHwhZS5vcHRpb25zW3QubmFtZV0uZW5hYmxlZCkmJihDbi5jb3B5QWN0aW9uKHRoaXMucHJlcGFyZWQsdCksdGhpcy5pbnRlcmFjdGFibGU9ZSx0aGlzLmVsZW1lbnQ9bix0aGlzLnJlY3Q9ZS5nZXRSZWN0KG4pLHRoaXMuZWRnZXM9dGhpcy5wcmVwYXJlZC5lZGdlcz9Dbi5leHRlbmQoe30sdGhpcy5wcmVwYXJlZC5lZGdlcyk6e2xlZnQ6ITAscmlnaHQ6ITAsdG9wOiEwLGJvdHRvbTohMH0sdGhpcy5fc3RvcHBlZD0hMSx0aGlzLl9pbnRlcmFjdGluZz10aGlzLl9kb1BoYXNlKHtpbnRlcmFjdGlvbjp0aGlzLGV2ZW50OnRoaXMuZG93bkV2ZW50LHBoYXNlOlwic3RhcnRcIn0pJiYhdGhpcy5fc3RvcHBlZCx0aGlzLl9pbnRlcmFjdGluZyl9fSx7a2V5OlwicG9pbnRlck1vdmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dGhpcy5zaW11bGF0aW9ufHx0aGlzLm1vZGlmaWNhdGlvbiYmdGhpcy5tb2RpZmljYXRpb24uZW5kUmVzdWx0fHx0aGlzLnVwZGF0ZVBvaW50ZXIodCxlLG4sITEpO3ZhciByLG8saT10aGlzLmNvb3Jkcy5jdXIucGFnZS54PT09dGhpcy5jb29yZHMucHJldi5wYWdlLngmJnRoaXMuY29vcmRzLmN1ci5wYWdlLnk9PT10aGlzLmNvb3Jkcy5wcmV2LnBhZ2UueSYmdGhpcy5jb29yZHMuY3VyLmNsaWVudC54PT09dGhpcy5jb29yZHMucHJldi5jbGllbnQueCYmdGhpcy5jb29yZHMuY3VyLmNsaWVudC55PT09dGhpcy5jb29yZHMucHJldi5jbGllbnQueTt0aGlzLnBvaW50ZXJJc0Rvd24mJiF0aGlzLnBvaW50ZXJXYXNNb3ZlZCYmKHI9dGhpcy5jb29yZHMuY3VyLmNsaWVudC54LXRoaXMuY29vcmRzLnN0YXJ0LmNsaWVudC54LG89dGhpcy5jb29yZHMuY3VyLmNsaWVudC55LXRoaXMuY29vcmRzLnN0YXJ0LmNsaWVudC55LHRoaXMucG9pbnRlcldhc01vdmVkPUNuLmh5cG90KHIsbyk+dGhpcy5wb2ludGVyTW92ZVRvbGVyYW5jZSk7dmFyIGE9dGhpcy5nZXRQb2ludGVySW5kZXgodCksdT17cG9pbnRlcjp0LHBvaW50ZXJJbmRleDphLHBvaW50ZXJJbmZvOnRoaXMucG9pbnRlcnNbYV0sZXZlbnQ6ZSx0eXBlOlwibW92ZVwiLGV2ZW50VGFyZ2V0Om4sZHg6cixkeTpvLGR1cGxpY2F0ZTppLGludGVyYWN0aW9uOnRoaXN9O2l8fENuLnBvaW50ZXIuc2V0Q29vcmRWZWxvY2l0eSh0aGlzLmNvb3Jkcy52ZWxvY2l0eSx0aGlzLmNvb3Jkcy5kZWx0YSksdGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOm1vdmVcIix1KSxpfHx0aGlzLnNpbXVsYXRpb258fCh0aGlzLmludGVyYWN0aW5nKCkmJih1LnR5cGU9bnVsbCx0aGlzLm1vdmUodSkpLHRoaXMucG9pbnRlcldhc01vdmVkJiZDbi5wb2ludGVyLmNvcHlDb29yZHModGhpcy5jb29yZHMucHJldix0aGlzLmNvb3Jkcy5jdXIpKX19LHtrZXk6XCJtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dCYmdC5ldmVudHx8Q24ucG9pbnRlci5zZXRaZXJvQ29vcmRzKHRoaXMuY29vcmRzLmRlbHRhKSwodD1Dbi5leHRlbmQoe3BvaW50ZXI6dGhpcy5fbGF0ZXN0UG9pbnRlci5wb2ludGVyLGV2ZW50OnRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnQsZXZlbnRUYXJnZXQ6dGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudFRhcmdldCxpbnRlcmFjdGlvbjp0aGlzfSx0fHx7fSkpLnBoYXNlPVwibW92ZVwiLHRoaXMuX2RvUGhhc2UodCl9fSx7a2V5OlwicG9pbnRlclVwXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dGhpcy5nZXRQb2ludGVySW5kZXgodCk7LTE9PT1vJiYobz10aGlzLnVwZGF0ZVBvaW50ZXIodCxlLG4sITEpKTt2YXIgaT0vY2FuY2VsJC9pLnRlc3QoZS50eXBlKT9cImNhbmNlbFwiOlwidXBcIjt0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6XCIuY29uY2F0KGkpLHtwb2ludGVyOnQscG9pbnRlckluZGV4Om8scG9pbnRlckluZm86dGhpcy5wb2ludGVyc1tvXSxldmVudDplLGV2ZW50VGFyZ2V0Om4sdHlwZTppLGN1ckV2ZW50VGFyZ2V0OnIsaW50ZXJhY3Rpb246dGhpc30pLHRoaXMuc2ltdWxhdGlvbnx8dGhpcy5lbmQoZSksdGhpcy5wb2ludGVySXNEb3duPSExLHRoaXMucmVtb3ZlUG9pbnRlcih0LGUpfX0se2tleTpcImRvY3VtZW50Qmx1clwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuZW5kKHQpLHRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpibHVyXCIse2V2ZW50OnQsdHlwZTpcImJsdXJcIixpbnRlcmFjdGlvbjp0aGlzfSl9fSx7a2V5OlwiZW5kXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU7dGhpcy5fZW5kaW5nPSEwLHQ9dHx8dGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudCx0aGlzLmludGVyYWN0aW5nKCkmJihlPXRoaXMuX2RvUGhhc2Uoe2V2ZW50OnQsaW50ZXJhY3Rpb246dGhpcyxwaGFzZTpcImVuZFwifSkpLCEodGhpcy5fZW5kaW5nPSExKT09PWUmJnRoaXMuc3RvcCgpfX0se2tleTpcImN1cnJlbnRBY3Rpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcmFjdGluZz90aGlzLnByZXBhcmVkLm5hbWU6bnVsbH19LHtrZXk6XCJpbnRlcmFjdGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyYWN0aW5nfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpzdG9wXCIse2ludGVyYWN0aW9uOnRoaXN9KSx0aGlzLmludGVyYWN0YWJsZT10aGlzLmVsZW1lbnQ9bnVsbCx0aGlzLl9pbnRlcmFjdGluZz0hMSx0aGlzLl9zdG9wcGVkPSEwLHRoaXMucHJlcGFyZWQubmFtZT10aGlzLnByZXZFdmVudD1udWxsfX0se2tleTpcImdldFBvaW50ZXJJbmRleFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPUNuLnBvaW50ZXIuZ2V0UG9pbnRlcklkKHQpO3JldHVyblwibW91c2VcIj09PXRoaXMucG9pbnRlclR5cGV8fFwicGVuXCI9PT10aGlzLnBvaW50ZXJUeXBlP3RoaXMucG9pbnRlcnMubGVuZ3RoLTE6Q24uYXJyLmZpbmRJbmRleCh0aGlzLnBvaW50ZXJzLGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkPT09ZX0pfX0se2tleTpcImdldFBvaW50ZXJJbmZvXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucG9pbnRlcnNbdGhpcy5nZXRQb2ludGVySW5kZXgodCldfX0se2tleTpcInVwZGF0ZVBvaW50ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyKXt2YXIgbz1Dbi5wb2ludGVyLmdldFBvaW50ZXJJZCh0KSxpPXRoaXMuZ2V0UG9pbnRlckluZGV4KHQpLGE9dGhpcy5wb2ludGVyc1tpXTtyZXR1cm4gcj0hMSE9PXImJihyfHwvKGRvd258c3RhcnQpJC9pLnRlc3QoZS50eXBlKSksYT9hLnBvaW50ZXI9dDooYT1uZXcgUm4uZGVmYXVsdChvLHQsZSxudWxsLG51bGwpLGk9dGhpcy5wb2ludGVycy5sZW5ndGgsdGhpcy5wb2ludGVycy5wdXNoKGEpKSxDbi5wb2ludGVyLnNldENvb3Jkcyh0aGlzLmNvb3Jkcy5jdXIsdGhpcy5wb2ludGVycy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucG9pbnRlcn0pLHRoaXMuX25vdygpKSxDbi5wb2ludGVyLnNldENvb3JkRGVsdGFzKHRoaXMuY29vcmRzLmRlbHRhLHRoaXMuY29vcmRzLnByZXYsdGhpcy5jb29yZHMuY3VyKSxyJiYodGhpcy5wb2ludGVySXNEb3duPSEwLGEuZG93blRpbWU9dGhpcy5jb29yZHMuY3VyLnRpbWVTdGFtcCxhLmRvd25UYXJnZXQ9bixDbi5wb2ludGVyLnBvaW50ZXJFeHRlbmQodGhpcy5kb3duUG9pbnRlcix0KSx0aGlzLmludGVyYWN0aW5nKCl8fChDbi5wb2ludGVyLmNvcHlDb29yZHModGhpcy5jb29yZHMuc3RhcnQsdGhpcy5jb29yZHMuY3VyKSxDbi5wb2ludGVyLmNvcHlDb29yZHModGhpcy5jb29yZHMucHJldix0aGlzLmNvb3Jkcy5jdXIpLHRoaXMuZG93bkV2ZW50PWUsdGhpcy5wb2ludGVyV2FzTW92ZWQ9ITEpKSx0aGlzLl91cGRhdGVMYXRlc3RQb2ludGVyKHQsZSxuKSx0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6dXBkYXRlLXBvaW50ZXJcIix7cG9pbnRlcjp0LGV2ZW50OmUsZXZlbnRUYXJnZXQ6bixkb3duOnIscG9pbnRlckluZm86YSxwb2ludGVySW5kZXg6aSxpbnRlcmFjdGlvbjp0aGlzfSksaX19LHtrZXk6XCJyZW1vdmVQb2ludGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldFBvaW50ZXJJbmRleCh0KTtpZigtMSE9PW4pe3ZhciByPXRoaXMucG9pbnRlcnNbbl07dGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOnJlbW92ZS1wb2ludGVyXCIse3BvaW50ZXI6dCxldmVudDplLGV2ZW50VGFyZ2V0Om51bGwscG9pbnRlckluZGV4Om4scG9pbnRlckluZm86cixpbnRlcmFjdGlvbjp0aGlzfSksdGhpcy5wb2ludGVycy5zcGxpY2UobiwxKX19fSx7a2V5OlwiX3VwZGF0ZUxhdGVzdFBvaW50ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dGhpcy5fbGF0ZXN0UG9pbnRlci5wb2ludGVyPXQsdGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudD1lLHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQ9bn19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9sYXRlc3RQb2ludGVyLnBvaW50ZXI9bnVsbCx0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50PW51bGwsdGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudFRhcmdldD1udWxsfX0se2tleTpcIl9jcmVhdGVQcmVwYXJlZEV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIG5ldyBXbi5kZWZhdWx0KHRoaXMsdCx0aGlzLnByZXBhcmVkLm5hbWUsZSx0aGlzLmVsZW1lbnQsbixyKX19LHtrZXk6XCJfZmlyZUV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5pbnRlcmFjdGFibGUuZmlyZSh0KSwoIXRoaXMucHJldkV2ZW50fHx0LnRpbWVTdGFtcD49dGhpcy5wcmV2RXZlbnQudGltZVN0YW1wKSYmKHRoaXMucHJldkV2ZW50PXQpfX0se2tleTpcIl9kb1BoYXNlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5ldmVudCxuPXQucGhhc2Uscj10LnByZUVuZCxvPXQudHlwZSxpPXRoaXMucmVjdDtpZihpJiZcIm1vdmVcIj09PW4mJihDbi5yZWN0LmFkZEVkZ2VzKHRoaXMuZWRnZXMsaSx0aGlzLmNvb3Jkcy5kZWx0YVt0aGlzLmludGVyYWN0YWJsZS5vcHRpb25zLmRlbHRhU291cmNlXSksaS53aWR0aD1pLnJpZ2h0LWkubGVmdCxpLmhlaWdodD1pLmJvdHRvbS1pLnRvcCksITE9PT10aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1cIi5jb25jYXQobiksdCkpcmV0dXJuITE7dmFyIGE9dC5pRXZlbnQ9dGhpcy5fY3JlYXRlUHJlcGFyZWRFdmVudChlLG4scixvKTtyZXR1cm4gdGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1cIi5jb25jYXQobiksdCksXCJzdGFydFwiPT09biYmKHRoaXMucHJldkV2ZW50PWEpLHRoaXMuX2ZpcmVFdmVudChhKSx0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLVwiLmNvbmNhdChuKSx0KSwhMH19LHtrZXk6XCJfbm93XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19XSksbH0oKSxxbj1Fbi5JbnRlcmFjdGlvbj1WbjtFbi5kZWZhdWx0PXFuO3ZhciBVbj17fTtmdW5jdGlvbiBHbih0KXtyZXR1cm4oR249XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxVbi5pbnN0YWxsPUpuLFVuLmRlZmF1bHQ9dm9pZCAwO3ZhciBIbj1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1Hbih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1LbigpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh3KTtmdW5jdGlvbiBLbigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIEtuPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gJG4odCl7cmV0dXJuL14oYWx3YXlzfG5ldmVyfGF1dG8pJC8udGVzdCh0KT8odGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0PXQsdGhpcyk6SG4uYm9vbCh0KT8odGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0PXQ/XCJhbHdheXNcIjpcIm5ldmVyXCIsdGhpcyk6dGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0fWZ1bmN0aW9uIFpuKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmV2ZW50O2UuaW50ZXJhY3RhYmxlJiZlLmludGVyYWN0YWJsZS5jaGVja0FuZFByZXZlbnREZWZhdWx0KG4pfWZ1bmN0aW9uIEpuKHIpe3ZhciB0PXIuSW50ZXJhY3RhYmxlO3QucHJvdG90eXBlLnByZXZlbnREZWZhdWx0PSRuLHQucHJvdG90eXBlLmNoZWNrQW5kUHJldmVudERlZmF1bHQ9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10Lm9wdGlvbnMucHJldmVudERlZmF1bHQ7aWYoXCJuZXZlclwiIT09cilpZihcImFsd2F5c1wiIT09cil7aWYoZS5ldmVudHMuc3VwcG9ydHNQYXNzaXZlJiYvXnRvdWNoKHN0YXJ0fG1vdmUpJC8udGVzdChuLnR5cGUpKXt2YXIgbz0oMCxPLmdldFdpbmRvdykobi50YXJnZXQpLmRvY3VtZW50LGk9ZS5nZXREb2NPcHRpb25zKG8pO2lmKCFpfHwhaS5ldmVudHN8fCExIT09aS5ldmVudHMucGFzc2l2ZSlyZXR1cm59L14obW91c2V8cG9pbnRlcnx0b3VjaCkqKGRvd258c3RhcnQpL2kudGVzdChuLnR5cGUpfHxIbi5lbGVtZW50KG4udGFyZ2V0KSYmKDAsJC5tYXRjaGVzU2VsZWN0b3IpKG4udGFyZ2V0LFwiaW5wdXQsc2VsZWN0LHRleHRhcmVhLFtjb250ZW50ZWRpdGFibGU9dHJ1ZV0sW2NvbnRlbnRlZGl0YWJsZT10cnVlXSAqXCIpfHxuLnByZXZlbnREZWZhdWx0KCl9ZWxzZSBuLnByZXZlbnREZWZhdWx0KCl9KHRoaXMscix0KX0sci5pbnRlcmFjdGlvbnMuZG9jRXZlbnRzLnB1c2goe3R5cGU6XCJkcmFnc3RhcnRcIixsaXN0ZW5lcjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHIuaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO2UrKyl7dmFyIG49ci5pbnRlcmFjdGlvbnMubGlzdFtlXTtpZihuLmVsZW1lbnQmJihuLmVsZW1lbnQ9PT10LnRhcmdldHx8KDAsJC5ub2RlQ29udGFpbnMpKG4uZWxlbWVudCx0LnRhcmdldCkpKXJldHVybiB2b2lkIG4uaW50ZXJhY3RhYmxlLmNoZWNrQW5kUHJldmVudERlZmF1bHQodCl9fX0pfXZhciBRbj17aWQ6XCJjb3JlL2ludGVyYWN0YWJsZVByZXZlbnREZWZhdWx0XCIsaW5zdGFsbDpKbixsaXN0ZW5lcnM6W1wiZG93blwiLFwibW92ZVwiLFwidXBcIixcImNhbmNlbFwiXS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtcImludGVyYWN0aW9uczpcIi5jb25jYXQoZSldPVpuLHR9LHt9KX07VW4uZGVmYXVsdD1Rbjt2YXIgdHI9e307ZnVuY3Rpb24gZXIodCl7cmV0dXJuKGVyPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdHIuZGVmYXVsdD12b2lkIDA7dmFyIG5yPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWVyKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPXJyKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KCQpO2Z1bmN0aW9uIHJyKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gcnI9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH12YXIgb3I9e21ldGhvZE9yZGVyOltcInNpbXVsYXRpb25SZXN1bWVcIixcIm1vdXNlT3JQZW5cIixcImhhc1BvaW50ZXJcIixcImlkbGVcIl0sc2VhcmNoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8b3IubWV0aG9kT3JkZXIubGVuZ3RoO2UrKyl7dmFyIG47bj1vci5tZXRob2RPcmRlcltlXTt2YXIgcj1vcltuXSh0KTtpZihyKXJldHVybiByfXJldHVybiBudWxsfSxzaW11bGF0aW9uUmVzdW1lOmZ1bmN0aW9uKHQpe3ZhciBlPXQucG9pbnRlclR5cGUsbj10LmV2ZW50VHlwZSxyPXQuZXZlbnRUYXJnZXQsbz10LnNjb3BlO2lmKCEvZG93bnxzdGFydC9pLnRlc3QobikpcmV0dXJuIG51bGw7Zm9yKHZhciBpPTA7aTxvLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDtpKyspe3ZhciBhPW8uaW50ZXJhY3Rpb25zLmxpc3RbaV0sdT1yO2lmKGEuc2ltdWxhdGlvbiYmYS5zaW11bGF0aW9uLmFsbG93UmVzdW1lJiZhLnBvaW50ZXJUeXBlPT09ZSlmb3IoO3U7KXtpZih1PT09YS5lbGVtZW50KXJldHVybiBhO3U9bnIucGFyZW50Tm9kZSh1KX19cmV0dXJuIG51bGx9LG1vdXNlT3JQZW46ZnVuY3Rpb24odCl7dmFyIGUsbj10LnBvaW50ZXJJZCxyPXQucG9pbnRlclR5cGUsbz10LmV2ZW50VHlwZSxpPXQuc2NvcGU7aWYoXCJtb3VzZVwiIT09ciYmXCJwZW5cIiE9PXIpcmV0dXJuIG51bGw7Zm9yKHZhciBhPTA7YTxpLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDthKyspe3ZhciB1PWkuaW50ZXJhY3Rpb25zLmxpc3RbYV07aWYodS5wb2ludGVyVHlwZT09PXIpe2lmKHUuc2ltdWxhdGlvbiYmIWlyKHUsbikpY29udGludWU7aWYodS5pbnRlcmFjdGluZygpKXJldHVybiB1O2U9ZXx8dX19aWYoZSlyZXR1cm4gZTtmb3IodmFyIHM9MDtzPGkuaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoO3MrKyl7dmFyIGw9aS5pbnRlcmFjdGlvbnMubGlzdFtzXTtpZighKGwucG9pbnRlclR5cGUhPT1yfHwvZG93bi9pLnRlc3QobykmJmwuc2ltdWxhdGlvbikpcmV0dXJuIGx9cmV0dXJuIG51bGx9LGhhc1BvaW50ZXI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQucG9pbnRlcklkLG49dC5zY29wZSxyPTA7cjxuLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDtyKyspe3ZhciBvPW4uaW50ZXJhY3Rpb25zLmxpc3Rbcl07aWYoaXIobyxlKSlyZXR1cm4gb31yZXR1cm4gbnVsbH0saWRsZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5wb2ludGVyVHlwZSxuPXQuc2NvcGUscj0wO3I8bi5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGg7cisrKXt2YXIgbz1uLmludGVyYWN0aW9ucy5saXN0W3JdO2lmKDE9PT1vLnBvaW50ZXJzLmxlbmd0aCl7dmFyIGk9by5pbnRlcmFjdGFibGU7aWYoaSYmKCFpLm9wdGlvbnMuZ2VzdHVyZXx8IWkub3B0aW9ucy5nZXN0dXJlLmVuYWJsZWQpKWNvbnRpbnVlfWVsc2UgaWYoMjw9by5wb2ludGVycy5sZW5ndGgpY29udGludWU7aWYoIW8uaW50ZXJhY3RpbmcoKSYmZT09PW8ucG9pbnRlclR5cGUpcmV0dXJuIG99cmV0dXJuIG51bGx9fTtmdW5jdGlvbiBpcih0LGUpe3JldHVybiB0LnBvaW50ZXJzLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWQ9PT1lfSl9dmFyIGFyPW9yO3RyLmRlZmF1bHQ9YXI7dmFyIHVyPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1cixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx1ci5kZWZhdWx0PXZvaWQgMDt2YXIgc3IsbHI9KHNyPU1lKSYmc3IuX19lc01vZHVsZT9zcjp7ZGVmYXVsdDpzcn0sY3I9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09cHIodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9ZnIoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oUyk7ZnVuY3Rpb24gZnIoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBmcj1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIHByKHQpe3JldHVybihwcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9ZnVuY3Rpb24gZHIodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIHZyKHQpe3JldHVybih2cj1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSkodCl9ZnVuY3Rpb24geXIodCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9ZnVuY3Rpb24gaHIodCxlKXtyZXR1cm4oaHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIGdyKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgYnI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBsKHQsZSxuKXt2YXIgcixvLGk7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxsKSxvPXRoaXMscj0hKGk9dnIobCkuY2FsbCh0aGlzLGUuX2ludGVyYWN0aW9uKSl8fFwib2JqZWN0XCIhPT1wcihpKSYmXCJmdW5jdGlvblwiIT10eXBlb2YgaT95cihvKTppLGdyKHlyKHIpLFwidGFyZ2V0XCIsdm9pZCAwKSxncih5cihyKSxcImRyb3B6b25lXCIsdm9pZCAwKSxncih5cihyKSxcImRyYWdFdmVudFwiLHZvaWQgMCksZ3IoeXIociksXCJyZWxhdGVkVGFyZ2V0XCIsdm9pZCAwKSxncih5cihyKSxcImRyYWdnYWJsZVwiLHZvaWQgMCksZ3IoeXIociksXCJ0aW1lU3RhbXBcIix2b2lkIDApLGdyKHlyKHIpLFwicHJvcGFnYXRpb25TdG9wcGVkXCIsITEpLGdyKHlyKHIpLFwiaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCIsITEpO3ZhciBhPVwiZHJhZ2xlYXZlXCI9PT1uP3QucHJldjp0LmN1cix1PWEuZWxlbWVudCxzPWEuZHJvcHpvbmU7cmV0dXJuIHIudHlwZT1uLHIudGFyZ2V0PXUsci5jdXJyZW50VGFyZ2V0PXUsci5kcm9wem9uZT1zLHIuZHJhZ0V2ZW50PWUsci5yZWxhdGVkVGFyZ2V0PWUudGFyZ2V0LHIuZHJhZ2dhYmxlPWUuaW50ZXJhY3RhYmxlLHIudGltZVN0YW1wPWUudGltZVN0YW1wLHJ9dmFyIHQsZSxuO3JldHVybiBmdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmaHIodCxlKX0obCxscltcImRlZmF1bHRcIl0pLHQ9bCwoZT1be2tleTpcInJlamVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHI9dGhpcyx0PXRoaXMuX2ludGVyYWN0aW9uLmRyb3BTdGF0ZTtpZihcImRyb3BhY3RpdmF0ZVwiPT09dGhpcy50eXBlfHx0aGlzLmRyb3B6b25lJiZ0LmN1ci5kcm9wem9uZT09PXRoaXMuZHJvcHpvbmUmJnQuY3VyLmVsZW1lbnQ9PT10aGlzLnRhcmdldClpZih0LnByZXYuZHJvcHpvbmU9dGhpcy5kcm9wem9uZSx0LnByZXYuZWxlbWVudD10aGlzLnRhcmdldCx0LnJlamVjdGVkPSEwLHQuZXZlbnRzLmVudGVyPW51bGwsdGhpcy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxcImRyb3BhY3RpdmF0ZVwiPT09dGhpcy50eXBlKXt2YXIgZT10LmFjdGl2ZURyb3BzLG49Y3IuZmluZEluZGV4KGUsZnVuY3Rpb24odCl7dmFyIGU9dC5kcm9wem9uZSxuPXQuZWxlbWVudDtyZXR1cm4gZT09PXIuZHJvcHpvbmUmJm49PT1yLnRhcmdldH0pO3QuYWN0aXZlRHJvcHMuc3BsaWNlKG4sMSk7dmFyIG89bmV3IGwodCx0aGlzLmRyYWdFdmVudCxcImRyb3BkZWFjdGl2YXRlXCIpO28uZHJvcHpvbmU9dGhpcy5kcm9wem9uZSxvLnRhcmdldD10aGlzLnRhcmdldCx0aGlzLmRyb3B6b25lLmZpcmUobyl9ZWxzZSB0aGlzLmRyb3B6b25lLmZpcmUobmV3IGwodCx0aGlzLmRyYWdFdmVudCxcImRyYWdsZWF2ZVwiKSl9fSx7a2V5OlwicHJldmVudERlZmF1bHRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJzdG9wUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX0se2tleTpcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fV0pJiZkcih0LnByb3RvdHlwZSxlKSxuJiZkcih0LG4pLGx9KCk7dXIuZGVmYXVsdD1icjt2YXIgbXI9e307ZnVuY3Rpb24gT3IodCl7cmV0dXJuKE9yPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkobXIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbXIuZGVmYXVsdD12b2lkIDA7U3Ioayh7fSkpLFNyKG0oe30pKTt2YXIgd3I9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09T3IodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9eHIoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0obGUpLF9yPVNyKHYpLFByPVNyKHVyKTtmdW5jdGlvbiB4cigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIHhyPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gU3IodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIGpyKHQsZSl7Zm9yKHZhciBuPTA7bjx0LnNsaWNlKCkubGVuZ3RoO24rKyl7cj10LnNsaWNlKClbbl07dmFyIHIsbz1yLmRyb3B6b25lLGk9ci5lbGVtZW50O2UuZHJvcHpvbmU9byxlLnRhcmdldD1pLG8uZmlyZShlKSxlLnByb3BhZ2F0aW9uU3RvcHBlZD1lLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD0hMX19ZnVuY3Rpb24gTXIodCxlKXtmb3IodmFyIG49ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pbnRlcmFjdGFibGVzLHI9W10sbz0wO288bi5saXN0Lmxlbmd0aDtvKyspe3ZhciBpPW4ubGlzdFtvXTtpZihpLm9wdGlvbnMuZHJvcC5lbmFibGVkKXt2YXIgYT1pLm9wdGlvbnMuZHJvcC5hY2NlcHQ7aWYoISh3ci5pcy5lbGVtZW50KGEpJiZhIT09ZXx8d3IuaXMuc3RyaW5nKGEpJiYhd3IuZG9tLm1hdGNoZXNTZWxlY3RvcihlLGEpfHx3ci5pcy5mdW5jKGEpJiYhYSh7ZHJvcHpvbmU6aSxkcmFnZ2FibGVFbGVtZW50OmV9KSkpZm9yKHZhciB1PXdyLmlzLnN0cmluZyhpLnRhcmdldCk/aS5fY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKGkudGFyZ2V0KTp3ci5pcy5hcnJheShpLnRhcmdldCk/aS50YXJnZXQ6W2kudGFyZ2V0XSxzPTA7czx1Lmxlbmd0aDtzKyspe3ZhciBsO2w9dVtzXTtsIT09ZSYmci5wdXNoKHtkcm9wem9uZTppLGVsZW1lbnQ6bH0pfX19cmV0dXJuIHJ9KHQsZSkscj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbztvPW5bcl07by5yZWN0PW8uZHJvcHpvbmUuZ2V0UmVjdChvLmVsZW1lbnQpfXJldHVybiBufWZ1bmN0aW9uIGtyKHQsZSxuKXtmb3IodmFyIHI9dC5kcm9wU3RhdGUsbz10LmludGVyYWN0YWJsZSxpPXQuZWxlbWVudCxhPVtdLHU9MDt1PHIuYWN0aXZlRHJvcHMubGVuZ3RoO3UrKyl7cz1yLmFjdGl2ZURyb3BzW3VdO3ZhciBzLGw9cy5kcm9wem9uZSxjPXMuZWxlbWVudCxmPXMucmVjdDthLnB1c2gobC5kcm9wQ2hlY2soZSxuLG8saSxjLGYpP2M6bnVsbCl9dmFyIHA9d3IuZG9tLmluZGV4T2ZEZWVwZXN0RWxlbWVudChhKTtyZXR1cm4gci5hY3RpdmVEcm9wc1twXXx8bnVsbH1mdW5jdGlvbiBFcih0LGUsbil7dmFyIHI9dC5kcm9wU3RhdGUsbz17ZW50ZXI6bnVsbCxsZWF2ZTpudWxsLGFjdGl2YXRlOm51bGwsZGVhY3RpdmF0ZTpudWxsLG1vdmU6bnVsbCxkcm9wOm51bGx9O3JldHVyblwiZHJhZ3N0YXJ0XCI9PT1uLnR5cGUmJihvLmFjdGl2YXRlPW5ldyBQci5kZWZhdWx0KHIsbixcImRyb3BhY3RpdmF0ZVwiKSxvLmFjdGl2YXRlLnRhcmdldD1udWxsLG8uYWN0aXZhdGUuZHJvcHpvbmU9bnVsbCksXCJkcmFnZW5kXCI9PT1uLnR5cGUmJihvLmRlYWN0aXZhdGU9bmV3IFByLmRlZmF1bHQocixuLFwiZHJvcGRlYWN0aXZhdGVcIiksby5kZWFjdGl2YXRlLnRhcmdldD1udWxsLG8uZGVhY3RpdmF0ZS5kcm9wem9uZT1udWxsKSxyLnJlamVjdGVkfHwoci5jdXIuZWxlbWVudCE9PXIucHJldi5lbGVtZW50JiYoci5wcmV2LmRyb3B6b25lJiYoby5sZWF2ZT1uZXcgUHIuZGVmYXVsdChyLG4sXCJkcmFnbGVhdmVcIiksbi5kcmFnTGVhdmU9by5sZWF2ZS50YXJnZXQ9ci5wcmV2LmVsZW1lbnQsbi5wcmV2RHJvcHpvbmU9by5sZWF2ZS5kcm9wem9uZT1yLnByZXYuZHJvcHpvbmUpLHIuY3VyLmRyb3B6b25lJiYoby5lbnRlcj1uZXcgUHIuZGVmYXVsdChyLG4sXCJkcmFnZW50ZXJcIiksbi5kcmFnRW50ZXI9ci5jdXIuZWxlbWVudCxuLmRyb3B6b25lPXIuY3VyLmRyb3B6b25lKSksXCJkcmFnZW5kXCI9PT1uLnR5cGUmJnIuY3VyLmRyb3B6b25lJiYoby5kcm9wPW5ldyBQci5kZWZhdWx0KHIsbixcImRyb3BcIiksbi5kcm9wem9uZT1yLmN1ci5kcm9wem9uZSxuLnJlbGF0ZWRUYXJnZXQ9ci5jdXIuZWxlbWVudCksXCJkcmFnbW92ZVwiPT09bi50eXBlJiZyLmN1ci5kcm9wem9uZSYmKG8ubW92ZT1uZXcgUHIuZGVmYXVsdChyLG4sXCJkcm9wbW92ZVwiKSwoby5tb3ZlLmRyYWdtb3ZlPW4pLmRyb3B6b25lPXIuY3VyLmRyb3B6b25lKSksb31mdW5jdGlvbiBUcih0LGUpe3ZhciBuPXQuZHJvcFN0YXRlLHI9bi5hY3RpdmVEcm9wcyxvPW4uY3VyLGk9bi5wcmV2O2UubGVhdmUmJmkuZHJvcHpvbmUuZmlyZShlLmxlYXZlKSxlLm1vdmUmJm8uZHJvcHpvbmUuZmlyZShlLm1vdmUpLGUuZW50ZXImJm8uZHJvcHpvbmUuZmlyZShlLmVudGVyKSxlLmRyb3AmJm8uZHJvcHpvbmUuZmlyZShlLmRyb3ApLGUuZGVhY3RpdmF0ZSYmanIocixlLmRlYWN0aXZhdGUpLG4ucHJldi5kcm9wem9uZT1vLmRyb3B6b25lLG4ucHJldi5lbGVtZW50PW8uZWxlbWVudH1mdW5jdGlvbiBEcih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LmlFdmVudCxvPXQuZXZlbnQ7aWYoXCJkcmFnbW92ZVwiPT09ci50eXBlfHxcImRyYWdlbmRcIj09PXIudHlwZSl7dmFyIGk9bi5kcm9wU3RhdGU7ZS5keW5hbWljRHJvcCYmKGkuYWN0aXZlRHJvcHM9TXIoZSxuLmVsZW1lbnQpKTt2YXIgYT1yLHU9a3IobixhLG8pO2kucmVqZWN0ZWQ9aS5yZWplY3RlZCYmISF1JiZ1LmRyb3B6b25lPT09aS5jdXIuZHJvcHpvbmUmJnUuZWxlbWVudD09PWkuY3VyLmVsZW1lbnQsaS5jdXIuZHJvcHpvbmU9dSYmdS5kcm9wem9uZSxpLmN1ci5lbGVtZW50PXUmJnUuZWxlbWVudCxpLmV2ZW50cz1FcihuLDAsYSl9fXZhciBJcj17aWQ6XCJhY3Rpb25zL2Ryb3BcIixpbnN0YWxsOmZ1bmN0aW9uKGUpe3ZhciB0PWUuYWN0aW9ucyxuPWUuaW50ZXJhY3RTdGF0aWMscj1lLkludGVyYWN0YWJsZSxvPWUuZGVmYXVsdHM7ZS51c2VQbHVnaW4oX3IuZGVmYXVsdCksci5wcm90b3R5cGUuZHJvcHpvbmU9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYod3IuaXMub2JqZWN0KGUpKXtpZih0Lm9wdGlvbnMuZHJvcC5lbmFibGVkPSExIT09ZS5lbmFibGVkLGUubGlzdGVuZXJzKXt2YXIgbj13ci5ub3JtYWxpemVMaXN0ZW5lcnMoZS5saXN0ZW5lcnMpLHI9T2JqZWN0LmtleXMobikucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbL14oZW50ZXJ8bGVhdmUpLy50ZXN0KGUpP1wiZHJhZ1wiLmNvbmNhdChlKTovXihhY3RpdmF0ZXxkZWFjdGl2YXRlfG1vdmUpLy50ZXN0KGUpP1wiZHJvcFwiLmNvbmNhdChlKTplXT1uW2VdLHR9LHt9KTt0Lm9mZih0Lm9wdGlvbnMuZHJvcC5saXN0ZW5lcnMpLHQub24ociksdC5vcHRpb25zLmRyb3AubGlzdGVuZXJzPXJ9cmV0dXJuIHdyLmlzLmZ1bmMoZS5vbmRyb3ApJiZ0Lm9uKFwiZHJvcFwiLGUub25kcm9wKSx3ci5pcy5mdW5jKGUub25kcm9wYWN0aXZhdGUpJiZ0Lm9uKFwiZHJvcGFjdGl2YXRlXCIsZS5vbmRyb3BhY3RpdmF0ZSksd3IuaXMuZnVuYyhlLm9uZHJvcGRlYWN0aXZhdGUpJiZ0Lm9uKFwiZHJvcGRlYWN0aXZhdGVcIixlLm9uZHJvcGRlYWN0aXZhdGUpLHdyLmlzLmZ1bmMoZS5vbmRyYWdlbnRlcikmJnQub24oXCJkcmFnZW50ZXJcIixlLm9uZHJhZ2VudGVyKSx3ci5pcy5mdW5jKGUub25kcmFnbGVhdmUpJiZ0Lm9uKFwiZHJhZ2xlYXZlXCIsZS5vbmRyYWdsZWF2ZSksd3IuaXMuZnVuYyhlLm9uZHJvcG1vdmUpJiZ0Lm9uKFwiZHJvcG1vdmVcIixlLm9uZHJvcG1vdmUpLC9eKHBvaW50ZXJ8Y2VudGVyKSQvLnRlc3QoZS5vdmVybGFwKT90Lm9wdGlvbnMuZHJvcC5vdmVybGFwPWUub3ZlcmxhcDp3ci5pcy5udW1iZXIoZS5vdmVybGFwKSYmKHQub3B0aW9ucy5kcm9wLm92ZXJsYXA9TWF0aC5tYXgoTWF0aC5taW4oMSxlLm92ZXJsYXApLDApKSxcImFjY2VwdFwiaW4gZSYmKHQub3B0aW9ucy5kcm9wLmFjY2VwdD1lLmFjY2VwdCksXCJjaGVja2VyXCJpbiBlJiYodC5vcHRpb25zLmRyb3AuY2hlY2tlcj1lLmNoZWNrZXIpLHR9aWYod3IuaXMuYm9vbChlKSlyZXR1cm4gdC5vcHRpb25zLmRyb3AuZW5hYmxlZD1lLHQ7cmV0dXJuIHQub3B0aW9ucy5kcm9wfSh0aGlzLHQpfSxyLnByb3RvdHlwZS5kcm9wQ2hlY2s9ZnVuY3Rpb24odCxlLG4scixvLGkpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8saSxhKXt2YXIgdT0hMTtpZighKGE9YXx8dC5nZXRSZWN0KGkpKSlyZXR1cm4hIXQub3B0aW9ucy5kcm9wLmNoZWNrZXImJnQub3B0aW9ucy5kcm9wLmNoZWNrZXIoZSxuLHUsdCxpLHIsbyk7dmFyIHM9dC5vcHRpb25zLmRyb3Aub3ZlcmxhcDtpZihcInBvaW50ZXJcIj09PXMpe3ZhciBsPXdyLmdldE9yaWdpblhZKHIsbyxcImRyYWdcIiksYz13ci5wb2ludGVyLmdldFBhZ2VYWShlKTtjLngrPWwueCxjLnkrPWwueTt2YXIgZj1jLng+YS5sZWZ0JiZjLng8YS5yaWdodCxwPWMueT5hLnRvcCYmYy55PGEuYm90dG9tO3U9ZiYmcH12YXIgZD1yLmdldFJlY3Qobyk7aWYoZCYmXCJjZW50ZXJcIj09PXMpe3ZhciB2PWQubGVmdCtkLndpZHRoLzIseT1kLnRvcCtkLmhlaWdodC8yO3U9dj49YS5sZWZ0JiZ2PD1hLnJpZ2h0JiZ5Pj1hLnRvcCYmeTw9YS5ib3R0b219aWYoZCYmd3IuaXMubnVtYmVyKHMpKXt2YXIgaD1NYXRoLm1heCgwLE1hdGgubWluKGEucmlnaHQsZC5yaWdodCktTWF0aC5tYXgoYS5sZWZ0LGQubGVmdCkpKk1hdGgubWF4KDAsTWF0aC5taW4oYS5ib3R0b20sZC5ib3R0b20pLU1hdGgubWF4KGEudG9wLGQudG9wKSkvKGQud2lkdGgqZC5oZWlnaHQpO3U9czw9aH10Lm9wdGlvbnMuZHJvcC5jaGVja2VyJiYodT10Lm9wdGlvbnMuZHJvcC5jaGVja2VyKGUsbix1LHQsaSxyLG8pKTtyZXR1cm4gdX0odGhpcyx0LGUsbixyLG8saSl9LG4uZHluYW1pY0Ryb3A9ZnVuY3Rpb24odCl7cmV0dXJuIHdyLmlzLmJvb2wodCk/KGUuZHluYW1pY0Ryb3A9dCxuKTplLmR5bmFtaWNEcm9wfSx3ci5leHRlbmQodC5waGFzZWxlc3NUeXBlcyx7ZHJhZ2VudGVyOiEwLGRyYWdsZWF2ZTohMCxkcm9wYWN0aXZhdGU6ITAsZHJvcGRlYWN0aXZhdGU6ITAsZHJvcG1vdmU6ITAsZHJvcDohMH0pLHQubWV0aG9kRGljdC5kcm9wPVwiZHJvcHpvbmVcIixlLmR5bmFtaWNEcm9wPSExLG8uYWN0aW9ucy5kcm9wPUlyLmRlZmF1bHRzfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tc3RhcnRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO1wiZHJhZ1wiPT09ZS5wcmVwYXJlZC5uYW1lJiYoZS5kcm9wU3RhdGU9e2N1cjp7ZHJvcHpvbmU6bnVsbCxlbGVtZW50Om51bGx9LHByZXY6e2Ryb3B6b25lOm51bGwsZWxlbWVudDpudWxsfSxyZWplY3RlZDpudWxsLGV2ZW50czpudWxsLGFjdGl2ZURyb3BzOltdfSl9LFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1zdGFydFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPSh0LmV2ZW50LHQuaUV2ZW50KTtpZihcImRyYWdcIj09PW4ucHJlcGFyZWQubmFtZSl7dmFyIG89bi5kcm9wU3RhdGU7by5hY3RpdmVEcm9wcz1udWxsLG8uZXZlbnRzPW51bGwsby5hY3RpdmVEcm9wcz1NcihlLG4uZWxlbWVudCksby5ldmVudHM9RXIobiwwLHIpLG8uZXZlbnRzLmFjdGl2YXRlJiYoanIoby5hY3RpdmVEcm9wcyxvLmV2ZW50cy5hY3RpdmF0ZSksZS5maXJlKFwiYWN0aW9ucy9kcm9wOnN0YXJ0XCIse2ludGVyYWN0aW9uOm4sZHJhZ0V2ZW50OnJ9KSl9fSxcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOkRyLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1lbmRcIjpEcixcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tbW92ZVwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQuaUV2ZW50O1wiZHJhZ1wiPT09bi5wcmVwYXJlZC5uYW1lJiYoVHIobixuLmRyb3BTdGF0ZS5ldmVudHMpLGUuZmlyZShcImFjdGlvbnMvZHJvcDptb3ZlXCIse2ludGVyYWN0aW9uOm4sZHJhZ0V2ZW50OnJ9KSxuLmRyb3BTdGF0ZS5ldmVudHM9e30pfSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tZW5kXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5pRXZlbnQ7XCJkcmFnXCI9PT1uLnByZXBhcmVkLm5hbWUmJihUcihuLG4uZHJvcFN0YXRlLmV2ZW50cyksZS5maXJlKFwiYWN0aW9ucy9kcm9wOmVuZFwiLHtpbnRlcmFjdGlvbjpuLGRyYWdFdmVudDpyfSkpfSxcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtpZihcImRyYWdcIj09PWUucHJlcGFyZWQubmFtZSl7dmFyIG49ZS5kcm9wU3RhdGU7biYmKG4uYWN0aXZlRHJvcHM9bnVsbCxuLmV2ZW50cz1udWxsLG4uY3VyLmRyb3B6b25lPW51bGwsbi5jdXIuZWxlbWVudD1udWxsLG4ucHJldi5kcm9wem9uZT1udWxsLG4ucHJldi5lbGVtZW50PW51bGwsbi5yZWplY3RlZD0hMSl9fX0sZ2V0QWN0aXZlRHJvcHM6TXIsZ2V0RHJvcDprcixnZXREcm9wRXZlbnRzOkVyLGZpcmVEcm9wRXZlbnRzOlRyLGRlZmF1bHRzOntlbmFibGVkOiExLGFjY2VwdDpudWxsLG92ZXJsYXA6XCJwb2ludGVyXCJ9fSx6cj1Jcjttci5kZWZhdWx0PXpyO3ZhciBBcj17fTtmdW5jdGlvbiBDcih0KXtyZXR1cm4oQ3I9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxBci5kZWZhdWx0PXZvaWQgMDt2YXIgV3I9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09Q3IodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9UnIoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0obGUpO2Z1bmN0aW9uIFJyKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gUnI9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBGcih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5pRXZlbnQscj10LnBoYXNlO2lmKFwiZ2VzdHVyZVwiPT09ZS5wcmVwYXJlZC5uYW1lKXt2YXIgbz1lLnBvaW50ZXJzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5wb2ludGVyfSksaT1cInN0YXJ0XCI9PT1yLGE9XCJlbmRcIj09PXIsdT1lLmludGVyYWN0YWJsZS5vcHRpb25zLmRlbHRhU291cmNlO2lmKG4udG91Y2hlcz1bb1swXSxvWzFdXSxpKW4uZGlzdGFuY2U9V3IucG9pbnRlci50b3VjaERpc3RhbmNlKG8sdSksbi5ib3g9V3IucG9pbnRlci50b3VjaEJCb3gobyksbi5zY2FsZT0xLG4uZHM9MCxuLmFuZ2xlPVdyLnBvaW50ZXIudG91Y2hBbmdsZShvLHUpLG4uZGE9MCxlLmdlc3R1cmUuc3RhcnREaXN0YW5jZT1uLmRpc3RhbmNlLGUuZ2VzdHVyZS5zdGFydEFuZ2xlPW4uYW5nbGU7ZWxzZSBpZihhKXt2YXIgcz1lLnByZXZFdmVudDtuLmRpc3RhbmNlPXMuZGlzdGFuY2Usbi5ib3g9cy5ib3gsbi5zY2FsZT1zLnNjYWxlLG4uZHM9MCxuLmFuZ2xlPXMuYW5nbGUsbi5kYT0wfWVsc2Ugbi5kaXN0YW5jZT1Xci5wb2ludGVyLnRvdWNoRGlzdGFuY2Uobyx1KSxuLmJveD1Xci5wb2ludGVyLnRvdWNoQkJveChvKSxuLnNjYWxlPW4uZGlzdGFuY2UvZS5nZXN0dXJlLnN0YXJ0RGlzdGFuY2Usbi5hbmdsZT1Xci5wb2ludGVyLnRvdWNoQW5nbGUobyx1KSxuLmRzPW4uc2NhbGUtZS5nZXN0dXJlLnNjYWxlLG4uZGE9bi5hbmdsZS1lLmdlc3R1cmUuYW5nbGU7ZS5nZXN0dXJlLmRpc3RhbmNlPW4uZGlzdGFuY2UsZS5nZXN0dXJlLmFuZ2xlPW4uYW5nbGUsV3IuaXMubnVtYmVyKG4uc2NhbGUpJiZuLnNjYWxlIT09MS8wJiYhaXNOYU4obi5zY2FsZSkmJihlLmdlc3R1cmUuc2NhbGU9bi5zY2FsZSl9fXZhciBYcj17aWQ6XCJhY3Rpb25zL2dlc3R1cmVcIixiZWZvcmU6W1wiYWN0aW9ucy9kcmFnXCIsXCJhY3Rpb25zL3Jlc2l6ZVwiXSxpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuYWN0aW9ucyxuPXQuSW50ZXJhY3RhYmxlLHI9dC5kZWZhdWx0cztuLnByb3RvdHlwZS5nZXN0dXJhYmxlPWZ1bmN0aW9uKHQpe3JldHVybiBXci5pcy5vYmplY3QodCk/KHRoaXMub3B0aW9ucy5nZXN0dXJlLmVuYWJsZWQ9ITEhPT10LmVuYWJsZWQsdGhpcy5zZXRQZXJBY3Rpb24oXCJnZXN0dXJlXCIsdCksdGhpcy5zZXRPbkV2ZW50cyhcImdlc3R1cmVcIix0KSx0aGlzKTpXci5pcy5ib29sKHQpPyh0aGlzLm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkPXQsdGhpcyk6dGhpcy5vcHRpb25zLmdlc3R1cmV9LGUubWFwLmdlc3R1cmU9WHIsZS5tZXRob2REaWN0Lmdlc3R1cmU9XCJnZXN0dXJhYmxlXCIsci5hY3Rpb25zLmdlc3R1cmU9WHIuZGVmYXVsdHN9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6YWN0aW9uLXN0YXJ0XCI6RnIsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpGcixcImludGVyYWN0aW9uczphY3Rpb24tZW5kXCI6RnIsXCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5nZXN0dXJlPXthbmdsZTowLGRpc3RhbmNlOjAsc2NhbGU6MSxzdGFydEFuZ2xlOjAsc3RhcnREaXN0YW5jZTowfX0sXCJhdXRvLXN0YXJ0OmNoZWNrXCI6ZnVuY3Rpb24odCl7aWYoISh0LmludGVyYWN0aW9uLnBvaW50ZXJzLmxlbmd0aDwyKSl7dmFyIGU9dC5pbnRlcmFjdGFibGUub3B0aW9ucy5nZXN0dXJlO2lmKGUmJmUuZW5hYmxlZClyZXR1cm4hKHQuYWN0aW9uPXtuYW1lOlwiZ2VzdHVyZVwifSl9fX0sZGVmYXVsdHM6e30sZ2V0Q3Vyc29yOmZ1bmN0aW9uKCl7cmV0dXJuXCJcIn19LFlyPVhyO0FyLmRlZmF1bHQ9WXI7dmFyIE5yPXt9O2Z1bmN0aW9uIExyKHQpe3JldHVybihMcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KE5yLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE5yLmRlZmF1bHQ9dm9pZCAwO3ZhciBCcixWcj1IcigkKSxxcj0oQnI9Y3QpJiZCci5fX2VzTW9kdWxlP0JyOntkZWZhdWx0OkJyfSxVcj1Icih3KTtmdW5jdGlvbiBHcigpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIEdyPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gSHIodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09THIodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9R3IoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn1mdW5jdGlvbiBLcih0LGUsbixyLG8saSxhKXtpZighZSlyZXR1cm4hMTtpZighMD09PWUpe3ZhciB1PVVyLm51bWJlcihpLndpZHRoKT9pLndpZHRoOmkucmlnaHQtaS5sZWZ0LHM9VXIubnVtYmVyKGkuaGVpZ2h0KT9pLmhlaWdodDppLmJvdHRvbS1pLnRvcDtpZihhPU1hdGgubWluKGEsKFwibGVmdFwiPT09dHx8XCJyaWdodFwiPT09dD91OnMpLzIpLHU8MCYmKFwibGVmdFwiPT09dD90PVwicmlnaHRcIjpcInJpZ2h0XCI9PT10JiYodD1cImxlZnRcIikpLHM8MCYmKFwidG9wXCI9PT10P3Q9XCJib3R0b21cIjpcImJvdHRvbVwiPT09dCYmKHQ9XCJ0b3BcIikpLFwibGVmdFwiPT09dClyZXR1cm4gbi54PCgwPD11P2kubGVmdDppLnJpZ2h0KSthO2lmKFwidG9wXCI9PT10KXJldHVybiBuLnk8KDA8PXM/aS50b3A6aS5ib3R0b20pK2E7aWYoXCJyaWdodFwiPT09dClyZXR1cm4gbi54PigwPD11P2kucmlnaHQ6aS5sZWZ0KS1hO2lmKFwiYm90dG9tXCI9PT10KXJldHVybiBuLnk+KDA8PXM/aS5ib3R0b206aS50b3ApLWF9cmV0dXJuISFVci5lbGVtZW50KHIpJiYoVXIuZWxlbWVudChlKT9lPT09cjpWci5tYXRjaGVzVXBUbyhyLGUsbykpfWZ1bmN0aW9uICRyKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbjtpZihcInJlc2l6ZVwiPT09bi5wcmVwYXJlZC5uYW1lJiZuLnJlc2l6ZUF4ZXMpe3ZhciByPWU7bi5pbnRlcmFjdGFibGUub3B0aW9ucy5yZXNpemUuc3F1YXJlPyhcInlcIj09PW4ucmVzaXplQXhlcz9yLmRlbHRhLng9ci5kZWx0YS55OnIuZGVsdGEueT1yLmRlbHRhLngsci5heGVzPVwieHlcIik6KHIuYXhlcz1uLnJlc2l6ZUF4ZXMsXCJ4XCI9PT1uLnJlc2l6ZUF4ZXM/ci5kZWx0YS55PTA6XCJ5XCI9PT1uLnJlc2l6ZUF4ZXMmJihyLmRlbHRhLng9MCkpfX12YXIgWnI9e2lkOlwiYWN0aW9ucy9yZXNpemVcIixiZWZvcmU6W1wiYWN0aW9ucy9kcmFnXCJdLGluc3RhbGw6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hY3Rpb25zLG49ZS5icm93c2VyLHI9ZS5JbnRlcmFjdGFibGUsbz1lLmRlZmF1bHRzO1pyLmN1cnNvcnM9bi5pc0llOT97eDpcImUtcmVzaXplXCIseTpcInMtcmVzaXplXCIseHk6XCJzZS1yZXNpemVcIix0b3A6XCJuLXJlc2l6ZVwiLGxlZnQ6XCJ3LXJlc2l6ZVwiLGJvdHRvbTpcInMtcmVzaXplXCIscmlnaHQ6XCJlLXJlc2l6ZVwiLHRvcGxlZnQ6XCJzZS1yZXNpemVcIixib3R0b21yaWdodDpcInNlLXJlc2l6ZVwiLHRvcHJpZ2h0OlwibmUtcmVzaXplXCIsYm90dG9tbGVmdDpcIm5lLXJlc2l6ZVwifTp7eDpcImV3LXJlc2l6ZVwiLHk6XCJucy1yZXNpemVcIix4eTpcIm53c2UtcmVzaXplXCIsdG9wOlwibnMtcmVzaXplXCIsbGVmdDpcImV3LXJlc2l6ZVwiLGJvdHRvbTpcIm5zLXJlc2l6ZVwiLHJpZ2h0OlwiZXctcmVzaXplXCIsdG9wbGVmdDpcIm53c2UtcmVzaXplXCIsYm90dG9tcmlnaHQ6XCJud3NlLXJlc2l6ZVwiLHRvcHJpZ2h0OlwibmVzdy1yZXNpemVcIixib3R0b21sZWZ0OlwibmVzdy1yZXNpemVcIn0sWnIuZGVmYXVsdE1hcmdpbj1uLnN1cHBvcnRzVG91Y2h8fG4uc3VwcG9ydHNQb2ludGVyRXZlbnQ/MjA6MTAsci5wcm90b3R5cGUucmVzaXphYmxlPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUsbil7aWYoVXIub2JqZWN0KGUpKXJldHVybiB0Lm9wdGlvbnMucmVzaXplLmVuYWJsZWQ9ITEhPT1lLmVuYWJsZWQsdC5zZXRQZXJBY3Rpb24oXCJyZXNpemVcIixlKSx0LnNldE9uRXZlbnRzKFwicmVzaXplXCIsZSksVXIuc3RyaW5nKGUuYXhpcykmJi9eeCR8XnkkfF54eSQvLnRlc3QoZS5heGlzKT90Lm9wdGlvbnMucmVzaXplLmF4aXM9ZS5heGlzOm51bGw9PT1lLmF4aXMmJih0Lm9wdGlvbnMucmVzaXplLmF4aXM9bi5kZWZhdWx0cy5hY3Rpb25zLnJlc2l6ZS5heGlzKSxVci5ib29sKGUucHJlc2VydmVBc3BlY3RSYXRpbyk/dC5vcHRpb25zLnJlc2l6ZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvPWUucHJlc2VydmVBc3BlY3RSYXRpbzpVci5ib29sKGUuc3F1YXJlKSYmKHQub3B0aW9ucy5yZXNpemUuc3F1YXJlPWUuc3F1YXJlKSx0O2lmKFVyLmJvb2woZSkpcmV0dXJuIHQub3B0aW9ucy5yZXNpemUuZW5hYmxlZD1lLHQ7cmV0dXJuIHQub3B0aW9ucy5yZXNpemV9KHRoaXMsdCxlKX0sdC5tYXAucmVzaXplPVpyLHQubWV0aG9kRGljdC5yZXNpemU9XCJyZXNpemFibGVcIixvLmFjdGlvbnMucmVzaXplPVpyLmRlZmF1bHRzfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3QuaW50ZXJhY3Rpb24ucmVzaXplQXhlcz1cInh5XCJ9LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1zdGFydFwiOmZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb247aWYoXCJyZXNpemVcIj09PW4ucHJlcGFyZWQubmFtZSYmbi5wcmVwYXJlZC5lZGdlcyl7dmFyIHI9ZSxvPW4ucmVjdDtuLl9yZWN0cz17c3RhcnQ6KDAscXIuZGVmYXVsdCkoe30sbyksY29ycmVjdGVkOigwLHFyLmRlZmF1bHQpKHt9LG8pLHByZXZpb3VzOigwLHFyLmRlZmF1bHQpKHt9LG8pLGRlbHRhOntsZWZ0OjAscmlnaHQ6MCx3aWR0aDowLHRvcDowLGJvdHRvbTowLGhlaWdodDowfX0sci5lZGdlcz1uLnByZXBhcmVkLmVkZ2VzLHIucmVjdD1uLl9yZWN0cy5jb3JyZWN0ZWQsci5kZWx0YVJlY3Q9bi5fcmVjdHMuZGVsdGF9fSh0KSwkcih0KX0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7dmFyIGU9dC5pRXZlbnQsbj10LmludGVyYWN0aW9uO2lmKFwicmVzaXplXCI9PT1uLnByZXBhcmVkLm5hbWUmJm4ucHJlcGFyZWQuZWRnZXMpe3ZhciByPWUsbz1uLmludGVyYWN0YWJsZS5vcHRpb25zLnJlc2l6ZS5pbnZlcnQsaT1cInJlcG9zaXRpb25cIj09PW98fFwibmVnYXRlXCI9PT1vLGE9bi5yZWN0LHU9bi5fcmVjdHMscz11LnN0YXJ0LGw9dS5jb3JyZWN0ZWQsYz11LmRlbHRhLGY9dS5wcmV2aW91cztpZigoMCxxci5kZWZhdWx0KShmLGwpLGkpe2lmKCgwLHFyLmRlZmF1bHQpKGwsYSksXCJyZXBvc2l0aW9uXCI9PT1vKXtpZihsLnRvcD5sLmJvdHRvbSl7dmFyIHA9bC50b3A7bC50b3A9bC5ib3R0b20sbC5ib3R0b209cH1pZihsLmxlZnQ+bC5yaWdodCl7dmFyIGQ9bC5sZWZ0O2wubGVmdD1sLnJpZ2h0LGwucmlnaHQ9ZH19fWVsc2UgbC50b3A9TWF0aC5taW4oYS50b3Ascy5ib3R0b20pLGwuYm90dG9tPU1hdGgubWF4KGEuYm90dG9tLHMudG9wKSxsLmxlZnQ9TWF0aC5taW4oYS5sZWZ0LHMucmlnaHQpLGwucmlnaHQ9TWF0aC5tYXgoYS5yaWdodCxzLmxlZnQpO2Zvcih2YXIgdiBpbiBsLndpZHRoPWwucmlnaHQtbC5sZWZ0LGwuaGVpZ2h0PWwuYm90dG9tLWwudG9wLGwpY1t2XT1sW3ZdLWZbdl07ci5lZGdlcz1uLnByZXBhcmVkLmVkZ2VzLHIucmVjdD1sLHIuZGVsdGFSZWN0PWN9fSh0KSwkcih0KX0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLWVuZFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbjtpZihcInJlc2l6ZVwiPT09bi5wcmVwYXJlZC5uYW1lJiZuLnByZXBhcmVkLmVkZ2VzKXt2YXIgcj1lO3IuZWRnZXM9bi5wcmVwYXJlZC5lZGdlcyxyLnJlY3Q9bi5fcmVjdHMuY29ycmVjdGVkLHIuZGVsdGFSZWN0PW4uX3JlY3RzLmRlbHRhfX0sXCJhdXRvLXN0YXJ0OmNoZWNrXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuaW50ZXJhY3RhYmxlLHI9dC5lbGVtZW50LG89dC5yZWN0LGk9dC5idXR0b25zO2lmKG8pe3ZhciBhPSgwLHFyLmRlZmF1bHQpKHt9LGUuY29vcmRzLmN1ci5wYWdlKSx1PW4ub3B0aW9ucy5yZXNpemU7aWYodSYmdS5lbmFibGVkJiYoIWUucG9pbnRlcklzRG93bnx8IS9tb3VzZXxwb2ludGVyLy50ZXN0KGUucG9pbnRlclR5cGUpfHwwIT0oaSZ1Lm1vdXNlQnV0dG9ucykpKXtpZihVci5vYmplY3QodS5lZGdlcykpe3ZhciBzPXtsZWZ0OiExLHJpZ2h0OiExLHRvcDohMSxib3R0b206ITF9O2Zvcih2YXIgbCBpbiBzKXNbbF09S3IobCx1LmVkZ2VzW2xdLGEsZS5fbGF0ZXN0UG9pbnRlci5ldmVudFRhcmdldCxyLG8sdS5tYXJnaW58fFpyLmRlZmF1bHRNYXJnaW4pO3MubGVmdD1zLmxlZnQmJiFzLnJpZ2h0LHMudG9wPXMudG9wJiYhcy5ib3R0b20sKHMubGVmdHx8cy5yaWdodHx8cy50b3B8fHMuYm90dG9tKSYmKHQuYWN0aW9uPXtuYW1lOlwicmVzaXplXCIsZWRnZXM6c30pfWVsc2V7dmFyIGM9XCJ5XCIhPT11LmF4aXMmJmEueD5vLnJpZ2h0LVpyLmRlZmF1bHRNYXJnaW4sZj1cInhcIiE9PXUuYXhpcyYmYS55Pm8uYm90dG9tLVpyLmRlZmF1bHRNYXJnaW47KGN8fGYpJiYodC5hY3Rpb249e25hbWU6XCJyZXNpemVcIixheGVzOihjP1wieFwiOlwiXCIpKyhmP1wieVwiOlwiXCIpfSl9cmV0dXJuIXQuYWN0aW9uJiZ2b2lkIDB9fX19LGRlZmF1bHRzOntzcXVhcmU6ITEscHJlc2VydmVBc3BlY3RSYXRpbzohMSxheGlzOlwieHlcIixtYXJnaW46TmFOLGVkZ2VzOm51bGwsaW52ZXJ0Olwibm9uZVwifSxjdXJzb3JzOm51bGwsZ2V0Q3Vyc29yOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZWRnZXMsbj10LmF4aXMscj10Lm5hbWUsbz1aci5jdXJzb3JzLGk9bnVsbDtpZihuKWk9b1tyK25dO2Vsc2UgaWYoZSl7Zm9yKHZhciBhPVwiXCIsdT1bXCJ0b3BcIixcImJvdHRvbVwiLFwibGVmdFwiLFwicmlnaHRcIl0scz0wO3M8dS5sZW5ndGg7cysrKXt2YXIgbD11W3NdO2VbbF0mJihhKz1sKX1pPW9bYV19cmV0dXJuIGl9LGRlZmF1bHRNYXJnaW46bnVsbH0sSnI9WnI7TnIuZGVmYXVsdD1Kcjt2YXIgUXI9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KFFyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRcixcImRyYWdcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdG8uZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoUXIsXCJkcm9wXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVvLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFFyLFwiZ2VzdHVyZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuby5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRcixcInJlc2l6ZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByby5kZWZhdWx0fX0pLFFyLmRlZmF1bHQ9dm9pZCAwO3ZhciB0bz1vbyh2KSxlbz1vbyhtciksbm89b28oQXIpLHJvPW9vKE5yKTtmdW5jdGlvbiBvbyh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19dmFyIGlvPXtpZDpcImFjdGlvbnNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3QudXNlUGx1Z2luKG5vLmRlZmF1bHQpLHQudXNlUGx1Z2luKHJvLmRlZmF1bHQpLHQudXNlUGx1Z2luKHRvLmRlZmF1bHQpLHQudXNlUGx1Z2luKGVvLmRlZmF1bHQpfX07UXIuZGVmYXVsdD1pbzt2YXIgYW89e307T2JqZWN0LmRlZmluZVByb3BlcnR5KGFvLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGFvLmRlZmF1bHQ9dm9pZCAwO2FvLmRlZmF1bHQ9e307dmFyIHVvPXt9O2Z1bmN0aW9uIHNvKHQpe3JldHVybihzbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHVvLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHVvLmdldENvbnRhaW5lcj1nbyx1by5nZXRTY3JvbGw9Ym8sdW8uZ2V0U2Nyb2xsU2l6ZT1mdW5jdGlvbih0KXtmby53aW5kb3codCkmJih0PXdpbmRvdy5kb2N1bWVudC5ib2R5KTtyZXR1cm57eDp0LnNjcm9sbFdpZHRoLHk6dC5zY3JvbGxIZWlnaHR9fSx1by5nZXRTY3JvbGxTaXplRGVsdGE9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5lbGVtZW50LG89biYmbi5pbnRlcmFjdGFibGUub3B0aW9uc1tuLnByZXBhcmVkLm5hbWVdLmF1dG9TY3JvbGw7aWYoIW98fCFvLmVuYWJsZWQpcmV0dXJuIGUoKSx7eDowLHk6MH07dmFyIGk9Z28oby5jb250YWluZXIsbi5pbnRlcmFjdGFibGUsciksYT1ibyhpKTtlKCk7dmFyIHU9Ym8oaSk7cmV0dXJue3g6dS54LWEueCx5OnUueS1hLnl9fSx1by5kZWZhdWx0PXZvaWQgMDt2YXIgbG8sY289eW8oJCksZm89eW8odykscG89KGxvPW9lKSYmbG8uX19lc01vZHVsZT9sbzp7ZGVmYXVsdDpsb307ZnVuY3Rpb24gdm8oKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiB2bz1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIHlvKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PXNvKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPXZvKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59dmFyIGhvPXtkZWZhdWx0czp7ZW5hYmxlZDohMSxtYXJnaW46NjAsY29udGFpbmVyOm51bGwsc3BlZWQ6MzAwfSxub3c6RGF0ZS5ub3csaW50ZXJhY3Rpb246bnVsbCxpOjAseDowLHk6MCxpc1Njcm9sbGluZzohMSxwcmV2VGltZTowLG1hcmdpbjowLHNwZWVkOjAsc3RhcnQ6ZnVuY3Rpb24odCl7aG8uaXNTY3JvbGxpbmc9ITAscG8uZGVmYXVsdC5jYW5jZWwoaG8uaSksKHQuYXV0b1Njcm9sbD1obykuaW50ZXJhY3Rpb249dCxoby5wcmV2VGltZT1oby5ub3coKSxoby5pPXBvLmRlZmF1bHQucmVxdWVzdChoby5zY3JvbGwpfSxzdG9wOmZ1bmN0aW9uKCl7aG8uaXNTY3JvbGxpbmc9ITEsaG8uaW50ZXJhY3Rpb24mJihoby5pbnRlcmFjdGlvbi5hdXRvU2Nyb2xsPW51bGwpLHBvLmRlZmF1bHQuY2FuY2VsKGhvLmkpfSxzY3JvbGw6ZnVuY3Rpb24oKXt2YXIgdD1oby5pbnRlcmFjdGlvbixlPXQuaW50ZXJhY3RhYmxlLG49dC5lbGVtZW50LHI9dC5wcmVwYXJlZC5uYW1lLG89ZS5vcHRpb25zW3JdLmF1dG9TY3JvbGwsaT1nbyhvLmNvbnRhaW5lcixlLG4pLGE9aG8ubm93KCksdT0oYS1oby5wcmV2VGltZSkvMWUzLHM9by5zcGVlZCp1O2lmKDE8PXMpe3ZhciBsPXt4OmhvLngqcyx5OmhvLnkqc307aWYobC54fHxsLnkpe3ZhciBjPWJvKGkpO2ZvLndpbmRvdyhpKT9pLnNjcm9sbEJ5KGwueCxsLnkpOmkmJihpLnNjcm9sbExlZnQrPWwueCxpLnNjcm9sbFRvcCs9bC55KTt2YXIgZj1ibyhpKSxwPXt4OmYueC1jLngseTpmLnktYy55fTsocC54fHxwLnkpJiZlLmZpcmUoe3R5cGU6XCJhdXRvc2Nyb2xsXCIsdGFyZ2V0Om4saW50ZXJhY3RhYmxlOmUsZGVsdGE6cCxpbnRlcmFjdGlvbjp0LGNvbnRhaW5lcjppfSl9aG8ucHJldlRpbWU9YX1oby5pc1Njcm9sbGluZyYmKHBvLmRlZmF1bHQuY2FuY2VsKGhvLmkpLGhvLmk9cG8uZGVmYXVsdC5yZXF1ZXN0KGhvLnNjcm9sbCkpfSxjaGVjazpmdW5jdGlvbih0LGUpe3ZhciBuPXQub3B0aW9ucztyZXR1cm4gbltlXS5hdXRvU2Nyb2xsJiZuW2VdLmF1dG9TY3JvbGwuZW5hYmxlZH0sb25JbnRlcmFjdGlvbk1vdmU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQucG9pbnRlcjtpZihlLmludGVyYWN0aW5nKCkmJmhvLmNoZWNrKGUuaW50ZXJhY3RhYmxlLGUucHJlcGFyZWQubmFtZSkpaWYoZS5zaW11bGF0aW9uKWhvLng9aG8ueT0wO2Vsc2V7dmFyIHIsbyxpLGEsdT1lLmludGVyYWN0YWJsZSxzPWUuZWxlbWVudCxsPWUucHJlcGFyZWQubmFtZSxjPXUub3B0aW9uc1tsXS5hdXRvU2Nyb2xsLGY9Z28oYy5jb250YWluZXIsdSxzKTtpZihmby53aW5kb3coZikpYT1uLmNsaWVudFg8aG8ubWFyZ2luLHI9bi5jbGllbnRZPGhvLm1hcmdpbixvPW4uY2xpZW50WD5mLmlubmVyV2lkdGgtaG8ubWFyZ2luLGk9bi5jbGllbnRZPmYuaW5uZXJIZWlnaHQtaG8ubWFyZ2luO2Vsc2V7dmFyIHA9Y28uZ2V0RWxlbWVudENsaWVudFJlY3QoZik7YT1uLmNsaWVudFg8cC5sZWZ0K2hvLm1hcmdpbixyPW4uY2xpZW50WTxwLnRvcCtoby5tYXJnaW4sbz1uLmNsaWVudFg+cC5yaWdodC1oby5tYXJnaW4saT1uLmNsaWVudFk+cC5ib3R0b20taG8ubWFyZ2lufWhvLng9bz8xOmE/LTE6MCxoby55PWk/MTpyPy0xOjAsaG8uaXNTY3JvbGxpbmd8fChoby5tYXJnaW49Yy5tYXJnaW4saG8uc3BlZWQ9Yy5zcGVlZCxoby5zdGFydChlKSl9fX07ZnVuY3Rpb24gZ28odCxlLG4pe3JldHVybihmby5zdHJpbmcodCk/KDAsJHQuZ2V0U3RyaW5nT3B0aW9uUmVzdWx0KSh0LGUsbik6dCl8fCgwLE8uZ2V0V2luZG93KShuKX1mdW5jdGlvbiBibyh0KXtyZXR1cm4gZm8ud2luZG93KHQpJiYodD13aW5kb3cuZG9jdW1lbnQuYm9keSkse3g6dC5zY3JvbGxMZWZ0LHk6dC5zY3JvbGxUb3B9fXZhciBtbz17aWQ6XCJhdXRvLXNjcm9sbFwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5kZWZhdWx0cyxuPXQuYWN0aW9uczsodC5hdXRvU2Nyb2xsPWhvKS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gdC5ub3coKX0sbi5waGFzZWxlc3NUeXBlcy5hdXRvc2Nyb2xsPSEwLGUucGVyQWN0aW9uLmF1dG9TY3JvbGw9aG8uZGVmYXVsdHN9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5hdXRvU2Nyb2xsPW51bGx9LFwiaW50ZXJhY3Rpb25zOmRlc3Ryb3lcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLmF1dG9TY3JvbGw9bnVsbCxoby5zdG9wKCksaG8uaW50ZXJhY3Rpb24mJihoby5pbnRlcmFjdGlvbj1udWxsKX0sXCJpbnRlcmFjdGlvbnM6c3RvcFwiOmhvLnN0b3AsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0KXtyZXR1cm4gaG8ub25JbnRlcmFjdGlvbk1vdmUodCl9fX07dW8uZGVmYXVsdD1tbzt2YXIgT289e307ZnVuY3Rpb24gd28odCl7cmV0dXJuKHdvPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoT28sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksT28uZGVmYXVsdD12b2lkIDA7dmFyIF9vPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PXdvKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPVBvKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHcpO2Z1bmN0aW9uIFBvKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gUG89ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiB4byh0KXtyZXR1cm4gX28uYm9vbCh0KT8odGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yPXQsdGhpcyk6bnVsbD09PXQ/KGRlbGV0ZSB0aGlzLm9wdGlvbnMuc3R5bGVDdXJzb3IsdGhpcyk6dGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yfWZ1bmN0aW9uIFNvKHQpe3JldHVybiBfby5mdW5jKHQpPyh0aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlcj10LHRoaXMpOm51bGw9PT10PyhkZWxldGUgdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXIsdGhpcyk6dGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXJ9dmFyIGpvPXtpZDpcImF1dG8tc3RhcnQvaW50ZXJhY3RhYmxlTWV0aG9kc1wiLGluc3RhbGw6ZnVuY3Rpb24oZCl7dmFyIHQ9ZC5JbnRlcmFjdGFibGU7dC5wcm90b3R5cGUuZ2V0QWN0aW9uPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvLGksYSx1LHMsbCxjLGYscD0oaT1lLGE9bix1PXIscz1kLGw9KG89dGhpcykuZ2V0UmVjdCh1KSxjPWkuYnV0dG9uc3x8ezA6MSwxOjQsMzo4LDQ6MTZ9W2kuYnV0dG9uXSxmPXthY3Rpb246bnVsbCxpbnRlcmFjdGFibGU6byxpbnRlcmFjdGlvbjphLGVsZW1lbnQ6dSxyZWN0OmwsYnV0dG9uczpjfSxzLmZpcmUoXCJhdXRvLXN0YXJ0OmNoZWNrXCIsZiksZi5hY3Rpb24pO3JldHVybiB0aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlcj90aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlcih0LGUscCx0aGlzLHIsbik6cH0sdC5wcm90b3R5cGUuaWdub3JlRnJvbT0oMCxsZS53YXJuT25jZSkoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2JhY2tDb21wYXRPcHRpb24oXCJpZ25vcmVGcm9tXCIsdCl9LFwiSW50ZXJhY3RhYmxlLmlnbm9yZUZyb20oKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgSW50ZXJhY3RibGUuZHJhZ2dhYmxlKHtpZ25vcmVGcm9tOiBuZXdWYWx1ZX0pLlwiKSx0LnByb3RvdHlwZS5hbGxvd0Zyb209KDAsbGUud2Fybk9uY2UpKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9iYWNrQ29tcGF0T3B0aW9uKFwiYWxsb3dGcm9tXCIsdCl9LFwiSW50ZXJhY3RhYmxlLmFsbG93RnJvbSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBJbnRlcmFjdGJsZS5kcmFnZ2FibGUoe2FsbG93RnJvbTogbmV3VmFsdWV9KS5cIiksdC5wcm90b3R5cGUuYWN0aW9uQ2hlY2tlcj1Tbyx0LnByb3RvdHlwZS5zdHlsZUN1cnNvcj14b319O09vLmRlZmF1bHQ9am87dmFyIE1vPXt9O2Z1bmN0aW9uIGtvKHQpe3JldHVybihrbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KE1vLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE1vLmRlZmF1bHQ9dm9pZCAwO3ZhciBFbyxUbz1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1rbyh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1JbygpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufShsZSksRG89KEVvPU9vKSYmRW8uX19lc01vZHVsZT9Fbzp7ZGVmYXVsdDpFb307ZnVuY3Rpb24gSW8oKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBJbz1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIHpvKHQsZSxuLHIsbyl7cmV0dXJuIGUudGVzdElnbm9yZUFsbG93KGUub3B0aW9uc1t0Lm5hbWVdLG4scikmJmUub3B0aW9uc1t0Lm5hbWVdLmVuYWJsZWQmJlJvKGUsbix0LG8pP3Q6bnVsbH1mdW5jdGlvbiBBbyh0LGUsbixyLG8saSxhKXtmb3IodmFyIHU9MCxzPXIubGVuZ3RoO3U8czt1Kyspe3ZhciBsPXJbdV0sYz1vW3VdLGY9bC5nZXRBY3Rpb24oZSxuLHQsYyk7aWYoZil7dmFyIHA9em8oZixsLGMsaSxhKTtpZihwKXJldHVybnthY3Rpb246cCxpbnRlcmFjdGFibGU6bCxlbGVtZW50OmN9fX1yZXR1cm57YWN0aW9uOm51bGwsaW50ZXJhY3RhYmxlOm51bGwsZWxlbWVudDpudWxsfX1mdW5jdGlvbiBDbyh0LGUsbixyLG8pe3ZhciBpPVtdLGE9W10sdT1yO2Z1bmN0aW9uIHModCl7aS5wdXNoKHQpLGEucHVzaCh1KX1mb3IoO1RvLmlzLmVsZW1lbnQodSk7KXtpPVtdLGE9W10sby5pbnRlcmFjdGFibGVzLmZvckVhY2hNYXRjaCh1LHMpO3ZhciBsPUFvKHQsZSxuLGksYSxyLG8pO2lmKGwuYWN0aW9uJiYhbC5pbnRlcmFjdGFibGUub3B0aW9uc1tsLmFjdGlvbi5uYW1lXS5tYW51YWxTdGFydClyZXR1cm4gbDt1PVRvLmRvbS5wYXJlbnROb2RlKHUpfXJldHVybnthY3Rpb246bnVsbCxpbnRlcmFjdGFibGU6bnVsbCxlbGVtZW50Om51bGx9fWZ1bmN0aW9uIFdvKHQsZSxuKXt2YXIgcj1lLmFjdGlvbixvPWUuaW50ZXJhY3RhYmxlLGk9ZS5lbGVtZW50O3I9cnx8e25hbWU6bnVsbH0sdC5pbnRlcmFjdGFibGU9byx0LmVsZW1lbnQ9aSxUby5jb3B5QWN0aW9uKHQucHJlcGFyZWQsciksdC5yZWN0PW8mJnIubmFtZT9vLmdldFJlY3QoaSk6bnVsbCxZbyh0LG4pLG4uZmlyZShcImF1dG9TdGFydDpwcmVwYXJlZFwiLHtpbnRlcmFjdGlvbjp0fSl9ZnVuY3Rpb24gUm8odCxlLG4scil7dmFyIG89dC5vcHRpb25zLGk9b1tuLm5hbWVdLm1heCxhPW9bbi5uYW1lXS5tYXhQZXJFbGVtZW50LHU9ci5hdXRvU3RhcnQubWF4SW50ZXJhY3Rpb25zLHM9MCxsPTAsYz0wO2lmKCEoaSYmYSYmdSkpcmV0dXJuITE7Zm9yKHZhciBmPTA7ZjxyLmludGVyYWN0aW9ucy5saXN0Lmxlbmd0aDtmKyspe3ZhciBwPXIuaW50ZXJhY3Rpb25zLmxpc3RbZl0sZD1wLnByZXBhcmVkLm5hbWU7aWYocC5pbnRlcmFjdGluZygpKXtpZih1PD0rK3MpcmV0dXJuITE7aWYocC5pbnRlcmFjdGFibGU9PT10KXtpZihpPD0obCs9ZD09PW4ubmFtZT8xOjApKXJldHVybiExO2lmKHAuZWxlbWVudD09PWUmJihjKyssZD09PW4ubmFtZSYmYTw9YykpcmV0dXJuITF9fX1yZXR1cm4gMDx1fWZ1bmN0aW9uIEZvKHQsZSl7cmV0dXJuIFRvLmlzLm51bWJlcih0KT8oZS5hdXRvU3RhcnQubWF4SW50ZXJhY3Rpb25zPXQsdGhpcyk6ZS5hdXRvU3RhcnQubWF4SW50ZXJhY3Rpb25zfWZ1bmN0aW9uIFhvKHQsZSxuKXt2YXIgcj1uLmF1dG9TdGFydC5jdXJzb3JFbGVtZW50O3ImJnIhPT10JiYoci5zdHlsZS5jdXJzb3I9XCJcIiksdC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3I9ZSx0LnN0eWxlLmN1cnNvcj1lLG4uYXV0b1N0YXJ0LmN1cnNvckVsZW1lbnQ9ZT90Om51bGx9ZnVuY3Rpb24gWW8odCxlKXt2YXIgbj10LmludGVyYWN0YWJsZSxyPXQuZWxlbWVudCxvPXQucHJlcGFyZWQ7aWYoXCJtb3VzZVwiPT09dC5wb2ludGVyVHlwZSYmbiYmbi5vcHRpb25zLnN0eWxlQ3Vyc29yKXt2YXIgaT1cIlwiO2lmKG8ubmFtZSl7dmFyIGE9bi5vcHRpb25zW28ubmFtZV0uY3Vyc29yQ2hlY2tlcjtpPVRvLmlzLmZ1bmMoYSk/YShvLG4scix0Ll9pbnRlcmFjdGluZyk6ZS5hY3Rpb25zLm1hcFtvLm5hbWVdLmdldEN1cnNvcihvKX1Ybyh0LmVsZW1lbnQsaXx8XCJcIixlKX1lbHNlIGUuYXV0b1N0YXJ0LmN1cnNvckVsZW1lbnQmJlhvKGUuYXV0b1N0YXJ0LmN1cnNvckVsZW1lbnQsXCJcIixlKX12YXIgTm89e2lkOlwiYXV0by1zdGFydC9iYXNlXCIsYmVmb3JlOltcImFjdGlvbnNcIixcImFjdGlvbnMvZHJhZ1wiLFwiYWN0aW9ucy9yZXNpemVcIixcImFjdGlvbnMvZ2VzdHVyZVwiXSxpbnN0YWxsOmZ1bmN0aW9uKGUpe3ZhciB0PWUuaW50ZXJhY3RTdGF0aWMsbj1lLmRlZmF1bHRzO2UudXNlUGx1Z2luKERvLmRlZmF1bHQpLG4uYmFzZS5hY3Rpb25DaGVja2VyPW51bGwsbi5iYXNlLnN0eWxlQ3Vyc29yPSEwLFRvLmV4dGVuZChuLnBlckFjdGlvbix7bWFudWFsU3RhcnQ6ITEsbWF4OjEvMCxtYXhQZXJFbGVtZW50OjEsYWxsb3dGcm9tOm51bGwsaWdub3JlRnJvbTpudWxsLG1vdXNlQnV0dG9uczoxfSksdC5tYXhJbnRlcmFjdGlvbnM9ZnVuY3Rpb24odCl7cmV0dXJuIEZvKHQsZSl9LGUuYXV0b1N0YXJ0PXttYXhJbnRlcmFjdGlvbnM6MS8wLHdpdGhpbkludGVyYWN0aW9uTGltaXQ6Um8sY3Vyc29yRWxlbWVudDpudWxsfX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpkb3duXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyLG89dC5ldmVudCxpPXQuZXZlbnRUYXJnZXQ7bi5pbnRlcmFjdGluZygpfHxXbyhuLENvKG4scixvLGksZSksZSl9LFwiaW50ZXJhY3Rpb25zOm1vdmVcIjpmdW5jdGlvbih0LGUpe3ZhciBuLHIsbyxpLGEsdTtyPWUsbz0obj10KS5pbnRlcmFjdGlvbixpPW4ucG9pbnRlcixhPW4uZXZlbnQsdT1uLmV2ZW50VGFyZ2V0LFwibW91c2VcIiE9PW8ucG9pbnRlclR5cGV8fG8ucG9pbnRlcklzRG93bnx8by5pbnRlcmFjdGluZygpfHxXbyhvLENvKG8saSxhLHUsciksciksZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uO2lmKG4ucG9pbnRlcklzRG93biYmIW4uaW50ZXJhY3RpbmcoKSYmbi5wb2ludGVyV2FzTW92ZWQmJm4ucHJlcGFyZWQubmFtZSl7ZS5maXJlKFwiYXV0b1N0YXJ0OmJlZm9yZS1zdGFydFwiLHQpO3ZhciByPW4uaW50ZXJhY3RhYmxlLG89bi5wcmVwYXJlZC5uYW1lO28mJnImJihyLm9wdGlvbnNbb10ubWFudWFsU3RhcnR8fCFSbyhyLG4uZWxlbWVudCxuLnByZXBhcmVkLGUpP24uc3RvcCgpOihuLnN0YXJ0KG4ucHJlcGFyZWQscixuLmVsZW1lbnQpLFlvKG4sZSkpKX19KHQsZSl9LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj1uLmludGVyYWN0YWJsZTtyJiZyLm9wdGlvbnMuc3R5bGVDdXJzb3ImJlhvKG4uZWxlbWVudCxcIlwiLGUpfX0sbWF4SW50ZXJhY3Rpb25zOkZvLHdpdGhpbkludGVyYWN0aW9uTGltaXQ6Um8sdmFsaWRhdGVBY3Rpb246em99O01vLmRlZmF1bHQ9Tm87dmFyIExvPXt9O2Z1bmN0aW9uIEJvKHQpe3JldHVybihCbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KExvLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLExvLmRlZmF1bHQ9dm9pZCAwO3ZhciBWbyxxbz1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1Cbyh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1HbygpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh3KSxVbz0oVm89TW8pJiZWby5fX2VzTW9kdWxlP1ZvOntkZWZhdWx0OlZvfTtmdW5jdGlvbiBHbygpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIEdvPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9dmFyIEhvPXtpZDpcImF1dG8tc3RhcnQvZHJhZ0F4aXNcIixsaXN0ZW5lcnM6e1wiYXV0b1N0YXJ0OmJlZm9yZS1zdGFydFwiOmZ1bmN0aW9uKHQscil7dmFyIG89dC5pbnRlcmFjdGlvbixpPXQuZXZlbnRUYXJnZXQsZT10LmR4LG49dC5keTtpZihcImRyYWdcIj09PW8ucHJlcGFyZWQubmFtZSl7dmFyIGE9TWF0aC5hYnMoZSksdT1NYXRoLmFicyhuKSxzPW8uaW50ZXJhY3RhYmxlLm9wdGlvbnMuZHJhZyxsPXMuc3RhcnRBeGlzLGM9dTxhP1wieFwiOmE8dT9cInlcIjpcInh5XCI7aWYoby5wcmVwYXJlZC5heGlzPVwic3RhcnRcIj09PXMubG9ja0F4aXM/Y1swXTpzLmxvY2tBeGlzLFwieHlcIiE9YyYmXCJ4eVwiIT09bCYmbCE9PWMpe28ucHJlcGFyZWQubmFtZT1udWxsO2Z1bmN0aW9uIGYodCl7aWYodCE9PW8uaW50ZXJhY3RhYmxlKXt2YXIgZT1vLmludGVyYWN0YWJsZS5vcHRpb25zLmRyYWc7aWYoIWUubWFudWFsU3RhcnQmJnQudGVzdElnbm9yZUFsbG93KGUscCxpKSl7dmFyIG49dC5nZXRBY3Rpb24oby5kb3duUG9pbnRlcixvLmRvd25FdmVudCxvLHApO2lmKG4mJlwiZHJhZ1wiPT09bi5uYW1lJiZmdW5jdGlvbih0LGUpe2lmKCFlKXJldHVybjt2YXIgbj1lLm9wdGlvbnMuZHJhZy5zdGFydEF4aXM7cmV0dXJuXCJ4eVwiPT09dHx8XCJ4eVwiPT09bnx8bj09PXR9KGMsdCkmJlVvLmRlZmF1bHQudmFsaWRhdGVBY3Rpb24obix0LHAsaSxyKSlyZXR1cm4gdH19fWZvcih2YXIgcD1pO3FvLmVsZW1lbnQocCk7KXt2YXIgZD1yLmludGVyYWN0YWJsZXMuZm9yRWFjaE1hdGNoKHAsZik7aWYoZCl7by5wcmVwYXJlZC5uYW1lPVwiZHJhZ1wiLG8uaW50ZXJhY3RhYmxlPWQsby5lbGVtZW50PXA7YnJlYWt9cD0oMCwkLnBhcmVudE5vZGUpKHApfX19fX19O0xvLmRlZmF1bHQ9SG87dmFyIEtvPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShLbyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxLby5kZWZhdWx0PXZvaWQgMDt2YXIgJG8sWm89KCRvPU1vKSYmJG8uX19lc01vZHVsZT8kbzp7ZGVmYXVsdDokb307ZnVuY3Rpb24gSm8odCl7dmFyIGU9dC5wcmVwYXJlZCYmdC5wcmVwYXJlZC5uYW1lO2lmKCFlKXJldHVybiBudWxsO3ZhciBuPXQuaW50ZXJhY3RhYmxlLm9wdGlvbnM7cmV0dXJuIG5bZV0uaG9sZHx8bltlXS5kZWxheX12YXIgUW89e2lkOlwiYXV0by1zdGFydC9ob2xkXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmRlZmF1bHRzO3QudXNlUGx1Z2luKFpvLmRlZmF1bHQpLGUucGVyQWN0aW9uLmhvbGQ9MCxlLnBlckFjdGlvbi5kZWxheT0wfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3QuaW50ZXJhY3Rpb24uYXV0b1N0YXJ0SG9sZFRpbWVyPW51bGx9LFwiYXV0b1N0YXJ0OnByZXBhcmVkXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPUpvKGUpOzA8biYmKGUuYXV0b1N0YXJ0SG9sZFRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLnN0YXJ0KGUucHJlcGFyZWQsZS5pbnRlcmFjdGFibGUsZS5lbGVtZW50KX0sbikpfSxcImludGVyYWN0aW9uczptb3ZlXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuZHVwbGljYXRlO2UucG9pbnRlcldhc01vdmVkJiYhbiYmY2xlYXJUaW1lb3V0KGUuYXV0b1N0YXJ0SG9sZFRpbWVyKX0sXCJhdXRvU3RhcnQ6YmVmb3JlLXN0YXJ0XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjswPEpvKGUpJiYoZS5wcmVwYXJlZC5uYW1lPW51bGwpfX0sZ2V0SG9sZER1cmF0aW9uOkpvfTtLby5kZWZhdWx0PVFvO3ZhciB0aT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRpLFwiYXV0b1N0YXJ0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVpLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRpLFwiZHJhZ0F4aXNcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbmkuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGksXCJob2xkXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJpLmRlZmF1bHR9fSksdGkuZGVmYXVsdD12b2lkIDA7dmFyIGVpPW9pKE1vKSxuaT1vaShMbykscmk9b2koS28pO2Z1bmN0aW9uIG9pKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX12YXIgaWk9e2lkOlwiYXV0by1zdGFydFwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC51c2VQbHVnaW4oZWkuZGVmYXVsdCksdC51c2VQbHVnaW4ocmkuZGVmYXVsdCksdC51c2VQbHVnaW4obmkuZGVmYXVsdCl9fTt0aS5kZWZhdWx0PWlpO3ZhciBhaT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYWksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksYWkuZGVmYXVsdD12b2lkIDA7YWkuZGVmYXVsdD17fTt2YXIgdWk9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHVpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHVpLmRlZmF1bHQ9dm9pZCAwO3VpLmRlZmF1bHQ9e307dmFyIHNpPXt9O2Z1bmN0aW9uIGxpKHQpe3JldHVybihsaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHNpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHNpLmRlZmF1bHQ9dm9pZCAwO3ZhciBjaSxmaSxwaT1oaShEKSxkaT0oaGkoY3QpLGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWxpKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPXlpKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHcpKSx2aT1oaShPKTtmdW5jdGlvbiB5aSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIHlpPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gaGkodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fShmaT1jaT1jaXx8e30pLnRvdWNoQWN0aW9uPVwidG91Y2hBY3Rpb25cIixmaS5ib3hTaXppbmc9XCJib3hTaXppbmdcIixmaS5ub0xpc3RlbmVycz1cIm5vTGlzdGVuZXJzXCI7dmFyIGdpPXt0b3VjaEFjdGlvbjpcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy90b3VjaC1hY3Rpb25cIixib3hTaXppbmc6XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvYm94LXNpemluZ1wifTtjaS50b3VjaEFjdGlvbixjaS5ib3hTaXppbmcsY2kubm9MaXN0ZW5lcnM7ZnVuY3Rpb24gYmkodCxlLG4pe3JldHVybiBuLnRlc3QodC5zdHlsZVtlXXx8dmkuZGVmYXVsdC53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KVtlXSl9dmFyIG1pPVwiZGV2LXRvb2xzXCIsT2k9e2lkOm1pLGluc3RhbGw6ZnVuY3Rpb24oKXt9fTtzaS5kZWZhdWx0PU9pO3ZhciB3aT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkod2ksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksd2kuZGVmYXVsdD12b2lkIDA7d2kuZGVmYXVsdD17fTt2YXIgX2k9e307ZnVuY3Rpb24gUGkodCl7cmV0dXJuKFBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoX2ksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksX2kuZ2V0UmVjdE9mZnNldD1BaSxfaS5kZWZhdWx0PXZvaWQgMDt2YXIgeGk9a2koViksU2k9a2koY3QpLGppPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PVBpKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPU1pKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KCR0KTtmdW5jdGlvbiBNaSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIE1pPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24ga2kodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIEVpKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHR9KHQpfHxmdW5jdGlvbih0LGUpe2lmKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkpcmV0dXJuO3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHU9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7cnx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufSh0LGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfWZ1bmN0aW9uIFRpKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBEaSh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIElpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMuaW50ZXJhY3Rpb249dCxEaSh0aGlzLFwic3RhdGVzXCIsW10pLERpKHRoaXMsXCJzdGFydE9mZnNldFwiLHtsZWZ0OjAscmlnaHQ6MCx0b3A6MCxib3R0b206MH0pLERpKHRoaXMsXCJzdGFydERlbHRhXCIsbnVsbCksRGkodGhpcyxcInJlc3VsdFwiLG51bGwpLERpKHRoaXMsXCJlbmRSZXN1bHRcIixudWxsKSxEaSh0aGlzLFwiZWRnZXNcIix2b2lkIDApLHRoaXMucmVzdWx0PXppKCl9dmFyIHQsbixyO3JldHVybiB0PWUsKG49W3trZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5waGFzZSxyPXRoaXMuaW50ZXJhY3Rpb24sbz1mdW5jdGlvbih0KXt2YXIgbj10LmludGVyYWN0YWJsZS5vcHRpb25zW3QucHJlcGFyZWQubmFtZV0sZT1uLm1vZGlmaWVycztpZihlJiZlLmxlbmd0aClyZXR1cm4gZS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIXQub3B0aW9uc3x8ITEhPT10Lm9wdGlvbnMuZW5hYmxlZH0pO3JldHVybltcInNuYXBcIixcInNuYXBTaXplXCIsXCJzbmFwRWRnZXNcIixcInJlc3RyaWN0XCIsXCJyZXN0cmljdEVkZ2VzXCIsXCJyZXN0cmljdFNpemVcIl0ubWFwKGZ1bmN0aW9uKHQpe3ZhciBlPW5bdF07cmV0dXJuIGUmJmUuZW5hYmxlZCYme29wdGlvbnM6ZSxtZXRob2RzOmUuX21ldGhvZHN9fSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiEhdH0pfShyKTt0aGlzLnByZXBhcmVTdGF0ZXMobyksdGhpcy5lZGdlcz0oMCxTaS5kZWZhdWx0KSh7fSxyLmVkZ2VzKSx0aGlzLnN0YXJ0T2Zmc2V0PUFpKHIucmVjdCxlKTt2YXIgaT17cGhhc2U6bixwYWdlQ29vcmRzOmUscHJlRW5kOiEodGhpcy5zdGFydERlbHRhPXt4OjAseTowfSl9O3JldHVybiB0aGlzLnJlc3VsdD16aSgpLHRoaXMuc3RhcnRBbGwoaSksdGhpcy5yZXN1bHQ9dGhpcy5zZXRBbGwoaSl9fSx7a2V5OlwiZmlsbEFyZ1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaW50ZXJhY3Rpb247dC5pbnRlcmFjdGlvbj1lLHQuaW50ZXJhY3RhYmxlPWUuaW50ZXJhY3RhYmxlLHQuZWxlbWVudD1lLmVsZW1lbnQsdC5yZWN0PXQucmVjdHx8ZS5yZWN0LHQuZWRnZXM9dGhpcy5lZGdlcyx0LnN0YXJ0T2Zmc2V0PXRoaXMuc3RhcnRPZmZzZXR9fSx7a2V5Olwic3RhcnRBbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmZpbGxBcmcodCk7Zm9yKHZhciBlPTA7ZTx0aGlzLnN0YXRlcy5sZW5ndGg7ZSsrKXt2YXIgbj10aGlzLnN0YXRlc1tlXTtuLm1ldGhvZHMuc3RhcnQmJih0LnN0YXRlPW4pLm1ldGhvZHMuc3RhcnQodCl9fX0se2tleTpcInNldEFsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuZmlsbEFyZyh0KTt2YXIgZT10LnBoYXNlLG49dC5wcmVFbmQscj10LnNraXBNb2RpZmllcnMsbz10LnJlY3Q7dC5jb29yZHM9KDAsU2kuZGVmYXVsdCkoe30sdC5wYWdlQ29vcmRzKSx0LnJlY3Q9KDAsU2kuZGVmYXVsdCkoe30sbyk7Zm9yKHZhciBpPXI/dGhpcy5zdGF0ZXMuc2xpY2Uocik6dGhpcy5zdGF0ZXMsYT16aSh0LmNvb3Jkcyx0LnJlY3QpLHU9MDt1PGkubGVuZ3RoO3UrKyl7dmFyIHM9aVt1XSxsPXMub3B0aW9ucyxjPSgwLFNpLmRlZmF1bHQpKHt9LHQuY29vcmRzKSxmPW51bGw7cy5tZXRob2RzLnNldCYmdGhpcy5zaG91bGREbyhsLG4sZSkmJihmPSh0LnN0YXRlPXMpLm1ldGhvZHMuc2V0KHQpLGppLmFkZEVkZ2VzKHRoaXMuaW50ZXJhY3Rpb24uZWRnZXMsdC5yZWN0LHt4OnQuY29vcmRzLngtYy54LHk6dC5jb29yZHMueS1jLnl9KSksYS5ldmVudFByb3BzLnB1c2goZil9YS5kZWx0YS54PXQuY29vcmRzLngtdC5wYWdlQ29vcmRzLngsYS5kZWx0YS55PXQuY29vcmRzLnktdC5wYWdlQ29vcmRzLnksYS5yZWN0RGVsdGEubGVmdD10LnJlY3QubGVmdC1vLmxlZnQsYS5yZWN0RGVsdGEucmlnaHQ9dC5yZWN0LnJpZ2h0LW8ucmlnaHQsYS5yZWN0RGVsdGEudG9wPXQucmVjdC50b3Atby50b3AsYS5yZWN0RGVsdGEuYm90dG9tPXQucmVjdC5ib3R0b20tby5ib3R0b207dmFyIHA9dGhpcy5yZXN1bHQuY29vcmRzLGQ9dGhpcy5yZXN1bHQucmVjdDtpZihwJiZkKXt2YXIgdj1hLnJlY3QubGVmdCE9PWQubGVmdHx8YS5yZWN0LnJpZ2h0IT09ZC5yaWdodHx8YS5yZWN0LnRvcCE9PWQudG9wfHxhLnJlY3QuYm90dG9tIT09ZC5ib3R0b207YS5jaGFuZ2VkPXZ8fHAueCE9PWEuY29vcmRzLnh8fHAueSE9PWEuY29vcmRzLnl9cmV0dXJuIGF9fSx7a2V5OlwiYXBwbHlUb0ludGVyYWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pbnRlcmFjdGlvbixuPXQucGhhc2Uscj1lLmNvb3Jkcy5jdXIsbz1lLmNvb3Jkcy5zdGFydCxpPXRoaXMucmVzdWx0LGE9dGhpcy5zdGFydERlbHRhLHU9aS5kZWx0YTtcInN0YXJ0XCI9PT1uJiYoMCxTaS5kZWZhdWx0KSh0aGlzLnN0YXJ0RGVsdGEsaS5kZWx0YSk7Zm9yKHZhciBzPTA7czxbW28sYV0sW3IsdV1dLmxlbmd0aDtzKyspe3ZhciBsPUVpKFtbbyxhXSxbcix1XV1bc10sMiksYz1sWzBdLGY9bFsxXTtjLnBhZ2UueCs9Zi54LGMucGFnZS55Kz1mLnksYy5jbGllbnQueCs9Zi54LGMuY2xpZW50LnkrPWYueX12YXIgcD10aGlzLnJlc3VsdC5yZWN0RGVsdGEsZD10LnJlY3R8fGUucmVjdDtkLmxlZnQrPXAubGVmdCxkLnJpZ2h0Kz1wLnJpZ2h0LGQudG9wKz1wLnRvcCxkLmJvdHRvbSs9cC5ib3R0b20sZC53aWR0aD1kLnJpZ2h0LWQubGVmdCxkLmhlaWdodD1kLmJvdHRvbS1kLnRvcH19LHtrZXk6XCJzZXRBbmRBcHBseVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaW50ZXJhY3Rpb24sbj10LnBoYXNlLHI9dC5wcmVFbmQsbz10LnNraXBNb2RpZmllcnMsaT10aGlzLnNldEFsbCh7cHJlRW5kOnIscGhhc2U6bixwYWdlQ29vcmRzOnQubW9kaWZpZWRDb29yZHN8fGUuY29vcmRzLmN1ci5wYWdlfSk7aWYoISh0aGlzLnJlc3VsdD1pKS5jaGFuZ2VkJiYoIW98fG88dGhpcy5zdGF0ZXMubGVuZ3RoKSYmZS5pbnRlcmFjdGluZygpKXJldHVybiExO2lmKHQubW9kaWZpZWRDb29yZHMpe3ZhciBhPWUuY29vcmRzLmN1ci5wYWdlLHU9dC5tb2RpZmllZENvb3Jkcy54LWEueCxzPXQubW9kaWZpZWRDb29yZHMueS1hLnk7aS5jb29yZHMueCs9dSxpLmNvb3Jkcy55Kz1zLGkuZGVsdGEueCs9dSxpLmRlbHRhLnkrPXN9dGhpcy5hcHBseVRvSW50ZXJhY3Rpb24odCl9fSx7a2V5OlwiYmVmb3JlRW5kXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuZXZlbnQscj10aGlzLnN0YXRlcztpZihyJiZyLmxlbmd0aCl7Zm9yKHZhciBvPSExLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIGE9cltpXSx1PSh0LnN0YXRlPWEpLm9wdGlvbnMscz1hLm1ldGhvZHMsbD1zLmJlZm9yZUVuZCYmcy5iZWZvcmVFbmQodCk7aWYobClyZXR1cm4gdGhpcy5lbmRSZXN1bHQ9bCwhMTtvPW98fCFvJiZ0aGlzLnNob3VsZERvKHUsITAsdC5waGFzZSwhMCl9byYmZS5tb3ZlKHtldmVudDpuLHByZUVuZDohMH0pfX19LHtrZXk6XCJzdG9wXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtpZih0aGlzLnN0YXRlcyYmdGhpcy5zdGF0ZXMubGVuZ3RoKXt2YXIgbj0oMCxTaS5kZWZhdWx0KSh7c3RhdGVzOnRoaXMuc3RhdGVzLGludGVyYWN0YWJsZTplLmludGVyYWN0YWJsZSxlbGVtZW50OmUuZWxlbWVudCxyZWN0Om51bGx9LHQpO3RoaXMuZmlsbEFyZyhuKTtmb3IodmFyIHI9MDtyPHRoaXMuc3RhdGVzLmxlbmd0aDtyKyspe3ZhciBvPXRoaXMuc3RhdGVzW3JdOyhuLnN0YXRlPW8pLm1ldGhvZHMuc3RvcCYmby5tZXRob2RzLnN0b3Aobil9dGhpcy5zdGF0ZXM9bnVsbCx0aGlzLmVuZFJlc3VsdD1udWxsfX19LHtrZXk6XCJwcmVwYXJlU3RhdGVzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5zdGF0ZXM9W107Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPXRbZV0scj1uLm9wdGlvbnMsbz1uLm1ldGhvZHMsaT1uLm5hbWU7ciYmITE9PT1yLmVuYWJsZWR8fHRoaXMuc3RhdGVzLnB1c2goe29wdGlvbnM6cixtZXRob2RzOm8saW5kZXg6ZSxuYW1lOml9KX1yZXR1cm4gdGhpcy5zdGF0ZXN9fSx7a2V5OlwicmVzdG9yZUludGVyYWN0aW9uQ29vcmRzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPWUuY29vcmRzLHI9ZS5yZWN0LG89ZS5tb2RpZmljYXRpb247aWYoby5yZXN1bHQpe2Zvcih2YXIgaT1vLnN0YXJ0RGVsdGEsYT1vLnJlc3VsdCx1PWEuZGVsdGEscz1hLnJlY3REZWx0YSxsPVtbbi5zdGFydCxpXSxbbi5jdXIsdV1dLGM9MDtjPGwubGVuZ3RoO2MrKyl7dmFyIGY9RWkobFtjXSwyKSxwPWZbMF0sZD1mWzFdO3AucGFnZS54LT1kLngscC5wYWdlLnktPWQueSxwLmNsaWVudC54LT1kLngscC5jbGllbnQueS09ZC55fXIubGVmdC09cy5sZWZ0LHIucmlnaHQtPXMucmlnaHQsci50b3AtPXMudG9wLHIuYm90dG9tLT1zLmJvdHRvbX19fSx7a2V5Olwic2hvdWxkRG9cIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4hKCF0fHwhMT09PXQuZW5hYmxlZHx8ciYmIXQuZW5kT25seXx8dC5lbmRPbmx5JiYhZXx8XCJzdGFydFwiPT09biYmIXQuc2V0U3RhcnQpfX0se2tleTpcImNvcHlGcm9tXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5zdGFydE9mZnNldD10LnN0YXJ0T2Zmc2V0LHRoaXMuc3RhcnREZWx0YT10LnN0YXJ0RGVsdGEsdGhpcy5lZGdlcz10LmVkZ2VzLHRoaXMuc3RhdGVzPXQuc3RhdGVzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4oMCx4aS5kZWZhdWx0KSh0KX0pLHRoaXMucmVzdWx0PXppKCgwLFNpLmRlZmF1bHQpKHt9LHQucmVzdWx0LmNvb3JkcyksKDAsU2kuZGVmYXVsdCkoe30sdC5yZXN1bHQucmVjdCkpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzKXRoaXNbdF09bnVsbH19XSkmJlRpKHQucHJvdG90eXBlLG4pLHImJlRpKHQsciksZX0oKTtmdW5jdGlvbiB6aSh0LGUpe3JldHVybntyZWN0OmUsY29vcmRzOnQsZGVsdGE6e3g6MCx5OjB9LHJlY3REZWx0YTp7bGVmdDowLHJpZ2h0OjAsdG9wOjAsYm90dG9tOjB9LGV2ZW50UHJvcHM6W10sY2hhbmdlZDohMH19ZnVuY3Rpb24gQWkodCxlKXtyZXR1cm4gdD97bGVmdDplLngtdC5sZWZ0LHRvcDplLnktdC50b3AscmlnaHQ6dC5yaWdodC1lLngsYm90dG9tOnQuYm90dG9tLWUueX06e2xlZnQ6MCx0b3A6MCxyaWdodDowLGJvdHRvbTowfX1faS5kZWZhdWx0PUlpO3ZhciBDaT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2ksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksQ2kubWFrZU1vZGlmaWVyPWZ1bmN0aW9uKHQscil7ZnVuY3Rpb24gZSh0KXt2YXIgZT10fHx7fTtmb3IodmFyIG4gaW4gZS5lbmFibGVkPSExIT09ZS5lbmFibGVkLG8pbiBpbiBlfHwoZVtuXT1vW25dKTtyZXR1cm57b3B0aW9uczplLG1ldGhvZHM6aSxuYW1lOnJ9fXZhciBvPXQuZGVmYXVsdHMsaT17c3RhcnQ6dC5zdGFydCxzZXQ6dC5zZXQsYmVmb3JlRW5kOnQuYmVmb3JlRW5kLHN0b3A6dC5zdG9wfTtyJiZcInN0cmluZ1wiPT10eXBlb2YgciYmKGUuX2RlZmF1bHRzPW8sZS5fbWV0aG9kcz1pKTtyZXR1cm4gZX0sQ2kuYWRkRXZlbnRNb2RpZmllcnM9RmksQ2kuZGVmYXVsdD12b2lkIDA7dmFyIFdpLFJpPShXaT1faSkmJldpLl9fZXNNb2R1bGU/V2k6e2RlZmF1bHQ6V2l9O2Z1bmN0aW9uIEZpKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdWx0O24mJihlLm1vZGlmaWVycz1uLmV2ZW50UHJvcHMpfXZhciBYaT17aWQ6XCJtb2RpZmllcnMvYmFzZVwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC5kZWZhdWx0cy5wZXJBY3Rpb24ubW9kaWZpZXJzPVtdfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247ZS5tb2RpZmljYXRpb249bmV3IFJpLmRlZmF1bHQoZSl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tc3RhcnRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbjtlLnN0YXJ0KHQsdC5pbnRlcmFjdGlvbi5jb29yZHMuc3RhcnQucGFnZSksdC5pbnRlcmFjdGlvbi5lZGdlcz1lLmVkZ2VzLGUuYXBwbHlUb0ludGVyYWN0aW9uKHQpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24uc2V0QW5kQXBwbHkodCl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tZW5kXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLmJlZm9yZUVuZCh0KX0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLXN0YXJ0XCI6RmksXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpGaSxcImludGVyYWN0aW9uczphY3Rpb24tZW5kXCI6RmksXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLXN0YXJ0XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkcyh0KX0sXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdG9yZUludGVyYWN0aW9uQ29vcmRzKHQpfSxcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnN0b3AodCl9fSxiZWZvcmU6W1wiYWN0aW9uc1wiLFwiYWN0aW9uL2RyYWdcIixcImFjdGlvbnMvcmVzaXplXCIsXCJhY3Rpb25zL2dlc3R1cmVcIl19O0NpLmRlZmF1bHQ9WGk7dmFyIFlpPXt9O2Z1bmN0aW9uIE5pKHQpe3JldHVybihOaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KFlpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFlpLmFkZFRvdGFsPVZpLFlpLmFwcGx5UGVuZGluZz1VaSxZaS5kZWZhdWx0PXZvaWQgMDt2YXIgTGk9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09TmkodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9QmkoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oJHQpO2Z1bmN0aW9uIEJpKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gQmk9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBWaSh0KXt0LnBvaW50ZXJJc0Rvd24mJihIaSh0LmNvb3Jkcy5jdXIsdC5vZmZzZXQudG90YWwpLHQub2Zmc2V0LnBlbmRpbmcueD0wLHQub2Zmc2V0LnBlbmRpbmcueT0wKX1mdW5jdGlvbiBxaSh0KXtVaSh0LmludGVyYWN0aW9uKX1mdW5jdGlvbiBVaSh0KXtpZighKGU9dCkub2Zmc2V0LnBlbmRpbmcueCYmIWUub2Zmc2V0LnBlbmRpbmcueSlyZXR1cm4hMTt2YXIgZSxuPXQub2Zmc2V0LnBlbmRpbmc7cmV0dXJuIEhpKHQuY29vcmRzLmN1cixuKSxIaSh0LmNvb3Jkcy5kZWx0YSxuKSxMaS5hZGRFZGdlcyh0LmVkZ2VzLHQucmVjdCxuKSxuLng9MCwhKG4ueT0wKX1mdW5jdGlvbiBHaSh0KXt2YXIgZT10Lngsbj10Lnk7dGhpcy5vZmZzZXQucGVuZGluZy54Kz1lLHRoaXMub2Zmc2V0LnBlbmRpbmcueSs9bix0aGlzLm9mZnNldC50b3RhbC54Kz1lLHRoaXMub2Zmc2V0LnRvdGFsLnkrPW59ZnVuY3Rpb24gSGkodCxlKXt2YXIgbj10LnBhZ2Uscj10LmNsaWVudCxvPWUueCxpPWUueTtuLngrPW8sbi55Kz1pLHIueCs9byxyLnkrPWl9RW4uX1Byb3h5TWV0aG9kcy5vZmZzZXRCeT1cIlwiO3ZhciBLaT17aWQ6XCJvZmZzZXRcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3QuSW50ZXJhY3Rpb24ucHJvdG90eXBlLm9mZnNldEJ5PUdpfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3QuaW50ZXJhY3Rpb24ub2Zmc2V0PXt0b3RhbDp7eDowLHk6MH0scGVuZGluZzp7eDowLHk6MH19fSxcImludGVyYWN0aW9uczp1cGRhdGUtcG9pbnRlclwiOmZ1bmN0aW9uKHQpe3JldHVybiBWaSh0LmludGVyYWN0aW9uKX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1zdGFydFwiOnFpLFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tbW92ZVwiOnFpLFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tZW5kXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtpZihVaShlKSlyZXR1cm4gZS5tb3ZlKHtvZmZzZXQ6ITB9KSxlLmVuZCgpLCExfSxcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtlLm9mZnNldC50b3RhbC54PTAsZS5vZmZzZXQudG90YWwueT0wLGUub2Zmc2V0LnBlbmRpbmcueD0wLGUub2Zmc2V0LnBlbmRpbmcueT0wfX19O1lpLmRlZmF1bHQ9S2k7dmFyICRpPXt9O2Z1bmN0aW9uIFppKHQpe3JldHVybihaaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KCRpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLCRpLmRlZmF1bHQ9JGkuSW5lcnRpYVN0YXRlPXZvaWQgMDt2YXIgSmk9dWEoX2kpLFFpPWFhKENpKSx0YT11YShZaSksZWE9YWEoJCksbmE9dWEoRXQpLHJhPWFhKHcpLG9hPXVhKG9lKTtmdW5jdGlvbiBpYSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIHQ9bmV3IFdlYWtNYXA7cmV0dXJuIGlhPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gYWEodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09WmkodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9aWEoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119cmV0dXJuIG4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbiksbn1mdW5jdGlvbiB1YSh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gc2EodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIGxhKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgY2E9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpeyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5pbnRlcmFjdGlvbj10LGxhKHRoaXMsXCJhY3RpdmVcIiwhMSksbGEodGhpcyxcImlzTW9kaWZpZWRcIiwhMSksbGEodGhpcyxcInNtb290aEVuZFwiLCExKSxsYSh0aGlzLFwiYWxsb3dSZXN1bWVcIiwhMSksbGEodGhpcyxcIm1vZGlmaWNhdGlvblwiLG51bGwpLGxhKHRoaXMsXCJtb2RpZmllckNvdW50XCIsMCksbGEodGhpcyxcIm1vZGlmaWVyQXJnXCIsbnVsbCksbGEodGhpcyxcInN0YXJ0Q29vcmRzXCIsbnVsbCksbGEodGhpcyxcInQwXCIsMCksbGEodGhpcyxcInYwXCIsMCksbGEodGhpcyxcInRlXCIsMCksbGEodGhpcyxcInRhcmdldE9mZnNldFwiLG51bGwpLGxhKHRoaXMsXCJtb2RpZmllZE9mZnNldFwiLG51bGwpLGxhKHRoaXMsXCJjdXJyZW50T2Zmc2V0XCIsbnVsbCksbGEodGhpcyxcImxhbWJkYV92MFwiLDApLGxhKHRoaXMsXCJvbmVfdmVfdjBcIiwwKSxsYSh0aGlzLFwidGltZW91dFwiLG51bGwpfXZhciB0LG4scjtyZXR1cm4gdD1lLChuPVt7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyYWN0aW9uLG49ZmEoZSk7aWYoIW58fCFuLmVuYWJsZWQpcmV0dXJuITE7dmFyIHI9ZS5jb29yZHMudmVsb2NpdHkuY2xpZW50LG89KDAsbmEuZGVmYXVsdCkoci54LHIueSksaT10aGlzLm1vZGlmaWNhdGlvbnx8KHRoaXMubW9kaWZpY2F0aW9uPW5ldyBKaS5kZWZhdWx0KGUpKTtpZihpLmNvcHlGcm9tKGUubW9kaWZpY2F0aW9uKSx0aGlzLnQwPWUuX25vdygpLHRoaXMuYWxsb3dSZXN1bWU9bi5hbGxvd1Jlc3VtZSx0aGlzLnYwPW8sdGhpcy5jdXJyZW50T2Zmc2V0PXt4OjAseTowfSx0aGlzLnN0YXJ0Q29vcmRzPWUuY29vcmRzLmN1ci5wYWdlLHRoaXMubW9kaWZpZXJBcmc9e2ludGVyYWN0aW9uOmUsaW50ZXJhY3RhYmxlOmUuaW50ZXJhY3RhYmxlLGVsZW1lbnQ6ZS5lbGVtZW50LHJlY3Q6ZS5yZWN0LGVkZ2VzOmUuZWRnZXMscGFnZUNvb3Jkczp0aGlzLnN0YXJ0Q29vcmRzLHByZUVuZDohMCxwaGFzZTpcImluZXJ0aWFzdGFydFwifSx0aGlzLnQwLWUuY29vcmRzLmN1ci50aW1lU3RhbXA8NTAmJm8+bi5taW5TcGVlZCYmbz5uLmVuZFNwZWVkKXRoaXMuc3RhcnRJbmVydGlhKCk7ZWxzZXtpZihpLnJlc3VsdD1pLnNldEFsbCh0aGlzLm1vZGlmaWVyQXJnKSwhaS5yZXN1bHQuY2hhbmdlZClyZXR1cm4hMTt0aGlzLnN0YXJ0U21vb3RoRW5kKCl9cmV0dXJuIGUubW9kaWZpY2F0aW9uLnJlc3VsdC5yZWN0PW51bGwsZS5vZmZzZXRCeSh0aGlzLnRhcmdldE9mZnNldCksZS5fZG9QaGFzZSh7aW50ZXJhY3Rpb246ZSxldmVudDp0LHBoYXNlOlwiaW5lcnRpYXN0YXJ0XCJ9KSxlLm9mZnNldEJ5KHt4Oi10aGlzLnRhcmdldE9mZnNldC54LHk6LXRoaXMudGFyZ2V0T2Zmc2V0Lnl9KSxlLm1vZGlmaWNhdGlvbi5yZXN1bHQucmVjdD1udWxsLHRoaXMuYWN0aXZlPSEwLGUuc2ltdWxhdGlvbj10aGlzLCEwfX0se2tleTpcInN0YXJ0SW5lcnRpYVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMuaW50ZXJhY3Rpb24uY29vcmRzLnZlbG9jaXR5LmNsaWVudCxuPWZhKHRoaXMuaW50ZXJhY3Rpb24pLHI9bi5yZXNpc3RhbmNlLG89LU1hdGgubG9nKG4uZW5kU3BlZWQvdGhpcy52MCkvcjt0aGlzLnRhcmdldE9mZnNldD17eDooZS54LW8pL3IseTooZS55LW8pL3J9LHRoaXMudGU9byx0aGlzLmxhbWJkYV92MD1yL3RoaXMudjAsdGhpcy5vbmVfdmVfdjA9MS1uLmVuZFNwZWVkL3RoaXMudjA7dmFyIGk9dGhpcy5tb2RpZmljYXRpb24sYT10aGlzLm1vZGlmaWVyQXJnO2EucGFnZUNvb3Jkcz17eDp0aGlzLnN0YXJ0Q29vcmRzLngrdGhpcy50YXJnZXRPZmZzZXQueCx5OnRoaXMuc3RhcnRDb29yZHMueSt0aGlzLnRhcmdldE9mZnNldC55fSxpLnJlc3VsdD1pLnNldEFsbChhKSxpLnJlc3VsdC5jaGFuZ2VkJiYodGhpcy5pc01vZGlmaWVkPSEwLHRoaXMubW9kaWZpZWRPZmZzZXQ9e3g6dGhpcy50YXJnZXRPZmZzZXQueCtpLnJlc3VsdC5kZWx0YS54LHk6dGhpcy50YXJnZXRPZmZzZXQueStpLnJlc3VsdC5kZWx0YS55fSksdGhpcy50aW1lb3V0PW9hLmRlZmF1bHQucmVxdWVzdChmdW5jdGlvbigpe3JldHVybiB0LmluZXJ0aWFUaWNrKCl9KX19LHtrZXk6XCJzdGFydFNtb290aEVuZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLnNtb290aEVuZD0hMCx0aGlzLmlzTW9kaWZpZWQ9ITAsdGhpcy50YXJnZXRPZmZzZXQ9e3g6dGhpcy5tb2RpZmljYXRpb24ucmVzdWx0LmRlbHRhLngseTp0aGlzLm1vZGlmaWNhdGlvbi5yZXN1bHQuZGVsdGEueX0sdGhpcy50aW1lb3V0PW9hLmRlZmF1bHQucmVxdWVzdChmdW5jdGlvbigpe3JldHVybiB0LnNtb290aEVuZFRpY2soKX0pfX0se2tleTpcImluZXJ0aWFUaWNrXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlLG4scixvLGksYSx1PXRoaXMscz10aGlzLmludGVyYWN0aW9uLGw9ZmEocykucmVzaXN0YW5jZSxjPShzLl9ub3coKS10aGlzLnQwKS8xZTM7aWYoYzx0aGlzLnRlKXt2YXIgZixwPTEtKE1hdGguZXhwKC1sKmMpLXRoaXMubGFtYmRhX3YwKS90aGlzLm9uZV92ZV92MCxkPXt4OihmPXRoaXMuaXNNb2RpZmllZD8oZT10PTAsbj10aGlzLnRhcmdldE9mZnNldC54LHI9dGhpcy50YXJnZXRPZmZzZXQueSxvPXRoaXMubW9kaWZpZWRPZmZzZXQueCxpPXRoaXMubW9kaWZpZWRPZmZzZXQueSx7eDpwYShhPXAsdCxuLG8pLHk6cGEoYSxlLHIsaSl9KTp7eDp0aGlzLnRhcmdldE9mZnNldC54KnAseTp0aGlzLnRhcmdldE9mZnNldC55KnB9KS54LXRoaXMuY3VycmVudE9mZnNldC54LHk6Zi55LXRoaXMuY3VycmVudE9mZnNldC55fTt0aGlzLmN1cnJlbnRPZmZzZXQueCs9ZC54LHRoaXMuY3VycmVudE9mZnNldC55Kz1kLnkscy5vZmZzZXRCeShkKSxzLm1vdmUoKSx0aGlzLnRpbWVvdXQ9b2EuZGVmYXVsdC5yZXF1ZXN0KGZ1bmN0aW9uKCl7cmV0dXJuIHUuaW5lcnRpYVRpY2soKX0pfWVsc2Ugcy5vZmZzZXRCeSh7eDp0aGlzLm1vZGlmaWVkT2Zmc2V0LngtdGhpcy5jdXJyZW50T2Zmc2V0LngseTp0aGlzLm1vZGlmaWVkT2Zmc2V0LnktdGhpcy5jdXJyZW50T2Zmc2V0Lnl9KSx0aGlzLmVuZCgpfX0se2tleTpcInNtb290aEVuZFRpY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLmludGVyYWN0aW9uLG49ZS5fbm93KCktdGhpcy50MCxyPWZhKGUpLnNtb290aEVuZER1cmF0aW9uO2lmKG48cil7dmFyIG89ZGEobiwwLHRoaXMudGFyZ2V0T2Zmc2V0LngsciksaT1kYShuLDAsdGhpcy50YXJnZXRPZmZzZXQueSxyKSxhPXt4Om8tdGhpcy5jdXJyZW50T2Zmc2V0LngseTppLXRoaXMuY3VycmVudE9mZnNldC55fTt0aGlzLmN1cnJlbnRPZmZzZXQueCs9YS54LHRoaXMuY3VycmVudE9mZnNldC55Kz1hLnksZS5vZmZzZXRCeShhKSxlLm1vdmUoe3NraXBNb2RpZmllcnM6dGhpcy5tb2RpZmllckNvdW50fSksdGhpcy50aW1lb3V0PW9hLmRlZmF1bHQucmVxdWVzdChmdW5jdGlvbigpe3JldHVybiB0LnNtb290aEVuZFRpY2soKX0pfWVsc2UgZS5vZmZzZXRCeSh7eDp0aGlzLnRhcmdldE9mZnNldC54LXRoaXMuY3VycmVudE9mZnNldC54LHk6dGhpcy50YXJnZXRPZmZzZXQueS10aGlzLmN1cnJlbnRPZmZzZXQueX0pLHRoaXMuZW5kKCl9fSx7a2V5OlwicmVzdW1lXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5wb2ludGVyLG49dC5ldmVudCxyPXQuZXZlbnRUYXJnZXQsbz10aGlzLmludGVyYWN0aW9uO28ub2Zmc2V0Qnkoe3g6LXRoaXMuY3VycmVudE9mZnNldC54LHk6LXRoaXMuY3VycmVudE9mZnNldC55fSksby51cGRhdGVQb2ludGVyKGUsbixyLCEwKSxvLl9kb1BoYXNlKHtpbnRlcmFjdGlvbjpvLGV2ZW50Om4scGhhc2U6XCJyZXN1bWVcIn0pLCgwLHp0LmNvcHlDb29yZHMpKG8uY29vcmRzLnByZXYsby5jb29yZHMuY3VyKSx0aGlzLnN0b3AoKX19LHtrZXk6XCJlbmRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW50ZXJhY3Rpb24ubW92ZSgpLHRoaXMuaW50ZXJhY3Rpb24uZW5kKCksdGhpcy5zdG9wKCl9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5hY3RpdmU9dGhpcy5zbW9vdGhFbmQ9ITEsdGhpcy5pbnRlcmFjdGlvbi5zaW11bGF0aW9uPW51bGwsb2EuZGVmYXVsdC5jYW5jZWwodGhpcy50aW1lb3V0KX19XSkmJnNhKHQucHJvdG90eXBlLG4pLHImJnNhKHQsciksZX0oKTtmdW5jdGlvbiBmYSh0KXt2YXIgZT10LmludGVyYWN0YWJsZSxuPXQucHJlcGFyZWQ7cmV0dXJuIGUmJmUub3B0aW9ucyYmbi5uYW1lJiZlLm9wdGlvbnNbbi5uYW1lXS5pbmVydGlhfWZ1bmN0aW9uIHBhKHQsZSxuLHIpe3ZhciBvPTEtdDtyZXR1cm4gbypvKmUrMipvKnQqbit0KnQqcn1mdW5jdGlvbiBkYSh0LGUsbixyKXtyZXR1cm4tbioodC89cikqKHQtMikrZX0kaS5JbmVydGlhU3RhdGU9Y2E7dmFyIHZhPXtpZDpcImluZXJ0aWFcIixiZWZvcmU6W1wibW9kaWZpZXJzL2Jhc2VcIl0saW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmRlZmF1bHRzO3QudXNlUGx1Z2luKHRhLmRlZmF1bHQpLHQudXNlUGx1Z2luKFFpLmRlZmF1bHQpLHQuYWN0aW9ucy5waGFzZXMuaW5lcnRpYXN0YXJ0PSEwLHQuYWN0aW9ucy5waGFzZXMucmVzdW1lPSEwLGUucGVyQWN0aW9uLmluZXJ0aWE9e2VuYWJsZWQ6ITEscmVzaXN0YW5jZToxMCxtaW5TcGVlZDoxMDAsZW5kU3BlZWQ6MTAsYWxsb3dSZXN1bWU6ITAsc21vb3RoRW5kRHVyYXRpb246MzAwfX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2UuaW5lcnRpYT1uZXcgY2EoZSl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tZW5kXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuZXZlbnQ7cmV0dXJuKCFlLl9pbnRlcmFjdGluZ3x8ZS5zaW11bGF0aW9ufHwhZS5pbmVydGlhLnN0YXJ0KG4pKSYmbnVsbH0sXCJpbnRlcmFjdGlvbnM6ZG93blwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmV2ZW50VGFyZ2V0LHI9ZS5pbmVydGlhO2lmKHIuYWN0aXZlKWZvcih2YXIgbz1uO3JhLmVsZW1lbnQobyk7KXtpZihvPT09ZS5lbGVtZW50KXtyLnJlc3VtZSh0KTticmVha31vPWVhLnBhcmVudE5vZGUobyl9fSxcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbi5pbmVydGlhO2UuYWN0aXZlJiZlLnN0b3AoKX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1yZXN1bWVcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbjtlLnN0b3AodCksZS5zdGFydCh0LHQuaW50ZXJhY3Rpb24uY29vcmRzLmN1ci5wYWdlKSxlLmFwcGx5VG9JbnRlcmFjdGlvbih0KX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1pbmVydGlhc3RhcnRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24uc2V0QW5kQXBwbHkodCl9LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1yZXN1bWVcIjpRaS5hZGRFdmVudE1vZGlmaWVycyxcImludGVyYWN0aW9uczphY3Rpb24taW5lcnRpYXN0YXJ0XCI6UWkuYWRkRXZlbnRNb2RpZmllcnMsXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLWluZXJ0aWFzdGFydFwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5yZXN0b3JlSW50ZXJhY3Rpb25Db29yZHModCl9LFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1yZXN1bWVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdG9yZUludGVyYWN0aW9uQ29vcmRzKHQpfX19OyRpLmRlZmF1bHQ9dmE7dmFyIHlhLGhhPXt9O2Z1bmN0aW9uIGdhKHQpe3JldHVybihnYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGhhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGhhLmluaXQ9aGEuZGVmYXVsdD12b2lkIDA7dmFyIGJhPW5ldygoKHlhPW0oe30pKSYmeWEuX19lc01vZHVsZT95YTp7ZGVmYXVsdDp5YX0pLmRlZmF1bHQpLG1hPWJhLmludGVyYWN0U3RhdGljO2hhLmRlZmF1bHQ9bWE7ZnVuY3Rpb24gT2EodCl7cmV0dXJuIGJhLmluaXQodCl9aGEuaW5pdD1PYSxcIm9iamVjdFwiPT09KFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3c/XCJ1bmRlZmluZWRcIjpnYSh3aW5kb3cpKSYmd2luZG93JiZPYSh3aW5kb3cpO3ZhciB3YT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkod2EsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksd2EuZGVmYXVsdD12b2lkIDA7d2EuZGVmYXVsdD17fTt2YXIgX2E9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KF9hLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLF9hLmRlZmF1bHQ9dm9pZCAwO19hLmRlZmF1bHQ9e307dmFyIFBhPXt9O2Z1bmN0aW9uIHhhKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHR9KHQpfHxmdW5jdGlvbih0LGUpe2lmKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkpcmV0dXJuO3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHU9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7cnx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufSh0LGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxQYS5kZWZhdWx0PXZvaWQgMDtQYS5kZWZhdWx0PWZ1bmN0aW9uKHYpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49di5yYW5nZSxyPXYubGltaXRzLG89dm9pZCAwPT09cj97bGVmdDotMS8wLHJpZ2h0OjEvMCx0b3A6LTEvMCxib3R0b206MS8wfTpyLGk9di5vZmZzZXQsYT12b2lkIDA9PT1pP3t4OjAseTowfTppLHU9e3JhbmdlOm4sZ3JpZDp2LHg6bnVsbCx5Om51bGx9LHM9MDtzPHkubGVuZ3RoO3MrKyl7dmFyIGw9eGEoeVtzXSwyKSxjPWxbMF0sZj1sWzFdLHA9TWF0aC5yb3VuZCgodC1hLngpL3ZbY10pLGQ9TWF0aC5yb3VuZCgoZS1hLnkpL3ZbZl0pO3VbY109TWF0aC5tYXgoby5sZWZ0LE1hdGgubWluKG8ucmlnaHQscCp2W2NdK2EueCkpLHVbZl09TWF0aC5tYXgoby50b3AsTWF0aC5taW4oby5ib3R0b20sZCp2W2ZdK2EueSkpfXJldHVybiB1fXZhciB5PVtbXCJ4XCIsXCJ5XCJdLFtcImxlZnRcIixcInRvcFwiXSxbXCJyaWdodFwiLFwiYm90dG9tXCJdLFtcIndpZHRoXCIsXCJoZWlnaHRcIl1dLmZpbHRlcihmdW5jdGlvbih0KXt2YXIgZT14YSh0LDIpLG49ZVswXSxyPWVbMV07cmV0dXJuIG4gaW4gdnx8ciBpbiB2fSk7cmV0dXJuIHQuZ3JpZD12LHQuY29vcmRGaWVsZHM9eSx0fTt2YXIgU2E9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KFNhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTYSxcImVkZ2VUYXJnZXRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gamEuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoU2EsXCJlbGVtZW50c1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBNYS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTYSxcImdyaWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4ga2EuZGVmYXVsdH19KTt2YXIgamE9RWEod2EpLE1hPUVhKF9hKSxrYT1FYShQYSk7ZnVuY3Rpb24gRWEodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fXZhciBUYT17fTtmdW5jdGlvbiBEYSh0KXtyZXR1cm4oRGE9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxUYS5kZWZhdWx0PXZvaWQgMDt2YXIgSWEsemE9KElhPWN0KSYmSWEuX19lc01vZHVsZT9JYTp7ZGVmYXVsdDpJYX0sQWE9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09RGEodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9Q2EoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oU2EpO2Z1bmN0aW9uIENhKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gQ2E9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH12YXIgV2E9e2lkOlwic25hcHBlcnNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3RTdGF0aWM7ZS5zbmFwcGVycz0oMCx6YS5kZWZhdWx0KShlLnNuYXBwZXJzfHx7fSxBYSksZS5jcmVhdGVTbmFwR3JpZD1lLnNuYXBwZXJzLmdyaWR9fTtUYS5kZWZhdWx0PVdhO3ZhciBSYT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoUmEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksUmEuYXNwZWN0UmF0aW89UmEuZGVmYXVsdD12b2lkIDA7dmFyIEZhPVlhKGN0KSxYYT1ZYShfaSk7ZnVuY3Rpb24gWWEodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIE5hKGUsdCl7dmFyIG49T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYocj1yLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSksbi5wdXNoLmFwcGx5KG4scil9cmV0dXJuIG59ZnVuY3Rpb24gTGEoZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIG49bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/TmEoT2JqZWN0KG4pLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe0JhKGUsdCxuW3RdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpOk5hKE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KSl9KX1yZXR1cm4gZX1mdW5jdGlvbiBCYSh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIFZhPXtzdGFydDpmdW5jdGlvbih0KXt2YXIgZT10LnN0YXRlLG49dC5yZWN0LHI9dC5lZGdlcyxvPXQucGFnZUNvb3JkcyxpPWUub3B0aW9ucy5yYXRpbyxhPWUub3B0aW9ucyx1PWEuZXF1YWxEZWx0YSxzPWEubW9kaWZpZXJzO1wicHJlc2VydmVcIj09PWkmJihpPW4ud2lkdGgvbi5oZWlnaHQpLGUuc3RhcnRDb29yZHM9KDAsRmEuZGVmYXVsdCkoe30sbyksZS5zdGFydFJlY3Q9KDAsRmEuZGVmYXVsdCkoe30sbiksZS5yYXRpbz1pLGUuZXF1YWxEZWx0YT11O3ZhciBsPWUubGlua2VkRWRnZXM9e3RvcDpyLnRvcHx8ci5sZWZ0JiYhci5ib3R0b20sbGVmdDpyLmxlZnR8fHIudG9wJiYhci5yaWdodCxib3R0b206ci5ib3R0b218fHIucmlnaHQmJiFyLnRvcCxyaWdodDpyLnJpZ2h0fHxyLmJvdHRvbSYmIXIubGVmdH07aWYoZS54SXNQcmltYXJ5QXhpcz0hKCFyLmxlZnQmJiFyLnJpZ2h0KSxlLmVxdWFsRGVsdGEpZS5lZGdlU2lnbj0obC5sZWZ0PzE6LTEpKihsLnRvcD8xOi0xKTtlbHNle3ZhciBjPWUueElzUHJpbWFyeUF4aXM/bC50b3A6bC5sZWZ0O2UuZWRnZVNpZ249Yz8tMToxfWlmKCgwLEZhLmRlZmF1bHQpKHQuZWRnZXMsbCkscyYmcy5sZW5ndGgpe3ZhciBmPW5ldyBYYS5kZWZhdWx0KHQuaW50ZXJhY3Rpb24pO2YuY29weUZyb20odC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24pLGYucHJlcGFyZVN0YXRlcyhzKSwoZS5zdWJNb2RpZmljYXRpb249Zikuc3RhcnRBbGwoTGEoe30sdCkpfX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGUsbj10LnJlY3Qscj10LmNvb3JkcyxvPSgwLEZhLmRlZmF1bHQpKHt9LHIpLGk9ZS5lcXVhbERlbHRhP3FhOlVhO2lmKGkoZSxlLnhJc1ByaW1hcnlBeGlzLHIsbiksIWUuc3ViTW9kaWZpY2F0aW9uKXJldHVybiBudWxsO3ZhciBhPSgwLEZhLmRlZmF1bHQpKHt9LG4pOygwLCR0LmFkZEVkZ2VzKShlLmxpbmtlZEVkZ2VzLGEse3g6ci54LW8ueCx5OnIueS1vLnl9KTt2YXIgdT1lLnN1Yk1vZGlmaWNhdGlvbi5zZXRBbGwoTGEoe30sdCx7cmVjdDphLGVkZ2VzOmUubGlua2VkRWRnZXMscGFnZUNvb3JkczpyLHByZXZDb29yZHM6cixwcmV2UmVjdDphfSkpLHM9dS5kZWx0YTt1LmNoYW5nZWQmJihpKGUsTWF0aC5hYnMocy54KT5NYXRoLmFicyhzLnkpLHUuY29vcmRzLHUucmVjdCksKDAsRmEuZGVmYXVsdCkocix1LmNvb3JkcykpO3JldHVybiB1LmV2ZW50UHJvcHN9LGRlZmF1bHRzOntyYXRpbzpcInByZXNlcnZlXCIsZXF1YWxEZWx0YTohMSxtb2RpZmllcnM6W10sZW5hYmxlZDohMX19O2Z1bmN0aW9uIHFhKHQsZSxuKXt2YXIgcj10LnN0YXJ0Q29vcmRzLG89dC5lZGdlU2lnbjtlP24ueT1yLnkrKG4ueC1yLngpKm86bi54PXIueCsobi55LXIueSkqb31mdW5jdGlvbiBVYSh0LGUsbixyKXt2YXIgbz10LnN0YXJ0UmVjdCxpPXQuc3RhcnRDb29yZHMsYT10LnJhdGlvLHU9dC5lZGdlU2lnbjtpZihlKXt2YXIgcz1yLndpZHRoL2E7bi55PWkueSsocy1vLmhlaWdodCkqdX1lbHNle3ZhciBsPXIuaGVpZ2h0KmE7bi54PWkueCsobC1vLndpZHRoKSp1fX1SYS5hc3BlY3RSYXRpbz1WYTt2YXIgR2E9KDAsQ2kubWFrZU1vZGlmaWVyKShWYSxcImFzcGVjdFJhdGlvXCIpO1JhLmRlZmF1bHQ9R2E7dmFyIEhhPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShIYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxIYS5kZWZhdWx0PXZvaWQgMDtmdW5jdGlvbiBLYSgpe31LYS5fZGVmYXVsdHM9e307dmFyICRhPUthO0hhLmRlZmF1bHQ9JGE7dmFyIFphPXt9O2Z1bmN0aW9uIEphKHQpe3JldHVybihKYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KFphLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFphLmdldFJlc3RyaWN0aW9uUmVjdD1pdSxaYS5yZXN0cmljdD1aYS5kZWZhdWx0PXZvaWQgMDt2YXIgUWEsdHU9KFFhPWN0KSYmUWEuX19lc01vZHVsZT9RYTp7ZGVmYXVsdDpRYX0sZXU9b3UodyksbnU9b3UoJHQpO2Z1bmN0aW9uIHJ1KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gcnU9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBvdSh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1KYSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1ydSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1yZXR1cm4gbi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKSxufWZ1bmN0aW9uIGl1KHQsZSxuKXtyZXR1cm4gZXUuZnVuYyh0KT9udS5yZXNvbHZlUmVjdExpa2UodCxlLmludGVyYWN0YWJsZSxlLmVsZW1lbnQsW24ueCxuLnksZV0pOm51LnJlc29sdmVSZWN0TGlrZSh0LGUuaW50ZXJhY3RhYmxlLGUuZWxlbWVudCl9dmFyIGF1PXtzdGFydDpmdW5jdGlvbih0KXt2YXIgZT10LnJlY3Qsbj10LnN0YXJ0T2Zmc2V0LHI9dC5zdGF0ZSxvPXQuaW50ZXJhY3Rpb24saT10LnBhZ2VDb29yZHMsYT1yLm9wdGlvbnMsdT1hLmVsZW1lbnRSZWN0LHM9KDAsdHUuZGVmYXVsdCkoe2xlZnQ6MCx0b3A6MCxyaWdodDowLGJvdHRvbTowfSxhLm9mZnNldHx8e30pO2lmKGUmJnUpe3ZhciBsPWl1KGEucmVzdHJpY3Rpb24sbyxpKTtpZihsKXt2YXIgYz1sLnJpZ2h0LWwubGVmdC1lLndpZHRoLGY9bC5ib3R0b20tbC50b3AtZS5oZWlnaHQ7YzwwJiYocy5sZWZ0Kz1jLHMucmlnaHQrPWMpLGY8MCYmKHMudG9wKz1mLHMuYm90dG9tKz1mKX1zLmxlZnQrPW4ubGVmdC1lLndpZHRoKnUubGVmdCxzLnRvcCs9bi50b3AtZS5oZWlnaHQqdS50b3Ascy5yaWdodCs9bi5yaWdodC1lLndpZHRoKigxLXUucmlnaHQpLHMuYm90dG9tKz1uLmJvdHRvbS1lLmhlaWdodCooMS11LmJvdHRvbSl9ci5vZmZzZXQ9c30sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuY29vcmRzLG49dC5pbnRlcmFjdGlvbixyPXQuc3RhdGUsbz1yLm9wdGlvbnMsaT1yLm9mZnNldCxhPWl1KG8ucmVzdHJpY3Rpb24sbixlKTtpZihhKXt2YXIgdT1udS54eXdoVG9UbGJyKGEpO2UueD1NYXRoLm1heChNYXRoLm1pbih1LnJpZ2h0LWkucmlnaHQsZS54KSx1LmxlZnQraS5sZWZ0KSxlLnk9TWF0aC5tYXgoTWF0aC5taW4odS5ib3R0b20taS5ib3R0b20sZS55KSx1LnRvcCtpLnRvcCl9fSxkZWZhdWx0czp7cmVzdHJpY3Rpb246bnVsbCxlbGVtZW50UmVjdDpudWxsLG9mZnNldDpudWxsLGVuZE9ubHk6ITEsZW5hYmxlZDohMX19O1phLnJlc3RyaWN0PWF1O3ZhciB1dT0oMCxDaS5tYWtlTW9kaWZpZXIpKGF1LFwicmVzdHJpY3RcIik7WmEuZGVmYXVsdD11dTt2YXIgc3U9e307ZnVuY3Rpb24gbHUodCl7cmV0dXJuKGx1PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoc3UsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksc3UucmVzdHJpY3RFZGdlcz1zdS5kZWZhdWx0PXZvaWQgMDt2YXIgY3UsZnU9KGN1PWN0KSYmY3UuX19lc01vZHVsZT9jdTp7ZGVmYXVsdDpjdX0scHU9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09bHUodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9ZHUoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oJHQpO2Z1bmN0aW9uIGR1KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gZHU9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH12YXIgdnU9e3RvcDoxLzAsbGVmdDoxLzAsYm90dG9tOi0xLzAscmlnaHQ6LTEvMH0seXU9e3RvcDotMS8wLGxlZnQ6LTEvMCxib3R0b206MS8wLHJpZ2h0OjEvMH07ZnVuY3Rpb24gaHUodCxlKXtmb3IodmFyIG49W1widG9wXCIsXCJsZWZ0XCIsXCJib3R0b21cIixcInJpZ2h0XCJdLHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIG89bltyXTtvIGluIHR8fCh0W29dPWVbb10pfXJldHVybiB0fXZhciBndT17bm9Jbm5lcjp2dSxub091dGVyOnl1LHN0YXJ0OmZ1bmN0aW9uKHQpe3ZhciBlLG49dC5pbnRlcmFjdGlvbixyPXQuc3RhcnRPZmZzZXQsbz10LnN0YXRlLGk9by5vcHRpb25zO2lmKGkpe3ZhciBhPSgwLFphLmdldFJlc3RyaWN0aW9uUmVjdCkoaS5vZmZzZXQsbixuLmNvb3Jkcy5zdGFydC5wYWdlKTtlPXB1LnJlY3RUb1hZKGEpfWU9ZXx8e3g6MCx5OjB9LG8ub2Zmc2V0PXt0b3A6ZS55K3IudG9wLGxlZnQ6ZS54K3IubGVmdCxib3R0b206ZS55LXIuYm90dG9tLHJpZ2h0OmUueC1yLnJpZ2h0fX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuY29vcmRzLG49dC5lZGdlcyxyPXQuaW50ZXJhY3Rpb24sbz10LnN0YXRlLGk9by5vZmZzZXQsYT1vLm9wdGlvbnM7aWYobil7dmFyIHU9KDAsZnUuZGVmYXVsdCkoe30sZSkscz0oMCxaYS5nZXRSZXN0cmljdGlvblJlY3QpKGEuaW5uZXIscix1KXx8e30sbD0oMCxaYS5nZXRSZXN0cmljdGlvblJlY3QpKGEub3V0ZXIscix1KXx8e307aHUocyx2dSksaHUobCx5dSksbi50b3A/ZS55PU1hdGgubWluKE1hdGgubWF4KGwudG9wK2kudG9wLHUueSkscy50b3AraS50b3ApOm4uYm90dG9tJiYoZS55PU1hdGgubWF4KE1hdGgubWluKGwuYm90dG9tK2kuYm90dG9tLHUueSkscy5ib3R0b20raS5ib3R0b20pKSxuLmxlZnQ/ZS54PU1hdGgubWluKE1hdGgubWF4KGwubGVmdCtpLmxlZnQsdS54KSxzLmxlZnQraS5sZWZ0KTpuLnJpZ2h0JiYoZS54PU1hdGgubWF4KE1hdGgubWluKGwucmlnaHQraS5yaWdodCx1LngpLHMucmlnaHQraS5yaWdodCkpfX0sZGVmYXVsdHM6e2lubmVyOm51bGwsb3V0ZXI6bnVsbCxvZmZzZXQ6bnVsbCxlbmRPbmx5OiExLGVuYWJsZWQ6ITF9fTtzdS5yZXN0cmljdEVkZ2VzPWd1O3ZhciBidT0oMCxDaS5tYWtlTW9kaWZpZXIpKGd1LFwicmVzdHJpY3RFZGdlc1wiKTtzdS5kZWZhdWx0PWJ1O3ZhciBtdSxPdT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoT3UsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksT3UucmVzdHJpY3RSZWN0PU91LmRlZmF1bHQ9dm9pZCAwO3ZhciB3dT0oMCwoKG11PWN0KSYmbXUuX19lc01vZHVsZT9tdTp7ZGVmYXVsdDptdX0pLmRlZmF1bHQpKHtnZXQgZWxlbWVudFJlY3QoKXtyZXR1cm57dG9wOjAsbGVmdDowLGJvdHRvbToxLHJpZ2h0OjF9fSxzZXQgZWxlbWVudFJlY3QodCl7fX0sWmEucmVzdHJpY3QuZGVmYXVsdHMpLF91PXtzdGFydDpaYS5yZXN0cmljdC5zdGFydCxzZXQ6WmEucmVzdHJpY3Quc2V0LGRlZmF1bHRzOnd1fTtPdS5yZXN0cmljdFJlY3Q9X3U7dmFyIFB1PSgwLENpLm1ha2VNb2RpZmllcikoX3UsXCJyZXN0cmljdFJlY3RcIik7T3UuZGVmYXVsdD1QdTt2YXIgeHU9e307ZnVuY3Rpb24gU3UodCl7cmV0dXJuKFN1PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoeHUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkseHUucmVzdHJpY3RTaXplPXh1LmRlZmF1bHQ9dm9pZCAwO3ZhciBqdSxNdT0oanU9Y3QpJiZqdS5fX2VzTW9kdWxlP2p1OntkZWZhdWx0Omp1fSxrdT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1TdSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1FdSgpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSgkdCk7ZnVuY3Rpb24gRXUoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBFdT1mdW5jdGlvbigpe3JldHVybiB0fSx0fXZhciBUdT17d2lkdGg6LTEvMCxoZWlnaHQ6LTEvMH0sRHU9e3dpZHRoOjEvMCxoZWlnaHQ6MS8wfTt2YXIgSXU9e3N0YXJ0OmZ1bmN0aW9uKHQpe3JldHVybiBzdS5yZXN0cmljdEVkZ2VzLnN0YXJ0KHQpfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuc3RhdGUscj10LnJlY3Qsbz10LmVkZ2VzLGk9bi5vcHRpb25zO2lmKG8pe3ZhciBhPWt1LnRsYnJUb1h5d2goKDAsWmEuZ2V0UmVzdHJpY3Rpb25SZWN0KShpLm1pbixlLHQuY29vcmRzKSl8fFR1LHU9a3UudGxiclRvWHl3aCgoMCxaYS5nZXRSZXN0cmljdGlvblJlY3QpKGkubWF4LGUsdC5jb29yZHMpKXx8RHU7bi5vcHRpb25zPXtlbmRPbmx5OmkuZW5kT25seSxpbm5lcjooMCxNdS5kZWZhdWx0KSh7fSxzdS5yZXN0cmljdEVkZ2VzLm5vSW5uZXIpLG91dGVyOigwLE11LmRlZmF1bHQpKHt9LHN1LnJlc3RyaWN0RWRnZXMubm9PdXRlcil9LG8udG9wPyhuLm9wdGlvbnMuaW5uZXIudG9wPXIuYm90dG9tLWEuaGVpZ2h0LG4ub3B0aW9ucy5vdXRlci50b3A9ci5ib3R0b20tdS5oZWlnaHQpOm8uYm90dG9tJiYobi5vcHRpb25zLmlubmVyLmJvdHRvbT1yLnRvcCthLmhlaWdodCxuLm9wdGlvbnMub3V0ZXIuYm90dG9tPXIudG9wK3UuaGVpZ2h0KSxvLmxlZnQ/KG4ub3B0aW9ucy5pbm5lci5sZWZ0PXIucmlnaHQtYS53aWR0aCxuLm9wdGlvbnMub3V0ZXIubGVmdD1yLnJpZ2h0LXUud2lkdGgpOm8ucmlnaHQmJihuLm9wdGlvbnMuaW5uZXIucmlnaHQ9ci5sZWZ0K2Eud2lkdGgsbi5vcHRpb25zLm91dGVyLnJpZ2h0PXIubGVmdCt1LndpZHRoKSxzdS5yZXN0cmljdEVkZ2VzLnNldCh0KSxuLm9wdGlvbnM9aX19LGRlZmF1bHRzOnttaW46bnVsbCxtYXg6bnVsbCxlbmRPbmx5OiExLGVuYWJsZWQ6ITF9fTt4dS5yZXN0cmljdFNpemU9SXU7dmFyIHp1PSgwLENpLm1ha2VNb2RpZmllcikoSXUsXCJyZXN0cmljdFNpemVcIik7eHUuZGVmYXVsdD16dTt2YXIgQXU9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KEF1LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEF1LmRlZmF1bHQ9dm9pZCAwO2Z1bmN0aW9uIEN1KCl7fUN1Ll9kZWZhdWx0cz17fTt2YXIgV3U9Q3U7QXUuZGVmYXVsdD1XdTt2YXIgUnU9e307ZnVuY3Rpb24gRnUodCl7cmV0dXJuKEZ1PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoUnUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksUnUuc25hcD1SdS5kZWZhdWx0PXZvaWQgMDt2YXIgWHU9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09RnUodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9WXUoKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0obGUpO2Z1bmN0aW9uIFl1KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gWXU9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH12YXIgTnU9e3N0YXJ0OmZ1bmN0aW9uKHQpe3ZhciBlLG4scixvPXQuaW50ZXJhY3Rpb24saT10LmludGVyYWN0YWJsZSxhPXQuZWxlbWVudCx1PXQucmVjdCxzPXQuc3RhdGUsbD10LnN0YXJ0T2Zmc2V0LGM9cy5vcHRpb25zLGY9Yy5vZmZzZXRXaXRoT3JpZ2luPyhuPShlPXQpLmludGVyYWN0aW9uLmVsZW1lbnQsWHUucmVjdC5yZWN0VG9YWShYdS5yZWN0LnJlc29sdmVSZWN0TGlrZShlLnN0YXRlLm9wdGlvbnMub3JpZ2luLG51bGwsbnVsbCxbbl0pKXx8WHUuZ2V0T3JpZ2luWFkoZS5pbnRlcmFjdGFibGUsbixlLmludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUpKTp7eDowLHk6MH07aWYoXCJzdGFydENvb3Jkc1wiPT09Yy5vZmZzZXQpcj17eDpvLmNvb3Jkcy5zdGFydC5wYWdlLngseTpvLmNvb3Jkcy5zdGFydC5wYWdlLnl9O2Vsc2V7dmFyIHA9WHUucmVjdC5yZXNvbHZlUmVjdExpa2UoYy5vZmZzZXQsaSxhLFtvXSk7KHI9WHUucmVjdC5yZWN0VG9YWShwKXx8e3g6MCx5OjB9KS54Kz1mLngsci55Kz1mLnl9dmFyIGQ9Yy5yZWxhdGl2ZVBvaW50cztzLm9mZnNldHM9dSYmZCYmZC5sZW5ndGg/ZC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm57aW5kZXg6ZSxyZWxhdGl2ZVBvaW50OnQseDpsLmxlZnQtdS53aWR0aCp0Lngrci54LHk6bC50b3AtdS5oZWlnaHQqdC55K3IueX19KTpbWHUuZXh0ZW5kKHtpbmRleDowLHJlbGF0aXZlUG9pbnQ6bnVsbH0scildfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuY29vcmRzLHI9dC5zdGF0ZSxvPXIub3B0aW9ucyxpPXIub2Zmc2V0cyxhPVh1LmdldE9yaWdpblhZKGUuaW50ZXJhY3RhYmxlLGUuZWxlbWVudCxlLnByZXBhcmVkLm5hbWUpLHU9WHUuZXh0ZW5kKHt9LG4pLHM9W107by5vZmZzZXRXaXRoT3JpZ2lufHwodS54LT1hLngsdS55LT1hLnkpO2Zvcih2YXIgbD0wO2w8aS5sZW5ndGg7bCsrKWZvcih2YXIgYz1pW2xdLGY9dS54LWMueCxwPXUueS1jLnksZD0wLHY9by50YXJnZXRzLmxlbmd0aDtkPHY7ZCsrKXt2YXIgeT1vLnRhcmdldHNbZF0saD12b2lkIDA7KGg9WHUuaXMuZnVuYyh5KT95KGYscCxlLGMsZCk6eSkmJnMucHVzaCh7eDooWHUuaXMubnVtYmVyKGgueCk/aC54OmYpK2MueCx5OihYdS5pcy5udW1iZXIoaC55KT9oLnk6cCkrYy55LHJhbmdlOlh1LmlzLm51bWJlcihoLnJhbmdlKT9oLnJhbmdlOm8ucmFuZ2Usc291cmNlOnksaW5kZXg6ZCxvZmZzZXQ6Y30pfWZvcih2YXIgZz17dGFyZ2V0Om51bGwsaW5SYW5nZTohMSxkaXN0YW5jZTowLHJhbmdlOjAsZGVsdGE6e3g6MCx5OjB9fSxiPTA7YjxzLmxlbmd0aDtiKyspe3ZhciBtPXNbYl0sTz1tLnJhbmdlLHc9bS54LXUueCxfPW0ueS11LnksUD1YdS5oeXBvdCh3LF8pLHg9UDw9TztPPT09MS8wJiZnLmluUmFuZ2UmJmcucmFuZ2UhPT0xLzAmJih4PSExKSxnLnRhcmdldCYmISh4P2cuaW5SYW5nZSYmTyE9PTEvMD9QL088Zy5kaXN0YW5jZS9nLnJhbmdlOk89PT0xLzAmJmcucmFuZ2UhPT0xLzB8fFA8Zy5kaXN0YW5jZTohZy5pblJhbmdlJiZQPGcuZGlzdGFuY2UpfHwoZy50YXJnZXQ9bSxnLmRpc3RhbmNlPVAsZy5yYW5nZT1PLGcuaW5SYW5nZT14LGcuZGVsdGEueD13LGcuZGVsdGEueT1fKX1yZXR1cm4gZy5pblJhbmdlJiYobi54PWcudGFyZ2V0Lngsbi55PWcudGFyZ2V0LnkpLHIuY2xvc2VzdD1nfSxkZWZhdWx0czp7cmFuZ2U6MS8wLHRhcmdldHM6bnVsbCxvZmZzZXQ6bnVsbCxvZmZzZXRXaXRoT3JpZ2luOiEwLG9yaWdpbjpudWxsLHJlbGF0aXZlUG9pbnRzOm51bGwsZW5kT25seTohMSxlbmFibGVkOiExfX07UnUuc25hcD1OdTt2YXIgTHU9KDAsQ2kubWFrZU1vZGlmaWVyKShOdSxcInNuYXBcIik7UnUuZGVmYXVsdD1MdTt2YXIgQnU9e307ZnVuY3Rpb24gVnUodCl7cmV0dXJuKFZ1PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksQnUuc25hcFNpemU9QnUuZGVmYXVsdD12b2lkIDA7dmFyIHF1LFV1PShxdT1jdCkmJnF1Ll9fZXNNb2R1bGU/cXU6e2RlZmF1bHQ6cXV9LEd1PWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PVZ1KHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUh1KCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KHcpO2Z1bmN0aW9uIEh1KCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gSHU9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBLdSh0LGUpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0fSh0KXx8ZnVuY3Rpb24odCxlKXtpZighKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpKXJldHVybjt2YXIgbj1bXSxyPSEwLG89ITEsaT12b2lkIDA7dHJ5e2Zvcih2YXIgYSx1PXRbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0oYT11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goYS52YWx1ZSksIWV8fG4ubGVuZ3RoIT09ZSk7cj0hMCk7fWNhdGNoKHQpe289ITAsaT10fWZpbmFsbHl7dHJ5e3J8fG51bGw9PXUucmV0dXJufHx1LnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn0odCxlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX12YXIgJHU9e3N0YXJ0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGUsbj10LmVkZ2VzLHI9ZS5vcHRpb25zO2lmKCFuKXJldHVybiBudWxsO3Quc3RhdGU9e29wdGlvbnM6e3RhcmdldHM6bnVsbCxyZWxhdGl2ZVBvaW50czpbe3g6bi5sZWZ0PzA6MSx5Om4udG9wPzA6MX1dLG9mZnNldDpyLm9mZnNldHx8XCJzZWxmXCIsb3JpZ2luOnt4OjAseTowfSxyYW5nZTpyLnJhbmdlfX0sZS50YXJnZXRGaWVsZHM9ZS50YXJnZXRGaWVsZHN8fFtbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdLFtcInhcIixcInlcIl1dLFJ1LnNuYXAuc3RhcnQodCksZS5vZmZzZXRzPXQuc3RhdGUub2Zmc2V0cyx0LnN0YXRlPWV9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5zdGF0ZSxyPXQuY29vcmRzLG89bi5vcHRpb25zLGk9bi5vZmZzZXRzLGE9e3g6ci54LWlbMF0ueCx5OnIueS1pWzBdLnl9O24ub3B0aW9ucz0oMCxVdS5kZWZhdWx0KSh7fSxvKSxuLm9wdGlvbnMudGFyZ2V0cz1bXTtmb3IodmFyIHU9MDt1PChvLnRhcmdldHN8fFtdKS5sZW5ndGg7dSsrKXt2YXIgcz0oby50YXJnZXRzfHxbXSlbdV0sbD12b2lkIDA7aWYobD1HdS5mdW5jKHMpP3MoYS54LGEueSxlKTpzKXtmb3IodmFyIGM9MDtjPG4udGFyZ2V0RmllbGRzLmxlbmd0aDtjKyspe3ZhciBmPUt1KG4udGFyZ2V0RmllbGRzW2NdLDIpLHA9ZlswXSxkPWZbMV07aWYocCBpbiBsfHxkIGluIGwpe2wueD1sW3BdLGwueT1sW2RdO2JyZWFrfX1uLm9wdGlvbnMudGFyZ2V0cy5wdXNoKGwpfX12YXIgdj1SdS5zbmFwLnNldCh0KTtyZXR1cm4gbi5vcHRpb25zPW8sdn0sZGVmYXVsdHM6e3JhbmdlOjEvMCx0YXJnZXRzOm51bGwsb2Zmc2V0Om51bGwsZW5kT25seTohMSxlbmFibGVkOiExfX07QnUuc25hcFNpemU9JHU7dmFyIFp1PSgwLENpLm1ha2VNb2RpZmllcikoJHUsXCJzbmFwU2l6ZVwiKTtCdS5kZWZhdWx0PVp1O3ZhciBKdT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSnUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSnUuc25hcEVkZ2VzPUp1LmRlZmF1bHQ9dm9pZCAwO3ZhciBRdT1lcyhWKSx0cz1lcyhjdCk7ZnVuY3Rpb24gZXModCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fXZhciBucz17c3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5lZGdlcztyZXR1cm4gZT8odC5zdGF0ZS50YXJnZXRGaWVsZHM9dC5zdGF0ZS50YXJnZXRGaWVsZHN8fFtbZS5sZWZ0P1wibGVmdFwiOlwicmlnaHRcIixlLnRvcD9cInRvcFwiOlwiYm90dG9tXCJdXSxCdS5zbmFwU2l6ZS5zdGFydCh0KSk6bnVsbH0sc2V0OkJ1LnNuYXBTaXplLnNldCxkZWZhdWx0czooMCx0cy5kZWZhdWx0KSgoMCxRdS5kZWZhdWx0KShCdS5zbmFwU2l6ZS5kZWZhdWx0cykse3RhcmdldHM6bnVsbCxyYW5nZTpudWxsLG9mZnNldDp7eDowLHk6MH19KX07SnUuc25hcEVkZ2VzPW5zO3ZhciBycz0oMCxDaS5tYWtlTW9kaWZpZXIpKG5zLFwic25hcEVkZ2VzXCIpO0p1LmRlZmF1bHQ9cnM7dmFyIG9zPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShvcyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxvcy5kZWZhdWx0PXZvaWQgMDtmdW5jdGlvbiBpcygpe31pcy5fZGVmYXVsdHM9e307dmFyIGFzPWlzO29zLmRlZmF1bHQ9YXM7dmFyIHVzPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx1cy5kZWZhdWx0PXZvaWQgMDtmdW5jdGlvbiBzcygpe31zcy5fZGVmYXVsdHM9e307dmFyIGxzPXNzO3VzLmRlZmF1bHQ9bHM7dmFyIGNzPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShjcyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxjcy5kZWZhdWx0PXZvaWQgMDt2YXIgZnM9UHMoUmEpLHBzPVBzKEhhKSxkcz1QcyhzdSksdnM9UHMoWmEpLHlzPVBzKE91KSxocz1Qcyh4dSksZ3M9UHMoQXUpLGJzPVBzKEp1KSxtcz1QcyhSdSksT3M9UHMoQnUpLHdzPVBzKG9zKSxfcz1Qcyh1cyk7ZnVuY3Rpb24gUHModCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fXZhciB4cz17YXNwZWN0UmF0aW86ZnMuZGVmYXVsdCxyZXN0cmljdEVkZ2VzOmRzLmRlZmF1bHQscmVzdHJpY3Q6dnMuZGVmYXVsdCxyZXN0cmljdFJlY3Q6eXMuZGVmYXVsdCxyZXN0cmljdFNpemU6aHMuZGVmYXVsdCxzbmFwRWRnZXM6YnMuZGVmYXVsdCxzbmFwOm1zLmRlZmF1bHQsc25hcFNpemU6T3MuZGVmYXVsdCxzcHJpbmc6d3MuZGVmYXVsdCxhdm9pZDpwcy5kZWZhdWx0LHRyYW5zZm9ybTpfcy5kZWZhdWx0LHJ1YmJlcmJhbmQ6Z3MuZGVmYXVsdH07Y3MuZGVmYXVsdD14czt2YXIgU3M9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KFNzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFNzLmRlZmF1bHQ9dm9pZCAwO3ZhciBqcz1FcyhUYSksTXM9RXMoY3MpLGtzPUVzKENpKTtmdW5jdGlvbiBFcyh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19dmFyIFRzPXtpZDpcIm1vZGlmaWVyc1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdFN0YXRpYztmb3IodmFyIG4gaW4gdC51c2VQbHVnaW4oa3MuZGVmYXVsdCksdC51c2VQbHVnaW4oanMuZGVmYXVsdCksZS5tb2RpZmllcnM9TXMuZGVmYXVsdCxNcy5kZWZhdWx0KXt2YXIgcj1Ncy5kZWZhdWx0W25dLG89ci5fZGVmYXVsdHMsaT1yLl9tZXRob2RzO28uX21ldGhvZHM9aSx0LmRlZmF1bHRzLnBlckFjdGlvbltuXT1vfX19O1NzLmRlZmF1bHQ9VHM7dmFyIERzPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShEcyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxEcy5kZWZhdWx0PXZvaWQgMDtEcy5kZWZhdWx0PXt9O3ZhciBJcz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSXMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSXMuUG9pbnRlckV2ZW50PUlzLmRlZmF1bHQ9dm9pZCAwO3ZhciB6cyxBcz0oenM9TWUpJiZ6cy5fX2VzTW9kdWxlP3pzOntkZWZhdWx0OnpzfSxDcz1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1Scyh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm57ZGVmYXVsdDp0fTt2YXIgZT1XcygpO2lmKGUmJmUuaGFzKHQpKXJldHVybiBlLmdldCh0KTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIG8gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSl7dmFyIGk9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk6bnVsbDtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixvLGkpOm5bb109dFtvXX1uLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pO3JldHVybiBufSh6dCk7ZnVuY3Rpb24gV3MoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBXcz1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIFJzKHQpe3JldHVybihScz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9ZnVuY3Rpb24gRnModCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIFhzKHQpe3JldHVybihYcz1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSkodCl9ZnVuY3Rpb24gWXModCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9ZnVuY3Rpb24gTnModCxlKXtyZXR1cm4oTnM9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIExzKHQsZSxuKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH12YXIgQnM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBmKHQsZSxuLHIsbyxpKXt2YXIgYSx1LHM7aWYoIWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxmKSx1PXRoaXMsYT0hKHM9WHMoZikuY2FsbCh0aGlzLG8pKXx8XCJvYmplY3RcIiE9PVJzKHMpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBzP1lzKHUpOnMsTHMoWXMoYSksXCJ0eXBlXCIsdm9pZCAwKSxMcyhZcyhhKSxcIm9yaWdpbmFsRXZlbnRcIix2b2lkIDApLExzKFlzKGEpLFwicG9pbnRlcklkXCIsdm9pZCAwKSxMcyhZcyhhKSxcInBvaW50ZXJUeXBlXCIsdm9pZCAwKSxMcyhZcyhhKSxcImRvdWJsZVwiLHZvaWQgMCksTHMoWXMoYSksXCJwYWdlWFwiLHZvaWQgMCksTHMoWXMoYSksXCJwYWdlWVwiLHZvaWQgMCksTHMoWXMoYSksXCJjbGllbnRYXCIsdm9pZCAwKSxMcyhZcyhhKSxcImNsaWVudFlcIix2b2lkIDApLExzKFlzKGEpLFwiZHRcIix2b2lkIDApLExzKFlzKGEpLFwiZXZlbnRhYmxlXCIsdm9pZCAwKSxDcy5wb2ludGVyRXh0ZW5kKFlzKGEpLG4pLG4hPT1lJiZDcy5wb2ludGVyRXh0ZW5kKFlzKGEpLGUpLGEudGltZVN0YW1wPWksYS5vcmlnaW5hbEV2ZW50PW4sYS50eXBlPXQsYS5wb2ludGVySWQ9Q3MuZ2V0UG9pbnRlcklkKGUpLGEucG9pbnRlclR5cGU9Q3MuZ2V0UG9pbnRlclR5cGUoZSksYS50YXJnZXQ9cixhLmN1cnJlbnRUYXJnZXQ9bnVsbCxcInRhcFwiPT09dCl7dmFyIGw9by5nZXRQb2ludGVySW5kZXgoZSk7YS5kdD1hLnRpbWVTdGFtcC1vLnBvaW50ZXJzW2xdLmRvd25UaW1lO3ZhciBjPWEudGltZVN0YW1wLW8udGFwVGltZTthLmRvdWJsZT0hIShvLnByZXZUYXAmJlwiZG91YmxldGFwXCIhPT1vLnByZXZUYXAudHlwZSYmby5wcmV2VGFwLnRhcmdldD09PWEudGFyZ2V0JiZjPDUwMCl9ZWxzZVwiZG91YmxldGFwXCI9PT10JiYoYS5kdD1lLnRpbWVTdGFtcC1vLnRhcFRpbWUpO3JldHVybiBhfXZhciB0LGUsbjtyZXR1cm4gZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJk5zKHQsZSl9KGYsQXNbXCJkZWZhdWx0XCJdKSx0PWYsKGU9W3trZXk6XCJfc3VidHJhY3RPcmlnaW5cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10Lngsbj10Lnk7cmV0dXJuIHRoaXMucGFnZVgtPWUsdGhpcy5wYWdlWS09bix0aGlzLmNsaWVudFgtPWUsdGhpcy5jbGllbnRZLT1uLHRoaXN9fSx7a2V5OlwiX2FkZE9yaWdpblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQueCxuPXQueTtyZXR1cm4gdGhpcy5wYWdlWCs9ZSx0aGlzLnBhZ2VZKz1uLHRoaXMuY2xpZW50WCs9ZSx0aGlzLmNsaWVudFkrPW4sdGhpc319LHtrZXk6XCJwcmV2ZW50RGVmYXVsdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCl9fV0pJiZGcyh0LnByb3RvdHlwZSxlKSxuJiZGcyh0LG4pLGZ9KCk7SXMuUG9pbnRlckV2ZW50PUlzLmRlZmF1bHQ9QnM7dmFyIFZzPXt9O2Z1bmN0aW9uIHFzKHQpe3JldHVybihxcz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KFZzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFZzLmRlZmF1bHQ9dm9pZCAwO0tzKEVuKSxLcyhtKHt9KSk7dmFyIFVzPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PXFzKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPUhzKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfW4uZGVmYXVsdD10LGUmJmUuc2V0KHQsbik7cmV0dXJuIG59KGxlKSxHcz1LcyhJcyk7ZnVuY3Rpb24gSHMoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBIcz1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIEtzKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX12YXIgJHM9e2lkOlwicG9pbnRlci1ldmVudHMvYmFzZVwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dC5wb2ludGVyRXZlbnRzPSRzLHQuZGVmYXVsdHMuYWN0aW9ucy5wb2ludGVyRXZlbnRzPSRzLmRlZmF1bHRzLFVzLmV4dGVuZCh0LmFjdGlvbnMucGhhc2VsZXNzVHlwZXMsJHMudHlwZXMpfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247ZS5wcmV2VGFwPW51bGwsZS50YXBUaW1lPTB9LFwiaW50ZXJhY3Rpb25zOnVwZGF0ZS1wb2ludGVyXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5kb3duLG49dC5wb2ludGVySW5mbztpZighZSYmbi5ob2xkKXJldHVybjtuLmhvbGQ9e2R1cmF0aW9uOjEvMCx0aW1lb3V0Om51bGx9fSxcImludGVyYWN0aW9uczptb3ZlXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyLG89dC5ldmVudCxpPXQuZXZlbnRUYXJnZXQsYT10LmR1cGxpY2F0ZSx1PW4uZ2V0UG9pbnRlckluZGV4KHIpO2F8fG4ucG9pbnRlcklzRG93biYmIW4ucG9pbnRlcldhc01vdmVkfHwobi5wb2ludGVySXNEb3duJiZjbGVhclRpbWVvdXQobi5wb2ludGVyc1t1XS5ob2xkLnRpbWVvdXQpLFpzKHtpbnRlcmFjdGlvbjpuLHBvaW50ZXI6cixldmVudDpvLGV2ZW50VGFyZ2V0OmksdHlwZTpcIm1vdmVcIn0sZSkpfSxcImludGVyYWN0aW9uczpkb3duXCI6ZnVuY3Rpb24odCxlKXshZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixvPXQuZXZlbnQsaT10LmV2ZW50VGFyZ2V0LGE9dC5wb2ludGVySW5kZXgsdT1uLnBvaW50ZXJzW2FdLmhvbGQscz1Vcy5kb20uZ2V0UGF0aChpKSxsPXtpbnRlcmFjdGlvbjpuLHBvaW50ZXI6cixldmVudDpvLGV2ZW50VGFyZ2V0OmksdHlwZTpcImhvbGRcIix0YXJnZXRzOltdLHBhdGg6cyxub2RlOm51bGx9LGM9MDtjPHMubGVuZ3RoO2MrKyl7dmFyIGY9c1tjXTtsLm5vZGU9ZixlLmZpcmUoXCJwb2ludGVyRXZlbnRzOmNvbGxlY3QtdGFyZ2V0c1wiLGwpfWlmKCFsLnRhcmdldHMubGVuZ3RoKXJldHVybjtmb3IodmFyIHA9MS8wLGQ9MDtkPGwudGFyZ2V0cy5sZW5ndGg7ZCsrKXt2YXIgdj1sLnRhcmdldHNbZF0uZXZlbnRhYmxlLm9wdGlvbnMuaG9sZER1cmF0aW9uO3Y8cCYmKHA9dil9dS5kdXJhdGlvbj1wLHUudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7WnMoe2ludGVyYWN0aW9uOm4sZXZlbnRUYXJnZXQ6aSxwb2ludGVyOnIsZXZlbnQ6byx0eXBlOlwiaG9sZFwifSxlKX0scCl9KHQsZSksWnModCxlKX0sXCJpbnRlcmFjdGlvbnM6dXBcIjpmdW5jdGlvbih0LGUpe3ZhciBuLHIsbyxpLGEsdTtRcyh0KSxacyh0LGUpLHI9ZSxvPShuPXQpLmludGVyYWN0aW9uLGk9bi5wb2ludGVyLGE9bi5ldmVudCx1PW4uZXZlbnRUYXJnZXQsby5wb2ludGVyV2FzTW92ZWR8fFpzKHtpbnRlcmFjdGlvbjpvLGV2ZW50VGFyZ2V0OnUscG9pbnRlcjppLGV2ZW50OmEsdHlwZTpcInRhcFwifSxyKX0sXCJpbnRlcmFjdGlvbnM6Y2FuY2VsXCI6ZnVuY3Rpb24odCxlKXtRcyh0KSxacyh0LGUpfX0sUG9pbnRlckV2ZW50OkdzLmRlZmF1bHQsZmlyZTpacyxjb2xsZWN0RXZlbnRUYXJnZXRzOkpzLGRlZmF1bHRzOntob2xkRHVyYXRpb246NjAwLGlnbm9yZUZyb206bnVsbCxhbGxvd0Zyb206bnVsbCxvcmlnaW46e3g6MCx5OjB9fSx0eXBlczp7ZG93bjohMCxtb3ZlOiEwLHVwOiEwLGNhbmNlbDohMCx0YXA6ITAsZG91YmxldGFwOiEwLGhvbGQ6ITB9fTtmdW5jdGlvbiBacyh0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsbz10LmV2ZW50LGk9dC5ldmVudFRhcmdldCxhPXQudHlwZSx1PXQudGFyZ2V0cyxzPXZvaWQgMD09PXU/SnModCxlKTp1LGw9bmV3IEdzLmRlZmF1bHQoYSxyLG8saSxuLGUubm93KCkpO2UuZmlyZShcInBvaW50ZXJFdmVudHM6bmV3XCIse3BvaW50ZXJFdmVudDpsfSk7Zm9yKHZhciBjPXtpbnRlcmFjdGlvbjpuLHBvaW50ZXI6cixldmVudDpvLGV2ZW50VGFyZ2V0OmksdGFyZ2V0czpzLHR5cGU6YSxwb2ludGVyRXZlbnQ6bH0sZj0wO2Y8cy5sZW5ndGg7ZisrKXt2YXIgcD1zW2ZdO2Zvcih2YXIgZCBpbiBwLnByb3BzfHx7fSlsW2RdPXAucHJvcHNbZF07dmFyIHY9VXMuZ2V0T3JpZ2luWFkocC5ldmVudGFibGUscC5ub2RlKTtpZihsLl9zdWJ0cmFjdE9yaWdpbih2KSxsLmV2ZW50YWJsZT1wLmV2ZW50YWJsZSxsLmN1cnJlbnRUYXJnZXQ9cC5ub2RlLHAuZXZlbnRhYmxlLmZpcmUobCksbC5fYWRkT3JpZ2luKHYpLGwuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkfHxsLnByb3BhZ2F0aW9uU3RvcHBlZCYmZisxPHMubGVuZ3RoJiZzW2YrMV0ubm9kZSE9PWwuY3VycmVudFRhcmdldClicmVha31pZihlLmZpcmUoXCJwb2ludGVyRXZlbnRzOmZpcmVkXCIsYyksXCJ0YXBcIj09PWEpe3ZhciB5PWwuZG91YmxlP1pzKHtpbnRlcmFjdGlvbjpuLHBvaW50ZXI6cixldmVudDpvLGV2ZW50VGFyZ2V0OmksdHlwZTpcImRvdWJsZXRhcFwifSxlKTpsO24ucHJldlRhcD15LG4udGFwVGltZT15LnRpbWVTdGFtcH1yZXR1cm4gbH1mdW5jdGlvbiBKcyh0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsbz10LmV2ZW50LGk9dC5ldmVudFRhcmdldCxhPXQudHlwZSx1PW4uZ2V0UG9pbnRlckluZGV4KHIpLHM9bi5wb2ludGVyc1t1XTtpZihcInRhcFwiPT09YSYmKG4ucG9pbnRlcldhc01vdmVkfHwhc3x8cy5kb3duVGFyZ2V0IT09aSkpcmV0dXJuW107Zm9yKHZhciBsPVVzLmRvbS5nZXRQYXRoKGkpLGM9e2ludGVyYWN0aW9uOm4scG9pbnRlcjpyLGV2ZW50Om8sZXZlbnRUYXJnZXQ6aSx0eXBlOmEscGF0aDpsLHRhcmdldHM6W10sbm9kZTpudWxsfSxmPTA7ZjxsLmxlbmd0aDtmKyspe3ZhciBwPWxbZl07Yy5ub2RlPXAsZS5maXJlKFwicG9pbnRlckV2ZW50czpjb2xsZWN0LXRhcmdldHNcIixjKX1yZXR1cm5cImhvbGRcIj09PWEmJihjLnRhcmdldHM9Yy50YXJnZXRzLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdC5ldmVudGFibGUub3B0aW9ucy5ob2xkRHVyYXRpb249PT1uLnBvaW50ZXJzW3VdLmhvbGQuZHVyYXRpb259KSksYy50YXJnZXRzfWZ1bmN0aW9uIFFzKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LnBvaW50ZXJJbmRleDtlLnBvaW50ZXJzW25dLmhvbGQmJmNsZWFyVGltZW91dChlLnBvaW50ZXJzW25dLmhvbGQudGltZW91dCl9dmFyIHRsPSRzO1ZzLmRlZmF1bHQ9dGw7dmFyIGVsPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlbC5kZWZhdWx0PXZvaWQgMDtybChJcyk7dmFyIG5sPXJsKFZzKTtmdW5jdGlvbiBybCh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gb2wodCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtlLmhvbGRJbnRlcnZhbEhhbmRsZSYmKGNsZWFySW50ZXJ2YWwoZS5ob2xkSW50ZXJ2YWxIYW5kbGUpLGUuaG9sZEludGVydmFsSGFuZGxlPW51bGwpfXZhciBpbD17aWQ6XCJwb2ludGVyLWV2ZW50cy9ob2xkUmVwZWF0XCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LnVzZVBsdWdpbihubC5kZWZhdWx0KTt2YXIgZT10LnBvaW50ZXJFdmVudHM7ZS5kZWZhdWx0cy5ob2xkUmVwZWF0SW50ZXJ2YWw9MCxlLnR5cGVzLmhvbGRyZXBlYXQ9dC5hY3Rpb25zLnBoYXNlbGVzc1R5cGVzLmhvbGRyZXBlYXQ9ITB9LGxpc3RlbmVyczpbXCJtb3ZlXCIsXCJ1cFwiLFwiY2FuY2VsXCIsXCJlbmRhbGxcIl0ucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbXCJwb2ludGVyRXZlbnRzOlwiLmNvbmNhdChlKV09b2wsdH0se1wicG9pbnRlckV2ZW50czpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50ZXJFdmVudDtcImhvbGRcIj09PWUudHlwZSYmKGUuY291bnQ9KGUuY291bnR8fDApKzEpfSxcInBvaW50ZXJFdmVudHM6ZmlyZWRcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXJFdmVudCxvPXQuZXZlbnRUYXJnZXQsaT10LnRhcmdldHM7aWYoXCJob2xkXCI9PT1yLnR5cGUmJmkubGVuZ3RoKXt2YXIgYT1pWzBdLmV2ZW50YWJsZS5vcHRpb25zLmhvbGRSZXBlYXRJbnRlcnZhbDthPD0wfHwobi5ob2xkSW50ZXJ2YWxIYW5kbGU9c2V0VGltZW91dChmdW5jdGlvbigpe2UucG9pbnRlckV2ZW50cy5maXJlKHtpbnRlcmFjdGlvbjpuLGV2ZW50VGFyZ2V0Om8sdHlwZTpcImhvbGRcIixwb2ludGVyOnIsZXZlbnQ6cn0sZSl9LGEpKX19fSl9O2VsLmRlZmF1bHQ9aWw7dmFyIGFsPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShhbCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxhbC5kZWZhdWx0PXZvaWQgMDt2YXIgdWwsc2w9KHVsPWN0KSYmdWwuX19lc01vZHVsZT91bDp7ZGVmYXVsdDp1bH07ZnVuY3Rpb24gbGwodCl7cmV0dXJuKDAsc2wuZGVmYXVsdCkodGhpcy5ldmVudHMub3B0aW9ucyx0KSx0aGlzfXZhciBjbD17aWQ6XCJwb2ludGVyLWV2ZW50cy9pbnRlcmFjdGFibGVUYXJnZXRzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LkludGVyYWN0YWJsZTtlLnByb3RvdHlwZS5wb2ludGVyRXZlbnRzPWxsO3ZhciByPWUucHJvdG90eXBlLl9iYWNrQ29tcGF0T3B0aW9uO2UucHJvdG90eXBlLl9iYWNrQ29tcGF0T3B0aW9uPWZ1bmN0aW9uKHQsZSl7dmFyIG49ci5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gbj09PXRoaXMmJih0aGlzLmV2ZW50cy5vcHRpb25zW3RdPWUpLG59fSxsaXN0ZW5lcnM6e1wicG9pbnRlckV2ZW50czpjb2xsZWN0LXRhcmdldHNcIjpmdW5jdGlvbih0LGUpe3ZhciByPXQudGFyZ2V0cyxvPXQubm9kZSxpPXQudHlwZSxhPXQuZXZlbnRUYXJnZXQ7ZS5pbnRlcmFjdGFibGVzLmZvckVhY2hNYXRjaChvLGZ1bmN0aW9uKHQpe3ZhciBlPXQuZXZlbnRzLG49ZS5vcHRpb25zO2UudHlwZXNbaV0mJmUudHlwZXNbaV0ubGVuZ3RoJiZ0LnRlc3RJZ25vcmVBbGxvdyhuLG8sYSkmJnIucHVzaCh7bm9kZTpvLGV2ZW50YWJsZTplLHByb3BzOntpbnRlcmFjdGFibGU6dH19KX0pfSxcImludGVyYWN0YWJsZTpuZXdcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0YWJsZTtlLmV2ZW50cy5nZXRSZWN0PWZ1bmN0aW9uKHQpe3JldHVybiBlLmdldFJlY3QodCl9fSxcImludGVyYWN0YWJsZTpzZXRcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3RhYmxlLHI9dC5vcHRpb25zOygwLHNsLmRlZmF1bHQpKG4uZXZlbnRzLm9wdGlvbnMsZS5wb2ludGVyRXZlbnRzLmRlZmF1bHRzKSwoMCxzbC5kZWZhdWx0KShuLmV2ZW50cy5vcHRpb25zLHIucG9pbnRlckV2ZW50c3x8e30pfX19O2FsLmRlZmF1bHQ9Y2w7dmFyIGZsPXt9O2Z1bmN0aW9uIHBsKHQpe3JldHVybihwbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGZsLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbCxcImhvbGRSZXBlYXRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdmwuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZmwsXCJpbnRlcmFjdGFibGVUYXJnZXRzXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHlsLmRlZmF1bHR9fSksZmwucG9pbnRlckV2ZW50cz1mbC5kZWZhdWx0PXZvaWQgMDt2YXIgZGw9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT09cGwodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJue2RlZmF1bHQ6dH07dmFyIGU9Z2woKTtpZihlJiZlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBvIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbykpe3ZhciBpPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pOm51bGw7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyxpKTpuW29dPXRbb119bi5kZWZhdWx0PXQsZSYmZS5zZXQodCxuKTtyZXR1cm4gbn0oVnMpO2ZsLnBvaW50ZXJFdmVudHM9ZGw7dmFyIHZsPWhsKGVsKSx5bD1obChhbCk7ZnVuY3Rpb24gaGwodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIGdsKCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcDtyZXR1cm4gZ2w9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH12YXIgYmw9e2lkOlwicG9pbnRlci1ldmVudHNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3QudXNlUGx1Z2luKGRsKSx0LnVzZVBsdWdpbih2bC5kZWZhdWx0KSx0LnVzZVBsdWdpbih5bC5kZWZhdWx0KX19O2ZsLmRlZmF1bHQ9Ymw7dmFyIG1sPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShtbCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxtbC5pbnN0YWxsPXdsLG1sLmRlZmF1bHQ9dm9pZCAwO3ZhciBPbDsoT2w9ayh7fSkpJiZPbC5fX2VzTW9kdWxlO2Z1bmN0aW9uIHdsKGUpe3ZhciB0PWUuSW50ZXJhY3RhYmxlO2UuYWN0aW9ucy5waGFzZXMucmVmbG93PSEwLHQucHJvdG90eXBlLnJlZmxvdz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odSxzLGwpe2Z1bmN0aW9uIHQoKXt2YXIgZT1jW2RdLHQ9dS5nZXRSZWN0KGUpO2lmKCF0KXJldHVyblwiYnJlYWtcIjt2YXIgbj1sZS5hcnIuZmluZChsLmludGVyYWN0aW9ucy5saXN0LGZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW5nKCkmJnQuaW50ZXJhY3RhYmxlPT09dSYmdC5lbGVtZW50PT09ZSYmdC5wcmVwYXJlZC5uYW1lPT09cy5uYW1lfSkscj12b2lkIDA7aWYobiluLm1vdmUoKSxwJiYocj1uLl9yZWZsb3dQcm9taXNlfHxuZXcgZihmdW5jdGlvbih0KXtuLl9yZWZsb3dSZXNvbHZlPXR9KSk7ZWxzZXt2YXIgbz1sZS5yZWN0LnRsYnJUb1h5d2godCksaT17cGFnZTp7eDpvLngseTpvLnl9LGNsaWVudDp7eDpvLngseTpvLnl9LHRpbWVTdGFtcDpsLm5vdygpfSxhPWxlLnBvaW50ZXIuY29vcmRzVG9FdmVudChpKTtyPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGk9dC5pbnRlcmFjdGlvbnMubmV3KHtwb2ludGVyVHlwZTpcInJlZmxvd1wifSksYT17aW50ZXJhY3Rpb246aSxldmVudDpvLHBvaW50ZXI6byxldmVudFRhcmdldDpuLHBoYXNlOlwicmVmbG93XCJ9O2kuaW50ZXJhY3RhYmxlPWUsaS5lbGVtZW50PW4saS5wcmVwYXJlZD0oMCxsZS5leHRlbmQpKHt9LHIpLGkucHJldkV2ZW50PW8saS51cGRhdGVQb2ludGVyKG8sbyxuLCEwKSxpLl9kb1BoYXNlKGEpO3ZhciB1PWxlLndpbi53aW5kb3cuUHJvbWlzZT9uZXcgbGUud2luLndpbmRvdy5Qcm9taXNlKGZ1bmN0aW9uKHQpe2kuX3JlZmxvd1Jlc29sdmU9dH0pOm51bGw7aS5fcmVmbG93UHJvbWlzZT11LGkuc3RhcnQocixlLG4pLGkuX2ludGVyYWN0aW5nPyhpLm1vdmUoYSksaS5lbmQobykpOmkuc3RvcCgpO3JldHVybiBpLnJlbW92ZVBvaW50ZXIobyxvKSxpLnBvaW50ZXJJc0Rvd249ITEsdX0obCx1LGUscyxhKX1wJiZwLnB1c2gocil9Zm9yKHZhciBjPWxlLmlzLnN0cmluZyh1LnRhcmdldCk/bGUuYXJyLmZyb20odS5fY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHUudGFyZ2V0KSk6W3UudGFyZ2V0XSxmPWxlLndpbi53aW5kb3cuUHJvbWlzZSxwPWY/W106bnVsbCxkPTA7ZDxjLmxlbmd0aDtkKyspe2lmKFwiYnJlYWtcIj09PXQoKSlicmVha31yZXR1cm4gcCYmZi5hbGwocCkudGhlbihmdW5jdGlvbigpe3JldHVybiB1fSl9KHRoaXMsdCxlKX19dmFyIF9sPXtpZDpcInJlZmxvd1wiLGluc3RhbGw6d2wsbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uO1wicmVmbG93XCI9PT1uLnBvaW50ZXJUeXBlJiYobi5fcmVmbG93UmVzb2x2ZSYmbi5fcmVmbG93UmVzb2x2ZSgpLGxlLmFyci5yZW1vdmUoZS5pbnRlcmFjdGlvbnMubGlzdCxuKSl9fX07bWwuZGVmYXVsdD1fbDt2YXIgUGw9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KFBsLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLFBsLmRlZmF1bHQ9dm9pZCAwO1BsLmRlZmF1bHQ9e307dmFyIHhsPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh4bCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx4bC5leGNoYW5nZT12b2lkIDA7eGwuZXhjaGFuZ2U9e307dmFyIFNsPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShTbCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxTbC5kZWZhdWx0PXZvaWQgMDtTbC5kZWZhdWx0PXt9O3ZhciBqbD17fTtmdW5jdGlvbiBNbCh0KXtyZXR1cm4oTWw9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShqbCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxqbC5kZWZhdWx0PXZvaWQgMDt2YXIga2w9SGwoUXIpLEVsPUhsKGFvKSxUbD1IbCh1byksRGw9SGwodGkpLElsPUhsKGFpKSx6bD1IbCh1aSksQWw9SGwoVW4pLENsPShIbChzaSksR2wod2kpKSxXbD1IbCgkaSksUmw9SGwoaGEpLEZsPUhsKFNzKSxYbD1IbChEcyksWWw9SGwoWWkpLE5sPUhsKGZsKSxMbD1IbChtbCksQmw9R2woUGwpLFZsPUdsKHp0KSxxbD1HbChTbCk7ZnVuY3Rpb24gVWwoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwO3JldHVybiBVbD1mdW5jdGlvbigpe3JldHVybiB0fSx0fWZ1bmN0aW9uIEdsKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PU1sKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybntkZWZhdWx0OnR9O3ZhciBlPVVsKCk7aWYoZSYmZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO3ZhciBuPXt9LHI9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbyBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pKXt2YXIgaT1yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTpudWxsO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8saSk6bltvXT10W29dfXJldHVybiBuLmRlZmF1bHQ9dCxlJiZlLnNldCh0LG4pLG59ZnVuY3Rpb24gSGwodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fVJsLmRlZmF1bHQudXNlKFhsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKEFsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKFlsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKElsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKEVsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKE5sLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKFdsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKEZsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKERsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKGtsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKFRsLmRlZmF1bHQpLFJsLmRlZmF1bHQudXNlKExsLmRlZmF1bHQpLFJsLmRlZmF1bHQuZmVlZGJhY2s9Q2wsUmwuZGVmYXVsdC51c2UoemwuZGVmYXVsdCksUmwuZGVmYXVsdC52dWU9e2NvbXBvbmVudHM6cWx9LFJsLmRlZmF1bHQuX191dGlscz17ZXhjaGFuZ2U6eGwuZXhjaGFuZ2UsZGlzcGxhY2U6QmwscG9pbnRlcjpWbH07dmFyIEtsPVJsLmRlZmF1bHQ7amwuZGVmYXVsdD1LbDt2YXIgJGw9e2V4cG9ydHM6e319O09iamVjdC5kZWZpbmVQcm9wZXJ0eSgkbC5leHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLCRsLmV4cG9ydHMuZGVmYXVsdD12b2lkIDA7dmFyIFpsLEpsPShabD1qbCkmJlpsLl9fZXNNb2R1bGU/Wmw6e2RlZmF1bHQ6Wmx9O2Z1bmN0aW9uIFFsKHQpe3JldHVybihRbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9aWYoXCJvYmplY3RcIj09PVFsKCRsKSYmJGwpdHJ5eyRsLmV4cG9ydHM9SmwuZGVmYXVsdH1jYXRjaCh0KXt9SmwuZGVmYXVsdC5kZWZhdWx0PUpsLmRlZmF1bHQ7dmFyIHRjPUpsLmRlZmF1bHQ7cmV0dXJuICRsLmV4cG9ydHMuZGVmYXVsdD10YywkbD0kbC5leHBvcnRzfSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyYWN0Lm1pbi5qcy5tYXBcbiIsIi8qIVxuICogaXNlY3QgdjMuMC4wXG4gKiAoYykgMjAxOCBBbmRyZWkgS2FzaGNoYS5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmlzZWN0ID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgLyogZm9sbG93cyBcIkFuIGltcGxlbWVudGF0aW9uIG9mIHRvcC1kb3duIHNwbGF5aW5nXCJcbiAgICogYnkgRC4gU2xlYXRvciA8c2xlYXRvckBjcy5jbXUuZWR1PiBNYXJjaCAxOTkyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7Kn0gS2V5XG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsqfSBWYWx1ZVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7ZnVuY3Rpb24obm9kZTpOb2RlKTp2b2lkfSBWaXNpdG9yXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtmdW5jdGlvbihhOktleSwgYjpLZXkpOm51bWJlcn0gQ29tcGFyYXRvclxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5vZGU6Tm9kZSk6c3RyaW5nfSBOb2RlUHJpbnRlclxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSAgTm9kZVxuICAgKiBAcHJvcGVydHkge0tleX0gICAgS2V5XG4gICAqIEBwcm9wZXJ0eSB7VmFsdWU9fSBkYXRhXG4gICAqIEBwcm9wZXJ0eSB7Tm9kZX0gICBsZWZ0XG4gICAqIEBwcm9wZXJ0eSB7Tm9kZX0gICByaWdodFxuICAgKi9cblxuICB2YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUgKGtleSwgZGF0YSkge1xuICAgIHRoaXMua2V5ICA9IGtleTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubGVmdCA9IG51bGw7XG4gICAgdGhpcy5yaWdodD0gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBERUZBVUxUX0NPTVBBUkUgKGEsIGIpIHsgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwOyB9XG5cblxuICAvKipcbiAgICogU2ltcGxlIHRvcCBkb3duIHNwbGF5LCBub3QgcmVxdWlyaW5nIGkgdG8gYmUgaW4gdGhlIHRyZWUgdC5cbiAgICogQHBhcmFtIHtLZXl9IGlcbiAgICogQHBhcmFtIHtOb2RlP30gdFxuICAgKiBAcGFyYW0ge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3JcbiAgICovXG4gIGZ1bmN0aW9uIHNwbGF5IChpLCB0LCBjb21wYXJhdG9yKSB7XG4gICAgaWYgKHQgPT09IG51bGwpIHsgcmV0dXJuIHQ7IH1cbiAgICB2YXIgbCwgciwgeTtcbiAgICB2YXIgTiA9IG5ldyBOb2RlKCk7XG4gICAgbCA9IHIgPSBOO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGksIHQua2V5KTtcbiAgICAgIC8vaWYgKGkgPCB0LmtleSkge1xuICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgaWYgKHQubGVmdCA9PT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgICAvL2lmIChpIDwgdC5sZWZ0LmtleSkge1xuICAgICAgICBpZiAoY29tcGFyYXRvcihpLCB0LmxlZnQua2V5KSA8IDApIHtcbiAgICAgICAgICB5ID0gdC5sZWZ0OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHJvdGF0ZSByaWdodCAqL1xuICAgICAgICAgIHQubGVmdCA9IHkucmlnaHQ7XG4gICAgICAgICAgeS5yaWdodCA9IHQ7XG4gICAgICAgICAgdCA9IHk7XG4gICAgICAgICAgaWYgKHQubGVmdCA9PT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIHIubGVmdCA9IHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpbmsgcmlnaHQgKi9cbiAgICAgICAgciA9IHQ7XG4gICAgICAgIHQgPSB0LmxlZnQ7XG4gICAgICAvL30gZWxzZSBpZiAoaSA+IHQua2V5KSB7XG4gICAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgaWYgKHQucmlnaHQgPT09IG51bGwpIHsgYnJlYWs7IH1cbiAgICAgICAgLy9pZiAoaSA+IHQucmlnaHQua2V5KSB7XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGksIHQucmlnaHQua2V5KSA+IDApIHtcbiAgICAgICAgICB5ID0gdC5yaWdodDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHJvdGF0ZSBsZWZ0ICovXG4gICAgICAgICAgdC5yaWdodCA9IHkubGVmdDtcbiAgICAgICAgICB5LmxlZnQgPSB0O1xuICAgICAgICAgIHQgPSB5O1xuICAgICAgICAgIGlmICh0LnJpZ2h0ID09PSBudWxsKSB7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgbC5yaWdodCA9IHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGluayBsZWZ0ICovXG4gICAgICAgIGwgPSB0O1xuICAgICAgICB0ID0gdC5yaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBhc3NlbWJsZSAqL1xuICAgIGwucmlnaHQgPSB0LmxlZnQ7XG4gICAgci5sZWZ0ID0gdC5yaWdodDtcbiAgICB0LmxlZnQgPSBOLnJpZ2h0O1xuICAgIHQucmlnaHQgPSBOLmxlZnQ7XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtLZXl9ICAgICAgICBpXG4gICAqIEBwYXJhbSAge1ZhbHVlfSAgICAgIGRhdGFcbiAgICogQHBhcmFtICB7Q29tcGFyYXRvcn0gY29tcGFyYXRvclxuICAgKiBAcGFyYW0gIHtUcmVlfSAgICAgICB0cmVlXG4gICAqIEByZXR1cm4ge05vZGV9ICAgICAgcm9vdFxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0IChpLCBkYXRhLCB0LCBjb21wYXJhdG9yLCB0cmVlKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgTm9kZShpLCBkYXRhKTtcblxuICAgIHRyZWUuX3NpemUrKztcblxuICAgIGlmICh0ID09PSBudWxsKSB7XG4gICAgICBub2RlLmxlZnQgPSBub2RlLnJpZ2h0ID0gbnVsbDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHQgPSBzcGxheShpLCB0LCBjb21wYXJhdG9yKTtcbiAgICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XG4gICAgaWYgKGNtcCA8IDApIHtcbiAgICAgIG5vZGUubGVmdCA9IHQubGVmdDtcbiAgICAgIG5vZGUucmlnaHQgPSB0O1xuICAgICAgdC5sZWZ0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNtcCA+PSAwKSB7XG4gICAgICBub2RlLnJpZ2h0ID0gdC5yaWdodDtcbiAgICAgIG5vZGUubGVmdCA9IHQ7XG4gICAgICB0LnJpZ2h0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBJbnNlcnQgaSBpbnRvIHRoZSB0cmVlIHQsIHVubGVzcyBpdCdzIGFscmVhZHkgdGhlcmUuXG4gICAqIEBwYXJhbSAge0tleX0gICAgICAgIGlcbiAgICogQHBhcmFtICB7VmFsdWV9ICAgICAgZGF0YVxuICAgKiBAcGFyYW0gIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yXG4gICAqIEBwYXJhbSAge1RyZWV9ICAgICAgIHRyZWVcbiAgICogQHJldHVybiB7Tm9kZX0gICAgICAgcm9vdFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkIChpLCBkYXRhLCB0LCBjb21wYXJhdG9yLCB0cmVlKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgTm9kZShpLCBkYXRhKTtcblxuICAgIGlmICh0ID09PSBudWxsKSB7XG4gICAgICBub2RlLmxlZnQgPSBub2RlLnJpZ2h0ID0gbnVsbDtcbiAgICAgIHRyZWUuX3NpemUrKztcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHQgPSBzcGxheShpLCB0LCBjb21wYXJhdG9yKTtcbiAgICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XG4gICAgaWYgKGNtcCA9PT0gMCkgeyByZXR1cm4gdDsgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgbm9kZS5sZWZ0ID0gdC5sZWZ0O1xuICAgICAgICBub2RlLnJpZ2h0ID0gdDtcbiAgICAgICAgdC5sZWZ0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICBub2RlLnJpZ2h0ID0gdC5yaWdodDtcbiAgICAgICAgbm9kZS5sZWZ0ID0gdDtcbiAgICAgICAgdC5yaWdodCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0cmVlLl9zaXplKys7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGkgZnJvbSB0aGUgdHJlZSBpZiBpdCdzIHRoZXJlXG4gICAqIEBwYXJhbSB7S2V5fSAgICAgICAgaVxuICAgKiBAcGFyYW0ge1RyZWV9ICAgICAgIHRyZWVcbiAgICogQHBhcmFtIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yXG4gICAqIEBwYXJhbSB7VHJlZX0gICAgICAgdHJlZVxuICAgKiBAcmV0dXJuIHtOb2RlfSAgICAgIG5ldyByb290XG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmUgKGksIHQsIGNvbXBhcmF0b3IsIHRyZWUpIHtcbiAgICB2YXIgeDtcbiAgICBpZiAodCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHQgPSBzcGxheShpLCB0LCBjb21wYXJhdG9yKTtcbiAgICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XG4gICAgaWYgKGNtcCA9PT0gMCkgeyAgICAgICAgICAgICAgIC8qIGZvdW5kIGl0ICovXG4gICAgICBpZiAodC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIHggPSB0LnJpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHNwbGF5KGksIHQubGVmdCwgY29tcGFyYXRvcik7XG4gICAgICAgIHgucmlnaHQgPSB0LnJpZ2h0O1xuICAgICAgfVxuICAgICAgdHJlZS5fc2l6ZS0tO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIHJldHVybiB0OyAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJdCB3YXNuJ3QgdGhlcmUgKi9cbiAgfVxuXG5cbiAgZnVuY3Rpb24gc3BsaXQgKGtleSwgdiwgY29tcGFyYXRvcikge1xuICAgIHZhciBsZWZ0LCByaWdodDtcbiAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgbGVmdCA9IHJpZ2h0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdiA9IHNwbGF5KGtleSwgdiwgY29tcGFyYXRvcik7XG5cbiAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKHYua2V5LCBrZXkpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICBsZWZ0ICA9IHYubGVmdDtcbiAgICAgICAgcmlnaHQgPSB2LnJpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgIHJpZ2h0ICAgPSB2LnJpZ2h0O1xuICAgICAgICB2LnJpZ2h0ID0gbnVsbDtcbiAgICAgICAgbGVmdCAgICA9IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ICAgPSB2LmxlZnQ7XG4gICAgICAgIHYubGVmdCA9IG51bGw7XG4gICAgICAgIHJpZ2h0ICA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCB9O1xuICB9XG5cblxuICBmdW5jdGlvbiBtZXJnZSAobGVmdCwgcmlnaHQsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAocmlnaHQgPT09IG51bGwpIHsgcmV0dXJuIGxlZnQ7IH1cbiAgICBpZiAobGVmdCAgPT09IG51bGwpIHsgcmV0dXJuIHJpZ2h0OyB9XG5cbiAgICByaWdodCA9IHNwbGF5KGxlZnQua2V5LCByaWdodCwgY29tcGFyYXRvcik7XG4gICAgcmlnaHQubGVmdCA9IGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cblxuICAvKipcbiAgICogUHJpbnRzIGxldmVsIG9mIHRoZSB0cmVlXG4gICAqIEBwYXJhbSAge05vZGV9ICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgIHByZWZpeFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgIGlzVGFpbFxuICAgKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSAgICAgICAgICAgICAgIG91dFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbihub2RlOk5vZGUpOlN0cmluZ30gIHByaW50Tm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gcHJpbnRSb3cgKHJvb3QsIHByZWZpeCwgaXNUYWlsLCBvdXQsIHByaW50Tm9kZSkge1xuICAgIGlmIChyb290KSB7XG4gICAgICBvdXQoKFwiXCIgKyBwcmVmaXggKyAoaXNUYWlsID8gJ+KUlOKUgOKUgCAnIDogJ+KUnOKUgOKUgCAnKSArIChwcmludE5vZGUocm9vdCkpICsgXCJcXG5cIikpO1xuICAgICAgdmFyIGluZGVudCA9IHByZWZpeCArIChpc1RhaWwgPyAnICAgICcgOiAn4pSCICAgJyk7XG4gICAgICBpZiAocm9vdC5sZWZ0KSAgeyBwcmludFJvdyhyb290LmxlZnQsICBpbmRlbnQsIGZhbHNlLCBvdXQsIHByaW50Tm9kZSk7IH1cbiAgICAgIGlmIChyb290LnJpZ2h0KSB7IHByaW50Um93KHJvb3QucmlnaHQsIGluZGVudCwgdHJ1ZSwgIG91dCwgcHJpbnROb2RlKTsgfVxuICAgIH1cbiAgfVxuXG5cbiAgdmFyIFRyZWUgPSBmdW5jdGlvbiBUcmVlIChjb21wYXJhdG9yKSB7XG4gICAgaWYgKCBjb21wYXJhdG9yID09PSB2b2lkIDAgKSBjb21wYXJhdG9yID0gREVGQVVMVF9DT01QQVJFO1xuXG4gICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgc2l6ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBrZXksIGFsbG93cyBkdXBsaWNhdGVzXG4gICAqIEBwYXJhbXtLZXl9ICBrZXlcbiAgICogQHBhcmFte1ZhbHVlPX0gZGF0YVxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQkMSAoa2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBpbnNlcnQoa2V5LCBkYXRhLCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yLCB0aGlzKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBBZGRzIGEga2V5LCBpZiBpdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgdHJlZVxuICAgKiBAcGFyYW17S2V5fSAga2V5XG4gICAqIEBwYXJhbXtWYWx1ZT19IGRhdGFcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkJDEgKGtleSwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9yb290ID0gYWRkKGtleSwgZGF0YSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvciwgdGhpcyk7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte0tleX0ga2V5XG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSQxIChrZXkpIHtcbiAgICB0aGlzLl9yb290ID0gcmVtb3ZlKGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvciwgdGhpcyk7XG4gIH07XG5cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgbm9kZSB3aXRoIHNtYWxsZXN0IGtleVxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9yb290O1xuICAgIGlmIChub2RlKSB7XG4gICAgICB3aGlsZSAobm9kZS5sZWZ0KSB7IG5vZGUgPSBub2RlLmxlZnQ7IH1cbiAgICAgIHRoaXMuX3Jvb3QgPSBzcGxheShub2RlLmtleSx0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcbiAgICAgIHRoaXMuX3Jvb3QgPSByZW1vdmUobm9kZS5rZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IsIHRoaXMpO1xuICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgZGF0YTogbm9kZS5kYXRhIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtLZXl9IGtleVxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5maW5kU3RhdGljID0gZnVuY3Rpb24gZmluZFN0YXRpYyAoa2V5KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290O1xuICAgIHZhciBjb21wYXJlID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgdmFyIGNtcCA9IGNvbXBhcmUoa2V5LCBjdXJyZW50LmtleSk7XG4gICAgICBpZiAoY21wID09PSAwKSAgeyByZXR1cm4gY3VycmVudDsgfVxuICAgICAgZWxzZSBpZiAoY21wIDwgMCkgeyBjdXJyZW50ID0gY3VycmVudC5sZWZ0OyB9XG4gICAgICBlbHNlICAgICAgICAgICAgeyBjdXJyZW50ID0gY3VycmVudC5yaWdodDsgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17S2V5fSBrZXlcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKGtleSkge1xuICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICB0aGlzLl9yb290ID0gc3BsYXkoa2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcbiAgICAgIGlmICh0aGlzLl9jb21wYXJhdG9yKGtleSwgdGhpcy5fcm9vdC5rZXkpICE9PSAwKSB7IHJldHVybiBudWxsOyB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtLZXl9IGtleVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyAoa2V5KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290O1xuICAgIHZhciBjb21wYXJlID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgdmFyIGNtcCA9IGNvbXBhcmUoa2V5LCBjdXJyZW50LmtleSk7XG4gICAgICBpZiAoY21wID09PSAwKSAgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoY21wIDwgMCkgeyBjdXJyZW50ID0gY3VycmVudC5sZWZ0OyB9XG4gICAgICBlbHNlICAgICAgICAgICAgeyBjdXJyZW50ID0gY3VycmVudC5yaWdodDsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte1Zpc2l0b3J9IHZpc2l0b3JcbiAgICogQHBhcmFteyo9fSAgICBjdHhcbiAgICogQHJldHVybiB7U3BsYXlUcmVlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKHZpc2l0b3IsIGN0eCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgUSA9IFtdOy8qIEluaXRpYWxpemUgc3RhY2sgcyAqL1xuICAgIHZhciBkb25lID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGlmIChjdXJyZW50ICE9PW51bGwpIHtcbiAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IFEucG9wKCk7XG4gICAgICAgICAgdmlzaXRvci5jYWxsKGN0eCwgY3VycmVudCk7XG5cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfSBlbHNlIHsgZG9uZSA9IHRydWU7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogV2FsayBrZXkgcmFuZ2UgZnJvbSBgbG93YCB0byBgaGlnaGAuIFN0b3BzIGlmIGBmbmAgcmV0dXJucyBhIHZhbHVlLlxuICAgKiBAcGFyYW17S2V5fSAgICBsb3dcbiAgICogQHBhcmFte0tleX0gICAgaGlnaFxuICAgKiBAcGFyYW17RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbXsqP30gICAgIGN0eFxuICAgKiBAcmV0dXJuIHtTcGxheVRyZWV9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlIChsb3csIGhpZ2gsIGZuLCBjdHgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9yb290LCBjbXA7XG5cbiAgICB3aGlsZSAoUS5sZW5ndGggIT09IDAgfHwgbm9kZSkge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgUS5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IFEucG9wKCk7XG4gICAgICAgIGNtcCA9IGNvbXBhcmUobm9kZS5rZXksIGhpZ2gpO1xuICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmUobm9kZS5rZXksIGxvdykgPj0gMCkge1xuICAgICAgICAgIGlmIChmbi5jYWxsKGN0eCwgbm9kZSkpIHsgcmV0dXJuIHRoaXMkMTsgfSAvLyBzdG9wIGlmIHNtdGggaXMgcmV0dXJuZWRcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSBvZiBrZXlzXG4gICAqIEByZXR1cm4ge0FycmF5PEtleT59XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24ga2V5cyAoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIga2V5ID0gcmVmLmtleTtcblxuICAgICAgICByZXR1cm4ga2V5cy5wdXNoKGtleSk7XG4gICAgICB9KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IG9mIGFsbCB0aGUgZGF0YSBpbiB0aGUgbm9kZXNcbiAgICogQHJldHVybiB7QXJyYXk8VmFsdWU+fVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzICgpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcblxuICAgICAgICByZXR1cm4gdmFsdWVzLnB1c2goZGF0YSk7XG4gICAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0tleXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gbWluICgpIHtcbiAgICBpZiAodGhpcy5fcm9vdCkgeyByZXR1cm4gdGhpcy5taW5Ob2RlKHRoaXMuX3Jvb3QpLmtleTsgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0tleXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gbWF4ICgpIHtcbiAgICBpZiAodGhpcy5fcm9vdCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlKHRoaXMuX3Jvb3QpLmtleTsgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLm1pbk5vZGUgPSBmdW5jdGlvbiBtaW5Ob2RlICh0KSB7XG4gICAgICBpZiAoIHQgPT09IHZvaWQgMCApIHQgPSB0aGlzLl9yb290O1xuXG4gICAgaWYgKHQpIHsgd2hpbGUgKHQubGVmdCkgeyB0ID0gdC5sZWZ0OyB9IH1cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5tYXhOb2RlID0gZnVuY3Rpb24gbWF4Tm9kZSAodCkge1xuICAgICAgaWYgKCB0ID09PSB2b2lkIDAgKSB0ID0gdGhpcy5fcm9vdDtcblxuICAgIGlmICh0KSB7IHdoaWxlICh0LnJpZ2h0KSB7IHQgPSB0LnJpZ2h0OyB9IH1cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5vZGUgYXQgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFte251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0IChpbmRleCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdCwgZG9uZSA9IGZhbHNlLCBpID0gMDtcbiAgICB2YXIgUSA9IFtdO1xuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBRLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoUS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IFEucG9wKCk7XG4gICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7IHJldHVybiBjdXJyZW50OyB9XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgeyBkb25lID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17Tm9kZX0gZFxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoZCkge1xuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgc3VjY2Vzc29yID0gbnVsbDtcblxuICAgIGlmIChkLnJpZ2h0KSB7XG4gICAgICBzdWNjZXNzb3IgPSBkLnJpZ2h0O1xuICAgICAgd2hpbGUgKHN1Y2Nlc3Nvci5sZWZ0KSB7IHN1Y2Nlc3NvciA9IHN1Y2Nlc3Nvci5sZWZ0OyB9XG4gICAgICByZXR1cm4gc3VjY2Vzc29yO1xuICAgIH1cblxuICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICB3aGlsZSAocm9vdCkge1xuICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoZC5rZXksIHJvb3Qua2V5KTtcbiAgICAgIGlmIChjbXAgPT09IDApIHsgYnJlYWs7IH1cbiAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgc3VjY2Vzc29yID0gcm9vdDtcbiAgICAgICAgcm9vdCA9IHJvb3QubGVmdDtcbiAgICAgIH0gZWxzZSB7IHJvb3QgPSByb290LnJpZ2h0OyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Y2Nlc3NvcjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17Tm9kZX0gZFxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gcHJldiAoZCkge1xuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgcHJlZGVjZXNzb3IgPSBudWxsO1xuXG4gICAgaWYgKGQubGVmdCAhPT0gbnVsbCkge1xuICAgICAgcHJlZGVjZXNzb3IgPSBkLmxlZnQ7XG4gICAgICB3aGlsZSAocHJlZGVjZXNzb3IucmlnaHQpIHsgcHJlZGVjZXNzb3IgPSBwcmVkZWNlc3Nvci5yaWdodDsgfVxuICAgICAgcmV0dXJuIHByZWRlY2Vzc29yO1xuICAgIH1cblxuICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICB3aGlsZSAocm9vdCkge1xuICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoZC5rZXksIHJvb3Qua2V5KTtcbiAgICAgIGlmIChjbXAgPT09IDApIHsgYnJlYWs7IH1cbiAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHsgcm9vdCA9IHJvb3QubGVmdDsgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHByZWRlY2Vzc29yID0gcm9vdDtcbiAgICAgICAgcm9vdCA9IHJvb3QucmlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmVkZWNlc3NvcjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTcGxheVRyZWV9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9zaXplID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOb2RlTGlzdH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLnRvTGlzdCA9IGZ1bmN0aW9uIHRvTGlzdCQxICgpIHtcbiAgICByZXR1cm4gdG9MaXN0KHRoaXMuX3Jvb3QpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEJ1bGstbG9hZCBpdGVtcy4gQm90aCBhcnJheSBoYXZlIHRvIGJlIHNhbWUgc2l6ZVxuICAgKiBAcGFyYW17QXJyYXk8S2V5Pn0gIGtleXNcbiAgICogQHBhcmFte0FycmF5PFZhbHVlPn1bdmFsdWVzXVxuICAgKiBAcGFyYW17Qm9vbGVhbn0gICAgIFtwcmVzb3J0PWZhbHNlXSBQcmUtc29ydCBrZXlzIGFuZCB2YWx1ZXMsIHVzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZSdzIGNvbXBhcmF0b3IuIFNvcnRpbmcgaXMgZG9uZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluLXBsYWNlXG4gICAqIEByZXR1cm4ge0FWTFRyZWV9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoa2V5cywgdmFsdWVzLCBwcmVzb3J0KSB7XG4gICAgICBpZiAoIGtleXMgPT09IHZvaWQgMCApIGtleXMgPSBbXTtcbiAgICAgIGlmICggdmFsdWVzID09PSB2b2lkIDAgKSB2YWx1ZXMgPSBbXTtcbiAgICAgIGlmICggcHJlc29ydCA9PT0gdm9pZCAwICkgcHJlc29ydCA9IGZhbHNlO1xuXG4gICAgdmFyIHNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XG5cbiAgICAvLyBzb3J0IGlmIG5lZWRlZFxuICAgIGlmIChwcmVzb3J0KSB7IHNvcnQoa2V5cywgdmFsdWVzLCAwLCBzaXplIC0gMSwgY29tcGFyYXRvcik7IH1cblxuICAgIGlmICh0aGlzLl9yb290ID09PSBudWxsKSB7IC8vIGVtcHR5IHRyZWVcbiAgICAgIHRoaXMuX3Jvb3QgPSBsb2FkUmVjdXJzaXZlKHRoaXMuX3Jvb3QsIGtleXMsIHZhbHVlcywgMCwgc2l6ZSk7XG4gICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB9IGVsc2UgeyAvLyB0aGF0IHJlLWJ1aWxkcyB0aGUgd2hvbGUgdHJlZSBmcm9tIHR3byBpbi1vcmRlciB0cmF2ZXJzYWxzXG4gICAgICB2YXIgbWVyZ2VkTGlzdCA9IG1lcmdlTGlzdHModGhpcy50b0xpc3QoKSwgY3JlYXRlTGlzdChrZXlzLCB2YWx1ZXMpLCBjb21wYXJhdG9yKTtcbiAgICAgIHNpemUgPSB0aGlzLl9zaXplICsgc2l6ZTtcbiAgICAgIHRoaXMuX3Jvb3QgPSBzb3J0ZWRMaXN0VG9CU1QoeyBoZWFkOiBtZXJnZWRMaXN0IH0sIDAsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkgeyByZXR1cm4gdGhpcy5fcm9vdCA9PT0gbnVsbDsgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuc2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zaXplOyB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtOb2RlUHJpbnRlcj19IHByaW50Tm9kZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChwcmludE5vZGUpIHtcbiAgICAgIGlmICggcHJpbnROb2RlID09PSB2b2lkIDAgKSBwcmludE5vZGUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gbi5rZXk7IH07XG5cbiAgICB2YXIgb3V0ID0gW107XG4gICAgcHJpbnRSb3codGhpcy5fcm9vdCwgJycsIHRydWUsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBvdXQucHVzaCh2KTsgfSwgcHJpbnROb2RlKTtcbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xuICB9O1xuXG5cbiAgVHJlZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChrZXksIG5ld0tleSwgbmV3RGF0YSkge1xuICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcbiAgICB2YXIgcmVmID0gc3BsaXQoa2V5LCB0aGlzLl9yb290LCBjb21wYXJhdG9yKTtcbiAgICAgIHZhciBsZWZ0ID0gcmVmLmxlZnQ7XG4gICAgICB2YXIgcmlnaHQgPSByZWYucmlnaHQ7XG4gICAgdGhpcy5fc2l6ZS0tO1xuICAgIGlmIChjb21wYXJhdG9yKGtleSwgbmV3S2V5KSA8IDApIHtcbiAgICAgIHJpZ2h0ID0gaW5zZXJ0KG5ld0tleSwgbmV3RGF0YSwgcmlnaHQsIGNvbXBhcmF0b3IsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gaW5zZXJ0KG5ld0tleSwgbmV3RGF0YSwgbGVmdCwgY29tcGFyYXRvciwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX3Jvb3QgPSBtZXJnZShsZWZ0LCByaWdodCwgY29tcGFyYXRvcik7XG4gIH07XG5cblxuICBUcmVlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0JDEgKGtleSkge1xuICAgIHJldHVybiBzcGxpdChrZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUcmVlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cblxuICBmdW5jdGlvbiBsb2FkUmVjdXJzaXZlIChwYXJlbnQsIGtleXMsIHZhbHVlcywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzaXplID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICB2YXIgbWlkZGxlID0gc3RhcnQgKyBNYXRoLmZsb29yKHNpemUgLyAyKTtcbiAgICAgIHZhciBrZXkgICAgPSBrZXlzW21pZGRsZV07XG4gICAgICB2YXIgZGF0YSAgID0gdmFsdWVzW21pZGRsZV07XG4gICAgICB2YXIgbm9kZSAgID0geyBrZXk6IGtleSwgZGF0YTogZGF0YSwgcGFyZW50OiBwYXJlbnQgfTtcbiAgICAgIG5vZGUubGVmdCAgICA9IGxvYWRSZWN1cnNpdmUobm9kZSwga2V5cywgdmFsdWVzLCBzdGFydCwgbWlkZGxlKTtcbiAgICAgIG5vZGUucmlnaHQgICA9IGxvYWRSZWN1cnNpdmUobm9kZSwga2V5cywgdmFsdWVzLCBtaWRkbGUgKyAxLCBlbmQpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cblxuICBmdW5jdGlvbiBjcmVhdGVMaXN0KGtleXMsIHZhbHVlcykge1xuICAgIHZhciBoZWFkID0geyBuZXh0OiBudWxsIH07XG4gICAgdmFyIHAgPSBoZWFkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcCA9IHAubmV4dCA9IHsga2V5OiBrZXlzW2ldLCBkYXRhOiB2YWx1ZXNbaV0gfTtcbiAgICB9XG4gICAgcC5uZXh0ID0gbnVsbDtcbiAgICByZXR1cm4gaGVhZC5uZXh0O1xuICB9XG5cblxuICBmdW5jdGlvbiB0b0xpc3QgKHJvb3QpIHtcbiAgICB2YXIgY3VycmVudCA9IHJvb3Q7XG4gICAgdmFyIFEgPSBbXSwgZG9uZSA9IGZhbHNlO1xuXG4gICAgdmFyIGhlYWQgPSB7IG5leHQ6IG51bGwgfTtcbiAgICB2YXIgcCA9IGhlYWQ7XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIFEucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChRLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gcCA9IHAubmV4dCA9IFEucG9wKCk7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7IGRvbmUgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHAubmV4dCA9IG51bGw7IC8vIHRoYXQnbGwgd29yayBldmVuIGlmIHRoZSB0cmVlIHdhcyBlbXB0eVxuICAgIHJldHVybiBoZWFkLm5leHQ7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNvcnRlZExpc3RUb0JTVChsaXN0LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHNpemUgPSBlbmQgLSBzdGFydDtcbiAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgIHZhciBtaWRkbGUgPSBzdGFydCArIE1hdGguZmxvb3Ioc2l6ZSAvIDIpO1xuICAgICAgdmFyIGxlZnQgPSBzb3J0ZWRMaXN0VG9CU1QobGlzdCwgc3RhcnQsIG1pZGRsZSk7XG5cbiAgICAgIHZhciByb290ID0gbGlzdC5oZWFkO1xuICAgICAgcm9vdC5sZWZ0ID0gbGVmdDtcblxuICAgICAgbGlzdC5oZWFkID0gbGlzdC5oZWFkLm5leHQ7XG5cbiAgICAgIHJvb3QucmlnaHQgPSBzb3J0ZWRMaXN0VG9CU1QobGlzdCwgbWlkZGxlICsgMSwgZW5kKTtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gbWVyZ2VMaXN0cyAobDEsIGwyLCBjb21wYXJlKSB7XG4gICAgaWYgKCBjb21wYXJlID09PSB2b2lkIDAgKSBjb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9O1xuXG4gICAgdmFyIGhlYWQgPSB7fTsgLy8gZHVtbXlcbiAgICB2YXIgcCA9IGhlYWQ7XG5cbiAgICB2YXIgcDEgPSBsMTtcbiAgICB2YXIgcDIgPSBsMjtcblxuICAgIHdoaWxlIChwMSAhPT0gbnVsbCAmJiBwMiAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbXBhcmUocDEua2V5LCBwMi5rZXkpIDwgMCkge1xuICAgICAgICBwLm5leHQgPSBwMTtcbiAgICAgICAgcDEgPSBwMS5uZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gcDI7XG4gICAgICAgIHAyID0gcDIubmV4dDtcbiAgICAgIH1cbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgaWYgKHAxICE9PSBudWxsKSAgICAgIHsgcC5uZXh0ID0gcDE7IH1cbiAgICBlbHNlIGlmIChwMiAhPT0gbnVsbCkgeyBwLm5leHQgPSBwMjsgfVxuXG4gICAgcmV0dXJuIGhlYWQubmV4dDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gc29ydChrZXlzLCB2YWx1ZXMsIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG4gICAgaWYgKGxlZnQgPj0gcmlnaHQpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgcGl2b3QgPSBrZXlzWyhsZWZ0ICsgcmlnaHQpID4+IDFdO1xuICAgIHZhciBpID0gbGVmdCAtIDE7XG4gICAgdmFyIGogPSByaWdodCArIDE7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgZG8geyBpKys7IH0gd2hpbGUgKGNvbXBhcmUoa2V5c1tpXSwgcGl2b3QpIDwgMCk7XG4gICAgICBkbyB7IGotLTsgfSB3aGlsZSAoY29tcGFyZShrZXlzW2pdLCBwaXZvdCkgPiAwKTtcbiAgICAgIGlmIChpID49IGopIHsgYnJlYWs7IH1cblxuICAgICAgdmFyIHRtcCA9IGtleXNbaV07XG4gICAgICBrZXlzW2ldID0ga2V5c1tqXTtcbiAgICAgIGtleXNbal0gPSB0bXA7XG5cbiAgICAgIHRtcCA9IHZhbHVlc1tpXTtcbiAgICAgIHZhbHVlc1tpXSA9IHZhbHVlc1tqXTtcbiAgICAgIHZhbHVlc1tqXSA9IHRtcDtcbiAgICB9XG5cbiAgICBzb3J0KGtleXMsIHZhbHVlcywgIGxlZnQsICAgICBqLCBjb21wYXJlKTtcbiAgICBzb3J0KGtleXMsIHZhbHVlcywgaiArIDEsIHJpZ2h0LCBjb21wYXJlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50UXVldWUoYnlZKSB7XG4gICAgdmFyIHEgPSBuZXcgVHJlZShieVkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgcG9wOiBwb3AsXG4gICAgICBmaW5kOiBmaW5kLFxuICAgICAgaW5zZXJ0OiBpbnNlcnRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kKHApIHtcbiAgICAgIHJldHVybiBxLmZpbmQocCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICAgIHJldHVybiBxLnNpemU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiBxLmlzRW1wdHkoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNlcnQoZXZlbnQpIHtcbiAgICAgIC8vIGRlYnVnZ2VyO1xuICAgICAgcS5hZGQoZXZlbnQucG9pbnQsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICB2YXIgbm9kZSA9IHEucG9wKCk7XG4gICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmRhdGE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEp1c3QgYSBjb2xsZWN0aW9uIG9mIGdlb21ldHJ5IHJlbGF0ZWQgdXRpbGl0aWVzXG4gICAqL1xuXG4gIC8vIFRoaXMgaXMgdXNlZCBmb3IgcHJlY2lzaW9uIGNoZWNraW5nIChlLmcuIHR3byBudW1iZXJzIGFyZSBlcXVhbFxuICAvLyBpZiB0aGVpciBkaWZmZXJlbmNlIGlzIHNtYWxsZXIgdGhhbiB0aGlzIG51bWJlcikuIFRoZSB2YWx1ZSBpcyBcbiAgLy8gY2hvc2VuIGVtcGlyaWNhbGx5LiBXZSBzdGlsbCBtYXkgcnVuIGludG8gcHJlY2lzaW9uIHJlbGF0ZWQgaXNzdWVzLlxuICAvLyBUT0RPOiB3ZSBzaG91bGQgYWxsb3cgY29uc3VtZXJzIHRvIGNvbmZpZ3VyZSB0aGlzLlxuICB2YXIgRVBTID0gMWUtOTsvLzEwO1xuXG4gIGZ1bmN0aW9uIGdldEludGVyc2VjdGlvblhQb2ludChzZWdtZW50LCB4UG9zLCB5UG9zKSB7XG4gICAgdmFyIGR5MSA9IHNlZ21lbnQuZnJvbS55IC0geVBvcztcbiAgICB2YXIgZHkyID0geVBvcyAtIHNlZ21lbnQudG8ueTtcbiAgICB2YXIgZHkgPSBzZWdtZW50LnRvLnkgLSBzZWdtZW50LmZyb20ueTtcbiAgICBpZiAoTWF0aC5hYnMoZHkxKSA8IEVQUykge1xuICAgICAgLy8gVGhlIHNlZ21lbnQgc3RhcnRzIG9uIHRoZSBzd2VlcCBsaW5lXG4gICAgICBpZiAoTWF0aC5hYnMoZHkpIDwgRVBTKSB7XG4gICAgICAgIC8vIHRoZSBzZWdtZW50IGlzIGhvcml6b250YWwuIEludGVyc2VjdGlvbiBpcyBhdCB0aGUgcG9pbnRcbiAgICAgICAgaWYgKHhQb3MgPD0gc2VnbWVudC5mcm9tLngpIHsgcmV0dXJuIHNlZ21lbnQuZnJvbS54OyB9XG4gICAgICAgIGlmICh4UG9zID4gc2VnbWVudC50by54KSB7IHJldHVybiBzZWdtZW50LnRvLng7IH1cbiAgICAgICAgcmV0dXJuIHhQb3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VnbWVudC5mcm9tLng7XG4gICAgfVxuICAgIFxuICAgIHZhciBkeCA9IChzZWdtZW50LnRvLnggLSBzZWdtZW50LmZyb20ueCk7IFxuICAgIHZhciB4T2Zmc2V0OyBcbiAgICBpZiAoZHkxID49IGR5Mikge1xuICAgICAgeE9mZnNldCA9IGR5MSAqIChkeCAvIGR5KTsgXG4gICAgICByZXR1cm4gKHNlZ21lbnQuZnJvbS54IC0geE9mZnNldCk7XG4gICAgfSBcbiAgICB4T2Zmc2V0ID0gZHkyICogKGR4IC8gZHkpO1xuICAgIHJldHVybiAoc2VnbWVudC50by54ICsgeE9mZnNldCk7XG4gIH1cblxuICBmdW5jdGlvbiBhbmdsZShkeCwgZHkpIHtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjU0MjA0Mi9mYXN0ZXN0LXdheS10by1zb3J0LXZlY3RvcnMtYnktYW5nbGUtd2l0aG91dC1hY3R1YWxseS1jb21wdXRpbmctdGhhdC1hbmdsZVxuICAgIHZhciBwID0gZHgvKE1hdGguYWJzKGR4KSArIE1hdGguYWJzKGR5KSk7IC8vIC0xIC4uIDEgaW5jcmVhc2luZyB3aXRoIHhcblxuICAgIGlmIChkeSA8IDApIHsgcmV0dXJuIHAgLSAxOyB9ICAvLyAtMiAuLiAwIGluY3JlYXNpbmcgd2l0aCB4XG4gICAgcmV0dXJuIDEgLSBwICAgICAgICAgICAgICAgLy8gIDAgLi4gMiBkZWNyZWFzaW5nIHdpdGggeFxuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0U2VnbWVudHMoYSwgYikge1xuICAgIC8vICBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTk2ODM0NS8xMjUzNTFcbiAgICB2YXIgYVN0YXJ0ID0gYS5mcm9tLCBiU3RhcnQgPSBiLmZyb207XG4gICAgdmFyIHAwX3ggPSBhU3RhcnQueCwgcDBfeSA9IGFTdGFydC55LFxuICAgICAgICBwMl94ID0gYlN0YXJ0LngsIHAyX3kgPSBiU3RhcnQueTtcblxuICAgIHZhciBzMV94ID0gYS5keCwgczFfeSA9IGEuZHksIHMyX3ggPSBiLmR4LCBzMl95ID0gYi5keTtcbiAgICB2YXIgZGl2ID0gczFfeCAqIHMyX3kgLSBzMl94ICogczFfeTtcblxuICAgIHZhciBzID0gKHMxX3kgKiAocDBfeCAtIHAyX3gpIC0gczFfeCAqIChwMF95IC0gcDJfeSkpIC8gZGl2O1xuICAgIGlmIChzIDwgMCB8fCBzID4gMSkgeyByZXR1cm47IH1cblxuICAgIHZhciB0ID0gKHMyX3ggKiAocDJfeSAtIHAwX3kpICsgczJfeSAqIChwMF94IC0gcDJfeCkpIC8gZGl2O1xuXG4gICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHAwX3ggLSAodCAqIHMxX3gpLFxuICAgICAgICB5OiBwMF95IC0gKHQgKiBzMV95KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhbWVQb2ludChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEueCAtIGIueCkgPCBFUFMgJiYgTWF0aC5hYnMoYS55IC0gYi55KSA8IEVQUztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHN3ZWVwIHN0YXR1cyBkYXRhIHN0cnVjdHVyZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVN3ZWVwU3RhdHVzKG9uRXJyb3IsIEVQUyQkMSkge1xuICAgIHZhciBsYXN0UG9pbnRZLCBwcmV2WTtcbiAgICB2YXIgbGFzdFBvaW50WCwgcHJldlg7XG4gICAgdmFyIHVzZUJlbG93ID0gZmFsc2U7XG4gICAgdmFyIHN0YXR1cyA9IG5ldyBUcmVlKGNvbXBhcmVTZWdtZW50cyk7XG5cbiAgICAvLyBUbyBzYXZlIG9uIEdDIHdlIHJldHVybiBtdXRhYmxlIG9iamVjdC5cbiAgICB2YXIgY3VycmVudEJvdW5kYXJ5ID0ge1xuICAgICAgYmVmb3JlTGVmdDogbnVsbCxcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICByaWdodDogbnVsbCxcbiAgICAgIGFmdGVyUmlnaHQ6IG51bGwsXG4gICAgfTtcblxuICAgIHZhciBjdXJyZW50TGVmdFJpZ2h0ID0ge2xlZnQ6IG51bGwsIHJpZ2h0OiBudWxsfTtcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBuZXcgc2VnbWVudHMgaW50byB0aGUgc3RhdHVzIHRyZWUuXG4gICAgICAgKi9cbiAgICAgIGluc2VydFNlZ21lbnRzOiBpbnNlcnRTZWdtZW50cyxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgc2VnbWVudHMgZnJvbSB0aGUgc3RhdHVzIHRyZWUuXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZVNlZ21lbnRzOiBkZWxldGVTZWdtZW50cyxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHNlZ21lbnRzIHRoYXQgYXJlIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBmcm9tIGEgZ2l2ZW4gcG9pbnQuXG4gICAgICAgKi9cbiAgICAgIGdldExlZnRSaWdodFBvaW50OiBnZXRMZWZ0UmlnaHRQb2ludCxcblxuICAgICAgLyoqXG4gICAgICAgKiBGb3IgYSBnaXZlbiBjb2xsZWN0aW9ucyBvZiBzZWdtZW50cyBmaW5kcyB0aGUgbW9zdCBsZWZ0IGFuZCB0aGUgbW9zdCByaWdodFxuICAgICAgICogc2VnbWVudHMuIEFsc28gcmV0dXJucyBzZWdtZW50cyBpbW1lZGlhdGVseSBiZWZvcmUgbGVmdCwgYW5kIGFmdGVyIHJpZ2h0IHNlZ21lbnRzLlxuICAgICAgICovXG4gICAgICBnZXRCb3VuZGFyeVNlZ21lbnRzOiBnZXRCb3VuZGFyeVNlZ21lbnRzLFxuXG4gICAgICBmaW5kU2VnbWVudHNXaXRoUG9pbnQ6IGZpbmRTZWdtZW50c1dpdGhQb2ludCxcblxuICAgICAgLyoqXG4gICAgICAgKiBDdXJyZW50IGJpbmFyeSBzZWFyY2ggdHJlZSB3aXRoIHNlZ21lbnRzXG4gICAgICAgKi9cbiAgICAgIHN0YXR1czogc3RhdHVzLFxuXG4gICAgICAvKipcbiAgICAgICAqIEludHJvc3BlY3Rpb24gbWV0aG9kIHRoYXQgdmVyaWZpZXMgaWYgdGhlcmUgYXJlIGR1cGxpY2F0ZXMgaW4gdGhlIHNlZ21lbnQgdHJlZS5cbiAgICAgICAqIElmIHRoZXJlIGFyZSAtIGBvbkVycm9yKClgIGlzIGNhbGxlZC5cbiAgICAgICAqL1xuICAgICAgY2hlY2tEdXBsaWNhdGU6IGNoZWNrRHVwbGljYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFByaW50cyBjdXJyZW50IHNlZ21lbnRzIGluIG9yZGVyIG9mIHRoZWlyIGludGVyc2VjdGlvbiB3aXRoIHN3ZWVwIGxpbmUuIEludHJvc3BlY3Rpb24gbWV0aG9kLlxuICAgICAgICovXG4gICAgICBwcmludFN0YXR1czogcHJpbnRTdGF0dXMsXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBzd2VlcCBsaW5lLlxuICAgICAgICovXG4gICAgICBnZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uIGdldExhc3RQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHt4OiBsYXN0UG9pbnRYLCB5OiBsYXN0UG9pbnRZfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlU2VnbWVudHMoYSwgYikge1xuICAgICAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIDA7IH1cblxuICAgICAgdmFyIGFrID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGEsIGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgICAgdmFyIGJrID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGIsIGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuXG4gICAgICB2YXIgcmVzID0gYWsgLSBiaztcbiAgICAgIGlmIChNYXRoLmFicyhyZXMpID49IEVQUyQkMSkge1xuICAgICAgICAvLyBXZSBhcmUgb2theSBmaW5lLiBJbnRlcnNlY3Rpb24gZGlzdGFuY2UgYmV0d2VlbiB0d28gc2VnbWVudHNcbiAgICAgICAgLy8gaXMgZ29vZCB0byBnaXZlIGNvbmNsdXNpdmUgYW5zd2VyXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBhSXNIb3Jpem9udGFsID0gTWF0aC5hYnMoYS5keSkgPCBFUFMkJDE7XG4gICAgICB2YXIgYklzSG9yaXpvbnRhbCA9IE1hdGguYWJzKGIuZHkpIDwgRVBTJCQxO1xuICAgICAgaWYgKGFJc0hvcml6b250YWwgJiYgYklzSG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gYi50by54IC0gYS50by54O1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogV2hhdCBpZiBib3RoIGEgYW5kIGIgaXMgaG9yaXpvbnRhbD9cbiAgICAgIC8vIG1vdmUgaG9yaXpvbnRhbCB0byBlbmRcbiAgICAgIGlmIChhSXNIb3Jpem9udGFsKSB7IFxuICAgICAgICByZXR1cm4gdXNlQmVsb3cgPyAtMSA6IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChiSXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGlmICh1c2VCZWxvdykge1xuICAgICAgICAgIHJldHVybiAoYi5mcm9tLnggPj0gbGFzdFBvaW50WCkgPyAtMSA6IDFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIC8vIHJldHVybiB1c2VCZWxvdyA/IDEgOiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBwYSA9IGEuYW5nbGU7XG4gICAgICB2YXIgcGIgPSBiLmFuZ2xlO1xuICAgICAgaWYgKE1hdGguYWJzKHBhIC0gcGIpID49IEVQUyQkMSkge1xuICAgICAgICByZXR1cm4gdXNlQmVsb3cgPyBwYSAtIHBiIDogcGIgLSBwYTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ0Rpc3QgPSBhLmZyb20ueSAtIGIuZnJvbS55O1xuICAgICAgaWYgKE1hdGguYWJzKHNlZ0Rpc3QpID49IEVQUyQkMSkge1xuICAgICAgICByZXR1cm4gLXNlZ0Rpc3Q7XG4gICAgICB9XG4gICAgICBzZWdEaXN0ID0gYS50by55IC0gYi50by55O1xuICAgICAgaWYgKE1hdGguYWJzKHNlZ0Rpc3QpID49IEVQUyQkMSkge1xuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGFjY3VyYXRlP1xuICAgICAgICByZXR1cm4gLXNlZ0Rpc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgICAgLy8gQ291bGQgYWxzbyB1c2U6XG4gICAgICAvLyB2YXIgYUFuZ2xlID0gTWF0aC5hdGFuMihhLmZyb20ueSAtIGEudG8ueSwgYS5mcm9tLnggLSBhLnRvLngpO1xuICAgICAgLy8gdmFyIGJBbmdsZSA9IE1hdGguYXRhbjIoYi5mcm9tLnkgLSBiLnRvLnksIGIuZnJvbS54IC0gYi50by54KTtcbiAgICAgIC8vIHJldHVybiB1c2VCZWxvdyA/IGJBbmdsZSAtIGFBbmdsZSA6IGFBbmdsZSAtIGJBbmdsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZGFyeVNlZ21lbnRzKHVwcGVyLCBpbnRlcmlvcikge1xuICAgICAgdmFyIGxlZnRNb3N0LCByaWdodE1vc3QsIGk7XG4gICAgICB2YXIgdUxlbmd0aCA9IHVwcGVyLmxlbmd0aDtcblxuICAgICAgaWYgKHVMZW5ndGggPiAwKSB7XG4gICAgICAgIGxlZnRNb3N0ID0gcmlnaHRNb3N0ID0gdXBwZXJbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0TW9zdCA9IHJpZ2h0TW9zdCA9IGludGVyaW9yWzBdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgdUxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gdXBwZXJbaV07XG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJlU2VnbWVudHMobGVmdE1vc3QsIHMpO1xuICAgICAgICBpZiAoY21wID4gMCkgeyBsZWZ0TW9zdCA9IHM7IH1cblxuICAgICAgICBjbXAgPSBjb21wYXJlU2VnbWVudHMocmlnaHRNb3N0LCBzKTtcbiAgICAgICAgaWYgKGNtcCA8IDApIHsgcmlnaHRNb3N0ID0gczsgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRGcm9tID0gdUxlbmd0aCA+IDAgPyAwIDogMTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0RnJvbTsgaSA8IGludGVyaW9yLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHMgPSBpbnRlcmlvcltpXTtcbiAgICAgICAgY21wID0gY29tcGFyZVNlZ21lbnRzKGxlZnRNb3N0LCBzKTtcbiAgICAgICAgaWYgKGNtcCA+IDApIHsgbGVmdE1vc3QgPSBzOyB9XG5cbiAgICAgICAgY21wID0gY29tcGFyZVNlZ21lbnRzKHJpZ2h0TW9zdCwgcyk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7IHJpZ2h0TW9zdCA9IHM7IH1cbiAgICAgIH1cblxuICAgICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBoYXZlIG91ciBsZWZ0L3JpZ2h0IHNlZ21lbnRzIGluIHRoZSBzdGF0dXMuXG4gICAgICAvLyBMZXQncyBmaW5kIHRoZWlyIHByZXYvbmV4dCBlbGVtZW50cyBhbmQgcmVwb3J0IHRoZW0gYmFjazpcbiAgICAgIHZhciBsZWZ0ID0gc3RhdHVzLmZpbmQobGVmdE1vc3QpO1xuICAgICAgaWYgKCFsZWZ0KSB7XG4gICAgICAgIG9uRXJyb3IoJ0xlZnQgaXMgbWlzc2luZy4gUHJlY2lzaW9uIGVycm9yPycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmlnaHQgPSBzdGF0dXMuZmluZChyaWdodE1vc3QpO1xuICAgICAgaWYgKCFyaWdodCkge1xuICAgICAgICBvbkVycm9yKCdSaWdodCBpcyBtaXNzaW5nLiBQcmVjaXNpb24gZXJyb3I/Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZWZvcmVMZWZ0ID0gbGVmdCAmJiBzdGF0dXMucHJldihsZWZ0KTtcbiAgICAgIHZhciBhZnRlclJpZ2h0ID0gcmlnaHQgJiYgc3RhdHVzLm5leHQocmlnaHQpO1xuXG4gICAgICB3aGlsZSAoYWZ0ZXJSaWdodCAmJiByaWdodC5rZXkuZHkgPT09IDAgJiYgYWZ0ZXJSaWdodC5rZXkuZHkgPT09IDApIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBzZWdtZW50cyBhcmUgc3BlY2lhbCA6KFxuICAgICAgICBhZnRlclJpZ2h0ID0gc3RhdHVzLm5leHQoYWZ0ZXJSaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRCb3VuZGFyeS5iZWZvcmVMZWZ0ID0gYmVmb3JlTGVmdCAmJiBiZWZvcmVMZWZ0LmtleTtcbiAgICAgIGN1cnJlbnRCb3VuZGFyeS5sZWZ0ID0gbGVmdCAmJiBsZWZ0LmtleTtcbiAgICAgIGN1cnJlbnRCb3VuZGFyeS5yaWdodCA9IHJpZ2h0ICYmIHJpZ2h0LmtleTtcbiAgICAgIGN1cnJlbnRCb3VuZGFyeS5hZnRlclJpZ2h0ID0gYWZ0ZXJSaWdodCAmJiBhZnRlclJpZ2h0LmtleTtcblxuICAgICAgcmV0dXJuIGN1cnJlbnRCb3VuZGFyeTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMZWZ0UmlnaHRQb2ludChwKSB7XG4gICAgICAvLyBXZSBhcmUgdHJ5aW5nIHRvIGZpbmQgbGVmdCBhbmQgcmlnaHQgc2VnbWVudHMgdGhhdCBhcmUgbmVhcmVzdCB0byB0aGVcbiAgICAgIC8vIHBvaW50IHAuIEZvciB0aGlzIHdlIHRyYXZlcnNlIHRoZSBiaW5hcnkgc2VhcmNoIHRyZWUsIGFuZCByZW1lbWJlclxuICAgICAgLy8gbm9kZSB3aXRoIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSB0byBwLlxuICAgICAgdmFyIGxhc3RMZWZ0O1xuICAgICAgdmFyIGN1cnJlbnQgPSBzdGF0dXMuX3Jvb3Q7XG4gICAgICB2YXIgbWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGN1cnJlbnQua2V5LCBwLngsIHAueSk7XG4gICAgICAgIHZhciBkeCA9IHAueCAtIHg7XG4gICAgICAgIGlmIChkeCA+PSAwKSB7XG4gICAgICAgICAgaWYgKGR4IDwgbWluWCkge1xuICAgICAgICAgICAgbWluWCA9IGR4O1xuICAgICAgICAgICAgbGFzdExlZnQgPSBjdXJyZW50O1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgtZHggPCBtaW5YKSB7XG4gICAgICAgICAgICBtaW5YID0gLWR4O1xuICAgICAgICAgICAgbGFzdExlZnQgPSBjdXJyZW50O1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50TGVmdFJpZ2h0LmxlZnQgPSBsYXN0TGVmdCAmJiBsYXN0TGVmdC5rZXk7XG4gICAgICB2YXIgbmV4dCA9IGxhc3RMZWZ0ICYmIHN0YXR1cy5uZXh0KGxhc3RMZWZ0KTtcbiAgICAgIGN1cnJlbnRMZWZ0UmlnaHQucmlnaHQgPSBuZXh0ICYmIG5leHQua2V5O1xuICAgICAgcmV0dXJuIGN1cnJlbnRMZWZ0UmlnaHQ7XG5cbiAgICAgIC8vIENvbmNlcHR1YWxseSwgdGhlIGNvZGUgYWJvdmUgc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGNvZGUgYmVsb3c7XG4gICAgICAvLyBUaGUgY29kZSBiZWxvdyBpcyBlYXNpZXIgdG8gdW5kZXJzdGFuZCwgYnV0IGludHVpdGl2ZWx5LCB0aGUgY29kZSBhYm92ZVxuICAgICAgLy8gc2hvdWxkIGhhdmUgYmV0dGVyIHBlcmZvcm1hbmNlIChhcyB3ZSBkbyBub3QgdHJhdmVyc2UgdGhlIGVudGlyZSBzdGF0dXNcbiAgICAgIC8vIHRyZWUpXG5cbiAgICAgIC8vIHZhciByaWdodCwgbGVmdCwgIHg7XG4gICAgICAvLyB2YXIgYWxsID0gc3RhdHVzLmtleXMoKVxuICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vICAgdmFyIHNlZ21lbnQgPSBhbGxbaV07XG4gICAgICAvLyAgIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoc2VnbWVudCwgcC54LCBwLnkpO1xuICAgICAgLy8gICBpZiAoeCA+IHAueCAmJiAhcmlnaHQpIHtcbiAgICAgIC8vICAgICByaWdodCA9IHNlZ21lbnQ7XG4gICAgICAvLyAgICAgYnJlYWs7XG4gICAgICAvLyAgIH0gZWxzZSBpZiAoeCA8IHAueCkge1xuICAgICAgLy8gICAgIGxlZnQgPSBzZWdtZW50O1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGN1cnJlbnRMZWZ0UmlnaHQubGVmdCA9IGxlZnQ7XG4gICAgICAvLyBjdXJyZW50TGVmdFJpZ2h0LnJpZ2h0ID0gcmlnaHQ7XG5cbiAgICAgIC8vIHJldHVybiBjdXJyZW50TGVmdFJpZ2h0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRTZWdtZW50c1dpdGhQb2ludChwLCBvbkZvdW5kKSB7XG4gICAgICAvLyBPcHRpb24gMS5cbiAgICAgIC8vIHZhciBhcnJSZXN1bHRzID0gW107XG4gICAgICAvLyBzdGF0dXMuZm9yRWFjaChjdXJyZW50ID0+IHtcbiAgICAgIC8vICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoY3VycmVudC5rZXksIHAueCwgcC55KTtcbiAgICAgIC8vICAgdmFyIGR4ID0gcC54IC0geDtcbiAgICAgIC8vICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQUykge1xuICAgICAgLy8gICAgIG9uRm91bmQoY3VycmVudC5rZXkpO1xuICAgICAgLy8gICAgLy8gYXJyUmVzdWx0cy5wdXNoKGN1cnJlbnQua2V5KVxuICAgICAgLy8gICB9XG4gICAgICAvLyB9KTtcbiAgICAgIC8vIHJldHVybiBhcnJSZXN1bHRzO1xuXG4gICAgICAvLyBPcHRpb24gMi5cblxuICAgICAgLy8gbGV0IGN1cnJlbnQgPSBzdGF0dXMuX3Jvb3Q7XG4gICAgICAvLyBjb25zdCBRID0gW107ICAvKiBJbml0aWFsaXplIHN0YWNrIHMgKi9cbiAgICAgIC8vIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAvLyB2YXIgcmVzID0gW107XG4gICAgICAvLyB2YXIgYnJlYWtFYXJseSA9IGZhbHNlO1xuXG4gICAgICAvLyB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIC8vICAgaWYgKGN1cnJlbnQgIT09ICBudWxsKSB7XG4gICAgICAvLyAgICAgUS5wdXNoKGN1cnJlbnQpO1xuICAgICAgLy8gICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICAvLyAgIH0gZWxzZSB7XG4gICAgICAvLyAgICAgaWYgKFEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAvLyAgICAgICBjdXJyZW50ID0gUS5wb3AoKTtcblxuICAgICAgLy8gICAgICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoY3VycmVudC5rZXksIHAueCwgcC55KTtcbiAgICAgIC8vICAgICAgIHZhciBkeCA9IHAueCAtIHg7XG4gICAgICAvLyAgICAgICBpZiAoTWF0aC5hYnMoZHgpIDwgRVBTKSB7XG4gICAgICAvLyAgICAgICAgIHJlcy5wdXNoKGN1cnJlbnQua2V5KVxuICAgICAgLy8gICAgICAgICBicmVha0Vhcmx5ID0gdHJ1ZTtcbiAgICAgIC8vICAgICAgIH0gZWxzZSBpZiAoYnJlYWtFYXJseSkge1xuICAgICAgLy8gICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIC8vICAgICAgIH1cblxuICAgICAgLy8gICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAvLyAgICAgfSBlbHNlIGRvbmUgPSB0cnVlO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIHJldHVybiByZXM7XG5cbiAgICAgIC8vIG9wdGlvbiAzLlxuICAgICAgdmFyIGN1cnJlbnQgPSBzdGF0dXMuX3Jvb3Q7XG5cbiAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGN1cnJlbnQua2V5LCBwLngsIHAueSk7XG4gICAgICAgIHZhciBkeCA9IHAueCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyhkeCkgPCBFUFMkJDEpIHtcbiAgICAgICAgICBjb2xsZWN0QWRqYWNlbnROb2RlcyhjdXJyZW50LCBwLCBvbkZvdW5kKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChkeCA8IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdEFkamFjZW50Tm9kZXMocm9vdCwgcCwgb25Gb3VuZCkge1xuICAgICAgb25Gb3VuZChyb290LmtleSk7XG4gICAgICBnb092ZXJQcmVkZWNlc3NvcnMocm9vdC5sZWZ0LCBwLCBvbkZvdW5kKTtcbiAgICAgIGdvT3ZlclN1Y2Nlc3NvcnMocm9vdC5yaWdodCwgcCwgb25Gb3VuZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ29PdmVyUHJlZGVjZXNzb3JzKHJvb3QsIHAsIHJlcykge1xuICAgICAgaWYgKCFyb290KSB7IHJldHVybjsgfVxuICAgICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQocm9vdC5rZXksIHAueCwgcC55KTtcbiAgICAgIHZhciBkeCA9IHAueCAtIHg7XG4gICAgICBpZiAoTWF0aC5hYnMoZHgpIDwgRVBTJCQxKSB7XG4gICAgICAgIGNvbGxlY3RBZGphY2VudE5vZGVzKHJvb3QsIHAsIHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnb092ZXJQcmVkZWNlc3NvcnMocm9vdC5yaWdodCwgcCwgcmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb092ZXJTdWNjZXNzb3JzKHJvb3QsIHAsIHJlcykge1xuICAgICAgaWYgKCFyb290KSB7IHJldHVybjsgfVxuICAgICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQocm9vdC5rZXksIHAueCwgcC55KTtcbiAgICAgIHZhciBkeCA9IHAueCAtIHg7XG4gICAgICBpZiAoTWF0aC5hYnMoZHgpIDwgRVBTJCQxKSB7XG4gICAgICAgIGNvbGxlY3RBZGphY2VudE5vZGVzKHJvb3QsIHAsIHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnb092ZXJTdWNjZXNzb3JzKHJvb3QubGVmdCwgcCwgcmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZSgpIHtcbiAgICAgIHZhciBwcmV2O1xuICAgICAgc3RhdHVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBub2RlLmtleTtcblxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIGlmIChzYW1lUG9pbnQocHJldi5mcm9tLCBjdXJyZW50LmZyb20pICYmIHNhbWVQb2ludChwcmV2LnRvLCBjdXJyZW50LnRvKSkge1xuICAgICAgICAgICAgLy8gTGlrZWx5IHlvdSBoYXZlIHJlY2VpdmVkIGVycm9yIGJlZm9yZSBkdXJpbmcgc2VnbWVudCByZW1vdmFsLlxuICAgICAgICAgICAgb25FcnJvcignRHVwbGljYXRlIGtleSBpbiB0aGUgc3RhdHVzISBUaGlzIG1heSBiZSBjYXVzZWQgYnkgRmxvYXRpbmcgUG9pbnQgcm91bmRpbmcgZXJyb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludFN0YXR1cyhwcmVmaXgpIHtcbiAgICAgIGlmICggcHJlZml4ID09PSB2b2lkIDAgKSBwcmVmaXggPSAnJztcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBjb25zb2xlLmxvZyhwcmVmaXgsICdzdGF0dXMgbGluZTogJywgbGFzdFBvaW50WCwgbGFzdFBvaW50WSk7XG4gICAgICBzdGF0dXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChub2RlLmtleSwgbGFzdFBvaW50WCwgbGFzdFBvaW50WSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zb2xlLmxvZyh4ICsgJyAnICsgbm9kZS5rZXkubmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNlcnRTZWdtZW50cyhpbnRlcmlvciwgdXBwZXIsIHN3ZWVwTGluZVBvcykge1xuICAgICAgbGFzdFBvaW50WSA9IHN3ZWVwTGluZVBvcy55O1xuICAgICAgbGFzdFBvaW50WCA9IHN3ZWVwTGluZVBvcy54O1xuICAgICAgdmFyIGtleTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRlcmlvci5sZW5ndGg7ICsraSkge1xuICAgICAgICBrZXkgPSBpbnRlcmlvcltpXTtcbiAgICAgICAgc3RhdHVzLmFkZChrZXkpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IHVwcGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGtleSA9IHVwcGVyW2ldO1xuICAgICAgICBzdGF0dXMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlU2VnbWVudHMobG93ZXIsIGludGVyaW9yLCBzd2VlcExpbmVQb3MpIHtcbiAgICAgIC8vIEkgc3BlbnQgbW9zdCBvZiB0aGUgdGltZSBkZWJ1Z2dpbmcgdGhpcyBtZXRob2QuIERlcGVuZGluZyBvbiB0aGVcbiAgICAgIC8vIGFsZ29yaXRobSBzdGF0ZSB3ZSBjYW4gcnVuIGludG8gc2l0dWF0aW9uIHdoZW4gZHluYW1pYyBrZXlzIG9mIHRoZVxuICAgICAgLy8gYHN0YXR1c2AgdHJlZSBwcmVkaWN0IHdyb25nIGJyYW5jaCwgYW5kIHRodXMgd2UgYXJlIG5vdCBhYmxlIHRvIGZpbmRcbiAgICAgIC8vIHRoZSBzZWdtZW50IHRoYXQgbmVlZHMgdG8gYmUgZGVsZXRlZC4gSWYgdGhhdCBoYXBwZW5zIEknbSB0cnlpbmcgdG9cbiAgICAgIC8vIHVzZSBwcmV2aW91cyBwb2ludCBhbmQgcmVwZWF0IHRoZSBwcm9jZXNzLiBUaGlzIG1heSByZXN1bHQgaW4gXG4gICAgICAvLyBpbmNvcnJlY3Qgc3RhdGUuIEluIHRoYXQgY2FzZSBJIHJlcG9ydCBhbiBlcnJvci4gXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBwcmV2Q291bnQgPSBzdGF0dXMuX3NpemU7XG4gICAgICBwcmV2WCA9IGxhc3RQb2ludFg7XG4gICAgICBwcmV2WSA9IGxhc3RQb2ludFk7XG4gICAgICBsYXN0UG9pbnRZID0gc3dlZXBMaW5lUG9zLnk7XG4gICAgICBsYXN0UG9pbnRYID0gc3dlZXBMaW5lUG9zLng7XG5cbiAgICAgIHVzZUJlbG93ID0gdHJ1ZTtcbiAgICAgIGZvcihpID0gMDsgaSA8IGxvd2VyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlbW92ZVNlZ21lbnQobG93ZXJbaV0sIHN3ZWVwTGluZVBvcyk7XG4gICAgICB9XG4gICAgICBmb3IoaSA9IDA7IGkgPCBpbnRlcmlvci5sZW5ndGg7ICsraSkge1xuICAgICAgICByZW1vdmVTZWdtZW50KGludGVyaW9yW2ldLCBzd2VlcExpbmVQb3MpO1xuICAgICAgfVxuICAgICAgdXNlQmVsb3cgPSBmYWxzZTtcblxuICAgICAgaWYgKHN0YXR1cy5fc2l6ZSAhPT0gcHJldkNvdW50IC0gaW50ZXJpb3IubGVuZ3RoIC0gbG93ZXIubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHJvdW5kaW5nIGVycm9yIG9jY3Vycy4gWW91IGNhbiB0cnkgc2NhbGluZyB5b3VyIGlucHV0XG4gICAgICAgIG9uRXJyb3IoJ1NlZ21lbnRzIHdlcmUgbm90IHJlbW92ZWQgZnJvbSBhIHRyZWUgcHJvcGVybHkuIFByZWNpc2lvbiBlcnJvcj8nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTZWdtZW50KGtleSwgc3dlZXBMaW5lUG9zKSB7XG4gICAgICBpZiAoc3RhdHVzLmZpbmQoa2V5KSkge1xuICAgICAgICBzdGF0dXMucmVtb3ZlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0UG9pbnRYID0gcHJldlg7XG4gICAgICAgIGxhc3RQb2ludFkgPSBwcmV2WTtcbiAgICAgICAgaWYgKHN0YXR1cy5maW5kKGtleSkpIHtcbiAgICAgICAgICBzdGF0dXMucmVtb3ZlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBvaW50WSA9IHN3ZWVwTGluZVBvcy55O1xuICAgICAgICBsYXN0UG9pbnRYID0gc3dlZXBMaW5lUG9zLng7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzaW5nbGUgZXZlbnQgaW4gdGhlIHN3ZWVwLWxpbmUgYWxnb3JpdGhtXG4gICAqL1xuICB2YXIgU3dlZXBFdmVudCA9IGZ1bmN0aW9uIFN3ZWVwRXZlbnQocG9pbnQsIHNlZ21lbnQpIHtcbiAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgaWYgKHNlZ21lbnQpIHsgdGhpcy5mcm9tID0gW3NlZ21lbnRdOyB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgcG9pbnQgb24gYSBsaW5lXG4gICAqIFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxuICAgKiBAcHJvcGVydHkge251bWJlcn0geCBjb29yZGluYXRlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IGNvb3JkaW5hdGVcbiAgICovXG5cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gU2VnbWVudCBcbiAgICogQHByb3BlcnR5IHtQb2ludH0gZnJvbSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgKiBAcHJvcGVydHkge1BvaW50fSB0byBlbmQgb2YgdGhlIHNlZ21lbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtmdW5jdGlvbihwb2ludCA6IFBvaW50LCBpbnRlcmlvciA6IFNlZ21lbnRbXSwgbG93ZXIgOiBTZWdtZW50W10sIHVwcGVyIDogU2VnbWVudFtdKX0gUmVwb3J0SW50ZXJzZWN0aW9uQ2FsbGJhY2tcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IElTZWN0T3B0aW9ucyBcbiAgICogQHByb3BlcnR5IHtSZXBvcnRJbnRlcnNlY3Rpb25DYWxsYmFja30gb25Gb3VuZCBcbiAgICovXG5cbiAgIC8qKlxuICAgICogQHR5cGVkZWYge09iamVjdH0gSVNlY3RSZXN1bHRcbiAgICAqL1xuXG4gIC8vIFdlIHVzZSBFTVBUWSBhcnJheSB0byBhdm9pZCBwcmVzc3VyZSBvbiBnYXJiYWdlIGNvbGxlY3Rvci4gTmVlZCB0byBiZVxuICAvLyB2ZXJ5IGNhdXRpb3VzIHRvIG5vdCBtdXRhdGUgdGhpcyBhcnJheS5cbiAgdmFyIEVNUFRZID0gW107XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBpbnRlcnNlY3Rpb25zIGFtb25nIGdpdmVuIHNlZ21lbnRzLlxuICAgKiBcbiAgICogVGhlIGFsZ29yaXRobSBmb2xsb3dzIFwiQ29tcHV0YXRpb24gR2VvbWV0cnksIEFsZ29yaXRobXMgYW5kIEFwcGxpY2F0aW9uc1wiIGJvb2tcbiAgICogYnkgTWFyayBkZSBCZXJnLCBPdGZyaWVkIENoZW9uZywgTWFyYyB2YW4gS3JldmVsZCwgYW5kIE1hcmsgT3Zlcm1hcnMuXG4gICAqIFxuICAgKiBMaW5lIGlzIHN3ZXB0IHRvcC1kb3duXG4gICAqIFxuICAgKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAgICogQHBhcmFtIHtJU2VjdE9wdGlvbnM9fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtJU2VjdFJlc3VsdH1cbiAgICovXG4gIGZ1bmN0aW9uIGlzZWN0KHNlZ21lbnRzLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgcmVwb3J0SW50ZXJzZWN0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5vbkZvdW5kKSB8fCBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXI7XG5cbiAgICB2YXIgb25FcnJvciA9IChvcHRpb25zICYmIG9wdGlvbnMub25FcnJvcikgfHwgZGVmYXVsdEVycm9yUmVwb3J0ZXI7XG5cbiAgICB2YXIgZXZlbnRRdWV1ZSA9IGNyZWF0ZUV2ZW50UXVldWUoYnlZKTtcbiAgICB2YXIgc3dlZXBTdGF0dXMgPSBjcmVhdGVTd2VlcFN0YXR1cyhvbkVycm9yLCBFUFMpO1xuICAgIHZhciBsb3dlciwgaW50ZXJpb3IsIGxhc3RQb2ludDtcblxuICAgIHNlZ21lbnRzLmZvckVhY2goYWRkU2VnbWVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIGFsbCBpbnRlcnNlY3Rpb25zIHN5bmNocm9ub3VzbHkuXG4gICAgICAgKiBcbiAgICAgICAqIEByZXR1cm5zIGFycmF5IG9mIGZvdW5kIGludGVyc2VjdGlvbnMuXG4gICAgICAgKi9cbiAgICAgIHJ1bjogcnVuLFxuXG4gICAgICAvKipcbiAgICAgICAqIFBlcmZvcm1zIGEgc2luZ2xlIHN0ZXAgaW4gdGhlIHN3ZWVwIGxpbmUgYWxnb3JpdGhtXG4gICAgICAgKiBcbiAgICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlcmUgd2FzIHNvbWV0aGluZyB0byBwcm9jZXNzOyBGYWxzZSBpZiBubyBtb3JlIHdvcmsgdG8gZG9cbiAgICAgICAqL1xuICAgICAgc3RlcDogc3RlcCxcblxuICAgICAgLy8gTWV0aG9kcyBiZWxvdyBhcmUgbG93IGxldmVsIEFQSSBmb3IgZmluZS1ncmFpbmVkIGNvbnRyb2wuXG4gICAgICAvLyBEb24ndCB1c2UgaXQgdW5sZXNzIHlvdSB1bmRlcnN0YW5kIHRoaXMgY29kZSB0aG9yb3VnaGx5XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIHNlZ21lbnQgaW50byB0aGUgXG4gICAgICAgKi9cbiAgICAgIGFkZFNlZ21lbnQ6IGFkZFNlZ21lbnQsXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlyZWN0IGFjY2VzcyB0byBldmVudCBxdWV1ZS4gUXVldWUgY29udGFpbnMgc2VnbWVudCBlbmRwb2ludHMgYW5kXG4gICAgICAgKiBwZW5kaW5nIGRldGVjdGVkIGludGVyc2VjdGlvbnMuXG4gICAgICAgKi9cbiAgICAgIGV2ZW50UXVldWU6IGV2ZW50UXVldWUsIFxuXG4gICAgICAvKipcbiAgICAgICAqIERpcmVjdCBhY2Nlc3MgdG8gc3dlZXAgbGluZSBzdGF0dXMuIFwiU3RhdHVzXCIgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcbiAgICAgICAqIGFsbCBpbnRlcnNlY3RlZCBzZWdtZW50cy5cbiAgICAgICAqL1xuICAgICAgc3dlZXBTdGF0dXM6IHN3ZWVwU3RhdHVzLFxuXG4gICAgICAvKipcbiAgICAgICAqIEFjY2VzcyB0byByZXN1bHRzIGFycmF5LiBXb3JrcyBvbmx5IHdoZW4geW91IHVzZSBkZWZhdWx0IG9uRm91bmQoKSBoYW5kbGVyXG4gICAgICAgKi9cbiAgICAgIHJlc3VsdHM6IHJlc3VsdHNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4oKSB7XG4gICAgICB3aGlsZSAoIWV2ZW50UXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgIHZhciBldmVudFBvaW50ID0gZXZlbnRRdWV1ZS5wb3AoKTtcbiAgICAgICAgaWYgKGhhbmRsZUV2ZW50UG9pbnQoZXZlbnRQb2ludCkpIHtcbiAgICAgICAgICAvLyB0aGV5IGRlY2lkZWQgdG8gc3RvcC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKCFldmVudFF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICB2YXIgZXZlbnRQb2ludCA9IGV2ZW50UXVldWUucG9wKCk7XG4gICAgICAgIGhhbmRsZUV2ZW50UG9pbnQoZXZlbnRQb2ludCk7XG4gICAgICAgIC8vIE5vdGU6IHdlIGRvbid0IGNoZWNrIHJlc3VsdHMgb2YgYGhhbmRsZUV2ZW50UG9pbnQoKWBcbiAgICAgICAgLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGNsaWVudCBjb250cm9scyBgc3RlcCgpYCBhbmQgdGh1cyB0aGV5IFxuICAgICAgICAvLyBrbm93IGJldHRlciBpZiB0aGV5IHdhbnQgdG8gc3RvcC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRXZlbnRQb2ludChwKSB7XG4gICAgICBsYXN0UG9pbnQgPSBwLnBvaW50O1xuICAgICAgdmFyIHVwcGVyID0gcC5mcm9tIHx8IEVNUFRZO1xuXG4gICAgICBsb3dlciA9IGludGVyaW9yID0gdW5kZWZpbmVkO1xuICAgICAgLy8gVE9ETzogbW92ZSBsb3dlci9pbnRlcmlvciBpbnRvIHN3ZWVwIHN0YXR1cyBtZXRob2Q/XG5cbiAgICAgIHN3ZWVwU3RhdHVzLmZpbmRTZWdtZW50c1dpdGhQb2ludChsYXN0UG9pbnQsIGFkZExvd2VyT3JJbnRlcmlvcik7XG4gICAgICAvLyBpZiAoc2VnbWVudHNXaXRoUG9pbnQpIHtcbiAgICAgIC8vICAgc2VnbWVudHNXaXRoUG9pbnQuZm9yRWFjaCgpXG4gICAgICAvLyB9IFxuXG4gICAgICBpZiAoIWxvd2VyKSB7IGxvd2VyID0gRU1QVFk7IH1cbiAgICAgIGlmICghaW50ZXJpb3IpIHsgaW50ZXJpb3IgPSBFTVBUWTsgfVxuXG4gICAgICB2YXIgdUxlbmd0aCA9IHVwcGVyLmxlbmd0aDtcbiAgICAgIHZhciBpTGVuZ3RoID0gaW50ZXJpb3IubGVuZ3RoO1xuICAgICAgdmFyIGxMZW5ndGggPSBsb3dlci5sZW5ndGg7XG4gICAgICB2YXIgaGFzSW50ZXJzZWN0aW9uID0gdUxlbmd0aCArIGlMZW5ndGggKyBsTGVuZ3RoID4gMTtcbiAgICAgIHZhciBoYXNQb2ludEludGVyc2VjdGlvbiA9ICFoYXNJbnRlcnNlY3Rpb24gJiYgKHVMZW5ndGggPT09IDAgJiYgbExlbmd0aCA9PT0gMCAmJiBpTGVuZ3RoID4gMCk7XG5cbiAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb24gfHwgaGFzUG9pbnRJbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgcC5pc1JlcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHJlcG9ydEludGVyc2VjdGlvbihsYXN0UG9pbnQsIHVuaW9uKGludGVyaW9yLCB1bmlvbihsb3dlciwgdXBwZXIpKSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2VlcFN0YXR1cy5kZWxldGVTZWdtZW50cyhsb3dlciwgaW50ZXJpb3IsIGxhc3RQb2ludCk7XG4gICAgICBzd2VlcFN0YXR1cy5pbnNlcnRTZWdtZW50cyhpbnRlcmlvciwgdXBwZXIsIGxhc3RQb2ludCk7XG5cbiAgICAgIHZhciBzTGVmdCwgc1JpZ2h0O1xuXG4gICAgICB2YXIgaGFzTm9Dcm9zc2luZyA9ICh1TGVuZ3RoICsgaUxlbmd0aCA9PT0gMCk7XG5cbiAgICAgIGlmIChoYXNOb0Nyb3NzaW5nKSB7XG4gICAgICAgIHZhciBsZWZ0UmlnaHQgPSBzd2VlcFN0YXR1cy5nZXRMZWZ0UmlnaHRQb2ludChsYXN0UG9pbnQpO1xuICAgICAgICBzTGVmdCA9IGxlZnRSaWdodC5sZWZ0O1xuICAgICAgICBpZiAoIXNMZWZ0KSB7IHJldHVybjsgfVxuXG4gICAgICAgIHNSaWdodCA9IGxlZnRSaWdodC5yaWdodDtcbiAgICAgICAgaWYgKCFzUmlnaHQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgZmluZE5ld0V2ZW50KHNMZWZ0LCBzUmlnaHQsIHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJvdW5kYXJ5U2VnbWVudHMgPSBzd2VlcFN0YXR1cy5nZXRCb3VuZGFyeVNlZ21lbnRzKHVwcGVyLCBpbnRlcmlvcik7XG5cbiAgICAgICAgZmluZE5ld0V2ZW50KGJvdW5kYXJ5U2VnbWVudHMuYmVmb3JlTGVmdCwgYm91bmRhcnlTZWdtZW50cy5sZWZ0LCBwKTtcbiAgICAgICAgZmluZE5ld0V2ZW50KGJvdW5kYXJ5U2VnbWVudHMucmlnaHQsIGJvdW5kYXJ5U2VnbWVudHMuYWZ0ZXJSaWdodCwgcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRMb3dlck9ySW50ZXJpb3Iocykge1xuICAgICAgaWYgKHNhbWVQb2ludChzLnRvLCBsYXN0UG9pbnQpKSB7XG4gICAgICAgIGlmICghbG93ZXIpIHsgbG93ZXIgPSBbc107IH1cbiAgICAgICAgZWxzZSB7IGxvd2VyLnB1c2gocyk7IH1cbiAgICAgIH0gZWxzZSBpZiAoIXNhbWVQb2ludChzLmZyb20sIGxhc3RQb2ludCkpIHtcbiAgICAgICAgaWYgKCFpbnRlcmlvcikgeyBpbnRlcmlvciA9IFtzXTsgfVxuICAgICAgICBlbHNlIHsgaW50ZXJpb3IucHVzaChzKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmROZXdFdmVudChsZWZ0LCByaWdodCwgcCkge1xuICAgICAgaWYgKCFsZWZ0IHx8ICFyaWdodCkgeyByZXR1cm47IH1cblxuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGludGVyc2VjdFNlZ21lbnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgIGlmICghaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHkgPSBwLnBvaW50LnkgLSBpbnRlcnNlY3Rpb24ueTtcbiAgICAgIC8vIFRPRE86IHNob3VsZCBJIGFkZCBkeSB0byBpbnRlcnNlY3Rpb24ueT9cbiAgICAgIGlmIChkeSA8IC1FUFMpIHtcbiAgICAgICAgLy8gdGhpcyBtZWFucyBpbnRlcnNlY3Rpb24gaGFwcGVuZWQgYWZ0ZXIgdGhlIHN3ZWVwIGxpbmUuIFxuICAgICAgICAvLyBXZSBhbHJlYWR5IHByb2Nlc3NlZCBpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKGR5KSA8IEVQUyAmJiBpbnRlcnNlY3Rpb24ueCA8PSBwLnBvaW50LngpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOZWVkIHRvIGFkanVzdCBmbG9hdGluZyBwb2ludCBmb3IgdGhpcyBzcGVjaWFsIGNhc2UsXG4gICAgICAvLyBzaW5jZSBvdGhlcndpc2UgaXQgZ2l2ZXMgcm91bmRpbmcgZXJyb3JzOlxuICAgICAgcm91bmROZWFyWmVybyhpbnRlcnNlY3Rpb24pO1xuXG4gICAgICB2YXIgY3VycmVudCA9IGV2ZW50UXVldWUuZmluZChpbnRlcnNlY3Rpb24pO1xuXG4gICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmlzUmVwb3J0ZWQpIHtcbiAgICAgICAgLy8gV2UgYWxyZWFkeSByZXBvcnRlZCB0aGlzIGV2ZW50LiBObyBuZWVkIHRvIGFkZCBpdCBvbmUgbW9yZSB0aW1lXG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgY2FzZSBldmVuIHBvc3NpYmxlP1xuICAgICAgICBvbkVycm9yKCdXZSBhbHJlYWR5IHJlcG9ydGVkIHRoaXMgZXZlbnQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBTd2VlcEV2ZW50KGludGVyc2VjdGlvbik7XG4gICAgICAgIGV2ZW50UXVldWUuaW5zZXJ0KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXIocCwgc2VnbWVudHMpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIHBvaW50OiBwLCBcbiAgICAgICAgc2VnbWVudHM6IHNlZ21lbnRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgIHZhciBmcm9tID0gc2VnbWVudC5mcm9tO1xuICAgICAgdmFyIHRvID0gc2VnbWVudC50bztcblxuICAgICAgLy8gU21hbGwgbnVtYmVycyBnaXZlIG1vcmUgcHJlY2lzaW9uIGVycm9ycy4gUm91bmRpbmcgdGhlbSB0byAwLlxuICAgICAgcm91bmROZWFyWmVybyhmcm9tKTtcbiAgICAgIHJvdW5kTmVhclplcm8odG8pO1xuXG4gICAgICB2YXIgZHkgPSBmcm9tLnkgLSB0by55O1xuXG4gICAgICAvLyBOb3RlOiBkeSBpcyBtdWNoIHNtYWxsZXIgdGhlbiBFUFMgb24gcHVycG9zZS4gSSBmb3VuZCB0aGF0IGhpZ2hlclxuICAgICAgLy8gcHJlY2lzaW9uIGhlcmUgZG9lcyBsZXNzIGdvb2QgLSBnZXR0aW5nIHdheSBtb3JlIHJvdW5kaW5nIGVycm9ycy5cbiAgICAgIGlmIChNYXRoLmFicyhkeSkgPCAxZS01KSB7XG4gICAgICAgIGZyb20ueSA9IHRvLnk7XG4gICAgICAgIHNlZ21lbnQuZHkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKChmcm9tLnkgPCB0by55KSB8fCAoXG4gICAgICAgICAgKGZyb20ueSA9PT0gdG8ueSkgJiYgKGZyb20ueCA+IHRvLngpKVxuICAgICAgICApIHtcbiAgICAgICAgdmFyIHRlbXAgPSBmcm9tO1xuICAgICAgICBmcm9tID0gc2VnbWVudC5mcm9tID0gdG87IFxuICAgICAgICB0byA9IHNlZ21lbnQudG8gPSB0ZW1wO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBwcmUtY29tcHV0ZSBzb21lIGltbXV0YWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzZWdtZW50XG4gICAgICAvLyBUaGV5IGFyZSB1c2VkIHF1aXRlIG9mdGVuIGluIHRoZSB0cmVlIHRyYXZlcnNhbCwgYW5kIHByZS1jb21wdXRhdGlvblxuICAgICAgLy8gZ2l2ZXMgc2lnbmlmaWNhbnQgYm9vc3Q6XG4gICAgICBzZWdtZW50LmR5ID0gZnJvbS55IC0gdG8ueTtcbiAgICAgIHNlZ21lbnQuZHggPSBmcm9tLnggLSB0by54O1xuICAgICAgc2VnbWVudC5hbmdsZSA9IGFuZ2xlKHNlZ21lbnQuZHksIHNlZ21lbnQuZHgpO1xuXG4gICAgICB2YXIgaXNQb2ludCA9IHNlZ21lbnQuZHkgPT09IHNlZ21lbnQuZHggJiYgc2VnbWVudC5keSA9PT0gMDtcbiAgICAgIHZhciBwcmV2ID0gZXZlbnRRdWV1ZS5maW5kKGZyb20pO1xuICAgICAgaWYgKHByZXYgJiYgIWlzUG9pbnQpIHtcbiAgICAgICAgLy8gdGhpcyBkZXRlY3RzIGlkZW50aWNhbCBzZWdtZW50cyBlYXJseS4gV2l0aG91dCB0aGlzIGNoZWNrXG4gICAgICAgIC8vIHRoZSBhbGdvcml0aG0gd291bGQgYnJlYWsgc2luY2Ugc3dlZXAgbGluZSBoYXMgbm8gbWVhbnMgdG9cbiAgICAgICAgLy8gZGV0ZWN0IGlkZW50aWNhbCBzZWdtZW50cy5cbiAgICAgICAgdmFyIHByZXZGcm9tID0gcHJldi5kYXRhLmZyb207XG4gICAgICAgIGlmIChwcmV2RnJvbSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkZyb20ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzID0gcHJldkZyb21baV07XG4gICAgICAgICAgICBpZiAoc2FtZVBvaW50KHMudG8sIHRvKSkge1xuICAgICAgICAgICAgICByZXBvcnRJbnRlcnNlY3Rpb24ocy5mcm9tLCBbcy5mcm9tLCBzLnRvXSk7XG4gICAgICAgICAgICAgIHJlcG9ydEludGVyc2VjdGlvbihzLnRvLCBbcy5mcm9tLCBzLnRvXSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1BvaW50KSB7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgaWYgKHByZXYuZGF0YS5mcm9tKSB7IHByZXYuZGF0YS5mcm9tLnB1c2goc2VnbWVudCk7IH1cbiAgICAgICAgICBlbHNlIHsgcHJldi5kYXRhLmZyb20gPSBbc2VnbWVudF07IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZSA9IG5ldyBTd2VlcEV2ZW50KGZyb20sIHNlZ21lbnQpO1xuICAgICAgICAgIGV2ZW50UXVldWUuaW5zZXJ0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBTd2VlcEV2ZW50KHRvKTtcbiAgICAgICAgZXZlbnRRdWV1ZS5pbnNlcnQoZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IFN3ZWVwRXZlbnQodG8pO1xuICAgICAgICBldmVudFF1ZXVlLmluc2VydChldmVudCk7XG4gICAgICB9XG4gICAgfSBcbiAgfVxuXG4gIGZ1bmN0aW9uIHJvdW5kTmVhclplcm8ocG9pbnQpIHtcbiAgICBpZiAoTWF0aC5hYnMocG9pbnQueCkgPCBFUFMpIHsgcG9pbnQueCA9IDA7IH1cbiAgICBpZiAoTWF0aC5hYnMocG9pbnQueSkgPCBFUFMpIHsgcG9pbnQueSA9IDA7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRFcnJvclJlcG9ydGVyKGVycm9yTWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5pb24oYSwgYikge1xuICAgIGlmICghYSkgeyByZXR1cm4gYjsgfVxuICAgIGlmICghYikgeyByZXR1cm4gYTsgfVxuXG4gICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICB9XG5cbiAgZnVuY3Rpb24gYnlZKGEsIGIpIHtcbiAgICAvLyBkZWNyZWFzaW5nIFkgXG4gICAgdmFyIHJlcyA9IGIueSAtIGEueTtcbiAgICAvLyBUT0RPOiBUaGlzIG1pZ2h0IG1lc3MgdXAgdGhlIHN0YXR1cyB0cmVlLlxuICAgIGlmIChNYXRoLmFicyhyZXMpIDwgRVBTKSB7XG4gICAgICAvLyBpbmNyZWFzaW5nIHguXG4gICAgICByZXMgPSBhLnggLSBiLng7XG4gICAgICBpZiAoTWF0aC5hYnMocmVzKSA8IEVQUykgeyByZXMgPSAwOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVyc2VjdFNlZ21lbnRzJDEoYSwgYikge1xuICAgIC8vIE5vdGU6IHRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIGdlb20uaW50ZXJzZWN0U2VnbWVudHMoKVxuICAgIC8vIFRoZSBtYWluIGRpZmZlcmVuY2UgaXMgdGhhdCB3ZSBkb24ndCBoYXZlIGEgcHJlLWNvbXB1dGVkXG4gICAgLy8gdmFsdWUgZm9yIGR4L2R5IG9uIHRoZSBzZWdtZW50cy5cbiAgICAvLyAgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NjgzNDUvMTI1MzUxXG4gICAgdmFyIGFTdGFydCA9IGEuZnJvbSwgYlN0YXJ0ID0gYi5mcm9tO1xuICAgIHZhciBwMF94ID0gYVN0YXJ0LngsIHAwX3kgPSBhU3RhcnQueSxcbiAgICAgICAgcDJfeCA9IGJTdGFydC54LCBwMl95ID0gYlN0YXJ0Lnk7XG5cbiAgICB2YXIgczFfeCA9IGEuZnJvbS54IC0gYS50by54LCBzMV95ID0gYS5mcm9tLnkgLSBhLnRvLnksIHMyX3ggPSBiLmZyb20ueCAtIGIudG8ueCwgczJfeSA9IGIuZnJvbS55IC0gYi50by55O1xuICAgIHZhciBkaXYgPSBzMV94ICogczJfeSAtIHMyX3ggKiBzMV95O1xuXG4gICAgdmFyIHMgPSAoczFfeSAqIChwMF94IC0gcDJfeCkgLSBzMV94ICogKHAwX3kgLSBwMl95KSkgLyBkaXY7XG4gICAgaWYgKHMgPCAwIHx8IHMgPiAxKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIHQgPSAoczJfeCAqIChwMl95IC0gcDBfeSkgKyBzMl95ICogKHAwX3ggLSBwMl94KSkgLyBkaXY7XG5cbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcDBfeCAtICh0ICogczFfeCksXG4gICAgICAgIHk6IHAwX3kgLSAodCAqIHMxX3kpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBicnV0ZSBmb3JjZSBzb2x1dGlvbiB3aXRoIE8obl4yKSBwZXJmb3JtYW5jZS5cbiAgICogKGBuYCBpcyBudW1iZXIgb2Ygc2VnbWVudHMpLlxuICAgKiBcbiAgICogVXNlIHRoaXMgd2hlbiBudW1iZXIgb2YgbGluZXMgaXMgbG93LCBhbmQgbnVtYmVyIG9mIGludGVyc2VjdGlvbnNcbiAgICogaXMgaGlnaC5cbiAgICovXG4gIGZ1bmN0aW9uIGJydXRlKGxpbmVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgcmVwb3J0SW50ZXJzZWN0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5vbkZvdW5kKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRJbnRlcnNlY3Rpb25SZXBvcnRlcjtcbiAgICB2YXIgYXN5bmNTdGF0ZTtcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4ZWN1dGUgYnJ1dGUgZm9yY2Ugb2YgdGhlIHNlZ21lbnQgaW50ZXJzZWN0aW9uIHNlYXJjaFxuICAgICAgICovXG4gICAgICBydW46IHJ1bixcbiAgICAgIC8qKlxuICAgICAgICogQWNjZXNzIHRvIHJlc3VsdHMgYXJyYXkuIFdvcmtzIG9ubHkgd2hlbiB5b3UgdXNlIGRlZmF1bHQgb25Gb3VuZCgpIGhhbmRsZXJcbiAgICAgICAqL1xuICAgICAgcmVzdWx0czogcmVzdWx0cyxcblxuICAgICAgLyoqXG4gICAgICAgKiBQZXJmb3JtcyBhIHNpbmdsZSBzdGVwIGluIHRoZSBicnV0ZSBmb3JjZSBhbGdvcml0aG0gKClcbiAgICAgICAqL1xuICAgICAgc3RlcDogc3RlcFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICBpZiAoIWFzeW5jU3RhdGUpIHtcbiAgICAgICAgYXN5bmNTdGF0ZSA9IHtcbiAgICAgICAgICBpOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgdGVzdCA9IGxpbmVzW2FzeW5jU3RhdGUuaV07XG4gICAgICBmb3IgKHZhciBqID0gYXN5bmNTdGF0ZS5pICsgMTsgaiA8IGxpbmVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGxpbmVzW2pdO1xuICAgICAgICB2YXIgcHQgPSBpbnRlcnNlY3RTZWdtZW50cyQxKHRlc3QsIG90aGVyKTtcbiAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgaWYgKHJlcG9ydEludGVyc2VjdGlvbihwdCwgW3Rlc3QsIG90aGVyXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzeW5jU3RhdGUuaSArPSAxO1xuICAgICAgcmV0dXJuIGFzeW5jU3RhdGUuaSA8IGxpbmVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4oKSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBsaW5lc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgb3RoZXIgPSBsaW5lc1tqXTtcbiAgICAgICAgICB2YXIgcHQgPSBpbnRlcnNlY3RTZWdtZW50cyQxKHRlc3QsIG90aGVyKTtcbiAgICAgICAgICBpZiAocHQpIHtcbiAgICAgICAgICAgIGlmIChyZXBvcnRJbnRlcnNlY3Rpb24ocHQsIFt0ZXN0LCBvdGhlcl0pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRJbnRlcnNlY3Rpb25SZXBvcnRlcihwLCBpbnRlcmlvcikge1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgcG9pbnQ6IHAsIFxuICAgICAgICBzZWdtZW50czogaW50ZXJpb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBBUlJBWV9UWVBFUyA9IFtcbiAgICAgIEludDhBcnJheSwgVWludDhBcnJheSwgVWludDhDbGFtcGVkQXJyYXksIEludDE2QXJyYXksIFVpbnQxNkFycmF5LFxuICAgICAgSW50MzJBcnJheSwgVWludDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQ2NEFycmF5XG4gIF07XG5cbiAgdmFyIFZFUlNJT04gPSAzOyAvLyBzZXJpYWxpemVkIGZvcm1hdCB2ZXJzaW9uXG5cbiAgdmFyIEZsYXRidXNoID0gZnVuY3Rpb24gRmxhdGJ1c2gobnVtSXRlbXMsIG5vZGVTaXplLCBBcnJheVR5cGUsIGRhdGEpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAobnVtSXRlbXMgPT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ6IG51bUl0ZW1zLicpOyB9XG4gICAgICBpZiAoaXNOYU4obnVtSXRlbXMpIHx8IG51bUl0ZW1zIDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKChcIlVucGV4cGVjdGVkIG51bUl0ZW1zIHZhbHVlOiBcIiArIG51bUl0ZW1zICsgXCIuXCIpKTsgfVxuXG4gICAgICB0aGlzLm51bUl0ZW1zID0gK251bUl0ZW1zO1xuICAgICAgdGhpcy5ub2RlU2l6ZSA9IE1hdGgubWluKE1hdGgubWF4KCtub2RlU2l6ZSB8fCAxNiwgMiksIDY1NTM1KTtcblxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIFItdHJlZSB0byBhbGxvY2F0ZSBzcGFjZSBmb3JcbiAgICAgIC8vIGFuZCB0aGUgaW5kZXggb2YgZWFjaCB0cmVlIGxldmVsICh1c2VkIGluIHNlYXJjaCBsYXRlcilcbiAgICAgIHZhciBuID0gbnVtSXRlbXM7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBuO1xuICAgICAgdGhpcy5fbGV2ZWxCb3VuZHMgPSBbbiAqIDRdO1xuICAgICAgZG8ge1xuICAgICAgICAgIG4gPSBNYXRoLmNlaWwobiAvIHRoaXMkMS5ub2RlU2l6ZSk7XG4gICAgICAgICAgbnVtTm9kZXMgKz0gbjtcbiAgICAgICAgICB0aGlzJDEuX2xldmVsQm91bmRzLnB1c2gobnVtTm9kZXMgKiA0KTtcbiAgICAgIH0gd2hpbGUgKG4gIT09IDEpO1xuXG4gICAgICB0aGlzLkFycmF5VHlwZSA9IEFycmF5VHlwZSB8fCBGbG9hdDY0QXJyYXk7XG4gICAgICB0aGlzLkluZGV4QXJyYXlUeXBlID0gbnVtTm9kZXMgPCAxNjM4NCA/IFVpbnQxNkFycmF5IDogVWludDMyQXJyYXk7XG5cbiAgICAgIHZhciBhcnJheVR5cGVJbmRleCA9IEFSUkFZX1RZUEVTLmluZGV4T2YodGhpcy5BcnJheVR5cGUpO1xuICAgICAgdmFyIG5vZGVzQnl0ZVNpemUgPSBudW1Ob2RlcyAqIDQgKiB0aGlzLkFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcblxuICAgICAgaWYgKGFycmF5VHlwZUluZGV4IDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJVbmV4cGVjdGVkIHR5cGVkIGFycmF5IGNsYXNzOiBcIiArIEFycmF5VHlwZSArIFwiLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhICYmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICB0aGlzLl9ib3hlcyA9IG5ldyB0aGlzLkFycmF5VHlwZSh0aGlzLmRhdGEsIDgsIG51bU5vZGVzICogNCk7XG4gICAgICAgICAgdGhpcy5faW5kaWNlcyA9IG5ldyB0aGlzLkluZGV4QXJyYXlUeXBlKHRoaXMuZGF0YSwgOCArIG5vZGVzQnl0ZVNpemUsIG51bU5vZGVzKTtcblxuICAgICAgICAgIHRoaXMuX3BvcyA9IG51bU5vZGVzICogNDtcbiAgICAgICAgICB0aGlzLm1pblggPSB0aGlzLl9ib3hlc1t0aGlzLl9wb3MgLSA0XTtcbiAgICAgICAgICB0aGlzLm1pblkgPSB0aGlzLl9ib3hlc1t0aGlzLl9wb3MgLSAzXTtcbiAgICAgICAgICB0aGlzLm1heFggPSB0aGlzLl9ib3hlc1t0aGlzLl9wb3MgLSAyXTtcbiAgICAgICAgICB0aGlzLm1heFkgPSB0aGlzLl9ib3hlc1t0aGlzLl9wb3MgLSAxXTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXJyYXlCdWZmZXIoOCArIG5vZGVzQnl0ZVNpemUgKyBudW1Ob2RlcyAqIHRoaXMuSW5kZXhBcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgICAgICAgIHRoaXMuX2JveGVzID0gbmV3IHRoaXMuQXJyYXlUeXBlKHRoaXMuZGF0YSwgOCwgbnVtTm9kZXMgKiA0KTtcbiAgICAgICAgICB0aGlzLl9pbmRpY2VzID0gbmV3IHRoaXMuSW5kZXhBcnJheVR5cGUodGhpcy5kYXRhLCA4ICsgbm9kZXNCeXRlU2l6ZSwgbnVtTm9kZXMpO1xuICAgICAgICAgIHRoaXMuX3BvcyA9IDA7XG4gICAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgICAgICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG4gICAgICAgICAgdGhpcy5tYXhYID0gLUluZmluaXR5O1xuICAgICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcblxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgMCwgMikuc2V0KFsweGZiLCAoVkVSU0lPTiA8PCA0KSArIGFycmF5VHlwZUluZGV4XSk7XG4gICAgICAgICAgbmV3IFVpbnQxNkFycmF5KHRoaXMuZGF0YSwgMiwgMSlbMF0gPSBub2RlU2l6ZTtcbiAgICAgICAgICBuZXcgVWludDMyQXJyYXkodGhpcy5kYXRhLCA0LCAxKVswXSA9IG51bUl0ZW1zO1xuICAgICAgfVxuICB9O1xuXG4gIEZsYXRidXNoLmZyb20gPSBmdW5jdGlvbiBmcm9tIChkYXRhKSB7XG4gICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgQXJyYXlCdWZmZXIuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgMCwgMik7XG4gICAgICAgICAgdmFyIG1hZ2ljID0gcmVmWzBdO1xuICAgICAgICAgIHZhciB2ZXJzaW9uQW5kVHlwZSA9IHJlZlsxXTtcbiAgICAgIGlmIChtYWdpYyAhPT0gMHhmYikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgaW4gYSBGbGF0YnVzaCBmb3JtYXQuJyk7XG4gICAgICB9XG4gICAgICBpZiAodmVyc2lvbkFuZFR5cGUgPj4gNCAhPT0gVkVSU0lPTikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJHb3QgdlwiICsgKHZlcnNpb25BbmRUeXBlID4+IDQpICsgXCIgZGF0YSB3aGVuIGV4cGVjdGVkIHZcIiArIFZFUlNJT04gKyBcIi5cIikpO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiQxID0gbmV3IFVpbnQxNkFycmF5KGRhdGEsIDIsIDEpO1xuICAgICAgICAgIHZhciBub2RlU2l6ZSA9IHJlZiQxWzBdO1xuICAgICAgdmFyIHJlZiQyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEsIDQsIDEpO1xuICAgICAgICAgIHZhciBudW1JdGVtcyA9IHJlZiQyWzBdO1xuXG4gICAgICByZXR1cm4gbmV3IEZsYXRidXNoKG51bUl0ZW1zLCBub2RlU2l6ZSwgQVJSQVlfVFlQRVNbdmVyc2lvbkFuZFR5cGUgJiAweDBmXSwgZGF0YSk7XG4gIH07XG5cbiAgRmxhdGJ1c2gucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobWluWCwgbWluWSwgbWF4WCwgbWF4WSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fcG9zID4+IDI7XG4gICAgICB0aGlzLl9pbmRpY2VzW2luZGV4XSA9IGluZGV4O1xuICAgICAgdGhpcy5fYm94ZXNbdGhpcy5fcG9zKytdID0gbWluWDtcbiAgICAgIHRoaXMuX2JveGVzW3RoaXMuX3BvcysrXSA9IG1pblk7XG4gICAgICB0aGlzLl9ib3hlc1t0aGlzLl9wb3MrK10gPSBtYXhYO1xuICAgICAgdGhpcy5fYm94ZXNbdGhpcy5fcG9zKytdID0gbWF4WTtcblxuICAgICAgaWYgKG1pblggPCB0aGlzLm1pblgpIHsgdGhpcy5taW5YID0gbWluWDsgfVxuICAgICAgaWYgKG1pblkgPCB0aGlzLm1pblkpIHsgdGhpcy5taW5ZID0gbWluWTsgfVxuICAgICAgaWYgKG1heFggPiB0aGlzLm1heFgpIHsgdGhpcy5tYXhYID0gbWF4WDsgfVxuICAgICAgaWYgKG1heFkgPiB0aGlzLm1heFkpIHsgdGhpcy5tYXhZID0gbWF4WTsgfVxuICB9O1xuXG4gIEZsYXRidXNoLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fcG9zID4+IDIgIT09IHRoaXMubnVtSXRlbXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiQWRkZWQgXCIgKyAodGhpcy5fcG9zID4+IDIpICsgXCIgaXRlbXMgd2hlbiBleHBlY3RlZCBcIiArICh0aGlzLm51bUl0ZW1zKSArIFwiLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IHRoaXMubWF4WCAtIHRoaXMubWluWDtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLm1heFkgLSB0aGlzLm1pblk7XG4gICAgICB2YXIgaGlsYmVydFZhbHVlcyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLm51bUl0ZW1zKTtcbiAgICAgIHZhciBoaWxiZXJ0TWF4ID0gKDEgPDwgMTYpIC0gMTtcblxuICAgICAgLy8gbWFwIGl0ZW0gY2VudGVycyBpbnRvIEhpbGJlcnQgY29vcmRpbmF0ZSBzcGFjZSBhbmQgY2FsY3VsYXRlIEhpbGJlcnQgdmFsdWVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtSXRlbXM7IGkrKykge1xuICAgICAgICAgIHZhciBwb3MgPSA0ICogaTtcbiAgICAgICAgICB2YXIgbWluWCA9IHRoaXMkMS5fYm94ZXNbcG9zKytdO1xuICAgICAgICAgIHZhciBtaW5ZID0gdGhpcyQxLl9ib3hlc1twb3MrK107XG4gICAgICAgICAgdmFyIG1heFggPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgICB2YXIgbWF4WSA9IHRoaXMkMS5fYm94ZXNbcG9zKytdO1xuICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihoaWxiZXJ0TWF4ICogKChtaW5YICsgbWF4WCkgLyAyIC0gdGhpcyQxLm1pblgpIC8gd2lkdGgpO1xuICAgICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihoaWxiZXJ0TWF4ICogKChtaW5ZICsgbWF4WSkgLyAyIC0gdGhpcyQxLm1pblkpIC8gaGVpZ2h0KTtcbiAgICAgICAgICBoaWxiZXJ0VmFsdWVzW2ldID0gaGlsYmVydCh4LCB5KTtcbiAgICAgIH1cblxuICAgICAgLy8gc29ydCBpdGVtcyBieSB0aGVpciBIaWxiZXJ0IHZhbHVlIChmb3IgcGFja2luZyBsYXRlcilcbiAgICAgIHNvcnQkMShoaWxiZXJ0VmFsdWVzLCB0aGlzLl9ib3hlcywgdGhpcy5faW5kaWNlcywgMCwgdGhpcy5udW1JdGVtcyAtIDEpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBub2RlcyBhdCBlYWNoIHRyZWUgbGV2ZWwsIGJvdHRvbS11cFxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgcG9zJDEgPSAwOyBpJDEgPCB0aGlzLl9sZXZlbEJvdW5kcy5sZW5ndGggLSAxOyBpJDErKykge1xuICAgICAgICAgIHZhciBlbmQgPSB0aGlzJDEuX2xldmVsQm91bmRzW2kkMV07XG5cbiAgICAgICAgICAvLyBnZW5lcmF0ZSBhIHBhcmVudCBub2RlIGZvciBlYWNoIGJsb2NrIG9mIGNvbnNlY3V0aXZlIDxub2RlU2l6ZT4gbm9kZXNcbiAgICAgICAgICB3aGlsZSAocG9zJDEgPCBlbmQpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGVNaW5YID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgIHZhciBub2RlTWluWSA9IEluZmluaXR5O1xuICAgICAgICAgICAgICB2YXIgbm9kZU1heFggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgIHZhciBub2RlTWF4WSA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHBvcyQxO1xuXG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBiYm94IGZvciB0aGUgbmV3IG5vZGVcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5ub2RlU2l6ZSAmJiBwb3MkMSA8IGVuZDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtaW5YJDEgPSB0aGlzJDEuX2JveGVzW3BvcyQxKytdO1xuICAgICAgICAgICAgICAgICAgdmFyIG1pblkkMSA9IHRoaXMkMS5fYm94ZXNbcG9zJDErK107XG4gICAgICAgICAgICAgICAgICB2YXIgbWF4WCQxID0gdGhpcyQxLl9ib3hlc1twb3MkMSsrXTtcbiAgICAgICAgICAgICAgICAgIHZhciBtYXhZJDEgPSB0aGlzJDEuX2JveGVzW3BvcyQxKytdO1xuICAgICAgICAgICAgICAgICAgaWYgKG1pblgkMSA8IG5vZGVNaW5YKSB7IG5vZGVNaW5YID0gbWluWCQxOyB9XG4gICAgICAgICAgICAgICAgICBpZiAobWluWSQxIDwgbm9kZU1pblkpIHsgbm9kZU1pblkgPSBtaW5ZJDE7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChtYXhYJDEgPiBub2RlTWF4WCkgeyBub2RlTWF4WCA9IG1heFgkMTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG1heFkkMSA+IG5vZGVNYXhZKSB7IG5vZGVNYXhZID0gbWF4WSQxOyB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBhZGQgdGhlIG5ldyBub2RlIHRvIHRoZSB0cmVlIGRhdGFcbiAgICAgICAgICAgICAgdGhpcyQxLl9pbmRpY2VzW3RoaXMkMS5fcG9zID4+IDJdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICB0aGlzJDEuX2JveGVzW3RoaXMkMS5fcG9zKytdID0gbm9kZU1pblg7XG4gICAgICAgICAgICAgIHRoaXMkMS5fYm94ZXNbdGhpcyQxLl9wb3MrK10gPSBub2RlTWluWTtcbiAgICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNYXhYO1xuICAgICAgICAgICAgICB0aGlzJDEuX2JveGVzW3RoaXMkMS5fcG9zKytdID0gbm9kZU1heFk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9O1xuXG4gIEZsYXRidXNoLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2ggKG1pblgsIG1pblksIG1heFgsIG1heFksIGZpbHRlckZuKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9wb3MgIT09IHRoaXMuX2JveGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBub3QgeWV0IGluZGV4ZWQgLSBjYWxsIGluZGV4LmZpbmlzaCgpLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5fYm94ZXMubGVuZ3RoIC0gNDtcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsQm91bmRzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgIHdoaWxlIChub2RlSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGZpbmQgdGhlIGVuZCBpbmRleCBvZiB0aGUgbm9kZVxuICAgICAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihub2RlSW5kZXggKyB0aGlzJDEubm9kZVNpemUgKiA0LCB0aGlzJDEuX2xldmVsQm91bmRzW2xldmVsXSk7XG5cbiAgICAgICAgICAvLyBzZWFyY2ggdGhyb3VnaCBjaGlsZCBub2Rlc1xuICAgICAgICAgIGZvciAodmFyIHBvcyA9IG5vZGVJbmRleDsgcG9zIDwgZW5kOyBwb3MgKz0gNCkge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzJDEuX2luZGljZXNbcG9zID4+IDJdO1xuXG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIG5vZGUgYmJveCBpbnRlcnNlY3RzIHdpdGggcXVlcnkgYmJveFxuICAgICAgICAgICAgICBpZiAobWF4WCA8IHRoaXMkMS5fYm94ZXNbcG9zXSkgeyBjb250aW51ZTsgfSAvLyBtYXhYIDwgbm9kZU1pblhcbiAgICAgICAgICAgICAgaWYgKG1heFkgPCB0aGlzJDEuX2JveGVzW3BvcyArIDFdKSB7IGNvbnRpbnVlOyB9IC8vIG1heFkgPCBub2RlTWluWVxuICAgICAgICAgICAgICBpZiAobWluWCA+IHRoaXMkMS5fYm94ZXNbcG9zICsgMl0pIHsgY29udGludWU7IH0gLy8gbWluWCA+IG5vZGVNYXhYXG4gICAgICAgICAgICAgIGlmIChtaW5ZID4gdGhpcyQxLl9ib3hlc1twb3MgKyAzXSkgeyBjb250aW51ZTsgfSAvLyBtaW5ZID4gbm9kZU1heFlcblxuICAgICAgICAgICAgICBpZiAobm9kZUluZGV4IDwgdGhpcyQxLm51bUl0ZW1zICogNCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckZuID09PSB1bmRlZmluZWQgfHwgZmlsdGVyRm4oaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGluZGV4KTsgLy8gbGVhZiBpdGVtXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goaW5kZXgpOyAvLyBub2RlOyBhZGQgaXQgdG8gdGhlIHNlYXJjaCBxdWV1ZVxuICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChsZXZlbCAtIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV2ZWwgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgICBub2RlSW5kZXggPSBxdWV1ZS5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gY3VzdG9tIHF1aWNrc29ydCB0aGF0IHNvcnRzIGJib3ggZGF0YSBhbG9uZ3NpZGUgdGhlIGhpbGJlcnQgdmFsdWVzXG4gIGZ1bmN0aW9uIHNvcnQkMSh2YWx1ZXMsIGJveGVzLCBpbmRpY2VzLCBsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKGxlZnQgPj0gcmlnaHQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBwaXZvdCA9IHZhbHVlc1sobGVmdCArIHJpZ2h0KSA+PiAxXTtcbiAgICAgIHZhciBpID0gbGVmdCAtIDE7XG4gICAgICB2YXIgaiA9IHJpZ2h0ICsgMTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBkbyB7IGkrKzsgfSB3aGlsZSAodmFsdWVzW2ldIDwgcGl2b3QpO1xuICAgICAgICAgIGRvIHsgai0tOyB9IHdoaWxlICh2YWx1ZXNbal0gPiBwaXZvdCk7XG4gICAgICAgICAgaWYgKGkgPj0gaikgeyBicmVhazsgfVxuICAgICAgICAgIHN3YXAodmFsdWVzLCBib3hlcywgaW5kaWNlcywgaSwgaik7XG4gICAgICB9XG5cbiAgICAgIHNvcnQkMSh2YWx1ZXMsIGJveGVzLCBpbmRpY2VzLCBsZWZ0LCBqKTtcbiAgICAgIHNvcnQkMSh2YWx1ZXMsIGJveGVzLCBpbmRpY2VzLCBqICsgMSwgcmlnaHQpO1xuICB9XG5cbiAgLy8gc3dhcCB0d28gdmFsdWVzIGFuZCB0d28gY29ycmVzcG9uZGluZyBib3hlc1xuICBmdW5jdGlvbiBzd2FwKHZhbHVlcywgYm94ZXMsIGluZGljZXMsIGksIGopIHtcbiAgICAgIHZhciB0ZW1wID0gdmFsdWVzW2ldO1xuICAgICAgdmFsdWVzW2ldID0gdmFsdWVzW2pdO1xuICAgICAgdmFsdWVzW2pdID0gdGVtcDtcblxuICAgICAgdmFyIGsgPSA0ICogaTtcbiAgICAgIHZhciBtID0gNCAqIGo7XG5cbiAgICAgIHZhciBhID0gYm94ZXNba107XG4gICAgICB2YXIgYiA9IGJveGVzW2sgKyAxXTtcbiAgICAgIHZhciBjID0gYm94ZXNbayArIDJdO1xuICAgICAgdmFyIGQgPSBib3hlc1trICsgM107XG4gICAgICBib3hlc1trXSA9IGJveGVzW21dO1xuICAgICAgYm94ZXNbayArIDFdID0gYm94ZXNbbSArIDFdO1xuICAgICAgYm94ZXNbayArIDJdID0gYm94ZXNbbSArIDJdO1xuICAgICAgYm94ZXNbayArIDNdID0gYm94ZXNbbSArIDNdO1xuICAgICAgYm94ZXNbbV0gPSBhO1xuICAgICAgYm94ZXNbbSArIDFdID0gYjtcbiAgICAgIGJveGVzW20gKyAyXSA9IGM7XG4gICAgICBib3hlc1ttICsgM10gPSBkO1xuXG4gICAgICB2YXIgZSA9IGluZGljZXNbaV07XG4gICAgICBpbmRpY2VzW2ldID0gaW5kaWNlc1tqXTtcbiAgICAgIGluZGljZXNbal0gPSBlO1xuICB9XG5cbiAgLy8gRmFzdCBIaWxiZXJ0IGN1cnZlIGFsZ29yaXRobSBieSBodHRwOi8vdGhyZWFkbG9jYWxtdXRleC5jb20vXG4gIC8vIFBvcnRlZCBmcm9tIEMrKyBodHRwczovL2dpdGh1Yi5jb20vcmF3cnVucHJvdGVjdGVkL2hpbGJlcnRfY3VydmVzIChwdWJsaWMgZG9tYWluKVxuICBmdW5jdGlvbiBoaWxiZXJ0KHgsIHkpIHtcbiAgICAgIHZhciBhID0geCBeIHk7XG4gICAgICB2YXIgYiA9IDB4RkZGRiBeIGE7XG4gICAgICB2YXIgYyA9IDB4RkZGRiBeICh4IHwgeSk7XG4gICAgICB2YXIgZCA9IHggJiAoeSBeIDB4RkZGRik7XG5cbiAgICAgIHZhciBBID0gYSB8IChiID4+IDEpO1xuICAgICAgdmFyIEIgPSAoYSA+PiAxKSBeIGE7XG4gICAgICB2YXIgQyA9ICgoYyA+PiAxKSBeIChiICYgKGQgPj4gMSkpKSBeIGM7XG4gICAgICB2YXIgRCA9ICgoYSAmIChjID4+IDEpKSBeIChkID4+IDEpKSBeIGQ7XG5cbiAgICAgIGEgPSBBOyBiID0gQjsgYyA9IEM7IGQgPSBEO1xuICAgICAgQSA9ICgoYSAmIChhID4+IDIpKSBeIChiICYgKGIgPj4gMikpKTtcbiAgICAgIEIgPSAoKGEgJiAoYiA+PiAyKSkgXiAoYiAmICgoYSBeIGIpID4+IDIpKSk7XG4gICAgICBDIF49ICgoYSAmIChjID4+IDIpKSBeIChiICYgKGQgPj4gMikpKTtcbiAgICAgIEQgXj0gKChiICYgKGMgPj4gMikpIF4gKChhIF4gYikgJiAoZCA+PiAyKSkpO1xuXG4gICAgICBhID0gQTsgYiA9IEI7IGMgPSBDOyBkID0gRDtcbiAgICAgIEEgPSAoKGEgJiAoYSA+PiA0KSkgXiAoYiAmIChiID4+IDQpKSk7XG4gICAgICBCID0gKChhICYgKGIgPj4gNCkpIF4gKGIgJiAoKGEgXiBiKSA+PiA0KSkpO1xuICAgICAgQyBePSAoKGEgJiAoYyA+PiA0KSkgXiAoYiAmIChkID4+IDQpKSk7XG4gICAgICBEIF49ICgoYiAmIChjID4+IDQpKSBeICgoYSBeIGIpICYgKGQgPj4gNCkpKTtcblxuICAgICAgYSA9IEE7IGIgPSBCOyBjID0gQzsgZCA9IEQ7XG4gICAgICBDIF49ICgoYSAmIChjID4+IDgpKSBeIChiICYgKGQgPj4gOCkpKTtcbiAgICAgIEQgXj0gKChiICYgKGMgPj4gOCkpIF4gKChhIF4gYikgJiAoZCA+PiA4KSkpO1xuXG4gICAgICBhID0gQyBeIChDID4+IDEpO1xuICAgICAgYiA9IEQgXiAoRCA+PiAxKTtcblxuICAgICAgdmFyIGkwID0geCBeIHk7XG4gICAgICB2YXIgaTEgPSBiIHwgKDB4RkZGRiBeIChpMCB8IGEpKTtcblxuICAgICAgaTAgPSAoaTAgfCAoaTAgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICAgIGkwID0gKGkwIHwgKGkwIDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgICBpMCA9IChpMCB8IChpMCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgICAgaTAgPSAoaTAgfCAoaTAgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgICAgaTEgPSAoaTEgfCAoaTEgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICAgIGkxID0gKGkxIHwgKGkxIDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgICBpMSA9IChpMSB8IChpMSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgICAgaTEgPSAoaTEgfCAoaTEgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgICAgcmV0dXJuICgoaTEgPDwgMSkgfCBpMCkgPj4+IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBpbnNwaXJlZCBieSBkaXNjdXNzaW9uIGhlcmUgXG4gICAqIGh0dHBzOi8vdHdpdHRlci5jb20vbW91cm5lci9zdGF0dXMvMTA0OTMyNTE5OTYxNzkyMTAyNCBhbmQgXG4gICAqIGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL2FudmFrYS9pc2VjdC9pc3N1ZXMvMVxuICAgKiBcbiAgICogSXQgYnVpbGRzIGFuIGluZGV4IG9mIGFsbCBzZWdtZW50cyB1c2luZyBzdGF0aWMgc3BhdGlhbCBpbmRleFxuICAgKiBhbmQgdGhlbiBmb3IgZWFjaCBzZWdtZW50IGl0IHF1ZXJpZXMgb3ZlcmxhcHBpbmcgcmVjdGFuZ2xlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJ1c2gobGluZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciByZXBvcnRJbnRlcnNlY3Rpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLm9uRm91bmQpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyO1xuICAgIHZhciBhc3luY1N0YXRlO1xuXG4gICAgdmFyIGluZGV4ID0gbmV3IEZsYXRidXNoKGxpbmVzLmxlbmd0aCk7XG4gICAgbGluZXMuZm9yRWFjaChhZGRUb0luZGV4KTtcbiAgICBpbmRleC5maW5pc2goKTtcblxuICAgIHJldHVybiB7XG4gICAgICBydW46IHJ1bixcbiAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICByZXN1bHRzOiByZXN1bHRzLFxuXG4gICAgICAvLyB1bmRvY3VtZW50ZWQsIGRvbid0IHVzZSB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nOlxuICAgICAgY2hlY2tJbnRlcnNlY3Rpb246IGNoZWNrSW50ZXJzZWN0aW9uXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoY2hlY2tJbnRlcnNlY3Rpb24obGluZXNbaV0sIGkpKSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBzdG9wIGVhcmx5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKGN1cnJlbnRTZWdtZW50LCBjdXJyZW50SWQpIHtcbiAgICAgIC8vIHNvcnJ5IGFib3V0IGNvZGUgZHVwbGljYXRpb24uXG4gICAgICB2YXIgbWluWCA9IGN1cnJlbnRTZWdtZW50LmZyb20ueDsgdmFyIG1heFggPSBjdXJyZW50U2VnbWVudC50by54O1xuICAgICAgdmFyIG1pblkgPSBjdXJyZW50U2VnbWVudC5mcm9tLnk7IHZhciBtYXhZID0gY3VycmVudFNlZ21lbnQudG8ueTtcbiAgICAgIHZhciB0O1xuICAgICAgaWYgKG1pblggPiBtYXhYKSB7IHQgPSBtaW5YOyBtaW5YID0gbWF4WDsgbWF4WCA9IHQ7IH1cbiAgICAgIGlmIChtaW5ZID4gbWF4WSkgeyB0ID0gbWluWTsgbWluWSA9IG1heFk7IG1heFkgPSB0OyB9XG5cbiAgICAgIHZhciBpZHMgPSBpbmRleC5zZWFyY2gobWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzZWdtZW50SW5kZXggPSBpZHNbaV07XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPD0gY3VycmVudElkKSB7IGNvbnRpbnVlOyB9IC8vIHdlIGhhdmUgZWl0aGVyIHJlcG9ydGVkIGl0LCBvciBpdCBpcyBjdXJyZW50LlxuXG4gICAgICAgIHZhciBvdGhlclNlZ21lbnQgPSBsaW5lc1tzZWdtZW50SW5kZXhdO1xuICAgICAgICB2YXIgcG9pbnQgPSBpbnRlcnNlY3RTZWdtZW50cyQxKG90aGVyU2VnbWVudCwgY3VycmVudFNlZ21lbnQpO1xuXG4gICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgIGlmIChyZXBvcnRJbnRlcnNlY3Rpb24ocG9pbnQsIFtjdXJyZW50U2VnbWVudCwgb3RoZXJTZWdtZW50XSkpIHtcbiAgICAgICAgICAgIC8vIHN0b3AgZWFybHlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICBpZiAoIWFzeW5jU3RhdGUpIHtcbiAgICAgICAgYXN5bmNTdGF0ZSA9IHtpOiAwfTtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXN0ID0gbGluZXNbYXN5bmNTdGF0ZS5pXTtcbiAgICAgIGNoZWNrSW50ZXJzZWN0aW9uKHRlc3QsIGFzeW5jU3RhdGUuaSk7XG4gICAgICBhc3luY1N0YXRlLmkgKz0gMTtcbiAgICAgIHJldHVybiBhc3luY1N0YXRlLmkgPCBsaW5lcy5sZW5ndGg7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhZGRUb0luZGV4KGxpbmUpIHtcbiAgICAgIHZhciBtaW5YID0gbGluZS5mcm9tLng7IHZhciBtYXhYID0gbGluZS50by54O1xuICAgICAgdmFyIG1pblkgPSBsaW5lLmZyb20ueTsgdmFyIG1heFkgPSBsaW5lLnRvLnk7XG4gICAgICB2YXIgdDtcbiAgICAgIGlmIChtaW5YID4gbWF4WCkgeyB0ID0gbWluWDsgbWluWCA9IG1heFg7IG1heFggPSB0OyB9XG4gICAgICBpZiAobWluWSA+IG1heFkpIHsgdCA9IG1pblk7IG1pblkgPSBtYXhZOyBtYXhZID0gdDsgfVxuICAgICAgaW5kZXguYWRkKG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRJbnRlcnNlY3Rpb25SZXBvcnRlcihwLCBpbnRlcmlvcikge1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgcG9pbnQ6IHAsIFxuICAgICAgICBzZWdtZW50czogaW50ZXJpb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydHMuc3dlZXAgPSBpc2VjdDtcbiAgZXhwb3J0cy5icnV0ZSA9IGJydXRlO1xuICBleHBvcnRzLmJ1c2ggPSBidXNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc2VjdC5qcy5tYXBcbiIsIi8qKlxuICogSlNUUy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FREx2MS50eHRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FUEx2MS50eHRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9MSUNFTlNFX0VTNl9DT0xMRUNUSU9OUy50eHRcbiAqIEBsaWNlbnNlXG4gKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOmUoKHQ9dHx8c2VsZikuanN0cz17fSl9KHRoaXMsKGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2NsYXNzIGV7Y29uc3RydWN0b3IoKXtlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGVxdWFsc1dpdGhUb2xlcmFuY2UodCxlLG4pe3JldHVybiBNYXRoLmFicyh0LWUpPD1ufWdldENsYXNzKCl7cmV0dXJuIGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIG4odCl7dGhpcy5tZXNzYWdlPXR9ZnVuY3Rpb24gcyh0LGUpe3RoaXMubG93PTB8ZSx0aGlzLmhpZ2g9MHx0fWZ1bmN0aW9uIGkoKXt9ZnVuY3Rpb24gcigpe31mdW5jdGlvbiBvKCl7fWZ1bmN0aW9uIGwoKXt9ZnVuY3Rpb24gYSgpe31mdW5jdGlvbiBjKHQpe3RoaXMubmFtZT1cIlJ1bnRpbWVFeGNlcHRpb25cIix0aGlzLm1lc3NhZ2U9dCx0aGlzLnN0YWNrPShuZXcgRXJyb3IpLnN0YWNrLEVycm9yLmNhbGwodGhpcyx0KX1lLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30scy50b0JpbmFyeVN0cmluZz1mdW5jdGlvbih0KXtsZXQgZSxuPVwiXCI7Zm9yKGU9MjE0NzQ4MzY0ODtlPjA7ZT4+Pj0xKW4rPSh0LmhpZ2gmZSk9PT1lP1wiMVwiOlwiMFwiO2ZvcihlPTIxNDc0ODM2NDg7ZT4wO2U+Pj49MSluKz0odC5sb3cmZSk9PT1lP1wiMVwiOlwiMFwiO3JldHVybiBufSxpLmlzTmFOPXQ9Pk51bWJlci5pc05hTih0KSxpLmlzSW5maW5pdGU9dD0+IU51bWJlci5pc0Zpbml0ZSh0KSxpLk1BWF9WQUxVRT1OdW1iZXIuTUFYX1ZBTFVFLFwiZnVuY3Rpb25cIj09dHlwZW9mIEZsb2F0NjRBcnJheSYmXCJmdW5jdGlvblwiPT10eXBlb2YgSW50MzJBcnJheT9mdW5jdGlvbigpe2NvbnN0IHQ9bmV3IEZsb2F0NjRBcnJheSgxKSxlPW5ldyBJbnQzMkFycmF5KHQuYnVmZmVyKTtpLmRvdWJsZVRvTG9uZ0JpdHM9ZnVuY3Rpb24obil7dFswXT1uO2xldCBpPTB8ZVswXSxyPTB8ZVsxXTtyZXR1cm4gMjE0NjQzNTA3Mj09KDIxNDY0MzUwNzImcikmJjAhPSgxMDQ4NTc1JnIpJiYwIT09aSYmKGk9MCxyPTIxNDY5NTkzNjApLG5ldyBzKHIsaSl9LGkubG9uZ0JpdHNUb0RvdWJsZT1mdW5jdGlvbihuKXtyZXR1cm4gZVswXT1uLmxvdyxlWzFdPW4uaGlnaCx0WzBdfX0oKTpmdW5jdGlvbigpe2NvbnN0IHQ9TWF0aC5sb2cyLGU9TWF0aC5mbG9vcixuPU1hdGgucG93LHI9ZnVuY3Rpb24oKXtmb3IobGV0IHM9NTM7cz4wO3MtLSl7Y29uc3QgaT1uKDIscyktMTtpZihlKHQoaSkpKzE9PT1zKXJldHVybiBpfXJldHVybiAwfSgpO2kuZG91YmxlVG9Mb25nQml0cz1mdW5jdGlvbihpKXtsZXQgbyxsLGEsYyxoLHUsZyxkLF87aWYoaTwwfHwxL2k9PT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk/KHU9MTw8MzEsaT0taSk6dT0wLDA9PT1pKXJldHVybiBfPTAsZD11LG5ldyBzKGQsXyk7aWYoaT09PTEvMClyZXR1cm4gXz0wLGQ9MjE0NjQzNTA3Mnx1LG5ldyBzKGQsXyk7aWYoaSE9aSlyZXR1cm4gXz0wLGQ9MjE0Njk1OTM2MCxuZXcgcyhkLF8pO2lmKGM9MCxfPTAsbz1lKGkpLG8+MSlpZihvPD1yKWM9ZSh0KG8pKSxjPD0yMD8oXz0wLGQ9bzw8MjAtYyYxMDQ4NTc1KTooYT1jLTIwLGw9bigyLGEpLF89byVsPDwzMi1hLGQ9by9sJjEwNDg1NzUpO2Vsc2UgZm9yKGE9byxfPTA7bD1hLzIsYT1lKGwpLDAhPT1hOyljKyssXz4+Pj0xLF98PSgxJmQpPDwzMSxkPj4+PTEsbCE9PWEmJihkfD01MjQyODgpO2lmKGc9YysxMDIzLGg9MD09PW8sbz1pLW8sYzw1MiYmMCE9PW8pZm9yKGE9MDs7KXtpZihsPTIqbyxsPj0xPyhvPWwtMSxoPyhnLS0saD0hMSk6KGE8PD0xLGF8PTEsYysrKSk6KG89bCxoPzA9PS0tZyYmKGMrKyxoPSExKTooYTw8PTEsYysrKSksMjA9PT1jKWR8PWEsYT0wO2Vsc2UgaWYoNTI9PT1jKXtffD1hO2JyZWFrfWlmKDE9PT1sKXtjPDIwP2R8PWE8PDIwLWM6Yzw1MiYmKF98PWE8PDUyLWMpO2JyZWFrfX1yZXR1cm4gZHw9Zzw8MjAsZHw9dSxuZXcgcyhkLF8pfSxpLmxvbmdCaXRzVG9Eb3VibGU9ZnVuY3Rpb24odCl7bGV0IGUscyxpLHIsbztjb25zdCBsPXQuaGlnaCxhPXQubG93O2ZvcihpPWwmMTw8MzE/LTE6MSxyPSgoMjE0NjQzNTA3MiZsKT4+MjApLTEwMjMsbz0wLHM9MTw8MTksZT0xO2U8PTIwO2UrKylsJnMmJihvKz1uKDIsLWUpKSxzPj4+PTE7Zm9yKHM9MTw8MzEsZT0yMTtlPD01MjtlKyspYSZzJiYobys9bigyLC1lKSkscz4+Pj0xO2lmKC0xMDIzPT09cil7aWYoMD09PW8pcmV0dXJuIDAqaTtyPS0xMDIyfWVsc2V7aWYoMTAyND09PXIpcmV0dXJuIDA9PT1vP2kvMDpOYU47bys9MX1yZXR1cm4gaSpvKm4oMixyKX19KCksYy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpLGMucHJvdG90eXBlLmNvbnN0cnVjdG9yPUVycm9yO2NsYXNzIGggZXh0ZW5kcyBje2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxoLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gaH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCljLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19O2NsYXNzIHV7Y29uc3RydWN0b3IoKXt1LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNob3VsZE5ldmVyUmVhY2hIZXJlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdS5zaG91bGROZXZlclJlYWNoSGVyZShudWxsKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aHJvdyBuZXcgaChcIlNob3VsZCBuZXZlciByZWFjaCBoZXJlXCIrKG51bGwhPT10P1wiOiBcIit0OlwiXCIpKX19c3RhdGljIGlzVHJ1ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt1LmlzVHJ1ZSh0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0KXRocm93IG51bGw9PT1lP25ldyBoOm5ldyBoKGUpfX1zdGF0aWMgZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3UuZXF1YWxzKHQsZSxudWxsKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZighZS5lcXVhbHModCkpdGhyb3cgbmV3IGgoXCJFeHBlY3RlZCBcIit0K1wiIGJ1dCBlbmNvdW50ZXJlZCBcIitlKyhudWxsIT09bj9cIjogXCIrbjpcIlwiKSl9fWdldENsYXNzKCl7cmV0dXJuIHV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBne2NvbnN0cnVjdG9yKCl7Zy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBoYXNoQ29kZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWkuZG91YmxlVG9Mb25nQml0cyh0KTtyZXR1cm4gTWF0aC50cnVuYyhlXmU+Pj4zMil9fXNldE9yZGluYXRlKHQsZSl7c3dpdGNoKHQpe2Nhc2UgZy5YOnRoaXMueD1lO2JyZWFrO2Nhc2UgZy5ZOnRoaXMueT1lO2JyZWFrO2Nhc2UgZy5aOnRoaXMuej1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IG4oXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX19ZXF1YWxzMkQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMueD09PXQueCYmdGhpcy55PT09dC55fWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4hIWUuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLngsdC54LG4pJiYhIWUuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLnksdC55LG4pfX1nZXRPcmRpbmF0ZSh0KXtzd2l0Y2godCl7Y2FzZSBnLlg6cmV0dXJuIHRoaXMueDtjYXNlIGcuWTpyZXR1cm4gdGhpcy55O2Nhc2UgZy5aOnJldHVybiB0aGlzLnp9dGhyb3cgbmV3IG4oXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX1lcXVhbHMzRCh0KXtyZXR1cm4gdGhpcy54PT09dC54JiZ0aGlzLnk9PT10LnkmJih0aGlzLno9PT10Lnp8fGkuaXNOYU4odGhpcy56KSYmaS5pc05hTih0LnopKX1lcXVhbHModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBnJiZ0aGlzLmVxdWFsczJEKHQpfWVxdWFsSW5aKHQsbil7cmV0dXJuIGUuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLnosdC56LG4pfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMueDxlLng/LTE6dGhpcy54PmUueD8xOnRoaXMueTxlLnk/LTE6dGhpcy55PmUueT8xOjB9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKXJldHVybiB1LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwidGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgdGhpcyBjbGFzcyBpcyBDbG9uZWFibGVcIiksbnVsbDt0aHJvdyB0fX1jb3B5KCl7cmV0dXJuIG5ldyBnKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIsIFwiK3RoaXMueitcIilcIn1kaXN0YW5jZTNEKHQpe2NvbnN0IGU9dGhpcy54LXQueCxuPXRoaXMueS10Lnkscz10aGlzLnotdC56O3JldHVybiBNYXRoLnNxcnQoZSplK24qbitzKnMpfWRpc3RhbmNlKHQpe2NvbnN0IGU9dGhpcy54LXQueCxuPXRoaXMueS10Lnk7cmV0dXJuIE1hdGguc3FydChlKmUrbipuKX1oYXNoQ29kZSgpe2xldCB0PTE3O3JldHVybiB0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLngpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMueSksdH1zZXRDb29yZGluYXRlKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC56fWdldENsYXNzKCl7cmV0dXJuIGd9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3IsbyxhXX19Y2xhc3MgZHtjb25zdHJ1Y3Rvcigpe2QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tcGFyZSh0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6aS5pc05hTih0KT9pLmlzTmFOKGUpPzA6LTE6aS5pc05hTihlKT8xOjB9Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWUsaT1kLmNvbXBhcmUobi54LHMueCk7aWYoMCE9PWkpcmV0dXJuIGk7Y29uc3Qgcj1kLmNvbXBhcmUobi55LHMueSk7cmV0dXJuIDAhPT1yP3I6dGhpcy5fZGltZW5zaW9uc1RvVGVzdDw9Mj8wOmQuY29tcGFyZShuLnoscy56KX1nZXRDbGFzcygpe3JldHVybiBkfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19ZnVuY3Rpb24gXyh0LGUpe3JldHVybiB0LmludGVyZmFjZXNfJiZ0LmludGVyZmFjZXNfLmluZGV4T2YoZSk+LTF9ZnVuY3Rpb24gZigpe31mdW5jdGlvbiBwKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIG0oKXt9ZnVuY3Rpb24geSh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiB4KCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmJiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfWQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZGltZW5zaW9uc1RvVGVzdD0yLDA9PT1hcmd1bWVudHMubGVuZ3RoKWQuY29uc3RydWN0b3JfLmNhbGwodGhpcywyKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigyIT09dCYmMyE9PXQpdGhyb3cgbmV3IG4oXCJvbmx5IDIgb3IgMyBkaW1lbnNpb25zIG1heSBiZSBzcGVjaWZpZWRcIik7dGhpcy5fZGltZW5zaW9uc1RvVGVzdD10fX0sZy5EaW1lbnNpb25hbENvbXBhcmF0b3I9ZCxnLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMuej1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWcuY29uc3RydWN0b3JfLmNhbGwodGhpcywwLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2cuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55LHQueil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Zy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxnLk5VTExfT1JESU5BVEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMueD10LHRoaXMueT1lLHRoaXMuej1ufX0sZy5zZXJpYWxWZXJzaW9uVUlEPTB4NWNiZjJjMjM1YzdlNTgwMCxnLk5VTExfT1JESU5BVEU9aS5OYU4sZy5YPTAsZy5ZPTEsZy5aPTIsZi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKCl7fSxmLnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24oKXt9LGYucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXt9LGYucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7fSxmLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7fSxmLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7fSxmLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt9LHAucHJvdG90eXBlPW5ldyBFcnJvcixwLnByb3RvdHlwZS5uYW1lPVwiSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvblwiLG0ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZi5wcm90b3R5cGUpLG0ucHJvdG90eXBlLmNvbnN0cnVjdG9yPW0sbS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7fSxtLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oKXt9LG0ucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXt9LHkucHJvdG90eXBlPW5ldyBFcnJvcix5LnByb3RvdHlwZS5uYW1lPVwiTm9TdWNoRWxlbWVudEV4Y2VwdGlvblwiLHgucHJvdG90eXBlPU9iamVjdC5jcmVhdGUobS5wcm90b3R5cGUpLHgucHJvdG90eXBlLmNvbnN0cnVjdG9yPXgseC5wcm90b3R5cGUuZW5zdXJlQ2FwYWNpdHk9ZnVuY3Rpb24oKXt9LHgucHJvdG90eXBlLmludGVyZmFjZXNfPVttLGZdLHgucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5hcnJheV8ucHVzaCh0KTp0aGlzLmFycmF5Xy5zcGxpY2UoYXJndW1lbnRzWzBdLDAsYXJndW1lbnRzWzFdKSwhMH0seC5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmFycmF5Xz1bXX0seC5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0seC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10aGlzLmFycmF5X1t0XTtyZXR1cm4gdGhpcy5hcnJheV9bdF09ZSxufSx4LnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgRSh0aGlzKX0seC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2lmKHQ8MHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IHA7cmV0dXJuIHRoaXMuYXJyYXlfW3RdfSx4LnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9LHgucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSx4LnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Y29uc3QgdD1bXTtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LHgucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXtsZXQgZT0hMTtmb3IobGV0IG49MCxzPXRoaXMuYXJyYXlfLmxlbmd0aDtuPHM7bisrKWlmKHRoaXMuYXJyYXlfW25dPT09dCl7dGhpcy5hcnJheV8uc3BsaWNlKG4sMSksZT0hMDticmVha31yZXR1cm4gZX0seC5wcm90b3R5cGUucmVtb3ZlQWxsPWZ1bmN0aW9uKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMucmVtb3ZlKGUubmV4dCgpKTtyZXR1cm4hMH07Y29uc3QgRT1mdW5jdGlvbih0KXt0aGlzLmFycmF5TGlzdF89dCx0aGlzLnBvc2l0aW9uXz0wfTtFLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLmFycmF5TGlzdF8uc2l6ZSgpKXRocm93IG5ldyB5O3JldHVybiB0aGlzLmFycmF5TGlzdF8uZ2V0KHRoaXMucG9zaXRpb25fKyspfSxFLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb25fPHRoaXMuYXJyYXlMaXN0Xy5zaXplKCl9LEUucHJvdG90eXBlLnNldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheUxpc3RfLnNldCh0aGlzLnBvc2l0aW9uXy0xLHQpfSxFLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt0aGlzLmFycmF5TGlzdF8ucmVtb3ZlKHRoaXMuYXJyYXlMaXN0Xy5nZXQodGhpcy5wb3NpdGlvbl8pKX07Y2xhc3MgSSBleHRlbmRzIHh7Y29uc3RydWN0b3IoKXtzdXBlcigpLEkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLmdldCh0KX1hZGRBbGwoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJl8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj0hMTtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl0aGlzLmFkZChzLm5leHQoKSxlKSxuPSEwO3JldHVybiBufXJldHVybiBzdXBlci5hZGRBbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfWNsb25lKCl7Y29uc3QgdD1zdXBlci5jbG9uZS5jYWxsKHRoaXMpO2ZvcihsZXQgZT0wO2U8dGhpcy5zaXplKCk7ZSsrKXQuYWRkKGUsdGhpcy5nZXQoZSkuY2xvbmUoKSk7cmV0dXJuIHR9dG9Db29yZGluYXRlQXJyYXkoKXtyZXR1cm4gdGhpcy50b0FycmF5KEkuY29vcmRBcnJheVR5cGUpfWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtzdXBlci5hZGQuY2FsbCh0aGlzLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQodCxlLCEwKSwhMH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZighYXJndW1lbnRzWzFdJiZ0aGlzLnNpemUoKT49MSl7aWYodGhpcy5nZXQodGhpcy5zaXplKCktMSkuZXF1YWxzMkQodCkpcmV0dXJuIG51bGx9c3VwZXIuYWRkLmNhbGwodGhpcyx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKHQsZSksITB9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoYXJndW1lbnRzWzJdKWZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXRoaXMuYWRkKHRbbl0sZSk7ZWxzZSBmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSl0aGlzLmFkZCh0W25dLGUpO3JldHVybiEwfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIWFyZ3VtZW50c1syXSl7Y29uc3Qgbj10aGlzLnNpemUoKTtpZihuPjApe2lmKHQ+MCl7aWYodGhpcy5nZXQodC0xKS5lcXVhbHMyRChlKSlyZXR1cm4gbnVsbH1pZih0PG4pe2lmKHRoaXMuZ2V0KHQpLmVxdWFsczJEKGUpKXJldHVybiBudWxsfX19c3VwZXIuYWRkLmNhbGwodGhpcyx0LGUpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtsZXQgaT0xO24+cyYmKGk9LTEpO2ZvcihsZXQgcj1uO3IhPT1zO3IrPWkpdGhpcy5hZGQodFtyXSxlKTtyZXR1cm4hMH19Y2xvc2VSaW5nKCl7dGhpcy5zaXplKCk+MCYmdGhpcy5hZGQobmV3IGcodGhpcy5nZXQoMCkpLCExKX1nZXRDbGFzcygpe3JldHVybiBJfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1JLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVuc3VyZUNhcGFjaXR5KHQubGVuZ3RoKSx0aGlzLmFkZCh0LCEwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVuc3VyZUNhcGFjaXR5KHQubGVuZ3RoKSx0aGlzLmFkZCh0LGUpfX0sSS5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKTtjbGFzcyBOe2NvbnN0cnVjdG9yKCl7Ti5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbnRlcnNlY3RzKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuLng+PSh0Lng8ZS54P3QueDplLngpJiZuLng8PSh0Lng+ZS54P3QueDplLngpJiZuLnk+PSh0Lnk8ZS55P3QueTplLnkpJiZuLnk8PSh0Lnk+ZS55P3QueTplLnkpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtsZXQgaT1NYXRoLm1pbihuLngscy54KSxyPU1hdGgubWF4KG4ueCxzLngpLG89TWF0aC5taW4odC54LGUueCksbD1NYXRoLm1heCh0LngsZS54KTtyZXR1cm4hKG8+cikmJighKGw8aSkmJihpPU1hdGgubWluKG4ueSxzLnkpLHI9TWF0aC5tYXgobi55LHMueSksbz1NYXRoLm1pbih0LnksZS55KSxsPU1hdGgubWF4KHQueSxlLnkpLCEobz5yKSYmIShsPGkpKSl9fWdldEFyZWEoKXtyZXR1cm4gdGhpcy5nZXRXaWR0aCgpKnRoaXMuZ2V0SGVpZ2h0KCl9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIE4pKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpOnRoaXMuX21heHg9PT1lLmdldE1heFgoKSYmdGhpcy5fbWF4eT09PWUuZ2V0TWF4WSgpJiZ0aGlzLl9taW54PT09ZS5nZXRNaW5YKCkmJnRoaXMuX21pbnk9PT1lLmdldE1pblkoKX1pbnRlcnNlY3Rpb24odCl7aWYodGhpcy5pc051bGwoKXx8dC5pc051bGwoKXx8IXRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gbmV3IE47Y29uc3QgZT10aGlzLl9taW54PnQuX21pbng/dGhpcy5fbWlueDp0Ll9taW54LG49dGhpcy5fbWlueT50Ll9taW55P3RoaXMuX21pbnk6dC5fbWlueSxzPXRoaXMuX21heHg8dC5fbWF4eD90aGlzLl9tYXh4OnQuX21heHgsaT10aGlzLl9tYXh5PHQuX21heHk/dGhpcy5fbWF4eTp0Ll9tYXh5O3JldHVybiBuZXcgTihlLHMsbixpKX1pc051bGwoKXtyZXR1cm4gdGhpcy5fbWF4eDx0aGlzLl9taW54fWdldE1heFgoKXtyZXR1cm4gdGhpcy5fbWF4eH1jb3ZlcnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModC54LHQueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmIXQuaXNOdWxsKCkmJih0LmdldE1pblgoKT49dGhpcy5fbWlueCYmdC5nZXRNYXhYKCk8PXRoaXMuX21heHgmJnQuZ2V0TWluWSgpPj10aGlzLl9taW55JiZ0LmdldE1heFkoKTw9dGhpcy5fbWF4eSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYodD49dGhpcy5fbWlueCYmdDw9dGhpcy5fbWF4eCYmZT49dGhpcy5fbWlueSYmZTw9dGhpcy5fbWF4eSl9fWludGVyc2VjdHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmIXQuaXNOdWxsKCkmJiEodC5fbWlueD50aGlzLl9tYXh4fHx0Ll9tYXh4PHRoaXMuX21pbnh8fHQuX21pbnk+dGhpcy5fbWF4eXx8dC5fbWF4eTx0aGlzLl9taW55KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmludGVyc2VjdHModC54LHQueSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmKCEoKHQueDxlLng/dC54OmUueCk+dGhpcy5fbWF4eCkmJighKCh0Lng+ZS54P3QueDplLngpPHRoaXMuX21pbngpJiYoISgodC55PGUueT90Lnk6ZS55KT50aGlzLl9tYXh5KSYmISgodC55PmUueT90Lnk6ZS55KTx0aGlzLl9taW55KSkpKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmISh0PnRoaXMuX21heHh8fHQ8dGhpcy5fbWlueHx8ZT50aGlzLl9tYXh5fHxlPHRoaXMuX21pbnkpfX19Z2V0TWluWSgpe3JldHVybiB0aGlzLl9taW55fWdldE1pblgoKXtyZXR1cm4gdGhpcy5fbWlueH1leHBhbmRUb0luY2x1ZGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZFRvSW5jbHVkZSh0LngsdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLmlzTnVsbCgpPyh0aGlzLl9taW54PXQuZ2V0TWluWCgpLHRoaXMuX21heHg9dC5nZXRNYXhYKCksdGhpcy5fbWlueT10LmdldE1pblkoKSx0aGlzLl9tYXh5PXQuZ2V0TWF4WSgpKToodC5fbWlueDx0aGlzLl9taW54JiYodGhpcy5fbWlueD10Ll9taW54KSx0Ll9tYXh4PnRoaXMuX21heHgmJih0aGlzLl9tYXh4PXQuX21heHgpLHQuX21pbnk8dGhpcy5fbWlueSYmKHRoaXMuX21pbnk9dC5fbWlueSksdC5fbWF4eT50aGlzLl9tYXh5JiYodGhpcy5fbWF4eT10Ll9tYXh5KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaXNOdWxsKCk/KHRoaXMuX21pbng9dCx0aGlzLl9tYXh4PXQsdGhpcy5fbWlueT1lLHRoaXMuX21heHk9ZSk6KHQ8dGhpcy5fbWlueCYmKHRoaXMuX21pbng9dCksdD50aGlzLl9tYXh4JiYodGhpcy5fbWF4eD10KSxlPHRoaXMuX21pbnkmJih0aGlzLl9taW55PWUpLGU+dGhpcy5fbWF4eSYmKHRoaXMuX21heHk9ZSkpfX1taW5FeHRlbnQoKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gdDxlP3Q6ZX1nZXRXaWR0aCgpe3JldHVybiB0aGlzLmlzTnVsbCgpPzA6dGhpcy5fbWF4eC10aGlzLl9taW54fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKT8wOi0xOmUuaXNOdWxsKCk/MTp0aGlzLl9taW54PGUuX21pbng/LTE6dGhpcy5fbWlueD5lLl9taW54PzE6dGhpcy5fbWlueTxlLl9taW55Py0xOnRoaXMuX21pbnk+ZS5fbWlueT8xOnRoaXMuX21heHg8ZS5fbWF4eD8tMTp0aGlzLl9tYXh4PmUuX21heHg/MTp0aGlzLl9tYXh5PGUuX21heHk/LTE6dGhpcy5fbWF4eT5lLl9tYXh5PzE6MH10cmFuc2xhdGUodCxlKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuaW5pdCh0aGlzLmdldE1pblgoKSt0LHRoaXMuZ2V0TWF4WCgpK3QsdGhpcy5nZXRNaW5ZKCkrZSx0aGlzLmdldE1heFkoKStlKX10b1N0cmluZygpe3JldHVyblwiRW52W1wiK3RoaXMuX21pbngrXCIgOiBcIit0aGlzLl9tYXh4K1wiLCBcIit0aGlzLl9taW55K1wiIDogXCIrdGhpcy5fbWF4eStcIl1cIn1zZXRUb051bGwoKXt0aGlzLl9taW54PTAsdGhpcy5fbWF4eD0tMSx0aGlzLl9taW55PTAsdGhpcy5fbWF4eT0tMX1nZXRIZWlnaHQoKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMuX21heHktdGhpcy5fbWlueX1tYXhFeHRlbnQoKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gdD5lP3Q6ZX1leHBhbmRCeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZEJ5KHQsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLl9taW54LT10LHRoaXMuX21heHgrPXQsdGhpcy5fbWlueS09ZSx0aGlzLl9tYXh5Kz1lLCh0aGlzLl9taW54PnRoaXMuX21heHh8fHRoaXMuX21pbnk+dGhpcy5fbWF4eSkmJnRoaXMuc2V0VG9OdWxsKCl9fWNvbnRhaW5zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb3ZlcnModCxlKX19Y2VudHJlKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/bnVsbDpuZXcgZygodGhpcy5nZXRNaW5YKCkrdGhpcy5nZXRNYXhYKCkpLzIsKHRoaXMuZ2V0TWluWSgpK3RoaXMuZ2V0TWF4WSgpKS8yKX1pbml0KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5zZXRUb051bGwoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9taW54PXQuX21pbngsdGhpcy5fbWF4eD10Ll9tYXh4LHRoaXMuX21pbnk9dC5fbWlueSx0aGlzLl9tYXh5PXQuX21heHl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdCh0LngsZS54LHQueSxlLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3Q8ZT8odGhpcy5fbWlueD10LHRoaXMuX21heHg9ZSk6KHRoaXMuX21pbng9ZSx0aGlzLl9tYXh4PXQpLG48cz8odGhpcy5fbWlueT1uLHRoaXMuX21heHk9cyk6KHRoaXMuX21pbnk9cyx0aGlzLl9tYXh5PW4pfX1nZXRNYXhZKCl7cmV0dXJuIHRoaXMuX21heHl9ZGlzdGFuY2UodCl7aWYodGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiAwO2xldCBlPTA7dGhpcy5fbWF4eDx0Ll9taW54P2U9dC5fbWlueC10aGlzLl9tYXh4OnRoaXMuX21pbng+dC5fbWF4eCYmKGU9dGhpcy5fbWlueC10Ll9tYXh4KTtsZXQgbj0wO3JldHVybiB0aGlzLl9tYXh5PHQuX21pbnk/bj10Ll9taW55LXRoaXMuX21heHk6dGhpcy5fbWlueT50Ll9tYXh5JiYobj10aGlzLl9taW55LXQuX21heHkpLDA9PT1lP246MD09PW4/ZTpNYXRoLnNxcnQoZSplK24qbil9aGFzaENvZGUoKXtsZXQgdD0xNztyZXR1cm4gdD0zNyp0K2cuaGFzaENvZGUodGhpcy5fbWlueCksdD0zNyp0K2cuaGFzaENvZGUodGhpcy5fbWF4eCksdD0zNyp0K2cuaGFzaENvZGUodGhpcy5fbWlueSksdD0zNyp0K2cuaGFzaENvZGUodGhpcy5fbWF4eSksdH1nZXRDbGFzcygpe3JldHVybiBOfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyLGFdfX1mdW5jdGlvbiBDKCl7fU4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbWlueD1udWxsLHRoaXMuX21heHg9bnVsbCx0aGlzLl9taW55PW51bGwsdGhpcy5fbWF4eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQueCx0LngsdC55LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0KHQueCxlLngsdC55LGUueSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5pbml0KHQsZSxuLHMpfX0sTi5zZXJpYWxWZXJzaW9uVUlEPTB4NTE4NDVjZDU1MjE4OTgwMDtjbGFzcyBTIGV4dGVuZHMgQ3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIFN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIHcodCl7dGhpcy5zdHI9dH1mdW5jdGlvbiBMKHQpe3RoaXMudmFsdWU9dH1mdW5jdGlvbiBUKCl7fVMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Qy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFwiUHJvamVjdGl2ZSBwb2ludCBub3QgcmVwcmVzZW50YWJsZSBvbiB0aGUgQ2FydGVzaWFuIHBsYW5lLlwiKX0sdy5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKHQpe3RoaXMuc3RyKz10fSx3LnByb3RvdHlwZS5zZXRDaGFyQXQ9ZnVuY3Rpb24odCxlKXt0aGlzLnN0cj10aGlzLnN0ci5zdWJzdHIoMCx0KStlK3RoaXMuc3RyLnN1YnN0cih0KzEpfSx3LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdHJ9LEwucHJvdG90eXBlLmludFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9LEwucHJvdG90eXBlLmNvbXBhcmVUbz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy52YWx1ZTx0Py0xOnRoaXMudmFsdWU+dD8xOjB9LEwuaXNOYU49dD0+TnVtYmVyLmlzTmFOKHQpLFQuaXNXaGl0ZXNwYWNlPXQ9PnQ8PTMyJiZ0Pj0wfHwxMjc9PT10LFQudG9VcHBlckNhc2U9dD0+dC50b1VwcGVyQ2FzZSgpO2NsYXNzIFJ7Y29uc3RydWN0b3IoKXtSLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNxcih0KXtyZXR1cm4gUi52YWx1ZU9mKHQpLnNlbGZNdWx0aXBseSh0KX1zdGF0aWMgdmFsdWVPZigpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBSLnBhcnNlKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgUih0KX19c3RhdGljIHNxcnQodCl7cmV0dXJuIFIudmFsdWVPZih0KS5zcXJ0KCl9c3RhdGljIHBhcnNlKHQpe2xldCBlPTA7Y29uc3Qgbj10Lmxlbmd0aDtmb3IoO1QuaXNXaGl0ZXNwYWNlKHQuY2hhckF0KGUpKTspZSsrO2xldCBzPSExO2lmKGU8bil7Y29uc3Qgbj10LmNoYXJBdChlKTtcIi1cIiE9PW4mJlwiK1wiIT09bnx8KGUrKyxcIi1cIj09PW4mJihzPSEwKSl9Y29uc3QgaT1uZXcgUjtsZXQgcj0wLG89MCxsPTA7Zm9yKDshKGU+PW4pOyl7Y29uc3Qgbj10LmNoYXJBdChlKTtpZihlKyssVC5pc0RpZ2l0KG4pKXtjb25zdCB0PW4tXCIwXCI7aS5zZWxmTXVsdGlwbHkoUi5URU4pLGkuc2VsZkFkZCh0KSxyKyt9ZWxzZXtpZihcIi5cIiE9PW4pe2lmKFwiZVwiPT09bnx8XCJFXCI9PT1uKXtjb25zdCBuPXQuc3Vic3RyaW5nKGUpO3RyeXtsPUwucGFyc2VJbnQobil9Y2F0Y2goZSl7dGhyb3cgZSBpbnN0YW5jZW9mIE51bWJlckZvcm1hdEV4Y2VwdGlvbj9uZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiSW52YWxpZCBleHBvbmVudCBcIituK1wiIGluIHN0cmluZyBcIit0KTplfWJyZWFrfXRocm93IG5ldyBOdW1iZXJGb3JtYXRFeGNlcHRpb24oXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIrbitcIicgYXQgcG9zaXRpb24gXCIrZStcIiBpbiBzdHJpbmcgXCIrdCl9bz1yfX1sZXQgYT1pO2NvbnN0IGM9ci1vLWw7aWYoMD09PWMpYT1pO2Vsc2UgaWYoYz4wKXtjb25zdCB0PVIuVEVOLnBvdyhjKTthPWkuZGl2aWRlKHQpfWVsc2UgaWYoYzwwKXtjb25zdCB0PVIuVEVOLnBvdygtYyk7YT1pLm11bHRpcGx5KHQpfXJldHVybiBzP2EubmVnYXRlKCk6YX1zdGF0aWMgY3JlYXRlTmFOKCl7cmV0dXJuIG5ldyBSKGkuTmFOLGkuTmFOKX1zdGF0aWMgY29weSh0KXtyZXR1cm4gbmV3IFIodCl9c3RhdGljIG1hZ25pdHVkZSh0KXtjb25zdCBlPU1hdGguYWJzKHQpLG49TWF0aC5sb2coZSkvTWF0aC5sb2coMTApO2xldCBzPU1hdGgudHJ1bmMoTWF0aC5mbG9vcihuKSk7cmV0dXJuIDEwKk1hdGgucG93KDEwLHMpPD1lJiYocys9MSksc31zdGF0aWMgc3RyaW5nT2ZDaGFyKHQsZSl7Y29uc3Qgbj1uZXcgdztmb3IobGV0IHM9MDtzPGU7cysrKW4uYXBwZW5kKHQpO3JldHVybiBuLnRvU3RyaW5nKCl9bGUodCl7cmV0dXJuIHRoaXMuX2hpPHQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbzw9dC5fbG99ZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKHQsZSl7bGV0IG49dGhpcy5hYnMoKSxzPVIubWFnbml0dWRlKG4uX2hpKTtjb25zdCBpPVIuVEVOLnBvdyhzKTtuPW4uZGl2aWRlKGkpLG4uZ3QoUi5URU4pPyhuPW4uZGl2aWRlKFIuVEVOKSxzKz0xKTpuLmx0KFIuT05FKSYmKG49bi5tdWx0aXBseShSLlRFTikscy09MSk7Y29uc3Qgcj1zKzEsbz1uZXcgdyxsPVIuTUFYX1BSSU5UX0RJR0lUUy0xO2ZvcihsZXQgZT0wO2U8PWw7ZSsrKXt0JiZlPT09ciYmby5hcHBlbmQoXCIuXCIpO2NvbnN0IHM9TWF0aC50cnVuYyhuLl9oaSk7aWYoczwwKWJyZWFrO2xldCBpPSExLGE9MDtzPjk/KGk9ITAsYT1cIjlcIik6YT1cIjBcIitzLG8uYXBwZW5kKGEpLG49bi5zdWJ0cmFjdChSLnZhbHVlT2YocykpLm11bHRpcGx5KFIuVEVOKSxpJiZuLnNlbGZBZGQoUi5URU4pO2xldCBjPSEwO2NvbnN0IGg9Ui5tYWduaXR1ZGUobi5faGkpO2lmKGg8MCYmTWF0aC5hYnMoaCk+PWwtZSYmKGM9ITEpLCFjKWJyZWFrfXJldHVybiBlWzBdPXMsby50b1N0cmluZygpfXNxcigpe3JldHVybiB0aGlzLm11bHRpcGx5KHRoaXMpfWRvdWJsZVZhbHVlKCl7cmV0dXJuIHRoaXMuX2hpK3RoaXMuX2xvfXN1YnRyYWN0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5hZGQodC5uZWdhdGUoKSl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKC10KX19ZXF1YWxzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPT09dC5fbG99fWlzWmVybygpe3JldHVybiAwPT09dGhpcy5faGkmJjA9PT10aGlzLl9sb31zZWxmU3VidHJhY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLXQuX2hpLC10Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOnRoaXMuc2VsZkFkZCgtdCwwKX19Z2V0U3BlY2lhbE51bWJlclN0cmluZygpe3JldHVybiB0aGlzLmlzWmVybygpP1wiMC4wXCI6dGhpcy5pc05hTigpP1wiTmFOIFwiOm51bGx9bWluKHQpe3JldHVybiB0aGlzLmxlKHQpP3RoaXM6dH1zZWxmRGl2aWRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh0Ll9oaSx0Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh0LDApfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGwsYT1udWxsLGM9bnVsbDtyZXR1cm4gbz10aGlzLl9oaS90LGw9Ui5TUExJVCpvLG49bC1vLGM9Ui5TUExJVCp0LG49bC1uLHM9by1uLGk9Yy10LGE9byp0LGk9Yy1pLHI9dC1pLGM9bippLWErbipyK3MqaStzKnIsbD0odGhpcy5faGktYS1jK3RoaXMuX2xvLW8qZSkvdCxjPW8rbCx0aGlzLl9oaT1jLHRoaXMuX2xvPW8tYytsLHRoaXN9fWR1bXAoKXtyZXR1cm5cIkREPFwiK3RoaXMuX2hpK1wiLCBcIit0aGlzLl9sbytcIj5cIn1kaXZpZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW51bGwsbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGwsYT1udWxsO3JldHVybiByPXRoaXMuX2hpL3QuX2hpLG89Ui5TUExJVCpyLGU9by1yLGE9Ui5TUExJVCp0Ll9oaSxlPW8tZSxuPXItZSxzPWEtdC5faGksbD1yKnQuX2hpLHM9YS1zLGk9dC5faGktcyxhPWUqcy1sK2UqaStuKnMrbippLG89KHRoaXMuX2hpLWwtYSt0aGlzLl9sby1yKnQuX2xvKS90Ll9oaSxhPXIrbyxuZXcgUihhLHItYStvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gaS5pc05hTih0KT9SLmNyZWF0ZU5hTigpOlIuY29weSh0aGlzKS5zZWxmRGl2aWRlKHQsMCl9fWdlKHQpe3JldHVybiB0aGlzLl9oaT50Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG8+PXQuX2xvfXBvdyh0KXtpZigwPT09dClyZXR1cm4gUi52YWx1ZU9mKDEpO2xldCBlPW5ldyBSKHRoaXMpLG49Ui52YWx1ZU9mKDEpLHM9TWF0aC5hYnModCk7aWYocz4xKWZvcig7cz4wOylzJTI9PTEmJm4uc2VsZk11bHRpcGx5KGUpLHMvPTIscz4wJiYoZT1lLnNxcigpKTtlbHNlIG49ZTtyZXR1cm4gdDwwP24ucmVjaXByb2NhbCgpOm59Y2VpbCgpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gUi5OYU47Y29uc3QgdD1NYXRoLmNlaWwodGhpcy5faGkpO2xldCBlPTA7cmV0dXJuIHQ9PT10aGlzLl9oaSYmKGU9TWF0aC5jZWlsKHRoaXMuX2xvKSksbmV3IFIodCxlKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9oaTxlLl9oaT8tMTp0aGlzLl9oaT5lLl9oaT8xOnRoaXMuX2xvPGUuX2xvPy0xOnRoaXMuX2xvPmUuX2xvPzE6MH1yaW50KCl7aWYodGhpcy5pc05hTigpKXJldHVybiB0aGlzO3JldHVybiB0aGlzLmFkZCguNSkuZmxvb3IoKX1zZXRWYWx1ZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdCh0KSx0aGlzfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluaXQodCksdGhpc319bWF4KHQpe3JldHVybiB0aGlzLmdlKHQpP3RoaXM6dH1zcXJ0KCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gUi52YWx1ZU9mKDApO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBSLk5hTjtjb25zdCB0PTEvTWF0aC5zcXJ0KHRoaXMuX2hpKSxlPXRoaXMuX2hpKnQsbj1SLnZhbHVlT2YoZSkscz10aGlzLnN1YnRyYWN0KG4uc3FyKCkpLl9oaSooLjUqdCk7cmV0dXJuIG4uYWRkKHMpfXNlbGZBZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmQWRkKHQuX2hpLHQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsLG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGw7cmV0dXJuIHM9dGhpcy5faGkrdCxyPXMtdGhpcy5faGksaT1zLXIsaT10LXIrKHRoaXMuX2hpLWkpLG89aSt0aGlzLl9sbyxlPXMrbyxuPW8rKHMtZSksdGhpcy5faGk9ZStuLHRoaXMuX2xvPW4rKGUtdGhpcy5faGkpLHRoaXN9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbCxhPW51bGwsYz1udWxsO289dGhpcy5faGkrdCxpPXRoaXMuX2xvK2UsYT1vLXRoaXMuX2hpLGM9aS10aGlzLl9sbyxsPW8tYSxyPWktYyxsPXQtYSsodGhpcy5faGktbCkscj1lLWMrKHRoaXMuX2xvLXIpLGE9bCtpLG49bythLHM9YSsoby1uKSxhPXIrcztjb25zdCBoPW4rYSx1PWErKG4taCk7cmV0dXJuIHRoaXMuX2hpPWgsdGhpcy5fbG89dSx0aGlzfX1zZWxmTXVsdGlwbHkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodC5faGksdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0LDApfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGw7bz1SLlNQTElUKnRoaXMuX2hpLG49by10aGlzLl9oaSxsPVIuU1BMSVQqdCxuPW8tbixzPXRoaXMuX2hpLW4saT1sLXQsbz10aGlzLl9oaSp0LGk9bC1pLHI9dC1pLGw9bippLW8rbipyK3MqaStzKnIrKHRoaXMuX2hpKmUrdGhpcy5fbG8qdCk7Y29uc3QgYT1vK2w7bj1vLWE7Y29uc3QgYz1sK247cmV0dXJuIHRoaXMuX2hpPWEsdGhpcy5fbG89Yyx0aGlzfX1zZWxmU3FyKCl7cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHRoaXMpfWZsb29yKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBSLk5hTjtjb25zdCB0PU1hdGguZmxvb3IodGhpcy5faGkpO2xldCBlPTA7cmV0dXJuIHQ9PT10aGlzLl9oaSYmKGU9TWF0aC5mbG9vcih0aGlzLl9sbykpLG5ldyBSKHQsZSl9bmVnYXRlKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOm5ldyBSKC10aGlzLl9oaSwtdGhpcy5fbG8pfWNsb25lKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gbnVsbDt0aHJvdyB0fX1tdWx0aXBseSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuaXNOYU4oKT9SLmNyZWF0ZU5hTigpOlIuY29weSh0aGlzKS5zZWxmTXVsdGlwbHkodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGkuaXNOYU4odCk/Ui5jcmVhdGVOYU4oKTpSLmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHQsMCl9fWlzTmFOKCl7cmV0dXJuIGkuaXNOYU4odGhpcy5faGkpfWludFZhbHVlKCl7cmV0dXJuIE1hdGgudHJ1bmModGhpcy5faGkpfXRvU3RyaW5nKCl7Y29uc3QgdD1SLm1hZ25pdHVkZSh0aGlzLl9oaSk7cmV0dXJuIHQ+PS0zJiZ0PD0yMD90aGlzLnRvU3RhbmRhcmROb3RhdGlvbigpOnRoaXMudG9TY2lOb3RhdGlvbigpfXRvU3RhbmRhcmROb3RhdGlvbigpe2NvbnN0IHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7Y29uc3QgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKCEwLGUpLHM9ZVswXSsxO2xldCBpPW47aWYoXCIuXCI9PT1uLmNoYXJBdCgwKSlpPVwiMFwiK247ZWxzZSBpZihzPDApaT1cIjAuXCIrUi5zdHJpbmdPZkNoYXIoXCIwXCIsLXMpK247ZWxzZSBpZigtMT09PW4uaW5kZXhPZihcIi5cIikpe2NvbnN0IHQ9cy1uLmxlbmd0aDtpPW4rUi5zdHJpbmdPZkNoYXIoXCIwXCIsdCkrXCIuMFwifXJldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIitpOml9cmVjaXByb2NhbCgpe2xldCB0PW51bGwsZT1udWxsLG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsO2k9MS90aGlzLl9oaSxyPVIuU1BMSVQqaSx0PXItaSxsPVIuU1BMSVQqdGhpcy5faGksdD1yLXQsZT1pLXQsbj1sLXRoaXMuX2hpLG89aSp0aGlzLl9oaSxuPWwtbixzPXRoaXMuX2hpLW4sbD10Km4tbyt0KnMrZSpuK2UqcyxyPSgxLW8tbC1pKnRoaXMuX2xvKS90aGlzLl9oaTtjb25zdCBhPWkrcjtyZXR1cm4gbmV3IFIoYSxpLWErcil9dG9TY2lOb3RhdGlvbigpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIFIuU0NJX05PVF9aRVJPO2NvbnN0IHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7Y29uc3QgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKCExLGUpLHM9Ui5TQ0lfTk9UX0VYUE9ORU5UX0NIQVIrZVswXTtpZihcIjBcIj09PW4uY2hhckF0KDApKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJGb3VuZCBsZWFkaW5nIHplcm86IFwiK24pO2xldCBpPVwiXCI7bi5sZW5ndGg+MSYmKGk9bi5zdWJzdHJpbmcoMSkpO2NvbnN0IHI9bi5jaGFyQXQoMCkrXCIuXCIraTtyZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIrcitzOnIrc31hYnMoKXtyZXR1cm4gdGhpcy5pc05hTigpP1IuTmFOOnRoaXMuaXNOZWdhdGl2ZSgpP3RoaXMubmVnYXRlKCk6bmV3IFIodGhpcyl9aXNQb3NpdGl2ZSgpe3JldHVybiB0aGlzLl9oaT4wfHwwPT09dGhpcy5faGkmJnRoaXMuX2xvPjB9bHQodCl7cmV0dXJuIHRoaXMuX2hpPHQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbzx0Ll9sb31hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBSLmNvcHkodGhpcykuc2VsZkFkZCh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gUi5jb3B5KHRoaXMpLnNlbGZBZGQodCl9fWluaXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faGk9dCx0aGlzLl9sbz0wfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9oaT10Ll9oaSx0aGlzLl9sbz10Ll9sb319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faGk9dCx0aGlzLl9sbz1lfX1ndCh0KXtyZXR1cm4gdGhpcy5faGk+dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPnQuX2xvfWlzTmVnYXRpdmUoKXtyZXR1cm4gdGhpcy5faGk8MHx8MD09PXRoaXMuX2hpJiZ0aGlzLl9sbzwwfXRydW5jKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9SLk5hTjp0aGlzLmlzUG9zaXRpdmUoKT90aGlzLmZsb29yKCk6dGhpcy5jZWlsKCl9c2lnbnVtKCl7cmV0dXJuIHRoaXMuX2hpPjA/MTp0aGlzLl9oaTwwPy0xOnRoaXMuX2xvPjA/MTp0aGlzLl9sbzwwPy0xOjB9Z2V0Q2xhc3MoKXtyZXR1cm4gUn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYSxyLG9dfX1SLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2hpPTAsdGhpcy5fbG89MCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLmluaXQoMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtSLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsUi5wYXJzZSh0KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdCh0LGUpfX0sUi5QST1uZXcgUigzLjE0MTU5MjY1MzU4OTc5MywxMjI0NjQ2Nzk5MTQ3MzUzMmUtMzIpLFIuVFdPX1BJPW5ldyBSKDYuMjgzMTg1MzA3MTc5NTg2LDI0NDkyOTM1OTgyOTQ3MDY0ZS0zMiksUi5QSV8yPW5ldyBSKDEuNTcwNzk2MzI2Nzk0ODk2Niw2MTIzMjMzOTk1NzM2NzY2ZS0zMiksUi5FPW5ldyBSKDIuNzE4MjgxODI4NDU5MDQ1LDE0NDU2NDY4OTE3MjkyNTAyZS0zMiksUi5OYU49bmV3IFIoaS5OYU4saS5OYU4pLFIuRVBTPTEyMzI1OTUxNjQ0MDc4M2UtNDYsUi5TUExJVD0xMzQyMTc3MjksUi5NQVhfUFJJTlRfRElHSVRTPTMyLFIuVEVOPVIudmFsdWVPZigxMCksUi5PTkU9Ui52YWx1ZU9mKDEpLFIuU0NJX05PVF9FWFBPTkVOVF9DSEFSPVwiRVwiLFIuU0NJX05PVF9aRVJPPVwiMC4wRTBcIjtjbGFzcyBQe2NvbnN0cnVjdG9yKCl7UC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvcmllbnRhdGlvbkluZGV4KHQsZSxuKXtjb25zdCBzPVAub3JpZW50YXRpb25JbmRleEZpbHRlcih0LGUsbik7aWYoczw9MSlyZXR1cm4gcztjb25zdCBpPVIudmFsdWVPZihlLngpLnNlbGZBZGQoLXQueCkscj1SLnZhbHVlT2YoZS55KS5zZWxmQWRkKC10LnkpLG89Ui52YWx1ZU9mKG4ueCkuc2VsZkFkZCgtZS54KSxsPVIudmFsdWVPZihuLnkpLnNlbGZBZGQoLWUueSk7cmV0dXJuIGkuc2VsZk11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChyLnNlbGZNdWx0aXBseShvKSkuc2lnbnVtKCl9c3RhdGljIHNpZ25PZkRldDJ4Migpe2lmKGFyZ3VtZW50c1szXWluc3RhbmNlb2YgUiYmYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBSJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFImJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHQubXVsdGlwbHkocykuc2VsZlN1YnRyYWN0KGUubXVsdGlwbHkobikpLnNpZ251bSgpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbM10mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9Ui52YWx1ZU9mKHQpLHI9Ui52YWx1ZU9mKGUpLG89Ui52YWx1ZU9mKG4pLGw9Ui52YWx1ZU9mKHMpO3JldHVybiBpLm11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChyLm11bHRpcGx5KG8pKS5zaWdudW0oKX19c3RhdGljIGludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCBpPVIudmFsdWVPZihzLnkpLnNlbGZTdWJ0cmFjdChuLnkpLnNlbGZNdWx0aXBseShSLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KSkscj1SLnZhbHVlT2Yocy54KS5zZWxmU3VidHJhY3Qobi54KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkpLG89aS5zdWJ0cmFjdChyKSxsPVIudmFsdWVPZihzLngpLnNlbGZTdWJ0cmFjdChuLngpLnNlbGZNdWx0aXBseShSLnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3Qobi55KSksYT1SLnZhbHVlT2Yocy55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KG4ueCkpLGM9bC5zdWJ0cmFjdChhKS5zZWxmRGl2aWRlKG8pLmRvdWJsZVZhbHVlKCksaD1SLnZhbHVlT2YodC54KS5zZWxmQWRkKFIudmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpLnNlbGZNdWx0aXBseShjKSkuZG91YmxlVmFsdWUoKSx1PVIudmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpLnNlbGZNdWx0aXBseShSLnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3Qobi55KSksZD1SLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QodC55KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KG4ueCkpLF89dS5zdWJ0cmFjdChkKS5zZWxmRGl2aWRlKG8pLmRvdWJsZVZhbHVlKCksZj1SLnZhbHVlT2Yobi55KS5zZWxmQWRkKFIudmFsdWVPZihzLnkpLnNlbGZTdWJ0cmFjdChuLnkpLnNlbGZNdWx0aXBseShfKSkuZG91YmxlVmFsdWUoKTtyZXR1cm4gbmV3IGcoaCxmKX1zdGF0aWMgb3JpZW50YXRpb25JbmRleEZpbHRlcih0LGUsbil7bGV0IHM9bnVsbDtjb25zdCBpPSh0Lngtbi54KSooZS55LW4ueSkscj0odC55LW4ueSkqKGUueC1uLngpLG89aS1yO2lmKGk+MCl7aWYocjw9MClyZXR1cm4gUC5zaWdudW0obyk7cz1pK3J9ZWxzZXtpZighKGk8MCkpcmV0dXJuIFAuc2lnbnVtKG8pO2lmKHI+PTApcmV0dXJuIFAuc2lnbnVtKG8pO3M9LWktcn1jb25zdCBsPVAuRFBfU0FGRV9FUFNJTE9OKnM7cmV0dXJuIG8+PWx8fC1vPj1sP1Auc2lnbnVtKG8pOjJ9c3RhdGljIHNpZ251bSh0KXtyZXR1cm4gdD4wPzE6dDwwPy0xOjB9Z2V0Q2xhc3MoKXtyZXR1cm4gUH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFAuRFBfU0FGRV9FUFNJTE9OPTFlLTE1O2NsYXNzIHZ7Y29uc3RydWN0b3IoKXt2LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGluZGV4KHQsZSxuKXtyZXR1cm4gUC5vcmllbnRhdGlvbkluZGV4KHQsZSxuKX1zdGF0aWMgaXNDQ1codCl7Y29uc3QgZT10Lmxlbmd0aC0xO2lmKGU8Myl0aHJvdyBuZXcgbihcIlJpbmcgaGFzIGZld2VyIHRoYW4gNCBwb2ludHMsIHNvIG9yaWVudGF0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkXCIpO2xldCBzPXRbMF0saT0wO2ZvcihsZXQgbj0xO248PWU7bisrKXtjb25zdCBlPXRbbl07ZS55PnMueSYmKHM9ZSxpPW4pfWxldCByPWk7ZG97ci09MSxyPDAmJihyPWUpfXdoaWxlKHRbcl0uZXF1YWxzMkQocykmJnIhPT1pKTtsZXQgbz1pO2Rve289KG8rMSklZX13aGlsZSh0W29dLmVxdWFsczJEKHMpJiZvIT09aSk7Y29uc3QgbD10W3JdLGE9dFtvXTtpZihsLmVxdWFsczJEKHMpfHxhLmVxdWFsczJEKHMpfHxsLmVxdWFsczJEKGEpKXJldHVybiExO2NvbnN0IGM9di5pbmRleChsLHMsYSk7bGV0IGg9bnVsbDtyZXR1cm4gaD0wPT09Yz9sLng+YS54OmM+MCxofWdldENsYXNzKCl7cmV0dXJuIHZ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIE8oKXt9di5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LHYuQ0xPQ0tXSVNFPS0xLHYuUklHSFQ9di5DTE9DS1dJU0Usdi5DT1VOVEVSQ0xPQ0tXSVNFPTEsdi5MRUZUPXYuQ09VTlRFUkNMT0NLV0lTRSx2LkNPTExJTkVBUj0wLHYuU1RSQUlHSFQ9di5DT0xMSU5FQVIsTy5hcnJheWNvcHk9KHQsZSxuLHMsaSk9PntsZXQgcj0wO2ZvcihsZXQgbz1lO288ZStpO28rKyluW3Mrcl09dFtvXSxyKyt9LE8uZ2V0UHJvcGVydHk9dD0+KHtcImxpbmUuc2VwYXJhdG9yXCI6XCJcXG5cIn1bdF0pO2NsYXNzIGJ7Y29uc3RydWN0b3IoKXtiLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCByPXQueS1lLnksbz1lLngtdC54LGw9dC54KmUueS1lLngqdC55LGE9bi55LXMueSxjPXMueC1uLngsaD1uLngqcy55LXMueCpuLnksdT1yKmMtYSpvLGQ9KG8qaC1jKmwpL3UsXz0oYSpsLXIqaCkvdTtpZihpLmlzTmFOKGQpfHxpLmlzSW5maW5pdGUoZCl8fGkuaXNOYU4oXyl8fGkuaXNJbmZpbml0ZShfKSl0aHJvdyBuZXcgUztyZXR1cm4gbmV3IGcoZCxfKX1nZXRZKCl7Y29uc3QgdD10aGlzLnkvdGhpcy53O2lmKGkuaXNOYU4odCl8fGkuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgUztyZXR1cm4gdH1nZXRYKCl7Y29uc3QgdD10aGlzLngvdGhpcy53O2lmKGkuaXNOYU4odCl8fGkuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgUztyZXR1cm4gdH1nZXRDb29yZGluYXRlKCl7Y29uc3QgdD1uZXcgZztyZXR1cm4gdC54PXRoaXMuZ2V0WCgpLHQueT10aGlzLmdldFkoKSx0fWdldENsYXNzKCl7cmV0dXJuIGJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy53PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy54PTAsdGhpcy55PTAsdGhpcy53PTE7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMudz0xfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMueD10LHRoaXMueT1lLHRoaXMudz0xfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBiJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMueD10LnkqZS53LWUueSp0LncsdGhpcy55PWUueCp0LnctdC54KmUudyx0aGlzLnc9dC54KmUueS1lLngqdC55fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMueD10LnktZS55LHRoaXMueT1lLngtdC54LHRoaXMudz10LngqZS55LWUueCp0Lnl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMueD10LHRoaXMueT1lLHRoaXMudz1ufWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9dC55LWUueSxyPWUueC10Lngsbz10LngqZS55LWUueCp0LnksbD1uLnktcy55LGE9cy54LW4ueCxjPW4ueCpzLnktcy54Km4ueTt0aGlzLng9cipjLWEqbyx0aGlzLnk9bCpvLWkqYyx0aGlzLnc9aSphLWwqcn19O2NsYXNzIE17Y29uc3RydWN0b3IoKXtNLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGxvZzEwKHQpe2NvbnN0IGU9TWF0aC5sb2codCk7cmV0dXJuIGkuaXNJbmZpbml0ZShlKXx8aS5pc05hTihlKT9lOmUvTS5MT0dfMTB9c3RhdGljIG1pbih0LGUsbixzKXtsZXQgaT10O3JldHVybiBlPGkmJihpPWUpLG48aSYmKGk9biksczxpJiYoaT1zKSxpfXN0YXRpYyBjbGFtcCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0PGU/ZTp0Pm4/bjp0fWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0PGU/ZTp0Pm4/bjp0fX1zdGF0aWMgd3JhcCh0LGUpe3JldHVybiB0PDA/ZS0gLXQlZTp0JWV9c3RhdGljIG1heCgpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtsZXQgcz10O3JldHVybiBlPnMmJihzPWUpLG4+cyYmKHM9biksc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bGV0IGk9dDtyZXR1cm4gZT5pJiYoaT1lKSxuPmkmJihpPW4pLHM+aSYmKGk9cyksaX19c3RhdGljIGF2ZXJhZ2UodCxlKXtyZXR1cm4odCtlKS8yfWdldENsYXNzKCl7cmV0dXJuIE19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU0uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxNLkxPR18xMD1NYXRoLmxvZygxMCk7Y2xhc3MgRHtjb25zdHJ1Y3Rvcigpe0QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2VnbWVudFRvU2VnbWVudCh0LGUsbixzKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gRC5wb2ludFRvU2VnbWVudCh0LG4scyk7aWYobi5lcXVhbHMocykpcmV0dXJuIEQucG9pbnRUb1NlZ21lbnQocyx0LGUpO2xldCBpPSExO2lmKE4uaW50ZXJzZWN0cyh0LGUsbixzKSl7Y29uc3Qgcj0oZS54LXQueCkqKHMueS1uLnkpLShlLnktdC55KSoocy54LW4ueCk7aWYoMD09PXIpaT0hMDtlbHNle2NvbnN0IG89KHQueS1uLnkpKihzLngtbi54KS0odC54LW4ueCkqKHMueS1uLnkpLGw9KCh0Lnktbi55KSooZS54LXQueCktKHQueC1uLngpKihlLnktdC55KSkvcixhPW8vcjsoYTwwfHxhPjF8fGw8MHx8bD4xKSYmKGk9ITApfX1lbHNlIGk9ITA7cmV0dXJuIGk/TS5taW4oRC5wb2ludFRvU2VnbWVudCh0LG4scyksRC5wb2ludFRvU2VnbWVudChlLG4scyksRC5wb2ludFRvU2VnbWVudChuLHQsZSksRC5wb2ludFRvU2VnbWVudChzLHQsZSkpOjB9c3RhdGljIHBvaW50VG9TZWdtZW50KHQsZSxuKXtpZihlLng9PT1uLngmJmUueT09PW4ueSlyZXR1cm4gdC5kaXN0YW5jZShlKTtjb25zdCBzPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxpPSgodC54LWUueCkqKG4ueC1lLngpKyh0LnktZS55KSoobi55LWUueSkpL3M7aWYoaTw9MClyZXR1cm4gdC5kaXN0YW5jZShlKTtpZihpPj0xKXJldHVybiB0LmRpc3RhbmNlKG4pO2NvbnN0IHI9KChlLnktdC55KSoobi54LWUueCktKGUueC10LngpKihuLnktZS55KSkvcztyZXR1cm4gTWF0aC5hYnMocikqTWF0aC5zcXJ0KHMpfXN0YXRpYyBwb2ludFRvTGluZVBlcnBlbmRpY3VsYXIodCxlLG4pe2NvbnN0IHM9KG4ueC1lLngpKihuLngtZS54KSsobi55LWUueSkqKG4ueS1lLnkpLGk9KChlLnktdC55KSoobi54LWUueCktKGUueC10LngpKihuLnktZS55KSkvcztyZXR1cm4gTWF0aC5hYnMoaSkqTWF0aC5zcXJ0KHMpfXN0YXRpYyBwb2ludFRvU2VnbWVudFN0cmluZyh0LGUpe2lmKDA9PT1lLmxlbmd0aCl0aHJvdyBuZXcgbihcIkxpbmUgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSB2ZXJ0ZXhcIik7bGV0IHM9dC5kaXN0YW5jZShlWzBdKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoLTE7bisrKXtjb25zdCBpPUQucG9pbnRUb1NlZ21lbnQodCxlW25dLGVbbisxXSk7aTxzJiYocz1pKX1yZXR1cm4gc31nZXRDbGFzcygpe3JldHVybiBEfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1ELmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgQXtjb25zdHJ1Y3Rvcigpe0EuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRPcmRpbmF0ZSh0LGUsbil7fXNpemUoKXt9Z2V0T3JkaW5hdGUodCxlKXt9Z2V0Q29vcmRpbmF0ZSgpe31nZXRDb29yZGluYXRlQ29weSh0KXt9Z2V0RGltZW5zaW9uKCl7fWdldFgodCl7fWV4cGFuZEVudmVsb3BlKHQpe31jb3B5KCl7fWdldFkodCl7fXRvQ29vcmRpbmF0ZUFycmF5KCl7fWdldENsYXNzKCl7cmV0dXJuIEF9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1BLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sQS5YPTAsQS5ZPTEsQS5aPTIsQS5NPTM7Y2xhc3MgRntjb25zdHJ1Y3Rvcigpe0YuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGUoKXsxPT09YXJndW1lbnRzLmxlbmd0aCYmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXl8fF8oYXJndW1lbnRzWzBdLEEpKX1nZXRDbGFzcygpe3JldHVybiBGfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1GLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgR3tjb25zdHJ1Y3Rvcigpe0cuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7fWdldENsYXNzKCl7cmV0dXJuIEd9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUcuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBxe2NvbnN0cnVjdG9yKCl7cS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzR2VvbWV0cnlDb2xsZWN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VHlwZUNvZGUoKT09PXEuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OfWdldEZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fZmFjdG9yeX1nZXRHZW9tZXRyeU4odCl7cmV0dXJuIHRoaXN9Z2V0QXJlYSgpe3JldHVybiAwfWlzUmVjdGFuZ2xlKCl7cmV0dXJuITF9ZXF1YWxzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbnVsbCE9PXQmJnRoaXMuZXF1YWxzVG9wbyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoISh0IGluc3RhbmNlb2YgcSkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLmVxdWFsc0V4YWN0KGUpfX1lcXVhbHNFeGFjdCh0KXtyZXR1cm4gdGhpcz09PXR8fHRoaXMuZXF1YWxzRXhhY3QodCwwKX1nZW9tZXRyeUNoYW5nZWQoKXt0aGlzLmFwcGx5KHEuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyKX1nZW9tZXRyeUNoYW5nZWRBY3Rpb24oKXt0aGlzLl9lbnZlbG9wZT1udWxsfWVxdWFsc05vcm0odCl7cmV0dXJuIG51bGwhPT10JiZ0aGlzLm5vcm0oKS5lcXVhbHNFeGFjdCh0Lm5vcm0oKSl9Z2V0TGVuZ3RoKCl7cmV0dXJuIDB9Z2V0TnVtR2VvbWV0cmllcygpe3JldHVybiAxfWNvbXBhcmVUbygpe2xldCB0O2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdD1lLHRoaXMuZ2V0VHlwZUNvZGUoKSE9PXQuZ2V0VHlwZUNvZGUoKT90aGlzLmdldFR5cGVDb2RlKCktdC5nZXRUeXBlQ29kZSgpOnRoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOnQuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3MoZSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiB0PWUsdGhpcy5nZXRUeXBlQ29kZSgpIT09dC5nZXRUeXBlQ29kZSgpP3RoaXMuZ2V0VHlwZUNvZGUoKS10LmdldFR5cGVDb2RlKCk6dGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpPzA6dGhpcy5pc0VtcHR5KCk/LTE6dC5pc0VtcHR5KCk/MTp0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhlLG4pfX1nZXRVc2VyRGF0YSgpe3JldHVybiB0aGlzLl91c2VyRGF0YX1nZXRTUklEKCl7cmV0dXJuIHRoaXMuX1NSSUR9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeSh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9Y2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCl7aWYodC5nZXRUeXBlQ29kZSgpPT09cS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT04pdGhyb3cgbmV3IG4oXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIil9ZXF1YWwodCxlLG4pe3JldHVybiAwPT09bj90LmVxdWFscyhlKTp0LmRpc3RhbmNlKGUpPD1ufW5vcm0oKXtjb25zdCB0PXRoaXMuY29weSgpO3JldHVybiB0Lm5vcm1hbGl6ZSgpLHR9Z2V0UHJlY2lzaW9uTW9kZWwoKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpfWdldEVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2VudmVsb3BlJiYodGhpcy5fZW52ZWxvcGU9dGhpcy5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpKSxuZXcgTih0aGlzLl9lbnZlbG9wZSl9c2V0U1JJRCh0KXt0aGlzLl9TUklEPXR9c2V0VXNlckRhdGEodCl7dGhpcy5fdXNlckRhdGE9dH1jb21wYXJlKHQsZSl7Y29uc3Qgbj10Lml0ZXJhdG9yKCkscz1lLml0ZXJhdG9yKCk7Zm9yKDtuLmhhc05leHQoKSYmcy5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLGU9cy5uZXh0KCksaT10LmNvbXBhcmVUbyhlKTtpZigwIT09aSlyZXR1cm4gaX1yZXR1cm4gbi5oYXNOZXh0KCk/MTpzLmhhc05leHQoKT8tMTowfWhhc2hDb2RlKCl7cmV0dXJuIHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmhhc2hDb2RlKCl9aXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQoKXtyZXR1cm4gdGhpcy5nZXRUeXBlQ29kZSgpPT09cS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT058fHRoaXMuZ2V0VHlwZUNvZGUoKT09PXEuVFlQRUNPREVfTVVMVElQT0lOVHx8dGhpcy5nZXRUeXBlQ29kZSgpPT09cS5UWVBFQ09ERV9NVUxUSUxJTkVTVFJJTkd8fHRoaXMuZ2V0VHlwZUNvZGUoKT09PXEuVFlQRUNPREVfTVVMVElQT0xZR09OfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvLHIsYV19Z2V0Q2xhc3MoKXtyZXR1cm4gcX1zdGF0aWMgaGFzTm9uRW1wdHlFbGVtZW50cyh0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZighdFtlXS5pc0VtcHR5KCkpcmV0dXJuITA7cmV0dXJuITF9c3RhdGljIGhhc051bGxFbGVtZW50cyh0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZihudWxsPT09dFtlXSlyZXR1cm4hMDtyZXR1cm4hMX19cS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24odCl7dCYmKHRoaXMuX2VudmVsb3BlPW51bGwsdGhpcy5fdXNlckRhdGE9bnVsbCx0aGlzLl9mYWN0b3J5PXQsdGhpcy5fU1JJRD10LmdldFNSSUQoKSl9LHEuc2VyaWFsVmVyc2lvblVJRD0weDc5OWVhNDY1MjI4NTRjMDAscS5UWVBFQ09ERV9QT0lOVD0wLHEuVFlQRUNPREVfTVVMVElQT0lOVD0xLHEuVFlQRUNPREVfTElORVNUUklORz0yLHEuVFlQRUNPREVfTElORUFSUklORz0zLHEuVFlQRUNPREVfTVVMVElMSU5FU1RSSU5HPTQscS5UWVBFQ09ERV9QT0xZR09OPTUscS5UWVBFQ09ERV9NVUxUSVBPTFlHT049NixxLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTj03LHEuVFlQRU5BTUVfUE9JTlQ9XCJQb2ludFwiLHEuVFlQRU5BTUVfTVVMVElQT0lOVD1cIk11bHRpUG9pbnRcIixxLlRZUEVOQU1FX0xJTkVTVFJJTkc9XCJMaW5lU3RyaW5nXCIscS5UWVBFTkFNRV9MSU5FQVJSSU5HPVwiTGluZWFyUmluZ1wiLHEuVFlQRU5BTUVfTVVMVElMSU5FU1RSSU5HPVwiTXVsdGlMaW5lU3RyaW5nXCIscS5UWVBFTkFNRV9QT0xZR09OPVwiUG9seWdvblwiLHEuVFlQRU5BTUVfTVVMVElQT0xZR09OPVwiTXVsdGlQb2x5Z29uXCIscS5UWVBFTkFNRV9HRU9NRVRSWUNPTExFQ1RJT049XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixxLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcj17Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ddfSxmaWx0ZXIodCl7dC5nZW9tZXRyeUNoYW5nZWRBY3Rpb24oKX19O2NsYXNzIEJ7Y29uc3RydWN0b3IoKXtCLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe31nZXRDbGFzcygpe3JldHVybiBCfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1CLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgVntjb25zdHJ1Y3Rvcigpe1YuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0luQm91bmRhcnkodCl7fWdldENsYXNzKCl7cmV0dXJuIFZ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHp7Y29uc3RydWN0b3IoKXt6LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0JTI9PTF9Z2V0Q2xhc3MoKXtyZXR1cm4gen1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVl19fXouY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBZe2NvbnN0cnVjdG9yKCl7WS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdD4wfWdldENsYXNzKCl7cmV0dXJuIFl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1ZdfX1ZLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgVXtjb25zdHJ1Y3Rvcigpe1UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0luQm91bmRhcnkodCl7cmV0dXJuIHQ+MX1nZXRDbGFzcygpe3JldHVybiBVfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltWXX19VS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGt7Y29uc3RydWN0b3IoKXtrLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbkJvdW5kYXJ5KHQpe3JldHVybiAxPT09dH1nZXRDbGFzcygpe3JldHVybiBrfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltWXX19ay5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFYuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGU9eixWLkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1ZLFYuTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9VSxWLk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9ayxWLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sVi5NT0QyX0JPVU5EQVJZX1JVTEU9bmV3IHosVi5FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBZLFYuTVVMVElWQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgVSxWLk1PTk9WQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgayxWLk9HQ19TRlNfQk9VTkRBUllfUlVMRT1WLk1PRDJfQk9VTkRBUllfUlVMRTtjbGFzcyBYe2NvbnN0cnVjdG9yKCl7WC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc1JpbmcodCl7cmV0dXJuISh0Lmxlbmd0aDw0KSYmISF0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfXN0YXRpYyBwdE5vdEluTGlzdCh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtjb25zdCBzPXRbbl07aWYoWC5pbmRleE9mKHMsZSk8MClyZXR1cm4gc31yZXR1cm4gbnVsbH1zdGF0aWMgc2Nyb2xsKHQsZSl7Y29uc3Qgbj1YLmluZGV4T2YoZSx0KTtpZihuPDApcmV0dXJuIG51bGw7Y29uc3Qgcz1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Ty5hcnJheWNvcHkodCxuLHMsMCx0Lmxlbmd0aC1uKSxPLmFycmF5Y29weSh0LDAscyx0Lmxlbmd0aC1uLG4pLE8uYXJyYXljb3B5KHMsMCx0LDAsdC5sZW5ndGgpfXN0YXRpYyBlcXVhbHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09PXR8fG51bGw9PT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGVbbl0pKXJldHVybiExO3JldHVybiEwfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT09dHx8bnVsbD09PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKylpZigwIT09bi5jb21wYXJlKHRbc10sZVtzXSkpcmV0dXJuITE7cmV0dXJuITB9fXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtjb25zdCBuPW5ldyBJO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKWUuaW50ZXJzZWN0cyh0W3NdKSYmbi5hZGQodFtzXSwhMCk7cmV0dXJuIG4udG9Db29yZGluYXRlQXJyYXkoKX1zdGF0aWMgaGFzUmVwZWF0ZWRQb2ludHModCl7Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDtlKyspaWYodFtlLTFdLmVxdWFscyh0W2VdKSlyZXR1cm4hMDtyZXR1cm4hMX1zdGF0aWMgcmVtb3ZlUmVwZWF0ZWRQb2ludHModCl7aWYoIVguaGFzUmVwZWF0ZWRQb2ludHModCkpcmV0dXJuIHQ7cmV0dXJuIG5ldyBJKHQsITEpLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIHJldmVyc2UodCl7Y29uc3QgZT10Lmxlbmd0aC0xLG49TWF0aC50cnVuYyhlLzIpO2ZvcihsZXQgcz0wO3M8PW47cysrKXtjb25zdCBuPXRbc107dFtzXT10W2Utc10sdFtlLXNdPW59fXN0YXRpYyByZW1vdmVOdWxsKHQpe2xldCBlPTA7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspbnVsbCE9PXRbbl0mJmUrKztjb25zdCBuPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2lmKDA9PT1lKXJldHVybiBuO2xldCBzPTA7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspbnVsbCE9PXRbZV0mJihuW3MrK109dFtlXSk7cmV0dXJuIG59c3RhdGljIGNvcHlEZWVwKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWVbbl09bmV3IGcodFtuXSk7cmV0dXJuIGV9aWYoNT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdO2ZvcihsZXQgcj0wO3I8aTtyKyspbltzK3JdPW5ldyBnKHRbZStyXSl9fXN0YXRpYyBpc0VxdWFsUmV2ZXJzZWQodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7Y29uc3Qgcz10W25dLGk9ZVt0Lmxlbmd0aC1uLTFdO2lmKDAhPT1zLmNvbXBhcmVUbyhpKSlyZXR1cm4hMX1yZXR1cm4hMH1zdGF0aWMgZW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTjtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllLmV4cGFuZFRvSW5jbHVkZSh0W25dKTtyZXR1cm4gZX1zdGF0aWMgdG9Db29yZGluYXRlQXJyYXkodCl7cmV0dXJuIHQudG9BcnJheShYLmNvb3JkQXJyYXlUeXBlKX1zdGF0aWMgYXRMZWFzdE5Db29yZGluYXRlc09yTm90aGluZyh0LGUpe3JldHVybiBlLmxlbmd0aD49dD9lOltdfXN0YXRpYyBpbmRleE9mKHQsZSl7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspaWYodC5lcXVhbHMoZVtuXSkpcmV0dXJuIG47cmV0dXJuLTF9c3RhdGljIGluY3JlYXNpbmdEaXJlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTxNYXRoLnRydW5jKHQubGVuZ3RoLzIpO2UrKyl7Y29uc3Qgbj10Lmxlbmd0aC0xLWUscz10W2VdLmNvbXBhcmVUbyh0W25dKTtpZigwIT09cylyZXR1cm4gc31yZXR1cm4gMX1zdGF0aWMgY29tcGFyZSh0LGUpe2xldCBuPTA7Zm9yKDtuPHQubGVuZ3RoJiZuPGUubGVuZ3RoOyl7Y29uc3Qgcz10W25dLmNvbXBhcmVUbyhlW25dKTtpZigwIT09cylyZXR1cm4gcztuKyt9cmV0dXJuIG48ZS5sZW5ndGg/LTE6bjx0Lmxlbmd0aD8xOjB9c3RhdGljIG1pbkNvb3JkaW5hdGUodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKykobnVsbD09PWV8fGUuY29tcGFyZVRvKHRbbl0pPjApJiYoZT10W25dKTtyZXR1cm4gZX1zdGF0aWMgZXh0cmFjdCh0LGUsbil7ZT1NLmNsYW1wKGUsMCx0Lmxlbmd0aCk7bGV0IHM9KG49TS5jbGFtcChuLC0xLHQubGVuZ3RoKSktZSsxO248MCYmKHM9MCksZT49dC5sZW5ndGgmJihzPTApLG48ZSYmKHM9MCk7Y29uc3QgaT1uZXcgQXJyYXkocykuZmlsbChudWxsKTtpZigwPT09cylyZXR1cm4gaTtsZXQgcj0wO2ZvcihsZXQgcz1lO3M8PW47cysrKWlbcisrXT10W3NdO3JldHVybiBpfWdldENsYXNzKCl7cmV0dXJuIFh9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIEh7Y29uc3RydWN0b3IoKXtILmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7cmV0dXJuIFguY29tcGFyZShuLHMpfWdldENsYXNzKCl7cmV0dXJuIEh9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1ILmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgV3tjb25zdHJ1Y3Rvcigpe1cuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtpZihuLmxlbmd0aDxzLmxlbmd0aClyZXR1cm4tMTtpZihuLmxlbmd0aD5zLmxlbmd0aClyZXR1cm4gMTtpZigwPT09bi5sZW5ndGgpcmV0dXJuIDA7Y29uc3QgaT1YLmNvbXBhcmUobixzKTtyZXR1cm4gWC5pc0VxdWFsUmV2ZXJzZWQobixzKT8wOml9T0xEY29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7aWYobi5sZW5ndGg8cy5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+cy5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO2NvbnN0IGk9WC5pbmNyZWFzaW5nRGlyZWN0aW9uKG4pLHI9WC5pbmNyZWFzaW5nRGlyZWN0aW9uKHMpO2xldCBvPWk+MD8wOm4ubGVuZ3RoLTEsbD1yPjA/MDpuLmxlbmd0aC0xO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCB0PW5bb10uY29tcGFyZVRvKHNbbF0pO2lmKDAhPT10KXJldHVybiB0O28rPWksbCs9cn1yZXR1cm4gMH1nZXRDbGFzcygpe3JldHVybiBXfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19ZnVuY3Rpb24gaigpe31mdW5jdGlvbiBLKCl7fWZ1bmN0aW9uIFoodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gUSgpe31mdW5jdGlvbiBKKCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmJiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfVcuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxYLkZvcndhcmRDb21wYXJhdG9yPUgsWC5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvcj1XLFguY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxYLmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLGoucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe30sai5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKCl7fSxqLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7fSxqLnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt9LGoucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7fSxLLnByb3RvdHlwZT1uZXcgaixaLnByb3RvdHlwZT1uZXcgRXJyb3IsWi5wcm90b3R5cGUubmFtZT1cIk9wZXJhdGlvbk5vdFN1cHBvcnRlZFwiLFEucHJvdG90eXBlPW5ldyBmLFEucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKCl7fSxKLnByb3RvdHlwZT1uZXcgUSxKLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbih0KXtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXtpZih0aGlzLmFycmF5X1tlXT09PXQpcmV0dXJuITB9cmV0dXJuITF9LEoucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4hdGhpcy5jb250YWlucyh0KSYmKHRoaXMuYXJyYXlfLnB1c2godCksITApfSxKLnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24odCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3JldHVybiEwfSxKLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IFp9LEoucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxKLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9LEoucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtjb25zdCB0PVtdO2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO2U8bjtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sSi5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3ICQodGhpcyl9O2NvbnN0ICQ9ZnVuY3Rpb24odCl7dGhpcy5oYXNoU2V0Xz10LHRoaXMucG9zaXRpb25fPTB9OyQucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvc2l0aW9uXz09PXRoaXMuaGFzaFNldF8uc2l6ZSgpKXRocm93IG5ldyB5O3JldHVybiB0aGlzLmhhc2hTZXRfLmFycmF5X1t0aGlzLnBvc2l0aW9uXysrXX0sJC5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLmhhc2hTZXRfLnNpemUoKX0sJC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFp9O2Z1bmN0aW9uIHR0KHQpe3JldHVybiBudWxsPT10PzA6dC5jb2xvcn1mdW5jdGlvbiBldCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucGFyZW50fWZ1bmN0aW9uIG50KHQsZSl7bnVsbCE9PXQmJih0LmNvbG9yPWUpfWZ1bmN0aW9uIHN0KHQpe3JldHVybiBudWxsPT10P251bGw6dC5sZWZ0fWZ1bmN0aW9uIGl0KHQpe3JldHVybiBudWxsPT10P251bGw6dC5yaWdodH1mdW5jdGlvbiBydCgpe3RoaXMucm9vdF89bnVsbCx0aGlzLnNpemVfPTB9cnQucHJvdG90eXBlPW5ldyBLLHJ0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMucm9vdF87bnVsbCE9PWU7KXt2YXIgbj10LmNvbXBhcmVUbyhlLmtleSk7aWYobjwwKWU9ZS5sZWZ0O2Vsc2V7aWYoIShuPjApKXJldHVybiBlLnZhbHVlO2U9ZS5yaWdodH19cmV0dXJuIG51bGx9LHJ0LnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24odCxlKXtpZihudWxsPT09dGhpcy5yb290XylyZXR1cm4gdGhpcy5yb290Xz17a2V5OnQsdmFsdWU6ZSxsZWZ0Om51bGwscmlnaHQ6bnVsbCxwYXJlbnQ6bnVsbCxjb2xvcjowLGdldFZhbHVlKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleSgpe3JldHVybiB0aGlzLmtleX19LHRoaXMuc2l6ZV89MSxudWxsO3ZhciBuLHMsaT10aGlzLnJvb3RfO2Rve2lmKG49aSwocz10LmNvbXBhcmVUbyhpLmtleSkpPDApaT1pLmxlZnQ7ZWxzZXtpZighKHM+MCkpe3ZhciByPWkudmFsdWU7cmV0dXJuIGkudmFsdWU9ZSxyfWk9aS5yaWdodH19d2hpbGUobnVsbCE9PWkpO3ZhciBvPXtrZXk6dCxsZWZ0Om51bGwscmlnaHQ6bnVsbCx2YWx1ZTplLHBhcmVudDpuLGNvbG9yOjAsZ2V0VmFsdWUoKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5KCl7cmV0dXJuIHRoaXMua2V5fX07cmV0dXJuIHM8MD9uLmxlZnQ9bzpuLnJpZ2h0PW8sdGhpcy5maXhBZnRlckluc2VydGlvbihvKSx0aGlzLnNpemVfKyssbnVsbH0scnQucHJvdG90eXBlLmZpeEFmdGVySW5zZXJ0aW9uPWZ1bmN0aW9uKHQpe2xldCBlO2Zvcih0LmNvbG9yPTE7bnVsbCE9dCYmdCE9PXRoaXMucm9vdF8mJjE9PT10LnBhcmVudC5jb2xvcjspZXQodCk9PT1zdChldChldCh0KSkpPyhlPWl0KGV0KGV0KHQpKSksMT09PXR0KGUpPyhudChldCh0KSwwKSxudChlLDApLG50KGV0KGV0KHQpKSwxKSx0PWV0KGV0KHQpKSk6KHQ9PT1pdChldCh0KSkmJih0PWV0KHQpLHRoaXMucm90YXRlTGVmdCh0KSksbnQoZXQodCksMCksbnQoZXQoZXQodCkpLDEpLHRoaXMucm90YXRlUmlnaHQoZXQoZXQodCkpKSkpOihlPXN0KGV0KGV0KHQpKSksMT09PXR0KGUpPyhudChldCh0KSwwKSxudChlLDApLG50KGV0KGV0KHQpKSwxKSx0PWV0KGV0KHQpKSk6KHQ9PT1zdChldCh0KSkmJih0PWV0KHQpLHRoaXMucm90YXRlUmlnaHQodCkpLG50KGV0KHQpLDApLG50KGV0KGV0KHQpKSwxKSx0aGlzLnJvdGF0ZUxlZnQoZXQoZXQodCkpKSkpO3RoaXMucm9vdF8uY29sb3I9MH0scnQucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe3ZhciB0PW5ldyB4LGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUudmFsdWUpO251bGwhPT0oZT1ydC5zdWNjZXNzb3IoZSkpOyl0LmFkZChlLnZhbHVlKTtyZXR1cm4gdH0scnQucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEosZT10aGlzLmdldEZpcnN0RW50cnkoKTtpZihudWxsIT09ZSlmb3IodC5hZGQoZSk7bnVsbCE9PShlPXJ0LnN1Y2Nlc3NvcihlKSk7KXQuYWRkKGUpO3JldHVybiB0fSxydC5wcm90b3R5cGUucm90YXRlTGVmdD1mdW5jdGlvbih0KXtpZihudWxsIT10KXt2YXIgZT10LnJpZ2h0O3QucmlnaHQ9ZS5sZWZ0LG51bGwhPWUubGVmdCYmKGUubGVmdC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LmxlZnQ9PT10P3QucGFyZW50LmxlZnQ9ZTp0LnBhcmVudC5yaWdodD1lLGUubGVmdD10LHQucGFyZW50PWV9fSxydC5wcm90b3R5cGUucm90YXRlUmlnaHQ9ZnVuY3Rpb24odCl7aWYobnVsbCE9dCl7dmFyIGU9dC5sZWZ0O3QubGVmdD1lLnJpZ2h0LG51bGwhPWUucmlnaHQmJihlLnJpZ2h0LnBhcmVudD10KSxlLnBhcmVudD10LnBhcmVudCxudWxsPT10LnBhcmVudD90aGlzLnJvb3RfPWU6dC5wYXJlbnQucmlnaHQ9PT10P3QucGFyZW50LnJpZ2h0PWU6dC5wYXJlbnQubGVmdD1lLGUucmlnaHQ9dCx0LnBhcmVudD1lfX0scnQucHJvdG90eXBlLmdldEZpcnN0RW50cnk9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnJvb3RfO2lmKG51bGwhPXQpZm9yKDtudWxsIT10LmxlZnQ7KXQ9dC5sZWZ0O3JldHVybiB0fSxydC5zdWNjZXNzb3I9ZnVuY3Rpb24odCl7bGV0IGU7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7aWYobnVsbCE9PXQucmlnaHQpe2ZvcihlPXQucmlnaHQ7bnVsbCE9PWUubGVmdDspZT1lLmxlZnQ7cmV0dXJuIGV9ZT10LnBhcmVudDtmb3IodmFyIG49dDtudWxsIT09ZSYmbj09PWUucmlnaHQ7KW49ZSxlPWUucGFyZW50O3JldHVybiBlfSxydC5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemVffSxydC5wcm90b3R5cGUuY29udGFpbnNLZXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMucm9vdF87bnVsbCE9PWU7KXt2YXIgbj10LmNvbXBhcmVUbyhlLmtleSk7aWYobjwwKWU9ZS5sZWZ0O2Vsc2V7aWYoIShuPjApKXJldHVybiEwO2U9ZS5yaWdodH19cmV0dXJuITF9O2NsYXNzIG90e2NvbnN0cnVjdG9yKCl7b3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBvdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gbHQoKXt9ZnVuY3Rpb24gYXQoKXt0aGlzLmFycmF5Xz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGYmJnRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSl9b3QuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxsdC5wcm90b3R5cGU9bmV3IFEsYXQucHJvdG90eXBlPW5ldyBsdCxhdC5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl7aWYoMD09PXRoaXMuYXJyYXlfW2VdLmNvbXBhcmVUbyh0KSlyZXR1cm4hMH1yZXR1cm4hMX0sYXQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtpZih0aGlzLmNvbnRhaW5zKHQpKXJldHVybiExO2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO2U8bjtlKyspe2lmKDE9PT10aGlzLmFycmF5X1tlXS5jb21wYXJlVG8odCkpcmV0dXJuIHRoaXMuYXJyYXlfLnNwbGljZShlLDAsdCksITB9cmV0dXJuIHRoaXMuYXJyYXlfLnB1c2godCksITB9LGF0LnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24odCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3JldHVybiEwfSxhdC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBafSxhdC5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LGF0LnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9LGF0LnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Y29uc3QgdD1bXTtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LGF0LnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgY3QodGhpcyl9O2NvbnN0IGN0PWZ1bmN0aW9uKHQpe3RoaXMudHJlZVNldF89dCx0aGlzLnBvc2l0aW9uXz0wfTtmdW5jdGlvbiBodCgpe31jdC5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy50cmVlU2V0Xy5zaXplKCkpdGhyb3cgbmV3IHk7cmV0dXJuIHRoaXMudHJlZVNldF8uYXJyYXlfW3RoaXMucG9zaXRpb25fKytdfSxjdC5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLnRyZWVTZXRfLnNpemUoKX0sY3QucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IG5ldyBafSxodC5zb3J0PWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGUsbixzLGk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmNvbXBhcmVUbyhlKX0sdC5zb3J0KGkpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpcz1hcmd1bWVudHNbMV0saT1mdW5jdGlvbih0LGUpe3JldHVybiBzLmNvbXBhcmUodCxlKX0sdC5zb3J0KGkpO2Vsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe249dC5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKSxuLnNvcnQoKTtjb25zdCBzPXQuc2xpY2UoMCxhcmd1bWVudHNbMV0pLmNvbmNhdChuLHQuc2xpY2UoYXJndW1lbnRzWzJdLHQubGVuZ3RoKSk7Zm9yKHQuc3BsaWNlKDAsdC5sZW5ndGgpLGU9MDtlPHMubGVuZ3RoO2UrKyl0LnB1c2goc1tlXSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7bj10LnNsaWNlKGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pLHM9YXJndW1lbnRzWzNdLGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcy5jb21wYXJlKHQsZSl9LG4uc29ydChpKTtjb25zdCByPXQuc2xpY2UoMCxhcmd1bWVudHNbMV0pLmNvbmNhdChuLHQuc2xpY2UoYXJndW1lbnRzWzJdLHQubGVuZ3RoKSk7Zm9yKHQuc3BsaWNlKDAsdC5sZW5ndGgpLGU9MDtlPHIubGVuZ3RoO2UrKyl0LnB1c2gocltlXSl9fSxodC5hc0xpc3Q9ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49MCxzPXQubGVuZ3RoO248cztuKyspZS5hZGQodFtuXSk7cmV0dXJuIGV9O2NsYXNzIHV0e2NvbnN0cnVjdG9yKCl7dXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9EaW1lbnNpb25TeW1ib2wodCl7c3dpdGNoKHQpe2Nhc2UgdXQuRkFMU0U6cmV0dXJuIHV0LlNZTV9GQUxTRTtjYXNlIHV0LlRSVUU6cmV0dXJuIHV0LlNZTV9UUlVFO2Nhc2UgdXQuRE9OVENBUkU6cmV0dXJuIHV0LlNZTV9ET05UQ0FSRTtjYXNlIHV0LlA6cmV0dXJuIHV0LlNZTV9QO2Nhc2UgdXQuTDpyZXR1cm4gdXQuU1lNX0w7Y2FzZSB1dC5BOnJldHVybiB1dC5TWU1fQX10aHJvdyBuZXcgbihcIlVua25vd24gZGltZW5zaW9uIHZhbHVlOiBcIit0KX1zdGF0aWMgdG9EaW1lbnNpb25WYWx1ZSh0KXtzd2l0Y2goVC50b1VwcGVyQ2FzZSh0KSl7Y2FzZSB1dC5TWU1fRkFMU0U6cmV0dXJuIHV0LkZBTFNFO2Nhc2UgdXQuU1lNX1RSVUU6cmV0dXJuIHV0LlRSVUU7Y2FzZSB1dC5TWU1fRE9OVENBUkU6cmV0dXJuIHV0LkRPTlRDQVJFO2Nhc2UgdXQuU1lNX1A6cmV0dXJuIHV0LlA7Y2FzZSB1dC5TWU1fTDpyZXR1cm4gdXQuTDtjYXNlIHV0LlNZTV9BOnJldHVybiB1dC5BfXRocm93IG5ldyBuKFwiVW5rbm93biBkaW1lbnNpb24gc3ltYm9sOiBcIit0KX1nZXRDbGFzcygpe3JldHVybiB1dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dXQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSx1dC5QPTAsdXQuTD0xLHV0LkE9Mix1dC5GQUxTRT0tMSx1dC5UUlVFPS0yLHV0LkRPTlRDQVJFPS0zLHV0LlNZTV9GQUxTRT1cIkZcIix1dC5TWU1fVFJVRT1cIlRcIix1dC5TWU1fRE9OVENBUkU9XCIqXCIsdXQuU1lNX1A9XCIwXCIsdXQuU1lNX0w9XCIxXCIsdXQuU1lNX0E9XCIyXCI7Y2xhc3MgZ3R7Y29uc3RydWN0b3IoKXtndC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gZ3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWd0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgZHR7Y29uc3RydWN0b3IoKXtkdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0LGUpe31pc0RvbmUoKXt9aXNHZW9tZXRyeUNoYW5nZWQoKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gZHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWR0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgX3QgZXh0ZW5kcyBxe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxfdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7Y29uc3QgdD1uZXcgTjtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9nZW9tZXRyaWVzW2VdLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIHR9Z2V0R2VvbWV0cnlOKHQpe3JldHVybiB0aGlzLl9nZW9tZXRyaWVzW3RdfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKTtsZXQgZT0tMTtmb3IobGV0IG49MDtuPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO24rKyl7Y29uc3Qgcz10aGlzLl9nZW9tZXRyaWVzW25dLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxzLmxlbmd0aDtuKyspZSsrLHRbZV09c1tuXX1yZXR1cm4gdH1nZXRBcmVhKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldEFyZWEoKTtyZXR1cm4gdH1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO2NvbnN0IG49dDtpZih0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCE9PW4uX2dlb21ldHJpZXMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9nZW9tZXRyaWVzW3RdLmVxdWFsc0V4YWN0KG4uX2dlb21ldHJpZXNbdF0sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKyl0aGlzLl9nZW9tZXRyaWVzW3RdLm5vcm1hbGl6ZSgpO2h0LnNvcnQodGhpcy5fZ2VvbWV0cmllcyl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuX2dlb21ldHJpZXNbMF0uZ2V0Q29vcmRpbmF0ZSgpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7bGV0IHQ9dXQuRkFMU0U7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdD1NYXRoLm1heCh0LHRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSk7cmV0dXJuIHR9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gcS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT059Z2V0RGltZW5zaW9uKCl7bGV0IHQ9dXQuRkFMU0U7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdD1NYXRoLm1heCh0LHRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0RGltZW5zaW9uKCkpO3JldHVybiB0fWdldExlbmd0aCgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRMZW5ndGgoKTtyZXR1cm4gdH1nZXROdW1Qb2ludHMoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIHR9Z2V0TnVtR2VvbWV0cmllcygpe3JldHVybiB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aH1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWVbdF09dGhpcy5fZ2VvbWV0cmllc1t0XS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgYXQoaHQuYXNMaXN0KHRoaXMuX2dlb21ldHJpZXMpKSxuPW5ldyBhdChodC5hc0xpc3QodC5fZ2VvbWV0cmllcykpO3JldHVybiB0aGlzLmNvbXBhcmUoZSxuKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LHM9dGhpcy5nZXROdW1HZW9tZXRyaWVzKCksaT1uLmdldE51bUdlb21ldHJpZXMoKTtsZXQgcj0wO2Zvcig7cjxzJiZyPGk7KXtjb25zdCB0PXRoaXMuZ2V0R2VvbWV0cnlOKHIpLHM9bi5nZXRHZW9tZXRyeU4ociksaT10LmNvbXBhcmVUb1NhbWVDbGFzcyhzLGUpO2lmKDAhPT1pKXJldHVybiBpO3IrK31yZXR1cm4gcjxzPzE6cjxpPy0xOjB9fWFwcGx5KCl7aWYoXyhhcmd1bWVudHNbMF0sQikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxkdCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDA9PT10aGlzLl9nZW9tZXRyaWVzLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoJiYodGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KSwhdC5pc0RvbmUoKSk7ZSsrKTt0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxndCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuZmlsdGVyKHRoaXMpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5maWx0ZXIodGhpcyk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KX19Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKSx1LnNob3VsZE5ldmVyUmVhY2hIZXJlKCksbnVsbH1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9HRU9NRVRSWUNPTExFQ1RJT059Y29weSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBfdCh0LHRoaXMuX2ZhY3RvcnkpfWlzRW1wdHkoKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5fZ2VvbWV0cmllc1t0XS5pc0VtcHR5KCkpcmV0dXJuITE7cmV0dXJuITB9Z2V0Q2xhc3MoKXtyZXR1cm4gX3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fV90LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2dlb21ldHJpZXM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzBdO2NvbnN0IGU9YXJndW1lbnRzWzFdO2lmKHEuY29uc3RydWN0b3JfLmNhbGwodGhpcyxlKSxudWxsPT09dCYmKHQ9W10pLHEuaGFzTnVsbEVsZW1lbnRzKHQpKXRocm93IG5ldyBuKFwiZ2VvbWV0cmllcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7dGhpcy5fZ2VvbWV0cmllcz10fX0sX3Quc2VyaWFsVmVyc2lvblVJRD0tMHg0ZjA3YmNiMWY4NTdkODAwO2NsYXNzIGZ0IGV4dGVuZHMgX3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLGZ0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJnN1cGVyLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpP3V0LkZBTFNFOjB9aXNDbG9zZWQoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5fZ2VvbWV0cmllc1t0XS5pc0Nsb3NlZCgpKXJldHVybiExO3JldHVybiEwfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfTVVMVElMSU5FU1RSSU5HfWdldERpbWVuc2lvbigpe3JldHVybiAxfXJldmVyc2UoKXtjb25zdCB0PXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtuKyspZVt0LTEtbl09dGhpcy5fZ2VvbWV0cmllc1tuXS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX1nZXRCb3VuZGFyeSgpe3JldHVybiBuZXcgcHQodGhpcykuZ2V0Qm91bmRhcnkoKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9NVUxUSUxJTkVTVFJJTkd9Y29weSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBmdCh0LHRoaXMuX2ZhY3RvcnkpfWdldENsYXNzKCl7cmV0dXJuIGZ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvdF19fWZ0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO190LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX0sZnQuc2VyaWFsVmVyc2lvblVJRD0weDcxNTVkMmFiNGFmYTgwMDA7Y2xhc3MgcHR7Y29uc3RydWN0b3IoKXtwdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRCb3VuZGFyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IHB0KHQpLmdldEJvdW5kYXJ5KCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgcHQodCxlKS5nZXRCb3VuZGFyeSgpfX1ib3VuZGFyeU11bHRpTGluZVN0cmluZyh0KXtpZih0aGlzLl9nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTtjb25zdCBlPXRoaXMuY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXModCk7cmV0dXJuIDE9PT1lLmxlbmd0aD90aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludChlWzBdKTp0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyhlKX1nZXRCb3VuZGFyeSgpe3JldHVybiB0aGlzLl9nZW9tIGluc3RhbmNlb2YgVHQ/dGhpcy5ib3VuZGFyeUxpbmVTdHJpbmcodGhpcy5fZ2VvbSk6dGhpcy5fZ2VvbSBpbnN0YW5jZW9mIGZ0P3RoaXMuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcodGhpcy5fZ2VvbSk6dGhpcy5fZ2VvbS5nZXRCb3VuZGFyeSgpfWJvdW5kYXJ5TGluZVN0cmluZyh0KXtpZih0aGlzLl9nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTtpZih0LmlzQ2xvc2VkKCkpe3JldHVybiB0aGlzLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KDIpP3QuZ2V0U3RhcnRQb2ludCgpOnRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX1yZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludChbdC5nZXRTdGFydFBvaW50KCksdC5nZXRFbmRQb2ludCgpXSl9Z2V0RW1wdHlNdWx0aVBvaW50KCl7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX1jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyB4O3RoaXMuX2VuZHBvaW50TWFwPW5ldyBydDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTswIT09bi5nZXROdW1Qb2ludHMoKSYmKHRoaXMuYWRkRW5kcG9pbnQobi5nZXRDb29yZGluYXRlTigwKSksdGhpcy5hZGRFbmRwb2ludChuLmdldENvb3JkaW5hdGVOKG4uZ2V0TnVtUG9pbnRzKCktMSkpKX1mb3IobGV0IHQ9dGhpcy5fZW5kcG9pbnRNYXAuZW50cnlTZXQoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKSxzPW4uZ2V0VmFsdWUoKS5jb3VudDt0aGlzLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KHMpJiZlLmFkZChuLmdldEtleSgpKX1yZXR1cm4gWC50b0Nvb3JkaW5hdGVBcnJheShlKX1hZGRFbmRwb2ludCh0KXtsZXQgZT10aGlzLl9lbmRwb2ludE1hcC5nZXQodCk7bnVsbD09PWUmJihlPW5ldyBtdCx0aGlzLl9lbmRwb2ludE1hcC5wdXQodCxlKSksZS5jb3VudCsrfWdldENsYXNzKCl7cmV0dXJuIHB0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1wdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9nZW9tPW51bGwsdGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9iblJ1bGU9bnVsbCx0aGlzLl9lbmRwb2ludE1hcD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtwdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsVi5NT0QyX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb209dCx0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKSx0aGlzLl9iblJ1bGU9ZX19O2NsYXNzIG10e2NvbnN0cnVjdG9yKCl7bXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBtdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bXQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5jb3VudD1udWxsfTtjbGFzcyB5dHtjb25zdHJ1Y3Rvcigpe3l0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG9mTGluZSh0KXtjb25zdCBlPXQuc2l6ZSgpO2lmKGU8PTEpcmV0dXJuIDA7bGV0IG49MDtjb25zdCBzPW5ldyBnO3QuZ2V0Q29vcmRpbmF0ZSgwLHMpO2xldCBpPXMueCxyPXMueTtmb3IobGV0IG89MTtvPGU7bysrKXt0LmdldENvb3JkaW5hdGUobyxzKTtjb25zdCBlPXMueCxsPXMueSxhPWUtaSxjPWwtcjtuKz1NYXRoLnNxcnQoYSphK2MqYyksaT1lLHI9bH1yZXR1cm4gbn1nZXRDbGFzcygpe3JldHVybiB5dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24geHQoKXt9ZnVuY3Rpb24gRXQoKXt9ZnVuY3Rpb24gSXQoKXt9ZnVuY3Rpb24gTnQoKXt9ZnVuY3Rpb24gQ3QoKXt9eXQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBTdHtjb25zdHJ1Y3Rvcigpe1N0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNoYXJzKHQsZSl7Y29uc3Qgbj1uZXcgQXJyYXkoZSkuZmlsbChudWxsKTtmb3IobGV0IHM9MDtzPGU7cysrKW5bc109dDtyZXR1cm4gbmV3IFN0cmluZyhuKX1zdGF0aWMgZ2V0U3RhY2tUcmFjZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBJdCxuPW5ldyB4dChlKTtyZXR1cm4gdC5wcmludFN0YWNrVHJhY2UobiksZS50b1N0cmluZygpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1cIlwiO2NvbnN0IHM9bmV3IEN0KG5ldyBFdChTdC5nZXRTdGFja1RyYWNlKHQpKSk7Zm9yKGxldCB0PTA7dDxlO3QrKyl0cnl7bis9cy5yZWFkTGluZSgpK1N0Lk5FV0xJTkV9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgTnQpKXRocm93IHQ7dS5zaG91bGROZXZlclJlYWNoSGVyZSgpfXJldHVybiBufX1zdGF0aWMgc3BsaXQodCxlKXtjb25zdCBuPWUubGVuZ3RoLHM9bmV3IHg7bGV0IGk9XCJcIit0LHI9aS5pbmRleE9mKGUpO2Zvcig7cj49MDspe2NvbnN0IHQ9aS5zdWJzdHJpbmcoMCxyKTtzLmFkZCh0KSxpPWkuc3Vic3RyaW5nKHIrbikscj1pLmluZGV4T2YoZSl9aS5sZW5ndGg+MCYmcy5hZGQoaSk7Y29uc3Qgbz1uZXcgQXJyYXkocy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDt0Kyspb1t0XT1zLmdldCh0KTtyZXR1cm4gb31zdGF0aWMgdG9TdHJpbmcoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIFN0LlNJTVBMRV9PUkRJTkFURV9GT1JNQVQuZm9ybWF0KHQpfX1zdGF0aWMgc3BhY2VzKHQpe3JldHVybiBTdC5jaGFycyhcIiBcIix0KX1nZXRDbGFzcygpe3JldHVybiBTdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gd3QodCl7dGhpcy5zdHI9dH1TdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFN0Lk5FV0xJTkU9Ty5nZXRQcm9wZXJ0eShcImxpbmUuc2VwYXJhdG9yXCIpLFN0LlNJTVBMRV9PUkRJTkFURV9GT1JNQVQ9bmV3IGZ1bmN0aW9uKCl7fShcIjAuI1wiKSx3dC5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKHQpe3RoaXMuc3RyKz10fSx3dC5wcm90b3R5cGUuc2V0Q2hhckF0PWZ1bmN0aW9uKHQsZSl7dGhpcy5zdHI9dGhpcy5zdHIuc3Vic3RyKDAsdCkrZSt0aGlzLnN0ci5zdWJzdHIodCsxKX0sd3QucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0cn07Y2xhc3MgTHR7Y29uc3RydWN0b3IoKXtMdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb3B5Q29vcmQodCxlLG4scyl7Y29uc3QgaT1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLG4uZ2V0RGltZW5zaW9uKCkpO2ZvcihsZXQgcj0wO3I8aTtyKyspbi5zZXRPcmRpbmF0ZShzLHIsdC5nZXRPcmRpbmF0ZShlLHIpKX1zdGF0aWMgaXNSaW5nKHQpe2NvbnN0IGU9dC5zaXplKCk7cmV0dXJuIDA9PT1lfHwhKGU8PTMpJiYodC5nZXRPcmRpbmF0ZSgwLEEuWCk9PT10LmdldE9yZGluYXRlKGUtMSxBLlgpJiZ0LmdldE9yZGluYXRlKDAsQS5ZKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEEuWSkpfXN0YXRpYyBpc0VxdWFsKHQsZSl7Y29uc3Qgbj10LnNpemUoKTtpZihuIT09ZS5zaXplKCkpcmV0dXJuITE7Y29uc3Qgcz1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpO2ZvcihsZXQgcj0wO3I8bjtyKyspZm9yKGxldCBuPTA7bjxzO24rKyl7Y29uc3Qgcz10LmdldE9yZGluYXRlKHIsbiksbz1lLmdldE9yZGluYXRlKHIsbik7aWYodC5nZXRPcmRpbmF0ZShyLG4pIT09ZS5nZXRPcmRpbmF0ZShyLG4pJiYoIWkuaXNOYU4ocyl8fCFpLmlzTmFOKG8pKSlyZXR1cm4hMX1yZXR1cm4hMH1zdGF0aWMgZXh0ZW5kKHQsZSxuKXtjb25zdCBzPXQuY3JlYXRlKG4sZS5nZXREaW1lbnNpb24oKSksaT1lLnNpemUoKTtpZihMdC5jb3B5KGUsMCxzLDAsaSksaT4wKWZvcihsZXQgdD1pO3Q8bjt0KyspTHQuY29weShlLGktMSxzLHQsMSk7cmV0dXJuIHN9c3RhdGljIHJldmVyc2UodCl7Y29uc3QgZT10LnNpemUoKS0xLG49TWF0aC50cnVuYyhlLzIpO2ZvcihsZXQgcz0wO3M8PW47cysrKUx0LnN3YXAodCxzLGUtcyl9c3RhdGljIHN3YXAodCxlLG4pe2lmKGU9PT1uKXJldHVybiBudWxsO2ZvcihsZXQgcz0wO3M8dC5nZXREaW1lbnNpb24oKTtzKyspe2NvbnN0IGk9dC5nZXRPcmRpbmF0ZShlLHMpO3Quc2V0T3JkaW5hdGUoZSxzLHQuZ2V0T3JkaW5hdGUobixzKSksdC5zZXRPcmRpbmF0ZShuLHMsaSl9fXN0YXRpYyBjb3B5KHQsZSxuLHMsaSl7Zm9yKGxldCByPTA7cjxpO3IrKylMdC5jb3B5Q29vcmQodCxlK3IsbixzK3IpfXN0YXRpYyB0b1N0cmluZygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LnNpemUoKTtpZigwPT09ZSlyZXR1cm5cIigpXCI7Y29uc3Qgbj10LmdldERpbWVuc2lvbigpLHM9bmV3IHd0O3MuYXBwZW5kKFwiKFwiKTtmb3IobGV0IGk9MDtpPGU7aSsrKXtpPjAmJnMuYXBwZW5kKFwiIFwiKTtmb3IobGV0IGU9MDtlPG47ZSsrKWU+MCYmcy5hcHBlbmQoXCIsXCIpLHMuYXBwZW5kKFN0LnRvU3RyaW5nKHQuZ2V0T3JkaW5hdGUoaSxlKSkpfXJldHVybiBzLmFwcGVuZChcIilcIikscy50b1N0cmluZygpfX1zdGF0aWMgZW5zdXJlVmFsaWRSaW5nKHQsZSl7Y29uc3Qgbj1lLnNpemUoKTtyZXR1cm4gMD09PW4/ZTpuPD0zP0x0LmNyZWF0ZUNsb3NlZFJpbmcodCxlLDQpOmUuZ2V0T3JkaW5hdGUoMCxBLlgpPT09ZS5nZXRPcmRpbmF0ZShuLTEsQS5YKSYmZS5nZXRPcmRpbmF0ZSgwLEEuWSk9PT1lLmdldE9yZGluYXRlKG4tMSxBLlkpP2U6THQuY3JlYXRlQ2xvc2VkUmluZyh0LGUsbisxKX1zdGF0aWMgY3JlYXRlQ2xvc2VkUmluZyh0LGUsbil7Y29uc3Qgcz10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLGk9ZS5zaXplKCk7THQuY29weShlLDAscywwLGkpO2ZvcihsZXQgdD1pO3Q8bjt0KyspTHQuY29weShlLDAscyx0LDEpO3JldHVybiBzfWdldENsYXNzKCl7cmV0dXJuIEx0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1MdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFR0IGV4dGVuZHMgcXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksVHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9uZXcgTjp0aGlzLl9wb2ludHMuZXhwYW5kRW52ZWxvcGUobmV3IE4pfWlzUmluZygpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCkmJnRoaXMuaXNTaW1wbGUoKX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wb2ludHMudG9Db29yZGluYXRlQXJyYXkoKX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO2NvbnN0IG49dDtpZih0aGlzLl9wb2ludHMuc2l6ZSgpIT09bi5fcG9pbnRzLnNpemUoKSlyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX3BvaW50cy5zaXplKCk7dCsrKWlmKCF0aGlzLmVxdWFsKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLG4uX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7Zm9yKGxldCB0PTA7dDxNYXRoLnRydW5jKHRoaXMuX3BvaW50cy5zaXplKCkvMik7dCsrKXtjb25zdCBlPXRoaXMuX3BvaW50cy5zaXplKCktMS10O2lmKCF0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5lcXVhbHModGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkpKXtpZih0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5jb21wYXJlVG8odGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkpPjApe2NvbnN0IHQ9dGhpcy5fcG9pbnRzLmNvcHkoKTtMdC5yZXZlcnNlKHQpLHRoaXMuX3BvaW50cz10fXJldHVybiBudWxsfX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKDApfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT91dC5GQUxTRTowfWlzQ2xvc2VkKCl7cmV0dXJuIXRoaXMuaXNFbXB0eSgpJiZ0aGlzLmdldENvb3JkaW5hdGVOKDApLmVxdWFsczJEKHRoaXMuZ2V0Q29vcmRpbmF0ZU4odGhpcy5nZXROdW1Qb2ludHMoKS0xKSl9Z2V0RW5kUG9pbnQoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50Tih0aGlzLmdldE51bVBvaW50cygpLTEpfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfTElORVNUUklOR31nZXREaW1lbnNpb24oKXtyZXR1cm4gMX1nZXRMZW5ndGgoKXtyZXR1cm4geXQub2ZMaW5lKHRoaXMuX3BvaW50cyl9Z2V0TnVtUG9pbnRzKCl7cmV0dXJuIHRoaXMuX3BvaW50cy5zaXplKCl9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5fcG9pbnRzLmNvcHkoKTtyZXR1cm4gTHQucmV2ZXJzZSh0KSx0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQpfWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT0wLG49MDtmb3IoO2U8dGhpcy5fcG9pbnRzLnNpemUoKSYmbjx0Ll9wb2ludHMuc2l6ZSgpOyl7Y29uc3Qgcz10aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKS5jb21wYXJlVG8odC5fcG9pbnRzLmdldENvb3JkaW5hdGUobikpO2lmKDAhPT1zKXJldHVybiBzO2UrKyxuKyt9cmV0dXJuIGU8dGhpcy5fcG9pbnRzLnNpemUoKT8xOm48dC5fcG9pbnRzLnNpemUoKT8tMTowfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gYXJndW1lbnRzWzFdLmNvbXBhcmUodGhpcy5fcG9pbnRzLHQuX3BvaW50cyl9fWFwcGx5KCl7aWYoXyhhcmd1bWVudHNbMF0sQikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9pbnRzLnNpemUoKTtlKyspdC5maWx0ZXIodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZHQpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigwPT09dGhpcy5fcG9pbnRzLnNpemUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCkmJih0LmZpbHRlcih0aGlzLl9wb2ludHMsZSksIXQuaXNEb25lKCkpO2UrKyk7dC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZ3QpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sRykpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9fWdldEJvdW5kYXJ5KCl7cmV0dXJuIG5ldyBwdCh0aGlzKS5nZXRCb3VuZGFyeSgpfWlzRXF1aXZhbGVudENsYXNzKHQpe3JldHVybiB0IGluc3RhbmNlb2YgVHR9Z2V0Q29vcmRpbmF0ZU4odCl7cmV0dXJuIHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX0xJTkVTVFJJTkd9Y29weSgpe3JldHVybiBuZXcgVHQodGhpcy5fcG9pbnRzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1nZXRDb29yZGluYXRlU2VxdWVuY2UoKXtyZXR1cm4gdGhpcy5fcG9pbnRzfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuX3BvaW50cy5zaXplKCl9aW5pdCh0KXtpZihudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLDE9PT10LnNpemUoKSl0aHJvdyBuZXcgbihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lU3RyaW5nIChmb3VuZCBcIit0LnNpemUoKStcIiAtIG11c3QgYmUgMCBvciA+PSAyKVwiKTt0aGlzLl9wb2ludHM9dH1pc0Nvb3JkaW5hdGUodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpO2UrKylpZih0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKS5lcXVhbHModCkpcmV0dXJuITA7cmV0dXJuITF9Z2V0U3RhcnRQb2ludCgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2V0UG9pbnROKDApfWdldFBvaW50Tih0KXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkpfWdldENsYXNzKCl7cmV0dXJuIFR0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvdF19fVR0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3BvaW50cz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtxLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfX0sVHQuc2VyaWFsVmVyc2lvblVJRD0weDJiMmI1MWJhNDM1YzhlMDA7Y2xhc3MgUnR7Y29uc3RydWN0b3IoKXtSdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIFJ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1SdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFB0IGV4dGVuZHMgcXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBuZXcgTjtjb25zdCB0PW5ldyBOO3JldHVybiB0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb29yZGluYXRlcy5nZXRYKDApLHRoaXMuX2Nvb3JkaW5hdGVzLmdldFkoMCkpLHR9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/W106W3RoaXMuZ2V0Q29vcmRpbmF0ZSgpXX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmKCEoIXRoaXMuaXNFbXB0eSgpfHwhdC5pc0VtcHR5KCkpfHx0aGlzLmlzRW1wdHkoKT09PXQuaXNFbXB0eSgpJiZ0aGlzLmVxdWFsKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLGUpKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe31nZXRDb29yZGluYXRlKCl7cmV0dXJuIDAhPT10aGlzLl9jb29yZGluYXRlcy5zaXplKCk/dGhpcy5fY29vcmRpbmF0ZXMuZ2V0Q29vcmRpbmF0ZSgwKTpudWxsfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHV0LkZBTFNFfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfUE9JTlR9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDB9Z2V0TnVtUG9pbnRzKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6MX1yZXZlcnNlKCl7cmV0dXJuIHRoaXMuY29weSgpfWdldFgoKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcImdldFggY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS54fWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHQuZ2V0Q29vcmRpbmF0ZSgpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGFyZ3VtZW50c1sxXS5jb21wYXJlKHRoaXMuX2Nvb3JkaW5hdGVzLHQuX2Nvb3JkaW5hdGVzKX19YXBwbHkoKXtpZihfKGFyZ3VtZW50c1swXSxCKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dC5maWx0ZXIodGhpcy5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZHQpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0LmZpbHRlcih0aGlzLl9jb29yZGluYXRlcywwKSx0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxndCkpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxHKSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX19Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfUE9JTlR9Y29weSgpe3JldHVybiBuZXcgUHQodGhpcy5fY29vcmRpbmF0ZXMuY29weSgpLHRoaXMuX2ZhY3RvcnkpfWdldENvb3JkaW5hdGVTZXF1ZW5jZSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc31nZXRZKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJnZXRZIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9jb29yZGluYXRlcy5zaXplKCl9aW5pdCh0KXtudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLHUuaXNUcnVlKHQuc2l6ZSgpPD0xKSx0aGlzLl9jb29yZGluYXRlcz10fWlzU2ltcGxlKCl7cmV0dXJuITB9Z2V0Q2xhc3MoKXtyZXR1cm4gUHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1J0XX19UHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29vcmRpbmF0ZXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtxLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfSxQdC5zZXJpYWxWZXJzaW9uVUlEPTB4NDQwNzdiYWQxNjFjYmMwMDtjbGFzcyB2dHtjb25zdHJ1Y3Rvcigpe3Z0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG9mUmluZygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmFicyh2dC5vZlJpbmdTaWduZWQodCkpfWlmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hYnModnQub2ZSaW5nU2lnbmVkKHQpKX19c3RhdGljIG9mUmluZ1NpZ25lZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQubGVuZ3RoPDMpcmV0dXJuIDA7bGV0IGU9MDtjb25zdCBuPXRbMF0ueDtmb3IobGV0IHM9MTtzPHQubGVuZ3RoLTE7cysrKXtjb25zdCBpPXRbc10ueC1uLHI9dFtzKzFdLnk7ZSs9aSoodFtzLTFdLnktcil9cmV0dXJuIGUvMn1pZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LnNpemUoKTtpZihlPDMpcmV0dXJuIDA7Y29uc3Qgbj1uZXcgZyxzPW5ldyBnLGk9bmV3IGc7dC5nZXRDb29yZGluYXRlKDAscyksdC5nZXRDb29yZGluYXRlKDEsaSk7Y29uc3Qgcj1zLng7aS54LT1yO2xldCBvPTA7Zm9yKGxldCBsPTE7bDxlLTE7bCsrKW4ueT1zLnkscy54PWkueCxzLnk9aS55LHQuZ2V0Q29vcmRpbmF0ZShsKzEsaSksaS54LT1yLG8rPXMueCoobi55LWkueSk7cmV0dXJuIG8vMn19Z2V0Q2xhc3MoKXtyZXR1cm4gdnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXZ0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgT3R7Y29uc3RydWN0b3IoKXtPdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIE90fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1PdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGJ0IGV4dGVuZHMgcXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksYnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe3JldHVybiB0aGlzLl9zaGVsbC5nZXRFbnZlbG9wZUludGVybmFsKCl9Z2V0Q29vcmRpbmF0ZXMoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm5bXTtjb25zdCB0PW5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpO2xldCBlPS0xO2NvbnN0IG49dGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyllKyssdFtlXT1uW3NdO2ZvcihsZXQgbj0wO248dGhpcy5faG9sZXMubGVuZ3RoO24rKyl7Y29uc3Qgcz10aGlzLl9ob2xlc1tuXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248cy5sZW5ndGg7bisrKWUrKyx0W2VdPXNbbl19cmV0dXJuIHR9Z2V0QXJlYSgpe2xldCB0PTA7dCs9dnQub2ZSaW5nKHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdC09dnQub2ZSaW5nKHRoaXMuX2hvbGVzW2VdLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtyZXR1cm4gdH1pc1JlY3RhbmdsZSgpe2lmKDAhPT10aGlzLmdldE51bUludGVyaW9yUmluZygpKXJldHVybiExO2lmKG51bGw9PT10aGlzLl9zaGVsbClyZXR1cm4hMTtpZig1IT09dGhpcy5fc2hlbGwuZ2V0TnVtUG9pbnRzKCkpcmV0dXJuITE7Y29uc3QgdD10aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxlPXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2ZvcihsZXQgbj0wO248NTtuKyspe2NvbnN0IHM9dC5nZXRYKG4pO2lmKHMhPT1lLmdldE1pblgoKSYmcyE9PWUuZ2V0TWF4WCgpKXJldHVybiExO2NvbnN0IGk9dC5nZXRZKG4pO2lmKGkhPT1lLmdldE1pblkoKSYmaSE9PWUuZ2V0TWF4WSgpKXJldHVybiExfWxldCBuPXQuZ2V0WCgwKSxzPXQuZ2V0WSgwKTtmb3IobGV0IGU9MTtlPD00O2UrKyl7Y29uc3QgaT10LmdldFgoZSkscj10LmdldFkoZSk7aWYoaSE9PW49PT0ociE9PXMpKXJldHVybiExO249aSxzPXJ9cmV0dXJuITB9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQscz10aGlzLl9zaGVsbCxpPW4uX3NoZWxsO2lmKCFzLmVxdWFsc0V4YWN0KGksZSkpcmV0dXJuITE7aWYodGhpcy5faG9sZXMubGVuZ3RoIT09bi5faG9sZXMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMubGVuZ3RoO3QrKylpZighdGhpcy5faG9sZXNbdF0uZXF1YWxzRXhhY3Qobi5faG9sZXNbdF0sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5ub3JtYWxpemUodGhpcy5fc2hlbGwsITApO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMubGVuZ3RoO3QrKyl0aGlzLm5vcm1hbGl6ZSh0aGlzLl9ob2xlc1t0XSwhMSk7aHQuc29ydCh0aGlzLl9ob2xlcyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgQXJyYXkodC5nZXRDb29yZGluYXRlcygpLmxlbmd0aC0xKS5maWxsKG51bGwpO08uYXJyYXljb3B5KHQuZ2V0Q29vcmRpbmF0ZXMoKSwwLG4sMCxuLmxlbmd0aCk7Y29uc3Qgcz1YLm1pbkNvb3JkaW5hdGUodC5nZXRDb29yZGluYXRlcygpKTtYLnNjcm9sbChuLHMpLE8uYXJyYXljb3B5KG4sMCx0LmdldENvb3JkaW5hdGVzKCksMCxuLmxlbmd0aCksdC5nZXRDb29yZGluYXRlcygpW24ubGVuZ3RoXT1uWzBdLHYuaXNDQ1codC5nZXRDb29yZGluYXRlcygpKT09PWUmJlgucmV2ZXJzZSh0LmdldENvb3JkaW5hdGVzKCkpfX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGUoKX1nZXROdW1JbnRlcmlvclJpbmcoKXtyZXR1cm4gdGhpcy5faG9sZXMubGVuZ3RofWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIDF9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gcS5UWVBFQ09ERV9QT0xZR09OfWdldERpbWVuc2lvbigpe3JldHVybiAyfWdldExlbmd0aCgpe2xldCB0PTA7dCs9dGhpcy5fc2hlbGwuZ2V0TGVuZ3RoKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2hvbGVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fWdldE51bVBvaW50cygpe2xldCB0PXRoaXMuX3NoZWxsLmdldE51bVBvaW50cygpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9ob2xlc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLmNvcHkoKTt0Ll9zaGVsbD10aGlzLl9zaGVsbC5jb3B5KCkucmV2ZXJzZSgpLHQuX2hvbGVzPW5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQuX2hvbGVzW2VdPXRoaXMuX2hvbGVzW2VdLmNvcHkoKS5yZXZlcnNlKCk7cmV0dXJuIHR9Y29udmV4SHVsbCgpe3JldHVybiB0aGlzLmdldEV4dGVyaW9yUmluZygpLmNvbnZleEh1bGwoKX1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLl9zaGVsbCxuPXQuX3NoZWxsO3JldHVybiBlLmNvbXBhcmVUb1NhbWVDbGFzcyhuKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LHM9dGhpcy5fc2hlbGwsaT1uLl9zaGVsbCxyPXMuY29tcGFyZVRvU2FtZUNsYXNzKGksZSk7aWYoMCE9PXIpcmV0dXJuIHI7Y29uc3Qgbz10aGlzLmdldE51bUludGVyaW9yUmluZygpLGw9bi5nZXROdW1JbnRlcmlvclJpbmcoKTtsZXQgYT0wO2Zvcig7YTxvJiZhPGw7KXtjb25zdCB0PXRoaXMuZ2V0SW50ZXJpb3JSaW5nTihhKSxzPW4uZ2V0SW50ZXJpb3JSaW5nTihhKSxpPXQuY29tcGFyZVRvU2FtZUNsYXNzKHMsZSk7aWYoMCE9PWkpcmV0dXJuIGk7YSsrfXJldHVybiBhPG8/MTphPGw/LTE6MH19YXBwbHkoKXtpZihfKGFyZ3VtZW50c1swXSxCKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2hlbGwuYXBwbHkodCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZHQpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLl9zaGVsbC5hcHBseSh0KSwhdC5pc0RvbmUoKSlmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aCYmKHRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGd0KSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmZpbHRlcih0aGlzKSx0aGlzLl9zaGVsbC5hcHBseSh0KTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdGhpcy5faG9sZXNbZV0uYXBwbHkodCl9fWdldEJvdW5kYXJ5KCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCsxKS5maWxsKG51bGwpO3RbMF09dGhpcy5fc2hlbGw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXRbZSsxXT10aGlzLl9ob2xlc1tlXTtyZXR1cm4gdC5sZW5ndGg8PTE/dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyh0WzBdLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTp0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcodCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfUE9MWUdPTn1jb3B5KCl7Y29uc3QgdD10aGlzLl9zaGVsbC5jb3B5KCksZT1uZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMubGVuZ3RoO3QrKyllW3RdPXRoaXMuX2hvbGVzW3RdLmNvcHkoKTtyZXR1cm4gbmV3IGJ0KHQsZSx0aGlzLl9mYWN0b3J5KX1nZXRFeHRlcmlvclJpbmcoKXtyZXR1cm4gdGhpcy5fc2hlbGx9aXNFbXB0eSgpe3JldHVybiB0aGlzLl9zaGVsbC5pc0VtcHR5KCl9Z2V0SW50ZXJpb3JSaW5nTih0KXtyZXR1cm4gdGhpcy5faG9sZXNbdF19Z2V0Q2xhc3MoKXtyZXR1cm4gYnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW090XX19YnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2hlbGw9bnVsbCx0aGlzLl9ob2xlcz1udWxsO2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtjb25zdCBzPWFyZ3VtZW50c1syXTtpZihxLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMscyksbnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoKSksbnVsbD09PWUmJihlPVtdKSxxLmhhc051bGxFbGVtZW50cyhlKSl0aHJvdyBuZXcgbihcImhvbGVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50c1wiKTtpZih0LmlzRW1wdHkoKSYmcS5oYXNOb25FbXB0eUVsZW1lbnRzKGUpKXRocm93IG5ldyBuKFwic2hlbGwgaXMgZW1wdHkgYnV0IGhvbGVzIGFyZSBub3RcIik7dGhpcy5fc2hlbGw9dCx0aGlzLl9ob2xlcz1lfSxidC5zZXJpYWxWZXJzaW9uVUlEPS0weDMwN2ZmZWZkOGRjOTcyMDA7Y2xhc3MgTXQgZXh0ZW5kcyBfdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc1ZhbGlkKCl7cmV0dXJuITB9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJnN1cGVyLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9nZW9tZXRyaWVzW3RdLmdldENvb3JkaW5hdGUoKX1yZXR1cm4gc3VwZXIuZ2V0Q29vcmRpbmF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gdXQuRkFMU0V9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gcS5UWVBFQ09ERV9NVUxUSVBPSU5UfWdldERpbWVuc2lvbigpe3JldHVybiAwfWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX01VTFRJUE9JTlR9Y29weSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBNdCh0LHRoaXMuX2ZhY3RvcnkpfWdldENsYXNzKCl7cmV0dXJuIE10fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltSdF19fU10LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO190LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX0sTXQuc2VyaWFsVmVyc2lvblVJRD0tMHg2ZmIxZWQ0MTYyZTBmYzAwO2NsYXNzIER0IGV4dGVuZHMgVHR7Y29uc3RydWN0b3IoKXtzdXBlcigpLER0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gdXQuRkFMU0V9aXNDbG9zZWQoKXtyZXR1cm4hIXRoaXMuaXNFbXB0eSgpfHxzdXBlci5pc0Nsb3NlZC5jYWxsKHRoaXMpfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfTElORUFSUklOR31yZXZlcnNlKCl7Y29uc3QgdD10aGlzLl9wb2ludHMuY29weSgpO3JldHVybiBMdC5yZXZlcnNlKHQpLHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodCl9dmFsaWRhdGVDb25zdHJ1Y3Rpb24oKXtpZighdGhpcy5pc0VtcHR5KCkmJiFzdXBlci5pc0Nsb3NlZC5jYWxsKHRoaXMpKXRocm93IG5ldyBuKFwiUG9pbnRzIG9mIExpbmVhclJpbmcgZG8gbm90IGZvcm0gYSBjbG9zZWQgbGluZXN0cmluZ1wiKTtpZih0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKT49MSYmdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk8RHQuTUlOSU1VTV9WQUxJRF9TSVpFKXRocm93IG5ldyBuKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVhclJpbmcgKGZvdW5kIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDQpXCIpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX0xJTkVBUlJJTkd9Y29weSgpe3JldHVybiBuZXcgRHQodGhpcy5fcG9pbnRzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1nZXRDbGFzcygpe3JldHVybiBEdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBIdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07RHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyxlLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCksZSl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxBKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBIdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07VHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMudmFsaWRhdGVDb25zdHJ1Y3Rpb24oKX19LER0Lk1JTklNVU1fVkFMSURfU0laRT00LER0LnNlcmlhbFZlcnNpb25VSUQ9LTB4M2IyMjllMjYyMzY3YTYwMDtjbGFzcyBBdCBleHRlbmRzIF90e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxBdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIDF9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gcS5UWVBFQ09ERV9NVUxUSVBPTFlHT059Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDJ9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKyllW3RdPXRoaXMuX2dlb21ldHJpZXNbdF0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9Z2V0Qm91bmRhcnkoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Y29uc3QgdD1uZXcgeDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl7Y29uc3Qgbj10aGlzLl9nZW9tZXRyaWVzW2VdLmdldEJvdW5kYXJ5KCk7Zm9yKGxldCBlPTA7ZTxuLmdldE51bUdlb21ldHJpZXMoKTtlKyspdC5hZGQobi5nZXRHZW9tZXRyeU4oZSkpfWNvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcodC50b0FycmF5KGUpKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9NVUxUSVBPTFlHT059Y29weSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBBdCh0LHRoaXMuX2ZhY3RvcnkpfWdldENsYXNzKCl7cmV0dXJuIEF0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltPdF19fUF0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO190LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX0sQXQuc2VyaWFsVmVyc2lvblVJRD0tMHg3YTVhYTEzNjkxNzE5ODA7Y2xhc3MgRnR7Y29uc3RydWN0b3IoKXtGdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldENvcHlVc2VyRGF0YSh0KXt0aGlzLl9pc1VzZXJEYXRhQ29waWVkPXR9ZWRpdCh0LGUpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5lZGl0SW50ZXJuYWwodCxlKTtyZXR1cm4gdGhpcy5faXNVc2VyRGF0YUNvcGllZCYmbi5zZXRVc2VyRGF0YSh0LmdldFVzZXJEYXRhKCkpLG59ZWRpdEludGVybmFsKHQsZSl7cmV0dXJuIG51bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdCBpbnN0YW5jZW9mIF90P3RoaXMuZWRpdEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpOnQgaW5zdGFuY2VvZiBidD90aGlzLmVkaXRQb2x5Z29uKHQsZSk6dCBpbnN0YW5jZW9mIFB0fHx0IGluc3RhbmNlb2YgVHQ/ZS5lZGl0KHQsdGhpcy5fZmFjdG9yeSk6KHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbnN1cHBvcnRlZCBHZW9tZXRyeSBjbGFzczogXCIrdC5nZXRDbGFzcygpLmdldE5hbWUoKSksbnVsbCl9ZWRpdEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpe2NvbnN0IG49ZS5lZGl0KHQsdGhpcy5fZmFjdG9yeSkscz1uZXcgeDtmb3IobGV0IHQ9MDt0PG4uZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3QgaT10aGlzLmVkaXQobi5nZXRHZW9tZXRyeU4odCksZSk7bnVsbD09PWl8fGkuaXNFbXB0eSgpfHxzLmFkZChpKX1yZXR1cm4gbi5nZXRDbGFzcygpPT09TXQ/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KHMudG9BcnJheShbXSkpOm4uZ2V0Q2xhc3MoKT09PWZ0P3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHMudG9BcnJheShbXSkpOm4uZ2V0Q2xhc3MoKT09PUF0P3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKHMudG9BcnJheShbXSkpOnRoaXMuX2ZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKHMudG9BcnJheShbXSkpfWVkaXRQb2x5Z29uKHQsZSl7bGV0IG49ZS5lZGl0KHQsdGhpcy5fZmFjdG9yeSk7aWYobnVsbD09PW4mJihuPXRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbigpKSxuLmlzRW1wdHkoKSlyZXR1cm4gbjtjb25zdCBzPXRoaXMuZWRpdChuLmdldEV4dGVyaW9yUmluZygpLGUpO2lmKG51bGw9PT1zfHxzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKCk7Y29uc3QgaT1uZXcgeDtmb3IobGV0IHQ9MDt0PG4uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7dCsrKXtjb25zdCBzPXRoaXMuZWRpdChuLmdldEludGVyaW9yUmluZ04odCksZSk7bnVsbD09PXN8fHMuaXNFbXB0eSgpfHxpLmFkZChzKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHMsaS50b0FycmF5KFtdKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gRnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIEd0KCl7fUZ0Lkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uPUd0O2NsYXNzIHF0e2NvbnN0cnVjdG9yKCl7cXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lZGl0KHQsZSl7cmV0dXJuIHR9Z2V0Q2xhc3MoKXtyZXR1cm4gcXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0d0XX19cXQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBCdHtjb25zdHJ1Y3Rvcigpe0J0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZWRpdCh0LGUpe2NvbnN0IG49dGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KTtyZXR1cm4gdCBpbnN0YW5jZW9mIER0P251bGw9PT1uP2UuY3JlYXRlTGluZWFyUmluZygpOmUuY3JlYXRlTGluZWFyUmluZyhuKTp0IGluc3RhbmNlb2YgVHQ/bnVsbD09PW4/ZS5jcmVhdGVMaW5lU3RyaW5nKCk6ZS5jcmVhdGVMaW5lU3RyaW5nKG4pOnQgaW5zdGFuY2VvZiBQdD9udWxsPT09bnx8MD09PW4ubGVuZ3RoP2UuY3JlYXRlUG9pbnQoKTplLmNyZWF0ZVBvaW50KG5bMF0pOnR9Z2V0Q2xhc3MoKXtyZXR1cm4gQnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0d0XX19QnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBWdHtjb25zdHJ1Y3Rvcigpe1Z0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZWRpdCh0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgRHQ/ZS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgVHQ/ZS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgUHQ/ZS5jcmVhdGVQb2ludCh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dH1nZXRDbGFzcygpe3JldHVybiBWdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR3RdfX1WdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LEZ0Lk5vT3BHZW9tZXRyeU9wZXJhdGlvbj1xdCxGdC5Db29yZGluYXRlT3BlcmF0aW9uPUJ0LEZ0LkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbj1WdCxGdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5faXNVc2VyRGF0YUNvcGllZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fX07Y2xhc3MgenR7Y29uc3RydWN0b3IoKXt6dC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldE9yZGluYXRlKHQsZSxzKXtzd2l0Y2goZSl7Y2FzZSBBLlg6dGhpcy5fY29vcmRpbmF0ZXNbdF0ueD1zO2JyZWFrO2Nhc2UgQS5ZOnRoaXMuX2Nvb3JkaW5hdGVzW3RdLnk9czticmVhaztjYXNlIEEuWjp0aGlzLl9jb29yZGluYXRlc1t0XS56PXM7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgbihcImludmFsaWQgb3JkaW5hdGVJbmRleFwiKX19c2l6ZSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGh9Z2V0T3JkaW5hdGUodCxlKXtzd2l0Y2goZSl7Y2FzZSBBLlg6cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLng7Y2FzZSBBLlk6cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLnk7Y2FzZSBBLlo6cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLnp9cmV0dXJuIGkuTmFOfWdldENvb3JkaW5hdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtlLng9dGhpcy5fY29vcmRpbmF0ZXNbdF0ueCxlLnk9dGhpcy5fY29vcmRpbmF0ZXNbdF0ueSxlLno9dGhpcy5fY29vcmRpbmF0ZXNbdF0uen19Z2V0Q29vcmRpbmF0ZUNvcHkodCl7cmV0dXJuIG5ldyBnKHRoaXMuX2Nvb3JkaW5hdGVzW3RdKX1nZXREaW1lbnNpb24oKXtyZXR1cm4gdGhpcy5fZGltZW5zaW9ufWdldFgodCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLnh9ZXhwYW5kRW52ZWxvcGUodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2Nvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdH1jb3B5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fY29vcmRpbmF0ZXNbZV0uY29weSgpO3JldHVybiBuZXcgenQodCx0aGlzLl9kaW1lbnNpb24pfXRvU3RyaW5nKCl7aWYodGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoPjApe2NvbnN0IHQ9bmV3IHd0KDE3KnRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCk7dC5hcHBlbmQoXCIoXCIpLHQuYXBwZW5kKHRoaXMuX2Nvb3JkaW5hdGVzWzBdKTtmb3IobGV0IGU9MTtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5hcHBlbmQoXCIsIFwiKSx0LmFwcGVuZCh0aGlzLl9jb29yZGluYXRlc1tlXSk7cmV0dXJuIHQuYXBwZW5kKFwiKVwiKSx0LnRvU3RyaW5nKCl9cmV0dXJuXCIoKVwifWdldFkodCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLnl9dG9Db29yZGluYXRlQXJyYXkoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXN9Z2V0Q2xhc3MoKXtyZXR1cm4genR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0EsYV19fXp0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2RpbWVuc2lvbj0zLHRoaXMuX2Nvb3JkaW5hdGVzPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3p0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwzKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0O2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT1uZXcgZ31lbHNlIGlmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dClyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KDApLmZpbGwobnVsbCksbnVsbDt0aGlzLl9kaW1lbnNpb249dC5nZXREaW1lbnNpb24oKSx0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXRoaXMuX2Nvb3JkaW5hdGVzW2VdPXQuZ2V0Q29vcmRpbmF0ZUNvcHkoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jb29yZGluYXRlcz10LHRoaXMuX2RpbWVuc2lvbj1lLG51bGw9PT10JiYodGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KDApLmZpbGwobnVsbCkpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLHRoaXMuX2RpbWVuc2lvbj1lO2ZvcihsZXQgZT0wO2U8dDtlKyspdGhpcy5fY29vcmRpbmF0ZXNbZV09bmV3IGd9fSx6dC5zZXJpYWxWZXJzaW9uVUlEPS0weGNiNDRhNzc4ZGIxOGUwMDtjbGFzcyBZdHtjb25zdHJ1Y3Rvcigpe1l0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGluc3RhbmNlKCl7cmV0dXJuIFl0Lmluc3RhbmNlT2JqZWN0fXJlYWRSZXNvbHZlKCl7cmV0dXJuIFl0Lmluc3RhbmNlKCl9Y3JlYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgenQodCl9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgenQodCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPWFyZ3VtZW50c1sxXTtyZXR1cm4gZT4zJiYoZT0zKSxlPDI/bmV3IHp0KHQpOm5ldyB6dCh0LGUpfX1nZXRDbGFzcygpe3JldHVybiBZdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRixhXX19ZnVuY3Rpb24gVXQoKXt0aGlzLm1hcF89bmV3IE1hcH1ZdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFl0LnNlcmlhbFZlcnNpb25VSUQ9LTB4MzhlNDlmYTZjZjZmMmUwMCxZdC5pbnN0YW5jZU9iamVjdD1uZXcgWXQsVXQucHJvdG90eXBlPW5ldyBqLFV0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubWFwXy5nZXQodCl8fG51bGx9LFV0LnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5tYXBfLnNldCh0LGUpLGV9LFV0LnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXtjb25zdCB0PW5ldyB4LGU9dGhpcy5tYXBfLnZhbHVlcygpO2xldCBuPWUubmV4dCgpO2Zvcig7IW4uZG9uZTspdC5hZGQobi52YWx1ZSksbj1lLm5leHQoKTtyZXR1cm4gdH0sVXQucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgSjtyZXR1cm4gdGhpcy5tYXBfLmVudHJpZXMoKS5mb3JFYWNoKGU9PnQuYWRkKGUpKSx0fSxVdC5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8uc2l6ZSgpfTtjbGFzcyBrdHtjb25zdHJ1Y3Rvcigpe2t0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1vc3RQcmVjaXNlKHQsZSl7cmV0dXJuIHQuY29tcGFyZVRvKGUpPj0wP3Q6ZX1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2Yga3QpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09ZS5fbW9kZWxUeXBlJiZ0aGlzLl9zY2FsZT09PWUuX3NjYWxlfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQsbj10aGlzLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpLHM9ZS5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKTtyZXR1cm4gbmV3IEwobikuY29tcGFyZVRvKG5ldyBMKHMpKX1nZXRTY2FsZSgpe3JldHVybiB0aGlzLl9zY2FsZX1pc0Zsb2F0aW5nKCl7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HfHx0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElOR19TSU5HTEV9Z2V0VHlwZSgpe3JldHVybiB0aGlzLl9tb2RlbFR5cGV9dG9TdHJpbmcoKXtsZXQgdD1cIlVOS05PV05cIjtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkc/dD1cIkZsb2F0aW5nXCI6dGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkdfU0lOR0xFP3Q9XCJGbG9hdGluZy1TaW5nbGVcIjp0aGlzLl9tb2RlbFR5cGU9PT1rdC5GSVhFRCYmKHQ9XCJGaXhlZCAoU2NhbGU9XCIrdGhpcy5nZXRTY2FsZSgpK1wiKVwiKSx0fW1ha2VQcmVjaXNlKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoaS5pc05hTih0KSlyZXR1cm4gdDtpZih0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElOR19TSU5HTEUpe3JldHVybiB0fXJldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1rdC5GSVhFRD9NYXRoLnJvdW5kKHQqdGhpcy5fc2NhbGUpL3RoaXMuX3NjYWxlOnR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElORylyZXR1cm4gbnVsbDt0Lng9dGhpcy5tYWtlUHJlY2lzZSh0LngpLHQueT10aGlzLm1ha2VQcmVjaXNlKHQueSl9fWdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpe2xldCB0PTE2O3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElORz90PTE2OnRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HX1NJTkdMRT90PTY6dGhpcy5fbW9kZWxUeXBlPT09a3QuRklYRUQmJih0PTErTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5sb2codGhpcy5nZXRTY2FsZSgpKS9NYXRoLmxvZygxMCkpKSksdH1zZXRTY2FsZSh0KXt0aGlzLl9zY2FsZT1NYXRoLmFicyh0KX1nZXRDbGFzcygpe3JldHVybiBrdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYSxyXX19Y2xhc3MgWHR7Y29uc3RydWN0b3IoKXtYdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJlYWRSZXNvbHZlKCl7cmV0dXJuIFh0Lm5hbWVUb1R5cGVNYXAuZ2V0KHRoaXMuX25hbWUpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuX25hbWV9Z2V0Q2xhc3MoKXtyZXR1cm4gWHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX1YdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9uYW1lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbmFtZT10LFh0Lm5hbWVUb1R5cGVNYXAucHV0KHQsdGhpcyl9LFh0LnNlcmlhbFZlcnNpb25VSUQ9LTU1Mjg2MDI2MzE3MzE1OWU0LFh0Lm5hbWVUb1R5cGVNYXA9bmV3IFV0LGt0LlR5cGU9WHQsa3QuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbW9kZWxUeXBlPW51bGwsdGhpcy5fc2NhbGU9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9tb2RlbFR5cGU9a3QuRkxPQVRJTkc7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFh0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tb2RlbFR5cGU9dCx0PT09a3QuRklYRUQmJnRoaXMuc2V0U2NhbGUoMSl9ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tb2RlbFR5cGU9a3QuRklYRUQsdGhpcy5zZXRTY2FsZSh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Yga3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21vZGVsVHlwZT10Ll9tb2RlbFR5cGUsdGhpcy5fc2NhbGU9dC5fc2NhbGV9fSxrdC5zZXJpYWxWZXJzaW9uVUlEPTB4NmJlZTY0MDRlOWEyNWMwMCxrdC5GSVhFRD1uZXcgWHQoXCJGSVhFRFwiKSxrdC5GTE9BVElORz1uZXcgWHQoXCJGTE9BVElOR1wiKSxrdC5GTE9BVElOR19TSU5HTEU9bmV3IFh0KFwiRkxPQVRJTkcgU0lOR0xFXCIpLGt0Lm1heGltdW1QcmVjaXNlVmFsdWU9OTAwNzE5OTI1NDc0MDk5MjtjbGFzcyBIdHtjb25zdHJ1Y3Rvcigpe0h0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvTXVsdGlQb2x5Z29uQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9HZW9tZXRyeUFycmF5KHQpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIGdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCl7cmV0dXJuIFl0Lmluc3RhbmNlKCl9c3RhdGljIHRvTXVsdGlMaW5lU3RyaW5nQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9MaW5lU3RyaW5nQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9NdWx0aVBvaW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9MaW5lYXJSaW5nQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9Qb2ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvUG9seWdvbkFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIGNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfXRvR2VvbWV0cnkodCl7cmV0dXJuIHQuaXNOdWxsKCk/dGhpcy5jcmVhdGVQb2ludCgpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCkmJnQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVQb2ludChuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSkpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCl8fHQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVMaW5lU3RyaW5nKFtuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpXSk6dGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhbbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSxuZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKV0pLG51bGwpfWNyZWF0ZUxpbmVTdHJpbmcoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBUdCh0LHRoaXMpfX19Y3JlYXRlTXVsdGlMaW5lU3RyaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBmdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IGZ0KHQsdGhpcyl9fWJ1aWxkR2VvbWV0cnkodCl7bGV0IGU9bnVsbCxuPSExLHM9ITE7Zm9yKGxldCBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IHQ9aS5uZXh0KCkscj10LmdldENsYXNzKCk7bnVsbD09PWUmJihlPXIpLHIhPT1lJiYobj0hMCksdCBpbnN0YW5jZW9mIF90JiYocz0hMCl9aWYobnVsbD09PWUpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7aWYobnx8cylyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oSHQudG9HZW9tZXRyeUFycmF5KHQpKTtjb25zdCBpPXQuaXRlcmF0b3IoKS5uZXh0KCk7aWYodC5zaXplKCk+MSl7aWYoaSBpbnN0YW5jZW9mIGJ0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9seWdvbihIdC50b1BvbHlnb25BcnJheSh0KSk7aWYoaSBpbnN0YW5jZW9mIFR0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpTGluZVN0cmluZyhIdC50b0xpbmVTdHJpbmdBcnJheSh0KSk7aWYoaSBpbnN0YW5jZW9mIFB0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoSHQudG9Qb2ludEFycmF5KHQpKTt1LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5oYW5kbGVkIGNsYXNzOiBcIitpLmdldENsYXNzKCkuZ2V0TmFtZSgpKX1yZXR1cm4gaX1jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3Jkcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1jcmVhdGVQb2ludCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZVBvaW50KHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbdF0pOm51bGwpfWlmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IFB0KHQsdGhpcyl9fX1nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnl9Y3JlYXRlUG9seWdvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24obnVsbCxudWxsKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyh0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0LG51bGwpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IGJ0KHQsZSx0aGlzKX19Z2V0U1JJRCgpe3JldHVybiB0aGlzLl9TUklEfWNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgX3QobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBfdCh0LHRoaXMpfX1jcmVhdGVHZW9tZXRyeSh0KXtyZXR1cm4gbmV3IEZ0KHRoaXMpLmVkaXQodCxuZXcgV3QodGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSkpfWdldFByZWNpc2lvbk1vZGVsKCl7cmV0dXJuIHRoaXMuX3ByZWNpc2lvbk1vZGVsfWNyZWF0ZUxpbmVhclJpbmcoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBEdCh0LHRoaXMpfX19Y3JlYXRlTXVsdGlQb2x5Z29uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBBdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IEF0KHQsdGhpcyl9fWNyZWF0ZU11bHRpUG9pbnQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IE10KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgTXQodCx0aGlzKX1pZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKyspe2NvbnN0IHM9dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKDEsdC5nZXREaW1lbnNpb24oKSk7THQuY29weSh0LG4scywwLDEpLGVbbl09dGhpcy5jcmVhdGVQb2ludChzKX1yZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KGUpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gSHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX1jbGFzcyBXdCBleHRlbmRzIEZ0LkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksV3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lZGl0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgcSYmXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkuY3JlYXRlKHQpfXJldHVybiBzdXBlci5lZGl0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBXdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19V3QuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PXR9LEh0LkNsb25lT3A9V3QsSHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW51bGwsdGhpcy5fU1JJRD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKUh0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IGt0LDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLEYpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtIdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBrdCwwLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBrdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07SHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDAsSHQuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0h0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLEh0LmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1uLHRoaXMuX1NSSUQ9ZX19LEh0LnNlcmlhbFZlcnNpb25VSUQ9LTB4NWVhNzVmMjA1MWVlYjQwMDtjb25zdCBqdD17dHlwZVN0cjovXlxccyooXFx3KylcXHMqXFwoXFxzKiguKilcXHMqXFwpXFxzKiQvLGVtcHR5VHlwZVN0cjovXlxccyooXFx3KylcXHMqRU1QVFlcXHMqJC8sc3BhY2VzOi9cXHMrLyxwYXJlbkNvbW1hOi9cXClcXHMqLFxccypcXCgvLGRvdWJsZVBhcmVuQ29tbWE6L1xcKVxccypcXClcXHMqLFxccypcXChcXHMqXFwoLyx0cmltUGFyZW5zOi9eXFxzKlxcKD8oLio/KVxcKT9cXHMqJC99O2NsYXNzIEt0e2NvbnN0cnVjdG9yKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBIdCx0aGlzLnByZWNpc2lvbk1vZGVsPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCl9cmVhZCh0KXt2YXIgZSxuLHM7dD10LnJlcGxhY2UoL1tcXG5cXHJdL2csXCIgXCIpO3ZhciBpPWp0LnR5cGVTdHIuZXhlYyh0KTtpZigtMSE9PXQuc2VhcmNoKFwiRU1QVFlcIikmJigoaT1qdC5lbXB0eVR5cGVTdHIuZXhlYyh0KSlbMl09dm9pZCAwKSxpJiYobj1pWzFdLnRvTG93ZXJDYXNlKCkscz1pWzJdLFF0W25dJiYoZT1RdFtuXS5jYWxsKHRoaXMscykpKSx2b2lkIDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBXS1QgXCIrdCk7cmV0dXJuIGV9d3JpdGUodCl7cmV0dXJuIHRoaXMuZXh0cmFjdEdlb21ldHJ5KHQpfWV4dHJhY3RHZW9tZXRyeSh0KXt2YXIgZT10LmdldEdlb21ldHJ5VHlwZSgpLnRvTG93ZXJDYXNlKCk7aWYoIVp0W2VdKXJldHVybiBudWxsO3ZhciBuPWUudG9VcHBlckNhc2UoKTtyZXR1cm4gdC5pc0VtcHR5KCk/bitcIiBFTVBUWVwiOm4rXCIoXCIrWnRbZV0uY2FsbCh0aGlzLHQpK1wiKVwifX1jb25zdCBadD17Y29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZSh0KSx0LngrXCIgXCIrdC55fSxwb2ludCh0KXtyZXR1cm4gWnQuY29vcmRpbmF0ZS5jYWxsKHRoaXMsdC5fY29vcmRpbmF0ZXMuX2Nvb3JkaW5hdGVzWzBdKX0sbXVsdGlwb2ludCh0KXt2YXIgZT1bXTtmb3IobGV0IG49MCxzPXQuX2dlb21ldHJpZXMubGVuZ3RoO248czsrK24pZS5wdXNoKFwiKFwiK1p0LnBvaW50LmNhbGwodGhpcyx0Ll9nZW9tZXRyaWVzW25dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LGxpbmVzdHJpbmcodCl7dmFyIGU9W107Zm9yKGxldCBuPTAscz10Ll9wb2ludHMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtuPHM7KytuKWUucHVzaChadC5jb29yZGluYXRlLmNhbGwodGhpcyx0Ll9wb2ludHMuX2Nvb3JkaW5hdGVzW25dKSk7cmV0dXJuIGUuam9pbihcIixcIil9LGxpbmVhcnJpbmcodCl7dmFyIGU9W107Zm9yKGxldCBuPTAscz10Ll9wb2ludHMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtuPHM7KytuKWUucHVzaChadC5jb29yZGluYXRlLmNhbGwodGhpcyx0Ll9wb2ludHMuX2Nvb3JkaW5hdGVzW25dKSk7cmV0dXJuIGUuam9pbihcIixcIil9LG11bHRpbGluZXN0cmluZyh0KXt2YXIgZT1bXTtmb3IobGV0IG49MCxzPXQuX2dlb21ldHJpZXMubGVuZ3RoO248czsrK24pZS5wdXNoKFwiKFwiK1p0LmxpbmVzdHJpbmcuY2FsbCh0aGlzLHQuX2dlb21ldHJpZXNbbl0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0scG9seWdvbih0KXt2YXIgZT1bXTtlLnB1c2goXCIoXCIrWnQubGluZXN0cmluZy5jYWxsKHRoaXMsdC5fc2hlbGwpK1wiKVwiKTtmb3IobGV0IG49MCxzPXQuX2hvbGVzLmxlbmd0aDtuPHM7KytuKWUucHVzaChcIihcIitadC5saW5lc3RyaW5nLmNhbGwodGhpcyx0Ll9ob2xlc1tuXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxtdWx0aXBvbHlnb24odCl7dmFyIGU9W107Zm9yKGxldCBuPTAscz10Ll9nZW9tZXRyaWVzLmxlbmd0aDtuPHM7KytuKWUucHVzaChcIihcIitadC5wb2x5Z29uLmNhbGwodGhpcyx0Ll9nZW9tZXRyaWVzW25dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LGdlb21ldHJ5Y29sbGVjdGlvbih0KXt2YXIgZT1bXTtmb3IobGV0IG49MCxzPXQuX2dlb21ldHJpZXMubGVuZ3RoO248czsrK24pZS5wdXNoKHRoaXMuZXh0cmFjdEdlb21ldHJ5KHQuX2dlb21ldHJpZXNbbl0pKTtyZXR1cm4gZS5qb2luKFwiLFwiKX19LFF0PXtjb29yZCh0KXt2YXIgZT10LnRyaW0oKS5zcGxpdChqdC5zcGFjZXMpLG49bmV3IGcoTnVtYmVyLnBhcnNlRmxvYXQoZVswXSksTnVtYmVyLnBhcnNlRmxvYXQoZVsxXSkpO3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKG4pLG59LHBvaW50KHQpe3JldHVybiB2b2lkIDA9PT10P3RoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KCk6dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoUXQuY29vcmQuY2FsbCh0aGlzLHQpKX0sbXVsdGlwb2ludCh0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KCk7dmFyIGUsbj10LnRyaW0oKS5zcGxpdChcIixcIikscz1bXTtmb3IobGV0IHQ9MCxpPW4ubGVuZ3RoO3Q8aTsrK3QpZT1uW3RdLnJlcGxhY2UoanQudHJpbVBhcmVucyxcIiQxXCIpLHMucHVzaChRdC5wb2ludC5jYWxsKHRoaXMsZSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KHMpfSxsaW5lc3RyaW5nKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoKTt2YXIgZT10LnRyaW0oKS5zcGxpdChcIixcIiksbj1bXTtmb3IobGV0IHQ9MCxzPWUubGVuZ3RoO3Q8czsrK3Qpbi5wdXNoKFF0LmNvb3JkLmNhbGwodGhpcyxlW3RdKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobil9LGxpbmVhcnJpbmcodCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZygpO3ZhciBlPXQudHJpbSgpLnNwbGl0KFwiLFwiKSxuPVtdO2ZvcihsZXQgdD0wLHM9ZS5sZW5ndGg7dDxzOysrdCluLnB1c2goUXQuY29vcmQuY2FsbCh0aGlzLGVbdF0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhuKX0sbXVsdGlsaW5lc3RyaW5nKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZygpO3ZhciBlLG49dC50cmltKCkuc3BsaXQoanQucGFyZW5Db21tYSkscz1bXTtmb3IobGV0IHQ9MCxpPW4ubGVuZ3RoO3Q8aTsrK3QpZT1uW3RdLnJlcGxhY2UoanQudHJpbVBhcmVucyxcIiQxXCIpLHMucHVzaChRdC5saW5lc3RyaW5nLmNhbGwodGhpcyxlKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhzKX0scG9seWdvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKCk7dmFyIGUsbixzLGkscj10LnRyaW0oKS5zcGxpdChqdC5wYXJlbkNvbW1hKSxvPVtdO2ZvcihsZXQgdD0wLGw9ci5sZW5ndGg7dDxsOysrdCllPXJbdF0ucmVwbGFjZShqdC50cmltUGFyZW5zLFwiJDFcIiksbj1RdC5saW5lc3RyaW5nLmNhbGwodGhpcyxlKSxzPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobi5fcG9pbnRzKSwwPT09dD9pPXM6by5wdXNoKHMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKGksbyl9LG11bHRpcG9seWdvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oKTt2YXIgZSxuPXQudHJpbSgpLnNwbGl0KGp0LmRvdWJsZVBhcmVuQ29tbWEpLHM9W107Zm9yKGxldCB0PTAsaT1uLmxlbmd0aDt0PGk7Kyt0KWU9blt0XS5yZXBsYWNlKGp0LnRyaW1QYXJlbnMsXCIkMVwiKSxzLnB1c2goUXQucG9seWdvbi5jYWxsKHRoaXMsZSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24ocyl9LGdlb21ldHJ5Y29sbGVjdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTt2YXIgZT0odD10LnJlcGxhY2UoLyxcXHMqKFtBLVphLXpdKS9nLFwifCQxXCIpKS50cmltKCkuc3BsaXQoXCJ8XCIpLG49W107Zm9yKGxldCB0PTAscz1lLmxlbmd0aDt0PHM7Kyt0KW4ucHVzaCh0aGlzLnJlYWQoZVt0XSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obil9fTtjbGFzcyBKdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj1uZXcgS3QodCl9d3JpdGUodCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfXN0YXRpYyB0b0xpbmVTdHJpbmcodCxlKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7cmV0dXJuXCJMSU5FU1RSSU5HICggXCIrdC54K1wiIFwiK3QueStcIiwgXCIrZS54K1wiIFwiK2UueStcIiApXCJ9fWNsYXNzICR0e2NvbnN0cnVjdG9yKCl7JHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tcHV0ZUVkZ2VEaXN0YW5jZSh0LGUsbil7Y29uc3Qgcz1NYXRoLmFicyhuLngtZS54KSxpPU1hdGguYWJzKG4ueS1lLnkpO2xldCByPS0xO2lmKHQuZXF1YWxzKGUpKXI9MDtlbHNlIGlmKHQuZXF1YWxzKG4pKXI9cz5pP3M6aTtlbHNle2NvbnN0IG49TWF0aC5hYnModC54LWUueCksbz1NYXRoLmFicyh0LnktZS55KTtyPXM+aT9uOm8sMCE9PXJ8fHQuZXF1YWxzKGUpfHwocj1NYXRoLm1heChuLG8pKX1yZXR1cm4gdS5pc1RydWUoISgwPT09ciYmIXQuZXF1YWxzKGUpKSxcIkJhZCBkaXN0YW5jZSBjYWxjdWxhdGlvblwiKSxyfXN0YXRpYyBub25Sb2J1c3RDb21wdXRlRWRnZURpc3RhbmNlKHQsZSxuKXtjb25zdCBzPXQueC1lLngsaT10LnktZS55LHI9TWF0aC5zcXJ0KHMqcytpKmkpO3JldHVybiB1LmlzVHJ1ZSghKDA9PT1yJiYhdC5lcXVhbHMoZSkpLFwiSW52YWxpZCBkaXN0YW5jZSBjYWxjdWxhdGlvblwiKSxyfWdldEluZGV4QWxvbmdTZWdtZW50KHQsZSl7cmV0dXJuIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpLHRoaXMuX2ludExpbmVJbmRleFt0XVtlXX1nZXRUb3BvbG9neVN1bW1hcnkoKXtjb25zdCB0PW5ldyB3dDtyZXR1cm4gdGhpcy5pc0VuZFBvaW50KCkmJnQuYXBwZW5kKFwiIGVuZHBvaW50XCIpLHRoaXMuX2lzUHJvcGVyJiZ0LmFwcGVuZChcIiBwcm9wZXJcIiksdGhpcy5pc0NvbGxpbmVhcigpJiZ0LmFwcGVuZChcIiBjb2xsaW5lYXJcIiksdC50b1N0cmluZygpfWNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLG4scyl7dGhpcy5faW5wdXRMaW5lc1swXVswXT10LHRoaXMuX2lucHV0TGluZXNbMF1bMV09ZSx0aGlzLl9pbnB1dExpbmVzWzFdWzBdPW4sdGhpcy5faW5wdXRMaW5lc1sxXVsxXT1zLHRoaXMuX3Jlc3VsdD10aGlzLmNvbXB1dGVJbnRlcnNlY3QodCxlLG4scyl9Z2V0SW50ZXJzZWN0aW9uTnVtKCl7cmV0dXJuIHRoaXMuX3Jlc3VsdH1jb21wdXRlSW50TGluZUluZGV4KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpbnVsbD09PXRoaXMuX2ludExpbmVJbmRleCYmKHRoaXMuX2ludExpbmVJbmRleD1BcnJheSgyKS5maWxsKCkubWFwKCgpPT5BcnJheSgyKSksdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDApLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgxKSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwwKT50aGlzLmdldEVkZ2VEaXN0YW5jZSh0LDEpPyh0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMF09MCx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMV09MSk6KHRoaXMuX2ludExpbmVJbmRleFt0XVswXT0xLHRoaXMuX2ludExpbmVJbmRleFt0XVsxXT0wKX19aXNQcm9wZXIoKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5faXNQcm9wZXJ9c2V0UHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fcHJlY2lzaW9uTW9kZWw9dH1pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuISF0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMCl8fCEhdGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDEpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX3Jlc3VsdDtlKyspaWYoIXRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHRoaXMuX2lucHV0TGluZXNbdF1bMF0pJiYhdGhpcy5faW50UHRbZV0uZXF1YWxzMkQodGhpcy5faW5wdXRMaW5lc1t0XVsxXSkpcmV0dXJuITA7cmV0dXJuITF9fWdldEludGVyc2VjdGlvbih0KXtyZXR1cm4gdGhpcy5faW50UHRbdF19aXNFbmRQb2ludCgpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpJiYhdGhpcy5faXNQcm9wZXJ9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX3Jlc3VsdCE9PSR0Lk5PX0lOVEVSU0VDVElPTn1nZXRFZGdlRGlzdGFuY2UodCxlKXtyZXR1cm4gJHQuY29tcHV0ZUVkZ2VEaXN0YW5jZSh0aGlzLl9pbnRQdFtlXSx0aGlzLl9pbnB1dExpbmVzW3RdWzBdLHRoaXMuX2lucHV0TGluZXNbdF1bMV0pfWlzQ29sbGluZWFyKCl7cmV0dXJuIHRoaXMuX3Jlc3VsdD09PSR0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT059dG9TdHJpbmcoKXtyZXR1cm4gSnQudG9MaW5lU3RyaW5nKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sdGhpcy5faW5wdXRMaW5lc1swXVsxXSkrXCIgLSBcIitKdC50b0xpbmVTdHJpbmcodGhpcy5faW5wdXRMaW5lc1sxXVswXSx0aGlzLl9pbnB1dExpbmVzWzFdWzFdKSt0aGlzLmdldFRvcG9sb2d5U3VtbWFyeSgpfWdldEVuZHBvaW50KHQsZSl7cmV0dXJuIHRoaXMuX2lucHV0TGluZXNbdF1bZV19aXNJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9yZXN1bHQ7ZSsrKWlmKHRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHQpKXJldHVybiEwO3JldHVybiExfWdldEludGVyc2VjdGlvbkFsb25nU2VnbWVudCh0LGUpe3JldHVybiB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKSx0aGlzLl9pbnRQdFt0aGlzLl9pbnRMaW5lSW5kZXhbdF1bZV1dfWdldENsYXNzKCl7cmV0dXJuICR0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX0kdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yZXN1bHQ9bnVsbCx0aGlzLl9pbnB1dExpbmVzPUFycmF5KDIpLmZpbGwoKS5tYXAoKCk9PkFycmF5KDIpKSx0aGlzLl9pbnRQdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9pbnRMaW5lSW5kZXg9bnVsbCx0aGlzLl9pc1Byb3Blcj1udWxsLHRoaXMuX3BhPW51bGwsdGhpcy5fcGI9bnVsbCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2ludFB0WzBdPW5ldyBnLHRoaXMuX2ludFB0WzFdPW5ldyBnLHRoaXMuX3BhPXRoaXMuX2ludFB0WzBdLHRoaXMuX3BiPXRoaXMuX2ludFB0WzFdLHRoaXMuX3Jlc3VsdD0wfSwkdC5ET05UX0lOVEVSU0VDVD0wLCR0LkRPX0lOVEVSU0VDVD0xLCR0LkNPTExJTkVBUj0yLCR0Lk5PX0lOVEVSU0VDVElPTj0wLCR0LlBPSU5UX0lOVEVSU0VDVElPTj0xLCR0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT049MjtjbGFzcyB0ZSBleHRlbmRzICR0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBuZWFyZXN0RW5kcG9pbnQodCxlLG4scyl7bGV0IGk9dCxyPUQucG9pbnRUb1NlZ21lbnQodCxuLHMpLG89RC5wb2ludFRvU2VnbWVudChlLG4scyk7cmV0dXJuIG88ciYmKHI9byxpPWUpLG89RC5wb2ludFRvU2VnbWVudChuLHQsZSksbzxyJiYocj1vLGk9biksbz1ELnBvaW50VG9TZWdtZW50KHMsdCxlKSxvPHImJihyPW8saT1zKSxpfWlzSW5TZWdtZW50RW52ZWxvcGVzKHQpe2NvbnN0IGU9bmV3IE4odGhpcy5faW5wdXRMaW5lc1swXVswXSx0aGlzLl9pbnB1dExpbmVzWzBdWzFdKSxuPW5ldyBOKHRoaXMuX2lucHV0TGluZXNbMV1bMF0sdGhpcy5faW5wdXRMaW5lc1sxXVsxXSk7cmV0dXJuIGUuY29udGFpbnModCkmJm4uY29udGFpbnModCl9Y29tcHV0ZUludGVyc2VjdGlvbigpe2lmKDMhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBzdXBlci5jb21wdXRlSW50ZXJzZWN0aW9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodGhpcy5faXNQcm9wZXI9ITEsTi5pbnRlcnNlY3RzKGUsbix0KSYmMD09PXYuaW5kZXgoZSxuLHQpJiYwPT09di5pbmRleChuLGUsdCkpcmV0dXJuIHRoaXMuX2lzUHJvcGVyPSEwLCh0LmVxdWFscyhlKXx8dC5lcXVhbHMobikpJiYodGhpcy5faXNQcm9wZXI9ITEpLHRoaXMuX3Jlc3VsdD0kdC5QT0lOVF9JTlRFUlNFQ1RJT04sbnVsbDt0aGlzLl9yZXN1bHQ9JHQuTk9fSU5URVJTRUNUSU9OfX1ub3JtYWxpemVUb01pbmltdW0odCxlLG4scyxpKXtpLng9dGhpcy5zbWFsbGVzdEluQWJzVmFsdWUodC54LGUueCxuLngscy54KSxpLnk9dGhpcy5zbWFsbGVzdEluQWJzVmFsdWUodC55LGUueSxuLnkscy55KSx0LngtPWkueCx0LnktPWkueSxlLngtPWkueCxlLnktPWkueSxuLngtPWkueCxuLnktPWkueSxzLngtPWkueCxzLnktPWkueX1zYWZlSENvb3JkaW5hdGVJbnRlcnNlY3Rpb24odCxlLG4scyl7bGV0IGk9bnVsbDt0cnl7aT1iLmludGVyc2VjdGlvbih0LGUsbixzKX1jYXRjaChyKXtpZighKHIgaW5zdGFuY2VvZiBTKSl0aHJvdyByO2k9dGUubmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpfXJldHVybiBpfWludGVyc2VjdGlvbih0LGUsbixzKXtsZXQgaT10aGlzLmludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uKHQsZSxuLHMpO3JldHVybiB0aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKGkpfHwoaT1uZXcgZyh0ZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4scykpKSxudWxsIT09dGhpcy5fcHJlY2lzaW9uTW9kZWwmJnRoaXMuX3ByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGkpLGl9c21hbGxlc3RJbkFic1ZhbHVlKHQsZSxuLHMpe2xldCBpPXQscj1NYXRoLmFicyhpKTtyZXR1cm4gTWF0aC5hYnMoZSk8ciYmKGk9ZSxyPU1hdGguYWJzKGUpKSxNYXRoLmFicyhuKTxyJiYoaT1uLHI9TWF0aC5hYnMobikpLE1hdGguYWJzKHMpPHImJihpPXMpLGl9Y2hlY2tERCh0LGUsbixzLGkpe2NvbnN0IHI9UC5pbnRlcnNlY3Rpb24odCxlLG4scyksbz10aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKHIpO08ub3V0LnByaW50bG4oXCJERCBpbiBlbnYgPSBcIitvK1wiICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gXCIrciksaS5kaXN0YW5jZShyKT4xZS00JiZPLm91dC5wcmludGxuKFwiRGlzdGFuY2UgPSBcIitpLmRpc3RhbmNlKHIpKX1pbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbih0LGUsbixzKXtjb25zdCBpPW5ldyBnKHQpLHI9bmV3IGcoZSksbz1uZXcgZyhuKSxsPW5ldyBnKHMpLGE9bmV3IGc7dGhpcy5ub3JtYWxpemVUb0VudkNlbnRyZShpLHIsbyxsLGEpO2NvbnN0IGM9dGhpcy5zYWZlSENvb3JkaW5hdGVJbnRlcnNlY3Rpb24oaSxyLG8sbCk7cmV0dXJuIGMueCs9YS54LGMueSs9YS55LGN9Y29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCBpPU4uaW50ZXJzZWN0cyh0LGUsbikscj1OLmludGVyc2VjdHModCxlLHMpLG89Ti5pbnRlcnNlY3RzKG4scyx0KSxsPU4uaW50ZXJzZWN0cyhuLHMsZSk7cmV0dXJuIGkmJnI/KHRoaXMuX2ludFB0WzBdPW4sdGhpcy5faW50UHRbMV09cywkdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTpvJiZsPyh0aGlzLl9pbnRQdFswXT10LHRoaXMuX2ludFB0WzFdPWUsJHQuQ09MTElORUFSX0lOVEVSU0VDVElPTik6aSYmbz8odGhpcy5faW50UHRbMF09bix0aGlzLl9pbnRQdFsxXT10LCFuLmVxdWFscyh0KXx8cnx8bD8kdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOiR0LlBPSU5UX0lOVEVSU0VDVElPTik6aSYmbD8odGhpcy5faW50UHRbMF09bix0aGlzLl9pbnRQdFsxXT1lLCFuLmVxdWFscyhlKXx8cnx8bz8kdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOiR0LlBPSU5UX0lOVEVSU0VDVElPTik6ciYmbz8odGhpcy5faW50UHRbMF09cyx0aGlzLl9pbnRQdFsxXT10LCFzLmVxdWFscyh0KXx8aXx8bD8kdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOiR0LlBPSU5UX0lOVEVSU0VDVElPTik6ciYmbD8odGhpcy5faW50UHRbMF09cyx0aGlzLl9pbnRQdFsxXT1lLCFzLmVxdWFscyhlKXx8aXx8bz8kdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOiR0LlBPSU5UX0lOVEVSU0VDVElPTik6JHQuTk9fSU5URVJTRUNUSU9OfW5vcm1hbGl6ZVRvRW52Q2VudHJlKHQsZSxuLHMsaSl7Y29uc3Qgcj10Lng8ZS54P3QueDplLngsbz10Lnk8ZS55P3QueTplLnksbD10Lng+ZS54P3QueDplLngsYT10Lnk+ZS55P3QueTplLnksYz1uLng8cy54P24ueDpzLngsaD1uLnk8cy55P24ueTpzLnksdT1uLng+cy54P24ueDpzLngsZz1uLnk+cy55P24ueTpzLnksZD0oKHI+Yz9yOmMpKyhsPHU/bDp1KSkvMixfPSgobz5oP286aCkrKGE8Zz9hOmcpKS8yO2kueD1kLGkueT1fLHQueC09aS54LHQueS09aS55LGUueC09aS54LGUueS09aS55LG4ueC09aS54LG4ueS09aS55LHMueC09aS54LHMueS09aS55fWNvbXB1dGVJbnRlcnNlY3QodCxlLG4scyl7aWYodGhpcy5faXNQcm9wZXI9ITEsIU4uaW50ZXJzZWN0cyh0LGUsbixzKSlyZXR1cm4gJHQuTk9fSU5URVJTRUNUSU9OO2NvbnN0IGk9di5pbmRleCh0LGUsbikscj12LmluZGV4KHQsZSxzKTtpZihpPjAmJnI+MHx8aTwwJiZyPDApcmV0dXJuICR0Lk5PX0lOVEVSU0VDVElPTjtjb25zdCBvPXYuaW5kZXgobixzLHQpLGw9di5pbmRleChuLHMsZSk7cmV0dXJuIG8+MCYmbD4wfHxvPDAmJmw8MD8kdC5OT19JTlRFUlNFQ1RJT046MD09PWkmJjA9PT1yJiYwPT09byYmMD09PWw/dGhpcy5jb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uKHQsZSxuLHMpOigwPT09aXx8MD09PXJ8fDA9PT1vfHwwPT09bD8odGhpcy5faXNQcm9wZXI9ITEsdC5lcXVhbHMyRChuKXx8dC5lcXVhbHMyRChzKT90aGlzLl9pbnRQdFswXT10OmUuZXF1YWxzMkQobil8fGUuZXF1YWxzMkQocyk/dGhpcy5faW50UHRbMF09ZTowPT09aT90aGlzLl9pbnRQdFswXT1uZXcgZyhuKTowPT09cj90aGlzLl9pbnRQdFswXT1uZXcgZyhzKTowPT09bz90aGlzLl9pbnRQdFswXT1uZXcgZyh0KTowPT09bCYmKHRoaXMuX2ludFB0WzBdPW5ldyBnKGUpKSk6KHRoaXMuX2lzUHJvcGVyPSEwLHRoaXMuX2ludFB0WzBdPXRoaXMuaW50ZXJzZWN0aW9uKHQsZSxuLHMpKSwkdC5QT0lOVF9JTlRFUlNFQ1RJT04pfWdldENsYXNzKCl7cmV0dXJuIHRlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX10ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGVle2NvbnN0cnVjdG9yKCl7ZWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbWlkUG9pbnQodCxlKXtyZXR1cm4gbmV3IGcoKHQueCtlLngpLzIsKHQueStlLnkpLzIpfW1pblgoKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC54LHRoaXMucDEueCl9b3JpZW50YXRpb25JbmRleCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9di5pbmRleCh0aGlzLnAwLHRoaXMucDEsdC5wMCksbj12LmluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAxKTtyZXR1cm4gZT49MCYmbj49MHx8ZTw9MCYmbjw9MD9NYXRoLm1heChlLG4pOjB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdi5pbmRleCh0aGlzLnAwLHRoaXMucDEsdCl9fXRvR2VvbWV0cnkodCl7cmV0dXJuIHQuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5wMCx0aGlzLnAxXSl9aXNWZXJ0aWNhbCgpe3JldHVybiB0aGlzLnAwLng9PT10aGlzLnAxLnh9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIGVlKSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMucDAuZXF1YWxzKGUucDApJiZ0aGlzLnAxLmVxdWFscyhlLnAxKX1pbnRlcnNlY3Rpb24odCl7Y29uc3QgZT1uZXcgdGU7cmV0dXJuIGUuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKSxlLmhhc0ludGVyc2VjdGlvbigpP2UuZ2V0SW50ZXJzZWN0aW9uKDApOm51bGx9cHJvamVjdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5lcXVhbHModGhpcy5wMCl8fHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiBuZXcgZyh0KTtjb25zdCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KSxuPW5ldyBnO3JldHVybiBuLng9dGhpcy5wMC54K2UqKHRoaXMucDEueC10aGlzLnAwLngpLG4ueT10aGlzLnAwLnkrZSoodGhpcy5wMS55LXRoaXMucDAueSksbn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0LnAwKSxuPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0LnAxKTtpZihlPj0xJiZuPj0xKXJldHVybiBudWxsO2lmKGU8PTAmJm48PTApcmV0dXJuIG51bGw7bGV0IHM9dGhpcy5wcm9qZWN0KHQucDApO2U8MCYmKHM9dGhpcy5wMCksZT4xJiYocz10aGlzLnAxKTtsZXQgaT10aGlzLnByb2plY3QodC5wMSk7cmV0dXJuIG48MCYmKGk9dGhpcy5wMCksbj4xJiYoaT10aGlzLnAxKSxuZXcgZWUocyxpKX19bm9ybWFsaXplKCl7dGhpcy5wMS5jb21wYXJlVG8odGhpcy5wMCk8MCYmdGhpcy5yZXZlcnNlKCl9YW5nbGUoKXtyZXR1cm4gTWF0aC5hdGFuMih0aGlzLnAxLnktdGhpcy5wMC55LHRoaXMucDEueC10aGlzLnAwLngpfWdldENvb3JkaW5hdGUodCl7cmV0dXJuIDA9PT10P3RoaXMucDA6dGhpcy5wMX1kaXN0YW5jZVBlcnBlbmRpY3VsYXIodCl7cmV0dXJuIEQucG9pbnRUb0xpbmVQZXJwZW5kaWN1bGFyKHQsdGhpcy5wMCx0aGlzLnAxKX1taW5ZKCl7cmV0dXJuIE1hdGgubWluKHRoaXMucDAueSx0aGlzLnAxLnkpfW1pZFBvaW50KCl7cmV0dXJuIGVlLm1pZFBvaW50KHRoaXMucDAsdGhpcy5wMSl9cHJvamVjdGlvbkZhY3Rvcih0KXtpZih0LmVxdWFscyh0aGlzLnAwKSlyZXR1cm4gMDtpZih0LmVxdWFscyh0aGlzLnAxKSlyZXR1cm4gMTtjb25zdCBlPXRoaXMucDEueC10aGlzLnAwLngsbj10aGlzLnAxLnktdGhpcy5wMC55LHM9ZSplK24qbjtyZXR1cm4gczw9MD9pLk5hTjooKHQueC10aGlzLnAwLngpKmUrKHQueS10aGlzLnAwLnkpKm4pL3N9Y2xvc2VzdFBvaW50cyh0KXtjb25zdCBlPXRoaXMuaW50ZXJzZWN0aW9uKHQpO2lmKG51bGwhPT1lKXJldHVybltlLGVdO2NvbnN0IG49bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7bGV0IHM9aS5NQVhfVkFMVUUscj1udWxsO2NvbnN0IG89dGhpcy5jbG9zZXN0UG9pbnQodC5wMCk7cz1vLmRpc3RhbmNlKHQucDApLG5bMF09byxuWzFdPXQucDA7Y29uc3QgbD10aGlzLmNsb3Nlc3RQb2ludCh0LnAxKTtyPWwuZGlzdGFuY2UodC5wMSkscjxzJiYocz1yLG5bMF09bCxuWzFdPXQucDEpO2NvbnN0IGE9dC5jbG9zZXN0UG9pbnQodGhpcy5wMCk7cj1hLmRpc3RhbmNlKHRoaXMucDApLHI8cyYmKHM9cixuWzBdPXRoaXMucDAsblsxXT1hKTtjb25zdCBjPXQuY2xvc2VzdFBvaW50KHRoaXMucDEpO3JldHVybiByPWMuZGlzdGFuY2UodGhpcy5wMSkscjxzJiYocz1yLG5bMF09dGhpcy5wMSxuWzFdPWMpLG59Y2xvc2VzdFBvaW50KHQpe2NvbnN0IGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO3JldHVybiBlPjAmJmU8MT90aGlzLnByb2plY3QodCk6dGhpcy5wMC5kaXN0YW5jZSh0KTx0aGlzLnAxLmRpc3RhbmNlKHQpP3RoaXMucDA6dGhpcy5wMX1tYXhYKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMucDAueCx0aGlzLnAxLngpfWdldExlbmd0aCgpe3JldHVybiB0aGlzLnAwLmRpc3RhbmNlKHRoaXMucDEpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQsbj10aGlzLnAwLmNvbXBhcmVUbyhlLnAwKTtyZXR1cm4gMCE9PW4/bjp0aGlzLnAxLmNvbXBhcmVUbyhlLnAxKX1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLnAwO3RoaXMucDA9dGhpcy5wMSx0aGlzLnAxPXR9ZXF1YWxzVG9wbyh0KXtyZXR1cm4gdGhpcy5wMC5lcXVhbHModC5wMCkmJnRoaXMucDEuZXF1YWxzKHQucDEpfHx0aGlzLnAwLmVxdWFscyh0LnAxKSYmdGhpcy5wMS5lcXVhbHModC5wMCl9bGluZUludGVyc2VjdGlvbih0KXt0cnl7cmV0dXJuIGIuaW50ZXJzZWN0aW9uKHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFMpKXRocm93IHR9cmV0dXJuIG51bGx9bWF4WSgpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLnksdGhpcy5wMS55KX1wb2ludEFsb25nT2Zmc2V0KHQsZSl7Y29uc3Qgbj10aGlzLnAwLngrdCoodGhpcy5wMS54LXRoaXMucDAueCkscz10aGlzLnAwLnkrdCoodGhpcy5wMS55LXRoaXMucDAueSksaT10aGlzLnAxLngtdGhpcy5wMC54LHI9dGhpcy5wMS55LXRoaXMucDAueSxvPU1hdGguc3FydChpKmkrcipyKTtsZXQgbD0wLGE9MDtpZigwIT09ZSl7aWYobzw9MCl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiQ2Fubm90IGNvbXB1dGUgb2Zmc2V0IGZyb20gemVyby1sZW5ndGggbGluZSBzZWdtZW50XCIpO2w9ZSppL28sYT1lKnIvb31yZXR1cm4gbmV3IGcobi1hLHMrbCl9c2V0Q29vcmRpbmF0ZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRDb29yZGluYXRlcyh0LnAwLHQucDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucDAueD10LngsdGhpcy5wMC55PXQueSx0aGlzLnAxLng9ZS54LHRoaXMucDEueT1lLnl9fXNlZ21lbnRGcmFjdGlvbih0KXtsZXQgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCk7cmV0dXJuIGU8MD9lPTA6KGU+MXx8aS5pc05hTihlKSkmJihlPTEpLGV9dG9TdHJpbmcoKXtyZXR1cm5cIkxJTkVTVFJJTkcoIFwiK3RoaXMucDAueCtcIiBcIit0aGlzLnAwLnkrXCIsIFwiK3RoaXMucDEueCtcIiBcIit0aGlzLnAxLnkrXCIpXCJ9aXNIb3Jpem9udGFsKCl7cmV0dXJuIHRoaXMucDAueT09PXRoaXMucDEueX1kaXN0YW5jZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBELnNlZ21lbnRUb1NlZ21lbnQodGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gRC5wb2ludFRvU2VnbWVudCh0LHRoaXMucDAsdGhpcy5wMSl9fXBvaW50QWxvbmcodCl7Y29uc3QgZT1uZXcgZztyZXR1cm4gZS54PXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxlLnk9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGV9aGFzaENvZGUoKXtsZXQgdD1qYXZhLmxhbmcuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC54KTt0Xj0zMSpqYXZhLmxhbmcuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC55KTtjb25zdCBlPU1hdGgudHJ1bmModCleTWF0aC50cnVuYyh0Pj4zMik7bGV0IG49amF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueCk7cmV0dXJuIG5ePTMxKmphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLnkpLGVeKE1hdGgudHJ1bmMobileTWF0aC50cnVuYyhuPj4zMikpfWdldENsYXNzKCl7cmV0dXJuIGVlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyLGFdfX1lZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWVlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IGcsbmV3IGcpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2VlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnAwPXQsdGhpcy5wMT1lfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2VlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IGcodCxlKSxuZXcgZyhuLHMpKX19LGVlLnNlcmlhbFZlcnNpb25VSUQ9MHgyZDIxNzIxMzVmNDExYzAwO2NsYXNzIG5le2NvbnN0cnVjdG9yKCl7bmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9Mb2NhdGlvblN5bWJvbCh0KXtzd2l0Y2godCl7Y2FzZSBuZS5FWFRFUklPUjpyZXR1cm5cImVcIjtjYXNlIG5lLkJPVU5EQVJZOnJldHVyblwiYlwiO2Nhc2UgbmUuSU5URVJJT1I6cmV0dXJuXCJpXCI7Y2FzZSBuZS5OT05FOnJldHVyblwiLVwifXRocm93IG5ldyBuKFwiVW5rbm93biBsb2NhdGlvbiB2YWx1ZTogXCIrdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gbmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW5lLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sbmUuSU5URVJJT1I9MCxuZS5CT1VOREFSWT0xLG5lLkVYVEVSSU9SPTIsbmUuTk9ORT0tMTtjbGFzcyBzZXtjb25zdHJ1Y3Rvcigpe3NlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1hdGNoZXMoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJlwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBlPT09dXQuU1lNX0RPTlRDQVJFfHwoZT09PXV0LlNZTV9UUlVFJiYodD49MHx8dD09PXV0LlRSVUUpfHwoZT09PXV0LlNZTV9GQUxTRSYmdD09PXV0LkZBTFNFfHwoZT09PXV0LlNZTV9QJiZ0PT09dXQuUHx8KGU9PT11dC5TWU1fTCYmdD09PXV0Lkx8fGU9PT11dC5TWU1fQSYmdD09PXV0LkEpKSkpfWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgc2UodCkubWF0Y2hlcyhlKX19c3RhdGljIGlzVHJ1ZSh0KXtyZXR1cm4gdD49MHx8dD09PXV0LlRSVUV9aXNJbnRlcnNlY3RzKCl7cmV0dXJuIXRoaXMuaXNEaXNqb2ludCgpfWlzQ292ZXJzKCl7cmV0dXJuKHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSl8fHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkJPVU5EQVJZXSl8fHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLklOVEVSSU9SXSl8fHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkJPVU5EQVJZXSkpJiZ0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkJPVU5EQVJZXT09PXV0LkZBTFNFfWlzQ292ZXJlZEJ5KCl7cmV0dXJuKHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSl8fHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkJPVU5EQVJZXSl8fHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLklOVEVSSU9SXSl8fHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkJPVU5EQVJZXSkpJiZ0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkVYVEVSSU9SXT09PXV0LkZBTFNFfXNldCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj1NYXRoLnRydW5jKGUvMykscz1lJTM7dGhpcy5fbWF0cml4W25dW3NdPXV0LnRvRGltZW5zaW9uVmFsdWUodC5jaGFyQXQoZSkpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9tYXRyaXhbdF1bZV09bn19aXNDb250YWlucygpe3JldHVybiBzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pJiZ0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkJPVU5EQVJZXT09PXV0LkZBTFNFfXNldEF0TGVhc3QoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49TWF0aC50cnVuYyhlLzMpLHM9ZSUzO3RoaXMuc2V0QXRMZWFzdChuLHMsdXQudG9EaW1lbnNpb25WYWx1ZSh0LmNoYXJBdChlKSkpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9tYXRyaXhbdF1bZV08biYmKHRoaXMuX21hdHJpeFt0XVtlXT1uKX19c2V0QXRMZWFzdElmVmFsaWQodCxlLG4pe3Q+PTAmJmU+PTAmJnRoaXMuc2V0QXRMZWFzdCh0LGUsbil9aXNXaXRoaW4oKXtyZXR1cm4gc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRX1pc1RvdWNoZXModCxlKXtyZXR1cm4gdD5lP3RoaXMuaXNUb3VjaGVzKGUsdCk6KHQ9PT11dC5BJiZlPT09dXQuQXx8dD09PXV0LkwmJmU9PT11dC5MfHx0PT09dXQuTCYmZT09PXV0LkF8fHQ9PT11dC5QJiZlPT09dXQuQXx8dD09PXV0LlAmJmU9PT11dC5MKSYmKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdPT09dXQuRkFMU0UmJihzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5CT1VOREFSWV0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5JTlRFUklPUl0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5CT1VOREFSWV0pKSl9aXNPdmVybGFwcyh0LGUpe3JldHVybiB0PT09dXQuUCYmZT09PXV0LlB8fHQ9PT11dC5BJiZlPT09dXQuQT9zZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pJiZzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl0pJiZzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl0pOnQ9PT11dC5MJiZlPT09dXQuTCYmKDE9PT10aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSYmc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdKSYmc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdKSl9aXNFcXVhbHModCxlKXtyZXR1cm4gdD09PWUmJihzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pJiZ0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkVYVEVSSU9SXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkJPVU5EQVJZXT09PXV0LkZBTFNFKX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHd0KFwiMTIzNDU2Nzg5XCIpO2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKyl0LnNldENoYXJBdCgzKmUrbix1dC50b0RpbWVuc2lvblN5bWJvbCh0aGlzLl9tYXRyaXhbZV1bbl0pKTtyZXR1cm4gdC50b1N0cmluZygpfXNldEFsbCh0KXtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdGhpcy5fbWF0cml4W2VdW25dPXR9Z2V0KHQsZSl7cmV0dXJuIHRoaXMuX21hdHJpeFt0XVtlXX10cmFuc3Bvc2UoKXtsZXQgdD10aGlzLl9tYXRyaXhbMV1bMF07cmV0dXJuIHRoaXMuX21hdHJpeFsxXVswXT10aGlzLl9tYXRyaXhbMF1bMV0sdGhpcy5fbWF0cml4WzBdWzFdPXQsdD10aGlzLl9tYXRyaXhbMl1bMF0sdGhpcy5fbWF0cml4WzJdWzBdPXRoaXMuX21hdHJpeFswXVsyXSx0aGlzLl9tYXRyaXhbMF1bMl09dCx0PXRoaXMuX21hdHJpeFsyXVsxXSx0aGlzLl9tYXRyaXhbMl1bMV09dGhpcy5fbWF0cml4WzFdWzJdLHRoaXMuX21hdHJpeFsxXVsyXT10LHRoaXN9bWF0Y2hlcyh0KXtpZig5IT09dC5sZW5ndGgpdGhyb3cgbmV3IG4oXCJTaG91bGQgYmUgbGVuZ3RoIDk6IFwiK3QpO2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKylpZighc2UubWF0Y2hlcyh0aGlzLl9tYXRyaXhbZV1bbl0sdC5jaGFyQXQoMyplK24pKSlyZXR1cm4hMTtyZXR1cm4hMH1hZGQodCl7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKXRoaXMuc2V0QXRMZWFzdChlLG4sdC5nZXQoZSxuKSl9aXNEaXNqb2ludCgpe3JldHVybiB0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkJPVU5EQVJZXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLklOVEVSSU9SXT09PXV0LkZBTFNFJiZ0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkJPVU5EQVJZXT09PXV0LkZBTFNFfWlzQ3Jvc3Nlcyh0LGUpe3JldHVybiB0PT09dXQuUCYmZT09PXV0Lkx8fHQ9PT11dC5QJiZlPT09dXQuQXx8dD09PXV0LkwmJmU9PT11dC5BP3NlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSkmJnNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXSk6dD09PXV0LkwmJmU9PT11dC5QfHx0PT09dXQuQSYmZT09PXV0LlB8fHQ9PT11dC5BJiZlPT09dXQuTD9zZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pJiZzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl0pOnQ9PT11dC5MJiZlPT09dXQuTCYmMD09PXRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdfWdldENsYXNzKCl7cmV0dXJuIHNlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19c2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbWF0cml4PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fbWF0cml4PUFycmF5KDMpLmZpbGwoKS5tYXAoKCk9PkFycmF5KDMpKSx0aGlzLnNldEFsbCh1dC5GQUxTRSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtzZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLnNldCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Ygc2Upe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3NlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpLHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdPXQuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdLHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuQk9VTkRBUlldPXQuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuQk9VTkRBUlldLHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdPXQuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdLHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuSU5URVJJT1JdPXQuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuSU5URVJJT1JdLHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuQk9VTkRBUlldPXQuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuQk9VTkRBUlldLHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuRVhURVJJT1JdPXQuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuRVhURVJJT1JdLHRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdPXQuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdLHRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuQk9VTkRBUlldPXQuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuQk9VTkRBUlldLHRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuRVhURVJJT1JdPXQuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuRVhURVJJT1JdfX07Y2xhc3MgaWV7Y29uc3RydWN0b3IoKXtpZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0RlZ3JlZXModCl7cmV0dXJuIDE4MCp0L01hdGguUEl9c3RhdGljIG5vcm1hbGl6ZSh0KXtmb3IoO3Q+TWF0aC5QSTspdC09aWUuUElfVElNRVNfMjtmb3IoO3Q8PS1NYXRoLlBJOyl0Kz1pZS5QSV9USU1FU18yO3JldHVybiB0fXN0YXRpYyBhbmdsZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hdGFuMih0LnksdC54KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1lLngtdC54LHM9ZS55LXQueTtyZXR1cm4gTWF0aC5hdGFuMihzLG4pfX1zdGF0aWMgaXNBY3V0ZSh0LGUsbil7Y29uc3Qgcz10LngtZS54LGk9dC55LWUueTtyZXR1cm4gcyoobi54LWUueCkraSoobi55LWUueSk+MH1zdGF0aWMgaXNPYnR1c2UodCxlLG4pe2NvbnN0IHM9dC54LWUueCxpPXQueS1lLnk7cmV0dXJuIHMqKG4ueC1lLngpK2kqKG4ueS1lLnkpPDB9c3RhdGljIGludGVyaW9yQW5nbGUodCxlLG4pe2NvbnN0IHM9aWUuYW5nbGUoZSx0KSxpPWllLmFuZ2xlKGUsbik7cmV0dXJuIE1hdGguYWJzKGktcyl9c3RhdGljIG5vcm1hbGl6ZVBvc2l0aXZlKHQpe2lmKHQ8MCl7Zm9yKDt0PDA7KXQrPWllLlBJX1RJTUVTXzI7dD49aWUuUElfVElNRVNfMiYmKHQ9MCl9ZWxzZXtmb3IoO3Q+PWllLlBJX1RJTUVTXzI7KXQtPWllLlBJX1RJTUVTXzI7dDwwJiYodD0wKX1yZXR1cm4gdH1zdGF0aWMgYW5nbGVCZXR3ZWVuKHQsZSxuKXtjb25zdCBzPWllLmFuZ2xlKGUsdCksaT1pZS5hbmdsZShlLG4pO3JldHVybiBpZS5kaWZmKHMsaSl9c3RhdGljIGRpZmYodCxlKXtsZXQgbj1udWxsO3JldHVybiBuPXQ8ZT9lLXQ6dC1lLG4+TWF0aC5QSSYmKG49MipNYXRoLlBJLW4pLG59c3RhdGljIHRvUmFkaWFucyh0KXtyZXR1cm4gdCpNYXRoLlBJLzE4MH1zdGF0aWMgZ2V0VHVybih0LGUpe2NvbnN0IG49TWF0aC5zaW4oZS10KTtyZXR1cm4gbj4wP2llLkNPVU5URVJDTE9DS1dJU0U6bjwwP2llLkNMT0NLV0lTRTppZS5OT05FfXN0YXRpYyBhbmdsZUJldHdlZW5PcmllbnRlZCh0LGUsbil7Y29uc3Qgcz1pZS5hbmdsZShlLHQpLGk9aWUuYW5nbGUoZSxuKS1zO3JldHVybiBpPD0tTWF0aC5QST9pK2llLlBJX1RJTUVTXzI6aT5NYXRoLlBJP2ktaWUuUElfVElNRVNfMjppfWdldENsYXNzKCl7cmV0dXJuIGllfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1pZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LGllLlBJX1RJTUVTXzI9MipNYXRoLlBJLGllLlBJX09WRVJfMj1NYXRoLlBJLzIsaWUuUElfT1ZFUl80PU1hdGguUEkvNCxpZS5DT1VOVEVSQ0xPQ0tXSVNFPXYuQ09VTlRFUkNMT0NLV0lTRSxpZS5DTE9DS1dJU0U9di5DTE9DS1dJU0UsaWUuTk9ORT12LkNPTExJTkVBUjtjbGFzcyByZXtjb25zdHJ1Y3Rvcigpe3JlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGFyZWEodCxlLG4pe3JldHVybiBNYXRoLmFicygoKG4ueC10LngpKihlLnktdC55KS0oZS54LXQueCkqKG4ueS10LnkpKS8yKX1zdGF0aWMgc2lnbmVkQXJlYSh0LGUsbil7cmV0dXJuKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMn1zdGF0aWMgZGV0KHQsZSxuLHMpe3JldHVybiB0KnMtZSpufXN0YXRpYyBpbnRlcnBvbGF0ZVoodCxlLG4scyl7Y29uc3QgaT1lLngscj1lLnksbz1uLngtaSxsPXMueC1pLGE9bi55LXIsYz1zLnktcixoPW8qYy1sKmEsdT10LngtaSxnPXQueS1yLGQ9KGMqdS1sKmcpL2gsXz0oLWEqdStvKmcpL2g7cmV0dXJuIGUueitkKihuLnotZS56KStfKihzLnotZS56KX1zdGF0aWMgbG9uZ2VzdFNpZGVMZW5ndGgodCxlLG4pe2NvbnN0IHM9dC5kaXN0YW5jZShlKSxpPWUuZGlzdGFuY2Uobikscj1uLmRpc3RhbmNlKHQpO2xldCBvPXM7cmV0dXJuIGk+byYmKG89aSkscj5vJiYobz1yKSxvfXN0YXRpYyBpc0FjdXRlKHQsZSxuKXtyZXR1cm4hIWllLmlzQWN1dGUodCxlLG4pJiYoISFpZS5pc0FjdXRlKGUsbix0KSYmISFpZS5pc0FjdXRlKG4sdCxlKSl9c3RhdGljIGNpcmN1bWNlbnRyZSh0LGUsbil7Y29uc3Qgcz1uLngsaT1uLnkscj10LngtcyxvPXQueS1pLGw9ZS54LXMsYT1lLnktaSxjPTIqcmUuZGV0KHIsbyxsLGEpLGg9cmUuZGV0KG8scipyK28qbyxhLGwqbCthKmEpLHU9cmUuZGV0KHIscipyK28qbyxsLGwqbCthKmEpO3JldHVybiBuZXcgZyhzLWgvYyxpK3UvYyl9c3RhdGljIHBlcnBlbmRpY3VsYXJCaXNlY3Rvcih0LGUpe2NvbnN0IG49ZS54LXQueCxzPWUueS10LnksaT1uZXcgYih0Lngrbi8yLHQueStzLzIsMSkscj1uZXcgYih0LngtcytuLzIsdC55K24rcy8yLDEpO3JldHVybiBuZXcgYihpLHIpfXN0YXRpYyBhbmdsZUJpc2VjdG9yKHQsZSxuKXtjb25zdCBzPWUuZGlzdGFuY2UodCksaT1zLyhzK2UuZGlzdGFuY2UobikpLHI9bi54LXQueCxvPW4ueS10Lnk7cmV0dXJuIG5ldyBnKHQueCtpKnIsdC55K2kqbyl9c3RhdGljIGFyZWEzRCh0LGUsbil7Y29uc3Qgcz1lLngtdC54LGk9ZS55LXQueSxyPWUuei10Lnosbz1uLngtdC54LGw9bi55LXQueSxhPW4uei10LnosYz1pKmEtcipsLGg9cipvLXMqYSx1PXMqbC1pKm8sZz1jKmMraCpoK3UqdTtyZXR1cm4gTWF0aC5zcXJ0KGcpLzJ9c3RhdGljIGNlbnRyb2lkKHQsZSxuKXtjb25zdCBzPSh0LngrZS54K24ueCkvMyxpPSh0LnkrZS55K24ueSkvMztyZXR1cm4gbmV3IGcocyxpKX1zdGF0aWMgaW5DZW50cmUodCxlLG4pe2NvbnN0IHM9ZS5kaXN0YW5jZShuKSxpPXQuZGlzdGFuY2Uobikscj10LmRpc3RhbmNlKGUpLG89cytpK3IsbD0ocyp0LngraSplLngrcipuLngpL28sYT0ocyp0LnkraSplLnkrcipuLnkpL287cmV0dXJuIG5ldyBnKGwsYSl9YXJlYSgpe3JldHVybiByZS5hcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1zaWduZWRBcmVhKCl7cmV0dXJuIHJlLnNpZ25lZEFyZWEodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWludGVycG9sYXRlWih0KXtpZihudWxsPT09dCl0aHJvdyBuZXcgbihcIlN1cHBsaWVkIHBvaW50IGlzIG51bGwuXCIpO3JldHVybiByZS5pbnRlcnBvbGF0ZVoodCx0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9bG9uZ2VzdFNpZGVMZW5ndGgoKXtyZXR1cm4gcmUubG9uZ2VzdFNpZGVMZW5ndGgodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWlzQWN1dGUoKXtyZXR1cm4gcmUuaXNBY3V0ZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9Y2lyY3VtY2VudHJlKCl7cmV0dXJuIHJlLmNpcmN1bWNlbnRyZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9YXJlYTNEKCl7cmV0dXJuIHJlLmFyZWEzRCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9Y2VudHJvaWQoKXtyZXR1cm4gcmUuY2VudHJvaWQodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWluQ2VudHJlKCl7cmV0dXJuIHJlLmluQ2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1nZXRDbGFzcygpe3JldHVybiByZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCx0aGlzLnAyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5wMD10LHRoaXMucDE9ZSx0aGlzLnAyPW59O2NsYXNzIG9lIGV4dGVuZHMgQ3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksb2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBvZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19b2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpQy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtDLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fTtjbGFzcyBsZXtjb25zdHJ1Y3Rvcigpe2xlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRyYW5zbGF0aW9uSW5zdGFuY2UodCxlKXtjb25zdCBuPW5ldyBsZTtyZXR1cm4gbi5zZXRUb1RyYW5zbGF0aW9uKHQsZSksbn1zdGF0aWMgc2hlYXJJbnN0YW5jZSh0LGUpe2NvbnN0IG49bmV3IGxlO3JldHVybiBuLnNldFRvU2hlYXIodCxlKSxufXN0YXRpYyByZWZsZWN0aW9uSW5zdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgbGU7cmV0dXJuIG4uc2V0VG9SZWZsZWN0aW9uKHQsZSksbn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgbGU7cmV0dXJuIGkuc2V0VG9SZWZsZWN0aW9uKHQsZSxuLHMpLGl9fXN0YXRpYyByb3RhdGlvbkluc3RhbmNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBsZS5yb3RhdGlvbkluc3RhbmNlKE1hdGguc2luKHQpLE1hdGguY29zKHQpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgbGU7cmV0dXJuIG4uc2V0VG9Sb3RhdGlvbih0LGUpLG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBsZS5yb3RhdGlvbkluc3RhbmNlKE1hdGguc2luKHQpLE1hdGguY29zKHQpLGUsbil9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGxlO3JldHVybiBpLnNldFRvUm90YXRpb24odCxlLG4scyksaX19c3RhdGljIHNjYWxlSW5zdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgbGU7cmV0dXJuIG4uc2V0VG9TY2FsZSh0LGUpLG59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGxlO3JldHVybiBpLnRyYW5zbGF0ZSgtbiwtcyksaS5zY2FsZSh0LGUpLGkudHJhbnNsYXRlKG4scyksaX19c2V0VG9SZWZsZWN0aW9uQmFzaWModCxlLHMsaSl7aWYodD09PXMmJmU9PT1pKXRocm93IG5ldyBuKFwiUmVmbGVjdGlvbiBsaW5lIHBvaW50cyBtdXN0IGJlIGRpc3RpbmN0XCIpO2NvbnN0IHI9cy10LG89aS1lLGw9TWF0aC5zcXJ0KHIqcitvKm8pLGE9by9sLGM9ci9sLGg9MiphKmMsdT1jKmMtYSphO3JldHVybiB0aGlzLl9tMDA9dSx0aGlzLl9tMDE9aCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9aCx0aGlzLl9tMTE9LXUsdGhpcy5fbTEyPTAsdGhpc31nZXRJbnZlcnNlKCl7Y29uc3QgdD10aGlzLmdldERldGVybWluYW50KCk7aWYoMD09PXQpdGhyb3cgbmV3IG9lKFwiVHJhbnNmb3JtYXRpb24gaXMgbm9uLWludmVydGlibGVcIik7Y29uc3QgZT10aGlzLl9tMTEvdCxuPS10aGlzLl9tMTAvdCxzPS10aGlzLl9tMDEvdCxpPXRoaXMuX20wMC90LHI9KHRoaXMuX20wMSp0aGlzLl9tMTItdGhpcy5fbTAyKnRoaXMuX20xMSkvdCxvPSgtdGhpcy5fbTAwKnRoaXMuX20xMit0aGlzLl9tMTAqdGhpcy5fbTAyKS90O3JldHVybiBuZXcgbGUoZSxzLHIsbixpLG8pfWNvbXBvc2UodCl7Y29uc3QgZT10Ll9tMDAqdGhpcy5fbTAwK3QuX20wMSp0aGlzLl9tMTAsbj10Ll9tMDAqdGhpcy5fbTAxK3QuX20wMSp0aGlzLl9tMTEscz10Ll9tMDAqdGhpcy5fbTAyK3QuX20wMSp0aGlzLl9tMTIrdC5fbTAyLGk9dC5fbTEwKnRoaXMuX20wMCt0Ll9tMTEqdGhpcy5fbTEwLHI9dC5fbTEwKnRoaXMuX20wMSt0Ll9tMTEqdGhpcy5fbTExLG89dC5fbTEwKnRoaXMuX20wMit0Ll9tMTEqdGhpcy5fbTEyK3QuX20xMjtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPW4sdGhpcy5fbTAyPXMsdGhpcy5fbTEwPWksdGhpcy5fbTExPXIsdGhpcy5fbTEyPW8sdGhpc31lcXVhbHModCl7aWYobnVsbD09PXQpcmV0dXJuITE7aWYoISh0IGluc3RhbmNlb2YgbGUpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fbTAwPT09ZS5fbTAwJiZ0aGlzLl9tMDE9PT1lLl9tMDEmJnRoaXMuX20wMj09PWUuX20wMiYmdGhpcy5fbTEwPT09ZS5fbTEwJiZ0aGlzLl9tMTE9PT1lLl9tMTEmJnRoaXMuX20xMj09PWUuX20xMn1zZXRUb1NjYWxlKHQsZSl7cmV0dXJuIHRoaXMuX20wMD10LHRoaXMuX20wMT0wLHRoaXMuX20wMj0wLHRoaXMuX20xMD0wLHRoaXMuX20xMT1lLHRoaXMuX20xMj0wLHRoaXN9aXNJZGVudGl0eSgpe3JldHVybiAxPT09dGhpcy5fbTAwJiYwPT09dGhpcy5fbTAxJiYwPT09dGhpcy5fbTAyJiYwPT09dGhpcy5fbTEwJiYxPT09dGhpcy5fbTExJiYwPT09dGhpcy5fbTEyfXNjYWxlKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShsZS5zY2FsZUluc3RhbmNlKHQsZSkpLHRoaXN9c2V0VG9JZGVudGl0eSgpe3JldHVybiB0aGlzLl9tMDA9MSx0aGlzLl9tMDE9MCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9MCx0aGlzLl9tMTE9MSx0aGlzLl9tMTI9MCx0aGlzfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITB9c2V0VHJhbnNmb3JtYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX20wMD10Ll9tMDAsdGhpcy5fbTAxPXQuX20wMSx0aGlzLl9tMDI9dC5fbTAyLHRoaXMuX20xMD10Ll9tMTAsdGhpcy5fbTExPXQuX20xMSx0aGlzLl9tMTI9dC5fbTEyLHRoaXN9aWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3JldHVybiB0aGlzLl9tMDA9dCx0aGlzLl9tMDE9ZSx0aGlzLl9tMDI9bix0aGlzLl9tMTA9cyx0aGlzLl9tMTE9aSx0aGlzLl9tMTI9cix0aGlzfX1zZXRUb1JvdGF0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNldFRvUm90YXRpb24oTWF0aC5zaW4odCksTWF0aC5jb3ModCkpLHRoaXN9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9LXQsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPXQsdGhpcy5fbTExPWUsdGhpcy5fbTEyPTAsdGhpc31pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHRoaXMuc2V0VG9Sb3RhdGlvbihNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSxlLG4pLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9LXQsdGhpcy5fbTAyPW4tbiplK3MqdCx0aGlzLl9tMTA9dCx0aGlzLl9tMTE9ZSx0aGlzLl9tMTI9cy1uKnQtcyplLHRoaXN9fWdldE1hdHJpeEVudHJpZXMoKXtyZXR1cm5bdGhpcy5fbTAwLHRoaXMuX20wMSx0aGlzLl9tMDIsdGhpcy5fbTEwLHRoaXMuX20xMSx0aGlzLl9tMTJdfWZpbHRlcih0LGUpe3RoaXMudHJhbnNmb3JtKHQsZSl9cm90YXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvbXBvc2UobGUucm90YXRpb25JbnN0YW5jZSh0KSksdGhpc31pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcG9zZShsZS5yb3RhdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLmNvbXBvc2UobGUucm90YXRpb25JbnN0YW5jZSh0LGUsbikpLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXBvc2UobGUucm90YXRpb25JbnN0YW5jZSh0LGUpKSx0aGlzfX1nZXREZXRlcm1pbmFudCgpe3JldHVybiB0aGlzLl9tMDAqdGhpcy5fbTExLXRoaXMuX20wMSp0aGlzLl9tMTB9Y29tcG9zZUJlZm9yZSh0KXtjb25zdCBlPXRoaXMuX20wMCp0Ll9tMDArdGhpcy5fbTAxKnQuX20xMCxuPXRoaXMuX20wMCp0Ll9tMDErdGhpcy5fbTAxKnQuX20xMSxzPXRoaXMuX20wMCp0Ll9tMDIrdGhpcy5fbTAxKnQuX20xMit0aGlzLl9tMDIsaT10aGlzLl9tMTAqdC5fbTAwK3RoaXMuX20xMSp0Ll9tMTAscj10aGlzLl9tMTAqdC5fbTAxK3RoaXMuX20xMSp0Ll9tMTEsbz10aGlzLl9tMTAqdC5fbTAyK3RoaXMuX20xMSp0Ll9tMTIrdGhpcy5fbTEyO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9bix0aGlzLl9tMDI9cyx0aGlzLl9tMTA9aSx0aGlzLl9tMTE9cix0aGlzLl9tMTI9byx0aGlzfXNldFRvU2hlYXIodCxlKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPXQsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPWUsdGhpcy5fbTExPTEsdGhpcy5fbTEyPTAsdGhpc31pc0RvbmUoKXtyZXR1cm4hMX1jbG9uZSgpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBDKSl0aHJvdyB0O3Uuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbnVsbH10cmFuc2xhdGUodCxlKXtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnRyYW5zbGF0aW9uSW5zdGFuY2UodCxlKSksdGhpc31zZXRUb1JlZmxlY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBuKFwiUmVmbGVjdGlvbiB2ZWN0b3IgbXVzdCBiZSBub24temVyb1wiKTtpZih0PT09ZSlyZXR1cm4gdGhpcy5fbTAwPTAsdGhpcy5fbTAxPTEsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPTEsdGhpcy5fbTExPTAsdGhpcy5fbTEyPTAsdGhpcztjb25zdCBzPU1hdGguc3FydCh0KnQrZSplKSxpPWUvcyxyPXQvcztyZXR1cm4gdGhpcy5yb3RhdGUoLWksciksdGhpcy5zY2FsZSgxLC0xKSx0aGlzLnJvdGF0ZShpLHIpLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO2lmKHQ9PT1zJiZlPT09aSl0aHJvdyBuZXcgbihcIlJlZmxlY3Rpb24gbGluZSBwb2ludHMgbXVzdCBiZSBkaXN0aW5jdFwiKTt0aGlzLnNldFRvVHJhbnNsYXRpb24oLXQsLWUpO2NvbnN0IHI9cy10LG89aS1lLGw9TWF0aC5zcXJ0KHIqcitvKm8pLGE9by9sLGM9ci9sO3JldHVybiB0aGlzLnJvdGF0ZSgtYSxjKSx0aGlzLnNjYWxlKDEsLTEpLHRoaXMucm90YXRlKGEsYyksdGhpcy50cmFuc2xhdGUodCxlKSx0aGlzfX10b1N0cmluZygpe3JldHVyblwiQWZmaW5lVHJhbnNmb3JtYXRpb25bW1wiK3RoaXMuX20wMCtcIiwgXCIrdGhpcy5fbTAxK1wiLCBcIit0aGlzLl9tMDIrXCJdLCBbXCIrdGhpcy5fbTEwK1wiLCBcIit0aGlzLl9tMTErXCIsIFwiK3RoaXMuX20xMitcIl1dXCJ9c2V0VG9UcmFuc2xhdGlvbih0LGUpe3JldHVybiB0aGlzLl9tMDA9MSx0aGlzLl9tMDE9MCx0aGlzLl9tMDI9dCx0aGlzLl9tMTA9MCx0aGlzLl9tMTE9MSx0aGlzLl9tMTI9ZSx0aGlzfXNoZWFyKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShsZS5zaGVhckluc3RhbmNlKHQsZSkpLHRoaXN9dHJhbnNmb3JtKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmNvcHkoKTtyZXR1cm4gdC5hcHBseSh0aGlzKSx0fWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9tMDAqdC54K3RoaXMuX20wMSp0LnkrdGhpcy5fbTAyLHM9dGhpcy5fbTEwKnQueCt0aGlzLl9tMTEqdC55K3RoaXMuX20xMjtyZXR1cm4gZS54PW4sZS55PXMsZX1pZihfKGFyZ3VtZW50c1swXSxBKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX20wMCp0LmdldE9yZGluYXRlKGUsMCkrdGhpcy5fbTAxKnQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLl9tMDIscz10aGlzLl9tMTAqdC5nZXRPcmRpbmF0ZShlLDApK3RoaXMuX20xMSp0LmdldE9yZGluYXRlKGUsMSkrdGhpcy5fbTEyO3Quc2V0T3JkaW5hdGUoZSwwLG4pLHQuc2V0T3JkaW5hdGUoZSwxLHMpfX19cmVmbGVjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnJlZmxlY3Rpb25JbnN0YW5jZSh0LGUpKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnJlZmxlY3Rpb25JbnN0YW5jZSh0LGUsbixzKSksdGhpc319Z2V0Q2xhc3MoKXtyZXR1cm4gbGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW28sZHRdfX1sZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9tMDA9bnVsbCx0aGlzLl9tMDE9bnVsbCx0aGlzLl9tMDI9bnVsbCx0aGlzLl9tMTA9bnVsbCx0aGlzLl9tMTE9bnVsbCx0aGlzLl9tMTI9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnNldFRvSWRlbnRpdHkoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tMDA9dFswXSx0aGlzLl9tMDE9dFsxXSx0aGlzLl9tMDI9dFsyXSx0aGlzLl9tMTA9dFszXSx0aGlzLl9tMTE9dFs0XSx0aGlzLl9tMTI9dFs1XX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbGUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0VHJhbnNmb3JtYXRpb24odCl9fWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbNV0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbNF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbM10mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3RoaXMuc2V0VHJhbnNmb3JtYXRpb24odCxlLG4scyxpLHIpfX07Y2xhc3MgYWV7Y29uc3RydWN0b3IoKXthZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzb2x2ZSh0LGUpe2NvbnN0IHM9ZS5sZW5ndGg7aWYodC5sZW5ndGghPT1zfHx0WzBdLmxlbmd0aCE9PXMpdGhyb3cgbmV3IG4oXCJNYXRyaXggQSBpcyBpbmNvcnJlY3RseSBzaXplZFwiKTtmb3IobGV0IG49MDtuPHM7bisrKXtsZXQgaT1uO2ZvcihsZXQgZT1uKzE7ZTxzO2UrKylNYXRoLmFicyh0W2VdW25dKT5NYXRoLmFicyh0W2ldW25dKSYmKGk9ZSk7aWYoMD09PXRbaV1bbl0pcmV0dXJuIG51bGw7YWUuc3dhcFJvd3ModCxuLGkpLGFlLnN3YXBSb3dzKGUsbixpKTtmb3IobGV0IGk9bisxO2k8cztpKyspe2NvbnN0IHI9dFtpXVtuXS90W25dW25dO2ZvcihsZXQgZT1zLTE7ZT49bjtlLS0pdFtpXVtlXS09dFtuXVtlXSpyO2VbaV0tPWVbbl0qcn19Y29uc3QgaT1uZXcgQXJyYXkocykuZmlsbChudWxsKTtmb3IobGV0IG49cy0xO24+PTA7bi0tKXtsZXQgcj0wO2ZvcihsZXQgZT1uKzE7ZTxzO2UrKylyKz10W25dW2VdKmlbZV07aVtuXT0oZVtuXS1yKS90W25dW25dfXJldHVybiBpfXN0YXRpYyBzd2FwUm93cygpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihlPT09bilyZXR1cm4gbnVsbDtmb3IobGV0IHM9MDtzPHRbMF0ubGVuZ3RoO3MrKyl7Y29uc3QgaT10W2VdW3NdO3RbZV1bc109dFtuXVtzXSx0W25dW3NdPWl9fWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKGU9PT1uKXJldHVybiBudWxsO2NvbnN0IHM9dFtlXTt0W2VdPXRbbl0sdFtuXT1zfX1nZXRDbGFzcygpe3JldHVybiBhZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19YWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBjZXtjb25zdHJ1Y3Rvcigpe2NlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c29sdmUodCl7Y29uc3QgZT1bW3RoaXMuX3NyYzAueCx0aGlzLl9zcmMwLnksMV0sW3RoaXMuX3NyYzEueCx0aGlzLl9zcmMxLnksMV0sW3RoaXMuX3NyYzIueCx0aGlzLl9zcmMyLnksMV1dO3JldHVybiBhZS5zb2x2ZShlLHQpfWNvbXB1dGUoKXtjb25zdCB0PVt0aGlzLl9kZXN0MC54LHRoaXMuX2Rlc3QxLngsdGhpcy5fZGVzdDIueF0sZT10aGlzLnNvbHZlKHQpO2lmKG51bGw9PT1lKXJldHVybiExO3RoaXMuX20wMD1lWzBdLHRoaXMuX20wMT1lWzFdLHRoaXMuX20wMj1lWzJdO2NvbnN0IG49W3RoaXMuX2Rlc3QwLnksdGhpcy5fZGVzdDEueSx0aGlzLl9kZXN0Mi55XSxzPXRoaXMuc29sdmUobik7cmV0dXJuIG51bGwhPT1zJiYodGhpcy5fbTEwPXNbMF0sdGhpcy5fbTExPXNbMV0sdGhpcy5fbTEyPXNbMl0sITApfWdldFRyYW5zZm9ybWF0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpP25ldyBsZSh0aGlzLl9tMDAsdGhpcy5fbTAxLHRoaXMuX20wMix0aGlzLl9tMTAsdGhpcy5fbTExLHRoaXMuX20xMik6bnVsbH1nZXRDbGFzcygpe3JldHVybiBjZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc3JjMD1udWxsLHRoaXMuX3NyYzE9bnVsbCx0aGlzLl9zcmMyPW51bGwsdGhpcy5fZGVzdDA9bnVsbCx0aGlzLl9kZXN0MT1udWxsLHRoaXMuX2Rlc3QyPW51bGwsdGhpcy5fbTAwPW51bGwsdGhpcy5fbTAxPW51bGwsdGhpcy5fbTAyPW51bGwsdGhpcy5fbTEwPW51bGwsdGhpcy5fbTExPW51bGwsdGhpcy5fbTEyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07dGhpcy5fc3JjMD10LHRoaXMuX3NyYzE9ZSx0aGlzLl9zcmMyPW4sdGhpcy5fZGVzdDA9cyx0aGlzLl9kZXN0MT1pLHRoaXMuX2Rlc3QyPXJ9O2NsYXNzIGhle2NvbnN0cnVjdG9yKCl7aGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY3JlYXRlRnJvbUJhc2VMaW5lcyh0LGUsbixzKXtjb25zdCBpPW5ldyBnKHQueCtzLngtbi54LHQueStzLnktbi55KSxyPWllLmFuZ2xlQmV0d2Vlbk9yaWVudGVkKGUsdCxpKSxvPWUuZGlzdGFuY2UodCksbD1zLmRpc3RhbmNlKG4pO2lmKDA9PT1vKXJldHVybiBuZXcgbGU7Y29uc3QgYT1sL28sYz1sZS50cmFuc2xhdGlvbkluc3RhbmNlKC10LngsLXQueSk7cmV0dXJuIGMucm90YXRlKHIpLGMuc2NhbGUoYSxhKSxjLnRyYW5zbGF0ZShuLngsbi55KSxjfXN0YXRpYyBjcmVhdGVGcm9tQ29udHJvbFZlY3RvcnMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ZS54LXQueCxzPWUueS10Lnk7cmV0dXJuIGxlLnRyYW5zbGF0aW9uSW5zdGFuY2UobixzKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBuKFwiU3JjIGFuZCBEZXN0IGFycmF5cyBhcmUgbm90IHRoZSBzYW1lIGxlbmd0aFwiKTtpZih0Lmxlbmd0aDw9MCl0aHJvdyBuZXcgbihcIlRvbyBmZXcgY29udHJvbCBwb2ludHNcIik7aWYodC5sZW5ndGg+Myl0aHJvdyBuZXcgbihcIlRvbyBtYW55IGNvbnRyb2wgcG9pbnRzXCIpO3JldHVybiAxPT09dC5sZW5ndGg/aGUuY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKHRbMF0sZVswXSk6Mj09PXQubGVuZ3RoP2hlLmNyZWF0ZUZyb21Db250cm9sVmVjdG9ycyh0WzBdLHRbMV0sZVswXSxlWzFdKTpoZS5jcmVhdGVGcm9tQ29udHJvbFZlY3RvcnModFswXSx0WzFdLHRbMl0sZVswXSxlWzFdLGVbMl0pfX1lbHNle2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBnKHMueC1uLngscy55LW4ueSkscj1pZS5hbmdsZUJldHdlZW5PcmllbnRlZChlLHQsaSksbz1lLmRpc3RhbmNlKHQpLGw9cy5kaXN0YW5jZShuKTtpZigwPT09bylyZXR1cm4gbnVsbDtjb25zdCBhPWwvbyxjPWxlLnRyYW5zbGF0aW9uSW5zdGFuY2UoLXQueCwtdC55KTtyZXR1cm4gYy5yb3RhdGUociksYy5zY2FsZShhLGEpLGMudHJhbnNsYXRlKG4ueCxuLnkpLGN9aWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3JldHVybiBuZXcgY2UodCxlLG4scyxpLHIpLmdldFRyYW5zZm9ybWF0aW9uKCl9fX1nZXRDbGFzcygpe3JldHVybiBoZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB1ZXtjb25zdHJ1Y3Rvcigpe3VlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IHg7cmV0dXJuIHQuYXBwbHkobmV3IHVlKGUpKSxlfWZpbHRlcih0KXsodCBpbnN0YW5jZW9mIFR0fHx0IGluc3RhbmNlb2YgUHQpJiZ0aGlzLl9jb29yZHMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpKX1nZXRDbGFzcygpe3JldHVybiB1ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR119fXVlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Nvb3Jkcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2Nvb3Jkcz10fTtjbGFzcyBnZXtjb25zdHJ1Y3Rvcigpe2dlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1hcCh0LGUpe3JldHVybiBuZXcgZ2UoZSkubWFwKHQpfW1hcCh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXRoaXMuX21hcE9wLm1hcCh0LmdldEdlb21ldHJ5TihuKSk7cy5pc0VtcHR5KCl8fGUuYWRkKHMpfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oSHQudG9HZW9tZXRyeUFycmF5KGUpKX1nZXRDbGFzcygpe3JldHVybiBnZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Z2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbWFwT3A9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tYXBPcD10fTtjbGFzcyBkZXtjb25zdHJ1Y3Rvcigpe2RlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbWJpbmUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBkZSh0KS5jb21iaW5lKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgZGUoZGUuY3JlYXRlTGlzdCh0LGUpKS5jb21iaW5lKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuZXcgZGUoZGUuY3JlYXRlTGlzdCh0LGUsbikpLmNvbWJpbmUoKX19c3RhdGljIGV4dHJhY3RGYWN0b3J5KHQpe3JldHVybiB0LmlzRW1wdHkoKT9udWxsOnQuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpfXN0YXRpYyBjcmVhdGVMaXN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IHg7cmV0dXJuIG4uYWRkKHQpLG4uYWRkKGUpLG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IHg7cmV0dXJuIHMuYWRkKHQpLHMuYWRkKGUpLHMuYWRkKG4pLHN9fWV4dHJhY3RFbGVtZW50cyh0LGUpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pO3RoaXMuX3NraXBFbXB0eSYmcy5pc0VtcHR5KCl8fGUuYWRkKHMpfX1jb21iaW5lKCl7Y29uc3QgdD1uZXcgeDtmb3IobGV0IGU9dGhpcy5faW5wdXRHZW9tcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLmV4dHJhY3RFbGVtZW50cyhuLHQpfXJldHVybiAwPT09dC5zaXplKCk/bnVsbCE9PXRoaXMuX2dlb21GYWN0b3J5P3RoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpOm51bGw6dGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0KX1nZXRDbGFzcygpe3JldHVybiBkZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9za2lwRW1wdHk9ITEsdGhpcy5faW5wdXRHZW9tcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0b3J5PWRlLmV4dHJhY3RGYWN0b3J5KHQpLHRoaXMuX2lucHV0R2VvbXM9dH07Y2xhc3MgX2V7Y29uc3RydWN0b3IoKXtfZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc09mVHlwZSh0LGUpe3JldHVybiB0LmdldEdlb21ldHJ5VHlwZSgpPT09ZXx8ZT09PXEuVFlQRU5BTUVfTElORVNUUklORyYmdC5nZXRHZW9tZXRyeVR5cGUoKT09PXEuVFlQRU5BTUVfTElORUFSUklOR31zdGF0aWMgZXh0cmFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gX2UuZXh0cmFjdCh0LGUsbmV3IHgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1syXSxtKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdC5nZXRHZW9tZXRyeVR5cGUoKT09PWU/bi5hZGQodCk6dCBpbnN0YW5jZW9mIF90JiZ0LmFwcGx5KG5ldyBfZShlLG4pKSxufWlmKF8oYXJndW1lbnRzWzJdLG0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQ2xhc3Mpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBfZS5leHRyYWN0KHQsX2UudG9HZW9tZXRyeVR5cGUoZSksbil9fX1maWx0ZXIodCl7KG51bGw9PT10aGlzLl9nZW9tZXRyeVR5cGV8fF9lLmlzT2ZUeXBlKHQsdGhpcy5fZ2VvbWV0cnlUeXBlKSkmJnRoaXMuX2NvbXBzLmFkZCh0KX1nZXRDbGFzcygpe3JldHVybiBfZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ3RdfX1fZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tZXRyeVR5cGU9bnVsbCx0aGlzLl9jb21wcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21ldHJ5VHlwZT10LHRoaXMuX2NvbXBzPWV9O2NsYXNzIGZle2NvbnN0cnVjdG9yKCl7ZmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1tYXAodCl7fWdldENsYXNzKCl7cmV0dXJuIGZlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHBle2NvbnN0cnVjdG9yKCl7cGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbWFwKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZfKGFyZ3VtZW50c1sxXSxmZSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IHg7Zm9yKGxldCBzPTA7czx0LmdldE51bUdlb21ldHJpZXMoKTtzKyspe2NvbnN0IGk9ZS5tYXAodC5nZXRHZW9tZXRyeU4ocykpO251bGwhPT1pJiZuLmFkZChpKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShuKX1pZihfKGFyZ3VtZW50c1swXSxmKSYmXyhhcmd1bWVudHNbMV0sZmUpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB4O2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9ZS5tYXAodCk7bnVsbCE9PWkmJm4uYWRkKGkpfXJldHVybiBufX1nZXRDbGFzcygpe3JldHVybiBwZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBtZXtjb25zdHJ1Y3Rvcigpe21lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dHJhbnNmb3JtUG9pbnQodCxlKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfXRyYW5zZm9ybVBvbHlnb24odCxlKXtsZXQgbj0hMDtjb25zdCBzPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEV4dGVyaW9yUmluZygpLHQpO251bGwhPT1zJiZzIGluc3RhbmNlb2YgRHQmJiFzLmlzRW1wdHkoKXx8KG49ITEpO2NvbnN0IGk9bmV3IHg7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRJbnRlcmlvclJpbmdOKGUpLHQpO251bGw9PT1zfHxzLmlzRW1wdHkoKXx8KHMgaW5zdGFuY2VvZiBEdHx8KG49ITEpLGkuYWRkKHMpKX1pZihuKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24ocyxpLnRvQXJyYXkoW10pKTt7Y29uc3QgdD1uZXcgeDtyZXR1cm4gbnVsbCE9PXMmJnQuYWRkKHMpLHQuYWRkQWxsKGkpLHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0KX19Y3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlKHQpe3JldHVybiB0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCl9Z2V0SW5wdXRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9pbnB1dEdlb219dHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodC5nZXRHZW9tZXRyeU4oZSksdCk7bnVsbCE9PXMmJihzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtyZXR1cm4gdGhpcy5jb3B5KHQpfXRyYW5zZm9ybUxpbmVTdHJpbmcodCxlKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9dHJhbnNmb3JtTXVsdGlQb2ludCh0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1Qb2ludCh0LmdldEdlb21ldHJ5TihlKSx0KTtudWxsIT09cyYmKHMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPW5ldyB4O2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtUG9seWdvbih0LmdldEdlb21ldHJ5TihlKSx0KTtudWxsIT09cyYmKHMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX1jb3B5KHQpe3JldHVybiB0LmNvcHkoKX10cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPW5ldyB4O2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtKHQuZ2V0R2VvbWV0cnlOKGUpKTtudWxsIT09cyYmKHRoaXMuX3BydW5lRW1wdHlHZW9tZXRyeSYmcy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fcHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlP3RoaXMuX2ZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEh0LnRvR2VvbWV0cnlBcnJheShuKSk6dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfXRyYW5zZm9ybSh0KXtpZih0aGlzLl9pbnB1dEdlb209dCx0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLHQgaW5zdGFuY2VvZiBQdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBNdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIER0KXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgVHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZVN0cmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBmdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgYnQpcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9seWdvbih0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBBdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgX3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uKHQsbnVsbCk7dGhyb3cgbmV3IG4oXCJVbmtub3duIEdlb21ldHJ5IHN1YnR5cGU6IFwiK3QuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfXRyYW5zZm9ybUxpbmVhclJpbmcodCxlKXtjb25zdCBuPXRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KTtpZihudWxsPT09bilyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG51bGwpO2NvbnN0IHM9bi5zaXplKCk7cmV0dXJuIHM+MCYmczw0JiYhdGhpcy5fcHJlc2VydmVUeXBlP3RoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhuKTp0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobil9Z2V0Q2xhc3MoKXtyZXR1cm4gbWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW1lLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9wcnVuZUVtcHR5R2VvbWV0cnk9ITAsdGhpcy5fcHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlPSEwLHRoaXMuX3ByZXNlcnZlQ29sbGVjdGlvbnM9ITEsdGhpcy5fcHJlc2VydmVUeXBlPSExfTtjbGFzcyB5ZXtjb25zdHJ1Y3Rvcigpe3llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldEdlb21ldHJ5KHQpe3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHllLmdldExpbmVzKHQpKX1zdGF0aWMgZ2V0TGluZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHllLmdldExpbmVzKHQsbmV3IHgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIFR0P2UuYWRkKHQpOnQgaW5zdGFuY2VvZiBfdCYmdC5hcHBseShuZXcgeWUoZSkpLGV9fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgVHQmJnRoaXMuX2NvbXBzLmFkZCh0KX1nZXRDbGFzcygpe3JldHVybiB5ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ3RdfX15ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb21wcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvbXBzPXR9O2NsYXNzIHhle2NvbnN0cnVjdG9yKCl7eGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0R2VvbWV0cnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoeGUuZ2V0TGluZXModCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh4ZS5nZXRMaW5lcyh0LGUpKX19c3RhdGljIGdldExpbmVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB4ZS5nZXRMaW5lcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMF0sZikmJl8oYXJndW1lbnRzWzFdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt4ZS5nZXRMaW5lcyh0LGUpfXJldHVybiBlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IHg7cmV0dXJuIHQuYXBwbHkobmV3IHhlKG4sZSkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZfKGFyZ3VtZW50c1sxXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiBUdD9lLmFkZCh0KTp0LmFwcGx5KG5ldyB4ZShlKSksZX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJl8oYXJndW1lbnRzWzBdLGYpJiZfKGFyZ3VtZW50c1sxXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7eGUuZ2V0TGluZXModCxlLG4pfXJldHVybiBlfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJl8oYXJndW1lbnRzWzFdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdC5hcHBseShuZXcgeGUoZSxuKSksZX19fWZpbHRlcih0KXtpZih0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZyYmdCBpbnN0YW5jZW9mIER0KXtjb25zdCBlPXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7cmV0dXJuIHRoaXMuX2xpbmVzLmFkZChlKSxudWxsfXQgaW5zdGFuY2VvZiBUdCYmdGhpcy5fbGluZXMuYWRkKHQpfXNldEZvcmNlVG9MaW5lU3RyaW5nKHQpe3RoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nPXR9Z2V0Q2xhc3MoKXtyZXR1cm4geGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ddfX14ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9saW5lcz1udWxsLHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nPSExLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lcz10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2xpbmVzPXQsdGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmc9ZX19O2NvbnN0IEVlPXtyZXZlcnNlT3JkZXI6ZnVuY3Rpb24oKXtyZXR1cm57Y29tcGFyZToodCxlKT0+ZS5jb21wYXJlVG8odCl9fSxtaW46ZnVuY3Rpb24odCl7cmV0dXJuIEVlLnNvcnQodCksdC5nZXQoMCl9LHNvcnQ6ZnVuY3Rpb24odCxlKXtjb25zdCBuPXQudG9BcnJheSgpO2U/aHQuc29ydChuLGUpOmh0LnNvcnQobik7Y29uc3Qgcz10Lml0ZXJhdG9yKCk7Zm9yKGxldCB0PTAsZT1uLmxlbmd0aDt0PGU7dCsrKXMubmV4dCgpLHMuc2V0KG5bdF0pfSxzaW5nbGV0b25MaXN0OmZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IHg7cmV0dXJuIGUuYWRkKHQpLGV9fTtjbGFzcyBJZXtjb25zdHJ1Y3Rvcigpe0llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldFBvaW50cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdCBpbnN0YW5jZW9mIFB0P0VlLnNpbmdsZXRvbkxpc3QodCk6SWUuZ2V0UG9pbnRzKHQsbmV3IHgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIFB0P2UuYWRkKHQpOnQgaW5zdGFuY2VvZiBfdCYmdC5hcHBseShuZXcgSWUoZSkpLGV9fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgUHQmJnRoaXMuX3B0cy5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gSWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2d0XX19SWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHRzPXR9O2NsYXNzIE5le2NvbnN0cnVjdG9yKCl7TmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0UG9seWdvbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE5lLmdldFBvbHlnb25zKHQsbmV3IHgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIGJ0P2UuYWRkKHQpOnQgaW5zdGFuY2VvZiBfdCYmdC5hcHBseShuZXcgTmUoZSkpLGV9fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgYnQmJnRoaXMuX2NvbXBzLmFkZCh0KX1nZXRDbGFzcygpe3JldHVybiBOZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ3RdfX1OZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb21wcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvbXBzPXR9O2NsYXNzIENle2NvbnN0cnVjdG9yKCl7Q2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hcHBseVRvKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCkmJiF0aGlzLl9pc0RvbmU7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKG4gaW5zdGFuY2VvZiBfdCl0aGlzLmFwcGx5VG8obik7ZWxzZSBpZih0aGlzLnZpc2l0KG4pLHRoaXMuaXNEb25lKCkpcmV0dXJuIHRoaXMuX2lzRG9uZT0hMCxudWxsfX1nZXRDbGFzcygpe3JldHVybiBDZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Q2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNEb25lPSExfTtjbGFzcyBTZXtjb25zdHJ1Y3Rvcigpe1NlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlU3VwZXJjaXJjbGUodCl7Y29uc3QgZT0xL3Qsbj10aGlzLl9kaW0uZ2V0TWluU2l6ZSgpLzIscz10aGlzLl9kaW0uZ2V0Q2VudHJlKCksaT1NYXRoLnBvdyhuLHQpLHI9bixvPU1hdGgucG93KGkvMixlKSxsPU1hdGgudHJ1bmModGhpcy5fblB0cy84KSxhPW5ldyBBcnJheSg4KmwrMSkuZmlsbChudWxsKSxjPW8vbDtmb3IobGV0IG49MDtuPD1sO24rKyl7bGV0IG89MCxoPXI7aWYoMCE9PW4pe289YypuO2NvbnN0IHM9TWF0aC5wb3cobyx0KTtoPU1hdGgucG93KGktcyxlKX1hW25dPXRoaXMuY29vcmRUcmFucyhvLGgscyksYVsyKmwtbl09dGhpcy5jb29yZFRyYW5zKGgsbyxzKSxhWzIqbCtuXT10aGlzLmNvb3JkVHJhbnMoaCwtbyxzKSxhWzQqbC1uXT10aGlzLmNvb3JkVHJhbnMobywtaCxzKSxhWzQqbCtuXT10aGlzLmNvb3JkVHJhbnMoLW8sLWgscyksYVs2Kmwtbl09dGhpcy5jb29yZFRyYW5zKC1oLC1vLHMpLGFbNipsK25dPXRoaXMuY29vcmRUcmFucygtaCxvLHMpLGFbOCpsLW5dPXRoaXMuY29vcmRUcmFucygtbyxoLHMpfWFbYS5sZW5ndGgtMV09bmV3IGcoYVswXSk7Y29uc3QgaD10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKGEpLHU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihoKTtyZXR1cm4gdGhpcy5yb3RhdGUodSl9c2V0TnVtUG9pbnRzKHQpe3RoaXMuX25QdHM9dH1zZXRCYXNlKHQpe3RoaXMuX2RpbS5zZXRCYXNlKHQpfXNldFJvdGF0aW9uKHQpe3RoaXMuX3JvdGF0aW9uQW5nbGU9dH1zZXRXaWR0aCh0KXt0aGlzLl9kaW0uc2V0V2lkdGgodCl9Y3JlYXRlRWxsaXBzZSgpe2NvbnN0IHQ9dGhpcy5fZGltLmdldEVudmVsb3BlKCksZT10LmdldFdpZHRoKCkvMixuPXQuZ2V0SGVpZ2h0KCkvMixzPXQuZ2V0TWluWCgpK2UsaT10LmdldE1pblkoKStuLHI9bmV3IEFycmF5KHRoaXMuX25QdHMrMSkuZmlsbChudWxsKTtsZXQgbz0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5fblB0czt0Kyspe2NvbnN0IGw9dCooMipNYXRoLlBJL3RoaXMuX25QdHMpLGE9ZSpNYXRoLmNvcyhsKStzLGM9bipNYXRoLnNpbihsKStpO3JbbysrXT10aGlzLmNvb3JkKGEsYyl9cltvXT1uZXcgZyhyWzBdKTtjb25zdCBsPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcociksYT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGwpO3JldHVybiB0aGlzLnJvdGF0ZShhKX1jb29yZFRyYW5zKHQsZSxuKXtyZXR1cm4gdGhpcy5jb29yZCh0K24ueCxlK24ueSl9Y3JlYXRlU3F1aXJjbGUoKXtyZXR1cm4gdGhpcy5jcmVhdGVTdXBlcmNpcmNsZSg0KX1zZXRFbnZlbG9wZSh0KXt0aGlzLl9kaW0uc2V0RW52ZWxvcGUodCl9c2V0Q2VudHJlKHQpe3RoaXMuX2RpbS5zZXRDZW50cmUodCl9Y3JlYXRlQXJjKHQsZSl7Y29uc3Qgbj10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxzPW4uZ2V0V2lkdGgoKS8yLGk9bi5nZXRIZWlnaHQoKS8yLHI9bi5nZXRNaW5YKCkrcyxvPW4uZ2V0TWluWSgpK2k7bGV0IGw9ZTsobDw9MHx8bD4yKk1hdGguUEkpJiYobD0yKk1hdGguUEkpO2NvbnN0IGE9bC8odGhpcy5fblB0cy0xKSxjPW5ldyBBcnJheSh0aGlzLl9uUHRzKS5maWxsKG51bGwpO2xldCBoPTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9uUHRzO2UrKyl7Y29uc3Qgbj10K2UqYSxsPXMqTWF0aC5jb3Mobikrcix1PWkqTWF0aC5zaW4obikrbztjW2grK109dGhpcy5jb29yZChsLHUpfWNvbnN0IHU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZVN0cmluZyhjKTtyZXR1cm4gdGhpcy5yb3RhdGUodSl9cm90YXRlKHQpe2lmKDAhPT10aGlzLl9yb3RhdGlvbkFuZ2xlKXtjb25zdCBlPWxlLnJvdGF0aW9uSW5zdGFuY2UodGhpcy5fcm90YXRpb25BbmdsZSx0aGlzLl9kaW0uZ2V0Q2VudHJlKCkueCx0aGlzLl9kaW0uZ2V0Q2VudHJlKCkueSk7dC5hcHBseShlKX1yZXR1cm4gdH1jb29yZCh0LGUpe2NvbnN0IG49bmV3IGcodCxlKTtyZXR1cm4gdGhpcy5fcHJlY01vZGVsLm1ha2VQcmVjaXNlKG4pLG59Y3JlYXRlQXJjUG9seWdvbih0LGUpe2NvbnN0IG49dGhpcy5fZGltLmdldEVudmVsb3BlKCkscz1uLmdldFdpZHRoKCkvMixpPW4uZ2V0SGVpZ2h0KCkvMixyPW4uZ2V0TWluWCgpK3Msbz1uLmdldE1pblkoKStpO2xldCBsPWU7KGw8PTB8fGw+MipNYXRoLlBJKSYmKGw9MipNYXRoLlBJKTtjb25zdCBhPWwvKHRoaXMuX25QdHMtMSksYz1uZXcgQXJyYXkodGhpcy5fblB0cysyKS5maWxsKG51bGwpO2xldCBoPTA7Y1toKytdPXRoaXMuY29vcmQocixvKTtmb3IobGV0IGU9MDtlPHRoaXMuX25QdHM7ZSsrKXtjb25zdCBuPXQrYSplLGw9cypNYXRoLmNvcyhuKStyLHU9aSpNYXRoLnNpbihuKStvO2NbaCsrXT10aGlzLmNvb3JkKGwsdSl9Y1toKytdPXRoaXMuY29vcmQocixvKTtjb25zdCB1PXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcoYyksZz10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKHUpO3JldHVybiB0aGlzLnJvdGF0ZShnKX1jcmVhdGVSZWN0YW5nbGUoKXtsZXQgdD1udWxsLGU9MCxuPU1hdGgudHJ1bmModGhpcy5fblB0cy80KTtuPDEmJihuPTEpO2NvbnN0IHM9dGhpcy5fZGltLmdldEVudmVsb3BlKCkuZ2V0V2lkdGgoKS9uLGk9dGhpcy5fZGltLmdldEVudmVsb3BlKCkuZ2V0SGVpZ2h0KCkvbixyPW5ldyBBcnJheSg0Km4rMSkuZmlsbChudWxsKSxvPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpO2Zvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1pblgoKSt0KnMsaT1vLmdldE1pblkoKTtyW2UrK109dGhpcy5jb29yZChuLGkpfWZvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1heFgoKSxzPW8uZ2V0TWluWSgpK3QqaTtyW2UrK109dGhpcy5jb29yZChuLHMpfWZvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1heFgoKS10KnMsaT1vLmdldE1heFkoKTtyW2UrK109dGhpcy5jb29yZChuLGkpfWZvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1pblgoKSxzPW8uZ2V0TWF4WSgpLXQqaTtyW2UrK109dGhpcy5jb29yZChuLHMpfXJbZSsrXT1uZXcgZyhyWzBdKTtjb25zdCBsPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcociksYT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGwpO3JldHVybiB0aGlzLnJvdGF0ZShhKX1jcmVhdGVDaXJjbGUoKXtyZXR1cm4gdGhpcy5jcmVhdGVFbGxpcHNlKCl9c2V0SGVpZ2h0KHQpe3RoaXMuX2RpbS5zZXRIZWlnaHQodCl9c2V0U2l6ZSh0KXt0aGlzLl9kaW0uc2V0U2l6ZSh0KX1nZXRDbGFzcygpe3JldHVybiBTZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3Mgd2V7Y29uc3RydWN0b3IoKXt3ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldEJhc2UodCl7dGhpcy5iYXNlPXR9c2V0V2lkdGgodCl7dGhpcy53aWR0aD10fWdldEJhc2UoKXtyZXR1cm4gdGhpcy5iYXNlfWdldFdpZHRoKCl7cmV0dXJuIHRoaXMud2lkdGh9c2V0RW52ZWxvcGUodCl7dGhpcy53aWR0aD10LmdldFdpZHRoKCksdGhpcy5oZWlnaHQ9dC5nZXRIZWlnaHQoKSx0aGlzLmJhc2U9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLHRoaXMuY2VudHJlPW5ldyBnKHQuY2VudHJlKCkpfXNldENlbnRyZSh0KXt0aGlzLmNlbnRyZT10fWdldE1pblNpemUoKXtyZXR1cm4gTWF0aC5taW4odGhpcy53aWR0aCx0aGlzLmhlaWdodCl9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gbnVsbCE9PXRoaXMuYmFzZT9uZXcgTih0aGlzLmJhc2UueCx0aGlzLmJhc2UueCt0aGlzLndpZHRoLHRoaXMuYmFzZS55LHRoaXMuYmFzZS55K3RoaXMuaGVpZ2h0KTpudWxsIT09dGhpcy5jZW50cmU/bmV3IE4odGhpcy5jZW50cmUueC10aGlzLndpZHRoLzIsdGhpcy5jZW50cmUueCt0aGlzLndpZHRoLzIsdGhpcy5jZW50cmUueS10aGlzLmhlaWdodC8yLHRoaXMuY2VudHJlLnkrdGhpcy5oZWlnaHQvMik6bmV3IE4oMCx0aGlzLndpZHRoLDAsdGhpcy5oZWlnaHQpfWdldENlbnRyZSgpe3JldHVybiBudWxsPT09dGhpcy5jZW50cmUmJih0aGlzLmNlbnRyZT1uZXcgZyh0aGlzLmJhc2UueCt0aGlzLndpZHRoLzIsdGhpcy5iYXNlLnkrdGhpcy5oZWlnaHQvMikpLHRoaXMuY2VudHJlfWdldEhlaWdodCgpe3JldHVybiB0aGlzLmhlaWdodH1zZXRIZWlnaHQodCl7dGhpcy5oZWlnaHQ9dH1zZXRTaXplKHQpe3RoaXMuaGVpZ2h0PXQsdGhpcy53aWR0aD10fWdldENsYXNzKCl7cmV0dXJuIHdlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX13ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmJhc2U9bnVsbCx0aGlzLmNlbnRyZT1udWxsLHRoaXMud2lkdGg9bnVsbCx0aGlzLmhlaWdodD1udWxsfSxTZS5EaW1lbnNpb25zPXdlLFNlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fcHJlY01vZGVsPW51bGwsdGhpcy5fZGltPW5ldyB3ZSx0aGlzLl9uUHRzPTEwMCx0aGlzLl9yb3RhdGlvbkFuZ2xlPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpU2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgSHQpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0PXQsdGhpcy5fcHJlY01vZGVsPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKX19O2NsYXNzIExlIGV4dGVuZHMgU2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLExlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0TnVtQXJtcyh0KXt0aGlzLl9udW1Bcm1zPXR9c2V0QXJtTGVuZ3RoUmF0aW8odCl7dGhpcy5fYXJtTGVuZ3RoUmF0aW89dH1jcmVhdGVTaW5lU3Rhcigpe2NvbnN0IHQ9dGhpcy5fZGltLmdldEVudmVsb3BlKCksZT10LmdldFdpZHRoKCkvMjtsZXQgbj10aGlzLl9hcm1MZW5ndGhSYXRpbztuPDAmJihuPTApLG4+MSYmKG49MSk7Y29uc3Qgcz1uKmUsaT0oMS1uKSplLHI9dC5nZXRNaW5YKCkrZSxvPXQuZ2V0TWluWSgpK2UsbD1uZXcgQXJyYXkodGhpcy5fblB0cysxKS5maWxsKG51bGwpO2xldCBhPTA7Zm9yKGxldCB0PTA7dDx0aGlzLl9uUHRzO3QrKyl7Y29uc3QgZT10L3RoaXMuX25QdHMqdGhpcy5fbnVtQXJtcyxuPWUtTWF0aC5mbG9vcihlKSxjPTIqTWF0aC5QSSpuLGg9aStzKigoTWF0aC5jb3MoYykrMSkvMiksdT10KigyKk1hdGguUEkvdGhpcy5fblB0cyksZz1oKk1hdGguY29zKHUpK3IsZD1oKk1hdGguc2luKHUpK287bFthKytdPXRoaXMuY29vcmQoZyxkKX1sW2FdPW5ldyBnKGxbMF0pO2NvbnN0IGM9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhsKTtyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihjKX1nZXRDbGFzcygpe3JldHVybiBMZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbnVtQXJtcz04LHRoaXMuX2FybUxlbmd0aFJhdGlvPS41LDA9PT1hcmd1bWVudHMubGVuZ3RoKVNlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO1NlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fTt2YXIgVGU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQWZmaW5lVHJhbnNmb3JtYXRpb246bGUsQWZmaW5lVHJhbnNmb3JtYXRpb25CdWlsZGVyOmNlLEFmZmluZVRyYW5zZm9ybWF0aW9uRmFjdG9yeTpoZSxDb21wb25lbnRDb29yZGluYXRlRXh0cmFjdGVyOnVlLEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlcjpnZSxHZW9tZXRyeUNvbWJpbmVyOmRlLEdlb21ldHJ5RWRpdG9yOkZ0LEdlb21ldHJ5RXh0cmFjdGVyOl9lLEdlb21ldHJ5TWFwcGVyOnBlLEdlb21ldHJ5VHJhbnNmb3JtZXI6bWUsTGluZVN0cmluZ0V4dHJhY3Rlcjp5ZSxMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXI6eGUsTWFwT3A6ZmUsUG9pbnRFeHRyYWN0ZXI6SWUsUG9seWdvbkV4dHJhY3RlcjpOZSxTaG9ydENpcmN1aXRlZEdlb21ldHJ5VmlzaXRvcjpDZSxTaW5lU3RhckZhY3Rvcnk6TGV9KSxSZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb29yZGluYXRlOmcsQ29vcmRpbmF0ZUxpc3Q6SSxFbnZlbG9wZTpOLExpbmVTZWdtZW50OmVlLEdlb21ldHJ5RmFjdG9yeTpIdCxHZW9tZXRyeTpxLFBvaW50OlB0LExpbmVTdHJpbmc6VHQsTGluZWFyUmluZzpEdCxQb2x5Z29uOmJ0LEdlb21ldHJ5Q29sbGVjdGlvbjpfdCxNdWx0aVBvaW50Ok10LE11bHRpTGluZVN0cmluZzpmdCxNdWx0aVBvbHlnb246QXQsRGltZW5zaW9uOnV0LEludGVyc2VjdGlvbk1hdHJpeDpzZSxQcmVjaXNpb25Nb2RlbDprdCxMb2NhdGlvbjpuZSxUcmlhbmdsZTpyZSx1dGlsOlRlfSk7Y2xhc3MgUGV7Y29uc3RydWN0b3IoKXtQZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0fWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0W3RdfXNldE1pbmltdW0oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRNaW5pbXVtKHQuX3B0WzBdLHQuX3B0WzFdKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLl9pc051bGwpcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZSh0LGUpLG51bGw7Y29uc3Qgbj10LmRpc3RhbmNlKGUpO248dGhpcy5fZGlzdGFuY2UmJnRoaXMuaW5pdGlhbGl6ZSh0LGUsbil9fWluaXRpYWxpemUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9pc051bGw9ITA7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZSh0KSx0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKGUpLHRoaXMuX2Rpc3RhbmNlPXQuZGlzdGFuY2UoZSksdGhpcy5faXNOdWxsPSExfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUodCksdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShlKSx0aGlzLl9kaXN0YW5jZT1uLHRoaXMuX2lzTnVsbD0hMX19dG9TdHJpbmcoKXtyZXR1cm4gSnQudG9MaW5lU3RyaW5nKHRoaXMuX3B0WzBdLHRoaXMuX3B0WzFdKX1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9kaXN0YW5jZX1zZXRNYXhpbXVtKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TWF4aW11bSh0Ll9wdFswXSx0Ll9wdFsxXSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5faXNOdWxsKXJldHVybiB0aGlzLmluaXRpYWxpemUodCxlKSxudWxsO2NvbnN0IG49dC5kaXN0YW5jZShlKTtuPnRoaXMuX2Rpc3RhbmNlJiZ0aGlzLmluaXRpYWxpemUodCxlLG4pfX1nZXRDbGFzcygpe3JldHVybiBQZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHQ9W25ldyBnLG5ldyBnXSx0aGlzLl9kaXN0YW5jZT1pLk5hTix0aGlzLl9pc051bGw9ITB9O2NsYXNzIHZle2NvbnN0cnVjdG9yKCl7dmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tcHV0ZURpc3RhbmNlKCl7aWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBQZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBlZSxpPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoLTE7dCsrKXtzLnNldENvb3JkaW5hdGVzKGlbdF0saVt0KzFdKTtjb25zdCByPXMuY2xvc2VzdFBvaW50KGUpO24uc2V0TWluaW11bShyLGUpfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUGUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dmUuY29tcHV0ZURpc3RhbmNlKHQuZ2V0RXh0ZXJpb3JSaW5nKCksZSxuKTtmb3IobGV0IHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXZlLmNvbXB1dGVEaXN0YW5jZSh0LmdldEludGVyaW9yUmluZ04ocyksZSxuKX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUGUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0IGluc3RhbmNlb2YgVHQpdmUuY29tcHV0ZURpc3RhbmNlKHQsZSxuKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBidCl2ZS5jb21wdXRlRGlzdGFuY2UodCxlLG4pO2Vsc2UgaWYodCBpbnN0YW5jZW9mIF90KXtjb25zdCBzPXQ7Zm9yKGxldCB0PTA7dDxzLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IGk9cy5nZXRHZW9tZXRyeU4odCk7dmUuY29tcHV0ZURpc3RhbmNlKGksZSxuKX19ZWxzZSBuLnNldE1pbmltdW0odC5nZXRDb29yZGluYXRlKCksZSl9ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFBlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9dC5jbG9zZXN0UG9pbnQoZSk7bi5zZXRNaW5pbXVtKHMsZSl9fWdldENsYXNzKCl7cmV0dXJuIHZlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIE9le2NvbnN0cnVjdG9yKCl7T2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGlzdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBPZSh0LGUpLmRpc3RhbmNlKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IE9lKHQsZSk7cmV0dXJuIHMuc2V0RGVuc2lmeUZyYWN0aW9uKG4pLHMuZGlzdGFuY2UoKX19Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHREaXN0LmdldENvb3JkaW5hdGVzKCl9c2V0RGVuc2lmeUZyYWN0aW9uKHQpe2lmKHQ+MXx8dDw9MCl0aHJvdyBuZXcgbihcIkZyYWN0aW9uIGlzIG5vdCBpbiByYW5nZSAoMC4wIC0gMS4wXVwiKTt0aGlzLl9kZW5zaWZ5RnJhYz10fWNvbXB1dGUodCxlKXt0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKHQsZSx0aGlzLl9wdERpc3QpLHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UoZSx0LHRoaXMuX3B0RGlzdCl9ZGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5jb21wdXRlKHRoaXMuX2cwLHRoaXMuX2cxKSx0aGlzLl9wdERpc3QuZ2V0RGlzdGFuY2UoKX1jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0LGUsbil7Y29uc3Qgcz1uZXcgYmUoZSk7aWYodC5hcHBseShzKSxuLnNldE1heGltdW0ocy5nZXRNYXhQb2ludERpc3RhbmNlKCkpLHRoaXMuX2RlbnNpZnlGcmFjPjApe2NvbnN0IHM9bmV3IE1lKGUsdGhpcy5fZGVuc2lmeUZyYWMpO3QuYXBwbHkocyksbi5zZXRNYXhpbXVtKHMuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKX19b3JpZW50ZWREaXN0YW5jZSgpe3JldHVybiB0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKHRoaXMuX2cwLHRoaXMuX2cxLHRoaXMuX3B0RGlzdCksdGhpcy5fcHREaXN0LmdldERpc3RhbmNlKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gT2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGJle2NvbnN0cnVjdG9yKCl7YmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7dGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKSx2ZS5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSx0LHRoaXMuX21pblB0RGlzdCksdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KX1nZXRNYXhQb2ludERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX21heFB0RGlzdH1nZXRDbGFzcygpe3JldHVybiBiZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQl19fWJlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX21heFB0RGlzdD1uZXcgUGUsdGhpcy5fbWluUHREaXN0PW5ldyBQZSx0aGlzLl9ldWNsaWRlYW5EaXN0PW5ldyB2ZSx0aGlzLl9nZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbT10fTtjbGFzcyBNZXtjb25zdHJ1Y3Rvcigpe01lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQsZSl7aWYoMD09PWUpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldENvb3JkaW5hdGUoZS0xKSxzPXQuZ2V0Q29vcmRpbmF0ZShlKSxpPShzLngtbi54KS90aGlzLl9udW1TdWJTZWdzLHI9KHMueS1uLnkpL3RoaXMuX251bVN1YlNlZ3M7Zm9yKGxldCB0PTA7dDx0aGlzLl9udW1TdWJTZWdzO3QrKyl7Y29uc3QgZT1uLngrdCppLHM9bi55K3QqcixvPW5ldyBnKGUscyk7dGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKSx2ZS5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSxvLHRoaXMuX21pblB0RGlzdCksdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KX19aXNEb25lKCl7cmV0dXJuITF9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMX1nZXRNYXhQb2ludERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX21heFB0RGlzdH1nZXRDbGFzcygpe3JldHVybiBNZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZHRdfX1NZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9tYXhQdERpc3Q9bmV3IFBlLHRoaXMuX21pblB0RGlzdD1uZXcgUGUsdGhpcy5fZ2VvbT1udWxsLHRoaXMuX251bVN1YlNlZ3M9MDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tPXQsdGhpcy5fbnVtU3ViU2Vncz1NYXRoLnRydW5jKE1hdGgucm91bmQoMS9lKSl9LE9lLk1heFBvaW50RGlzdGFuY2VGaWx0ZXI9YmUsT2UuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyPU1lLE9lLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2cwPW51bGwsdGhpcy5fZzE9bnVsbCx0aGlzLl9wdERpc3Q9bmV3IFBlLHRoaXMuX2RlbnNpZnlGcmFjPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZzA9dCx0aGlzLl9nMT1lfTt2YXIgRGU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZTpPZSxEaXN0YW5jZVRvUG9pbnQ6dmUsUG9pbnRQYWlyRGlzdGFuY2U6UGV9KTtjbGFzcyBBZXtjb25zdHJ1Y3Rvcigpe0FlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXRJdGVtKHQpe31nZXRDbGFzcygpe3JldHVybiBBZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19QWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBGZXtjb25zdHJ1Y3Rvcigpe0ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bG9jYXRlKHQpe31nZXRDbGFzcygpe3JldHVybiBGZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBHZXtjb25zdHJ1Y3Rvcigpe0dlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TWluKCl7cmV0dXJuIHRoaXMuX21pbn1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuISh0aGlzLl9taW4+ZXx8dGhpcy5fbWF4PHQpfWdldE1heCgpe3JldHVybiB0aGlzLl9tYXh9dG9TdHJpbmcoKXtyZXR1cm4gSnQudG9MaW5lU3RyaW5nKG5ldyBnKHRoaXMuX21pbiwwKSxuZXcgZyh0aGlzLl9tYXgsMCkpfWdldENsYXNzKCl7cmV0dXJuIEdlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBxZXtjb25zdHJ1Y3Rvcigpe3FlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWUsaT0obi5fbWluK24uX21heCkvMixyPShzLl9taW4rcy5fbWF4KS8yO3JldHVybiBpPHI/LTE6aT5yPzE6MH1nZXRDbGFzcygpe3JldHVybiBxZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fXFlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sR2UuTm9kZUNvbXBhcmF0b3I9cWUsR2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbWluPWkuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5fbWF4PWkuTkVHQVRJVkVfSU5GSU5JVFl9O2NsYXNzIEJlIGV4dGVuZHMgR2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLEJlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cXVlcnkodCxlLG4pe2lmKCF0aGlzLmludGVyc2VjdHModCxlKSlyZXR1cm4gbnVsbDtuLnZpc2l0SXRlbSh0aGlzLl9pdGVtKX1nZXRDbGFzcygpe3JldHVybiBCZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19QmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXRlbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX21pbj10LHRoaXMuX21heD1lLHRoaXMuX2l0ZW09bn07Y2xhc3MgVmUgZXh0ZW5kcyBHZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksVmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1idWlsZEV4dGVudCh0LGUpe3RoaXMuX21pbj1NYXRoLm1pbih0Ll9taW4sZS5fbWluKSx0aGlzLl9tYXg9TWF0aC5tYXgodC5fbWF4LGUuX21heCl9cXVlcnkodCxlLG4pe2lmKCF0aGlzLmludGVyc2VjdHModCxlKSlyZXR1cm4gbnVsbDtudWxsIT09dGhpcy5fbm9kZTEmJnRoaXMuX25vZGUxLnF1ZXJ5KHQsZSxuKSxudWxsIT09dGhpcy5fbm9kZTImJnRoaXMuX25vZGUyLnF1ZXJ5KHQsZSxuKX1nZXRDbGFzcygpe3JldHVybiBWZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbm9kZTE9bnVsbCx0aGlzLl9ub2RlMj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX25vZGUxPXQsdGhpcy5fbm9kZTI9ZSx0aGlzLmJ1aWxkRXh0ZW50KHRoaXMuX25vZGUxLHRoaXMuX25vZGUyKX07Y2xhc3MgemV7Y29uc3RydWN0b3IoKXt6ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWJ1aWxkVHJlZSgpe0VlLnNvcnQodGhpcy5fbGVhdmVzLG5ldyBHZS5Ob2RlQ29tcGFyYXRvcik7bGV0IHQ9dGhpcy5fbGVhdmVzLGU9bnVsbCxuPW5ldyB4O2Zvcig7Oyl7aWYodGhpcy5idWlsZExldmVsKHQsbiksMT09PW4uc2l6ZSgpKXJldHVybiBuLmdldCgwKTtlPXQsdD1uLG49ZX19aW5zZXJ0KHQsZSxuKXtpZihudWxsIT09dGhpcy5fcm9vdCl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiSW5kZXggY2Fubm90IGJlIGFkZGVkIHRvIG9uY2UgaXQgaGFzIGJlZW4gcXVlcmllZFwiKTt0aGlzLl9sZWF2ZXMuYWRkKG5ldyBCZSh0LGUsbikpfXF1ZXJ5KHQsZSxuKXt0aGlzLmluaXQoKSx0aGlzLl9yb290LnF1ZXJ5KHQsZSxuKX1idWlsZFJvb3QoKXtpZihudWxsIT09dGhpcy5fcm9vdClyZXR1cm4gbnVsbDt0aGlzLl9yb290PXRoaXMuYnVpbGRUcmVlKCl9cHJpbnROb2RlKHQpe08ub3V0LnByaW50bG4oSnQudG9MaW5lU3RyaW5nKG5ldyBnKHQuX21pbix0aGlzLl9sZXZlbCksbmV3IGcodC5fbWF4LHRoaXMuX2xldmVsKSkpfWluaXQoKXtpZihudWxsIT09dGhpcy5fcm9vdClyZXR1cm4gbnVsbDt0aGlzLmJ1aWxkUm9vdCgpfWJ1aWxkTGV2ZWwodCxlKXt0aGlzLl9sZXZlbCsrLGUuY2xlYXIoKTtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rPTIpe2NvbnN0IHM9dC5nZXQobik7aWYobnVsbD09PShuKzE8dC5zaXplKCk/dC5nZXQobik6bnVsbCkpZS5hZGQocyk7ZWxzZXtjb25zdCBzPW5ldyBWZSh0LmdldChuKSx0LmdldChuKzEpKTtlLmFkZChzKX19fWdldENsYXNzKCl7cmV0dXJuIHplfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX16ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9sZWF2ZXM9bmV3IHgsdGhpcy5fcm9vdD1udWxsLHRoaXMuX2xldmVsPTB9O2NsYXNzIFlle2NvbnN0cnVjdG9yKCl7WWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdEl0ZW0odCl7dGhpcy5faXRlbXMuYWRkKHQpfWdldEl0ZW1zKCl7cmV0dXJuIHRoaXMuX2l0ZW1zfWdldENsYXNzKCl7cmV0dXJuIFllfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19fVllLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2l0ZW1zPW5ldyB4fTtjbGFzcyBVZXtjb25zdHJ1Y3Rvcigpe1VlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGxvY2F0ZVBvaW50SW5SaW5nKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZfKGFyZ3VtZW50c1sxXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgVWUodCkscz1uZXcgZyxpPW5ldyBnO2ZvcihsZXQgdD0xO3Q8ZS5zaXplKCk7dCsrKWlmKGUuZ2V0Q29vcmRpbmF0ZSh0LHMpLGUuZ2V0Q29vcmRpbmF0ZSh0LTEsaSksbi5jb3VudFNlZ21lbnQocyxpKSxuLmlzT25TZWdtZW50KCkpcmV0dXJuIG4uZ2V0TG9jYXRpb24oKTtyZXR1cm4gbi5nZXRMb2NhdGlvbigpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgVWUodCk7Zm9yKGxldCB0PTE7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHM9ZVt0XSxpPWVbdC0xXTtpZihuLmNvdW50U2VnbWVudChzLGkpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpfXJldHVybiBuLmdldExvY2F0aW9uKCl9fWNvdW50U2VnbWVudCh0LGUpe2lmKHQueDx0aGlzLl9wLngmJmUueDx0aGlzLl9wLngpcmV0dXJuIG51bGw7aWYodGhpcy5fcC54PT09ZS54JiZ0aGlzLl9wLnk9PT1lLnkpcmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITAsbnVsbDtpZih0Lnk9PT10aGlzLl9wLnkmJmUueT09PXRoaXMuX3AueSl7bGV0IG49dC54LHM9ZS54O3JldHVybiBuPnMmJihuPWUueCxzPXQueCksdGhpcy5fcC54Pj1uJiZ0aGlzLl9wLng8PXMmJih0aGlzLl9pc1BvaW50T25TZWdtZW50PSEwKSxudWxsfWlmKHQueT50aGlzLl9wLnkmJmUueTw9dGhpcy5fcC55fHxlLnk+dGhpcy5fcC55JiZ0Lnk8PXRoaXMuX3AueSl7bGV0IG49di5pbmRleCh0LGUsdGhpcy5fcCk7aWYobj09PXYuQ09MTElORUFSKXJldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50PSEwLG51bGw7ZS55PHQueSYmKG49LW4pLG49PT12LkxFRlQmJnRoaXMuX2Nyb3NzaW5nQ291bnQrK319aXNQb2ludEluUG9seWdvbigpe3JldHVybiB0aGlzLmdldExvY2F0aW9uKCkhPT1uZS5FWFRFUklPUn1nZXRMb2NhdGlvbigpe3JldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50P25lLkJPVU5EQVJZOnRoaXMuX2Nyb3NzaW5nQ291bnQlMj09MT9uZS5JTlRFUklPUjpuZS5FWFRFUklPUn1pc09uU2VnbWVudCgpe3JldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50fWdldENsYXNzKCl7cmV0dXJuIFVlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1VZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wPW51bGwsdGhpcy5fY3Jvc3NpbmdDb3VudD0wLHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcD10fTtjbGFzcyBrZXtjb25zdHJ1Y3Rvcigpe2tlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bG9jYXRlKHQpe2NvbnN0IGU9bmV3IFVlKHQpLG49bmV3IFhlKGUpO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeSh0LnksdC55LG4pLGUuZ2V0TG9jYXRpb24oKX1nZXRDbGFzcygpe3JldHVybiBrZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRmVdfX1jbGFzcyBYZXtjb25zdHJ1Y3Rvcigpe1hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXRJdGVtKHQpe2NvbnN0IGU9dDt0aGlzLl9jb3VudGVyLmNvdW50U2VnbWVudChlLmdldENvb3JkaW5hdGUoMCksZS5nZXRDb29yZGluYXRlKDEpKX1nZXRDbGFzcygpe3JldHVybiBYZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQWVdfX1YZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb3VudGVyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY291bnRlcj10fTtjbGFzcyBIZXtjb25zdHJ1Y3Rvcigpe0hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5pdCh0KXtmb3IobGV0IGU9eGUuZ2V0TGluZXModCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCkuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmFkZExpbmUodCl9fWFkZExpbmUodCl7Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49bmV3IGVlKHRbZS0xXSx0W2VdKSxzPU1hdGgubWluKG4ucDAueSxuLnAxLnkpLGk9TWF0aC5tYXgobi5wMC55LG4ucDEueSk7dGhpcy5faW5kZXguaW5zZXJ0KHMsaSxuKX19cXVlcnkoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgWWU7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHQsZSxuKSxuLmdldEl0ZW1zKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2luZGV4LnF1ZXJ5KHQsZSxuKX19Z2V0Q2xhc3MoKXtyZXR1cm4gSGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUhlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2luZGV4PW5ldyB6ZTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9LGtlLlNlZ21lbnRWaXNpdG9yPVhlLGtlLkludGVydmFsSW5kZXhlZEdlb21ldHJ5PUhlLGtlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2luZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoIShfKHQsT3QpfHx0IGluc3RhbmNlb2YgRHQpKXRocm93IG5ldyBuKFwiQXJndW1lbnQgbXVzdCBiZSBQb2x5Z29uYWwgb3IgTGluZWFyUmluZ1wiKTt0aGlzLl9pbmRleD1uZXcgSGUodCl9O2NsYXNzIFdle2NvbnN0cnVjdG9yKCl7V2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNPbkxpbmUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJl8oYXJndW1lbnRzWzFdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB0ZSxzPW5ldyBnLGk9bmV3IGcscj1lLnNpemUoKTtmb3IobGV0IG89MTtvPHI7bysrKWlmKGUuZ2V0Q29vcmRpbmF0ZShvLTEscyksZS5nZXRDb29yZGluYXRlKG8saSksbi5jb21wdXRlSW50ZXJzZWN0aW9uKHQscyxpKSxuLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiEwO3JldHVybiExfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgdGU7Zm9yKGxldCBzPTE7czxlLmxlbmd0aDtzKyspe2NvbnN0IGk9ZVtzLTFdLHI9ZVtzXTtpZihuLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxpLHIpLG4uaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuITB9cmV0dXJuITF9fXN0YXRpYyBsb2NhdGVJblJpbmcodCxlKXtyZXR1cm4gVWUubG9jYXRlUG9pbnRJblJpbmcodCxlKX1zdGF0aWMgaXNJblJpbmcodCxlKXtyZXR1cm4gV2UubG9jYXRlSW5SaW5nKHQsZSkhPT1uZS5FWFRFUklPUn1nZXRDbGFzcygpe3JldHVybiBXZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gamUoKXt9V2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxqZS5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe30samUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXt9LGplLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt9O2NsYXNzIEtle2NvbnN0cnVjdG9yKCl7S2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNBdG9taWModCl7cmV0dXJuISh0IGluc3RhbmNlb2YgX3QpfW5leHQoKXtpZih0aGlzLl9hdFN0YXJ0KXJldHVybiB0aGlzLl9hdFN0YXJ0PSExLEtlLmlzQXRvbWljKHRoaXMuX3BhcmVudCkmJnRoaXMuX2luZGV4KyssdGhpcy5fcGFyZW50O2lmKG51bGwhPT10aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3Ipe2lmKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCk7dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGx9aWYodGhpcy5faW5kZXg+PXRoaXMuX21heCl0aHJvdyBuZXcgeTtjb25zdCB0PXRoaXMuX3BhcmVudC5nZXRHZW9tZXRyeU4odGhpcy5faW5kZXgrKyk7cmV0dXJuIHQgaW5zdGFuY2VvZiBfdD8odGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW5ldyBLZSh0KSx0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpKTp0fXJlbW92ZSgpe3Rocm93IG5ldyBaKHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfWhhc05leHQoKXtpZih0aGlzLl9hdFN0YXJ0KXJldHVybiEwO2lmKG51bGwhPT10aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3Ipe2lmKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuITA7dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGx9cmV0dXJuISh0aGlzLl9pbmRleD49dGhpcy5fbWF4KX1nZXRDbGFzcygpe3JldHVybiBLZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bamVdfX1LZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wYXJlbnQ9bnVsbCx0aGlzLl9hdFN0YXJ0PW51bGwsdGhpcy5fbWF4PW51bGwsdGhpcy5faW5kZXg9bnVsbCx0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wYXJlbnQ9dCx0aGlzLl9hdFN0YXJ0PSEwLHRoaXMuX2luZGV4PTAsdGhpcy5fbWF4PXQuZ2V0TnVtR2VvbWV0cmllcygpfTtjbGFzcyBaZXtjb25zdHJ1Y3Rvcigpe1plLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGxvY2F0ZVBvaW50SW5Qb2x5Z29uKHQsZSl7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG5lLkVYVEVSSU9SO2NvbnN0IG49ZS5nZXRFeHRlcmlvclJpbmcoKSxzPVplLmxvY2F0ZVBvaW50SW5SaW5nKHQsbik7aWYocyE9PW5lLklOVEVSSU9SKXJldHVybiBzO2ZvcihsZXQgbj0wO248ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtuKyspe2NvbnN0IHM9ZS5nZXRJbnRlcmlvclJpbmdOKG4pLGk9WmUubG9jYXRlUG9pbnRJblJpbmcodCxzKTtpZihpPT09bmUuQk9VTkRBUlkpcmV0dXJuIG5lLkJPVU5EQVJZO2lmKGk9PT1uZS5JTlRFUklPUilyZXR1cm4gbmUuRVhURVJJT1J9cmV0dXJuIG5lLklOVEVSSU9SfXN0YXRpYyBsb2NhdGVQb2ludEluUmluZyh0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP1dlLmxvY2F0ZUluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSk6bmUuRVhURVJJT1J9c3RhdGljIGNvbnRhaW5zUG9pbnRJblBvbHlnb24odCxlKXtyZXR1cm4gbmUuRVhURVJJT1IhPT1aZS5sb2NhdGVQb2ludEluUG9seWdvbih0LGUpfXN0YXRpYyBsb2NhdGVJbkdlb21ldHJ5KHQsZSl7aWYoZSBpbnN0YW5jZW9mIGJ0KXJldHVybiBaZS5sb2NhdGVQb2ludEluUG9seWdvbih0LGUpO2lmKGUgaW5zdGFuY2VvZiBfdCl7Y29uc3Qgbj1uZXcgS2UoZSk7Zm9yKDtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocyE9PWUpe2NvbnN0IGU9WmUubG9jYXRlSW5HZW9tZXRyeSh0LHMpO2lmKGUhPT1uZS5FWFRFUklPUilyZXR1cm4gZX19fXJldHVybiBuZS5FWFRFUklPUn1zdGF0aWMgbG9jYXRlKHQsZSl7cmV0dXJuIGUuaXNFbXB0eSgpP25lLkVYVEVSSU9SOlplLmxvY2F0ZUluR2VvbWV0cnkodCxlKX1sb2NhdGUodCl7cmV0dXJuIFplLmxvY2F0ZSh0LHRoaXMuX2dlb20pfWdldENsYXNzKCl7cmV0dXJuIFplfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltGZV19fVplLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tPXR9O3ZhciBRZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxJbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yOmtlLFBvaW50T25HZW9tZXRyeUxvY2F0b3I6RmUsU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yOlplfSk7Y2xhc3MgSmV7Y29uc3RydWN0b3IoKXtKZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfW1lYXN1cmUodCxlKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gSmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUplLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgJGV7Y29uc3RydWN0b3IoKXskZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfW1lYXN1cmUodCxlKXtyZXR1cm4gdC5pbnRlcnNlY3Rpb24oZSkuZ2V0QXJlYSgpL3QudW5pb24oZSkuZ2V0QXJlYSgpfWdldENsYXNzKCl7cmV0dXJuICRlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKZV19fSRlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgdG57Y29uc3RydWN0b3IoKXt0bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkaWFnb25hbFNpemUodCl7aWYodC5pc051bGwoKSlyZXR1cm4gMDtjb25zdCBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCk7cmV0dXJuIE1hdGguc3FydChlKmUrbipuKX1tZWFzdXJlKHQsZSl7Y29uc3Qgbj1PZS5kaXN0YW5jZSh0LGUsdG4uREVOU0lGWV9GUkFDVElPTikscz1uZXcgTih0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIHMuZXhwYW5kVG9JbmNsdWRlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSwxLW4vdG4uZGlhZ29uYWxTaXplKHMpfWdldENsYXNzKCl7cmV0dXJuIHRufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKZV19fXRuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sdG4uREVOU0lGWV9GUkFDVElPTj0uMjU7Y2xhc3MgZW57Y29uc3RydWN0b3IoKXtlbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21iaW5lKHQsZSl7cmV0dXJuIE1hdGgubWluKHQsZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gZW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWVuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307dmFyIG5uPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFyZWFTaW1pbGFyaXR5TWVhc3VyZTokZSxIYXVzZG9yZmZTaW1pbGFyaXR5TWVhc3VyZTp0bixTaW1pbGFyaXR5TWVhc3VyZTpKZSxTaW1pbGFyaXR5TWVhc3VyZUNvbWJpbmVyOmVufSk7Y2xhc3Mgc257Y29uc3RydWN0b3IoKXtzbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBhcmVhMih0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0obi54LXQueCkqKGUueS10LnkpfXN0YXRpYyBjZW50cm9pZDModCxlLG4scyl7cmV0dXJuIHMueD10LngrZS54K24ueCxzLnk9dC55K2UueStuLnksbnVsbH1zdGF0aWMgZ2V0Q2VudHJvaWQodCl7cmV0dXJuIG5ldyBzbih0KS5nZXRDZW50cm9pZCgpfXNldEFyZWFCYXNlUG9pbnQodCl7dGhpcy5fYXJlYUJhc2VQdD10fWFkZFBvaW50KHQpe3RoaXMuX3B0Q291bnQrPTEsdGhpcy5fcHRDZW50U3VtLngrPXQueCx0aGlzLl9wdENlbnRTdW0ueSs9dC55fWFkZExpbmVTZWdtZW50cyh0KXtsZXQgZT0wO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspe2NvbnN0IHM9dFtuXS5kaXN0YW5jZSh0W24rMV0pO2lmKDA9PT1zKWNvbnRpbnVlO2UrPXM7Y29uc3QgaT0odFtuXS54K3RbbisxXS54KS8yO3RoaXMuX2xpbmVDZW50U3VtLngrPXMqaTtjb25zdCByPSh0W25dLnkrdFtuKzFdLnkpLzI7dGhpcy5fbGluZUNlbnRTdW0ueSs9cypyfXRoaXMuX3RvdGFsTGVuZ3RoKz1lLDA9PT1lJiZ0Lmxlbmd0aD4wJiZ0aGlzLmFkZFBvaW50KHRbMF0pfWFkZEhvbGUodCl7Y29uc3QgZT12LmlzQ0NXKHQpO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLl9hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfWdldENlbnRyb2lkKCl7Y29uc3QgdD1uZXcgZztpZihNYXRoLmFicyh0aGlzLl9hcmVhc3VtMik+MCl0Lng9dGhpcy5fY2czLngvMy90aGlzLl9hcmVhc3VtMix0Lnk9dGhpcy5fY2czLnkvMy90aGlzLl9hcmVhc3VtMjtlbHNlIGlmKHRoaXMuX3RvdGFsTGVuZ3RoPjApdC54PXRoaXMuX2xpbmVDZW50U3VtLngvdGhpcy5fdG90YWxMZW5ndGgsdC55PXRoaXMuX2xpbmVDZW50U3VtLnkvdGhpcy5fdG90YWxMZW5ndGg7ZWxzZXtpZighKHRoaXMuX3B0Q291bnQ+MCkpcmV0dXJuIG51bGw7dC54PXRoaXMuX3B0Q2VudFN1bS54L3RoaXMuX3B0Q291bnQsdC55PXRoaXMuX3B0Q2VudFN1bS55L3RoaXMuX3B0Q291bnR9cmV0dXJuIHR9YWRkU2hlbGwodCl7dC5sZW5ndGg+MCYmdGhpcy5zZXRBcmVhQmFzZVBvaW50KHRbMF0pO2NvbnN0IGU9IXYuaXNDQ1codCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl0aGlzLmFkZFRyaWFuZ2xlKHRoaXMuX2FyZWFCYXNlUHQsdFtuXSx0W24rMV0sZSk7dGhpcy5hZGRMaW5lU2VnbWVudHModCl9YWRkVHJpYW5nbGUodCxlLG4scyl7Y29uc3QgaT1zPzE6LTE7c24uY2VudHJvaWQzKHQsZSxuLHRoaXMuX3RyaWFuZ2xlQ2VudDMpO2NvbnN0IHI9c24uYXJlYTIodCxlLG4pO3RoaXMuX2NnMy54Kz1pKnIqdGhpcy5fdHJpYW5nbGVDZW50My54LHRoaXMuX2NnMy55Kz1pKnIqdGhpcy5fdHJpYW5nbGVDZW50My55LHRoaXMuX2FyZWFzdW0yKz1pKnJ9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBidCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGRTaGVsbCh0LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspdGhpcy5hZGRIb2xlKHQuZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkUG9pbnQodC5nZXRDb29yZGluYXRlKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkTGluZVNlZ21lbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgYnQpe2NvbnN0IGU9dDt0aGlzLmFkZChlKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBfdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKHQpKX19fWdldENsYXNzKCl7cmV0dXJuIHNufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBybih0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBvbigpe3RoaXMuYXJyYXlfPVtdfXNuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2FyZWFCYXNlUHQ9bnVsbCx0aGlzLl90cmlhbmdsZUNlbnQzPW5ldyBnLHRoaXMuX2FyZWFzdW0yPTAsdGhpcy5fY2czPW5ldyBnLHRoaXMuX2xpbmVDZW50U3VtPW5ldyBnLHRoaXMuX3RvdGFsTGVuZ3RoPTAsdGhpcy5fcHRDb3VudD0wLHRoaXMuX3B0Q2VudFN1bT1uZXcgZztjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9hcmVhQmFzZVB0PW51bGwsdGhpcy5hZGQodCl9LHJuLnByb3RvdHlwZT1uZXcgRXJyb3Iscm4ucHJvdG90eXBlLm5hbWU9XCJFbXB0eVN0YWNrRXhjZXB0aW9uXCIsb24ucHJvdG90eXBlPW5ldyBtLG9uLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLnB1c2godCksITB9LG9uLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7aWYodDwwfHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgcDtyZXR1cm4gdGhpcy5hcnJheV9bdF19LG9uLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLHR9LG9uLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMuYXJyYXlfLmxlbmd0aCl0aHJvdyBuZXcgcm47cmV0dXJuIHRoaXMuYXJyYXlfLnBvcCgpfSxvbi5wcm90b3R5cGUucGVlaz1mdW5jdGlvbigpe2lmKDA9PT10aGlzLmFycmF5Xy5sZW5ndGgpdGhyb3cgbmV3IHJuO3JldHVybiB0aGlzLmFycmF5X1t0aGlzLmFycmF5Xy5sZW5ndGgtMV19LG9uLnByb3RvdHlwZS5lbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxvbi5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVtcHR5KCl9LG9uLnByb3RvdHlwZS5zZWFyY2g9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLmluZGV4T2YodCl9LG9uLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sb24ucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO2U8bjtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH07Y2xhc3MgbG57Y29uc3RydWN0b3IoKXtsbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaWx0ZXJDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBsbjtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllLmZpbHRlcih0W25dKTtyZXR1cm4gZS5nZXRDb29yZGluYXRlcygpfWZpbHRlcih0KXt0aGlzLnRyZWVTZXQuY29udGFpbnModCl8fCh0aGlzLmxpc3QuYWRkKHQpLHRoaXMudHJlZVNldC5hZGQodCkpfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5saXN0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdGhpcy5saXN0LnRvQXJyYXkodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gbG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0JdfX1sbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLnRyZWVTZXQ9bmV3IGF0LHRoaXMubGlzdD1uZXcgeH07Y2xhc3MgYW57Y29uc3RydWN0b3IoKXthbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBleHRyYWN0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgbG47cmV0dXJuIHQuYXBwbHkoZSksZS5nZXRDb29yZGluYXRlcygpfXByZVNvcnQodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKykodFtuXS55PHRbMF0ueXx8dFtuXS55PT09dFswXS55JiZ0W25dLng8dFswXS54KSYmKGU9dFswXSx0WzBdPXRbbl0sdFtuXT1lKTtyZXR1cm4gaHQuc29ydCh0LDEsdC5sZW5ndGgsbmV3IGNuKHRbMF0pKSx0fWNvbXB1dGVPY3RSaW5nKHQpe2NvbnN0IGU9dGhpcy5jb21wdXRlT2N0UHRzKHQpLG49bmV3IEk7cmV0dXJuIG4uYWRkKGUsITEpLG4uc2l6ZSgpPDM/bnVsbDoobi5jbG9zZVJpbmcoKSxuLnRvQ29vcmRpbmF0ZUFycmF5KCkpfWxpbmVPclBvbHlnb24odCl7aWYoMz09PSh0PXRoaXMuY2xlYW5SaW5nKHQpKS5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoW3RbMF0sdFsxXV0pO2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KTtyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlUG9seWdvbihlKX1jbGVhblJpbmcodCl7dS5lcXVhbHModFswXSx0W3QubGVuZ3RoLTFdKTtjb25zdCBlPW5ldyB4O2xldCBuPW51bGw7Zm9yKGxldCBzPTA7czw9dC5sZW5ndGgtMjtzKyspe2NvbnN0IGk9dFtzXSxyPXRbcysxXTtpLmVxdWFscyhyKXx8KG51bGwhPT1uJiZ0aGlzLmlzQmV0d2VlbihuLGkscil8fChlLmFkZChpKSxuPWkpKX1lLmFkZCh0W3QubGVuZ3RoLTFdKTtjb25zdCBzPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gZS50b0FycmF5KHMpfWlzQmV0d2Vlbih0LGUsbil7aWYoMCE9PXYuaW5kZXgodCxlLG4pKXJldHVybiExO2lmKHQueCE9PW4ueCl7aWYodC54PD1lLngmJmUueDw9bi54KXJldHVybiEwO2lmKG4ueDw9ZS54JiZlLng8PXQueClyZXR1cm4hMH1pZih0LnkhPT1uLnkpe2lmKHQueTw9ZS55JiZlLnk8PW4ueSlyZXR1cm4hMDtpZihuLnk8PWUueSYmZS55PD10LnkpcmV0dXJuITB9cmV0dXJuITF9cmVkdWNlKHQpe2NvbnN0IGU9dGhpcy5jb21wdXRlT2N0UmluZyh0KTtpZihudWxsPT09ZSlyZXR1cm4gdDtjb25zdCBuPW5ldyBhdDtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyluLmFkZChlW3RdKTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKylXZS5pc0luUmluZyh0W3NdLGUpfHxuLmFkZCh0W3NdKTtjb25zdCBzPVgudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHMubGVuZ3RoPDM/dGhpcy5wYWRBcnJheTMocyk6c31nZXRDb252ZXhIdWxsKCl7aWYoMD09PXRoaXMuX2lucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7aWYoMT09PXRoaXMuX2lucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy5faW5wdXRQdHNbMF0pO2lmKDI9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5faW5wdXRQdHMpO2xldCB0PXRoaXMuX2lucHV0UHRzO3RoaXMuX2lucHV0UHRzLmxlbmd0aD41MCYmKHQ9dGhpcy5yZWR1Y2UodGhpcy5faW5wdXRQdHMpKTtjb25zdCBlPXRoaXMucHJlU29ydCh0KSxuPXRoaXMuZ3JhaGFtU2NhbihlKSxzPXRoaXMudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHRoaXMubGluZU9yUG9seWdvbihzKX1wYWRBcnJheTModCl7Y29uc3QgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyluPHQubGVuZ3RoP2Vbbl09dFtuXTplW25dPXRbMF07cmV0dXJuIGV9Y29tcHV0ZU9jdFB0cyh0KXtjb25zdCBlPW5ldyBBcnJheSg4KS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dFswXTtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl0W25dLng8ZVswXS54JiYoZVswXT10W25dKSx0W25dLngtdFtuXS55PGVbMV0ueC1lWzFdLnkmJihlWzFdPXRbbl0pLHRbbl0ueT5lWzJdLnkmJihlWzJdPXRbbl0pLHRbbl0ueCt0W25dLnk+ZVszXS54K2VbM10ueSYmKGVbM109dFtuXSksdFtuXS54PmVbNF0ueCYmKGVbNF09dFtuXSksdFtuXS54LXRbbl0ueT5lWzVdLngtZVs1XS55JiYoZVs1XT10W25dKSx0W25dLnk8ZVs2XS55JiYoZVs2XT10W25dKSx0W25dLngrdFtuXS55PGVbN10ueCtlWzddLnkmJihlWzddPXRbbl0pO3JldHVybiBlfXRvQ29vcmRpbmF0ZUFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKXtjb25zdCBzPXQuZ2V0KG4pO2Vbbl09c31yZXR1cm4gZX1ncmFoYW1TY2FuKHQpe2xldCBlPW51bGw7Y29uc3Qgbj1uZXcgb247bi5wdXNoKHRbMF0pLG4ucHVzaCh0WzFdKSxuLnB1c2godFsyXSk7Zm9yKGxldCBzPTM7czx0Lmxlbmd0aDtzKyspe2ZvcihlPW4ucG9wKCk7IW4uZW1wdHkoKSYmdi5pbmRleChuLnBlZWsoKSxlLHRbc10pPjA7KWU9bi5wb3AoKTtuLnB1c2goZSksbi5wdXNoKHRbc10pfXJldHVybiBuLnB1c2godFswXSksbn1nZXRDbGFzcygpe3JldHVybiBhbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgY257Y29uc3RydWN0b3IoKXtjbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBwb2xhckNvbXBhcmUodCxlLG4pe2NvbnN0IHM9ZS54LXQueCxpPWUueS10Lnkscj1uLngtdC54LG89bi55LXQueSxsPXYuaW5kZXgodCxlLG4pO2lmKGw9PT12LkNPVU5URVJDTE9DS1dJU0UpcmV0dXJuIDE7aWYobD09PXYuQ0xPQ0tXSVNFKXJldHVybi0xO2NvbnN0IGE9cypzK2kqaSxjPXIqcitvKm87cmV0dXJuIGE8Yz8tMTphPmM/MTowfWNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO3JldHVybiBjbi5wb2xhckNvbXBhcmUodGhpcy5fb3JpZ2luLG4scyl9Z2V0Q2xhc3MoKXtyZXR1cm4gY259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1jbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9vcmlnaW49bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9vcmlnaW49dH0sYW4uUmFkaWFsQ29tcGFyYXRvcj1jbixhbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9nZW9tRmFjdG9yeT1udWxsLHRoaXMuX2lucHV0UHRzPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2FuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsYW4uZXh0cmFjdENvb3JkaW5hdGVzKHQpLHQuZ2V0RmFjdG9yeSgpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbnB1dFB0cz1sbi5maWx0ZXJDb29yZGluYXRlcyh0KSx0aGlzLl9nZW9tRmFjdG9yeT1lfX07Y2xhc3MgaG57Y29uc3RydWN0b3IoKXtobi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjZW50cmUodCl7cmV0dXJuIG5ldyBnKGhuLmF2Zyh0LmdldE1pblgoKSx0LmdldE1heFgoKSksaG4uYXZnKHQuZ2V0TWluWSgpLHQuZ2V0TWF4WSgpKSl9c3RhdGljIGF2Zyh0LGUpe3JldHVybih0K2UpLzJ9YWRkUG9seWdvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtsZXQgZT1udWxsLG49bnVsbDtjb25zdCBzPXRoaXMuaG9yaXpvbnRhbEJpc2VjdG9yKHQpO2lmKDA9PT1zLmdldExlbmd0aCgpKW49MCxlPXMuZ2V0Q29vcmRpbmF0ZSgpO2Vsc2V7Y29uc3QgaT1zLmludGVyc2VjdGlvbih0KSxyPXRoaXMud2lkZXN0R2VvbWV0cnkoaSk7bj1yLmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRXaWR0aCgpLGU9aG4uY2VudHJlKHIuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX0obnVsbD09PXRoaXMuX2ludGVyaW9yUG9pbnR8fG4+dGhpcy5fbWF4V2lkdGgpJiYodGhpcy5faW50ZXJpb3JQb2ludD1lLHRoaXMuX21heFdpZHRoPW4pfWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH13aWRlc3RHZW9tZXRyeSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgX3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNFbXB0eSgpKXJldHVybiB0O2xldCBlPXQuZ2V0R2VvbWV0cnlOKDApO2ZvcihsZXQgbj0xO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXQuZ2V0R2VvbWV0cnlOKG4pLmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRXaWR0aCgpPmUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCkmJihlPXQuZ2V0R2VvbWV0cnlOKG4pKTtyZXR1cm4gZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0IGluc3RhbmNlb2YgX3Q/dGhpcy53aWRlc3RHZW9tZXRyeSh0KTp0fX1ob3Jpem9udGFsQmlzZWN0b3IodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxuPXVuLmdldEJpc2VjdG9yWSh0KTtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKFtuZXcgZyhlLmdldE1pblgoKSxuKSxuZXcgZyhlLmdldE1heFgoKSxuKV0pfWFkZCh0KXtpZih0IGluc3RhbmNlb2YgYnQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIF90KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4odCkpfX1nZXRDbGFzcygpe3JldHVybiBobn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgdW57Y29uc3RydWN0b3IoKXt1bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRCaXNlY3RvclkodCl7cmV0dXJuIG5ldyB1bih0KS5nZXRCaXNlY3RvclkoKX11cGRhdGVJbnRlcnZhbCh0KXt0PD10aGlzLl9jZW50cmVZP3Q+dGhpcy5fbG9ZJiYodGhpcy5fbG9ZPXQpOnQ+dGhpcy5fY2VudHJlWSYmdDx0aGlzLl9oaVkmJih0aGlzLl9oaVk9dCl9Z2V0QmlzZWN0b3JZKCl7dGhpcy5wcm9jZXNzKHRoaXMuX3BvbHkuZ2V0RXh0ZXJpb3JSaW5nKCkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTt0KyspdGhpcy5wcm9jZXNzKHRoaXMuX3BvbHkuZ2V0SW50ZXJpb3JSaW5nTih0KSk7cmV0dXJuIGhuLmF2Zyh0aGlzLl9oaVksdGhpcy5fbG9ZKX1wcm9jZXNzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgbj1lLmdldFkodCk7dGhpcy51cGRhdGVJbnRlcnZhbChuKX19Z2V0Q2xhc3MoKXtyZXR1cm4gdW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXVuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3BvbHk9bnVsbCx0aGlzLl9jZW50cmVZPW51bGwsdGhpcy5faGlZPWkuTUFYX1ZBTFVFLHRoaXMuX2xvWT0taS5NQVhfVkFMVUU7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcG9seT10LHRoaXMuX2hpWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNYXhZKCksdGhpcy5fbG9ZPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldE1pblkoKSx0aGlzLl9jZW50cmVZPWhuLmF2Zyh0aGlzLl9sb1ksdGhpcy5faGlZKX0saG4uU2FmZUJpc2VjdG9yRmluZGVyPXVuLGhuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9pbnRlcmlvclBvaW50PW51bGwsdGhpcy5fbWF4V2lkdGg9MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLHRoaXMuYWRkKHQpfTtjbGFzcyBnbntjb25zdHJ1Y3Rvcigpe2duLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkRW5kcG9pbnRzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRFbmRwb2ludHModC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBfdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkRW5kcG9pbnRzKGUuZ2V0R2VvbWV0cnlOKHQpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0WzBdKSx0aGlzLmFkZCh0W3QubGVuZ3RoLTFdKX19Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fWFkZEludGVyaW9yKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRJbnRlcmlvcih0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIF90KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGRJbnRlcmlvcihlLmdldEdlb21ldHJ5Tih0KSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aC0xO2UrKyl0aGlzLmFkZCh0W2VdKX19YWRkKHQpe2NvbnN0IGU9dC5kaXN0YW5jZSh0aGlzLl9jZW50cm9pZCk7ZTx0aGlzLl9taW5EaXN0YW5jZSYmKHRoaXMuX2ludGVyaW9yUG9pbnQ9bmV3IGcodCksdGhpcy5fbWluRGlzdGFuY2U9ZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gZ259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWduLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2NlbnRyb2lkPW51bGwsdGhpcy5fbWluRGlzdGFuY2U9aS5NQVhfVkFMVUUsdGhpcy5faW50ZXJpb3JQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuaXNFbXB0eSgpP3RoaXMuX2NlbnRyb2lkPW5ldyBnOnRoaXMuX2NlbnRyb2lkPXNuLmdldENlbnRyb2lkKHQpLHRoaXMuYWRkSW50ZXJpb3IodCksbnVsbD09PXRoaXMuX2ludGVyaW9yUG9pbnQmJnRoaXMuYWRkRW5kcG9pbnRzKHQpfTtjbGFzcyBkbntjb25zdHJ1Y3Rvcigpe2RuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBfdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKHQpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5kaXN0YW5jZSh0aGlzLl9jZW50cm9pZCk7ZTx0aGlzLl9taW5EaXN0YW5jZSYmKHRoaXMuX2ludGVyaW9yUG9pbnQ9bmV3IGcodCksdGhpcy5fbWluRGlzdGFuY2U9ZSl9fWdldENsYXNzKCl7cmV0dXJuIGRufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1kbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jZW50cm9pZD1udWxsLHRoaXMuX21pbkRpc3RhbmNlPWkuTUFYX1ZBTFVFLHRoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jZW50cm9pZD10LmdldENlbnRyb2lkKCkuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuYWRkKHQpfTtjbGFzcyBfbntjb25zdHJ1Y3Rvcigpe19uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bG9jYXRlSW5Qb2x5Z29uUmluZyh0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP1dlLmxvY2F0ZUluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSk6bmUuRVhURVJJT1J9aW50ZXJzZWN0cyh0LGUpe3JldHVybiB0aGlzLmxvY2F0ZSh0LGUpIT09bmUuRVhURVJJT1J9dXBkYXRlTG9jYXRpb25JbmZvKHQpe3Q9PT1uZS5JTlRFUklPUiYmKHRoaXMuX2lzSW49ITApLHQ9PT1uZS5CT1VOREFSWSYmdGhpcy5fbnVtQm91bmRhcmllcysrfWNvbXB1dGVMb2NhdGlvbih0LGUpe2lmKGUgaW5zdGFuY2VvZiBQdCYmdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVPblBvaW50KHQsZSkpLGUgaW5zdGFuY2VvZiBUdCl0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LGUpKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBidCl0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUluUG9seWdvbih0LGUpKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBmdCl7Y29uc3Qgbj1lO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPW4uZ2V0R2VvbWV0cnlOKGUpO3RoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlT25MaW5lU3RyaW5nKHQscykpfX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBBdCl7Y29uc3Qgbj1lO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPW4uZ2V0R2VvbWV0cnlOKGUpO3RoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW5Qb2x5Z29uKHQscykpfX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBfdCl7Y29uc3Qgbj1uZXcgS2UoZSk7Zm9yKDtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cyE9PWUmJnRoaXMuY29tcHV0ZUxvY2F0aW9uKHQscyl9fX1sb2NhdGVPblBvaW50KHQsZSl7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQpP25lLklOVEVSSU9SOm5lLkVYVEVSSU9SfWxvY2F0ZU9uTGluZVN0cmluZyh0LGUpe2lmKCFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpKXJldHVybiBuZS5FWFRFUklPUjtjb25zdCBuPWUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7cmV0dXJuIGUuaXNDbG9zZWQoKXx8IXQuZXF1YWxzKG4uZ2V0Q29vcmRpbmF0ZSgwKSkmJiF0LmVxdWFscyhuLmdldENvb3JkaW5hdGUobi5zaXplKCktMSkpP1dlLmlzT25MaW5lKHQsbik/bmUuSU5URVJJT1I6bmUuRVhURVJJT1I6bmUuQk9VTkRBUll9bG9jYXRlSW5Qb2x5Z29uKHQsZSl7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG5lLkVYVEVSSU9SO2NvbnN0IG49ZS5nZXRFeHRlcmlvclJpbmcoKSxzPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LG4pO2lmKHM9PT1uZS5FWFRFUklPUilyZXR1cm4gbmUuRVhURVJJT1I7aWYocz09PW5lLkJPVU5EQVJZKXJldHVybiBuZS5CT1VOREFSWTtmb3IobGV0IG49MDtuPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bisrKXtjb25zdCBzPWUuZ2V0SW50ZXJpb3JSaW5nTihuKSxpPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LHMpO2lmKGk9PT1uZS5JTlRFUklPUilyZXR1cm4gbmUuRVhURVJJT1I7aWYoaT09PW5lLkJPVU5EQVJZKXJldHVybiBuZS5CT1VOREFSWX1yZXR1cm4gbmUuSU5URVJJT1J9bG9jYXRlKHQsZSl7cmV0dXJuIGUuaXNFbXB0eSgpP25lLkVYVEVSSU9SOmUgaW5zdGFuY2VvZiBUdD90aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LGUpOmUgaW5zdGFuY2VvZiBidD90aGlzLmxvY2F0ZUluUG9seWdvbih0LGUpOih0aGlzLl9pc0luPSExLHRoaXMuX251bUJvdW5kYXJpZXM9MCx0aGlzLmNvbXB1dGVMb2NhdGlvbih0LGUpLHRoaXMuX2JvdW5kYXJ5UnVsZS5pc0luQm91bmRhcnkodGhpcy5fbnVtQm91bmRhcmllcyk/bmUuQk9VTkRBUlk6dGhpcy5fbnVtQm91bmRhcmllcz4wfHx0aGlzLl9pc0luP25lLklOVEVSSU9SOm5lLkVYVEVSSU9SKX1nZXRDbGFzcygpe3JldHVybiBfbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19X24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fYm91bmRhcnlSdWxlPVYuT0dDX1NGU19CT1VOREFSWV9SVUxFLHRoaXMuX2lzSW49bnVsbCx0aGlzLl9udW1Cb3VuZGFyaWVzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXRocm93IG5ldyBuKFwiUnVsZSBtdXN0IGJlIG5vbi1udWxsXCIpO3RoaXMuX2JvdW5kYXJ5UnVsZT10fX07Y2xhc3MgZm57Y29uc3RydWN0b3IoKXtmbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBwb2ludFdpdE1pbkFuZ2xlV2l0aFgodCxlKXtsZXQgbj1pLk1BWF9WQUxVRSxzPW51bGw7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspe2NvbnN0IHI9dFtpXTtpZihyPT09ZSljb250aW51ZTtjb25zdCBvPXIueC1lLng7bGV0IGw9ci55LWUueTtsPDAmJihsPS1sKTtjb25zdCBhPWwvTWF0aC5zcXJ0KG8qbytsKmwpO2E8biYmKG49YSxzPXIpfXJldHVybiBzfXN0YXRpYyBsb3dlc3RQb2ludCh0KXtsZXQgZT10WzBdO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKXRbbl0ueTxlLnkmJihlPXRbbl0pO3JldHVybiBlfXN0YXRpYyBwb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50KHQsZSxuKXtsZXQgcz1pLk1BWF9WQUxVRSxyPW51bGw7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspe2NvbnN0IG89dFtpXTtpZihvPT09ZSljb250aW51ZTtpZihvPT09biljb250aW51ZTtjb25zdCBsPWllLmFuZ2xlQmV0d2VlbihlLG8sbik7bDxzJiYocz1sLHI9byl9cmV0dXJuIHJ9Z2V0UmFkaXVzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX3JhZGl1c31nZXREaWFtZXRlcigpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpfWNvbnN0IHQ9dGhpcy5fZXh0cmVtYWxQdHNbMF0sZT10aGlzLl9leHRyZW1hbFB0c1sxXTtyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsZV0pfWdldEV4dHJlbWFsUG9pbnRzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX2V4dHJlbWFsUHRzfWNvbXB1dGVDaXJjbGVQb2ludHMoKXtpZih0aGlzLl9pbnB1dC5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7aWYoMT09PXRoaXMuX2lucHV0LmdldE51bVBvaW50cygpKXtjb25zdCB0PXRoaXMuX2lucHV0LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVtuZXcgZyh0WzBdKV0sbnVsbH1jb25zdCB0PXRoaXMuX2lucHV0LmNvbnZleEh1bGwoKS5nZXRDb29yZGluYXRlcygpO2xldCBlPXQ7aWYodFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKSYmKGU9bmV3IEFycmF5KHQubGVuZ3RoLTEpLmZpbGwobnVsbCksWC5jb3B5RGVlcCh0LDAsZSwwLHQubGVuZ3RoLTEpKSxlLmxlbmd0aDw9MilyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9WC5jb3B5RGVlcChlKSxudWxsO2xldCBuPWZuLmxvd2VzdFBvaW50KGUpLHM9Zm4ucG9pbnRXaXRNaW5BbmdsZVdpdGhYKGUsbik7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHQ9Zm4ucG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudChlLG4scyk7aWYoaWUuaXNPYnR1c2Uobix0LHMpKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IGcobiksbmV3IGcocyldLG51bGw7aWYoaWUuaXNPYnR1c2UodCxuLHMpKW49dDtlbHNle2lmKCFpZS5pc09idHVzZSh0LHMsbikpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVtuZXcgZyhuKSxuZXcgZyhzKSxuZXcgZyh0KV0sbnVsbDtzPXR9fXUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJMb2dpYyBmYWlsdXJlIGluIE1pbmltdW0gQm91bmRpbmcgQ2lyY2xlIGFsZ29yaXRobSFcIil9Y29tcHV0ZSgpe2lmKG51bGwhPT10aGlzLl9leHRyZW1hbFB0cylyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVDaXJjbGVQb2ludHMoKSx0aGlzLmNvbXB1dGVDZW50cmUoKSxudWxsIT09dGhpcy5fY2VudHJlJiYodGhpcy5fcmFkaXVzPXRoaXMuX2NlbnRyZS5kaXN0YW5jZSh0aGlzLl9leHRyZW1hbFB0c1swXSkpfWdldEZhcnRoZXN0UG9pbnRzKCl7c3dpdGNoKHRoaXMuY29tcHV0ZSgpLHRoaXMuX2V4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMTpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX2NlbnRyZSl9Y29uc3QgdD10aGlzLl9leHRyZW1hbFB0c1swXSxlPXRoaXMuX2V4dHJlbWFsUHRzW3RoaXMuX2V4dHJlbWFsUHRzLmxlbmd0aC0xXTtyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsZV0pfWdldENpcmNsZSgpe2lmKHRoaXMuY29tcHV0ZSgpLG51bGw9PT10aGlzLl9jZW50cmUpcmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKCk7Y29uc3QgdD10aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKTtyZXR1cm4gMD09PXRoaXMuX3JhZGl1cz90OnQuYnVmZmVyKHRoaXMuX3JhZGl1cyl9Z2V0Q2VudHJlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX2NlbnRyZX1jb21wdXRlQ2VudHJlKCl7c3dpdGNoKHRoaXMuX2V4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnRoaXMuX2NlbnRyZT1udWxsO2JyZWFrO2Nhc2UgMTp0aGlzLl9jZW50cmU9dGhpcy5fZXh0cmVtYWxQdHNbMF07YnJlYWs7Y2FzZSAyOnRoaXMuX2NlbnRyZT1uZXcgZygodGhpcy5fZXh0cmVtYWxQdHNbMF0ueCt0aGlzLl9leHRyZW1hbFB0c1sxXS54KS8yLCh0aGlzLl9leHRyZW1hbFB0c1swXS55K3RoaXMuX2V4dHJlbWFsUHRzWzFdLnkpLzIpO2JyZWFrO2Nhc2UgMzp0aGlzLl9jZW50cmU9cmUuY2lyY3VtY2VudHJlKHRoaXMuX2V4dHJlbWFsUHRzWzBdLHRoaXMuX2V4dHJlbWFsUHRzWzFdLHRoaXMuX2V4dHJlbWFsUHRzWzJdKX19Z2V0Q2xhc3MoKXtyZXR1cm4gZm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0PW51bGwsdGhpcy5fZXh0cmVtYWxQdHM9bnVsbCx0aGlzLl9jZW50cmU9bnVsbCx0aGlzLl9yYWRpdXM9MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dD10fTtjbGFzcyBwbntjb25zdHJ1Y3Rvcigpe3BuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG5leHRJbmRleCh0LGUpe3JldHVybisrZT49dC5sZW5ndGgmJihlPTApLGV9c3RhdGljIGNvbXB1dGVDKHQsZSxuKXtyZXR1cm4gdCpuLnktZSpuLnh9c3RhdGljIGdldE1pbmltdW1EaWFtZXRlcih0KXtyZXR1cm4gbmV3IHBuKHQpLmdldERpYW1ldGVyKCl9c3RhdGljIGdldE1pbmltdW1SZWN0YW5nbGUodCl7cmV0dXJuIG5ldyBwbih0KS5nZXRNaW5pbXVtUmVjdGFuZ2xlKCl9c3RhdGljIGNvbXB1dGVTZWdtZW50Rm9yTGluZSh0LGUsbil7bGV0IHM9bnVsbCxpPW51bGw7cmV0dXJuIE1hdGguYWJzKGUpPk1hdGguYWJzKHQpPyhzPW5ldyBnKDAsbi9lKSxpPW5ldyBnKDEsbi9lLXQvZSkpOihzPW5ldyBnKG4vdCwwKSxpPW5ldyBnKG4vdC1lL3QsMSkpLG5ldyBlZShzLGkpfWdldFdpZHRoQ29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9taW5XaWR0aFB0fWdldFN1cHBvcnRpbmdTZWdtZW50KCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5fbWluQmFzZVNlZy5wMCx0aGlzLl9taW5CYXNlU2VnLnAxXSl9Z2V0RGlhbWV0ZXIoKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSxudWxsPT09dGhpcy5fbWluV2lkdGhQdClyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y29uc3QgdD10aGlzLl9taW5CYXNlU2VnLnByb2plY3QodGhpcy5fbWluV2lkdGhQdCk7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCx0aGlzLl9taW5XaWR0aFB0XSl9Y29tcHV0ZVdpZHRoQ29udmV4KHQpe3RoaXMuX2NvbnZleEh1bGxQdHM9dCBpbnN0YW5jZW9mIGJ0P3QuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKTp0LmdldENvb3JkaW5hdGVzKCksMD09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLl9taW5XaWR0aD0wLHRoaXMuX21pbldpZHRoUHQ9bnVsbCx0aGlzLl9taW5CYXNlU2VnPW51bGwpOjE9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5fbWluV2lkdGg9MCx0aGlzLl9taW5XaWR0aFB0PXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDE9dGhpcy5fY29udmV4SHVsbFB0c1swXSk6Mj09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RofHwzPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMuX21pbldpZHRoPTAsdGhpcy5fbWluV2lkdGhQdD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDA9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAxPXRoaXMuX2NvbnZleEh1bGxQdHNbMV0pOnRoaXMuY29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0aGlzLl9jb252ZXhIdWxsUHRzKX1jb21wdXRlQ29udmV4UmluZ01pbkRpYW1ldGVyKHQpe3RoaXMuX21pbldpZHRoPWkuTUFYX1ZBTFVFO2xldCBlPTE7Y29uc3Qgbj1uZXcgZWU7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aC0xO3MrKyluLnAwPXRbc10sbi5wMT10W3MrMV0sZT10aGlzLmZpbmRNYXhQZXJwRGlzdGFuY2UodCxuLGUpfWNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKXtpZihudWxsIT09dGhpcy5fbWluV2lkdGhQdClyZXR1cm4gbnVsbDtpZih0aGlzLl9pc0NvbnZleCl0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0aGlzLl9pbnB1dEdlb20pO2Vsc2V7Y29uc3QgdD1uZXcgYW4odGhpcy5faW5wdXRHZW9tKS5nZXRDb252ZXhIdWxsKCk7dGhpcy5jb21wdXRlV2lkdGhDb252ZXgodCl9fWdldExlbmd0aCgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9taW5XaWR0aH1maW5kTWF4UGVycERpc3RhbmNlKHQsZSxuKXtsZXQgcz1lLmRpc3RhbmNlUGVycGVuZGljdWxhcih0W25dKSxpPXMscj1uLG89cjtmb3IoO2k+PXM7KXM9aSxyPW8sbz1wbi5uZXh0SW5kZXgodCxyKSxpPWUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHRbb10pO3JldHVybiBzPHRoaXMuX21pbldpZHRoJiYodGhpcy5fbWluUHRJbmRleD1yLHRoaXMuX21pbldpZHRoPXMsdGhpcy5fbWluV2lkdGhQdD10W3RoaXMuX21pblB0SW5kZXhdLHRoaXMuX21pbkJhc2VTZWc9bmV3IGVlKGUpKSxyfWdldE1pbmltdW1SZWN0YW5nbGUoKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSwwPT09dGhpcy5fbWluV2lkdGgpcmV0dXJuIHRoaXMuX21pbkJhc2VTZWcucDAuZXF1YWxzMkQodGhpcy5fbWluQmFzZVNlZy5wMSk/dGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9taW5CYXNlU2VnLnAwKTp0aGlzLl9taW5CYXNlU2VnLnRvR2VvbWV0cnkodGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKSk7Y29uc3QgdD10aGlzLl9taW5CYXNlU2VnLnAxLngtdGhpcy5fbWluQmFzZVNlZy5wMC54LGU9dGhpcy5fbWluQmFzZVNlZy5wMS55LXRoaXMuX21pbkJhc2VTZWcucDAueTtsZXQgbj1pLk1BWF9WQUxVRSxzPS1pLk1BWF9WQUxVRSxyPWkuTUFYX1ZBTFVFLG89LWkuTUFYX1ZBTFVFO2ZvcihsZXQgaT0wO2k8dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg7aSsrKXtjb25zdCBsPXBuLmNvbXB1dGVDKHQsZSx0aGlzLl9jb252ZXhIdWxsUHRzW2ldKTtsPnMmJihzPWwpLGw8biYmKG49bCk7Y29uc3QgYT1wbi5jb21wdXRlQygtZSx0LHRoaXMuX2NvbnZleEh1bGxQdHNbaV0pO2E+byYmKG89YSksYTxyJiYocj1hKX1jb25zdCBsPXBuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxvKSxhPXBuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxyKSxjPXBuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LHMpLGg9cG4uY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC1lLHQsbiksdT1jLmxpbmVJbnRlcnNlY3Rpb24obCksZz1oLmxpbmVJbnRlcnNlY3Rpb24obCksZD1oLmxpbmVJbnRlcnNlY3Rpb24oYSksXz1jLmxpbmVJbnRlcnNlY3Rpb24oYSksZj10aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoW3UsZyxkLF8sdV0pO3JldHVybiB0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24oZil9Z2V0Q2xhc3MoKXtyZXR1cm4gcG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXBuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2lzQ29udmV4PW51bGwsdGhpcy5fY29udmV4SHVsbFB0cz1udWxsLHRoaXMuX21pbkJhc2VTZWc9bmV3IGVlLHRoaXMuX21pbldpZHRoUHQ9bnVsbCx0aGlzLl9taW5QdEluZGV4PW51bGwsdGhpcy5fbWluV2lkdGg9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cG4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LCExKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbnB1dEdlb209dCx0aGlzLl9pc0NvbnZleD1lfX07dmFyIG1uPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRpc3RhbmNlOkRlLGxvY2F0ZTpRZSxtYXRjaDpubixBbmdsZTppZSxBcmVhOnZ0LENlbnRyb2lkOnNuLENvbnZleEh1bGw6YW4sRGlzdGFuY2U6RCxJbnRlcmlvclBvaW50QXJlYTpobixJbnRlcmlvclBvaW50TGluZTpnbixJbnRlcmlvclBvaW50UG9pbnQ6ZG4sTGVuZ3RoOnl0LE9yaWVudGF0aW9uOnYsUG9pbnRMb2NhdGlvbjpXZSxQb2ludExvY2F0b3I6X24sUm9idXN0TGluZUludGVyc2VjdG9yOnRlLE1pbmltdW1Cb3VuZGluZ0NpcmNsZTpmbixNaW5pbXVtRGlhbWV0ZXI6cG59KTtjbGFzcyB5bntjb25zdHJ1Y3Rvcigpe3luLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRlbnNpZnlQb2ludHModCxlLG4pe2NvbnN0IHM9bmV3IGVlLGk9bmV3IEk7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aC0xO3IrKyl7cy5wMD10W3JdLHMucDE9dFtyKzFdLGkuYWRkKHMucDAsITEpO2NvbnN0IG89cy5nZXRMZW5ndGgoKSxsPU1hdGgudHJ1bmMoby9lKSsxO2lmKGw+MSl7Y29uc3QgdD1vL2w7Zm9yKGxldCBlPTE7ZTxsO2UrKyl7Y29uc3Qgcj1lKnQvbyxsPXMucG9pbnRBbG9uZyhyKTtuLm1ha2VQcmVjaXNlKGwpLGkuYWRkKGwsITEpfX19cmV0dXJuIGkuYWRkKHRbdC5sZW5ndGgtMV0sITEpLGkudG9Db29yZGluYXRlQXJyYXkoKX1zdGF0aWMgZGVuc2lmeSh0LGUpe2NvbnN0IG49bmV3IHluKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1nZXRSZXN1bHRHZW9tZXRyeSgpe3JldHVybiBuZXcgeG4odGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8PTApdGhyb3cgbmV3IG4oXCJUb2xlcmFuY2UgbXVzdCBiZSBwb3NpdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fWdldENsYXNzKCl7cmV0dXJuIHlufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyB4biBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx4bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgQXQ/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBzPXluLmRlbnNpZnlQb2ludHMobix0aGlzLmRpc3RhbmNlVG9sZXJhbmNlLGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBUdCYmMT09PXMubGVuZ3RoJiYocz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSksdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdC5idWZmZXIoMCl9Z2V0Q2xhc3MoKXtyZXR1cm4geG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXhuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LHluLkRlbnNpZnlUcmFuc2Zvcm1lcj14bix5bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fTt2YXIgRW49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGVuc2lmaWVyOnlufSk7Y2xhc3MgSW57Y29uc3RydWN0b3IoKXtJbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc05vcnRoZXJuKHQpe3JldHVybiB0PT09SW4uTkV8fHQ9PT1Jbi5OV31zdGF0aWMgaXNPcHBvc2l0ZSh0LGUpe2lmKHQ9PT1lKXJldHVybiExO3JldHVybiAyPT09KHQtZSs0KSU0fXN0YXRpYyBjb21tb25IYWxmUGxhbmUodCxlKXtpZih0PT09ZSlyZXR1cm4gdDtpZigyPT09KHQtZSs0KSU0KXJldHVybi0xO2NvbnN0IG49dDxlP3Q6ZTtyZXR1cm4gMD09PW4mJjM9PT0odD5lP3Q6ZSk/MzpufXN0YXRpYyBpc0luSGFsZlBsYW5lKHQsZSl7cmV0dXJuIGU9PT1Jbi5TRT90PT09SW4uU0V8fHQ9PT1Jbi5TVzp0PT09ZXx8dD09PWUrMX1zdGF0aWMgcXVhZHJhbnQoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dCYmMD09PWUpdGhyb3cgbmV3IG4oXCJDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHBvaW50ICggXCIrdCtcIiwgXCIrZStcIiApXCIpO3JldHVybiB0Pj0wP2U+PTA/SW4uTkU6SW4uU0U6ZT49MD9Jbi5OVzpJbi5TV31pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoZS54PT09dC54JiZlLnk9PT10LnkpdGhyb3cgbmV3IG4oXCJDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK3QpO3JldHVybiBlLng+PXQueD9lLnk+PXQueT9Jbi5ORTpJbi5TRTplLnk+PXQueT9Jbi5OVzpJbi5TV319Z2V0Q2xhc3MoKXtyZXR1cm4gSW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUluLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sSW4uTkU9MCxJbi5OVz0xLEluLlNXPTIsSW4uU0U9MztjbGFzcyBObntjb25zdHJ1Y3Rvcigpe05uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGluaXQodCxlKXtpZihudWxsIT09dC5fc3ltfHxudWxsIT09ZS5fc3ltfHxudWxsIT09dC5fbmV4dHx8bnVsbCE9PWUuX25leHQpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkVkZ2VzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkXCIpO3JldHVybiB0LmluaXQoZSksdH1zdGF0aWMgY3JlYXRlKHQsZSl7Y29uc3Qgbj1uZXcgTm4odCkscz1uZXcgTm4oZSk7cmV0dXJuIG4uaW5pdChzKSxufWZpbmQodCl7bGV0IGU9dGhpcztkb3tpZihudWxsPT09ZSlyZXR1cm4gbnVsbDtpZihlLmRlc3QoKS5lcXVhbHMyRCh0KSlyZXR1cm4gZTtlPWUub05leHQoKX13aGlsZShlIT09dGhpcyk7cmV0dXJuIG51bGx9ZGVzdCgpe3JldHVybiB0aGlzLl9zeW0uX29yaWd9b05leHQoKXtyZXR1cm4gdGhpcy5fc3ltLl9uZXh0fWluc2VydCh0KXtpZih0aGlzLm9OZXh0KCk9PT10aGlzKXJldHVybiB0aGlzLmluc2VydEFmdGVyKHQpLG51bGw7Y29uc3QgZT10aGlzLmNvbXBhcmVUbyh0KTtsZXQgbj10aGlzO2Rve2NvbnN0IHM9bi5vTmV4dCgpO2lmKHMuY29tcGFyZVRvKHQpIT09ZXx8cz09PXRoaXMpcmV0dXJuIG4uaW5zZXJ0QWZ0ZXIodCksbnVsbDtuPXN9d2hpbGUobiE9PXRoaXMpO3Uuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1pbnNlcnRBZnRlcih0KXt1LmVxdWFscyh0aGlzLl9vcmlnLHQub3JpZygpKTtjb25zdCBlPXRoaXMub05leHQoKTt0aGlzLl9zeW0uc2V0TmV4dCh0KSx0LnN5bSgpLnNldE5leHQoZSl9ZGVncmVlKCl7bGV0IHQ9MCxlPXRoaXM7ZG97dCsrLGU9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gdH1lcXVhbHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9vcmlnLmVxdWFsczJEKHQpJiZ0aGlzLl9zeW0uX29yaWcuZXF1YWxzKGUpfX1kZWx0YVkoKXtyZXR1cm4gdGhpcy5fc3ltLl9vcmlnLnktdGhpcy5fb3JpZy55fXN5bSgpe3JldHVybiB0aGlzLl9zeW19cHJldigpe3JldHVybiB0aGlzLl9zeW0ubmV4dCgpLl9zeW19Y29tcGFyZUFuZ3VsYXJEaXJlY3Rpb24odCl7Y29uc3QgZT10aGlzLmRlbHRhWCgpLG49dGhpcy5kZWx0YVkoKSxzPXQuZGVsdGFYKCksaT10LmRlbHRhWSgpO2lmKGU9PT1zJiZuPT09aSlyZXR1cm4gMDtjb25zdCByPUluLnF1YWRyYW50KGUsbiksbz1Jbi5xdWFkcmFudChzLGkpO3JldHVybiByPm8/MTpyPG8/LTE6di5pbmRleCh0Ll9vcmlnLHQuZGVzdCgpLHRoaXMuZGVzdCgpKX1wcmV2Tm9kZSgpe2xldCB0PXRoaXM7Zm9yKDsyPT09dC5kZWdyZWUoKTspaWYodD10LnByZXYoKSx0PT09dGhpcylyZXR1cm4gbnVsbDtyZXR1cm4gdH1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKGUpfW5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1zZXRTeW0odCl7dGhpcy5fc3ltPXR9b3JpZygpe3JldHVybiB0aGlzLl9vcmlnfXRvU3RyaW5nKCl7cmV0dXJuXCJIRShcIit0aGlzLl9vcmlnLngrXCIgXCIrdGhpcy5fb3JpZy55K1wiLCBcIit0aGlzLl9zeW0uX29yaWcueCtcIiBcIit0aGlzLl9zeW0uX29yaWcueStcIilcIn1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1pbml0KHQpe3RoaXMuc2V0U3ltKHQpLHQuc2V0U3ltKHRoaXMpLHRoaXMuc2V0TmV4dCh0KSx0LnNldE5leHQodGhpcyl9ZGVsdGFYKCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZy54LXRoaXMuX29yaWcueH1nZXRDbGFzcygpe3JldHVybiBObn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Tm4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fb3JpZz1udWxsLHRoaXMuX3N5bT1udWxsLHRoaXMuX25leHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9vcmlnPXR9O2NsYXNzIENuIGV4dGVuZHMgTm57Y29uc3RydWN0b3IoKXtzdXBlcigpLENuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNldE1hcmtCb3RoKHQsZSl7dC5zZXRNYXJrKGUpLHQuc3ltKCkuc2V0TWFyayhlKX1zdGF0aWMgaXNNYXJrZWQodCl7cmV0dXJuIHQuaXNNYXJrZWQoKX1zdGF0aWMgc2V0TWFyayh0LGUpe3Quc2V0TWFyayhlKX1zdGF0aWMgbWFya0JvdGgodCl7dC5tYXJrKCksdC5zeW0oKS5tYXJrKCl9c3RhdGljIG1hcmsodCl7dC5tYXJrKCl9bWFyaygpe3RoaXMuX2lzTWFya2VkPSEwfXNldE1hcmsodCl7dGhpcy5faXNNYXJrZWQ9dH1pc01hcmtlZCgpe3JldHVybiB0aGlzLl9pc01hcmtlZH1nZXRDbGFzcygpe3JldHVybiBDbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Q24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNNYXJrZWQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07Tm4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX07Y2xhc3MgU257Y29uc3RydWN0b3IoKXtTbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc1ZhbGlkRWRnZSh0LGUpe3JldHVybiAwIT09ZS5jb21wYXJlVG8odCl9aW5zZXJ0KHQsZSxuKXtjb25zdCBzPXRoaXMuY3JlYXRlKHQsZSk7bnVsbCE9PW4/bi5pbnNlcnQocyk6dGhpcy5fdmVydGV4TWFwLnB1dCh0LHMpO2NvbnN0IGk9dGhpcy5fdmVydGV4TWFwLmdldChlKTtyZXR1cm4gbnVsbCE9PWk/aS5pbnNlcnQocy5zeW0oKSk6dGhpcy5fdmVydGV4TWFwLnB1dChlLHMuc3ltKCkpLHN9Y3JlYXRlKHQsZSl7Y29uc3Qgbj10aGlzLmNyZWF0ZUVkZ2UodCkscz10aGlzLmNyZWF0ZUVkZ2UoZSk7cmV0dXJuIE5uLmluaXQobixzKSxufWNyZWF0ZUVkZ2UodCl7cmV0dXJuIG5ldyBObih0KX1hZGRFZGdlKHQsZSl7aWYoIVNuLmlzVmFsaWRFZGdlKHQsZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj10aGlzLl92ZXJ0ZXhNYXAuZ2V0KHQpO2xldCBzPW51bGw7aWYobnVsbCE9PW4mJihzPW4uZmluZChlKSksbnVsbCE9PXMpcmV0dXJuIHM7cmV0dXJuIHRoaXMuaW5zZXJ0KHQsZSxuKX1nZXRWZXJ0ZXhFZGdlcygpe3JldHVybiB0aGlzLl92ZXJ0ZXhNYXAudmFsdWVzKCl9ZmluZEVkZ2UodCxlKXtjb25zdCBuPXRoaXMuX3ZlcnRleE1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1uP251bGw6bi5maW5kKGUpfWdldENsYXNzKCl7cmV0dXJuIFNufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Tbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl92ZXJ0ZXhNYXA9bmV3IFV0fTtjbGFzcyB3biBleHRlbmRzIENue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx3bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldFN0YXJ0KCl7dGhpcy5faXNTdGFydD0hMH1pc1N0YXJ0KCl7cmV0dXJuIHRoaXMuX2lzU3RhcnR9Z2V0Q2xhc3MoKXtyZXR1cm4gd259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXduLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzU3RhcnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07Q24uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX07Y2xhc3MgTG4gZXh0ZW5kcyBTbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVFZGdlKHQpe3JldHVybiBuZXcgd24odCl9Z2V0Q2xhc3MoKXtyZXR1cm4gTG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUxuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgVG57Y29uc3RydWN0b3IoKXtUbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkaXNzb2x2ZSh0KXtjb25zdCBlPW5ldyBUbjtyZXR1cm4gZS5hZGQodCksZS5nZXRSZXN1bHQoKX1hZGRMaW5lKHQpe3RoaXMuX2xpbmVzLmFkZCh0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC50b0Nvb3JkaW5hdGVBcnJheSgpKSl9dXBkYXRlUmluZ1N0YXJ0RWRnZSh0KXtyZXR1cm4gdC5pc1N0YXJ0KCl8fCh0PXQuc3ltKCkpLmlzU3RhcnQoKT9udWxsPT09dGhpcy5fcmluZ1N0YXJ0RWRnZT8odGhpcy5fcmluZ1N0YXJ0RWRnZT10LG51bGwpOnZvaWQodC5vcmlnKCkuY29tcGFyZVRvKHRoaXMuX3JpbmdTdGFydEVkZ2Uub3JpZygpKTwwJiYodGhpcy5fcmluZ1N0YXJ0RWRnZT10KSk6bnVsbH1nZXRSZXN1bHQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Jlc3VsdCYmdGhpcy5jb21wdXRlUmVzdWx0KCksdGhpcy5fcmVzdWx0fXByb2Nlc3ModCl7bGV0IGU9dC5wcmV2Tm9kZSgpO251bGw9PT1lJiYoZT10KSx0aGlzLnN0YWNrRWRnZXMoZSksdGhpcy5idWlsZExpbmVzKCl9YnVpbGRSaW5nKHQpe2NvbnN0IGU9bmV3IEk7bGV0IG49dDtmb3IoZS5hZGQobi5vcmlnKCkuY29weSgpLCExKTsyPT09bi5zeW0oKS5kZWdyZWUoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocz09PXQpYnJlYWs7ZS5hZGQocy5vcmlnKCkuY29weSgpLCExKSxuPXN9ZS5hZGQobi5kZXN0KCkuY29weSgpLCExKSx0aGlzLmFkZExpbmUoZSl9YnVpbGRMaW5lKHQpe2NvbnN0IGU9bmV3IEk7bGV0IG49dDtmb3IodGhpcy5fcmluZ1N0YXJ0RWRnZT1udWxsLENuLm1hcmtCb3RoKG4pLGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXt0aGlzLnVwZGF0ZVJpbmdTdGFydEVkZ2Uobik7Y29uc3Qgcz1uLm5leHQoKTtpZihzPT09dClyZXR1cm4gdGhpcy5idWlsZFJpbmcodGhpcy5fcmluZ1N0YXJ0RWRnZSksbnVsbDtlLmFkZChzLm9yaWcoKS5jb3B5KCksITEpLG49cyxDbi5tYXJrQm90aChuKX1lLmFkZChuLmRlc3QoKS5jbG9uZSgpLCExKSx0aGlzLnN0YWNrRWRnZXMobi5zeW0oKSksdGhpcy5hZGRMaW5lKGUpfXN0YWNrRWRnZXModCl7bGV0IGU9dDtkb3tDbi5pc01hcmtlZChlKXx8dGhpcy5fbm9kZUVkZ2VTdGFjay5hZGQoZSksZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXQpfWNvbXB1dGVSZXN1bHQoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0VmVydGV4RWRnZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtDbi5pc01hcmtlZChlKXx8dGhpcy5wcm9jZXNzKGUpfXRoaXMuX3Jlc3VsdD10aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodGhpcy5fbGluZXMpfWJ1aWxkTGluZXMoKXtmb3IoOyF0aGlzLl9ub2RlRWRnZVN0YWNrLmVtcHR5KCk7KXtjb25zdCB0PXRoaXMuX25vZGVFZGdlU3RhY2sucG9wKCk7Q24uaXNNYXJrZWQodCl8fHRoaXMuYnVpbGRMaW5lKHQpfX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2FyZ3VtZW50c1swXS5hcHBseShuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ddfWZpbHRlcih0KXt0IGluc3RhbmNlb2YgVHQmJnRoaXMuYWRkKHQpfX0pfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGQoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKTtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7bGV0IG49ITE7Zm9yKGxldCB0PTE7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9dGhpcy5fZ3JhcGguYWRkRWRnZShlLmdldENvb3JkaW5hdGUodC0xKSxlLmdldENvb3JkaW5hdGUodCkpO251bGwhPT1zJiYobnx8KHMuc2V0U3RhcnQoKSxuPSEwKSl9fX1nZXRDbGFzcygpe3JldHVybiBUbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVzdWx0PW51bGwsdGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fbGluZXM9bmV3IHgsdGhpcy5fbm9kZUVkZ2VTdGFjaz1uZXcgb24sdGhpcy5fcmluZ1N0YXJ0RWRnZT1udWxsLHRoaXMuX2dyYXBoPW5ldyBMbn07dmFyIFJuPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLExpbmVEaXNzb2x2ZXI6VG59KTtjbGFzcyBQbntjb25zdHJ1Y3Rvcigpe1BuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG9wcG9zaXRlKHQpe3JldHVybiB0PT09UG4uTEVGVD9Qbi5SSUdIVDp0PT09UG4uUklHSFQ/UG4uTEVGVDp0fWdldENsYXNzKCl7cmV0dXJuIFBufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Qbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFBuLk9OPTAsUG4uTEVGVD0xLFBuLlJJR0hUPTI7Y2xhc3Mgdm57Y29uc3RydWN0b3IoKXt2bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXB1dGVJbnRlcnNlY3Rpb25zKHQsZSl7dGhpcy5tY2UuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLmNoYWluSW5kZXgsdC5tY2UsdC5jaGFpbkluZGV4LGUpfWdldENsYXNzKCl7cmV0dXJuIHZufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLm1jZT1udWxsLHRoaXMuY2hhaW5JbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubWNlPXQsdGhpcy5jaGFpbkluZGV4PWV9O2NsYXNzIE9ue2NvbnN0cnVjdG9yKCl7T24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0RlbGV0ZSgpe3JldHVybiB0aGlzLl9ldmVudFR5cGU9PT1Pbi5ERUxFVEV9c2V0RGVsZXRlRXZlbnRJbmRleCh0KXt0aGlzLl9kZWxldGVFdmVudEluZGV4PXR9Z2V0T2JqZWN0KCl7cmV0dXJuIHRoaXMuX29ian1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl94VmFsdWU8ZS5feFZhbHVlPy0xOnRoaXMuX3hWYWx1ZT5lLl94VmFsdWU/MTp0aGlzLl9ldmVudFR5cGU8ZS5fZXZlbnRUeXBlPy0xOnRoaXMuX2V2ZW50VHlwZT5lLl9ldmVudFR5cGU/MTowfWdldEluc2VydEV2ZW50KCl7cmV0dXJuIHRoaXMuX2luc2VydEV2ZW50fWlzSW5zZXJ0KCl7cmV0dXJuIHRoaXMuX2V2ZW50VHlwZT09PU9uLklOU0VSVH1pc1NhbWVMYWJlbCh0KXtyZXR1cm4gbnVsbCE9PXRoaXMuX2xhYmVsJiZ0aGlzLl9sYWJlbD09PXQuX2xhYmVsfWdldERlbGV0ZUV2ZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fZGVsZXRlRXZlbnRJbmRleH1nZXRDbGFzcygpe3JldHVybiBPbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fU9uLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2xhYmVsPW51bGwsdGhpcy5feFZhbHVlPW51bGwsdGhpcy5fZXZlbnRUeXBlPW51bGwsdGhpcy5faW5zZXJ0RXZlbnQ9bnVsbCx0aGlzLl9kZWxldGVFdmVudEluZGV4PW51bGwsdGhpcy5fb2JqPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2V2ZW50VHlwZT1Pbi5ERUxFVEUsdGhpcy5feFZhbHVlPXQsdGhpcy5faW5zZXJ0RXZlbnQ9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9ldmVudFR5cGU9T24uSU5TRVJULHRoaXMuX2xhYmVsPXQsdGhpcy5feFZhbHVlPWUsdGhpcy5fb2JqPW59fSxPbi5JTlNFUlQ9MSxPbi5ERUxFVEU9MjtjbGFzcyBibntjb25zdHJ1Y3Rvcigpe2JuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gYm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWJuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgTW57Y29uc3RydWN0b3IoKXtNbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc0FkamFjZW50U2VnbWVudHModCxlKXtyZXR1cm4gMT09PU1hdGguYWJzKHQtZSl9aXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2lmKHQ9PT1uJiYxPT09dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkpe2lmKE1uLmlzQWRqYWNlbnRTZWdtZW50cyhlLHMpKXJldHVybiEwO2lmKHQuaXNDbG9zZWQoKSl7Y29uc3Qgbj10LmdldE51bVBvaW50cygpLTE7aWYoMD09PWUmJnM9PT1ufHwwPT09cyYmZT09PW4pcmV0dXJuITB9fXJldHVybiExfWdldFByb3BlckludGVyc2VjdGlvblBvaW50KCl7cmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50fXNldElzRG9uZUlmUHJvcGVySW50KHQpe3RoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQ9dH1oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcn1pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpLmdldENvb3JkaW5hdGUoKTtpZih0LmlzSW50ZXJzZWN0aW9uKGUpKXJldHVybiEwfXJldHVybiExfWhhc1Byb3BlckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJ9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4gdGhpcy5faXNEb25lfWlzQm91bmRhcnlQb2ludCh0LGUpe3JldHVybiBudWxsIT09ZSYmKCEhdGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMF0pfHwhIXRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzFdKSl9c2V0Qm91bmRhcnlOb2Rlcyh0LGUpe3RoaXMuX2JkeU5vZGVzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2JkeU5vZGVzWzBdPXQsdGhpcy5fYmR5Tm9kZXNbMV09ZX1hZGRJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLl9yZWNvcmRJc29sYXRlZCYmKHQuc2V0SXNvbGF0ZWQoITEpLG4uc2V0SXNvbGF0ZWQoITEpKSx0aGlzLl9udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl8fCh0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsIXRoaXMuX2luY2x1ZGVQcm9wZXImJnRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKSksdGhpcy5fbGkuaXNQcm9wZXIoKSYmKHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKS5jb3B5KCksdGhpcy5faGFzUHJvcGVyPSEwLHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQmJih0aGlzLl9pc0RvbmU9ITApLHRoaXMuaXNCb3VuZGFyeVBvaW50KHRoaXMuX2xpLHRoaXMuX2JkeU5vZGVzKXx8KHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSEwKSkpKX1nZXRDbGFzcygpe3JldHVybiBNbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuX2hhc1Byb3Blcj0hMSx0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMSx0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5faW5jbHVkZVByb3Blcj1udWxsLHRoaXMuX3JlY29yZElzb2xhdGVkPW51bGwsdGhpcy5faXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5fbnVtSW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtVGVzdHM9MCx0aGlzLl9iZHlOb2Rlcz1udWxsLHRoaXMuX2lzRG9uZT0hMSx0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2xpPXQsdGhpcy5faW5jbHVkZVByb3Blcj1lLHRoaXMuX3JlY29yZElzb2xhdGVkPW59O2NsYXNzIERuIGV4dGVuZHMgYm57Y29uc3RydWN0b3IoKXtzdXBlcigpLERuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cHJlcGFyZUV2ZW50cygpe0VlLnNvcnQodGhpcy5ldmVudHMpO2ZvcihsZXQgdD0wO3Q8dGhpcy5ldmVudHMuc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLmV2ZW50cy5nZXQodCk7ZS5pc0RlbGV0ZSgpJiZlLmdldEluc2VydEV2ZW50KCkuc2V0RGVsZXRlRXZlbnRJbmRleCh0KX19Y29tcHV0ZUludGVyc2VjdGlvbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5uT3ZlcmxhcHM9MCx0aGlzLnByZXBhcmVFdmVudHMoKTtmb3IobGV0IGU9MDtlPHRoaXMuZXZlbnRzLnNpemUoKTtlKyspe2NvbnN0IG49dGhpcy5ldmVudHMuZ2V0KGUpO2lmKG4uaXNJbnNlcnQoKSYmdGhpcy5wcm9jZXNzT3ZlcmxhcHMoZSxuLmdldERlbGV0ZUV2ZW50SW5kZXgoKSxuLHQpLHQuaXNEb25lKCkpYnJlYWt9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBNbiYmXyhhcmd1bWVudHNbMF0sbSkmJl8oYXJndW1lbnRzWzFdLG0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmFkZEVkZ2VzKHQsdCksdGhpcy5hZGRFZGdlcyhlLGUpLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMobil9ZWxzZSBpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXyhhcmd1bWVudHNbMF0sbSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgTW4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1syXT90aGlzLmFkZEVkZ2VzKHQsbnVsbCk6dGhpcy5hZGRFZGdlcyh0KSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKGUpfX1hZGRFZGdlKHQsZSl7Y29uc3Qgbj10LmdldE1vbm90b25lQ2hhaW5FZGdlKCkscz1uLmdldFN0YXJ0SW5kZXhlcygpO2ZvcihsZXQgdD0wO3Q8cy5sZW5ndGgtMTt0Kyspe2NvbnN0IHM9bmV3IHZuKG4sdCksaT1uZXcgT24oZSxuLmdldE1pblgodCkscyk7dGhpcy5ldmVudHMuYWRkKGkpLHRoaXMuZXZlbnRzLmFkZChuZXcgT24obi5nZXRNYXhYKHQpLGkpKX19cHJvY2Vzc092ZXJsYXBzKHQsZSxuLHMpe2NvbnN0IGk9bi5nZXRPYmplY3QoKTtmb3IobGV0IHI9dDtyPGU7cisrKXtjb25zdCB0PXRoaXMuZXZlbnRzLmdldChyKTtpZih0LmlzSW5zZXJ0KCkpe2NvbnN0IGU9dC5nZXRPYmplY3QoKTtuLmlzU2FtZUxhYmVsKHQpfHwoaS5jb21wdXRlSW50ZXJzZWN0aW9ucyhlLHMpLHRoaXMubk92ZXJsYXBzKyspfX19YWRkRWRnZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZEVkZ2UoZSxlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5hZGRFZGdlKHQsZSl9fX1nZXRDbGFzcygpe3JldHVybiBEbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5ldmVudHM9bmV3IHgsdGhpcy5uT3ZlcmxhcHM9bnVsbH07Y2xhc3MgQW57Y29uc3RydWN0b3IoKXtBbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldEFsbExvY2F0aW9ucyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPXR9aXNOdWxsKCl7Zm9yKGxldCB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XSE9PW5lLk5PTkUpcmV0dXJuITE7cmV0dXJuITB9c2V0QWxsTG9jYXRpb25zSWZOdWxsKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09PT1uZS5OT05FJiYodGhpcy5sb2NhdGlvbltlXT10KX1pc0xpbmUoKXtyZXR1cm4gMT09PXRoaXMubG9jYXRpb24ubGVuZ3RofW1lcmdlKHQpe2lmKHQubG9jYXRpb24ubGVuZ3RoPnRoaXMubG9jYXRpb24ubGVuZ3RoKXtjb25zdCB0PW5ldyBBcnJheSgzKS5maWxsKG51bGwpO3RbUG4uT05dPXRoaXMubG9jYXRpb25bUG4uT05dLHRbUG4uTEVGVF09bmUuTk9ORSx0W1BuLlJJR0hUXT1uZS5OT05FLHRoaXMubG9jYXRpb249dH1mb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPT09bmUuTk9ORSYmZTx0LmxvY2F0aW9uLmxlbmd0aCYmKHRoaXMubG9jYXRpb25bZV09dC5sb2NhdGlvbltlXSl9Z2V0TG9jYXRpb25zKCl7cmV0dXJuIHRoaXMubG9jYXRpb259ZmxpcCgpe2lmKHRoaXMubG9jYXRpb24ubGVuZ3RoPD0xKXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy5sb2NhdGlvbltQbi5MRUZUXTt0aGlzLmxvY2F0aW9uW1BuLkxFRlRdPXRoaXMubG9jYXRpb25bUG4uUklHSFRdLHRoaXMubG9jYXRpb25bUG4uUklHSFRdPXR9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB3O3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChuZS50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bUG4uTEVGVF0pKSx0LmFwcGVuZChuZS50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bUG4uT05dKSksdGhpcy5sb2NhdGlvbi5sZW5ndGg+MSYmdC5hcHBlbmQobmUudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1BuLlJJR0hUXSkpLHQudG9TdHJpbmcoKX1zZXRMb2NhdGlvbnModCxlLG4pe3RoaXMubG9jYXRpb25bUG4uT05dPXQsdGhpcy5sb2NhdGlvbltQbi5MRUZUXT1lLHRoaXMubG9jYXRpb25bUG4uUklHSFRdPW59Z2V0KHQpe3JldHVybiB0PHRoaXMubG9jYXRpb24ubGVuZ3RoP3RoaXMubG9jYXRpb25bdF06bmUuTk9ORX1pc0FyZWEoKXtyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MX1pc0FueU51bGwoKXtmb3IobGV0IHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdPT09bmUuTk9ORSlyZXR1cm4hMDtyZXR1cm4hMX1zZXRMb2NhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldExvY2F0aW9uKFBuLk9OLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubG9jYXRpb25bdF09ZX19aW5pdCh0KXt0aGlzLmxvY2F0aW9uPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLHRoaXMuc2V0QWxsTG9jYXRpb25zKG5lLk5PTkUpfWlzRXF1YWxPblNpZGUodCxlKXtyZXR1cm4gdGhpcy5sb2NhdGlvbltlXT09PXQubG9jYXRpb25bZV19YWxsUG9zaXRpb25zRXF1YWwodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspaWYodGhpcy5sb2NhdGlvbltlXSE9PXQpcmV0dXJuITE7cmV0dXJuITB9Z2V0Q2xhc3MoKXtyZXR1cm4gQW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUFuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMubG9jYXRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQubGVuZ3RoKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KDEpLHRoaXMubG9jYXRpb25bUG4uT05dPXR9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFuKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmluaXQodC5sb2NhdGlvbi5sZW5ndGgpLG51bGwhPT10KWZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09dC5sb2NhdGlvbltlXX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5pbml0KDMpLHRoaXMubG9jYXRpb25bUG4uT05dPXQsdGhpcy5sb2NhdGlvbltQbi5MRUZUXT1lLHRoaXMubG9jYXRpb25bUG4uUklHSFRdPW59fTtjbGFzcyBGbntjb25zdHJ1Y3Rvcigpe0ZuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvTGluZUxhYmVsKHQpe2NvbnN0IGU9bmV3IEZuKG5lLk5PTkUpO2ZvcihsZXQgbj0wO248MjtuKyspZS5zZXRMb2NhdGlvbihuLHQuZ2V0TG9jYXRpb24obikpO3JldHVybiBlfWdldEdlb21ldHJ5Q291bnQoKXtsZXQgdD0wO3JldHVybiB0aGlzLmVsdFswXS5pc051bGwoKXx8dCsrLHRoaXMuZWx0WzFdLmlzTnVsbCgpfHx0KyssdH1zZXRBbGxMb2NhdGlvbnModCxlKXt0aGlzLmVsdFt0XS5zZXRBbGxMb2NhdGlvbnMoZSl9aXNOdWxsKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc051bGwoKX1zZXRBbGxMb2NhdGlvbnNJZk51bGwoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0KSx0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0W3RdLnNldEFsbExvY2F0aW9uc0lmTnVsbChlKX19aXNMaW5lKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0xpbmUoKX1tZXJnZSh0KXtmb3IobGV0IGU9MDtlPDI7ZSsrKW51bGw9PT10aGlzLmVsdFtlXSYmbnVsbCE9PXQuZWx0W2VdP3RoaXMuZWx0W2VdPW5ldyBBbih0LmVsdFtlXSk6dGhpcy5lbHRbZV0ubWVyZ2UodC5lbHRbZV0pfWZsaXAoKXt0aGlzLmVsdFswXS5mbGlwKCksdGhpcy5lbHRbMV0uZmxpcCgpfWdldExvY2F0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5nZXQoUG4uT04pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5lbHRbdF0uZ2V0KGUpfX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHc7cmV0dXJuIG51bGwhPT10aGlzLmVsdFswXSYmKHQuYXBwZW5kKFwiQTpcIiksdC5hcHBlbmQodGhpcy5lbHRbMF0udG9TdHJpbmcoKSkpLG51bGwhPT10aGlzLmVsdFsxXSYmKHQuYXBwZW5kKFwiIEI6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzFdLnRvU3RyaW5nKCkpKSx0LnRvU3RyaW5nKCl9aXNBcmVhKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuZWx0WzBdLmlzQXJlYSgpfHx0aGlzLmVsdFsxXS5pc0FyZWEoKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWx0W3RdLmlzQXJlYSgpfX1pc0FueU51bGwodCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzQW55TnVsbCgpfXNldExvY2F0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0W3RdLnNldExvY2F0aW9uKFBuLk9OLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuZWx0W3RdLnNldExvY2F0aW9uKGUsbil9fWlzRXF1YWxPblNpZGUodCxlKXtyZXR1cm4gdGhpcy5lbHRbMF0uaXNFcXVhbE9uU2lkZSh0LmVsdFswXSxlKSYmdGhpcy5lbHRbMV0uaXNFcXVhbE9uU2lkZSh0LmVsdFsxXSxlKX1hbGxQb3NpdGlvbnNFcXVhbCh0LGUpe3JldHVybiB0aGlzLmVsdFt0XS5hbGxQb3NpdGlvbnNFcXVhbChlKX10b0xpbmUodCl7dGhpcy5lbHRbdF0uaXNBcmVhKCkmJih0aGlzLmVsdFt0XT1uZXcgQW4odGhpcy5lbHRbdF0ubG9jYXRpb25bMF0pKX1nZXRDbGFzcygpe3JldHVybiBGbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Rm4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5lbHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IEFuKHQpLHRoaXMuZWx0WzFdPW5ldyBBbih0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRm4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWx0WzBdPW5ldyBBbih0LmVsdFswXSksdGhpcy5lbHRbMV09bmV3IEFuKHQuZWx0WzFdKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbMF09bmV3IEFuKG5lLk5PTkUpLHRoaXMuZWx0WzFdPW5ldyBBbihuZS5OT05FKSx0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbihlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmVsdFswXT1uZXcgQW4odCxlLG4pLHRoaXMuZWx0WzFdPW5ldyBBbih0LGUsbil9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5lbHRbMF09bmV3IEFuKG5lLk5PTkUsbmUuTk9ORSxuZS5OT05FKSx0aGlzLmVsdFsxXT1uZXcgQW4obmUuTk9ORSxuZS5OT05FLG5lLk5PTkUpLHRoaXMuZWx0W3RdLnNldExvY2F0aW9ucyhlLG4scyl9fTtjbGFzcyBHbntjb25zdHJ1Y3Rvcigpe0duLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb29yZH1wcmludCh0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCksdC5wcmludGxuKFwiIGRpc3QgPSBcIit0aGlzLmRpc3QpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZShlLnNlZ21lbnRJbmRleCxlLmRpc3QpfWlzRW5kUG9pbnQodCl7cmV0dXJuIDA9PT10aGlzLnNlZ21lbnRJbmRleCYmMD09PXRoaXMuZGlzdHx8dGhpcy5zZWdtZW50SW5kZXg9PT10fXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuY29vcmQrXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCtcIiBkaXN0ID0gXCIrdGhpcy5kaXN0fWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuZGlzdH1jb21wYXJlKHQsZSl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PHQ/LTE6dGhpcy5zZWdtZW50SW5kZXg+dD8xOnRoaXMuZGlzdDxlPy0xOnRoaXMuZGlzdD5lPzE6MH1nZXRDbGFzcygpe3JldHVybiBHbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fUduLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuZGlzdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuY29vcmQ9bmV3IGcodCksdGhpcy5zZWdtZW50SW5kZXg9ZSx0aGlzLmRpc3Q9bn07Y2xhc3MgcW57Y29uc3RydWN0b3IoKXtxbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXByaW50KHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfWFkZFNwbGl0RWRnZXModCl7dGhpcy5hZGRFbmRwb2ludHMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4scyk7dC5hZGQoaSksbj1zfX1hZGRFbmRwb2ludHMoKXtjb25zdCB0PXRoaXMuZWRnZS5wdHMubGVuZ3RoLTE7dGhpcy5hZGQodGhpcy5lZGdlLnB0c1swXSwwLDApLHRoaXMuYWRkKHRoaXMuZWRnZS5wdHNbdF0sdCwwKX1jcmVhdGVTcGxpdEVkZ2UodCxlKXtsZXQgbj1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyO2NvbnN0IHM9dGhpcy5lZGdlLnB0c1tlLnNlZ21lbnRJbmRleF0saT1lLmRpc3Q+MHx8IWUuY29vcmQuZXF1YWxzMkQocyk7aXx8bi0tO2NvbnN0IHI9bmV3IEFycmF5KG4pLmZpbGwobnVsbCk7bGV0IG89MDtyW28rK109bmV3IGcodC5jb29yZCk7Zm9yKGxldCBuPXQuc2VnbWVudEluZGV4KzE7bjw9ZS5zZWdtZW50SW5kZXg7bisrKXJbbysrXT10aGlzLmVkZ2UucHRzW25dO3JldHVybiBpJiYocltvXT1lLmNvb3JkKSxuZXcgVW4ocixuZXcgRm4odGhpcy5lZGdlLl9sYWJlbCkpfWFkZCh0LGUsbil7Y29uc3Qgcz1uZXcgR24odCxlLG4pLGk9dGhpcy5fbm9kZU1hcC5nZXQocyk7cmV0dXJuIG51bGwhPT1pP2k6KHRoaXMuX25vZGVNYXAucHV0KHMscykscyl9aXNJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2lmKGUubmV4dCgpLmNvb3JkLmVxdWFscyh0KSlyZXR1cm4hMH1yZXR1cm4hMX1nZXRDbGFzcygpe3JldHVybiBxbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbm9kZU1hcD1uZXcgcnQsdGhpcy5lZGdlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lZGdlPXR9O2NsYXNzIEJue2NvbnN0cnVjdG9yKCl7Qm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9JbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPXQuZ2V0KG4pLmludFZhbHVlKCk7cmV0dXJuIGV9Z2V0Q2hhaW5TdGFydEluZGljZXModCl7bGV0IGU9MDtjb25zdCBuPW5ldyB4O24uYWRkKG5ldyBMKGUpKTtkb3tjb25zdCBzPXRoaXMuZmluZENoYWluRW5kKHQsZSk7bi5hZGQobmV3IEwocykpLGU9c313aGlsZShlPHQubGVuZ3RoLTEpO3JldHVybiBCbi50b0ludEFycmF5KG4pfWZpbmRDaGFpbkVuZCh0LGUpe2NvbnN0IG49SW4ucXVhZHJhbnQodFtlXSx0W2UrMV0pO2xldCBzPWUrMTtmb3IoO3M8dC5sZW5ndGg7KXtpZihJbi5xdWFkcmFudCh0W3MtMV0sdFtzXSkhPT1uKWJyZWFrO3MrK31yZXR1cm4gcy0xfWdldENsYXNzKCl7cmV0dXJuIEJufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Cbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFZue2NvbnN0cnVjdG9yKCl7Vm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLnB0c31nZXRNYXhYKHQpe2NvbnN0IGU9dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3RdXS54LG49dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3QrMV1dLng7cmV0dXJuIGU+bj9lOm59Z2V0TWluWCh0KXtjb25zdCBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBlPG4/ZTpufWNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4oKXtpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuc3RhcnRJbmRleFt0XSx0aGlzLnN0YXJ0SW5kZXhbdCsxXSxlLGUuc3RhcnRJbmRleFtuXSxlLnN0YXJ0SW5kZXhbbisxXSxzKX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtpZihlLXQ9PTEmJmktcz09MSlyZXR1cm4gci5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuZSx0LG4uZSxzKSxudWxsO2lmKCF0aGlzLm92ZXJsYXBzKHQsZSxuLHMsaSkpcmV0dXJuIG51bGw7Y29uc3Qgbz1NYXRoLnRydW5jKCh0K2UpLzIpLGw9TWF0aC50cnVuYygocytpKS8yKTt0PG8mJihzPGwmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0LG8sbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odCxvLG4sbCxpLHIpKSxvPGUmJihzPGwmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihvLGUsbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obyxlLG4sbCxpLHIpKX19b3ZlcmxhcHModCxlLG4scyxpKXtyZXR1cm4gTi5pbnRlcnNlY3RzKHRoaXMucHRzW3RdLHRoaXMucHRzW2VdLG4ucHRzW3NdLG4ucHRzW2ldKX1nZXRTdGFydEluZGV4ZXMoKXtyZXR1cm4gdGhpcy5zdGFydEluZGV4fWNvbXB1dGVJbnRlcnNlY3RzKHQsZSl7Zm9yKGxldCBuPTA7bjx0aGlzLnN0YXJ0SW5kZXgubGVuZ3RoLTE7bisrKWZvcihsZXQgcz0wO3M8dC5zdGFydEluZGV4Lmxlbmd0aC0xO3MrKyl0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obix0LHMsZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gVm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVZuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuZT1udWxsLHRoaXMucHRzPW51bGwsdGhpcy5zdGFydEluZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lPXQsdGhpcy5wdHM9dC5nZXRDb29yZGluYXRlcygpO2NvbnN0IGU9bmV3IEJuO3RoaXMuc3RhcnRJbmRleD1lLmdldENoYWluU3RhcnRJbmRpY2VzKHRoaXMucHRzKX07Y2xhc3Mgem57Y29uc3RydWN0b3IoKXt6bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkZXB0aEF0TG9jYXRpb24odCl7cmV0dXJuIHQ9PT1uZS5FWFRFUklPUj8wOnQ9PT1uZS5JTlRFUklPUj8xOnpuLk5VTExfVkFMVUV9Z2V0RGVwdGgodCxlKXtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bZV19c2V0RGVwdGgodCxlLG4pe3RoaXMuX2RlcHRoW3RdW2VdPW59aXNOdWxsKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD0wO3Q8Mjt0KyspZm9yKGxldCBlPTA7ZTwzO2UrKylpZih0aGlzLl9kZXB0aFt0XVtlXSE9PXpuLk5VTExfVkFMVUUpcmV0dXJuITE7cmV0dXJuITB9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kZXB0aFt0XVsxXT09PXpuLk5VTExfVkFMVUV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9kZXB0aFt0XVtlXT09PXpuLk5VTExfVkFMVUV9fW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8Mjt0KyspaWYoIXRoaXMuaXNOdWxsKHQpKXtsZXQgZT10aGlzLl9kZXB0aFt0XVsxXTt0aGlzLl9kZXB0aFt0XVsyXTxlJiYoZT10aGlzLl9kZXB0aFt0XVsyXSksZTwwJiYoZT0wKTtmb3IobGV0IG49MTtuPDM7bisrKXtsZXQgcz0wO3RoaXMuX2RlcHRoW3RdW25dPmUmJihzPTEpLHRoaXMuX2RlcHRoW3RdW25dPXN9fX1nZXREZWx0YSh0KXtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bUG4uUklHSFRdLXRoaXMuX2RlcHRoW3RdW1BuLkxFRlRdfWdldExvY2F0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2VdPD0wP25lLkVYVEVSSU9SOm5lLklOVEVSSU9SfXRvU3RyaW5nKCl7cmV0dXJuXCJBOiBcIit0aGlzLl9kZXB0aFswXVsxXStcIixcIit0aGlzLl9kZXB0aFswXVsyXStcIiBCOiBcIit0aGlzLl9kZXB0aFsxXVsxXStcIixcIit0aGlzLl9kZXB0aFsxXVsyXX1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTwyO2UrKylmb3IobGV0IG49MTtuPDM7bisrKXtjb25zdCBzPXQuZ2V0TG9jYXRpb24oZSxuKTtzIT09bmUuRVhURVJJT1ImJnMhPT1uZS5JTlRFUklPUnx8KHRoaXMuaXNOdWxsKGUsbik/dGhpcy5fZGVwdGhbZV1bbl09em4uZGVwdGhBdExvY2F0aW9uKHMpOnRoaXMuX2RlcHRoW2VdW25dKz16bi5kZXB0aEF0TG9jYXRpb24ocykpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl09PT1uZS5JTlRFUklPUiYmdGhpcy5fZGVwdGhbdF1bZV0rK319Z2V0Q2xhc3MoKXtyZXR1cm4gem59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXpuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2RlcHRoPUFycmF5KDIpLmZpbGwoKS5tYXAoKCk9PkFycmF5KDMpKTtmb3IobGV0IHQ9MDt0PDI7dCsrKWZvcihsZXQgZT0wO2U8MztlKyspdGhpcy5fZGVwdGhbdF1bZV09em4uTlVMTF9WQUxVRX0sem4uTlVMTF9WQUxVRT0tMTtjbGFzcyBZbntjb25zdHJ1Y3Rvcigpe1luLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0VmlzaXRlZCh0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH1zZXRJblJlc3VsdCh0KXt0aGlzLl9pc0luUmVzdWx0PXR9aXNDb3ZlcmVkKCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZH1pc0NvdmVyZWRTZXQoKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkU2V0fXNldExhYmVsKHQpe3RoaXMuX2xhYmVsPXR9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9c2V0Q292ZXJlZCh0KXt0aGlzLl9pc0NvdmVyZWQ9dCx0aGlzLl9pc0NvdmVyZWRTZXQ9ITB9dXBkYXRlSU0odCl7dS5pc1RydWUodGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpPj0yLFwiZm91bmQgcGFydGlhbCBsYWJlbFwiKSx0aGlzLmNvbXB1dGVJTSh0KX1pc0luUmVzdWx0KCl7cmV0dXJuIHRoaXMuX2lzSW5SZXN1bHR9aXNWaXNpdGVkKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH1nZXRDbGFzcygpe3JldHVybiBZbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19WW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzQ292ZXJlZD0hMSx0aGlzLl9pc0NvdmVyZWRTZXQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sYWJlbD10fX07Y2xhc3MgVW4gZXh0ZW5kcyBZbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksVW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdXBkYXRlSU0oKXtpZighKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHNlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZuKSlyZXR1cm4gc3VwZXIudXBkYXRlSU0uYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxQbi5PTiksdC5nZXRMb2NhdGlvbigxLFBuLk9OKSwxKSx0LmlzQXJlYSgpJiYoZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsUG4uTEVGVCksdC5nZXRMb2NhdGlvbigxLFBuLkxFRlQpLDIpLGUuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLFBuLlJJR0hUKSx0LmdldExvY2F0aW9uKDEsUG4uUklHSFQpLDIpKX19Z2V0RGVwdGgoKXtyZXR1cm4gdGhpcy5fZGVwdGh9Z2V0Q29sbGFwc2VkRWRnZSgpe2NvbnN0IHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIHRbMF09dGhpcy5wdHNbMF0sdFsxXT10aGlzLnB0c1sxXSxuZXcgVW4odCxGbi50b0xpbmVMYWJlbCh0aGlzLl9sYWJlbCkpfWlzSXNvbGF0ZWQoKXtyZXR1cm4gdGhpcy5faXNJc29sYXRlZH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLnB0c31zZXRJc29sYXRlZCh0KXt0aGlzLl9pc0lzb2xhdGVkPXR9c2V0TmFtZSh0KXt0aGlzLl9uYW1lPXR9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIFVuKSlyZXR1cm4hMTtjb25zdCBlPXQ7aWYodGhpcy5wdHMubGVuZ3RoIT09ZS5wdHMubGVuZ3RoKXJldHVybiExO2xldCBuPSEwLHM9ITAsaT10aGlzLnB0cy5sZW5ndGg7Zm9yKGxldCB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKWlmKHRoaXMucHRzW3RdLmVxdWFsczJEKGUucHRzW3RdKXx8KG49ITEpLHRoaXMucHRzW3RdLmVxdWFsczJEKGUucHRzWy0taV0pfHwocz0hMSksIW4mJiFzKXJldHVybiExO3JldHVybiEwfWdldENvb3JkaW5hdGUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5wdHMubGVuZ3RoPjA/dGhpcy5wdHNbMF06bnVsbDtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMucHRzW3RdfX1wcmludCh0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLl9uYW1lK1wiOiBcIiksdC5wcmludChcIkxJTkVTVFJJTkcgKFwiKTtmb3IobGV0IGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KHRoaXMucHRzW2VdLngrXCIgXCIrdGhpcy5wdHNbZV0ueSk7dC5wcmludChcIikgIFwiK3RoaXMuX2xhYmVsK1wiIFwiK3RoaXMuX2RlcHRoRGVsdGEpfWNvbXB1dGVJTSh0KXtVbi51cGRhdGVJTSh0aGlzLl9sYWJlbCx0KX1pc0NvbGxhcHNlZCgpe3JldHVybiEhdGhpcy5fbGFiZWwuaXNBcmVhKCkmJigzPT09dGhpcy5wdHMubGVuZ3RoJiYhIXRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1syXSkpfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1t0aGlzLnB0cy5sZW5ndGgtMV0pfWdldE1heGltdW1TZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RoLTF9Z2V0RGVwdGhEZWx0YSgpe3JldHVybiB0aGlzLl9kZXB0aERlbHRhfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9cHJpbnRSZXZlcnNlKHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMuX25hbWUrXCI6IFwiKTtmb3IobGV0IGU9dGhpcy5wdHMubGVuZ3RoLTE7ZT49MDtlLS0pdC5wcmludCh0aGlzLnB0c1tlXStcIiBcIik7dC5wcmludGxuKFwiXCIpfWdldE1vbm90b25lQ2hhaW5FZGdlKCl7cmV0dXJuIG51bGw9PT10aGlzLl9tY2UmJih0aGlzLl9tY2U9bmV3IFZuKHRoaXMpKSx0aGlzLl9tY2V9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXt0aGlzLl9lbnY9bmV3IE47Zm9yKGxldCB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMuX2Vudi5leHBhbmRUb0luY2x1ZGUodGhpcy5wdHNbdF0pfXJldHVybiB0aGlzLl9lbnZ9YWRkSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9bmV3IGcodC5nZXRJbnRlcnNlY3Rpb24ocykpO2xldCByPWUsbz10LmdldEVkZ2VEaXN0YW5jZShuLHMpO2NvbnN0IGw9cisxO2lmKGw8dGhpcy5wdHMubGVuZ3RoKXtjb25zdCB0PXRoaXMucHRzW2xdO2kuZXF1YWxzMkQodCkmJihyPWwsbz0wKX10aGlzLmVpTGlzdC5hZGQoaSxyLG8pfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgd3Q7dC5hcHBlbmQoXCJlZGdlIFwiK3RoaXMuX25hbWUrXCI6IFwiKSx0LmFwcGVuZChcIkxJTkVTVFJJTkcgKFwiKTtmb3IobGV0IGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LmFwcGVuZChcIixcIiksdC5hcHBlbmQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTtyZXR1cm4gdC5hcHBlbmQoXCIpICBcIit0aGlzLl9sYWJlbCtcIiBcIit0aGlzLl9kZXB0aERlbHRhKSx0LnRvU3RyaW5nKCl9aXNQb2ludHdpc2VFcXVhbCh0KXtpZih0aGlzLnB0cy5sZW5ndGghPT10LnB0cy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWlmKCF0aGlzLnB0c1tlXS5lcXVhbHMyRCh0LnB0c1tlXSkpcmV0dXJuITE7cmV0dXJuITB9c2V0RGVwdGhEZWx0YSh0KXt0aGlzLl9kZXB0aERlbHRhPXR9Z2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKXtyZXR1cm4gdGhpcy5laUxpc3R9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LmdldEludGVyc2VjdGlvbk51bSgpO3MrKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixzKX1nZXRDbGFzcygpe3JldHVybiBVbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5wdHM9bnVsbCx0aGlzLl9lbnY9bnVsbCx0aGlzLmVpTGlzdD1uZXcgcW4odGhpcyksdGhpcy5fbmFtZT1udWxsLHRoaXMuX21jZT1udWxsLHRoaXMuX2lzSXNvbGF0ZWQ9ITAsdGhpcy5fZGVwdGg9bmV3IHpuLHRoaXMuX2RlcHRoRGVsdGE9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07VW4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucHRzPXQsdGhpcy5fbGFiZWw9ZX19O2NsYXNzIGtuIGV4dGVuZHMgWW57Y29uc3RydWN0b3IoKXtzdXBlcigpLGtuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpe2ZvcihsZXQgdD10aGlzLmdldEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7aWYodC5uZXh0KCkuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSlyZXR1cm4hMH1yZXR1cm4hMX1pc0lzb2xhdGVkKCl7cmV0dXJuIDE9PT10aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9jb29yZH1wcmludCh0KXt0LnByaW50bG4oXCJub2RlIFwiK3RoaXMuX2Nvb3JkK1wiIGxibDogXCIrdGhpcy5fbGFiZWwpfWNvbXB1dGVJTSh0KXt9Y29tcHV0ZU1lcmdlZExvY2F0aW9uKHQsZSl7bGV0IG49bmUuTk9ORTtpZihuPXRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUpLCF0LmlzTnVsbChlKSl7Y29uc3Qgcz10LmdldExvY2F0aW9uKGUpO24hPT1uZS5CT1VOREFSWSYmKG49cyl9cmV0dXJuIG59c2V0TGFiZWwoKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aHx8IU51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKXx8IU51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSlyZXR1cm4gc3VwZXIuc2V0TGFiZWwuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtudWxsPT09dGhpcy5fbGFiZWw/dGhpcy5fbGFiZWw9bmV3IEZuKHQsZSk6dGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlKX19Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9bWVyZ2VMYWJlbCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Yga24pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubWVyZ2VMYWJlbCh0Ll9sYWJlbCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZuKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPDI7ZSsrKXtjb25zdCBuPXRoaXMuY29tcHV0ZU1lcmdlZExvY2F0aW9uKHQsZSk7dGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSk9PT1uZS5OT05FJiZ0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbihlLG4pfX19YWRkKHQpe3RoaXMuX2VkZ2VzLmluc2VydCh0KSx0LnNldE5vZGUodGhpcyl9c2V0TGFiZWxCb3VuZGFyeSh0KXtpZihudWxsPT09dGhpcy5fbGFiZWwpcmV0dXJuIG51bGw7bGV0IGU9bmUuTk9ORTtudWxsIT09dGhpcy5fbGFiZWwmJihlPXRoaXMuX2xhYmVsLmdldExvY2F0aW9uKHQpKTtsZXQgbj1udWxsO3N3aXRjaChlKXtjYXNlIG5lLkJPVU5EQVJZOm49bmUuSU5URVJJT1I7YnJlYWs7Y2FzZSBuZS5JTlRFUklPUjpkZWZhdWx0Om49bmUuQk9VTkRBUll9dGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxuKX1nZXRDbGFzcygpe3JldHVybiBrbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19a24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29vcmQ9bnVsbCx0aGlzLl9lZGdlcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Nvb3JkPXQsdGhpcy5fZWRnZXM9ZSx0aGlzLl9sYWJlbD1uZXcgRm4oMCxuZS5OT05FKX07Y2xhc3MgWG57Y29uc3RydWN0b3IoKXtYbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmQodCl7cmV0dXJuIHRoaXMubm9kZU1hcC5nZXQodCl9YWRkTm9kZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9dGhpcy5ub2RlTWFwLmdldCh0KTtyZXR1cm4gbnVsbD09PWUmJihlPXRoaXMubm9kZUZhY3QuY3JlYXRlTm9kZSh0KSx0aGlzLm5vZGVNYXAucHV0KHQsZSkpLGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBrbil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLm5vZGVNYXAuZ2V0KHQuZ2V0Q29vcmRpbmF0ZSgpKTtyZXR1cm4gbnVsbD09PWU/KHRoaXMubm9kZU1hcC5wdXQodC5nZXRDb29yZGluYXRlKCksdCksdCk6KGUubWVyZ2VMYWJlbCh0KSxlKX19cHJpbnQodCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1pdGVyYXRvcigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX12YWx1ZXMoKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpfWdldEJvdW5kYXJ5Tm9kZXModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk9PT1uZS5CT1VOREFSWSYmZS5hZGQocyl9cmV0dXJuIGV9YWRkKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKCk7dGhpcy5hZGROb2RlKGUpLmFkZCh0KX1nZXRDbGFzcygpe3JldHVybiBYbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19WG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5ub2RlTWFwPW5ldyBydCx0aGlzLm5vZGVGYWN0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5ub2RlRmFjdD10fTtjbGFzcyBIbntjb25zdHJ1Y3Rvcigpe0huLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcGFyZURpcmVjdGlvbih0KXtyZXR1cm4gdGhpcy5fZHg9PT10Ll9keCYmdGhpcy5fZHk9PT10Ll9keT8wOnRoaXMuX3F1YWRyYW50PnQuX3F1YWRyYW50PzE6dGhpcy5fcXVhZHJhbnQ8dC5fcXVhZHJhbnQ/LTE6di5pbmRleCh0Ll9wMCx0Ll9wMSx0aGlzLl9wMSl9Z2V0RHkoKXtyZXR1cm4gdGhpcy5fZHl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wMH1zZXROb2RlKHQpe3RoaXMuX25vZGU9dH1wcmludCh0KXtjb25zdCBlPU1hdGguYXRhbjIodGhpcy5fZHksdGhpcy5fZHgpLG49dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxzPW4ubGFzdEluZGV4T2YoXCIuXCIpLGk9bi5zdWJzdHJpbmcocysxKTt0LnByaW50KFwiICBcIitpK1wiOiBcIit0aGlzLl9wMCtcIiAtIFwiK3RoaXMuX3AxK1wiIFwiK3RoaXMuX3F1YWRyYW50K1wiOlwiK2UrXCIgICBcIit0aGlzLl9sYWJlbCl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlRGlyZWN0aW9uKGUpfWdldERpcmVjdGVkQ29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wMX1nZXREeCgpe3JldHVybiB0aGlzLl9keH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX2VkZ2V9Z2V0UXVhZHJhbnQoKXtyZXR1cm4gdGhpcy5fcXVhZHJhbnR9Z2V0Tm9kZSgpe3JldHVybiB0aGlzLl9ub2RlfXRvU3RyaW5nKCl7Y29uc3QgdD1NYXRoLmF0YW4yKHRoaXMuX2R5LHRoaXMuX2R4KSxlPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksbj1lLmxhc3RJbmRleE9mKFwiLlwiKTtyZXR1cm5cIiAgXCIrZS5zdWJzdHJpbmcobisxKStcIjogXCIrdGhpcy5fcDArXCIgLSBcIit0aGlzLl9wMStcIiBcIit0aGlzLl9xdWFkcmFudCtcIjpcIit0K1wiICAgXCIrdGhpcy5fbGFiZWx9Y29tcHV0ZUxhYmVsKHQpe31pbml0KHQsZSl7dGhpcy5fcDA9dCx0aGlzLl9wMT1lLHRoaXMuX2R4PWUueC10LngsdGhpcy5fZHk9ZS55LXQueSx0aGlzLl9xdWFkcmFudD1Jbi5xdWFkcmFudCh0aGlzLl9keCx0aGlzLl9keSksdS5pc1RydWUoISgwPT09dGhpcy5fZHgmJjA9PT10aGlzLl9keSksXCJFZGdlRW5kIHdpdGggaWRlbnRpY2FsIGVuZHBvaW50cyBmb3VuZFwiKX1nZXRDbGFzcygpe3JldHVybiBIbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fUhuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2VkZ2U9bnVsbCx0aGlzLl9sYWJlbD1udWxsLHRoaXMuX25vZGU9bnVsbCx0aGlzLl9wMD1udWxsLHRoaXMuX3AxPW51bGwsdGhpcy5fZHg9bnVsbCx0aGlzLl9keT1udWxsLHRoaXMuX3F1YWRyYW50PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2VkZ2U9dH1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtIbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuLG51bGwpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO0huLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCksdGhpcy5pbml0KGUsbiksdGhpcy5fbGFiZWw9c319O2NsYXNzIFduIGV4dGVuZHMgY3tjb25zdHJ1Y3Rvcigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtzdXBlcih0KSxjLmNhbGwodGhpcyx0KX1lbHNle2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXRocm93IEVycm9yKCk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3N1cGVyKFduLm1zZ1dpdGhDb29yZCh0LGUpKSx0aGlzLm5hbWU9XCJUb3BvbG9neUV4Y2VwdGlvblwiLHRoaXMucHQ9bmV3IGcoZSl9fX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMucHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119Z2V0Q2xhc3MoKXtyZXR1cm4gV259c3RhdGljIG1zZ1dpdGhDb29yZCh0LGUpe3JldHVybiBudWxsIT09ZT90K1wiIFsgXCIrZStcIiBdXCI6dH19Y2xhc3Mgam4gZXh0ZW5kcyBIbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksam4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGVwdGhGYWN0b3IodCxlKXtyZXR1cm4gdD09PW5lLkVYVEVSSU9SJiZlPT09bmUuSU5URVJJT1I/MTp0PT09bmUuSU5URVJJT1ImJmU9PT1uZS5FWFRFUklPUj8tMTowfWdldE5leHRNaW4oKXtyZXR1cm4gdGhpcy5fbmV4dE1pbn1nZXREZXB0aCh0KXtyZXR1cm4gdGhpcy5fZGVwdGhbdF19c2V0VmlzaXRlZCh0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH1jb21wdXRlRGlyZWN0ZWRMYWJlbCgpe3RoaXMuX2xhYmVsPW5ldyBGbih0aGlzLl9lZGdlLmdldExhYmVsKCkpLHRoaXMuX2lzRm9yd2FyZHx8dGhpcy5fbGFiZWwuZmxpcCgpfWdldE5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1zZXREZXB0aCh0LGUpe2lmKC05OTkhPT10aGlzLl9kZXB0aFt0XSYmdGhpcy5fZGVwdGhbdF0hPT1lKXRocm93IG5ldyBXbihcImFzc2lnbmVkIGRlcHRocyBkbyBub3QgbWF0Y2hcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7dGhpcy5fZGVwdGhbdF09ZX1pc0ludGVyaW9yQXJlYUVkZ2UoKXtsZXQgdD0hMDtmb3IobGV0IGU9MDtlPDI7ZSsrKXRoaXMuX2xhYmVsLmlzQXJlYShlKSYmdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSxQbi5MRUZUKT09PW5lLklOVEVSSU9SJiZ0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlLFBuLlJJR0hUKT09PW5lLklOVEVSSU9SfHwodD0hMSk7cmV0dXJuIHR9c2V0TmV4dE1pbih0KXt0aGlzLl9uZXh0TWluPXR9cHJpbnQodCl7c3VwZXIucHJpbnQuY2FsbCh0aGlzLHQpLHQucHJpbnQoXCIgXCIrdGhpcy5fZGVwdGhbUG4uTEVGVF0rXCIvXCIrdGhpcy5fZGVwdGhbUG4uUklHSFRdKSx0LnByaW50KFwiIChcIit0aGlzLmdldERlcHRoRGVsdGEoKStcIilcIiksdGhpcy5faXNJblJlc3VsdCYmdC5wcmludChcIiBpblJlc3VsdFwiKX1zZXRNaW5FZGdlUmluZyh0KXt0aGlzLl9taW5FZGdlUmluZz10fWlzTGluZUVkZ2UoKXtjb25zdCB0PXRoaXMuX2xhYmVsLmlzTGluZSgwKXx8dGhpcy5fbGFiZWwuaXNMaW5lKDEpLGU9IXRoaXMuX2xhYmVsLmlzQXJlYSgwKXx8dGhpcy5fbGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMCxuZS5FWFRFUklPUiksbj0hdGhpcy5fbGFiZWwuaXNBcmVhKDEpfHx0aGlzLl9sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgxLG5lLkVYVEVSSU9SKTtyZXR1cm4gdCYmZSYmbn1zZXRFZGdlUmluZyh0KXt0aGlzLl9lZGdlUmluZz10fWdldE1pbkVkZ2VSaW5nKCl7cmV0dXJuIHRoaXMuX21pbkVkZ2VSaW5nfWdldERlcHRoRGVsdGEoKXtsZXQgdD10aGlzLl9lZGdlLmdldERlcHRoRGVsdGEoKTtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfHwodD0tdCksdH1zZXRJblJlc3VsdCh0KXt0aGlzLl9pc0luUmVzdWx0PXR9Z2V0U3ltKCl7cmV0dXJuIHRoaXMuX3N5bX1pc0ZvcndhcmQoKXtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fZWRnZX1wcmludEVkZ2UodCl7dGhpcy5wcmludCh0KSx0LnByaW50KFwiIFwiKSx0aGlzLl9pc0ZvcndhcmQ/dGhpcy5fZWRnZS5wcmludCh0KTp0aGlzLl9lZGdlLnByaW50UmV2ZXJzZSh0KX1zZXRTeW0odCl7dGhpcy5fc3ltPXR9c2V0VmlzaXRlZEVkZ2UodCl7dGhpcy5zZXRWaXNpdGVkKHQpLHRoaXMuX3N5bS5zZXRWaXNpdGVkKHQpfXNldEVkZ2VEZXB0aHModCxlKXtsZXQgbj10aGlzLmdldEVkZ2UoKS5nZXREZXB0aERlbHRhKCk7dGhpcy5faXNGb3J3YXJkfHwobj0tbik7bGV0IHM9MTt0PT09UG4uTEVGVCYmKHM9LTEpO2NvbnN0IGk9UG4ub3Bwb3NpdGUodCkscj1lK24qczt0aGlzLnNldERlcHRoKHQsZSksdGhpcy5zZXREZXB0aChpLHIpfWdldEVkZ2VSaW5nKCl7cmV0dXJuIHRoaXMuX2VkZ2VSaW5nfWlzSW5SZXN1bHQoKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfWdldENsYXNzKCl7cmV0dXJuIGpufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1qbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc0ZvcndhcmQ9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fbmV4dE1pbj1udWxsLHRoaXMuX2VkZ2VSaW5nPW51bGwsdGhpcy5fbWluRWRnZVJpbmc9bnVsbCx0aGlzLl9kZXB0aD1bMCwtOTk5LC05OTldO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKEhuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCksdGhpcy5faXNGb3J3YXJkPWUsZSl0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKDApLHQuZ2V0Q29vcmRpbmF0ZSgxKSk7ZWxzZXtjb25zdCBlPXQuZ2V0TnVtUG9pbnRzKCktMTt0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKGUpLHQuZ2V0Q29vcmRpbmF0ZShlLTEpKX10aGlzLmNvbXB1dGVEaXJlY3RlZExhYmVsKCl9O2NsYXNzIEtue2NvbnN0cnVjdG9yKCl7S24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVOb2RlKHQpe3JldHVybiBuZXcga24odCxudWxsKX1nZXRDbGFzcygpe3JldHVybiBLbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19S24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBabntjb25zdHJ1Y3Rvcigpe1puLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fXByaW50RWRnZXModCl7dC5wcmludGxuKFwiRWRnZXM6XCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKyl7dC5wcmludGxuKFwiZWRnZSBcIitlK1wiOlwiKTtjb25zdCBuPXRoaXMuX2VkZ2VzLmdldChlKTtuLnByaW50KHQpLG4uZWlMaXN0LnByaW50KHQpfX1maW5kKHQpe3JldHVybiB0aGlzLl9ub2Rlcy5maW5kKHQpfWFkZE5vZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGtuKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9ub2Rlcy5hZGROb2RlKHQpfX1nZXROb2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKX1saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpfX1kZWJ1Z1ByaW50bG4odCl7Ty5vdXQucHJpbnRsbih0KX1pc0JvdW5kYXJ5Tm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fbm9kZXMuZmluZChlKTtpZihudWxsPT09bilyZXR1cm4hMTtjb25zdCBzPW4uZ2V0TGFiZWwoKTtyZXR1cm4gbnVsbCE9PXMmJnMuZ2V0TG9jYXRpb24odCk9PT1uZS5CT1VOREFSWX1saW5rQWxsRGlyZWN0ZWRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rQWxsRGlyZWN0ZWRFZGdlcygpfX1tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsbixzKXtyZXR1cm4hIXQuZXF1YWxzKG4pJiYodi5pbmRleCh0LGUscyk9PT12LkNPTExJTkVBUiYmSW4ucXVhZHJhbnQodCxlKT09PUluLnF1YWRyYW50KG4scykpfWdldEVkZ2VFbmRzKCl7cmV0dXJuIHRoaXMuX2VkZ2VFbmRMaXN0fWRlYnVnUHJpbnQodCl7Ty5vdXQucHJpbnQodCl9Z2V0RWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9ZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24odCxlKXtmb3IobGV0IG49MDtuPHRoaXMuX2VkZ2VzLnNpemUoKTtuKyspe2NvbnN0IHM9dGhpcy5fZWRnZXMuZ2V0KG4pLGk9cy5nZXRDb29yZGluYXRlcygpO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLGlbMF0saVsxXSkpcmV0dXJuIHM7aWYodGhpcy5tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsaVtpLmxlbmd0aC0xXSxpW2kubGVuZ3RoLTJdKSlyZXR1cm4gc31yZXR1cm4gbnVsbH1pbnNlcnRFZGdlKHQpe3RoaXMuX2VkZ2VzLmFkZCh0KX1maW5kRWRnZUVuZCh0KXtmb3IobGV0IGU9dGhpcy5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4uZ2V0RWRnZSgpPT09dClyZXR1cm4gbn1yZXR1cm4gbnVsbH1hZGRFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9lZGdlcy5hZGQodCk7Y29uc3Qgbj1uZXcgam4odCwhMCkscz1uZXcgam4odCwhMSk7bi5zZXRTeW0ocykscy5zZXRTeW0obiksdGhpcy5hZGQobiksdGhpcy5hZGQocyl9fWFkZCh0KXt0aGlzLl9ub2Rlcy5hZGQodCksdGhpcy5fZWRnZUVuZExpc3QuYWRkKHQpfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzLnZhbHVlcygpfWZpbmRFZGdlKHQsZSl7Zm9yKGxldCBuPTA7bjx0aGlzLl9lZGdlcy5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuX2VkZ2VzLmdldChuKSxpPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0LmVxdWFscyhpWzBdKSYmZS5lcXVhbHMoaVsxXSkpcmV0dXJuIHN9cmV0dXJuIG51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gWm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVpuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2VkZ2VzPW5ldyB4LHRoaXMuX25vZGVzPW51bGwsdGhpcy5fZWRnZUVuZExpc3Q9bmV3IHgsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fbm9kZXM9bmV3IFhuKG5ldyBLbik7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbm9kZXM9bmV3IFhuKHQpfX07Y2xhc3MgUW4gZXh0ZW5kcyBabntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGV0ZXJtaW5lQm91bmRhcnkodCxlKXtyZXR1cm4gdC5pc0luQm91bmRhcnkoZSk/bmUuQk9VTkRBUlk6bmUuSU5URVJJT1J9aW5zZXJ0Qm91bmRhcnlQb2ludCh0LGUpe2NvbnN0IG49dGhpcy5fbm9kZXMuYWRkTm9kZShlKS5nZXRMYWJlbCgpO2xldCBzPTEsaT1uZS5OT05FO2k9bi5nZXRMb2NhdGlvbih0LFBuLk9OKSxpPT09bmUuQk9VTkRBUlkmJnMrKztjb25zdCByPVFuLmRldGVybWluZUJvdW5kYXJ5KHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGUscyk7bi5zZXRMb2NhdGlvbih0LHIpfWNvbXB1dGVTZWxmTm9kZXMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcHV0ZVNlbGZOb2Rlcyh0LGUsITEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBNbih0LCEwLCExKTtzLnNldElzRG9uZUlmUHJvcGVySW50KG4pO2NvbnN0IGk9dGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKSxyPXRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBEdHx8dGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIGJ0fHx0aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgQXQsbz1lfHwhcjtyZXR1cm4gaS5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLl9lZGdlcyxzLG8pLHRoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzKHRoaXMuX2FyZ0luZGV4KSxzfX1jb21wdXRlU3BsaXRFZGdlcyh0KXtmb3IobGV0IGU9dGhpcy5fZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmVpTGlzdC5hZGRTcGxpdEVkZ2VzKHQpfX1jb21wdXRlRWRnZUludGVyc2VjdGlvbnModCxlLG4pe2NvbnN0IHM9bmV3IE1uKGUsbiwhMCk7cmV0dXJuIHMuc2V0Qm91bmRhcnlOb2Rlcyh0aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSx0LmdldEJvdW5kYXJ5Tm9kZXMoKSksdGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKS5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLl9lZGdlcyx0Ll9lZGdlcyxzKSxzfWdldEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX3BhcmVudEdlb219Z2V0Qm91bmRhcnlOb2RlUnVsZSgpe3JldHVybiB0aGlzLl9ib3VuZGFyeU5vZGVSdWxlfWhhc1Rvb0Zld1BvaW50cygpe3JldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHN9YWRkUG9pbnQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFB0KXtjb25zdCB0PWFyZ3VtZW50c1swXS5nZXRDb29yZGluYXRlKCk7dGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCx0LG5lLklOVEVSSU9SKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCx0LG5lLklOVEVSSU9SKX19YWRkUG9seWdvbih0KXt0aGlzLmFkZFBvbHlnb25SaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksbmUuRVhURVJJT1IsbmUuSU5URVJJT1IpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe2NvbnN0IG49dC5nZXRJbnRlcmlvclJpbmdOKGUpO3RoaXMuYWRkUG9seWdvblJpbmcobixuZS5JTlRFUklPUixuZS5FWFRFUklPUil9fWFkZEVkZ2UodCl7dGhpcy5pbnNlcnRFZGdlKHQpO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsZVswXSxuZS5CT1VOREFSWSksdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCxlW2UubGVuZ3RoLTFdLG5lLkJPVU5EQVJZKX1hZGRMaW5lU3RyaW5nKHQpe2NvbnN0IGU9WC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLl9pbnZhbGlkUG9pbnQ9ZVswXSxudWxsO2NvbnN0IG49bmV3IFVuKGUsbmV3IEZuKHRoaXMuX2FyZ0luZGV4LG5lLklOVEVSSU9SKSk7dGhpcy5fbGluZUVkZ2VNYXAucHV0KHQsbiksdGhpcy5pbnNlcnRFZGdlKG4pLHUuaXNUcnVlKGUubGVuZ3RoPj0yLFwiZm91bmQgTGluZVN0cmluZyB3aXRoIHNpbmdsZSBwb2ludFwiKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsZVswXSksdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuX2FyZ0luZGV4LGVbZS5sZW5ndGgtMV0pfWdldEludmFsaWRQb2ludCgpe3JldHVybiB0aGlzLl9pbnZhbGlkUG9pbnR9Z2V0Qm91bmRhcnlQb2ludHMoKXtjb25zdCB0PXRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBuPTA7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7ZVtuKytdPXQuZ2V0Q29vcmRpbmF0ZSgpLmNvcHkoKX1yZXR1cm4gZX1nZXRCb3VuZGFyeU5vZGVzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9ib3VuZGFyeU5vZGVzJiYodGhpcy5fYm91bmRhcnlOb2Rlcz10aGlzLl9ub2Rlcy5nZXRCb3VuZGFyeU5vZGVzKHRoaXMuX2FyZ0luZGV4KSksdGhpcy5fYm91bmRhcnlOb2Rlc31hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSh0LGUsbil7aWYodGhpcy5pc0JvdW5kYXJ5Tm9kZSh0LGUpKXJldHVybiBudWxsO249PT1uZS5CT1VOREFSWSYmdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT90aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodCxlKTp0aGlzLmluc2VydFBvaW50KHQsZSxuKX1hZGRQb2x5Z29uUmluZyh0LGUsbil7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgcz1YLnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYocy5sZW5ndGg8NClyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzPSEwLHRoaXMuX2ludmFsaWRQb2ludD1zWzBdLG51bGw7bGV0IGk9ZSxyPW47di5pc0NDVyhzKSYmKGk9bixyPWUpO2NvbnN0IG89bmV3IFVuKHMsbmV3IEZuKHRoaXMuX2FyZ0luZGV4LG5lLkJPVU5EQVJZLGkscikpO3RoaXMuX2xpbmVFZGdlTWFwLnB1dCh0LG8pLHRoaXMuaW5zZXJ0RWRnZShvKSx0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LHNbMF0sbmUuQk9VTkRBUlkpfWluc2VydFBvaW50KHQsZSxuKXtjb25zdCBzPXRoaXMuX25vZGVzLmFkZE5vZGUoZSksaT1zLmdldExhYmVsKCk7bnVsbD09PWk/cy5fbGFiZWw9bmV3IEZuKHQsbik6aS5zZXRMb2NhdGlvbih0LG4pfWNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3Rvcigpe3JldHVybiBuZXcgRG59YWRkU2VsZkludGVyc2VjdGlvbk5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9lZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtmb3IobGV0IGU9bi5laUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSh0LG4uY29vcmQscyl9fX1hZGQoKXtpZighKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpKXJldHVybiBzdXBlci5hZGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgQXQmJih0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSExKSx0IGluc3RhbmNlb2YgYnQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBQdCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIE10KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgX3QpKXRocm93IG5ldyBaKHQuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19fWFkZENvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fWxvY2F0ZSh0KXtyZXR1cm4gXyh0aGlzLl9wYXJlbnRHZW9tLE90KSYmdGhpcy5fcGFyZW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk+NTA/KG51bGw9PT10aGlzLl9hcmVhUHRMb2NhdG9yJiYodGhpcy5fYXJlYVB0TG9jYXRvcj1uZXcga2UodGhpcy5fcGFyZW50R2VvbSkpLHRoaXMuX2FyZWFQdExvY2F0b3IubG9jYXRlKHQpKTp0aGlzLl9wdExvY2F0b3IubG9jYXRlKHQsdGhpcy5fcGFyZW50R2VvbSl9ZmluZEVkZ2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2xpbmVFZGdlTWFwLmdldCh0KX1yZXR1cm4gc3VwZXIuZmluZEVkZ2UuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIFFufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Rbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wYXJlbnRHZW9tPW51bGwsdGhpcy5fbGluZUVkZ2VNYXA9bmV3IFV0LHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGU9bnVsbCx0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSEwLHRoaXMuX2FyZ0luZGV4PW51bGwsdGhpcy5fYm91bmRhcnlOb2Rlcz1udWxsLHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMSx0aGlzLl9pbnZhbGlkUG9pbnQ9bnVsbCx0aGlzLl9hcmVhUHRMb2NhdG9yPW51bGwsdGhpcy5fcHRMb2NhdG9yPW5ldyBfbiwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07UW4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsVi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2FyZ0luZGV4PXQsdGhpcy5fcGFyZW50R2VvbT1lLHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGU9bixudWxsIT09ZSYmdGhpcy5hZGQoZSl9fTt2YXIgSm49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvbWV0cnlHcmFwaDpRbn0pO2NsYXNzICRue2NvbnN0cnVjdG9yKCl7JG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdCh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gJG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fSRuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgdHN7Y29uc3RydWN0b3IoKXt0cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzUmVwZWF0ZWQoKXtyZXR1cm4gdGhpcy5fY291bnQ+MX1nZXRSaWdodCgpe3JldHVybiB0aGlzLl9yaWdodH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B9c2V0TGVmdCh0KXt0aGlzLl9sZWZ0PXR9Z2V0WCgpe3JldHVybiB0aGlzLl9wLnh9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWdldENvdW50KCl7cmV0dXJuIHRoaXMuX2NvdW50fWdldExlZnQoKXtyZXR1cm4gdGhpcy5fbGVmdH1nZXRZKCl7cmV0dXJuIHRoaXMuX3AueX1pbmNyZW1lbnQoKXt0aGlzLl9jb3VudD10aGlzLl9jb3VudCsxfXNldFJpZ2h0KHQpe3RoaXMuX3JpZ2h0PXR9Z2V0Q2xhc3MoKXtyZXR1cm4gdHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXRzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3A9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5fbGVmdD1udWxsLHRoaXMuX3JpZ2h0PW51bGwsdGhpcy5fY291bnQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD1uZXcgZyh0KSx0aGlzLl9sZWZ0PW51bGwsdGhpcy5fcmlnaHQ9bnVsbCx0aGlzLl9jb3VudD0xLHRoaXMuX2RhdGE9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wPW5ldyBnKHQsZSksdGhpcy5fbGVmdD1udWxsLHRoaXMuX3JpZ2h0PW51bGwsdGhpcy5fY291bnQ9MSx0aGlzLl9kYXRhPW59fTtjbGFzcyBlc3tjb25zdHJ1Y3Rvcigpe2VzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvQ29vcmRpbmF0ZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGVzLnRvQ29vcmRpbmF0ZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEk7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCksaT1lP3QuZ2V0Q291bnQoKToxO2ZvcihsZXQgZT0wO2U8aTtlKyspbi5hZGQodC5nZXRDb29yZGluYXRlKCksITApfXJldHVybiBuLnRvQ29vcmRpbmF0ZUFycmF5KCl9fWluc2VydCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbnNlcnQodCxudWxsKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYobnVsbD09PXRoaXMuX3Jvb3QpcmV0dXJuIHRoaXMuX3Jvb3Q9bmV3IHRzKHQsZSksdGhpcy5fcm9vdDtpZih0aGlzLl90b2xlcmFuY2U+MCl7Y29uc3QgZT10aGlzLmZpbmRCZXN0TWF0Y2hOb2RlKHQpO2lmKG51bGwhPT1lKXJldHVybiBlLmluY3JlbWVudCgpLGV9cmV0dXJuIHRoaXMuaW5zZXJ0RXhhY3QodCxlKX19cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgeDtyZXR1cm4gdGhpcy5xdWVyeSh0LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOJiZfKGFyZ3VtZW50c1sxXSxtKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5xdWVyeU5vZGUodGhpcy5fcm9vdCx0LCEwLG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bJG5dfXZpc2l0KHQpe2UuYWRkKHQpfX0pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOJiZfKGFyZ3VtZW50c1sxXSwkbikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucXVlcnlOb2RlKHRoaXMuX3Jvb3QsdCwhMCxlKX19cXVlcnlOb2RlKHQsZSxuLHMpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2xldCBpPW51bGwscj1udWxsLG89bnVsbDtuPyhpPWUuZ2V0TWluWCgpLHI9ZS5nZXRNYXhYKCksbz10LmdldFgoKSk6KGk9ZS5nZXRNaW5ZKCkscj1lLmdldE1heFkoKSxvPXQuZ2V0WSgpKTtjb25zdCBsPW88PXI7aTxvJiZ0aGlzLnF1ZXJ5Tm9kZSh0LmdldExlZnQoKSxlLCFuLHMpLGUuY29udGFpbnModC5nZXRDb29yZGluYXRlKCkpJiZzLnZpc2l0KHQpLGwmJnRoaXMucXVlcnlOb2RlKHQuZ2V0UmlnaHQoKSxlLCFuLHMpfWZpbmRCZXN0TWF0Y2hOb2RlKHQpe2NvbnN0IGU9bmV3IG5zKHQsdGhpcy5fdG9sZXJhbmNlKTtyZXR1cm4gdGhpcy5xdWVyeShlLnF1ZXJ5RW52ZWxvcGUoKSxlKSxlLmdldE5vZGUoKX1pc0VtcHR5KCl7cmV0dXJuIG51bGw9PT10aGlzLl9yb290fWluc2VydEV4YWN0KHQsZSl7bGV0IG49dGhpcy5fcm9vdCxzPXRoaXMuX3Jvb3QsaT0hMCxyPSEwO2Zvcig7bnVsbCE9PW47KXtpZihudWxsIT09bil7aWYodC5kaXN0YW5jZShuLmdldENvb3JkaW5hdGUoKSk8PXRoaXMuX3RvbGVyYW5jZSlyZXR1cm4gbi5pbmNyZW1lbnQoKSxufXI9aT90Lng8bi5nZXRYKCk6dC55PG4uZ2V0WSgpLHM9bixuPXI/bi5nZXRMZWZ0KCk6bi5nZXRSaWdodCgpLGk9IWl9dGhpcy5fbnVtYmVyT2ZOb2Rlcz10aGlzLl9udW1iZXJPZk5vZGVzKzE7Y29uc3Qgbz1uZXcgdHModCxlKTtyZXR1cm4gcj9zLnNldExlZnQobyk6cy5zZXRSaWdodChvKSxvfWdldENsYXNzKCl7cmV0dXJuIGVzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBuc3tjb25zdHJ1Y3Rvcigpe25zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXQodCl7Y29uc3QgZT10aGlzLl9wLmRpc3RhbmNlKHQuZ2V0Q29vcmRpbmF0ZSgpKTtpZighKGU8PXRoaXMuX3RvbGVyYW5jZSkpcmV0dXJuIG51bGw7bGV0IG49ITE7KG51bGw9PT10aGlzLl9tYXRjaE5vZGV8fGU8dGhpcy5fbWF0Y2hEaXN0fHxudWxsIT09dGhpcy5fbWF0Y2hOb2RlJiZlPT09dGhpcy5fbWF0Y2hEaXN0JiZ0LmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odGhpcy5fbWF0Y2hOb2RlLmdldENvb3JkaW5hdGUoKSk8MSkmJihuPSEwKSxuJiYodGhpcy5fbWF0Y2hOb2RlPXQsdGhpcy5fbWF0Y2hEaXN0PWUpfXF1ZXJ5RW52ZWxvcGUoKXtjb25zdCB0PW5ldyBOKHRoaXMuX3ApO3JldHVybiB0LmV4cGFuZEJ5KHRoaXMuX3RvbGVyYW5jZSksdH1nZXROb2RlKCl7cmV0dXJuIHRoaXMuX21hdGNoTm9kZX1nZXRDbGFzcygpe3JldHVybiBuc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bJG5dfX1ucy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl90b2xlcmFuY2U9bnVsbCx0aGlzLl9tYXRjaE5vZGU9bnVsbCx0aGlzLl9tYXRjaERpc3Q9MCx0aGlzLl9wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD10LHRoaXMuX3RvbGVyYW5jZT1lfSxlcy5CZXN0TWF0Y2hWaXNpdG9yPW5zLGVzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9udW1iZXJPZk5vZGVzPW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpZXMuY29uc3RydWN0b3JfLmNhbGwodGhpcywwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl90b2xlcmFuY2U9dH19O3ZhciBzcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxLZFRyZWU6ZXN9KTtjbGFzcyBpc3tjb25zdHJ1Y3Rvcigpe2lzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldFN1Ym5vZGVJbmRleCh0LGUsbil7bGV0IHM9LTE7cmV0dXJuIHQuZ2V0TWluWCgpPj1lJiYodC5nZXRNaW5ZKCk+PW4mJihzPTMpLHQuZ2V0TWF4WSgpPD1uJiYocz0xKSksdC5nZXRNYXhYKCk8PWUmJih0LmdldE1pblkoKT49biYmKHM9MiksdC5nZXRNYXhZKCk8PW4mJihzPTApKSxzfWhhc0NoaWxkcmVuKCl7Zm9yKGxldCB0PTA7dDw0O3QrKylpZihudWxsIT09dGhpcy5fc3Vibm9kZVt0XSlyZXR1cm4hMDtyZXR1cm4hMX1pc1BydW5hYmxlKCl7cmV0dXJuISh0aGlzLmhhc0NoaWxkcmVuKCl8fHRoaXMuaGFzSXRlbXMoKSl9YWRkQWxsSXRlbXModCl7dC5hZGRBbGwodGhpcy5faXRlbXMpO2ZvcihsZXQgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJnRoaXMuX3N1Ym5vZGVbZV0uYWRkQWxsSXRlbXModCk7cmV0dXJuIHR9Z2V0Tm9kZUNvdW50KCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLl9zdWJub2RlW2VdJiYodCs9dGhpcy5fc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0KzF9c2l6ZSgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmKHQrPXRoaXMuX3N1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCt0aGlzLl9pdGVtcy5zaXplKCl9YWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO2UuYWRkQWxsKHRoaXMuX2l0ZW1zKTtmb3IobGV0IG49MDtuPDQ7bisrKW51bGwhPT10aGlzLl9zdWJub2RlW25dJiZ0aGlzLl9zdWJub2RlW25dLmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSl9dmlzaXRJdGVtcyh0LGUpe2ZvcihsZXQgdD10aGlzLl9pdGVtcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyllLnZpc2l0SXRlbSh0Lm5leHQoKSl9aGFzSXRlbXMoKXtyZXR1cm4hdGhpcy5faXRlbXMuaXNFbXB0eSgpfXJlbW92ZSh0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuITE7bGV0IG49ITE7Zm9yKGxldCBzPTA7czw0O3MrKylpZihudWxsIT09dGhpcy5fc3Vibm9kZVtzXSYmKG49dGhpcy5fc3Vibm9kZVtzXS5yZW1vdmUodCxlKSxuKSl7dGhpcy5fc3Vibm9kZVtzXS5pc1BydW5hYmxlKCkmJih0aGlzLl9zdWJub2RlW3NdPW51bGwpO2JyZWFrfXJldHVybiBufHwobj10aGlzLl9pdGVtcy5yZW1vdmUoZSksbil9dmlzaXQodCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO3RoaXMudmlzaXRJdGVtcyh0LGUpO2ZvcihsZXQgbj0wO248NDtuKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbbl0mJnRoaXMuX3N1Ym5vZGVbbl0udmlzaXQodCxlKX1nZXRJdGVtcygpe3JldHVybiB0aGlzLl9pdGVtc31kZXB0aCgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTw0O2UrKylpZihudWxsIT09dGhpcy5fc3Vibm9kZVtlXSl7Y29uc3Qgbj10aGlzLl9zdWJub2RlW2VdLmRlcHRoKCk7bj50JiYodD1uKX1yZXR1cm4gdCsxfWlzRW1wdHkoKXtsZXQgdD0hMDtpZih0aGlzLl9pdGVtcy5pc0VtcHR5KCkpe2ZvcihsZXQgZT0wO2U8NDtlKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJiF0aGlzLl9zdWJub2RlW2VdLmlzRW1wdHkoKSl7dD0hMTticmVha319ZWxzZSB0PSExO3JldHVybiB0fWFkZCh0KXt0aGlzLl9pdGVtcy5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gaXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX1mdW5jdGlvbiBycygpe31pcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pdGVtcz1uZXcgeCx0aGlzLl9zdWJub2RlPW5ldyBBcnJheSg0KS5maWxsKG51bGwpfSxycy5leHBvbmVudD1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlKXtsZXQgbixzLGkscjtjb25zdCBvPXszMjp7ZDoxMjcsYzoxMjgsYjowLGE6MH0sNjQ6e2Q6MzI3NTIsYzowLGI6MCxhOjB9fSxsPXszMjo4LDY0OjExfVt0XTtyfHwobj1lPDB8fDEvZTwwLGlzRmluaXRlKGUpfHwocj1vW3RdLG4mJihyLmQrPTE8PHQvNC0xKSxzPU1hdGgucG93KDIsbCktMSxpPTApKTtpZighcil7Zm9yKHM9ezMyOjEyNyw2NDoxMDIzfVt0XSxpPU1hdGguYWJzKGUpO2k+PTI7KXMrKyxpLz0yO2Zvcig7aTwxJiZzPjA7KXMtLSxpKj0yO3M8PTAmJihpLz0yKSwzMj09PXQmJnM+MjU0JiYocj17ZDpuPzI1NToxMjcsYzoxMjgsYjowLGE6MH0scz1NYXRoLnBvdygyLGwpLTEsaT0wKX1yZXR1cm4gc30oNjQsdCktMTAyM30scnMucG93ZXJPZjI9ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucG93KDIsdCl9O2NsYXNzIG9ze2NvbnN0cnVjdG9yKCl7b3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tcHV0ZVF1YWRMZXZlbCh0KXtjb25zdCBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCkscz1lPm4/ZTpuO3JldHVybiBycy5leHBvbmVudChzKSsxfWdldExldmVsKCl7cmV0dXJuIHRoaXMuX2xldmVsfWNvbXB1dGVLZXkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKHRoaXMuX2xldmVsPW9zLmNvbXB1dGVRdWFkTGV2ZWwodCksdGhpcy5fZW52PW5ldyBOLHRoaXMuY29tcHV0ZUtleSh0aGlzLl9sZXZlbCx0KTshdGhpcy5fZW52LmNvbnRhaW5zKHQpOyl0aGlzLl9sZXZlbCs9MSx0aGlzLmNvbXB1dGVLZXkodGhpcy5fbGV2ZWwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1ycy5wb3dlck9mMih0KTt0aGlzLl9wdC54PU1hdGguZmxvb3IoZS5nZXRNaW5YKCkvbikqbix0aGlzLl9wdC55PU1hdGguZmxvb3IoZS5nZXRNaW5ZKCkvbikqbix0aGlzLl9lbnYuaW5pdCh0aGlzLl9wdC54LHRoaXMuX3B0Lngrbix0aGlzLl9wdC55LHRoaXMuX3B0Lnkrbil9fWdldEVudmVsb3BlKCl7cmV0dXJuIHRoaXMuX2Vudn1nZXRDZW50cmUoKXtyZXR1cm4gbmV3IGcoKHRoaXMuX2Vudi5nZXRNaW5YKCkrdGhpcy5fZW52LmdldE1heFgoKSkvMiwodGhpcy5fZW52LmdldE1pblkoKSt0aGlzLl9lbnYuZ2V0TWF4WSgpKS8yKX1nZXRQb2ludCgpe3JldHVybiB0aGlzLl9wdH1nZXRDbGFzcygpe3JldHVybiBvc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19b3MuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHQ9bmV3IGcsdGhpcy5fbGV2ZWw9MCx0aGlzLl9lbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXB1dGVLZXkodCl9O2NsYXNzIGxzIGV4dGVuZHMgaXN7Y29uc3RydWN0b3IoKXtzdXBlcigpLGxzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNyZWF0ZU5vZGUodCl7Y29uc3QgZT1uZXcgb3ModCk7cmV0dXJuIG5ldyBscyhlLmdldEVudmVsb3BlKCksZS5nZXRMZXZlbCgpKX1zdGF0aWMgY3JlYXRlRXhwYW5kZWQodCxlKXtjb25zdCBuPW5ldyBOKGUpO251bGwhPT10JiZuLmV4cGFuZFRvSW5jbHVkZSh0Ll9lbnYpO2NvbnN0IHM9bHMuY3JlYXRlTm9kZShuKTtyZXR1cm4gbnVsbCE9PXQmJnMuaW5zZXJ0Tm9kZSh0KSxzfWZpbmQodCl7Y29uc3QgZT1pcy5nZXRTdWJub2RlSW5kZXgodCx0aGlzLl9jZW50cmV4LHRoaXMuX2NlbnRyZXkpO2lmKC0xPT09ZSlyZXR1cm4gdGhpcztpZihudWxsIT09dGhpcy5fc3Vibm9kZVtlXSl7cmV0dXJuIHRoaXMuX3N1Ym5vZGVbZV0uZmluZCh0KX1yZXR1cm4gdGhpc31pc1NlYXJjaE1hdGNoKHQpe3JldHVybiBudWxsIT09dCYmdGhpcy5fZW52LmludGVyc2VjdHModCl9Z2V0U3Vibm9kZSh0KXtyZXR1cm4gbnVsbD09PXRoaXMuX3N1Ym5vZGVbdF0mJih0aGlzLl9zdWJub2RlW3RdPXRoaXMuY3JlYXRlU3Vibm9kZSh0KSksdGhpcy5fc3Vibm9kZVt0XX1nZXRFbnZlbG9wZSgpe3JldHVybiB0aGlzLl9lbnZ9Z2V0Tm9kZSh0KXtjb25zdCBlPWlzLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuX2NlbnRyZXgsdGhpcy5fY2VudHJleSk7aWYoLTEhPT1lKXtyZXR1cm4gdGhpcy5nZXRTdWJub2RlKGUpLmdldE5vZGUodCl9cmV0dXJuIHRoaXN9Y3JlYXRlU3Vibm9kZSh0KXtsZXQgZT0wLG49MCxzPTAsaT0wO3N3aXRjaCh0KXtjYXNlIDA6ZT10aGlzLl9lbnYuZ2V0TWluWCgpLG49dGhpcy5fY2VudHJleCxzPXRoaXMuX2Vudi5nZXRNaW5ZKCksaT10aGlzLl9jZW50cmV5O2JyZWFrO2Nhc2UgMTplPXRoaXMuX2NlbnRyZXgsbj10aGlzLl9lbnYuZ2V0TWF4WCgpLHM9dGhpcy5fZW52LmdldE1pblkoKSxpPXRoaXMuX2NlbnRyZXk7YnJlYWs7Y2FzZSAyOmU9dGhpcy5fZW52LmdldE1pblgoKSxuPXRoaXMuX2NlbnRyZXgscz10aGlzLl9jZW50cmV5LGk9dGhpcy5fZW52LmdldE1heFkoKTticmVhaztjYXNlIDM6ZT10aGlzLl9jZW50cmV4LG49dGhpcy5fZW52LmdldE1heFgoKSxzPXRoaXMuX2NlbnRyZXksaT10aGlzLl9lbnYuZ2V0TWF4WSgpfWNvbnN0IHI9bmV3IE4oZSxuLHMsaSk7cmV0dXJuIG5ldyBscyhyLHRoaXMuX2xldmVsLTEpfWluc2VydE5vZGUodCl7dS5pc1RydWUobnVsbD09PXRoaXMuX2Vudnx8dGhpcy5fZW52LmNvbnRhaW5zKHQuX2VudikpO2NvbnN0IGU9aXMuZ2V0U3Vibm9kZUluZGV4KHQuX2Vudix0aGlzLl9jZW50cmV4LHRoaXMuX2NlbnRyZXkpO2lmKHQuX2xldmVsPT09dGhpcy5fbGV2ZWwtMSl0aGlzLl9zdWJub2RlW2VdPXQ7ZWxzZXtjb25zdCBuPXRoaXMuY3JlYXRlU3Vibm9kZShlKTtuLmluc2VydE5vZGUodCksdGhpcy5fc3Vibm9kZVtlXT1ufX1nZXRDbGFzcygpe3JldHVybiBsc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZW52PW51bGwsdGhpcy5fY2VudHJleD1udWxsLHRoaXMuX2NlbnRyZXk9bnVsbCx0aGlzLl9sZXZlbD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Vudj10LHRoaXMuX2xldmVsPWUsdGhpcy5fY2VudHJleD0odC5nZXRNaW5YKCkrdC5nZXRNYXhYKCkpLzIsdGhpcy5fY2VudHJleT0odC5nZXRNaW5ZKCkrdC5nZXRNYXhZKCkpLzJ9O2NsYXNzIGFze2NvbnN0cnVjdG9yKCl7YXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNaZXJvV2lkdGgodCxlKXtjb25zdCBuPWUtdDtpZigwPT09bilyZXR1cm4hMDtjb25zdCBzPW4vTWF0aC5tYXgoTWF0aC5hYnModCksTWF0aC5hYnMoZSkpO3JldHVybiBycy5leHBvbmVudChzKTw9YXMuTUlOX0JJTkFSWV9FWFBPTkVOVH1nZXRDbGFzcygpe3JldHVybiBhc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19YXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxhcy5NSU5fQklOQVJZX0VYUE9ORU5UPS01MDtjbGFzcyBjcyBleHRlbmRzIGlze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxjcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydCh0LGUpe2NvbnN0IG49aXMuZ2V0U3Vibm9kZUluZGV4KHQsY3Mub3JpZ2luLngsY3Mub3JpZ2luLnkpO2lmKC0xPT09bilyZXR1cm4gdGhpcy5hZGQoZSksbnVsbDtjb25zdCBzPXRoaXMuX3N1Ym5vZGVbbl07aWYobnVsbD09PXN8fCFzLmdldEVudmVsb3BlKCkuY29udGFpbnModCkpe2NvbnN0IGU9bHMuY3JlYXRlRXhwYW5kZWQocyx0KTt0aGlzLl9zdWJub2RlW25dPWV9dGhpcy5pbnNlcnRDb250YWluZWQodGhpcy5fc3Vibm9kZVtuXSx0LGUpfWlzU2VhcmNoTWF0Y2godCl7cmV0dXJuITB9aW5zZXJ0Q29udGFpbmVkKHQsZSxuKXt1LmlzVHJ1ZSh0LmdldEVudmVsb3BlKCkuY29udGFpbnMoZSkpO2NvbnN0IHM9YXMuaXNaZXJvV2lkdGgoZS5nZXRNaW5YKCksZS5nZXRNYXhYKCkpLGk9YXMuaXNaZXJvV2lkdGgoZS5nZXRNaW5ZKCksZS5nZXRNYXhZKCkpO2xldCByPW51bGw7cj1zfHxpP3QuZmluZChlKTp0LmdldE5vZGUoZSksci5hZGQobil9Z2V0Q2xhc3MoKXtyZXR1cm4gY3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sY3Mub3JpZ2luPW5ldyBnKDAsMCk7Y2xhc3MgaHN7Y29uc3RydWN0b3IoKXtocy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydCh0LGUpe31yZW1vdmUodCxlKXt9cXVlcnkoKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gaHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWhzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgdXN7Y29uc3RydWN0b3IoKXt1cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBlbnN1cmVFeHRlbnQodCxlKXtsZXQgbj10LmdldE1pblgoKSxzPXQuZ2V0TWF4WCgpLGk9dC5nZXRNaW5ZKCkscj10LmdldE1heFkoKTtyZXR1cm4gbiE9PXMmJmkhPT1yP3Q6KG49PT1zJiYobi09ZS8yLHM9bitlLzIpLGk9PT1yJiYoaS09ZS8yLHI9aStlLzIpLG5ldyBOKG4scyxpLHIpKX1zaXplKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb290P3RoaXMuX3Jvb3Quc2l6ZSgpOjB9aW5zZXJ0KHQsZSl7dGhpcy5jb2xsZWN0U3RhdHModCk7Y29uc3Qgbj11cy5lbnN1cmVFeHRlbnQodCx0aGlzLl9taW5FeHRlbnQpO3RoaXMuX3Jvb3QuaW5zZXJ0KG4sZSl9cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgWWU7cmV0dXJuIHRoaXMucXVlcnkodCxlKSxlLmdldEl0ZW1zKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3Jvb3QudmlzaXQodCxlKX19cXVlcnlBbGwoKXtjb25zdCB0PW5ldyB4O3JldHVybiB0aGlzLl9yb290LmFkZEFsbEl0ZW1zKHQpLHR9cmVtb3ZlKHQsZSl7Y29uc3Qgbj11cy5lbnN1cmVFeHRlbnQodCx0aGlzLl9taW5FeHRlbnQpO3JldHVybiB0aGlzLl9yb290LnJlbW92ZShuLGUpfWNvbGxlY3RTdGF0cyh0KXtjb25zdCBlPXQuZ2V0V2lkdGgoKTtlPHRoaXMuX21pbkV4dGVudCYmZT4wJiYodGhpcy5fbWluRXh0ZW50PWUpO2NvbnN0IG49dC5nZXRIZWlnaHQoKTtuPHRoaXMuX21pbkV4dGVudCYmbj4wJiYodGhpcy5fbWluRXh0ZW50PW4pfWRlcHRoKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb290P3RoaXMuX3Jvb3QuZGVwdGgoKTowfWlzRW1wdHkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Jvb3R8fHRoaXMuX3Jvb3QuaXNFbXB0eSgpfWdldENsYXNzKCl7cmV0dXJuIHVzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltocyxhXX19dXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcm9vdD1udWxsLHRoaXMuX21pbkV4dGVudD0xLHRoaXMuX3Jvb3Q9bmV3IGNzfSx1cy5zZXJpYWxWZXJzaW9uVUlEPS0weDY3OGI2MGM5NjdhMjU0MDA7dmFyIGdzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFF1YWR0cmVlOnVzfSk7Y2xhc3MgZHN7Y29uc3RydWN0b3IoKXtkcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kcygpe31nZXRDbGFzcygpe3JldHVybiBkc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBfc3tjb25zdHJ1Y3Rvcigpe19zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0SXRlbSgpe3JldHVybiB0aGlzLl9pdGVtfWdldEJvdW5kcygpe3JldHVybiB0aGlzLl9ib3VuZHN9Z2V0Q2xhc3MoKXtyZXR1cm4gX3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2RzLGFdfX1fcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ib3VuZHM9bnVsbCx0aGlzLl9pdGVtPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fYm91bmRzPXQsdGhpcy5faXRlbT1lfTtjbGFzcyBmc3tjb25zdHJ1Y3Rvcigpe2ZzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cG9sbCgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy5faXRlbXMuZ2V0KDEpO3JldHVybiB0aGlzLl9pdGVtcy5zZXQoMSx0aGlzLl9pdGVtcy5nZXQodGhpcy5fc2l6ZSkpLHRoaXMuX3NpemUtPTEsdGhpcy5yZW9yZGVyKDEpLHR9c2l6ZSgpe3JldHVybiB0aGlzLl9zaXplfXJlb3JkZXIodCl7bGV0IGU9bnVsbDtjb25zdCBuPXRoaXMuX2l0ZW1zLmdldCh0KTtmb3IoOzIqdDw9dGhpcy5fc2l6ZSYmKGU9Mip0LGUhPT10aGlzLl9zaXplJiZ0aGlzLl9pdGVtcy5nZXQoZSsxKS5jb21wYXJlVG8odGhpcy5faXRlbXMuZ2V0KGUpKTwwJiZlKyssdGhpcy5faXRlbXMuZ2V0KGUpLmNvbXBhcmVUbyhuKTwwKTt0PWUpdGhpcy5faXRlbXMuc2V0KHQsdGhpcy5faXRlbXMuZ2V0KGUpKTt0aGlzLl9pdGVtcy5zZXQodCxuKX1jbGVhcigpe3RoaXMuX3NpemU9MCx0aGlzLl9pdGVtcy5jbGVhcigpfXBlZWsoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtyZXR1cm4gdGhpcy5faXRlbXMuZ2V0KDEpfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuX3NpemV9YWRkKHQpe3RoaXMuX2l0ZW1zLmFkZChudWxsKSx0aGlzLl9zaXplKz0xO2xldCBlPXRoaXMuX3NpemU7Zm9yKHRoaXMuX2l0ZW1zLnNldCgwLHQpO3QuY29tcGFyZVRvKHRoaXMuX2l0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTwwO2UvPTIpdGhpcy5faXRlbXMuc2V0KGUsdGhpcy5faXRlbXMuZ2V0KE1hdGgudHJ1bmMoZS8yKSkpO3RoaXMuX2l0ZW1zLnNldChlLHQpfWdldENsYXNzKCl7cmV0dXJuIGZzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zaXplPW51bGwsdGhpcy5faXRlbXM9bnVsbCx0aGlzLl9zaXplPTAsdGhpcy5faXRlbXM9bmV3IHgsdGhpcy5faXRlbXMuYWRkKG51bGwpfTtjbGFzcyBwc3tjb25zdHJ1Y3Rvcigpe3BzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TGV2ZWwoKXtyZXR1cm4gdGhpcy5fbGV2ZWx9c2l6ZSgpe3JldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuc2l6ZSgpfWdldENoaWxkQm91bmRhYmxlcygpe3JldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXN9YWRkQ2hpbGRCb3VuZGFibGUodCl7dS5pc1RydWUobnVsbD09PXRoaXMuX2JvdW5kcyksdGhpcy5fY2hpbGRCb3VuZGFibGVzLmFkZCh0KX1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5pc0VtcHR5KCl9Z2V0Qm91bmRzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9ib3VuZHMmJih0aGlzLl9ib3VuZHM9dGhpcy5jb21wdXRlQm91bmRzKCkpLHRoaXMuX2JvdW5kc31nZXRDbGFzcygpe3JldHVybiBwc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZHMsYV19fXBzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2NoaWxkQm91bmRhYmxlcz1uZXcgeCx0aGlzLl9ib3VuZHM9bnVsbCx0aGlzLl9sZXZlbD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sZXZlbD10fX0scHMuc2VyaWFsVmVyc2lvblVJRD0weDVhMWU1NWVjNDEzNjk4MDA7Y2xhc3MgbXN7Y29uc3RydWN0b3IoKXttcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBhcmVhKHQpe3JldHVybiB0LmdldEJvdW5kcygpLmdldEFyZWEoKX1zdGF0aWMgaXNDb21wb3NpdGUodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBwc31leHBhbmRUb1F1ZXVlKHQsZSl7Y29uc3Qgcz1tcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUxKSxpPW1zLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTIpO2lmKHMmJmkpcmV0dXJuIG1zLmFyZWEodGhpcy5fYm91bmRhYmxlMSk+bXMuYXJlYSh0aGlzLl9ib3VuZGFibGUyKT8odGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMSx0aGlzLl9ib3VuZGFibGUyLHQsZSksbnVsbCk6KHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsdGhpcy5fYm91bmRhYmxlMSx0LGUpLG51bGwpO2lmKHMpcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMix0LGUpLG51bGw7aWYoaSlyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMix0aGlzLl9ib3VuZGFibGUxLHQsZSksbnVsbDt0aHJvdyBuZXcgbihcIm5laXRoZXIgYm91bmRhYmxlIGlzIGNvbXBvc2l0ZVwiKX1pc0xlYXZlcygpe3JldHVybiEobXMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSl8fG1zLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTIpKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9kaXN0YW5jZTxlLl9kaXN0YW5jZT8tMTp0aGlzLl9kaXN0YW5jZT5lLl9kaXN0YW5jZT8xOjB9ZXhwYW5kKHQsZSxuLHMpe2ZvcihsZXQgaT10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCB0PWkubmV4dCgpLHI9bmV3IG1zKHQsZSx0aGlzLl9pdGVtRGlzdGFuY2UpO3IuZ2V0RGlzdGFuY2UoKTxzJiZuLmFkZChyKX19Z2V0Qm91bmRhYmxlKHQpe3JldHVybiAwPT09dD90aGlzLl9ib3VuZGFibGUxOnRoaXMuX2JvdW5kYWJsZTJ9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2V9ZGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5pc0xlYXZlcygpP3RoaXMuX2l0ZW1EaXN0YW5jZS5kaXN0YW5jZSh0aGlzLl9ib3VuZGFibGUxLHRoaXMuX2JvdW5kYWJsZTIpOnRoaXMuX2JvdW5kYWJsZTEuZ2V0Qm91bmRzKCkuZGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMi5nZXRCb3VuZHMoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gbXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1tcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ib3VuZGFibGUxPW51bGwsdGhpcy5fYm91bmRhYmxlMj1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5faXRlbURpc3RhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fYm91bmRhYmxlMT10LHRoaXMuX2JvdW5kYWJsZTI9ZSx0aGlzLl9pdGVtRGlzdGFuY2U9bix0aGlzLl9kaXN0YW5jZT10aGlzLmRpc3RhbmNlKCl9O2NsYXNzIHlze2NvbnN0cnVjdG9yKCl7eXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tcGFyZURvdWJsZXModCxlKXtyZXR1cm4gdD5lPzE6dDxlPy0xOjB9cXVlcnlJbnRlcm5hbCgpe2lmKF8oYXJndW1lbnRzWzJdLEFlKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgcHMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtmb3IobGV0IGU9MDtlPHMuc2l6ZSgpO2UrKyl7Y29uc3QgaT1zLmdldChlKTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoaS5nZXRCb3VuZHMoKSx0KSYmKGkgaW5zdGFuY2VvZiBwcz90aGlzLnF1ZXJ5SW50ZXJuYWwodCxpLG4pOmkgaW5zdGFuY2VvZiBfcz9uLnZpc2l0SXRlbShpLmdldEl0ZW0oKSk6dS5zaG91bGROZXZlclJlYWNoSGVyZSgpKX19ZWxzZSBpZihfKGFyZ3VtZW50c1syXSxtKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgcHMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtmb3IobGV0IGU9MDtlPHMuc2l6ZSgpO2UrKyl7Y29uc3QgaT1zLmdldChlKTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoaS5nZXRCb3VuZHMoKSx0KSYmKGkgaW5zdGFuY2VvZiBwcz90aGlzLnF1ZXJ5SW50ZXJuYWwodCxpLG4pOmkgaW5zdGFuY2VvZiBfcz9uLmFkZChpLmdldEl0ZW0oKSk6dS5zaG91bGROZXZlclJlYWNoSGVyZSgpKX19fWdldE5vZGVDYXBhY2l0eSgpe3JldHVybiB0aGlzLl9ub2RlQ2FwYWNpdHl9bGFzdE5vZGUodCl7cmV0dXJuIHQuZ2V0KHQuc2l6ZSgpLTEpfXNpemUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoodGhpcy5idWlsZCgpLHRoaXMuc2l6ZSh0aGlzLl9yb290KSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtuIGluc3RhbmNlb2YgcHM/dCs9dGhpcy5zaXplKG4pOm4gaW5zdGFuY2VvZiBfcyYmKHQrPTEpfXJldHVybiB0fX1yZW1vdmVJdGVtKHQsZSl7bGV0IG49bnVsbDtmb3IobGV0IHM9dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0IGluc3RhbmNlb2YgX3MmJnQuZ2V0SXRlbSgpPT09ZSYmKG49dCl9cmV0dXJuIG51bGwhPT1uJiYodC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUobiksITApfWl0ZW1zVHJlZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLmJ1aWxkKCk7Y29uc3QgdD10aGlzLml0ZW1zVHJlZSh0aGlzLl9yb290KTtyZXR1cm4gbnVsbD09PXQ/bmV3IHg6dH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgeDtmb3IobGV0IG49dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0IGluc3RhbmNlb2YgcHMpe2NvbnN0IG49dGhpcy5pdGVtc1RyZWUodCk7bnVsbCE9PW4mJmUuYWRkKG4pfWVsc2UgdCBpbnN0YW5jZW9mIF9zP2UuYWRkKHQuZ2V0SXRlbSgpKTp1LnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIGUuc2l6ZSgpPD0wP251bGw6ZX19aW5zZXJ0KHQsZSl7dS5pc1RydWUoIXRoaXMuX2J1aWx0LFwiQ2Fubm90IGluc2VydCBpdGVtcyBpbnRvIGFuIFNUUiBwYWNrZWQgUi10cmVlIGFmdGVyIGl0IGhhcyBiZWVuIGJ1aWx0LlwiKSx0aGlzLl9pdGVtQm91bmRhYmxlcy5hZGQobmV3IF9zKHQsZSkpfWJvdW5kYWJsZXNBdExldmVsKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHg7cmV0dXJuIHRoaXMuYm91bmRhYmxlc0F0TGV2ZWwodCx0aGlzLl9yb290LGUpLGV9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHUuaXNUcnVlKHQ+LTIpLGUuZ2V0TGV2ZWwoKT09PXQpcmV0dXJuIG4uYWRkKGUpLG51bGw7Zm9yKGxldCBzPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGU9cy5uZXh0KCk7ZSBpbnN0YW5jZW9mIHBzP3RoaXMuYm91bmRhYmxlc0F0TGV2ZWwodCxlLG4pOih1LmlzVHJ1ZShlIGluc3RhbmNlb2YgX3MpLC0xPT09dCYmbi5hZGQoZSkpfXJldHVybiBudWxsfX1xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmJ1aWxkKCk7Y29uc3QgZT1uZXcgeDtyZXR1cm4gdGhpcy5pc0VtcHR5KCl8fHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnF1ZXJ5SW50ZXJuYWwodCx0aGlzLl9yb290LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuYnVpbGQoKSx0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5xdWVyeUludGVybmFsKHQsdGhpcy5fcm9vdCxlKX19YnVpbGQoKXtpZih0aGlzLl9idWlsdClyZXR1cm4gbnVsbDt0aGlzLl9yb290PXRoaXMuX2l0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKT90aGlzLmNyZWF0ZU5vZGUoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHModGhpcy5faXRlbUJvdW5kYWJsZXMsLTEpLHRoaXMuX2l0ZW1Cb3VuZGFibGVzPW51bGwsdGhpcy5fYnVpbHQ9ITB9Z2V0Um9vdCgpe3JldHVybiB0aGlzLmJ1aWxkKCksdGhpcy5fcm9vdH1yZW1vdmUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYnVpbGQoKSwhIXRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnJlbW92ZSh0LHRoaXMuX3Jvb3QsZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2xldCBzPXRoaXMucmVtb3ZlSXRlbShlLG4pO2lmKHMpcmV0dXJuITA7bGV0IGk9bnVsbDtmb3IobGV0IHI9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7Y29uc3QgZT1yLm5leHQoKTtpZih0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoZS5nZXRCb3VuZHMoKSx0KSYmKGUgaW5zdGFuY2VvZiBwcyYmKHM9dGhpcy5yZW1vdmUodCxlLG4pLHMpKSl7aT1lO2JyZWFrfX1yZXR1cm4gbnVsbCE9PWkmJmkuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXNFbXB0eSgpJiZlLmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShpKSxzfX1jcmVhdGVIaWdoZXJMZXZlbHModCxlKXt1LmlzVHJ1ZSghdC5pc0VtcHR5KCkpO2NvbnN0IG49dGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSsxKTtyZXR1cm4gMT09PW4uc2l6ZSgpP24uZ2V0KDApOnRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKG4sZSsxKX1kZXB0aCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5kZXB0aCh0aGlzLl9yb290KSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZihuIGluc3RhbmNlb2YgcHMpe2NvbnN0IGU9dGhpcy5kZXB0aChuKTtlPnQmJih0PWUpfX1yZXR1cm4gdCsxfX1jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSl7dS5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPW5ldyB4O24uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSk7Y29uc3Qgcz1uZXcgeCh0KTtFZS5zb3J0KHMsdGhpcy5nZXRDb21wYXJhdG9yKCkpO2ZvcihsZXQgdD1zLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBzPXQubmV4dCgpO3RoaXMubGFzdE5vZGUobikuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuc2l6ZSgpPT09dGhpcy5nZXROb2RlQ2FwYWNpdHkoKSYmbi5hZGQodGhpcy5jcmVhdGVOb2RlKGUpKSx0aGlzLmxhc3ROb2RlKG4pLmFkZENoaWxkQm91bmRhYmxlKHMpfXJldHVybiBufWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fYnVpbHQ/dGhpcy5fcm9vdC5pc0VtcHR5KCk6dGhpcy5faXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpfWdldENsYXNzKCl7cmV0dXJuIHlzfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19eXMuSW50ZXJzZWN0c09wPWZ1bmN0aW9uKCl7fSx5cy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9yb290PW51bGwsdGhpcy5fYnVpbHQ9ITEsdGhpcy5faXRlbUJvdW5kYWJsZXM9bmV3IHgsdGhpcy5fbm9kZUNhcGFjaXR5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpeXMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx5cy5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3UuaXNUcnVlKHQ+MSxcIk5vZGUgY2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKSx0aGlzLl9ub2RlQ2FwYWNpdHk9dH19LHlzLnNlcmlhbFZlcnNpb25VSUQ9LTB4MzVlZjY0YzgyZDRjNTQwMCx5cy5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTA7Y2xhc3MgeHN7Y29uc3RydWN0b3IoKXt4cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWRpc3RhbmNlKHQsZSl7fWdldENsYXNzKCl7cmV0dXJuIHhzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX14cy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEVzIGV4dGVuZHMgeXN7Y29uc3RydWN0b3IoKXtzdXBlcigpLEVzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNlbnRyZVgodCl7cmV0dXJuIEVzLmF2Zyh0LmdldE1pblgoKSx0LmdldE1heFgoKSl9c3RhdGljIGF2Zyh0LGUpe3JldHVybih0K2UpLzJ9c3RhdGljIGdldEl0ZW1zKHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBuPTA7Zm9yKDshdC5pc0VtcHR5KCk7KXtjb25zdCBzPXQucG9sbCgpO2Vbbl09cy5nZXRCb3VuZGFibGUoMCkuZ2V0SXRlbSgpLG4rK31yZXR1cm4gZX1zdGF0aWMgY2VudHJlWSh0KXtyZXR1cm4gRXMuYXZnKHQuZ2V0TWluWSgpLHQuZ2V0TWF4WSgpKX1jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzKHQsZSl7dS5pc1RydWUodC5sZW5ndGg+MCk7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyluLmFkZEFsbCh0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSh0W3NdLGUpKTtyZXR1cm4gbn1jcmVhdGVOb2RlKHQpe3JldHVybiBuZXcgSXModCl9c2l6ZSgpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9zdXBlci5zaXplLmNhbGwodGhpcyk6c3VwZXIuc2l6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0KCl7aWYoISgyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTikpcmV0dXJuIHN1cGVyLmluc2VydC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQuaXNOdWxsKCkpcmV0dXJuIG51bGw7c3VwZXIuaW5zZXJ0LmNhbGwodGhpcyx0LGUpfX1nZXRJbnRlcnNlY3RzT3AoKXtyZXR1cm4gRXMuaW50ZXJzZWN0c09wfXZlcnRpY2FsU2xpY2VzKHQsZSl7Y29uc3Qgbj1NYXRoLnRydW5jKE1hdGguY2VpbCh0LnNpemUoKS9lKSkscz1uZXcgQXJyYXkoZSkuZmlsbChudWxsKSxpPXQuaXRlcmF0b3IoKTtmb3IobGV0IHQ9MDt0PGU7dCsrKXtzW3RdPW5ldyB4O2xldCBlPTA7Zm9yKDtpLmhhc05leHQoKSYmZTxuOyl7Y29uc3Qgbj1pLm5leHQoKTtzW3RdLmFkZChuKSxlKyt9fXJldHVybiBzfXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBzdXBlci5xdWVyeS5jYWxsKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3N1cGVyLnF1ZXJ5LmNhbGwodGhpcyx0LGUpfX1nZXRDb21wYXJhdG9yKCl7cmV0dXJuIEVzLnlDb21wYXJhdG9yfWNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSh0LGUpe3JldHVybiBzdXBlci5jcmVhdGVQYXJlbnRCb3VuZGFibGVzLmNhbGwodGhpcyx0LGUpfXJlbW92ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gc3VwZXIucmVtb3ZlLmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5yZW1vdmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWRlcHRoKCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP3N1cGVyLmRlcHRoLmNhbGwodGhpcyk6c3VwZXIuZGVwdGguYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKXt1LmlzVHJ1ZSghdC5pc0VtcHR5KCkpO2NvbnN0IG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvdGhpcy5nZXROb2RlQ2FwYWNpdHkoKSkpLHM9bmV3IHgodCk7RWUuc29ydChzLEVzLnhDb21wYXJhdG9yKTtjb25zdCBpPXRoaXMudmVydGljYWxTbGljZXMocyxNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLnNxcnQobikpKSk7cmV0dXJuIHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyhpLGUpfW5lYXJlc3ROZWlnaGJvdXIoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMF0seHMpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBtcyh0aGlzLmdldFJvb3QoKSx0aGlzLmdldFJvb3QoKSx0KTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbXMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIodCxpLlBPU0lUSVZFX0lORklOSVRZKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBFcyYmXyhhcmd1bWVudHNbMV0seHMpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBtcyh0aGlzLmdldFJvb3QoKSx0LmdldFJvb3QoKSxlKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKG4pfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbXMmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPWFyZ3VtZW50c1sxXSxuPW51bGw7Y29uc3Qgcz1uZXcgZnM7Zm9yKHMuYWRkKHQpOyFzLmlzRW1wdHkoKSYmZT4wOyl7Y29uc3QgdD1zLnBvbGwoKSxpPXQuZ2V0RGlzdGFuY2UoKTtpZihpPj1lKWJyZWFrO3QuaXNMZWF2ZXMoKT8oZT1pLG49dCk6dC5leHBhbmRUb1F1ZXVlKHMsZSl9cmV0dXJuW24uZ2V0Qm91bmRhYmxlKDApLmdldEl0ZW0oKSxuLmdldEJvdW5kYWJsZSgxKS5nZXRJdGVtKCldfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbXMmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cih0LGkuUE9TSVRJVkVfSU5GSU5JVFksZSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzJdLHhzKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIE9iamVjdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgX3ModCxlKSxpPW5ldyBtcyh0aGlzLmdldFJvb3QoKSxzLG4pO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoaSlbMF19aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1zJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtsZXQgcz1lO2NvbnN0IGk9bmV3IGZzO2kuYWRkKHQpO2NvbnN0IHI9bmV3IGZzO2Zvcig7IWkuaXNFbXB0eSgpJiZzPj0wOyl7Y29uc3QgdD1pLnBvbGwoKSxlPXQuZ2V0RGlzdGFuY2UoKTtpZihlPj1zKWJyZWFrO2lmKHQuaXNMZWF2ZXMoKSlpZihyLnNpemUoKTxuKXIuYWRkKHQpO2Vsc2V7ci5wZWVrKCkuZ2V0RGlzdGFuY2UoKT5lJiYoci5wb2xsKCksci5hZGQodCkpLHM9ci5wZWVrKCkuZ2V0RGlzdGFuY2UoKX1lbHNlIHQuZXhwYW5kVG9RdWV1ZShpLHMpfXJldHVybiBFcy5nZXRJdGVtcyhyKX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgX3ModCxlKSxyPW5ldyBtcyh0aGlzLmdldFJvb3QoKSxpLG4pO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIocixzKX19Z2V0Q2xhc3MoKXtyZXR1cm4gRXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2hzLGFdfX1jbGFzcyBJcyBleHRlbmRzIHBze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxJcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXB1dGVCb3VuZHMoKXtsZXQgdD1udWxsO2ZvcihsZXQgZT10aGlzLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO251bGw9PT10P3Q9bmV3IE4obi5nZXRCb3VuZHMoKSk6dC5leHBhbmRUb0luY2x1ZGUobi5nZXRCb3VuZHMoKSl9cmV0dXJuIHR9Z2V0Q2xhc3MoKXtyZXR1cm4gSXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUlzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3BzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9LEVzLlNUUnRyZWVOb2RlPUlzLEVzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKUVzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsRXMuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt5cy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX0sRXMuc2VyaWFsVmVyc2lvblVJRD0weDM5OTIwZjdkNWYyNjFlMCxFcy54Q29tcGFyYXRvcj1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfWNvbXBhcmUodCxlKXtyZXR1cm4geXMuY29tcGFyZURvdWJsZXMoRXMuY2VudHJlWCh0LmdldEJvdW5kcygpKSxFcy5jZW50cmVYKGUuZ2V0Qm91bmRzKCkpKX19LEVzLnlDb21wYXJhdG9yPW5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19Y29tcGFyZSh0LGUpe3JldHVybiB5cy5jb21wYXJlRG91YmxlcyhFcy5jZW50cmVZKHQuZ2V0Qm91bmRzKCkpLEVzLmNlbnRyZVkoZS5nZXRCb3VuZHMoKSkpfX0sRXMuaW50ZXJzZWN0c09wPW5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSW50ZXJzZWN0c09wXX1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuIHQuaW50ZXJzZWN0cyhlKX19LEVzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWT0xMDt2YXIgTnM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsU1RSdHJlZTpFc30pLENzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGtkdHJlZTpzcyxxdWFkdHJlZTpncyxzdHJ0cmVlOk5zfSk7Y29uc3QgU3M9W1wiUG9pbnRcIixcIk11bHRpUG9pbnRcIixcIkxpbmVTdHJpbmdcIixcIk11bHRpTGluZVN0cmluZ1wiLFwiUG9seWdvblwiLFwiTXVsdGlQb2x5Z29uXCJdO2NsYXNzIHdze2NvbnN0cnVjdG9yKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBIdH1yZWFkKHQpe2xldCBlO2U9XCJzdHJpbmdcIj09dHlwZW9mIHQ/SlNPTi5wYXJzZSh0KTp0O2NvbnN0IG49ZS50eXBlO2lmKCFMc1tuXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrZS50eXBlKTtyZXR1cm4tMSE9PVNzLmluZGV4T2Yobik/THNbbl0uY2FsbCh0aGlzLGUuY29vcmRpbmF0ZXMpOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT1uP0xzW25dLmNhbGwodGhpcyxlLmdlb21ldHJpZXMpOkxzW25dLmNhbGwodGhpcyxlKX13cml0ZSh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlUeXBlKCk7aWYoIVRzW2VdKXRocm93IG5ldyBFcnJvcihcIkdlb21ldHJ5IGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIFRzW2VdLmNhbGwodGhpcyx0KX19Y29uc3QgTHM9e0ZlYXR1cmU6ZnVuY3Rpb24odCl7Y29uc3QgZT17fTtmb3IoY29uc3QgbiBpbiB0KWVbbl09dFtuXTtpZih0Lmdlb21ldHJ5KXtjb25zdCBuPXQuZ2VvbWV0cnkudHlwZTtpZighTHNbbl0pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9KU09OIHR5cGU6IFwiK3QudHlwZSk7ZS5nZW9tZXRyeT10aGlzLnJlYWQodC5nZW9tZXRyeSl9cmV0dXJuIHQuYmJveCYmKGUuYmJveD1Mcy5iYm94LmNhbGwodGhpcyx0LmJib3gpKSxlfSxGZWF0dXJlQ29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPXt9O2lmKHQuZmVhdHVyZXMpe2UuZmVhdHVyZXM9W107Zm9yKGxldCBuPTA7bjx0LmZlYXR1cmVzLmxlbmd0aDsrK24pZS5mZWF0dXJlcy5wdXNoKHRoaXMucmVhZCh0LmZlYXR1cmVzW25dKSl9cmV0dXJuIHQuYmJveCYmKGUuYmJveD10aGlzLnBhcnNlLmJib3guY2FsbCh0aGlzLHQuYmJveCkpLGV9LGNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pe2NvbnN0IHM9dFtuXTtlLnB1c2gobmV3IGcoc1swXSxzWzFdKSl9cmV0dXJuIGV9LGJib3g6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoW25ldyBnKHRbMF0sdFsxXSksbmV3IGcodFsyXSx0WzFdKSxuZXcgZyh0WzJdLHRbM10pLG5ldyBnKHRbMF0sdFszXSksbmV3IGcodFswXSx0WzFdKV0pfSxQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPW5ldyBnKHRbMF0sdFsxXSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGUpfSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKExzLlBvaW50LmNhbGwodGhpcyx0W25dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1Mcy5jb29yZGluYXRlcy5jYWxsKHRoaXMsdCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoZSl9LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKWUucHVzaChMcy5MaW5lU3RyaW5nLmNhbGwodGhpcyx0W25dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX0sUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPUxzLmNvb3JkaW5hdGVzLmNhbGwodGhpcyx0WzBdKSxuPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoZSkscz1bXTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoOysrZSl7Y29uc3Qgbj10W2VdLGk9THMuY29vcmRpbmF0ZXMuY2FsbCh0aGlzLG4pLHI9dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhpKTtzLnB1c2gocil9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24obixzKX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pe2NvbnN0IHM9dFtuXTtlLnB1c2goTHMuUG9seWdvbi5jYWxsKHRoaXMscykpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKHRoaXMucmVhZChzKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX19LFRzPXtjb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVyblt0LngsdC55XX0sUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJue3R5cGU6XCJQb2ludFwiLGNvb3JkaW5hdGVzOlRzLmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuZ2V0Q29vcmRpbmF0ZSgpKX19LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9VHMuUG9pbnQuY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpUG9pbnRcIixjb29yZGluYXRlczplfX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdLG49dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7Kyt0KXtjb25zdCBzPW5bdF07ZS5wdXNoKFRzLmNvb3JkaW5hdGUuY2FsbCh0aGlzLHMpKX1yZXR1cm57dHlwZTpcIkxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPVRzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W10sbj1Ucy5MaW5lU3RyaW5nLmNhbGwodGhpcyx0Ll9zaGVsbCk7ZS5wdXNoKG4uY29vcmRpbmF0ZXMpO2ZvcihsZXQgbj0wO248dC5faG9sZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9ob2xlc1tuXSxpPVRzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIlBvbHlnb25cIixjb29yZGluYXRlczplfX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPVRzLlBvbHlnb24uY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpUG9seWdvblwiLGNvb3JkaW5hdGVzOmV9fSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9cy5nZXRHZW9tZXRyeVR5cGUoKTtlLnB1c2goVHNbaV0uY2FsbCh0aGlzLHMpKX1yZXR1cm57dHlwZTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLGdlb21ldHJpZXM6ZX19fTtmdW5jdGlvbiBScyh0KXtyZXR1cm5bdC54LHQueV19dmFyIFBzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb0pTT05SZWFkZXI6Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9bmV3IHdzKHR8fG5ldyBIdCl9cmVhZCh0KXtyZXR1cm4gdGhpcy5wYXJzZXIucmVhZCh0KX19LEdlb0pTT05Xcml0ZXI6Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnBhcnNlcj1uZXcgd3ModGhpcy5nZW9tZXRyeUZhY3RvcnkpfXdyaXRlKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX19LE9MM1BhcnNlcjpjbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBIdCx0aGlzLm9sPWV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBvbCYmb2x9aW5qZWN0KHQsZSxuLHMsaSxyLG8sbCl7dGhpcy5vbD17Z2VvbTp7UG9pbnQ6dCxMaW5lU3RyaW5nOmUsTGluZWFyUmluZzpuLFBvbHlnb246cyxNdWx0aVBvaW50OmksTXVsdGlMaW5lU3RyaW5nOnIsTXVsdGlQb2x5Z29uOm8sR2VvbWV0cnlDb2xsZWN0aW9uOmx9fX1yZWFkKHQpe2NvbnN0IGU9dGhpcy5vbDtyZXR1cm4gdCBpbnN0YW5jZW9mIGUuZ2VvbS5Qb2ludD90aGlzLmNvbnZlcnRGcm9tUG9pbnQodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5MaW5lU3RyaW5nP3RoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTGluZWFyUmluZz90aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLlBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aVBvaW50P3RoaXMuY29udmVydEZyb21NdWx0aVBvaW50KHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTXVsdGlMaW5lU3RyaW5nP3RoaXMuY29udmVydEZyb21NdWx0aUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aVBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9seWdvbih0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkdlb21ldHJ5Q29sbGVjdGlvbj90aGlzLmNvbnZlcnRGcm9tQ29sbGVjdGlvbih0KTp2b2lkIDB9Y29udmVydEZyb21Qb2ludCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQobmV3IGcoZVswXSxlWzFdKSl9Y29udmVydEZyb21MaW5lU3RyaW5nKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyh0WzBdLHRbMV0pfSkpKX1jb252ZXJ0RnJvbUxpbmVhclJpbmcodCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnKHRbMF0sdFsxXSl9KSkpfWNvbnZlcnRGcm9tUG9seWdvbih0KXtjb25zdCBlPXQuZ2V0TGluZWFyUmluZ3MoKTtsZXQgbj1udWxsO2NvbnN0IHM9W107Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IGk9dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcoZVt0XSk7MD09PXQ/bj1pOnMucHVzaChpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLHMpfWNvbnZlcnRGcm9tTXVsdGlQb2ludCh0KXtjb25zdCBlPXQuZ2V0UG9pbnRzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9Y29udmVydEZyb21NdWx0aUxpbmVTdHJpbmcodCl7Y29uc3QgZT10LmdldExpbmVTdHJpbmdzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfWNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uKHQpe2NvbnN0IGU9dC5nZXRQb2x5Z29ucygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX1jb252ZXJ0RnJvbUNvbGxlY3Rpb24odCl7Y29uc3QgZT10LmdldEdlb21ldHJpZXMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlYWQodCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfXdyaXRlKHQpe3JldHVyblwiUG9pbnRcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2ludCh0LmdldENvb3JkaW5hdGUoKSk6XCJMaW5lU3RyaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZVN0cmluZyh0KTpcIkxpbmVhclJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9MaW5lYXJSaW5nKHQpOlwiUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb1BvbHlnb24odCk6XCJNdWx0aVBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlQb2ludCh0KTpcIk11bHRpTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpTGluZVN0cmluZyh0KTpcIk11bHRpUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9seWdvbih0KTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0NvbGxlY3Rpb24odCk6dm9pZCAwfWNvbnZlcnRUb1BvaW50KHQpe3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLlBvaW50KFt0LngsdC55XSl9Y29udmVydFRvTGluZVN0cmluZyh0KXtjb25zdCBlPXQuX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKFJzKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5MaW5lU3RyaW5nKGUpfWNvbnZlcnRUb0xpbmVhclJpbmcodCl7Y29uc3QgZT10Ll9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChScyk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTGluZWFyUmluZyhlKX1jb252ZXJ0VG9Qb2x5Z29uKHQpe2NvbnN0IGU9W3QuX3NoZWxsLl9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChScyldO2ZvcihsZXQgbj0wO248dC5faG9sZXMubGVuZ3RoO24rKyllLnB1c2godC5faG9sZXNbbl0uX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKFJzKSk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uUG9seWdvbihlKX1jb252ZXJ0VG9NdWx0aVBvaW50KHQpe3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpUG9pbnQodC5nZXRDb29yZGluYXRlcygpLm1hcChScykpfWNvbnZlcnRUb011bHRpTGluZVN0cmluZyh0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKWUucHVzaCh0aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodC5fZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTXVsdGlMaW5lU3RyaW5nKGUpfWNvbnZlcnRUb011bHRpUG9seWdvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKWUucHVzaCh0aGlzLmNvbnZlcnRUb1BvbHlnb24odC5fZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTXVsdGlQb2x5Z29uKGUpfWNvbnZlcnRUb0NvbGxlY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoO24rKyl7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dO2UucHVzaCh0aGlzLndyaXRlKHMpKX1yZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24oZSl9fSxXS1RSZWFkZXI6Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9bmV3IEt0KHR8fG5ldyBIdCl9cmVhZCh0KXtyZXR1cm4gdGhpcy5wYXJzZXIucmVhZCh0KX19LFdLVFdyaXRlcjpKdH0pO2NsYXNzIHZze2NvbnN0cnVjdG9yKCl7dnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcmVsYXRpdmVTaWduKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTowfXN0YXRpYyBjb21wYXJlKHQsZSxuKXtpZihlLmVxdWFsczJEKG4pKXJldHVybiAwO2NvbnN0IHM9dnMucmVsYXRpdmVTaWduKGUueCxuLngpLGk9dnMucmVsYXRpdmVTaWduKGUueSxuLnkpO3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZShzLGkpO2Nhc2UgMTpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKGkscyk7Y2FzZSAyOnJldHVybiB2cy5jb21wYXJlVmFsdWUoaSwtcyk7Y2FzZSAzOnJldHVybiB2cy5jb21wYXJlVmFsdWUoLXMsaSk7Y2FzZSA0OnJldHVybiB2cy5jb21wYXJlVmFsdWUoLXMsLWkpO2Nhc2UgNTpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKC1pLC1zKTtjYXNlIDY6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZSgtaSxzKTtjYXNlIDc6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZShzLC1pKX1yZXR1cm4gdS5zaG91bGROZXZlclJlYWNoSGVyZShcImludmFsaWQgb2N0YW50IHZhbHVlXCIpLDB9c3RhdGljIGNvbXBhcmVWYWx1ZSh0LGUpe3JldHVybiB0PDA/LTE6dD4wPzE6ZTwwPy0xOmU+MD8xOjB9Z2V0Q2xhc3MoKXtyZXR1cm4gdnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXZzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgT3N7Y29uc3RydWN0b3IoKXtPcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb29yZH1wcmludCh0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg8ZS5zZWdtZW50SW5kZXg/LTE6dGhpcy5zZWdtZW50SW5kZXg+ZS5zZWdtZW50SW5kZXg/MTp0aGlzLmNvb3JkLmVxdWFsczJEKGUuY29vcmQpPzA6dnMuY29tcGFyZSh0aGlzLl9zZWdtZW50T2N0YW50LHRoaXMuY29vcmQsZS5jb29yZCl9aXNFbmRQb2ludCh0KXtyZXR1cm4gMD09PXRoaXMuc2VnbWVudEluZGV4JiYhdGhpcy5faXNJbnRlcmlvcnx8dGhpcy5zZWdtZW50SW5kZXg9PT10fWlzSW50ZXJpb3IoKXtyZXR1cm4gdGhpcy5faXNJbnRlcmlvcn1nZXRDbGFzcygpe3JldHVybiBPc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fU9zLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NlZ1N0cmluZz1udWxsLHRoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuX3NlZ21lbnRPY3RhbnQ9bnVsbCx0aGlzLl9pc0ludGVyaW9yPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fc2VnU3RyaW5nPXQsdGhpcy5jb29yZD1uZXcgZyhlKSx0aGlzLnNlZ21lbnRJbmRleD1uLHRoaXMuX3NlZ21lbnRPY3RhbnQ9cyx0aGlzLl9pc0ludGVyaW9yPSFlLmVxdWFsczJEKHQuZ2V0Q29vcmRpbmF0ZShuKSl9O2NsYXNzIGJze2NvbnN0cnVjdG9yKCl7YnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRTcGxpdENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgSTt0aGlzLmFkZEVuZHBvaW50cygpO2NvbnN0IGU9dGhpcy5pdGVyYXRvcigpO2xldCBuPWUubmV4dCgpO2Zvcig7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpO3RoaXMuYWRkRWRnZUNvb3JkaW5hdGVzKG4scyx0KSxuPXN9cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX1hZGRDb2xsYXBzZWROb2Rlcygpe2NvbnN0IHQ9bmV3IHg7dGhpcy5maW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXModCksdGhpcy5maW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXModCk7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCkuaW50VmFsdWUoKTt0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUodCksdCl9fXByaW50KHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19ZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZS5zaXplKCktMjtlKyspe2NvbnN0IG49dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUpLHM9KHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKzEpLHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKzIpKTtuLmVxdWFsczJEKHMpJiZ0LmFkZChuZXcgTChlKzEpKX19YWRkRWRnZUNvb3JkaW5hdGVzKHQsZSxuKXtlLnNlZ21lbnRJbmRleCx0LnNlZ21lbnRJbmRleDtjb25zdCBzPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlLnNlZ21lbnRJbmRleCksaT1lLmlzSW50ZXJpb3IoKXx8IWUuY29vcmQuZXF1YWxzMkQocyk7bi5hZGQobmV3IGcodC5jb29yZCksITEpO2ZvcihsZXQgcz10LnNlZ21lbnRJbmRleCsxO3M8PWUuc2VnbWVudEluZGV4O3MrKyluLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUocykpO2kmJm4uYWRkKG5ldyBnKGUuY29vcmQpKX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9YWRkU3BsaXRFZGdlcyh0KXt0aGlzLmFkZEVuZHBvaW50cygpLHRoaXMuYWRkQ29sbGFwc2VkTm9kZXMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4scyk7dC5hZGQoaSksbj1zfX1maW5kQ29sbGFwc2VJbmRleCh0LGUsbil7aWYoIXQuY29vcmQuZXF1YWxzMkQoZS5jb29yZCkpcmV0dXJuITE7bGV0IHM9ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXg7cmV0dXJuIGUuaXNJbnRlcmlvcigpfHxzLS0sMT09PXMmJihuWzBdPXQuc2VnbWVudEluZGV4KzEsITApfWZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2Rlcyh0KXtjb25zdCBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5pdGVyYXRvcigpO2xldCBzPW4ubmV4dCgpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBpPW4ubmV4dCgpO3RoaXMuZmluZENvbGxhcHNlSW5kZXgocyxpLGUpJiZ0LmFkZChuZXcgTChlWzBdKSkscz1pfX1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX2VkZ2V9YWRkRW5kcG9pbnRzKCl7Y29uc3QgdD10aGlzLl9lZGdlLnNpemUoKS0xO3RoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSgwKSwwKSx0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUodCksdCl9Y3JlYXRlU3BsaXRFZGdlKHQsZSl7bGV0IG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMjtjb25zdCBzPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlLnNlZ21lbnRJbmRleCksaT1lLmlzSW50ZXJpb3IoKXx8IWUuY29vcmQuZXF1YWxzMkQocyk7aXx8bi0tO2NvbnN0IHI9bmV3IEFycmF5KG4pLmZpbGwobnVsbCk7bGV0IG89MDtyW28rK109bmV3IGcodC5jb29yZCk7Zm9yKGxldCBuPXQuc2VnbWVudEluZGV4KzE7bjw9ZS5zZWdtZW50SW5kZXg7bisrKXJbbysrXT10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUobik7cmV0dXJuIGkmJihyW29dPW5ldyBnKGUuY29vcmQpKSxuZXcgRnMocix0aGlzLl9lZGdlLmdldERhdGEoKSl9YWRkKHQsZSl7Y29uc3Qgbj1uZXcgT3ModGhpcy5fZWRnZSx0LGUsdGhpcy5fZWRnZS5nZXRTZWdtZW50T2N0YW50KGUpKSxzPXRoaXMuX25vZGVNYXAuZ2V0KG4pO3JldHVybiBudWxsIT09cz8odS5pc1RydWUocy5jb29yZC5lcXVhbHMyRCh0KSxcIkZvdW5kIGVxdWFsIG5vZGVzIHdpdGggZGlmZmVyZW50IGNvb3JkaW5hdGVzXCIpLHMpOih0aGlzLl9ub2RlTWFwLnB1dChuLG4pLG4pfWNoZWNrU3BsaXRFZGdlc0NvcnJlY3RuZXNzKHQpe2NvbnN0IGU9dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlcygpLG49dC5nZXQoMCkuZ2V0Q29vcmRpbmF0ZSgwKTtpZighbi5lcXVhbHMyRChlWzBdKSl0aHJvdyBuZXcgYyhcImJhZCBzcGxpdCBlZGdlIHN0YXJ0IHBvaW50IGF0IFwiK24pO2NvbnN0IHM9dC5nZXQodC5zaXplKCktMSkuZ2V0Q29vcmRpbmF0ZXMoKSxpPXNbcy5sZW5ndGgtMV07aWYoIWkuZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkpdGhyb3cgbmV3IGMoXCJiYWQgc3BsaXQgZWRnZSBlbmQgcG9pbnQgYXQgXCIraSl9Z2V0Q2xhc3MoKXtyZXR1cm4gYnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWJzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25vZGVNYXA9bmV3IHJ0LHRoaXMuX2VkZ2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlPXR9O2NsYXNzIE1ze2NvbnN0cnVjdG9yKCl7TXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb2N0YW50KCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBuKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7Y29uc3Qgcz1NYXRoLmFicyh0KSxpPU1hdGguYWJzKGUpO3JldHVybiB0Pj0wP2U+PTA/cz49aT8wOjE6cz49aT83OjY6ZT49MD9zPj1pPzM6MjpzPj1pPzQ6NX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0scz1lLngtdC54LGk9ZS55LXQueTtpZigwPT09cyYmMD09PWkpdGhyb3cgbmV3IG4oXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIit0KTtyZXR1cm4gTXMub2N0YW50KHMsaSl9fWdldENsYXNzKCl7cmV0dXJuIE1zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ncy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIERze2NvbnN0cnVjdG9yKCl7RHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlcygpe31zaXplKCl7fWdldENvb3JkaW5hdGUodCl7fWlzQ2xvc2VkKCl7fXNldERhdGEodCl7fWdldERhdGEoKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gRHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fURzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgQXN7Y29uc3RydWN0b3IoKXtBcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZEludGVyc2VjdGlvbih0LGUpe31nZXRDbGFzcygpe3JldHVybiBBc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRHNdfX1Bcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEZze2NvbnN0cnVjdG9yKCl7RnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0Tm9kZWRTdWJzdHJpbmdzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHg7cmV0dXJuIEZzLmdldE5vZGVkU3Vic3RyaW5ncyh0LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5nZXROb2RlTGlzdCgpLmFkZFNwbGl0RWRnZXMoZSl9fX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdHN9c2l6ZSgpe3JldHVybiB0aGlzLl9wdHMubGVuZ3RofWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0c1t0XX1pc0Nsb3NlZCgpe3JldHVybiB0aGlzLl9wdHNbMF0uZXF1YWxzKHRoaXMuX3B0c1t0aGlzLl9wdHMubGVuZ3RoLTFdKX1nZXRTZWdtZW50T2N0YW50KHQpe3JldHVybiB0PT09dGhpcy5fcHRzLmxlbmd0aC0xPy0xOnRoaXMuc2FmZU9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfXNldERhdGEodCl7dGhpcy5fZGF0YT10fXNhZmVPY3RhbnQodCxlKXtyZXR1cm4gdC5lcXVhbHMyRChlKT8wOk1zLm9jdGFudCh0LGUpfWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1hZGRJbnRlcnNlY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5hZGRJbnRlcnNlY3Rpb25Ob2RlKHQsZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbM10scz1uZXcgZyh0LmdldEludGVyc2VjdGlvbihuKSk7dGhpcy5hZGRJbnRlcnNlY3Rpb24ocyxlKX19dG9TdHJpbmcoKXtyZXR1cm4gSnQudG9MaW5lU3RyaW5nKG5ldyB6dCh0aGlzLl9wdHMpKX1nZXROb2RlTGlzdCgpe3JldHVybiB0aGlzLl9ub2RlTGlzdH1hZGRJbnRlcnNlY3Rpb25Ob2RlKHQsZSl7bGV0IG49ZTtjb25zdCBzPW4rMTtpZihzPHRoaXMuX3B0cy5sZW5ndGgpe2NvbnN0IGU9dGhpcy5fcHRzW3NdO3QuZXF1YWxzMkQoZSkmJihuPXMpfXJldHVybiB0aGlzLl9ub2RlTGlzdC5hZGQodCxuKX1hZGRJbnRlcnNlY3Rpb25zKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7cysrKXRoaXMuYWRkSW50ZXJzZWN0aW9uKHQsZSxuLHMpfWdldENsYXNzKCl7cmV0dXJuIEZzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBc119fUZzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25vZGVMaXN0PW5ldyBicyh0aGlzKSx0aGlzLl9wdHM9bnVsbCx0aGlzLl9kYXRhPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fZGF0YT1lfTtjbGFzcyBHc3tjb25zdHJ1Y3Rvcigpe0dzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9b3ZlcmxhcCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0LmdldExpbmVTZWdtZW50KGUsdGhpcy5fb3ZlcmxhcFNlZzEpLG4uZ2V0TGluZVNlZ21lbnQocyx0aGlzLl9vdmVybGFwU2VnMiksdGhpcy5vdmVybGFwKHRoaXMuX292ZXJsYXBTZWcxLHRoaXMuX292ZXJsYXBTZWcyKX19Z2V0Q2xhc3MoKXtyZXR1cm4gR3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUdzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX292ZXJsYXBTZWcxPW5ldyBlZSx0aGlzLl9vdmVybGFwU2VnMj1uZXcgZWV9O2NsYXNzIHFze2NvbnN0cnVjdG9yKCl7cXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRMaW5lU2VnbWVudCh0LGUpe2UucDA9dGhpcy5fcHRzW3RdLGUucDE9dGhpcy5fcHRzW3QrMV19Y29tcHV0ZVNlbGVjdCh0LGUsbixzKXtjb25zdCBpPXRoaXMuX3B0c1tlXSxyPXRoaXMuX3B0c1tuXTtpZihuLWU9PTEpcmV0dXJuIHMuc2VsZWN0KHRoaXMsZSksbnVsbDtpZighdC5pbnRlcnNlY3RzKGkscikpcmV0dXJuIG51bGw7Y29uc3Qgbz1NYXRoLnRydW5jKChlK24pLzIpO2U8byYmdGhpcy5jb21wdXRlU2VsZWN0KHQsZSxvLHMpLG88biYmdGhpcy5jb21wdXRlU2VsZWN0KHQsbyxuLHMpfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZW5kLXRoaXMuX3N0YXJ0KzEpLmZpbGwobnVsbCk7bGV0IGU9MDtmb3IobGV0IG49dGhpcy5fc3RhcnQ7bjw9dGhpcy5fZW5kO24rKyl0W2UrK109dGhpcy5fcHRzW25dO3JldHVybiB0fWNvbXB1dGVPdmVybGFwcygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmNvbXB1dGVPdmVybGFwcyh0aGlzLl9zdGFydCx0aGlzLl9lbmQsdCx0Ll9zdGFydCx0Ll9lbmQsZSl9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07aWYoZS10PT0xJiZpLXM9PTEpcmV0dXJuIHIub3ZlcmxhcCh0aGlzLHQsbixzKSxudWxsO2lmKCF0aGlzLm92ZXJsYXBzKHQsZSxuLHMsaSkpcmV0dXJuIG51bGw7Y29uc3Qgbz1NYXRoLnRydW5jKCh0K2UpLzIpLGw9TWF0aC50cnVuYygocytpKS8yKTt0PG8mJihzPGwmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKHQsbyxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKHQsbyxuLGwsaSxyKSksbzxlJiYoczxsJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyhvLGUsbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyhvLGUsbixsLGkscikpfX1zZXRJZCh0KXt0aGlzLl9pZD10fXNlbGVjdCh0LGUpe3RoaXMuY29tcHV0ZVNlbGVjdCh0LHRoaXMuX3N0YXJ0LHRoaXMuX2VuZCxlKX1nZXRFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9lbnYpe2NvbnN0IHQ9dGhpcy5fcHRzW3RoaXMuX3N0YXJ0XSxlPXRoaXMuX3B0c1t0aGlzLl9lbmRdO3RoaXMuX2Vudj1uZXcgTih0LGUpfXJldHVybiB0aGlzLl9lbnZ9b3ZlcmxhcHModCxlLG4scyxpKXtyZXR1cm4gTi5pbnRlcnNlY3RzKHRoaXMuX3B0c1t0XSx0aGlzLl9wdHNbZV0sbi5fcHRzW3NdLG4uX3B0c1tpXSl9Z2V0RW5kSW5kZXgoKXtyZXR1cm4gdGhpcy5fZW5kfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gdGhpcy5fc3RhcnR9Z2V0Q29udGV4dCgpe3JldHVybiB0aGlzLl9jb250ZXh0fWdldElkKCl7cmV0dXJuIHRoaXMuX2lkfWdldENsYXNzKCl7cmV0dXJuIHFzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1xcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl9zdGFydD1udWxsLHRoaXMuX2VuZD1udWxsLHRoaXMuX2Vudj1udWxsLHRoaXMuX2NvbnRleHQ9bnVsbCx0aGlzLl9pZD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX3B0cz10LHRoaXMuX3N0YXJ0PWUsdGhpcy5fZW5kPW4sdGhpcy5fY29udGV4dD1zfTtjbGFzcyBCc3tjb25zdHJ1Y3Rvcigpe0JzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldENoYWluU3RhcnRJbmRpY2VzKHQpe2xldCBlPTA7Y29uc3Qgbj1uZXcgeDtuLmFkZChuZXcgTChlKSk7ZG97Y29uc3Qgcz1Ccy5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChuZXcgTChzKSksZT1zfXdoaWxlKGU8dC5sZW5ndGgtMSk7cmV0dXJuIEJzLnRvSW50QXJyYXkobil9c3RhdGljIGZpbmRDaGFpbkVuZCh0LGUpe2xldCBuPWU7Zm9yKDtuPHQubGVuZ3RoLTEmJnRbbl0uZXF1YWxzMkQodFtuKzFdKTspbisrO2lmKG4+PXQubGVuZ3RoLTEpcmV0dXJuIHQubGVuZ3RoLTE7Y29uc3Qgcz1Jbi5xdWFkcmFudCh0W25dLHRbbisxXSk7bGV0IGk9ZSsxO2Zvcig7aTx0Lmxlbmd0aDspe2lmKCF0W2ktMV0uZXF1YWxzMkQodFtpXSkpe2lmKEluLnF1YWRyYW50KHRbaS0xXSx0W2ldKSE9PXMpYnJlYWt9aSsrfXJldHVybiBpLTF9c3RhdGljIGdldENoYWlucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gQnMuZ2V0Q2hhaW5zKHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IHgscz1Ccy5nZXRDaGFpblN0YXJ0SW5kaWNlcyh0KTtmb3IobGV0IGk9MDtpPHMubGVuZ3RoLTE7aSsrKXtjb25zdCByPW5ldyBxcyh0LHNbaV0sc1tpKzFdLGUpO24uYWRkKHIpfXJldHVybiBufX1zdGF0aWMgdG9JbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPXQuZ2V0KG4pLmludFZhbHVlKCk7cmV0dXJuIGV9Z2V0Q2xhc3MoKXtyZXR1cm4gQnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUJzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgVnN7Y29uc3RydWN0b3IoKXtWcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXB1dGVOb2Rlcyh0KXt9Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7fWdldENsYXNzKCl7cmV0dXJuIFZzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Wcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHpze2NvbnN0cnVjdG9yKCl7enMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRTZWdtZW50SW50ZXJzZWN0b3IodCl7dGhpcy5fc2VnSW50PXR9Z2V0Q2xhc3MoKXtyZXR1cm4genN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1ZzXX19enMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fc2VnSW50PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0U2VnbWVudEludGVyc2VjdG9yKHQpfX07Y2xhc3MgWXMgZXh0ZW5kcyB6c3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksWXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRNb25vdG9uZUNoYWlucygpe3JldHVybiB0aGlzLl9tb25vQ2hhaW5zfWdldE5vZGVkU3Vic3RyaW5ncygpe3JldHVybiBGcy5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5fbm9kZWRTZWdTdHJpbmdzKX1nZXRJbmRleCgpe3JldHVybiB0aGlzLl9pbmRleH1hZGQodCl7Zm9yKGxldCBlPUJzLmdldENoYWlucyh0LmdldENvb3JkaW5hdGVzKCksdCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5zZXRJZCh0aGlzLl9pZENvdW50ZXIrKyksdGhpcy5faW5kZXguaW5zZXJ0KHQuZ2V0RW52ZWxvcGUoKSx0KSx0aGlzLl9tb25vQ2hhaW5zLmFkZCh0KX19Y29tcHV0ZU5vZGVzKHQpe3RoaXMuX25vZGVkU2VnU3RyaW5ncz10O2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTt0aGlzLmludGVyc2VjdENoYWlucygpfWludGVyc2VjdENoYWlucygpe2NvbnN0IHQ9bmV3IFVzKHRoaXMuX3NlZ0ludCk7Zm9yKGxldCBlPXRoaXMuX21vbm9DaGFpbnMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7Zm9yKGxldCBlPXRoaXMuX2luZGV4LnF1ZXJ5KG4uZ2V0RW52ZWxvcGUoKSkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCk7aWYocy5nZXRJZCgpPm4uZ2V0SWQoKSYmKG4uY29tcHV0ZU92ZXJsYXBzKHMsdCksdGhpcy5fbk92ZXJsYXBzKyspLHRoaXMuX3NlZ0ludC5pc0RvbmUoKSlyZXR1cm4gbnVsbH19fWdldENsYXNzKCl7cmV0dXJuIFlzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBVcyBleHRlbmRzIEdze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxVcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfW92ZXJsYXAoKXtpZig0IT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gc3VwZXIub3ZlcmxhcC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9dC5nZXRDb250ZXh0KCkscj1uLmdldENvbnRleHQoKTt0aGlzLl9zaS5wcm9jZXNzSW50ZXJzZWN0aW9ucyhpLGUscixzKX19Z2V0Q2xhc3MoKXtyZXR1cm4gVXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVVzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NpPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2k9dH0sWXMuU2VnbWVudE92ZXJsYXBBY3Rpb249VXMsWXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbW9ub0NoYWlucz1uZXcgeCx0aGlzLl9pbmRleD1uZXcgRXMsdGhpcy5faWRDb3VudGVyPTAsdGhpcy5fbm9kZWRTZWdTdHJpbmdzPW51bGwsdGhpcy5fbk92ZXJsYXBzPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3pzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fTtjbGFzcyBrc3tjb25zdHJ1Y3Rvcigpe2tzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmVzY2FsZSgpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMucmVzY2FsZShlLmdldENvb3JkaW5hdGVzKCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW51bGwsbj1udWxsOzI9PT10Lmxlbmd0aCYmKGU9bmV3IGcodFswXSksbj1uZXcgZyh0WzFdKSk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXS54PXRbZV0ueC90aGlzLl9zY2FsZUZhY3Rvcit0aGlzLl9vZmZzZXRYLHRbZV0ueT10W2VdLnkvdGhpcy5fc2NhbGVGYWN0b3IrdGhpcy5fb2Zmc2V0WTsyPT09dC5sZW5ndGgmJnRbMF0uZXF1YWxzMkQodFsxXSkmJk8ub3V0LnByaW50bG4odCl9fXNjYWxlKCl7aWYoXyhhcmd1bWVudHNbMF0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHgodC5zaXplKCkpO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyBGcyh0aGlzLnNjYWxlKHQuZ2V0Q29vcmRpbmF0ZXMoKSksdC5nZXREYXRhKCkpKX1yZXR1cm4gZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllW25dPW5ldyBnKE1hdGgucm91bmQoKHRbbl0ueC10aGlzLl9vZmZzZXRYKSp0aGlzLl9zY2FsZUZhY3RvciksTWF0aC5yb3VuZCgodFtuXS55LXRoaXMuX29mZnNldFkpKnRoaXMuX3NjYWxlRmFjdG9yKSx0W25dLnopO3JldHVybiBYLnJlbW92ZVJlcGVhdGVkUG9pbnRzKGUpfX1pc0ludGVnZXJQcmVjaXNpb24oKXtyZXR1cm4gMT09PXRoaXMuX3NjYWxlRmFjdG9yfWdldE5vZGVkU3Vic3RyaW5ncygpe2NvbnN0IHQ9dGhpcy5fbm9kZXIuZ2V0Tm9kZWRTdWJzdHJpbmdzKCk7cmV0dXJuIHRoaXMuX2lzU2NhbGVkJiZ0aGlzLnJlc2NhbGUodCksdH1jb21wdXRlTm9kZXModCl7bGV0IGU9dDt0aGlzLl9pc1NjYWxlZCYmKGU9dGhpcy5zY2FsZSh0KSksdGhpcy5fbm9kZXIuY29tcHV0ZU5vZGVzKGUpfWdldENsYXNzKCl7cmV0dXJuIGtzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltWc119fWtzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX25vZGVyPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9vZmZzZXRYPW51bGwsdGhpcy5fb2Zmc2V0WT1udWxsLHRoaXMuX2lzU2NhbGVkPSExLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtrcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSwwLDApfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX25vZGVyPXQsdGhpcy5fc2NhbGVGYWN0b3I9ZSx0aGlzLl9pc1NjYWxlZD0hdGhpcy5pc0ludGVnZXJQcmVjaXNpb24oKX19O3ZhciBYcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxNQ0luZGV4Tm9kZXI6WXMsU2NhbGVkTm9kZXI6a3MsU2VnbWVudFN0cmluZzpEc30pO2NsYXNzIEhze2NvbnN0cnVjdG9yKCl7SHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNTaW1wbGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBIcyh0KS5pc1NpbXBsZSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IEhzKHQsZSkuaXNTaW1wbGUoKX19aXNTaW1wbGVNdWx0aVBvaW50KHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiEwO2NvbnN0IGU9bmV3IGF0O2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pLmdldENvb3JkaW5hdGUoKTtpZihlLmNvbnRhaW5zKHMpKXJldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1zLCExO2UuYWRkKHMpfXJldHVybiEwfWlzU2ltcGxlUG9seWdvbmFsKHQpe2ZvcihsZXQgZT14ZS5nZXRMaW5lcyh0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZighdGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpKXJldHVybiExfXJldHVybiEwfWhhc0Nsb3NlZEVuZHBvaW50SW50ZXJzZWN0aW9uKHQpe2NvbnN0IGU9bmV3IHJ0O2ZvcihsZXQgbj10LmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxzPSh0LmdldE1heGltdW1TZWdtZW50SW5kZXgoKSx0LmlzQ2xvc2VkKCkpLGk9dC5nZXRDb29yZGluYXRlKDApO3RoaXMuYWRkRW5kcG9pbnQoZSxpLHMpO2NvbnN0IHI9dC5nZXRDb29yZGluYXRlKHQuZ2V0TnVtUG9pbnRzKCktMSk7dGhpcy5hZGRFbmRwb2ludChlLHIscyl9Zm9yKGxldCB0PWUudmFsdWVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7aWYoZS5pc0Nsb3NlZCYmMiE9PWUuZGVncmVlKXJldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1lLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX1nZXROb25TaW1wbGVMb2NhdGlvbigpe3JldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbn1pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiEwO2NvbnN0IGU9bmV3IFFuKDAsdCksbj1uZXcgdGUscz1lLmNvbXB1dGVTZWxmTm9kZXMobiwhMCk7cmV0dXJuIXMuaGFzSW50ZXJzZWN0aW9uKCl8fChzLmhhc1Byb3BlckludGVyc2VjdGlvbigpPyh0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1zLmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOiF0aGlzLmhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uKGUpJiYoIXRoaXMuX2lzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcnx8IXRoaXMuaGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSkpKX1oYXNOb25FbmRwb2ludEludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9dC5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldE1heGltdW1TZWdtZW50SW5kZXgoKTtmb3IobGV0IGU9dC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKCF0LmlzRW5kUG9pbnQobikpcmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPXQuZ2V0Q29vcmRpbmF0ZSgpLCEwfX1yZXR1cm4hMX1hZGRFbmRwb2ludCh0LGUsbil7bGV0IHM9dC5nZXQoZSk7bnVsbD09PXMmJihzPW5ldyBXcyhlKSx0LnB1dChlLHMpKSxzLmFkZEVuZHBvaW50KG4pfWNvbXB1dGVTaW1wbGUodCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsISF0LmlzRW1wdHkoKXx8KHQgaW5zdGFuY2VvZiBUdHx8dCBpbnN0YW5jZW9mIGZ0P3RoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KTp0IGluc3RhbmNlb2YgTXQ/dGhpcy5pc1NpbXBsZU11bHRpUG9pbnQodCk6Xyh0LE90KT90aGlzLmlzU2ltcGxlUG9seWdvbmFsKHQpOiEodCBpbnN0YW5jZW9mIF90KXx8dGhpcy5pc1NpbXBsZUdlb21ldHJ5Q29sbGVjdGlvbih0KSl9aXNTaW1wbGUoKXtyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249bnVsbCx0aGlzLmNvbXB1dGVTaW1wbGUodGhpcy5faW5wdXRHZW9tKX1pc1NpbXBsZUdlb21ldHJ5Q29sbGVjdGlvbih0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZighdGhpcy5jb21wdXRlU2ltcGxlKG4pKXJldHVybiExfXJldHVybiEwfWdldENsYXNzKCl7cmV0dXJuIEhzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBXc3tjb25zdHJ1Y3Rvcigpe1dzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkRW5kcG9pbnQodCl7dGhpcy5kZWdyZWUrKyx0aGlzLmlzQ2xvc2VkfD10fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5wdH1nZXRDbGFzcygpe3JldHVybiBXc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19V3MuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5wdD1udWxsLHRoaXMuaXNDbG9zZWQ9bnVsbCx0aGlzLmRlZ3JlZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucHQ9dCx0aGlzLmlzQ2xvc2VkPSExLHRoaXMuZGVncmVlPTB9LEhzLkVuZHBvaW50SW5mbz1XcyxIcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3I9ITAsdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSFlLmlzSW5Cb3VuZGFyeSgyKX19O2NsYXNzIGpze2NvbnN0cnVjdG9yKCl7anMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgYnVmZmVyRGlzdGFuY2VFcnJvcih0KXtjb25zdCBlPU1hdGguUEkvMi90O3JldHVybiAxLU1hdGguY29zKGUvMil9Z2V0RW5kQ2FwU3R5bGUoKXtyZXR1cm4gdGhpcy5fZW5kQ2FwU3R5bGV9aXNTaW5nbGVTaWRlZCgpe3JldHVybiB0aGlzLl9pc1NpbmdsZVNpZGVkfXNldFF1YWRyYW50U2VnbWVudHModCl7dGhpcy5fcXVhZHJhbnRTZWdtZW50cz10LDA9PT10aGlzLl9xdWFkcmFudFNlZ21lbnRzJiYodGhpcy5fam9pblN0eWxlPWpzLkpPSU5fQkVWRUwpLHRoaXMuX3F1YWRyYW50U2VnbWVudHM8MCYmKHRoaXMuX2pvaW5TdHlsZT1qcy5KT0lOX01JVFJFLHRoaXMuX21pdHJlTGltaXQ9TWF0aC5hYnModGhpcy5fcXVhZHJhbnRTZWdtZW50cykpLHQ8PTAmJih0aGlzLl9xdWFkcmFudFNlZ21lbnRzPTEpLHRoaXMuX2pvaW5TdHlsZSE9PWpzLkpPSU5fUk9VTkQmJih0aGlzLl9xdWFkcmFudFNlZ21lbnRzPWpzLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMpfWdldEpvaW5TdHlsZSgpe3JldHVybiB0aGlzLl9qb2luU3R5bGV9c2V0Sm9pblN0eWxlKHQpe3RoaXMuX2pvaW5TdHlsZT10fXNldFNpbXBsaWZ5RmFjdG9yKHQpe3RoaXMuX3NpbXBsaWZ5RmFjdG9yPXQ8MD8wOnR9Z2V0U2ltcGxpZnlGYWN0b3IoKXtyZXR1cm4gdGhpcy5fc2ltcGxpZnlGYWN0b3J9Z2V0UXVhZHJhbnRTZWdtZW50cygpe3JldHVybiB0aGlzLl9xdWFkcmFudFNlZ21lbnRzfXNldEVuZENhcFN0eWxlKHQpe3RoaXMuX2VuZENhcFN0eWxlPXR9Z2V0TWl0cmVMaW1pdCgpe3JldHVybiB0aGlzLl9taXRyZUxpbWl0fXNldE1pdHJlTGltaXQodCl7dGhpcy5fbWl0cmVMaW1pdD10fXNldFNpbmdsZVNpZGVkKHQpe3RoaXMuX2lzU2luZ2xlU2lkZWQ9dH1nZXRDbGFzcygpe3JldHVybiBqc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19anMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz1qcy5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTLHRoaXMuX2VuZENhcFN0eWxlPWpzLkNBUF9ST1VORCx0aGlzLl9qb2luU3R5bGU9anMuSk9JTl9ST1VORCx0aGlzLl9taXRyZUxpbWl0PWpzLkRFRkFVTFRfTUlUUkVfTElNSVQsdGhpcy5faXNTaW5nbGVTaWRlZD0hMSx0aGlzLl9zaW1wbGlmeUZhY3Rvcj1qcy5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUiwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KSx0aGlzLnNldEVuZENhcFN0eWxlKGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KSx0aGlzLnNldEVuZENhcFN0eWxlKGUpLHRoaXMuc2V0Sm9pblN0eWxlKG4pLHRoaXMuc2V0TWl0cmVMaW1pdChzKX19LGpzLkNBUF9ST1VORD0xLGpzLkNBUF9GTEFUPTIsanMuQ0FQX1NRVUFSRT0zLGpzLkpPSU5fUk9VTkQ9MSxqcy5KT0lOX01JVFJFPTIsanMuSk9JTl9CRVZFTD0zLGpzLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM9OCxqcy5ERUZBVUxUX01JVFJFX0xJTUlUPTUsanMuREVGQVVMVF9TSU1QTElGWV9GQUNUT1I9LjAxO2NsYXNzIEtze2NvbnN0cnVjdG9yKCl7S3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX21pbkNvb3JkfWdldFJpZ2h0bW9zdFNpZGUodCxlKXtsZXQgbj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlKTtyZXR1cm4gbjwwJiYobj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlLTEpKSxuPDAmJih0aGlzLl9taW5Db29yZD1udWxsLHRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpKSxufWZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXgoKXtjb25zdCB0PXRoaXMuX21pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO3UuaXNUcnVlKHRoaXMuX21pbkluZGV4PjAmJnRoaXMuX21pbkluZGV4PHQubGVuZ3RoLFwicmlnaHRtb3N0IHBvaW50IGV4cGVjdGVkIHRvIGJlIGludGVyaW9yIHZlcnRleCBvZiBlZGdlXCIpO2NvbnN0IGU9dFt0aGlzLl9taW5JbmRleC0xXSxuPXRbdGhpcy5fbWluSW5kZXgrMV0scz12LmluZGV4KHRoaXMuX21pbkNvb3JkLG4sZSk7bGV0IGk9ITE7KGUueTx0aGlzLl9taW5Db29yZC55JiZuLnk8dGhpcy5fbWluQ29vcmQueSYmcz09PXYuQ09VTlRFUkNMT0NLV0lTRXx8ZS55PnRoaXMuX21pbkNvb3JkLnkmJm4ueT50aGlzLl9taW5Db29yZC55JiZzPT09di5DTE9DS1dJU0UpJiYoaT0hMCksaSYmKHRoaXMuX21pbkluZGV4PXRoaXMuX21pbkluZGV4LTEpfWdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlKXtjb25zdCBuPXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7aWYoZTwwfHxlKzE+PW4ubGVuZ3RoKXJldHVybi0xO2lmKG5bZV0ueT09PW5bZSsxXS55KXJldHVybi0xO2xldCBzPVBuLkxFRlQ7cmV0dXJuIG5bZV0ueTxuW2UrMV0ueSYmKHM9UG4uUklHSFQpLHN9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9vcmllbnRlZERlfWNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KXtjb25zdCBlPXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aC0xO24rKykobnVsbD09PXRoaXMuX21pbkNvb3JkfHxlW25dLng+dGhpcy5fbWluQ29vcmQueCkmJih0aGlzLl9taW5EZT10LHRoaXMuX21pbkluZGV4PW4sdGhpcy5fbWluQ29vcmQ9ZVtuXSl9ZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUoKXtjb25zdCB0PXRoaXMuX21pbkRlLmdldE5vZGUoKS5nZXRFZGdlcygpO3RoaXMuX21pbkRlPXQuZ2V0UmlnaHRtb3N0RWRnZSgpLHRoaXMuX21pbkRlLmlzRm9yd2FyZCgpfHwodGhpcy5fbWluRGU9dGhpcy5fbWluRGUuZ2V0U3ltKCksdGhpcy5fbWluSW5kZXg9dGhpcy5fbWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoLTEpfWZpbmRFZGdlKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuaXNGb3J3YXJkKCkmJnRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpfXUuaXNUcnVlKDAhPT10aGlzLl9taW5JbmRleHx8dGhpcy5fbWluQ29vcmQuZXF1YWxzKHRoaXMuX21pbkRlLmdldENvb3JkaW5hdGUoKSksXCJpbmNvbnNpc3RlbmN5IGluIHJpZ2h0bW9zdCBwcm9jZXNzaW5nXCIpLDA9PT10aGlzLl9taW5JbmRleD90aGlzLmZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCk6dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCksdGhpcy5fb3JpZW50ZWREZT10aGlzLl9taW5EZSx0aGlzLmdldFJpZ2h0bW9zdFNpZGUodGhpcy5fbWluRGUsdGhpcy5fbWluSW5kZXgpPT09UG4uTEVGVCYmKHRoaXMuX29yaWVudGVkRGU9dGhpcy5fbWluRGUuZ2V0U3ltKCkpfWdldENsYXNzKCl7cmV0dXJuIEtzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBacygpe3RoaXMuYXJyYXlfPVtdfUtzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX21pbkluZGV4PS0xLHRoaXMuX21pbkNvb3JkPW51bGwsdGhpcy5fbWluRGU9bnVsbCx0aGlzLl9vcmllbnRlZERlPW51bGx9LFpzLnByb3RvdHlwZS5hZGRMYXN0PWZ1bmN0aW9uKHQpe3RoaXMuYXJyYXlfLnB1c2godCl9LFpzLnByb3RvdHlwZS5yZW1vdmVGaXJzdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5zaGlmdCgpfSxacy5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofTtjbGFzcyBRc3tjb25zdHJ1Y3Rvcigpe1FzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2xlYXJWaXNpdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLnNldFZpc2l0ZWQoITEpfX1nZXRSaWdodG1vc3RDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3JpZ2h0TW9zdENvb3JkfWNvbXB1dGVOb2RlRGVwdGgodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQuaXNWaXNpdGVkKCl8fHQuZ2V0U3ltKCkuaXNWaXNpdGVkKCkpe2U9dDticmVha319aWYobnVsbD09PWUpdGhyb3cgbmV3IFduKFwidW5hYmxlIHRvIGZpbmQgZWRnZSB0byBjb21wdXRlIGRlcHRocyBhdCBcIit0LmdldENvb3JkaW5hdGUoKSk7dC5nZXRFZGdlcygpLmNvbXB1dGVEZXB0aHMoZSk7Zm9yKGxldCBlPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LnNldFZpc2l0ZWQoITApLHRoaXMuY29weVN5bURlcHRocyh0KX19Y29tcHV0ZURlcHRoKHQpe3RoaXMuY2xlYXJWaXNpdGVkRWRnZXMoKTtjb25zdCBlPXRoaXMuX2ZpbmRlci5nZXRFZGdlKCk7ZS5nZXROb2RlKCksZS5nZXRMYWJlbCgpO2Uuc2V0RWRnZURlcHRocyhQbi5SSUdIVCx0KSx0aGlzLmNvcHlTeW1EZXB0aHMoZSksdGhpcy5jb21wdXRlRGVwdGhzKGUpfWNyZWF0ZSh0KXt0aGlzLmFkZFJlYWNoYWJsZSh0KSx0aGlzLl9maW5kZXIuZmluZEVkZ2UodGhpcy5fZGlyRWRnZUxpc3QpLHRoaXMuX3JpZ2h0TW9zdENvb3JkPXRoaXMuX2ZpbmRlci5nZXRDb29yZGluYXRlKCl9ZmluZFJlc3VsdEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2UuZ2V0RGVwdGgoUG4uUklHSFQpPj0xJiZlLmdldERlcHRoKFBuLkxFRlQpPD0wJiYhZS5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmZS5zZXRJblJlc3VsdCghMCl9fWNvbXB1dGVEZXB0aHModCl7Y29uc3QgZT1uZXcgSixuPW5ldyBacyxzPXQuZ2V0Tm9kZSgpO2ZvcihuLmFkZExhc3QocyksZS5hZGQocyksdC5zZXRWaXNpdGVkKCEwKTshbi5pc0VtcHR5KCk7KXtjb25zdCB0PW4ucmVtb3ZlRmlyc3QoKTtlLmFkZCh0KSx0aGlzLmNvbXB1dGVOb2RlRGVwdGgodCk7Zm9yKGxldCBzPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKS5nZXRTeW0oKTtpZih0LmlzVmlzaXRlZCgpKWNvbnRpbnVlO2NvbnN0IGk9dC5nZXROb2RlKCk7ZS5jb250YWlucyhpKXx8KG4uYWRkTGFzdChpKSxlLmFkZChpKSl9fX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9yaWdodE1vc3RDb29yZC54PGUuX3JpZ2h0TW9zdENvb3JkLng/LTE6dGhpcy5fcmlnaHRNb3N0Q29vcmQueD5lLl9yaWdodE1vc3RDb29yZC54PzE6MH1nZXRFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9lbnYpe2NvbnN0IHQ9bmV3IE47Zm9yKGxldCBlPXRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGgtMTtlKyspdC5leHBhbmRUb0luY2x1ZGUobltlXSl9dGhpcy5fZW52PXR9cmV0dXJuIHRoaXMuX2Vudn1hZGRSZWFjaGFibGUodCl7Y29uc3QgZT1uZXcgb247Zm9yKGUuYWRkKHQpOyFlLmVtcHR5KCk7KXtjb25zdCB0PWUucG9wKCk7dGhpcy5hZGQodCxlKX19Y29weVN5bURlcHRocyh0KXtjb25zdCBlPXQuZ2V0U3ltKCk7ZS5zZXREZXB0aChQbi5MRUZULHQuZ2V0RGVwdGgoUG4uUklHSFQpKSxlLnNldERlcHRoKFBuLlJJR0hULHQuZ2V0RGVwdGgoUG4uTEVGVCkpfWFkZCh0LGUpe3Quc2V0VmlzaXRlZCghMCksdGhpcy5fbm9kZXMuYWRkKHQpO2ZvcihsZXQgbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fZGlyRWRnZUxpc3QuYWRkKHQpO2NvbnN0IHM9dC5nZXRTeW0oKS5nZXROb2RlKCk7cy5pc1Zpc2l0ZWQoKXx8ZS5wdXNoKHMpfX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2Rlc31nZXREaXJlY3RlZEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VMaXN0fWdldENsYXNzKCl7cmV0dXJuIFFzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19UXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZmluZGVyPW51bGwsdGhpcy5fZGlyRWRnZUxpc3Q9bmV3IHgsdGhpcy5fbm9kZXM9bmV3IHgsdGhpcy5fcmlnaHRNb3N0Q29vcmQ9bnVsbCx0aGlzLl9lbnY9bnVsbCx0aGlzLl9maW5kZXI9bmV3IEtzfTtjbGFzcyBKc3tjb25zdHJ1Y3Rvcigpe0pzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZVJpbmcoKXtpZihudWxsIT09dGhpcy5fcmluZylyZXR1cm4gbnVsbDtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9wdHMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5fcHRzLnNpemUoKTtlKyspdFtlXT10aGlzLl9wdHMuZ2V0KGUpO3RoaXMuX3Jpbmc9dGhpcy5fZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodCksdGhpcy5faXNIb2xlPXYuaXNDQ1codGhpcy5fcmluZy5nZXRDb29yZGluYXRlcygpKX1pc0lzb2xhdGVkKCl7cmV0dXJuIDE9PT10aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCl9Y29tcHV0ZVBvaW50cyh0KXt0aGlzLl9zdGFydERlPXQ7bGV0IGU9dCxuPSEwO2Rve2lmKG51bGw9PT1lKXRocm93IG5ldyBXbihcIkZvdW5kIG51bGwgRGlyZWN0ZWRFZGdlXCIpO2lmKGUuZ2V0RWRnZVJpbmcoKT09PXRoaXMpdGhyb3cgbmV3IFduKFwiRGlyZWN0ZWQgRWRnZSB2aXNpdGVkIHR3aWNlIGR1cmluZyByaW5nLWJ1aWxkaW5nIGF0IFwiK2UuZ2V0Q29vcmRpbmF0ZSgpKTt0aGlzLl9lZGdlcy5hZGQoZSk7Y29uc3QgdD1lLmdldExhYmVsKCk7dS5pc1RydWUodC5pc0FyZWEoKSksdGhpcy5tZXJnZUxhYmVsKHQpLHRoaXMuYWRkUG9pbnRzKGUuZ2V0RWRnZSgpLGUuaXNGb3J3YXJkKCksbiksbj0hMSx0aGlzLnNldEVkZ2VSaW5nKGUsdGhpcyksZT10aGlzLmdldE5leHQoZSl9d2hpbGUoZSE9PXRoaXMuX3N0YXJ0RGUpfWdldExpbmVhclJpbmcoKXtyZXR1cm4gdGhpcy5fcmluZ31nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdHMuZ2V0KHQpfWNvbXB1dGVNYXhOb2RlRGVncmVlKCl7dGhpcy5fbWF4Tm9kZURlZ3JlZT0wO2xldCB0PXRoaXMuX3N0YXJ0RGU7ZG97Y29uc3QgZT10LmdldE5vZGUoKS5nZXRFZGdlcygpLmdldE91dGdvaW5nRGVncmVlKHRoaXMpO2U+dGhpcy5fbWF4Tm9kZURlZ3JlZSYmKHRoaXMuX21heE5vZGVEZWdyZWU9ZSksdD10aGlzLmdldE5leHQodCl9d2hpbGUodCE9PXRoaXMuX3N0YXJ0RGUpO3RoaXMuX21heE5vZGVEZWdyZWUqPTJ9YWRkUG9pbnRzKHQsZSxuKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlKXtsZXQgdD0xO24mJih0PTApO2ZvcihsZXQgZT10O2U8cy5sZW5ndGg7ZSsrKXRoaXMuX3B0cy5hZGQoc1tlXSl9ZWxzZXtsZXQgdD1zLmxlbmd0aC0yO24mJih0PXMubGVuZ3RoLTEpO2ZvcihsZXQgZT10O2U+PTA7ZS0tKXRoaXMuX3B0cy5hZGQoc1tlXSl9fWlzSG9sZSgpe3JldHVybiB0aGlzLl9pc0hvbGV9c2V0SW5SZXN1bHQoKXtsZXQgdD10aGlzLl9zdGFydERlO2Rve3QuZ2V0RWRnZSgpLnNldEluUmVzdWx0KCEwKSx0PXQuZ2V0TmV4dCgpfXdoaWxlKHQhPT10aGlzLl9zdGFydERlKX1jb250YWluc1BvaW50KHQpe2NvbnN0IGU9dGhpcy5nZXRMaW5lYXJSaW5nKCk7aWYoIWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvbnRhaW5zKHQpKXJldHVybiExO2lmKCFXZS5pc0luUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSkpcmV0dXJuITE7Zm9yKGxldCBlPXRoaXMuX2hvbGVzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtpZihlLm5leHQoKS5jb250YWluc1BvaW50KHQpKXJldHVybiExfXJldHVybiEwfWFkZEhvbGUodCl7dGhpcy5faG9sZXMuYWRkKHQpfWlzU2hlbGwoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3NoZWxsfWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfWdldE1heE5vZGVEZWdyZWUoKXtyZXR1cm4gdGhpcy5fbWF4Tm9kZURlZ3JlZTwwJiZ0aGlzLmNvbXB1dGVNYXhOb2RlRGVncmVlKCksdGhpcy5fbWF4Tm9kZURlZ3JlZX1nZXRTaGVsbCgpe3JldHVybiB0aGlzLl9zaGVsbH1tZXJnZUxhYmVsKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubWVyZ2VMYWJlbCh0LDApLHRoaXMubWVyZ2VMYWJlbCh0LDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRMb2NhdGlvbihlLFBuLlJJR0hUKTtpZihuPT09bmUuTk9ORSlyZXR1cm4gbnVsbDtpZih0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlKT09PW5lLk5PTkUpcmV0dXJuIHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKGUsbiksbnVsbH19c2V0U2hlbGwodCl7dGhpcy5fc2hlbGw9dCxudWxsIT09dCYmdC5hZGRIb2xlKHRoaXMpfXRvUG9seWdvbih0KXtjb25zdCBlPW5ldyBBcnJheSh0aGlzLl9ob2xlcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5zaXplKCk7dCsrKWVbdF09dGhpcy5faG9sZXMuZ2V0KHQpLmdldExpbmVhclJpbmcoKTtyZXR1cm4gdC5jcmVhdGVQb2x5Z29uKHRoaXMuZ2V0TGluZWFyUmluZygpLGUpfWdldENsYXNzKCl7cmV0dXJuIEpzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Kcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9zdGFydERlPW51bGwsdGhpcy5fbWF4Tm9kZURlZ3JlZT0tMSx0aGlzLl9lZGdlcz1uZXcgeCx0aGlzLl9wdHM9bmV3IHgsdGhpcy5fbGFiZWw9bmV3IEZuKG5lLk5PTkUpLHRoaXMuX3Jpbmc9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLl9zaGVsbD1udWxsLHRoaXMuX2hvbGVzPW5ldyB4LHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZSx0aGlzLmNvbXB1dGVQb2ludHModCksdGhpcy5jb21wdXRlUmluZygpfX07Y2xhc3MgJHMgZXh0ZW5kcyBKc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksJHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRFZGdlUmluZyh0LGUpe3Quc2V0TWluRWRnZVJpbmcoZSl9Z2V0TmV4dCh0KXtyZXR1cm4gdC5nZXROZXh0TWluKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gJHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fSRzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0pzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX07Y2xhc3MgdGkgZXh0ZW5kcyBKc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1idWlsZE1pbmltYWxSaW5ncygpe2NvbnN0IHQ9bmV3IHg7bGV0IGU9dGhpcy5fc3RhcnREZTtkb3tpZihudWxsPT09ZS5nZXRNaW5FZGdlUmluZygpKXtjb25zdCBuPW5ldyAkcyhlLHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7dC5hZGQobil9ZT1lLmdldE5leHQoKX13aGlsZShlIT09dGhpcy5fc3RhcnREZSk7cmV0dXJuIHR9c2V0RWRnZVJpbmcodCxlKXt0LnNldEVkZ2VSaW5nKGUpfWxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpe2xldCB0PXRoaXMuX3N0YXJ0RGU7ZG97dC5nZXROb2RlKCkuZ2V0RWRnZXMoKS5saW5rTWluaW1hbERpcmVjdGVkRWRnZXModGhpcyksdD10LmdldE5leHQoKX13aGlsZSh0IT09dGhpcy5fc3RhcnREZSl9Z2V0TmV4dCh0KXtyZXR1cm4gdC5nZXROZXh0KCl9Z2V0Q2xhc3MoKXtyZXR1cm4gdGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXRpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0pzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX07Y2xhc3MgZWl7Y29uc3RydWN0b3IoKXtlaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNvcnRTaGVsbHNBbmRIb2xlcyh0LGUsbil7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5pc0hvbGUoKT9uLmFkZCh0KTplLmFkZCh0KX19Y29tcHV0ZVBvbHlnb25zKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkudG9Qb2x5Z29uKHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7ZS5hZGQodCl9cmV0dXJuIGV9cGxhY2VGcmVlSG9sZXModCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKTtpZihudWxsPT09ZS5nZXRTaGVsbCgpKXtjb25zdCBuPXRoaXMuZmluZEVkZ2VSaW5nQ29udGFpbmluZyhlLHQpO2lmKG51bGw9PT1uKXRocm93IG5ldyBXbihcInVuYWJsZSB0byBhc3NpZ24gaG9sZSB0byBhIHNoZWxsXCIsZS5nZXRDb29yZGluYXRlKDApKTtlLnNldFNoZWxsKG4pfX19YnVpbGRNaW5pbWFsRWRnZVJpbmdzKHQsZSxuKXtjb25zdCBzPW5ldyB4O2ZvcihsZXQgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCB0PWkubmV4dCgpO2lmKHQuZ2V0TWF4Tm9kZURlZ3JlZSgpPjIpe3QubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7Y29uc3Qgcz10LmJ1aWxkTWluaW1hbFJpbmdzKCksaT10aGlzLmZpbmRTaGVsbChzKTtudWxsIT09aT8odGhpcy5wbGFjZVBvbHlnb25Ib2xlcyhpLHMpLGUuYWRkKGkpKTpuLmFkZEFsbChzKX1lbHNlIHMuYWRkKHQpfXJldHVybiBzfWNvbnRhaW5zUG9pbnQodCl7Zm9yKGxldCBlPXRoaXMuX3NoZWxsTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7aWYoZS5uZXh0KCkuY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMH1yZXR1cm4hMX1idWlsZE1heGltYWxFZGdlUmluZ3ModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzSW5SZXN1bHQoKSYmdC5nZXRMYWJlbCgpLmlzQXJlYSgpJiZudWxsPT09dC5nZXRFZGdlUmluZygpKXtjb25zdCBuPW5ldyB0aSh0LHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7ZS5hZGQobiksbi5zZXRJblJlc3VsdCgpfX1yZXR1cm4gZX1wbGFjZVBvbHlnb25Ib2xlcyh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpO2UuaXNIb2xlKCkmJmUuc2V0U2hlbGwodCl9fWdldFBvbHlnb25zKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVBvbHlnb25zKHRoaXMuX3NoZWxsTGlzdCl9ZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LGUpe2NvbnN0IG49dC5nZXRMaW5lYXJSaW5nKCkscz1uLmdldEVudmVsb3BlSW50ZXJuYWwoKSxpPW4uZ2V0Q29vcmRpbmF0ZU4oMCk7bGV0IHI9bnVsbCxvPW51bGw7Zm9yKGxldCB0PWUuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExpbmVhclJpbmcoKSxsPW4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO251bGwhPT1yJiYobz1yLmdldExpbmVhclJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpO2xldCBhPSExO2wuY29udGFpbnMocykmJldlLmlzSW5SaW5nKGksbi5nZXRDb29yZGluYXRlcygpKSYmKGE9ITApLGEmJihudWxsPT09cnx8by5jb250YWlucyhsKSkmJihyPWUpfXJldHVybiByfWZpbmRTaGVsbCh0KXtsZXQgZT0wLG49bnVsbDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmlzSG9sZSgpfHwobj10LGUrKyl9cmV0dXJuIHUuaXNUcnVlKGU8PTEsXCJmb3VuZCB0d28gc2hlbGxzIGluIE1pbmltYWxFZGdlUmluZyBsaXN0XCIpLG59YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHQuZ2V0RWRnZUVuZHMoKSx0LmdldE5vZGVzKCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1puLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKGUpO2NvbnN0IG49dGhpcy5idWlsZE1heGltYWxFZGdlUmluZ3ModCkscz1uZXcgeCxpPXRoaXMuYnVpbGRNaW5pbWFsRWRnZVJpbmdzKG4sdGhpcy5fc2hlbGxMaXN0LHMpO3RoaXMuc29ydFNoZWxsc0FuZEhvbGVzKGksdGhpcy5fc2hlbGxMaXN0LHMpLHRoaXMucGxhY2VGcmVlSG9sZXModGhpcy5fc2hlbGxMaXN0LHMpfX1nZXRDbGFzcygpe3JldHVybiBlaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5fc2hlbGxMaXN0PW5ldyB4O2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21ldHJ5RmFjdG9yeT10fTtjbGFzcyBuaXtjb25zdHJ1Y3Rvcigpe25pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNpbXBsaWZ5KHQsZSl7cmV0dXJuIG5ldyBuaSh0KS5zaW1wbGlmeShlKX1pc0RlbGV0YWJsZSh0LGUsbixzKXtjb25zdCBpPXRoaXMuX2lucHV0TGluZVt0XSxyPXRoaXMuX2lucHV0TGluZVtlXSxvPXRoaXMuX2lucHV0TGluZVtuXTtyZXR1cm4hIXRoaXMuaXNDb25jYXZlKGkscixvKSYmKCEhdGhpcy5pc1NoYWxsb3coaSxyLG8scykmJnRoaXMuaXNTaGFsbG93U2FtcGxlZChpLHIsdCxuLHMpKX1kZWxldGVTaGFsbG93Q29uY2F2aXRpZXMoKXtsZXQgdD0xO3RoaXMuX2lucHV0TGluZS5sZW5ndGg7bGV0IGU9dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSkscz0hMTtmb3IoO248dGhpcy5faW5wdXRMaW5lLmxlbmd0aDspe2xldCBpPSExO3RoaXMuaXNEZWxldGFibGUodCxlLG4sdGhpcy5fZGlzdGFuY2VUb2wpJiYodGhpcy5faXNEZWxldGVkW2VdPW5pLkRFTEVURSxpPSEwLHM9ITApLHQ9aT9uOmUsZT10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKX1yZXR1cm4gc31pc1NoYWxsb3dDb25jYXZpdHkodCxlLG4scyl7cmV0dXJuIHYuaW5kZXgodCxlLG4pPT09dGhpcy5fYW5nbGVPcmllbnRhdGlvbiYmRC5wb2ludFRvU2VnbWVudChlLHQsbik8c31pc1NoYWxsb3dTYW1wbGVkKHQsZSxuLHMsaSl7bGV0IHI9TWF0aC50cnVuYygocy1uKS9uaS5OVU1fUFRTX1RPX0NIRUNLKTtyPD0wJiYocj0xKTtmb3IobGV0IG89bjtvPHM7bys9cilpZighdGhpcy5pc1NoYWxsb3codCxlLHRoaXMuX2lucHV0TGluZVtvXSxpKSlyZXR1cm4hMTtyZXR1cm4hMH1pc0NvbmNhdmUodCxlLG4pe3JldHVybiB2LmluZGV4KHQsZSxuKT09PXRoaXMuX2FuZ2xlT3JpZW50YXRpb259c2ltcGxpZnkodCl7dGhpcy5fZGlzdGFuY2VUb2w9TWF0aC5hYnModCksdDwwJiYodGhpcy5fYW5nbGVPcmllbnRhdGlvbj12LkNMT0NLV0lTRSksdGhpcy5faXNEZWxldGVkPW5ldyBBcnJheSh0aGlzLl9pbnB1dExpbmUubGVuZ3RoKS5maWxsKG51bGwpO2xldCBlPSExO2Rve2U9dGhpcy5kZWxldGVTaGFsbG93Q29uY2F2aXRpZXMoKX13aGlsZShlKTtyZXR1cm4gdGhpcy5jb2xsYXBzZUxpbmUoKX1maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KXtsZXQgZT10KzE7Zm9yKDtlPHRoaXMuX2lucHV0TGluZS5sZW5ndGgmJnRoaXMuX2lzRGVsZXRlZFtlXT09PW5pLkRFTEVURTspZSsrO3JldHVybiBlfWlzU2hhbGxvdyh0LGUsbixzKXtyZXR1cm4gRC5wb2ludFRvU2VnbWVudChlLHQsbik8c31jb2xsYXBzZUxpbmUoKXtjb25zdCB0PW5ldyBJO2ZvcihsZXQgZT0wO2U8dGhpcy5faW5wdXRMaW5lLmxlbmd0aDtlKyspdGhpcy5faXNEZWxldGVkW2VdIT09bmkuREVMRVRFJiZ0LmFkZCh0aGlzLl9pbnB1dExpbmVbZV0pO3JldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9Z2V0Q2xhc3MoKXtyZXR1cm4gbml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW5pLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0TGluZT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sPW51bGwsdGhpcy5faXNEZWxldGVkPW51bGwsdGhpcy5fYW5nbGVPcmllbnRhdGlvbj12LkNPVU5URVJDTE9DS1dJU0U7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRMaW5lPXR9LG5pLklOSVQ9MCxuaS5ERUxFVEU9MSxuaS5LRUVQPTEsbmkuTlVNX1BUU19UT19DSEVDSz0xMDtjbGFzcyBzaXtjb25zdHJ1Y3Rvcigpe3NpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHRMaXN0LnRvQXJyYXkoc2kuQ09PUkRJTkFURV9BUlJBWV9UWVBFKX1zZXRQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl9wcmVjaXNpb25Nb2RlbD10fWFkZFB0KHQpe2NvbnN0IGU9bmV3IGcodCk7aWYodGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoZSksdGhpcy5pc1JlZHVuZGFudChlKSlyZXR1cm4gbnVsbDt0aGlzLl9wdExpc3QuYWRkKGUpfXJldmVyc2UoKXt9YWRkUHRzKHQsZSl7aWYoZSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLmFkZFB0KHRbZV0pO2Vsc2UgZm9yKGxldCBlPXQubGVuZ3RoLTE7ZT49MDtlLS0pdGhpcy5hZGRQdCh0W2VdKX1pc1JlZHVuZGFudCh0KXtpZih0aGlzLl9wdExpc3Quc2l6ZSgpPDEpcmV0dXJuITE7Y29uc3QgZT10aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCktMSk7cmV0dXJuIHQuZGlzdGFuY2UoZSk8dGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlfXRvU3RyaW5nKCl7cmV0dXJuKG5ldyBIdCkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpLnRvU3RyaW5nKCl9Y2xvc2VSaW5nKCl7aWYodGhpcy5fcHRMaXN0LnNpemUoKTwxKXJldHVybiBudWxsO2NvbnN0IHQ9bmV3IGcodGhpcy5fcHRMaXN0LmdldCgwKSksZT10aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCktMSk7bGV0IG49bnVsbDtpZih0aGlzLl9wdExpc3Quc2l6ZSgpPj0yJiZ0aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCktMiksdC5lcXVhbHMoZSkpcmV0dXJuIG51bGw7dGhpcy5fcHRMaXN0LmFkZCh0KX1zZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UodCl7dGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlPXR9Z2V0Q2xhc3MoKXtyZXR1cm4gc2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXNpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0TGlzdD1udWxsLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlPTAsdGhpcy5fcHRMaXN0PW5ldyB4fSxzaS5DT09SRElOQVRFX0FSUkFZX1RZUEU9bmV3IEFycmF5KDApLmZpbGwobnVsbCk7Y2xhc3MgaWl7Y29uc3RydWN0b3IoKXtpaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZE5leHRTZWdtZW50KHQsZSl7aWYodGhpcy5fczA9dGhpcy5fczEsdGhpcy5fczE9dGhpcy5fczIsdGhpcy5fczI9dCx0aGlzLl9zZWcwLnNldENvb3JkaW5hdGVzKHRoaXMuX3MwLHRoaXMuX3MxKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzAsdGhpcy5fc2lkZSx0aGlzLl9kaXN0YW5jZSx0aGlzLl9vZmZzZXQwKSx0aGlzLl9zZWcxLnNldENvb3JkaW5hdGVzKHRoaXMuX3MxLHRoaXMuX3MyKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzEsdGhpcy5fc2lkZSx0aGlzLl9kaXN0YW5jZSx0aGlzLl9vZmZzZXQxKSx0aGlzLl9zMS5lcXVhbHModGhpcy5fczIpKXJldHVybiBudWxsO2NvbnN0IG49di5pbmRleCh0aGlzLl9zMCx0aGlzLl9zMSx0aGlzLl9zMikscz1uPT09di5DTE9DS1dJU0UmJnRoaXMuX3NpZGU9PT1Qbi5MRUZUfHxuPT09di5DT1VOVEVSQ0xPQ0tXSVNFJiZ0aGlzLl9zaWRlPT09UG4uUklHSFQ7MD09PW4/dGhpcy5hZGRDb2xsaW5lYXIoZSk6cz90aGlzLmFkZE91dHNpZGVUdXJuKG4sZSk6dGhpcy5hZGRJbnNpZGVUdXJuKG4sZSl9YWRkTGluZUVuZENhcCh0LGUpe2NvbnN0IG49bmV3IGVlKHQsZSkscz1uZXcgZWU7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLFBuLkxFRlQsdGhpcy5fZGlzdGFuY2Uscyk7Y29uc3QgaT1uZXcgZWU7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLFBuLlJJR0hULHRoaXMuX2Rpc3RhbmNlLGkpO2NvbnN0IHI9ZS54LXQueCxvPWUueS10LnksbD1NYXRoLmF0YW4yKG8scik7c3dpdGNoKHRoaXMuX2J1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKXtjYXNlIGpzLkNBUF9ST1VORDp0aGlzLl9zZWdMaXN0LmFkZFB0KHMucDEpLHRoaXMuYWRkRGlyZWN0ZWRGaWxsZXQoZSxsK01hdGguUEkvMixsLU1hdGguUEkvMix2LkNMT0NLV0lTRSx0aGlzLl9kaXN0YW5jZSksdGhpcy5fc2VnTGlzdC5hZGRQdChpLnAxKTticmVhaztjYXNlIGpzLkNBUF9GTEFUOnRoaXMuX3NlZ0xpc3QuYWRkUHQocy5wMSksdGhpcy5fc2VnTGlzdC5hZGRQdChpLnAxKTticmVhaztjYXNlIGpzLkNBUF9TUVVBUkU6Y29uc3QgdD1uZXcgZzt0Lng9TWF0aC5hYnModGhpcy5fZGlzdGFuY2UpKk1hdGguY29zKGwpLHQueT1NYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkqTWF0aC5zaW4obCk7Y29uc3Qgbj1uZXcgZyhzLnAxLngrdC54LHMucDEueSt0LnkpLHI9bmV3IGcoaS5wMS54K3QueCxpLnAxLnkrdC55KTt0aGlzLl9zZWdMaXN0LmFkZFB0KG4pLHRoaXMuX3NlZ0xpc3QuYWRkUHQocil9fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3NlZ0xpc3QuZ2V0Q29vcmRpbmF0ZXMoKX1hZGRNaXRyZUpvaW4odCxlLG4scyl7bGV0IGk9ITAscj1udWxsO3RyeXtyPWIuaW50ZXJzZWN0aW9uKGUucDAsZS5wMSxuLnAwLG4ucDEpLChzPD0wPzE6ci5kaXN0YW5jZSh0KS9NYXRoLmFicyhzKSk+dGhpcy5fYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSYmKGk9ITEpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFMpKXRocm93IHQ7cj1uZXcgZygwLDApLGk9ITF9aT90aGlzLl9zZWdMaXN0LmFkZFB0KHIpOnRoaXMuYWRkTGltaXRlZE1pdHJlSm9pbihlLG4scyx0aGlzLl9idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKX1hZGRPdXRzaWRlVHVybih0LGUpe2lmKHRoaXMuX29mZnNldDAucDEuZGlzdGFuY2UodGhpcy5fb2Zmc2V0MS5wMCk8dGhpcy5fZGlzdGFuY2UqaWkuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1IpcmV0dXJuIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksbnVsbDt0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1qcy5KT0lOX01JVFJFP3RoaXMuYWRkTWl0cmVKb2luKHRoaXMuX3MxLHRoaXMuX29mZnNldDAsdGhpcy5fb2Zmc2V0MSx0aGlzLl9kaXN0YW5jZSk6dGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09anMuSk9JTl9CRVZFTD90aGlzLmFkZEJldmVsSm9pbih0aGlzLl9vZmZzZXQwLHRoaXMuX29mZnNldDEpOihlJiZ0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLHRoaXMuYWRkQ29ybmVyRmlsbGV0KHRoaXMuX3MxLHRoaXMuX29mZnNldDAucDEsdGhpcy5fb2Zmc2V0MS5wMCx0LHRoaXMuX2Rpc3RhbmNlKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApKX1jcmVhdGVTcXVhcmUodCl7dGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgZyh0LngrdGhpcy5fZGlzdGFuY2UsdC55K3RoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgZyh0LngrdGhpcy5fZGlzdGFuY2UsdC55LXRoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgZyh0LngtdGhpcy5fZGlzdGFuY2UsdC55LXRoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgZyh0LngtdGhpcy5fZGlzdGFuY2UsdC55K3RoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKX1hZGRTZWdtZW50cyh0LGUpe3RoaXMuX3NlZ0xpc3QuYWRkUHRzKHQsZSl9YWRkRmlyc3RTZWdtZW50KCl7dGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKX1hZGRDb3JuZXJGaWxsZXQodCxlLG4scyxpKXtjb25zdCByPWUueC10Lngsbz1lLnktdC55O2xldCBsPU1hdGguYXRhbjIobyxyKTtjb25zdCBhPW4ueC10LngsYz1uLnktdC55LGg9TWF0aC5hdGFuMihjLGEpO3M9PT12LkNMT0NLV0lTRT9sPD1oJiYobCs9MipNYXRoLlBJKTpsPj1oJiYobC09MipNYXRoLlBJKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGUpLHRoaXMuYWRkRGlyZWN0ZWRGaWxsZXQodCxsLGgscyxpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG4pfWFkZExhc3RTZWdtZW50KCl7dGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAxKX1pbml0U2lkZVNlZ21lbnRzKHQsZSxuKXt0aGlzLl9zMT10LHRoaXMuX3MyPWUsdGhpcy5fc2lkZT1uLHRoaXMuX3NlZzEuc2V0Q29vcmRpbmF0ZXModCxlKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzEsbix0aGlzLl9kaXN0YW5jZSx0aGlzLl9vZmZzZXQxKX1hZGRMaW1pdGVkTWl0cmVKb2luKHQsZSxuLHMpe2NvbnN0IGk9dGhpcy5fc2VnMC5wMSxyPWllLmFuZ2xlKGksdGhpcy5fc2VnMC5wMCksbz0oaWUuYW5nbGUoaSx0aGlzLl9zZWcxLnAxKSxpZS5hbmdsZUJldHdlZW5PcmllbnRlZCh0aGlzLl9zZWcwLnAwLGksdGhpcy5fc2VnMS5wMSkvMiksbD1pZS5ub3JtYWxpemUocitvKSxhPWllLm5vcm1hbGl6ZShsK01hdGguUEkpLGM9cypuLGg9bi1jKk1hdGguYWJzKE1hdGguc2luKG8pKSx1PWkueCtjKk1hdGguY29zKGEpLGQ9aS55K2MqTWF0aC5zaW4oYSksXz1uZXcgZyh1LGQpLGY9bmV3IGVlKGksXykscD1mLnBvaW50QWxvbmdPZmZzZXQoMSxoKSxtPWYucG9pbnRBbG9uZ09mZnNldCgxLC1oKTt0aGlzLl9zaWRlPT09UG4uTEVGVD8odGhpcy5fc2VnTGlzdC5hZGRQdChwKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG0pKToodGhpcy5fc2VnTGlzdC5hZGRQdChtKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHApKX1hZGREaXJlY3RlZEZpbGxldCh0LGUsbixzLGkpe2NvbnN0IHI9cz09PXYuQ0xPQ0tXSVNFPy0xOjEsbz1NYXRoLmFicyhlLW4pLGw9TWF0aC50cnVuYyhvL3RoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bSsuNSk7aWYobDwxKXJldHVybiBudWxsO2xldCBhPW51bGwsYz1udWxsO2E9MCxjPW8vbDtsZXQgaD0wO2NvbnN0IHU9bmV3IGc7Zm9yKDtoPG87KXtjb25zdCBuPWUrcipoO3UueD10LngraSpNYXRoLmNvcyhuKSx1Lnk9dC55K2kqTWF0aC5zaW4obiksdGhpcy5fc2VnTGlzdC5hZGRQdCh1KSxoKz1jfX1jb21wdXRlT2Zmc2V0U2VnbWVudCh0LGUsbixzKXtjb25zdCBpPWU9PT1Qbi5MRUZUPzE6LTEscj10LnAxLngtdC5wMC54LG89dC5wMS55LXQucDAueSxsPU1hdGguc3FydChyKnIrbypvKSxhPWkqbipyL2wsYz1pKm4qby9sO3MucDAueD10LnAwLngtYyxzLnAwLnk9dC5wMC55K2Escy5wMS54PXQucDEueC1jLHMucDEueT10LnAxLnkrYX1hZGRJbnNpZGVUdXJuKHQsZSl7aWYodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLl9vZmZzZXQwLnAwLHRoaXMuX29mZnNldDAucDEsdGhpcy5fb2Zmc2V0MS5wMCx0aGlzLl9vZmZzZXQxLnAxKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSl0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKSk7ZWxzZSBpZih0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITAsdGhpcy5fb2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLl9vZmZzZXQxLnAwKTx0aGlzLl9kaXN0YW5jZSppaS5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTtlbHNle2lmKHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksdGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj4wKXtjb25zdCB0PW5ldyBnKCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDAucDEueCt0aGlzLl9zMS54KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQwLnAxLnkrdGhpcy5fczEueSkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQodCk7Y29uc3QgZT1uZXcgZygodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQxLnAwLngrdGhpcy5fczEueCkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSksKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MS5wMC55K3RoaXMuX3MxLnkpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLl9zZWdMaXN0LmFkZFB0KGUpfWVsc2UgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9zMSk7dGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKX19Y3JlYXRlQ2lyY2xlKHQpe2NvbnN0IGU9bmV3IGcodC54K3RoaXMuX2Rpc3RhbmNlLHQueSk7dGhpcy5fc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZERpcmVjdGVkRmlsbGV0KHQsMCwyKk1hdGguUEksLTEsdGhpcy5fZGlzdGFuY2UpLHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCl9YWRkQmV2ZWxKb2luKHQsZSl7dGhpcy5fc2VnTGlzdC5hZGRQdCh0LnAxKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGUucDApfWluaXQodCl7dGhpcy5fZGlzdGFuY2U9dCx0aGlzLl9tYXhDdXJ2ZVNlZ21lbnRFcnJvcj10KigxLU1hdGguY29zKHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bS8yKSksdGhpcy5fc2VnTGlzdD1uZXcgc2ksdGhpcy5fc2VnTGlzdC5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLl9wcmVjaXNpb25Nb2RlbCksdGhpcy5fc2VnTGlzdC5zZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UodCppaS5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpfWFkZENvbGxpbmVhcih0KXt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuX3MwLHRoaXMuX3MxLHRoaXMuX3MxLHRoaXMuX3MyKSx0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKT49MiYmKHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWpzLkpPSU5fQkVWRUx8fHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWpzLkpPSU5fTUlUUkU/KHQmJnRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKSk6dGhpcy5hZGRDb3JuZXJGaWxsZXQodGhpcy5fczEsdGhpcy5fb2Zmc2V0MC5wMSx0aGlzLl9vZmZzZXQxLnAwLHYuQ0xPQ0tXSVNFLHRoaXMuX2Rpc3RhbmNlKSl9Y2xvc2VSaW5nKCl7dGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKX1oYXNOYXJyb3dDb25jYXZlQW5nbGUoKXtyZXR1cm4gdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlfWdldENsYXNzKCl7cmV0dXJuIGlpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1paS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9tYXhDdXJ2ZVNlZ21lbnRFcnJvcj0wLHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bT1udWxsLHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3I9MSx0aGlzLl9zZWdMaXN0PW51bGwsdGhpcy5fZGlzdGFuY2U9MCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2J1ZlBhcmFtcz1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5fczA9bnVsbCx0aGlzLl9zMT1udWxsLHRoaXMuX3MyPW51bGwsdGhpcy5fc2VnMD1uZXcgZWUsdGhpcy5fc2VnMT1uZXcgZWUsdGhpcy5fb2Zmc2V0MD1uZXcgZWUsdGhpcy5fb2Zmc2V0MT1uZXcgZWUsdGhpcy5fc2lkZT0wLHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wcmVjaXNpb25Nb2RlbD10LHRoaXMuX2J1ZlBhcmFtcz1lLHRoaXMuX2xpPW5ldyB0ZSx0aGlzLl9maWxsZXRBbmdsZVF1YW50dW09TWF0aC5QSS8yL2UuZ2V0UXVhZHJhbnRTZWdtZW50cygpLGUuZ2V0UXVhZHJhbnRTZWdtZW50cygpPj04JiZlLmdldEpvaW5TdHlsZSgpPT09anMuSk9JTl9ST1VORCYmKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3I9aWkuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1IpLHRoaXMuaW5pdChuKX0saWkuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1I9LjAwMSxpaS5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1I9LjAwMSxpaS5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1I9MWUtNixpaS5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUj04MDtjbGFzcyByaXtjb25zdHJ1Y3Rvcigpe3JpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvcHlDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPW5ldyBnKHRbbl0pO3JldHVybiBlfWdldE9mZnNldEN1cnZlKHQsZSl7aWYodGhpcy5fZGlzdGFuY2U9ZSwwPT09ZSlyZXR1cm4gbnVsbDtjb25zdCBuPWU8MCxzPU1hdGguYWJzKGUpLGk9dGhpcy5nZXRTZWdHZW4ocyk7dC5sZW5ndGg8PTE/dGhpcy5jb21wdXRlUG9pbnRDdXJ2ZSh0WzBdLGkpOnRoaXMuY29tcHV0ZU9mZnNldEN1cnZlKHQsbixpKTtjb25zdCByPWkuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gbiYmWC5yZXZlcnNlKHIpLHJ9Y29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxlLG4pe2NvbnN0IHM9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7aWYoZSl7bi5hZGRTZWdtZW50cyh0LCEwKTtjb25zdCBlPW5pLnNpbXBsaWZ5KHQsLXMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVtpXSxlW2ktMV0sUG4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9aS0yO3Q+PTA7dC0tKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9ZWxzZXtuLmFkZFNlZ21lbnRzKHQsITEpO2NvbnN0IGU9bmkuc2ltcGxpZnkodCxzKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbMF0sZVsxXSxQbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9bi5hZGRMYXN0U2VnbWVudCgpLG4uY2xvc2VSaW5nKCl9Y29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZSh0LGUsbil7bGV0IHM9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7ZT09PVBuLlJJR0hUJiYocz0tcyk7Y29uc3QgaT1uaS5zaW1wbGlmeSh0LHMpLHI9aS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoaVtyLTFdLGlbMF0sZSk7Zm9yKGxldCB0PTE7dDw9cjt0Kyspe2NvbnN0IGU9MSE9PXQ7bi5hZGROZXh0U2VnbWVudChpW3RdLGUpfW4uY2xvc2VSaW5nKCl9Y29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSh0LGUpe2NvbnN0IG49dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSkscz1uaS5zaW1wbGlmeSh0LG4pLGk9cy5sZW5ndGgtMTtlLmluaXRTaWRlU2VnbWVudHMoc1swXSxzWzFdLFBuLkxFRlQpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKWUuYWRkTmV4dFNlZ21lbnQoc1t0XSwhMCk7ZS5hZGRMYXN0U2VnbWVudCgpLGUuYWRkTGluZUVuZENhcChzW2ktMV0sc1tpXSk7Y29uc3Qgcj1uaS5zaW1wbGlmeSh0LC1uKSxvPXIubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKHJbb10scltvLTFdLFBuLkxFRlQpO2ZvcihsZXQgdD1vLTI7dD49MDt0LS0pZS5hZGROZXh0U2VnbWVudChyW3RdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKHJbMV0sclswXSksZS5jbG9zZVJpbmcoKX1jb21wdXRlUG9pbnRDdXJ2ZSh0LGUpe3N3aXRjaCh0aGlzLl9idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBqcy5DQVBfUk9VTkQ6ZS5jcmVhdGVDaXJjbGUodCk7YnJlYWs7Y2FzZSBqcy5DQVBfU1FVQVJFOmUuY3JlYXRlU3F1YXJlKHQpfX1nZXRMaW5lQ3VydmUodCxlKXtpZih0aGlzLl9kaXN0YW5jZT1lLGU8MCYmIXRoaXMuX2J1ZlBhcmFtcy5pc1NpbmdsZVNpZGVkKCkpcmV0dXJuIG51bGw7aWYoMD09PWUpcmV0dXJuIG51bGw7Y29uc3Qgbj1NYXRoLmFicyhlKSxzPXRoaXMuZ2V0U2VnR2VuKG4pO2lmKHQubGVuZ3RoPD0xKXRoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxzKTtlbHNlIGlmKHRoaXMuX2J1ZlBhcmFtcy5pc1NpbmdsZVNpZGVkKCkpe2NvbnN0IG49ZTwwO3RoaXMuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxuLHMpfWVsc2UgdGhpcy5jb21wdXRlTGluZUJ1ZmZlckN1cnZlKHQscyk7cmV0dXJuIHMuZ2V0Q29vcmRpbmF0ZXMoKX1nZXRCdWZmZXJQYXJhbWV0ZXJzKCl7cmV0dXJuIHRoaXMuX2J1ZlBhcmFtc31zaW1wbGlmeVRvbGVyYW5jZSh0KXtyZXR1cm4gdCp0aGlzLl9idWZQYXJhbXMuZ2V0U2ltcGxpZnlGYWN0b3IoKX1nZXRSaW5nQ3VydmUodCxlLG4pe2lmKHRoaXMuX2Rpc3RhbmNlPW4sdC5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuZ2V0TGluZUN1cnZlKHQsbik7aWYoMD09PW4pcmV0dXJuIHJpLmNvcHlDb29yZGluYXRlcyh0KTtjb25zdCBzPXRoaXMuZ2V0U2VnR2VuKG4pO3JldHVybiB0aGlzLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLHMpLHMuZ2V0Q29vcmRpbmF0ZXMoKX1jb21wdXRlT2Zmc2V0Q3VydmUodCxlLG4pe2NvbnN0IHM9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7aWYoZSl7Y29uc3QgZT1uaS5zaW1wbGlmeSh0LC1zKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbaV0sZVtpLTFdLFBuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PWktMjt0Pj0wO3QtLSluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfWVsc2V7Y29uc3QgZT1uaS5zaW1wbGlmeSh0LHMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVswXSxlWzFdLFBuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PTI7dDw9aTt0Kyspbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1uLmFkZExhc3RTZWdtZW50KCl9Z2V0U2VnR2VuKHQpe3JldHVybiBuZXcgaWkodGhpcy5fcHJlY2lzaW9uTW9kZWwsdGhpcy5fYnVmUGFyYW1zLHQpfWdldENsYXNzKCl7cmV0dXJuIHJpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1yaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9kaXN0YW5jZT0wLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYnVmUGFyYW1zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9idWZQYXJhbXM9ZX07Y2xhc3Mgb2l7Y29uc3RydWN0b3IoKXtvaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmRTdGFiYmVkU2VnbWVudHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgeDtmb3IobGV0IG49dGhpcy5fc3ViZ3JhcGhzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLGk9cy5nZXRFbnZlbG9wZSgpO3QueTxpLmdldE1pblkoKXx8dC55PmkuZ2V0TWF4WSgpfHx0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCxzLmdldERpcmVjdGVkRWRnZXMoKSxlKX1yZXR1cm4gZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihfKGFyZ3VtZW50c1syXSxtKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGpuKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBpPTA7aTxzLmxlbmd0aC0xO2krKyl7aWYodGhpcy5fc2VnLnAwPXNbaV0sdGhpcy5fc2VnLnAxPXNbaSsxXSx0aGlzLl9zZWcucDAueT50aGlzLl9zZWcucDEueSYmdGhpcy5fc2VnLnJldmVyc2UoKSxNYXRoLm1heCh0aGlzLl9zZWcucDAueCx0aGlzLl9zZWcucDEueCk8dC54KWNvbnRpbnVlO2lmKHRoaXMuX3NlZy5pc0hvcml6b250YWwoKSljb250aW51ZTtpZih0Lnk8dGhpcy5fc2VnLnAwLnl8fHQueT50aGlzLl9zZWcucDEueSljb250aW51ZTtpZih2LmluZGV4KHRoaXMuX3NlZy5wMCx0aGlzLl9zZWcucDEsdCk9PT12LlJJR0hUKWNvbnRpbnVlO2xldCByPWUuZ2V0RGVwdGgoUG4uTEVGVCk7dGhpcy5fc2VnLnAwLmVxdWFscyhzW2ldKXx8KHI9ZS5nZXREZXB0aChQbi5SSUdIVCkpO2NvbnN0IG89bmV3IGxpKHRoaXMuX3NlZyxyKTtuLmFkZChvKX19ZWxzZSBpZihfKGFyZ3VtZW50c1syXSxtKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZfKGFyZ3VtZW50c1sxXSxtKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07Zm9yKGxldCBzPWUuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGU9cy5uZXh0KCk7ZS5pc0ZvcndhcmQoKSYmdGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQsZSxuKX19fWdldERlcHRoKHQpe2NvbnN0IGU9dGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQpO3JldHVybiAwPT09ZS5zaXplKCk/MDpFZS5taW4oZSkuX2xlZnREZXB0aH1nZXRDbGFzcygpe3JldHVybiBvaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgbGl7Y29uc3RydWN0b3IoKXtsaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7aWYodGhpcy5fdXB3YXJkU2VnLm1pblgoKT49ZS5fdXB3YXJkU2VnLm1heFgoKSlyZXR1cm4gMTtpZih0aGlzLl91cHdhcmRTZWcubWF4WCgpPD1lLl91cHdhcmRTZWcubWluWCgpKXJldHVybi0xO2xldCBuPXRoaXMuX3Vwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KGUuX3Vwd2FyZFNlZyk7cmV0dXJuIDAhPT1uP246KG49LTEqZS5fdXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgodGhpcy5fdXB3YXJkU2VnKSwwIT09bj9uOnRoaXMuX3Vwd2FyZFNlZy5jb21wYXJlVG8oZS5fdXB3YXJkU2VnKSl9Y29tcGFyZVgodCxlKXtjb25zdCBuPXQucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnQucDEuY29tcGFyZVRvKGUucDEpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuX3Vwd2FyZFNlZy50b1N0cmluZygpfWdldENsYXNzKCl7cmV0dXJuIGxpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19bGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdXB3YXJkU2VnPW51bGwsdGhpcy5fbGVmdERlcHRoPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fdXB3YXJkU2VnPW5ldyBlZSh0KSx0aGlzLl9sZWZ0RGVwdGg9ZX0sb2kuRGVwdGhTZWdtZW50PWxpLG9pLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3N1YmdyYXBocz1udWxsLHRoaXMuX3NlZz1uZXcgZWU7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3ViZ3JhcGhzPXR9O2NsYXNzIGFpe2NvbnN0cnVjdG9yKCl7YWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGRQb2ludCh0KXtpZih0aGlzLl9kaXN0YW5jZTw9MClyZXR1cm4gbnVsbDtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKSxuPXRoaXMuX2N1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLl9kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZShuLG5lLkVYVEVSSU9SLG5lLklOVEVSSU9SKX1hZGRQb2x5Z29uKHQpe2xldCBlPXRoaXMuX2Rpc3RhbmNlLG49UG4uTEVGVDt0aGlzLl9kaXN0YW5jZTwwJiYoZT0tdGhpcy5fZGlzdGFuY2Usbj1Qbi5SSUdIVCk7Y29uc3Qgcz10LmdldEV4dGVyaW9yUmluZygpLGk9WC5yZW1vdmVSZXBlYXRlZFBvaW50cyhzLmdldENvb3JkaW5hdGVzKCkpO2lmKHRoaXMuX2Rpc3RhbmNlPDAmJnRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KHMsdGhpcy5fZGlzdGFuY2UpKXJldHVybiBudWxsO2lmKHRoaXMuX2Rpc3RhbmNlPD0wJiZpLmxlbmd0aDwzKXJldHVybiBudWxsO3RoaXMuYWRkUG9seWdvblJpbmcoaSxlLG4sbmUuRVhURVJJT1IsbmUuSU5URVJJT1IpO2ZvcihsZXQgcz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe2NvbnN0IGk9dC5nZXRJbnRlcmlvclJpbmdOKHMpLHI9WC5yZW1vdmVSZXBlYXRlZFBvaW50cyhpLmdldENvb3JkaW5hdGVzKCkpO3RoaXMuX2Rpc3RhbmNlPjAmJnRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KGksLXRoaXMuX2Rpc3RhbmNlKXx8dGhpcy5hZGRQb2x5Z29uUmluZyhyLGUsUG4ub3Bwb3NpdGUobiksbmUuSU5URVJJT1IsbmUuRVhURVJJT1IpfX1pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseSh0LGUpe2NvbnN0IG49bmV3IHJlKHRbMF0sdFsxXSx0WzJdKSxzPW4uaW5DZW50cmUoKTtyZXR1cm4gRC5wb2ludFRvU2VnbWVudChzLG4ucDAsbi5wMSk8TWF0aC5hYnMoZSl9YWRkTGluZVN0cmluZyh0KXtpZih0aGlzLl9kaXN0YW5jZTw9MCYmIXRoaXMuX2N1cnZlQnVpbGRlci5nZXRCdWZmZXJQYXJhbWV0ZXJzKCkuaXNTaW5nbGVTaWRlZCgpKXJldHVybiBudWxsO2NvbnN0IGU9WC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpLG49dGhpcy5fY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShlLHRoaXMuX2Rpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKG4sbmUuRVhURVJJT1IsbmUuSU5URVJJT1IpfWFkZEN1cnZlKHQsZSxuKXtpZihudWxsPT09dHx8dC5sZW5ndGg8MilyZXR1cm4gbnVsbDtjb25zdCBzPW5ldyBGcyh0LG5ldyBGbigwLG5lLkJPVU5EQVJZLGUsbikpO3RoaXMuX2N1cnZlTGlzdC5hZGQocyl9Z2V0Q3VydmVzKCl7cmV0dXJuIHRoaXMuYWRkKHRoaXMuX2lucHV0R2VvbSksdGhpcy5fY3VydmVMaXN0fWFkZFBvbHlnb25SaW5nKHQsZSxuLHMsaSl7aWYoMD09PWUmJnQubGVuZ3RoPER0Lk1JTklNVU1fVkFMSURfU0laRSlyZXR1cm4gbnVsbDtsZXQgcj1zLG89aTt0Lmxlbmd0aD49RHQuTUlOSU1VTV9WQUxJRF9TSVpFJiZ2LmlzQ0NXKHQpJiYocj1pLG89cyxuPVBuLm9wcG9zaXRlKG4pKTtjb25zdCBsPXRoaXMuX2N1cnZlQnVpbGRlci5nZXRSaW5nQ3VydmUodCxuLGUpO3RoaXMuYWRkQ3VydmUobCxyLG8pfWFkZCh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgYnQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBQdCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIE10KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgX3QpKXRocm93IG5ldyBaKHQuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19aXNFcm9kZWRDb21wbGV0ZWx5KHQsZSl7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCk7aWYobi5sZW5ndGg8NClyZXR1cm4gZTwwO2lmKDQ9PT1uLmxlbmd0aClyZXR1cm4gdGhpcy5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseShuLGUpO2NvbnN0IHM9dC5nZXRFbnZlbG9wZUludGVybmFsKCksaT1NYXRoLm1pbihzLmdldEhlaWdodCgpLHMuZ2V0V2lkdGgoKSk7cmV0dXJuIGU8MCYmMipNYXRoLmFicyhlKT5pfWFkZENvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fWdldENsYXNzKCl7cmV0dXJuIGFpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1haS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuX2N1cnZlQnVpbGRlcj1udWxsLHRoaXMuX2N1cnZlTGlzdD1uZXcgeDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9pbnB1dEdlb209dCx0aGlzLl9kaXN0YW5jZT1lLHRoaXMuX2N1cnZlQnVpbGRlcj1ufTtjbGFzcyBjaXtjb25zdHJ1Y3Rvcigpe2NpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TmV4dENXKHQpe3RoaXMuZ2V0RWRnZXMoKTtjb25zdCBlPXRoaXMuX2VkZ2VMaXN0LmluZGV4T2YodCk7bGV0IG49ZS0xO3JldHVybiAwPT09ZSYmKG49dGhpcy5fZWRnZUxpc3Quc2l6ZSgpLTEpLHRoaXMuX2VkZ2VMaXN0LmdldChuKX1wcm9wYWdhdGVTaWRlTGFiZWxzKHQpe2xldCBlPW5lLk5PTkU7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCkuZ2V0TGFiZWwoKTtzLmlzQXJlYSh0KSYmcy5nZXRMb2NhdGlvbih0LFBuLkxFRlQpIT09bmUuTk9ORSYmKGU9cy5nZXRMb2NhdGlvbih0LFBuLkxFRlQpKX1pZihlPT09bmUuTk9ORSlyZXR1cm4gbnVsbDtsZXQgbj1lO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpLGk9cy5nZXRMYWJlbCgpO2lmKGkuZ2V0TG9jYXRpb24odCxQbi5PTik9PT1uZS5OT05FJiZpLnNldExvY2F0aW9uKHQsUG4uT04sbiksaS5pc0FyZWEodCkpe2NvbnN0IGU9aS5nZXRMb2NhdGlvbih0LFBuLkxFRlQpLHI9aS5nZXRMb2NhdGlvbih0LFBuLlJJR0hUKTtpZihyIT09bmUuTk9ORSl7aWYociE9PW4pdGhyb3cgbmV3IFduKFwic2lkZSBsb2NhdGlvbiBjb25mbGljdFwiLHMuZ2V0Q29vcmRpbmF0ZSgpKTtlPT09bmUuTk9ORSYmdS5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHNpbmdsZSBudWxsIHNpZGUgKGF0IFwiK3MuZ2V0Q29vcmRpbmF0ZSgpK1wiKVwiKSxuPWV9ZWxzZSB1LmlzVHJ1ZShpLmdldExvY2F0aW9uKHQsUG4uTEVGVCk9PT1uZS5OT05FLFwiZm91bmQgc2luZ2xlIG51bGwgc2lkZVwiKSxpLnNldExvY2F0aW9uKHQsUG4uUklHSFQsbiksaS5zZXRMb2NhdGlvbih0LFBuLkxFRlQsbil9fX1nZXRDb29yZGluYXRlKCl7Y29uc3QgdD10aGlzLml0ZXJhdG9yKCk7cmV0dXJuIHQuaGFzTmV4dCgpP3QubmV4dCgpLmdldENvb3JkaW5hdGUoKTpudWxsfXByaW50KHQpe08ub3V0LnByaW50bG4oXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1pc0FyZWFMYWJlbHNDb25zaXN0ZW50KHQpe3JldHVybiB0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKHQuZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKSx0aGlzLmNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQoMCl9Y2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCh0KXtjb25zdCBlPXRoaXMuZ2V0RWRnZXMoKTtpZihlLnNpemUoKTw9MClyZXR1cm4hMDtjb25zdCBuPWUuc2l6ZSgpLTEscz1lLmdldChuKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQsUG4uTEVGVCk7dS5pc1RydWUocyE9PW5lLk5PTkUsXCJGb3VuZCB1bmxhYmVsbGVkIGFyZWEgZWRnZVwiKTtsZXQgaT1zO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldExhYmVsKCk7dS5pc1RydWUobi5pc0FyZWEodCksXCJGb3VuZCBub24tYXJlYSBlZGdlXCIpO2NvbnN0IHM9bi5nZXRMb2NhdGlvbih0LFBuLkxFRlQpLHI9bi5nZXRMb2NhdGlvbih0LFBuLlJJR0hUKTtpZihzPT09cilyZXR1cm4hMTtpZihyIT09aSlyZXR1cm4hMTtpPXN9cmV0dXJuITB9ZmluZEluZGV4KHQpe3RoaXMuaXRlcmF0b3IoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VMaXN0LnNpemUoKTtlKyspe2lmKHRoaXMuX2VkZ2VMaXN0LmdldChlKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5nZXRFZGdlcygpLml0ZXJhdG9yKCl9Z2V0RWRnZXMoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2VkZ2VMaXN0JiYodGhpcy5fZWRnZUxpc3Q9bmV3IHgodGhpcy5fZWRnZU1hcC52YWx1ZXMoKSkpLHRoaXMuX2VkZ2VMaXN0fWdldExvY2F0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5fcHRJbkFyZWFMb2NhdGlvblt0XT09PW5lLk5PTkUmJih0aGlzLl9wdEluQXJlYUxvY2F0aW9uW3RdPVplLmxvY2F0ZShlLG5bdF0uZ2V0R2VvbWV0cnkoKSkpLHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bdF19dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB3O3QuYXBwZW5kKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpLHQuYXBwZW5kKFwiXFxuXCIpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3QuYXBwZW5kKG4pLHQuYXBwZW5kKFwiXFxuXCIpfXJldHVybiB0LnRvU3RyaW5nKCl9Y29tcHV0ZUVkZ2VFbmRMYWJlbHModCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmNvbXB1dGVMYWJlbCh0KX19Y29tcHV0ZUxhYmVsbGluZyh0KXt0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKHRbMF0uZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKSx0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMCksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDEpO2NvbnN0IGU9WyExLCExXTtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKS5nZXRMYWJlbCgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspbi5pc0xpbmUodCkmJm4uZ2V0TG9jYXRpb24odCk9PT1uZS5CT1VOREFSWSYmKGVbdF09ITApfWZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLGk9cy5nZXRMYWJlbCgpO2ZvcihsZXQgbj0wO248MjtuKyspaWYoaS5pc0FueU51bGwobikpe2xldCByPW5lLk5PTkU7aWYoZVtuXSlyPW5lLkVYVEVSSU9SO2Vsc2V7Y29uc3QgZT1zLmdldENvb3JkaW5hdGUoKTtyPXRoaXMuZ2V0TG9jYXRpb24obixlLHQpfWkuc2V0QWxsTG9jYXRpb25zSWZOdWxsKG4scil9fX1nZXREZWdyZWUoKXtyZXR1cm4gdGhpcy5fZWRnZU1hcC5zaXplKCl9aW5zZXJ0RWRnZUVuZCh0LGUpe3RoaXMuX2VkZ2VNYXAucHV0KHQsZSksdGhpcy5fZWRnZUxpc3Q9bnVsbH1nZXRDbGFzcygpe3JldHVybiBjaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZWRnZU1hcD1uZXcgcnQsdGhpcy5fZWRnZUxpc3Q9bnVsbCx0aGlzLl9wdEluQXJlYUxvY2F0aW9uPVtuZS5OT05FLG5lLk5PTkVdfTtjbGFzcyBoaSBleHRlbmRzIGNpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxoaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl7dGhpcy5nZXRSZXN1bHRBcmVhRWRnZXMoKTtsZXQgdD1udWxsLGU9bnVsbCxuPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztmb3IobGV0IHM9MDtzPHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCk7cysrKXtjb25zdCBpPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5nZXQocykscj1pLmdldFN5bSgpO2lmKGkuZ2V0TGFiZWwoKS5pc0FyZWEoKSlzd2l0Y2gobnVsbD09PXQmJmkuaXNJblJlc3VsdCgpJiYodD1pKSxuKXtjYXNlIHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORzppZighci5pc0luUmVzdWx0KCkpY29udGludWU7ZT1yLG49dGhpcy5fTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc6aWYoIWkuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2Uuc2V0TmV4dChpKSxuPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlOR319aWYobj09PXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcpe2lmKG51bGw9PT10KXRocm93IG5ldyBXbihcIm5vIG91dGdvaW5nIGRpckVkZ2UgZm91bmRcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7dS5pc1RydWUodC5pc0luUmVzdWx0KCksXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksZS5zZXROZXh0KHQpfX1pbnNlcnQodCl7Y29uc3QgZT10O3RoaXMuaW5zZXJ0RWRnZUVuZChlLGUpfWdldFJpZ2h0bW9zdEVkZ2UoKXtjb25zdCB0PXRoaXMuZ2V0RWRnZXMoKSxlPXQuc2l6ZSgpO2lmKGU8MSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0KDApO2lmKDE9PT1lKXJldHVybiBuO2NvbnN0IHM9dC5nZXQoZS0xKSxpPW4uZ2V0UXVhZHJhbnQoKSxyPXMuZ2V0UXVhZHJhbnQoKTtyZXR1cm4gSW4uaXNOb3J0aGVybihpKSYmSW4uaXNOb3J0aGVybihyKT9uOkluLmlzTm9ydGhlcm4oaSl8fEluLmlzTm9ydGhlcm4ocik/MCE9PW4uZ2V0RHkoKT9uOjAhPT1zLmdldER5KCk/czoodS5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHR3byBob3Jpem9udGFsIGVkZ2VzIGluY2lkZW50IG9uIG5vZGVcIiksbnVsbCk6c31wcmludCh0KXtPLm91dC5wcmludGxuKFwiRGlyZWN0ZWRFZGdlU3RhcjogXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3QucHJpbnQoXCJvdXQgXCIpLG4ucHJpbnQodCksdC5wcmludGxuKCksdC5wcmludChcImluIFwiKSxuLmdldFN5bSgpLnByaW50KHQpLHQucHJpbnRsbigpfX1nZXRSZXN1bHRBcmVhRWRnZXMoKXtpZihudWxsIT09dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0KXJldHVybiB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Q7dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0PW5ldyB4O2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpOyhlLmlzSW5SZXN1bHQoKXx8ZS5nZXRTeW0oKS5pc0luUmVzdWx0KCkpJiZ0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QuYWRkKGUpfXJldHVybiB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3R9dXBkYXRlTGFiZWxsaW5nKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldExhYmVsKCk7bi5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0LmdldExvY2F0aW9uKDApKSxuLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQuZ2V0TG9jYXRpb24oMSkpfX1saW5rQWxsRGlyZWN0ZWRFZGdlcygpe3RoaXMuZ2V0RWRnZXMoKTtsZXQgdD1udWxsLGU9bnVsbDtmb3IobGV0IG49dGhpcy5fZWRnZUxpc3Quc2l6ZSgpLTE7bj49MDtuLS0pe2NvbnN0IHM9dGhpcy5fZWRnZUxpc3QuZ2V0KG4pLGk9cy5nZXRTeW0oKTtudWxsPT09ZSYmKGU9aSksbnVsbCE9PXQmJmkuc2V0TmV4dCh0KSx0PXN9ZS5zZXROZXh0KHQpfWNvbXB1dGVEZXB0aHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLmZpbmRJbmRleCh0KSxuPXQuZ2V0RGVwdGgoUG4uTEVGVCkscz10LmdldERlcHRoKFBuLlJJR0hUKSxpPXRoaXMuY29tcHV0ZURlcHRocyhlKzEsdGhpcy5fZWRnZUxpc3Quc2l6ZSgpLG4pO2lmKHRoaXMuY29tcHV0ZURlcHRocygwLGUsaSkhPT1zKXRocm93IG5ldyBXbihcImRlcHRoIG1pc21hdGNoIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1hcmd1bWVudHNbMl07Zm9yKGxldCBzPXQ7czxlO3MrKyl7Y29uc3QgdD10aGlzLl9lZGdlTGlzdC5nZXQocyk7dC5zZXRFZGdlRGVwdGhzKFBuLlJJR0hULG4pLG49dC5nZXREZXB0aChQbi5MRUZUKX1yZXR1cm4gbn19bWVyZ2VTeW1MYWJlbHMoKXtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtlLmdldExhYmVsKCkubWVyZ2UoZS5nZXRTeW0oKS5nZXRMYWJlbCgpKX19bGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHQpe2xldCBlPW51bGwsbj1udWxsLHM9dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO2ZvcihsZXQgaT10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpLTE7aT49MDtpLS0pe2NvbnN0IHI9dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LmdldChpKSxvPXIuZ2V0U3ltKCk7c3dpdGNoKG51bGw9PT1lJiZyLmdldEVkZ2VSaW5nKCk9PT10JiYoZT1yKSxzKXtjYXNlIHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORzppZihvLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO249byxzPXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc7YnJlYWs7Y2FzZSB0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HOmlmKHIuZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bi5zZXROZXh0TWluKHIpLHM9dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HfX1zPT09dGhpcy5fTElOS0lOR19UT19PVVRHT0lORyYmKHUuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBmb3IgZmlyc3Qgb3V0Z29pbmcgZGlyRWRnZVwiKSx1LmlzVHJ1ZShlLmdldEVkZ2VSaW5nKCk9PT10LFwidW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlXCIpLG4uc2V0TmV4dE1pbihlKSl9Z2V0T3V0Z29pbmdEZWdyZWUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9MDtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuaXNJblJlc3VsdCgpJiZ0Kyt9cmV0dXJuIHR9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPTA7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLmdldEVkZ2VSaW5nKCk9PT10JiZlKyt9cmV0dXJuIGV9fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl7bGV0IHQ9bmUuTk9ORTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0U3ltKCk7aWYoIW4uaXNMaW5lRWRnZSgpKXtpZihuLmlzSW5SZXN1bHQoKSl7dD1uZS5JTlRFUklPUjticmVha31pZihzLmlzSW5SZXN1bHQoKSl7dD1uZS5FWFRFUklPUjticmVha319fWlmKHQ9PT1uZS5OT05FKXJldHVybiBudWxsO2xldCBlPXQ7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkscz1uLmdldFN5bSgpO24uaXNMaW5lRWRnZSgpP24uZ2V0RWRnZSgpLnNldENvdmVyZWQoZT09PW5lLklOVEVSSU9SKToobi5pc0luUmVzdWx0KCkmJihlPW5lLkVYVEVSSU9SKSxzLmlzSW5SZXN1bHQoKSYmKGU9bmUuSU5URVJJT1IpKX19Y29tcHV0ZUxhYmVsbGluZyh0KXtzdXBlci5jb21wdXRlTGFiZWxsaW5nLmNhbGwodGhpcyx0KSx0aGlzLl9sYWJlbD1uZXcgRm4obmUuTk9ORSk7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCkuZ2V0RWRnZSgpLmdldExhYmVsKCk7Zm9yKGxldCB0PTA7dDwyO3QrKyl7Y29uc3Qgbj1lLmdldExvY2F0aW9uKHQpO24hPT1uZS5JTlRFUklPUiYmbiE9PW5lLkJPVU5EQVJZfHx0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LG5lLklOVEVSSU9SKX19fWdldENsYXNzKCl7cmV0dXJuIGhpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1oaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Q9bnVsbCx0aGlzLl9sYWJlbD1udWxsLHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORz0xLHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc9Mn07Y2xhc3MgdWkgZXh0ZW5kcyBLbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVOb2RlKHQpe3JldHVybiBuZXcga24odCxuZXcgaGkpfWdldENsYXNzKCl7cmV0dXJuIHVpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX11aS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGdpe2NvbnN0cnVjdG9yKCl7Z2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb3JpZW50YXRpb24odCl7cmV0dXJuIDE9PT1YLmluY3JlYXNpbmdEaXJlY3Rpb24odCl9c3RhdGljIGNvbXBhcmVPcmllbnRlZCh0LGUsbixzKXtjb25zdCBpPWU/MTotMSxyPXM/MTotMSxvPWU/dC5sZW5ndGg6LTEsbD1zP24ubGVuZ3RoOi0xO2xldCBhPWU/MDp0Lmxlbmd0aC0xLGM9cz8wOm4ubGVuZ3RoLTE7Zm9yKDs7KXtjb25zdCBlPXRbYV0uY29tcGFyZVRvKG5bY10pO2lmKDAhPT1lKXJldHVybiBlO2ErPWksYys9cjtjb25zdCBzPWE9PT1vLGg9Yz09PWw7aWYocyYmIWgpcmV0dXJuLTE7aWYoIXMmJmgpcmV0dXJuIDE7aWYocyYmaClyZXR1cm4gMH19Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gZ2kuY29tcGFyZU9yaWVudGVkKHRoaXMuX3B0cyx0aGlzLl9vcmllbnRhdGlvbixlLl9wdHMsZS5fb3JpZW50YXRpb24pfWdldENsYXNzKCl7cmV0dXJuIGdpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19Z2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fb3JpZW50YXRpb249bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dCx0aGlzLl9vcmllbnRhdGlvbj1naS5vcmllbnRhdGlvbih0KX07Y2xhc3MgZGl7Y29uc3RydWN0b3IoKXtkaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXByaW50KHQpe3QucHJpbnQoXCJNVUxUSUxJTkVTVFJJTkcgKCBcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlcy5zaXplKCk7ZSsrKXtjb25zdCBuPXRoaXMuX2VkZ2VzLmdldChlKTtlPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoXCIoXCIpO2NvbnN0IHM9bi5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0wO2U8cy5sZW5ndGg7ZSsrKWU+MCYmdC5wcmludChcIixcIiksdC5wcmludChzW2VdLngrXCIgXCIrc1tlXS55KTt0LnByaW50bG4oXCIpXCIpfXQucHJpbnQoXCIpICBcIil9YWRkQWxsKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKX1maW5kRWRnZUluZGV4KHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKylpZih0aGlzLl9lZGdlcy5nZXQoZSkuZXF1YWxzKHQpKXJldHVybiBlO3JldHVybi0xfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9Z2V0KHQpe3JldHVybiB0aGlzLl9lZGdlcy5nZXQodCl9ZmluZEVxdWFsRWRnZSh0KXtjb25zdCBlPW5ldyBnaSh0LmdldENvb3JkaW5hdGVzKCkpO3JldHVybiB0aGlzLl9vY2FNYXAuZ2V0KGUpfWFkZCh0KXt0aGlzLl9lZGdlcy5hZGQodCk7Y29uc3QgZT1uZXcgZ2kodC5nZXRDb29yZGluYXRlcygpKTt0aGlzLl9vY2FNYXAucHV0KGUsdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gZGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWRpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2VkZ2VzPW5ldyB4LHRoaXMuX29jYU1hcD1uZXcgcnR9O2NsYXNzIF9pe2NvbnN0cnVjdG9yKCl7X2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1wcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXt9aXNEb25lKCl7fWdldENsYXNzKCl7cmV0dXJuIF9pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1faS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGZpe2NvbnN0cnVjdG9yKCl7ZmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNBZGphY2VudFNlZ21lbnRzKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfWlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXtpZih0PT09biYmMT09PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihmaS5pc0FkamFjZW50U2VnbWVudHMoZSxzKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe2NvbnN0IG49dC5zaXplKCktMTtpZigwPT09ZSYmcz09PW58fDA9PT1zJiZlPT09bilyZXR1cm4hMH19cmV0dXJuITF9Z2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKXtyZXR1cm4gdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnR9aGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3J9Z2V0TGluZUludGVyc2VjdG9yKCl7cmV0dXJuIHRoaXMuX2xpfWhhc1Byb3BlckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJ9cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO3RoaXMubnVtVGVzdHMrKztjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMubnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSYmKHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zKyssdGhpcy5faGFzSW50ZXJpb3I9ITApLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxzLDEpLHRoaXMuX2xpLmlzUHJvcGVyKCkmJih0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnMrKyx0aGlzLl9oYXNQcm9wZXI9ITAsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITApKSl9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4hMX1oYXNJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcmlvcn1nZXRDbGFzcygpe3JldHVybiBmaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bX2ldfX1maS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5faGFzUHJvcGVyPSExLHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSExLHRoaXMuX2hhc0ludGVyaW9yPSExLHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9pc1NlbGZJbnRlcnNlY3Rpb249bnVsbCx0aGlzLm51bUludGVyc2VjdGlvbnM9MCx0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtUHJvcGVySW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtVGVzdHM9MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saT10fTtjbGFzcyBwaXtjb25zdHJ1Y3Rvcigpe3BpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRlcHRoRGVsdGEodCl7Y29uc3QgZT10LmdldExvY2F0aW9uKDAsUG4uTEVGVCksbj10LmdldExvY2F0aW9uKDAsUG4uUklHSFQpO3JldHVybiBlPT09bmUuSU5URVJJT1ImJm49PT1uZS5FWFRFUklPUj8xOmU9PT1uZS5FWFRFUklPUiYmbj09PW5lLklOVEVSSU9SPy0xOjB9c3RhdGljIGNvbnZlcnRTZWdTdHJpbmdzKHQpe2NvbnN0IGU9bmV3IEh0LG49bmV3IHg7Zm9yKDt0Lmhhc05leHQoKTspe2NvbnN0IHM9dC5uZXh0KCksaT1lLmNyZWF0ZUxpbmVTdHJpbmcocy5nZXRDb29yZGluYXRlcygpKTtuLmFkZChpKX1yZXR1cm4gZS5idWlsZEdlb21ldHJ5KG4pfXNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw9dH1pbnNlcnRVbmlxdWVFZGdlKHQpe2NvbnN0IGU9dGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZSh0KTtpZihudWxsIT09ZSl7Y29uc3Qgbj1lLmdldExhYmVsKCk7bGV0IHM9dC5nZXRMYWJlbCgpO2UuaXNQb2ludHdpc2VFcXVhbCh0KXx8KHM9bmV3IEZuKHQuZ2V0TGFiZWwoKSkscy5mbGlwKCkpLG4ubWVyZ2Uocyk7Y29uc3QgaT1waS5kZXB0aERlbHRhKHMpLHI9ZS5nZXREZXB0aERlbHRhKCkraTtlLnNldERlcHRoRGVsdGEocil9ZWxzZSB0aGlzLl9lZGdlTGlzdC5hZGQodCksdC5zZXREZXB0aERlbHRhKHBpLmRlcHRoRGVsdGEodC5nZXRMYWJlbCgpKSl9YnVpbGRTdWJncmFwaHModCxlKXtjb25zdCBuPW5ldyB4O2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9dC5nZXRSaWdodG1vc3RDb29yZGluYXRlKCkscj1uZXcgb2kobikuZ2V0RGVwdGgoaSk7dC5jb21wdXRlRGVwdGgociksdC5maW5kUmVzdWx0RWRnZXMoKSxuLmFkZCh0KSxlLmFkZCh0LmdldERpcmVjdGVkRWRnZXMoKSx0LmdldE5vZGVzKCkpfX1jcmVhdGVTdWJncmFwaHModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5nZXROb2RlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKCF0LmlzVmlzaXRlZCgpKXtjb25zdCBuPW5ldyBRcztuLmNyZWF0ZSh0KSxlLmFkZChuKX19cmV0dXJuIEVlLnNvcnQoZSxFZS5yZXZlcnNlT3JkZXIoKSksZX1jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oKX1nZXROb2Rlcih0KXtpZihudWxsIT09dGhpcy5fd29ya2luZ05vZGVyKXJldHVybiB0aGlzLl93b3JraW5nTm9kZXI7Y29uc3QgZT1uZXcgWXMsbj1uZXcgdGU7cmV0dXJuIG4uc2V0UHJlY2lzaW9uTW9kZWwodCksZS5zZXRTZWdtZW50SW50ZXJzZWN0b3IobmV3IGZpKG4pKSxlfWJ1ZmZlcih0LGUpe2xldCBuPXRoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbDtudWxsPT09biYmKG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKTtjb25zdCBzPW5ldyByaShuLHRoaXMuX2J1ZlBhcmFtcyksaT1uZXcgYWkodCxlLHMpLmdldEN1cnZlcygpO2lmKGkuc2l6ZSgpPD0wKXJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKTt0aGlzLmNvbXB1dGVOb2RlZEVkZ2VzKGksbiksdGhpcy5fZ3JhcGg9bmV3IFpuKG5ldyB1aSksdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSk7Y29uc3Qgcj10aGlzLmNyZWF0ZVN1YmdyYXBocyh0aGlzLl9ncmFwaCksbz1uZXcgZWkodGhpcy5fZ2VvbUZhY3QpO3RoaXMuYnVpbGRTdWJncmFwaHMocixvKTtjb25zdCBsPW8uZ2V0UG9seWdvbnMoKTtyZXR1cm4gbC5zaXplKCk8PTA/dGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk6dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShsKX1jb21wdXRlTm9kZWRFZGdlcyh0LGUpe2NvbnN0IG49dGhpcy5nZXROb2RlcihlKTtuLmNvbXB1dGVOb2Rlcyh0KTtmb3IobGV0IHQ9bi5nZXROb2RlZFN1YnN0cmluZ3MoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKTtpZigyPT09bi5sZW5ndGgmJm5bMF0uZXF1YWxzMkQoblsxXSkpY29udGludWU7Y29uc3Qgcz1lLmdldERhdGEoKSxpPW5ldyBVbihlLmdldENvb3JkaW5hdGVzKCksbmV3IEZuKHMpKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2UoaSl9fXNldE5vZGVyKHQpe3RoaXMuX3dvcmtpbmdOb2Rlcj10fWdldENsYXNzKCl7cmV0dXJuIHBpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1waS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9idWZQYXJhbXM9bnVsbCx0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl93b3JraW5nTm9kZXI9bnVsbCx0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fZWRnZUxpc3Q9bmV3IGRpO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2J1ZlBhcmFtcz10fTtjbGFzcyBtaXtjb25zdHJ1Y3Rvcigpe21pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKS5nZXRDb29yZGluYXRlcygpO3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoZVswXSx0aGlzLl9zZWdTdHJpbmdzKSx0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKGVbZS5sZW5ndGgtMV0sdGhpcy5fc2VnU3RyaW5ncyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPWFyZ3VtZW50c1sxXS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0xO2U8bi5sZW5ndGgtMTtlKyspaWYobltlXS5lcXVhbHModCkpdGhyb3cgbmV3IGMoXCJmb3VuZCBlbmRwdC9pbnRlcmlvciBwdCBpbnRlcnNlY3Rpb24gYXQgaW5kZXggXCIrZStcIiA6cHQgXCIrdCl9fX1jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2ZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO3RoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoZSxuKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldENvb3JkaW5hdGVzKCkscz1lLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBpPTA7aTxuLmxlbmd0aC0xO2krKylmb3IobGV0IG49MDtuPHMubGVuZ3RoLTE7bisrKXRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnModCxpLGUsbil9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTtpZih0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5fbGkuaXNQcm9wZXIoKXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLl9saSxpLHIpfHx0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMuX2xpLG8sbCkpKXRocm93IG5ldyBjKFwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBhdCBcIitpK1wiLVwiK3IrXCIgYW5kIFwiK28rXCItXCIrbCl9fWNoZWNrVmFsaWQoKXt0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpLHRoaXMuY2hlY2tDb2xsYXBzZXMoKX1jaGVja0NvbGxhcHNlcygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuY2hlY2tDb2xsYXBzZXMoZSl9ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTI7ZSsrKXRoaXMuY2hlY2tDb2xsYXBzZSh0W2VdLHRbZSsxXSx0W2UrMl0pfX1oYXNJbnRlcmlvckludGVyc2VjdGlvbih0LGUsbil7Zm9yKGxldCBzPTA7czx0LmdldEludGVyc2VjdGlvbk51bSgpO3MrKyl7Y29uc3QgaT10LmdldEludGVyc2VjdGlvbihzKTtpZighaS5lcXVhbHMoZSkmJiFpLmVxdWFscyhuKSlyZXR1cm4hMH1yZXR1cm4hMX1jaGVja0NvbGxhcHNlKHQsZSxuKXtpZih0LmVxdWFscyhuKSl0aHJvdyBuZXcgYyhcImZvdW5kIG5vbi1ub2RlZCBjb2xsYXBzZSBhdCBcIittaS5mYWN0LmNyZWF0ZUxpbmVTdHJpbmcoW3QsZSxuXSkpfWdldENsYXNzKCl7cmV0dXJuIG1pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1taS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saT1uZXcgdGUsdGhpcy5fc2VnU3RyaW5ncz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NlZ1N0cmluZ3M9dH0sbWkuZmFjdD1uZXcgSHQ7Y2xhc3MgeWl7Y29uc3RydWN0b3IoKXt5aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWludGVyc2VjdHNTY2FsZWQodCxlKXtjb25zdCBuPU1hdGgubWluKHQueCxlLngpLHM9TWF0aC5tYXgodC54LGUueCksaT1NYXRoLm1pbih0LnksZS55KSxyPU1hdGgubWF4KHQueSxlLnkpLG89dGhpcy5fbWF4eDxufHx0aGlzLl9taW54PnN8fHRoaXMuX21heHk8aXx8dGhpcy5fbWlueT5yO2lmKG8pcmV0dXJuITE7Y29uc3QgbD10aGlzLmludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUodCxlKTtyZXR1cm4gdS5pc1RydWUoIShvJiZsKSxcIkZvdW5kIGJhZCBlbnZlbG9wZSB0ZXN0XCIpLGx9aW5pdENvcm5lcnModCl7dGhpcy5fbWlueD10LngtLjUsdGhpcy5fbWF4eD10LngrLjUsdGhpcy5fbWlueT10LnktLjUsdGhpcy5fbWF4eT10LnkrLjUsdGhpcy5fY29ybmVyWzBdPW5ldyBnKHRoaXMuX21heHgsdGhpcy5fbWF4eSksdGhpcy5fY29ybmVyWzFdPW5ldyBnKHRoaXMuX21pbngsdGhpcy5fbWF4eSksdGhpcy5fY29ybmVyWzJdPW5ldyBnKHRoaXMuX21pbngsdGhpcy5fbWlueSksdGhpcy5fY29ybmVyWzNdPW5ldyBnKHRoaXMuX21heHgsdGhpcy5fbWlueSl9aW50ZXJzZWN0cyh0LGUpe3JldHVybiAxPT09dGhpcy5fc2NhbGVGYWN0b3I/dGhpcy5pbnRlcnNlY3RzU2NhbGVkKHQsZSk6KHRoaXMuY29weVNjYWxlZCh0LHRoaXMuX3AwU2NhbGVkKSx0aGlzLmNvcHlTY2FsZWQoZSx0aGlzLl9wMVNjYWxlZCksdGhpcy5pbnRlcnNlY3RzU2NhbGVkKHRoaXMuX3AwU2NhbGVkLHRoaXMuX3AxU2NhbGVkKSl9c2NhbGUodCl7cmV0dXJuIE1hdGgucm91bmQodCp0aGlzLl9zY2FsZUZhY3Rvcil9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9vcmlnaW5hbFB0fWNvcHlTY2FsZWQodCxlKXtlLng9dGhpcy5zY2FsZSh0LngpLGUueT10aGlzLnNjYWxlKHQueSl9Z2V0U2FmZUVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX3NhZmVFbnYpe2NvbnN0IHQ9eWkuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUi90aGlzLl9zY2FsZUZhY3Rvcjt0aGlzLl9zYWZlRW52PW5ldyBOKHRoaXMuX29yaWdpbmFsUHQueC10LHRoaXMuX29yaWdpbmFsUHQueCt0LHRoaXMuX29yaWdpbmFsUHQueS10LHRoaXMuX29yaWdpbmFsUHQueSt0KX1yZXR1cm4gdGhpcy5fc2FmZUVudn1pbnRlcnNlY3RzUGl4ZWxDbG9zdXJlKHQsZSl7cmV0dXJuIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclswXSx0aGlzLl9jb3JuZXJbMV0pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMV0sdGhpcy5fY29ybmVyWzJdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzJdLHRoaXMuX2Nvcm5lclszXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclszXSx0aGlzLl9jb3JuZXJbMF0pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpKSl9aW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSh0LGUpe2xldCBuPSExLHM9ITE7cmV0dXJuIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclswXSx0aGlzLl9jb3JuZXJbMV0pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsxXSx0aGlzLl9jb3JuZXJbMl0pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYobj0hMCksdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzJdLHRoaXMuX2Nvcm5lclszXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJihzPSEwKSx0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbM10sdGhpcy5fY29ybmVyWzBdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCghKCFufHwhcyl8fCghIXQuZXF1YWxzKHRoaXMuX3B0KXx8ISFlLmVxdWFscyh0aGlzLl9wdCkpKSkpKX1hZGRTbmFwcGVkTm9kZSh0LGUpe2NvbnN0IG49dC5nZXRDb29yZGluYXRlKGUpLHM9dC5nZXRDb29yZGluYXRlKGUrMSk7cmV0dXJuISF0aGlzLmludGVyc2VjdHMobixzKSYmKHQuYWRkSW50ZXJzZWN0aW9uKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLGUpLCEwKX1nZXRDbGFzcygpe3JldHVybiB5aX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bnVsbCx0aGlzLl9wdD1udWxsLHRoaXMuX29yaWdpbmFsUHQ9bnVsbCx0aGlzLl9wdFNjYWxlZD1udWxsLHRoaXMuX3AwU2NhbGVkPW51bGwsdGhpcy5fcDFTY2FsZWQ9bnVsbCx0aGlzLl9zY2FsZUZhY3Rvcj1udWxsLHRoaXMuX21pbng9bnVsbCx0aGlzLl9tYXh4PW51bGwsdGhpcy5fbWlueT1udWxsLHRoaXMuX21heHk9bnVsbCx0aGlzLl9jb3JuZXI9bmV3IEFycmF5KDQpLmZpbGwobnVsbCksdGhpcy5fc2FmZUVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO2lmKHRoaXMuX29yaWdpbmFsUHQ9dCx0aGlzLl9wdD10LHRoaXMuX3NjYWxlRmFjdG9yPWUsdGhpcy5fbGk9cyxlPD0wKXRocm93IG5ldyBuKFwiU2NhbGUgZmFjdG9yIG11c3QgYmUgbm9uLXplcm9cIik7MSE9PWUmJih0aGlzLl9wdD1uZXcgZyh0aGlzLnNjYWxlKHQueCksdGhpcy5zY2FsZSh0LnkpKSx0aGlzLl9wMFNjYWxlZD1uZXcgZyx0aGlzLl9wMVNjYWxlZD1uZXcgZyksdGhpcy5pbml0Q29ybmVycyh0aGlzLl9wdCl9LHlpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1I9Ljc1O2NsYXNzIHhpe2NvbnN0cnVjdG9yKCl7eGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZWxlY3QoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dC5nZXRMaW5lU2VnbWVudChlLHRoaXMuc2VsZWN0ZWRTZWdtZW50KSx0aGlzLnNlbGVjdCh0aGlzLnNlbGVjdGVkU2VnbWVudCl9fWdldENsYXNzKCl7cmV0dXJuIHhpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX14aS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLnNlbGVjdGVkU2VnbWVudD1uZXcgZWV9O2NsYXNzIEVpe2NvbnN0cnVjdG9yKCl7RWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zbmFwKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNuYXAodCxudWxsLC0xKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz10LmdldFNhZmVFbnZlbG9wZSgpLGk9bmV3IElpKHQsZSxuKTtyZXR1cm4gdGhpcy5faW5kZXgucXVlcnkocyxuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FlXX12aXNpdEl0ZW0odCl7dC5zZWxlY3QocyxpKX19KSxpLmlzTm9kZUFkZGVkKCl9fWdldENsYXNzKCl7cmV0dXJuIEVpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBJaSBleHRlbmRzIHhpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxJaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzTm9kZUFkZGVkKCl7cmV0dXJuIHRoaXMuX2lzTm9kZUFkZGVkfXNlbGVjdCgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxcykpcmV0dXJuIHN1cGVyLnNlbGVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRDb250ZXh0KCk7aWYobnVsbCE9PXRoaXMuX3BhcmVudEVkZ2UmJm49PT10aGlzLl9wYXJlbnRFZGdlJiZlPT09dGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleClyZXR1cm4gbnVsbDt0aGlzLl9pc05vZGVBZGRlZD10aGlzLl9ob3RQaXhlbC5hZGRTbmFwcGVkTm9kZShuLGUpfX1nZXRDbGFzcygpe3JldHVybiBJaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faG90UGl4ZWw9bnVsbCx0aGlzLl9wYXJlbnRFZGdlPW51bGwsdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleD1udWxsLHRoaXMuX2lzTm9kZUFkZGVkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2hvdFBpeGVsPXQsdGhpcy5fcGFyZW50RWRnZT1lLHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXg9bn0sRWkuSG90UGl4ZWxTbmFwQWN0aW9uPUlpLEVpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2luZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5kZXg9dH07Y2xhc3MgTml7Y29uc3RydWN0b3IoKXtOaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07aWYodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpO3QrKyl0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnMuYWRkKHRoaXMuX2xpLmdldEludGVyc2VjdGlvbih0KSk7dC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLHMsMSl9fWlzRG9uZSgpe3JldHVybiExfWdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnN9Z2V0Q2xhc3MoKXtyZXR1cm4gTml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW19pXX19TmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bnVsbCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saT10LHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucz1uZXcgeH07Y2xhc3MgQ2l7Y29uc3RydWN0b3IoKXtDaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNoZWNrQ29ycmVjdG5lc3ModCl7Y29uc3QgZT1Gcy5nZXROb2RlZFN1YnN0cmluZ3ModCksbj1uZXcgbWkoZSk7dHJ5e24uY2hlY2tWYWxpZCgpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIEMpKXRocm93IHQ7dC5wcmludFN0YWNrVHJhY2UoKX19Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7cmV0dXJuIEZzLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLl9ub2RlZFNlZ1N0cmluZ3MpfXNuYXBSb3VuZCh0LGUpe2NvbnN0IG49dGhpcy5maW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHQsZSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uU25hcHMobiksdGhpcy5jb21wdXRlVmVydGV4U25hcHModCl9ZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGUpe2NvbnN0IG49bmV3IE5pKGUpO3JldHVybiB0aGlzLl9ub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IobiksdGhpcy5fbm9kZXIuY29tcHV0ZU5vZGVzKHQpLG4uZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9Y29tcHV0ZVZlcnRleFNuYXBzKCl7aWYoXyhhcmd1bWVudHNbMF0sZikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5jb21wdXRlVmVydGV4U25hcHMoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2NvbnN0IHM9bmV3IHlpKGVbbl0sdGhpcy5fc2NhbGVGYWN0b3IsdGhpcy5fbGkpO3RoaXMuX3BvaW50U25hcHBlci5zbmFwKHMsdCxuKSYmdC5hZGRJbnRlcnNlY3Rpb24oZVtuXSxuKX19fWNvbXB1dGVOb2Rlcyh0KXt0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9dCx0aGlzLl9ub2Rlcj1uZXcgWXMsdGhpcy5fcG9pbnRTbmFwcGVyPW5ldyBFaSh0aGlzLl9ub2Rlci5nZXRJbmRleCgpKSx0aGlzLnNuYXBSb3VuZCh0LHRoaXMuX2xpKX1jb21wdXRlSW50ZXJzZWN0aW9uU25hcHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj1uZXcgeWkodCx0aGlzLl9zY2FsZUZhY3Rvcix0aGlzLl9saSk7dGhpcy5fcG9pbnRTbmFwcGVyLnNuYXAobil9fWdldENsYXNzKCl7cmV0dXJuIENpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltWc119fUNpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3BtPW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9zY2FsZUZhY3Rvcj1udWxsLHRoaXMuX25vZGVyPW51bGwsdGhpcy5fcG9pbnRTbmFwcGVyPW51bGwsdGhpcy5fbm9kZWRTZWdTdHJpbmdzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcG09dCx0aGlzLl9saT1uZXcgdGUsdGhpcy5fbGkuc2V0UHJlY2lzaW9uTW9kZWwodCksdGhpcy5fc2NhbGVGYWN0b3I9dC5nZXRTY2FsZSgpfTtjbGFzcyBTaXtjb25zdHJ1Y3Rvcigpe1NpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGJ1ZmZlck9wKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgU2kodCkuZ2V0UmVzdWx0R2VvbWV0cnkoZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBTaSh0KTtyZXR1cm4gcy5zZXRRdWFkcmFudFNlZ21lbnRzKG4pLHMuZ2V0UmVzdWx0R2VvbWV0cnkoZSl9aWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBqcyYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbmV3IFNpKHQsbikuZ2V0UmVzdWx0R2VvbWV0cnkoZSl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IFNpKHQpO3JldHVybiBpLnNldFF1YWRyYW50U2VnbWVudHMobiksaS5zZXRFbmRDYXBTdHlsZShzKSxpLmdldFJlc3VsdEdlb21ldHJ5KGUpfX1zdGF0aWMgcHJlY2lzaW9uU2NhbGVGYWN0b3IodCxlLG4pe2NvbnN0IHM9dC5nZXRFbnZlbG9wZUludGVybmFsKCksaT1NLm1heChNYXRoLmFicyhzLmdldE1heFgoKSksTWF0aC5hYnMocy5nZXRNYXhZKCkpLE1hdGguYWJzKHMuZ2V0TWluWCgpKSxNYXRoLmFicyhzLmdldE1pblkoKSkpKzIqKGU+MD9lOjApLHI9bi1NYXRoLnRydW5jKE1hdGgubG9nKGkpL01hdGgubG9nKDEwKSsxKTtyZXR1cm4gTWF0aC5wb3coMTAscil9YnVmZmVyRml4ZWRQcmVjaXNpb24odCl7Y29uc3QgZT1uZXcga3MobmV3IENpKG5ldyBrdCgxKSksdC5nZXRTY2FsZSgpKSxuPW5ldyBwaSh0aGlzLl9idWZQYXJhbXMpO24uc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsKHQpLG4uc2V0Tm9kZXIoZSksdGhpcy5fcmVzdWx0R2VvbWV0cnk9bi5idWZmZXIodGhpcy5fYXJnR2VvbSx0aGlzLl9kaXN0YW5jZSl9YnVmZmVyUmVkdWNlZFByZWNpc2lvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobGV0IHQ9U2kuTUFYX1BSRUNJU0lPTl9ESUdJVFM7dD49MDt0LS0pe3RyeXt0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24odCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgV24pKXRocm93IHQ7dGhpcy5fc2F2ZUV4Y2VwdGlvbj10fWlmKG51bGwhPT10aGlzLl9yZXN1bHRHZW9tZXRyeSlyZXR1cm4gbnVsbH10aHJvdyB0aGlzLl9zYXZlRXhjZXB0aW9ufWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPVNpLnByZWNpc2lvblNjYWxlRmFjdG9yKHRoaXMuX2FyZ0dlb20sdGhpcy5fZGlzdGFuY2UsdCksbj1uZXcga3QoZSk7dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbihuKX19Y29tcHV0ZUdlb21ldHJ5KCl7aWYodGhpcy5idWZmZXJPcmlnaW5hbFByZWNpc2lvbigpLG51bGwhPT10aGlzLl9yZXN1bHRHZW9tZXRyeSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMuX2FyZ0dlb20uZ2V0RmFjdG9yeSgpLmdldFByZWNpc2lvbk1vZGVsKCk7dC5nZXRUeXBlKCk9PT1rdC5GSVhFRD90aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKHQpOnRoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbigpfXNldFF1YWRyYW50U2VnbWVudHModCl7dGhpcy5fYnVmUGFyYW1zLnNldFF1YWRyYW50U2VnbWVudHModCl9YnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKXt0cnl7Y29uc3QgdD1uZXcgcGkodGhpcy5fYnVmUGFyYW1zKTt0aGlzLl9yZXN1bHRHZW9tZXRyeT10LmJ1ZmZlcih0aGlzLl9hcmdHZW9tLHRoaXMuX2Rpc3RhbmNlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBjKSl0aHJvdyB0O3RoaXMuX3NhdmVFeGNlcHRpb249dH19Z2V0UmVzdWx0R2VvbWV0cnkodCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlPXQsdGhpcy5jb21wdXRlR2VvbWV0cnkoKSx0aGlzLl9yZXN1bHRHZW9tZXRyeX1zZXRFbmRDYXBTdHlsZSh0KXt0aGlzLl9idWZQYXJhbXMuc2V0RW5kQ2FwU3R5bGUodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gU2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVNpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2FyZ0dlb209bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuX2J1ZlBhcmFtcz1uZXcganMsdGhpcy5fcmVzdWx0R2VvbWV0cnk9bnVsbCx0aGlzLl9zYXZlRXhjZXB0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2FyZ0dlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9hcmdHZW9tPXQsdGhpcy5fYnVmUGFyYW1zPWV9fSxTaS5DQVBfUk9VTkQ9anMuQ0FQX1JPVU5ELFNpLkNBUF9CVVRUPWpzLkNBUF9GTEFULFNpLkNBUF9GTEFUPWpzLkNBUF9GTEFULFNpLkNBUF9TUVVBUkU9anMuQ0FQX1NRVUFSRSxTaS5NQVhfUFJFQ0lTSU9OX0RJR0lUUz0xMjt2YXIgd2k9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQnVmZmVyT3A6U2ksQnVmZmVyUGFyYW1ldGVyczpqc30pO2NsYXNzIExpe2NvbnN0cnVjdG9yKCl7TGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0luc2lkZUFyZWEoKXtyZXR1cm4gdGhpcy5fc2VnSW5kZXg9PT1MaS5JTlNJREVfQVJFQX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fWdldEdlb21ldHJ5Q29tcG9uZW50KCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudH1nZXRTZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fc2VnSW5kZXh9Z2V0Q2xhc3MoKXtyZXR1cm4gTGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUxpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2NvbXBvbmVudD1udWxsLHRoaXMuX3NlZ0luZGV4PW51bGwsdGhpcy5fcHQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07TGkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LExpLklOU0lERV9BUkVBLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2NvbXBvbmVudD10LHRoaXMuX3NlZ0luZGV4PWUsdGhpcy5fcHQ9bn19LExpLklOU0lERV9BUkVBPS0xO2NsYXNzIFRpe2NvbnN0cnVjdG9yKCl7VGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0TG9jYXRpb25zKHQpe2NvbnN0IGU9bmV3IHg7cmV0dXJuIHQuYXBwbHkobmV3IFRpKGUpKSxlfWZpbHRlcih0KXsodCBpbnN0YW5jZW9mIFB0fHx0IGluc3RhbmNlb2YgVHR8fHQgaW5zdGFuY2VvZiBidCkmJnRoaXMuX2xvY2F0aW9ucy5hZGQobmV3IExpKHQsMCx0LmdldENvb3JkaW5hdGUoKSkpfWdldENsYXNzKCl7cmV0dXJuIFRpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltndF19fVRpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xvY2F0aW9ucz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xvY2F0aW9ucz10fTtjbGFzcyBSaXtjb25zdHJ1Y3Rvcigpe1JpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRpc3RhbmNlKHQsZSl7cmV0dXJuIG5ldyBSaSh0LGUpLmRpc3RhbmNlKCl9c3RhdGljIGlzV2l0aGluRGlzdGFuY2UodCxlLG4pe3JldHVybiEodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPm4pJiZuZXcgUmkodCxlLG4pLmRpc3RhbmNlKCk8PW59c3RhdGljIG5lYXJlc3RQb2ludHModCxlKXtyZXR1cm4gbmV3IFJpKHQsZSkubmVhcmVzdFBvaW50cygpfWNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgwLHQpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDEsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9nZW9tW3RdO2lmKG4uZ2V0RGltZW5zaW9uKCk8MilyZXR1cm4gbnVsbDtjb25zdCBzPTEtdCxpPU5lLmdldFBvbHlnb25zKG4pO2lmKGkuc2l6ZSgpPjApe2NvbnN0IG49VGkuZ2V0TG9jYXRpb25zKHRoaXMuX2dlb21bc10pO2lmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UobixpLGUpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbltzXT1lWzBdLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bdF09ZVsxXSxudWxsfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJl8oYXJndW1lbnRzWzBdLG0pJiZfKGFyZ3VtZW50c1sxXSxtKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0KyspaWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShpLGUuZ2V0KHQpLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIExpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGJ0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPXQuZ2V0Q29vcmRpbmF0ZSgpO2lmKG5lLkVYVEVSSU9SIT09dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShzLGUpKXJldHVybiB0aGlzLl9taW5EaXN0YW5jZT0wLG5bMF09dCxuWzFdPW5ldyBMaShlLHMpLG51bGx9fWNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz1lLmdldCh0KTtpZih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZShpLHMsbiksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19Y29tcHV0ZUZhY2V0RGlzdGFuY2UoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLGU9eGUuZ2V0TGluZXModGhpcy5fZ2VvbVswXSksbj14ZS5nZXRMaW5lcyh0aGlzLl9nZW9tWzFdKSxzPUllLmdldFBvaW50cyh0aGlzLl9nZW9tWzBdKSxpPUllLmdldFBvaW50cyh0aGlzLl9nZW9tWzFdKTtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyhlLG4sdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKGUsaSx0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMobixzLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMCksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VQb2ludHMocyxpLHQpLHZvaWQgdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSkpKX1uZWFyZXN0TG9jYXRpb25zKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbn11cGRhdGVNaW5EaXN0YW5jZSh0LGUpe2lmKG51bGw9PT10WzBdKXJldHVybiBudWxsO2U/KHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF09dFsxXSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMF0pOih0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMF0sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzFdKX1uZWFyZXN0UG9pbnRzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksW3RoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF0uZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV0uZ2V0Q29vcmRpbmF0ZSgpXX1jb21wdXRlTWluRGlzdGFuY2UoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7aWYobnVsbCE9PXRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb24pcmV0dXJuIG51bGw7aWYodGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUZhY2V0RGlzdGFuY2UoKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgUHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLl9taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0Q29vcmRpbmF0ZSgpO2ZvcihsZXQgcj0wO3I8cy5sZW5ndGgtMTtyKyspe2NvbnN0IG89RC5wb2ludFRvU2VnbWVudChpLHNbcl0sc1tyKzFdKTtpZihvPHRoaXMuX21pbkRpc3RhbmNlKXt0aGlzLl9taW5EaXN0YW5jZT1vO2NvbnN0IGw9bmV3IGVlKHNbcl0sc1tyKzFdKS5jbG9zZXN0UG9pbnQoaSk7blswXT1uZXcgTGkodCxyLGwpLG5bMV09bmV3IExpKGUsMCxpKX1pZih0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBUdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMuX21pbkRpc3RhbmNlKXJldHVybiBudWxsO2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgcj0wO3I8cy5sZW5ndGgtMTtyKyspZm9yKGxldCBvPTA7bzxpLmxlbmd0aC0xO28rKyl7Y29uc3QgbD1ELnNlZ21lbnRUb1NlZ21lbnQoc1tyXSxzW3IrMV0saVtvXSxpW28rMV0pO2lmKGw8dGhpcy5fbWluRGlzdGFuY2Upe3RoaXMuX21pbkRpc3RhbmNlPWw7Y29uc3QgYT1uZXcgZWUoc1tyXSxzW3IrMV0pLGM9bmV3IGVlKGlbb10saVtvKzFdKSxoPWEuY2xvc2VzdFBvaW50cyhjKTtuWzBdPW5ldyBMaSh0LHIsaFswXSksblsxXT1uZXcgTGkoZSxvLGhbMV0pfWlmKHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fWNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCkscj1pLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZShzLmdldENvb3JkaW5hdGUoKSk7aWYocjx0aGlzLl9taW5EaXN0YW5jZSYmKHRoaXMuX21pbkRpc3RhbmNlPXIsblswXT1uZXcgTGkoaSwwLGkuZ2V0Q29vcmRpbmF0ZSgpKSxuWzFdPW5ldyBMaShzLDAscy5nZXRDb29yZGluYXRlKCkpKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX1kaXN0YW5jZSgpe2lmKG51bGw9PT10aGlzLl9nZW9tWzBdfHxudWxsPT09dGhpcy5fZ2VvbVsxXSl0aHJvdyBuZXcgbihcIm51bGwgZ2VvbWV0cmllcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gdGhpcy5fZ2VvbVswXS5pc0VtcHR5KCl8fHRoaXMuX2dlb21bMV0uaXNFbXB0eSgpPzA6KHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksdGhpcy5fbWluRGlzdGFuY2UpfWNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz1lLmdldCh0KTtpZih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZShpLHMsbiksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19Z2V0Q2xhc3MoKXtyZXR1cm4gUml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVJpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2dlb209bnVsbCx0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT0wLHRoaXMuX3B0TG9jYXRvcj1uZXcgX24sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbj1udWxsLHRoaXMuX21pbkRpc3RhbmNlPWkuTUFYX1ZBTFVFLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtSaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSwwKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2dlb21bMF09dCx0aGlzLl9nZW9tWzFdPWUsdGhpcy5fdGVybWluYXRlRGlzdGFuY2U9bn19O3ZhciBQaT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEaXN0YW5jZU9wOlJpfSk7Y2xhc3Mgdml7Y29uc3RydWN0b3IoKXt2aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGVzKCl7aWYobnVsbD09PXRoaXMuX2Nvb3JkaW5hdGVzKXtsZXQgdD0wLGU9MDtjb25zdCBuPW5ldyBJO2ZvcihsZXQgcz10aGlzLl9kaXJlY3RlZEVkZ2VzLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBpPXMubmV4dCgpO2kuZ2V0RWRnZURpcmVjdGlvbigpP3QrKzplKyssbi5hZGQoaS5nZXRFZGdlKCkuZ2V0TGluZSgpLmdldENvb3JkaW5hdGVzKCksITEsaS5nZXRFZGdlRGlyZWN0aW9uKCkpfXRoaXMuX2Nvb3JkaW5hdGVzPW4udG9Db29yZGluYXRlQXJyYXkoKSxlPnQmJlgucmV2ZXJzZSh0aGlzLl9jb29yZGluYXRlcyl9cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzfXRvTGluZVN0cmluZygpe3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKX1hZGQodCl7dGhpcy5fZGlyZWN0ZWRFZGdlcy5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gdml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXZpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9kaXJlY3RlZEVkZ2VzPW5ldyB4LHRoaXMuX2Nvb3JkaW5hdGVzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fTtjbGFzcyBPaXtjb25zdHJ1Y3Rvcigpe09pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldENvbXBvbmVudFdpdGhWaXNpdGVkU3RhdGUodCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKTtpZihuLmlzVmlzaXRlZCgpPT09ZSlyZXR1cm4gbn1yZXR1cm4gbnVsbH1zdGF0aWMgc2V0VmlzaXRlZCh0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRWaXNpdGVkKGUpfX1zdGF0aWMgc2V0TWFya2VkKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3QubmV4dCgpLnNldE1hcmtlZChlKX19c2V0VmlzaXRlZCh0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH1pc01hcmtlZCgpe3JldHVybiB0aGlzLl9pc01hcmtlZH1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9c2V0TWFya2VkKHQpe3RoaXMuX2lzTWFya2VkPXR9Z2V0Q29udGV4dCgpe3JldHVybiB0aGlzLl9kYXRhfWlzVmlzaXRlZCgpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9c2V0Q29udGV4dCh0KXt0aGlzLl9kYXRhPXR9Z2V0Q2xhc3MoKXtyZXR1cm4gT2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU9pLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzTWFya2VkPSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLl9kYXRhPW51bGx9O2NsYXNzIGJpIGV4dGVuZHMgT2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLGJpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvRWRnZXModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLmFkZChuLm5leHQoKS5fcGFyZW50RWRnZSk7cmV0dXJuIGV9aXNSZW1vdmVkKCl7cmV0dXJuIG51bGw9PT10aGlzLl9wYXJlbnRFZGdlfWNvbXBhcmVEaXJlY3Rpb24odCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50PnQuX3F1YWRyYW50PzE6dGhpcy5fcXVhZHJhbnQ8dC5fcXVhZHJhbnQ/LTE6di5pbmRleCh0Ll9wMCx0Ll9wMSx0aGlzLl9wMSl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9mcm9tLmdldENvb3JkaW5hdGUoKX1wcmludCh0KXtjb25zdCBlPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksbj1lLmxhc3RJbmRleE9mKFwiLlwiKSxzPWUuc3Vic3RyaW5nKG4rMSk7dC5wcmludChcIiAgXCIrcytcIjogXCIrdGhpcy5fcDArXCIgLSBcIit0aGlzLl9wMStcIiBcIit0aGlzLl9xdWFkcmFudCtcIjpcIit0aGlzLl9hbmdsZSl9Z2V0RGlyZWN0aW9uUHQoKXtyZXR1cm4gdGhpcy5fcDF9Z2V0QW5nbGUoKXtyZXR1cm4gdGhpcy5fYW5nbGV9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlRGlyZWN0aW9uKGUpfWdldEZyb21Ob2RlKCl7cmV0dXJuIHRoaXMuX2Zyb219Z2V0U3ltKCl7cmV0dXJuIHRoaXMuX3N5bX1zZXRFZGdlKHQpe3RoaXMuX3BhcmVudEVkZ2U9dH1yZW1vdmUoKXt0aGlzLl9zeW09bnVsbCx0aGlzLl9wYXJlbnRFZGdlPW51bGx9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9wYXJlbnRFZGdlfWdldFF1YWRyYW50KCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50fXNldFN5bSh0KXt0aGlzLl9zeW09dH1nZXRUb05vZGUoKXtyZXR1cm4gdGhpcy5fdG99Z2V0RWRnZURpcmVjdGlvbigpe3JldHVybiB0aGlzLl9lZGdlRGlyZWN0aW9ufWdldENsYXNzKCl7cmV0dXJuIGJpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19YmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcGFyZW50RWRnZT1udWxsLHRoaXMuX2Zyb209bnVsbCx0aGlzLl90bz1udWxsLHRoaXMuX3AwPW51bGwsdGhpcy5fcDE9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9lZGdlRGlyZWN0aW9uPW51bGwsdGhpcy5fcXVhZHJhbnQ9bnVsbCx0aGlzLl9hbmdsZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9mcm9tPXQsdGhpcy5fdG89ZSx0aGlzLl9lZGdlRGlyZWN0aW9uPXMsdGhpcy5fcDA9dC5nZXRDb29yZGluYXRlKCksdGhpcy5fcDE9bjtjb25zdCBpPXRoaXMuX3AxLngtdGhpcy5fcDAueCxyPXRoaXMuX3AxLnktdGhpcy5fcDAueTt0aGlzLl9xdWFkcmFudD1Jbi5xdWFkcmFudChpLHIpLHRoaXMuX2FuZ2xlPU1hdGguYXRhbjIocixpKX19O2NsYXNzIE1pIGV4dGVuZHMgYml7Y29uc3RydWN0b3IoKXtzdXBlcigpLE1pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TmV4dCgpe3JldHVybiAyIT09dGhpcy5nZXRUb05vZGUoKS5nZXREZWdyZWUoKT9udWxsOnRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgwKT09PXRoaXMuZ2V0U3ltKCk/dGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpOih1LmlzVHJ1ZSh0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMSk9PT10aGlzLmdldFN5bSgpKSx0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCkpfWdldENsYXNzKCl7cmV0dXJuIE1pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1NaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtiaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuLHMpfTtjbGFzcyBEaSBleHRlbmRzIE9pe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxEaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzUmVtb3ZlZCgpe3JldHVybiBudWxsPT09dGhpcy5fZGlyRWRnZX1zZXREaXJlY3RlZEVkZ2VzKHQsZSl7dGhpcy5fZGlyRWRnZT1bdCxlXSx0LnNldEVkZ2UodGhpcyksZS5zZXRFZGdlKHRoaXMpLHQuc2V0U3ltKGUpLGUuc2V0U3ltKHQpLHQuZ2V0RnJvbU5vZGUoKS5hZGRPdXRFZGdlKHQpLGUuZ2V0RnJvbU5vZGUoKS5hZGRPdXRFZGdlKGUpfWdldERpckVkZ2UoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kaXJFZGdlW3RdfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kaXJFZGdlWzBdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMF06dGhpcy5fZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzFdOm51bGx9fXJlbW92ZSgpe3RoaXMuX2RpckVkZ2U9bnVsbH1nZXRPcHBvc2l0ZU5vZGUodCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVswXS5nZXRUb05vZGUoKTp0aGlzLl9kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMV0uZ2V0VG9Ob2RlKCk6bnVsbH1nZXRDbGFzcygpe3JldHVybiBEaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZGlyRWRnZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNldERpcmVjdGVkRWRnZXModCxlKX19O2NsYXNzIEFpe2NvbnN0cnVjdG9yKCl7QWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXROZXh0RWRnZSh0KXtjb25zdCBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMuX291dEVkZ2VzLmdldCh0aGlzLmdldEluZGV4KGUrMSkpfWdldENvb3JkaW5hdGUoKXtjb25zdCB0PXRoaXMuaXRlcmF0b3IoKTtyZXR1cm4gdC5oYXNOZXh0KCk/dC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZSgpOm51bGx9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLl9vdXRFZGdlcy5pdGVyYXRvcigpfXNvcnRFZGdlcygpe3RoaXMuX3NvcnRlZHx8KEVlLnNvcnQodGhpcy5fb3V0RWRnZXMpLHRoaXMuX3NvcnRlZD0hMCl9cmVtb3ZlKHQpe3RoaXMuX291dEVkZ2VzLnJlbW92ZSh0KX1nZXRFZGdlcygpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMuX291dEVkZ2VzfWdldE5leHRDV0VkZ2UodCl7Y29uc3QgZT10aGlzLmdldEluZGV4KHQpO3JldHVybiB0aGlzLl9vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlLTEpKX1nZXRJbmRleCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRGkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc29ydEVkZ2VzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9vdXRFZGdlcy5zaXplKCk7ZSsrKXtpZih0aGlzLl9vdXRFZGdlcy5nZXQoZSkuZ2V0RWRnZSgpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2ZvcihsZXQgZT0wO2U8dGhpcy5fb3V0RWRnZXMuc2l6ZSgpO2UrKyl7aWYodGhpcy5fb3V0RWRnZXMuZ2V0KGUpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2xldCB0PWFyZ3VtZW50c1swXSV0aGlzLl9vdXRFZGdlcy5zaXplKCk7cmV0dXJuIHQ8MCYmKHQrPXRoaXMuX291dEVkZ2VzLnNpemUoKSksdH19YWRkKHQpe3RoaXMuX291dEVkZ2VzLmFkZCh0KSx0aGlzLl9zb3J0ZWQ9ITF9Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX291dEVkZ2VzLnNpemUoKX1nZXRDbGFzcygpe3JldHVybiBBaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19QWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fb3V0RWRnZXM9bmV3IHgsdGhpcy5fc29ydGVkPSExfTtjbGFzcyBGaSBleHRlbmRzIE9pe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxGaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRFZGdlc0JldHdlZW4odCxlKXtjb25zdCBuPW5ldyBKKGJpLnRvRWRnZXModC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkpKSxzPWJpLnRvRWRnZXMoZS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkpO3JldHVybiBuLnJldGFpbkFsbChzKSxufWlzUmVtb3ZlZCgpe3JldHVybiBudWxsPT09dGhpcy5fcHR9YWRkT3V0RWRnZSh0KXt0aGlzLl9kZVN0YXIuYWRkKHQpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9Z2V0T3V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZGVTdGFyfXJlbW92ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX3B0PW51bGw7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZGVTdGFyLnJlbW92ZSh0KX19Z2V0SW5kZXgodCl7cmV0dXJuIHRoaXMuX2RlU3Rhci5nZXRJbmRleCh0KX1nZXREZWdyZWUoKXtyZXR1cm4gdGhpcy5fZGVTdGFyLmdldERlZ3JlZSgpfWdldENsYXNzKCl7cmV0dXJuIEZpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1GaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wdD1udWxsLHRoaXMuX2RlU3Rhcj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtGaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbmV3IEFpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdD10LHRoaXMuX2RlU3Rhcj1lfX07Y2xhc3MgR2kgZXh0ZW5kcyBEaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksR2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2xpbmV9Z2V0Q2xhc3MoKXtyZXR1cm4gR2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUdpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lPXR9O2NsYXNzIHFpe2NvbnN0cnVjdG9yKCl7cWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5kKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLmdldCh0KX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9cmVtb3ZlKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLnJlbW92ZSh0KX12YWx1ZXMoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKX1hZGQodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAucHV0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpLHR9Z2V0Q2xhc3MoKXtyZXR1cm4gcWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXFpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25vZGVNYXA9bmV3IHJ0fTtjbGFzcyBCaXtjb25zdHJ1Y3Rvcigpe0JpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluZE5vZGVzT2ZEZWdyZWUodCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dGhpcy5ub2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cy5nZXREZWdyZWUoKT09PXQmJmUuYWRkKHMpfXJldHVybiBlfWRpckVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9kaXJFZGdlcy5pdGVyYXRvcigpfWVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfXJlbW92ZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRGkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDEpKSx0aGlzLl9lZGdlcy5yZW1vdmUodCksdC5yZW1vdmUoKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5nZXRTeW0oKTtudWxsIT09ZSYmZS5zZXRTeW0obnVsbCksdC5nZXRGcm9tTm9kZSgpLnJlbW92ZSh0KSx0LnJlbW92ZSgpLHRoaXMuX2RpckVkZ2VzLnJlbW92ZSh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0U3ltKCk7bnVsbCE9PW4mJnRoaXMucmVtb3ZlKG4pLHRoaXMuX2RpckVkZ2VzLnJlbW92ZSh0KTtjb25zdCBzPXQuZ2V0RWRnZSgpO251bGwhPT1zJiZ0aGlzLl9lZGdlcy5yZW1vdmUocyl9dGhpcy5fbm9kZU1hcC5yZW1vdmUodC5nZXRDb29yZGluYXRlKCkpLHQucmVtb3ZlKCl9fWZpbmROb2RlKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLmZpbmQodCl9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9bm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuaXRlcmF0b3IoKX1jb250YWlucygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRGkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9lZGdlcy5jb250YWlucyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGlyRWRnZXMuY29udGFpbnModCl9fWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25vZGVNYXAuYWRkKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZWRnZXMuYWRkKHQpLHRoaXMuYWRkKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5hZGQodC5nZXREaXJFZGdlKDEpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2RpckVkZ2VzLmFkZCh0KX19Z2V0Tm9kZXMoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKX1nZXRDbGFzcygpe3JldHVybiBCaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19QmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZWRnZXM9bmV3IEosdGhpcy5fZGlyRWRnZXM9bmV3IEosdGhpcy5fbm9kZU1hcD1uZXcgcWl9O2NsYXNzIFZpIGV4dGVuZHMgQml7Y29uc3RydWN0b3IoKXtzdXBlcigpLFZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkRWRnZSh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBlPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDtjb25zdCBuPWVbMF0scz1lW2UubGVuZ3RoLTFdLGk9dGhpcy5nZXROb2RlKG4pLHI9dGhpcy5nZXROb2RlKHMpLG89bmV3IE1pKGkscixlWzFdLCEwKSxsPW5ldyBNaShyLGksZVtlLmxlbmd0aC0yXSwhMSksYT1uZXcgR2kodCk7YS5zZXREaXJlY3RlZEVkZ2VzKG8sbCksdGhpcy5hZGQoYSl9Z2V0Tm9kZSh0KXtsZXQgZT10aGlzLmZpbmROb2RlKHQpO3JldHVybiBudWxsPT09ZSYmKGU9bmV3IEZpKHQpLHRoaXMuYWRkKGUpKSxlfWdldENsYXNzKCl7cmV0dXJuIFZpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1WaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHppe2NvbnN0cnVjdG9yKCl7emkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1idWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2UuaXNNYXJrZWQoKXx8KHUuaXNUcnVlKDI9PT1lLmdldERlZ3JlZSgpKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fWJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTsyIT09ZS5nZXREZWdyZWUoKSYmKHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19YnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzKCl9Z2V0TWVyZ2VkTGluZVN0cmluZ3MoKXtyZXR1cm4gdGhpcy5tZXJnZSgpLHRoaXMuX21lcmdlZExpbmVTdHJpbmdzfWJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KHQpe2ZvcihsZXQgZT10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5nZXRFZGdlKCkuaXNNYXJrZWQoKXx8dGhpcy5fZWRnZVN0cmluZ3MuYWRkKHRoaXMuYnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoKHQpKX19bWVyZ2UoKXtpZihudWxsIT09dGhpcy5fbWVyZ2VkTGluZVN0cmluZ3MpcmV0dXJuIG51bGw7T2kuc2V0TWFya2VkKHRoaXMuX2dyYXBoLm5vZGVJdGVyYXRvcigpLCExKSxPaS5zZXRNYXJrZWQodGhpcy5fZ3JhcGguZWRnZUl0ZXJhdG9yKCksITEpLHRoaXMuX2VkZ2VTdHJpbmdzPW5ldyB4LHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzKCksdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wcygpLHRoaXMuX21lcmdlZExpbmVTdHJpbmdzPW5ldyB4O2ZvcihsZXQgdD10aGlzLl9lZGdlU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncy5hZGQoZS50b0xpbmVTdHJpbmcoKSl9fWFkZExpbmVTdHJpbmcodCl7bnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0aGlzLl9ncmFwaC5hZGRFZGdlKHQpfWJ1aWxkRWRnZVN0cmluZ1N0YXJ0aW5nV2l0aCh0KXtjb25zdCBlPW5ldyB2aSh0aGlzLl9mYWN0b3J5KTtsZXQgbj10O2Rve2UuYWRkKG4pLG4uZ2V0RWRnZSgpLnNldE1hcmtlZCghMCksbj1uLmdldE5leHQoKX13aGlsZShudWxsIT09biYmbiE9PXQpO3JldHVybiBlfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7biBpbnN0YW5jZW9mIFR0JiZ0aGlzLmFkZExpbmVTdHJpbmcobil9fWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21lcmdlZExpbmVTdHJpbmdzPW51bGw7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5hZGQodCl9fX1idWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wcygpe3RoaXMuYnVpbGRFZGdlU3RyaW5nc0ZvclVucHJvY2Vzc2VkTm9kZXMoKX1nZXRDbGFzcygpe3JldHVybiB6aX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19emkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ3JhcGg9bmV3IFZpLHRoaXMuX21lcmdlZExpbmVTdHJpbmdzPW51bGwsdGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2VkZ2VTdHJpbmdzPW51bGx9O2NsYXNzIFlpe2NvbnN0cnVjdG9yKCl7WWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1kaXJFZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKX1lZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50R3JhcGh9bm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuaXRlcmF0b3IoKX1jb250YWlucyh0KXtyZXR1cm4gdGhpcy5fZWRnZXMuY29udGFpbnModCl9YWRkKHQpe2lmKHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpKXJldHVybiBudWxsO3RoaXMuX2VkZ2VzLmFkZCh0KSx0aGlzLl9kaXJFZGdlcy5hZGQodC5nZXREaXJFZGdlKDApKSx0aGlzLl9kaXJFZGdlcy5hZGQodC5nZXREaXJFZGdlKDEpKSx0aGlzLl9ub2RlTWFwLmFkZCh0LmdldERpckVkZ2UoMCkuZ2V0RnJvbU5vZGUoKSksdGhpcy5fbm9kZU1hcC5hZGQodC5nZXREaXJFZGdlKDEpLmdldEZyb21Ob2RlKCkpfWdldENsYXNzKCl7cmV0dXJuIFlpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1ZaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wYXJlbnRHcmFwaD1udWxsLHRoaXMuX2VkZ2VzPW5ldyBKLHRoaXMuX2RpckVkZ2VzPW5ldyB4LHRoaXMuX25vZGVNYXA9bmV3IHFpO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BhcmVudEdyYXBoPXR9O2NsYXNzIFVpe2NvbnN0cnVjdG9yKCl7VWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGRSZWFjaGFibGUodCxlKXtjb25zdCBuPW5ldyBvbjtmb3Iobi5hZGQodCk7IW4uZW1wdHkoKTspe2NvbnN0IHQ9bi5wb3AoKTt0aGlzLmFkZEVkZ2VzKHQsbixlKX19ZmluZFN1YmdyYXBoKHQpe2NvbnN0IGU9bmV3IFlpKHRoaXMuX2dyYXBoKTtyZXR1cm4gdGhpcy5hZGRSZWFjaGFibGUodCxlKSxlfWdldENvbm5lY3RlZFN1YmdyYXBocygpe2NvbnN0IHQ9bmV3IHg7T2kuc2V0VmlzaXRlZCh0aGlzLl9ncmFwaC5ub2RlSXRlcmF0b3IoKSwhMSk7Zm9yKGxldCBlPXRoaXMuX2dyYXBoLmVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXREaXJFZGdlKDApLmdldEZyb21Ob2RlKCk7bi5pc1Zpc2l0ZWQoKXx8dC5hZGQodGhpcy5maW5kU3ViZ3JhcGgobikpfXJldHVybiB0fWFkZEVkZ2VzKHQsZSxuKXt0LnNldFZpc2l0ZWQoITApO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7bi5hZGQodC5nZXRFZGdlKCkpO2NvbnN0IGk9dC5nZXRUb05vZGUoKTtpLmlzVmlzaXRlZCgpfHxlLnB1c2goaSl9fWdldENsYXNzKCl7cmV0dXJuIFVpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1VaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ncmFwaD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dyYXBoPXR9O2NsYXNzIGtpe2NvbnN0cnVjdG9yKCl7a2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmluZFVudmlzaXRlZEJlc3RPcmllbnRlZERFKHQpe2xldCBlPW51bGwsbj1udWxsO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5nZXRFZGdlKCkuaXNWaXNpdGVkKCl8fChuPXQsdC5nZXRFZGdlRGlyZWN0aW9uKCkmJihlPXQpKX1yZXR1cm4gbnVsbCE9PWU/ZTpufXN0YXRpYyBmaW5kTG93ZXN0RGVncmVlTm9kZSh0KXtsZXQgZT1MLk1BWF9WQUxVRSxuPW51bGw7Zm9yKGxldCBzPXQubm9kZUl0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpOyhudWxsPT09bnx8dC5nZXREZWdyZWUoKTxlKSYmKGU9dC5nZXREZWdyZWUoKSxuPXQpfXJldHVybiBufXN0YXRpYyBpc1NlcXVlbmNlZCh0KXtpZighKHQgaW5zdGFuY2VvZiBmdCkpcmV0dXJuITA7Y29uc3QgZT10LG49bmV3IGF0O2xldCBzPW51bGw7Y29uc3QgaT1uZXcgeDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3Qgcj1lLmdldEdlb21ldHJ5Tih0KSxvPXIuZ2V0Q29vcmRpbmF0ZU4oMCksbD1yLmdldENvb3JkaW5hdGVOKHIuZ2V0TnVtUG9pbnRzKCktMSk7aWYobi5jb250YWlucyhvKSlyZXR1cm4hMTtpZihuLmNvbnRhaW5zKGwpKXJldHVybiExO251bGwhPT1zJiYoby5lcXVhbHMocyl8fChuLmFkZEFsbChpKSxpLmNsZWFyKCkpKSxpLmFkZChvKSxpLmFkZChsKSxzPWx9cmV0dXJuITB9c3RhdGljIHJldmVyc2UodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCksbj1uZXcgQXJyYXkoZS5sZW5ndGgpLmZpbGwobnVsbCkscz1lLmxlbmd0aDtmb3IobGV0IHQ9MDt0PHM7dCsrKW5bcy0xLXRdPW5ldyBnKGVbdF0pO3JldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKG4pfXN0YXRpYyBzZXF1ZW5jZSh0KXtjb25zdCBlPW5ldyBraTtyZXR1cm4gZS5hZGQodCksZS5nZXRTZXF1ZW5jZWRMaW5lU3RyaW5ncygpfWFkZExpbmUodCl7bnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0aGlzLl9ncmFwaC5hZGRFZGdlKHQpLHRoaXMuX2xpbmVDb3VudCsrfWhhc1NlcXVlbmNlKHQpe2xldCBlPTA7Zm9yKGxldCBuPXQubm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5nZXREZWdyZWUoKSUyPT0xJiZlKyt9cmV0dXJuIGU8PTJ9Y29tcHV0ZVNlcXVlbmNlKCl7aWYodGhpcy5faXNSdW4pcmV0dXJuIG51bGw7dGhpcy5faXNSdW49ITA7Y29uc3QgdD10aGlzLmZpbmRTZXF1ZW5jZXMoKTtpZihudWxsPT09dClyZXR1cm4gbnVsbDt0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeT10aGlzLmJ1aWxkU2VxdWVuY2VkR2VvbWV0cnkodCksdGhpcy5faXNTZXF1ZW5jZWFibGU9ITA7Y29uc3QgZT10aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeS5nZXROdW1HZW9tZXRyaWVzKCk7dS5pc1RydWUodGhpcy5fbGluZUNvdW50PT09ZSxcIkxpbmVzIHdlcmUgbWlzc2luZyBmcm9tIHJlc3VsdFwiKSx1LmlzVHJ1ZSh0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeSBpbnN0YW5jZW9mIFR0fHx0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeSBpbnN0YW5jZW9mIGZ0LFwiUmVzdWx0IGlzIG5vdCBsaW5lYWxcIil9ZmluZFNlcXVlbmNlcygpe2NvbnN0IHQ9bmV3IHg7Zm9yKGxldCBlPW5ldyBVaSh0aGlzLl9ncmFwaCkuZ2V0Q29ubmVjdGVkU3ViZ3JhcGhzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYoIXRoaXMuaGFzU2VxdWVuY2UobikpcmV0dXJuIG51bGw7e2NvbnN0IGU9dGhpcy5maW5kU2VxdWVuY2Uobik7dC5hZGQoZSl9fXJldHVybiB0fWFkZFJldmVyc2VTdWJwYXRoKHQsZSxuKXtjb25zdCBzPXQuZ2V0VG9Ob2RlKCk7bGV0IGk9bnVsbDtmb3IoOzspe2UuYWRkKHQuZ2V0U3ltKCkpLHQuZ2V0RWRnZSgpLnNldFZpc2l0ZWQoITApLGk9dC5nZXRGcm9tTm9kZSgpO2NvbnN0IG49a2kuZmluZFVudmlzaXRlZEJlc3RPcmllbnRlZERFKGkpO2lmKG51bGw9PT1uKWJyZWFrO3Q9bi5nZXRTeW0oKX1uJiZ1LmlzVHJ1ZShpPT09cyxcInBhdGggbm90IGNvbnRpZ3VvdXNcIil9ZmluZFNlcXVlbmNlKHQpe09pLnNldFZpc2l0ZWQodC5lZGdlSXRlcmF0b3IoKSwhMSk7Y29uc3QgZT1raS5maW5kTG93ZXN0RGVncmVlTm9kZSh0KS5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCkubmV4dCgpLmdldFN5bSgpLG49bmV3IFpzLHM9bi5saXN0SXRlcmF0b3IoKTtmb3IodGhpcy5hZGRSZXZlcnNlU3VicGF0aChlLHMsITEpO3MuaGFzUHJldmlvdXMoKTspe2NvbnN0IHQ9cy5wcmV2aW91cygpLGU9a2kuZmluZFVudmlzaXRlZEJlc3RPcmllbnRlZERFKHQuZ2V0RnJvbU5vZGUoKSk7bnVsbCE9PWUmJnRoaXMuYWRkUmV2ZXJzZVN1YnBhdGgoZS5nZXRTeW0oKSxzLCEwKX1yZXR1cm4gdGhpcy5vcmllbnQobil9cmV2ZXJzZSh0KXtjb25zdCBlPW5ldyBacztmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZEZpcnN0KHQuZ2V0U3ltKCkpfXJldHVybiBlfW9yaWVudCh0KXtjb25zdCBlPXQuZ2V0KDApLG49dC5nZXQodC5zaXplKCktMSkscz1lLmdldEZyb21Ob2RlKCksaT1uLmdldFRvTm9kZSgpO2xldCByPSExO2lmKDE9PT1zLmdldERlZ3JlZSgpfHwxPT09aS5nZXREZWdyZWUoKSl7bGV0IHQ9ITE7MT09PW4uZ2V0VG9Ob2RlKCkuZ2V0RGVncmVlKCkmJiExPT09bi5nZXRFZGdlRGlyZWN0aW9uKCkmJih0PSEwLHI9ITApLDE9PT1lLmdldEZyb21Ob2RlKCkuZ2V0RGVncmVlKCkmJiEwPT09ZS5nZXRFZGdlRGlyZWN0aW9uKCkmJih0PSEwLHI9ITEpLHR8fDE9PT1lLmdldEZyb21Ob2RlKCkuZ2V0RGVncmVlKCkmJihyPSEwKX1yZXR1cm4gcj90aGlzLnJldmVyc2UodCk6dH1idWlsZFNlcXVlbmNlZEdlb21ldHJ5KHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2ZvcihsZXQgdD1uLm5leHQoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKSxzPW4uZ2V0RWRnZSgpLmdldExpbmUoKTtsZXQgaT1zO24uZ2V0RWRnZURpcmVjdGlvbigpfHxzLmlzQ2xvc2VkKCl8fChpPWtpLnJldmVyc2UocykpLGUuYWRkKGkpfX1yZXR1cm4gMD09PWUuc2l6ZSgpP3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG5ldyBBcnJheSgwKS5maWxsKG51bGwpKTp0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkoZSl9Z2V0U2VxdWVuY2VkTGluZVN0cmluZ3MoKXtyZXR1cm4gdGhpcy5jb21wdXRlU2VxdWVuY2UoKSx0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeX1pc1NlcXVlbmNlYWJsZSgpe3JldHVybiB0aGlzLmNvbXB1dGVTZXF1ZW5jZSgpLHRoaXMuX2lzU2VxdWVuY2VhYmxlfWFkZCgpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7YXJndW1lbnRzWzBdLmFwcGx5KG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bR119ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBUdCYmdGhpcy5hZGRMaW5lKHQpfX0pfX1nZXRDbGFzcygpe3JldHVybiBraX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19a2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ3JhcGg9bmV3IFZpLHRoaXMuX2ZhY3Rvcnk9bmV3IEh0LHRoaXMuX2xpbmVDb3VudD0wLHRoaXMuX2lzUnVuPSExLHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5PW51bGwsdGhpcy5faXNTZXF1ZW5jZWFibGU9ITF9O3ZhciBYaT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxMaW5lTWVyZ2VyOnppLExpbmVTZXF1ZW5jZXI6a2l9KTtjbGFzcyBIaXtjb25zdHJ1Y3Rvcigpe0hpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzQ2xvc2VkKHQpe3JldHVybiEodC5sZW5ndGg8PTEpJiZ0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfXNuYXBWZXJ0aWNlcyh0LGUpe2NvbnN0IG49dGhpcy5faXNDbG9zZWQ/dC5zaXplKCktMTp0LnNpemUoKTtmb3IobGV0IHM9MDtzPG47cysrKXtjb25zdCBuPXQuZ2V0KHMpLGk9dGhpcy5maW5kU25hcEZvclZlcnRleChuLGUpO251bGwhPT1pJiYodC5zZXQocyxuZXcgZyhpKSksMD09PXMmJnRoaXMuX2lzQ2xvc2VkJiZ0LnNldCh0LnNpemUoKS0xLG5ldyBnKGkpKSl9fWZpbmRTbmFwRm9yVmVydGV4KHQsZSl7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2lmKHQuZXF1YWxzMkQoZVtuXSkpcmV0dXJuIG51bGw7aWYodC5kaXN0YW5jZShlW25dKTx0aGlzLl9zbmFwVG9sZXJhbmNlKXJldHVybiBlW25dfXJldHVybiBudWxsfXNuYXBUbyh0KXtjb25zdCBlPW5ldyBJKHRoaXMuX3NyY1B0cyk7cmV0dXJuIHRoaXMuc25hcFZlcnRpY2VzKGUsdCksdGhpcy5zbmFwU2VnbWVudHMoZSx0KSxlLnRvQ29vcmRpbmF0ZUFycmF5KCl9c25hcFNlZ21lbnRzKHQsZSl7aWYoMD09PWUubGVuZ3RoKXJldHVybiBudWxsO2xldCBuPWUubGVuZ3RoO2VbMF0uZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkmJihuPWUubGVuZ3RoLTEpO2ZvcihsZXQgcz0wO3M8bjtzKyspe2NvbnN0IG49ZVtzXSxpPXRoaXMuZmluZFNlZ21lbnRJbmRleFRvU25hcChuLHQpO2k+PTAmJnQuYWRkKGkrMSxuZXcgZyhuKSwhMSl9fWZpbmRTZWdtZW50SW5kZXhUb1NuYXAodCxlKXtsZXQgbj1pLk1BWF9WQUxVRSxzPS0xO2ZvcihsZXQgaT0wO2k8ZS5zaXplKCktMTtpKyspe2lmKHRoaXMuX3NlZy5wMD1lLmdldChpKSx0aGlzLl9zZWcucDE9ZS5nZXQoaSsxKSx0aGlzLl9zZWcucDAuZXF1YWxzMkQodCl8fHRoaXMuX3NlZy5wMS5lcXVhbHMyRCh0KSl7aWYodGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMpY29udGludWU7cmV0dXJuLTF9Y29uc3Qgcj10aGlzLl9zZWcuZGlzdGFuY2UodCk7cjx0aGlzLl9zbmFwVG9sZXJhbmNlJiZyPG4mJihuPXIscz1pKX1yZXR1cm4gc31zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyh0KXt0aGlzLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcz10fWdldENsYXNzKCl7cmV0dXJuIEhpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1IaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9zbmFwVG9sZXJhbmNlPTAsdGhpcy5fc3JjUHRzPW51bGwsdGhpcy5fc2VnPW5ldyBlZSx0aGlzLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcz0hMSx0aGlzLl9pc0Nsb3NlZD0hMSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0JiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtIaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQuZ2V0Q29vcmRpbmF0ZXMoKSxlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3NyY1B0cz10LHRoaXMuX2lzQ2xvc2VkPUhpLmlzQ2xvc2VkKHQpLHRoaXMuX3NuYXBUb2xlcmFuY2U9ZX19O2NsYXNzIFdpe2NvbnN0cnVjdG9yKCl7V2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc25hcCh0LGUsbil7Y29uc3Qgcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxpPW5ldyBXaSh0KTtzWzBdPWkuc25hcFRvKGUsbik7Y29uc3Qgcj1uZXcgV2koZSk7cmV0dXJuIHNbMV09ci5zbmFwVG8oc1swXSxuKSxzfXN0YXRpYyBjb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9V2kuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UodCk7Y29uc3Qgbj10LmdldFByZWNpc2lvbk1vZGVsKCk7aWYobi5nZXRUeXBlKCk9PT1rdC5GSVhFRCl7Y29uc3QgdD0xL24uZ2V0U2NhbGUoKSoyLzEuNDE1O3Q+ZSYmKGU9dCl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBNYXRoLm1pbihXaS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UodCksV2kuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKGUpKX19c3RhdGljIGNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIE1hdGgubWluKGUuZ2V0SGVpZ2h0KCksZS5nZXRXaWR0aCgpKSpXaS5TTkFQX1BSRUNJU0lPTl9GQUNUT1J9c3RhdGljIHNuYXBUb1NlbGYodCxlLG4pe3JldHVybiBuZXcgV2kodCkuc25hcFRvU2VsZihlLG4pfXNuYXBUbyh0LGUpe2NvbnN0IG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModCk7cmV0dXJuIG5ldyBqaShlLG4pLnRyYW5zZm9ybSh0aGlzLl9zcmNHZW9tKX1zbmFwVG9TZWxmKHQsZSl7Y29uc3Qgbj10aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0aGlzLl9zcmNHZW9tKSxzPW5ldyBqaSh0LG4sITApLnRyYW5zZm9ybSh0aGlzLl9zcmNHZW9tKTtsZXQgaT1zO3JldHVybiBlJiZfKGksT3QpJiYoaT1zLmJ1ZmZlcigwKSksaX1jb21wdXRlU25hcFRvbGVyYW5jZSh0KXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGgodCkvMTB9ZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IGF0LG49dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuYWRkKG5bdF0pO3JldHVybiBlLnRvQXJyYXkobmV3IEFycmF5KDApLmZpbGwobnVsbCkpfWNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCh0KXtsZXQgZT1pLk1BWF9WQUxVRTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXtjb25zdCBzPXRbbl0uZGlzdGFuY2UodFtuKzFdKTtzPGUmJihlPXMpfXJldHVybiBlfWdldENsYXNzKCl7cmV0dXJuIFdpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1XaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zcmNHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3JjR2VvbT10fSxXaS5TTkFQX1BSRUNJU0lPTl9GQUNUT1I9MWUtOTtjbGFzcyBqaSBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxqaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNuYXBMaW5lKHQsZSl7Y29uc3Qgbj1uZXcgSGkodCx0aGlzLl9zbmFwVG9sZXJhbmNlKTtyZXR1cm4gbi5zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyh0aGlzLl9pc1NlbGZTbmFwKSxuLnNuYXBUbyhlKX10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpLHM9dGhpcy5zbmFwTGluZShuLHRoaXMuX3NuYXBQdHMpO3JldHVybiB0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9Z2V0Q2xhc3MoKXtyZXR1cm4gaml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWppLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3NuYXBUb2xlcmFuY2U9bnVsbCx0aGlzLl9zbmFwUHRzPW51bGwsdGhpcy5faXNTZWxmU25hcD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fc25hcFRvbGVyYW5jZT10LHRoaXMuX3NuYXBQdHM9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9zbmFwVG9sZXJhbmNlPXQsdGhpcy5fc25hcFB0cz1lLHRoaXMuX2lzU2VsZlNuYXA9bn19O3ZhciBLaT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxHZW9tZXRyeVNuYXBwZXI6V2ksTGluZVN0cmluZ1NuYXBwZXI6SGl9KTtjbGFzcyBaaXtjb25zdHJ1Y3Rvcigpe1ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHRzfXNpemUoKXtyZXR1cm4gdGhpcy5fcHRzLmxlbmd0aH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdHNbdF19aXNDbG9zZWQoKXtyZXR1cm4gdGhpcy5fcHRzWzBdLmVxdWFscyh0aGlzLl9wdHNbdGhpcy5fcHRzLmxlbmd0aC0xXSl9Z2V0U2VnbWVudE9jdGFudCh0KXtyZXR1cm4gdD09PXRoaXMuX3B0cy5sZW5ndGgtMT8tMTpNcy5vY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9dG9TdHJpbmcoKXtyZXR1cm4gSnQudG9MaW5lU3RyaW5nKG5ldyB6dCh0aGlzLl9wdHMpKX1nZXRDbGFzcygpe3JldHVybiBaaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRHNdfX1aaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl9kYXRhPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fZGF0YT1lfTtjbGFzcyBRaXtjb25zdHJ1Y3Rvcigpe1FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNyZWF0ZUFsbEludGVyc2VjdGlvbnNGaW5kZXIodCl7Y29uc3QgZT1uZXcgUWkodCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGV9c3RhdGljIGNyZWF0ZUFueUludGVyc2VjdGlvbkZpbmRlcih0KXtyZXR1cm4gbmV3IFFpKHQpfXN0YXRpYyBjcmVhdGVJbnRlcnNlY3Rpb25Db3VudGVyKHQpe2NvbnN0IGU9bmV3IFFpKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLnNldEtlZXBJbnRlcnNlY3Rpb25zKCExKSxlfWdldEludGVyaW9ySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ufXNldENoZWNrRW5kU2VnbWVudHNPbmx5KHQpe3RoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHk9dH1nZXRJbnRlcnNlY3Rpb25TZWdtZW50cygpe3JldHVybiB0aGlzLl9pbnRTZWdtZW50c31jb3VudCgpe3JldHVybiB0aGlzLl9pbnRlcnNlY3Rpb25Db3VudH1nZXRJbnRlcnNlY3Rpb25zKCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbnN9c2V0RmluZEFsbEludGVyc2VjdGlvbnModCl7dGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9dH1zZXRLZWVwSW50ZXJzZWN0aW9ucyh0KXt0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucz10fXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKCF0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyYmdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4gbnVsbDtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7aWYodGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seSl7aWYoISh0aGlzLmlzRW5kU2VnbWVudCh0LGUpfHx0aGlzLmlzRW5kU2VnbWVudChuLHMpKSlyZXR1cm4gbnVsbH1jb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpJiYodGhpcy5faW50U2VnbWVudHM9bmV3IEFycmF5KDQpLmZpbGwobnVsbCksdGhpcy5faW50U2VnbWVudHNbMF09aSx0aGlzLl9pbnRTZWdtZW50c1sxXT1yLHRoaXMuX2ludFNlZ21lbnRzWzJdPW8sdGhpcy5faW50U2VnbWVudHNbM109bCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbj10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCksdGhpcy5fa2VlcEludGVyc2VjdGlvbnMmJnRoaXMuX2ludGVyc2VjdGlvbnMuYWRkKHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uKSx0aGlzLl9pbnRlcnNlY3Rpb25Db3VudCsrKX1pc0VuZFNlZ21lbnQodCxlKXtyZXR1cm4gMD09PWV8fGU+PXQuc2l6ZSgpLTJ9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4hdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMmJm51bGwhPT10aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbn1nZXRDbGFzcygpe3JldHVybiBRaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bX2ldfX1RaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5PSExLHRoaXMuX2xpPW51bGwsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb249bnVsbCx0aGlzLl9pbnRTZWdtZW50cz1udWxsLHRoaXMuX2ludGVyc2VjdGlvbnM9bmV3IHgsdGhpcy5faW50ZXJzZWN0aW9uQ291bnQ9MCx0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucz0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saT10LHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uPW51bGx9O2NsYXNzIEppe2NvbnN0cnVjdG9yKCl7SmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tcHV0ZUludGVyc2VjdGlvbnModCl7Y29uc3QgZT1uZXcgSmkodCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuaXNWYWxpZCgpLGUuZ2V0SW50ZXJzZWN0aW9ucygpfWV4ZWN1dGUoKXtpZihudWxsIT09dGhpcy5fc2VnSW50KXJldHVybiBudWxsO3RoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKX1nZXRJbnRlcnNlY3Rpb25zKCl7cmV0dXJuIHRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb25zKCl9aXNWYWxpZCgpe3JldHVybiB0aGlzLmV4ZWN1dGUoKSx0aGlzLl9pc1ZhbGlkfXNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9Y2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKXt0aGlzLl9pc1ZhbGlkPSEwLHRoaXMuX3NlZ0ludD1uZXcgUWkodGhpcy5fbGkpLHRoaXMuX3NlZ0ludC5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyk7Y29uc3QgdD1uZXcgWXM7aWYodC5zZXRTZWdtZW50SW50ZXJzZWN0b3IodGhpcy5fc2VnSW50KSx0LmNvbXB1dGVOb2Rlcyh0aGlzLl9zZWdTdHJpbmdzKSx0aGlzLl9zZWdJbnQuaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuIHRoaXMuX2lzVmFsaWQ9ITEsbnVsbH1jaGVja1ZhbGlkKCl7aWYodGhpcy5leGVjdXRlKCksIXRoaXMuX2lzVmFsaWQpdGhyb3cgbmV3IFduKHRoaXMuZ2V0RXJyb3JNZXNzYWdlKCksdGhpcy5fc2VnSW50LmdldEludGVyaW9ySW50ZXJzZWN0aW9uKCkpfWdldEVycm9yTWVzc2FnZSgpe2lmKHRoaXMuX2lzVmFsaWQpcmV0dXJuXCJubyBpbnRlcnNlY3Rpb25zIGZvdW5kXCI7Y29uc3QgdD10aGlzLl9zZWdJbnQuZ2V0SW50ZXJzZWN0aW9uU2VnbWVudHMoKTtyZXR1cm5cImZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYmV0d2VlbiBcIitKdC50b0xpbmVTdHJpbmcodFswXSx0WzFdKStcIiBhbmQgXCIrSnQudG9MaW5lU3RyaW5nKHRbMl0sdFszXSl9Z2V0Q2xhc3MoKXtyZXR1cm4gSml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUppLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW5ldyB0ZSx0aGlzLl9zZWdTdHJpbmdzPW51bGwsdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9ITEsdGhpcy5fc2VnSW50PW51bGwsdGhpcy5faXNWYWxpZD0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWdTdHJpbmdzPXR9O2NsYXNzICRpe2NvbnN0cnVjdG9yKCl7JGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9TZWdtZW50U3RyaW5ncyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyBaaSh0LmdldENvb3JkaW5hdGVzKCksdCkpfXJldHVybiBlfXN0YXRpYyBjaGVja1ZhbGlkKHQpe25ldyAkaSh0KS5jaGVja1ZhbGlkKCl9Y2hlY2tWYWxpZCgpe3RoaXMuX252LmNoZWNrVmFsaWQoKX1nZXRDbGFzcygpe3JldHVybiAkaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19JGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9udj1uZXcgSmkoJGkudG9TZWdtZW50U3RyaW5ncyh0KSl9O2NsYXNzIHRye2NvbnN0cnVjdG9yKCl7dHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb2xsZWN0TGluZXModCl7Zm9yKGxldCBlPXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLmNvbGxlY3RMaW5lRWRnZShuLHQsdGhpcy5fbGluZUVkZ2VzTGlzdCksdGhpcy5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2Uobix0LHRoaXMuX2xpbmVFZGdlc0xpc3QpfX1sYWJlbElzb2xhdGVkTGluZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9vcC5nZXRBcmdHZW9tZXRyeShlKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9YnVpbGQodCl7cmV0dXJuIHRoaXMuZmluZENvdmVyZWRMaW5lRWRnZXMoKSx0aGlzLmNvbGxlY3RMaW5lcyh0KSx0aGlzLmJ1aWxkTGluZXModCksdGhpcy5fcmVzdWx0TGluZUxpc3R9Y29sbGVjdExpbmVFZGdlKHQsZSxuKXtjb25zdCBzPXQuZ2V0TGFiZWwoKSxpPXQuZ2V0RWRnZSgpO3QuaXNMaW5lRWRnZSgpJiYodC5pc1Zpc2l0ZWQoKXx8IWNyLmlzUmVzdWx0T2ZPcChzLGUpfHxpLmlzQ292ZXJlZCgpfHwobi5hZGQoaSksdC5zZXRWaXNpdGVkRWRnZSghMCkpKX1maW5kQ292ZXJlZExpbmVFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkuZmluZENvdmVyZWRMaW5lRWRnZXMoKX1mb3IobGV0IHQ9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRFZGdlKCk7aWYoZS5pc0xpbmVFZGdlKCkmJiFuLmlzQ292ZXJlZFNldCgpKXtjb25zdCB0PXRoaXMuX29wLmlzQ292ZXJlZEJ5QShlLmdldENvb3JkaW5hdGUoKSk7bi5zZXRDb3ZlcmVkKHQpfX19bGFiZWxJc29sYXRlZExpbmVzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRMYWJlbCgpO3QuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbElzb2xhdGVkTGluZSh0LDApOnRoaXMubGFiZWxJc29sYXRlZExpbmUodCwxKSl9fWJ1aWxkTGluZXModCl7Zm9yKGxldCB0PXRoaXMuX2xpbmVFZGdlc0xpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj0oZS5nZXRMYWJlbCgpLHRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGUuZ2V0Q29vcmRpbmF0ZXMoKSkpO3RoaXMuX3Jlc3VsdExpbmVMaXN0LmFkZChuKSxlLnNldEluUmVzdWx0KCEwKX19Y29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlKHQsZSxuKXtjb25zdCBzPXQuZ2V0TGFiZWwoKTtyZXR1cm4gdC5pc0xpbmVFZGdlKCl8fHQuaXNWaXNpdGVkKCl8fHQuaXNJbnRlcmlvckFyZWFFZGdlKCl8fHQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKT9udWxsOih1LmlzVHJ1ZSghKHQuaXNJblJlc3VsdCgpfHx0LmdldFN5bSgpLmlzSW5SZXN1bHQoKSl8fCF0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpLHZvaWQoY3IuaXNSZXN1bHRPZk9wKHMsZSkmJmU9PT1jci5JTlRFUlNFQ1RJT04mJihuLmFkZCh0LmdldEVkZ2UoKSksdC5zZXRWaXNpdGVkRWRnZSghMCkpKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gdHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXRyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX29wPW51bGwsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5fcHRMb2NhdG9yPW51bGwsdGhpcy5fbGluZUVkZ2VzTGlzdD1uZXcgeCx0aGlzLl9yZXN1bHRMaW5lTGlzdD1uZXcgeDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9vcD10LHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1lLHRoaXMuX3B0TG9jYXRvcj1ufTtjbGFzcyBlcntjb25zdHJ1Y3Rvcigpe2VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKCk7aWYoIXRoaXMuX29wLmlzQ292ZXJlZEJ5TEEoZSkpe2NvbnN0IHQ9dGhpcy5fZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGUpO3RoaXMuX3Jlc3VsdFBvaW50TGlzdC5hZGQodCl9fWV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZighbi5pc0luUmVzdWx0KCkmJighbi5pc0luY2lkZW50RWRnZUluUmVzdWx0KCkmJigwPT09bi5nZXRFZGdlcygpLmdldERlZ3JlZSgpfHx0PT09Y3IuSU5URVJTRUNUSU9OKSkpe2NvbnN0IGU9bi5nZXRMYWJlbCgpO2NyLmlzUmVzdWx0T2ZPcChlLHQpJiZ0aGlzLmZpbHRlckNvdmVyZWROb2RlVG9Qb2ludChuKX19fWJ1aWxkKHQpe3JldHVybiB0aGlzLmV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXModCksdGhpcy5fcmVzdWx0UG9pbnRMaXN0fWdldENsYXNzKCl7cmV0dXJuIGVyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1lci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9vcD1udWxsLHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3Jlc3VsdFBvaW50TGlzdD1uZXcgeDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9vcD10LHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1lfTtjbGFzcyBucntjb25zdHJ1Y3Rvcigpe3RoaXMuX2lzRmlyc3Q9ITAsdGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQ9NTMsdGhpcy5fY29tbW9uQml0cz1uZXcgcyx0aGlzLl9jb21tb25TaWduRXhwPW51bGx9Z2V0Q29tbW9uKCl7cmV0dXJuIGkubG9uZ0JpdHNUb0RvdWJsZSh0aGlzLl9jb21tb25CaXRzKX1hZGQodCl7Y29uc3QgZT1pLmRvdWJsZVRvTG9uZ0JpdHModCk7cmV0dXJuIHRoaXMuX2lzRmlyc3Q/KHRoaXMuX2NvbW1vbkJpdHM9ZSx0aGlzLl9jb21tb25TaWduRXhwPW5yLnNpZ25FeHBCaXRzKHRoaXMuX2NvbW1vbkJpdHMpLHRoaXMuX2lzRmlyc3Q9ITEsbnVsbCk6bnIuc2lnbkV4cEJpdHMoZSkhPT10aGlzLl9jb21tb25TaWduRXhwPyh0aGlzLl9jb21tb25CaXRzLmhpZ2g9MCx0aGlzLl9jb21tb25CaXRzLmxvdz0wLG51bGwpOih0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudD1uci5udW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHRoaXMuX2NvbW1vbkJpdHMsZSksdm9pZCh0aGlzLl9jb21tb25CaXRzPW5yLnplcm9Mb3dlckJpdHModGhpcy5fY29tbW9uQml0cyw2NC0oMTIrdGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQpKSkpfXRvU3RyaW5nKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9aS5sb25nQml0c1RvRG91YmxlKHQpLG49XCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIrcy50b0JpbmFyeVN0cmluZyh0KSxyPW4uc3Vic3RyaW5nKG4ubGVuZ3RoLTY0KTtyZXR1cm4gci5zdWJzdHJpbmcoMCwxKStcIiAgXCIrci5zdWJzdHJpbmcoMSwxMikrXCIoZXhwKSBcIityLnN1YnN0cmluZygxMikrXCIgWyBcIitlK1wiIF1cIn19Z2V0Q2xhc3MoKXtyZXR1cm4gbnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119c3RhdGljIGdldEJpdCh0LGUpe2NvbnN0IG49MTw8ZSUzMjtyZXR1cm4gZTwzMj8wIT0odC5sb3cmbik/MTowOjAhPSh0LmhpZ2gmbik/MTowfXN0YXRpYyBzaWduRXhwQml0cyh0KXtyZXR1cm4gdC5oaWdoPj4+MjB9c3RhdGljIHplcm9Mb3dlckJpdHModCxlKXtsZXQgbj1cImxvd1wiO2lmKGU+MzImJih0Lmxvdz0wLGUlPTMyLG49XCJoaWdoXCIpLGU+MCl7Y29uc3Qgcz1lPDMyP34oKDE8PGUpLTEpOjA7dFtuXSY9c31yZXR1cm4gdH1zdGF0aWMgbnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyh0LGUpe2xldCBuPTA7Zm9yKGxldCBzPTUyO3M+PTA7cy0tKXtpZihuci5nZXRCaXQodCxzKSE9PW5yLmdldEJpdChlLHMpKXJldHVybiBuO24rK31yZXR1cm4gNTJ9fWNsYXNzIHNye2NvbnN0cnVjdG9yKCl7c3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGRDb21tb25CaXRzKHQpe2NvbnN0IGU9bmV3IHJyKHRoaXMuX2NvbW1vbkNvb3JkKTt0LmFwcGx5KGUpLHQuZ2VvbWV0cnlDaGFuZ2VkKCl9cmVtb3ZlQ29tbW9uQml0cyh0KXtpZigwPT09dGhpcy5fY29tbW9uQ29vcmQueCYmMD09PXRoaXMuX2NvbW1vbkNvb3JkLnkpcmV0dXJuIHQ7Y29uc3QgZT1uZXcgZyh0aGlzLl9jb21tb25Db29yZCk7ZS54PS1lLngsZS55PS1lLnk7Y29uc3Qgbj1uZXcgcnIoZSk7cmV0dXJuIHQuYXBwbHkobiksdC5nZW9tZXRyeUNoYW5nZWQoKSx0fWdldENvbW1vbkNvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fY29tbW9uQ29vcmR9YWRkKHQpe3QuYXBwbHkodGhpcy5fY2NGaWx0ZXIpLHRoaXMuX2NvbW1vbkNvb3JkPXRoaXMuX2NjRmlsdGVyLmdldENvbW1vbkNvb3JkaW5hdGUoKX1nZXRDbGFzcygpe3JldHVybiBzcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgaXJ7Y29uc3RydWN0b3IoKXtpci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt0aGlzLl9jb21tb25CaXRzWC5hZGQodC54KSx0aGlzLl9jb21tb25CaXRzWS5hZGQodC55KX1nZXRDb21tb25Db29yZGluYXRlKCl7cmV0dXJuIG5ldyBnKHRoaXMuX2NvbW1vbkJpdHNYLmdldENvbW1vbigpLHRoaXMuX2NvbW1vbkJpdHNZLmdldENvbW1vbigpKX1nZXRDbGFzcygpe3JldHVybiBpcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQl19fWlyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2NvbW1vbkJpdHNYPW5ldyBucix0aGlzLl9jb21tb25CaXRzWT1uZXcgbnJ9O2NsYXNzIHJye2NvbnN0cnVjdG9yKCl7cnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCxlKXtjb25zdCBuPXQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLnRyYW5zLngscz10LmdldE9yZGluYXRlKGUsMSkrdGhpcy50cmFucy55O3Quc2V0T3JkaW5hdGUoZSwwLG4pLHQuc2V0T3JkaW5hdGUoZSwxLHMpfWlzRG9uZSgpe3JldHVybiExfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITB9Z2V0Q2xhc3MoKXtyZXR1cm4gcnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2R0XX19cnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy50cmFucz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMudHJhbnM9dH0sc3IuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlcj1pcixzci5UcmFuc2xhdGVyPXJyLHNyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2NvbW1vbkNvb3JkPW51bGwsdGhpcy5fY2NGaWx0ZXI9bmV3IGlyfTtjbGFzcyBvcntjb25zdHJ1Y3Rvcigpe29yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG92ZXJsYXlPcCh0LGUsbil7cmV0dXJuIG5ldyBvcih0LGUpLmdldFJlc3VsdEdlb21ldHJ5KG4pfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBvci5vdmVybGF5T3AodCxlLGNyLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIG9yLm92ZXJsYXlPcCh0LGUsY3IuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe3JldHVybiBvci5vdmVybGF5T3AodCxlLGNyLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7cmV0dXJuIG9yLm92ZXJsYXlPcCh0LGUsY3IuRElGRkVSRU5DRSl9c2VsZlNuYXAodCl7cmV0dXJuIG5ldyBXaSh0KS5zbmFwVG8odCx0aGlzLl9zbmFwVG9sZXJhbmNlKX1yZW1vdmVDb21tb25CaXRzKHQpe3RoaXMuX2Nicj1uZXcgc3IsdGhpcy5fY2JyLmFkZCh0WzBdKSx0aGlzLl9jYnIuYWRkKHRbMV0pO2NvbnN0IGU9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIGVbMF09dGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHModFswXS5jb3B5KCkpLGVbMV09dGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHModFsxXS5jb3B5KCkpLGV9cHJlcGFyZVJlc3VsdCh0KXtyZXR1cm4gdGhpcy5fY2JyLmFkZENvbW1vbkJpdHModCksdH1nZXRSZXN1bHRHZW9tZXRyeSh0KXtjb25zdCBlPXRoaXMuc25hcCh0aGlzLl9nZW9tKSxuPWNyLm92ZXJsYXlPcChlWzBdLGVbMV0sdCk7cmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChuKX1jaGVja1ZhbGlkKHQpe3QuaXNWYWxpZCgpfHxPLm91dC5wcmludGxuKFwiU25hcHBlZCBnZW9tZXRyeSBpcyBpbnZhbGlkXCIpfWNvbXB1dGVTbmFwVG9sZXJhbmNlKCl7dGhpcy5fc25hcFRvbGVyYW5jZT1XaS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdKX1zbmFwKHQpe2NvbnN0IGU9dGhpcy5yZW1vdmVDb21tb25CaXRzKHQpO3JldHVybiBXaS5zbmFwKGVbMF0sZVsxXSx0aGlzLl9zbmFwVG9sZXJhbmNlKX1nZXRDbGFzcygpe3JldHVybiBvcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19b3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5fY2JyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbVswXT10LHRoaXMuX2dlb21bMV09ZSx0aGlzLmNvbXB1dGVTbmFwVG9sZXJhbmNlKCl9O2NsYXNzIGxye2NvbnN0cnVjdG9yKCl7bHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb3ZlcmxheU9wKHQsZSxuKXtyZXR1cm4gbmV3IGxyKHQsZSkuZ2V0UmVzdWx0R2VvbWV0cnkobil9c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuVU5JT04pfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtyZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuU1lNRElGRkVSRU5DRSl9c3RhdGljIGRpZmZlcmVuY2UodCxlKXtyZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5ESUZGRVJFTkNFKX1nZXRSZXN1bHRHZW9tZXRyeSh0KXtsZXQgZT1udWxsLG49ITEscz1udWxsO3RyeXtlPWNyLm92ZXJsYXlPcCh0aGlzLl9nZW9tWzBdLHRoaXMuX2dlb21bMV0sdCksITAmJihuPSEwKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBjKSl0aHJvdyB0O3M9dH1pZighbil0cnl7ZT1vci5vdmVybGF5T3AodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdLHQpfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBjP3M6dH1yZXR1cm4gZX1nZXRDbGFzcygpe3JldHVybiBscn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tWzBdPXQsdGhpcy5fZ2VvbVsxXT1lfTtjbGFzcyBhcntjb25zdHJ1Y3Rvcigpe2FyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0QXJnR2VvbWV0cnkodCl7cmV0dXJuIHRoaXMuX2FyZ1t0XS5nZXRHZW9tZXRyeSgpfXNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHQpe3RoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsPXQsdGhpcy5fbGkuc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWwpfWdldENsYXNzKCl7cmV0dXJuIGFyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1hci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9saT1uZXcgdGUsdGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9hcmc9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuX2FyZz1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSx0aGlzLl9hcmdbMF09bmV3IFFuKDAsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsVi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3QuZ2V0UHJlY2lzaW9uTW9kZWwoKS5jb21wYXJlVG8oZS5nZXRQcmVjaXNpb25Nb2RlbCgpKT49MD90aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKSk6dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihlLmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuX2FyZz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9hcmdbMF09bmV3IFFuKDAsdCxuKSx0aGlzLl9hcmdbMV09bmV3IFFuKDEsZSxuKX19O2NsYXNzIGNyIGV4dGVuZHMgYXJ7Y29uc3RydWN0b3IoKXtzdXBlcigpLGNyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG92ZXJsYXlPcCh0LGUsbil7cmV0dXJuIG5ldyBjcih0LGUpLmdldFJlc3VsdEdlb21ldHJ5KG4pfXN0YXRpYyB1bmlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiBjci5jcmVhdGVFbXB0eVJlc3VsdChjci5VTklPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpdGhyb3cgbmV3IG4oXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIik7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuVU5JT04pfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpcmV0dXJuIGNyLmNyZWF0ZUVtcHR5UmVzdWx0KGNyLklOVEVSU0VDVElPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7Y29uc3Qgbj1lO3JldHVybiBnZS5tYXAodCxuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2ZlXX1tYXAodCl7cmV0dXJuIGNyLmludGVyc2VjdGlvbih0LG4pfX0pfXJldHVybiBsci5vdmVybGF5T3AodCxlLGNyLklOVEVSU0VDVElPTil9c3RhdGljIHN5bURpZmZlcmVuY2UodCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gY3IuY3JlYXRlRW1wdHlSZXN1bHQoY3IuU1lNRElGRkVSRU5DRSx0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpdGhyb3cgbmV3IG4oXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIik7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuU1lNRElGRkVSRU5DRSl9c3RhdGljIHJlc3VsdERpbWVuc2lvbih0LGUsbil7Y29uc3Qgcz1lLmdldERpbWVuc2lvbigpLGk9bi5nZXREaW1lbnNpb24oKTtsZXQgcj0tMTtzd2l0Y2godCl7Y2FzZSBjci5JTlRFUlNFQ1RJT046cj1NYXRoLm1pbihzLGkpO2JyZWFrO2Nhc2UgY3IuVU5JT046cj1NYXRoLm1heChzLGkpO2JyZWFrO2Nhc2UgY3IuRElGRkVSRU5DRTpyPXM7YnJlYWs7Y2FzZSBjci5TWU1ESUZGRVJFTkNFOnI9TWF0aC5tYXgocyxpKX1yZXR1cm4gcn1zdGF0aWMgY3JlYXRlRW1wdHlSZXN1bHQodCxlLG4scyl7bGV0IGk9bnVsbDtzd2l0Y2goY3IucmVzdWx0RGltZW5zaW9uKHQsZSxuKSl7Y2FzZS0xOmk9cy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTticmVhaztjYXNlIDA6aT1zLmNyZWF0ZVBvaW50KCk7YnJlYWs7Y2FzZSAxOmk9cy5jcmVhdGVMaW5lU3RyaW5nKCk7YnJlYWs7Y2FzZSAyOmk9cy5jcmVhdGVQb2x5Z29uKCl9cmV0dXJuIGl9c3RhdGljIGRpZmZlcmVuY2UodCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gY3IuY3JlYXRlRW1wdHlSZXN1bHQoY3IuRElGRkVSRU5DRSx0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl0aHJvdyBuZXcgbihcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKTtyZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5ESUZGRVJFTkNFKX1zdGF0aWMgaXNSZXN1bHRPZk9wKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRMb2NhdGlvbigwKSxzPXQuZ2V0TG9jYXRpb24oMSk7cmV0dXJuIGNyLmlzUmVzdWx0T2ZPcChuLHMsZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtjb25zdCBuPWFyZ3VtZW50c1syXTtzd2l0Y2godD09PW5lLkJPVU5EQVJZJiYodD1uZS5JTlRFUklPUiksZT09PW5lLkJPVU5EQVJZJiYoZT1uZS5JTlRFUklPUiksbil7Y2FzZSBjci5JTlRFUlNFQ1RJT046cmV0dXJuIHQ9PT1uZS5JTlRFUklPUiYmZT09PW5lLklOVEVSSU9SO2Nhc2UgY3IuVU5JT046cmV0dXJuIHQ9PT1uZS5JTlRFUklPUnx8ZT09PW5lLklOVEVSSU9SO2Nhc2UgY3IuRElGRkVSRU5DRTpyZXR1cm4gdD09PW5lLklOVEVSSU9SJiZlIT09bmUuSU5URVJJT1I7Y2FzZSBjci5TWU1ESUZGRVJFTkNFOnJldHVybiB0PT09bmUuSU5URVJJT1ImJmUhPT1uZS5JTlRFUklPUnx8dCE9PW5lLklOVEVSSU9SJiZlPT09bmUuSU5URVJJT1J9cmV0dXJuITF9fWluc2VydFVuaXF1ZUVkZ2UodCl7Y29uc3QgZT10aGlzLl9lZGdlTGlzdC5maW5kRXF1YWxFZGdlKHQpO2lmKG51bGwhPT1lKXtjb25zdCBuPWUuZ2V0TGFiZWwoKTtsZXQgcz10LmdldExhYmVsKCk7ZS5pc1BvaW50d2lzZUVxdWFsKHQpfHwocz1uZXcgRm4odC5nZXRMYWJlbCgpKSxzLmZsaXAoKSk7Y29uc3QgaT1lLmdldERlcHRoKCk7aS5pc051bGwoKSYmaS5hZGQobiksaS5hZGQocyksbi5tZXJnZShzKX1lbHNlIHRoaXMuX2VkZ2VMaXN0LmFkZCh0KX1nZXRHcmFwaCgpe3JldHVybiB0aGlzLl9ncmFwaH1jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRTeW0oKTtlLmlzSW5SZXN1bHQoKSYmbi5pc0luUmVzdWx0KCkmJihlLnNldEluUmVzdWx0KCExKSxuLnNldEluUmVzdWx0KCExKSl9fWlzQ292ZXJlZEJ5TEEodCl7cmV0dXJuISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMuX3Jlc3VsdExpbmVMaXN0KXx8ISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMuX3Jlc3VsdFBvbHlMaXN0KX1jb21wdXRlR2VvbWV0cnkodCxlLG4scyl7Y29uc3QgaT1uZXcgeDtyZXR1cm4gaS5hZGRBbGwodCksaS5hZGRBbGwoZSksaS5hZGRBbGwobiksaS5pc0VtcHR5KCk/Y3IuY3JlYXRlRW1wdHlSZXN1bHQocyx0aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKSx0aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKSx0aGlzLl9nZW9tRmFjdCk6dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShpKX1tZXJnZVN5bUxhYmVscygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLm1lcmdlU3ltTGFiZWxzKCl9fWlzQ292ZXJlZCh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpO2lmKHRoaXMuX3B0TG9jYXRvci5sb2NhdGUodCxlKSE9PW5lLkVYVEVSSU9SKXJldHVybiEwfXJldHVybiExfXJlcGxhY2VDb2xsYXBzZWRFZGdlcygpe2NvbnN0IHQ9bmV3IHg7Zm9yKGxldCBlPXRoaXMuX2VkZ2VMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24uaXNDb2xsYXBzZWQoKSYmKGUucmVtb3ZlKCksdC5hZGQobi5nZXRDb2xsYXBzZWRFZGdlKCkpKX10aGlzLl9lZGdlTGlzdC5hZGRBbGwodCl9dXBkYXRlTm9kZUxhYmVsbGluZygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRFZGdlcygpLmdldExhYmVsKCk7ZS5nZXRMYWJlbCgpLm1lcmdlKG4pfX1nZXRSZXN1bHRHZW9tZXRyeSh0KXtyZXR1cm4gdGhpcy5jb21wdXRlT3ZlcmxheSh0KSx0aGlzLl9yZXN1bHRHZW9tfWluc2VydFVuaXF1ZUVkZ2VzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZSh0KX19Y29tcHV0ZU92ZXJsYXkodCl7dGhpcy5jb3B5UG9pbnRzKDApLHRoaXMuY29weVBvaW50cygxKSx0aGlzLl9hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSksdGhpcy5fYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpLHRoaXMuX2FyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5fYXJnWzFdLHRoaXMuX2xpLCEwKTtjb25zdCBlPW5ldyB4O3RoaXMuX2FyZ1swXS5jb21wdXRlU3BsaXRFZGdlcyhlKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNwbGl0RWRnZXMoZSksdGhpcy5pbnNlcnRVbmlxdWVFZGdlcyhlKSx0aGlzLmNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCksdGhpcy5yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKSwkaS5jaGVja1ZhbGlkKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuX2dyYXBoLmFkZEVkZ2VzKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuY29tcHV0ZUxhYmVsbGluZygpLHRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZXMoKSx0aGlzLmZpbmRSZXN1bHRBcmVhRWRnZXModCksdGhpcy5jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcygpO2NvbnN0IG49bmV3IGVpKHRoaXMuX2dlb21GYWN0KTtuLmFkZCh0aGlzLl9ncmFwaCksdGhpcy5fcmVzdWx0UG9seUxpc3Q9bi5nZXRQb2x5Z29ucygpO2NvbnN0IHM9bmV3IHRyKHRoaXMsdGhpcy5fZ2VvbUZhY3QsdGhpcy5fcHRMb2NhdG9yKTt0aGlzLl9yZXN1bHRMaW5lTGlzdD1zLmJ1aWxkKHQpO2NvbnN0IGk9bmV3IGVyKHRoaXMsdGhpcy5fZ2VvbUZhY3QsdGhpcy5fcHRMb2NhdG9yKTt0aGlzLl9yZXN1bHRQb2ludExpc3Q9aS5idWlsZCh0KSx0aGlzLl9yZXN1bHRHZW9tPXRoaXMuY29tcHV0ZUdlb21ldHJ5KHRoaXMuX3Jlc3VsdFBvaW50TGlzdCx0aGlzLl9yZXN1bHRMaW5lTGlzdCx0aGlzLl9yZXN1bHRQb2x5TGlzdCx0KX1sYWJlbEluY29tcGxldGVOb2RlKHQsZSl7Y29uc3Qgbj10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX2FyZ1tlXS5nZXRHZW9tZXRyeSgpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX1jb3B5UG9pbnRzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0Tm9kZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuX2dyYXBoLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpLnNldExhYmVsKHQsbi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpKX19ZmluZFJlc3VsdEFyZWFFZGdlcyh0KXtmb3IobGV0IGU9dGhpcy5fZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKTtzLmlzQXJlYSgpJiYhbi5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmY3IuaXNSZXN1bHRPZk9wKHMuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCkscy5nZXRMb2NhdGlvbigxLFBuLlJJR0hUKSx0KSYmbi5zZXRJblJlc3VsdCghMCl9fWNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCl7Zm9yKGxldCB0PXRoaXMuX2VkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpLHM9ZS5nZXREZXB0aCgpO2lmKCFzLmlzTnVsbCgpKXtzLm5vcm1hbGl6ZSgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspbi5pc051bGwodCl8fCFuLmlzQXJlYSgpfHxzLmlzTnVsbCh0KXx8KDA9PT1zLmdldERlbHRhKHQpP24udG9MaW5lKHQpOih1LmlzVHJ1ZSghcy5pc051bGwodCxQbi5MRUZUKSxcImRlcHRoIG9mIExFRlQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbih0LFBuLkxFRlQscy5nZXRMb2NhdGlvbih0LFBuLkxFRlQpKSx1LmlzVHJ1ZSghcy5pc051bGwodCxQbi5SSUdIVCksXCJkZXB0aCBvZiBSSUdIVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKSxuLnNldExvY2F0aW9uKHQsUG4uUklHSFQscy5nZXRMb2NhdGlvbih0LFBuLlJJR0hUKSkpKX19fWNvbXB1dGVMYWJlbGxpbmcoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuX2FyZyl9dGhpcy5tZXJnZVN5bUxhYmVscygpLHRoaXMudXBkYXRlTm9kZUxhYmVsbGluZygpfWxhYmVsSW5jb21wbGV0ZU5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7ZS5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUoZSwwKTp0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUoZSwxKSksZS5nZXRFZGdlcygpLnVwZGF0ZUxhYmVsbGluZyhuKX19aXNDb3ZlcmVkQnlBKHQpe3JldHVybiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLl9yZXN1bHRQb2x5TGlzdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gY3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0TG9jYXRvcj1uZXcgX24sdGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9yZXN1bHRHZW9tPW51bGwsdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9lZGdlTGlzdD1uZXcgZGksdGhpcy5fcmVzdWx0UG9seUxpc3Q9bmV3IHgsdGhpcy5fcmVzdWx0TGluZUxpc3Q9bmV3IHgsdGhpcy5fcmVzdWx0UG9pbnRMaXN0PW5ldyB4O2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLl9ncmFwaD1uZXcgWm4obmV3IHVpKSx0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKX0sY3IuSU5URVJTRUNUSU9OPTEsY3IuVU5JT049Mixjci5ESUZGRVJFTkNFPTMsY3IuU1lNRElGRkVSRU5DRT00O3ZhciBocj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxzbmFwOktpLE92ZXJsYXlPcDpjcn0pO2NsYXNzIHVyIGV4dGVuZHMgYml7Y29uc3RydWN0b3IoKXtzdXBlcigpLHVyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fWlzSW5SaW5nKCl7cmV0dXJuIG51bGwhPT10aGlzLl9lZGdlUmluZ31zZXRSaW5nKHQpe3RoaXMuX2VkZ2VSaW5nPXR9c2V0TGFiZWwodCl7dGhpcy5fbGFiZWw9dH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1nZXRSaW5nKCl7cmV0dXJuIHRoaXMuX2VkZ2VSaW5nfWdldENsYXNzKCl7cmV0dXJuIHVyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX11ci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9lZGdlUmluZz1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9sYWJlbD0tMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtiaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuLHMpfTtjbGFzcyBnciBleHRlbmRzIERpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxnci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldExpbmUoKXtyZXR1cm4gdGhpcy5fbGluZX1nZXRDbGFzcygpe3JldHVybiBncn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Z3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmU9dH07Y2xhc3MgZHJ7Y29uc3RydWN0b3IoKXtkci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaW5kRGlmZmVyZW50UG9pbnQodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZighdFtuXS5lcXVhbHMoZSkpcmV0dXJuIHRbbl07cmV0dXJuIG51bGx9dmlzaXRJbnRlcmlvclJpbmcodCxlKXtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxzPW5bMF0saT1kci5maW5kRGlmZmVyZW50UG9pbnQobixzKSxyPWUuZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24ocyxpKSxvPWUuZmluZEVkZ2VFbmQocik7bGV0IGw9bnVsbDtvLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCk9PT1uZS5JTlRFUklPUj9sPW86by5nZXRTeW0oKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsUG4uUklHSFQpPT09bmUuSU5URVJJT1ImJihsPW8uZ2V0U3ltKCkpLHUuaXNUcnVlKG51bGwhPT1sLFwidW5hYmxlIHRvIGZpbmQgZGlyRWRnZSB3aXRoIEludGVyaW9yIG9uIFJIU1wiKSx0aGlzLnZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlcyhsKX12aXNpdFNoZWxsSW50ZXJpb3JzKHQsZSl7aWYodCBpbnN0YW5jZW9mIGJ0KXtjb25zdCBuPXQ7dGhpcy52aXNpdEludGVyaW9yUmluZyhuLmdldEV4dGVyaW9yUmluZygpLGUpfWlmKHQgaW5zdGFuY2VvZiBBdCl7Y29uc3Qgbj10O2ZvcihsZXQgdD0wO3Q8bi5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBzPW4uZ2V0R2VvbWV0cnlOKHQpO3RoaXMudmlzaXRJbnRlcmlvclJpbmcocy5nZXRFeHRlcmlvclJpbmcoKSxlKX19fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fZGlzY29ubmVjdGVkUmluZ2Nvb3JkfXNldEludGVyaW9yRWRnZXNJblJlc3VsdCh0KXtmb3IobGV0IGU9dC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLFBuLlJJR0hUKT09PW5lLklOVEVSSU9SJiZ0LnNldEluUmVzdWx0KCEwKX19dmlzaXRMaW5rZWREaXJlY3RlZEVkZ2VzKHQpe2NvbnN0IGU9dDtsZXQgbj10O2Rve3UuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBEaXJlY3RlZCBFZGdlXCIpLG4uc2V0VmlzaXRlZCghMCksbj1uLmdldE5leHQoKX13aGlsZShuIT09ZSl9YnVpbGRFZGdlUmluZ3ModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzSW5SZXN1bHQoKSYmbnVsbD09PXQuZ2V0RWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgdGkodCx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO24ubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7Y29uc3Qgcz1uLmJ1aWxkTWluaW1hbFJpbmdzKCk7ZS5hZGRBbGwocyl9fXJldHVybiBlfWhhc1VudmlzaXRlZFNoZWxsRWRnZSh0KXtmb3IobGV0IGU9MDtlPHQuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10LmdldChlKTtpZihuLmlzSG9sZSgpKWNvbnRpbnVlO2NvbnN0IHM9bi5nZXRFZGdlcygpO2xldCBpPXMuZ2V0KDApO2lmKGkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLFBuLlJJR0hUKT09PW5lLklOVEVSSU9SKWZvcihsZXQgdD0wO3Q8cy5zaXplKCk7dCsrKWlmKGk9cy5nZXQodCksIWkuaXNWaXNpdGVkKCkpcmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZD1pLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX1pc0ludGVyaW9yc0Nvbm5lY3RlZCgpe2NvbnN0IHQ9bmV3IHg7dGhpcy5fZ2VvbUdyYXBoLmNvbXB1dGVTcGxpdEVkZ2VzKHQpO2NvbnN0IGU9bmV3IFpuKG5ldyB1aSk7ZS5hZGRFZGdlcyh0KSx0aGlzLnNldEludGVyaW9yRWRnZXNJblJlc3VsdChlKSxlLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCk7Y29uc3Qgbj10aGlzLmJ1aWxkRWRnZVJpbmdzKGUuZ2V0RWRnZUVuZHMoKSk7cmV0dXJuIHRoaXMudmlzaXRTaGVsbEludGVyaW9ycyh0aGlzLl9nZW9tR3JhcGguZ2V0R2VvbWV0cnkoKSxlKSwhdGhpcy5oYXNVbnZpc2l0ZWRTaGVsbEVkZ2Uobil9Z2V0Q2xhc3MoKXtyZXR1cm4gZHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWRyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb21ldHJ5RmFjdG9yeT1uZXcgSHQsdGhpcy5fZ2VvbUdyYXBoPW51bGwsdGhpcy5fZGlzY29ubmVjdGVkUmluZ2Nvb3JkPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUdyYXBoPXR9O2NsYXNzIF9ye2NvbnN0cnVjdG9yKCl7X3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVFZGdlRW5kRm9yTmV4dCh0LGUsbixzKXtjb25zdCBpPW4uc2VnbWVudEluZGV4KzE7aWYoaT49dC5nZXROdW1Qb2ludHMoKSYmbnVsbD09PXMpcmV0dXJuIG51bGw7bGV0IHI9dC5nZXRDb29yZGluYXRlKGkpO251bGwhPT1zJiZzLnNlZ21lbnRJbmRleD09PW4uc2VnbWVudEluZGV4JiYocj1zLmNvb3JkKTtjb25zdCBvPW5ldyBIbih0LG4uY29vcmQscixuZXcgRm4odC5nZXRMYWJlbCgpKSk7ZS5hZGQobyl9Y3JlYXRlRWRnZUVuZEZvclByZXYodCxlLG4scyl7bGV0IGk9bi5zZWdtZW50SW5kZXg7aWYoMD09PW4uZGlzdCl7aWYoMD09PWkpcmV0dXJuIG51bGw7aS0tfWxldCByPXQuZ2V0Q29vcmRpbmF0ZShpKTtudWxsIT09cyYmcy5zZWdtZW50SW5kZXg+PWkmJihyPXMuY29vcmQpO2NvbnN0IG89bmV3IEZuKHQuZ2V0TGFiZWwoKSk7by5mbGlwKCk7Y29uc3QgbD1uZXcgSG4odCxuLmNvb3JkLHIsbyk7ZS5hZGQobCl9Y29tcHV0ZUVkZ2VFbmRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHg7Zm9yKGxldCBuPXQ7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuY29tcHV0ZUVkZ2VFbmRzKHQsZSl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpO24uYWRkRW5kcG9pbnRzKCk7Y29uc3Qgcz1uLml0ZXJhdG9yKCk7bGV0IGk9bnVsbCxyPW51bGw7aWYoIXMuaGFzTmV4dCgpKXJldHVybiBudWxsO2xldCBvPXMubmV4dCgpO2Rve2k9cixyPW8sbz1udWxsLHMuaGFzTmV4dCgpJiYobz1zLm5leHQoKSksbnVsbCE9PXImJih0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JQcmV2KHQsZSxyLGkpLHRoaXMuY3JlYXRlRWRnZUVuZEZvck5leHQodCxlLHIsbykpfXdoaWxlKG51bGwhPT1yKX19Z2V0Q2xhc3MoKXtyZXR1cm4gX3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fV9yLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgZnIgZXh0ZW5kcyBIbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnQodCl7dGhpcy5fZWRnZUVuZHMuYWRkKHQpfXByaW50KHQpe3QucHJpbnRsbihcIkVkZ2VFbmRCdW5kbGUtLVxceDNlIExhYmVsOiBcIit0aGlzLl9sYWJlbCk7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpLHQucHJpbnRsbigpfX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlRW5kcy5pdGVyYXRvcigpfWdldEVkZ2VFbmRzKCl7cmV0dXJuIHRoaXMuX2VkZ2VFbmRzfWNvbXB1dGVMYWJlbE9uKHQsZSl7bGV0IG49MCxzPSExO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBpPWUubmV4dCgpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7aT09PW5lLkJPVU5EQVJZJiZuKyssaT09PW5lLklOVEVSSU9SJiYocz0hMCl9bGV0IGk9bmUuTk9ORTtzJiYoaT1uZS5JTlRFUklPUiksbj4wJiYoaT1Rbi5kZXRlcm1pbmVCb3VuZGFyeShlLG4pKSx0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGkpfWNvbXB1dGVMYWJlbFNpZGUodCxlKXtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtpZihzLmdldExhYmVsKCkuaXNBcmVhKCkpe2NvbnN0IG49cy5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQsZSk7aWYobj09PW5lLklOVEVSSU9SKXJldHVybiB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUsbmUuSU5URVJJT1IpLG51bGw7bj09PW5lLkVYVEVSSU9SJiZ0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUsbmUuRVhURVJJT1IpfX19Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Y29tcHV0ZUxhYmVsU2lkZXModCl7dGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsUG4uTEVGVCksdGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsUG4uUklHSFQpfXVwZGF0ZUlNKHQpe1VuLnVwZGF0ZUlNKHRoaXMuX2xhYmVsLHQpfWNvbXB1dGVMYWJlbCh0KXtsZXQgZT0hMTtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0TGFiZWwoKS5pc0FyZWEoKSYmKGU9ITApfXRoaXMuX2xhYmVsPWU/bmV3IEZuKG5lLk5PTkUsbmUuTk9ORSxuZS5OT05FKTpuZXcgRm4obmUuTk9ORSk7Zm9yKGxldCBuPTA7bjwyO24rKyl0aGlzLmNvbXB1dGVMYWJlbE9uKG4sdCksZSYmdGhpcy5jb21wdXRlTGFiZWxTaWRlcyhuKX1nZXRDbGFzcygpe3JldHVybiBmcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZWRnZUVuZHM9bmV3IHgsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbnVsbCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtIbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQuZ2V0RWRnZSgpLHQuZ2V0Q29vcmRpbmF0ZSgpLHQuZ2V0RGlyZWN0ZWRDb29yZGluYXRlKCksbmV3IEZuKHQuZ2V0TGFiZWwoKSkpLHRoaXMuaW5zZXJ0KHQpfX07Y2xhc3MgcHIgZXh0ZW5kcyBjaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkscHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX11cGRhdGVJTSh0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkudXBkYXRlSU0odCl9fWluc2VydCh0KXtsZXQgZT10aGlzLl9lZGdlTWFwLmdldCh0KTtudWxsPT09ZT8oZT1uZXcgZnIodCksdGhpcy5pbnNlcnRFZGdlRW5kKHQsZSkpOmUuaW5zZXJ0KHQpfWdldENsYXNzKCl7cmV0dXJuIHByfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1wci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIG1yIGV4dGVuZHMga257Y29uc3RydWN0b3IoKXtzdXBlcigpLG1yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dXBkYXRlSU1Gcm9tRWRnZXModCl7dGhpcy5fZWRnZXMudXBkYXRlSU0odCl9Y29tcHV0ZUlNKHQpe3Quc2V0QXRMZWFzdElmVmFsaWQodGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oMCksdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oMSksMCl9Z2V0Q2xhc3MoKXtyZXR1cm4gbXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW1yLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2tuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX07Y2xhc3MgeXIgZXh0ZW5kcyBLbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCkseXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVOb2RlKHQpe3JldHVybiBuZXcgbXIodCxuZXcgcHIpfWdldENsYXNzKCl7cmV0dXJuIHlyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX15ci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHhye2NvbnN0cnVjdG9yKCl7eHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnRFZGdlRW5kcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGQodCl9fWdldE5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2Rlcy5pdGVyYXRvcigpfWNvcHlOb2Rlc0FuZExhYmVscyh0LGUpe2ZvcihsZXQgbj10LmdldE5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGROb2RlKHQuZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbChlLHQuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKSl9fWJ1aWxkKHQpe3RoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKHQsMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHModCwwKTtjb25zdCBlPShuZXcgX3IpLmNvbXB1dGVFZGdlRW5kcyh0LmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKGUpfWNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0LGUpe2ZvcihsZXQgbj10LmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxzPXQuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKTtmb3IobGV0IG49dC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLGk9dGhpcy5fbm9kZXMuYWRkTm9kZSh0LmNvb3JkKTtzPT09bmUuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KGUpOmkuZ2V0TGFiZWwoKS5pc051bGwoZSkmJmkuc2V0TGFiZWwoZSxuZS5JTlRFUklPUil9fX1nZXRDbGFzcygpe3JldHVybiB4cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbm9kZXM9bmV3IFhuKG5ldyB5cil9O2NsYXNzIEVye2NvbnN0cnVjdG9yKCl7RXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtpZighZS5nZXRFZGdlcygpLmlzQXJlYUxhYmVsc0NvbnNpc3RlbnQodGhpcy5fZ2VvbUdyYXBoKSlyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50PWUuZ2V0Q29vcmRpbmF0ZSgpLmNvcHkoKSwhMX1yZXR1cm4hMH1nZXRJbnZhbGlkUG9pbnQoKXtyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50fWhhc0R1cGxpY2F0ZVJpbmdzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVHcmFwaC5nZXROb2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2ZvcihsZXQgZT10Lm5leHQoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKHQuZ2V0RWRnZUVuZHMoKS5zaXplKCk+MSlyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50PXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGUoMCksITB9fXJldHVybiExfWlzTm9kZUNvbnNpc3RlbnRBcmVhKCl7Y29uc3QgdD10aGlzLl9nZW9tR3JhcGguY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMCwhMCk7cmV0dXJuIHQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMuX2ludmFsaWRQb2ludD10LmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOih0aGlzLl9ub2RlR3JhcGguYnVpbGQodGhpcy5fZ2VvbUdyYXBoKSx0aGlzLmlzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudCgpKX1nZXRDbGFzcygpe3JldHVybiBFcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bmV3IHRlLHRoaXMuX2dlb21HcmFwaD1udWxsLHRoaXMuX25vZGVHcmFwaD1uZXcgeHIsdGhpcy5faW52YWxpZFBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUdyYXBoPXR9O2NsYXNzIElye2NvbnN0cnVjdG9yKCl7SXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1idWlsZEluZGV4KCl7dGhpcy5faW5kZXg9bmV3IEVzO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcmluZ3Muc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9yaW5ncy5nZXQodCksbj1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTt0aGlzLl9pbmRleC5pbnNlcnQobixlKX19Z2V0TmVzdGVkUG9pbnQoKXtyZXR1cm4gdGhpcy5fbmVzdGVkUHR9aXNOb25OZXN0ZWQoKXt0aGlzLmJ1aWxkSW5kZXgoKTtmb3IobGV0IHQ9MDt0PHRoaXMuX3JpbmdzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fcmluZ3MuZ2V0KHQpLG49ZS5nZXRDb29yZGluYXRlcygpLHM9dGhpcy5faW5kZXgucXVlcnkoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpO2ZvcihsZXQgdD0wO3Q8cy5zaXplKCk7dCsrKXtjb25zdCBpPXMuZ2V0KHQpLHI9aS5nZXRDb29yZGluYXRlcygpO2lmKGU9PT1pKWNvbnRpbnVlO2lmKCFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSljb250aW51ZTtjb25zdCBvPUNyLmZpbmRQdE5vdE5vZGUobixpLHRoaXMuX2dyYXBoKTtpZihudWxsIT09byYmV2UuaXNJblJpbmcobyxyKSlyZXR1cm4gdGhpcy5fbmVzdGVkUHQ9bywhMX19cmV0dXJuITB9YWRkKHQpe3RoaXMuX3JpbmdzLmFkZCh0KSx0aGlzLl90b3RhbEVudi5leHBhbmRUb0luY2x1ZGUodC5nZXRFbnZlbG9wZUludGVybmFsKCkpfWdldENsYXNzKCl7cmV0dXJuIElyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Jci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ncmFwaD1udWxsLHRoaXMuX3JpbmdzPW5ldyB4LHRoaXMuX3RvdGFsRW52PW5ldyBOLHRoaXMuX2luZGV4PW51bGwsdGhpcy5fbmVzdGVkUHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ncmFwaD10fTtjbGFzcyBOcntjb25zdHJ1Y3Rvcigpe05yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0RXJyb3JUeXBlKCl7cmV0dXJuIHRoaXMuX2Vycm9yVHlwZX1nZXRNZXNzYWdlKCl7cmV0dXJuIE5yLmVyck1zZ1t0aGlzLl9lcnJvclR5cGVdfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9dG9TdHJpbmcoKXtsZXQgdD1cIlwiO3JldHVybiBudWxsIT09dGhpcy5fcHQmJih0PVwiIGF0IG9yIG5lYXIgcG9pbnQgXCIrdGhpcy5fcHQpLHRoaXMuZ2V0TWVzc2FnZSgpK3R9Z2V0Q2xhc3MoKXtyZXR1cm4gTnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU5yLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2Vycm9yVHlwZT1udWxsLHRoaXMuX3B0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO05yLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9lcnJvclR5cGU9dCxudWxsIT09ZSYmKHRoaXMuX3B0PWUuY29weSgpKX19LE5yLkVSUk9SPTAsTnIuUkVQRUFURURfUE9JTlQ9MSxOci5IT0xFX09VVFNJREVfU0hFTEw9MixOci5ORVNURURfSE9MRVM9MyxOci5ESVNDT05ORUNURURfSU5URVJJT1I9NCxOci5TRUxGX0lOVEVSU0VDVElPTj01LE5yLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT049NixOci5ORVNURURfU0hFTExTPTcsTnIuRFVQTElDQVRFX1JJTkdTPTgsTnIuVE9PX0ZFV19QT0lOVFM9OSxOci5JTlZBTElEX0NPT1JESU5BVEU9MTAsTnIuUklOR19OT1RfQ0xPU0VEPTExLE5yLmVyck1zZz1bXCJUb3BvbG9neSBWYWxpZGF0aW9uIEVycm9yXCIsXCJSZXBlYXRlZCBQb2ludFwiLFwiSG9sZSBsaWVzIG91dHNpZGUgc2hlbGxcIixcIkhvbGVzIGFyZSBuZXN0ZWRcIixcIkludGVyaW9yIGlzIGRpc2Nvbm5lY3RlZFwiLFwiU2VsZi1pbnRlcnNlY3Rpb25cIixcIlJpbmcgU2VsZi1pbnRlcnNlY3Rpb25cIixcIk5lc3RlZCBzaGVsbHNcIixcIkR1cGxpY2F0ZSBSaW5nc1wiLFwiVG9vIGZldyBkaXN0aW5jdCBwb2ludHMgaW4gZ2VvbWV0cnkgY29tcG9uZW50XCIsXCJJbnZhbGlkIENvb3JkaW5hdGVcIixcIlJpbmcgaXMgbm90IGNsb3NlZFwiXTtjbGFzcyBDcntjb25zdHJ1Y3Rvcigpe0NyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGZpbmRQdE5vdE5vZGUodCxlLG4pe2NvbnN0IHM9bi5maW5kRWRnZShlKS5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPXRbZV07aWYoIXMuaXNJbnRlcnNlY3Rpb24obikpcmV0dXJuIG59cmV0dXJuIG51bGx9c3RhdGljIGlzVmFsaWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgQ3IodCkuaXNWYWxpZCgpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIWkuaXNOYU4odC54KSYmKCFpLmlzSW5maW5pdGUodC54KSYmKCFpLmlzTmFOKHQueSkmJiFpLmlzSW5maW5pdGUodC55KSkpfX1jaGVja0ludmFsaWRDb29yZGluYXRlcygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCFDci5pc1ZhbGlkKHRbZV0pKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuSU5WQUxJRF9DT09SRElOQVRFLHRbZV0pLG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX1jaGVja0hvbGVzTm90TmVzdGVkKHQsZSl7Y29uc3Qgbj1uZXcgSXIoZSk7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl7Y29uc3Qgcz10LmdldEludGVyaW9yUmluZ04oZSk7bi5hZGQocyl9bi5pc05vbk5lc3RlZCgpfHwodGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLk5FU1RFRF9IT0xFUyxuLmdldE5lc3RlZFBvaW50KCkpKX1jaGVja0NvbnNpc3RlbnRBcmVhKHQpe2NvbnN0IGU9bmV3IEVyKHQpO2lmKCFlLmlzTm9kZUNvbnNpc3RlbnRBcmVhKCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5TRUxGX0lOVEVSU0VDVElPTixlLmdldEludmFsaWRQb2ludCgpKSxudWxsO2UuaGFzRHVwbGljYXRlUmluZ3MoKSYmKHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5EVVBMSUNBVEVfUklOR1MsZS5nZXRJbnZhbGlkUG9pbnQoKSkpfWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMuX3BhcmVudEdlb21ldHJ5KSxudWxsPT09dGhpcy5fdmFsaWRFcnJ9Y2hlY2tTaGVsbEluc2lkZUhvbGUodCxlLG4pe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRDb29yZGluYXRlcygpLHI9Q3IuZmluZFB0Tm90Tm9kZShzLGUsbik7aWYobnVsbCE9PXIpe2lmKCFXZS5pc0luUmluZyhyLGkpKXJldHVybiByfWNvbnN0IG89Q3IuZmluZFB0Tm90Tm9kZShpLHQsbik7aWYobnVsbCE9PW8pe3JldHVybiBXZS5pc0luUmluZyhvLHMpP286bnVsbH1yZXR1cm4gdS5zaG91bGROZXZlclJlYWNoSGVyZShcInBvaW50cyBpbiBzaGVsbCBhbmQgaG9sZSBhcHBlYXIgdG8gYmUgZXF1YWxcIiksbnVsbH1jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKHQpe2ZvcihsZXQgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZyh0LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19Y2hlY2tDb25uZWN0ZWRJbnRlcmlvcnModCl7Y29uc3QgZT1uZXcgZHIodCk7ZS5pc0ludGVyaW9yc0Nvbm5lY3RlZCgpfHwodGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLkRJU0NPTk5FQ1RFRF9JTlRFUklPUixlLmdldENvb3JkaW5hdGUoKSkpfWNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZyh0KXtjb25zdCBlPW5ldyBhdDtsZXQgbj0hMDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtpZihuKW49ITE7ZWxzZXtpZihlLmNvbnRhaW5zKHQuY29vcmQpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuUklOR19TRUxGX0lOVEVSU0VDVElPTix0LmNvb3JkKSxudWxsO2UuYWRkKHQuY29vcmQpfX19Y2hlY2tIb2xlc0luU2hlbGwodCxlKXtjb25zdCBuPXQuZ2V0RXh0ZXJpb3JSaW5nKCkscz1uZXcga2Uobik7Zm9yKGxldCBpPTA7aTx0LmdldE51bUludGVyaW9yUmluZygpO2krKyl7Y29uc3Qgcj10LmdldEludGVyaW9yUmluZ04oaSksbz1Dci5maW5kUHROb3ROb2RlKHIuZ2V0Q29vcmRpbmF0ZXMoKSxuLGUpO2lmKG51bGw9PT1vKXJldHVybiBudWxsO2lmKG5lLkVYVEVSSU9SPT09cy5sb2NhdGUobykpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5IT0xFX09VVFNJREVfU0hFTEwsbyksbnVsbH19Y2hlY2tUb29GZXdQb2ludHModCl7aWYodC5oYXNUb29GZXdQb2ludHMoKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLlRPT19GRVdfUE9JTlRTLHQuZ2V0SW52YWxpZFBvaW50KCkpLG51bGx9Z2V0VmFsaWRhdGlvbkVycm9yKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLl9wYXJlbnRHZW9tZXRyeSksdGhpcy5fdmFsaWRFcnJ9Y2hlY2tWYWxpZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IFFuKDAsdCk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgdGU7ZS5jb21wdXRlU2VsZk5vZGVzKG4sITAsITApLHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgUW4oMCx0KTt0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBidCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0KSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmdzKHQpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBRbigwLHQpO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYoIXRoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQmJih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKSlyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNJblNoZWxsKHQsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tIb2xlc05vdE5lc3RlZCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDt0aGlzLmNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhuKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmdzKG4pLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1jb25zdCBlPW5ldyBRbigwLHQpO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYoIXRoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQmJih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKSlyZXR1cm4gbnVsbDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKTtpZih0aGlzLmNoZWNrSG9sZXNJblNoZWxsKHMsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pO2lmKHRoaXMuY2hlY2tIb2xlc05vdE5lc3RlZChzLGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1pZih0aGlzLmNoZWNrU2hlbGxzTm90TmVzdGVkKHQsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO3RoaXMuY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnMoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF90KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZih0aGlzLmNoZWNrVmFsaWQobiksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5fdmFsaWRFcnI9bnVsbCx0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIE10KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBEdCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGJ0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBBdCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBfdCkpdGhyb3cgbmV3IFoodC5nZXRDbGFzcygpLmdldE5hbWUoKSk7dGhpcy5jaGVja1ZhbGlkKHQpfX19c2V0U2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQodCl7dGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZD10fWNoZWNrU2hlbGxOb3ROZXN0ZWQodCxlLG4pe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRFeHRlcmlvclJpbmcoKSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKSxvPUNyLmZpbmRQdE5vdE5vZGUocyxpLG4pO2lmKG51bGw9PT1vKXJldHVybiBudWxsO2lmKCFXZS5pc0luUmluZyhvLHIpKXJldHVybiBudWxsO2lmKGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk8PTApcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5ORVNURURfU0hFTExTLG8pLG51bGw7bGV0IGw9bnVsbDtmb3IobGV0IHM9MDtzPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXtjb25zdCBpPWUuZ2V0SW50ZXJpb3JSaW5nTihzKTtpZihsPXRoaXMuY2hlY2tTaGVsbEluc2lkZUhvbGUodCxpLG4pLG51bGw9PT1sKXJldHVybiBudWxsfXRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5ORVNURURfU0hFTExTLGwpfWNoZWNrQ2xvc2VkUmluZ3ModCl7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRJbnRlcmlvclJpbmdOKGUpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Y2hlY2tDbG9zZWRSaW5nKHQpe2lmKCF0LmlzQ2xvc2VkKCkpe2xldCBlPW51bGw7dC5nZXROdW1Qb2ludHMoKT49MSYmKGU9dC5nZXRDb29yZGluYXRlTigwKSksdGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLlJJTkdfTk9UX0NMT1NFRCxlKX19Y2hlY2tTaGVsbHNOb3ROZXN0ZWQodCxlKXtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKS5nZXRFeHRlcmlvclJpbmcoKTtmb3IobGV0IGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7aWYobj09PWkpY29udGludWU7Y29uc3Qgcj10LmdldEdlb21ldHJ5TihpKTtpZih0aGlzLmNoZWNrU2hlbGxOb3ROZXN0ZWQocyxyLGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19fWdldENsYXNzKCl7cmV0dXJuIENyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Dci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wYXJlbnRHZW9tZXRyeT1udWxsLHRoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9ITEsdGhpcy5fdmFsaWRFcnI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wYXJlbnRHZW9tZXRyeT10fTtjbGFzcyBTcntjb25zdHJ1Y3Rvcigpe1NyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGZpbmREaXJFZGdlc0luUmluZyh0KXtsZXQgZT10O2NvbnN0IG49bmV3IHg7ZG97bi5hZGQoZSksZT1lLmdldE5leHQoKSx1LmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSx1LmlzVHJ1ZShlPT09dHx8IWUuaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShlIT09dCk7cmV0dXJuIG59c3RhdGljIGFkZEVkZ2UodCxlLG4pe2lmKGUpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspbi5hZGQodFtlXSwhMSk7ZWxzZSBmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSluLmFkZCh0W2VdLCExKX1zdGF0aWMgZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LGUpe2NvbnN0IG49dC5nZXRSaW5nKCkscz1uLmdldEVudmVsb3BlSW50ZXJuYWwoKTtsZXQgaT1uLmdldENvb3JkaW5hdGVOKDApLHI9bnVsbCxvPW51bGw7Zm9yKGxldCB0PWUuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbD1lLmdldFJpbmcoKSxhPWwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKGEuZXF1YWxzKHMpKWNvbnRpbnVlO2lmKCFhLmNvbnRhaW5zKHMpKWNvbnRpbnVlO2k9WC5wdE5vdEluTGlzdChuLmdldENvb3JkaW5hdGVzKCksbC5nZXRDb29yZGluYXRlcygpKTtsZXQgYz0hMTtXZS5pc0luUmluZyhpLGwuZ2V0Q29vcmRpbmF0ZXMoKSkmJihjPSEwKSxjJiYobnVsbD09PXJ8fG8uY29udGFpbnMoYSkpJiYocj1lLG89ci5nZXRSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX1yZXR1cm4gcn1pc0luY2x1ZGVkKCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWR9Z2V0Q29vcmRpbmF0ZXMoKXtpZihudWxsPT09dGhpcy5fcmluZ1B0cyl7Y29uc3QgdD1uZXcgSTtmb3IobGV0IGU9dGhpcy5fZGVMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRFZGdlKCk7U3IuYWRkRWRnZShzLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLG4uZ2V0RWRnZURpcmVjdGlvbigpLHQpfXRoaXMuX3JpbmdQdHM9dC50b0Nvb3JkaW5hdGVBcnJheSgpfXJldHVybiB0aGlzLl9yaW5nUHRzfWlzSW5jbHVkZWRTZXQoKXtyZXR1cm4gdGhpcy5faXNJbmNsdWRlZFNldH1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSwhKHRoaXMuX3JpbmdQdHMubGVuZ3RoPD0zKSYmKHRoaXMuZ2V0UmluZygpLENyLmlzVmFsaWQodGhpcy5fcmluZykpfWJ1aWxkKHQpe2xldCBlPXQ7ZG97dGhpcy5hZGQoZSksZS5zZXRSaW5nKHRoaXMpLGU9ZS5nZXROZXh0KCksdS5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksdS5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUoZSE9PXQpfWlzT3V0ZXJIb2xlKCl7cmV0dXJuISF0aGlzLl9pc0hvbGUmJiF0aGlzLmhhc1NoZWxsKCl9Z2V0UG9seWdvbigpe2xldCB0PW51bGw7aWYobnVsbCE9PXRoaXMuX2hvbGVzKXt0PW5ldyBBcnJheSh0aGlzLl9ob2xlcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5zaXplKCk7ZSsrKXRbZV09dGhpcy5faG9sZXMuZ2V0KGUpfXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24odGhpcy5fcmluZyx0KX1pc0hvbGUoKXtyZXR1cm4gdGhpcy5faXNIb2xlfWlzUHJvY2Vzc2VkKCl7cmV0dXJuIHRoaXMuX2lzUHJvY2Vzc2VkfWFkZEhvbGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIER0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5faG9sZXMmJih0aGlzLl9ob2xlcz1uZXcgeCksdGhpcy5faG9sZXMuYWRkKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTcil7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5zZXRTaGVsbCh0aGlzKTtjb25zdCBlPXQuZ2V0UmluZygpO251bGw9PT10aGlzLl9ob2xlcyYmKHRoaXMuX2hvbGVzPW5ldyB4KSx0aGlzLl9ob2xlcy5hZGQoZSl9fXNldEluY2x1ZGVkKHQpe3RoaXMuX2lzSW5jbHVkZWQ9dCx0aGlzLl9pc0luY2x1ZGVkU2V0PSEwfWdldE91dGVySG9sZSgpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKGxldCB0PTA7dDx0aGlzLl9kZUxpc3Quc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9kZUxpc3QuZ2V0KHQpLmdldFN5bSgpLmdldFJpbmcoKTtpZihlLmlzT3V0ZXJIb2xlKCkpcmV0dXJuIGV9cmV0dXJuIG51bGx9Y29tcHV0ZUhvbGUoKXtjb25zdCB0PXRoaXMuZ2V0UmluZygpO3RoaXMuX2lzSG9sZT12LmlzQ0NXKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9aGFzU2hlbGwoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3NoZWxsfWlzT3V0ZXJTaGVsbCgpe3JldHVybiBudWxsIT09dGhpcy5nZXRPdXRlckhvbGUoKX1nZXRMaW5lU3RyaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSx0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5fcmluZ1B0cyl9dG9TdHJpbmcoKXtyZXR1cm4gSnQudG9MaW5lU3RyaW5nKG5ldyB6dCh0aGlzLmdldENvb3JkaW5hdGVzKCkpKX1nZXRTaGVsbCgpe3JldHVybiB0aGlzLmlzSG9sZSgpP3RoaXMuX3NoZWxsOnRoaXN9YWRkKHQpe3RoaXMuX2RlTGlzdC5hZGQodCl9Z2V0UmluZygpe2lmKG51bGwhPT10aGlzLl9yaW5nKXJldHVybiB0aGlzLl9yaW5nO3RoaXMuZ2V0Q29vcmRpbmF0ZXMoKSx0aGlzLl9yaW5nUHRzLmxlbmd0aDwzJiZPLm91dC5wcmludGxuKHRoaXMuX3JpbmdQdHMpO3RyeXt0aGlzLl9yaW5nPXRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0aGlzLl9yaW5nUHRzKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBDKSl0aHJvdyB0O08ub3V0LnByaW50bG4odGhpcy5fcmluZ1B0cyl9cmV0dXJuIHRoaXMuX3Jpbmd9dXBkYXRlSW5jbHVkZWQoKXtpZih0aGlzLmlzSG9sZSgpKXJldHVybiBudWxsO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZGVMaXN0LnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fZGVMaXN0LmdldCh0KS5nZXRTeW0oKS5nZXRSaW5nKCkuZ2V0U2hlbGwoKTtpZihudWxsIT09ZSYmZS5pc0luY2x1ZGVkU2V0KCkpcmV0dXJuIHRoaXMuc2V0SW5jbHVkZWQoIWUuaXNJbmNsdWRlZCgpKSxudWxsfX1zZXRTaGVsbCh0KXt0aGlzLl9zaGVsbD10fXNldFByb2Nlc3NlZCh0KXt0aGlzLl9pc1Byb2Nlc3NlZD10fWdldENsYXNzKCl7cmV0dXJuIFNyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyB3cntjb25zdHJ1Y3Rvcigpe3dyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcGFyZSh0LGUpe2NvbnN0IG49ZTtyZXR1cm4gdC5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKS5jb21wYXJlVG8obi5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gd3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX13ci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFNyLkVudmVsb3BlQ29tcGFyYXRvcj13cixTci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZGVMaXN0PW5ldyB4LHRoaXMuX2xvd2VzdEVkZ2U9bnVsbCx0aGlzLl9yaW5nPW51bGwsdGhpcy5fcmluZ1B0cz1udWxsLHRoaXMuX2hvbGVzPW51bGwsdGhpcy5fc2hlbGw9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLl9pc1Byb2Nlc3NlZD0hMSx0aGlzLl9pc0luY2x1ZGVkU2V0PSExLHRoaXMuX2lzSW5jbHVkZWQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fTtjbGFzcyBMciBleHRlbmRzIEJpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxMci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaW5kTGFiZWxlZEVkZ2VSaW5ncyh0KXtjb25zdCBlPW5ldyB4O2xldCBuPTE7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7aWYodC5pc01hcmtlZCgpKWNvbnRpbnVlO2lmKHQuZ2V0TGFiZWwoKT49MCljb250aW51ZTtlLmFkZCh0KTtjb25zdCBpPVNyLmZpbmREaXJFZGdlc0luUmluZyh0KTtMci5sYWJlbChpLG4pLG4rK31yZXR1cm4gZX1zdGF0aWMgZ2V0RGVncmVlTm9uRGVsZXRlZCh0KXtsZXQgZT0wO2ZvcihsZXQgbj10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuaXNNYXJrZWQoKXx8ZSsrfXJldHVybiBlfXN0YXRpYyBkZWxldGVBbGxFZGdlcyh0KXtmb3IobGV0IGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5zZXRNYXJrZWQoITApO2NvbnN0IG49dC5nZXRTeW0oKTtudWxsIT09biYmbi5zZXRNYXJrZWQoITApfX1zdGF0aWMgbGFiZWwodCxlKXtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuc2V0TGFiZWwoZSl9fXN0YXRpYyBjb21wdXRlTmV4dENXRWRnZXModCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2lmKCF0LmlzTWFya2VkKCkpe2lmKG51bGw9PT1lJiYoZT10KSxudWxsIT09bil7bi5nZXRTeW0oKS5zZXROZXh0KHQpfW49dH19aWYobnVsbCE9PW4pe24uZ2V0U3ltKCkuc2V0TmV4dChlKX19c3RhdGljIGNvbXB1dGVOZXh0Q0NXRWRnZXModCxlKXtsZXQgbj1udWxsLHM9bnVsbDtjb25zdCBpPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpO2ZvcihsZXQgdD1pLnNpemUoKS0xO3Q+PTA7dC0tKXtjb25zdCByPWkuZ2V0KHQpLG89ci5nZXRTeW0oKTtsZXQgbD1udWxsO3IuZ2V0TGFiZWwoKT09PWUmJihsPXIpO2xldCBhPW51bGw7by5nZXRMYWJlbCgpPT09ZSYmKGE9byksbnVsbD09PWwmJm51bGw9PT1hfHwobnVsbCE9PWEmJihzPWEpLG51bGwhPT1sJiYobnVsbCE9PXMmJihzLnNldE5leHQobCkscz1udWxsKSxudWxsPT09biYmKG49bCkpKX1udWxsIT09cyYmKHUuaXNUcnVlKG51bGwhPT1uKSxzLnNldE5leHQobikpfXN0YXRpYyBnZXREZWdyZWUodCxlKXtsZXQgbj0wO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7cy5uZXh0KCkuZ2V0TGFiZWwoKT09PWUmJm4rK31yZXR1cm4gbn1zdGF0aWMgZmluZEludGVyc2VjdGlvbk5vZGVzKHQsZSl7bGV0IG49dCxzPW51bGw7ZG97Y29uc3QgaT1uLmdldEZyb21Ob2RlKCk7THIuZ2V0RGVncmVlKGksZSk+MSYmKG51bGw9PT1zJiYocz1uZXcgeCkscy5hZGQoaSkpLG49bi5nZXROZXh0KCksdS5pc1RydWUobnVsbCE9PW4sXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksdS5pc1RydWUobj09PXR8fCFuLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUobiE9PXQpO3JldHVybiBzfWZpbmRFZGdlUmluZyh0KXtjb25zdCBlPW5ldyBTcih0aGlzLl9mYWN0b3J5KTtyZXR1cm4gZS5idWlsZCh0KSxlfWNvbXB1dGVEZXB0aFBhcml0eSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcig7OylyZXR1cm4gbnVsbH1jb21wdXRlTmV4dENXRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5ub2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7THIuY29tcHV0ZU5leHRDV0VkZ2VzKGUpfX1hZGRFZGdlKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IGU9WC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIG51bGw7Y29uc3Qgbj1lWzBdLHM9ZVtlLmxlbmd0aC0xXSxpPXRoaXMuZ2V0Tm9kZShuKSxyPXRoaXMuZ2V0Tm9kZShzKSxvPW5ldyB1cihpLHIsZVsxXSwhMCksbD1uZXcgdXIocixpLGVbZS5sZW5ndGgtMl0sITEpLGE9bmV3IGdyKHQpO2Euc2V0RGlyZWN0ZWRFZGdlcyhvLGwpLHRoaXMuYWRkKGEpfWRlbGV0ZUN1dEVkZ2VzKCl7dGhpcy5jb21wdXRlTmV4dENXRWRnZXMoKSxMci5maW5kTGFiZWxlZEVkZ2VSaW5ncyh0aGlzLl9kaXJFZGdlcyk7Y29uc3QgdD1uZXcgeDtmb3IobGV0IGU9dGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYobi5pc01hcmtlZCgpKWNvbnRpbnVlO2NvbnN0IHM9bi5nZXRTeW0oKTtpZihuLmdldExhYmVsKCk9PT1zLmdldExhYmVsKCkpe24uc2V0TWFya2VkKCEwKSxzLnNldE1hcmtlZCghMCk7Y29uc3QgZT1uLmdldEVkZ2UoKTt0LmFkZChlLmdldExpbmUoKSl9fXJldHVybiB0fWdldEVkZ2VSaW5ncygpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCksTHIubGFiZWwodGhpcy5fZGlyRWRnZXMsLTEpO2NvbnN0IHQ9THIuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5fZGlyRWRnZXMpO3RoaXMuY29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3ModCk7Y29uc3QgZT1uZXcgeDtmb3IobGV0IHQ9dGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7aWYobi5pc01hcmtlZCgpKWNvbnRpbnVlO2lmKG4uaXNJblJpbmcoKSljb250aW51ZTtjb25zdCBzPXRoaXMuZmluZEVkZ2VSaW5nKG4pO2UuYWRkKHMpfXJldHVybiBlfWdldE5vZGUodCl7bGV0IGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBGaSh0KSx0aGlzLmFkZChlKSksZX1jb252ZXJ0TWF4aW1hbFRvTWluaW1hbEVkZ2VSaW5ncyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0TGFiZWwoKSxzPUxyLmZpbmRJbnRlcnNlY3Rpb25Ob2Rlcyh0LG4pO2lmKG51bGwhPT1zKWZvcihsZXQgdD1zLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO0xyLmNvbXB1dGVOZXh0Q0NXRWRnZXMoZSxuKX19fWRlbGV0ZURhbmdsZXMoKXtjb25zdCB0PXRoaXMuZmluZE5vZGVzT2ZEZWdyZWUoMSksZT1uZXcgSixuPW5ldyBvbjtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyluLnB1c2goZS5uZXh0KCkpO2Zvcig7IW4uaXNFbXB0eSgpOyl7Y29uc3QgdD1uLnBvcCgpO0xyLmRlbGV0ZUFsbEVkZ2VzKHQpO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LnNldE1hcmtlZCghMCk7Y29uc3QgaT10LmdldFN5bSgpO251bGwhPT1pJiZpLnNldE1hcmtlZCghMCk7Y29uc3Qgcj10LmdldEVkZ2UoKTtlLmFkZChyLmdldExpbmUoKSk7Y29uc3Qgbz10LmdldFRvTm9kZSgpOzE9PT1Mci5nZXREZWdyZWVOb25EZWxldGVkKG8pJiZuLnB1c2gobyl9fXJldHVybiBlfWdldENsYXNzKCl7cmV0dXJuIExyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Mci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9mYWN0b3J5PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fTtjbGFzcyBUcntjb25zdHJ1Y3Rvcigpe1RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGZpbmRPdXRlclNoZWxscyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0T3V0ZXJIb2xlKCk7bnVsbD09PW58fG4uaXNQcm9jZXNzZWQoKXx8KHQuc2V0SW5jbHVkZWQoITApLG4uc2V0UHJvY2Vzc2VkKCEwKSl9fXN0YXRpYyBleHRyYWN0UG9seWdvbnModCxlKXtjb25zdCBuPW5ldyB4O2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpOyhlfHx0LmlzSW5jbHVkZWQoKSkmJm4uYWRkKHQuZ2V0UG9seWdvbigpKX1yZXR1cm4gbn1zdGF0aWMgYXNzaWduSG9sZXNUb1NoZWxscyh0LGUpe2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO1RyLmFzc2lnbkhvbGVUb1NoZWxsKHQsZSl9fXN0YXRpYyBhc3NpZ25Ib2xlVG9TaGVsbCh0LGUpe2NvbnN0IG49U3IuZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LGUpO251bGwhPT1uJiZuLmFkZEhvbGUodCl9c3RhdGljIGZpbmREaXNqb2ludFNoZWxscyh0KXtUci5maW5kT3V0ZXJTaGVsbHModCk7bGV0IGU9bnVsbDtkb3tlPSExO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3QuaXNJbmNsdWRlZFNldCgpfHwodC51cGRhdGVJbmNsdWRlZCgpLHQuaXNJbmNsdWRlZFNldCgpfHwoZT0hMCkpfX13aGlsZShlKX1nZXRHZW9tZXRyeSgpe3JldHVybiBudWxsPT09dGhpcy5fZ2VvbUZhY3RvcnkmJih0aGlzLl9nZW9tRmFjdG9yeT1uZXcgSHQpLHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsP3RoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodGhpcy5fcG9seUxpc3QpOnRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihIdC50b0dlb21ldHJ5QXJyYXkodGhpcy5fcG9seUxpc3QpKX1nZXRJbnZhbGlkUmluZ0xpbmVzKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2ludmFsaWRSaW5nTGluZXN9ZmluZFZhbGlkUmluZ3ModCxlLG4pe2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuaXNWYWxpZCgpP2UuYWRkKHQpOm4uYWRkKHQuZ2V0TGluZVN0cmluZygpKX19cG9seWdvbml6ZSgpe2lmKG51bGwhPT10aGlzLl9wb2x5TGlzdClyZXR1cm4gbnVsbDtpZih0aGlzLl9wb2x5TGlzdD1uZXcgeCxudWxsPT09dGhpcy5fZ3JhcGgpcmV0dXJuIG51bGw7dGhpcy5fZGFuZ2xlcz10aGlzLl9ncmFwaC5kZWxldGVEYW5nbGVzKCksdGhpcy5fY3V0RWRnZXM9dGhpcy5fZ3JhcGguZGVsZXRlQ3V0RWRnZXMoKTtjb25zdCB0PXRoaXMuX2dyYXBoLmdldEVkZ2VSaW5ncygpO2xldCBlPW5ldyB4O3RoaXMuX2ludmFsaWRSaW5nTGluZXM9bmV3IHgsdGhpcy5faXNDaGVja2luZ1JpbmdzVmFsaWQ/dGhpcy5maW5kVmFsaWRSaW5ncyh0LGUsdGhpcy5faW52YWxpZFJpbmdMaW5lcyk6ZT10LHRoaXMuZmluZFNoZWxsc0FuZEhvbGVzKGUpLFRyLmFzc2lnbkhvbGVzVG9TaGVsbHModGhpcy5faG9sZUxpc3QsdGhpcy5fc2hlbGxMaXN0KSxFZS5zb3J0KHRoaXMuX3NoZWxsTGlzdCxuZXcgU3IuRW52ZWxvcGVDb21wYXJhdG9yKTtsZXQgbj0hMDt0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbCYmKFRyLmZpbmREaXNqb2ludFNoZWxscyh0aGlzLl9zaGVsbExpc3QpLG49ITEpLHRoaXMuX3BvbHlMaXN0PVRyLmV4dHJhY3RQb2x5Z29ucyh0aGlzLl9zaGVsbExpc3Qsbil9Z2V0RGFuZ2xlcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9kYW5nbGVzfWdldEN1dEVkZ2VzKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2N1dEVkZ2VzfWdldFBvbHlnb25zKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX3BvbHlMaXN0fWFkZCgpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLG51bGw9PT10aGlzLl9ncmFwaCYmKHRoaXMuX2dyYXBoPW5ldyBMcih0aGlzLl9nZW9tRmFjdG9yeSkpLHRoaXMuX2dyYXBoLmFkZEVkZ2UodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2FyZ3VtZW50c1swXS5hcHBseSh0aGlzLl9saW5lU3RyaW5nQWRkZXIpfX1zZXRDaGVja1JpbmdzVmFsaWQodCl7dGhpcy5faXNDaGVja2luZ1JpbmdzVmFsaWQ9dH1maW5kU2hlbGxzQW5kSG9sZXModCl7dGhpcy5faG9sZUxpc3Q9bmV3IHgsdGhpcy5fc2hlbGxMaXN0PW5ldyB4O2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuY29tcHV0ZUhvbGUoKSx0LmlzSG9sZSgpP3RoaXMuX2hvbGVMaXN0LmFkZCh0KTp0aGlzLl9zaGVsbExpc3QuYWRkKHQpfX1nZXRDbGFzcygpe3JldHVybiBUcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgUnJ7Y29uc3RydWN0b3IoKXtSci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt0IGluc3RhbmNlb2YgVHQmJnRoaXMucC5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gUnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ddfX1Sci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLnA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnA9dH0sVHIuTGluZVN0cmluZ0FkZGVyPVJyLFRyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2xpbmVTdHJpbmdBZGRlcj1uZXcgUnIodGhpcyksdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9kYW5nbGVzPW5ldyB4LHRoaXMuX2N1dEVkZ2VzPW5ldyB4LHRoaXMuX2ludmFsaWRSaW5nTGluZXM9bmV3IHgsdGhpcy5faG9sZUxpc3Q9bnVsbCx0aGlzLl9zaGVsbExpc3Q9bnVsbCx0aGlzLl9wb2x5TGlzdD1udWxsLHRoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkPSEwLHRoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsPW51bGwsdGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClUci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLCExKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD10fX07dmFyIFByPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFBvbHlnb25pemVyOlRyfSk7Y2xhc3MgdnJ7Y29uc3RydWN0b3IoKXt2ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydEVkZ2VFbmRzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuX25vZGVzLmFkZCh0KX19Y29tcHV0ZVByb3BlckludGVyc2VjdGlvbklNKHQsZSl7Y29uc3Qgbj10aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxzPXRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpLmdldERpbWVuc2lvbigpLGk9dC5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKSxyPXQuaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKTsyPT09biYmMj09PXM/aSYmZS5zZXRBdExlYXN0KFwiMjEyMTAxMjEyXCIpOjI9PT1uJiYxPT09cz8oaSYmZS5zZXRBdExlYXN0KFwiRkZGMEZGRkYyXCIpLHImJmUuc2V0QXRMZWFzdChcIjFGRkZGRjFGRlwiKSk6MT09PW4mJjI9PT1zPyhpJiZlLnNldEF0TGVhc3QoXCJGMEZGRkZGRjJcIiksciYmZS5zZXRBdExlYXN0KFwiMUYxRkZGRkZGXCIpKToxPT09biYmMT09PXMmJnImJmUuc2V0QXRMZWFzdChcIjBGRkZGRkZGRlwiKX1sYWJlbElzb2xhdGVkRWRnZXModCxlKXtmb3IobGV0IG49dGhpcy5fYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0LmlzSXNvbGF0ZWQoKSYmKHRoaXMubGFiZWxJc29sYXRlZEVkZ2UodCxlLHRoaXMuX2FyZ1tlXS5nZXRHZW9tZXRyeSgpKSx0aGlzLl9pc29sYXRlZEVkZ2VzLmFkZCh0KSl9fWxhYmVsSXNvbGF0ZWRFZGdlKHQsZSxuKXtpZihuLmdldERpbWVuc2lvbigpPjApe2NvbnN0IHM9dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSxuKTt0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUscyl9ZWxzZSB0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsbmUuRVhURVJJT1IpfWNvbXB1dGVJTSgpe2NvbnN0IHQ9bmV3IHNlO2lmKHQuc2V0KG5lLkVYVEVSSU9SLG5lLkVYVEVSSU9SLDIpLCF0aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiB0aGlzLmNvbXB1dGVEaXNqb2ludElNKHQpLHQ7dGhpcy5fYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpLHRoaXMuX2FyZ1sxXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKTtjb25zdCBlPXRoaXMuX2FyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5fYXJnWzFdLHRoaXMuX2xpLCExKTt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlcygwKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlcygxKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscygwKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscygxKSx0aGlzLmxhYmVsSXNvbGF0ZWROb2RlcygpLHRoaXMuY29tcHV0ZVByb3BlckludGVyc2VjdGlvbklNKGUsdCk7Y29uc3Qgbj1uZXcgX3Iscz1uLmNvbXB1dGVFZGdlRW5kcyh0aGlzLl9hcmdbMF0uZ2V0RWRnZUl0ZXJhdG9yKCkpO3RoaXMuaW5zZXJ0RWRnZUVuZHMocyk7Y29uc3QgaT1uLmNvbXB1dGVFZGdlRW5kcyh0aGlzLl9hcmdbMV0uZ2V0RWRnZUl0ZXJhdG9yKCkpO3JldHVybiB0aGlzLmluc2VydEVkZ2VFbmRzKGkpLHRoaXMubGFiZWxOb2RlRWRnZXMoKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygwLDEpLHRoaXMubGFiZWxJc29sYXRlZEVkZ2VzKDEsMCksdGhpcy51cGRhdGVJTSh0KSx0fWxhYmVsTm9kZUVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcy5fYXJnKX19Y29weU5vZGVzQW5kTGFiZWxzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0Tm9kZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuX25vZGVzLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpLnNldExhYmVsKHQsbi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpKX19bGFiZWxJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtmb3IobGV0IGU9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLGk9dGhpcy5fbm9kZXMuZmluZChuLmNvb3JkKTtpLmdldExhYmVsKCkuaXNOdWxsKHQpJiYocz09PW5lLkJPVU5EQVJZP2kuc2V0TGFiZWxCb3VuZGFyeSh0KTppLnNldExhYmVsKHQsbmUuSU5URVJJT1IpKX19fWxhYmVsSXNvbGF0ZWROb2RlKHQsZSl7Y29uc3Qgbj10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX2FyZ1tlXS5nZXRHZW9tZXRyeSgpKTt0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsbil9Y29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2ZvcihsZXQgZT1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCksaT10aGlzLl9ub2Rlcy5hZGROb2RlKG4uY29vcmQpO3M9PT1uZS5CT1VOREFSWT9pLnNldExhYmVsQm91bmRhcnkodCk6aS5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmaS5zZXRMYWJlbCh0LG5lLklOVEVSSU9SKX19fWxhYmVsSXNvbGF0ZWROb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKTt1LmlzVHJ1ZShuLmdldEdlb21ldHJ5Q291bnQoKT4wLFwibm9kZSB3aXRoIGVtcHR5IGxhYmVsIGZvdW5kXCIpLGUuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbElzb2xhdGVkTm9kZShlLDApOnRoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwxKSl9fXVwZGF0ZUlNKHQpe2ZvcihsZXQgZT10aGlzLl9pc29sYXRlZEVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS51cGRhdGVJTSh0KX1mb3IobGV0IGU9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7bi51cGRhdGVJTSh0KSxuLnVwZGF0ZUlNRnJvbUVkZ2VzKHQpfX1jb21wdXRlRGlzam9pbnRJTSh0KXtjb25zdCBlPXRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpO2UuaXNFbXB0eSgpfHwodC5zZXQobmUuSU5URVJJT1IsbmUuRVhURVJJT1IsZS5nZXREaW1lbnNpb24oKSksdC5zZXQobmUuQk9VTkRBUlksbmUuRVhURVJJT1IsZS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKSk7Y29uc3Qgbj10aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKTtuLmlzRW1wdHkoKXx8KHQuc2V0KG5lLkVYVEVSSU9SLG5lLklOVEVSSU9SLG4uZ2V0RGltZW5zaW9uKCkpLHQuc2V0KG5lLkVYVEVSSU9SLG5lLkJPVU5EQVJZLG4uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpfWdldENsYXNzKCl7cmV0dXJuIHZyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12ci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saT1uZXcgdGUsdGhpcy5fcHRMb2NhdG9yPW5ldyBfbix0aGlzLl9hcmc9bnVsbCx0aGlzLl9ub2Rlcz1uZXcgWG4obmV3IHlyKSx0aGlzLl9pbT1udWxsLHRoaXMuX2lzb2xhdGVkRWRnZXM9bmV3IHgsdGhpcy5faW52YWxpZFBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYXJnPXR9O2NsYXNzIE9ye2NvbnN0cnVjdG9yKCl7T3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29udGFpbnModCxlKXtyZXR1cm4gbmV3IE9yKHQpLmNvbnRhaW5zKGUpfWlzQ29udGFpbmVkSW5Cb3VuZGFyeSh0KXtpZih0IGluc3RhbmNlb2YgYnQpcmV0dXJuITE7aWYodCBpbnN0YW5jZW9mIFB0KXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQgaW5zdGFuY2VvZiBUdClyZXR1cm4gdGhpcy5pc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5KHQpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeShuKSlyZXR1cm4hMX1yZXR1cm4hMH1pc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0LGUpe2lmKHQuZXF1YWxzKGUpKXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQueD09PWUueCl7aWYodC54PT09dGhpcy5fcmVjdEVudi5nZXRNaW5YKCl8fHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WCgpKXJldHVybiEwfWVsc2UgaWYodC55PT09ZS55JiYodC55PT09dGhpcy5fcmVjdEVudi5nZXRNaW5ZKCl8fHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WSgpKSlyZXR1cm4hMDtyZXR1cm4hMX1pc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxuPW5ldyBnLHM9bmV3IGc7Zm9yKGxldCB0PTA7dDxlLnNpemUoKS0xO3QrKylpZihlLmdldENvb3JkaW5hdGUodCxuKSxlLmdldENvb3JkaW5hdGUodCsxLHMpLCF0aGlzLmlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5KG4scykpcmV0dXJuITE7cmV0dXJuITB9aXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFB0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0LmdldENvb3JkaW5hdGUoKSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC54PT09dGhpcy5fcmVjdEVudi5nZXRNaW5YKCl8fHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WCgpfHx0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1pblkoKXx8dC55PT09dGhpcy5fcmVjdEVudi5nZXRNYXhZKCl9fWNvbnRhaW5zKHQpe3JldHVybiEhdGhpcy5fcmVjdEVudi5jb250YWlucyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJiF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeSh0KX1nZXRDbGFzcygpe3JldHVybiBPcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19T3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVjdEVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9O2NsYXNzIGJye2NvbnN0cnVjdG9yKCl7YnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnRlcnNlY3RzKHQsZSl7Y29uc3Qgbj1uZXcgTih0LGUpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMobikpcmV0dXJuITE7aWYodGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKHQpKXJldHVybiEwO2lmKHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4hMDtpZih0LmNvbXBhcmVUbyhlKT4wKXtjb25zdCBuPXQ7dD1lLGU9bn1sZXQgcz0hMTtyZXR1cm4gZS55PnQueSYmKHM9ITApLHM/dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fZGlhZ0Rvd24wLHRoaXMuX2RpYWdEb3duMSk6dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fZGlhZ1VwMCx0aGlzLl9kaWFnVXAxKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfWdldENsYXNzKCl7cmV0dXJuIGJyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1ici5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saT1uZXcgdGUsdGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX2RpYWdVcDA9bnVsbCx0aGlzLl9kaWFnVXAxPW51bGwsdGhpcy5fZGlhZ0Rvd24wPW51bGwsdGhpcy5fZGlhZ0Rvd24xPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10LHRoaXMuX2RpYWdVcDA9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLHRoaXMuX2RpYWdVcDE9bmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLHRoaXMuX2RpYWdEb3duMD1uZXcgZyh0LmdldE1pblgoKSx0LmdldE1heFkoKSksdGhpcy5fZGlhZ0Rvd24xPW5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKX07Y2xhc3MgTXJ7Y29uc3RydWN0b3IoKXtNci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbnRlcnNlY3RzKHQsZSl7cmV0dXJuIG5ldyBNcih0KS5pbnRlcnNlY3RzKGUpfWludGVyc2VjdHModCl7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuITE7Y29uc3QgZT1uZXcgRHIodGhpcy5fcmVjdEVudik7aWYoZS5hcHBseVRvKHQpLGUuaW50ZXJzZWN0cygpKXJldHVybiEwO2NvbnN0IG49bmV3IEFyKHRoaXMuX3JlY3RhbmdsZSk7aWYobi5hcHBseVRvKHQpLG4uY29udGFpbnNQb2ludCgpKXJldHVybiEwO2NvbnN0IHM9bmV3IEZyKHRoaXMuX3JlY3RhbmdsZSk7cmV0dXJuIHMuYXBwbHlUbyh0KSwhIXMuaW50ZXJzZWN0cygpfWdldENsYXNzKCl7cmV0dXJuIE1yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Nci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yZWN0YW5nbGU9bnVsbCx0aGlzLl9yZWN0RW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdGFuZ2xlPXQsdGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX07Y2xhc3MgRHIgZXh0ZW5kcyBDZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0RvbmUoKXtyZXR1cm4hMD09PXRoaXMuX2ludGVyc2VjdHN9dmlzaXQodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtyZXR1cm4gdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpP3RoaXMuX3JlY3RFbnYuY29udGFpbnMoZSl8fGUuZ2V0TWluWCgpPj10aGlzLl9yZWN0RW52LmdldE1pblgoKSYmZS5nZXRNYXhYKCk8PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WCgpfHxlLmdldE1pblkoKT49dGhpcy5fcmVjdEVudi5nZXRNaW5ZKCkmJmUuZ2V0TWF4WSgpPD10aGlzLl9yZWN0RW52LmdldE1heFkoKT8odGhpcy5faW50ZXJzZWN0cz0hMCxudWxsKTp2b2lkIDA6bnVsbH1pbnRlcnNlY3RzKCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdHN9Z2V0Q2xhc3MoKXtyZXR1cm4gRHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fURyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9pbnRlcnNlY3RzPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dH07Y2xhc3MgQXIgZXh0ZW5kcyBDZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0RvbmUoKXtyZXR1cm4hMD09PXRoaXMuX2NvbnRhaW5zUG9pbnR9dmlzaXQodCl7aWYoISh0IGluc3RhbmNlb2YgYnQpKXJldHVybiBudWxsO2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBnO2ZvcihsZXQgcz0wO3M8NDtzKyspaWYodGhpcy5fcmVjdFNlcS5nZXRDb29yZGluYXRlKHMsbiksZS5jb250YWlucyhuKSYmWmUuY29udGFpbnNQb2ludEluUG9seWdvbihuLHQpKXJldHVybiB0aGlzLl9jb250YWluc1BvaW50PSEwLG51bGx9Y29udGFpbnNQb2ludCgpe3JldHVybiB0aGlzLl9jb250YWluc1BvaW50fWdldENsYXNzKCl7cmV0dXJuIEFyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Bci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yZWN0U2VxPW51bGwsdGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX2NvbnRhaW5zUG9pbnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdFNlcT10LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHRoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9O2NsYXNzIEZyIGV4dGVuZHMgQ2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLEZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW50ZXJzZWN0cygpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9oYXNJbnRlcnNlY3Rpb259dmlzaXQodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiBudWxsO2NvbnN0IG49eGUuZ2V0TGluZXModCk7dGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5ncyhuKX1jaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5ncyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZih0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzKHQpLHRoaXMuX2hhc0ludGVyc2VjdGlvbilyZXR1cm4gbnVsbH19Y2hlY2tJbnRlcnNlY3Rpb25XaXRoU2VnbWVudHModCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2ZvcihsZXQgdD0xO3Q8ZS5zaXplKCk7dCsrKWlmKGUuZ2V0Q29vcmRpbmF0ZSh0LTEsdGhpcy5fcDApLGUuZ2V0Q29vcmRpbmF0ZSh0LHRoaXMuX3AxKSx0aGlzLl9yZWN0SW50ZXJzZWN0b3IuaW50ZXJzZWN0cyh0aGlzLl9wMCx0aGlzLl9wMSkpcmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCxudWxsfWdldENsYXNzKCl7cmV0dXJuIEZyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Gci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5fcmVjdEludGVyc2VjdG9yPW51bGwsdGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuX3AwPW5ldyBnLHRoaXMuX3AxPW5ldyBnO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCksdGhpcy5fcmVjdEludGVyc2VjdG9yPW5ldyBicih0aGlzLl9yZWN0RW52KX07Y2xhc3MgR3IgZXh0ZW5kcyBhcntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksR3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY292ZXJzKHQsZSl7cmV0dXJuISgyPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwyKSYmKCEoMT09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MSYmZS5nZXRMZW5ndGgoKT4wKSYmKCEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuY292ZXJzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKCEhdC5pc1JlY3RhbmdsZSgpfHxuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0NvdmVycygpKSkpfXN0YXRpYyBpbnRlcnNlY3RzKHQsZSl7aWYoIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiExO2lmKHQuaXNSZWN0YW5nbGUoKSlyZXR1cm4gTXIuaW50ZXJzZWN0cyh0LGUpO2lmKGUuaXNSZWN0YW5nbGUoKSlyZXR1cm4gTXIuaW50ZXJzZWN0cyhlLHQpO2lmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKylmb3IobGV0IHM9MDtzPGUuZ2V0TnVtR2VvbWV0cmllcygpO3MrKylpZih0LmdldEdlb21ldHJ5TihuKS5pbnRlcnNlY3RzKGUuZ2V0R2VvbWV0cnlOKHMpKSlyZXR1cm4hMDtyZXR1cm4hMX1yZXR1cm4gbmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNJbnRlcnNlY3RzKCl9c3RhdGljIHRvdWNoZXModCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc1RvdWNoZXModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgZXF1YWxzVG9wbyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuZXF1YWxzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmR3IucmVsYXRlKHQsZSkuaXNFcXVhbHModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgcmVsYXRlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG5ldyBHcih0LGUsbikuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCl9fXN0YXRpYyBvdmVybGFwcyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJm5ldyBHcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzT3ZlcmxhcHModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgY3Jvc3Nlcyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJm5ldyBHcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzQ3Jvc3Nlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyBjb250YWlucyh0LGUpe3JldHVybiEoMj09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MikmJighKDE9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDEmJmUuZ2V0TGVuZ3RoKCk+MCkmJighIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvbnRhaW5zKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKHQuaXNSZWN0YW5nbGUoKT9Pci5jb250YWlucyh0LGUpOm5ldyBHcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzQ29udGFpbnMoKSkpKX1nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKXtyZXR1cm4gdGhpcy5fcmVsYXRlLmNvbXB1dGVJTSgpfWdldENsYXNzKCl7cmV0dXJuIEdyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Hci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9yZWxhdGU9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMuX3JlbGF0ZT1uZXcgdnIodGhpcy5fYXJnKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTthci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuKSx0aGlzLl9yZWxhdGU9bmV3IHZyKHRoaXMuX2FyZyl9fTt2YXIgcXI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsUmVsYXRlT3A6R3J9KTtjbGFzcyBCcntjb25zdHJ1Y3Rvcigpe0JyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIG5ldyBCcih0LGUpLnVuaW9uKCl9dW5pb24oKXtjb25zdCB0PW5ldyBfbixlPW5ldyBhdDtmb3IobGV0IG49MDtuPHRoaXMuX3BvaW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXRoaXMuX3BvaW50R2VvbS5nZXRHZW9tZXRyeU4obikuZ2V0Q29vcmRpbmF0ZSgpO3QubG9jYXRlKHMsdGhpcy5fb3RoZXJHZW9tKT09PW5lLkVYVEVSSU9SJiZlLmFkZChzKX1pZigwPT09ZS5zaXplKCkpcmV0dXJuIHRoaXMuX290aGVyR2VvbTtsZXQgbj1udWxsO2NvbnN0IHM9WC50b0Nvb3JkaW5hdGVBcnJheShlKTtyZXR1cm4gbj0xPT09cy5sZW5ndGg/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoc1swXSk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMocyksZGUuY29tYmluZShuLHRoaXMuX290aGVyR2VvbSl9Z2V0Q2xhc3MoKXtyZXR1cm4gQnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUJyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3BvaW50R2VvbT1udWxsLHRoaXMuX290aGVyR2VvbT1udWxsLHRoaXMuX2dlb21GYWN0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcG9pbnRHZW9tPXQsdGhpcy5fb3RoZXJHZW9tPWUsdGhpcy5fZ2VvbUZhY3Q9ZS5nZXRGYWN0b3J5KCl9O2NsYXNzIFZye2NvbnN0cnVjdG9yKCl7VnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcmVzdHJpY3RUb1BvbHlnb25zKHQpe2lmKF8odCxPdCkpcmV0dXJuIHQ7Y29uc3QgZT1OZS5nZXRQb2x5Z29ucyh0KTtyZXR1cm4gMT09PWUuc2l6ZSgpP2UuZ2V0KDApOnQuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpUG9seWdvbihIdC50b1BvbHlnb25BcnJheShlKSl9c3RhdGljIGdldEdlb21ldHJ5KHQsZSl7cmV0dXJuIGU+PXQuc2l6ZSgpP251bGw6dC5nZXQoZSl9c3RhdGljIHVuaW9uKHQpe3JldHVybiBuZXcgVnIodCkudW5pb24oKX1yZWR1Y2VUb0dlb21ldHJpZXModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtsZXQgcz1udWxsO18odCxtKT9zPXRoaXMudW5pb25UcmVlKHQpOnQgaW5zdGFuY2VvZiBxJiYocz10KSxlLmFkZChzKX1yZXR1cm4gZX1leHRyYWN0QnlFbnZlbG9wZSh0LGUsbil7Y29uc3Qgcz1uZXcgeDtmb3IobGV0IGk9MDtpPGUuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7Y29uc3Qgcj1lLmdldEdlb21ldHJ5TihpKTtyLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP3MuYWRkKHIpOm4uYWRkKHIpfXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHMpfXVuaW9uT3B0aW1pemVkKHQsZSl7Y29uc3Qgbj10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxzPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCFuLmludGVyc2VjdHMocykpe3JldHVybiBkZS5jb21iaW5lKHQsZSl9aWYodC5nZXROdW1HZW9tZXRyaWVzKCk8PTEmJmUuZ2V0TnVtR2VvbWV0cmllcygpPD0xKXJldHVybiB0aGlzLnVuaW9uQWN0dWFsKHQsZSk7Y29uc3QgaT1uLmludGVyc2VjdGlvbihzKTtyZXR1cm4gdGhpcy51bmlvblVzaW5nRW52ZWxvcGVJbnRlcnNlY3Rpb24odCxlLGkpfXVuaW9uKCl7aWYobnVsbD09PXRoaXMuX2lucHV0UG9seXMpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcInVuaW9uKCkgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2VcIik7aWYodGhpcy5faW5wdXRQb2x5cy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5fZ2VvbUZhY3Rvcnk9dGhpcy5faW5wdXRQb2x5cy5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCk7Y29uc3QgdD1uZXcgRXMoVnIuU1RSVFJFRV9OT0RFX0NBUEFDSVRZKTtmb3IobGV0IGU9dGhpcy5faW5wdXRQb2x5cy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0Lmluc2VydChuLmdldEVudmVsb3BlSW50ZXJuYWwoKSxuKX10aGlzLl9pbnB1dFBvbHlzPW51bGw7Y29uc3QgZT10Lml0ZW1zVHJlZSgpO3JldHVybiB0aGlzLnVuaW9uVHJlZShlKX1iaW5hcnlVbmlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5iaW5hcnlVbmlvbih0LDAsdC5zaXplKCkpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihuLWU8PTEpe2NvbnN0IG49VnIuZ2V0R2VvbWV0cnkodCxlKTtyZXR1cm4gdGhpcy51bmlvblNhZmUobixudWxsKX1pZihuLWU9PTIpcmV0dXJuIHRoaXMudW5pb25TYWZlKFZyLmdldEdlb21ldHJ5KHQsZSksVnIuZ2V0R2VvbWV0cnkodCxlKzEpKTt7Y29uc3Qgcz1NYXRoLnRydW5jKChuK2UpLzIpLGk9dGhpcy5iaW5hcnlVbmlvbih0LGUscykscj10aGlzLmJpbmFyeVVuaW9uKHQscyxuKTtyZXR1cm4gdGhpcy51bmlvblNhZmUoaSxyKX19fXJlcGVhdGVkVW5pb24odCl7bGV0IGU9bnVsbDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlPW51bGw9PT1lP3QuY29weSgpOmUudW5pb24odCl9cmV0dXJuIGV9dW5pb25TYWZlKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT10P2UuY29weSgpOm51bGw9PT1lP3QuY29weSgpOnRoaXMudW5pb25PcHRpbWl6ZWQodCxlKX11bmlvbkFjdHVhbCh0LGUpe3JldHVybiBWci5yZXN0cmljdFRvUG9seWdvbnModC51bmlvbihlKSl9dW5pb25UcmVlKHQpe2NvbnN0IGU9dGhpcy5yZWR1Y2VUb0dlb21ldHJpZXModCk7cmV0dXJuIHRoaXMuYmluYXJ5VW5pb24oZSl9dW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uKHQsZSxuKXtjb25zdCBzPW5ldyB4LGk9dGhpcy5leHRyYWN0QnlFbnZlbG9wZShuLHQscykscj10aGlzLmV4dHJhY3RCeUVudmVsb3BlKG4sZSxzKSxvPXRoaXMudW5pb25BY3R1YWwoaSxyKTtyZXR1cm4gcy5hZGQobyksZGUuY29tYmluZShzKX1idWZmZXJVbmlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5nZXQoMCkuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkodCkuYnVmZmVyKDApfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFt0LGVdKS5idWZmZXIoMCl9fWdldENsYXNzKCl7cmV0dXJuIFZyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Wci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dFBvbHlzPW51bGwsdGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dFBvbHlzPXQsbnVsbD09PXRoaXMuX2lucHV0UG9seXMmJih0aGlzLl9pbnB1dFBvbHlzPW5ldyB4KX0sVnIuU1RSVFJFRV9OT0RFX0NBUEFDSVRZPTQ7Y2xhc3MgenJ7Y29uc3RydWN0b3IoKXt6ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB1bmlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyB6cih0KS51bmlvbigpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyB6cih0KS51bmlvbigpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IHpyKHQsZSkudW5pb24oKX19dW5pb25Ob09wdCh0KXtjb25zdCBlPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KCk7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuVU5JT04pfXVuaW9uV2l0aE51bGwodCxlKXtyZXR1cm4gbnVsbD09PXQmJm51bGw9PT1lP251bGw6bnVsbD09PWU/dDpudWxsPT09dD9lOnQudW5pb24oZSl9ZXh0cmFjdCgpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuZXh0cmFjdChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9nZW9tRmFjdCYmKHRoaXMuX2dlb21GYWN0PXQuZ2V0RmFjdG9yeSgpKSxfZS5leHRyYWN0KHQscS5UWVBFTkFNRV9QT0xZR09OLHRoaXMuX3BvbHlnb25zKSxfZS5leHRyYWN0KHQscS5UWVBFTkFNRV9MSU5FU1RSSU5HLHRoaXMuX2xpbmVzKSxfZS5leHRyYWN0KHQscS5UWVBFTkFNRV9QT0lOVCx0aGlzLl9wb2ludHMpfX11bmlvbigpe2lmKG51bGw9PT10aGlzLl9nZW9tRmFjdClyZXR1cm4gbnVsbDtsZXQgdD1udWxsO2lmKHRoaXMuX3BvaW50cy5zaXplKCk+MCl7Y29uc3QgZT10aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHRoaXMuX3BvaW50cyk7dD10aGlzLnVuaW9uTm9PcHQoZSl9bGV0IGU9bnVsbDtpZih0aGlzLl9saW5lcy5zaXplKCk+MCl7Y29uc3QgdD10aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHRoaXMuX2xpbmVzKTtlPXRoaXMudW5pb25Ob09wdCh0KX1sZXQgbj1udWxsO3RoaXMuX3BvbHlnb25zLnNpemUoKT4wJiYobj1Wci51bmlvbih0aGlzLl9wb2x5Z29ucykpO2NvbnN0IHM9dGhpcy51bmlvbldpdGhOdWxsKGUsbik7bGV0IGk9bnVsbDtyZXR1cm4gaT1udWxsPT09dD9zOm51bGw9PT1zP3Q6QnIudW5pb24odCxzKSxudWxsPT09aT90aGlzLl9nZW9tRmFjdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTppfWdldENsYXNzKCl7cmV0dXJuIHpyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX16ci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wb2x5Z29ucz1uZXcgeCx0aGlzLl9saW5lcz1uZXcgeCx0aGlzLl9wb2ludHM9bmV3IHgsdGhpcy5fZ2VvbUZhY3Q9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMF0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tRmFjdD1lLHRoaXMuZXh0cmFjdCh0KX19O3ZhciBZcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxVbmFyeVVuaW9uT3A6enJ9KSxVcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxJc1ZhbGlkT3A6Q3IsQ29uc2lzdGVudEFyZWFUZXN0ZXI6RXJ9KSxrcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxCb3VuZGFyeU9wOnB0LElzU2ltcGxlT3A6SHMsYnVmZmVyOndpLGRpc3RhbmNlOlBpLGxpbmVtZXJnZTpYaSxvdmVybGF5OmhyLHBvbHlnb25pemU6UHIscmVsYXRlOnFyLHVuaW9uOllyLHZhbGlkOlVyfSk7Y2xhc3MgWHIgZXh0ZW5kcyBGdC5Db29yZGluYXRlT3BlcmF0aW9ue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxYci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVkaXQoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBxJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IHM9bmV3IGcodFtlXSk7dGhpcy5fdGFyZ2V0UE0ubWFrZVByZWNpc2UocyksbltlXT1zfWNvbnN0IHM9bmV3IEkobiwhMSkudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgaT0wO2UgaW5zdGFuY2VvZiBUdCYmKGk9MiksZSBpbnN0YW5jZW9mIER0JiYoaT00KTtsZXQgcj1uO3JldHVybiB0aGlzLl9yZW1vdmVDb2xsYXBzZWQmJihyPW51bGwpLHMubGVuZ3RoPGk/cjpzfXJldHVybiBzdXBlci5lZGl0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBYcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19WHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdGFyZ2V0UE09bnVsbCx0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fdGFyZ2V0UE09dCx0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9ZX07Y2xhc3MgSHJ7Y29uc3RydWN0b3IoKXtIci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyByZWR1Y2UodCxlKXtyZXR1cm4gbmV3IEhyKGUpLnJlZHVjZSh0KX1zdGF0aWMgcmVkdWNlUG9pbnR3aXNlKHQsZSl7Y29uc3Qgbj1uZXcgSHIoZSk7cmV0dXJuIG4uc2V0UG9pbnR3aXNlKCEwKSxuLnJlZHVjZSh0KX1maXhQb2x5Z29uYWxUb3BvbG9neSh0KXtsZXQgZT10O3RoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsfHwoZT10aGlzLmNoYW5nZVBNKHQsdGhpcy5fdGFyZ2V0UE0pKTtjb25zdCBuPVNpLmJ1ZmZlck9wKGUsMCk7bGV0IHM9bjtyZXR1cm4gdGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWx8fChzPXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5KG4pKSxzfXJlZHVjZVBvaW50d2lzZSh0KXtsZXQgZT1udWxsO2lmKHRoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsKXtjb25zdCBuPXRoaXMuY3JlYXRlRmFjdG9yeSh0LmdldEZhY3RvcnkoKSx0aGlzLl90YXJnZXRQTSk7ZT1uZXcgRnQobil9ZWxzZSBlPW5ldyBGdDtsZXQgbj10aGlzLl9yZW1vdmVDb2xsYXBzZWQ7cmV0dXJuIHQuZ2V0RGltZW5zaW9uKCk+PTImJihuPSEwKSxlLmVkaXQodCxuZXcgWHIodGhpcy5fdGFyZ2V0UE0sbikpfWNoYW5nZVBNKHQsZSl7cmV0dXJuIHRoaXMuY3JlYXRlRWRpdG9yKHQuZ2V0RmFjdG9yeSgpLGUpLmVkaXQodCxuZXcgRnQuTm9PcEdlb21ldHJ5T3BlcmF0aW9uKX1zZXRSZW1vdmVDb2xsYXBzZWRDb21wb25lbnRzKHQpe3RoaXMuX3JlbW92ZUNvbGxhcHNlZD10fWNyZWF0ZUZhY3RvcnkodCxlKXtyZXR1cm4gbmV3IEh0KGUsdC5nZXRTUklEKCksdC5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfXNldENoYW5nZVByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsPXR9cmVkdWNlKHQpe2NvbnN0IGU9dGhpcy5yZWR1Y2VQb2ludHdpc2UodCk7cmV0dXJuIHRoaXMuX2lzUG9pbnR3aXNlP2U6XyhlLE90KT9Dci5pc1ZhbGlkKGUpP2U6dGhpcy5maXhQb2x5Z29uYWxUb3BvbG9neShlKTplfXNldFBvaW50d2lzZSh0KXt0aGlzLl9pc1BvaW50d2lzZT10fWNyZWF0ZUVkaXRvcih0LGUpe2lmKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKT09PWUpcmV0dXJuIG5ldyBGdDtjb25zdCBuPXRoaXMuY3JlYXRlRmFjdG9yeSh0LGUpO3JldHVybiBuZXcgRnQobil9Z2V0Q2xhc3MoKXtyZXR1cm4gSHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUhyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3RhcmdldFBNPW51bGwsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPSEwLHRoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsPSExLHRoaXMuX2lzUG9pbnR3aXNlPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3RhcmdldFBNPXR9O3ZhciBXcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxHZW9tZXRyeVByZWNpc2lvblJlZHVjZXI6SHJ9KTtjbGFzcyBqcntjb25zdHJ1Y3Rvcigpe2pyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcganIodCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5zaW1wbGlmeSgpfXNpbXBsaWZ5U2VjdGlvbih0LGUpe2lmKHQrMT09PWUpcmV0dXJuIG51bGw7dGhpcy5fc2VnLnAwPXRoaXMuX3B0c1t0XSx0aGlzLl9zZWcucDE9dGhpcy5fcHRzW2VdO2xldCBuPS0xLHM9dDtmb3IobGV0IGk9dCsxO2k8ZTtpKyspe2NvbnN0IHQ9dGhpcy5fc2VnLmRpc3RhbmNlKHRoaXMuX3B0c1tpXSk7dD5uJiYobj10LHM9aSl9aWYobjw9dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpZm9yKGxldCBuPXQrMTtuPGU7bisrKXRoaXMuX3VzZVB0W25dPSExO2Vsc2UgdGhpcy5zaW1wbGlmeVNlY3Rpb24odCxzKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbihzLGUpfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9c2ltcGxpZnkoKXt0aGlzLl91c2VQdD1uZXcgQXJyYXkodGhpcy5fcHRzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX3B0cy5sZW5ndGg7dCsrKXRoaXMuX3VzZVB0W3RdPSEwO3RoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5fcHRzLmxlbmd0aC0xKTtjb25zdCB0PW5ldyBJO2ZvcihsZXQgZT0wO2U8dGhpcy5fcHRzLmxlbmd0aDtlKyspdGhpcy5fdXNlUHRbZV0mJnQuYWRkKG5ldyBnKHRoaXMuX3B0c1tlXSkpO3JldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9Z2V0Q2xhc3MoKXtyZXR1cm4ganJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWpyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0cz1udWxsLHRoaXMuX3VzZVB0PW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9zZWc9bmV3IGVlO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0cz10fTtjbGFzcyBLcntjb25zdHJ1Y3Rvcigpe0tyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgS3IodCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfXNldEVuc3VyZVZhbGlkKHQpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10fWdldFJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5pc0VtcHR5KCk/dGhpcy5faW5wdXRHZW9tLmNvcHkoKTpuZXcgWnIodGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PDApdGhyb3cgbmV3IG4oXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1nZXRDbGFzcygpe3JldHVybiBLcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgWnIgZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksWnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgQXQ/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX1jcmVhdGVWYWxpZEFyZWEodCl7cmV0dXJuIHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT90LmJ1ZmZlcigwKTp0fXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IHM9bnVsbDtyZXR1cm4gcz0wPT09bi5sZW5ndGg/bmV3IEFycmF5KDApLmZpbGwobnVsbCk6anIuc2ltcGxpZnkobix0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSksdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1MaW5lYXJSaW5nKHQsZSl7Y29uc3Qgbj1lIGluc3RhbmNlb2YgYnQscz1zdXBlci50cmFuc2Zvcm1MaW5lYXJSaW5nLmNhbGwodGhpcyx0LGUpO3JldHVybiFufHxzIGluc3RhbmNlb2YgRHQ/czpudWxsfWdldENsYXNzKCl7cmV0dXJuIFpyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1aci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITAsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1lfSxLci5EUFRyYW5zZm9ybWVyPVpyLEtyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fTtjbGFzcyBRciBleHRlbmRzIGVle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxRci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEluZGV4KCl7cmV0dXJuIHRoaXMuX2luZGV4fWdldFBhcmVudCgpe3JldHVybiB0aGlzLl9wYXJlbnR9Z2V0Q2xhc3MoKXtyZXR1cm4gUXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVFyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3BhcmVudD1udWxsLHRoaXMuX2luZGV4PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1FyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG51bGwsLTEpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2VlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLl9wYXJlbnQ9bix0aGlzLl9pbmRleD1zfX07Y2xhc3MgSnJ7Y29uc3RydWN0b3IoKXtKci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBleHRyYWN0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkrMSkuZmlsbChudWxsKTtsZXQgbj1udWxsO2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKW49dC5nZXQocyksZVtzXT1uLnAwO3JldHVybiBlW2UubGVuZ3RoLTFdPW4ucDEsZX1hZGRUb1Jlc3VsdCh0KXt0aGlzLl9yZXN1bHRTZWdzLmFkZCh0KX1hc0xpbmVTdHJpbmcoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhKci5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5fcmVzdWx0U2VncykpfWdldFJlc3VsdFNpemUoKXtjb25zdCB0PXRoaXMuX3Jlc3VsdFNlZ3Muc2l6ZSgpO3JldHVybiAwPT09dD8wOnQrMX1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZX1nZXRTZWdtZW50KHQpe3JldHVybiB0aGlzLl9zZWdzW3RdfWdldFBhcmVudENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKX1nZXRNaW5pbXVtU2l6ZSgpe3JldHVybiB0aGlzLl9taW5pbXVtU2l6ZX1hc0xpbmVhclJpbmcoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhKci5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5fcmVzdWx0U2VncykpfWdldFNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX3NlZ3N9aW5pdCgpe2NvbnN0IHQ9dGhpcy5fcGFyZW50TGluZS5nZXRDb29yZGluYXRlcygpO3RoaXMuX3NlZ3M9bmV3IEFycmF5KHQubGVuZ3RoLTEpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0xO2UrKyl7Y29uc3Qgbj1uZXcgUXIodFtlXSx0W2UrMV0sdGhpcy5fcGFyZW50TGluZSxlKTt0aGlzLl9zZWdzW2VdPW59fWdldFJlc3VsdENvb3JkaW5hdGVzKCl7cmV0dXJuIEpyLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLl9yZXN1bHRTZWdzKX1nZXRDbGFzcygpe3JldHVybiBKcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcGFyZW50TGluZT1udWxsLHRoaXMuX3NlZ3M9bnVsbCx0aGlzLl9yZXN1bHRTZWdzPW5ldyB4LHRoaXMuX21pbmltdW1TaXplPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0pyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwyKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wYXJlbnRMaW5lPXQsdGhpcy5fbWluaW11bVNpemU9ZSx0aGlzLmluaXQoKX19O2NsYXNzICRye2NvbnN0cnVjdG9yKCl7JHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZW1vdmUodCl7dGhpcy5faW5kZXgucmVtb3ZlKG5ldyBOKHQucDAsdC5wMSksdCl9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBKcil7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0U2VnbWVudHMoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj10W2VdO3RoaXMuYWRkKG4pfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2luZGV4Lmluc2VydChuZXcgTih0LnAwLHQucDEpLHQpfX1xdWVyeSh0KXtjb25zdCBlPW5ldyBOKHQucDAsdC5wMSksbj1uZXcgdG8odCk7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KGUsbiksbi5nZXRJdGVtcygpfWdldENsYXNzKCl7cmV0dXJuICRyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX0kci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbmRleD1uZXcgdXN9O2NsYXNzIHRve2NvbnN0cnVjdG9yKCl7dG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdEl0ZW0odCl7Y29uc3QgZT10O04uaW50ZXJzZWN0cyhlLnAwLGUucDEsdGhpcy5fcXVlcnlTZWcucDAsdGhpcy5fcXVlcnlTZWcucDEpJiZ0aGlzLl9pdGVtcy5hZGQodCl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9Z2V0Q2xhc3MoKXtyZXR1cm4gdG99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FlXX19dG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcXVlcnlTZWc9bnVsbCx0aGlzLl9pdGVtcz1uZXcgeDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9xdWVyeVNlZz10fTtjbGFzcyBlb3tjb25zdHJ1Y3Rvcigpe2VvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzSW5MaW5lU2VjdGlvbih0LGUsbil7aWYobi5nZXRQYXJlbnQoKSE9PXQuZ2V0UGFyZW50KCkpcmV0dXJuITE7Y29uc3Qgcz1uLmdldEluZGV4KCk7cmV0dXJuIHM+PWVbMF0mJnM8ZVsxXX1mbGF0dGVuKHQsZSl7Y29uc3Qgbj10aGlzLl9saW5lUHRzW3RdLHM9dGhpcy5fbGluZVB0c1tlXSxpPW5ldyBlZShuLHMpO3JldHVybiB0aGlzLnJlbW92ZSh0aGlzLl9saW5lLHQsZSksdGhpcy5fb3V0cHV0SW5kZXguYWRkKGkpLGl9aGFzQmFkSW50ZXJzZWN0aW9uKHQsZSxuKXtyZXR1cm4hIXRoaXMuaGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uKG4pfHwhIXRoaXMuaGFzQmFkSW5wdXRJbnRlcnNlY3Rpb24odCxlLG4pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9c2ltcGxpZnlTZWN0aW9uKHQsZSxuKXtuKz0xO2NvbnN0IHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodCsxPT09ZSl7Y29uc3QgZT10aGlzLl9saW5lLmdldFNlZ21lbnQodCk7cmV0dXJuIHRoaXMuX2xpbmUuYWRkVG9SZXN1bHQoZSksbnVsbH1sZXQgaT0hMDtpZih0aGlzLl9saW5lLmdldFJlc3VsdFNpemUoKTx0aGlzLl9saW5lLmdldE1pbmltdW1TaXplKCkpe24rMTx0aGlzLl9saW5lLmdldE1pbmltdW1TaXplKCkmJihpPSExKX1jb25zdCByPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG89dGhpcy5maW5kRnVydGhlc3RQb2ludCh0aGlzLl9saW5lUHRzLHQsZSxyKTtyWzBdPnRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlJiYoaT0hMSk7Y29uc3QgbD1uZXcgZWU7aWYobC5wMD10aGlzLl9saW5lUHRzW3RdLGwucDE9dGhpcy5fbGluZVB0c1tlXSxzWzBdPXQsc1sxXT1lLHRoaXMuaGFzQmFkSW50ZXJzZWN0aW9uKHRoaXMuX2xpbmUscyxsKSYmKGk9ITEpLGkpe2NvbnN0IG49dGhpcy5mbGF0dGVuKHQsZSk7cmV0dXJuIHRoaXMuX2xpbmUuYWRkVG9SZXN1bHQobiksbnVsbH10aGlzLnNpbXBsaWZ5U2VjdGlvbih0LG8sbiksdGhpcy5zaW1wbGlmeVNlY3Rpb24obyxlLG4pfWhhc0JhZE91dHB1dEludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9dGhpcy5fb3V0cHV0SW5kZXgucXVlcnkodCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihuLHQpKXJldHVybiEwfXJldHVybiExfWZpbmRGdXJ0aGVzdFBvaW50KHQsZSxuLHMpe2NvbnN0IGk9bmV3IGVlO2kucDA9dFtlXSxpLnAxPXRbbl07bGV0IHI9LTEsbz1lO2ZvcihsZXQgcz1lKzE7czxuO3MrKyl7Y29uc3QgZT10W3NdLG49aS5kaXN0YW5jZShlKTtuPnImJihyPW4sbz1zKX1yZXR1cm4gc1swXT1yLG99c2ltcGxpZnkodCl7dGhpcy5fbGluZT10LHRoaXMuX2xpbmVQdHM9dC5nZXRQYXJlbnRDb29yZGluYXRlcygpLHRoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5fbGluZVB0cy5sZW5ndGgtMSwwKX1yZW1vdmUodCxlLG4pe2ZvcihsZXQgcz1lO3M8bjtzKyspe2NvbnN0IGU9dC5nZXRTZWdtZW50KHMpO3RoaXMuX2lucHV0SW5kZXgucmVtb3ZlKGUpfX1oYXNJbnRlcmlvckludGVyc2VjdGlvbih0LGUpe3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQucDAsdC5wMSxlLnAwLGUucDEpLHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKX1oYXNCYWRJbnB1dEludGVyc2VjdGlvbih0LGUsbil7Zm9yKGxldCBzPXRoaXMuX2lucHV0SW5kZXgucXVlcnkobikuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGk9cy5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihpLG4pKXtpZihlby5pc0luTGluZVNlY3Rpb24odCxlLGkpKWNvbnRpbnVlO3JldHVybiEwfX1yZXR1cm4hMX1nZXRDbGFzcygpe3JldHVybiBlb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bmV3IHRlLHRoaXMuX2lucHV0SW5kZXg9bmV3ICRyLHRoaXMuX291dHB1dEluZGV4PW5ldyAkcix0aGlzLl9saW5lPW51bGwsdGhpcy5fbGluZVB0cz1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRJbmRleD10LHRoaXMuX291dHB1dEluZGV4PWV9O2NsYXNzIG5ve2NvbnN0cnVjdG9yKCl7bm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fXNpbXBsaWZ5KHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuX2lucHV0SW5kZXguYWRkKGUubmV4dCgpKTtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1uZXcgZW8odGhpcy5faW5wdXRJbmRleCx0aGlzLl9vdXRwdXRJbmRleCk7dC5zZXREaXN0YW5jZVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSksdC5zaW1wbGlmeShlLm5leHQoKSl9fWdldENsYXNzKCl7cmV0dXJuIG5vfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1uby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEluZGV4PW5ldyAkcix0aGlzLl9vdXRwdXRJbmRleD1uZXcgJHIsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9MH07Y2xhc3Mgc297Y29uc3RydWN0b3IoKXtzby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IHNvKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1nZXRSZXN1bHRHZW9tZXRyeSgpe2lmKHRoaXMuX2lucHV0R2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2lucHV0R2VvbS5jb3B5KCk7cmV0dXJuIHRoaXMuX2xpbmVzdHJpbmdNYXA9bmV3IFV0LHRoaXMuX2lucHV0R2VvbS5hcHBseShuZXcgcm8odGhpcykpLHRoaXMuX2xpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KHRoaXMuX2xpbmVzdHJpbmdNYXAudmFsdWVzKCkpLG5ldyBpbyh0aGlzLl9saW5lc3RyaW5nTWFwKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PDApdGhyb3cgbmV3IG4oXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5fbGluZVNpbXBsaWZpZXIuc2V0RGlzdGFuY2VUb2xlcmFuY2UodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gc299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGlvIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLGlvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtpZigwPT09dC5zaXplKCkpcmV0dXJuIG51bGw7aWYoZSBpbnN0YW5jZW9mIFR0KXtjb25zdCB0PXRoaXMuX2xpbmVzdHJpbmdNYXAuZ2V0KGUpO3JldHVybiB0aGlzLmNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZSh0LmdldFJlc3VsdENvb3JkaW5hdGVzKCkpfXJldHVybiBzdXBlci50cmFuc2Zvcm1Db29yZGluYXRlcy5jYWxsKHRoaXMsdCxlKX1nZXRDbGFzcygpe3JldHVybiBpb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZXN0cmluZ01hcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVzdHJpbmdNYXA9dH07Y2xhc3Mgcm97Y29uc3RydWN0b3IoKXtyby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXtpZih0IGluc3RhbmNlb2YgVHQpe2NvbnN0IGU9dDtpZihlLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPWUuaXNDbG9zZWQoKT80OjIscz1uZXcgSnIoZSxuKTt0aGlzLnRwcy5fbGluZXN0cmluZ01hcC5wdXQoZSxzKX19Z2V0Q2xhc3MoKXtyZXR1cm4gcm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ddfX1yby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLnRwcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMudHBzPXR9LHNvLkxpbmVTdHJpbmdUcmFuc2Zvcm1lcj1pbyxzby5MaW5lU3RyaW5nTWFwQnVpbGRlckZpbHRlcj1ybyxzby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9saW5lU2ltcGxpZmllcj1uZXcgbm8sdGhpcy5fbGluZXN0cmluZ01hcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fTtjbGFzcyBvb3tjb25zdHJ1Y3Rvcigpe29vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNpbXBsaWZ5KHQsZSl7cmV0dXJuIG5ldyBvbyh0LGUpLnNpbXBsaWZ5KCl9c2ltcGxpZnlWZXJ0ZXgodCl7bGV0IGU9dCxuPWUuZ2V0QXJlYSgpLHM9bnVsbDtmb3IoO251bGwhPT1lOyl7Y29uc3QgdD1lLmdldEFyZWEoKTt0PG4mJihuPXQscz1lKSxlPWUuX25leHR9cmV0dXJuIG51bGwhPT1zJiZuPHRoaXMuX3RvbGVyYW5jZSYmcy5yZW1vdmUoKSx0LmlzTGl2ZSgpP246LTF9c2ltcGxpZnkoKXtjb25zdCB0PWxvLmJ1aWxkTGluZSh0aGlzLl9wdHMpO2xldCBlPXRoaXMuX3RvbGVyYW5jZTtkb3tlPXRoaXMuc2ltcGxpZnlWZXJ0ZXgodCl9d2hpbGUoZTx0aGlzLl90b2xlcmFuY2UpO2NvbnN0IG49dC5nZXRDb29yZGluYXRlcygpO3JldHVybiBuLmxlbmd0aDwyP1tuWzBdLG5ldyBnKG5bMF0pXTpufWdldENsYXNzKCl7cmV0dXJuIG9vfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBsb3tjb25zdHJ1Y3Rvcigpe2xvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGJ1aWxkTGluZSh0KXtsZXQgZT1udWxsLG49bnVsbDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl7Y29uc3QgaT1uZXcgbG8odFtzXSk7bnVsbD09PWUmJihlPWkpLGkuc2V0UHJldihuKSxudWxsIT09biYmKG4uc2V0TmV4dChpKSxuLnVwZGF0ZUFyZWEoKSksbj1pfXJldHVybiBlfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgSTtsZXQgZT10aGlzO2Rve3QuYWRkKGUuX3B0LCExKSxlPWUuX25leHR9d2hpbGUobnVsbCE9PWUpO3JldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9Z2V0QXJlYSgpe3JldHVybiB0aGlzLl9hcmVhfXVwZGF0ZUFyZWEoKXtpZihudWxsPT09dGhpcy5fcHJldnx8bnVsbD09PXRoaXMuX25leHQpcmV0dXJuIHRoaXMuX2FyZWE9bG8uTUFYX0FSRUEsbnVsbDt0aGlzLl9hcmVhPU1hdGguYWJzKHJlLmFyZWEodGhpcy5fcHJldi5fcHQsdGhpcy5fcHQsdGhpcy5fbmV4dC5fcHQpKX1yZW1vdmUoKXtjb25zdCB0PXRoaXMuX3ByZXYsZT10aGlzLl9uZXh0O2xldCBuPW51bGw7cmV0dXJuIG51bGwhPT10aGlzLl9wcmV2JiYodGhpcy5fcHJldi5zZXROZXh0KGUpLHRoaXMuX3ByZXYudXBkYXRlQXJlYSgpLG49dGhpcy5fcHJldiksbnVsbCE9PXRoaXMuX25leHQmJih0aGlzLl9uZXh0LnNldFByZXYodCksdGhpcy5fbmV4dC51cGRhdGVBcmVhKCksbnVsbD09PW4mJihuPXRoaXMuX25leHQpKSx0aGlzLl9pc0xpdmU9ITEsbn1pc0xpdmUoKXtyZXR1cm4gdGhpcy5faXNMaXZlfXNldFByZXYodCl7dGhpcy5fcHJldj10fXNldE5leHQodCl7dGhpcy5fbmV4dD10fWdldENsYXNzKCl7cmV0dXJuIGxvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1sby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdD1udWxsLHRoaXMuX3ByZXY9bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fYXJlYT1sby5NQVhfQVJFQSx0aGlzLl9pc0xpdmU9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHQ9dH0sbG8uTUFYX0FSRUE9aS5NQVhfVkFMVUUsb28uVldWZXJ0ZXg9bG8sb28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fdG9sZXJhbmNlPWUqZX07Y2xhc3MgYW97Y29uc3RydWN0b3IoKXthby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IGFvKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1zZXRFbnN1cmVWYWxpZCh0KXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dH1nZXRSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpP3RoaXMuX2lucHV0R2VvbS5jb3B5KCk6bmV3IGNvKHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neSx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBuKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9Z2V0Q2xhc3MoKXtyZXR1cm4gYW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGNvIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLGNvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dHJhbnNmb3JtUG9seWdvbih0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIEF0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9Y3JlYXRlVmFsaWRBcmVhKHQpe3JldHVybiB0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k/dC5idWZmZXIoMCk6dH10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBzPW51bGw7cmV0dXJuIHM9MD09PW4ubGVuZ3RoP25ldyBBcnJheSgwKS5maWxsKG51bGwpOm9vLnNpbXBsaWZ5KG4sdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtTGluZWFyUmluZyh0LGUpe2NvbnN0IG49ZSBpbnN0YW5jZW9mIGJ0LHM9c3VwZXIudHJhbnNmb3JtTGluZWFyUmluZy5jYWxsKHRoaXMsdCxlKTtyZXR1cm4hbnx8cyBpbnN0YW5jZW9mIER0P3M6bnVsbH1nZXRDbGFzcygpe3JldHVybiBjb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXQsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9ZX0sYW8uVldUcmFuc2Zvcm1lcj1jbyxhby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH07dmFyIGhvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERvdWdsYXNQZXVja2VyU2ltcGxpZmllcjpLcixUb3BvbG9neVByZXNlcnZpbmdTaW1wbGlmaWVyOnNvLFZXU2ltcGxpZmllcjphb30pO2NsYXNzIHVve2NvbnN0cnVjdG9yKCl7dW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcG9pbnRBbG9uZ1JldmVyc2UodCxlKXtjb25zdCBuPW5ldyBnO3JldHVybiBuLng9dC5wMS54LWUqKHQucDEueC10LnAwLngpLG4ueT10LnAxLnktZSoodC5wMS55LXQucDAueSksbn1zcGxpdEF0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5fbWluaW11bUxlbi90aGlzLl9zZWdMZW47aWYodC5kaXN0YW5jZSh0aGlzLl9zZWcucDApPHRoaXMuX21pbmltdW1MZW4pcmV0dXJuIHRoaXMuX3NwbGl0UHQ9dGhpcy5fc2VnLnBvaW50QWxvbmcoZSksbnVsbDtpZih0LmRpc3RhbmNlKHRoaXMuX3NlZy5wMSk8dGhpcy5fbWluaW11bUxlbilyZXR1cm4gdGhpcy5fc3BsaXRQdD11by5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLl9zZWcsZSksbnVsbDt0aGlzLl9zcGxpdFB0PXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLmdldENvbnN0cmFpbmVkTGVuZ3RoKHQpL3RoaXMuX3NlZ0xlbjtlLmVxdWFsczJEKHRoaXMuX3NlZy5wMCk/dGhpcy5fc3BsaXRQdD10aGlzLl9zZWcucG9pbnRBbG9uZyhuKTp0aGlzLl9zcGxpdFB0PXVvLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuX3NlZyxuKX19c2V0TWluaW11bUxlbmd0aCh0KXt0aGlzLl9taW5pbXVtTGVuPXR9Z2V0Q29uc3RyYWluZWRMZW5ndGgodCl7cmV0dXJuIHQ8dGhpcy5fbWluaW11bUxlbj90aGlzLl9taW5pbXVtTGVuOnR9Z2V0U3BsaXRQb2ludCgpe3JldHVybiB0aGlzLl9zcGxpdFB0fWdldENsYXNzKCl7cmV0dXJuIHVvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX11by5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zZWc9bnVsbCx0aGlzLl9zZWdMZW49bnVsbCx0aGlzLl9zcGxpdFB0PW51bGwsdGhpcy5fbWluaW11bUxlbj0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NlZz10LHRoaXMuX3NlZ0xlbj10LmdldExlbmd0aCgpfTtjbGFzcyBnb3tjb25zdHJ1Y3Rvcigpe2dvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluZFNwbGl0UG9pbnQodCxlKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gZ299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWdvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgX297Y29uc3RydWN0b3IoKXtfby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBwcm9qZWN0ZWRTcGxpdFBvaW50KHQsZSl7cmV0dXJuIHQuZ2V0TGluZVNlZ21lbnQoKS5wcm9qZWN0KGUpfWZpbmRTcGxpdFBvaW50KHQsZSl7Y29uc3Qgbj10LmdldExpbmVTZWdtZW50KCkscz1uLmdldExlbmd0aCgpLzIsaT1uZXcgdW8obikscj1fby5wcm9qZWN0ZWRTcGxpdFBvaW50KHQsZSk7bGV0IG89MipyLmRpc3RhbmNlKGUpKi44O3JldHVybiBvPnMmJihvPXMpLGkuc2V0TWluaW11bUxlbmd0aChvKSxpLnNwbGl0QXQociksaS5nZXRTcGxpdFBvaW50KCl9Z2V0Q2xhc3MoKXtyZXR1cm4gX299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2dvXX19X28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBmb3tjb25zdHJ1Y3Rvcigpe2ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRyaUFyZWEodCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKGUueS10LnkpKihuLngtdC54KX1zdGF0aWMgaXNJbkNpcmNsZURETm9ybWFsaXplZCh0LGUsbixzKXtjb25zdCBpPVIudmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChzLngpLHI9Ui52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KHMueSksbz1SLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3Qocy54KSxsPVIudmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdChzLnkpLGE9Ui52YWx1ZU9mKG4ueCkuc2VsZlN1YnRyYWN0KHMueCksYz1SLnZhbHVlT2Yobi55KS5zZWxmU3VidHJhY3Qocy55KSxoPWkubXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KG8ubXVsdGlwbHkocikpLHU9by5tdWx0aXBseShjKS5zZWxmU3VidHJhY3QoYS5tdWx0aXBseShsKSksZz1hLm11bHRpcGx5KHIpLnNlbGZTdWJ0cmFjdChpLm11bHRpcGx5KGMpKSxkPWkubXVsdGlwbHkoaSkuc2VsZkFkZChyLm11bHRpcGx5KHIpKSxfPW8ubXVsdGlwbHkobykuc2VsZkFkZChsLm11bHRpcGx5KGwpKSxmPWEubXVsdGlwbHkoYSkuc2VsZkFkZChjLm11bHRpcGx5KGMpKTtyZXR1cm4gZC5zZWxmTXVsdGlwbHkodSkuc2VsZkFkZChfLnNlbGZNdWx0aXBseShnKSkuc2VsZkFkZChmLnNlbGZNdWx0aXBseShoKSkuZG91YmxlVmFsdWUoKT4wfXN0YXRpYyBjaGVja1JvYnVzdEluQ2lyY2xlKHQsZSxuLHMpe2NvbnN0IGk9Zm8uaXNJbkNpcmNsZU5vblJvYnVzdCh0LGUsbixzKSxyPWZvLmlzSW5DaXJjbGVERFNsb3codCxlLG4scyksbz1mby5pc0luQ2lyY2xlQ0ModCxlLG4scyksbD1yZS5jaXJjdW1jZW50cmUodCxlLG4pO08ub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGEgPSBcIitNYXRoLmFicyhzLmRpc3RhbmNlKGwpLXQuZGlzdGFuY2UobCkpL3QuZGlzdGFuY2UobCkpLGk9PT1yJiZpPT09b3x8KE8ub3V0LnByaW50bG4oXCJpbkNpcmNsZSByb2J1c3RuZXNzIGZhaWx1cmUgKGRvdWJsZSByZXN1bHQgPSBcIitpK1wiLCBERCByZXN1bHQgPSBcIityK1wiLCBDQyByZXN1bHQgPSBcIitvK1wiKVwiKSxPLm91dC5wcmludGxuKEp0LnRvTGluZVN0cmluZyhuZXcgenQoW3QsZSxuLHNdKSkpLE8ub3V0LnByaW50bG4oXCJDaXJjdW1jZW50cmUgPSBcIitKdC50b1BvaW50KGwpK1wiIHJhZGl1cyA9IFwiK3QuZGlzdGFuY2UobCkpLE8ub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGEgPSBcIitNYXRoLmFicyhzLmRpc3RhbmNlKGwpL3QuZGlzdGFuY2UobCktMSkpLE8ub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGIgPSBcIitNYXRoLmFicyhzLmRpc3RhbmNlKGwpL2UuZGlzdGFuY2UobCktMSkpLE8ub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGMgPSBcIitNYXRoLmFicyhzLmRpc3RhbmNlKGwpL24uZGlzdGFuY2UobCktMSkpLE8ub3V0LnByaW50bG4oKSl9c3RhdGljIGlzSW5DaXJjbGVEREZhc3QodCxlLG4scyl7Y29uc3QgaT1SLnNxcih0LngpLnNlbGZBZGQoUi5zcXIodC55KSkuc2VsZk11bHRpcGx5KGZvLnRyaUFyZWFEREZhc3QoZSxuLHMpKSxyPVIuc3FyKGUueCkuc2VsZkFkZChSLnNxcihlLnkpKS5zZWxmTXVsdGlwbHkoZm8udHJpQXJlYURERmFzdCh0LG4scykpLG89Ui5zcXIobi54KS5zZWxmQWRkKFIuc3FyKG4ueSkpLnNlbGZNdWx0aXBseShmby50cmlBcmVhRERGYXN0KHQsZSxzKSksbD1SLnNxcihzLngpLnNlbGZBZGQoUi5zcXIocy55KSkuc2VsZk11bHRpcGx5KGZvLnRyaUFyZWFEREZhc3QodCxlLG4pKTtyZXR1cm4gaS5zZWxmU3VidHJhY3Qocikuc2VsZkFkZChvKS5zZWxmU3VidHJhY3QobCkuZG91YmxlVmFsdWUoKT4wfXN0YXRpYyBpc0luQ2lyY2xlQ0ModCxlLG4scyl7Y29uc3QgaT1yZS5jaXJjdW1jZW50cmUodCxlLG4pLHI9dC5kaXN0YW5jZShpKTtyZXR1cm4gcy5kaXN0YW5jZShpKS1yPD0wfXN0YXRpYyBpc0luQ2lyY2xlTm9ybWFsaXplZCh0LGUsbixzKXtjb25zdCBpPXQueC1zLngscj10Lnktcy55LG89ZS54LXMueCxsPWUueS1zLnksYT1uLngtcy54LGM9bi55LXMueTtyZXR1cm4oaSppK3IqcikqKG8qYy1hKmwpKyhvKm8rbCpsKSooYSpyLWkqYykrKGEqYStjKmMpKihpKmwtbypyKT4wfXN0YXRpYyBpc0luQ2lyY2xlRERTbG93KHQsZSxuLHMpe2NvbnN0IGk9Ui52YWx1ZU9mKHMueCkscj1SLnZhbHVlT2Yocy55KSxvPVIudmFsdWVPZih0LngpLGw9Ui52YWx1ZU9mKHQueSksYT1SLnZhbHVlT2YoZS54KSxjPVIudmFsdWVPZihlLnkpLGg9Ui52YWx1ZU9mKG4ueCksdT1SLnZhbHVlT2Yobi55KSxnPW8ubXVsdGlwbHkobykuYWRkKGwubXVsdGlwbHkobCkpLm11bHRpcGx5KGZvLnRyaUFyZWFERFNsb3coYSxjLGgsdSxpLHIpKSxkPWEubXVsdGlwbHkoYSkuYWRkKGMubXVsdGlwbHkoYykpLm11bHRpcGx5KGZvLnRyaUFyZWFERFNsb3cobyxsLGgsdSxpLHIpKSxfPWgubXVsdGlwbHkoaCkuYWRkKHUubXVsdGlwbHkodSkpLm11bHRpcGx5KGZvLnRyaUFyZWFERFNsb3cobyxsLGEsYyxpLHIpKSxmPWkubXVsdGlwbHkoaSkuYWRkKHIubXVsdGlwbHkocikpLm11bHRpcGx5KGZvLnRyaUFyZWFERFNsb3cobyxsLGEsYyxoLHUpKTtyZXR1cm4gZy5zdWJ0cmFjdChkKS5hZGQoXykuc3VidHJhY3QoZikuZG91YmxlVmFsdWUoKT4wfXN0YXRpYyBpc0luQ2lyY2xlTm9uUm9idXN0KHQsZSxuLHMpe3JldHVybih0LngqdC54K3QueSp0LnkpKmZvLnRyaUFyZWEoZSxuLHMpLShlLngqZS54K2UueSplLnkpKmZvLnRyaUFyZWEodCxuLHMpKyhuLngqbi54K24ueSpuLnkpKmZvLnRyaUFyZWEodCxlLHMpLShzLngqcy54K3MueSpzLnkpKmZvLnRyaUFyZWEodCxlLG4pPjB9c3RhdGljIGlzSW5DaXJjbGVSb2J1c3QodCxlLG4scyl7cmV0dXJuIGZvLmlzSW5DaXJjbGVOb3JtYWxpemVkKHQsZSxuLHMpfXN0YXRpYyB0cmlBcmVhRERTbG93KHQsZSxuLHMsaSxyKXtyZXR1cm4gbi5zdWJ0cmFjdCh0KS5tdWx0aXBseShyLnN1YnRyYWN0KGUpKS5zdWJ0cmFjdChzLnN1YnRyYWN0KGUpLm11bHRpcGx5KGkuc3VidHJhY3QodCkpKX1zdGF0aWMgdHJpQXJlYURERmFzdCh0LGUsbil7Y29uc3Qgcz1SLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KHQueSkpLGk9Ui52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkuc2VsZk11bHRpcGx5KFIudmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdCh0LngpKTtyZXR1cm4gcy5zZWxmU3VidHJhY3QoaSl9Z2V0Q2xhc3MoKXtyZXR1cm4gZm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgcG97Y29uc3RydWN0b3IoKXtwby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbnRlcnBvbGF0ZVooKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1lLmRpc3RhbmNlKG4pLGk9dC5kaXN0YW5jZShlKSxyPW4uei1lLno7cmV0dXJuIGUueityKihpL3MpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWUueCxyPWUueSxvPW4ueC1pLGw9cy54LWksYT1uLnktcixjPXMueS1yLGg9bypjLWwqYSx1PXQueC1pLGc9dC55LXIsZD0oYyp1LWwqZykvaCxfPSgtYSp1K28qZykvaDtyZXR1cm4gZS56K2QqKG4uei1lLnopK18qKHMuei1lLnopfX1jaXJjbGVDZW50ZXIodCxlKXtjb25zdCBuPW5ldyBwbyh0aGlzLmdldFgoKSx0aGlzLmdldFkoKSkscz10aGlzLmJpc2VjdG9yKG4sdCksaT10aGlzLmJpc2VjdG9yKHQsZSkscj1uZXcgYihzLGkpO2xldCBvPW51bGw7dHJ5e289bmV3IHBvKHIuZ2V0WCgpLHIuZ2V0WSgpKX1jYXRjaChzKXtpZighKHMgaW5zdGFuY2VvZiBTKSl0aHJvdyBzO08uZXJyLnByaW50bG4oXCJhOiBcIituK1wiICBiOiBcIit0K1wiICBjOiBcIitlKSxPLmVyci5wcmludGxuKHMpfXJldHVybiBvfWRvdCh0KXtyZXR1cm4gdGhpcy5fcC54KnQuZ2V0WCgpK3RoaXMuX3AueSp0LmdldFkoKX1tYWduKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLl9wLngqdGhpcy5fcC54K3RoaXMuX3AueSp0aGlzLl9wLnkpfWdldFooKXtyZXR1cm4gdGhpcy5fcC56fWJpc2VjdG9yKHQsZSl7Y29uc3Qgbj1lLmdldFgoKS10LmdldFgoKSxzPWUuZ2V0WSgpLXQuZ2V0WSgpLGk9bmV3IGIodC5nZXRYKCkrbi8yLHQuZ2V0WSgpK3MvMiwxKSxyPW5ldyBiKHQuZ2V0WCgpLXMrbi8yLHQuZ2V0WSgpK24rcy8yLDEpO3JldHVybiBuZXcgYihpLHIpfWVxdWFscygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fcC54PT09dC5nZXRYKCkmJnRoaXMuX3AueT09PXQuZ2V0WSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fcC5kaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoKSk8ZX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wfWlzSW5DaXJjbGUodCxlLG4pe3JldHVybiBmby5pc0luQ2lyY2xlUm9idXN0KHQuX3AsZS5fcCxuLl9wLHRoaXMuX3ApfWludGVycG9sYXRlWlZhbHVlKHQsZSxuKXtjb25zdCBzPXQuZ2V0WCgpLGk9dC5nZXRZKCkscj1lLmdldFgoKS1zLG89bi5nZXRYKCktcyxsPWUuZ2V0WSgpLWksYT1uLmdldFkoKS1pLGM9ciphLW8qbCxoPXRoaXMuZ2V0WCgpLXMsdT10aGlzLmdldFkoKS1pLGc9KGEqaC1vKnUpL2MsZD0oLWwqaCtyKnUpL2M7cmV0dXJuIHQuZ2V0WigpK2cqKGUuZ2V0WigpLXQuZ2V0WigpKStkKihuLmdldFooKS10LmdldFooKSl9bWlkUG9pbnQodCl7Y29uc3QgZT0odGhpcy5fcC54K3QuZ2V0WCgpKS8yLG49KHRoaXMuX3AueSt0LmdldFkoKSkvMixzPSh0aGlzLl9wLnordC5nZXRaKCkpLzI7cmV0dXJuIG5ldyBwbyhlLG4scyl9cmlnaHRPZih0KXtyZXR1cm4gdGhpcy5pc0NDVyh0LmRlc3QoKSx0Lm9yaWcoKSl9aXNDQ1codCxlKXtyZXR1cm4odC5fcC54LXRoaXMuX3AueCkqKGUuX3AueS10aGlzLl9wLnkpLSh0Ll9wLnktdGhpcy5fcC55KSooZS5fcC54LXRoaXMuX3AueCk+MH1nZXRYKCl7cmV0dXJuIHRoaXMuX3AueH1jcm9zc1Byb2R1Y3QodCl7cmV0dXJuIHRoaXMuX3AueCp0LmdldFkoKS10aGlzLl9wLnkqdC5nZXRYKCl9c2V0Wih0KXt0aGlzLl9wLno9dH10aW1lcyh0KXtyZXR1cm4gbmV3IHBvKHQqdGhpcy5fcC54LHQqdGhpcy5fcC55KX1jcm9zcygpe3JldHVybiBuZXcgcG8odGhpcy5fcC55LC10aGlzLl9wLngpfWxlZnRPZih0KXtyZXR1cm4gdGhpcy5pc0NDVyh0Lm9yaWcoKSx0LmRlc3QoKSl9dG9TdHJpbmcoKXtyZXR1cm5cIlBPSU5UIChcIit0aGlzLl9wLngrXCIgXCIrdGhpcy5fcC55K1wiKVwifXN1Yih0KXtyZXR1cm4gbmV3IHBvKHRoaXMuX3AueC10LmdldFgoKSx0aGlzLl9wLnktdC5nZXRZKCkpfWdldFkoKXtyZXR1cm4gdGhpcy5fcC55fWNsYXNzaWZ5KHQsZSl7Y29uc3Qgbj1lLnN1Yih0KSxzPXRoaXMuc3ViKHQpLGk9bi5jcm9zc1Byb2R1Y3Qocyk7cmV0dXJuIGk+MD9wby5MRUZUOmk8MD9wby5SSUdIVDpuLmdldFgoKSpzLmdldFgoKTwwfHxuLmdldFkoKSpzLmdldFkoKTwwP3BvLkJFSElORDpuLm1hZ24oKTxzLm1hZ24oKT9wby5CRVlPTkQ6dC5lcXVhbHModGhpcyk/cG8uT1JJR0lOOmUuZXF1YWxzKHRoaXMpP3BvLkRFU1RJTkFUSU9OOnBvLkJFVFdFRU59c3VtKHQpe3JldHVybiBuZXcgcG8odGhpcy5fcC54K3QuZ2V0WCgpLHRoaXMuX3AueSt0LmdldFkoKSl9ZGlzdGFuY2UodCxlKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGUuZ2V0WCgpLXQuZ2V0WCgpLDIpK01hdGgucG93KGUuZ2V0WSgpLXQuZ2V0WSgpLDIpKX1jaXJjdW1SYWRpdXNSYXRpbyh0LGUpe2NvbnN0IG49dGhpcy5jaXJjbGVDZW50ZXIodCxlKSxzPXRoaXMuZGlzdGFuY2Uobix0KTtsZXQgaT10aGlzLmRpc3RhbmNlKHRoaXMsdCkscj10aGlzLmRpc3RhbmNlKHQsZSk7cmV0dXJuIHI8aSYmKGk9cikscj10aGlzLmRpc3RhbmNlKGUsdGhpcykscjxpJiYoaT1yKSxzL2l9Z2V0Q2xhc3MoKXtyZXR1cm4gcG99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXBvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3A9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcD1uZXcgZyh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wPW5ldyBnKHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcD1uZXcgZyh0LGUsbil9fSxwby5MRUZUPTAscG8uUklHSFQ9MSxwby5CRVlPTkQ9Mixwby5CRUhJTkQ9Myxwby5CRVRXRUVOPTQscG8uT1JJR0lOPTUscG8uREVTVElOQVRJT049NjtjbGFzcyBtbyBleHRlbmRzIHBve2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxtby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvbnN0cmFpbnQoKXtyZXR1cm4gdGhpcy5fY29uc3RyYWludH1zZXRPbkNvbnN0cmFpbnQodCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9dH1tZXJnZSh0KXt0Ll9pc09uQ29uc3RyYWludCYmKHRoaXMuX2lzT25Db25zdHJhaW50PSEwLHRoaXMuX2NvbnN0cmFpbnQ9dC5fY29uc3RyYWludCl9aXNPbkNvbnN0cmFpbnQoKXtyZXR1cm4gdGhpcy5faXNPbkNvbnN0cmFpbnR9c2V0Q29uc3RyYWludCh0KXt0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLl9jb25zdHJhaW50PXR9Z2V0Q2xhc3MoKXtyZXR1cm4gbW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW1vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzT25Db25zdHJhaW50PW51bGwsdGhpcy5fY29uc3RyYWludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3BvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9O2NsYXNzIHlve2NvbnN0cnVjdG9yKCl7eW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbWFrZUVkZ2UodCxlKXtjb25zdCBuPW5ldyB5byxzPW5ldyB5byxpPW5ldyB5byxyPW5ldyB5bztuLl9yb3Q9cyxzLl9yb3Q9aSxpLl9yb3Q9cixyLl9yb3Q9bixuLnNldE5leHQobikscy5zZXROZXh0KHIpLGkuc2V0TmV4dChpKSxyLnNldE5leHQocyk7Y29uc3Qgbz1uO3JldHVybiBvLnNldE9yaWcodCksby5zZXREZXN0KGUpLG99c3RhdGljIHN3YXAodCl7Y29uc3QgZT10Lm9QcmV2KCksbj10LnN5bSgpLm9QcmV2KCk7eW8uc3BsaWNlKHQsZSkseW8uc3BsaWNlKHQuc3ltKCksbikseW8uc3BsaWNlKHQsZS5sTmV4dCgpKSx5by5zcGxpY2UodC5zeW0oKSxuLmxOZXh0KCkpLHQuc2V0T3JpZyhlLmRlc3QoKSksdC5zZXREZXN0KG4uZGVzdCgpKX1zdGF0aWMgc3BsaWNlKHQsZSl7Y29uc3Qgbj10Lm9OZXh0KCkucm90KCkscz1lLm9OZXh0KCkucm90KCksaT1lLm9OZXh0KCkscj10Lm9OZXh0KCksbz1zLm9OZXh0KCksbD1uLm9OZXh0KCk7dC5zZXROZXh0KGkpLGUuc2V0TmV4dChyKSxuLnNldE5leHQobykscy5zZXROZXh0KGwpfXN0YXRpYyBjb25uZWN0KHQsZSl7Y29uc3Qgbj15by5tYWtlRWRnZSh0LmRlc3QoKSxlLm9yaWcoKSk7cmV0dXJuIHlvLnNwbGljZShuLHQubE5leHQoKSkseW8uc3BsaWNlKG4uc3ltKCksZSksbn1lcXVhbHNOb25PcmllbnRlZCh0KXtyZXR1cm4hIXRoaXMuZXF1YWxzT3JpZW50ZWQodCl8fCEhdGhpcy5lcXVhbHNPcmllbnRlZCh0LnN5bSgpKX10b0xpbmVTZWdtZW50KCl7cmV0dXJuIG5ldyBlZSh0aGlzLl92ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9ZGVzdCgpe3JldHVybiB0aGlzLnN5bSgpLm9yaWcoKX1vTmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fWVxdWFsc09yaWVudGVkKHQpe3JldHVybiEoIXRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0Lm9yaWcoKS5nZXRDb29yZGluYXRlKCkpfHwhdGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSkpfWROZXh0KCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKS5zeW0oKX1sUHJldigpe3JldHVybiB0aGlzLl9uZXh0LnN5bSgpfXJQcmV2KCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKX1yb3QoKXtyZXR1cm4gdGhpcy5fcm90fW9QcmV2KCl7cmV0dXJuIHRoaXMuX3JvdC5fbmV4dC5fcm90fXN5bSgpe3JldHVybiB0aGlzLl9yb3QuX3JvdH1zZXRPcmlnKHQpe3RoaXMuX3ZlcnRleD10fWxOZXh0KCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5yb3QoKX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmRpc3RhbmNlKHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9aW52Um90KCl7cmV0dXJuIHRoaXMuX3JvdC5zeW0oKX1zZXREZXN0KHQpe3RoaXMuc3ltKCkuc2V0T3JpZyh0KX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9ZGVsZXRlKCl7dGhpcy5fcm90PW51bGx9b3JpZygpe3JldHVybiB0aGlzLl92ZXJ0ZXh9ck5leHQoKXtyZXR1cm4gdGhpcy5fcm90Ll9uZXh0LmludlJvdCgpfXRvU3RyaW5nKCl7Y29uc3QgdD10aGlzLl92ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLGU9dGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpO3JldHVybiBKdC50b0xpbmVTdHJpbmcodCxlKX1pc0xpdmUoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3JvdH1nZXRQcmltYXJ5KCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKTw9MD90aGlzOnRoaXMuc3ltKCl9ZFByZXYoKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLmludlJvdCgpfXNldE5leHQodCl7dGhpcy5fbmV4dD10fWdldENsYXNzKCl7cmV0dXJuIHlvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX15by5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yb3Q9bnVsbCx0aGlzLl92ZXJ0ZXg9bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fZGF0YT1udWxsfTtjbGFzcyB4b3tjb25zdHJ1Y3Rvcigpe3hvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0U2l0ZSh0KXtsZXQgZT10aGlzLl9zdWJkaXYubG9jYXRlKHQpO2lmKHRoaXMuX3N1YmRpdi5pc1ZlcnRleE9mRWRnZShlLHQpKXJldHVybiBlO3RoaXMuX3N1YmRpdi5pc09uRWRnZShlLHQuZ2V0Q29vcmRpbmF0ZSgpKSYmKGU9ZS5vUHJldigpLHRoaXMuX3N1YmRpdi5kZWxldGUoZS5vTmV4dCgpKSk7bGV0IG49dGhpcy5fc3ViZGl2Lm1ha2VFZGdlKGUub3JpZygpLHQpO3lvLnNwbGljZShuLGUpO2NvbnN0IHM9bjtkb3tuPXRoaXMuX3N1YmRpdi5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCl9d2hpbGUoZS5sTmV4dCgpIT09cyk7Zm9yKDs7KXtjb25zdCBpPWUub1ByZXYoKTtpZihpLmRlc3QoKS5yaWdodE9mKGUpJiZ0LmlzSW5DaXJjbGUoZS5vcmlnKCksaS5kZXN0KCksZS5kZXN0KCkpKXlvLnN3YXAoZSksZT1lLm9QcmV2KCk7ZWxzZXtpZihlLm9OZXh0KCk9PT1zKXJldHVybiBuO2U9ZS5vTmV4dCgpLmxQcmV2KCl9fX1pbnNlcnRTaXRlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUodCl9fWdldENsYXNzKCl7cmV0dXJuIHhvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX14by5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9pc1VzaW5nVG9sZXJhbmNlPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3N1YmRpdj10LHRoaXMuX2lzVXNpbmdUb2xlcmFuY2U9dC5nZXRUb2xlcmFuY2UoKT4wfTtjbGFzcyBFb3tjb25zdHJ1Y3Rvcigpe0VvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bG9jYXRlKHQpe31nZXRDbGFzcygpe3JldHVybiBFb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBJb3tjb25zdHJ1Y3Rvcigpe0lvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5pdCgpe3RoaXMuX2xhc3RFZGdlPXRoaXMuZmluZEVkZ2UoKX1sb2NhdGUodCl7dGhpcy5fbGFzdEVkZ2UuaXNMaXZlKCl8fHRoaXMuaW5pdCgpO2NvbnN0IGU9dGhpcy5fc3ViZGl2LmxvY2F0ZUZyb21FZGdlKHQsdGhpcy5fbGFzdEVkZ2UpO3JldHVybiB0aGlzLl9sYXN0RWRnZT1lLGV9ZmluZEVkZ2UoKXtyZXR1cm4gdGhpcy5fc3ViZGl2LmdldEVkZ2VzKCkuaXRlcmF0b3IoKS5uZXh0KCl9Z2V0Q2xhc3MoKXtyZXR1cm4gSW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0VvXX19SW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc3ViZGl2PW51bGwsdGhpcy5fbGFzdEVkZ2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJkaXY9dCx0aGlzLmluaXQoKX07Y2xhc3MgTm8gZXh0ZW5kcyBje2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxOby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtc2dXaXRoU3BhdGlhbCh0LGUpe3JldHVybiBudWxsIT09ZT90K1wiIFsgXCIrZStcIiBdXCI6dH1nZXRTZWdtZW50KCl7cmV0dXJuIHRoaXMuX3NlZ31nZXRDbGFzcygpe3JldHVybiBOb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Tm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fc2VnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2MuY29uc3RydWN0b3JfLmNhbGwodGhpcyxcIkxvY2F0ZSBmYWlsZWQgdG8gY29udmVyZ2UgKGF0IGVkZ2U6IFwiK3QrXCIpLiAgUG9zc2libGUgY2F1c2VzIGluY2x1ZGUgaW52YWxpZCBTdWJkaXZpc2lvbiB0b3BvbG9neSBvciB2ZXJ5IGNsb3NlIHNpdGVzXCIpLHRoaXMuX3NlZz1uZXcgZWUodCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2MuY29uc3RydWN0b3JfLmNhbGwodGhpcyxOby5tc2dXaXRoU3BhdGlhbCh0LGUpKSx0aGlzLl9zZWc9bmV3IGVlKGUpfX07Y2xhc3MgQ297Y29uc3RydWN0b3IoKXtDby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0KHQpe31nZXRDbGFzcygpe3JldHVybiBDb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Q28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBTb3tjb25zdHJ1Y3Rvcigpe1NvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldFRyaWFuZ2xlRWRnZXModCxlKXtpZihlWzBdPXQsZVsxXT1lWzBdLmxOZXh0KCksZVsyXT1lWzFdLmxOZXh0KCksZVsyXS5sTmV4dCgpIT09ZVswXSl0aHJvdyBuZXcgbihcIkVkZ2VzIGRvIG5vdCBmb3JtIGEgdHJpYW5nbGVcIil9Z2V0VHJpYW5nbGVWZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyBUbztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVWZXJ0aWNlcygpfWlzRnJhbWVWZXJ0ZXgodCl7cmV0dXJuISF0LmVxdWFscyh0aGlzLl9mcmFtZVZlcnRleFswXSl8fCghIXQuZXF1YWxzKHRoaXMuX2ZyYW1lVmVydGV4WzFdKXx8ISF0LmVxdWFscyh0aGlzLl9mcmFtZVZlcnRleFsyXSkpfWlzVmVydGV4T2ZFZGdlKHQsZSl7cmV0dXJuISghZS5lcXVhbHModC5vcmlnKCksdGhpcy5fdG9sZXJhbmNlKSYmIWUuZXF1YWxzKHQuZGVzdCgpLHRoaXMuX3RvbGVyYW5jZSkpfWNvbm5lY3QodCxlKXtjb25zdCBuPXlvLmNvbm5lY3QodCxlKTtyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzLmFkZChuKSxufWdldFZvcm9ub2lDZWxsUG9seWdvbih0LGUpe2NvbnN0IG49bmV3IHgscz10O2Rve2NvbnN0IGU9dC5yb3QoKS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpO24uYWRkKGUpLHQ9dC5vUHJldigpfXdoaWxlKHQhPT1zKTtjb25zdCBpPW5ldyBJO2kuYWRkQWxsKG4sITEpLGkuY2xvc2VSaW5nKCksaS5zaXplKCk8NCYmKE8ub3V0LnByaW50bG4oaSksaS5hZGQoaS5nZXQoaS5zaXplKCktMSksITApKTtjb25zdCByPWkudG9Db29yZGluYXRlQXJyYXkoKSxvPWUuY3JlYXRlUG9seWdvbihlLmNyZWF0ZUxpbmVhclJpbmcocikpLGw9cy5vcmlnKCk7cmV0dXJuIG8uc2V0VXNlckRhdGEobC5nZXRDb29yZGluYXRlKCkpLG99c2V0TG9jYXRvcih0KXt0aGlzLl9sb2NhdG9yPXR9aW5pdFN1YmRpdigpe2NvbnN0IHQ9dGhpcy5tYWtlRWRnZSh0aGlzLl9mcmFtZVZlcnRleFswXSx0aGlzLl9mcmFtZVZlcnRleFsxXSksZT10aGlzLm1ha2VFZGdlKHRoaXMuX2ZyYW1lVmVydGV4WzFdLHRoaXMuX2ZyYW1lVmVydGV4WzJdKTt5by5zcGxpY2UodC5zeW0oKSxlKTtjb25zdCBuPXRoaXMubWFrZUVkZ2UodGhpcy5fZnJhbWVWZXJ0ZXhbMl0sdGhpcy5fZnJhbWVWZXJ0ZXhbMF0pO3JldHVybiB5by5zcGxpY2UoZS5zeW0oKSxuKSx5by5zcGxpY2Uobi5zeW0oKSx0KSx0fWlzRnJhbWVCb3JkZXJFZGdlKHQpe2NvbnN0IGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7U28uZ2V0VHJpYW5nbGVFZGdlcyh0LGUpO2NvbnN0IG49bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7U28uZ2V0VHJpYW5nbGVFZGdlcyh0LnN5bSgpLG4pO2NvbnN0IHM9dC5sTmV4dCgpLmRlc3QoKTtpZih0aGlzLmlzRnJhbWVWZXJ0ZXgocykpcmV0dXJuITA7Y29uc3QgaT10LnN5bSgpLmxOZXh0KCkuZGVzdCgpO3JldHVybiEhdGhpcy5pc0ZyYW1lVmVydGV4KGkpfW1ha2VFZGdlKHQsZSl7Y29uc3Qgbj15by5tYWtlRWRnZSh0LGUpO3JldHVybiB0aGlzLl9xdWFkRWRnZXMuYWRkKG4pLG59dmlzaXRUcmlhbmdsZXModCxlKXt0aGlzLl92aXNpdGVkS2V5Kys7Y29uc3Qgbj1uZXcgb247bi5wdXNoKHRoaXMuX3N0YXJ0aW5nRWRnZSk7Y29uc3Qgcz1uZXcgSjtmb3IoOyFuLmVtcHR5KCk7KXtjb25zdCBpPW4ucG9wKCk7aWYoIXMuY29udGFpbnMoaSkpe2NvbnN0IHI9dGhpcy5mZXRjaFRyaWFuZ2xlVG9WaXNpdChpLG4sZSxzKTtudWxsIT09ciYmdC52aXNpdChyKX19fWlzRnJhbWVFZGdlKHQpe3JldHVybiEoIXRoaXMuaXNGcmFtZVZlcnRleCh0Lm9yaWcoKSkmJiF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5kZXN0KCkpKX1pc09uRWRnZSh0LGUpe3JldHVybiB0aGlzLl9zZWcuc2V0Q29vcmRpbmF0ZXModC5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSksdGhpcy5fc2VnLmRpc3RhbmNlKGUpPHRoaXMuX2VkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZX1nZXRFbnZlbG9wZSgpe3JldHVybiBuZXcgTih0aGlzLl9mcmFtZUVudil9Y3JlYXRlRnJhbWUodCl7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpO2xldCBzPTA7cz1lPm4/MTAqZToxMCpuLHRoaXMuX2ZyYW1lVmVydGV4WzBdPW5ldyBwbygodC5nZXRNYXhYKCkrdC5nZXRNaW5YKCkpLzIsdC5nZXRNYXhZKCkrcyksdGhpcy5fZnJhbWVWZXJ0ZXhbMV09bmV3IHBvKHQuZ2V0TWluWCgpLXMsdC5nZXRNaW5ZKCktcyksdGhpcy5fZnJhbWVWZXJ0ZXhbMl09bmV3IHBvKHQuZ2V0TWF4WCgpK3MsdC5nZXRNaW5ZKCktcyksdGhpcy5fZnJhbWVFbnY9bmV3IE4odGhpcy5fZnJhbWVWZXJ0ZXhbMF0uZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX2ZyYW1lVmVydGV4WzFdLmdldENvb3JkaW5hdGUoKSksdGhpcy5fZnJhbWVFbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2ZyYW1lVmVydGV4WzJdLmdldENvb3JkaW5hdGUoKSl9Z2V0VHJpYW5nbGVDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBSbztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVzKCl9Z2V0VmVydGljZXModCl7Y29uc3QgZT1uZXcgSjtmb3IobGV0IG49dGhpcy5fcXVhZEVkZ2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLGk9cy5vcmlnKCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChpKXx8ZS5hZGQoaSk7Y29uc3Qgcj1zLmRlc3QoKTshdCYmdGhpcy5pc0ZyYW1lVmVydGV4KHIpfHxlLmFkZChyKX1yZXR1cm4gZX1mZXRjaFRyaWFuZ2xlVG9WaXNpdCh0LGUsbixzKXtsZXQgaT10LHI9MCxvPSExO2Rve3RoaXMuX3RyaUVkZ2VzW3JdPWksdGhpcy5pc0ZyYW1lRWRnZShpKSYmKG89ITApO2NvbnN0IHQ9aS5zeW0oKTtzLmNvbnRhaW5zKHQpfHxlLnB1c2godCkscy5hZGQoaSkscisrLGk9aS5sTmV4dCgpfXdoaWxlKGkhPT10KTtyZXR1cm4gbyYmIW4/bnVsbDp0aGlzLl90cmlFZGdlc31nZXRFZGdlcygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9xdWFkRWRnZXM7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5nZXRQcmltYXJ5RWRnZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBzPTA7Zm9yKGxldCBpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IGU9aS5uZXh0KCk7bltzKytdPXQuY3JlYXRlTGluZVN0cmluZyhbZS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLGUuZGVzdCgpLmdldENvb3JkaW5hdGUoKV0pfXJldHVybiB0LmNyZWF0ZU11bHRpTGluZVN0cmluZyhuKX19Z2V0VmVydGV4VW5pcXVlRWRnZXModCl7Y29uc3QgZT1uZXcgeCxuPW5ldyBKO2ZvcihsZXQgcz10aGlzLl9xdWFkRWRnZXMuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGk9cy5uZXh0KCkscj1pLm9yaWcoKTtuLmNvbnRhaW5zKHIpfHwobi5hZGQociksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChyKXx8ZS5hZGQoaSkpO2NvbnN0IG89aS5zeW0oKSxsPW8ub3JpZygpO24uY29udGFpbnMobCl8fChuLmFkZChsKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KGwpfHxlLmFkZChvKSl9cmV0dXJuIGV9Z2V0VHJpYW5nbGVFZGdlcyh0KXtjb25zdCBlPW5ldyBMbztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVFZGdlcygpfWdldFByaW1hcnlFZGdlcyh0KXt0aGlzLl92aXNpdGVkS2V5Kys7Y29uc3QgZT1uZXcgeCxuPW5ldyBvbjtuLnB1c2godGhpcy5fc3RhcnRpbmdFZGdlKTtjb25zdCBzPW5ldyBKO2Zvcig7IW4uZW1wdHkoKTspe2NvbnN0IGk9bi5wb3AoKTtpZighcy5jb250YWlucyhpKSl7Y29uc3Qgcj1pLmdldFByaW1hcnkoKTshdCYmdGhpcy5pc0ZyYW1lRWRnZShyKXx8ZS5hZGQociksbi5wdXNoKGkub05leHQoKSksbi5wdXNoKGkuc3ltKCkub05leHQoKSkscy5hZGQoaSkscy5hZGQoaS5zeW0oKSl9fXJldHVybiBlfWRlbGV0ZSh0KXt5by5zcGxpY2UodCx0Lm9QcmV2KCkpLHlvLnNwbGljZSh0LnN5bSgpLHQuc3ltKCkub1ByZXYoKSk7Y29uc3QgZT10LnN5bSgpLG49dC5yb3QoKSxzPXQucm90KCkuc3ltKCk7dGhpcy5fcXVhZEVkZ2VzLnJlbW92ZSh0KSx0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKGUpLHRoaXMuX3F1YWRFZGdlcy5yZW1vdmUobiksdGhpcy5fcXVhZEVkZ2VzLnJlbW92ZShzKSx0LmRlbGV0ZSgpLGUuZGVsZXRlKCksbi5kZWxldGUoKSxzLmRlbGV0ZSgpfWxvY2F0ZUZyb21FZGdlKHQsZSl7bGV0IG49MDtjb25zdCBzPXRoaXMuX3F1YWRFZGdlcy5zaXplKCk7bGV0IGk9ZTtmb3IoOzspe2lmKG4rKyxuPnMpdGhyb3cgbmV3IE5vKGkudG9MaW5lU2VnbWVudCgpKTtpZih0LmVxdWFscyhpLm9yaWcoKSl8fHQuZXF1YWxzKGkuZGVzdCgpKSlicmVhaztpZih0LnJpZ2h0T2YoaSkpaT1pLnN5bSgpO2Vsc2UgaWYodC5yaWdodE9mKGkub05leHQoKSkpe2lmKHQucmlnaHRPZihpLmRQcmV2KCkpKWJyZWFrO2k9aS5kUHJldigpfWVsc2UgaT1pLm9OZXh0KCl9cmV0dXJuIGl9Z2V0VG9sZXJhbmNlKCl7cmV0dXJuIHRoaXMuX3RvbGVyYW5jZX1nZXRWb3Jvbm9pQ2VsbFBvbHlnb25zKHQpe3RoaXMudmlzaXRUcmlhbmdsZXMobmV3IHdvLCEwKTtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10aGlzLmdldFZlcnRleFVuaXF1ZUVkZ2VzKCExKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtlLmFkZCh0aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbihzLHQpKX1yZXR1cm4gZX1nZXRWb3Jvbm9pRGlhZ3JhbSh0KXtjb25zdCBlPXRoaXMuZ2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KTtyZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oSHQudG9HZW9tZXRyeUFycmF5KGUpKX1nZXRUcmlhbmdsZXModCl7Y29uc3QgZT10aGlzLmdldFRyaWFuZ2xlQ29vcmRpbmF0ZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBzPTA7Zm9yKGxldCBpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IGU9aS5uZXh0KCk7bltzKytdPXQuY3JlYXRlUG9seWdvbih0LmNyZWF0ZUxpbmVhclJpbmcoZSkpfXJldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuKX1pbnNlcnRTaXRlKHQpe2xldCBlPXRoaXMubG9jYXRlKHQpO2lmKHQuZXF1YWxzKGUub3JpZygpLHRoaXMuX3RvbGVyYW5jZSl8fHQuZXF1YWxzKGUuZGVzdCgpLHRoaXMuX3RvbGVyYW5jZSkpcmV0dXJuIGU7bGV0IG49dGhpcy5tYWtlRWRnZShlLm9yaWcoKSx0KTt5by5zcGxpY2UobixlKTtjb25zdCBzPW47ZG97bj10aGlzLmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKX13aGlsZShlLmxOZXh0KCkhPT1zKTtyZXR1cm4gc31sb2NhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBwbyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2xvY2F0b3IubG9jYXRlKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2xvY2F0b3IubG9jYXRlKG5ldyBwbyh0KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fbG9jYXRvci5sb2NhdGUobmV3IHBvKHQpKTtpZihudWxsPT09bilyZXR1cm4gbnVsbDtsZXQgcz1uO24uZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0KSYmKHM9bi5zeW0oKSk7bGV0IGk9cztkb3tpZihpLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQoZSkpcmV0dXJuIGk7aT1pLm9OZXh0KCl9d2hpbGUoaSE9PXMpO3JldHVybiBudWxsfX1nZXRDbGFzcygpe3JldHVybiBTb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3Mgd297Y29uc3RydWN0b3IoKXt3by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0KHQpe2NvbnN0IGU9dFswXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLG49dFsxXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHM9dFsyXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLGk9cmUuY2lyY3VtY2VudHJlKGUsbixzKSxyPW5ldyBwbyhpKTtmb3IobGV0IGU9MDtlPDM7ZSsrKXRbZV0ucm90KCkuc2V0T3JpZyhyKX1nZXRDbGFzcygpe3JldHVybiB3b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQ29dfX13by5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIExve2NvbnN0cnVjdG9yKCl7TG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRUcmlhbmdsZUVkZ2VzKCl7cmV0dXJuIHRoaXMuX3RyaUxpc3R9dmlzaXQodCl7dGhpcy5fdHJpTGlzdC5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gTG99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0NvXX19TG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdHJpTGlzdD1uZXcgeH07Y2xhc3MgVG97Y29uc3RydWN0b3IoKXtUby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0KHQpe3RoaXMuX3RyaUxpc3QuYWRkKFt0WzBdLm9yaWcoKSx0WzFdLm9yaWcoKSx0WzJdLm9yaWcoKV0pfWdldFRyaWFuZ2xlVmVydGljZXMoKXtyZXR1cm4gdGhpcy5fdHJpTGlzdH1nZXRDbGFzcygpe3JldHVybiBUb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQ29dfX1Uby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl90cmlMaXN0PW5ldyB4fTtjbGFzcyBSb3tjb25zdHJ1Y3Rvcigpe1JvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2hlY2tUcmlhbmdsZVNpemUodCl7bGV0IGU9XCJcIjt0Lmxlbmd0aD49Mj9lPUp0LnRvTGluZVN0cmluZyh0WzBdLHRbMV0pOnQubGVuZ3RoPj0xJiYoZT1KdC50b1BvaW50KHRbMF0pKX12aXNpdCh0KXt0aGlzLl9jb29yZExpc3QuY2xlYXIoKTtmb3IobGV0IGU9MDtlPDM7ZSsrKXtjb25zdCBuPXRbZV0ub3JpZygpO3RoaXMuX2Nvb3JkTGlzdC5hZGQobi5nZXRDb29yZGluYXRlKCkpfWlmKHRoaXMuX2Nvb3JkTGlzdC5zaXplKCk+MCl7dGhpcy5fY29vcmRMaXN0LmNsb3NlUmluZygpO2NvbnN0IHQ9dGhpcy5fY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7aWYoNCE9PXQubGVuZ3RoKXJldHVybiBudWxsO3RoaXMuX3RyaUNvb3Jkcy5hZGQodCl9fWdldFRyaWFuZ2xlcygpe3JldHVybiB0aGlzLl90cmlDb29yZHN9Z2V0Q2xhc3MoKXtyZXR1cm4gUm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0NvXX19Um8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29vcmRMaXN0PW5ldyBJLHRoaXMuX3RyaUNvb3Jkcz1uZXcgeH0sU28uVHJpYW5nbGVDaXJjdW1jZW50cmVWaXNpdG9yPXdvLFNvLlRyaWFuZ2xlRWRnZXNMaXN0VmlzaXRvcj1MbyxTby5UcmlhbmdsZVZlcnRleExpc3RWaXNpdG9yPVRvLFNvLlRyaWFuZ2xlQ29vcmRpbmF0ZXNWaXNpdG9yPVJvLFNvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3Zpc2l0ZWRLZXk9MCx0aGlzLl9xdWFkRWRnZXM9bmV3IHgsdGhpcy5fc3RhcnRpbmdFZGdlPW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGwsdGhpcy5fZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5fZnJhbWVWZXJ0ZXg9bmV3IEFycmF5KDMpLmZpbGwobnVsbCksdGhpcy5fZnJhbWVFbnY9bnVsbCx0aGlzLl9sb2NhdG9yPW51bGwsdGhpcy5fc2VnPW5ldyBlZSx0aGlzLl90cmlFZGdlcz1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl90b2xlcmFuY2U9ZSx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9ZS9Tby5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1IsdGhpcy5jcmVhdGVGcmFtZSh0KSx0aGlzLl9zdGFydGluZ0VkZ2U9dGhpcy5pbml0U3ViZGl2KCksdGhpcy5fbG9jYXRvcj1uZXcgSW8odGhpcyl9LFNvLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUj0xZTM7Y2xhc3MgUG97Y29uc3RydWN0b3IoKXtQby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldExpbmVTZWdtZW50KCl7cmV0dXJuIHRoaXMuX2xzfWdldEVuZFooKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKS56fWdldFN0YXJ0Wigpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDApLnp9aW50ZXJzZWN0aW9uKHQpe3JldHVybiB0aGlzLl9scy5pbnRlcnNlY3Rpb24odC5nZXRMaW5lU2VnbWVudCgpKX1nZXRTdGFydCgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDApfWdldEVuZCgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpfWdldEVuZFkoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKS55fWdldFN0YXJ0WCgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDApLnh9ZXF1YWxzVG9wbyh0KXtyZXR1cm4gdGhpcy5fbHMuZXF1YWxzVG9wbyh0LmdldExpbmVTZWdtZW50KCkpfWdldFN0YXJ0WSgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDApLnl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWdldEVuZFgoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKS54fXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuX2xzLnRvU3RyaW5nKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gUG99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVBvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2xzPW51bGwsdGhpcy5fZGF0YT1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9scz1uZXcgZWUodCxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9scz1uZXcgZWUodCxlKSx0aGlzLl9kYXRhPW59ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07UG8uY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgZyh0LGUsbiksbmV3IGcocyxpLHIpKX1lbHNlIGlmKDc9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XSxvPWFyZ3VtZW50c1s2XTtQby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBnKHQsZSxuKSxuZXcgZyhzLGksciksbyl9fTtjbGFzcyB2b3tjb25zdHJ1Y3Rvcigpe3ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0KXtjb25zdCBlPW5ldyBOO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0Q29vcmRpbmF0ZSgpKX1yZXR1cm4gZX1nZXRJbml0aWFsVmVydGljZXMoKXtyZXR1cm4gdGhpcy5faW5pdGlhbFZlcnRpY2VzfWdldEtEVCgpe3JldHVybiB0aGlzLl9rZHR9ZW5mb3JjZUNvbnN0cmFpbnRzKCl7dGhpcy5hZGRDb25zdHJhaW50VmVydGljZXMoKTtsZXQgdD0wLGU9MDtkb3tlPXRoaXMuZW5mb3JjZUdhYnJpZWwodGhpcy5fc2VnbWVudHMpLHQrK313aGlsZShlPjAmJnQ8dm8uTUFYX1NQTElUX0lURVIpfWluc2VydFNpdGVzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuaW5zZXJ0U2l0ZSh0KX19Z2V0VmVydGV4RmFjdG9yeSgpe3JldHVybiB0aGlzLl92ZXJ0ZXhGYWN0b3J5fWdldFBvaW50QXJyYXkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9pbml0aWFsVmVydGljZXMuc2l6ZSgpK3RoaXMuX3NlZ1ZlcnRpY2VzLnNpemUoKSkuZmlsbChudWxsKTtsZXQgZT0wO2ZvcihsZXQgbj10aGlzLl9pbml0aWFsVmVydGljZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7dFtlKytdPXMuZ2V0Q29vcmRpbmF0ZSgpfWZvcihsZXQgbj10aGlzLl9zZWdWZXJ0aWNlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTt0W2UrK109cy5nZXRDb29yZGluYXRlKCl9cmV0dXJuIHR9c2V0Q29uc3RyYWludHModCxlKXt0aGlzLl9zZWdtZW50cz10LHRoaXMuX3NlZ1ZlcnRpY2VzPWV9Y29tcHV0ZUNvbnZleEh1bGwoKXtjb25zdCB0PW5ldyBIdCxlPXRoaXMuZ2V0UG9pbnRBcnJheSgpLG49bmV3IGFuKGUsdCk7dGhpcy5fY29udmV4SHVsbD1uLmdldENvbnZleEh1bGwoKX1hZGRDb25zdHJhaW50VmVydGljZXMoKXt0aGlzLmNvbXB1dGVDb252ZXhIdWxsKCksdGhpcy5pbnNlcnRTaXRlcyh0aGlzLl9zZWdWZXJ0aWNlcyl9ZmluZE5vbkdhYnJpZWxQb2ludCh0KXtjb25zdCBlPXQuZ2V0U3RhcnQoKSxuPXQuZ2V0RW5kKCkscz1uZXcgZygoZS54K24ueCkvMiwoZS55K24ueSkvMikscj1lLmRpc3RhbmNlKHMpLG89bmV3IE4ocyk7by5leHBhbmRCeShyKTtjb25zdCBsPXRoaXMuX2tkdC5xdWVyeShvKTtsZXQgYT1udWxsLGM9aS5NQVhfVkFMVUU7Zm9yKGxldCB0PWwuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGk9dC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZSgpO2lmKGkuZXF1YWxzMkQoZSl8fGkuZXF1YWxzMkQobikpY29udGludWU7Y29uc3Qgbz1zLmRpc3RhbmNlKGkpO2lmKG88cil7Y29uc3QgdD1vOyhudWxsPT09YXx8dDxjKSYmKGE9aSxjPXQpfX1yZXR1cm4gYX1nZXRDb25zdHJhaW50U2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fc2VnbWVudHN9c2V0U3BsaXRQb2ludEZpbmRlcih0KXt0aGlzLl9zcGxpdEZpbmRlcj10fWdldENvbnZleEh1bGwoKXtyZXR1cm4gdGhpcy5fY29udmV4SHVsbH1nZXRUb2xlcmFuY2UoKXtyZXR1cm4gdGhpcy5fdG9sZXJhbmNlfWVuZm9yY2VHYWJyaWVsKHQpe2NvbnN0IGU9bmV3IHg7bGV0IG49MDtjb25zdCBzPW5ldyB4O2ZvcihsZXQgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCB0PWkubmV4dCgpLHI9dGhpcy5maW5kTm9uR2FicmllbFBvaW50KHQpO2lmKG51bGw9PT1yKWNvbnRpbnVlO3RoaXMuX3NwbGl0UHQ9dGhpcy5fc3BsaXRGaW5kZXIuZmluZFNwbGl0UG9pbnQodCxyKTtjb25zdCBvPXRoaXMuY3JlYXRlVmVydGV4KHRoaXMuX3NwbGl0UHQsdCk7dGhpcy5pbnNlcnRTaXRlKG8pLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0aGlzLl9zcGxpdFB0KTtjb25zdCBsPW5ldyBQbyh0LmdldFN0YXJ0WCgpLHQuZ2V0U3RhcnRZKCksdC5nZXRTdGFydFooKSxvLmdldFgoKSxvLmdldFkoKSxvLmdldFooKSx0LmdldERhdGEoKSksYT1uZXcgUG8oby5nZXRYKCksby5nZXRZKCksby5nZXRaKCksdC5nZXRFbmRYKCksdC5nZXRFbmRZKCksdC5nZXRFbmRaKCksdC5nZXREYXRhKCkpO2UuYWRkKGwpLGUuYWRkKGEpLHMuYWRkKHQpLG4rPTF9cmV0dXJuIHQucmVtb3ZlQWxsKHMpLHQuYWRkQWxsKGUpLG59Y3JlYXRlVmVydGV4KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW51bGw7cmV0dXJuIGU9bnVsbCE9PXRoaXMuX3ZlcnRleEZhY3Rvcnk/dGhpcy5fdmVydGV4RmFjdG9yeS5jcmVhdGVWZXJ0ZXgodCxudWxsKTpuZXcgbW8odCksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbDtyZXR1cm4gbj1udWxsIT09dGhpcy5fdmVydGV4RmFjdG9yeT90aGlzLl92ZXJ0ZXhGYWN0b3J5LmNyZWF0ZVZlcnRleCh0LGUpOm5ldyBtbyh0KSxuLnNldE9uQ29uc3RyYWludCghMCksbn19Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5fc3ViZGl2fWNvbXB1dGVCb3VuZGluZ0JveCgpe2NvbnN0IHQ9dm8uY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuX2luaXRpYWxWZXJ0aWNlcyksZT12by5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5fc2VnVmVydGljZXMpLG49bmV3IE4odCk7bi5leHBhbmRUb0luY2x1ZGUoZSk7Y29uc3Qgcz0uMipuLmdldFdpZHRoKCksaT0uMipuLmdldEhlaWdodCgpLHI9TWF0aC5tYXgocyxpKTt0aGlzLl9jb21wdXRlQXJlYUVudj1uZXcgTihuKSx0aGlzLl9jb21wdXRlQXJlYUVudi5leHBhbmRCeShyKX1zZXRWZXJ0ZXhGYWN0b3J5KHQpe3RoaXMuX3ZlcnRleEZhY3Rvcnk9dH1mb3JtSW5pdGlhbERlbGF1bmF5KCl7dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLl9zdWJkaXY9bmV3IFNvKHRoaXMuX2NvbXB1dGVBcmVhRW52LHRoaXMuX3RvbGVyYW5jZSksdGhpcy5fc3ViZGl2LnNldExvY2F0b3IobmV3IElvKHRoaXMuX3N1YmRpdikpLHRoaXMuX2luY0RlbD1uZXcgeG8odGhpcy5fc3ViZGl2KSx0aGlzLmluc2VydFNpdGVzKHRoaXMuX2luaXRpYWxWZXJ0aWNlcyl9aW5zZXJ0U2l0ZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbW8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5fa2R0Lmluc2VydCh0LmdldENvb3JkaW5hdGUoKSx0KTtpZihlLmlzUmVwZWF0ZWQoKSl7Y29uc3Qgbj1lLmdldERhdGEoKTtyZXR1cm4gbi5tZXJnZSh0KSxufXJldHVybiB0aGlzLl9pbmNEZWwuaW5zZXJ0U2l0ZSh0KSx0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbnNlcnRTaXRlKHRoaXMuY3JlYXRlVmVydGV4KHQpKX19Z2V0Q2xhc3MoKXtyZXR1cm4gdm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXZvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2luaXRpYWxWZXJ0aWNlcz1udWxsLHRoaXMuX3NlZ1ZlcnRpY2VzPW51bGwsdGhpcy5fc2VnbWVudHM9bmV3IHgsdGhpcy5fc3ViZGl2PW51bGwsdGhpcy5faW5jRGVsPW51bGwsdGhpcy5fY29udmV4SHVsbD1udWxsLHRoaXMuX3NwbGl0RmluZGVyPW5ldyBfbyx0aGlzLl9rZHQ9bnVsbCx0aGlzLl92ZXJ0ZXhGYWN0b3J5PW51bGwsdGhpcy5fY29tcHV0ZUFyZWFFbnY9bnVsbCx0aGlzLl9zcGxpdFB0PW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5pdGlhbFZlcnRpY2VzPW5ldyB4KHQpLHRoaXMuX3RvbGVyYW5jZT1lLHRoaXMuX2tkdD1uZXcgZXMoZSl9LHZvLk1BWF9TUExJVF9JVEVSPTk5O2NsYXNzIE9ve2NvbnN0cnVjdG9yKCl7T28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpe2lmKG51bGw9PT10KXJldHVybiBuZXcgSTtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gT28udW5pcXVlKGUpfXN0YXRpYyBlbnZlbG9wZSh0KXtjb25zdCBlPW5ldyBOO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKHQpfXJldHVybiBlfXN0YXRpYyB1bmlxdWUodCl7Y29uc3QgZT1YLmNvcHlEZWVwKHQpO3JldHVybiBodC5zb3J0KGUpLG5ldyBJKGUsITEpfXN0YXRpYyB0b1ZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGQobmV3IHBvKHQpKX1yZXR1cm4gZX1jcmVhdGUoKXtpZihudWxsIT09dGhpcy5fc3ViZGl2KXJldHVybiBudWxsO2NvbnN0IHQ9T28uZW52ZWxvcGUodGhpcy5fc2l0ZUNvb3JkcyksZT1Pby50b1ZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpO3RoaXMuX3N1YmRpdj1uZXcgU28odCx0aGlzLl90b2xlcmFuY2UpLG5ldyB4byh0aGlzLl9zdWJkaXYpLmluc2VydFNpdGVzKGUpfXNldFRvbGVyYW5jZSh0KXt0aGlzLl90b2xlcmFuY2U9dH1zZXRTaXRlcygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1Pby5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1Pby51bmlxdWUoWC50b0Nvb3JkaW5hdGVBcnJheSh0KSl9fWdldEVkZ2VzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRFZGdlcyh0KX1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdn1nZXRUcmlhbmdsZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldFRyaWFuZ2xlcyh0KX1nZXRDbGFzcygpe3JldHVybiBPb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19T28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2l0ZUNvb3Jkcz1udWxsLHRoaXMuX3RvbGVyYW5jZT0wLHRoaXMuX3N1YmRpdj1udWxsfTtjbGFzcyBib3tjb25zdHJ1Y3Rvcigpe2JvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXhlLmdldExpbmVzKHQpLG49bmV3IHg7Zm9yKGxldCB0PWUuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7Ym8uY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKGUsbil9cmV0dXJuIG59aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0xO3Q8bi5sZW5ndGg7dCsrKWUuYWRkKG5ldyBQbyhuW3QtMV0sblt0XSkpfX1jcmVhdGVTaXRlVmVydGljZXModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwLmNvbnRhaW5zS2V5KHQpfHxlLmFkZChuZXcgbW8odCkpfXJldHVybiBlfWNyZWF0ZSgpe2lmKG51bGwhPT10aGlzLl9zdWJkaXYpcmV0dXJuIG51bGw7Y29uc3QgdD1Pby5lbnZlbG9wZSh0aGlzLl9zaXRlQ29vcmRzKTtsZXQgZT1uZXcgeDtudWxsIT09dGhpcy5fY29uc3RyYWludExpbmVzJiYodC5leHBhbmRUb0luY2x1ZGUodGhpcy5fY29uc3RyYWludExpbmVzLmdldEVudmVsb3BlSW50ZXJuYWwoKSksdGhpcy5jcmVhdGVWZXJ0aWNlcyh0aGlzLl9jb25zdHJhaW50TGluZXMpLGU9Ym8uY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKHRoaXMuX2NvbnN0cmFpbnRMaW5lcykpO2NvbnN0IG49dGhpcy5jcmVhdGVTaXRlVmVydGljZXModGhpcy5fc2l0ZUNvb3Jkcykscz1uZXcgdm8obix0aGlzLl90b2xlcmFuY2UpO3Muc2V0Q29uc3RyYWludHMoZSxuZXcgeCh0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwLnZhbHVlcygpKSkscy5mb3JtSW5pdGlhbERlbGF1bmF5KCkscy5lbmZvcmNlQ29uc3RyYWludHMoKSx0aGlzLl9zdWJkaXY9cy5nZXRTdWJkaXZpc2lvbigpfXNldFRvbGVyYW5jZSh0KXt0aGlzLl90b2xlcmFuY2U9dH1zZXRDb25zdHJhaW50cyh0KXt0aGlzLl9jb25zdHJhaW50TGluZXM9dH1zZXRTaXRlcyh0KXt0aGlzLl9zaXRlQ29vcmRzPU9vLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX1nZXRFZGdlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0RWRnZXModCl9Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXZ9Z2V0VHJpYW5nbGVzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRUcmlhbmdsZXModCl9Y3JlYXRlVmVydGljZXModCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IG49bmV3IG1vKGVbdF0pO3RoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXAucHV0KGVbdF0sbil9fWdldENsYXNzKCl7cmV0dXJuIGJvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1iby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zaXRlQ29vcmRzPW51bGwsdGhpcy5fY29uc3RyYWludExpbmVzPW51bGwsdGhpcy5fdG9sZXJhbmNlPTAsdGhpcy5fc3ViZGl2PW51bGwsdGhpcy5fY29uc3RyYWludFZlcnRleE1hcD1uZXcgcnR9O2NsYXNzIE1ve2NvbnN0cnVjdG9yKCl7TW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY2xpcEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpe2NvbnN0IG49dC5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeShlKSxzPW5ldyB4O2ZvcihsZXQgaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXtjb25zdCByPXQuZ2V0R2VvbWV0cnlOKGkpO2xldCBvPW51bGw7ZS5jb250YWlucyhyLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/bz1yOmUuaW50ZXJzZWN0cyhyLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJihvPW4uaW50ZXJzZWN0aW9uKHIpLG8uc2V0VXNlckRhdGEoci5nZXRVc2VyRGF0YSgpKSksbnVsbD09PW98fG8uaXNFbXB0eSgpfHxzLmFkZChvKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEh0LnRvR2VvbWV0cnlBcnJheShzKSl9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PU9vLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpO3RoaXMuX2RpYWdyYW1FbnY9dDtjb25zdCBlPU1hdGgubWF4KHRoaXMuX2RpYWdyYW1FbnYuZ2V0V2lkdGgoKSx0aGlzLl9kaWFncmFtRW52LmdldEhlaWdodCgpKTt0aGlzLl9kaWFncmFtRW52LmV4cGFuZEJ5KGUpLG51bGwhPT10aGlzLl9jbGlwRW52JiZ0aGlzLl9kaWFncmFtRW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jbGlwRW52KTtjb25zdCBuPU9vLnRvVmVydGljZXModGhpcy5fc2l0ZUNvb3Jkcyk7dGhpcy5fc3ViZGl2PW5ldyBTbyh0LHRoaXMuX3RvbGVyYW5jZSksbmV3IHhvKHRoaXMuX3N1YmRpdikuaW5zZXJ0U2l0ZXMobil9Z2V0RGlhZ3JhbSh0KXt0aGlzLmNyZWF0ZSgpO2NvbnN0IGU9dGhpcy5fc3ViZGl2LmdldFZvcm9ub2lEaWFncmFtKHQpO3JldHVybiBNby5jbGlwR2VvbWV0cnlDb2xsZWN0aW9uKGUsdGhpcy5fZGlhZ3JhbUVudil9c2V0VG9sZXJhbmNlKHQpe3RoaXMuX3RvbGVyYW5jZT10fXNldFNpdGVzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPU9vLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPU9vLnVuaXF1ZShYLnRvQ29vcmRpbmF0ZUFycmF5KHQpKX19c2V0Q2xpcEVudmVsb3BlKHQpe3RoaXMuX2NsaXBFbnY9dH1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdn1nZXRDbGFzcygpe3JldHVybiBNb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2l0ZUNvb3Jkcz1udWxsLHRoaXMuX3RvbGVyYW5jZT0wLHRoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2NsaXBFbnY9bnVsbCx0aGlzLl9kaWFncmFtRW52PW51bGx9O3ZhciBEbz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxWZXJ0ZXg6cG99KSxBbz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb25mb3JtaW5nRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjpibyxEZWxhdW5heVRyaWFuZ3VsYXRpb25CdWlsZGVyOk9vLFZvcm9ub2lEaWFncmFtQnVpbGRlcjpNbyxxdWFkZWRnZTpEb30pO2NsYXNzIEZve2NvbnN0cnVjdG9yKCl7Rm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0RW5kTG9jYXRpb24odCl7Y29uc3QgZT1uZXcgRm87cmV0dXJuIGUuc2V0VG9FbmQodCksZX1zdGF0aWMgcG9pbnRBbG9uZ1NlZ21lbnRCeUZyYWN0aW9uKHQsZSxuKXtpZihuPD0wKXJldHVybiB0O2lmKG4+PTEpcmV0dXJuIGU7Y29uc3Qgcz0oZS54LXQueCkqbit0LngsaT0oZS55LXQueSkqbit0Lnkscj0oZS56LXQueikqbit0Lno7cmV0dXJuIG5ldyBnKHMsaSxyKX1zdGF0aWMgY29tcGFyZUxvY2F0aW9uVmFsdWVzKHQsZSxuLHMsaSxyKXtyZXR1cm4gdDxzPy0xOnQ+cz8xOmU8aT8tMTplPmk/MTpuPHI/LTE6bj5yPzE6MH1nZXRTZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fc2VnbWVudEluZGV4fWdldENvbXBvbmVudEluZGV4KCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4fWlzRW5kcG9pbnQodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCkuZ2V0TnVtUG9pbnRzKCktMTtyZXR1cm4gdGhpcy5fc2VnbWVudEluZGV4Pj1lfHx0aGlzLl9zZWdtZW50SW5kZXg9PT1lJiZ0aGlzLl9zZWdtZW50RnJhY3Rpb24+PTF9aXNWYWxpZCh0KXtpZih0aGlzLl9jb21wb25lbnRJbmRleDwwfHx0aGlzLl9jb21wb25lbnRJbmRleD49dC5nZXROdW1HZW9tZXRyaWVzKCkpcmV0dXJuITE7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7cmV0dXJuISh0aGlzLl9zZWdtZW50SW5kZXg8MHx8dGhpcy5fc2VnbWVudEluZGV4PmUuZ2V0TnVtUG9pbnRzKCkpJiYoKHRoaXMuX3NlZ21lbnRJbmRleCE9PWUuZ2V0TnVtUG9pbnRzKCl8fDA9PT10aGlzLl9zZWdtZW50RnJhY3Rpb24pJiYhKHRoaXMuX3NlZ21lbnRGcmFjdGlvbjwwfHx0aGlzLl9zZWdtZW50RnJhY3Rpb24+MSkpfW5vcm1hbGl6ZSgpe3RoaXMuX3NlZ21lbnRGcmFjdGlvbjwwJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTApLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj4xJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTEpLHRoaXMuX2NvbXBvbmVudEluZGV4PDAmJih0aGlzLl9jb21wb25lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSx0aGlzLl9zZWdtZW50SW5kZXg8MCYmKHRoaXMuX3NlZ21lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSwxPT09dGhpcy5fc2VnbWVudEZyYWN0aW9uJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTAsdGhpcy5fc2VnbWVudEluZGV4Kz0xKX10b0xvd2VzdCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KS5nZXROdW1Qb2ludHMoKS0xO3JldHVybiB0aGlzLl9zZWdtZW50SW5kZXg8ZT90aGlzOm5ldyBGbyh0aGlzLl9jb21wb25lbnRJbmRleCxlLDEsITEpfWdldENvb3JkaW5hdGUodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCk7aWYodGhpcy5fc2VnbWVudEluZGV4Pj1lLmdldE51bVBvaW50cygpLTEpcmV0dXJuIG47Y29uc3Qgcz1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCsxKTtyZXR1cm4gRm8ucG9pbnRBbG9uZ1NlZ21lbnRCeUZyYWN0aW9uKG4scyx0aGlzLl9zZWdtZW50RnJhY3Rpb24pfWdldFNlZ21lbnRGcmFjdGlvbigpe3JldHVybiB0aGlzLl9zZWdtZW50RnJhY3Rpb259Z2V0U2VnbWVudCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KSxuPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KTtpZih0aGlzLl9zZWdtZW50SW5kZXg+PWUuZ2V0TnVtUG9pbnRzKCktMSl7Y29uc3QgdD1lLmdldENvb3JkaW5hdGVOKGUuZ2V0TnVtUG9pbnRzKCktMik7cmV0dXJuIG5ldyBlZSh0LG4pfWNvbnN0IHM9ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgrMSk7cmV0dXJuIG5ldyBlZShuLHMpfWNsYW1wKHQpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10LmdldE51bUdlb21ldHJpZXMoKSlyZXR1cm4gdGhpcy5zZXRUb0VuZCh0KSxudWxsO2lmKHRoaXMuX3NlZ21lbnRJbmRleD49dC5nZXROdW1Qb2ludHMoKSl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7dGhpcy5fc2VnbWVudEluZGV4PWUuZ2V0TnVtUG9pbnRzKCktMSx0aGlzLl9zZWdtZW50RnJhY3Rpb249MX19c2V0VG9FbmQodCl7dGhpcy5fY29tcG9uZW50SW5kZXg9dC5nZXROdW1HZW9tZXRyaWVzKCktMTtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTt0aGlzLl9zZWdtZW50SW5kZXg9ZS5nZXROdW1Qb2ludHMoKS0xLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4PGUuX2NvbXBvbmVudEluZGV4Py0xOnRoaXMuX2NvbXBvbmVudEluZGV4PmUuX2NvbXBvbmVudEluZGV4PzE6dGhpcy5fc2VnbWVudEluZGV4PGUuX3NlZ21lbnRJbmRleD8tMTp0aGlzLl9zZWdtZW50SW5kZXg+ZS5fc2VnbWVudEluZGV4PzE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPGUuX3NlZ21lbnRGcmFjdGlvbj8tMTp0aGlzLl9zZWdtZW50RnJhY3Rpb24+ZS5fc2VnbWVudEZyYWN0aW9uPzE6MH1jb3B5KCl7cmV0dXJuIG5ldyBGbyh0aGlzLl9jb21wb25lbnRJbmRleCx0aGlzLl9zZWdtZW50SW5kZXgsdGhpcy5fc2VnbWVudEZyYWN0aW9uKX10b1N0cmluZygpe3JldHVyblwiTGluZWFyTG9jW1wiK3RoaXMuX2NvbXBvbmVudEluZGV4K1wiLCBcIit0aGlzLl9zZWdtZW50SW5kZXgrXCIsIFwiK3RoaXMuX3NlZ21lbnRGcmFjdGlvbitcIl1cIn1pc09uU2FtZVNlZ21lbnQodCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4PT09dC5fY29tcG9uZW50SW5kZXgmJih0aGlzLl9zZWdtZW50SW5kZXg9PT10Ll9zZWdtZW50SW5kZXh8fCh0Ll9zZWdtZW50SW5kZXgtdGhpcy5fc2VnbWVudEluZGV4PT0xJiYwPT09dC5fc2VnbWVudEZyYWN0aW9ufHx0aGlzLl9zZWdtZW50SW5kZXgtdC5fc2VnbWVudEluZGV4PT0xJiYwPT09dGhpcy5fc2VnbWVudEZyYWN0aW9uKSl9c25hcFRvVmVydGV4KHQsZSl7aWYodGhpcy5fc2VnbWVudEZyYWN0aW9uPD0wfHx0aGlzLl9zZWdtZW50RnJhY3Rpb24+PTEpcmV0dXJuIG51bGw7Y29uc3Qgbj10aGlzLmdldFNlZ21lbnRMZW5ndGgodCkscz10aGlzLl9zZWdtZW50RnJhY3Rpb24qbixpPW4tcztzPD1pJiZzPGU/dGhpcy5fc2VnbWVudEZyYWN0aW9uPTA6aTw9cyYmaTxlJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTEpfWNvbXBhcmVMb2NhdGlvblZhbHVlcyh0LGUsbil7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4PHQ/LTE6dGhpcy5fY29tcG9uZW50SW5kZXg+dD8xOnRoaXMuX3NlZ21lbnRJbmRleDxlPy0xOnRoaXMuX3NlZ21lbnRJbmRleD5lPzE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPG4/LTE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPm4/MTowfWdldFNlZ21lbnRMZW5ndGgodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7bGV0IG49dGhpcy5fc2VnbWVudEluZGV4O3RoaXMuX3NlZ21lbnRJbmRleD49ZS5nZXROdW1Qb2ludHMoKS0xJiYobj1lLmdldE51bVBvaW50cygpLTIpO2NvbnN0IHM9ZS5nZXRDb29yZGluYXRlTihuKSxpPWUuZ2V0Q29vcmRpbmF0ZU4obisxKTtyZXR1cm4gcy5kaXN0YW5jZShpKX1pc1ZlcnRleCgpe3JldHVybiB0aGlzLl9zZWdtZW50RnJhY3Rpb248PTB8fHRoaXMuX3NlZ21lbnRGcmFjdGlvbj49MX1nZXRDbGFzcygpe3JldHVybiBGb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fUZvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4PTAsdGhpcy5fc2VnbWVudEluZGV4PTAsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvbXBvbmVudEluZGV4PXQuX2NvbXBvbmVudEluZGV4LHRoaXMuX3NlZ21lbnRJbmRleD10Ll9zZWdtZW50SW5kZXgsdGhpcy5fc2VnbWVudEZyYWN0aW9uPXQuX3NlZ21lbnRGcmFjdGlvbn1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtGby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDAsdCxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9jb21wb25lbnRJbmRleD10LHRoaXMuX3NlZ21lbnRJbmRleD1lLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj1uLHRoaXMubm9ybWFsaXplKCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fY29tcG9uZW50SW5kZXg9dCx0aGlzLl9zZWdtZW50SW5kZXg9ZSx0aGlzLl9zZWdtZW50RnJhY3Rpb249bixzJiZ0aGlzLm5vcm1hbGl6ZSgpfX07Y2xhc3MgR297Y29uc3RydWN0b3IoKXtHby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzZWdtZW50RW5kVmVydGV4SW5kZXgodCl7cmV0dXJuIHQuZ2V0U2VnbWVudEZyYWN0aW9uKCk+MD90LmdldFNlZ21lbnRJbmRleCgpKzE6dC5nZXRTZWdtZW50SW5kZXgoKX1nZXRDb21wb25lbnRJbmRleCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleH1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lfWdldFZlcnRleEluZGV4KCl7cmV0dXJuIHRoaXMuX3ZlcnRleEluZGV4fWdldFNlZ21lbnRFbmQoKXtyZXR1cm4gdGhpcy5fdmVydGV4SW5kZXg8dGhpcy5nZXRMaW5lKCkuZ2V0TnVtUG9pbnRzKCktMT90aGlzLl9jdXJyZW50TGluZS5nZXRDb29yZGluYXRlTih0aGlzLl92ZXJ0ZXhJbmRleCsxKTpudWxsfW5leHQoKXtpZighdGhpcy5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dGhpcy5fdmVydGV4SW5kZXgrKyx0aGlzLl92ZXJ0ZXhJbmRleD49dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCkmJih0aGlzLl9jb21wb25lbnRJbmRleCsrLHRoaXMubG9hZEN1cnJlbnRMaW5lKCksdGhpcy5fdmVydGV4SW5kZXg9MCl9bG9hZEN1cnJlbnRMaW5lKCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg+PXRoaXMuX251bUxpbmVzKXJldHVybiB0aGlzLl9jdXJyZW50TGluZT1udWxsLG51bGw7dGhpcy5fY3VycmVudExpbmU9dGhpcy5fbGluZWFyR2VvbS5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpfWdldFNlZ21lbnRTdGFydCgpe3JldHVybiB0aGlzLl9jdXJyZW50TGluZS5nZXRDb29yZGluYXRlTih0aGlzLl92ZXJ0ZXhJbmRleCl9aXNFbmRPZkxpbmUoKXtyZXR1cm4hKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcykmJiEodGhpcy5fdmVydGV4SW5kZXg8dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCktMSl9aGFzTmV4dCgpe3JldHVybiEodGhpcy5fY29tcG9uZW50SW5kZXg+PXRoaXMuX251bUxpbmVzKSYmISh0aGlzLl9jb21wb25lbnRJbmRleD09PXRoaXMuX251bUxpbmVzLTEmJnRoaXMuX3ZlcnRleEluZGV4Pj10aGlzLl9jdXJyZW50TGluZS5nZXROdW1Qb2ludHMoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gR299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUdvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2xpbmVhckdlb209bnVsbCx0aGlzLl9udW1MaW5lcz1udWxsLHRoaXMuX2N1cnJlbnRMaW5lPW51bGwsdGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl92ZXJ0ZXhJbmRleD0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtHby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMCwwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtHby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZS5nZXRDb21wb25lbnRJbmRleCgpLEdvLnNlZ21lbnRFbmRWZXJ0ZXhJbmRleChlKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07aWYoIV8odCxvdCkpdGhyb3cgbmV3IG4oXCJMaW5lYWwgZ2VvbWV0cnkgaXMgcmVxdWlyZWRcIik7dGhpcy5fbGluZWFyR2VvbT10LHRoaXMuX251bUxpbmVzPXQuZ2V0TnVtR2VvbWV0cmllcygpLHRoaXMuX2NvbXBvbmVudEluZGV4PWUsdGhpcy5fdmVydGV4SW5kZXg9cyx0aGlzLmxvYWRDdXJyZW50TGluZSgpfX07Y2xhc3MgcW97Y29uc3RydWN0b3IoKXtxby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbmRleE9mKHQsZSl7cmV0dXJuIG5ldyBxbyh0KS5pbmRleE9mKGUpfXN0YXRpYyBpbmRleE9mQWZ0ZXIodCxlLG4pe3JldHVybiBuZXcgcW8odCkuaW5kZXhPZkFmdGVyKGUsbil9aW5kZXhPZih0KXtyZXR1cm4gdGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsbnVsbCl9aW5kZXhPZkZyb21TdGFydCh0LGUpe2xldCBuPWkuTUFYX1ZBTFVFLHM9MCxyPTAsbz0tMTtjb25zdCBsPW5ldyBlZTtmb3IobGV0IGk9bmV3IEdvKHRoaXMuX2xpbmVhckdlb20pO2kuaGFzTmV4dCgpO2kubmV4dCgpKWlmKCFpLmlzRW5kT2ZMaW5lKCkpe2wucDA9aS5nZXRTZWdtZW50U3RhcnQoKSxsLnAxPWkuZ2V0U2VnbWVudEVuZCgpO2NvbnN0IGE9bC5kaXN0YW5jZSh0KSxjPWwuc2VnbWVudEZyYWN0aW9uKHQpLGg9aS5nZXRDb21wb25lbnRJbmRleCgpLHU9aS5nZXRWZXJ0ZXhJbmRleCgpO2E8biYmKG51bGw9PT1lfHxlLmNvbXBhcmVMb2NhdGlvblZhbHVlcyhoLHUsYyk8MCkmJihzPWgscj11LG89YyxuPWEpfXJldHVybiBuPT09aS5NQVhfVkFMVUU/bmV3IEZvKGUpOm5ldyBGbyhzLHIsbyl9aW5kZXhPZkFmdGVyKHQsZSl7aWYobnVsbD09PWUpcmV0dXJuIHRoaXMuaW5kZXhPZih0KTtjb25zdCBuPUZvLmdldEVuZExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20pO2lmKG4uY29tcGFyZVRvKGUpPD0wKXJldHVybiBuO2NvbnN0IHM9dGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsZSk7cmV0dXJuIHUuaXNUcnVlKHMuY29tcGFyZVRvKGUpPj0wLFwiY29tcHV0ZWQgbG9jYXRpb24gaXMgYmVmb3JlIHNwZWNpZmllZCBtaW5pbXVtIGxvY2F0aW9uXCIpLHN9Z2V0Q2xhc3MoKXtyZXR1cm4gcW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXFvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9O2NsYXNzIEJve2NvbnN0cnVjdG9yKCl7Qm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW5kaWNlc09mKHQsZSl7cmV0dXJuIG5ldyBCbyh0KS5pbmRpY2VzT2YoZSl9aW5kaWNlc09mKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4oMCkuZ2V0Q29vcmRpbmF0ZU4oMCksbj10LmdldEdlb21ldHJ5Tih0LmdldE51bUdlb21ldHJpZXMoKS0xKSxzPW4uZ2V0Q29vcmRpbmF0ZU4obi5nZXROdW1Qb2ludHMoKS0xKSxpPW5ldyBxbyh0aGlzLl9saW5lYXJHZW9tKSxyPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiByWzBdPWkuaW5kZXhPZihlKSwwPT09dC5nZXRMZW5ndGgoKT9yWzFdPXJbMF0uY29weSgpOnJbMV09aS5pbmRleE9mQWZ0ZXIocyxyWzBdKSxyfWdldENsYXNzKCl7cmV0dXJuIEJvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Cby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fTtjbGFzcyBWb3tjb25zdHJ1Y3Rvcigpe1ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5lbmRMaW5lKCksdGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLl9saW5lcyl9Z2V0TGFzdENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fbGFzdFB0fWVuZExpbmUoKXtpZihudWxsPT09dGhpcy5fY29vcmRMaXN0KXJldHVybiBudWxsO2lmKHRoaXMuX2lnbm9yZUludmFsaWRMaW5lcyYmdGhpcy5fY29vcmRMaXN0LnNpemUoKTwyKXJldHVybiB0aGlzLl9jb29yZExpc3Q9bnVsbCxudWxsO2NvbnN0IHQ9dGhpcy5fY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IGU9dDt0aGlzLl9maXhJbnZhbGlkTGluZXMmJihlPXRoaXMudmFsaWRDb29yZGluYXRlU2VxdWVuY2UodCkpLHRoaXMuX2Nvb3JkTGlzdD1udWxsO2xldCBzPW51bGw7dHJ5e3M9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZVN0cmluZyhlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBuKSl0aHJvdyB0O2lmKCF0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXMpdGhyb3cgdH1udWxsIT09cyYmdGhpcy5fbGluZXMuYWRkKHMpfXNldEZpeEludmFsaWRMaW5lcyh0KXt0aGlzLl9maXhJbnZhbGlkTGluZXM9dH1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodCwhMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMuX2Nvb3JkTGlzdCYmKHRoaXMuX2Nvb3JkTGlzdD1uZXcgSSksdGhpcy5fY29vcmRMaXN0LmFkZCh0LGUpLHRoaXMuX2xhc3RQdD10fX1zZXRJZ25vcmVJbnZhbGlkTGluZXModCl7dGhpcy5faWdub3JlSW52YWxpZExpbmVzPXR9dmFsaWRDb29yZGluYXRlU2VxdWVuY2UodCl7aWYodC5sZW5ndGg+PTIpcmV0dXJuIHQ7cmV0dXJuW3RbMF0sdFswXV19Z2V0Q2xhc3MoKXtyZXR1cm4gVm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVZvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fbGluZXM9bmV3IHgsdGhpcy5fY29vcmRMaXN0PW51bGwsdGhpcy5faWdub3JlSW52YWxpZExpbmVzPSExLHRoaXMuX2ZpeEludmFsaWRMaW5lcz0hMSx0aGlzLl9sYXN0UHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdD10fTtjbGFzcyB6b3tjb25zdHJ1Y3Rvcigpe3pvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGV4dHJhY3QodCxlLG4pe3JldHVybiBuZXcgem8odCkuZXh0cmFjdChlLG4pfWNvbXB1dGVMaW5lYXIodCxlKXtjb25zdCBuPW5ldyBWbyh0aGlzLl9saW5lLmdldEZhY3RvcnkoKSk7bi5zZXRGaXhJbnZhbGlkTGluZXMoITApLHQuaXNWZXJ0ZXgoKXx8bi5hZGQodC5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKTtmb3IobGV0IHM9bmV3IEdvKHRoaXMuX2xpbmUsdCk7cy5oYXNOZXh0KCkmJiEoZS5jb21wYXJlTG9jYXRpb25WYWx1ZXMocy5nZXRDb21wb25lbnRJbmRleCgpLHMuZ2V0VmVydGV4SW5kZXgoKSwwKTwwKTtzLm5leHQoKSl7Y29uc3QgdD1zLmdldFNlZ21lbnRTdGFydCgpO24uYWRkKHQpLHMuaXNFbmRPZkxpbmUoKSYmbi5lbmRMaW5lKCl9cmV0dXJuIGUuaXNWZXJ0ZXgoKXx8bi5hZGQoZS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKSxuLmdldEdlb21ldHJ5KCl9Y29tcHV0ZUxpbmUodCxlKXtjb25zdCBuPXRoaXMuX2xpbmUuZ2V0Q29vcmRpbmF0ZXMoKSxzPW5ldyBJO2xldCBpPXQuZ2V0U2VnbWVudEluZGV4KCk7dC5nZXRTZWdtZW50RnJhY3Rpb24oKT4wJiYoaSs9MSk7bGV0IHI9ZS5nZXRTZWdtZW50SW5kZXgoKTsxPT09ZS5nZXRTZWdtZW50RnJhY3Rpb24oKSYmKHIrPTEpLHI+PW4ubGVuZ3RoJiYocj1uLmxlbmd0aC0xKSx0LmlzVmVydGV4KCl8fHMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSk7Zm9yKGxldCB0PWk7dDw9cjt0Kyspcy5hZGQoblt0XSk7ZS5pc1ZlcnRleCgpfHxzLmFkZChlLmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpLHMuc2l6ZSgpPD0wJiZzLmFkZCh0LmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpO2xldCBvPXMudG9Db29yZGluYXRlQXJyYXkoKTtyZXR1cm4gby5sZW5ndGg8PTEmJihvPVtvWzBdLG9bMF1dKSx0aGlzLl9saW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKG8pfWV4dHJhY3QodCxlKXtyZXR1cm4gZS5jb21wYXJlVG8odCk8MD90aGlzLnJldmVyc2UodGhpcy5jb21wdXRlTGluZWFyKGUsdCkpOnRoaXMuY29tcHV0ZUxpbmVhcih0LGUpfXJldmVyc2UodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBUdHx8dCBpbnN0YW5jZW9mIGZ0P3QucmV2ZXJzZSgpOih1LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwibm9uLWxpbmVhciBnZW9tZXRyeSBlbmNvdW50ZXJlZFwiKSxudWxsKX1nZXRDbGFzcygpe3JldHVybiB6b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19em8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmU9dH07Y2xhc3MgWW97Y29uc3RydWN0b3IoKXtZby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNsYW1wSW5kZXgodCl7Y29uc3QgZT10LmNvcHkoKTtyZXR1cm4gZS5jbGFtcCh0aGlzLl9saW5lYXJHZW9tKSxlfXByb2plY3QodCl7cmV0dXJuIHFvLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1jaGVja0dlb21ldHJ5VHlwZSgpe2lmKCEodGhpcy5fbGluZWFyR2VvbSBpbnN0YW5jZW9mIFR0fHx0aGlzLl9saW5lYXJHZW9tIGluc3RhbmNlb2YgZnQpKXRocm93IG5ldyBuKFwiSW5wdXQgZ2VvbWV0cnkgbXVzdCBiZSBsaW5lYXJcIil9ZXh0cmFjdFBvaW50KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBhcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lYXJHZW9tKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LnRvTG93ZXN0KHRoaXMuX2xpbmVhckdlb20pO3JldHVybiBuLmdldFNlZ21lbnQodGhpcy5fbGluZWFyR2VvbSkucG9pbnRBbG9uZ09mZnNldChuLmdldFNlZ21lbnRGcmFjdGlvbigpLGUpfX1pc1ZhbGlkSW5kZXgodCl7cmV0dXJuIHQuaXNWYWxpZCh0aGlzLl9saW5lYXJHZW9tKX1nZXRFbmRJbmRleCgpe3JldHVybiBGby5nZXRFbmRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tKX1nZXRTdGFydEluZGV4KCl7cmV0dXJuIG5ldyBGb31pbmRleE9mQWZ0ZXIodCxlKXtyZXR1cm4gcW8uaW5kZXhPZkFmdGVyKHRoaXMuX2xpbmVhckdlb20sdCxlKX1leHRyYWN0TGluZSh0LGUpe3JldHVybiB6by5leHRyYWN0KHRoaXMuX2xpbmVhckdlb20sdCxlKX1pbmRleE9mKHQpe3JldHVybiBxby5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9aW5kaWNlc09mKHQpe3JldHVybiBCby5pbmRpY2VzT2YodGhpcy5fbGluZWFyR2VvbSx0KX1nZXRDbGFzcygpe3JldHVybiBZb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19WW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dCx0aGlzLmNoZWNrR2VvbWV0cnlUeXBlKCl9O2NsYXNzIFVve2NvbnN0cnVjdG9yKCl7VW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW5kZXhPZih0LGUpe3JldHVybiBuZXcgVW8odCkuaW5kZXhPZihlKX1zdGF0aWMgaW5kZXhPZkFmdGVyKHQsZSxuKXtyZXR1cm4gbmV3IFVvKHQpLmluZGV4T2ZBZnRlcihlLG4pfWluZGV4T2YodCl7cmV0dXJuIHRoaXMuaW5kZXhPZkZyb21TdGFydCh0LC0xKX1pbmRleE9mRnJvbVN0YXJ0KHQsZSl7bGV0IG49aS5NQVhfVkFMVUUscz1lLHI9MDtjb25zdCBvPW5ldyBlZSxsPW5ldyBHbyh0aGlzLl9saW5lYXJHZW9tKTtmb3IoO2wuaGFzTmV4dCgpOyl7aWYoIWwuaXNFbmRPZkxpbmUoKSl7by5wMD1sLmdldFNlZ21lbnRTdGFydCgpLG8ucDE9bC5nZXRTZWdtZW50RW5kKCk7Y29uc3QgaT1vLmRpc3RhbmNlKHQpLGE9dGhpcy5zZWdtZW50TmVhcmVzdE1lYXN1cmUobyx0LHIpO2k8biYmYT5lJiYocz1hLG49aSkscis9by5nZXRMZW5ndGgoKX1sLm5leHQoKX1yZXR1cm4gc31pbmRleE9mQWZ0ZXIodCxlKXtpZihlPDApcmV0dXJuIHRoaXMuaW5kZXhPZih0KTtjb25zdCBuPXRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCk7aWYobjxlKXJldHVybiBuO2NvbnN0IHM9dGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsZSk7cmV0dXJuIHUuaXNUcnVlKHM+PWUsXCJjb21wdXRlZCBpbmRleCBpcyBiZWZvcmUgc3BlY2lmaWVkIG1pbmltdW0gaW5kZXhcIiksc31zZWdtZW50TmVhcmVzdE1lYXN1cmUodCxlLG4pe2NvbnN0IHM9dC5wcm9qZWN0aW9uRmFjdG9yKGUpO3JldHVybiBzPD0wP246czw9MT9uK3MqdC5nZXRMZW5ndGgoKTpuK3QuZ2V0TGVuZ3RoKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gVW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVVvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9O2NsYXNzIGtve2NvbnN0cnVjdG9yKCl7a28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0TGVuZ3RoKHQsZSl7cmV0dXJuIG5ldyBrbyh0KS5nZXRMZW5ndGgoZSl9c3RhdGljIGdldExvY2F0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcga28odCkuZ2V0TG9jYXRpb24oZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuZXcga28odCkuZ2V0TG9jYXRpb24oZSxuKX19Z2V0TGVuZ3RoKHQpe2xldCBlPTA7Y29uc3Qgbj1uZXcgR28odGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtuLmhhc05leHQoKTspe2lmKCFuLmlzRW5kT2ZMaW5lKCkpe2NvbnN0IHM9bi5nZXRTZWdtZW50U3RhcnQoKSxpPW4uZ2V0U2VnbWVudEVuZCgpLmRpc3RhbmNlKHMpO2lmKHQuZ2V0Q29tcG9uZW50SW5kZXgoKT09PW4uZ2V0Q29tcG9uZW50SW5kZXgoKSYmdC5nZXRTZWdtZW50SW5kZXgoKT09PW4uZ2V0VmVydGV4SW5kZXgoKSlyZXR1cm4gZStpKnQuZ2V0U2VnbWVudEZyYWN0aW9uKCk7ZSs9aX1uLm5leHQoKX1yZXR1cm4gZX1yZXNvbHZlSGlnaGVyKHQpe2lmKCF0LmlzRW5kcG9pbnQodGhpcy5fbGluZWFyR2VvbSkpcmV0dXJuIHQ7bGV0IGU9dC5nZXRDb21wb25lbnRJbmRleCgpO2lmKGU+PXRoaXMuX2xpbmVhckdlb20uZ2V0TnVtR2VvbWV0cmllcygpLTEpcmV0dXJuIHQ7ZG97ZSsrfXdoaWxlKGU8dGhpcy5fbGluZWFyR2VvbS5nZXROdW1HZW9tZXRyaWVzKCktMSYmMD09PXRoaXMuX2xpbmVhckdlb20uZ2V0R2VvbWV0cnlOKGUpLmdldExlbmd0aCgpKTtyZXR1cm4gbmV3IEZvKGUsMCwwKX1nZXRMb2NhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbih0LCEwKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49dDtpZih0PDApe249dGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKSt0fWNvbnN0IHM9dGhpcy5nZXRMb2NhdGlvbkZvcndhcmQobik7cmV0dXJuIGU/czp0aGlzLnJlc29sdmVIaWdoZXIocyl9fWdldExvY2F0aW9uRm9yd2FyZCh0KXtpZih0PD0wKXJldHVybiBuZXcgRm87bGV0IGU9MDtjb25zdCBuPW5ldyBHbyh0aGlzLl9saW5lYXJHZW9tKTtmb3IoO24uaGFzTmV4dCgpOyl7aWYobi5pc0VuZE9mTGluZSgpKXtpZihlPT09dCl7Y29uc3QgdD1uLmdldENvbXBvbmVudEluZGV4KCksZT1uLmdldFZlcnRleEluZGV4KCk7cmV0dXJuIG5ldyBGbyh0LGUsMCl9fWVsc2V7Y29uc3Qgcz1uLmdldFNlZ21lbnRTdGFydCgpLGk9bi5nZXRTZWdtZW50RW5kKCkuZGlzdGFuY2Uocyk7aWYoZStpPnQpe2NvbnN0IHM9KHQtZSkvaSxyPW4uZ2V0Q29tcG9uZW50SW5kZXgoKSxvPW4uZ2V0VmVydGV4SW5kZXgoKTtyZXR1cm4gbmV3IEZvKHIsbyxzKX1lKz1pfW4ubmV4dCgpfXJldHVybiBGby5nZXRFbmRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tKX1nZXRDbGFzcygpe3JldHVybiBrb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19a28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH07Y2xhc3MgWG97Y29uc3RydWN0b3IoKXtYby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNsYW1wSW5kZXgodCl7Y29uc3QgZT10aGlzLnBvc2l0aXZlSW5kZXgodCksbj10aGlzLmdldFN0YXJ0SW5kZXgoKTtpZihlPG4pcmV0dXJuIG47Y29uc3Qgcz10aGlzLmdldEVuZEluZGV4KCk7cmV0dXJuIGU+cz9zOmV9bG9jYXRpb25PZigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4ga28uZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGtvLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCxlKX19cHJvamVjdCh0KXtyZXR1cm4gVW8uaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfXBvc2l0aXZlSW5kZXgodCl7cmV0dXJuIHQ+PTA/dDp0aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpK3R9ZXh0cmFjdFBvaW50KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBrby5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQpLmdldENvb3JkaW5hdGUodGhpcy5fbGluZWFyR2VvbSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49a28uZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KS50b0xvd2VzdCh0aGlzLl9saW5lYXJHZW9tKTtyZXR1cm4gbi5nZXRTZWdtZW50KHRoaXMuX2xpbmVhckdlb20pLnBvaW50QWxvbmdPZmZzZXQobi5nZXRTZWdtZW50RnJhY3Rpb24oKSxlKX19aXNWYWxpZEluZGV4KHQpe3JldHVybiB0Pj10aGlzLmdldFN0YXJ0SW5kZXgoKSYmdDw9dGhpcy5nZXRFbmRJbmRleCgpfWdldEVuZEluZGV4KCl7cmV0dXJuIHRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCl9Z2V0U3RhcnRJbmRleCgpe3JldHVybiAwfWluZGV4T2ZBZnRlcih0LGUpe3JldHVybiBVby5pbmRleE9mQWZ0ZXIodGhpcy5fbGluZWFyR2VvbSx0LGUpfWV4dHJhY3RMaW5lKHQsZSl7bmV3IFlvKHRoaXMuX2xpbmVhckdlb20pO2NvbnN0IG49dGhpcy5jbGFtcEluZGV4KHQpLHM9dGhpcy5jbGFtcEluZGV4KGUpLGk9bj09PXMscj10aGlzLmxvY2F0aW9uT2YobixpKSxvPXRoaXMubG9jYXRpb25PZihzKTtyZXR1cm4gem8uZXh0cmFjdCh0aGlzLl9saW5lYXJHZW9tLHIsbyl9aW5kZXhPZih0KXtyZXR1cm4gVW8uaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfWluZGljZXNPZih0KXtjb25zdCBlPUJvLmluZGljZXNPZih0aGlzLl9saW5lYXJHZW9tLHQpO3JldHVybltrby5nZXRMZW5ndGgodGhpcy5fbGluZWFyR2VvbSxlWzBdKSxrby5nZXRMZW5ndGgodGhpcy5fbGluZWFyR2VvbSxlWzFdKV19Z2V0Q2xhc3MoKXtyZXR1cm4gWG99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVhvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9O3ZhciBIbz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxMZW5ndGhJbmRleGVkTGluZTpYbyxMZW5ndGhMb2NhdGlvbk1hcDprbyxMaW5lYXJHZW9tZXRyeUJ1aWxkZXI6Vm8sTGluZWFySXRlcmF0b3I6R28sTGluZWFyTG9jYXRpb246Rm8sTG9jYXRpb25JbmRleGVkTGluZTpZb30pO2NsYXNzIFdve2NvbnN0cnVjdG9yKCl7V28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdHJhbnNmb3JtKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyluLmFkZChlLmV4ZWN1dGUocy5uZXh0KCkpKTtyZXR1cm4gbn1zdGF0aWMgc2VsZWN0KHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtCb29sZWFuLlRSVUUuZXF1YWxzKGUuZXhlY3V0ZSh0KSkmJm4uYWRkKHQpfXJldHVybiBufXN0YXRpYyBhcHBseSh0LGUpe2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUuZXhlY3V0ZShuLm5leHQoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gV299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVdvLkZ1bmN0aW9uPWZ1bmN0aW9uKCl7fSxXby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGpve2NvbnN0cnVjdG9yKCl7am8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7dGhpcy5wdHNbdGhpcy5uKytdPXR9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5wdHN9Z2V0Q2xhc3MoKXtyZXR1cm4gam99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0JdfX1qby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLnB0cz1udWxsLHRoaXMubj0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpfTtjbGFzcyBLb3tjb25zdHJ1Y3Rvcigpe0tvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe3RoaXMuX24rK31nZXRDb3VudCgpe3JldHVybiB0aGlzLl9ufWdldENsYXNzKCl7cmV0dXJuIEtvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltCXX19S28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbj0wfTtjbGFzcyBab3tjb25zdHJ1Y3Rvcigpe1pvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y291bnQodCl7Y29uc3QgZT10aGlzLl9jb3VudHMuZ2V0KHQpO3JldHVybiBudWxsPT09ZT8wOmUuY291bnQoKX1hZGQodCl7Y29uc3QgZT10aGlzLl9jb3VudHMuZ2V0KHQpO251bGw9PT1lP3RoaXMuX2NvdW50cy5wdXQodCxuZXcgUW8oMSkpOmUuaW5jcmVtZW50KCl9Z2V0Q2xhc3MoKXtyZXR1cm4gWm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIFFve2NvbnN0cnVjdG9yKCl7UW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb3VudCgpe3JldHVybiB0aGlzLmNvdW50fWluY3JlbWVudCgpe3RoaXMuY291bnQrK31nZXRDbGFzcygpe3JldHVybiBRb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5jb3VudD0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNvdW50PXR9fSxaby5Db3VudGVyPVFvLFpvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2NvdW50cz1uZXcgVXR9O3ZhciBKbz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb2xsZWN0aW9uVXRpbDpXbyxDb29yZGluYXRlQXJyYXlGaWx0ZXI6am8sQ29vcmRpbmF0ZUNvdW50RmlsdGVyOktvLEdlb21ldHJpY1NoYXBlRmFjdG9yeTpTZSxOdW1iZXJVdGlsOmUsT2JqZWN0Q291bnRlcjpabyxQcmlvcml0eVF1ZXVlOmZzLFN0cmluZ1V0aWw6U3QsVW5pcXVlQ29vcmRpbmF0ZUFycmF5RmlsdGVyOmxufSk7Y2xhc3MgJG97Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119Z2V0Q2xhc3MoKXtyZXR1cm4gJG99c3RhdGljIHVuaW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIGNyLmNyZWF0ZUVtcHR5UmVzdWx0KGNyLlVOSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1yZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLGxyLm92ZXJsYXlPcCh0LGUsY3IuVU5JT04pfX1xLnByb3RvdHlwZS5lcXVhbHNUb3BvPWZ1bmN0aW9uKHQpe3JldHVybiEhdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuZXF1YWxzKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmR3IucmVsYXRlKHRoaXMsdCkuaXNFcXVhbHModGhpcy5nZXREaW1lbnNpb24oKSx0LmdldERpbWVuc2lvbigpKX0scS5wcm90b3R5cGUudW5pb249ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4genIudW5pb24odGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiAkby51bmlvbih0aGlzLHQpfX0scS5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiBDci5pc1ZhbGlkKHRoaXMpfSxxLnByb3RvdHlwZS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCl7cmV0dXJuIGNyLmludGVyc2VjdGlvbih0aGlzLHQpfSxxLnByb3RvdHlwZS5jb3ZlcnM9ZnVuY3Rpb24odCl7cmV0dXJuIEdyLmNvdmVycyh0aGlzLHQpfSxxLnByb3RvdHlwZS5jb3ZlcmVkQnk9ZnVuY3Rpb24odCl7cmV0dXJuIEdyLmNvdmVycyh0LHRoaXMpfSxxLnByb3RvdHlwZS50b3VjaGVzPWZ1bmN0aW9uKHQpe3JldHVybiBHci50b3VjaGVzKHRoaXMsdCl9LHEucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24odCl7cmV0dXJuIEdyLmludGVyc2VjdHModGhpcyx0KX0scS5wcm90b3R5cGUud2l0aGluPWZ1bmN0aW9uKHQpe3JldHVybiBHci5jb250YWlucyh0LHRoaXMpfSxxLnByb3RvdHlwZS5vdmVybGFwcz1mdW5jdGlvbih0KXtyZXR1cm4gR3Iub3ZlcmxhcHModGhpcyx0KX0scS5wcm90b3R5cGUuZGlzam9pbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIEdyLmRpc2pvaW50KHRoaXMsdCl9LHEucHJvdG90eXBlLmNyb3NzZXM9ZnVuY3Rpb24odCl7cmV0dXJuIEdyLmNyb3NzZXModGhpcyx0KX0scS5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBTaS5idWZmZXJPcCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gU2kuYnVmZmVyT3AodGhpcyx0LGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gU2kuYnVmZmVyT3AodGhpcyx0LGUsbil9fSxxLnByb3RvdHlwZS5jb252ZXhIdWxsPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhbih0aGlzKS5nZXRDb252ZXhIdWxsKCl9LHEucHJvdG90eXBlLnJlbGF0ZT1mdW5jdGlvbiguLi50KXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEdyLnJlbGF0ZSh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gR3IucmVsYXRlKHRoaXMsdCkubWF0Y2hlcyhlKX19LHEucHJvdG90eXBlLmdldENlbnRyb2lkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQoKTtjb25zdCB0PXNuLmdldENlbnRyb2lkKHRoaXMpO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCx0aGlzKX0scS5wcm90b3R5cGUuZ2V0SW50ZXJpb3JQb2ludD1mdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KCk7bGV0IHQ9bnVsbDtjb25zdCBlPXRoaXMuZ2V0RGltZW5zaW9uKCk7dD0wPT09ZT9uZXcgZG4odGhpcyk6MT09PWU/bmV3IGduKHRoaXMpOm5ldyBobih0aGlzKTtjb25zdCBuPXQuZ2V0SW50ZXJpb3JQb2ludCgpO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQobix0aGlzKX0scS5wcm90b3R5cGUuc3ltRGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gY3Iuc3ltRGlmZmVyZW5jZSh0aGlzLHQpfSxxLnByb3RvdHlwZS5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX0scS5wcm90b3R5cGUudG9UZXh0PWZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBKdCkud3JpdGUodGhpcyl9LHEucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dGhpcy50b1RleHQoKX0scS5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7cmV0dXJuIEdyLmNvbnRhaW5zKHRoaXMsdCl9LHEucHJvdG90eXBlLmRpZmZlcmVuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIGNyLmRpZmZlcmVuY2UodGhpcyx0KX0scS5wcm90b3R5cGUuaXNTaW1wbGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEhzKHRoaXMpLmlzU2ltcGxlKCl9LHEucHJvdG90eXBlLmlzV2l0aGluRGlzdGFuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4hKHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT5lKSYmUmkuaXNXaXRoaW5EaXN0YW5jZSh0aGlzLHQsZSl9LHEucHJvdG90eXBlLmRpc3RhbmNlPWZ1bmN0aW9uKHQpe3JldHVybiBSaS5kaXN0YW5jZSh0aGlzLHQpfSxxLnByb3RvdHlwZS5pc0VxdWl2YWxlbnRDbGFzcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRDbGFzcygpPT09dC5nZXRDbGFzcygpfTt0LmFsZ29yaXRobT1tbix0LmRlbnNpZnk9RW4sdC5kaXNzb2x2ZT1Sbix0Lmdlb209UmUsdC5nZW9tZ3JhcGg9Sm4sdC5pbmRleD1Dcyx0LmlvPVBzLHQubGluZWFycmVmPUhvLHQubm9kaW5nPVhzLHQub3BlcmF0aW9uPWtyLHQucHJlY2lzaW9uPVdyLHQuc2ltcGxpZnk9aG8sdC50cmlhbmd1bGF0ZT1Bbyx0LnV0aWw9Sm8sdC52ZXJzaW9uPVwiMi4xLjIgKDgzYjVhZWUpXCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc3RzLm1pbi5qcy5tYXAiLCIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2tzLCBpZiBwb2x5Z29uIGlzIHNpbXBsZS4gUG9seWdvbiBpcyBzaW1wbGUsIHdoZW4gaXRzIGVkZ2VzIGRvbid0IGNyb3NzIGVhY2ggb3RoZXIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBQb2x5Z29uIGlzIHNpbXBsZVxuICovXG5mdW5jdGlvbiBJc1NpbXBsZSAocG9seWdvbikge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBuID0gcC5sZW5ndGggPj4gMTtcbiAgaWYgKG4gPCA0KSByZXR1cm4gdHJ1ZVxuICB2YXIgYTEgPSBQb2ludCgpO1xuICB2YXIgYTIgPSBQb2ludCgpO1xuICB2YXIgYjEgPSBQb2ludCgpO1xuICB2YXIgYjIgPSBQb2ludCgpO1xuICB2YXIgYyA9IFBvaW50KCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBhMS54ID0gcFsyICogaV07XG4gICAgYTEueSA9IHBbMiAqIGkgKyAxXTtcbiAgICBpZiAoaSA9PSBuIC0gMSkge1xuICAgICAgYTIueCA9IHBbMF07XG4gICAgICBhMi55ID0gcFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYTIueCA9IHBbMiAqIGkgKyAyXTtcbiAgICAgIGEyLnkgPSBwWzIgKiBpICsgM107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIGlmIChNYXRoLmFicyhpIC0gaikgPCAyKSBjb250aW51ZVxuICAgICAgaWYgKGogPT0gbiAtIDEgJiYgaSA9PSAwKSBjb250aW51ZVxuICAgICAgaWYgKGkgPT0gbiAtIDEgJiYgaiA9PSAwKSBjb250aW51ZVxuXG4gICAgICBiMS54ID0gcFsyICogal07XG4gICAgICBiMS55ID0gcFsyICogaiArIDFdO1xuICAgICAgaWYgKGogPT0gbiAtIDEpIHtcbiAgICAgICAgYjIueCA9IHBbMF07XG4gICAgICAgIGIyLnkgPSBwWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYjIueCA9IHBbMiAqIGogKyAyXTtcbiAgICAgICAgYjIueSA9IHBbMiAqIGogKyAzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKEdldExpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpICE9IG51bGwpIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxubW9kdWxlLmV4cG9ydHMuSXNTaW1wbGUgPSBJc1NpbXBsZTtcblxuLyoqXG4gKiBDaGVja3MsIGlmIHBvbHlnb24gaXMgY29udmV4LiBQb2x5Z29uIGlzIGNvbnZleCwgd2hlbiBlYWNoIGlubmVyIGFuZ2xlIGlzIDw9IDE4MMKwLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIElzQ29udmV4IChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgaWYgKHAubGVuZ3RoIDwgNikgcmV0dXJuIHRydWVcbiAgdmFyIGwgPSBwLmxlbmd0aCAtIDQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgaWYgKCFjb252ZXgocFtpXSwgcFtpICsgMV0sIHBbaSArIDJdLCBwW2kgKyAzXSwgcFtpICsgNF0sIHBbaSArIDVdKSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKCFjb252ZXgocFtsXSwgcFtsICsgMV0sIHBbbCArIDJdLCBwW2wgKyAzXSwgcFswXSwgcFsxXSkpIHJldHVybiBmYWxzZVxuICBpZiAoIWNvbnZleChwW2wgKyAyXSwgcFtsICsgM10sIHBbMF0sIHBbMV0sIHBbMl0sIHBbM10pKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRydWVcbn1cbm1vZHVsZS5leHBvcnRzLklzQ29udmV4ID0gSXNDb252ZXg7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJlYSBvZiBwb2x5Z29uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gR2V0QXJlYSAocG9seWdvbikge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIGlmIChwLmxlbmd0aCA8IDYpIHJldHVybiAwXG4gIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICB2YXIgc3VtID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICBzdW0gKz0gKHBbaSArIDJdIC0gcFtpXSkgKiAocFtpICsgMV0gKyBwW2kgKyAzXSk7XG4gIH1cbiAgc3VtICs9IChwWzBdIC0gcFtsXSkgKiAocFtsICsgMV0gKyBwWzFdKTtcbiAgcmV0dXJuIC1zdW0gKiAwLjVcbn1cbm1vZHVsZS5leHBvcnRzLkdldEFyZWEgPSBHZXRBcmVhO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIEF4aXMtYWxpZ25lZCBCb3VuZGluZyBCb3ggb2YgcG9seWdvblxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHJldHVybnMge0FBQkJ9XG4gKiBAZXhhbXBsZVxuICogLy89e3g6MCwgeTowLCB3aWR0aDowLCBoZWlnaHQ6MH1cbiAqL1xuZnVuY3Rpb24gR2V0QUFCQiAocG9seWdvbikge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBtaW54ID0gSW5maW5pdHk7XG4gIHZhciBtaW55ID0gSW5maW5pdHk7XG4gIHZhciBtYXh4ID0gLW1pbng7XG4gIHZhciBtYXh5ID0gLW1pbnk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkgKz0gMikge1xuICAgIG1pbnggPSBNYXRoLm1pbihtaW54LCBwW2ldKTtcbiAgICBtYXh4ID0gTWF0aC5tYXgobWF4eCwgcFtpXSk7XG4gICAgbWlueSA9IE1hdGgubWluKG1pbnksIHBbaSArIDFdKTtcbiAgICBtYXh5ID0gTWF0aC5tYXgobWF4eSwgcFtpICsgMV0pO1xuICB9XG4gIHJldHVybiB7eDogbWlueCwgeTogbWlueSwgd2lkdGg6IG1heHggLSBtaW54LCBoZWlnaHQ6IG1heHkgLSBtaW55fVxufVxubW9kdWxlLmV4cG9ydHMuR2V0QUFCQiA9IEdldEFBQkI7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHRyaWFuZ3VsYXRpb24uIE91dHB1dCBhcnJheSBpcyBhcnJheSBvZiB0cmlhbmdsZXMgKHRyaWFuZ2xlID0gMyBpbmRpY2VzIG9mIHBvbHlnb24gdmVydGljZXMpLlxuICpcbiAqIFdvcmtzIHdpdGggc2ltcGxlIHBvbHlnb25zIG9ubHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IGFycmF5IG9mIHRyaWFuZ2xlcyAodHJpYW5nbGUgPSAzIGluZGljZXMgb2YgcG9seWdvbiB2ZXJ0aWNlcylcbiAqIEBleGFtcGxlXG4gKiB2YXIgaWRzID0gUG9seUsuVHJpYW5ndWxhdGUoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKTtcbiAqIC8vPVswLCAxLCAyLCAwLCAyLCAzXVxuICovXG5mdW5jdGlvbiBUcmlhbmd1bGF0ZSAocG9seWdvbikge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBuID0gcC5sZW5ndGggPj4gMTtcbiAgaWYgKG4gPCAzKSByZXR1cm4gW11cbiAgdmFyIHRncyA9IFtdO1xuICB2YXIgYXZsID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IGF2bC5wdXNoKGkpOyB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgYWwgPSBuO1xuICB3aGlsZSAoYWwgPiAzKSB7XG4gICAgdmFyIGkwID0gYXZsWyhpICsgMCkgJSBhbF07XG4gICAgdmFyIGkxID0gYXZsWyhpICsgMSkgJSBhbF07XG4gICAgdmFyIGkyID0gYXZsWyhpICsgMikgJSBhbF07XG5cbiAgICB2YXIgYXggPSBwWzIgKiBpMF07XG4gICAgdmFyIGF5ID0gcFsyICogaTAgKyAxXTtcbiAgICB2YXIgYnggPSBwWzIgKiBpMV07XG4gICAgdmFyIGJ5ID0gcFsyICogaTEgKyAxXTtcbiAgICB2YXIgY3ggPSBwWzIgKiBpMl07XG4gICAgdmFyIGN5ID0gcFsyICogaTIgKyAxXTtcblxuICAgIHZhciBlYXJGb3VuZCA9IGZhbHNlO1xuICAgIGlmIChjb252ZXgoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpIHtcbiAgICAgIGVhckZvdW5kID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWw7IGorKykge1xuICAgICAgICB2YXIgdmkgPSBhdmxbal07XG4gICAgICAgIGlmICh2aSA9PSBpMCB8fCB2aSA9PSBpMSB8fCB2aSA9PSBpMikgY29udGludWVcbiAgICAgICAgaWYgKFBvaW50SW5UcmlhbmdsZShwWzIgKiB2aV0sIHBbMiAqIHZpICsgMV0sIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7XG4gICAgICAgICAgZWFyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlYXJGb3VuZCkge1xuICAgICAgdGdzLnB1c2goaTAsIGkxLCBpMik7XG4gICAgICBhdmwuc3BsaWNlKChpICsgMSkgJSBhbCwgMSk7XG4gICAgICBhbC0tO1xuICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIGlmIChpKysgPiAzICogYWwpIGJyZWFrICAgIC8vIG5vIGNvbnZleCBhbmdsZXMgOihcbiAgfVxuICB0Z3MucHVzaChhdmxbMF0sIGF2bFsxXSwgYXZsWzJdKTtcbiAgcmV0dXJuIHRnc1xufVxubW9kdWxlLmV4cG9ydHMuVHJpYW5ndWxhdGUgPSBUcmlhbmd1bGF0ZTtcblxuLyoqXG4gKiBTbGljZXMgdGhlIHBvbHlnb24gd2l0aCBsaW5lIHNlZ21lbnQgQS1CLCBkZWZpbmVkIGJ5IFtheCxheV0gYW5kIFtieCxieV0uIEEsIEIgbXVzdCBub3QgbGF5IGluc2lkZSBhIHBvbHlnb24uIFJldHVybnMgYW4gYXJyYXkgb2YgcG9seWdvbnMuXG4gKlxuICogV29ya3Mgd2l0aCBzaW1wbGUgcG9seWdvbnMgb25seS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFggU3RhcnQgQ29vcmRpbmF0ZSBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFkgU3RhcnQgQ29vcmRpbmF0ZSBbeV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRYIEVuZCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFkgRW5kIENvb3JkaW5hdGUgW3ldXG4gKiBAcmV0dXJucyB7bnVtYmVyW11bXX0gQXJyYXkgb2YgUG9seWdvblxuICovXG5mdW5jdGlvbiBTbGljZSAocG9seWdvbiwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFkpIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICB2YXIgYXggPSBzdGFydFg7XG4gIHZhciBheSA9IHN0YXJ0WTtcbiAgdmFyIGJ4ID0gZW5kWDtcbiAgdmFyIGJ5ID0gZW5kWTtcbiAgaWYgKENvbnRhaW5zUG9pbnQocCwgYXgsIGF5KSB8fCBDb250YWluc1BvaW50KHAsIGJ4LCBieSkpIHtcbiAgICByZXR1cm4gW3Auc2xpY2UoMCldXG4gIH1cblxuICB2YXIgYSA9IFBvaW50KGF4LCBheSk7XG4gIHZhciBiID0gUG9pbnQoYngsIGJ5KTtcbiAgdmFyIGlzY3MgPSBbXTsgIC8vIGludGVyc2VjdGlvbnNcbiAgdmFyIHBzID0gW107ICAvLyBwb2ludHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcHMucHVzaChQb2ludChwW2ldLCBwW2kgKyAxXSkpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXNjID0gUG9pbnQoMCwgMCk7XG4gICAgaXNjID0gR2V0TGluZUludGVyc2VjdGlvbihhLCBiLCBwc1tpXSwgcHNbKGkgKyAxKSAlIHBzLmxlbmd0aF0sIGlzYyk7XG4gICAgdmFyIGZpc2MgPSBpc2NzWzBdO1xuICAgIHZhciBsaXNjID0gaXNjc1tpc2NzLmxlbmd0aCAtIDFdO1xuICAgIC8vICYmIChpc2MueCE9cHNbaV0ueCB8fCBpc2MueSE9cHNbaV0ueSkgKVxuICAgIGlmIChpc2MgJiYgKGZpc2MgPT0gbnVsbCB8fCBkaXN0YW5jZShpc2MsIGZpc2MpID4gMWUtMTApICYmIChsaXNjID09IG51bGwgfHwgZGlzdGFuY2UoaXNjLCBsaXNjKSA+IDFlLTEwKSkge1xuICAgICAgaXNjLmZsYWcgPSB0cnVlO1xuICAgICAgaXNjcy5wdXNoKGlzYyk7XG4gICAgICBwcy5zcGxpY2UoaSArIDEsIDAsIGlzYyk7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzY3MubGVuZ3RoIDwgMikgcmV0dXJuIFtwLnNsaWNlKDApXVxuICB2YXIgY29tcCA9IGZ1bmN0aW9uICh1LCB2KSB7IHJldHVybiBkaXN0YW5jZShhLCB1KSAtIGRpc3RhbmNlKGEsIHYpIH07XG4gIGlzY3Muc29ydChjb21wKTtcblxuICB2YXIgcGdzID0gW107XG4gIHZhciBkaXIgPSAwO1xuICB3aGlsZSAoaXNjcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gdmFyIG4gPSBwcy5sZW5ndGggLy8gaXMgYXNzaWduZWQgYSB2YWx1ZSBidXQgbmV2ZXIgdXNlZC4gKG5vLXVudXNlZC12YXJzKVxuICAgIHZhciBpMCA9IGlzY3NbMF07XG4gICAgdmFyIGkxID0gaXNjc1sxXTtcbiAgICAvLyBpZihpMC54PT1pMS54ICYmIGkwLnk9PWkxLnkpIHsgaXNjcy5zcGxpY2UoMCwyKTsgY29udGludWU7fVxuICAgIHZhciBpbmRleDAgPSBwcy5pbmRleE9mKGkwKTtcbiAgICB2YXIgaW5kZXgxID0gcHMuaW5kZXhPZihpMSk7XG4gICAgdmFyIHNvbHZlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGZpcnN0V2l0aEZsYWcocHMsIGluZGV4MCkgPT09IGluZGV4MSkge1xuICAgICAgc29sdmVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaTAgPSBpc2NzWzFdO1xuICAgICAgaTEgPSBpc2NzWzBdO1xuICAgICAgaW5kZXgwID0gcHMuaW5kZXhPZihpMCk7XG4gICAgICBpbmRleDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICAgIGlmIChmaXJzdFdpdGhGbGFnKHBzLCBpbmRleDApID09PSBpbmRleDEpIHNvbHZlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzb2x2ZWQpIHtcbiAgICAgIGRpci0tO1xuICAgICAgdmFyIHBnbiA9IGdldFBvaW50cyhwcywgaW5kZXgwLCBpbmRleDEpO1xuICAgICAgcGdzLnB1c2gocGduKTtcbiAgICAgIHBzID0gZ2V0UG9pbnRzKHBzLCBpbmRleDEsIGluZGV4MCk7XG4gICAgICBpMC5mbGFnID0gaTEuZmxhZyA9IGZhbHNlO1xuICAgICAgaXNjcy5zcGxpY2UoMCwgMik7XG4gICAgICBpZiAoaXNjcy5sZW5ndGggPT0gMCkgcGdzLnB1c2gocHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXIrKztcbiAgICAgIGlzY3MucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBpZiAoZGlyID4gMSkgYnJlYWtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBnID0gcGdzW2ldO1xuICAgIHZhciBucGcgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBnLmxlbmd0aDsgaisrKSB7IG5wZy5wdXNoKHBnW2pdLngsIHBnW2pdLnkpOyB9XG4gICAgcmVzdWx0LnB1c2gobnBnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5tb2R1bGUuZXhwb3J0cy5TbGljZSA9IFNsaWNlO1xuXG4vKipcbiAqIENoZWNrcywgaWYgcG9seWdvbiBjb250YWlucyBbeCwgeV0uXG4gKlxuICogV29ya3Mgd2l0aCBzaW1wbGUgcG9seWdvbnMgb25seS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludFggQ29vcmRpbmF0ZSBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludFkgQ29vcmRpbmF0ZSBbeV1cbiAqIEByZXR1cm5zIHtib29sZWFufSBkZXB0aFxuICovXG5mdW5jdGlvbiBDb250YWluc1BvaW50IChwb2x5Z29uLCBwb2ludFgsIHBvaW50WSkge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBweCA9IHBvaW50WDtcbiAgdmFyIHB5ID0gcG9pbnRZO1xuICB2YXIgbiA9IHAubGVuZ3RoID4+IDE7XG4gIHZhciBheDtcbiAgdmFyIGF5ID0gcFsyICogbiAtIDNdIC0gcHk7XG4gIHZhciBieCA9IHBbMiAqIG4gLSAyXSAtIHB4O1xuICB2YXIgYnkgPSBwWzIgKiBuIC0gMV0gLSBweTtcblxuICAvLyB2YXIgbHVwID0gYnkgPiBheTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBheCA9IGJ4O1xuICAgIGF5ID0gYnk7XG4gICAgYnggPSBwWzIgKiBpXSAtIHB4O1xuICAgIGJ5ID0gcFsyICogaSArIDFdIC0gcHk7XG4gICAgaWYgKGF5ID09PSBieSkgY29udGludWVcbiAgICB2YXIgbHVwID0gYnkgPiBheTtcbiAgfVxuXG4gIHZhciBkZXB0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgYXggPSBieDtcbiAgICBheSA9IGJ5O1xuICAgIGJ4ID0gcFsyICogaV0gLSBweDtcbiAgICBieSA9IHBbMiAqIGkgKyAxXSAtIHB5O1xuICAgIGlmIChheSA8IDAgJiYgYnkgPCAwKSBjb250aW51ZSAgLy8gYm90aCBcInVwXCIgb3IgYm90aCBcImRvd25cIlxuICAgIGlmIChheSA+IDAgJiYgYnkgPiAwKSBjb250aW51ZSAgLy8gYm90aCBcInVwXCIgb3IgYm90aCBcImRvd25cIlxuICAgIGlmIChheCA8IDAgJiYgYnggPCAwKSBjb250aW51ZSAgIC8vIGJvdGggcG9pbnRzIG9uIHRoZSBsZWZ0XG5cbiAgICBpZiAoYXkgPT09IGJ5ICYmIE1hdGgubWluKGF4LCBieCkgPD0gMCkgcmV0dXJuIHRydWVcbiAgICBpZiAoYXkgPT09IGJ5KSBjb250aW51ZVxuXG4gICAgdmFyIGx4ID0gYXggKyAoYnggLSBheCkgKiAoLWF5KSAvIChieSAtIGF5KTtcbiAgICBpZiAobHggPT09IDApIHJldHVybiB0cnVlICAgICAgLy8gcG9pbnQgb24gZWRnZVxuICAgIGlmIChseCA+IDApIGRlcHRoKys7XG4gICAgaWYgKGF5ID09PSAwICYmIGx1cCAmJiBieSA+IGF5KSBkZXB0aC0tOyAgLy8gaGl0IHZlcnRleCwgYm90aCB1cFxuICAgIGlmIChheSA9PT0gMCAmJiAhbHVwICYmIGJ5IDwgYXkpIGRlcHRoLS07IC8vIGhpdCB2ZXJ0ZXgsIGJvdGggZG93blxuICAgIGx1cCA9IGJ5ID4gYXk7XG4gIH1cbiAgcmV0dXJuIChkZXB0aCAmIDEpID09PSAxXG59XG5tb2R1bGUuZXhwb3J0cy5Db250YWluc1BvaW50ID0gQ29udGFpbnNQb2ludDtcblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBwb2ludCBvZiBwb2x5Z29uLCB3aGljaCBsYXlzIG9uIHJheSBkZWZpbmVkIGJ5IFt4LHldIChvcmlnaW4pIGFuZCBbZHgsZHldIChkaXJlY3Rpb24pLlxuICpcbiAqIFwiZGlzdFwiIGlzIHRoZSBkaXN0YW5jZSBvZiB0aGUgcG9seWdvbiBwb2ludCwgXCJlZGdlXCIgaXMgdGhlIG51bWJlciBvZiB0aGUgZWRnZSwgb24gd2hpY2ggaW50ZXJzZWN0aW9uIG9jY3VycywgXCJub3JtXCIgaXMgdGhlIG5vcm1hbCBpbiB0aGF0IHBsYWNlLCBcInJlZmxcIiBpcyByZWZsZWN0ZWQgZGlyZWN0aW9uLlxuICpcbiAqIFdvcmtzIHdpdGggc2ltcGxlIHBvbHlnb25zIG9ubHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWCBPcmlnaW4gW3hdXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWSBPcmlnaW4gW3ldXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uWCBEaXJlY3Rpb24gW3hdXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uWSBEaXJlY3Rpb24gW3ldXG4gKiBAcmV0dXJucyB7UmF5Y2FzdH1cbiAqIEBleGFtcGxlXG4gKiAvLz17ZGlzdDowLCBlZGdlOjAsIG5vcm06e3g6MCwgeTowfSwgcmVmbDp7eDowLCB5OjB9fVxuICovXG5mdW5jdGlvbiBSYXljYXN0IChwb2x5Z29uLCBvcmlnaW5YLCBvcmlnaW5ZLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZLCBpc2MpIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICB2YXIgeCA9IG9yaWdpblg7XG4gIHZhciB5ID0gb3JpZ2luWTtcbiAgdmFyIGR4ID0gZGlyZWN0aW9uWDtcbiAgdmFyIGR5ID0gZGlyZWN0aW9uWTtcbiAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gIHZhciBlbXB0eSA9IGVtcHR5UG9pbnRzKCk7XG4gIHZhciBhMSA9IGVtcHR5WzBdO1xuICB2YXIgYTIgPSBlbXB0eVsxXTtcbiAgdmFyIGIxID0gZW1wdHlbMl07XG4gIHZhciBiMiA9IGVtcHR5WzNdO1xuICB2YXIgYyA9IGVtcHR5WzRdO1xuICBhMS54ID0geDtcbiAgYTEueSA9IHk7XG4gIGEyLnggPSB4ICsgZHg7XG4gIGEyLnkgPSB5ICsgZHk7XG5cbiAgaWYgKGlzYyA9PT0gbnVsbCB8fCBpc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIGlzYyA9IHtkaXN0OiAwLCBlZGdlOiAwLCBub3JtOiB7eDogMCwgeTogMH0sIHJlZmw6IHt4OiAwLCB5OiAwfX07XG4gIH1cbiAgaXNjLmRpc3QgPSBJbmZpbml0eTtcblxuICB2YXIgbmlzYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICBiMS54ID0gcFtpXTtcbiAgICBiMS55ID0gcFtpICsgMV07XG4gICAgYjIueCA9IHBbaSArIDJdO1xuICAgIGIyLnkgPSBwW2kgKyAzXTtcbiAgICBuaXNjID0gUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XG4gICAgaWYgKG5pc2MpIHtcbiAgICAgIGlzYyA9IHVwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIGkgLyAyLCBpc2MpO1xuICAgIH1cbiAgfVxuICBiMS54ID0gYjIueDtcbiAgYjEueSA9IGIyLnk7XG4gIGIyLnggPSBwWzBdO1xuICBiMi55ID0gcFsxXTtcbiAgbmlzYyA9IFJheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xuICBpZiAobmlzYykge1xuICAgIGlzYyA9IHVwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIChwLmxlbmd0aCAvIDIpIC0gMSwgaXNjKTtcbiAgfVxuXG4gIHJldHVybiAoaXNjLmRpc3QgIT09IEluZmluaXR5KSA/IGlzYyA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzLlJheWNhc3QgPSBSYXljYXN0O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBwb2ludCBvbiBwb2x5Z29uIGVkZ2VzLCB3aGljaCBpcyBjbG9zZXN0IHRvIFt4LHldLiBSZXR1cm5zIGFuIG9iamVjdCBpbiB0aGlzIGZvcm1hdFxuICpcbiAqIFwiZGlzdFwiIGlzIHRoZSBkaXN0YW5jZSBvZiB0aGUgcG9seWdvbiBwb2ludCwgXCJlZGdlXCIgaXMgdGhlIG51bWJlciBvZiB0aGUgY2xvc2VzdCBlZGdlLCBcInBvaW50XCIgaXMgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhhdCBlZGdlLCBcIm5vcm1cIiBpcyB0aGUgbm9ybWFsIGZyb20gXCJwb2ludFwiIHRvIFt4LHldLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHBhcmFtIHtudW1iZXJ9IHggQ29vcmRpbmF0ZSBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IENvb3JkaW5hdGUgW3ldXG4gKiBAcmV0dXJucyB7Q2xvc2VzdEVkZ2V9XG4gKiBAZXhhbXBsZVxuICogLy89e2Rpc3Q6MCwgZWRnZTowLCBwb2ludDp7eDowLCB5OjB9LCBub3JtOnt4OjAsIHk6MH19XG4gKi9cbmZ1bmN0aW9uIENsb3Nlc3RFZGdlIChwb2x5Z29uLCB4LCB5LCBpc2MpIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgdmFyIGVtcHR5ID0gZW1wdHlQb2ludHMoKTtcbiAgdmFyIGExID0gZW1wdHlbMF07XG4gIHZhciBiMSA9IGVtcHR5WzJdO1xuICB2YXIgYjIgPSBlbXB0eVszXTtcbiAgLy8gdmFyIGMgPSB0cFs0XSAvLyBpcyBhc3NpZ25lZCBhIHZhbHVlIGJ1dCBuZXZlciB1c2VkLlxuICBhMS54ID0geDtcbiAgYTEueSA9IHk7XG5cbiAgaWYgKGlzYyA9PSBudWxsKSB7XG4gICAgaXNjID0ge2Rpc3Q6IDAsIGVkZ2U6IDAsIHBvaW50OiB7eDogMCwgeTogMH0sIG5vcm06IHt4OiAwLCB5OiAwfX07XG4gIH1cbiAgaXNjLmRpc3QgPSBJbmZpbml0eTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIGIxLnggPSBwW2ldO1xuICAgIGIxLnkgPSBwW2kgKyAxXTtcbiAgICBiMi54ID0gcFtpICsgMl07XG4gICAgYjIueSA9IHBbaSArIDNdO1xuICAgIGlzYyA9IHBvaW50TGluZURpc3QoYTEsIGIxLCBiMiwgaSA+PiAxLCBpc2MpO1xuICB9XG4gIGIxLnggPSBiMi54O1xuICBiMS55ID0gYjIueTtcbiAgYjIueCA9IHBbMF07XG4gIGIyLnkgPSBwWzFdO1xuICBpc2MgPSBwb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGwgPj4gMSwgaXNjKTtcblxuICB2YXIgaWRzdCA9IDEgLyBpc2MuZGlzdDtcbiAgaXNjLm5vcm0ueCA9ICh4IC0gaXNjLnBvaW50LngpICogaWRzdDtcbiAgaXNjLm5vcm0ueSA9ICh5IC0gaXNjLnBvaW50LnkpICogaWRzdDtcbiAgcmV0dXJuIGlzY1xufVxubW9kdWxlLmV4cG9ydHMuQ2xvc2VzdEVkZ2UgPSBDbG9zZXN0RWRnZTtcblxuLyoqXG4gKiBSZXZlcnNlXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKi9cbmZ1bmN0aW9uIFJldmVyc2UgKHBvbHlnb24pIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICB2YXIgbnAgPSBbXTtcbiAgZm9yICh2YXIgaiA9IHAubGVuZ3RoIC0gMjsgaiA+PSAwOyBqIC09IDIpIHsgbnAucHVzaChwW2pdLCBwW2ogKyAxXSk7IH1cbiAgcmV0dXJuIG5wXG59XG5tb2R1bGUuZXhwb3J0cy5SZXZlcnNlID0gUmV2ZXJzZTtcblxuLyoqXG4gKiBQb2ludCBMaW5lIERpc3RhbmNlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IHBcbiAqIEBwYXJhbSB7UG9pbnR9IGFcbiAqIEBwYXJhbSB7UG9pbnR9IGJcbiAqIEBwYXJhbSB7Pz99IGVkZ2VcbiAqIEBwYXJhbSB7Pz99IGlzY1xuICogQHJldHVybnMgez8/fSBJU0NcbiAqL1xuZnVuY3Rpb24gcG9pbnRMaW5lRGlzdCAocCwgYSwgYiwgZWRnZSwgaXNjKSB7XG4gIHZhciB4ID0gcC54O1xuICB2YXIgeSA9IHAueTtcbiAgdmFyIHgxID0gYS54O1xuICB2YXIgeTEgPSBhLnk7XG4gIHZhciB4MiA9IGIueDtcbiAgdmFyIHkyID0gYi55O1xuXG4gIHZhciBBID0geCAtIHgxO1xuICB2YXIgQiA9IHkgLSB5MTtcbiAgdmFyIEMgPSB4MiAtIHgxO1xuICB2YXIgRCA9IHkyIC0geTE7XG5cbiAgdmFyIGRvdCA9IEEgKiBDICsgQiAqIEQ7XG4gIHZhciBsZW5TcSA9IEMgKiBDICsgRCAqIEQ7XG4gIHZhciBwYXJhbSA9IGRvdCAvIGxlblNxO1xuXG4gIHZhciB4eDtcbiAgdmFyIHl5O1xuXG4gIGlmIChwYXJhbSA8IDAgfHwgKHgxID09IHgyICYmIHkxID09IHkyKSkge1xuICAgIHh4ID0geDE7XG4gICAgeXkgPSB5MTtcbiAgfSBlbHNlIGlmIChwYXJhbSA+IDEpIHtcbiAgICB4eCA9IHgyO1xuICAgIHl5ID0geTI7XG4gIH0gZWxzZSB7XG4gICAgeHggPSB4MSArIHBhcmFtICogQztcbiAgICB5eSA9IHkxICsgcGFyYW0gKiBEO1xuICB9XG5cbiAgdmFyIGR4ID0geCAtIHh4O1xuICB2YXIgZHkgPSB5IC0geXk7XG4gIHZhciBkc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBpZiAoZHN0IDwgaXNjLmRpc3QpIHtcbiAgICBpc2MuZGlzdCA9IGRzdDtcbiAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgaXNjLnBvaW50LnggPSB4eDtcbiAgICBpc2MucG9pbnQueSA9IHl5O1xuICB9XG4gIHJldHVybiBpc2Ncbn1cblxuLyoqXG4gKiBVcGRhdGUgSVNDXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gKiBAcGFyYW0ge1BvaW50fSBhMVxuICogQHBhcmFtIHtQb2ludH0gYjFcbiAqIEBwYXJhbSB7UG9pbnR9IGIyXG4gKiBAcGFyYW0ge1BvaW50fSBjXG4gKiBAcGFyYW0gez8/fSBlZGdlXG4gKiBAcGFyYW0gez8/fSBpc2NcbiAqIEByZXR1cm5zIHs/P31cbiAqL1xuZnVuY3Rpb24gdXBkYXRlSVNDIChkeCwgZHksIGExLCBiMSwgYjIsIGMsIGVkZ2UsIGlzYykge1xuICB2YXIgbnJsID0gZGlzdGFuY2UoYTEsIGMpO1xuICBpZiAobnJsIDwgaXNjLmRpc3QpIHtcbiAgICB2YXIgaWJsID0gMSAvIGRpc3RhbmNlKGIxLCBiMik7XG4gICAgdmFyIG54ID0gLShiMi55IC0gYjEueSkgKiBpYmw7XG4gICAgdmFyIG55ID0gKGIyLnggLSBiMS54KSAqIGlibDtcbiAgICB2YXIgZGRvdCA9IDIgKiAoZHggKiBueCArIGR5ICogbnkpO1xuICAgIGlzYy5kaXN0ID0gbnJsO1xuICAgIGlzYy5ub3JtLnggPSBueDtcbiAgICBpc2Mubm9ybS55ID0gbnk7XG4gICAgaXNjLnJlZmwueCA9IC1kZG90ICogbnggKyBkeDtcbiAgICBpc2MucmVmbC55ID0gLWRkb3QgKiBueSArIGR5O1xuICAgIGlzYy5lZGdlID0gZWRnZTtcbiAgfVxuICByZXR1cm4gaXNjXG59XG5cbi8qKlxuICogR2V0IFBvaW50c1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleDBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleDFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50cyAocG9pbnRzLCBpbmRleDAsIGluZGV4MSkge1xuICB2YXIgbiA9IHBvaW50cy5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKGluZGV4MSA8IGluZGV4MCkgaW5kZXgxICs9IG47XG4gIGZvciAodmFyIGkgPSBpbmRleDA7IGkgPD0gaW5kZXgxOyBpKyspIHsgcmVzdWx0LnB1c2gocG9pbnRzW2kgJSBuXSk7IH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEZpcnN0IFdpdGggRmxhZ1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50W119IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBmaXJzdFdpdGhGbGFnIChwb2ludHMsIGluZGV4KSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpbmRleCA9IChpbmRleCArIDEpICUgbjtcbiAgICBpZiAocG9pbnRzW2luZGV4XS5mbGFnKSB7XG4gICAgICByZXR1cm4gaW5kZXhcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQb2ludCBpbiBUcmlhbmdsZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBweVxuICogQHBhcmFtIHtudW1iZXJ9IGF4XG4gKiBAcGFyYW0ge251bWJlcn0gYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBieFxuICogQHBhcmFtIHtudW1iZXJ9IGJ5XG4gKiBAcGFyYW0ge251bWJlcn0gY3hcbiAqIEBwYXJhbSB7bnVtYmVyfSBjeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIFBvaW50SW5UcmlhbmdsZSAocHgsIHB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KSB7XG4gIHZhciB2MHggPSBjeCAtIGF4O1xuICB2YXIgdjB5ID0gY3kgLSBheTtcbiAgdmFyIHYxeCA9IGJ4IC0gYXg7XG4gIHZhciB2MXkgPSBieSAtIGF5O1xuICB2YXIgdjJ4ID0gcHggLSBheDtcbiAgdmFyIHYyeSA9IHB5IC0gYXk7XG5cbiAgdmFyIGRvdDAwID0gdjB4ICogdjB4ICsgdjB5ICogdjB5O1xuICB2YXIgZG90MDEgPSB2MHggKiB2MXggKyB2MHkgKiB2MXk7XG4gIHZhciBkb3QwMiA9IHYweCAqIHYyeCArIHYweSAqIHYyeTtcbiAgdmFyIGRvdDExID0gdjF4ICogdjF4ICsgdjF5ICogdjF5O1xuICB2YXIgZG90MTIgPSB2MXggKiB2MnggKyB2MXkgKiB2Mnk7XG5cbiAgdmFyIGludkRlbm9tID0gMSAvIChkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSk7XG4gIHZhciB1ID0gKGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSAqIGludkRlbm9tO1xuICB2YXIgdiA9IChkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgKiBpbnZEZW5vbTtcblxuICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbiB0cmlhbmdsZVxuICByZXR1cm4gKHUgPj0gMCkgJiYgKHYgPj0gMCkgJiYgKHUgKyB2IDwgMSlcbn1cblxuLyoqXG4gKiBSYXlMaW5lIEludGVyc2VjdGlvblxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBhMVxuICogQHBhcmFtIHtQb2ludH0gYTJcbiAqIEBwYXJhbSB7UG9pbnR9IGIxXG4gKiBAcGFyYW0ge1BvaW50fSBiMlxuICogQHBhcmFtIHtQb2ludH0gY1xuICovXG5mdW5jdGlvbiBSYXlMaW5lSW50ZXJzZWN0aW9uIChhMSwgYTIsIGIxLCBiMiwgYykge1xuICB2YXIgZGF4ID0gKGExLnggLSBhMi54KTtcbiAgdmFyIGRieCA9IChiMS54IC0gYjIueCk7XG4gIHZhciBkYXkgPSAoYTEueSAtIGEyLnkpO1xuICB2YXIgZGJ5ID0gKGIxLnkgLSBiMi55KTtcblxuICB2YXIgRGVuID0gZGF4ICogZGJ5IC0gZGF5ICogZGJ4O1xuICBpZiAoRGVuID09IDApIHJldHVybiBudWxsICAvLyBwYXJhbGxlbFxuXG4gIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICB2YXIgSSA9IGM7XG4gIHZhciBpRGVuID0gMSAvIERlbjtcbiAgSS54ID0gKEEgKiBkYnggLSBkYXggKiBCKSAqIGlEZW47XG4gIEkueSA9IChBICogZGJ5IC0gZGF5ICogQikgKiBpRGVuO1xuXG4gIGlmICghSW5SZWN0YW5nbGUoSSwgYjEsIGIyKSkgcmV0dXJuIG51bGxcbiAgaWYgKChkYXkgPiAwICYmIEkueSA+IGExLnkpIHx8IChkYXkgPCAwICYmIEkueSA8IGExLnkpKSByZXR1cm4gbnVsbFxuICBpZiAoKGRheCA+IDAgJiYgSS54ID4gYTEueCkgfHwgKGRheCA8IDAgJiYgSS54IDwgYTEueCkpIHJldHVybiBudWxsXG4gIHJldHVybiBJXG59XG5cbi8qKlxuICogR2V0IExpbmUgSW50ZXJzZWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IGExXG4gKiBAcGFyYW0ge1BvaW50fSBhMlxuICogQHBhcmFtIHtQb2ludH0gYjFcbiAqIEBwYXJhbSB7UG9pbnR9IGIyXG4gKiBAcGFyYW0ge1BvaW50fSBjXG4gKiBAcmV0dXJucyB7UG9pbnR9XG4gKi9cbmZ1bmN0aW9uIEdldExpbmVJbnRlcnNlY3Rpb24gKGExLCBhMiwgYjEsIGIyLCBjKSB7XG4gIHZhciBkYXggPSAoYTEueCAtIGEyLngpO1xuICB2YXIgZGJ4ID0gKGIxLnggLSBiMi54KTtcbiAgdmFyIGRheSA9IChhMS55IC0gYTIueSk7XG4gIHZhciBkYnkgPSAoYjEueSAtIGIyLnkpO1xuXG4gIHZhciBEZW4gPSBkYXggKiBkYnkgLSBkYXkgKiBkYng7XG5cbiAgaWYgKERlbiA9PT0gMCkgeyByZXR1cm4gbnVsbCB9IC8vIHBhcmFsbGVsXG5cbiAgdmFyIEEgPSAoYTEueCAqIGEyLnkgLSBhMS55ICogYTIueCk7XG4gIHZhciBCID0gKGIxLnggKiBiMi55IC0gYjEueSAqIGIyLngpO1xuXG4gIHZhciBJID0gYztcbiAgSS54ID0gKEEgKiBkYnggLSBkYXggKiBCKSAvIERlbjtcbiAgSS55ID0gKEEgKiBkYnkgLSBkYXkgKiBCKSAvIERlbjtcblxuICBpZiAoSW5SZWN0YW5nbGUoSSwgYTEsIGEyKSAmJiBJblJlY3RhbmdsZShJLCBiMSwgYjIpKSB7XG4gICAgcmV0dXJuIElcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIEluIFJlY3RhbmdsZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBhXG4gKiBAcGFyYW0ge1BvaW50fSBiXG4gKiBAcGFyYW0ge1BvaW50fSBjXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBJblJlY3RhbmdsZSAoYSwgYiwgYykge1xuICB2YXIgbWlueCA9IE1hdGgubWluKGIueCwgYy54KTtcbiAgdmFyIG1heHggPSBNYXRoLm1heChiLngsIGMueCk7XG4gIHZhciBtaW55ID0gTWF0aC5taW4oYi55LCBjLnkpO1xuICB2YXIgbWF4eSA9IE1hdGgubWF4KGIueSwgYy55KTtcblxuICBpZiAobWlueCA9PT0gbWF4eCkgeyByZXR1cm4gKG1pbnkgPD0gYS55ICYmIGEueSA8PSBtYXh5KSB9XG4gIGlmIChtaW55ID09PSBtYXh5KSB7IHJldHVybiAobWlueCA8PSBhLnggJiYgYS54IDw9IG1heHgpIH1cblxuICAvLyByZXR1cm4gKG1pbnggPD0gYS54ICYmIGEueCA8PSBtYXh4ICYmIG1pbnkgPD0gYS55ICYmIGEueSA8PSBtYXh5KVxuICByZXR1cm4gKG1pbnggPD0gYS54ICsgMWUtMTAgJiYgYS54IC0gMWUtMTAgPD0gbWF4eCAmJiBtaW55IDw9IGEueSArIDFlLTEwICYmIGEueSAtIDFlLTEwIDw9IG1heHkpXG59XG5cbi8qKlxuICogQ29udmV4XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IGF4XG4gKiBAcGFyYW0ge1BvaW50fSBheVxuICogQHBhcmFtIHtQb2ludH0gYnhcbiAqIEBwYXJhbSB7UG9pbnR9IGJ5XG4gKiBAcGFyYW0ge1BvaW50fSBjeFxuICogQHBhcmFtIHtQb2ludH0gY3lcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb252ZXggKGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpIHtcbiAgcmV0dXJuIChheSAtIGJ5KSAqIChjeCAtIGJ4KSArIChieCAtIGF4KSAqIChjeSAtIGJ5KSA+PSAwXG59XG5cbi8qKlxuICogUG9pbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJucyB7UG9pbnR9XG4gKi9cbmZ1bmN0aW9uIFBvaW50ICh4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIGZsYWc6IGZhbHNlLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnUG9pbnQgWycgKyB4ICsgJywgJyArIHkgKyAnXScgfVxuICB9XG59XG5cbi8qKlxuICogRGlzdGFuY2VcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gYVxuICogQHBhcmFtIHtQb2ludH0gYlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UgKGEsIGIpIHtcbiAgdmFyIGR4ID0gYi54IC0gYS54O1xuICB2YXIgZHkgPSBiLnkgLSBhLnk7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbXB0eSBQb2ludHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtudW09MTBdIE51bWJlciBvZiBwb2ludHNcbiAqIEByZXR1cm5zIHtQb2ludFtdfVxuICovXG5mdW5jdGlvbiBlbXB0eVBvaW50cyAobnVtKSB7XG4gIG51bSA9IG51bSB8fCAxMDtcbiAgdmFyIGNvbnRhaW5lciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7IGNvbnRhaW5lci5wdXNoKFBvaW50KDAsIDApKTsgfVxuICByZXR1cm4gY29udGFpbmVyXG59XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5ay5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxuXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovdmFyIHQ9ZnVuY3Rpb24oZSxuKXtyZXR1cm4odD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKX0pKGUsbil9O2Z1bmN0aW9uIGUoZSxuKXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfXQoZSxuKSxlLnByb3RvdHlwZT1udWxsPT09bj9PYmplY3QuY3JlYXRlKG4pOihyLnByb3RvdHlwZT1uLnByb3RvdHlwZSxuZXcgcil9ZnVuY3Rpb24gbigpe2Zvcih2YXIgdD0wLGU9MCxuPWFyZ3VtZW50cy5sZW5ndGg7ZTxuO2UrKyl0Kz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciByPUFycmF5KHQpLGE9MDtmb3IoZT0wO2U8bjtlKyspZm9yKHZhciBvPWFyZ3VtZW50c1tlXSxzPTAsaD1vLmxlbmd0aDtzPGg7cysrLGErKylyW2FdPW9bc107cmV0dXJuIHJ9ZnVuY3Rpb24gcih0LGUsbil7aWYodCYmdC5sZW5ndGgpe3ZhciByPWVbMF0sYT1lWzFdLG89TWF0aC5QSS8xODAqbixzPU1hdGguY29zKG8pLGg9TWF0aC5zaW4obyk7dC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10WzBdLG49dFsxXTt0WzBdPShlLXIpKnMtKG4tYSkqaCtyLHRbMV09KGUtcikqaCsobi1hKSpzK2F9KSl9fWZ1bmN0aW9uIGEodCl7dmFyIGU9dFswXSxuPXRbMV07cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlWzBdLW5bMF0sMikrTWF0aC5wb3coZVsxXS1uWzFdLDIpKX1mdW5jdGlvbiBvKHQsZSl7dmFyIGE9WzAsMF0sbz1NYXRoLnJvdW5kKGUuaGFjaHVyZUFuZ2xlKzkwKTtvJiZyKHQsYSxvKTt2YXIgcz1mdW5jdGlvbih0LGUpe3ZhciByPW4odCk7clswXS5qb2luKFwiLFwiKSE9PXJbci5sZW5ndGgtMV0uam9pbihcIixcIikmJnIucHVzaChbclswXVswXSxyWzBdWzFdXSk7dmFyIGE9W107aWYociYmci5sZW5ndGg+Mil7dmFyIG89ZS5oYWNodXJlR2FwO288MCYmKG89NCplLnN0cm9rZVdpZHRoKSxvPU1hdGgubWF4KG8sLjEpO2Zvcih2YXIgcz1bXSxoPTA7aDxyLmxlbmd0aC0xO2grKyl7dmFyIGk9cltoXSx1PXJbaCsxXTtpZihpWzFdIT09dVsxXSl7dmFyIHA9TWF0aC5taW4oaVsxXSx1WzFdKTtzLnB1c2goe3ltaW46cCx5bWF4Ok1hdGgubWF4KGlbMV0sdVsxXSkseDpwPT09aVsxXT9pWzBdOnVbMF0saXNsb3BlOih1WzBdLWlbMF0pLyh1WzFdLWlbMV0pfSl9fWlmKHMuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC55bWluPGUueW1pbj8tMTp0LnltaW4+ZS55bWluPzE6dC54PGUueD8tMTp0Lng+ZS54PzE6dC55bWF4PT09ZS55bWF4PzA6KHQueW1heC1lLnltYXgpL01hdGguYWJzKHQueW1heC1lLnltYXgpfSkpLCFzLmxlbmd0aClyZXR1cm4gYTtmb3IodmFyIGM9W10sbD1zWzBdLnltaW47Yy5sZW5ndGh8fHMubGVuZ3RoOyl7aWYocy5sZW5ndGgpe3ZhciBmPS0xO2ZvcihoPTA7aDxzLmxlbmd0aCYmIShzW2hdLnltaW4+bCk7aCsrKWY9aDtzLnNwbGljZSgwLGYrMSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7Yy5wdXNoKHtzOmwsZWRnZTp0fSl9KSl9aWYoKGM9Yy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiEodC5lZGdlLnltYXg8PWwpfSkpKS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiB0LmVkZ2UueD09PWUuZWRnZS54PzA6KHQuZWRnZS54LWUuZWRnZS54KS9NYXRoLmFicyh0LmVkZ2UueC1lLmVkZ2UueCl9KSksYy5sZW5ndGg+MSlmb3IoaD0wO2g8Yy5sZW5ndGg7aCs9Mil7dmFyIGQ9aCsxO2lmKGQ+PWMubGVuZ3RoKWJyZWFrO3ZhciBnPWNbaF0uZWRnZSx5PWNbZF0uZWRnZTthLnB1c2goW1tNYXRoLnJvdW5kKGcueCksbF0sW01hdGgucm91bmQoeS54KSxsXV0pfWwrPW8sYy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmVkZ2UueD10LmVkZ2UueCtvKnQuZWRnZS5pc2xvcGV9KSl9fXJldHVybiBhfSh0LGUpO3JldHVybiBvJiYocih0LGEsLW8pLGZ1bmN0aW9uKHQsZSxuKXt2YXIgYT1bXTt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBhLnB1c2guYXBwbHkoYSx0KX0pKSxyKGEsZSxuKX0ocyxhLC1vKSksc312YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5oZWxwZXI9dH1yZXR1cm4gdC5wcm90b3R5cGUuZmlsbFBvbHlnb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZmlsbFBvbHlnb24odCxlKX0sdC5wcm90b3R5cGUuX2ZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9byh0LGUpO3JldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczp0aGlzLnJlbmRlckxpbmVzKHIsZSxuKX19LHQucHJvdG90eXBlLnJlbmRlckxpbmVzPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9W10sYT1udWxsLG89MCxzPXQ7bzxzLmxlbmd0aDtvKyspe3ZhciBoPXNbb107ci5wdXNoLmFwcGx5KHIsdGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhoWzBdWzBdLGhbMF1bMV0saFsxXVswXSxoWzFdWzFdLGUpKSxuJiZhJiZyLnB1c2guYXBwbHkocix0aGlzLmhlbHBlci5kb3VibGVMaW5lT3BzKGFbMF0sYVsxXSxoWzBdWzBdLGhbMF1bMV0sZSkpLGE9aFsxXX1yZXR1cm4gcn0sdH0oKSxoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuZmlsbFBvbHlnb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZmlsbFBvbHlnb24odCxlLCEwKX0sbn0ocyksaT1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fZmlsbFBvbHlnb24odCxlKSxyPU9iamVjdC5hc3NpZ24oe30sZSx7aGFjaHVyZUFuZ2xlOmUuaGFjaHVyZUFuZ2xlKzkwfSksYT10aGlzLl9maWxsUG9seWdvbih0LHIpO3JldHVybiBuLm9wcz1uLm9wcy5jb25jYXQoYS5vcHMpLG59LG59KHMpLHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaGVscGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49byh0LGU9T2JqZWN0LmFzc2lnbih7fSxlLHtjdXJ2ZVN0ZXBDb3VudDo0LGhhY2h1cmVBbmdsZTowLHJvdWdobmVzczoxfSkpO3JldHVybiB0aGlzLmRvdHNPbkxpbmVzKG4sZSl9LHQucHJvdG90eXBlLmRvdHNPbkxpbmVzPWZ1bmN0aW9uKHQsZSl7dmFyIG49W10scj1lLmhhY2h1cmVHYXA7cjwwJiYocj00KmUuc3Ryb2tlV2lkdGgpLHI9TWF0aC5tYXgociwuMSk7dmFyIG89ZS5maWxsV2VpZ2h0O288MCYmKG89ZS5zdHJva2VXaWR0aC8yKTtmb3IodmFyIHM9ci80LGg9MCxpPXQ7aDxpLmxlbmd0aDtoKyspZm9yKHZhciB1PWlbaF0scD1hKHUpLGM9cC9yLGw9TWF0aC5jZWlsKGMpLTEsZj1wLWwqcixkPSh1WzBdWzBdK3VbMV1bMF0pLzItci80LGc9TWF0aC5taW4odVswXVsxXSx1WzFdWzFdKSx5PTA7eTxsO3krKyl7dmFyIHY9ZytmK3kqcixNPXRoaXMuaGVscGVyLnJhbmRPZmZzZXRXaXRoUmFuZ2UoZC1zLGQrcyxlKSxrPXRoaXMuaGVscGVyLnJhbmRPZmZzZXRXaXRoUmFuZ2Uodi1zLHYrcyxlKSxiPXRoaXMuaGVscGVyLmVsbGlwc2UoTSxrLG8sbyxlKTtuLnB1c2guYXBwbHkobixiLm9wcyl9cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOm59fSx0fSgpLHA9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaGVscGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49byh0LGUpO3JldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczp0aGlzLmRhc2hlZExpbmUobixlKX19LHQucHJvdG90eXBlLmRhc2hlZExpbmU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9ZS5kYXNoT2Zmc2V0PDA/ZS5oYWNodXJlR2FwPDA/NCplLnN0cm9rZVdpZHRoOmUuaGFjaHVyZUdhcDplLmRhc2hPZmZzZXQsbz1lLmRhc2hHYXA8MD9lLmhhY2h1cmVHYXA8MD80KmUuc3Ryb2tlV2lkdGg6ZS5oYWNodXJlR2FwOmUuZGFzaEdhcCxzPVtdO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBoPWEodCksaT1NYXRoLmZsb29yKGgvKHIrbykpLHU9KGgrby1pKihyK28pKS8yLHA9dFswXSxjPXRbMV07cFswXT5jWzBdJiYocD10WzFdLGM9dFswXSk7Zm9yKHZhciBsPU1hdGguYXRhbigoY1sxXS1wWzFdKS8oY1swXS1wWzBdKSksZj0wO2Y8aTtmKyspe3ZhciBkPWYqKHIrbyksZz1kK3IseT1bcFswXStkKk1hdGguY29zKGwpK3UqTWF0aC5jb3MobCkscFsxXStkKk1hdGguc2luKGwpK3UqTWF0aC5zaW4obCldLHY9W3BbMF0rZypNYXRoLmNvcyhsKSt1Kk1hdGguY29zKGwpLHBbMV0rZypNYXRoLnNpbihsKSt1Kk1hdGguc2luKGwpXTtzLnB1c2guYXBwbHkocyxuLmhlbHBlci5kb3VibGVMaW5lT3BzKHlbMF0seVsxXSx2WzBdLHZbMV0sZSkpfX0pKSxzfSx0fSgpLGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaGVscGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5oYWNodXJlR2FwPDA/NCplLnN0cm9rZVdpZHRoOmUuaGFjaHVyZUdhcCxyPWUuemlnemFnT2Zmc2V0PDA/bjplLnppZ3phZ09mZnNldCxhPW8odCxlPU9iamVjdC5hc3NpZ24oe30sZSx7aGFjaHVyZUdhcDpuK3J9KSk7cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOnRoaXMuemlnemFnTGluZXMoYSxyLGUpfX0sdC5wcm90b3R5cGUuemlnemFnTGluZXM9ZnVuY3Rpb24odCxlLHIpe3ZhciBvPXRoaXMscz1bXTtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgaD1hKHQpLGk9TWF0aC5yb3VuZChoLygyKmUpKSx1PXRbMF0scD10WzFdO3VbMF0+cFswXSYmKHU9dFsxXSxwPXRbMF0pO2Zvcih2YXIgYz1NYXRoLmF0YW4oKHBbMV0tdVsxXSkvKHBbMF0tdVswXSkpLGw9MDtsPGk7bCsrKXt2YXIgZj0yKmwqZSxkPTIqKGwrMSkqZSxnPU1hdGguc3FydCgyKk1hdGgucG93KGUsMikpLHk9W3VbMF0rZipNYXRoLmNvcyhjKSx1WzFdK2YqTWF0aC5zaW4oYyldLHY9W3VbMF0rZCpNYXRoLmNvcyhjKSx1WzFdK2QqTWF0aC5zaW4oYyldLE09W3lbMF0rZypNYXRoLmNvcyhjK01hdGguUEkvNCkseVsxXStnKk1hdGguc2luKGMrTWF0aC5QSS80KV07cy5wdXNoLmFwcGx5KHMsbihvLmhlbHBlci5kb3VibGVMaW5lT3BzKHlbMF0seVsxXSxNWzBdLE1bMV0sciksby5oZWxwZXIuZG91YmxlTGluZU9wcyhNWzBdLE1bMV0sdlswXSx2WzFdLHIpKSl9fSkpLHN9LHR9KCksbD17fTt2YXIgZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5zZWVkPXR9cmV0dXJuIHQucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWVkPyhNYXRoLnBvdygyLDMxKS0xJih0aGlzLnNlZWQ9TWF0aC5pbXVsKDQ4MjcxLHRoaXMuc2VlZCkpKS9NYXRoLnBvdygyLDMxKTpNYXRoLnJhbmRvbSgpfSx0fSgpO2NvbnN0IGQ9e0E6NyxhOjcsQzo2LGM6NixIOjEsaDoxLEw6MixsOjIsTToyLG06MixROjQscTo0LFM6NCxzOjQsVDoyLHQ6MixWOjEsdjoxLFo6MCx6OjB9O2Z1bmN0aW9uIGcodCxlKXtyZXR1cm4gdC50eXBlPT09ZX1mdW5jdGlvbiB5KHQpe2NvbnN0IGU9W10sbj1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBBcnJheTtmb3IoO1wiXCIhPT10OylpZih0Lm1hdGNoKC9eKFsgXFx0XFxyXFxuLF0rKS8pKXQ9dC5zdWJzdHIoUmVnRXhwLiQxLmxlbmd0aCk7ZWxzZSBpZih0Lm1hdGNoKC9eKFthQWNDaEhsTG1NcVFzU3RUdlZ6Wl0pLykpZVtlLmxlbmd0aF09e3R5cGU6MCx0ZXh0OlJlZ0V4cC4kMX0sdD10LnN1YnN0cihSZWdFeHAuJDEubGVuZ3RoKTtlbHNle2lmKCF0Lm1hdGNoKC9eKChbLStdP1swLTldKyhcXC5bMC05XSopP3xbLStdP1xcLlswLTldKykoW2VFXVstK10/WzAtOV0rKT8pLykpcmV0dXJuW107ZVtlLmxlbmd0aF09e3R5cGU6MSx0ZXh0OlwiXCIrcGFyc2VGbG9hdChSZWdFeHAuJDEpfSx0PXQuc3Vic3RyKFJlZ0V4cC4kMS5sZW5ndGgpfXJldHVybiBlW2UubGVuZ3RoXT17dHlwZToyLHRleHQ6XCJcIn0sZX0odCk7bGV0IHI9XCJCT0RcIixhPTAsbz1uW2FdO2Zvcig7IWcobywyKTspe2xldCBzPTA7Y29uc3QgaD1bXTtpZihcIkJPRFwiPT09cil7aWYoXCJNXCIhPT1vLnRleHQmJlwibVwiIT09by50ZXh0KXJldHVybiB5KFwiTTAsMFwiK3QpO2ErKyxzPWRbby50ZXh0XSxyPW8udGV4dH1lbHNlIGcobywxKT9zPWRbcl06KGErKyxzPWRbby50ZXh0XSxyPW8udGV4dCk7aWYoIShhK3M8bi5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIlBhdGggZGF0YSBlbmRlZCBzaG9ydFwiKTtmb3IobGV0IHQ9YTt0PGErczt0Kyspe2NvbnN0IGU9blt0XTtpZighZyhlLDEpKXRocm93IG5ldyBFcnJvcihcIlBhcmFtIG5vdCBhIG51bWJlcjogXCIrcitcIixcIitlLnRleHQpO2hbaC5sZW5ndGhdPStlLnRleHR9aWYoXCJudW1iZXJcIiE9dHlwZW9mIGRbcl0pdGhyb3cgbmV3IEVycm9yKFwiQmFkIHNlZ21lbnQ6IFwiK3IpO3tjb25zdCB0PXtrZXk6cixkYXRhOmh9O2UucHVzaCh0KSxhKz1zLG89blthXSxcIk1cIj09PXImJihyPVwiTFwiKSxcIm1cIj09PXImJihyPVwibFwiKX19cmV0dXJuIGV9ZnVuY3Rpb24gdih0KXtsZXQgZT0wLG49MCxyPTAsYT0wO2NvbnN0IG89W107Zm9yKGNvbnN0e2tleTpzLGRhdGE6aH1vZiB0KXN3aXRjaChzKXtjYXNlXCJNXCI6by5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbLi4uaF19KSxbZSxuXT1oLFtyLGFdPWg7YnJlYWs7Y2FzZVwibVwiOmUrPWhbMF0sbis9aFsxXSxvLnB1c2goe2tleTpcIk1cIixkYXRhOltlLG5dfSkscj1lLGE9bjticmVhaztjYXNlXCJMXCI6by5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbLi4uaF19KSxbZSxuXT1oO2JyZWFrO2Nhc2VcImxcIjplKz1oWzBdLG4rPWhbMV0sby5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbZSxuXX0pO2JyZWFrO2Nhc2VcIkNcIjpvLnB1c2goe2tleTpcIkNcIixkYXRhOlsuLi5oXX0pLGU9aFs0XSxuPWhbNV07YnJlYWs7Y2FzZVwiY1wiOntjb25zdCB0PWgubWFwKCh0LHIpPT5yJTI/dCtuOnQrZSk7by5wdXNoKHtrZXk6XCJDXCIsZGF0YTp0fSksZT10WzRdLG49dFs1XTticmVha31jYXNlXCJRXCI6by5wdXNoKHtrZXk6XCJRXCIsZGF0YTpbLi4uaF19KSxlPWhbMl0sbj1oWzNdO2JyZWFrO2Nhc2VcInFcIjp7Y29uc3QgdD1oLm1hcCgodCxyKT0+ciUyP3Qrbjp0K2UpO28ucHVzaCh7a2V5OlwiUVwiLGRhdGE6dH0pLGU9dFsyXSxuPXRbM107YnJlYWt9Y2FzZVwiQVwiOm8ucHVzaCh7a2V5OlwiQVwiLGRhdGE6Wy4uLmhdfSksZT1oWzVdLG49aFs2XTticmVhaztjYXNlXCJhXCI6ZSs9aFs1XSxuKz1oWzZdLG8ucHVzaCh7a2V5OlwiQVwiLGRhdGE6W2hbMF0saFsxXSxoWzJdLGhbM10saFs0XSxlLG5dfSk7YnJlYWs7Y2FzZVwiSFwiOm8ucHVzaCh7a2V5OlwiSFwiLGRhdGE6Wy4uLmhdfSksZT1oWzBdO2JyZWFrO2Nhc2VcImhcIjplKz1oWzBdLG8ucHVzaCh7a2V5OlwiSFwiLGRhdGE6W2VdfSk7YnJlYWs7Y2FzZVwiVlwiOm8ucHVzaCh7a2V5OlwiVlwiLGRhdGE6Wy4uLmhdfSksbj1oWzBdO2JyZWFrO2Nhc2VcInZcIjpuKz1oWzBdLG8ucHVzaCh7a2V5OlwiVlwiLGRhdGE6W25dfSk7YnJlYWs7Y2FzZVwiU1wiOm8ucHVzaCh7a2V5OlwiU1wiLGRhdGE6Wy4uLmhdfSksZT1oWzJdLG49aFszXTticmVhaztjYXNlXCJzXCI6e2NvbnN0IHQ9aC5tYXAoKHQscik9PnIlMj90K246dCtlKTtvLnB1c2goe2tleTpcIlNcIixkYXRhOnR9KSxlPXRbMl0sbj10WzNdO2JyZWFrfWNhc2VcIlRcIjpvLnB1c2goe2tleTpcIlRcIixkYXRhOlsuLi5oXX0pLGU9aFswXSxuPWhbMV07YnJlYWs7Y2FzZVwidFwiOmUrPWhbMF0sbis9aFsxXSxvLnB1c2goe2tleTpcIlRcIixkYXRhOltlLG5dfSk7YnJlYWs7Y2FzZVwiWlwiOmNhc2VcInpcIjpvLnB1c2goe2tleTpcIlpcIixkYXRhOltdfSksZT1yLG49YX1yZXR1cm4gb31mdW5jdGlvbiBNKHQpe2NvbnN0IGU9W107bGV0IG49XCJcIixyPTAsYT0wLG89MCxzPTAsaD0wLGk9MDtmb3IoY29uc3R7a2V5OnUsZGF0YTpwfW9mIHQpe3N3aXRjaCh1KXtjYXNlXCJNXCI6ZS5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbLi4ucF19KSxbcixhXT1wLFtvLHNdPXA7YnJlYWs7Y2FzZVwiQ1wiOmUucHVzaCh7a2V5OlwiQ1wiLGRhdGE6Wy4uLnBdfSkscj1wWzRdLGE9cFs1XSxoPXBbMl0saT1wWzNdO2JyZWFrO2Nhc2VcIkxcIjplLnB1c2goe2tleTpcIkxcIixkYXRhOlsuLi5wXX0pLFtyLGFdPXA7YnJlYWs7Y2FzZVwiSFwiOnI9cFswXSxlLnB1c2goe2tleTpcIkxcIixkYXRhOltyLGFdfSk7YnJlYWs7Y2FzZVwiVlwiOmE9cFswXSxlLnB1c2goe2tleTpcIkxcIixkYXRhOltyLGFdfSk7YnJlYWs7Y2FzZVwiU1wiOntsZXQgdD0wLG89MDtcIkNcIj09PW58fFwiU1wiPT09bj8odD1yKyhyLWgpLG89YSsoYS1pKSk6KHQ9cixvPWEpLGUucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W3QsbywuLi5wXX0pLGg9cFswXSxpPXBbMV0scj1wWzJdLGE9cFszXTticmVha31jYXNlXCJUXCI6e2NvbnN0W3Qsb109cDtsZXQgcz0wLHU9MDtcIlFcIj09PW58fFwiVFwiPT09bj8ocz1yKyhyLWgpLHU9YSsoYS1pKSk6KHM9cix1PWEpO2NvbnN0IGM9cisyKihzLXIpLzMsbD1hKzIqKHUtYSkvMyxmPXQrMioocy10KS8zLGQ9bysyKih1LW8pLzM7ZS5wdXNoKHtrZXk6XCJDXCIsZGF0YTpbYyxsLGYsZCx0LG9dfSksaD1zLGk9dSxyPXQsYT1vO2JyZWFrfWNhc2VcIlFcIjp7Y29uc3RbdCxuLG8sc109cCx1PXIrMioodC1yKS8zLGM9YSsyKihuLWEpLzMsbD1vKzIqKHQtbykvMyxmPXMrMioobi1zKS8zO2UucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W3UsYyxsLGYsbyxzXX0pLGg9dCxpPW4scj1vLGE9czticmVha31jYXNlXCJBXCI6e2NvbnN0IHQ9TWF0aC5hYnMocFswXSksbj1NYXRoLmFicyhwWzFdKSxvPXBbMl0scz1wWzNdLGg9cFs0XSxpPXBbNV0sdT1wWzZdO2lmKDA9PT10fHwwPT09billLnB1c2goe2tleTpcIkNcIixkYXRhOltyLGEsaSx1LGksdV19KSxyPWksYT11O2Vsc2UgaWYociE9PWl8fGEhPT11KXtiKHIsYSxpLHUsdCxuLG8scyxoKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlLnB1c2goe2tleTpcIkNcIixkYXRhOnR9KX0pKSxyPWksYT11fWJyZWFrfWNhc2VcIlpcIjplLnB1c2goe2tleTpcIlpcIixkYXRhOltdfSkscj1vLGE9c31uPXV9cmV0dXJuIGV9ZnVuY3Rpb24gayh0LGUsbil7cmV0dXJuW3QqTWF0aC5jb3MobiktZSpNYXRoLnNpbihuKSx0Kk1hdGguc2luKG4pK2UqTWF0aC5jb3MobildfWZ1bmN0aW9uIGIodCxlLG4scixhLG8scyxoLGksdSl7Y29uc3QgcD0oYz1zLE1hdGguUEkqYy8xODApO3ZhciBjO2xldCBsPVtdLGY9MCxkPTAsZz0wLHk9MDtpZih1KVtmLGQsZyx5XT11O2Vsc2V7W3QsZV09ayh0LGUsLXApLFtuLHJdPWsobixyLC1wKTtjb25zdCBzPSh0LW4pLzIsdT0oZS1yKS8yO2xldCBjPXMqcy8oYSphKSt1KnUvKG8qbyk7Yz4xJiYoYz1NYXRoLnNxcnQoYyksYSo9YyxvKj1jKTtjb25zdCBsPWEqYSx2PW8qbyxNPWwqdi1sKnUqdS12KnMqcyxiPWwqdSp1K3YqcypzLG09KGg9PT1pPy0xOjEpKk1hdGguc3FydChNYXRoLmFicyhNL2IpKTtnPW0qYSp1L28rKHQrbikvMix5PW0qLW8qcy9hKyhlK3IpLzIsZj1NYXRoLmFzaW4ocGFyc2VGbG9hdCgoKGUteSkvbykudG9GaXhlZCg5KSkpLGQ9TWF0aC5hc2luKHBhcnNlRmxvYXQoKChyLXkpL28pLnRvRml4ZWQoOSkpKSx0PGcmJihmPU1hdGguUEktZiksbjxnJiYoZD1NYXRoLlBJLWQpLGY8MCYmKGY9MipNYXRoLlBJK2YpLGQ8MCYmKGQ9MipNYXRoLlBJK2QpLGkmJmY+ZCYmKGYtPTIqTWF0aC5QSSksIWkmJmQ+ZiYmKGQtPTIqTWF0aC5QSSl9bGV0IHY9ZC1mO2lmKE1hdGguYWJzKHYpPjEyMCpNYXRoLlBJLzE4MCl7Y29uc3QgdD1kLGU9bixoPXI7ZD1pJiZkPmY/ZisxMjAqTWF0aC5QSS8xODAqMTpmKzEyMCpNYXRoLlBJLzE4MCotMSxsPWIobj1nK2EqTWF0aC5jb3MoZCkscj15K28qTWF0aC5zaW4oZCksZSxoLGEsbyxzLDAsaSxbZCx0LGcseV0pfXY9ZC1mO2NvbnN0IE09TWF0aC5jb3MoZiksbT1NYXRoLnNpbihmKSx3PU1hdGguY29zKGQpLFA9TWF0aC5zaW4oZCkseD1NYXRoLnRhbih2LzQpLE89NC8zKmEqeCxTPTQvMypvKngsVD1bdCxlXSxfPVt0K08qbSxlLVMqTV0sQz1bbitPKlAsci1TKnddLFc9W24scl07aWYoX1swXT0yKlRbMF0tX1swXSxfWzFdPTIqVFsxXS1fWzFdLHUpcmV0dXJuW18sQyxXXS5jb25jYXQobCk7e2w9W18sQyxXXS5jb25jYXQobCk7Y29uc3QgdD1bXTtmb3IobGV0IGU9MDtlPGwubGVuZ3RoO2UrPTMpe2NvbnN0IG49ayhsW2VdWzBdLGxbZV1bMV0scCkscj1rKGxbZSsxXVswXSxsW2UrMV1bMV0scCksYT1rKGxbZSsyXVswXSxsW2UrMl1bMV0scCk7dC5wdXNoKFtuWzBdLG5bMV0sclswXSxyWzFdLGFbMF0sYVsxXV0pfXJldHVybiB0fX12YXIgbT17cmFuZE9mZnNldDpmdW5jdGlvbih0LGUpe3JldHVybiBFKHQsZSl9LHJhbmRPZmZzZXRXaXRoUmFuZ2U6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBMKHQsZSxuKX0sZWxsaXBzZTpmdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPU8obixyLGEpO3JldHVybiBTKHQsZSxhLG8pLm9wc2V0fSxkb3VibGVMaW5lT3BzOmZ1bmN0aW9uKHQsZSxuLHIsYSl7cmV0dXJuIHoodCxlLG4scixhKX19O2Z1bmN0aW9uIHcodCxlLG4scixhKXtyZXR1cm57dHlwZTpcInBhdGhcIixvcHM6eih0LGUsbixyLGEpfX1mdW5jdGlvbiBQKHQsZSxuKXt2YXIgcj0odHx8W10pLmxlbmd0aDtpZihyPjIpe2Zvcih2YXIgYT1bXSxvPTA7bzxyLTE7bysrKWEucHVzaC5hcHBseShhLHoodFtvXVswXSx0W29dWzFdLHRbbysxXVswXSx0W28rMV1bMV0sbikpO3JldHVybiBlJiZhLnB1c2guYXBwbHkoYSx6KHRbci0xXVswXSx0W3ItMV1bMV0sdFswXVswXSx0WzBdWzFdLG4pKSx7dHlwZTpcInBhdGhcIixvcHM6YX19cmV0dXJuIDI9PT1yP3codFswXVswXSx0WzBdWzFdLHRbMV1bMF0sdFsxXVsxXSxuKTp7dHlwZTpcInBhdGhcIixvcHM6W119fWZ1bmN0aW9uIHgodCxlLG4scixhKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtyZXR1cm4gUCh0LCEwLGUpfShbW3QsZV0sW3QrbixlXSxbdCtuLGUrcl0sW3QsZStyXV0sYSl9ZnVuY3Rpb24gTyh0LGUsbil7dmFyIHI9TWF0aC5zcXJ0KDIqTWF0aC5QSSpNYXRoLnNxcnQoKE1hdGgucG93KHQvMiwyKStNYXRoLnBvdyhlLzIsMikpLzIpKSxhPU1hdGgubWF4KG4uY3VydmVTdGVwQ291bnQsbi5jdXJ2ZVN0ZXBDb3VudC9NYXRoLnNxcnQoMjAwKSpyKSxvPTIqTWF0aC5QSS9hLHM9TWF0aC5hYnModC8yKSxoPU1hdGguYWJzKGUvMiksaT0xLW4uY3VydmVGaXR0aW5nO3JldHVybntpbmNyZW1lbnQ6byxyeDpzKz1FKHMqaSxuKSxyeTpoKz1FKGgqaSxuKX19ZnVuY3Rpb24gUyh0LGUsbixyKXt2YXIgYT1HKHIuaW5jcmVtZW50LHQsZSxyLnJ4LHIucnksMSxyLmluY3JlbWVudCpMKC4xLEwoLjQsMSxuKSxuKSxuKSxvPWFbMF0scz1hWzFdLGg9RyhyLmluY3JlbWVudCx0LGUsci5yeCxyLnJ5LDEuNSwwLG4pWzBdLGk9cShvLG51bGwsbiksdT1xKGgsbnVsbCxuKTtyZXR1cm57ZXN0aW1hdGVkUG9pbnRzOnMsb3BzZXQ6e3R5cGU6XCJwYXRoXCIsb3BzOmkuY29uY2F0KHUpfX19ZnVuY3Rpb24gVCh0LGUscixhLG8scyxoLGksdSl7dmFyIHA9dCxjPWUsbD1NYXRoLmFicyhyLzIpLGY9TWF0aC5hYnMoYS8yKTtsKz1FKC4wMSpsLHUpLGYrPUUoLjAxKmYsdSk7Zm9yKHZhciBkPW8sZz1zO2Q8MDspZCs9MipNYXRoLlBJLGcrPTIqTWF0aC5QSTtnLWQ+MipNYXRoLlBJJiYoZD0wLGc9MipNYXRoLlBJKTt2YXIgeT0yKk1hdGguUEkvdS5jdXJ2ZVN0ZXBDb3VudCx2PU1hdGgubWluKHkvMiwoZy1kKS8yKSxNPWoodixwLGMsbCxmLGQsZywxLHUpLGs9aih2LHAsYyxsLGYsZCxnLDEuNSx1KSxiPU0uY29uY2F0KGspO3JldHVybiBoJiYoaT9iLnB1c2guYXBwbHkoYixuKHoocCxjLHArbCpNYXRoLmNvcyhkKSxjK2YqTWF0aC5zaW4oZCksdSkseihwLGMscCtsKk1hdGguY29zKGcpLGMrZipNYXRoLnNpbihnKSx1KSkpOmIucHVzaCh7b3A6XCJsaW5lVG9cIixkYXRhOltwLGNdfSx7b3A6XCJsaW5lVG9cIixkYXRhOltwK2wqTWF0aC5jb3MoZCksYytmKk1hdGguc2luKGQpXX0pKSx7dHlwZTpcInBhdGhcIixvcHM6Yn19ZnVuY3Rpb24gXyh0LGUpe2Zvcih2YXIgbj1NKHYoeSh0KSkpLHI9W10sYT1bMCwwXSxvPVswLDBdLHM9ZnVuY3Rpb24odCxuKXtzd2l0Y2godCl7Y2FzZVwiTVwiOnZhciBzPTEqKGUubWF4UmFuZG9tbmVzc09mZnNldHx8MCk7ci5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOm4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdCtFKHMsZSl9KSl9KSxvPVtuWzBdLG5bMV1dLGE9W25bMF0sblsxXV07YnJlYWs7Y2FzZVwiTFwiOnIucHVzaC5hcHBseShyLHoob1swXSxvWzFdLG5bMF0sblsxXSxlKSksbz1bblswXSxuWzFdXTticmVhaztjYXNlXCJDXCI6dmFyIGg9blswXSxpPW5bMV0sdT1uWzJdLHA9blszXSxjPW5bNF0sbD1uWzVdO3IucHVzaC5hcHBseShyLGZ1bmN0aW9uKHQsZSxuLHIsYSxvLHMsaCl7Zm9yKHZhciBpPVtdLHU9W2gubWF4UmFuZG9tbmVzc09mZnNldHx8MSwoaC5tYXhSYW5kb21uZXNzT2Zmc2V0fHwxKSsuM10scD1bMCwwXSxjPTA7YzwyO2MrKykwPT09Yz9pLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3NbMF0sc1sxXV19KTppLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3NbMF0rRSh1WzBdLGgpLHNbMV0rRSh1WzBdLGgpXX0pLHA9W2ErRSh1W2NdLGgpLG8rRSh1W2NdLGgpXSxpLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOlt0K0UodVtjXSxoKSxlK0UodVtjXSxoKSxuK0UodVtjXSxoKSxyK0UodVtjXSxoKSxwWzBdLHBbMV1dfSk7cmV0dXJuIGl9KGgsaSx1LHAsYyxsLG8sZSkpLG89W2MsbF07YnJlYWs7Y2FzZVwiWlwiOnIucHVzaC5hcHBseShyLHoob1swXSxvWzFdLGFbMF0sYVsxXSxlKSksbz1bYVswXSxhWzFdXX19LGg9MCxpPW47aDxpLmxlbmd0aDtoKyspe3ZhciB1PWlbaF07cyh1LmtleSx1LmRhdGEpfXJldHVybnt0eXBlOlwicGF0aFwiLG9wczpyfX1mdW5jdGlvbiBDKHQsZSl7dmFyIG49W107aWYodC5sZW5ndGgpe3ZhciByPWUubWF4UmFuZG9tbmVzc09mZnNldHx8MCxhPXQubGVuZ3RoO2lmKGE+Mil7bi5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0WzBdWzBdK0UocixlKSx0WzBdWzFdK0UocixlKV19KTtmb3IodmFyIG89MTtvPGE7bysrKW4ucHVzaCh7b3A6XCJsaW5lVG9cIixkYXRhOlt0W29dWzBdK0UocixlKSx0W29dWzFdK0UocixlKV19KX19cmV0dXJue3R5cGU6XCJmaWxsUGF0aFwiLG9wczpufX1mdW5jdGlvbiBXKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5maWxsU3R5bGV8fFwiaGFjaHVyZVwiO2lmKCFsW25dKXN3aXRjaChuKXtjYXNlXCJ6aWd6YWdcIjpsW25dfHwobFtuXT1uZXcgaChlKSk7YnJlYWs7Y2FzZVwiY3Jvc3MtaGF0Y2hcIjpsW25dfHwobFtuXT1uZXcgaShlKSk7YnJlYWs7Y2FzZVwiZG90c1wiOmxbbl18fChsW25dPW5ldyB1KGUpKTticmVhaztjYXNlXCJkYXNoZWRcIjpsW25dfHwobFtuXT1uZXcgcChlKSk7YnJlYWs7Y2FzZVwiemlnemFnLWxpbmVcIjpsW25dfHwobFtuXT1uZXcgYyhlKSk7YnJlYWs7Y2FzZVwiaGFjaHVyZVwiOmRlZmF1bHQ6bFtuPVwiaGFjaHVyZVwiXXx8KGxbbl09bmV3IHMoZSkpfXJldHVybiBsW25dfShlLG0pLmZpbGxQb2x5Z29uKHQsZSl9ZnVuY3Rpb24gSSh0KXtyZXR1cm4gdC5yYW5kb21pemVyfHwodC5yYW5kb21pemVyPW5ldyBmKHQuc2VlZHx8MCkpLHQucmFuZG9taXplci5uZXh0KCl9ZnVuY3Rpb24gTCh0LGUsbixyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MSksbi5yb3VnaG5lc3MqciooSShuKSooZS10KSt0KX1mdW5jdGlvbiBFKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MSksTCgtdCx0LGUsbil9ZnVuY3Rpb24geih0LGUsbixyLGEpe3ZhciBvPUEodCxlLG4scixhLCEwLCExKSxzPUEodCxlLG4scixhLCEwLCEwKTtyZXR1cm4gby5jb25jYXQocyl9ZnVuY3Rpb24gQSh0LGUsbixyLGEsbyxzKXt2YXIgaD1NYXRoLnBvdyh0LW4sMikrTWF0aC5wb3coZS1yLDIpLGk9TWF0aC5zcXJ0KGgpLHU9MTt1PWk8MjAwPzE6aT41MDA/LjQ6LS4wMDE2NjY4KmkrMS4yMzMzMzQ7dmFyIHA9YS5tYXhSYW5kb21uZXNzT2Zmc2V0fHwwO3AqcCoxMDA+aCYmKHA9aS8xMCk7dmFyIGM9cC8yLGw9LjIrLjIqSShhKSxmPWEuYm93aW5nKmEubWF4UmFuZG9tbmVzc09mZnNldCooci1lKS8yMDAsZD1hLmJvd2luZyphLm1heFJhbmRvbW5lc3NPZmZzZXQqKHQtbikvMjAwO2Y9RShmLGEsdSksZD1FKGQsYSx1KTt2YXIgZz1bXSx5PWZ1bmN0aW9uKCl7cmV0dXJuIEUoYyxhLHUpfSx2PWZ1bmN0aW9uKCl7cmV0dXJuIEUocCxhLHUpfTtyZXR1cm4gbyYmKHM/Zy5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0K3koKSxlK3koKV19KTpnLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3QrRShwLGEsdSksZStFKHAsYSx1KV19KSkscz9nLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOltmK3QrKG4tdCkqbCt5KCksZCtlKyhyLWUpKmwreSgpLGYrdCsyKihuLXQpKmwreSgpLGQrZSsyKihyLWUpKmwreSgpLG4reSgpLHIreSgpXX0pOmcucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W2YrdCsobi10KSpsK3YoKSxkK2UrKHItZSkqbCt2KCksZit0KzIqKG4tdCkqbCt2KCksZCtlKzIqKHItZSkqbCt2KCksbit2KCkscit2KCldfSksZ31mdW5jdGlvbiBSKHQsZSxuKXt2YXIgcj1bXTtyLnB1c2goW3RbMF1bMF0rRShlLG4pLHRbMF1bMV0rRShlLG4pXSksci5wdXNoKFt0WzBdWzBdK0UoZSxuKSx0WzBdWzFdK0UoZSxuKV0pO2Zvcih2YXIgYT0xO2E8dC5sZW5ndGg7YSsrKXIucHVzaChbdFthXVswXStFKGUsbiksdFthXVsxXStFKGUsbildKSxhPT09dC5sZW5ndGgtMSYmci5wdXNoKFt0W2FdWzBdK0UoZSxuKSx0W2FdWzFdK0UoZSxuKV0pO3JldHVybiBxKHIsbnVsbCxuKX1mdW5jdGlvbiBxKHQsZSxuKXt2YXIgcj10Lmxlbmd0aCxhPVtdO2lmKHI+Myl7dmFyIG89W10scz0xLW4uY3VydmVUaWdodG5lc3M7YS5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0WzFdWzBdLHRbMV1bMV1dfSk7Zm9yKHZhciBoPTE7aCsyPHI7aCsrKXt2YXIgaT10W2hdO29bMF09W2lbMF0saVsxXV0sb1sxXT1baVswXSsocyp0W2grMV1bMF0tcyp0W2gtMV1bMF0pLzYsaVsxXSsocyp0W2grMV1bMV0tcyp0W2gtMV1bMV0pLzZdLG9bMl09W3RbaCsxXVswXSsocyp0W2hdWzBdLXMqdFtoKzJdWzBdKS82LHRbaCsxXVsxXSsocyp0W2hdWzFdLXMqdFtoKzJdWzFdKS82XSxvWzNdPVt0W2grMV1bMF0sdFtoKzFdWzFdXSxhLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOltvWzFdWzBdLG9bMV1bMV0sb1syXVswXSxvWzJdWzFdLG9bM11bMF0sb1szXVsxXV19KX1pZihlJiYyPT09ZS5sZW5ndGgpe3ZhciB1PW4ubWF4UmFuZG9tbmVzc09mZnNldDthLnB1c2goe29wOlwibGluZVRvXCIsZGF0YTpbZVswXStFKHUsbiksZVsxXStFKHUsbildfSl9fWVsc2UgMz09PXI/KGEucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdFsxXVswXSx0WzFdWzFdXX0pLGEucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W3RbMV1bMF0sdFsxXVsxXSx0WzJdWzBdLHRbMl1bMV0sdFsyXVswXSx0WzJdWzFdXX0pKToyPT09ciYmYS5wdXNoLmFwcGx5KGEseih0WzBdWzBdLHRbMF1bMV0sdFsxXVswXSx0WzFdWzFdLG4pKTtyZXR1cm4gYX1mdW5jdGlvbiBHKHQsZSxuLHIsYSxvLHMsaCl7dmFyIGk9W10sdT1bXSxwPUUoLjUsaCktTWF0aC5QSS8yO3UucHVzaChbRShvLGgpK2UrLjkqcipNYXRoLmNvcyhwLXQpLEUobyxoKStuKy45KmEqTWF0aC5zaW4ocC10KV0pO2Zvcih2YXIgYz1wO2M8MipNYXRoLlBJK3AtLjAxO2MrPXQpe3ZhciBsPVtFKG8saCkrZStyKk1hdGguY29zKGMpLEUobyxoKStuK2EqTWF0aC5zaW4oYyldO2kucHVzaChsKSx1LnB1c2gobCl9cmV0dXJuIHUucHVzaChbRShvLGgpK2UrcipNYXRoLmNvcyhwKzIqTWF0aC5QSSsuNSpzKSxFKG8saCkrbithKk1hdGguc2luKHArMipNYXRoLlBJKy41KnMpXSksdS5wdXNoKFtFKG8saCkrZSsuOTgqcipNYXRoLmNvcyhwK3MpLEUobyxoKStuKy45OCphKk1hdGguc2luKHArcyldKSx1LnB1c2goW0UobyxoKStlKy45KnIqTWF0aC5jb3MocCsuNSpzKSxFKG8saCkrbisuOSphKk1hdGguc2luKHArLjUqcyldKSxbdSxpXX1mdW5jdGlvbiBqKHQsZSxuLHIsYSxvLHMsaCxpKXt2YXIgdT1vK0UoLjEsaSkscD1bXTtwLnB1c2goW0UoaCxpKStlKy45KnIqTWF0aC5jb3ModS10KSxFKGgsaSkrbisuOSphKk1hdGguc2luKHUtdCldKTtmb3IodmFyIGM9dTtjPD1zO2MrPXQpcC5wdXNoKFtFKGgsaSkrZStyKk1hdGguY29zKGMpLEUoaCxpKStuK2EqTWF0aC5zaW4oYyldKTtyZXR1cm4gcC5wdXNoKFtlK3IqTWF0aC5jb3MocyksbithKk1hdGguc2luKHMpXSkscC5wdXNoKFtlK3IqTWF0aC5jb3MocyksbithKk1hdGguc2luKHMpXSkscShwLG51bGwsaSl9ZnVuY3Rpb24gWih0KXtyZXR1cm5bLi4udF19ZnVuY3Rpb24gRCh0LGUpe3JldHVybiBNYXRoLnBvdyh0WzBdLWVbMF0sMikrTWF0aC5wb3codFsxXS1lWzFdLDIpfWZ1bmN0aW9uIEYodCxlLG4pe2NvbnN0IHI9RChlLG4pO2lmKDA9PT1yKXJldHVybiBEKHQsZSk7bGV0IGE9KCh0WzBdLWVbMF0pKihuWzBdLWVbMF0pKyh0WzFdLWVbMV0pKihuWzFdLWVbMV0pKS9yO3JldHVybiBhPU1hdGgubWF4KDAsTWF0aC5taW4oMSxhKSksRCh0LFEoZSxuLGEpKX1mdW5jdGlvbiBRKHQsZSxuKXtyZXR1cm5bdFswXSsoZVswXS10WzBdKSpuLHRbMV0rKGVbMV0tdFsxXSkqbl19ZnVuY3Rpb24gSCh0LGUsbixyKXtjb25zdCBhPXJ8fFtdO2lmKGZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10W2UrMF0scj10W2UrMV0sYT10W2UrMl0sbz10W2UrM107bGV0IHM9MypyWzBdLTIqblswXS1vWzBdO3MqPXM7bGV0IGg9MypyWzFdLTIqblsxXS1vWzFdO2gqPWg7bGV0IGk9MyphWzBdLTIqb1swXS1uWzBdO2kqPWk7bGV0IHU9MyphWzFdLTIqb1sxXS1uWzFdO3JldHVybiB1Kj11LHM8aSYmKHM9aSksaDx1JiYoaD11KSxzK2h9KHQsZSk8bil7Y29uc3Qgbj10W2UrMF07aWYoYS5sZW5ndGgpeyhvPWFbYS5sZW5ndGgtMV0scz1uLE1hdGguc3FydChEKG8scykpKT4xJiZhLnB1c2gobil9ZWxzZSBhLnB1c2gobik7YS5wdXNoKHRbZSszXSl9ZWxzZXtjb25zdCByPS41LG89dFtlKzBdLHM9dFtlKzFdLGg9dFtlKzJdLGk9dFtlKzNdLHU9UShvLHMscikscD1RKHMsaCxyKSxjPVEoaCxpLHIpLGw9USh1LHAsciksZj1RKHAsYyxyKSxkPVEobCxmLHIpO0goW28sdSxsLGRdLDAsbixhKSxIKFtkLGYsYyxpXSwwLG4sYSl9dmFyIG8scztyZXR1cm4gYX1mdW5jdGlvbiBOKHQsZSl7cmV0dXJuIFYodCwwLHQubGVuZ3RoLGUpfWZ1bmN0aW9uIFYodCxlLG4scixhKXtjb25zdCBvPWF8fFtdLHM9dFtlXSxoPXRbbi0xXTtsZXQgaT0wLHU9MTtmb3IobGV0IHI9ZSsxO3I8bi0xOysrcil7Y29uc3QgZT1GKHRbcl0scyxoKTtlPmkmJihpPWUsdT1yKX1yZXR1cm4gTWF0aC5zcXJ0KGkpPnI/KFYodCxlLHUrMSxyLG8pLFYodCx1LG4scixvKSk6KG8ubGVuZ3RofHxvLnB1c2gocyksby5wdXNoKGgpKSxvfWZ1bmN0aW9uICQodCxlPS4xNSxuKXtjb25zdCByPVtdLGE9KHQubGVuZ3RoLTEpLzM7Zm9yKGxldCBuPTA7bjxhO24rKyl7SCh0LDMqbixlLHIpfXJldHVybiBuJiZuPjA/VihyLDAsci5sZW5ndGgsbik6cn12YXIgQj1cIm5vbmVcIixKPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmRlZmF1bHRPcHRpb25zPXttYXhSYW5kb21uZXNzT2Zmc2V0OjIscm91Z2huZXNzOjEsYm93aW5nOjEsc3Ryb2tlOlwiIzAwMFwiLHN0cm9rZVdpZHRoOjEsY3VydmVUaWdodG5lc3M6MCxjdXJ2ZUZpdHRpbmc6Ljk1LGN1cnZlU3RlcENvdW50OjksZmlsbFN0eWxlOlwiaGFjaHVyZVwiLGZpbGxXZWlnaHQ6LTEsaGFjaHVyZUFuZ2xlOi00MSxoYWNodXJlR2FwOi0xLGRhc2hPZmZzZXQ6LTEsZGFzaEdhcDotMSx6aWd6YWdPZmZzZXQ6LTEsc2VlZDowLGNvbWJpbmVOZXN0ZWRTdmdQYXRoczohMX0sdGhpcy5jb25maWc9dHx8e30sdGhpcy5jb25maWcub3B0aW9ucyYmKHRoaXMuZGVmYXVsdE9wdGlvbnM9dGhpcy5fbyh0aGlzLmNvbmZpZy5vcHRpb25zKSl9cmV0dXJuIHQubmV3U2VlZD1mdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMiwzMSkpfSx0LnByb3RvdHlwZS5fbz1mdW5jdGlvbih0KXtyZXR1cm4gdD9PYmplY3QuYXNzaWduKHt9LHRoaXMuZGVmYXVsdE9wdGlvbnMsdCk6dGhpcy5kZWZhdWx0T3B0aW9uc30sdC5wcm90b3R5cGUuX2Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybntzaGFwZTp0LHNldHM6ZXx8W10sb3B0aW9uczpufHx0aGlzLmRlZmF1bHRPcHRpb25zfX0sdC5wcm90b3R5cGUubGluZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuX28oYSk7cmV0dXJuIHRoaXMuX2QoXCJsaW5lXCIsW3codCxlLG4scixvKV0sbyl9LHQucHJvdG90eXBlLnJlY3RhbmdsZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuX28oYSkscz1bXSxoPXgodCxlLG4scixvKTtpZihvLmZpbGwpe3ZhciBpPVtbdCxlXSxbdCtuLGVdLFt0K24sZStyXSxbdCxlK3JdXTtcInNvbGlkXCI9PT1vLmZpbGxTdHlsZT9zLnB1c2goQyhpLG8pKTpzLnB1c2goVyhpLG8pKX1yZXR1cm4gby5zdHJva2UhPT1CJiZzLnB1c2goaCksdGhpcy5fZChcInJlY3RhbmdsZVwiLHMsbyl9LHQucHJvdG90eXBlLmVsbGlwc2U9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgbz10aGlzLl9vKGEpLHM9W10saD1PKG4scixvKSxpPVModCxlLG8saCk7aWYoby5maWxsKWlmKFwic29saWRcIj09PW8uZmlsbFN0eWxlKXt2YXIgdT1TKHQsZSxvLGgpLm9wc2V0O3UudHlwZT1cImZpbGxQYXRoXCIscy5wdXNoKHUpfWVsc2Ugcy5wdXNoKFcoaS5lc3RpbWF0ZWRQb2ludHMsbykpO3JldHVybiBvLnN0cm9rZSE9PUImJnMucHVzaChpLm9wc2V0KSx0aGlzLl9kKFwiZWxsaXBzZVwiLHMsbyl9LHQucHJvdG90eXBlLmNpcmNsZT1mdW5jdGlvbih0LGUsbixyKXt2YXIgYT10aGlzLmVsbGlwc2UodCxlLG4sbixyKTtyZXR1cm4gYS5zaGFwZT1cImNpcmNsZVwiLGF9LHQucHJvdG90eXBlLmxpbmVhclBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9vKGUpO3JldHVybiB0aGlzLl9kKFwibGluZWFyUGF0aFwiLFtQKHQsITEsbildLG4pfSx0LnByb3RvdHlwZS5hcmM9ZnVuY3Rpb24odCxlLG4scixhLG8scyxoKXt2b2lkIDA9PT1zJiYocz0hMSk7dmFyIGk9dGhpcy5fbyhoKSx1PVtdLHA9VCh0LGUsbixyLGEsbyxzLCEwLGkpO2lmKHMmJmkuZmlsbClpZihcInNvbGlkXCI9PT1pLmZpbGxTdHlsZSl7dmFyIGM9VCh0LGUsbixyLGEsbywhMCwhMSxpKTtjLnR5cGU9XCJmaWxsUGF0aFwiLHUucHVzaChjKX1lbHNlIHUucHVzaChmdW5jdGlvbih0LGUsbixyLGEsbyxzKXt2YXIgaD10LGk9ZSx1PU1hdGguYWJzKG4vMikscD1NYXRoLmFicyhyLzIpO3UrPUUoLjAxKnUscykscCs9RSguMDEqcCxzKTtmb3IodmFyIGM9YSxsPW87YzwwOyljKz0yKk1hdGguUEksbCs9MipNYXRoLlBJO2wtYz4yKk1hdGguUEkmJihjPTAsbD0yKk1hdGguUEkpO2Zvcih2YXIgZj0obC1jKS9zLmN1cnZlU3RlcENvdW50LGQ9W10sZz1jO2c8PWw7Zys9ZilkLnB1c2goW2grdSpNYXRoLmNvcyhnKSxpK3AqTWF0aC5zaW4oZyldKTtyZXR1cm4gZC5wdXNoKFtoK3UqTWF0aC5jb3MobCksaStwKk1hdGguc2luKGwpXSksZC5wdXNoKFtoLGldKSxXKGQscyl9KHQsZSxuLHIsYSxvLGkpKTtyZXR1cm4gaS5zdHJva2UhPT1CJiZ1LnB1c2gocCksdGhpcy5fZChcImFyY1wiLHUsaSl9LHQucHJvdG90eXBlLmN1cnZlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fbyhlKSxyPVtdLGE9ZnVuY3Rpb24odCxlKXt2YXIgbj1SKHQsMSooMSsuMiplLnJvdWdobmVzcyksZSkscj1SKHQsMS41KigxKy4yMiplLnJvdWdobmVzcyksZSk7cmV0dXJue3R5cGU6XCJwYXRoXCIsb3BzOm4uY29uY2F0KHIpfX0odCxuKTtpZihuLmZpbGwmJm4uZmlsbCE9PUImJnQubGVuZ3RoPj0zKXt2YXIgbz0kKGZ1bmN0aW9uKHQsZT0wKXtjb25zdCBuPXQubGVuZ3RoO2lmKG48Myl0aHJvdyBuZXcgRXJyb3IoXCJBIGN1cnZlIG11c3QgaGF2ZSBhdCBsZWFzdCB0aHJlZSBwb2ludHMuXCIpO2NvbnN0IHI9W107aWYoMz09PW4pci5wdXNoKFoodFswXSksWih0WzFdKSxaKHRbMl0pLFoodFsyXSkpO2Vsc2V7Y29uc3Qgbj1bXTtuLnB1c2godFswXSx0WzBdKTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKyluLnB1c2godFtlXSksZT09PXQubGVuZ3RoLTEmJm4ucHVzaCh0W2VdKTtjb25zdCBhPVtdLG89MS1lO3IucHVzaChaKG5bMF0pKTtmb3IobGV0IHQ9MTt0KzI8bi5sZW5ndGg7dCsrKXtjb25zdCBlPW5bdF07YVswXT1bZVswXSxlWzFdXSxhWzFdPVtlWzBdKyhvKm5bdCsxXVswXS1vKm5bdC0xXVswXSkvNixlWzFdKyhvKm5bdCsxXVsxXS1vKm5bdC0xXVsxXSkvNl0sYVsyXT1bblt0KzFdWzBdKyhvKm5bdF1bMF0tbypuW3QrMl1bMF0pLzYsblt0KzFdWzFdKyhvKm5bdF1bMV0tbypuW3QrMl1bMV0pLzZdLGFbM109W25bdCsxXVswXSxuW3QrMV1bMV1dLHIucHVzaChhWzFdLGFbMl0sYVszXSl9fXJldHVybiByfSh0KSwxMCwoMStuLnJvdWdobmVzcykvMik7XCJzb2xpZFwiPT09bi5maWxsU3R5bGU/ci5wdXNoKEMobyxuKSk6ci5wdXNoKFcobyxuKSl9cmV0dXJuIG4uc3Ryb2tlIT09QiYmci5wdXNoKGEpLHRoaXMuX2QoXCJjdXJ2ZVwiLHIsbil9LHQucHJvdG90eXBlLnBvbHlnb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9vKGUpLHI9W10sYT1QKHQsITAsbik7cmV0dXJuIG4uZmlsbCYmKFwic29saWRcIj09PW4uZmlsbFN0eWxlP3IucHVzaChDKHQsbikpOnIucHVzaChXKHQsbikpKSxuLnN0cm9rZSE9PUImJnIucHVzaChhKSx0aGlzLl9kKFwicG9seWdvblwiLHIsbil9LHQucHJvdG90eXBlLnBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9vKGUpLHI9W107aWYoIXQpcmV0dXJuIHRoaXMuX2QoXCJwYXRoXCIscixuKTt0PSh0fHxcIlwiKS5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSgvKC1cXHMpL2csXCItXCIpLnJlcGxhY2UoXCIvKHNzKS9nXCIsXCIgXCIpO3ZhciBhPW4uZmlsbCYmXCJ0cmFuc3BhcmVudFwiIT09bi5maWxsJiZuLmZpbGwhPT1CLG89bi5zdHJva2UhPT1CLHM9ISEobi5zaW1wbGlmaWNhdGlvbiYmbi5zaW1wbGlmaWNhdGlvbjwxKSxoPWZ1bmN0aW9uKHQsZSxuKXtjb25zdCByPU0odih5KHQpKSksYT1bXTtsZXQgbz1bXSxzPVswLDBdLGg9W107Y29uc3QgaT0oKT0+e2gubGVuZ3RoPj00JiZvLnB1c2goLi4uJChoLGUpKSxoPVtdfSx1PSgpPT57aSgpLG8ubGVuZ3RoJiYoYS5wdXNoKG8pLG89W10pfTtmb3IoY29uc3R7a2V5OnQsZGF0YTplfW9mIHIpc3dpdGNoKHQpe2Nhc2VcIk1cIjp1KCkscz1bZVswXSxlWzFdXSxvLnB1c2gocyk7YnJlYWs7Y2FzZVwiTFwiOmkoKSxvLnB1c2goW2VbMF0sZVsxXV0pO2JyZWFrO2Nhc2VcIkNcIjppZighaC5sZW5ndGgpe2NvbnN0IHQ9by5sZW5ndGg/b1tvLmxlbmd0aC0xXTpzO2gucHVzaChbdFswXSx0WzFdXSl9aC5wdXNoKFtlWzBdLGVbMV1dKSxoLnB1c2goW2VbMl0sZVszXV0pLGgucHVzaChbZVs0XSxlWzVdXSk7YnJlYWs7Y2FzZVwiWlwiOmkoKSxvLnB1c2goW3NbMF0sc1sxXV0pfWlmKHUoKSwhbilyZXR1cm4gYTtjb25zdCBwPVtdO2Zvcihjb25zdCB0IG9mIGEpe2NvbnN0IGU9Tih0LG4pO2UubGVuZ3RoJiZwLnB1c2goZSl9cmV0dXJuIHB9KHQsMSxzPzQtNCpuLnNpbXBsaWZpY2F0aW9uOigxK24ucm91Z2huZXNzKS8yKTtpZihhKWlmKG4uY29tYmluZU5lc3RlZFN2Z1BhdGhzKXt2YXIgaT1bXTtoLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBpLnB1c2guYXBwbHkoaSx0KX0pKSxcInNvbGlkXCI9PT1uLmZpbGxTdHlsZT9yLnB1c2goQyhpLG4pKTpyLnB1c2goVyhpLG4pKX1lbHNlIGguZm9yRWFjaCgoZnVuY3Rpb24odCl7XCJzb2xpZFwiPT09bi5maWxsU3R5bGU/ci5wdXNoKEModCxuKSk6ci5wdXNoKFcodCxuKSl9KSk7cmV0dXJuIG8mJihzP2guZm9yRWFjaCgoZnVuY3Rpb24odCl7ci5wdXNoKFAodCwhMSxuKSl9KSk6ci5wdXNoKF8odCxuKSkpLHRoaXMuX2QoXCJwYXRoXCIscixuKX0sdC5wcm90b3R5cGUub3BzVG9QYXRoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1cIlwiLG49MCxyPXQub3BzO248ci5sZW5ndGg7bisrKXt2YXIgYT1yW25dLG89YS5kYXRhO3N3aXRjaChhLm9wKXtjYXNlXCJtb3ZlXCI6ZSs9XCJNXCIrb1swXStcIiBcIitvWzFdK1wiIFwiO2JyZWFrO2Nhc2VcImJjdXJ2ZVRvXCI6ZSs9XCJDXCIrb1swXStcIiBcIitvWzFdK1wiLCBcIitvWzJdK1wiIFwiK29bM10rXCIsIFwiK29bNF0rXCIgXCIrb1s1XStcIiBcIjticmVhaztjYXNlXCJsaW5lVG9cIjplKz1cIkxcIitvWzBdK1wiIFwiK29bMV0rXCIgXCJ9fXJldHVybiBlLnRyaW0oKX0sdC5wcm90b3R5cGUudG9QYXRocz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5zZXRzfHxbXSxuPXQub3B0aW9uc3x8dGhpcy5kZWZhdWx0T3B0aW9ucyxyPVtdLGE9MCxvPWU7YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV0saD1udWxsO3N3aXRjaChzLnR5cGUpe2Nhc2VcInBhdGhcIjpoPXtkOnRoaXMub3BzVG9QYXRoKHMpLHN0cm9rZTpuLnN0cm9rZSxzdHJva2VXaWR0aDpuLnN0cm9rZVdpZHRoLGZpbGw6Qn07YnJlYWs7Y2FzZVwiZmlsbFBhdGhcIjpoPXtkOnRoaXMub3BzVG9QYXRoKHMpLHN0cm9rZTpCLHN0cm9rZVdpZHRoOjAsZmlsbDpuLmZpbGx8fEJ9O2JyZWFrO2Nhc2VcImZpbGxTa2V0Y2hcIjpoPXRoaXMuZmlsbFNrZXRjaChzLG4pfWgmJnIucHVzaChoKX1yZXR1cm4gcn0sdC5wcm90b3R5cGUuZmlsbFNrZXRjaD1mdW5jdGlvbih0LGUpe3ZhciBuPWUuZmlsbFdlaWdodDtyZXR1cm4gbjwwJiYobj1lLnN0cm9rZVdpZHRoLzIpLHtkOnRoaXMub3BzVG9QYXRoKHQpLHN0cm9rZTplLmZpbGx8fEIsc3Ryb2tlV2lkdGg6bixmaWxsOkJ9fSx0fSgpLEs9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5jYW52YXM9dCx0aGlzLmN0eD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksdGhpcy5nZW49bmV3IEooZSl9cmV0dXJuIHQucHJvdG90eXBlLmRyYXc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc2V0c3x8W10sbj10Lm9wdGlvbnN8fHRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKSxyPXRoaXMuY3R4LGE9MCxvPWU7YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV07c3dpdGNoKHMudHlwZSl7Y2FzZVwicGF0aFwiOnIuc2F2ZSgpLHIuc3Ryb2tlU3R5bGU9XCJub25lXCI9PT1uLnN0cm9rZT9cInRyYW5zcGFyZW50XCI6bi5zdHJva2Usci5saW5lV2lkdGg9bi5zdHJva2VXaWR0aCx0aGlzLl9kcmF3VG9Db250ZXh0KHIscyksci5yZXN0b3JlKCk7YnJlYWs7Y2FzZVwiZmlsbFBhdGhcIjpyLnNhdmUoKSxyLmZpbGxTdHlsZT1uLmZpbGx8fFwiXCI7dmFyIGg9XCJjdXJ2ZVwiPT09dC5zaGFwZXx8XCJwb2x5Z29uXCI9PT10LnNoYXBlP1wiZXZlbm9kZFwiOlwibm9uemVyb1wiO3RoaXMuX2RyYXdUb0NvbnRleHQocixzLGgpLHIucmVzdG9yZSgpO2JyZWFrO2Nhc2VcImZpbGxTa2V0Y2hcIjp0aGlzLmZpbGxTa2V0Y2gocixzLG4pfX19LHQucHJvdG90eXBlLmZpbGxTa2V0Y2g9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW4uZmlsbFdlaWdodDtyPDAmJihyPW4uc3Ryb2tlV2lkdGgvMiksdC5zYXZlKCksdC5zdHJva2VTdHlsZT1uLmZpbGx8fFwiXCIsdC5saW5lV2lkdGg9cix0aGlzLl9kcmF3VG9Db250ZXh0KHQsZSksdC5yZXN0b3JlKCl9LHQucHJvdG90eXBlLl9kcmF3VG9Db250ZXh0PWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1cIm5vbnplcm9cIiksdC5iZWdpblBhdGgoKTtmb3IodmFyIHI9MCxhPWUub3BzO3I8YS5sZW5ndGg7cisrKXt2YXIgbz1hW3JdLHM9by5kYXRhO3N3aXRjaChvLm9wKXtjYXNlXCJtb3ZlXCI6dC5tb3ZlVG8oc1swXSxzWzFdKTticmVhaztjYXNlXCJiY3VydmVUb1wiOnQuYmV6aWVyQ3VydmVUbyhzWzBdLHNbMV0sc1syXSxzWzNdLHNbNF0sc1s1XSk7YnJlYWs7Y2FzZVwibGluZVRvXCI6dC5saW5lVG8oc1swXSxzWzFdKX19XCJmaWxsUGF0aFwiPT09ZS50eXBlP3QuZmlsbChuKTp0LnN0cm9rZSgpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJnZW5lcmF0b3JcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldERlZmF1bHRPcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VuLmRlZmF1bHRPcHRpb25zfSx0LnByb3RvdHlwZS5saW5lPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5nZW4ubGluZSh0LGUsbixyLGEpO3JldHVybiB0aGlzLmRyYXcobyksb30sdC5wcm90b3R5cGUucmVjdGFuZ2xlPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5nZW4ucmVjdGFuZ2xlKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhvKSxvfSx0LnByb3RvdHlwZS5lbGxpcHNlPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5nZW4uZWxsaXBzZSh0LGUsbixyLGEpO3JldHVybiB0aGlzLmRyYXcobyksb30sdC5wcm90b3R5cGUuY2lyY2xlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPXRoaXMuZ2VuLmNpcmNsZSh0LGUsbixyKTtyZXR1cm4gdGhpcy5kcmF3KGEpLGF9LHQucHJvdG90eXBlLmxpbmVhclBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5saW5lYXJQYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKSxufSx0LnByb3RvdHlwZS5wb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4ucG9seWdvbih0LGUpO3JldHVybiB0aGlzLmRyYXcobiksbn0sdC5wcm90b3R5cGUuYXJjPWZ1bmN0aW9uKHQsZSxuLHIsYSxvLHMsaCl7dm9pZCAwPT09cyYmKHM9ITEpO3ZhciBpPXRoaXMuZ2VuLmFyYyh0LGUsbixyLGEsbyxzLGgpO3JldHVybiB0aGlzLmRyYXcoaSksaX0sdC5wcm90b3R5cGUuY3VydmU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5jdXJ2ZSh0LGUpO3JldHVybiB0aGlzLmRyYXcobiksbn0sdC5wcm90b3R5cGUucGF0aD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2VuLnBhdGgodCxlKTtyZXR1cm4gdGhpcy5kcmF3KG4pLG59LHR9KCksVT1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsWD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLnN2Zz10LHRoaXMuZ2VuPW5ldyBKKGUpfXJldHVybiB0LnByb3RvdHlwZS5kcmF3PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnNldHN8fFtdLG49dC5vcHRpb25zfHx0aGlzLmdldERlZmF1bHRPcHRpb25zKCkscj10aGlzLnN2Zy5vd25lckRvY3VtZW50fHx3aW5kb3cuZG9jdW1lbnQsYT1yLmNyZWF0ZUVsZW1lbnROUyhVLFwiZ1wiKSxvPTAscz1lO288cy5sZW5ndGg7bysrKXt2YXIgaD1zW29dLGk9bnVsbDtzd2l0Y2goaC50eXBlKXtjYXNlXCJwYXRoXCI6KGk9ci5jcmVhdGVFbGVtZW50TlMoVSxcInBhdGhcIikpLnNldEF0dHJpYnV0ZShcImRcIix0aGlzLm9wc1RvUGF0aChoKSksaS5zdHlsZS5zdHJva2U9bi5zdHJva2UsaS5zdHlsZS5zdHJva2VXaWR0aD1uLnN0cm9rZVdpZHRoK1wiXCIsaS5zdHlsZS5maWxsPVwibm9uZVwiO2JyZWFrO2Nhc2VcImZpbGxQYXRoXCI6KGk9ci5jcmVhdGVFbGVtZW50TlMoVSxcInBhdGhcIikpLnNldEF0dHJpYnV0ZShcImRcIix0aGlzLm9wc1RvUGF0aChoKSksaS5zdHlsZS5zdHJva2U9XCJub25lXCIsaS5zdHlsZS5zdHJva2VXaWR0aD1cIjBcIixpLnN0eWxlLmZpbGw9bi5maWxsfHxcIlwiO2JyZWFrO2Nhc2VcImZpbGxTa2V0Y2hcIjppPXRoaXMuZmlsbFNrZXRjaChyLGgsbil9aSYmYS5hcHBlbmRDaGlsZChpKX1yZXR1cm4gYX0sdC5wcm90b3R5cGUuZmlsbFNrZXRjaD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bi5maWxsV2VpZ2h0O3I8MCYmKHI9bi5zdHJva2VXaWR0aC8yKTt2YXIgYT10LmNyZWF0ZUVsZW1lbnROUyhVLFwicGF0aFwiKTtyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoXCJkXCIsdGhpcy5vcHNUb1BhdGgoZSkpLGEuc3R5bGUuc3Ryb2tlPW4uZmlsbHx8XCJcIixhLnN0eWxlLnN0cm9rZVdpZHRoPXIrXCJcIixhLnN0eWxlLmZpbGw9XCJub25lXCIsYX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZ2VuZXJhdG9yXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXREZWZhdWx0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdlbi5kZWZhdWx0T3B0aW9uc30sdC5wcm90b3R5cGUub3BzVG9QYXRoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlbi5vcHNUb1BhdGgodCl9LHQucHJvdG90eXBlLmxpbmU9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgbz10aGlzLmdlbi5saW5lKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhvKX0sdC5wcm90b3R5cGUucmVjdGFuZ2xlPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5nZW4ucmVjdGFuZ2xlKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhvKX0sdC5wcm90b3R5cGUuZWxsaXBzZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuZ2VuLmVsbGlwc2UodCxlLG4scixhKTtyZXR1cm4gdGhpcy5kcmF3KG8pfSx0LnByb3RvdHlwZS5jaXJjbGU9ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9dGhpcy5nZW4uY2lyY2xlKHQsZSxuLHIpO3JldHVybiB0aGlzLmRyYXcoYSl9LHQucHJvdG90eXBlLmxpbmVhclBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5saW5lYXJQYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKX0sdC5wcm90b3R5cGUucG9seWdvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2VuLnBvbHlnb24odCxlKTtyZXR1cm4gdGhpcy5kcmF3KG4pfSx0LnByb3RvdHlwZS5hcmM9ZnVuY3Rpb24odCxlLG4scixhLG8scyxoKXt2b2lkIDA9PT1zJiYocz0hMSk7dmFyIGk9dGhpcy5nZW4uYXJjKHQsZSxuLHIsYSxvLHMsaCk7cmV0dXJuIHRoaXMuZHJhdyhpKX0sdC5wcm90b3R5cGUuY3VydmU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5jdXJ2ZSh0LGUpO3JldHVybiB0aGlzLmRyYXcobil9LHQucHJvdG90eXBlLnBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5wYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKX0sdH0oKSxZPXtjYW52YXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IEsodCxlKX0sc3ZnOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBYKHQsZSl9LGdlbmVyYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEoodCl9LG5ld1NlZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gSi5uZXdTZWVkKCl9fTttb2R1bGUuZXhwb3J0cz1ZO1xuIiwiLypcbiAqIEEgZmFzdCBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHNpbXBsZXggbm9pc2UgYnkgSm9uYXMgV2FnbmVyXG5cbkJhc2VkIG9uIGEgc3BlZWQtaW1wcm92ZWQgc2ltcGxleCBub2lzZSBhbGdvcml0aG0gZm9yIDJELCAzRCBhbmQgNEQgaW4gSmF2YS5cbldoaWNoIGlzIGJhc2VkIG9uIGV4YW1wbGUgY29kZSBieSBTdGVmYW4gR3VzdGF2c29uIChzdGVndUBpdG4ubGl1LnNlKS5cbldpdGggT3B0aW1pc2F0aW9ucyBieSBQZXRlciBFYXN0bWFuIChwZWFzdG1hbkBkcml6emxlLnN0YW5mb3JkLmVkdSkuXG5CZXR0ZXIgcmFuayBvcmRlcmluZyBtZXRob2QgYnkgU3RlZmFuIEd1c3RhdnNvbiBpbiAyMDEyLlxuXG5cbiBDb3B5cmlnaHQgKGMpIDIwMTggSm9uYXMgV2FnbmVyXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiBTT0ZUV0FSRS5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEYyID0gMC41ICogKE1hdGguc3FydCgzLjApIC0gMS4wKTtcbiAgdmFyIEcyID0gKDMuMCAtIE1hdGguc3FydCgzLjApKSAvIDYuMDtcbiAgdmFyIEYzID0gMS4wIC8gMy4wO1xuICB2YXIgRzMgPSAxLjAgLyA2LjA7XG4gIHZhciBGNCA9IChNYXRoLnNxcnQoNS4wKSAtIDEuMCkgLyA0LjA7XG4gIHZhciBHNCA9ICg1LjAgLSBNYXRoLnNxcnQoNS4wKSkgLyAyMC4wO1xuXG4gIGZ1bmN0aW9uIFNpbXBsZXhOb2lzZShyYW5kb21PclNlZWQpIHtcbiAgICB2YXIgcmFuZG9tO1xuICAgIGlmICh0eXBlb2YgcmFuZG9tT3JTZWVkID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJhbmRvbSA9IHJhbmRvbU9yU2VlZDtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuZG9tT3JTZWVkKSB7XG4gICAgICByYW5kb20gPSBhbGVhKHJhbmRvbU9yU2VlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuICAgIH1cbiAgICB0aGlzLnAgPSBidWlsZFBlcm11dGF0aW9uVGFibGUocmFuZG9tKTtcbiAgICB0aGlzLnBlcm0gPSBuZXcgVWludDhBcnJheSg1MTIpO1xuICAgIHRoaXMucGVybU1vZDEyID0gbmV3IFVpbnQ4QXJyYXkoNTEyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDUxMjsgaSsrKSB7XG4gICAgICB0aGlzLnBlcm1baV0gPSB0aGlzLnBbaSAmIDI1NV07XG4gICAgICB0aGlzLnBlcm1Nb2QxMltpXSA9IHRoaXMucGVybVtpXSAlIDEyO1xuICAgIH1cblxuICB9XG4gIFNpbXBsZXhOb2lzZS5wcm90b3R5cGUgPSB7XG4gICAgZ3JhZDM6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDAsXG4gICAgICAtMSwgMSwgMCxcbiAgICAgIDEsIC0xLCAwLFxuXG4gICAgICAtMSwgLTEsIDAsXG4gICAgICAxLCAwLCAxLFxuICAgICAgLTEsIDAsIDEsXG5cbiAgICAgIDEsIDAsIC0xLFxuICAgICAgLTEsIDAsIC0xLFxuICAgICAgMCwgMSwgMSxcblxuICAgICAgMCwgLTEsIDEsXG4gICAgICAwLCAxLCAtMSxcbiAgICAgIDAsIC0xLCAtMV0pLFxuICAgIGdyYWQ0OiBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAxLCAxLCAwLCAxLCAxLCAtMSwgMCwgMSwgLTEsIDEsIDAsIDEsIC0xLCAtMSxcbiAgICAgIDAsIC0xLCAxLCAxLCAwLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSwgMSwgMCwgLTEsIC0xLCAtMSxcbiAgICAgIDEsIDAsIDEsIDEsIDEsIDAsIDEsIC0xLCAxLCAwLCAtMSwgMSwgMSwgMCwgLTEsIC0xLFxuICAgICAgLTEsIDAsIDEsIDEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIC0xLCAxLCAtMSwgMCwgLTEsIC0xLFxuICAgICAgMSwgMSwgMCwgMSwgMSwgMSwgMCwgLTEsIDEsIC0xLCAwLCAxLCAxLCAtMSwgMCwgLTEsXG4gICAgICAtMSwgMSwgMCwgMSwgLTEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIC0xLCAtMSwgMCwgLTEsXG4gICAgICAxLCAxLCAxLCAwLCAxLCAxLCAtMSwgMCwgMSwgLTEsIDEsIDAsIDEsIC0xLCAtMSwgMCxcbiAgICAgIC0xLCAxLCAxLCAwLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSwgMSwgMCwgLTEsIC0xLCAtMSwgMF0pLFxuICAgIG5vaXNlMkQ6IGZ1bmN0aW9uKHhpbiwgeWluKSB7XG4gICAgICB2YXIgcGVybU1vZDEyID0gdGhpcy5wZXJtTW9kMTI7XG4gICAgICB2YXIgcGVybSA9IHRoaXMucGVybTtcbiAgICAgIHZhciBncmFkMyA9IHRoaXMuZ3JhZDM7XG4gICAgICB2YXIgbjAgPSAwOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcbiAgICAgIHZhciBuMSA9IDA7XG4gICAgICB2YXIgbjIgPSAwO1xuICAgICAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpblxuICAgICAgdmFyIHMgPSAoeGluICsgeWluKSAqIEYyOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG4gICAgICB2YXIgaSA9IE1hdGguZmxvb3IoeGluICsgcyk7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gICAgICB2YXIgdCA9IChpICsgaikgKiBHMjtcbiAgICAgIHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSkgc3BhY2VcbiAgICAgIHZhciBZMCA9IGogLSB0O1xuICAgICAgdmFyIHgwID0geGluIC0gWDA7IC8vIFRoZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICB2YXIgeTAgPSB5aW4gLSBZMDtcbiAgICAgIC8vIEZvciB0aGUgMkQgY2FzZSwgdGhlIHNpbXBsZXggc2hhcGUgaXMgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUuXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG4gICAgICB2YXIgaTEsIGoxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgKG1pZGRsZSkgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaikgY29vcmRzXG4gICAgICBpZiAoeDAgPiB5MCkge1xuICAgICAgICBpMSA9IDE7XG4gICAgICAgIGoxID0gMDtcbiAgICAgIH0gLy8gbG93ZXIgdHJpYW5nbGUsIFhZIG9yZGVyOiAoMCwwKS0+KDEsMCktPigxLDEpXG4gICAgICBlbHNlIHtcbiAgICAgICAgaTEgPSAwO1xuICAgICAgICBqMSA9IDE7XG4gICAgICB9IC8vIHVwcGVyIHRyaWFuZ2xlLCBZWCBvcmRlcjogKDAsMCktPigwLDEpLT4oMSwxKVxuICAgICAgLy8gQSBzdGVwIG9mICgxLDApIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jKSBpbiAoeCx5KSwgYW5kXG4gICAgICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuICAgICAgLy8gYyA9ICgzLXNxcnQoMykpLzZcbiAgICAgIHZhciB4MSA9IHgwIC0gaTEgKyBHMjsgLy8gT2Zmc2V0cyBmb3IgbWlkZGxlIGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcbiAgICAgIHZhciB5MSA9IHkwIC0gajEgKyBHMjtcbiAgICAgIHZhciB4MiA9IHgwIC0gMS4wICsgMi4wICogRzI7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkpIHVuc2tld2VkIGNvb3Jkc1xuICAgICAgdmFyIHkyID0geTAgLSAxLjAgKyAyLjAgKiBHMjtcbiAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXG4gICAgICB2YXIgaWkgPSBpICYgMjU1O1xuICAgICAgdmFyIGpqID0gaiAmIDI1NTtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcbiAgICAgIHZhciB0MCA9IDAuNSAtIHgwICogeDAgLSB5MCAqIHkwO1xuICAgICAgaWYgKHQwID49IDApIHtcbiAgICAgICAgdmFyIGdpMCA9IHBlcm1Nb2QxMltpaSArIHBlcm1bampdXSAqIDM7XG4gICAgICAgIHQwICo9IHQwO1xuICAgICAgICBuMCA9IHQwICogdDAgKiAoZ3JhZDNbZ2kwXSAqIHgwICsgZ3JhZDNbZ2kwICsgMV0gKiB5MCk7IC8vICh4LHkpIG9mIGdyYWQzIHVzZWQgZm9yIDJEIGdyYWRpZW50XG4gICAgICB9XG4gICAgICB2YXIgdDEgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MTtcbiAgICAgIGlmICh0MSA+PSAwKSB7XG4gICAgICAgIHZhciBnaTEgPSBwZXJtTW9kMTJbaWkgKyBpMSArIHBlcm1bamogKyBqMV1dICogMztcbiAgICAgICAgdDEgKj0gdDE7XG4gICAgICAgIG4xID0gdDEgKiB0MSAqIChncmFkM1tnaTFdICogeDEgKyBncmFkM1tnaTEgKyAxXSAqIHkxKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MiA9IDAuNSAtIHgyICogeDIgLSB5MiAqIHkyO1xuICAgICAgaWYgKHQyID49IDApIHtcbiAgICAgICAgdmFyIGdpMiA9IHBlcm1Nb2QxMltpaSArIDEgKyBwZXJtW2pqICsgMV1dICogMztcbiAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgIG4yID0gdDIgKiB0MiAqIChncmFkM1tnaTJdICogeDIgKyBncmFkM1tnaTIgKyAxXSAqIHkyKTtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgICAgIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHJldHVybiB2YWx1ZXMgaW4gdGhlIGludGVydmFsIFstMSwxXS5cbiAgICAgIHJldHVybiA3MC4wICogKG4wICsgbjEgKyBuMik7XG4gICAgfSxcbiAgICAvLyAzRCBzaW1wbGV4IG5vaXNlXG4gICAgbm9pc2UzRDogZnVuY3Rpb24oeGluLCB5aW4sIHppbikge1xuICAgICAgdmFyIHBlcm1Nb2QxMiA9IHRoaXMucGVybU1vZDEyO1xuICAgICAgdmFyIHBlcm0gPSB0aGlzLnBlcm07XG4gICAgICB2YXIgZ3JhZDMgPSB0aGlzLmdyYWQzO1xuICAgICAgdmFyIG4wLCBuMSwgbjIsIG4zOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAgICAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpblxuICAgICAgdmFyIHMgPSAoeGluICsgeWluICsgemluKSAqIEYzOyAvLyBWZXJ5IG5pY2UgYW5kIHNpbXBsZSBza2V3IGZhY3RvciBmb3IgM0RcbiAgICAgIHZhciBpID0gTWF0aC5mbG9vcih4aW4gKyBzKTtcbiAgICAgIHZhciBqID0gTWF0aC5mbG9vcih5aW4gKyBzKTtcbiAgICAgIHZhciBrID0gTWF0aC5mbG9vcih6aW4gKyBzKTtcbiAgICAgIHZhciB0ID0gKGkgKyBqICsgaykgKiBHMztcbiAgICAgIHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6KSBzcGFjZVxuICAgICAgdmFyIFkwID0gaiAtIHQ7XG4gICAgICB2YXIgWjAgPSBrIC0gdDtcbiAgICAgIHZhciB4MCA9IHhpbiAtIFgwOyAvLyBUaGUgeCx5LHogZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICB2YXIgeTAgPSB5aW4gLSBZMDtcbiAgICAgIHZhciB6MCA9IHppbiAtIFowO1xuICAgICAgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgICAgIC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi5cbiAgICAgIHZhciBpMSwgajEsIGsxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcbiAgICAgIHZhciBpMiwgajIsIGsyOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICAgICAgaWYgKHgwID49IHkwKSB7XG4gICAgICAgIGlmICh5MCA+PSB6MCkge1xuICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgazEgPSAwO1xuICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICBqMiA9IDE7XG4gICAgICAgICAgazIgPSAwO1xuICAgICAgICB9IC8vIFggWSBaIG9yZGVyXG4gICAgICAgIGVsc2UgaWYgKHgwID49IHowKSB7XG4gICAgICAgICAgaTEgPSAxO1xuICAgICAgICAgIGoxID0gMDtcbiAgICAgICAgICBrMSA9IDA7XG4gICAgICAgICAgaTIgPSAxO1xuICAgICAgICAgIGoyID0gMDtcbiAgICAgICAgICBrMiA9IDE7XG4gICAgICAgIH0gLy8gWCBaIFkgb3JkZXJcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgIGoxID0gMDtcbiAgICAgICAgICBrMSA9IDE7XG4gICAgICAgICAgaTIgPSAxO1xuICAgICAgICAgIGoyID0gMDtcbiAgICAgICAgICBrMiA9IDE7XG4gICAgICAgIH0gLy8gWiBYIFkgb3JkZXJcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyB4MDx5MFxuICAgICAgICBpZiAoeTAgPCB6MCkge1xuICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgazEgPSAxO1xuICAgICAgICAgIGkyID0gMDtcbiAgICAgICAgICBqMiA9IDE7XG4gICAgICAgICAgazIgPSAxO1xuICAgICAgICB9IC8vIFogWSBYIG9yZGVyXG4gICAgICAgIGVsc2UgaWYgKHgwIDwgejApIHtcbiAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgajEgPSAxO1xuICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICBpMiA9IDA7XG4gICAgICAgICAgajIgPSAxO1xuICAgICAgICAgIGsyID0gMTtcbiAgICAgICAgfSAvLyBZIFogWCBvcmRlclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgajEgPSAxO1xuICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICBpMiA9IDE7XG4gICAgICAgICAgajIgPSAxO1xuICAgICAgICAgIGsyID0gMDtcbiAgICAgICAgfSAvLyBZIFggWiBvcmRlclxuICAgICAgfVxuICAgICAgLy8gQSBzdGVwIG9mICgxLDAsMCkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYywtYykgaW4gKHgseSx6KSxcbiAgICAgIC8vIGEgc3RlcCBvZiAoMCwxLDApIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMsLWMpIGluICh4LHkseiksIGFuZFxuICAgICAgLy8gYSBzdGVwIG9mICgwLDAsMSkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKC1jLC1jLDEtYykgaW4gKHgseSx6KSwgd2hlcmVcbiAgICAgIC8vIGMgPSAxLzYuXG4gICAgICB2YXIgeDEgPSB4MCAtIGkxICsgRzM7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgICAgIHZhciB5MSA9IHkwIC0gajEgKyBHMztcbiAgICAgIHZhciB6MSA9IHowIC0gazEgKyBHMztcbiAgICAgIHZhciB4MiA9IHgwIC0gaTIgKyAyLjAgKiBHMzsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gICAgICB2YXIgeTIgPSB5MCAtIGoyICsgMi4wICogRzM7XG4gICAgICB2YXIgejIgPSB6MCAtIGsyICsgMi4wICogRzM7XG4gICAgICB2YXIgeDMgPSB4MCAtIDEuMCArIDMuMCAqIEczOyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xuICAgICAgdmFyIHkzID0geTAgLSAxLjAgKyAzLjAgKiBHMztcbiAgICAgIHZhciB6MyA9IHowIC0gMS4wICsgMy4wICogRzM7XG4gICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZvdXIgc2ltcGxleCBjb3JuZXJzXG4gICAgICB2YXIgaWkgPSBpICYgMjU1O1xuICAgICAgdmFyIGpqID0gaiAmIDI1NTtcbiAgICAgIHZhciBrayA9IGsgJiAyNTU7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcbiAgICAgIHZhciB0MCA9IDAuNiAtIHgwICogeDAgLSB5MCAqIHkwIC0gejAgKiB6MDtcbiAgICAgIGlmICh0MCA8IDApIG4wID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTAgPSBwZXJtTW9kMTJbaWkgKyBwZXJtW2pqICsgcGVybVtra11dXSAqIDM7XG4gICAgICAgIHQwICo9IHQwO1xuICAgICAgICBuMCA9IHQwICogdDAgKiAoZ3JhZDNbZ2kwXSAqIHgwICsgZ3JhZDNbZ2kwICsgMV0gKiB5MCArIGdyYWQzW2dpMCArIDJdICogejApO1xuICAgICAgfVxuICAgICAgdmFyIHQxID0gMC42IC0geDEgKiB4MSAtIHkxICogeTEgLSB6MSAqIHoxO1xuICAgICAgaWYgKHQxIDwgMCkgbjEgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMSA9IHBlcm1Nb2QxMltpaSArIGkxICsgcGVybVtqaiArIGoxICsgcGVybVtrayArIGsxXV1dICogMztcbiAgICAgICAgdDEgKj0gdDE7XG4gICAgICAgIG4xID0gdDEgKiB0MSAqIChncmFkM1tnaTFdICogeDEgKyBncmFkM1tnaTEgKyAxXSAqIHkxICsgZ3JhZDNbZ2kxICsgMl0gKiB6MSk7XG4gICAgICB9XG4gICAgICB2YXIgdDIgPSAwLjYgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejI7XG4gICAgICBpZiAodDIgPCAwKSBuMiA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kyID0gcGVybU1vZDEyW2lpICsgaTIgKyBwZXJtW2pqICsgajIgKyBwZXJtW2trICsgazJdXV0gKiAzO1xuICAgICAgICB0MiAqPSB0MjtcbiAgICAgICAgbjIgPSB0MiAqIHQyICogKGdyYWQzW2dpMl0gKiB4MiArIGdyYWQzW2dpMiArIDFdICogeTIgKyBncmFkM1tnaTIgKyAyXSAqIHoyKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MyA9IDAuNiAtIHgzICogeDMgLSB5MyAqIHkzIC0gejMgKiB6MztcbiAgICAgIGlmICh0MyA8IDApIG4zID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTMgPSBwZXJtTW9kMTJbaWkgKyAxICsgcGVybVtqaiArIDEgKyBwZXJtW2trICsgMV1dXSAqIDM7XG4gICAgICAgIHQzICo9IHQzO1xuICAgICAgICBuMyA9IHQzICogdDMgKiAoZ3JhZDNbZ2kzXSAqIHgzICsgZ3JhZDNbZ2kzICsgMV0gKiB5MyArIGdyYWQzW2dpMyArIDJdICogejMpO1xuICAgICAgfVxuICAgICAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxuICAgICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gc3RheSBqdXN0IGluc2lkZSBbLTEsMV1cbiAgICAgIHJldHVybiAzMi4wICogKG4wICsgbjEgKyBuMiArIG4zKTtcbiAgICB9LFxuICAgIC8vIDREIHNpbXBsZXggbm9pc2UsIGJldHRlciBzaW1wbGV4IHJhbmsgb3JkZXJpbmcgbWV0aG9kIDIwMTItMDMtMDlcbiAgICBub2lzZTREOiBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgICB2YXIgcGVybSA9IHRoaXMucGVybTtcbiAgICAgIHZhciBncmFkNCA9IHRoaXMuZ3JhZDQ7XG5cbiAgICAgIHZhciBuMCwgbjEsIG4yLCBuMywgbjQ7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXG4gICAgICAvLyBTa2V3IHRoZSAoeCx5LHosdykgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGNlbGwgb2YgMjQgc2ltcGxpY2VzIHdlJ3JlIGluXG4gICAgICB2YXIgcyA9ICh4ICsgeSArIHogKyB3KSAqIEY0OyAvLyBGYWN0b3IgZm9yIDREIHNrZXdpbmdcbiAgICAgIHZhciBpID0gTWF0aC5mbG9vcih4ICsgcyk7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeSArIHMpO1xuICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKHogKyBzKTtcbiAgICAgIHZhciBsID0gTWF0aC5mbG9vcih3ICsgcyk7XG4gICAgICB2YXIgdCA9IChpICsgaiArIGsgKyBsKSAqIEc0OyAvLyBGYWN0b3IgZm9yIDREIHVuc2tld2luZ1xuICAgICAgdmFyIFgwID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5LHosdykgc3BhY2VcbiAgICAgIHZhciBZMCA9IGogLSB0O1xuICAgICAgdmFyIFowID0gayAtIHQ7XG4gICAgICB2YXIgVzAgPSBsIC0gdDtcbiAgICAgIHZhciB4MCA9IHggLSBYMDsgLy8gVGhlIHgseSx6LHcgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICB2YXIgeTAgPSB5IC0gWTA7XG4gICAgICB2YXIgejAgPSB6IC0gWjA7XG4gICAgICB2YXIgdzAgPSB3IC0gVzA7XG4gICAgICAvLyBGb3IgdGhlIDREIGNhc2UsIHRoZSBzaW1wbGV4IGlzIGEgNEQgc2hhcGUgSSB3b24ndCBldmVuIHRyeSB0byBkZXNjcmliZS5cbiAgICAgIC8vIFRvIGZpbmQgb3V0IHdoaWNoIG9mIHRoZSAyNCBwb3NzaWJsZSBzaW1wbGljZXMgd2UncmUgaW4sIHdlIG5lZWQgdG9cbiAgICAgIC8vIGRldGVybWluZSB0aGUgbWFnbml0dWRlIG9yZGVyaW5nIG9mIHgwLCB5MCwgejAgYW5kIHcwLlxuICAgICAgLy8gU2l4IHBhaXItd2lzZSBjb21wYXJpc29ucyBhcmUgcGVyZm9ybWVkIGJldHdlZW4gZWFjaCBwb3NzaWJsZSBwYWlyXG4gICAgICAvLyBvZiB0aGUgZm91ciBjb29yZGluYXRlcywgYW5kIHRoZSByZXN1bHRzIGFyZSB1c2VkIHRvIHJhbmsgdGhlIG51bWJlcnMuXG4gICAgICB2YXIgcmFua3ggPSAwO1xuICAgICAgdmFyIHJhbmt5ID0gMDtcbiAgICAgIHZhciByYW5reiA9IDA7XG4gICAgICB2YXIgcmFua3cgPSAwO1xuICAgICAgaWYgKHgwID4geTApIHJhbmt4Kys7XG4gICAgICBlbHNlIHJhbmt5Kys7XG4gICAgICBpZiAoeDAgPiB6MCkgcmFua3grKztcbiAgICAgIGVsc2UgcmFua3orKztcbiAgICAgIGlmICh4MCA+IHcwKSByYW5reCsrO1xuICAgICAgZWxzZSByYW5rdysrO1xuICAgICAgaWYgKHkwID4gejApIHJhbmt5Kys7XG4gICAgICBlbHNlIHJhbmt6Kys7XG4gICAgICBpZiAoeTAgPiB3MCkgcmFua3krKztcbiAgICAgIGVsc2UgcmFua3crKztcbiAgICAgIGlmICh6MCA+IHcwKSByYW5reisrO1xuICAgICAgZWxzZSByYW5rdysrO1xuICAgICAgdmFyIGkxLCBqMSwgazEsIGwxOyAvLyBUaGUgaW50ZWdlciBvZmZzZXRzIGZvciB0aGUgc2Vjb25kIHNpbXBsZXggY29ybmVyXG4gICAgICB2YXIgaTIsIGoyLCBrMiwgbDI7IC8vIFRoZSBpbnRlZ2VyIG9mZnNldHMgZm9yIHRoZSB0aGlyZCBzaW1wbGV4IGNvcm5lclxuICAgICAgdmFyIGkzLCBqMywgazMsIGwzOyAvLyBUaGUgaW50ZWdlciBvZmZzZXRzIGZvciB0aGUgZm91cnRoIHNpbXBsZXggY29ybmVyXG4gICAgICAvLyBzaW1wbGV4W2NdIGlzIGEgNC12ZWN0b3Igd2l0aCB0aGUgbnVtYmVycyAwLCAxLCAyIGFuZCAzIGluIHNvbWUgb3JkZXIuXG4gICAgICAvLyBNYW55IHZhbHVlcyBvZiBjIHdpbGwgbmV2ZXIgb2NjdXIsIHNpbmNlIGUuZy4geD55Pno+dyBtYWtlcyB4PHosIHk8dyBhbmQgeDx3XG4gICAgICAvLyBpbXBvc3NpYmxlLiBPbmx5IHRoZSAyNCBpbmRpY2VzIHdoaWNoIGhhdmUgbm9uLXplcm8gZW50cmllcyBtYWtlIGFueSBzZW5zZS5cbiAgICAgIC8vIFdlIHVzZSBhIHRocmVzaG9sZGluZyB0byBzZXQgdGhlIGNvb3JkaW5hdGVzIGluIHR1cm4gZnJvbSB0aGUgbGFyZ2VzdCBtYWduaXR1ZGUuXG4gICAgICAvLyBSYW5rIDMgZGVub3RlcyB0aGUgbGFyZ2VzdCBjb29yZGluYXRlLlxuICAgICAgaTEgPSByYW5reCA+PSAzID8gMSA6IDA7XG4gICAgICBqMSA9IHJhbmt5ID49IDMgPyAxIDogMDtcbiAgICAgIGsxID0gcmFua3ogPj0gMyA/IDEgOiAwO1xuICAgICAgbDEgPSByYW5rdyA+PSAzID8gMSA6IDA7XG4gICAgICAvLyBSYW5rIDIgZGVub3RlcyB0aGUgc2Vjb25kIGxhcmdlc3QgY29vcmRpbmF0ZS5cbiAgICAgIGkyID0gcmFua3ggPj0gMiA/IDEgOiAwO1xuICAgICAgajIgPSByYW5reSA+PSAyID8gMSA6IDA7XG4gICAgICBrMiA9IHJhbmt6ID49IDIgPyAxIDogMDtcbiAgICAgIGwyID0gcmFua3cgPj0gMiA/IDEgOiAwO1xuICAgICAgLy8gUmFuayAxIGRlbm90ZXMgdGhlIHNlY29uZCBzbWFsbGVzdCBjb29yZGluYXRlLlxuICAgICAgaTMgPSByYW5reCA+PSAxID8gMSA6IDA7XG4gICAgICBqMyA9IHJhbmt5ID49IDEgPyAxIDogMDtcbiAgICAgIGszID0gcmFua3ogPj0gMSA/IDEgOiAwO1xuICAgICAgbDMgPSByYW5rdyA+PSAxID8gMSA6IDA7XG4gICAgICAvLyBUaGUgZmlmdGggY29ybmVyIGhhcyBhbGwgY29vcmRpbmF0ZSBvZmZzZXRzID0gMSwgc28gbm8gbmVlZCB0byBjb21wdXRlIHRoYXQuXG4gICAgICB2YXIgeDEgPSB4MCAtIGkxICsgRzQ7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xuICAgICAgdmFyIHkxID0geTAgLSBqMSArIEc0O1xuICAgICAgdmFyIHoxID0gejAgLSBrMSArIEc0O1xuICAgICAgdmFyIHcxID0gdzAgLSBsMSArIEc0O1xuICAgICAgdmFyIHgyID0geDAgLSBpMiArIDIuMCAqIEc0OyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xuICAgICAgdmFyIHkyID0geTAgLSBqMiArIDIuMCAqIEc0O1xuICAgICAgdmFyIHoyID0gejAgLSBrMiArIDIuMCAqIEc0O1xuICAgICAgdmFyIHcyID0gdzAgLSBsMiArIDIuMCAqIEc0O1xuICAgICAgdmFyIHgzID0geDAgLSBpMyArIDMuMCAqIEc0OyAvLyBPZmZzZXRzIGZvciBmb3VydGggY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgIHZhciB5MyA9IHkwIC0gajMgKyAzLjAgKiBHNDtcbiAgICAgIHZhciB6MyA9IHowIC0gazMgKyAzLjAgKiBHNDtcbiAgICAgIHZhciB3MyA9IHcwIC0gbDMgKyAzLjAgKiBHNDtcbiAgICAgIHZhciB4NCA9IHgwIC0gMS4wICsgNC4wICogRzQ7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgIHZhciB5NCA9IHkwIC0gMS4wICsgNC4wICogRzQ7XG4gICAgICB2YXIgejQgPSB6MCAtIDEuMCArIDQuMCAqIEc0O1xuICAgICAgdmFyIHc0ID0gdzAgLSAxLjAgKyA0LjAgKiBHNDtcbiAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgZml2ZSBzaW1wbGV4IGNvcm5lcnNcbiAgICAgIHZhciBpaSA9IGkgJiAyNTU7XG4gICAgICB2YXIgamogPSBqICYgMjU1O1xuICAgICAgdmFyIGtrID0gayAmIDI1NTtcbiAgICAgIHZhciBsbCA9IGwgJiAyNTU7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmaXZlIGNvcm5lcnNcbiAgICAgIHZhciB0MCA9IDAuNiAtIHgwICogeDAgLSB5MCAqIHkwIC0gejAgKiB6MCAtIHcwICogdzA7XG4gICAgICBpZiAodDAgPCAwKSBuMCA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kwID0gKHBlcm1baWkgKyBwZXJtW2pqICsgcGVybVtrayArIHBlcm1bbGxdXV1dICUgMzIpICogNDtcbiAgICAgICAgdDAgKj0gdDA7XG4gICAgICAgIG4wID0gdDAgKiB0MCAqIChncmFkNFtnaTBdICogeDAgKyBncmFkNFtnaTAgKyAxXSAqIHkwICsgZ3JhZDRbZ2kwICsgMl0gKiB6MCArIGdyYWQ0W2dpMCArIDNdICogdzApO1xuICAgICAgfVxuICAgICAgdmFyIHQxID0gMC42IC0geDEgKiB4MSAtIHkxICogeTEgLSB6MSAqIHoxIC0gdzEgKiB3MTtcbiAgICAgIGlmICh0MSA8IDApIG4xID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTEgPSAocGVybVtpaSArIGkxICsgcGVybVtqaiArIGoxICsgcGVybVtrayArIGsxICsgcGVybVtsbCArIGwxXV1dXSAlIDMyKSAqIDQ7XG4gICAgICAgIHQxICo9IHQxO1xuICAgICAgICBuMSA9IHQxICogdDEgKiAoZ3JhZDRbZ2kxXSAqIHgxICsgZ3JhZDRbZ2kxICsgMV0gKiB5MSArIGdyYWQ0W2dpMSArIDJdICogejEgKyBncmFkNFtnaTEgKyAzXSAqIHcxKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MiA9IDAuNiAtIHgyICogeDIgLSB5MiAqIHkyIC0gejIgKiB6MiAtIHcyICogdzI7XG4gICAgICBpZiAodDIgPCAwKSBuMiA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kyID0gKHBlcm1baWkgKyBpMiArIHBlcm1bamogKyBqMiArIHBlcm1ba2sgKyBrMiArIHBlcm1bbGwgKyBsMl1dXV0gJSAzMikgKiA0O1xuICAgICAgICB0MiAqPSB0MjtcbiAgICAgICAgbjIgPSB0MiAqIHQyICogKGdyYWQ0W2dpMl0gKiB4MiArIGdyYWQ0W2dpMiArIDFdICogeTIgKyBncmFkNFtnaTIgKyAyXSAqIHoyICsgZ3JhZDRbZ2kyICsgM10gKiB3Mik7XG4gICAgICB9XG4gICAgICB2YXIgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejMgLSB3MyAqIHczO1xuICAgICAgaWYgKHQzIDwgMCkgbjMgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMyA9IChwZXJtW2lpICsgaTMgKyBwZXJtW2pqICsgajMgKyBwZXJtW2trICsgazMgKyBwZXJtW2xsICsgbDNdXV1dICUgMzIpICogNDtcbiAgICAgICAgdDMgKj0gdDM7XG4gICAgICAgIG4zID0gdDMgKiB0MyAqIChncmFkNFtnaTNdICogeDMgKyBncmFkNFtnaTMgKyAxXSAqIHkzICsgZ3JhZDRbZ2kzICsgMl0gKiB6MyArIGdyYWQ0W2dpMyArIDNdICogdzMpO1xuICAgICAgfVxuICAgICAgdmFyIHQ0ID0gMC42IC0geDQgKiB4NCAtIHk0ICogeTQgLSB6NCAqIHo0IC0gdzQgKiB3NDtcbiAgICAgIGlmICh0NCA8IDApIG40ID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTQgPSAocGVybVtpaSArIDEgKyBwZXJtW2pqICsgMSArIHBlcm1ba2sgKyAxICsgcGVybVtsbCArIDFdXV1dICUgMzIpICogNDtcbiAgICAgICAgdDQgKj0gdDQ7XG4gICAgICAgIG40ID0gdDQgKiB0NCAqIChncmFkNFtnaTRdICogeDQgKyBncmFkNFtnaTQgKyAxXSAqIHk0ICsgZ3JhZDRbZ2k0ICsgMl0gKiB6NCArIGdyYWQ0W2dpNCArIDNdICogdzQpO1xuICAgICAgfVxuICAgICAgLy8gU3VtIHVwIGFuZCBzY2FsZSB0aGUgcmVzdWx0IHRvIGNvdmVyIHRoZSByYW5nZSBbLTEsMV1cbiAgICAgIHJldHVybiAyNy4wICogKG4wICsgbjEgKyBuMiArIG4zICsgbjQpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBidWlsZFBlcm11dGF0aW9uVGFibGUocmFuZG9tKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgcFtpXSA9IGk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTU7IGkrKykge1xuICAgICAgdmFyIHIgPSBpICsgfn4ocmFuZG9tKCkgKiAoMjU2IC0gaSkpO1xuICAgICAgdmFyIGF1eCA9IHBbaV07XG4gICAgICBwW2ldID0gcFtyXTtcbiAgICAgIHBbcl0gPSBhdXg7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG4gIFNpbXBsZXhOb2lzZS5fYnVpbGRQZXJtdXRhdGlvblRhYmxlID0gYnVpbGRQZXJtdXRhdGlvblRhYmxlO1xuXG4gIGZ1bmN0aW9uIGFsZWEoKSB7XG4gICAgLy8gSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4gICAgdmFyIHMwID0gMDtcbiAgICB2YXIgczEgPSAwO1xuICAgIHZhciBzMiA9IDA7XG4gICAgdmFyIGMgPSAxO1xuXG4gICAgdmFyIG1hc2ggPSBtYXNoZXIoKTtcbiAgICBzMCA9IG1hc2goJyAnKTtcbiAgICBzMSA9IG1hc2goJyAnKTtcbiAgICBzMiA9IG1hc2goJyAnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzMCAtPSBtYXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICBpZiAoczAgPCAwKSB7XG4gICAgICAgIHMwICs9IDE7XG4gICAgICB9XG4gICAgICBzMSAtPSBtYXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICBpZiAoczEgPCAwKSB7XG4gICAgICAgIHMxICs9IDE7XG4gICAgICB9XG4gICAgICBzMiAtPSBtYXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICBpZiAoczIgPCAwKSB7XG4gICAgICAgIHMyICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIG1hc2ggPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ID0gMjA5MTYzOSAqIHMwICsgYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgICBzMCA9IHMxO1xuICAgICAgczEgPSBzMjtcbiAgICAgIHJldHVybiBzMiA9IHQgLSAoYyA9IHQgfCAwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG1hc2hlcigpIHtcbiAgICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgICBoIC09IG47XG4gICAgICAgIGggKj0gbjtcbiAgICAgICAgbiA9IGggPj4+IDA7XG4gICAgICAgIGggLT0gbjtcbiAgICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICAgIH1cbiAgICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIH07XG4gIH1cblxuICAvLyBhbWRcbiAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIGRlZmluZShmdW5jdGlvbigpIHtyZXR1cm4gU2ltcGxleE5vaXNlO30pO1xuICAvLyBjb21tb24ganNcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykgZXhwb3J0cy5TaW1wbGV4Tm9pc2UgPSBTaW1wbGV4Tm9pc2U7XG4gIC8vIGJyb3dzZXJcbiAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHdpbmRvdy5TaW1wbGV4Tm9pc2UgPSBTaW1wbGV4Tm9pc2U7XG4gIC8vIG5vZGVqc1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNpbXBsZXhOb2lzZTtcbiAgfVxuXG59KSgpO1xuIiwiLypcbiAoYykgMjAxNywgVmxhZGltaXIgQWdhZm9ua2luXG4gU2ltcGxpZnkuanMsIGEgaGlnaC1wZXJmb3JtYW5jZSBKUyBwb2x5bGluZSBzaW1wbGlmaWNhdGlvbiBsaWJyYXJ5XG4gbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanNcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gdG8gc3VpdCB5b3VyIHBvaW50IGZvcm1hdCwgcnVuIHNlYXJjaC9yZXBsYWNlIGZvciAnLngnIGFuZCAnLnknO1xuLy8gZm9yIDNEIHZlcnNpb24sIHNlZSAzZCBicmFuY2ggKGNvbmZpZ3VyYWJpbGl0eSB3b3VsZCBkcmF3IHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIG92ZXJoZWFkKVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuZnVuY3Rpb24gZ2V0U3FEaXN0KHAxLCBwMikge1xuXG4gICAgdmFyIGR4ID0gcDEueCAtIHAyLngsXG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgcDEsIHAyKSB7XG5cbiAgICB2YXIgeCA9IHAxLngsXG4gICAgICAgIHkgPSBwMS55LFxuICAgICAgICBkeCA9IHAyLnggLSB4LFxuICAgICAgICBkeSA9IHAyLnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyLng7XG4gICAgICAgICAgICB5ID0gcDIueTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBwLnggLSB4O1xuICAgIGR5ID0gcC55IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbi8vIHJlc3Qgb2YgdGhlIGNvZGUgZG9lc24ndCBjYXJlIGFib3V0IHBvaW50IGZvcm1hdFxuXG4vLyBiYXNpYyBkaXN0YW5jZS1iYXNlZCBzaW1wbGlmaWNhdGlvblxuZnVuY3Rpb24gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpIHtcblxuICAgIHZhciBwcmV2UG9pbnQgPSBwb2ludHNbMF0sXG4gICAgICAgIG5ld1BvaW50cyA9IFtwcmV2UG9pbnRdLFxuICAgICAgICBwb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGdldFNxRGlzdChwb2ludCwgcHJldlBvaW50KSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2UG9pbnQgIT09IHBvaW50KSBuZXdQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICAgIHZhciBtYXhTcURpc3QgPSBzcVRvbGVyYW5jZSxcbiAgICAgICAgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIHZhciBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICBpZiAoaW5kZXggLSBmaXJzdCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdKTtcbiAgICAgICAgaWYgKGxhc3QgLSBpbmRleCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICB9XG59XG5cbi8vIHNpbXBsaWZpY2F0aW9uIHVzaW5nIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cbmZ1bmN0aW9uIHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuICAgIHZhciBsYXN0ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgc2ltcGxpZmllZCA9IFtwb2ludHNbMF1dO1xuICAgIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgMCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbbGFzdF0pO1xuXG4gICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbi8vIGJvdGggYWxnb3JpdGhtcyBjb21iaW5lZCBmb3IgYXdlc29tZSBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UsIGhpZ2hlc3RRdWFsaXR5KSB7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSByZXR1cm4gcG9pbnRzO1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyB0b2xlcmFuY2UgKiB0b2xlcmFuY2UgOiAxO1xuXG4gICAgcG9pbnRzID0gaGlnaGVzdFF1YWxpdHkgPyBwb2ludHMgOiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKTtcblxuICAgIHJldHVybiBwb2ludHM7XG59XG5cbi8vIGV4cG9ydCBhcyBBTUQgbW9kdWxlIC8gTm9kZSBtb2R1bGUgLyBicm93c2VyIG9yIHdvcmtlciB2YXJpYWJsZVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2ltcGxpZnk7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBzaW1wbGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5lbHNlIHdpbmRvdy5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuXG59KSgpO1xuIiwibW9kdWxlLmV4cG9ydHM9Ly8gYmdDb2xvdXI6IHN0cmluZztcbi8vIGJnQ29sb3VySW4/OiBzdHJpbmc7XG4vLyBidWlsZGluZ0NvbG91cj86IHN0cmluZztcbi8vIGJ1aWxkaW5nU3Ryb2tlPzogc3RyaW5nO1xuLy8gc2VhQ29sb3VyOiBzdHJpbmc7XG4vLyBncmFzc0NvbG91cj86IHN0cmluZztcbi8vIG1pbm9yUm9hZENvbG91cjogc3RyaW5nO1xuLy8gbWlub3JSb2FkT3V0bGluZT86IHN0cmluZztcbi8vIG1ham9yUm9hZENvbG91cj86IHN0cmluZztcbi8vIG1ham9yUm9hZE91dGxpbmU/OiBzdHJpbmc7XG4vLyBtYWluUm9hZENvbG91cj86IHN0cmluZztcbi8vIG1haW5Sb2FkT3V0bGluZT86IHN0cmluZzsgIC8vIEJlIGNhcmVmdWwsIGluaGVyaXRzIG1ham9yUm9hZE91dGxpbmUsIG5vdCBtYWluUm9hZENvbG91clxuLy8gb3V0bGluZVNpemU/OiBudW1iZXI7ICAgICAgLy8gQ2FzY2FkZSBzZW1hbnRpY3MgaW4gc3R5bGUudHNcbi8vIHpvb21CdWlsZGluZ3M/OiBib29sZWFuO1xuLy8gXG4vLyBTY2hlbWUgbmFtZSBzdGFydHNXaXRoICdEcmF3bicgbWVhbnMgc2NoZW1lIHdpbGwgdXNlIFJvdWdoSlMgY2FudmFzXG5cbntcbiAgICBcIkRlZmF1bHRcIjoge1xuICAgICAgICBcImJnQ29sb3VyXCI6IFwicmdiKDIzNiwyMjksMjE5KVwiLFxuICAgICAgICBcImJ1aWxkaW5nU3Ryb2tlXCI6IFwiIzI4MjgyOFwiLFxuICAgICAgICBcInNlYUNvbG91clwiOiBcIiNhOWQ5ZmVcIixcbiAgICAgICAgXCJncmFzc0NvbG91clwiOiBcIiNjNWU4YzVcIixcbiAgICAgICAgXCJtaW5vclJvYWRPdXRsaW5lXCI6IFwiIzAyMDIwMlwiLFxuICAgICAgICBcIm1pbm9yUm9hZENvbG91clwiOiBcIiNGOEY4RjhcIixcbiAgICAgICAgXCJtYWluUm9hZE91dGxpbmVcIjogXCIjMjgyODI4XCIsXG4gICAgICAgIFwibWFpblJvYWRDb2xvdXJcIjogXCIjRkFGQTdBXCIsXG4gICAgfSxcbiAgICBcIkFwcGxlXCI6IHtcbiAgICAgICAgXCJiZ0NvbG91clwiOiBcInJnYigyNDgsMjQ1LDIzOClcIixcbiAgICAgICAgXCJidWlsZGluZ0NvbG91clwiOiBcInJnYigyMzksMjM2LDIyOSlcIixcbiAgICAgICAgXCJidWlsZGluZ1N0cm9rZVwiOiBcInJnYigyMzUsMjM0LDIyNClcIixcbiAgICAgICAgXCJzZWFDb2xvdXJcIjogXCJyZ2IoMTg0LDIyNCwyNDMpXCIsXG4gICAgICAgIFwiZ3Jhc3NDb2xvdXJcIjogXCJyZ2IoMjI0LDIzNywyMDUpXCIsXG4gICAgICAgIFwibWlub3JSb2FkQ29sb3VyXCI6IFwicmdiKDI1NSwyNTUsMjU1KVwiLFxuICAgICAgICBcIm1pbm9yUm9hZE91dGxpbmVcIjogXCJyZ2IoMjE1LDIwOCwxOTgpXCIsXG4gICAgICAgIFwibWFqb3JSb2FkQ29sb3VyXCI6IFwicmdiKDI1MiwyNTIsMjI0KVwiLFxuICAgICAgICBcIm1ham9yUm9hZE91dGxpbmVcIjogXCJyZ2IoMjQwLDIxMCwxNTIpXCIsXG4gICAgICAgIFwibWFpblJvYWRDb2xvdXJcIjogXCJyZ2IoMjUwLDIyNCw5OClcIixcbiAgICAgICAgXCJtYWluUm9hZE91dGxpbmVcIjogXCJyZ2IoMjM4LDE5OSwxMzIpXCIsXG4gICAgICAgIFwiem9vbUJ1aWxkaW5nc1wiOiB0cnVlLFxuICAgICAgICBcIm91dGxpbmVTaXplXCI6IDIsXG4gICAgfSxcbiAgICBcIkFwcGxlRGFya1wiOiB7XG4gICAgICAgIFwiYmdDb2xvdXJcIjogXCJyZ2IoNDMsNDUsNDcpXCIsXG4gICAgICAgIFwiYnVpbGRpbmdDb2xvdXJcIjogXCJyZ2IoNTIsNTQsNTYpXCIsXG4gICAgICAgIFwiYnVpbGRpbmdTdHJva2VcIjogXCJyZ2IoNDcsNDksNTEpXCIsXG4gICAgICAgIFwic2VhQ29sb3VyXCI6IFwicmdiKDU1LDY4LDEwMClcIixcbiAgICAgICAgXCJncmFzc0NvbG91clwiOiBcInJnYig0MCw1Niw1NilcIixcbiAgICAgICAgXCJtaW5vclJvYWRDb2xvdXJcIjogXCJyZ2IoNjUsNjgsNzEpXCIsXG4gICAgICAgIFwibWlub3JSb2FkT3V0bGluZVwiOiBcInJnYig0Myw0NSw0NylcIixcbiAgICAgICAgXCJtYWpvclJvYWRDb2xvdXJcIjogXCJyZ2IoNzgsODEsODQpXCIsXG4gICAgICAgIFwibWFqb3JSb2FkT3V0bGluZVwiOiBcInJnYig0Myw0NSw0NylcIixcbiAgICAgICAgXCJtYWluUm9hZENvbG91clwiOiBcInJnYigxNDksMTA4LDYyKVwiLFxuICAgICAgICBcIm1haW5Sb2FkT3V0bGluZVwiOiBcInJnYig1MSw1MSw1MSlcIixcbiAgICAgICAgXCJ6b29tQnVpbGRpbmdzXCI6IHRydWUsXG4gICAgICAgIFwib3V0bGluZVNpemVcIjogMSxcbiAgICB9LFxuICAgIFwiQXNzYXNzaW5cIjoge1xuICAgICAgICBcImJnQ29sb3VyXCI6IFwicmdiKDc3LDk2LDg5KVwiLFxuICAgICAgICBcImJ1aWxkaW5nU3Ryb2tlXCI6IFwicmdiKDcyLDkxLDg0KVwiLFxuICAgICAgICBcInNlYUNvbG91clwiOiBcInJnYigzNiw0MCw0MylcIixcbiAgICAgICAgXCJtaW5vclJvYWRDb2xvdXJcIjogXCJyZ2IoMTI3LDE0MSwxMzcpXCIsXG4gICAgICAgIFwibWFpblJvYWRDb2xvdXJcIjogXCJyZ2IoMTQ5LDE2MSwxNTcpXCIsXG4gICAgICAgIFwibWFpblJvYWRPdXRsaW5lXCI6IFwicmdiKDE0OSwxNjEsMTU3KVwiLFxuICAgIH0sXG4gICAgXCJEcmF3biAoc2xvdylcIjogeyAgLy8gU3BlY2lhbCBjYW52YXNcbiAgICAgICAgXCJiZ0NvbG91clwiOiBcInJnYigyNDIsMjM2LDIyMilcIixcbiAgICAgICAgXCJzZWFDb2xvdXJcIjogXCIjZGJkMmJkXCIsXG4gICAgICAgIFwibWlub3JSb2FkQ29sb3VyXCI6IFwiIzY2NjY2NlwiLFxuICAgICAgICBcIm1ham9yUm9hZENvbG91clwiOiBcIiM0NDQ0NDRcIixcbiAgICAgICAgXCJtYWluUm9hZENvbG91clwiOiBcIiMyMjIyMjJcIixcbiAgICAgICAgXCJidWlsZGluZ1N0cm9rZVwiOiBcIiMzMzMzMzNcIixcbiAgICAgICAgXCJidWlsZGluZ0NvbG91clwiOiBcInJnYigyNDIsMjM2LDIyMilcIixcbiAgICB9LFxuICAgIFwiRHJhd24yIChzbG93KVwiOiB7ICAvLyBTcGVjaWFsIGNhbnZhc1xuICAgICAgICBcImJnQ29sb3VyXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJzZWFDb2xvdXJcIjogXCIjYzJjNWJmXCIsXG4gICAgICAgIFwibWlub3JSb2FkQ29sb3VyXCI6IFwiIzY2NjY2NlwiLFxuICAgICAgICBcIm1ham9yUm9hZENvbG91clwiOiBcIiM0NDQ0NDRcIixcbiAgICAgICAgXCJtYWluUm9hZENvbG91clwiOiBcIiMyMjIyMjJcIixcbiAgICAgICAgXCJidWlsZGluZ1N0cm9rZVwiOiBcIiMzMzMzMzNcIixcbiAgICAgICAgXCJidWlsZGluZ0NvbG91clwiOiBcInJnYigyNDIsMjM2LDIyMilcIixcbiAgICB9LFxuICAgIFwiR29vZ2xlXCI6IHtcbiAgICAgICAgXCJiZ0NvbG91clwiOiBcInJnYigyMzYsMjM2LDIzNilcIixcbiAgICAgICAgXCJiZ0NvbG91ckluXCI6IFwicmdiKDI0OCwyNDksMjUwKVwiLFxuICAgICAgICBcImJ1aWxkaW5nQ29sb3VyXCI6IFwicmdiKDI0MCwyNDAsMjQwKVwiLFxuICAgICAgICBcImJ1aWxkaW5nU2lkZUNvbG91clwiOiBcInJnYigyMDAsMjAwLDIwMClcIixcbiAgICAgICAgXCJidWlsZGluZ1N0cm9rZVwiOiBcInJnYigyMjAsMjIwLDIyMClcIixcbiAgICAgICAgXCJzZWFDb2xvdXJcIjogXCJyZ2IoMTY2LDIxMywyNDkpXCIsXG4gICAgICAgIFwiZ3Jhc3NDb2xvdXJcIjogXCJyZ2IoMTk4LDIzMiwxOTgpXCIsXG4gICAgICAgIFwibWlub3JSb2FkQ29sb3VyXCI6IFwicmdiKDI1NSwyNTUsMjU1KVwiLFxuICAgICAgICBcIm1pbm9yUm9hZE91dGxpbmVcIjogXCJyZ2IoMTkzLDE5NywyMTQpXCIsXG4gICAgICAgIFwibWFpblJvYWRDb2xvdXJcIjogXCJyZ2IoMjU1LDI0MiwxNzUpXCIsXG4gICAgICAgIFwibWFpblJvYWRPdXRsaW5lXCI6IFwicmdiKDI0NiwyMDcsMTAxKVwiLFxuICAgICAgICBcInpvb21CdWlsZGluZ3NcIjogdHJ1ZSxcbiAgICAgICAgXCJidWlsZGluZ01vZGVsc1wiOiB0cnVlLFxuICAgICAgICBcIm91dGxpbmVTaXplXCI6IDIsXG4gICAgfSxcbiAgICBcIkdvb2dsZU5vWm9vbVwiOiB7XG4gICAgICAgIFwiYmdDb2xvdXJcIjogXCJyZ2IoMjM2LDIzNiwyMzYpXCIsXG4gICAgICAgIFwiYmdDb2xvdXJJblwiOiBcInJnYigyNDgsMjQ5LDI1MClcIixcbiAgICAgICAgXCJidWlsZGluZ0NvbG91clwiOiBcInJnYigyNDAsMjQwLDI0MClcIixcbiAgICAgICAgXCJidWlsZGluZ1NpZGVDb2xvdXJcIjogXCJyZ2IoMjAwLDIwMCwyMDApXCIsXG4gICAgICAgIFwiYnVpbGRpbmdTdHJva2VcIjogXCJyZ2IoMjIwLDIyMCwyMjApXCIsXG4gICAgICAgIFwic2VhQ29sb3VyXCI6IFwicmdiKDE2NiwyMTMsMjQ5KVwiLFxuICAgICAgICBcImdyYXNzQ29sb3VyXCI6IFwicmdiKDE5OCwyMzIsMTk4KVwiLFxuICAgICAgICBcIm1pbm9yUm9hZENvbG91clwiOiBcInJnYigyNTUsMjU1LDI1NSlcIixcbiAgICAgICAgXCJtaW5vclJvYWRPdXRsaW5lXCI6IFwicmdiKDE5MywxOTcsMjE0KVwiLFxuICAgICAgICBcIm1haW5Sb2FkQ29sb3VyXCI6IFwicmdiKDI1NSwyNDIsMTc1KVwiLFxuICAgICAgICBcIm1haW5Sb2FkT3V0bGluZVwiOiBcInJnYigyNDYsMjA3LDEwMSlcIixcbiAgICAgICAgXCJ6b29tQnVpbGRpbmdzXCI6IGZhbHNlLFxuICAgICAgICBcImJ1aWxkaW5nTW9kZWxzXCI6IHRydWUsXG4gICAgICAgIFwib3V0bGluZVNpemVcIjogMixcbiAgICB9LFxuICAgIFwiUGFwZXJcIjoge1xuICAgICAgICBcImJnQ29sb3VyXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJzZWFDb2xvdXJcIjogXCJyZ2IoMjMzLDI0MCwyNTUpXCIsXG4gICAgICAgIFwiZ3Jhc3NDb2xvdXJcIjogXCJyZ2IoMTk3LDIzMiwxOTcpXCIsXG4gICAgICAgIFwibWlub3JSb2FkQ29sb3VyXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJtaW5vclJvYWRPdXRsaW5lXCI6IFwicmdiKDIyMiwyMjMsMjI3KVwiLFxuICAgICAgICBcIm91dGxpbmVTaXplXCI6IDIsXG4gICAgfSxcbiAgICBcIlN1YnRsZUdyZXlcIjoge1xuICAgICAgICBcImJnQ29sb3VyXCI6IFwicmdiKDI0NywyNDcsMjQ3KVwiLFxuICAgICAgICBcImJ1aWxkaW5nQ29sb3VyXCI6IFwicmdiKDI1MSwyNTEsMjUxKVwiLFxuICAgICAgICBcImJ1aWxkaW5nU3Ryb2tlXCI6IFwicmdiKDI0MywyNDMsMjQzKVwiLFxuICAgICAgICBcInNlYUNvbG91clwiOiBcInJnYigxNjIsMTYyLDE1NylcIixcbiAgICAgICAgXCJncmFzc0NvbG91clwiOiBcInJnYigyMzksMjM5LDIzOSlcIixcbiAgICAgICAgXCJtaW5vclJvYWRPdXRsaW5lXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJtaW5vclJvYWRDb2xvdXJcIjogXCJyZ2IoMjEyLDIxMiwyMTIpXCIsXG4gICAgICAgIFwibWFpblJvYWRPdXRsaW5lXCI6IFwicmdiKDIwOCwyMDgsMjA4KVwiLFxuICAgICAgICBcIm1haW5Sb2FkQ29sb3VyXCI6IFwicmdiKDIwOCwyMDgsMjA4KVwiLFxuICAgICAgICBcImZyYW1lVGV4dENvbG91clwiOiBcInJnYigxNjIsMTYyLDE1NylcIixcbiAgICB9LFxuICAgIFwiVWx0cmFMaWdodFwiOiB7XG4gICAgICAgIFwiYmdDb2xvdXJcIjogXCJyZ2IoMjQ3LDI0NywyNDcpXCIsXG4gICAgICAgIFwic2VhQ29sb3VyXCI6IFwicmdiKDIzNywyMzcsMjM3KVwiLFxuICAgICAgICBcImJ1aWxkaW5nU3Ryb2tlXCI6IFwicmdiKDIzOCwyMzgsMjM4KVwiLFxuICAgICAgICBcImdyYXNzQ29sb3VyXCI6IFwicmdiKDIyOSwyMjksMjI5KVwiLFxuICAgICAgICBcIm1pbm9yUm9hZENvbG91clwiOiBcIndoaXRlXCIsXG4gICAgfSxcbiAgICBcIld5XCI6IHtcbiAgICAgICAgXCJiZ0NvbG91clwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwic2VhQ29sb3VyXCI6IFwicmdiKDIwMCwyMTUsMjEyKVwiLFxuICAgICAgICBcImJ1aWxkaW5nU3Ryb2tlXCI6IFwicmdiKDIzOCwyMzgsMjM4KVwiLFxuICAgICAgICBcIm1pbm9yUm9hZE91dGxpbmVcIjogXCJyZ2IoMTkwLDE5MCwxOTApXCIsXG4gICAgICAgIFwibWlub3JSb2FkQ29sb3VyXCI6IFwicmdiKDIzOCwyMzgsMjM4KVwiLFxuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBkYXQgZnJvbSAnZGF0Lmd1aSc7XG5pbXBvcnQgVGVuc29yRmllbGRHVUkgZnJvbSAnLi90cy91aS90ZW5zb3JfZmllbGRfZ3VpJztcbmltcG9ydCB7Tm9pc2VQYXJhbXN9IGZyb20gJy4vdHMvaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IE1haW5HVUkgZnJvbSAnLi90cy91aS9tYWluX2d1aSc7XG5pbXBvcnQgQ2FudmFzV3JhcHBlciBmcm9tICcuL3RzL3VpL2NhbnZhc193cmFwcGVyJztcbmltcG9ydCB7RGVmYXVsdENhbnZhc1dyYXBwZXIsIFJvdWdoQ2FudmFzV3JhcHBlcn0gZnJvbSAnLi90cy91aS9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgVXRpbCBmcm9tICcuL3RzL3V0aWwnO1xuaW1wb3J0IERyYWdDb250cm9sbGVyIGZyb20gJy4vdHMvdWkvZHJhZ19jb250cm9sbGVyJztcbmltcG9ydCBEb21haW5Db250cm9sbGVyIGZyb20gJy4vdHMvdWkvZG9tYWluX2NvbnRyb2xsZXInO1xuaW1wb3J0IFN0eWxlIGZyb20gJy4vdHMvdWkvc3R5bGUnO1xuaW1wb3J0IHtDb2xvdXJTY2hlbWUsIERlZmF1bHRTdHlsZSwgUm91Z2hTdHlsZX0gZnJvbSAnLi90cy91aS9zdHlsZSc7XG5pbXBvcnQgKiBhcyBDb2xvdXJTY2hlbWVzIGZyb20gJy4vY29sb3VyX3NjaGVtZXMuanNvbic7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4vdHMvdmVjdG9yJztcbmltcG9ydCB7IFNWRyB9IGZyb20gJ0Bzdmdkb3Rqcy9zdmcuanMnO1xuXG5jbGFzcyBNYWluIHtcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG4gICAgcHJpdmF0ZSBndWk6IGRhdC5HVUkgPSBuZXcgZGF0LkdVSSh7d2lkdGg6IDMwMH0pO1xuICAgIHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkR1VJO1xuICAgIHByaXZhdGUgbWFpbkd1aTogTWFpbkdVSTtcbiAgICBwcml2YXRlIGRyYWdDb250cm9sbGVyID0gbmV3IERyYWdDb250cm9sbGVyKHRoaXMuZ3VpKTtcblxuICAgIC8vIE9wdGlvbnNcbiAgICBwcml2YXRlIGltYWdlU2NhbGUgPSAzO1xuXG4gICAgLy8gRm9sZGVyc1xuICAgIHByaXZhdGUgdGVuc29yRm9sZGVyOiBkYXQuR1VJO1xuICAgIHByaXZhdGUgcm9hZHNGb2xkZXI6IGRhdC5HVUk7XG5cbiAgICAvLyBUbyBmb3JjZSBkcmF3IGlmIG5lZWRlZFxuICAgIHByaXZhdGUgcHJldmlvdXNGcmFtZURyYXdUZW5zb3IgPSB0cnVlO1xuXG4gICAgcHJpdmF0ZSBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50O1xuICAgIHByaXZhdGUgdGVuc29yQ2FudmFzOiBEZWZhdWx0Q2FudmFzV3JhcHBlcjtcbiAgICBwcml2YXRlIF9zdHlsZTogU3R5bGU7XG4gICAgcHJpdmF0ZSBzdHlsZUZvbGRlcjogZGF0LkdVSTtcbiAgICBwcml2YXRlIGNvbG91clNjaGVtZTogc3RyaW5nID0gXCJEZWZhdWx0XCI7XG4gICAgcHJpdmF0ZSB6b29tQnVpbGRpbmdzOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBidWlsZGluZ01vZGVsczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgc2hvd0ZyYW1lOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHVibGljIGhpZ2hEUEkgPSBmYWxzZTtcblxuICAgIC8vIDNEIHNldHRpbmdzXG4gICAgcHJpdmF0ZSBjYW1lcmFYID0gMDtcbiAgICBwcml2YXRlIGNhbWVyYVkgPSAwO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBTVEFSVElOR19XSURUSCA9IDE0NDA7XG4gICAgcHJpdmF0ZSBmaXJzdEdlbmVyYXRlID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBDYW52YXMgc2V0dXBcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChVdGlsLkNBTlZBU19JRCkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICAgIHRoaXMudGVuc29yQ2FudmFzID0gbmV3IERlZmF1bHRDYW52YXNXcmFwcGVyKHRoaXMuY2FudmFzKTtcbiAgICAgICAgY29uc3Qgem9vbUNvbnRyb2xsZXIgPSB0aGlzLmd1aS5hZGQodGhpcy5kb21haW5Db250cm9sbGVyLCAnem9vbScpO1xuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuc2V0Wm9vbVVwZGF0ZSgoKSA9PiB6b29tQ29udHJvbGxlci51cGRhdGVEaXNwbGF5KCkpO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgdG9vIHpvb21lZCBvdXQgZm9yIGxhcmdlIHJlc29sdXRpb25zXG4gICAgICAgIGNvbnN0IHNjcmVlbldpZHRoID0gdGhpcy5kb21haW5Db250cm9sbGVyLnNjcmVlbkRpbWVuc2lvbnMueDtcbiAgICAgICAgaWYgKHNjcmVlbldpZHRoID4gdGhpcy5TVEFSVElOR19XSURUSCkge1xuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSBzY3JlZW5XaWR0aCAvIHRoaXMuU1RBUlRJTkdfV0lEVEg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHVUkgU2V0dXBcbiAgICAgICAgdGhpcy5ndWkuYWRkKHRoaXMsICdnZW5lcmF0ZScpO1xuICAgICAgICB0aGlzLnN0eWxlRm9sZGVyID0gdGhpcy5ndWkuYWRkRm9sZGVyKCdTdHlsZScpO1xuICAgICAgICB0aGlzLnN0eWxlRm9sZGVyLmFkZCh0aGlzLCAnY29sb3VyU2NoZW1lJywgT2JqZWN0LmtleXMoQ29sb3VyU2NoZW1lcykpLm9uQ2hhbmdlKCh2YWw6IHN0cmluZykgPT4gdGhpcy5jaGFuZ2VDb2xvdXJTY2hlbWUodmFsKSk7XG5cbiAgICAgICAgdGhpcy5zdHlsZUZvbGRlci5hZGQodGhpcywgJ3pvb21CdWlsZGluZ3MnKS5vbkNoYW5nZSgodmFsOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICAvLyBGb3JjZSByZWRyYXdcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNGcmFtZURyYXdUZW5zb3IgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc3R5bGUuem9vbUJ1aWxkaW5ncyA9IHZhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdHlsZUZvbGRlci5hZGQodGhpcywgJ2J1aWxkaW5nTW9kZWxzJykub25DaGFuZ2UoKHZhbDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgLy8gRm9yY2UgcmVkcmF3XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzRnJhbWVEcmF3VGVuc29yID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlLnNob3dCdWlsZGluZ01vZGVscyA9IHZhbDtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnN0eWxlRm9sZGVyLmFkZCh0aGlzLCAnc2hvd0ZyYW1lJykub25DaGFuZ2UoKHZhbDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0ZyYW1lRHJhd1RlbnNvciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZS5zaG93RnJhbWUgPSB2YWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc3R5bGVGb2xkZXIuYWRkKHRoaXMuZG9tYWluQ29udHJvbGxlciwgJ29ydGhvZ3JhcGhpYycpO1xuICAgICAgICB0aGlzLnN0eWxlRm9sZGVyLmFkZCh0aGlzLCAnY2FtZXJhWCcsIC0xNSwgMTUpLnN0ZXAoMSkub25DaGFuZ2UoKCkgPT4gdGhpcy5zZXRDYW1lcmFEaXJlY3Rpb24oKSk7XG4gICAgICAgIHRoaXMuc3R5bGVGb2xkZXIuYWRkKHRoaXMsICdjYW1lcmFZJywgLTE1LCAxNSkuc3RlcCgxKS5vbkNoYW5nZSgoKSA9PiB0aGlzLnNldENhbWVyYURpcmVjdGlvbigpKTtcblxuICAgICAgICBjb25zdCBub2lzZVBhcmFtczogTm9pc2VQYXJhbXMgPSB7XG4gICAgICAgICAgICBnbG9iYWxOb2lzZTogZmFsc2UsXG4gICAgICAgICAgICBub2lzZVNpemVQYXJrOiAyMCxcbiAgICAgICAgICAgIG5vaXNlQW5nbGVQYXJrOiA5MCxcbiAgICAgICAgICAgIG5vaXNlU2l6ZUdsb2JhbDogMzAsXG4gICAgICAgICAgICBub2lzZUFuZ2xlR2xvYmFsOiAyMFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudGVuc29yRm9sZGVyID0gdGhpcy5ndWkuYWRkRm9sZGVyKCdUZW5zb3IgRmllbGQnKTtcbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZCA9IG5ldyBUZW5zb3JGaWVsZEdVSSh0aGlzLnRlbnNvckZvbGRlciwgdGhpcy5kcmFnQ29udHJvbGxlciwgdHJ1ZSwgbm9pc2VQYXJhbXMpO1xuICAgICAgICB0aGlzLnJvYWRzRm9sZGVyID0gdGhpcy5ndWkuYWRkRm9sZGVyKCdNYXAnKTtcbiAgICAgICAgdGhpcy5tYWluR3VpID0gbmV3IE1haW5HVUkodGhpcy5yb2Fkc0ZvbGRlciwgdGhpcy50ZW5zb3JGaWVsZCwgKCkgPT4gdGhpcy50ZW5zb3JGb2xkZXIuY2xvc2UoKSk7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9uc0ZvbGRlciA9IHRoaXMuZ3VpLmFkZEZvbGRlcignT3B0aW9ucycpO1xuICAgICAgICBvcHRpb25zRm9sZGVyLmFkZCh0aGlzLnRlbnNvckZpZWxkLCAnZHJhd0NlbnRyZScpO1xuICAgICAgICBjb25zdCBjYW52YXNTY2FsZUNvbnRyb2xsZXIgPSBvcHRpb25zRm9sZGVyLmFkZCh0aGlzLCAnaGlnaERQSScpO1xuICAgICAgICBjYW52YXNTY2FsZUNvbnRyb2xsZXIub25DaGFuZ2UoKGhpZ2g6IGJvb2xlYW4pID0+IHRoaXMuY2hhbmdlQ2FudmFzU2NhbGUoaGlnaCkpO1xuICAgICAgICBvcHRpb25zRm9sZGVyLmFkZCh0aGlzLCAnaW1hZ2VTY2FsZScsIDEsIDUpLnN0ZXAoMSk7XG4gICAgICAgIG9wdGlvbnNGb2xkZXIuYWRkKHRoaXMsICdkb3dubG9hZCcpO1xuICAgICAgICBvcHRpb25zRm9sZGVyLmFkZCh0aGlzLCAnZG93bmxvYWRTVkcnKTtcblxuICAgICAgICB0aGlzLmNoYW5nZUNvbG91clNjaGVtZSh0aGlzLmNvbG91clNjaGVtZSk7XG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuc2V0UmVjb21tZW5kZWQoKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGdlbmVyYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmlyc3RHZW5lcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5zZXRSZWNvbW1lbmRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maXJzdEdlbmVyYXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMubWFpbkd1aS5nZW5lcmF0ZUV2ZXJ5dGhpbmcoKTtcbiAgICB9XG5cbiAgICBjaGFuZ2VDb2xvdXJTY2hlbWUoc2NoZW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29sb3VyU2NoZW1lOiBDb2xvdXJTY2hlbWUgPSAoQ29sb3VyU2NoZW1lcyBhcyBhbnkpW3NjaGVtZV07XG4gICAgICAgIHRoaXMuem9vbUJ1aWxkaW5ncyA9IGNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzO1xuICAgICAgICB0aGlzLmJ1aWxkaW5nTW9kZWxzID0gY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzO1xuICAgICAgICBVdGlsLnVwZGF0ZUd1aSh0aGlzLnN0eWxlRm9sZGVyKTtcbiAgICAgICAgaWYgKHNjaGVtZS5zdGFydHNXaXRoKFwiRHJhd25cIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gbmV3IFJvdWdoU3R5bGUodGhpcy5jYW52YXMsIHRoaXMuZHJhZ0NvbnRyb2xsZXIsIE9iamVjdC5hc3NpZ24oe30sIGNvbG91clNjaGVtZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgRGVmYXVsdFN0eWxlKHRoaXMuY2FudmFzLCB0aGlzLmRyYWdDb250cm9sbGVyLCBPYmplY3QuYXNzaWduKHt9LCBjb2xvdXJTY2hlbWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdHlsZS5zaG93RnJhbWUgPSB0aGlzLnNob3dGcmFtZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VDYW52YXNTY2FsZSh0aGlzLmhpZ2hEUEkpO1xuICAgIH1cblxuICAgIGNoYW5nZUNhbnZhc1NjYWxlKGhpZ2g6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBoaWdoID8gMiA6IDE7XG4gICAgICAgIHRoaXMuX3N0eWxlLmNhbnZhc1NjYWxlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudGVuc29yQ2FudmFzLmNhbnZhc1NjYWxlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgc2V0Q2FtZXJhRGlyZWN0aW9uKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3Rvcih0aGlzLmNhbWVyYVggLyAxMCwgdGhpcy5jYW1lcmFZIC8gMTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBpbWFnZSBvZiBtYXBcbiAgICAgKiBEcmF3cyBvbnRvIGhpZGRlbiBjYW52YXMgYXQgcmVxdWVzdGVkIHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkb3dubG9hZCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFV0aWwuSU1HX0NBTlZBU19JRCkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG5cbiAgICAgICAgLy8gRHJhd1xuICAgICAgICBpZiAodGhpcy5zaG93VGVuc29yRmllbGQoKSkge1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5kcmF3KG5ldyBEZWZhdWx0Q2FudmFzV3JhcHBlcihjLCB0aGlzLmltYWdlU2NhbGUsIGZhbHNlKSk7XG4gICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBpbWdDYW52YXMgPSB0aGlzLl9zdHlsZS5jcmVhdGVDYW52YXNXcmFwcGVyKGMsIHRoaXMuaW1hZ2VTY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5tYWluR3VpLmRyYXcodGhpcy5fc3R5bGUsIHRydWUsIGltZ0NhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBsaW5rLmRvd25sb2FkID0gJ21hcC5wbmcnO1xuICAgICAgICBsaW5rLmhyZWYgPSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVXRpbC5JTUdfQ0FOVkFTX0lEKSBhcyBhbnkpLnRvRGF0YVVSTCgpO1xuICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIHN2ZyBvZiBtYXBcbiAgICAgKiBEcmF3cyBvbnRvIGhpZGRlbiBzdmcgYXQgcmVxdWVzdGVkIHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkb3dubG9hZFNWRygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFV0aWwuSU1HX0NBTlZBU19JRCkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChVdGlsLlNWR19JRCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd1RlbnNvckZpZWxkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGltZ0NhbnZhcyA9IG5ldyBEZWZhdWx0Q2FudmFzV3JhcHBlcihjLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICBpbWdDYW52YXMuY3JlYXRlU1ZHKHN2Z0VsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5kcmF3KGltZ0NhbnZhcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbWdDYW52YXMgPSB0aGlzLl9zdHlsZS5jcmVhdGVDYW52YXNXcmFwcGVyKGMsIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIGltZ0NhbnZhcy5jcmVhdGVTVkcoc3ZnRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLm1haW5HdWkuZHJhdyh0aGlzLl9zdHlsZSwgdHJ1ZSwgaW1nQ2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgICBsZXQgc291cmNlID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdFbGVtZW50KTtcbiAgICAgICAgLy9hZGQgbmFtZSBzcGFjZXMuXG4gICAgICAgIGlmKCFzb3VyY2UubWF0Y2goL148c3ZnW14+XSt4bWxucz1cImh0dHBcXDpcXC9cXC93d3dcXC53M1xcLm9yZ1xcLzIwMDBcXC9zdmdcIi8pKXtcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC9ePHN2Zy8sICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFzb3VyY2UubWF0Y2goL148c3ZnW14+XStcImh0dHBcXDpcXC9cXC93d3dcXC53M1xcLm9yZ1xcLzE5OTlcXC94bGlua1wiLykpe1xuICAgICAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UoL148c3ZnLywgJzxzdmcgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYWRkIHhtbCBkZWNsYXJhdGlvblxuICAgICAgICBzb3VyY2UgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIHN0YW5kYWxvbmU9XCJub1wiPz5cXHJcXG4nICsgc291cmNlO1xuXG4gICAgICAgIC8vY29udmVydCBzdmcgc291cmNlIHRvIFVSSSBkYXRhIHNjaGVtZS5cbiAgICAgICAgY29uc3QgdXJsID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCxcIitlbmNvZGVVUklDb21wb25lbnQoc291cmNlKTtcblxuICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBsaW5rLmRvd25sb2FkID0gJ21hcC5zdmcnO1xuICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICAgIGxpbmsuY2xpY2soKTtcblxuICAgICAgICAvLyBDbGVhciBTVkdcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IFNWRyhzdmdFbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5jbGVhcigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2hvd1RlbnNvckZpZWxkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMudGVuc29yRm9sZGVyLmNsb3NlZCB8fCB0aGlzLm1haW5HdWkucm9hZHNFbXB0eSgpO1xuICAgIH1cblxuICAgIGRyYXcoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNob3dUZW5zb3JGaWVsZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzRnJhbWVEcmF3VGVuc29yID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbnRyb2xsZXIuc2V0RHJhZ0Rpc2FibGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMudGVuc29yRmllbGQuZHJhdyh0aGlzLnRlbnNvckNhbnZhcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXNhYmxlIGZpZWxkIGRyYWcgYW5kIGRyb3BcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbnRyb2xsZXIuc2V0RHJhZ0Rpc2FibGVkKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c0ZyYW1lRHJhd1RlbnNvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNGcmFtZURyYXdUZW5zb3IgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIHJlZHJhdyBpZiBzd2l0Y2hpbmcgZnJvbSB0ZW5zb3IgZmllbGRcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5HdWkuZHJhdyh0aGlzLl9zdHlsZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbkd1aS5kcmF3KHRoaXMuX3N0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3R5bGUudXBkYXRlKCk7XG4gICAgICAgIHRoaXMubWFpbkd1aS51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG59XG5cbih3aW5kb3cgYXMgYW55KS5sb2cgPSBsb2c7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpOiB2b2lkID0+IHtcbiAgICBuZXcgTWFpbigpO1xufSk7XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB4OiBudW1iZXIsIHB1YmxpYyB5OiBudW1iZXIpIHt9XG5cbiAgICBzdGF0aWMgemVyb1ZlY3RvcigpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihzLCBzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAtcGkgdG8gcGlcbiAgICAgKi9cbiAgICBzdGF0aWMgYW5nbGVCZXR3ZWVuKHYxOiBWZWN0b3IsIHYyOiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICAvLyAtMnBpIHRvIDJwaVxuICAgICAgICBsZXQgYW5nbGVCZXR3ZWVuID0gdjEuYW5nbGUoKSAtIHYyLmFuZ2xlKCk7XG4gICAgICAgIGlmIChhbmdsZUJldHdlZW4gPiBNYXRoLlBJKSB7XG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gLT0gMiAqIE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5nbGVCZXR3ZWVuIDw9IC1NYXRoLlBJKSB7XG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuZ2xlQmV0d2VlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIGEgcG9pbnQgbGllcyB0byB0aGUgbGVmdCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IGxpbmVQb2ludCAgICAgUG9pbnQgb24gdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IGxpbmVEaXJlY3Rpb24gXG4gICAgICogQHBhcmFtICB7VmVjdG9yfSBwb2ludFxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gICAgICAgICAgICAgICB0cnVlIGlmIGxlZnQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0xlZnQobGluZVBvaW50OiBWZWN0b3IsIGxpbmVEaXJlY3Rpb246IFZlY3RvciwgcG9pbnQ6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBwZXJwZW5kaWN1bGFyVmVjdG9yID0gbmV3IFZlY3RvcihsaW5lRGlyZWN0aW9uLnksIC1saW5lRGlyZWN0aW9uLngpO1xuICAgICAgICByZXR1cm4gcG9pbnQuY2xvbmUoKS5zdWIobGluZVBvaW50KS5kb3QocGVycGVuZGljdWxhclZlY3RvcikgPCAwO1xuICAgIH1cblxuICAgIGFkZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKz0gdi54O1xuICAgICAgICB0aGlzLnkgKz0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBpbiByYWRpYW5zIHRvIHBvc2l0aXZlIHgtYXhpcyBiZXR3ZWVuIC1waSBhbmQgcGlcbiAgICAgKi9cbiAgICBhbmdsZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cblxuICAgIGNvcHkodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgICB0aGlzLnkgPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNyb3NzKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG4gICAgfVxuXG4gICAgZGlzdGFuY2VUbyh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xuICAgIH1cblxuICAgIGRpc3RhbmNlVG9TcXVhcmVkICh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkeCA9IHRoaXMueCAtIHYueFxuICAgICAgICBjb25zdCBkeSA9IHRoaXMueSAtIHYueTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH1cblxuICAgIGRpdmlkZSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICBpZiAodi54ID09PSAwIHx8IHYueSA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggLz0gdi54O1xuICAgICAgICB0aGlzLnkgLz0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkaXZpZGVTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiRGl2aXNpb24gYnkgemVyb1wiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzKTtcbiAgICB9XG5cbiAgICBkb3QodjogVmVjdG9yKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcbiAgICB9XG5cbiAgICBlcXVhbHModjogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoKHYueCA9PT0gdGhpcy54KSAmJiAodi55ID09PSB0aGlzLnkpKTtcbiAgICB9XG5cbiAgICBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkpO1xuICAgIH1cblxuICAgIGxlbmd0aFNxKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG4gICAgfVxuXG4gICAgbXVsdGlwbHkodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ICo9IHYueDtcbiAgICAgICAgdGhpcy55ICo9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbXVsdGlwbHlTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ICo9IHM7XG4gICAgICAgIHRoaXMueSAqPSBzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBuZWdhdGUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoLTEpO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZSgpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiWmVybyBWZWN0b3JcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICByb3RhdGVBcm91bmQoY2VudGVyOiBWZWN0b3IsIGFuZ2xlOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSlcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnggLSBjZW50ZXIueDtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIGNlbnRlci55O1xuXG4gICAgICAgIHRoaXMueCA9IHggKiBjb3MgLSB5ICogc2luICsgY2VudGVyLng7XG4gICAgICAgIHRoaXMueSA9IHggKiBzaW4gKyB5ICogY29zICsgY2VudGVyLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0WCh4OiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRZKHk6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldExlbmd0aCAobGVuZ3RoOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgIH1cblxuICAgIHN1Yih2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgICB0aGlzLnkgLT0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCJpbXBvcnQgVGVuc29yIGZyb20gJy4vdGVuc29yJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2lzRmllbGQge1xuICAgIGFic3RyYWN0IHJlYWRvbmx5IEZPTERFUl9OQU1FOiBzdHJpbmc7XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBmb2xkZXJOYW1lSW5kZXg6IG51bWJlciA9IDA7XG4gICAgcHJvdGVjdGVkIF9jZW50cmU6IFZlY3RvcjtcblxuICAgIGNvbnN0cnVjdG9yKGNlbnRyZTogVmVjdG9yLCBwcm90ZWN0ZWQgX3NpemU6IG51bWJlciwgcHJvdGVjdGVkIF9kZWNheTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2NlbnRyZSA9IGNlbnRyZS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHNldCBjZW50cmUoY2VudHJlOiBWZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fY2VudHJlLmNvcHkoY2VudHJlKTtcbiAgICB9XG5cbiAgICBnZXQgY2VudHJlKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jZW50cmUuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBzZXQgZGVjYXkoZGVjYXk6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9kZWNheSA9IGRlY2F5O1xuICAgIH1cblxuICAgIHNldCBzaXplKHNpemU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB9XG5cbiAgICBkcmFnTW92ZUxpc3RlbmVyKGRlbHRhOiBWZWN0b3IpOiB2b2lkIHtcbiAgICAgICAgLy8gRGVsdGEgYXNzdW1lZCB0byBiZSBpbiB3b3JsZCBzcGFjZSAob25seSByZWxldmFudCB3aGVuIHpvb21lZClcbiAgICAgICAgdGhpcy5fY2VudHJlLmFkZChkZWx0YSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0VGVuc29yKHBvaW50OiBWZWN0b3IpOiBUZW5zb3I7XG5cbiAgICBnZXRXZWlnaHRlZFRlbnNvcihwb2ludDogVmVjdG9yKTogVGVuc29yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGVuc29yKHBvaW50KS5zY2FsZSh0aGlzLmdldFRlbnNvcldlaWdodChwb2ludCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmb2xkZXIgYW5kIGFkZHMgaXQgdG8gdGhlIEdVSSB0byBjb250cm9sIHBhcmFtc1xuICAgICAqL1xuICAgIHNldEd1aShndWk6IGRhdC5HVUkpOiB2b2lkIHtcbiAgICAgICAgZ3VpLmFkZCh0aGlzLl9jZW50cmUsICd4Jyk7XG4gICAgICAgIGd1aS5hZGQodGhpcy5fY2VudHJlLCAneScpO1xuICAgICAgICBndWkuYWRkKHRoaXMsICdfc2l6ZScpO1xuICAgICAgICBndWkuYWRkKHRoaXMsICdfZGVjYXknLCAwLCA1MCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJwb2xhdGVzIGJldHdlZW4gKDAgYW5kIDEpXmRlY2F5XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldFRlbnNvcldlaWdodChwb2ludDogVmVjdG9yKTogbnVtYmVyIHsgICAgICAgIFxuICAgICAgICBjb25zdCBub3JtRGlzdGFuY2VUb0NlbnRyZSA9IHBvaW50LmNsb25lKCkuc3ViKHRoaXMuX2NlbnRyZSkubGVuZ3RoKCkgLyB0aGlzLl9zaXplO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcCAoKiogMCkgdHVybmluZyB3ZWlnaHQgaW50byAxLCBmaWxsaW5nIHNjcmVlbiBldmVuIHdoZW4gb3V0c2lkZSAnc2l6ZSdcbiAgICAgICAgaWYgKHRoaXMuX2RlY2F5ID09PSAwICYmIG5vcm1EaXN0YW5jZVRvQ2VudHJlID49IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCAoMSAtIG5vcm1EaXN0YW5jZVRvQ2VudHJlKSkgKiogdGhpcy5fZGVjYXk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgR3JpZCBleHRlbmRzIEJhc2lzRmllbGQge1xuICAgIHJlYWRvbmx5IEZPTERFUl9OQU1FID0gYEdyaWQgJHtHcmlkLmZvbGRlck5hbWVJbmRleCsrfWA7XG5cbiAgICBjb25zdHJ1Y3RvcihjZW50cmU6IFZlY3Rvciwgc2l6ZTogbnVtYmVyLCBkZWNheTogbnVtYmVyLCBwcml2YXRlIF90aGV0YTogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKGNlbnRyZSwgc2l6ZSwgZGVjYXkpO1xuICAgIH1cblxuICAgIHNldCB0aGV0YSh0aGV0YTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3RoZXRhID0gdGhldGE7XG4gICAgfVxuXG4gICAgc2V0R3VpKGd1aTogZGF0LkdVSSk6IHZvaWQge1xuICAgICAgICBzdXBlci5zZXRHdWkoZ3VpKTtcblxuICAgICAgICAvLyBHVUkgaW4gZGVncmVlcywgY29udmVydCB0byByYWRzXG4gICAgICAgIGNvbnN0IHRoZXRhUHJvcCA9IHt0aGV0YTogdGhpcy5fdGhldGEgKiAxODAgLyBNYXRoLlBJfTtcbiAgICAgICAgY29uc3QgdGhldGFDb250cm9sbGVyID0gZ3VpLmFkZCh0aGV0YVByb3AsICd0aGV0YScsIC05MCwgOTApO1xuICAgICAgICB0aGV0YUNvbnRyb2xsZXIub25DaGFuZ2UodGhldGEgPT4gdGhpcy5fdGhldGEgPSB0aGV0YSAqIChNYXRoLlBJIC8gMTgwKSk7XG4gICAgfVxuXG4gICAgZ2V0VGVuc29yKHBvaW50OiBWZWN0b3IpOiBUZW5zb3Ige1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcygyICogdGhpcy5fdGhldGEpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbigyICogdGhpcy5fdGhldGEpO1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigxLCBbY29zLCBzaW5dKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSYWRpYWwgZXh0ZW5kcyBCYXNpc0ZpZWxkIHtcbiAgICByZWFkb25seSBGT0xERVJfTkFNRSA9IGBSYWRpYWwgJHtSYWRpYWwuZm9sZGVyTmFtZUluZGV4Kyt9YDtcbiAgICBjb25zdHJ1Y3RvcihjZW50cmU6IFZlY3Rvciwgc2l6ZTogbnVtYmVyLCBkZWNheTogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKGNlbnRyZSwgc2l6ZSwgZGVjYXkpO1xuICAgIH1cblxuICAgIGdldFRlbnNvcihwb2ludDogVmVjdG9yKTogVGVuc29yIHtcbiAgICAgICAgY29uc3QgdCA9IHBvaW50LmNsb25lKCkuc3ViKHRoaXMuX2NlbnRyZSk7XG4gICAgICAgIGNvbnN0IHQxID0gdC55KioyIC0gdC54KioyO1xuICAgICAgICBjb25zdCB0MiA9IC0yICogdC54ICogdC55O1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigxLCBbdDEsIHQyXSk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCAqIGFzIGlzZWN0IGZyb20gJ2lzZWN0JztcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzLXF1YWR0cmVlJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuZGVjbGFyZSBtb2R1bGUgJ2lzZWN0JyB7XG4gICAgZXhwb3J0IGZ1bmN0aW9uIGJ1c2gobGluZXM6IFNlZ21lbnRbXSk6IERldGVjdEludGVyc2VjdGlvbnM7XG59XG5cbmludGVyZmFjZSBEZXRlY3RJbnRlcnNlY3Rpb25zIHtcbiAgICBydW46ICgpID0+IEludGVyc2VjdGlvbltdO1xufVxuXG5pbnRlcmZhY2UgU2VnbWVudCB7XG4gICAgZnJvbTogVmVjdG9yO1xuICAgIHRvOiBWZWN0b3I7XG59XG5cbmludGVyZmFjZSBJbnRlcnNlY3Rpb24ge1xuICAgIHBvaW50OiBWZWN0b3I7XG4gICAgc2VnbWVudHM6IFNlZ21lbnRbXTtcbn1cblxuZXhwb3J0IGNsYXNzIE5vZGUge1xuICAgIHB1YmxpYyBzZWdtZW50cyA9IG5ldyBTZXQ8U2VnbWVudD4oKTtcbiAgICBwdWJsaWMgYWRqOiBOb2RlW107XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IFZlY3RvciwgcHVibGljIG5laWdoYm9ycz1uZXcgU2V0PE5vZGU+KCkpIHt9XG5cbiAgICBhZGRTZWdtZW50KHNlZ21lbnQ6IFNlZ21lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZWdtZW50cy5hZGQoc2VnbWVudCk7XG4gICAgfVxuXG4gICAgYWRkTmVpZ2hib3Iobm9kZTogTm9kZSk6IHZvaWQge1xuICAgICAgICBpZiAobm9kZSAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcnMuYWRkKG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5uZWlnaGJvcnMuYWRkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaCB7XG4gICAgcHVibGljIG5vZGVzOiBOb2RlW107XG4gICAgcHVibGljIGludGVyc2VjdGlvbnM6IFZlY3RvcltdO1xuXG4gICAgY29uc3RydWN0b3Ioc3RyZWFtbGluZXM6IFZlY3RvcltdW10sIGRzdGVwOiBudW1iZXIsIGRlbGV0ZURhbmdsaW5nPWZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBpc2VjdC5idXNoKHRoaXMuc3RyZWFtbGluZXNUb1NlZ21lbnQoc3RyZWFtbGluZXMpKS5ydW4oKTtcbiAgICAgICAgY29uc3QgcXVhZHRyZWUgPSAoZDMucXVhZHRyZWUoKSBhcyBkMy5RdWFkdHJlZTxOb2RlPikueChuID0+IG4udmFsdWUueCkueShuID0+IG4udmFsdWUueSk7XG4gICAgICAgIGNvbnN0IG5vZGVBZGRSYWRpdXMgPSAwLjAwMTtcblxuICAgICAgICAvLyBBZGQgYWxsIHNlZ21lbnQgc3RhcnQgYW5kIGVuZHBvaW50c1xuICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2Ygc3RyZWFtbGluZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZShzdHJlYW1saW5lW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRTZWdtZW50KHRoaXMudmVjdG9yc1RvU2VnbWVudChzdHJlYW1saW5lW2kgLSAxXSwgc3RyZWFtbGluZVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgc3RyZWFtbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkU2VnbWVudCh0aGlzLnZlY3RvcnNUb1NlZ21lbnQoc3RyZWFtbGluZVtpXSwgc3RyZWFtbGluZVtpICsgMV0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZ1enp5QWRkVG9RdWFkdHJlZShxdWFkdHJlZSwgbm9kZSwgbm9kZUFkZFJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYWxsIGludGVyc2VjdGlvbnNcbiAgICAgICAgZm9yIChjb25zdCBpbnRlcnNlY3Rpb24gb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKG5ldyBWZWN0b3IoaW50ZXJzZWN0aW9uLnBvaW50LngsIGludGVyc2VjdGlvbi5wb2ludC55KSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgaW50ZXJzZWN0aW9uLnNlZ21lbnRzKSBub2RlLmFkZFNlZ21lbnQocyk7XG4gICAgICAgICAgICB0aGlzLmZ1enp5QWRkVG9RdWFkdHJlZShxdWFkdHJlZSwgbm9kZSwgbm9kZUFkZFJhZGl1cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgZWFjaCBzaW1wbGlmaWVkIHN0cmVhbWxpbmUsIGJ1aWxkIGxpc3Qgb2Ygbm9kZXMgaW4gb3JkZXIgYWxvbmcgc3RyZWFtbGluZVxuICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2Ygc3RyZWFtbGluZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2Rlc0Fsb25nU2VnbWVudCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Tm9kZXNBbG9uZ1NlZ21lbnQodGhpcy52ZWN0b3JzVG9TZWdtZW50KHN0cmVhbWxpbmVbaV0sIHN0cmVhbWxpbmVbaSArIDFdKSwgcXVhZHRyZWUsIG5vZGVBZGRSYWRpdXMsIGRzdGVwKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobm9kZXNBbG9uZ1NlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVzQWxvbmdTZWdtZW50Lmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNBbG9uZ1NlZ21lbnRbal0uYWRkTmVpZ2hib3Iobm9kZXNBbG9uZ1NlZ21lbnRbaisxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJFcnJvciBHcmFwaC5qczogc2VnbWVudCB3aXRoIGxlc3MgdGhhbiAyIG5vZGVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFxuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgcXVhZHRyZWUuZGF0YSgpKSB7XG4gICAgICAgICAgICBpZiAoZGVsZXRlRGFuZ2xpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZURhbmdsaW5nTm9kZXMobiwgcXVhZHRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4uYWRqID0gQXJyYXkuZnJvbShuLm5laWdoYm9ycyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vZGVzID0gcXVhZHRyZWUuZGF0YSgpO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGludGVyc2VjdGlvbnMpIHRoaXMuaW50ZXJzZWN0aW9ucy5wdXNoKG5ldyBWZWN0b3IoaS5wb2ludC54LCBpLnBvaW50LnkpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlbGV0ZURhbmdsaW5nTm9kZXMobjogTm9kZSwgcXVhZHRyZWU6IGQzLlF1YWR0cmVlPE5vZGU+KSB7XG4gICAgICAgIGlmIChuLm5laWdoYm9ycy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICBxdWFkdHJlZS5yZW1vdmUobik7XG4gICAgICAgICAgICBmb3IgKGxldCBuZWlnaGJvciBvZiBuLm5laWdoYm9ycykge1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLm5laWdoYm9ycy5kZWxldGUobik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVEYW5nbGluZ05vZGVzKG5laWdoYm9yLCBxdWFkdHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE5vZGVzQWxvbmdTZWdtZW50KHNlZ21lbnQ6IFNlZ21lbnQsIHF1YWR0cmVlOiBkMy5RdWFkdHJlZTxOb2RlPiwgcmFkaXVzOiBudW1iZXIsIHN0ZXA6IG51bWJlcik6IE5vZGVbXSB7XG4gICAgICAgIC8vIFdhbGsgZHN0ZXAgYWxvbmcgZWFjaCBzdHJlYW1saW5lLCBhZGRpbmcgbm9kZXMgd2l0aGluIGRzdGVwLzJcbiAgICAgICAgLy8gYW5kIGNvbm5lY3RlZCB0byB0aGlzIHN0cmVhbWxpbmUgKGZ1enp5IC0gbm9kZUFkZFJhZGl1cykgdG8gbGlzdCwgcmVtb3ZpbmcgZnJvbVxuICAgICAgICAvLyBxdWFkdHJlZSBhbmQgYWRkaW5nIHRoZW0gYWxsIGJhY2sgYXQgdGhlIGVuZFxuXG4gICAgICAgIGNvbnN0IGZvdW5kTm9kZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgbm9kZXNBbG9uZ1NlZ21lbnQ6IE5vZGVbXSA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IFZlY3RvcihzZWdtZW50LmZyb20ueCwgc2VnbWVudC5mcm9tLnkpO1xuICAgICAgICBjb25zdCBlbmQgPSBuZXcgVmVjdG9yKHNlZ21lbnQudG8ueCwgc2VnbWVudC50by55KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRpZmZlcmVuY2VWZWN0b3IgPSBlbmQuY2xvbmUoKS5zdWIoc3RhcnQpO1xuICAgICAgICBzdGVwID0gTWF0aC5taW4oc3RlcCwgZGlmZmVyZW5jZVZlY3Rvci5sZW5ndGgoKSAvIDIpOyAgLy8gTWluIG9mIDIgc3RlcCBhbG9uZyB2ZWN0b3JcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBNYXRoLmNlaWwoZGlmZmVyZW5jZVZlY3Rvci5sZW5ndGgoKSAvIHN0ZXApO1xuICAgICAgICBjb25zdCBkaWZmZXJlbmNlVmVjdG9yTGVuZ3RoID0gZGlmZmVyZW5jZVZlY3Rvci5sZW5ndGgoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBzdGVwczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFBvaW50ID0gc3RhcnQuY2xvbmUoKS5hZGQoZGlmZmVyZW5jZVZlY3Rvci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGkgLyBzdGVwcykpO1xuXG4gICAgICAgICAgICAvLyBPcmRlciBub2Rlcywgbm90IGJ5ICdjbG9zZW5lc3MnLCBidXQgYnkgZG90IHByb2R1Y3RcbiAgICAgICAgICAgIGxldCBub2Rlc1RvQWRkID0gW107XG4gICAgICAgICAgICBsZXQgY2xvc2VzdE5vZGUgPSBxdWFkdHJlZS5maW5kKGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSwgcmFkaXVzICsgc3RlcC8yKTtcblxuICAgICAgICAgICAgd2hpbGUgKGNsb3Nlc3ROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWFkdHJlZS5yZW1vdmUoY2xvc2VzdE5vZGUpO1xuICAgICAgICAgICAgICAgIGZvdW5kTm9kZXMucHVzaChjbG9zZXN0Tm9kZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGV0IG5vZGVPblNlZ21lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzIG9mIGNsb3Nlc3ROb2RlLnNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1enp5U2VnbWVudHNFcXVhbChzLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9uU2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChub2RlT25TZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9BZGQucHVzaChjbG9zZXN0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xvc2VzdE5vZGUgPSBxdWFkdHJlZS5maW5kKGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSwgcmFkaXVzICsgc3RlcC8yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZXNUb0FkZC5zb3J0KChmaXJzdDogTm9kZSwgc2Vjb25kOiBOb2RlKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZG90UHJvZHVjdFRvU2VnbWVudChmaXJzdCwgc3RhcnQsIGRpZmZlcmVuY2VWZWN0b3IpIC0gdGhpcy5kb3RQcm9kdWN0VG9TZWdtZW50KHNlY29uZCwgc3RhcnQsIGRpZmZlcmVuY2VWZWN0b3IpKTtcbiAgICAgICAgICAgIG5vZGVzQWxvbmdTZWdtZW50LnB1c2goLi4ubm9kZXNUb0FkZCk7XG4gICAgICAgIH1cblxuICAgICAgICBxdWFkdHJlZS5hZGRBbGwoZm91bmROb2Rlcyk7XG4gICAgICAgIHJldHVybiBub2Rlc0Fsb25nU2VnbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZ1enp5U2VnbWVudHNFcXVhbChzMTogU2VnbWVudCwgczI6IFNlZ21lbnQsIHRvbGVyYW5jZT0wLjAwMDEpOiBib29sZWFuIHtcbiAgICAgICAgLy8gRnJvbVxuICAgICAgICBpZiAoczEuZnJvbS54IC0gczIuZnJvbS54ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoczEuZnJvbS55IC0gczIuZnJvbS55ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb1xuXG4gICAgICAgIGlmIChzMS50by54IC0gczIudG8ueCA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHMxLnRvLnkgLSBzMi50by55ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRvdFByb2R1Y3RUb1NlZ21lbnQobm9kZTogTm9kZSwgc3RhcnQ6IFZlY3RvciwgZGlmZmVyZW5jZVZlY3RvcjogVmVjdG9yKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgZG90VmVjdG9yID0gbm9kZS52YWx1ZS5jbG9uZSgpLnN1YihzdGFydCk7XG4gICAgICAgIHJldHVybiBkaWZmZXJlbmNlVmVjdG9yLmRvdChkb3RWZWN0b3IpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZnV6enlBZGRUb1F1YWR0cmVlKHF1YWR0cmVlOiBkMy5RdWFkdHJlZTxOb2RlPiwgbm9kZTogTm9kZSwgcmFkaXVzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gT25seSBhZGQgaWYgdGhlcmUgaXNuJ3QgYSBub2RlIHdpdGhpbiByYWRpdXNcbiAgICAgICAgLy8gUmVtZW1iZXIgdG8gY2hlY2sgZm9yIGRvdWJsZSByYWRpdXMgd2hlbiBxdWVyeWluZyB0cmVlLCBvciBwb2ludCBtaWdodCBiZSBtaXNzZWRcbiAgICAgICAgY29uc3QgZXhpc3RpbmdOb2RlID0gcXVhZHRyZWUuZmluZChub2RlLnZhbHVlLngsIG5vZGUudmFsdWUueSwgcmFkaXVzKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBxdWFkdHJlZS5hZGQobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5laWdoYm9yIG9mIG5vZGUubmVpZ2hib3JzKSBleGlzdGluZ05vZGUuYWRkTmVpZ2hib3IobmVpZ2hib3IpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIG5vZGUuc2VnbWVudHMpIGV4aXN0aW5nTm9kZS5hZGRTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdHJlYW1saW5lc1RvU2VnbWVudChzdHJlYW1saW5lczogVmVjdG9yW11bXSk6IFNlZ21lbnRbXSB7XG4gICAgICAgIGNvbnN0IG91dDogU2VnbWVudFtdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzdHJlYW1saW5lcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHRoaXMudmVjdG9yc1RvU2VnbWVudChzW2ldLCBzW2kgKyAxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZlY3RvcnNUb1NlZ21lbnQodjE6IFZlY3RvciwgdjI6IFZlY3Rvcik6IFNlZ21lbnQge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogdjEsXG4gICAgICAgICAgICB0bzogICB2MlxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRTdG9yYWdlIHtcblxuICAgIHByaXZhdGUgZ3JpZERpbWVuc2lvbnM6IFZlY3RvcjtcbiAgICBwcml2YXRlIGdyaWQ6IFZlY3RvcltdW11bXTtcbiAgICBwcml2YXRlIGRzZXBTcTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogd29ybGREaW1lbnNpb25zIGFzc3VtZXMgb3JpZ2luIG9mIDAsMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkc2VwIFNlcGFyYXRpb24gZGlzdGFuY2UgYmV0d2VlbiBzYW1wbGVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKHByaXZhdGUgd29ybGREaW1lbnNpb25zOiBWZWN0b3IsIHByaXZhdGUgb3JpZ2luOiBWZWN0b3IsIHByaXZhdGUgZHNlcDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZHNlcFNxID0gdGhpcy5kc2VwICogdGhpcy5kc2VwO1xuICAgICAgICB0aGlzLmdyaWREaW1lbnNpb25zID0gd29ybGREaW1lbnNpb25zLmNsb25lKCkuZGl2aWRlU2NhbGFyKHRoaXMuZHNlcCk7XG4gICAgICAgIHRoaXMuZ3JpZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuZ3JpZERpbWVuc2lvbnMueDsgeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQucHVzaChbXSk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuZ3JpZERpbWVuc2lvbnMueTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkW3hdLnB1c2goW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGFsbCBzYW1wbGVzIGZyb20gYW5vdGhlciBncmlkIHRvIHRoaXMgb25lXG4gICAgICovXG4gICAgYWRkQWxsKGdyaWRTdG9yYWdlOiBHcmlkU3RvcmFnZSk6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBncmlkU3RvcmFnZS5ncmlkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNhbXBsZShzYW1wbGUpOyAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkUG9seWxpbmUobGluZTogVmVjdG9yW10pOiB2b2lkIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIGxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2FtcGxlKHYpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmZvcmNlIHNlcGFyYXRpb25cbiAgICAgKiBEb2VzIG5vdCBjbG9uZVxuICAgICAqL1xuICAgIGFkZFNhbXBsZSh2OiBWZWN0b3IsIGNvb3Jkcz86IFZlY3Rvcik6IHZvaWQge1xuICAgICAgICBpZiAoIWNvb3Jkcykge1xuICAgICAgICAgICAgY29vcmRzID0gdGhpcy5nZXRTYW1wbGVDb29yZHModik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkW2Nvb3Jkcy54XVtjb29yZHMueV0ucHVzaCh2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIHYgaXMgYXQgbGVhc3QgZCBhd2F5IGZyb20gc2FtcGxlc1xuICAgICAqIFBlcmZvcm1hbmNlIHZlcnkgaW1wb3J0YW50IC0gdGhpcyBpcyBjYWxsZWQgYXQgZXZlcnkgaW50ZWdyYXRpb24gc3RlcFxuICAgICAqIEBwYXJhbSBkU3E9dGhpcy5kc2VwU3Egc3F1YXJlZCB0ZXN0IGRpc3RhbmNlXG4gICAgICogQ291bGQgYmUgZHRlc3QgaWYgd2UgYXJlIGludGVncmF0aW5nIGEgc3RyZWFtbGluZVxuICAgICAqL1xuICAgIGlzVmFsaWRTYW1wbGUodjogVmVjdG9yLCBkU3E9dGhpcy5kc2VwU3EpOiBib29sZWFuIHtcbiAgICAgICAgLy8gQ29kZSBkdXBsaWNhdGlvbiB3aXRoIHRoaXMuZ2V0TmVhcmJ5UG9pbnRzIGJ1dCBtdWNoIHNsb3dlciB3aGVuIGNhbGxpbmdcbiAgICAgICAgLy8gdGhpcy5nZXROZWFyYnlQb2ludHMgZHVlIHRvIGFycmF5IGNyZWF0aW9uIGluIHRoYXQgbWV0aG9kXG5cbiAgICAgICAgY29uc3QgY29vcmRzID0gdGhpcy5nZXRTYW1wbGVDb29yZHModik7XG5cbiAgICAgICAgLy8gQ2hlY2sgc2FtcGxlcyBpbiA5IGNlbGxzIGluIDN4MyBncmlkXG4gICAgICAgIGZvciAobGV0IHggPSAtMTsgeCA8PSAxOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAtMTsgeSA8PSAxOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY29vcmRzLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IoeCwgeSkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy52ZWN0b3JPdXRPZkJvdW5kcyhjZWxsLCB0aGlzLmdyaWREaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmVjdG9yRmFyRnJvbVZlY3RvcnModiwgdGhpcy5ncmlkW2NlbGwueF1bY2VsbC55XSwgZFNxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB2IGlzIGF0IGxlYXN0IGQgYXdheSBmcm9tIHZlY3RvcnNcbiAgICAgKiBQZXJmb3JtYW5jZSB2ZXJ5IGltcG9ydGFudCAtIHRoaXMgaXMgY2FsbGVkIGF0IGV2ZXJ5IGludGVncmF0aW9uIHN0ZXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICBkU3EgICAgIHNxdWFyZWQgdGVzdCBkaXN0YW5jZVxuICAgICAqL1xuICAgIHZlY3RvckZhckZyb21WZWN0b3JzKHY6IFZlY3RvciwgdmVjdG9yczogVmVjdG9yW10sIGRTcTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIHZlY3RvcnMpIHtcbiAgICAgICAgICAgIGlmIChzYW1wbGUgIT09IHYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZVNxID0gc2FtcGxlLmRpc3RhbmNlVG9TcXVhcmVkKHYpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVNxIDwgZFNxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBvaW50cyBpbiBjZWxscyBzdXJyb3VuZGluZyB2XG4gICAgICogUmVzdWx0cyBpbmNsdWRlIHYsIGlmIGl0IGV4aXN0cyBpbiB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXR1cm5zIHNhbXBsZXMgKGtpbmQgb2YpIGNsb3NlciB0aGFuIGRpc3RhbmNlIC0gcmV0dXJucyBhbGwgc2FtcGxlcyBpbiBcbiAgICAgKiBjZWxscyBzbyBhcHByb3hpbWF0aW9uIChzcXVhcmUgdG8gYXBwcm94aW1hdGUgY2lyY2xlKVxuICAgICAqL1xuICAgIGdldE5lYXJieVBvaW50cyh2OiBWZWN0b3IsIGRpc3RhbmNlOiBudW1iZXIpOiBWZWN0b3JbXSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGguY2VpbCgoZGlzdGFuY2UvdGhpcy5kc2VwKSAtIDAuNSk7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuZ2V0U2FtcGxlQ29vcmRzKHYpO1xuICAgICAgICBjb25zdCBvdXQ6IFZlY3RvcltdID0gW107XG4gICAgICAgIGZvciAobGV0IHggPSAtMSAqIHJhZGl1czsgeCA8PSAxICogcmFkaXVzOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAtMSAqIHJhZGl1czsgeSA8PSAxICogcmFkaXVzOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY29vcmRzLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IoeCwgeSkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy52ZWN0b3JPdXRPZkJvdW5kcyhjZWxsLCB0aGlzLmdyaWREaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYyIG9mIHRoaXMuZ3JpZFtjZWxsLnhdW2NlbGwueV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHYyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB3b3JsZFRvR3JpZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5jbG9uZSgpLnN1Yih0aGlzLm9yaWdpbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBncmlkVG9Xb3JsZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdi5jbG9uZSgpLmFkZCh0aGlzLm9yaWdpbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2ZWN0b3JPdXRPZkJvdW5kcyhncmlkVjogVmVjdG9yLCBib3VuZHM6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGdyaWRWLnggPCAwIHx8IGdyaWRWLnkgPCAwIHx8XG4gICAgICAgICAgICBncmlkVi54ID49IGJvdW5kcy54IHx8IGdyaWRWLnkgPj0gYm91bmRzLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gICBDZWxsIGNvb3JkcyBjb3JyZXNwb25kaW5nIHRvIHZlY3RvclxuICAgICAqIFBlcmZvcm1hbmNlIGltcG9ydGFudCAtIGNhbGxlZCBhdCBldmVyeSBpbnRlZ3JhdGlvbiBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTYW1wbGVDb29yZHMod29ybGRWOiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCB2ID0gdGhpcy53b3JsZFRvR3JpZCh3b3JsZFYpO1xuICAgICAgICBpZiAodGhpcy52ZWN0b3JPdXRPZkJvdW5kcyh2LCB0aGlzLndvcmxkRGltZW5zaW9ucykpIHtcbiAgICAgICAgICAgIC8vIGxvZy5lcnJvcihcIlRyaWVkIHRvIGFjY2VzcyBvdXQtb2YtYm91bmRzIHNhbXBsZSBpbiBncmlkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFZlY3Rvci56ZXJvVmVjdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihcbiAgICAgICAgICAgIE1hdGguZmxvb3Iodi54IC8gdGhpcy5kc2VwKSxcbiAgICAgICAgICAgIE1hdGguZmxvb3Iodi55IC8gdGhpcy5kc2VwKVxuICAgICAgICApO1xuICAgIH1cbn1cbiIsImltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4vc3RyZWFtbGluZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBGaWVsZEludGVncmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBmaWVsZDogVGVuc29yRmllbGQpIHt9XG5cbiAgICBhYnN0cmFjdCBpbnRlZ3JhdGUocG9pbnQ6IFZlY3RvciwgbWFqb3I6IGJvb2xlYW4pOiBWZWN0b3I7XG5cbiAgICBwcm90ZWN0ZWQgc2FtcGxlRmllbGRWZWN0b3IocG9pbnQ6IFZlY3RvciwgbWFqb3I6IGJvb2xlYW4pOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCB0ZW5zb3IgPSB0aGlzLmZpZWxkLnNhbXBsZVBvaW50KHBvaW50KTtcbiAgICAgICAgaWYgKG1ham9yKSByZXR1cm4gdGVuc29yLmdldE1ham9yKCk7XG4gICAgICAgIHJldHVybiB0ZW5zb3IuZ2V0TWlub3IoKTtcbiAgICB9XG5cbiAgICBvbkxhbmQocG9pbnQ6IFZlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5vbkxhbmQocG9pbnQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEV1bGVySW50ZWdyYXRvciBleHRlbmRzIEZpZWxkSW50ZWdyYXRvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBzdXBlcihmaWVsZCk7XG4gICAgfVxuXG4gICAgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQsIG1ham9yKS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5kc3RlcCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUks0SW50ZWdyYXRvciBleHRlbmRzIEZpZWxkSW50ZWdyYXRvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBzdXBlcihmaWVsZCk7XG4gICAgfVxuXG4gICAgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yIHtcbiAgICAgICAgY29uc3QgazEgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LCBtYWpvcik7XG4gICAgICAgIGNvbnN0IGsyMyA9IHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQuY2xvbmUoKS5hZGQoVmVjdG9yLmZyb21TY2FsYXIodGhpcy5wYXJhbXMuZHN0ZXAgLyAyKSksIG1ham9yKTtcbiAgICAgICAgY29uc3QgazQgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LmNsb25lKCkuYWRkKFZlY3Rvci5mcm9tU2NhbGFyKHRoaXMucGFyYW1zLmRzdGVwKSksIG1ham9yKTtcblxuICAgICAgICByZXR1cm4gazEuYWRkKGsyMy5tdWx0aXBseVNjYWxhcig0KSkuYWRkKGs0KS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5kc3RlcCAvIDYpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge05vZGV9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4vcG9seWdvbl91dGlsJztcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuL3RlbnNvcl9maWVsZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9seWdvblBhcmFtcyB7XG4gICAgbWF4TGVuZ3RoOiBudW1iZXI7XG4gICAgbWluQXJlYTogbnVtYmVyO1xuICAgIHNocmlua1NwYWNpbmc6IG51bWJlcjtcbiAgICBjaGFuY2VOb0RpdmlkZTogbnVtYmVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uRmluZGVyIHtcbiAgICBwcml2YXRlIF9wb2x5Z29uczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHByaXZhdGUgX3NocnVua1BvbHlnb25zOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHJpdmF0ZSBfZGl2aWRlZFBvbHlnb25zOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHJpdmF0ZSB0b1NocmluazogVmVjdG9yW11bXSA9IFtdO1xuICAgIHByaXZhdGUgcmVzb2x2ZVNocmluazogKCkgPT4gdm9pZDtcbiAgICBwcml2YXRlIHRvRGl2aWRlOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHJpdmF0ZSByZXNvbHZlRGl2aWRlOiAoKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBub2RlczogTm9kZVtdLCBwcml2YXRlIHBhcmFtczogUG9seWdvblBhcmFtcywgcHJpdmF0ZSB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGQpIHt9XG5cbiAgICBnZXQgcG9seWdvbnMoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXZpZGVkUG9seWdvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpdmlkZWRQb2x5Z29ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zaHJ1bmtQb2x5Z29ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hydW5rUG9seWdvbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbnM7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudG9TaHJpbmsgPSBbXTtcbiAgICAgICAgdGhpcy50b0RpdmlkZSA9IFtdO1xuICAgICAgICB0aGlzLl9wb2x5Z29ucyA9IFtdO1xuICAgICAgICB0aGlzLl9zaHJ1bmtQb2x5Z29ucyA9IFtdXG4gICAgICAgIHRoaXMuX2RpdmlkZWRQb2x5Z29ucyA9IFtdO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy50b1Nocmluay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZSA9IHRoaXMudG9TaHJpbmsubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RlcFNocmluayh0aGlzLnRvU2hyaW5rLnBvcCgpKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChyZXNvbHZlKSB0aGlzLnJlc29sdmVTaHJpbmsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRvRGl2aWRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlID0gdGhpcy50b0RpdmlkZS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwRGl2aWRlKHRoaXMudG9EaXZpZGUucG9wKCkpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0IGRpdmlkZWQgPSBQb2x5Z29uVXRpbC5zdWJkaXZpZGVQb2x5Z29uKHRoaXMudG9EaXZpZGUucG9wKCksIHRoaXMucGFyYW1zLm1pbkFyZWEpO1xuXG4gICAgICAgICAgICAvLyBpZiAoZGl2aWRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5fZGl2aWRlZFBvbHlnb25zLnB1c2goLi4uZGl2aWRlZCk7XG4gICAgICAgICAgICAvLyAgICAgY2hhbmdlID0gdHJ1ZTsgICAgXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAocmVzb2x2ZSkgdGhpcy5yZXNvbHZlRGl2aWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICBhc3luYyBzaHJpbmsoYW5pbWF0ZT1mYWxzZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9seWdvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kUG9seWdvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcG9seWdvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudG9TaHJpbmsgPSB0aGlzLl9wb2x5Z29ucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVNocmluayA9IHJlc29sdmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NocnVua1BvbHlnb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuX3BvbHlnb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlcFNocmluayhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0ZXBTaHJpbmsocG9seWdvbjogVmVjdG9yW10pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgc2hydW5rID0gUG9seWdvblV0aWwucmVzaXplR2VvbWV0cnkocG9seWdvbiwgLXRoaXMucGFyYW1zLnNocmlua1NwYWNpbmcpO1xuICAgICAgICBpZiAoc2hydW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NocnVua1BvbHlnb25zLnB1c2goc2hydW5rKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBhc3luYyBkaXZpZGUoYW5pbWF0ZT1mYWxzZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9seWdvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kUG9seWdvbnMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHBvbHlnb25zID0gdGhpcy5fcG9seWdvbnM7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hydW5rUG9seWdvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBvbHlnb25zID0gdGhpcy5fc2hydW5rUG9seWdvbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRvRGl2aWRlID0gcG9seWdvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVEaXZpZGUgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcG9seWdvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGVwRGl2aWRlKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RlcERpdmlkZShwb2x5Z29uOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBUT0RPIG5lZWQgdG8gZmlsdGVyIHNocnVuayBwb2x5Z29ucyB1c2luZyBhc3BlY3QgcmF0aW8sIGFyZWEgXG4gICAgICAgIC8vIHRoaXMgc2tpcHMgdGhlIGZpbHRlciBpbiBQb2x5Z29uVXRpbC5zdWJkaXZpZGVQb2x5Z29uXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5jaGFuY2VOb0RpdmlkZSA+IDAgJiYgTWF0aC5yYW5kb20oKSA8IHRoaXMucGFyYW1zLmNoYW5jZU5vRGl2aWRlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpdmlkZWQgPSBQb2x5Z29uVXRpbC5zdWJkaXZpZGVQb2x5Z29uKHBvbHlnb24sIHRoaXMucGFyYW1zLm1pbkFyZWEpO1xuICAgICAgICBpZiAoZGl2aWRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMucHVzaCguLi5kaXZpZGVkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmaW5kUG9seWdvbnMoKTogdm9pZCB7XG4gICAgICAgIC8vIE5vZGVcbiAgICAgICAgLy8geCwgeSwgdmFsdWUgKFZlY3RvcjIpLCBhZGogKGxpc3Qgb2Ygbm9kZSByZWZzKVxuICAgICAgICAvLyBHb25uYSBlZGl0IGFkaiBmb3Igbm93XG5cbiAgICAgICAgLy8gV2FsayBhIGNsb2Nrd2lzZSBwYXRoIHVudGlsIHBvbHlnb24gZm91bmQgb3IgbGltaXQgcmVhY2hlZFxuICAgICAgICAvLyBXaGVuIHdlIGZpbmQgYSBwb2x5Z29uLCBtYXJrIGFsbCBlZGdlcyBhcyB0cmF2ZXJzZWQgKGluIHBhcnRpY3VsYXIgZGlyZWN0aW9uKVxuICAgICAgICAvLyBFYWNoIGVkZ2Ugc2VwYXJhdGVzIHR3byBwb2x5Z29uc1xuICAgICAgICAvLyBJZiBlZGdlIGFscmVhZHkgdHJhdmVyc2VkIGluIHRoaXMgZGlyZWN0aW9uLCB0aGlzIHBvbHlnb24gaGFzIGFscmVhZHkgYmVlbiBmb3VuZFxuICAgICAgICB0aGlzLl9zaHJ1bmtQb2x5Z29ucyA9IFtdO1xuICAgICAgICB0aGlzLl9kaXZpZGVkUG9seWdvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgcG9seWdvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmFkai5sZW5ndGggPCAyKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IG5leHROb2RlIG9mIG5vZGUuYWRqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9seWdvbiA9IHRoaXMucmVjdXJzaXZlV2Fsayhbbm9kZSwgbmV4dE5vZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbiAhPT0gbnVsbCAmJiBwb2x5Z29uLmxlbmd0aCA8IHRoaXMucGFyYW1zLm1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVBvbHlnb25BZGphY2VuY2llcyhwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uLm1hcChuID0+IG4udmFsdWUuY2xvbmUoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BvbHlnb25zID0gdGhpcy5maWx0ZXJQb2x5Z29uc0J5V2F0ZXIocG9seWdvbnMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZmlsdGVyUG9seWdvbnNCeVdhdGVyKHBvbHlnb25zOiBWZWN0b3JbXVtdKTogVmVjdG9yW11bXSB7XG4gICAgICAgIGNvbnN0IG91dDogVmVjdG9yW11bXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcG9seWdvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2VQb2ludCA9IFBvbHlnb25VdGlsLmF2ZXJhZ2VQb2ludChwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRlbnNvckZpZWxkLm9uTGFuZChhdmVyYWdlUG9pbnQpICYmICF0aGlzLnRlbnNvckZpZWxkLmluUGFya3MoYXZlcmFnZVBvaW50KSkgb3V0LnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbW92ZVBvbHlnb25BZGphY2VuY2llcyhwb2x5Z29uOiBOb2RlW10pOiB2b2lkIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcG9seWdvbltpXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwb2x5Z29uWyhpICsgMSkgJSBwb2x5Z29uLmxlbmd0aF07XG5cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudC5hZGouaW5kZXhPZihuZXh0KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5hZGouc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiUG9seWdvbkZpbmRlciAtIG5vZGUgbm90IGluIGFkalwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVjdXJzaXZlV2Fsayh2aXNpdGVkOiBOb2RlW10sIGNvdW50PTApOiBOb2RlW10ge1xuICAgICAgICBpZiAoY291bnQgPj0gdGhpcy5wYXJhbXMubWF4TGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gVE9ETyBiYWNrdHJhY2tpbmcgdG8gZmluZCBwb2x5Z29ucyB3aXRoIGRlYWQgZW5kIHJvYWRzIGluc2lkZSB0aGVtXG4gICAgICAgIGNvbnN0IG5leHROb2RlID0gdGhpcy5nZXRSaWdodG1vc3ROb2RlKHZpc2l0ZWRbdmlzaXRlZC5sZW5ndGggLSAyXSwgdmlzaXRlZFt2aXNpdGVkLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKG5leHROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgIC8vIEN1cnJlbnRseSBpZ25vcmVzIHBvbHlnb25zIHdpdGggZGVhZCBlbmQgaW5zaWRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2aXNpdGVkSW5kZXggPSB2aXNpdGVkLmluZGV4T2YobmV4dE5vZGUpO1xuICAgICAgICBpZiAodmlzaXRlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdGVkLnNsaWNlKHZpc2l0ZWRJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpdGVkLnB1c2gobmV4dE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlV2Fsayh2aXNpdGVkLCBjb3VudCsrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UmlnaHRtb3N0Tm9kZShub2RlRnJvbTogTm9kZSwgbm9kZVRvOiBOb2RlKTogTm9kZSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gdHVybiByaWdodCBhdCBldmVyeSBqdW5jdGlvblxuICAgICAgICBpZiAobm9kZVRvLmFkai5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IGJhY2t3YXJkc0RpZmZlcmVuY2VWZWN0b3IgPSBub2RlRnJvbS52YWx1ZS5jbG9uZSgpLnN1Yihub2RlVG8udmFsdWUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1BbmdsZSA9IE1hdGguYXRhbjIoYmFja3dhcmRzRGlmZmVyZW5jZVZlY3Rvci55LCBiYWNrd2FyZHNEaWZmZXJlbmNlVmVjdG9yLngpO1xuXG4gICAgICAgIGxldCByaWdodG1vc3ROb2RlID0gbnVsbDtcbiAgICAgICAgbGV0IHNtYWxsZXN0VGhldGEgPSBNYXRoLlBJICogMjtcblxuICAgICAgICBmb3IgKGxldCBuZXh0Tm9kZSBvZiBub2RlVG8uYWRqKSB7XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUgIT09IG5vZGVGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZlY3RvciA9IG5leHROb2RlLnZhbHVlLmNsb25lKCkuc3ViKG5vZGVUby52YWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRBbmdsZSA9IE1hdGguYXRhbjIobmV4dFZlY3Rvci55LCBuZXh0VmVjdG9yLngpIC0gdHJhbnNmb3JtQW5nbGU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXh0QW5nbGUgPCBzbWFsbGVzdFRoZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0VGhldGEgPSBuZXh0QW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0bW9zdE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmlnaHRtb3N0Tm9kZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0ICogYXMgUG9seUsgZnJvbSAncG9seWsnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0ICogYXMganN0cyBmcm9tICdqc3RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvblV0aWwge1xuICAgIHByaXZhdGUgc3RhdGljIGdlb21ldHJ5RmFjdG9yeSA9IG5ldyBqc3RzLmdlb20uR2VvbWV0cnlGYWN0b3J5KCk7XG5cbiAgICAvKipcbiAgICAgKiBTbGljZXMgcmVjdGFuZ2xlIGJ5IGxpbmUsIHJldHVybmluZyBsYXJnZXN0IHBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHNsaWNlUmVjdGFuZ2xlKG9yaWdpbjogVmVjdG9yLCB3b3JsZERpbWVuc2lvbnM6IFZlY3RvciwgcDE6IFZlY3RvciwgcDI6IFZlY3Rvcik6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3QgcmVjdGFuZ2xlID0gW1xuICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55LFxuICAgICAgICAgICAgb3JpZ2luLnggKyB3b3JsZERpbWVuc2lvbnMueCwgb3JpZ2luLnksXG4gICAgICAgICAgICBvcmlnaW4ueCArIHdvcmxkRGltZW5zaW9ucy54LCBvcmlnaW4ueSArIHdvcmxkRGltZW5zaW9ucy55LFxuICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55ICsgd29ybGREaW1lbnNpb25zLnksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHNsaWNlZCA9IFBvbHlLLlNsaWNlKHJlY3RhbmdsZSwgcDEueCwgcDEueSwgcDIueCwgcDIueSkubWFwKHAgPT4gUG9seWdvblV0aWwucG9seWdvbkFycmF5VG9Qb2x5Z29uKHApKTtcbiAgICAgICAgY29uc3QgbWluQXJlYSA9IFBvbHlnb25VdGlsLmNhbGNQb2x5Z29uQXJlYShzbGljZWRbMF0pO1xuXG4gICAgICAgIGlmIChzbGljZWQubGVuZ3RoID4gMSAmJiBQb2x5Z29uVXRpbC5jYWxjUG9seWdvbkFyZWEoc2xpY2VkWzFdKSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGljZWRbMV07XG4gICAgICAgIH0gXG4gICAgICAgIHJldHVybiBzbGljZWRbMF07XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjYWxjUG9seWdvbkFyZWEocG9seWdvbjogVmVjdG9yW10pOiBudW1iZXIge1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBhZGRYID0gcG9seWdvbltpXS54O1xuICAgICAgICAgIGxldCBhZGRZID0gcG9seWdvbltpID09IHBvbHlnb24ubGVuZ3RoIC0gMSA/IDAgOiBpICsgMV0ueTtcbiAgICAgICAgICBsZXQgc3ViWCA9IHBvbHlnb25baSA9PSBwb2x5Z29uLmxlbmd0aCAtIDEgPyAwIDogaSArIDFdLng7XG4gICAgICAgICAgbGV0IHN1YlkgPSBwb2x5Z29uW2ldLnk7XG5cbiAgICAgICAgICB0b3RhbCArPSAoYWRkWCAqIGFkZFkgKiAwLjUpO1xuICAgICAgICAgIHRvdGFsIC09IChzdWJYICogc3ViWSAqIDAuNSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5hYnModG90YWwpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3ViZGl2aWRlUG9seWdvbihwOiBWZWN0b3JbXSwgbWluQXJlYTogbnVtYmVyKTogVmVjdG9yW11bXSB7XG4gICAgICAgIGNvbnN0IGFyZWEgPSBQb2x5Z29uVXRpbC5jYWxjUG9seWdvbkFyZWEocCk7XG4gICAgICAgIGlmIChhcmVhIDwgMC41ICogbWluQXJlYSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaXZpZGVkOiBWZWN0b3JbXVtdID0gW107ICAvLyBBcnJheSBvZiBwb2x5Z29uc1xuXG4gICAgICAgIGxldCBsb25nZXN0U2lkZUxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBsb25nZXN0U2lkZSA9IFtwWzBdLCBwWzFdXTtcblxuICAgICAgICBsZXQgcGVyaW1ldGVyID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZGVMZW5ndGggPSBwW2ldLmNsb25lKCkuc3ViKHBbKGkrMSkgJSBwLmxlbmd0aF0pLmxlbmd0aCgpO1xuICAgICAgICAgICAgcGVyaW1ldGVyICs9IHNpZGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2lkZUxlbmd0aCA+IGxvbmdlc3RTaWRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9uZ2VzdFNpZGVMZW5ndGggPSBzaWRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxvbmdlc3RTaWRlID0gW3BbaV0sIHBbKGkrMSkgJSBwLmxlbmd0aF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hhcGUgaW5kZXhcbiAgICAgICAgLy8gVXNpbmcgcmVjdGFuZ2xlIHJhdGlvIG9mIDE6NCBhcyBsaW1pdFxuICAgICAgICAvLyBpZiAoYXJlYSAvIHBlcmltZXRlciAqIHBlcmltZXRlciA8IDAuMDQpIHtcbiAgICAgICAgaWYgKGFyZWEgLyAocGVyaW1ldGVyICogcGVyaW1ldGVyKSA8IDAuMDQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmVhIDwgMiAqIG1pbkFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiBbcF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZXR3ZWVuIDAuNCBhbmQgMC42XG4gICAgICAgIGNvbnN0IGRldmlhdGlvbiA9IChNYXRoLnJhbmRvbSgpICogMC4yKSArIDAuNDtcblxuICAgICAgICBjb25zdCBhdmVyYWdlUG9pbnQgPSBsb25nZXN0U2lkZVswXS5jbG9uZSgpLmFkZChsb25nZXN0U2lkZVsxXSkubXVsdGlwbHlTY2FsYXIoZGV2aWF0aW9uKTtcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZVZlY3RvciA9IGxvbmdlc3RTaWRlWzBdLmNsb25lKCkuc3ViKGxvbmdlc3RTaWRlWzFdKTtcbiAgICAgICAgY29uc3QgcGVycFZlY3RvciA9IChuZXcgVmVjdG9yKGRpZmZlcmVuY2VWZWN0b3IueSwgLTEgKiBkaWZmZXJlbmNlVmVjdG9yLngpKVxuICAgICAgICAgICAgLm5vcm1hbGl6ZSgpXG4gICAgICAgICAgICAubXVsdGlwbHlTY2FsYXIoMTAwKTtcblxuICAgICAgICBjb25zdCBiaXNlY3QgPSBbYXZlcmFnZVBvaW50LmNsb25lKCkuYWRkKHBlcnBWZWN0b3IpLCBhdmVyYWdlUG9pbnQuY2xvbmUoKS5zdWIocGVycFZlY3RvcildO1xuXG4gICAgICAgIC8vIEFycmF5IG9mIHBvbHlnb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZWQgPSBQb2x5Sy5TbGljZShQb2x5Z29uVXRpbC5wb2x5Z29uVG9Qb2x5Z29uQXJyYXkocCksIGJpc2VjdFswXS54LCBiaXNlY3RbMF0ueSwgYmlzZWN0WzFdLngsIGJpc2VjdFsxXS55KTtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc2xpY2VkKSB7XG4gICAgICAgICAgICAgICAgZGl2aWRlZC5wdXNoKC4uLlBvbHlnb25VdGlsLnN1YmRpdmlkZVBvbHlnb24oUG9seWdvblV0aWwucG9seWdvbkFycmF5VG9Qb2x5Z29uKHMpLCBtaW5BcmVhKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkaXZpZGVkO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgcmVzaXplR2VvbWV0cnkoZ2VvbWV0cnk6IFZlY3RvcltdLCBzcGFjaW5nOiBudW1iZXIsIGlzUG9seWdvbj10cnVlKTogVmVjdG9yW10ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganN0c0dlb21ldHJ5ID0gaXNQb2x5Z29uPyBQb2x5Z29uVXRpbC5wb2x5Z29uVG9KdHMoZ2VvbWV0cnkpIDogUG9seWdvblV0aWwubGluZVRvSnRzKGdlb21ldHJ5KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZWQgPSBqc3RzR2VvbWV0cnkuYnVmZmVyKHNwYWNpbmcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmICghcmVzaXplZC5pc1NpbXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc2l6ZWQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoYyA9PiBuZXcgVmVjdG9yKGMueCwgYy55KSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBhdmVyYWdlUG9pbnQocG9seWdvbjogVmVjdG9yW10pOiBWZWN0b3Ige1xuICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPT09IDApIHJldHVybiBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgICAgICBjb25zdCBzdW0gPSBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgcG9seWdvbikge1xuICAgICAgICAgICAgc3VtLmFkZCh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtLmRpdmlkZVNjYWxhcihwb2x5Z29uLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBpbnNpZGVQb2x5Z29uKHBvaW50OiBWZWN0b3IsIHBvbHlnb246IFZlY3RvcltdKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIHJheS1jYXN0aW5nIGFsZ29yaXRobSBiYXNlZCBvblxuICAgICAgICAvLyBodHRwOi8vd3d3LmVjc2UucnBpLmVkdS9Ib21lcGFnZXMvd3JmL1Jlc2VhcmNoL1Nob3J0X05vdGVzL3BucG9seS5odG1sXG5cbiAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gcG9seWdvbi5sZW5ndGggLSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgIHZhciB4aSA9IHBvbHlnb25baV0ueCwgeWkgPSBwb2x5Z29uW2ldLnk7XG4gICAgICAgICAgICB2YXIgeGogPSBwb2x5Z29uW2pdLngsIHlqID0gcG9seWdvbltqXS55O1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0ID0gKCh5aSA+IHBvaW50LnkpICE9ICh5aiA+IHBvaW50LnkpKVxuICAgICAgICAgICAgICAgICYmIChwb2ludC54IDwgKHhqIC0geGkpICogKHBvaW50LnkgLSB5aSkgLyAoeWogLSB5aSkgKyB4aSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0KSBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHBvaW50SW5SZWN0YW5nbGUocG9pbnQ6IFZlY3Rvciwgb3JpZ2luOiBWZWN0b3IsIGRpbWVuc2lvbnM6IFZlY3Rvcikge1xuICAgICAgICByZXR1cm4gcG9pbnQueCA+PSBvcmlnaW4ueCAmJiBwb2ludC55ID49IG9yaWdpbi55ICYmIHBvaW50LnggPD0gZGltZW5zaW9ucy54ICYmIHBvaW50LnkgPD0gZGltZW5zaW9ucy55O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGxpbmVUb0p0cyhsaW5lOiBWZWN0b3JbXSk6IGpzdHMuZ2VvbS5MaW5lU3RyaW5nIHtcbiAgICAgICAgY29uc3QgY29vcmRzID0gbGluZS5tYXAodiA9PiBuZXcganN0cy5nZW9tLkNvb3JkaW5hdGUodi54LCB2LnkpKTtcbiAgICAgICAgcmV0dXJuIFBvbHlnb25VdGlsLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGNvb3Jkcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcG9seWdvblRvSnRzKHBvbHlnb246IFZlY3RvcltdKToganN0cy5nZW9tLlBvbHlnb24ge1xuICAgICAgICBjb25zdCBnZW9JbnB1dCA9IHBvbHlnb24ubWFwKHYgPT4gbmV3IGpzdHMuZ2VvbS5Db29yZGluYXRlKHYueCwgdi55KSk7XG4gICAgICAgIGdlb0lucHV0LnB1c2goZ2VvSW5wdXRbMF0pOyAgLy8gQ3JlYXRlIGxvb3BcbiAgICAgICAgcmV0dXJuIFBvbHlnb25VdGlsLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKFBvbHlnb25VdGlsLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGdlb0lucHV0KSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFsgdi54LCB2LnksIHYueCwgdi55IF0uLi5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBwb2x5Z29uVG9Qb2x5Z29uQXJyYXkocDogVmVjdG9yW10pOiBudW1iZXJbXSB7XG4gICAgICAgIGNvbnN0IG91dFA6IG51bWJlcltdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBwKSB7XG4gICAgICAgICAgICBvdXRQLnB1c2godi54KTtcbiAgICAgICAgICAgIG91dFAucHVzaCh2LnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRQO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFsgdi54LCB2LnksIHYueCwgdi55IF0uLi5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBwb2x5Z29uQXJyYXlUb1BvbHlnb24ocDogbnVtYmVyW10pOiBWZWN0b3JbXSB7XG4gICAgICAgIGNvbnN0IG91dFAgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgb3V0UC5wdXNoKG5ldyBWZWN0b3IocFsyKmldLCBwWzIqaSArIDFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dFA7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCAqIGFzIHNpbXBsaWZ5IGZyb20gJ3NpbXBsaWZ5LWpzJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBHcmlkU3RvcmFnZSBmcm9tICcuL2dyaWRfc3RvcmFnZSc7XG5pbXBvcnQgRmllbGRJbnRlZ3JhdG9yIGZyb20gJy4vaW50ZWdyYXRvcic7XG5cbmludGVyZmFjZSBTdHJlYW1saW5lSW50ZWdyYXRpb24ge1xuICAgIHNlZWQ6IFZlY3RvcjtcbiAgICBvcmlnaW5hbERpcjogVmVjdG9yO1xuICAgIHN0cmVhbWxpbmU6IFZlY3RvcltdO1xuICAgIHByZXZpb3VzRGlyZWN0aW9uOiBWZWN0b3I7XG4gICAgcHJldmlvdXNQb2ludDogVmVjdG9yO1xuICAgIHZhbGlkOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmVhbWxpbmVQYXJhbXMge1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgICBkc2VwOiBudW1iZXI7ICAvLyBTdHJlYW1saW5lIHNlZWQgc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgIGR0ZXN0OiBudW1iZXI7ICAvLyBTdHJlYW1saW5lIGludGVncmF0aW9uIHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICBkc3RlcDogbnVtYmVyOyAgLy8gU3RlcCBzaXplXG4gICAgZGNpcmNsZWpvaW46IG51bWJlcjsgIC8vIEhvdyBmYXIgdG8gbG9vayB0byBqb2luIGNpcmNsZXMgLSAoZS5nLiAyIHggZHN0ZXApXG4gICAgZGxvb2thaGVhZDogbnVtYmVyOyAgLy8gSG93IGZhciB0byBsb29rIGFoZWFkIHRvIGpvaW4gdXAgZGFuZ2xpbmdcbiAgICBqb2luYW5nbGU6IG51bWJlcjsgIC8vIEFuZ2xlIHRvIGpvaW4gcm9hZHMgaW4gcmFkaWFuc1xuICAgIHBhdGhJdGVyYXRpb25zOiBudW1iZXI7ICAvLyBQYXRoIGludGVncmF0aW9uIGl0ZXJhdGlvbiBsaW1pdFxuICAgIHNlZWRUcmllczogbnVtYmVyOyAgLy8gTWF4IGZhaWxlZCBzZWVkc1xuICAgIHNpbXBsaWZ5VG9sZXJhbmNlOiBudW1iZXI7XG4gICAgY29sbGlkZUVhcmx5OiBudW1iZXI7ICAvLyBDaGFuY2Ugb2YgZWFybHkgY29sbGlzaW9uIDAtMVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJlYW1saW5lR2VuZXJhdG9yIHtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgU0VFRF9BVF9FTkRQT0lOVFMgPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgTkVBUl9FREdFID0gMzsgIC8vIFNhbXBsZSBuZWFyIGVkZ2VcblxuICAgIHByb3RlY3RlZCBtYWpvckdyaWQ6IEdyaWRTdG9yYWdlO1xuICAgIHByb3RlY3RlZCBtaW5vckdyaWQ6IEdyaWRTdG9yYWdlO1xuICAgIHByb3RlY3RlZCBwYXJhbXNTcTogU3RyZWFtbGluZVBhcmFtcztcblxuICAgIC8vIEhvdyBtYW55IHNhbXBsZXMgdG8gc2tpcCB3aGVuIGNoZWNraW5nIHN0cmVhbWxpbmUgY29sbGlzaW9uIHdpdGggaXRzZWxmXG4gICAgcHJvdGVjdGVkIG5TdHJlYW1saW5lU3RlcDogbnVtYmVyO1xuICAgIC8vIEhvdyBtYW55IHNhbXBsZXMgdG8gaWdub3JlIGJhY2t3YXJkcyB3aGVuIGNoZWNraW5nIHN0cmVhbWxpbmUgY29sbGlzaW9uIHdpdGggaXRzZWxmXG4gICAgcHJvdGVjdGVkIG5TdHJlYW1saW5lTG9va0JhY2s6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZGNvbGxpZGVzZWxmU3E6IG51bWJlcjtcblxuICAgIHByb3RlY3RlZCBjYW5kaWRhdGVTZWVkc01ham9yOiBWZWN0b3JbXSA9IFtdO1xuICAgIHByb3RlY3RlZCBjYW5kaWRhdGVTZWVkc01pbm9yOiBWZWN0b3JbXSA9IFtdO1xuXG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVzRG9uZSA9IHRydWU7XG4gICAgcHJvdGVjdGVkIHJlc29sdmU6ICgpID0+IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGxhc3RTdHJlYW1saW5lTWFqb3IgPSB0cnVlO1xuXG4gICAgcHVibGljIGFsbFN0cmVhbWxpbmVzOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHVibGljIHN0cmVhbWxpbmVzTWFqb3I6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwdWJsaWMgc3RyZWFtbGluZXNNaW5vcjogVmVjdG9yW11bXSA9IFtdO1xuICAgIHB1YmxpYyBhbGxTdHJlYW1saW5lc1NpbXBsZTogVmVjdG9yW11bXSA9IFtdOyAgLy8gUmVkdWNlZCB2ZXJ0ZXggY291bnRcblxuICAgIC8qKlxuICAgICAqIFVzZXMgd29ybGQtc3BhY2UgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBvcmlnaW46IFZlY3RvcixcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgd29ybGREaW1lbnNpb25zOiBWZWN0b3IsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmFtczogU3RyZWFtbGluZVBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmRzdGVwID4gcGFyYW1zLmRzZXApIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIlNUUkVBTUxJTkUgU0FNUExFIERJU1RBTkNFIEJJR0dFUiBUSEFOIERTRVBcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmZvcmNlIHRlc3QgPCBzZXBcbiAgICAgICAgcGFyYW1zLmR0ZXN0ID0gTWF0aC5taW4ocGFyYW1zLmR0ZXN0LCBwYXJhbXMuZHNlcCk7XG5cbiAgICAgICAgLy8gTmVlZHMgdG8gYmUgbGVzcyB0aGFuIGNpcmNsZWpvaW5cbiAgICAgICAgdGhpcy5kY29sbGlkZXNlbGZTcSA9IChwYXJhbXMuZGNpcmNsZWpvaW4gLyAyKSAqKiAyO1xuICAgICAgICB0aGlzLm5TdHJlYW1saW5lU3RlcCA9IE1hdGguZmxvb3IocGFyYW1zLmRjaXJjbGVqb2luIC8gcGFyYW1zLmRzdGVwKTtcbiAgICAgICAgdGhpcy5uU3RyZWFtbGluZUxvb2tCYWNrID0gMiAqIHRoaXMublN0cmVhbWxpbmVTdGVwO1xuXG4gICAgICAgIHRoaXMubWFqb3JHcmlkID0gbmV3IEdyaWRTdG9yYWdlKHRoaXMud29ybGREaW1lbnNpb25zLCB0aGlzLm9yaWdpbiwgcGFyYW1zLmRzZXApO1xuICAgICAgICB0aGlzLm1pbm9yR3JpZCA9IG5ldyBHcmlkU3RvcmFnZSh0aGlzLndvcmxkRGltZW5zaW9ucywgdGhpcy5vcmlnaW4sIHBhcmFtcy5kc2VwKTtcblxuICAgICAgICB0aGlzLnNldFBhcmFtc1NxKCk7XG4gICAgfVxuXG4gICAgY2xlYXJTdHJlYW1saW5lcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZSA9IFtdO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzTWFqb3IgPSBbXTtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lc01pbm9yID0gW107XG4gICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0cyBzdHJlYW1saW5lc1xuICAgICAqL1xuICAgIGpvaW5EYW5nbGluZ1N0cmVhbWxpbmVzKCk6IHZvaWQge1xuICAgICAgICAvLyBUT0RPIGRvIGluIHVwZGF0ZSBtZXRob2RcbiAgICAgICAgZm9yIChjb25zdCBtYWpvciBvZiBbdHJ1ZSwgZmFsc2VdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2YgdGhpcy5zdHJlYW1saW5lcyhtYWpvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY2lyY2xlc1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW1saW5lWzBdLmVxdWFscyhzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gdGhpcy5nZXRCZXN0TmV4dFBvaW50KHN0cmVhbWxpbmVbMF0sIHN0cmVhbWxpbmVbNF0sIHN0cmVhbWxpbmUpXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBvaW50c0JldHdlZW4oc3RyZWFtbGluZVswXSwgbmV3U3RhcnQsIHRoaXMucGFyYW1zLmRzdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtbGluZS51bnNoaWZ0KHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkKG1ham9yKS5hZGRTYW1wbGUocCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFbmQgPSB0aGlzLmdldEJlc3ROZXh0UG9pbnQoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdLCBzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gNF0sIHN0cmVhbWxpbmUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdFbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucG9pbnRzQmV0d2VlbihzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0sIG5ld0VuZCwgdGhpcy5wYXJhbXMuZHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1saW5lLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFNhbXBsZShwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHNpbXBsaWZpZWQgc3RyZWFtbGluZXNcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5hbGxTdHJlYW1saW5lcykge1xuICAgICAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5wdXNoKHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXJyYXkgb2YgcG9pbnRzIGZyb20gdjEgdG8gdjIgc3VjaCB0aGF0IHRoZXkgYXJlIHNlcGFyYXRlZCBieSBhdCBtb3N0IGRzZXBcbiAgICAgKiBub3QgaW5jbHVkaW5nIHYxXG4gICAgICovXG4gICAgcG9pbnRzQmV0d2Vlbih2MTogVmVjdG9yLCB2MjogVmVjdG9yLCBkc3RlcDogbnVtYmVyKTogVmVjdG9yW10ge1xuICAgICAgICBjb25zdCBkID0gdjEuZGlzdGFuY2VUbyh2Mik7XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGQgLyBkc3RlcCk7XG4gICAgICAgIGlmIChuUG9pbnRzID09PSAwKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3Qgc3RlcFZlY3RvciA9IHYyLmNsb25lKCkuc3ViKHYxKTtcblxuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBsZXQgbmV4dCA9IHYxLmNsb25lKCkuYWRkKHN0ZXBWZWN0b3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihpIC8gblBvaW50cykpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZWdyYXRvci5pbnRlZ3JhdGUobmV4dCwgdHJ1ZSkubGVuZ3RoU3EoKSA+IDAuMDAxKSB7ICAvLyBUZXN0IGZvciBkZWdlbmVyYXRlIHBvaW50XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gdjEuY2xvbmUoKS5hZGQoc3RlcFZlY3Rvci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGkgLyBuUG9pbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgbmV4dCBiZXN0IHBvaW50IHRvIGpvaW4gc3RyZWFtbGluZVxuICAgICAqIHJldHVybnMgbnVsbCBpZiB0aGVyZSBhcmUgbm8gZ29vZCBjYW5kaWRhdGVzXG4gICAgICovXG4gICAgZ2V0QmVzdE5leHRQb2ludChwb2ludDogVmVjdG9yLCBwcmV2aW91c1BvaW50OiBWZWN0b3IsIHN0cmVhbWxpbmU6IFZlY3RvcltdKTogVmVjdG9yIHtcbiAgICAgICAgY29uc3QgbmVhcmJ5UG9pbnRzID0gdGhpcy5tYWpvckdyaWQuZ2V0TmVhcmJ5UG9pbnRzKHBvaW50LCB0aGlzLnBhcmFtcy5kbG9va2FoZWFkKTtcbiAgICAgICAgbmVhcmJ5UG9pbnRzLnB1c2goLi4udGhpcy5taW5vckdyaWQuZ2V0TmVhcmJ5UG9pbnRzKHBvaW50LCB0aGlzLnBhcmFtcy5kbG9va2FoZWFkKSk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBvaW50LmNsb25lKCkuc3ViKHByZXZpb3VzUG9pbnQpO1xuXG4gICAgICAgIGxldCBjbG9zZXN0U2FtcGxlID0gbnVsbDtcbiAgICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIG5lYXJieVBvaW50cykge1xuICAgICAgICAgICAgaWYgKCFzYW1wbGUuZXF1YWxzKHBvaW50KSAmJiAhc2FtcGxlLmVxdWFscyhwcmV2aW91c1BvaW50KSkgey8vICYmICFzdHJlYW1saW5lLmluY2x1ZGVzKHNhbXBsZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlVmVjdG9yID0gc2FtcGxlLmNsb25lKCkuc3ViKHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZmVyZW5jZVZlY3Rvci5kb3QoZGlyZWN0aW9uKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBBY3V0ZSBhbmdsZSBiZXR3ZWVuIHZlY3RvcnMgKGFnbm9zdGljIG9mIENXLCBBQ1cpXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VUb1NhbXBsZSA9IHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHNhbXBsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlVG9TYW1wbGUgPCAyICogdGhpcy5wYXJhbXNTcS5kc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0U2FtcGxlID0gc2FtcGxlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYW5nbGVCZXR3ZWVuID0gTWF0aC5hYnMoVmVjdG9yLmFuZ2xlQmV0d2VlbihkaXJlY3Rpb24sIGRpZmZlcmVuY2VWZWN0b3IpKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBieSBhbmdsZVxuICAgICAgICAgICAgICAgIGlmIChhbmdsZUJldHdlZW4gPCB0aGlzLnBhcmFtcy5qb2luYW5nbGUgJiYgZGlzdGFuY2VUb1NhbXBsZSA8IGNsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZVRvU2FtcGxlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0U2FtcGxlID0gc2FtcGxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gaXMgcmVpbXBsZW1lbnQgc2ltcGxpZnktanMgdG8gcHJlc2VydmUgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgICAgICAvLyAgLSB0aGlzIGlzIHRoZSBwcmltYXJ5IHJlYXNvbiBwb2x5Z29ucyBhcmVuJ3QgZm91bmRcbiAgICAgICAgLy8gSWYgdHJ5aW5nIHRvIGZpbmQgaW50ZXJzZWN0aW9ucyBpbiB0aGUgc2ltcGxpZmllZCBncmFwaFxuICAgICAgICAvLyBwcmV2ZW50IGVuZHMgZ2V0dGluZyBwdWxsZWQgYXdheSBmcm9tIHNpbXBsaWZpZWQgbGluZXNcbiAgICAgICAgaWYgKGNsb3Nlc3RTYW1wbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RTYW1wbGUgPSBjbG9zZXN0U2FtcGxlLmNsb25lKCkuYWRkKGRpcmVjdGlvbi5zZXRMZW5ndGgodGhpcy5wYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2UgKiA0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvc2VzdFNhbXBsZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFzc3VtZXMgcyBoYXMgYWxyZWFkeSBnZW5lcmF0ZWRcbiAgICAgKi9cbiAgICBhZGRFeGlzdGluZ1N0cmVhbWxpbmVzKHM6IFN0cmVhbWxpbmVHZW5lcmF0b3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYWpvckdyaWQuYWRkQWxsKHMubWFqb3JHcmlkKTtcbiAgICAgICAgdGhpcy5taW5vckdyaWQuYWRkQWxsKHMubWlub3JHcmlkKTtcbiAgICB9XG5cbiAgICBzZXRHcmlkKHM6IFN0cmVhbWxpbmVHZW5lcmF0b3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYWpvckdyaWQgPSBzLm1ham9yR3JpZDtcbiAgICAgICAgdGhpcy5taW5vckdyaWQgPSBzLm1pbm9yR3JpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRydWUgaWYgc3RhdGUgdXBkYXRlc1xuICAgICAqL1xuICAgIHVwZGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbWxpbmVzRG9uZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0U3RyZWFtbGluZU1ham9yID0gIXRoaXMubGFzdFN0cmVhbWxpbmVNYWpvcjtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVTdHJlYW1saW5lKHRoaXMubGFzdFN0cmVhbWxpbmVNYWpvcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYXQgb25jZSAtIHdpbGwgZnJlZXplIGlmIGRzZXAgc21hbGxcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbGxTdHJlYW1saW5lcyhhbmltYXRlPWZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtbGluZXNEb25lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICghYW5pbWF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBtYWpvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY3JlYXRlU3RyZWFtbGluZShtYWpvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFqb3IgPSAhbWFqb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKCgpID0+IHRoaXMuam9pbkRhbmdsaW5nU3RyZWFtbGluZXMoKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNpbXBsaWZ5U3RyZWFtbGluZShzdHJlYW1saW5lOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgY29uc3Qgc2ltcGxpZmllZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHNpbXBsaWZ5KHN0cmVhbWxpbmUsIHRoaXMucGFyYW1zLnNpbXBsaWZ5VG9sZXJhbmNlKSkge1xuICAgICAgICAgICAgc2ltcGxpZmllZC5wdXNoKG5ldyBWZWN0b3IocG9pbnQueCwgcG9pbnQueSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGlmaWVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHNlZWQgYW5kIGNyZWF0ZXMgYSBzdHJlYW1saW5lIGZyb20gdGhhdCBwb2ludFxuICAgICAqIFB1c2hlcyBuZXcgY2FuZGlkYXRlIHNlZWRzIHRvIHF1ZXVlXG4gICAgICogQHJldHVybiB7VmVjdG9yW119IHJldHVybnMgZmFsc2UgaWYgc2VlZCBpc24ndCBmb3VuZCB3aXRoaW4gcGFyYW1zLnNlZWRUcmllc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVTdHJlYW1saW5lKG1ham9yOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHNlZWQgPSB0aGlzLmdldFNlZWQobWFqb3IpO1xuICAgICAgICBpZiAoc2VlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbWxpbmUgPSB0aGlzLmludGVncmF0ZVN0cmVhbWxpbmUoc2VlZCwgbWFqb3IpO1xuICAgICAgICBpZiAodGhpcy52YWxpZFN0cmVhbWxpbmUoc3RyZWFtbGluZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoc3RyZWFtbGluZSk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzKG1ham9yKS5wdXNoKHN0cmVhbWxpbmUpO1xuICAgICAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcy5wdXNoKHN0cmVhbWxpbmUpO1xuXG4gICAgICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnB1c2godGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUoc3RyZWFtbGluZSkpO1xuXG4gICAgICAgICAgICAvLyBBZGQgY2FuZGlkYXRlIHNlZWRzXG4gICAgICAgICAgICBpZiAoIXN0cmVhbWxpbmVbMF0uZXF1YWxzKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmRpZGF0ZVNlZWRzKCFtYWpvcikucHVzaChzdHJlYW1saW5lWzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmRpZGF0ZVNlZWRzKCFtYWpvcikucHVzaChzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHZhbGlkU3RyZWFtbGluZShzOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gcy5sZW5ndGggPiA1O1xuICAgIH0gXG5cbiAgICBwcm90ZWN0ZWQgc2V0UGFyYW1zU3EoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGFyYW1zU3EgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcyk7XG4gICAgICAgIGZvciAoY29uc3QgcCBpbiB0aGlzLnBhcmFtc1NxKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyYW1zU3FbcF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtc1NxW3BdICo9IHRoaXMucGFyYW1zU3FbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2FtcGxlUG9pbnQoKTogVmVjdG9yIHtcbiAgICAgICAgLy8gVE9ETyBiZXR0ZXIgc2VlZGluZyBzY2hlbWVcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoXG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogdGhpcy53b3JsZERpbWVuc2lvbnMueCxcbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiB0aGlzLndvcmxkRGltZW5zaW9ucy55KVxuICAgICAgICAgICAgLmFkZCh0aGlzLm9yaWdpbik7XG4gICAgfVxuIFxuICAgIC8qKlxuICAgICAqIFRyaWVzIHRoaXMuY2FuZGlkYXRlU2VlZHMgZmlyc3QsIHRoZW4gc2FtcGxlcyB1c2luZyB0aGlzLnNhbXBsZVBvaW50XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldFNlZWQobWFqb3I6IGJvb2xlYW4pOiBWZWN0b3Ige1xuICAgICAgICAvLyBDYW5kaWRhdGUgc2VlZHMgZmlyc3RcbiAgICAgICAgaWYgKHRoaXMuU0VFRF9BVF9FTkRQT0lOVFMgJiYgdGhpcy5jYW5kaWRhdGVTZWVkcyhtYWpvcikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2FuZGlkYXRlU2VlZHMobWFqb3IpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWVkID0gdGhpcy5jYW5kaWRhdGVTZWVkcyhtYWpvcikucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFNhbXBsZShtYWpvciwgc2VlZCwgdGhpcy5wYXJhbXNTcS5kc2VwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VlZCA9IHRoaXMuc2FtcGxlUG9pbnQoKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoIXRoaXMuaXNWYWxpZFNhbXBsZShtYWpvciwgc2VlZCwgdGhpcy5wYXJhbXNTcS5kc2VwKSkge1xuICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5wYXJhbXMuc2VlZFRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVkID0gdGhpcy5zYW1wbGVQb2ludCgpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlZWQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzVmFsaWRTYW1wbGUobWFqb3I6IGJvb2xlYW4sIHBvaW50OiBWZWN0b3IsIGRTcTogbnVtYmVyLCBib3RoR3JpZHM9ZmFsc2UpOiBib29sZWFuIHtcbiAgICAgICAgLy8gZFNxID0gZFNxICogcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoVmVjdG9yLnplcm9WZWN0b3IoKSk7XG4gICAgICAgIGxldCBncmlkVmFsaWQgPSB0aGlzLmdyaWQobWFqb3IpLmlzVmFsaWRTYW1wbGUocG9pbnQsIGRTcSk7XG4gICAgICAgIGlmIChib3RoR3JpZHMpIHtcbiAgICAgICAgICAgIGdyaWRWYWxpZCA9IGdyaWRWYWxpZCAmJiB0aGlzLmdyaWQoIW1ham9yKS5pc1ZhbGlkU2FtcGxlKHBvaW50LCBkU3EpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmludGVncmF0b3Iub25MYW5kKHBvaW50KSAmJiBncmlkVmFsaWQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGNhbmRpZGF0ZVNlZWRzKG1ham9yOiBib29sZWFuKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gbWFqb3IgPyB0aGlzLmNhbmRpZGF0ZVNlZWRzTWFqb3IgOiB0aGlzLmNhbmRpZGF0ZVNlZWRzTWlub3I7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVzKG1ham9yOiBib29sZWFuKTogVmVjdG9yW11bXSB7XG4gICAgICAgIHJldHVybiBtYWpvciA/IHRoaXMuc3RyZWFtbGluZXNNYWpvciA6IHRoaXMuc3RyZWFtbGluZXNNaW5vcjtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ3JpZChtYWpvcjogYm9vbGVhbik6IEdyaWRTdG9yYWdlIHtcbiAgICAgICAgcmV0dXJuIG1ham9yID8gdGhpcy5tYWpvckdyaWQgOiB0aGlzLm1pbm9yR3JpZDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcG9pbnRJbkJvdW5kcyh2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh2LnggPj0gdGhpcy5vcmlnaW4ueFxuICAgICAgICAgICAgJiYgdi55ID49IHRoaXMub3JpZ2luLnlcbiAgICAgICAgICAgICYmIHYueCA8IHRoaXMud29ybGREaW1lbnNpb25zLnggKyB0aGlzLm9yaWdpbi54XG4gICAgICAgICAgICAmJiB2LnkgPCB0aGlzLndvcmxkRGltZW5zaW9ucy55ICsgdGhpcy5vcmlnaW4ueVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpZG4ndCBlbmQgdXAgdXNpbmcgLSBiaXQgZXhwZW5zaXZlLCB1c2VkIHN0cmVhbWxpbmVUdXJuZWQgaW5zdGVhZFxuICAgICAqIFN0b3BzIHNwaXJhbHMgZnJvbSBmb3JtaW5nXG4gICAgICogdXNlcyAwLjUgZGNpcmNsZWpvaW4gc28gdGhhdCBjaXJjbGVzIGFyZSBzdGlsbCBqb2luZWQgdXBcbiAgICAgKiB0ZXN0U2FtcGxlIGlzIGNhbmRpZGF0ZSB0byBwdXNoZWQgb24gZW5kIG9mIHN0cmVhbWxpbmVGb3J3YXJkc1xuICAgICAqIHJldHVybnMgdHJ1ZSBpZiBzdHJlYW1saW5lIGNvbGxpZGVzIHdpdGggaXRzZWxmXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRvZXNTdHJlYW1saW5lQ29sbGlkZVNlbGYodGVzdFNhbXBsZTogVmVjdG9yLCBzdHJlYW1saW5lRm9yd2FyZHM6IFZlY3RvcltdLCBzdHJlYW1saW5lQmFja3dhcmRzOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBTdHJlYW1saW5lIGxvbmcgZW5vdWdoXG4gICAgICAgIGlmIChzdHJlYW1saW5lRm9yd2FyZHMubGVuZ3RoID4gdGhpcy5uU3RyZWFtbGluZUxvb2tCYWNrKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkcyBjaGVja1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJlYW1saW5lRm9yd2FyZHMubGVuZ3RoIC0gdGhpcy5uU3RyZWFtbGluZUxvb2tCYWNrOyBpICs9IHRoaXMublN0cmVhbWxpbmVTdGVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RTYW1wbGUuZGlzdGFuY2VUb1NxdWFyZWQoc3RyZWFtbGluZUZvcndhcmRzW2ldKSA8IHRoaXMuZGNvbGxpZGVzZWxmU3EpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMgY2hlY2tcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZUJhY2t3YXJkcy5sZW5ndGg7IGkgKz0gdGhpcy5uU3RyZWFtbGluZVN0ZXApIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFNhbXBsZS5kaXN0YW5jZVRvU3F1YXJlZChzdHJlYW1saW5lQmFja3dhcmRzW2ldKSA8IHRoaXMuZGNvbGxpZGVzZWxmU3EpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgc3RyZWFtbGluZSBoYXMgdHVybmVkIHRocm91Z2ggZ3JlYXRlciB0aGFuIDE4MCBkZWdyZWVzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVUdXJuZWQoc2VlZDogVmVjdG9yLCBvcmlnaW5hbERpcjogVmVjdG9yLCBwb2ludDogVmVjdG9yLCBkaXJlY3Rpb246IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAob3JpZ2luYWxEaXIuZG90KGRpcmVjdGlvbikgPCAwKSB7XG4gICAgICAgICAgICAvLyBUT0RPIG9wdGltaXNlXG4gICAgICAgICAgICBjb25zdCBwZXJwZW5kaWN1bGFyVmVjdG9yID0gbmV3IFZlY3RvcihvcmlnaW5hbERpci55LCAtb3JpZ2luYWxEaXIueCk7XG4gICAgICAgICAgICBjb25zdCBpc0xlZnQgPSBwb2ludC5jbG9uZSgpLnN1YihzZWVkKS5kb3QocGVycGVuZGljdWxhclZlY3RvcikgPCAwO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uVXAgPSBkaXJlY3Rpb24uZG90KHBlcnBlbmRpY3VsYXJWZWN0b3IpID4gMDtcbiAgICAgICAgICAgIHJldHVybiBpc0xlZnQgPT09IGRpcmVjdGlvblVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIC8vIFRPRE8gdGhpcyBkb2Vzbid0IHdvcmsgd2VsbCAtIGNvbnNpZGVyIHNvbWV0aGluZyBkaXNhbGxvd2luZyBvbmUgZGlyZWN0aW9uIChGL0IpIHRvIHR1cm4gbW9yZSB0aGFuIDE4MCBkZWdcbiAgICAgKiBPbmUgc3RlcCBvZiB0aGUgc3RyZWFtbGluZSBpbnRlZ3JhdGlvbiBwcm9jZXNzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVJbnRlZ3JhdGlvblN0ZXAocGFyYW1zOiBTdHJlYW1saW5lSW50ZWdyYXRpb24sIG1ham9yOiBib29sZWFuLCBjb2xsaWRlQm90aDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBpZiAocGFyYW1zLnZhbGlkKSB7XG4gICAgICAgICAgICBwYXJhbXMuc3RyZWFtbGluZS5wdXNoKHBhcmFtcy5wcmV2aW91c1BvaW50KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHREaXJlY3Rpb24gPSB0aGlzLmludGVncmF0b3IuaW50ZWdyYXRlKHBhcmFtcy5wcmV2aW91c1BvaW50LCBtYWpvcik7XG5cbiAgICAgICAgICAgIC8vIFN0b3AgYXQgZGVnZW5lcmF0ZSBwb2ludFxuICAgICAgICAgICAgaWYgKG5leHREaXJlY3Rpb24ubGVuZ3RoU3EoKSA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB0cmF2ZWwgaW4gdGhlIHNhbWUgZGlyZWN0aW9uXG4gICAgICAgICAgICBpZiAobmV4dERpcmVjdGlvbi5kb3QocGFyYW1zLnByZXZpb3VzRGlyZWN0aW9uKSA8IDApIHtcbiAgICAgICAgICAgICAgICBuZXh0RGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuZXh0UG9pbnQgPSBwYXJhbXMucHJldmlvdXNQb2ludC5jbG9uZSgpLmFkZChuZXh0RGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgLy8gVmlzdWFsaXNlIHN0b3BwaW5nIHBvaW50c1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMuc3RyZWFtbGluZVR1cm5lZChwYXJhbXMuc2VlZCwgcGFyYW1zLm9yaWdpbmFsRGlyLCBuZXh0UG9pbnQsIG5leHREaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAvLyAgICAgcGFyYW1zLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyAgICAgcGFyYW1zLnN0cmVhbWxpbmUucHVzaChWZWN0b3IuemVyb1ZlY3RvcigpKTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRJbkJvdW5kcyhuZXh0UG9pbnQpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5pc1ZhbGlkU2FtcGxlKG1ham9yLCBuZXh0UG9pbnQsIHRoaXMucGFyYW1zU3EuZHRlc3QsIGNvbGxpZGVCb3RoKVxuICAgICAgICAgICAgICAgICYmICF0aGlzLnN0cmVhbWxpbmVUdXJuZWQocGFyYW1zLnNlZWQsIHBhcmFtcy5vcmlnaW5hbERpciwgbmV4dFBvaW50LCBuZXh0RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wcmV2aW91c1BvaW50ID0gbmV4dFBvaW50O1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wcmV2aW91c0RpcmVjdGlvbiA9IG5leHREaXJlY3Rpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE9uZSBtb3JlIHN0ZXBcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RyZWFtbGluZS5wdXNoKG5leHRQb2ludCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCeSBzaW11bHRhbmVvdXNseSBpbnRlZ3JhdGluZyBpbiBib3RoIGRpcmVjdGlvbnMgd2UgcmVkdWNlIHRoZSBpbXBhY3Qgb2YgY2lyY2xlcyBub3Qgam9pbmluZ1xuICAgICAqIHVwIGFzIHRoZSBlcnJvciBtYXRjaGVzIGF0IHRoZSBqb2luXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGludGVncmF0ZVN0cmVhbWxpbmUoc2VlZDogVmVjdG9yLCBtYWpvcjogYm9vbGVhbik6IFZlY3RvcltdIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IHBvaW50c0VzY2FwZWQgPSBmYWxzZTsgIC8vIFRydWUgb25jZSB0d28gaW50ZWdyYXRpb24gZnJvbnRzIGhhdmUgbW92ZWQgZGxvb2thaGVhZCBhd2F5XG5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3QgdG8gdGVzdCB2YWxpZGl0eSB1c2luZyBib3RoIGdyaWQgc3RvcmFnZXNcbiAgICAgICAgLy8gKENvbGxpZGUgd2l0aCBib3RoIG1ham9yIGFuZCBtaW5vcilcbiAgICAgICAgY29uc3QgY29sbGlkZUJvdGggPSBNYXRoLnJhbmRvbSgpIDwgdGhpcy5wYXJhbXMuY29sbGlkZUVhcmx5O1xuXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmludGVncmF0b3IuaW50ZWdyYXRlKHNlZWQsIG1ham9yKTtcblxuICAgICAgICBjb25zdCBmb3J3YXJkUGFyYW1zOiBTdHJlYW1saW5lSW50ZWdyYXRpb24gPSB7XG4gICAgICAgICAgICBzZWVkOiBzZWVkLFxuICAgICAgICAgICAgb3JpZ2luYWxEaXI6IGQsXG4gICAgICAgICAgICBzdHJlYW1saW5lOiBbc2VlZF0sXG4gICAgICAgICAgICBwcmV2aW91c0RpcmVjdGlvbjogZCxcbiAgICAgICAgICAgIHByZXZpb3VzUG9pbnQ6IHNlZWQuY2xvbmUoKS5hZGQoZCksXG4gICAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcndhcmRQYXJhbXMudmFsaWQgPSB0aGlzLnBvaW50SW5Cb3VuZHMoZm9yd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcblxuICAgICAgICBjb25zdCBuZWdEID0gZC5jbG9uZSgpLm5lZ2F0ZSgpO1xuICAgICAgICBjb25zdCBiYWNrd2FyZFBhcmFtczogU3RyZWFtbGluZUludGVncmF0aW9uID0ge1xuICAgICAgICAgICAgc2VlZDogc2VlZCxcbiAgICAgICAgICAgIG9yaWdpbmFsRGlyOiBuZWdELFxuICAgICAgICAgICAgc3RyZWFtbGluZTogW10sXG4gICAgICAgICAgICBwcmV2aW91c0RpcmVjdGlvbjogbmVnRCxcbiAgICAgICAgICAgIHByZXZpb3VzUG9pbnQ6IHNlZWQuY2xvbmUoKS5hZGQobmVnRCksXG4gICAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGJhY2t3YXJkUGFyYW1zLnZhbGlkID0gdGhpcy5wb2ludEluQm91bmRzKGJhY2t3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQpO1xuXG4gICAgICAgIHdoaWxlIChjb3VudCA8IHRoaXMucGFyYW1zLnBhdGhJdGVyYXRpb25zICYmIChmb3J3YXJkUGFyYW1zLnZhbGlkIHx8IGJhY2t3YXJkUGFyYW1zLnZhbGlkKSkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1saW5lSW50ZWdyYXRpb25TdGVwKGZvcndhcmRQYXJhbXMsIG1ham9yLCBjb2xsaWRlQm90aCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVJbnRlZ3JhdGlvblN0ZXAoYmFja3dhcmRQYXJhbXMsIG1ham9yLCBjb2xsaWRlQm90aCk7XG5cbiAgICAgICAgICAgIC8vIEpvaW4gdXAgY2lyY2xlc1xuICAgICAgICAgICAgY29uc3Qgc3FEaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBmb3J3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoYmFja3dhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG5cbiAgICAgICAgICAgIGlmICghcG9pbnRzRXNjYXBlZCAmJiBzcURpc3RhbmNlQmV0d2VlblBvaW50cyA+IHRoaXMucGFyYW1zU3EuZGNpcmNsZWpvaW4pIHtcbiAgICAgICAgICAgICAgICBwb2ludHNFc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvaW50c0VzY2FwZWQgJiYgc3FEaXN0YW5jZUJldHdlZW5Qb2ludHMgPD0gdGhpcy5wYXJhbXNTcS5kY2lyY2xlam9pbikge1xuICAgICAgICAgICAgICAgIGZvcndhcmRQYXJhbXMuc3RyZWFtbGluZS5wdXNoKGZvcndhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFBhcmFtcy5zdHJlYW1saW5lLnB1c2goYmFja3dhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XG4gICAgICAgICAgICAgICAgYmFja3dhcmRQYXJhbXMuc3RyZWFtbGluZS5wdXNoKGJhY2t3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFja3dhcmRQYXJhbXMuc3RyZWFtbGluZS5yZXZlcnNlKCkucHVzaCguLi5mb3J3YXJkUGFyYW1zLnN0cmVhbWxpbmUpO1xuICAgICAgICByZXR1cm4gYmFja3dhcmRQYXJhbXMuc3RyZWFtbGluZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbnNvciB7XG4gICAgcHJpdmF0ZSBvbGRUaGV0YTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF90aGV0YTogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByOiBudW1iZXIsIHByaXZhdGUgbWF0cml4OiBudW1iZXJbXSkge1xuICAgICAgICAvLyBNYXRyaXggaXMgMiBlbGVtZW50IGxpc3RcbiAgICAgICAgLy8gWyAwLCAxXG4gICAgICAgIC8vICAgMSwgLTAgXVxuICAgICAgICB0aGlzLm9sZFRoZXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RoZXRhID0gdGhpcy5jYWxjdWxhdGVUaGV0YSgpO1xuICAgIH1cblxuICAgIGdldCB0aGV0YSgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5vbGRUaGV0YSkge1xuICAgICAgICAgICAgdGhpcy5fdGhldGEgPSB0aGlzLmNhbGN1bGF0ZVRoZXRhKCk7XG4gICAgICAgICAgICB0aGlzLm9sZFRoZXRhID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdGhldGE7XG4gICAgfVxuXG4gICAgYWRkKHRlbnNvcjogVGVuc29yKTogVGVuc29yIHtcbiAgICAgICAgdGhpcy5tYXRyaXggPSB0aGlzLm1hdHJpeC5tYXAoKHYsIGkpID0+IHYgKiB0aGlzLnIgKyB0ZW5zb3IubWF0cml4W2ldICogdGVuc29yLnIpO1xuICAgICAgICB0aGlzLnIgPSAyO1xuICAgICAgICB0aGlzLm9sZFRoZXRhID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2NhbGUoczogbnVtYmVyKTogVGVuc29yIHtcbiAgICAgICAgdGhpcy5yICo9IHM7XG4gICAgICAgIHRoaXMub2xkVGhldGEgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBSYWRpYW5zXG4gICAgcm90YXRlKHRoZXRhOiBudW1iZXIpOiBUZW5zb3Ige1xuICAgICAgICBpZiAodGhldGEgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdUaGV0YSA9IHRoaXMudGhldGEgKyB0aGV0YTtcbiAgICAgICAgaWYgKG5ld1RoZXRhIDwgTWF0aC5QSSkge1xuICAgICAgICAgICAgbmV3VGhldGEgKz0gTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdUaGV0YSA+PSBNYXRoLlBJKSB7XG4gICAgICAgICAgICBuZXdUaGV0YSAtPSBNYXRoLlBJO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXRyaXhbMF0gPSBNYXRoLmNvcygyICogbmV3VGhldGEpICogdGhpcy5yO1xuICAgICAgICB0aGlzLm1hdHJpeFsxXSA9IE1hdGguc2luKDIgKiBuZXdUaGV0YSkgKiB0aGlzLnI7XG4gICAgICAgIHRoaXMuX3RoZXRhID0gbmV3VGhldGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldE1ham9yKCk6IFZlY3RvciB7XG4gICAgICAgIC8vIERlZ2VuZXJhdGUgY2FzZVxuICAgICAgICBpZiAodGhpcy5yID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLnplcm9WZWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLmNvcyh0aGlzLnRoZXRhKSwgTWF0aC5zaW4odGhpcy50aGV0YSkpO1xuICAgIH1cblxuICAgIGdldE1pbm9yKCk6IFZlY3RvciB7XG4gICAgICAgIC8vIERlZ2VuZXJhdGUgY2FzZVxuICAgICAgICBpZiAodGhpcy5yID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLnplcm9WZWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmdsZSA9IHRoaXMudGhldGEgKyBNYXRoLlBJIC8gMjtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2FsY3VsYXRlVGhldGEoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5tYXRyaXhbMV0gLyB0aGlzLnIsIHRoaXMubWF0cml4WzBdIC8gdGhpcy5yKSAvIDI7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbi8vIGltcG9ydCAqIGFzIG5vaXNlIGZyb20gJ25vaXNlanMnO1xuaW1wb3J0ICogYXMgU2ltcGxleE5vaXNlIGZyb20gJ3NpbXBsZXgtbm9pc2UnO1xuaW1wb3J0IFRlbnNvciBmcm9tICcuL3RlbnNvcic7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge0dyaWQsIFJhZGlhbCwgQmFzaXNGaWVsZH0gZnJvbSAnLi9iYXNpc19maWVsZCc7XG5pbXBvcnQgUG9seWdvblV0aWwgZnJvbSAnLi9wb2x5Z29uX3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vaXNlUGFyYW1zIHtcbiAgICBnbG9iYWxOb2lzZTogYm9vbGVhbjtcbiAgICBub2lzZVNpemVQYXJrOiBudW1iZXI7XG4gICAgbm9pc2VBbmdsZVBhcms6IG51bWJlcjsgIC8vIERlZ3JlZXNcbiAgICBub2lzZVNpemVHbG9iYWw6IG51bWJlcjtcbiAgICBub2lzZUFuZ2xlR2xvYmFsOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbnNvckZpZWxkIHtcbiAgICBwcml2YXRlIGJhc2lzRmllbGRzOiBCYXNpc0ZpZWxkW10gPSBbXTtcbiAgICBwcml2YXRlIG5vaXNlOiBTaW1wbGV4Tm9pc2U7XG5cbiAgICBwdWJsaWMgcGFya3M6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwdWJsaWMgc2VhOiBWZWN0b3JbXSA9IFtdO1xuICAgIHB1YmxpYyByaXZlcjogVmVjdG9yW10gPSBbXTtcbiAgICBwdWJsaWMgaWdub3JlUml2ZXIgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBub2lzZVBhcmFtczogTm9pc2VQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5ub2lzZSA9IG5ldyBTaW1wbGV4Tm9pc2UoKTtcbiAgICB9XG5cbiAgICBlbmFibGVHbG9iYWxOb2lzZShhbmdsZTogbnVtYmVyLCBzaXplOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ub2lzZVBhcmFtcy5nbG9iYWxOb2lzZSA9IHRydWU7XG4gICAgICAgIHRoaXMubm9pc2VQYXJhbXMubm9pc2VBbmdsZUdsb2JhbCA9IGFuZ2xlO1xuICAgICAgICB0aGlzLm5vaXNlUGFyYW1zLm5vaXNlU2l6ZUdsb2JhbCA9IHNpemU7XG4gICAgfVxuXG4gICAgZGlzYWJsZUdsb2JhbE5vaXNlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm5vaXNlUGFyYW1zLmdsb2JhbE5vaXNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkR3JpZChjZW50cmU6IFZlY3Rvciwgc2l6ZTogbnVtYmVyLCBkZWNheTogbnVtYmVyLCB0aGV0YTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSBuZXcgR3JpZChjZW50cmUsIHNpemUsIGRlY2F5LCB0aGV0YSk7XG4gICAgICAgIHRoaXMuYWRkRmllbGQoZ3JpZCk7ICAgICAgICBcbiAgICB9XG5cbiAgICBhZGRSYWRpYWwoY2VudHJlOiBWZWN0b3IsIHNpemU6IG51bWJlciwgZGVjYXk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCByYWRpYWwgPSBuZXcgUmFkaWFsKGNlbnRyZSwgc2l6ZSwgZGVjYXkpO1xuICAgICAgICB0aGlzLmFkZEZpZWxkKHJhZGlhbCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFkZEZpZWxkKGZpZWxkOiBCYXNpc0ZpZWxkKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYmFzaXNGaWVsZHMucHVzaChmaWVsZCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlbW92ZUZpZWxkKGZpZWxkOiBCYXNpc0ZpZWxkKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5iYXNpc0ZpZWxkcy5pbmRleE9mKGZpZWxkKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzaXNGaWVsZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJhc2lzRmllbGRzID0gW107XG4gICAgICAgIHRoaXMucGFya3MgPSBbXTtcbiAgICAgICAgdGhpcy5zZWEgPSBbXTtcbiAgICAgICAgdGhpcy5yaXZlciA9IFtdO1xuICAgIH1cblxuICAgIGdldENlbnRyZVBvaW50cygpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2lzRmllbGRzLm1hcChmaWVsZCA9PiBmaWVsZC5jZW50cmUpO1xuICAgIH1cblxuICAgIHNhbXBsZVBvaW50KHBvaW50OiBWZWN0b3IpOiBUZW5zb3Ige1xuICAgICAgICBpZiAoIXRoaXMub25MYW5kKHBvaW50KSkge1xuICAgICAgICAgICAgLy8gRGVnZW5lcmF0ZSBwb2ludFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoMCwgWzAsMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCBmaWVsZCBpcyBhIGdyaWRcbiAgICAgICAgaWYgKHRoaXMuYmFzaXNGaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigxLCBbMCwgMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVuc29yQWNjID0gbmV3IFRlbnNvcigwLCBbMCwgMF0pO1xuICAgICAgICB0aGlzLmJhc2lzRmllbGRzLmZvckVhY2goZmllbGQgPT4gdGVuc29yQWNjLmFkZChmaWVsZC5nZXRXZWlnaHRlZFRlbnNvcihwb2ludCkpKTtcblxuICAgICAgICAvLyBBZGQgcm90YXRpb25hbCBub2lzZSBmb3IgcGFya3MgLSByYW5nZSAtcGkvMiB0byBwaS8yXG4gICAgICAgIGlmICh0aGlzLnBhcmtzLnNvbWUocCA9PiBQb2x5Z29uVXRpbC5pbnNpZGVQb2x5Z29uKHBvaW50LCBwKSkpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gb3B0aW1pc2UgaW5zaWRlUG9seWdvbiBlLmcuIGRpc3RhbmNlXG4gICAgICAgICAgICB0ZW5zb3JBY2Mucm90YXRlKHRoaXMuZ2V0Um90YXRpb25hbE5vaXNlKHBvaW50LCB0aGlzLm5vaXNlUGFyYW1zLm5vaXNlU2l6ZVBhcmssIHRoaXMubm9pc2VQYXJhbXMubm9pc2VBbmdsZVBhcmspKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5vaXNlUGFyYW1zLmdsb2JhbE5vaXNlKSB7XG4gICAgICAgICAgICB0ZW5zb3JBY2Mucm90YXRlKHRoaXMuZ2V0Um90YXRpb25hbE5vaXNlKHBvaW50LCB0aGlzLm5vaXNlUGFyYW1zLm5vaXNlU2l6ZUdsb2JhbCwgdGhpcy5ub2lzZVBhcmFtcy5ub2lzZUFuZ2xlR2xvYmFsKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGVuc29yQWNjO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vaXNlIEFuZ2xlIGlzIGluIGRlZ3JlZXNcbiAgICAgKi9cbiAgICBnZXRSb3RhdGlvbmFsTm9pc2UocG9pbnQ6IFZlY3Rvciwgbm9pc2VTaXplOiBudW1iZXIsIG5vaXNlQW5nbGU6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vaXNlLm5vaXNlMkQocG9pbnQueCAvIG5vaXNlU2l6ZSwgcG9pbnQueSAvIG5vaXNlU2l6ZSkgKiBub2lzZUFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICB9XG5cbiAgICBvbkxhbmQocG9pbnQ6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBpblNlYSA9IFBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24ocG9pbnQsIHRoaXMuc2VhKTtcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlUml2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAhaW5TZWE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIWluU2VhICYmICFQb2x5Z29uVXRpbC5pbnNpZGVQb2x5Z29uKHBvaW50LCB0aGlzLnJpdmVyKTtcbiAgICB9XG5cbiAgICBpblBhcmtzKHBvaW50OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFya3MpIHtcbiAgICAgICAgICAgIGlmIChQb2x5Z29uVXRpbC5pbnNpZGVQb2x5Z29uKHBvaW50LCBwKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBzaW1wbGlmeSBmcm9tICdzaW1wbGlmeS1qcyc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgR3JpZFN0b3JhZ2UgZnJvbSAnLi9ncmlkX3N0b3JhZ2UnO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuL2ludGVncmF0b3InO1xuaW1wb3J0IFN0cmVhbWxpbmVHZW5lcmF0b3IgZnJvbSAnLi9zdHJlYW1saW5lcyc7XG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4vc3RyZWFtbGluZXMnO1xuaW1wb3J0IFRlbnNvckZpZWxkIGZyb20gJy4vdGVuc29yX2ZpZWxkJztcbmltcG9ydCBQb2x5Z29uVXRpbCBmcm9tICcuL3BvbHlnb25fdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2F0ZXJQYXJhbXMgZXh0ZW5kcyBTdHJlYW1saW5lUGFyYW1zIHtcbiAgICBjb2FzdE5vaXNlOiBOb2lzZVN0cmVhbWxpbmVQYXJhbXM7XG4gICAgcml2ZXJOb2lzZTogTm9pc2VTdHJlYW1saW5lUGFyYW1zO1xuICAgIHJpdmVyQmFua1NpemU6IG51bWJlcjtcbiAgICByaXZlclNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb2lzZVN0cmVhbWxpbmVQYXJhbXMge1xuICAgIG5vaXNlRW5hYmxlZDogYm9vbGVhbjtcbiAgICBub2lzZVNpemU6IG51bWJlcjtcbiAgICBub2lzZUFuZ2xlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhdGVyR2VuZXJhdG9yIGV4dGVuZHMgU3RyZWFtbGluZUdlbmVyYXRvciB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBUUklFUyA9IDEwMDtcbiAgICBwcml2YXRlIGNvYXN0bGluZU1ham9yID0gdHJ1ZTtcbiAgICBwcml2YXRlIF9jb2FzdGxpbmU6IFZlY3RvcltdID0gW107ICAvLyBOb2lzeSBsaW5lXG4gICAgcHJpdmF0ZSBfc2VhUG9seWdvbjogVmVjdG9yW10gPSBbXTsgIC8vIFVzZXMgc2NyZWVuIHJlY3RhbmdsZSBhbmQgc2ltcGxpZmllZCByb2FkXG4gICAgcHJpdmF0ZSBfcml2ZXJQb2x5Z29uOiBWZWN0b3JbXSA9IFtdOyAvLyBTaW1wbGlmaWVkXG4gICAgcHJpdmF0ZSBfcml2ZXJTZWNvbmRhcnlSb2FkOiBWZWN0b3JbXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IoaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogVmVjdG9yLFxuICAgICAgICAgICAgICAgIHdvcmxkRGltZW5zaW9uczogVmVjdG9yLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJhbXM6IFdhdGVyUGFyYW1zLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkKSB7XG4gICAgICAgIHN1cGVyKGludGVncmF0b3IsIG9yaWdpbiwgd29ybGREaW1lbnNpb25zLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGdldCBjb2FzdGxpbmUoKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29hc3RsaW5lO1xuICAgIH1cblxuICAgIGdldCBzZWFQb2x5Z29uKCk6IFZlY3RvcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlYVBvbHlnb247XG4gICAgfVxuXG4gICAgZ2V0IHJpdmVyUG9seWdvbigpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaXZlclBvbHlnb247XG4gICAgfVxuXG4gICAgZ2V0IHJpdmVyU2Vjb25kYXJ5Um9hZCgpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaXZlclNlY29uZGFyeVJvYWQ7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29hc3QoKTogdm9pZCB7XG4gICAgICAgIGxldCBjb2FzdFN0cmVhbWxpbmU7XG4gICAgICAgIGxldCBzZWVkO1xuICAgICAgICBsZXQgbWFqb3I7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmNvYXN0Tm9pc2Uubm9pc2VFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRlbnNvckZpZWxkLmVuYWJsZUdsb2JhbE5vaXNlKHRoaXMucGFyYW1zLmNvYXN0Tm9pc2Uubm9pc2VBbmdsZSwgdGhpcy5wYXJhbXMuY29hc3ROb2lzZS5ub2lzZVNpemUpOyAgICBcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuVFJJRVM7IGkrKykge1xuICAgICAgICAgICAgbWFqb3IgPSBNYXRoLnJhbmRvbSgpIDwgMC41O1xuICAgICAgICAgICAgc2VlZCA9IHRoaXMuZ2V0U2VlZChtYWpvcik7XG4gICAgICAgICAgICBjb2FzdFN0cmVhbWxpbmUgPSB0aGlzLmV4dGVuZFN0cmVhbWxpbmUodGhpcy5pbnRlZ3JhdGVTdHJlYW1saW5lKHNlZWQsIG1ham9yKSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWNoZXNFZGdlcyhjb2FzdFN0cmVhbWxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5kaXNhYmxlR2xvYmFsTm9pc2UoKTtcblxuICAgICAgICB0aGlzLl9jb2FzdGxpbmUgPSBjb2FzdFN0cmVhbWxpbmU7XG4gICAgICAgIHRoaXMuY29hc3RsaW5lTWFqb3IgPSBtYWpvcjtcblxuICAgICAgICBjb25zdCByb2FkID0gdGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUoY29hc3RTdHJlYW1saW5lKTtcbiAgICAgICAgdGhpcy5fc2VhUG9seWdvbiA9IHRoaXMuZ2V0U2VhUG9seWdvbihyb2FkKTtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5wdXNoKHJvYWQpO1xuICAgICAgICB0aGlzLnRlbnNvckZpZWxkLnNlYSA9ICh0aGlzLl9zZWFQb2x5Z29uKTtcblxuICAgICAgICAvLyBDcmVhdGUgaW50ZXJtZWRpYXRlIHNhbXBsZXNcbiAgICAgICAgY29uc3QgY29tcGxleCA9IHRoaXMuY29tcGxleGlmeVN0cmVhbWxpbmUocm9hZCk7XG4gICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoY29tcGxleCk7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMobWFqb3IpLnB1c2goY29tcGxleCk7XG4gICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXMucHVzaChjb21wbGV4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVSaXZlcigpOiB2b2lkIHtcbiAgICAgICAgbGV0IHJpdmVyU3RyZWFtbGluZTtcbiAgICAgICAgbGV0IHNlZWQ7XG5cbiAgICAgICAgLy8gTmVlZCB0byBpZ25vcmUgc2VhIHdoZW4gaW50ZWdyYXRpbmcgZm9yIGVkZ2UgY2hlY2tcbiAgICAgICAgY29uc3Qgb2xkU2VhID0gdGhpcy50ZW5zb3JGaWVsZC5zZWE7XG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuc2VhID0gW107XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5yaXZlck5vaXNlLm5vaXNlRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5lbmFibGVHbG9iYWxOb2lzZSh0aGlzLnBhcmFtcy5yaXZlck5vaXNlLm5vaXNlQW5nbGUsIHRoaXMucGFyYW1zLnJpdmVyTm9pc2Uubm9pc2VTaXplKTsgICAgXG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuVFJJRVM7IGkrKykge1xuICAgICAgICAgICAgc2VlZCA9IHRoaXMuZ2V0U2VlZCghdGhpcy5jb2FzdGxpbmVNYWpvcik7XG4gICAgICAgICAgICByaXZlclN0cmVhbWxpbmUgPSB0aGlzLmV4dGVuZFN0cmVhbWxpbmUodGhpcy5pbnRlZ3JhdGVTdHJlYW1saW5lKHNlZWQsICF0aGlzLmNvYXN0bGluZU1ham9yKSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWNoZXNFZGdlcyhyaXZlclN0cmVhbWxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IHRoaXMuVFJJRVMgLSAxKSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdGYWlsZWQgdG8gZmluZCByaXZlciByZWFjaGluZyBlZGdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5zZWEgPSBvbGRTZWE7XG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuZGlzYWJsZUdsb2JhbE5vaXNlKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJpdmVyIHJvYWRzXG4gICAgICAgIGNvbnN0IGV4cGFuZGVkTm9pc3kgPSB0aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lKFBvbHlnb25VdGlsLnJlc2l6ZUdlb21ldHJ5KHJpdmVyU3RyZWFtbGluZSwgdGhpcy5wYXJhbXMucml2ZXJTaXplLCBmYWxzZSkpO1xuICAgICAgICB0aGlzLl9yaXZlclBvbHlnb24gPSBQb2x5Z29uVXRpbC5yZXNpemVHZW9tZXRyeShyaXZlclN0cmVhbWxpbmUsIHRoaXMucGFyYW1zLnJpdmVyU2l6ZSAtIHRoaXMucGFyYW1zLnJpdmVyQmFua1NpemUsIGZhbHNlKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHJpdmVyUG9seWdvblswXSBpcyBvZmYgc2NyZWVuXG4gICAgICAgIGNvbnN0IGZpcnN0T2ZmU2NyZWVuID0gZXhwYW5kZWROb2lzeS5maW5kSW5kZXgodiA9PiB0aGlzLnZlY3Rvck9mZlNjcmVlbih2KSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RPZmZTY3JlZW47IGkrKykge1xuICAgICAgICAgICAgZXhwYW5kZWROb2lzeS5wdXNoKGV4cGFuZGVkTm9pc3kuc2hpZnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgcml2ZXIgcm9hZHNcbiAgICAgICAgY29uc3Qgcml2ZXJTcGxpdFBvbHkgPSB0aGlzLmdldFNlYVBvbHlnb24ocml2ZXJTdHJlYW1saW5lKTtcbiAgICAgICAgY29uc3Qgcm9hZDEgPSBleHBhbmRlZE5vaXN5LmZpbHRlcih2ID0+XG4gICAgICAgICAgICAhUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbih2LCB0aGlzLl9zZWFQb2x5Z29uKVxuICAgICAgICAgICAgJiYgIXRoaXMudmVjdG9yT2ZmU2NyZWVuKHYpXG4gICAgICAgICAgICAmJiBQb2x5Z29uVXRpbC5pbnNpZGVQb2x5Z29uKHYsIHJpdmVyU3BsaXRQb2x5KSk7XG4gICAgICAgIGNvbnN0IHJvYWQxU2ltcGxlID0gdGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUocm9hZDEpO1xuICAgICAgICBjb25zdCByb2FkMiA9IGV4cGFuZGVkTm9pc3kuZmlsdGVyKHYgPT5cbiAgICAgICAgICAgICFQb2x5Z29uVXRpbC5pbnNpZGVQb2x5Z29uKHYsIHRoaXMuX3NlYVBvbHlnb24pXG4gICAgICAgICAgICAmJiAhdGhpcy52ZWN0b3JPZmZTY3JlZW4odilcbiAgICAgICAgICAgICYmICFQb2x5Z29uVXRpbC5pbnNpZGVQb2x5Z29uKHYsIHJpdmVyU3BsaXRQb2x5KSk7XG4gICAgICAgIGNvbnN0IHJvYWQyU2ltcGxlID0gdGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUocm9hZDIpO1xuXG4gICAgICAgIGlmIChyb2FkMS5sZW5ndGggPT09IDAgfHwgcm9hZDIubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHJvYWQxWzBdLmRpc3RhbmNlVG9TcXVhcmVkKHJvYWQyWzBdKSA8IHJvYWQxWzBdLmRpc3RhbmNlVG9TcXVhcmVkKHJvYWQyW3JvYWQyLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgcm9hZDJTaW1wbGUucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5yaXZlciA9IHJvYWQxU2ltcGxlLmNvbmNhdChyb2FkMlNpbXBsZSk7XG5cbiAgICAgICAgLy8gUm9hZCAxXG4gICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXNTaW1wbGUucHVzaChyb2FkMVNpbXBsZSk7XG4gICAgICAgIHRoaXMuX3JpdmVyU2Vjb25kYXJ5Um9hZCA9IHJvYWQyU2ltcGxlO1xuXG4gICAgICAgIHRoaXMuZ3JpZCghdGhpcy5jb2FzdGxpbmVNYWpvcikuYWRkUG9seWxpbmUocm9hZDEpO1xuICAgICAgICB0aGlzLmdyaWQoIXRoaXMuY29hc3RsaW5lTWFqb3IpLmFkZFBvbHlsaW5lKHJvYWQyKTtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyghdGhpcy5jb2FzdGxpbmVNYWpvcikucHVzaChyb2FkMSk7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMoIXRoaXMuY29hc3RsaW5lTWFqb3IpLnB1c2gocm9hZDIpO1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzLnB1c2gocm9hZDEpO1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzLnB1c2gocm9hZDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc3VtZXMgc2ltcGxpZmllZFxuICAgICAqIFVzZWQgZm9yIGFkZGluZyByaXZlciByb2Fkc1xuICAgICAqL1xuICAgIHByaXZhdGUgbWFudWFsbHlBZGRTdHJlYW1saW5lKHM6IFZlY3RvcltdLCBtYWpvcjogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnB1c2gocyk7XG4gICAgICAgIC8vIENyZWF0ZSBpbnRlcm1lZGlhdGUgc2FtcGxlc1xuICAgICAgICBjb25zdCBjb21wbGV4ID0gdGhpcy5jb21wbGV4aWZ5U3RyZWFtbGluZShzKTtcbiAgICAgICAgdGhpcy5ncmlkKG1ham9yKS5hZGRQb2x5bGluZShjb21wbGV4KTtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyhtYWpvcikucHVzaChjb21wbGV4KTtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcy5wdXNoKGNvbXBsZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pZ2h0IHJldmVyc2UgaW5wdXQgYXJyYXlcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFNlYVBvbHlnb24ocG9seWxpbmU6IFZlY3RvcltdKTogVmVjdG9yW10ge1xuICAgICAgICBjb25zdCBzZWFQb2x5Z29uID0gUG9seWdvblV0aWwuc2xpY2VSZWN0YW5nbGUodGhpcy5vcmlnaW4sIHRoaXMud29ybGREaW1lbnNpb25zLFxuICAgICAgICAgICAgcG9seWxpbmVbMF0sIHBvbHlsaW5lW3BvbHlsaW5lLmxlbmd0aCAtIDFdKTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBsb25nZXN0IHNpZGUgd2l0aCBjb2FzdGxpbmVcbiAgICAgICAgbGV0IGxvbmdlc3RJbmRleCA9IDA7XG4gICAgICAgIGxldCBsb25nZXN0TGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFQb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gKGkgKyAxKSAlIHNlYVBvbHlnb24ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZCA9IHNlYVBvbHlnb25baV0uZGlzdGFuY2VUb1NxdWFyZWQoc2VhUG9seWdvbltuZXh0XSk7XG4gICAgICAgICAgICBpZiAoZCA+IGxvbmdlc3RMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb25nZXN0TGVuZ3RoID0gZDtcbiAgICAgICAgICAgICAgICBsb25nZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5zZXJ0QmFja3dhcmRzID0gc2VhUG9seWdvbltsb25nZXN0SW5kZXhdLmRpc3RhbmNlVG9TcXVhcmVkKHBvbHlsaW5lWzBdKSA+IHNlYVBvbHlnb25bbG9uZ2VzdEluZGV4XS5kaXN0YW5jZVRvU3F1YXJlZChwb2x5bGluZVtwb2x5bGluZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChpbnNlcnRCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHBvbHlsaW5lLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlYVBvbHlnb24uc3BsaWNlKChsb25nZXN0SW5kZXggKyAxKSAlIHNlYVBvbHlnb24ubGVuZ3RoLCAwLCAuLi5wb2x5bGluZSk7XG4gICAgICAgIHJldHVybiBzZWFQb2x5Z29uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBzYW1wbGVzIGluIHN0cmVhbWxpbmUgdW50aWwgc2VwYXJhdGVkIGJ5IGRzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBjb21wbGV4aWZ5U3RyZWFtbGluZShzOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgbGV0IG91dDogVmVjdG9yW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgb3V0LnB1c2goLi4udGhpcy5jb21wbGV4aWZ5U3RyZWFtbGluZVJlY3Vyc2l2ZShzW2ldLCBzW2krMV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgY29tcGxleGlmeVN0cmVhbWxpbmVSZWN1cnNpdmUodjE6IFZlY3RvciwgdjI6IFZlY3Rvcik6IFZlY3RvcltdIHtcbiAgICAgICAgaWYgKHYxLmRpc3RhbmNlVG9TcXVhcmVkKHYyKSA8PSB0aGlzLnBhcmFtc1NxLmRzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gW3YxLCB2Ml07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZCA9IHYyLmNsb25lKCkuc3ViKHYxKTtcbiAgICAgICAgY29uc3QgaGFsZndheSA9IHYxLmNsb25lKCkuYWRkKGQubXVsdGlwbHlTY2FsYXIoMC41KSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjb21wbGV4ID0gdGhpcy5jb21wbGV4aWZ5U3RyZWFtbGluZVJlY3Vyc2l2ZSh2MSwgaGFsZndheSk7XG4gICAgICAgIGNvbXBsZXgucHVzaCguLi50aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lUmVjdXJzaXZlKGhhbGZ3YXksIHYyKSk7XG4gICAgICAgIHJldHVybiBjb21wbGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11dGF0ZXMgc3RyZWFtbGluZVxuICAgICAqL1xuICAgIHByaXZhdGUgZXh0ZW5kU3RyZWFtbGluZShzdHJlYW1saW5lOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcbiAgICAgICAgICAgIHN0cmVhbWxpbmUudW5zaGlmdChzdHJlYW1saW5lWzBdLmNsb25lKCkuYWRkKFxuICAgICAgICAgICAgICAgIHN0cmVhbWxpbmVbMF0uY2xvbmUoKS5zdWIoc3RyZWFtbGluZVsxXSkuc2V0TGVuZ3RoKHRoaXMucGFyYW1zLmRzdGVwICogNSkpKTtcbiAgICAgICAgICAgIHN0cmVhbWxpbmUucHVzaChzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0uY2xvbmUoKS5hZGQoXG4gICAgICAgICAgICAgICAgc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdLmNsb25lKCkuc3ViKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAyXSkuc2V0TGVuZ3RoKHRoaXMucGFyYW1zLmRzdGVwICogNSkpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW1saW5lO1xuICAgICAgICB9XG5cbiAgICBwcml2YXRlIHJlYWNoZXNFZGdlcyhzdHJlYW1saW5lOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JPZmZTY3JlZW4oc3RyZWFtbGluZVswXSkgJiYgdGhpcy52ZWN0b3JPZmZTY3JlZW4oc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZlY3Rvck9mZlNjcmVlbih2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgdG9PcmlnaW4gPSB2LmNsb25lKCkuc3ViKHRoaXMub3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRvT3JpZ2luLnggPD0gMCB8fCB0b09yaWdpbi55IDw9IDAgfHxcbiAgICAgICAgICAgIHRvT3JpZ2luLnggPj0gdGhpcy53b3JsZERpbWVuc2lvbnMueCB8fCB0b09yaWdpbi55ID49IHRoaXMud29ybGREaW1lbnNpb25zLnk7XG4gICAgfVxufVxuXG4vLyBjcmVhdGVDb2FzdFN0cmVhbWxpbmUoKTogVmVjdG9yW11bXSB7XG4vLyAgICAgICAgIGxldCBjb2FzdFN0cmVhbWxpbmU7XG4vLyAgICAgICAgIGxldCByaXZlclN0cmVhbWxpbmU7XG4vLyAgICAgICAgIGxldCBzZWVkO1xuLy8gICAgICAgICBsZXQgbWFqb3I7XG5cbi8vICAgICAgICAgY29uc3QgZXh0ZW5kU3RyZWFtbGluZSA9IChzdHJlYW1saW5lOiBWZWN0b3JbXSkgPT4ge1xuLy8gICAgICAgICAgICAgc3RyZWFtbGluZS51bnNoaWZ0KHN0cmVhbWxpbmVbMF0uY2xvbmUoKS5hZGQoXG4vLyAgICAgICAgICAgICAgICAgc3RyZWFtbGluZVswXS5jbG9uZSgpLnN1YihzdHJlYW1saW5lWzFdKS5zZXRMZW5ndGgodGhpcy5wYXJhbXMuZHN0ZXAgKiA1KSkpO1xuLy8gICAgICAgICAgICAgc3RyZWFtbGluZS5wdXNoKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXS5jbG9uZSgpLmFkZChcbi8vICAgICAgICAgICAgICAgICBzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0uY2xvbmUoKS5zdWIoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDJdKS5zZXRMZW5ndGgodGhpcy5wYXJhbXMuZHN0ZXAgKiA1KSkpO1xuLy8gICAgICAgICAgICAgcmV0dXJuIHN0cmVhbWxpbmU7XG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICBjb25zdCByZWFjaGVzRWRnZXMgPSAoc3RyZWFtbGluZTogVmVjdG9yW10pID0+IHtcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlY3Rvck9mZlNjcmVlbihzdHJlYW1saW5lWzBdKSAmJiB0aGlzLnZlY3Rvck9mZlNjcmVlbihzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pO1xuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuLy8gICAgICAgICAgICAgLy8gVE9ET1xuLy8gICAgICAgICAgICAgbWFqb3IgPSB0cnVlO1xuLy8gICAgICAgICAgICAgLy8gbWFqb3IgPSBNYXRoLnJhbmRvbSgpIDwgMC41O1xuLy8gICAgICAgICAgICAgc2VlZCA9IHRoaXMuZ2V0U2VlZChtYWpvcik7XG4vLyAgICAgICAgICAgICBjb2FzdFN0cmVhbWxpbmUgPSBleHRlbmRTdHJlYW1saW5lKHRoaXMuaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkLCBtYWpvcikpO1xuLy8gICAgICAgICAgICAgcml2ZXJTdHJlYW1saW5lID0gZXh0ZW5kU3RyZWFtbGluZSh0aGlzLmludGVncmF0ZVN0cmVhbWxpbmUoc2VlZCwgIW1ham9yKSk7XG5cbi8vICAgICAgICAgICAgIGlmIChyZWFjaGVzRWRnZXMoY29hc3RTdHJlYW1saW5lKSAmJiByZWFjaGVzRWRnZXMocml2ZXJTdHJlYW1saW5lKSkge1xuLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgLy8gU3RyZWFtbGluZSBpcyBjb2FzdGFsID0gbm9pc3lcbi8vICAgICAgICAgY29uc3Qgcm9hZCA9IHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKGNvYXN0U3RyZWFtbGluZSk7XG4vLyAgICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXNTaW1wbGUucHVzaChyb2FkKTtcblxuLy8gICAgICAgICAvLyBDcmVhdGUgaW50ZXJtZWRpYXRlIHNhbXBsZXNcbi8vICAgICAgICAgY29uc3QgY29tcGxleCA9IHRoaXMuY29tcGxleGlmeVN0cmVhbWxpbmUocm9hZCk7XG4vLyAgICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoY29tcGxleCk7XG4vLyAgICAgICAgIHRoaXMuc3RyZWFtbGluZXMobWFqb3IpLnB1c2goY29tcGxleCk7XG4vLyAgICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXMucHVzaChjb21wbGV4KTtcblxuLy8gICAgICAgICB0aGlzLnRlbnNvckZpZWxkLmFkZFdhdGVyKHRoaXMuZ2V0U2VhUG9seWdvbihyb2FkKSk7XG5cbi8vICAgICAgICAgLy8gUmV0dXJuIHVuc2ltcGxpZmllZCBzdHJlYW1saW5lc1xuLy8gICAgICAgICByZXR1cm4gW2NvYXN0U3RyZWFtbGluZSwgcml2ZXJTdHJlYW1saW5lXTtcbi8vICAgICB9XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5pbXBvcnQgVGVuc29yRmllbGQgZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IHtSSzRJbnRlZ3JhdG9yfSBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCB7V2F0ZXJQYXJhbXN9IGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBHcmFwaCBmcm9tICcuLi9pbXBsL2dyYXBoJztcbmltcG9ydCBSb2FkR1VJIGZyb20gJy4vcm9hZF9ndWknO1xuaW1wb3J0IFdhdGVyR1VJIGZyb20gJy4vd2F0ZXJfZ3VpJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBQb2x5Z29uRmluZGVyIGZyb20gJy4uL2ltcGwvcG9seWdvbl9maW5kZXInO1xuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4uL2ltcGwvcG9seWdvbl91dGlsJztcbmltcG9ydCB7UG9seWdvblBhcmFtc30gZnJvbSAnLi4vaW1wbC9wb2x5Z29uX2ZpbmRlcic7XG5pbXBvcnQgU3RyZWFtbGluZUdlbmVyYXRvciBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCBXYXRlckdlbmVyYXRvciBmcm9tICcuLi9pbXBsL3dhdGVyX2dlbmVyYXRvcic7XG5pbXBvcnQgU3R5bGUgZnJvbSAnLi9zdHlsZSc7XG5pbXBvcnQgQ2FudmFzV3JhcHBlciBmcm9tICcuL2NhbnZhc193cmFwcGVyJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkaW5nTW9kZWwge1xuICAgIGhlaWdodDogbnVtYmVyO1xuICAgIGxvdFdvcmxkOiBWZWN0b3JbXTsgLy8gSW4gd29ybGQgc3BhY2VcbiAgICBsb3RTY3JlZW46IFZlY3RvcltdOyAvLyBJbiBzY3JlZW4gc3BhY2VcbiAgICByb29mOiBWZWN0b3JbXTsgLy8gSW4gc2NyZWVuIHNwYWNlXG4gICAgc2lkZXM6IFZlY3RvcltdW107IC8vIEluIHNjcmVlbiBzcGFjZVxufVxuXG5jbGFzcyBCdWlsZGluZ01vZGVscyB7XG4gICAgcHJpdmF0ZSBkb21haW5Db250cm9sbGVyID0gRG9tYWluQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xuICAgIHByaXZhdGUgX2J1aWxkaW5nTW9kZWxzOiBCdWlsZGluZ01vZGVsW10gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKGxvdHM6IFZlY3RvcltdW10pIHsgIC8vIExvdHMgaW4gd29ybGQgc3BhY2VcbiAgICAgICAgZm9yIChjb25zdCBsb3Qgb2YgbG90cykge1xuICAgICAgICAgICAgdGhpcy5fYnVpbGRpbmdNb2RlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJhbmRvbSgpICogMjAgKyAyMCxcbiAgICAgICAgICAgICAgICBsb3RXb3JsZDogbG90LFxuICAgICAgICAgICAgICAgIGxvdFNjcmVlbjogW10sXG4gICAgICAgICAgICAgICAgcm9vZjogW10sXG4gICAgICAgICAgICAgICAgc2lkZXM6IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9idWlsZGluZ01vZGVscy5zb3J0KChhLCBiKSA9PiBhLmhlaWdodCAtIGIuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBnZXQgYnVpbGRpbmdNb2RlbHMoKTogQnVpbGRpbmdNb2RlbFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkaW5nTW9kZWxzO1xuICAgIH1cblxuICAgIHNldEJ1aWxkaW5nUHJvamVjdGlvbnMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGQgPSAxMDAwIC8gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb207XG4gICAgICAgIGNvbnN0IGNhbWVyYVBvcyA9IHRoaXMuZG9tYWluQ29udHJvbGxlci5nZXRDYW1lcmFQb3NpdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5fYnVpbGRpbmdNb2RlbHMpIHtcbiAgICAgICAgICAgIGIubG90U2NyZWVuID0gYi5sb3RXb3JsZC5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKTtcbiAgICAgICAgICAgIGIucm9vZiA9IGIubG90U2NyZWVuLm1hcCh2ID0+IHRoaXMuaGVpZ2h0VmVjdG9yVG9TY3JlZW4odiwgYi5oZWlnaHQsIGQsIGNhbWVyYVBvcykpO1xuICAgICAgICAgICAgYi5zaWRlcyA9IHRoaXMuZ2V0QnVpbGRpbmdTaWRlcyhiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGVpZ2h0VmVjdG9yVG9TY3JlZW4odjogVmVjdG9yLCBoOiBudW1iZXIsIGQ6IG51bWJlciwgY2FtZXJhOiBWZWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAoZCAvIChkIC0gaCkpOyAvLyAwLjFcbiAgICAgICAgaWYgKHRoaXMuZG9tYWluQ29udHJvbGxlci5vcnRob2dyYXBoaWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuY2FtZXJhRGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKC1oICogc2NhbGUpO1xuICAgICAgICAgICAgcmV0dXJuIHYuY2xvbmUoKS5hZGQoZGlmZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdi5jbG9uZSgpLnN1YihjYW1lcmEpLm11bHRpcGx5U2NhbGFyKHNjYWxlKS5hZGQoY2FtZXJhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0QnVpbGRpbmdTaWRlcyhiOiBCdWlsZGluZ01vZGVsKTogVmVjdG9yW11bXSB7XG4gICAgICAgIGNvbnN0IHBvbHlnb25zOiBWZWN0b3JbXVtdID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYi5sb3RTY3JlZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSAoaSArIDEpICUgYi5sb3RTY3JlZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbnMucHVzaChbYi5sb3RTY3JlZW5baV0sIGIubG90U2NyZWVuW25leHRdLCBiLnJvb2ZbbmV4dF0sIGIucm9vZltpXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2x5Z29ucztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1aWxkaW5ncyB7XG4gICAgcHJpdmF0ZSBwb2x5Z29uRmluZGVyOiBQb2x5Z29uRmluZGVyO1xuICAgIHByaXZhdGUgYWxsU3RyZWFtbGluZXM6IFZlY3RvcltdW10gPSBbXTtcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XG4gICAgcHJpdmF0ZSBwcmVHZW5lcmF0ZUNhbGxiYWNrOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcbiAgICBwcml2YXRlIHBvc3RHZW5lcmF0ZUNhbGxiYWNrOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcbiAgICBwcml2YXRlIF9tb2RlbHM6IEJ1aWxkaW5nTW9kZWxzID0gbmV3IEJ1aWxkaW5nTW9kZWxzKFtdKTtcblxuICAgIHByaXZhdGUgYnVpbGRpbmdQYXJhbXM6IFBvbHlnb25QYXJhbXMgPSB7XG4gICAgICAgIG1heExlbmd0aDogMjAsXG4gICAgICAgIG1pbkFyZWE6IDUwLFxuICAgICAgICBzaHJpbmtTcGFjaW5nOiA0LFxuICAgICAgICBjaGFuY2VOb0RpdmlkZTogMC4wNSxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGQsXG4gICAgICAgICAgICAgICAgZm9sZGVyOiBkYXQuR1VJLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgcmVkcmF3OiAoKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZHN0ZXA6IG51bWJlcixcbiAgICAgICAgICAgICAgICBwcml2YXRlIF9hbmltYXRlOiBib29sZWFuKSB7XG4gICAgICAgIGZvbGRlci5hZGQoeydBZGRCdWlsZGluZ3MnOiAoKSA9PiB0aGlzLmdlbmVyYXRlKHRoaXMuX2FuaW1hdGUpfSwgJ0FkZEJ1aWxkaW5ncycpO1xuICAgICAgICBmb2xkZXIuYWRkKHRoaXMuYnVpbGRpbmdQYXJhbXMsICdtaW5BcmVhJyk7XG4gICAgICAgIGZvbGRlci5hZGQodGhpcy5idWlsZGluZ1BhcmFtcywgJ3Nocmlua1NwYWNpbmcnKTtcbiAgICAgICAgZm9sZGVyLmFkZCh0aGlzLmJ1aWxkaW5nUGFyYW1zLCAnY2hhbmNlTm9EaXZpZGUnKTtcbiAgICAgICAgdGhpcy5wb2x5Z29uRmluZGVyID0gbmV3IFBvbHlnb25GaW5kZXIoW10sIHRoaXMuYnVpbGRpbmdQYXJhbXMsIHRoaXMudGVuc29yRmllbGQpO1xuICAgIH1cblxuICAgIHNldCBhbmltYXRlKHY6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGxvdHMoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvbHlnb25GaW5kZXIucG9seWdvbnMubWFwKHAgPT4gcC5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKSk7XG4gICAgfVxuXG4gICAgZ2V0IG1vZGVscygpOiBCdWlsZGluZ01vZGVsW10ge1xuICAgICAgICB0aGlzLl9tb2RlbHMuc2V0QnVpbGRpbmdQcm9qZWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWxzLmJ1aWxkaW5nTW9kZWxzO1xuICAgIH1cblxuICAgIHNldEFsbFN0cmVhbWxpbmVzKHM6IFZlY3RvcltdW10pIHtcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcyA9IHM7XG4gICAgfVxuXG4gICAgcmVzZXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucG9seWdvbkZpbmRlci5yZXNldCgpO1xuICAgICAgICB0aGlzLl9tb2RlbHMgPSBuZXcgQnVpbGRpbmdNb2RlbHMoW10pO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9seWdvbkZpbmRlci51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZW5lcmF0ZShhbmltYXRlOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMucHJlR2VuZXJhdGVDYWxsYmFjaygpO1xuICAgICAgICB0aGlzLl9tb2RlbHMgPSBuZXcgQnVpbGRpbmdNb2RlbHMoW10pO1xuICAgICAgICBjb25zdCBnID0gbmV3IEdyYXBoKHRoaXMuYWxsU3RyZWFtbGluZXMsIHRoaXMuZHN0ZXAsIHRydWUpO1xuICAgICAgICB0aGlzLnBvbHlnb25GaW5kZXIgPSBuZXcgUG9seWdvbkZpbmRlcihnLm5vZGVzLCB0aGlzLmJ1aWxkaW5nUGFyYW1zLCB0aGlzLnRlbnNvckZpZWxkKTtcbiAgICAgICAgdGhpcy5wb2x5Z29uRmluZGVyLmZpbmRQb2x5Z29ucygpO1xuICAgICAgICBhd2FpdCB0aGlzLnBvbHlnb25GaW5kZXIuc2hyaW5rKGFuaW1hdGUpO1xuICAgICAgICBhd2FpdCB0aGlzLnBvbHlnb25GaW5kZXIuZGl2aWRlKGFuaW1hdGUpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB0aGlzLl9tb2RlbHMgPSBuZXcgQnVpbGRpbmdNb2RlbHModGhpcy5wb2x5Z29uRmluZGVyLnBvbHlnb25zKTtcblxuICAgICAgICB0aGlzLnBvc3RHZW5lcmF0ZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgc2V0UHJlR2VuZXJhdGVDYWxsYmFjayhjYWxsYmFjazogKCkgPT4gYW55KSB7XG4gICAgICAgIHRoaXMucHJlR2VuZXJhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKGNhbGxiYWNrOiAoKSA9PiBhbnkpIHtcbiAgICAgICAgdGhpcy5wb3N0R2VuZXJhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IHsgU1ZHIH0gZnJvbSAnQHN2Z2RvdGpzL3N2Zy5qcyc7XG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBSb3VnaE9wdGlvbnMge1xuICAgIHJvdWdobmVzcz86IG51bWJlcjtcbiAgICBib3dpbmc/OiBudW1iZXI7XG4gICAgc2VlZD86IG51bWJlcjtcbiAgICBzdHJva2U/OiBzdHJpbmc7XG4gICAgc3Ryb2tlV2lkdGg/OiBudW1iZXI7XG4gICAgZmlsbD86IHN0cmluZztcbiAgICBmaWxsU3R5bGU/OiBzdHJpbmc7XG4gICAgZmlsbFdlaWdodD86IG51bWJlcjtcbiAgICBoYWNodXJlQW5nbGU/OiBudW1iZXI7XG4gICAgaGFjaHVyZUdhcD86IG51bWJlcjtcbiAgICBkYXNoT2Zmc2V0PzogbnVtYmVyO1xuICAgIGRhc2hHYXA/OiBudW1iZXI7XG4gICAgemlnemFnT2Zmc2V0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDYW52YXNXcmFwcGVyIHtcbiAgICBwcm90ZWN0ZWQgc3ZnTm9kZTogYW55O1xuICAgIHByb3RlY3RlZCBfd2lkdGg6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2hlaWdodDogbnVtYmVyO1xuICAgIHB1YmxpYyBuZWVkc1VwZGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBwcm90ZWN0ZWQgX3NjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpIHtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMucmVzaXplQ2FudmFzKCk7XG4gICAgICAgIGlmIChyZXNpemVUb1dpbmRvdykge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYXBwZW5kU3ZnTm9kZShub2RlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5zdmdOb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlU1ZHKHN2Z0VsZW1lbnQ6IGFueSkge1xuICAgICAgICB0aGlzLnN2Z05vZGUgPSBzdmdFbGVtZW50O1xuICAgIH1cblxuICAgIGFic3RyYWN0IGRyYXdGcmFtZShsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHVwOiBudW1iZXIsIGRvd246IG51bWJlcik6IHZvaWQ7XG5cbiAgICBzZXREaW1lbnNpb25zKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICogdGhpcy5fc2NhbGU7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIHRoaXMuX3NjYWxlO1xuICAgIH1cblxuICAgIGdldCB3aWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuXG4gICAgZ2V0IGhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH1cblxuICAgIGdldCBjYW52YXNTY2FsZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgfVxuXG4gICAgc2V0IGNhbnZhc1NjYWxlKHM6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9zY2FsZSA9IHM7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB6b29tVmVjdG9ycyh2czogVmVjdG9yW10pOiBWZWN0b3JbXSB7XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSA9PT0gMSkgcmV0dXJuIHZzO1xuICAgICAgICByZXR1cm4gdnMubWFwKHYgPT4gdi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuX3NjYWxlKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlc2l6ZUNhbnZhcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZWZhdWx0Q2FudmFzV3JhcHBlciBleHRlbmRzIENhbnZhc1dyYXBwZXIge1xuICAgIHByaXZhdGUgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgcHJpdmF0ZSBzdmc6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpIHtcbiAgICAgICAgc3VwZXIoY2FudmFzLCBzY2FsZSwgcmVzaXplVG9XaW5kb3cpO1xuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIGNyZWF0ZVNWRyhzdmdFbGVtZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuY3JlYXRlU1ZHKHN2Z0VsZW1lbnQpO1xuICAgICAgICB0aGlzLnN2ZyA9IFNWRyhzdmdFbGVtZW50KTtcbiAgICB9XG5cbiAgICBzZXRGaWxsU3R5bGUoY29sb3VyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3VyO1xuICAgIH1cblxuICAgIGNsZWFyQ2FudmFzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zdmdOb2RlKSB7XG4gICAgICAgICAgICAvLyBFeHBhbmRlZCB0byBjb3ZlciB3aG9sZSBkcmF3biBhcmVhXG4gICAgICAgICAgICBjb25zdCBzdGFydFcgPSB3aW5kb3cuaW5uZXJXaWR0aCAqIChVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQgLSAxKSAvIDI7XG4gICAgICAgICAgICBjb25zdCBzdGFydEggPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiAoVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UIC0gMSkgLyAyO1xuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKC1zdGFydFcsIC1zdGFydEgsIHdpbmRvdy5pbm5lcldpZHRoICogVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5ULCB3aW5kb3cuaW5uZXJIZWlnaHQgKiBVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHJhd0ZyYW1lKGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgdXA6IG51bWJlciwgZG93bjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZSgwLCAwLCB0aGlzLl93aWR0aC90aGlzLl9zY2FsZSwgdXApO1xuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoMCwgMCwgbGVmdCwgdGhpcy5faGVpZ2h0L3RoaXMuX3NjYWxlKTtcbiAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKHRoaXMuX3dpZHRoL3RoaXMuX3NjYWxlIC0gcmlnaHQsIDAsIHJpZ2h0LCB0aGlzLl9oZWlnaHQvdGhpcy5fc2NhbGUpO1xuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoMCwgdGhpcy5faGVpZ2h0L3RoaXMuX3NjYWxlIC0gZG93biwgdGhpcy5fd2lkdGgvdGhpcy5fc2NhbGUsIGRvd24pO1xuICAgIH1cblxuICAgIGRyYXdDaXR5TmFtZSgpIHtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSA1MCAqIHRoaXMuX3NjYWxlO1xuICAgICAgICB0aGlzLmN0eC5mb250ID0gYHNtYWxsLWNhcHMgJHtmb250U2l6ZX1weCBWZXJkYW5hYDtcbiAgICAgICAgdGhpcy5jdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJzYW4gZnJhbmNpc2NvXCIsIHRoaXMuX3dpZHRoLzIsIHRoaXMuX2hlaWdodCAtICg4MCAqIHRoaXMuX3NjYWxlIC0gZm9udFNpemUpKTtcbiAgICB9XG5cbiAgICBkcmF3UmVjdGFuZ2xlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICB5ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgd2lkdGggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICBoZWlnaHQgKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3ZnKSB7XG4gICAgICAgICAgICB0aGlzLnN2Zy5yZWN0KHtcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmN0eC5maWxsU3R5bGUsXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmN0eC5zdHJva2VTdHlsZSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdGhpcy5jdHgubGluZVdpZHRoLFxuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRyYXdQb2x5Z29uKHBvbHlnb246IFZlY3RvcltdKSB7XG4gICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb24gPSB0aGlzLnpvb21WZWN0b3JzKHBvbHlnb24pO1xuXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8ocG9seWdvblswXS54LCBwb2x5Z29uWzBdLnkpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKHBvbHlnb25baV0ueCwgcG9seWdvbltpXS55KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN0eC5saW5lVG8ocG9seWdvblswXS54LCBwb2x5Z29uWzBdLnkpO1xuXG4gICAgICAgIHRoaXMuY3R4LmZpbGwoKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3ZnKSB7XG4gICAgICAgICAgICBjb25zdCB2ZWN0b3JBcnJheSA9IHBvbHlnb24ubWFwKHYgPT4gW3YueCwgdi55XSk7XG4gICAgICAgICAgICB2ZWN0b3JBcnJheS5wdXNoKHZlY3RvckFycmF5WzBdKTtcbiAgICAgICAgICAgIHRoaXMuc3ZnLnBvbHlsaW5lKHZlY3RvckFycmF5KS5hdHRyKHtcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmN0eC5maWxsU3R5bGUsXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmN0eC5zdHJva2VTdHlsZSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdGhpcy5jdHgubGluZVdpZHRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmF3U3F1YXJlKGNlbnRyZTogVmVjdG9yLCByYWRpdXM6IG51bWJlcikge1xuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoY2VudHJlLnggLSByYWRpdXMsIGNlbnRyZS55IC0gcmFkaXVzLCAyICogcmFkaXVzLCAyICogcmFkaXVzKTtcbiAgICB9XG5cbiAgICBzZXRMaW5lV2lkdGgod2lkdGg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHdpZHRoICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIH1cblxuICAgIHNldFN0cm9rZVN0eWxlKGNvbG91cjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3VyO1xuICAgIH1cblxuICAgIGRyYXdQb2x5bGluZShsaW5lOiBWZWN0b3JbXSk6IHZvaWQge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lID0gdGhpcy56b29tVmVjdG9ycyhsaW5lKTtcblxuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKGxpbmVbMF0ueCwgbGluZVswXS55KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyhsaW5lW2ldLngsIGxpbmVbaV0ueSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcblxuICAgICAgICBpZiAodGhpcy5zdmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlY3RvckFycmF5ID0gbGluZS5tYXAodiA9PiBbdi54LCB2LnldKTtcbiAgICAgICAgICAgIHRoaXMuc3ZnLnBvbHlsaW5lKHZlY3RvckFycmF5KS5hdHRyKHtcbiAgICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMCxcbiAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuY3R4LnN0cm9rZVN0eWxlLFxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiB0aGlzLmN0eC5saW5lV2lkdGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJvdWdoQ2FudmFzV3JhcHBlciBleHRlbmRzIENhbnZhc1dyYXBwZXIge1xuICAgIHByaXZhdGUgciA9IHJlcXVpcmUoJ3JvdWdoanMvYnVuZGxlZC9yb3VnaC5janMnKTtcbiAgICBwcml2YXRlIHJjOiBhbnk7XG4gICAgICAgIFxuICAgIHByaXZhdGUgb3B0aW9uczogUm91Z2hPcHRpb25zID0ge1xuICAgICAgICByb3VnaG5lc3M6IDEsXG4gICAgICAgIGJvd2luZzogMSxcbiAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXG4gICAgICAgIGZpbGxTdHlsZTogJ3NvbGlkJyxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGU9MSwgcmVzaXplVG9XaW5kb3c9dHJ1ZSkge1xuICAgICAgICBzdXBlcihjYW52YXMsIHNjYWxlLCByZXNpemVUb1dpbmRvdyk7XG4gICAgICAgIHRoaXMucmMgPSB0aGlzLnIuY2FudmFzKGNhbnZhcyk7XG4gICAgfVxuXG4gICAgY3JlYXRlU1ZHKHN2Z0VsZW1lbnQ6IGFueSkge1xuICAgICAgICBzdXBlci5jcmVhdGVTVkcoc3ZnRWxlbWVudCk7XG4gICAgICAgIHRoaXMucmMgPSB0aGlzLnIuc3ZnKHRoaXMuc3ZnTm9kZSk7XG4gICAgfVxuXG4gICAgZHJhd0ZyYW1lKGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgdXA6IG51bWJlciwgZG93bjogbnVtYmVyKTogdm9pZCB7XG5cbiAgICB9XG5cbiAgICBzZXRPcHRpb25zKG9wdGlvbnM6IFJvdWdoT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VXaWR0aCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdHJva2VXaWR0aCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY2xlYXJDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN2Z05vZGUpIHtcbiAgICAgICAgICAgIC8vIEV4cGFuZGVkIHRvIGNvdmVyIHdob2xlIGRyYXduIGFyZWFcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VyA9IHdpbmRvdy5pbm5lcldpZHRoICogKFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVCAtIDEpIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIChVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQgLSAxKSAvIDI7XG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoLXN0YXJ0VywgLXN0YXJ0SCwgd2luZG93LmlubmVyV2lkdGggKiBVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQsIHdpbmRvdy5pbm5lckhlaWdodCAqIFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoMCwgMCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmF3UmVjdGFuZ2xlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICB5ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgd2lkdGggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICBoZWlnaHQgKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRTdmdOb2RlKHRoaXMucmMucmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMub3B0aW9ucykpO1xuICAgIH1cblxuICAgIGRyYXdQb2x5Z29uKHBvbHlnb246IFZlY3RvcltdKSB7XG4gICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICBwb2x5Z29uID0gcG9seWdvbi5tYXAodiA9PiB2LmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGhpcy5fc2NhbGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwZW5kU3ZnTm9kZSh0aGlzLnJjLnBvbHlnb24ocG9seWdvbi5tYXAodiA9PiBbdi54LCB2LnldKSwgdGhpcy5vcHRpb25zKSk7XG4gICAgfVxuXG4gICAgZHJhd1NxdWFyZShjZW50cmU6IFZlY3RvciwgcmFkaXVzOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcHJldlN0cm9rZSA9IHRoaXMub3B0aW9ucy5zdHJva2U7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdHJva2UgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZShjZW50cmUueCAtIHJhZGl1cywgY2VudHJlLnkgLSByYWRpdXMsIDIgKiByYWRpdXMsIDIgKiByYWRpdXMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3Ryb2tlID0gcHJldlN0cm9rZTtcbiAgICB9XG5cbiAgICBkcmF3UG9seWxpbmUobGluZTogVmVjdG9yW10pOiB2b2lkIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5tYXAodiA9PiB2LmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGhpcy5fc2NhbGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwZW5kU3ZnTm9kZSh0aGlzLnJjLmxpbmVhclBhdGgobGluZS5tYXAodiA9PiBbdi54LCB2LnldKSwgdGhpcy5vcHRpb25zKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuXG4vKipcbiAqIFNpbmdsZXRvblxuICogQ29udHJvbHMgcGFubmluZyBhbmQgem9vbWluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb21haW5Db250cm9sbGVyIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRG9tYWluQ29udHJvbGxlcjtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgWk9PTV9TUEVFRCA9IDAuOTY7XG4gICAgcHJpdmF0ZSByZWFkb25seSBTQ1JPTExfREVMQVkgPSAxMDA7XG5cbiAgICAvLyBMb2NhdGlvbiBvZiBzY3JlZW4gb3JpZ2luIGluIHdvcmxkIHNwYWNlXG4gICAgcHJpdmF0ZSBfb3JpZ2luOiBWZWN0b3IgPSBWZWN0b3IuemVyb1ZlY3RvcigpO1xuICAgIFxuICAgIC8vIFNjcmVlbi1zcGFjZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgcHJpdmF0ZSBfc2NyZWVuRGltZW5zaW9ucyA9IFZlY3Rvci56ZXJvVmVjdG9yKCk7XG5cbiAgICAvLyBSYXRpbyBvZiBzY3JlZW4gcGl4ZWxzIHRvIHdvcmxkIHBpeGVsc1xuICAgIHByaXZhdGUgX3pvb206IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSB6b29tQ2FsbGJhY2s6ICgpID0+IGFueSA9ICgpID0+IHt9O1xuICAgIHByaXZhdGUgbGFzdFNjcm9sbHRpbWUgPSAtdGhpcy5TQ1JPTExfREVMQVk7XG4gICAgcHJpdmF0ZSByZWZyZXNoZWRBZnRlclNjcm9sbCA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBfY2FtZXJhRGlyZWN0aW9uID0gVmVjdG9yLnplcm9WZWN0b3IoKTtcbiAgICBwcml2YXRlIF9vcnRob2dyYXBoaWMgPSBmYWxzZTtcblxuICAgIC8vIFNldCBhZnRlciBwYW4gb3Igem9vbVxuICAgIHB1YmxpYyBtb3ZlZCA9IGZhbHNlO1xuXG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNldFNjcmVlbkRpbWVuc2lvbnMoKTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCk6IHZvaWQgPT4gdGhpcy5zZXRTY3JlZW5EaW1lbnNpb25zKCkpO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChlOiBhbnkpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5pZCA9PT0gVXRpbC5DQU5WQVNfSUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTY3JvbGx0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hlZEFmdGVyU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGE6IG51bWJlciA9IGUuZGVsdGFZO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gc2NhbGUgYnkgdmFsdWUgb2YgZGVsdGFcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbSA9IHRoaXMuX3pvb20gKiB0aGlzLlpPT01fU1BFRUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tID0gdGhpcy5fem9vbSAvIHRoaXMuWk9PTV9TUEVFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZ2V0IGlzU2Nyb2xsaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFNjcm9sbHRpbWUgPCB0aGlzLlNDUk9MTF9ERUxBWTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFNjcmVlbkRpbWVuc2lvbnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zY3JlZW5EaW1lbnNpb25zLnNldFgod2luZG93LmlubmVyV2lkdGgpO1xuICAgICAgICB0aGlzLl9zY3JlZW5EaW1lbnNpb25zLnNldFkod2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IERvbWFpbkNvbnRyb2xsZXIge1xuICAgICAgICBpZiAoIURvbWFpbkNvbnRyb2xsZXIuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIERvbWFpbkNvbnRyb2xsZXIuaW5zdGFuY2UgPSBuZXcgRG9tYWluQ29udHJvbGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEb21haW5Db250cm9sbGVyLmluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VmVjdG9yfSBkZWx0YSBpbiB3b3JsZCBzcGFjZVxuICAgICAqL1xuICAgIHBhbihkZWx0YTogVmVjdG9yKSB7XG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vcmlnaW4uc3ViKGRlbHRhKTtcbiAgICB9XG5cbiAgICBnZXQgb3JpZ2luKCk6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW4uY2xvbmUoKTtcbiAgICB9XG5cbiAgICBnZXQgem9vbSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fem9vbTtcbiAgICB9XG5cbiAgICBnZXQgc2NyZWVuRGltZW5zaW9ucygpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NyZWVuRGltZW5zaW9ucy5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gd29ybGQtc3BhY2Ugdy9oIHZpc2libGUgb24gc2NyZWVuXG4gICAgICovXG4gICAgZ2V0IHdvcmxkRGltZW5zaW9ucygpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW5EaW1lbnNpb25zLmRpdmlkZVNjYWxhcih0aGlzLl96b29tKTtcbiAgICB9XG5cbiAgICBzZXQgc2NyZWVuRGltZW5zaW9ucyh2OiBWZWN0b3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjcmVlbkRpbWVuc2lvbnMuY29weSh2KTtcbiAgICB9XG5cbiAgICBzZXQgem9vbSh6OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHogPj0gMC4zICYmIHogPD0gMjApIHtcbiAgICAgICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgb2xkV29ybGRTcGFjZU1pZHBvaW50ID0gdGhpcy5vcmlnaW4uYWRkKHRoaXMud29ybGREaW1lbnNpb25zLmRpdmlkZVNjYWxhcigyKSk7XG4gICAgICAgICAgICB0aGlzLl96b29tID0gejtcbiAgICAgICAgICAgIGNvbnN0IG5ld1dvcmxkU3BhY2VNaWRwb2ludCA9IHRoaXMub3JpZ2luLmFkZCh0aGlzLndvcmxkRGltZW5zaW9ucy5kaXZpZGVTY2FsYXIoMikpO1xuICAgICAgICAgICAgdGhpcy5wYW4obmV3V29ybGRTcGFjZU1pZHBvaW50LnN1YihvbGRXb3JsZFNwYWNlTWlkcG9pbnQpKTtcbiAgICAgICAgICAgIHRoaXMuem9vbUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNjcmVlbih2OiBWZWN0b3IpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgc2NyZWVuU3BhY2UgPSB0aGlzLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKTtcbiAgICAgICAgcmV0dXJuIHNjcmVlblNwYWNlLnggPj0gMCAmJiBzY3JlZW5TcGFjZS55ID49IDBcbiAgICAgICAgICAgICYmIHNjcmVlblNwYWNlLnggPD0gdGhpcy5zY3JlZW5EaW1lbnNpb25zLnggJiYgc2NyZWVuU3BhY2UueSA8PSB0aGlzLnNjcmVlbkRpbWVuc2lvbnMueTtcbiAgICB9XG5cbiAgICBzZXQgb3J0aG9ncmFwaGljKHY6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fb3J0aG9ncmFwaGljID0gdjtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZ2V0IG9ydGhvZ3JhcGhpYygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ydGhvZ3JhcGhpYztcbiAgICB9XG5cbiAgICBzZXQgY2FtZXJhRGlyZWN0aW9uKHY6IFZlY3Rvcikge1xuICAgICAgICB0aGlzLl9jYW1lcmFEaXJlY3Rpb24gPSB2O1xuICAgICAgICAvLyBTY3JlZW4gdXBkYXRlXG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGdldCBjYW1lcmFEaXJlY3Rpb24oKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbWVyYURpcmVjdGlvbi5jbG9uZSgpO1xuICAgIH1cblxuICAgIGdldENhbWVyYVBvc2l0aW9uKCk6IFZlY3RvciB7XG4gICAgICAgIGNvbnN0IGNlbnRyZSA9IG5ldyBWZWN0b3IodGhpcy5fc2NyZWVuRGltZW5zaW9ucy54IC8gMiwgdGhpcy5fc2NyZWVuRGltZW5zaW9ucy55IC8gMik7XG4gICAgICAgIHJldHVybiBjZW50cmUuYWRkKGNlbnRyZS5jbG9uZSgpLm11bHRpcGx5KHRoaXMuX2NhbWVyYURpcmVjdGlvbikpO1xuICAgICAgICAvLyB0aGlzLnNjcmVlbkRpbWVuc2lvbnMuZGl2aWRlU2NhbGFyKDIpO1xuICAgIH1cblxuICAgIHNldFpvb21VcGRhdGUoY2FsbGJhY2s6ICgpID0+IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLnpvb21DYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVkaXRzIHZlY3RvclxuICAgICAqL1xuICAgIHpvb21Ub1dvcmxkKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB2LmRpdmlkZVNjYWxhcih0aGlzLl96b29tKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0cyB2ZWN0b3JcbiAgICAgKi9cbiAgICB6b29tVG9TY3JlZW4odjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHYubXVsdGlwbHlTY2FsYXIodGhpcy5fem9vbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgdmVjdG9yXG4gICAgICovXG4gICAgc2NyZWVuVG9Xb3JsZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy56b29tVG9Xb3JsZCh2KS5hZGQodGhpcy5fb3JpZ2luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0cyB2ZWN0b3JcbiAgICAgKi9cbiAgICB3b3JsZFRvU2NyZWVuKHY6IFZlY3Rvcik6IFZlY3RvciB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvb21Ub1NjcmVlbih2LnN1Yih0aGlzLl9vcmlnaW4pKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IGludGVyYWN0IGZyb20gJ2ludGVyYWN0anMnO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL1ZlY3Rvcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcblxuaW50ZXJmYWNlIERyYWdnYWJsZSB7XG4gICAgZ2V0Q2VudHJlOiAoKCkgPT4gVmVjdG9yKTtcbiAgICBjYWxsYmFja0ZuOiAoKHY6IFZlY3RvcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuKiBSZWdpc3RlciBtdWx0aXBsZSBjZW50cmUgcG9pbnRzXG4qIENsb3Nlc3Qgb25lIHRvIG1vdXNlIGNsaWNrIHdpbGwgYmUgc2VsZWN0ZWQgdG8gZHJhZ1xuKiBVcCB0byBjYWxsZXIgdG8gYWN0dWFsbHkgbW92ZSB0aGVpciBjZW50cmUgcG9pbnQgdmlhIGNhbGxiYWNrXG4qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJhZ0NvbnRyb2xsZXIge1xuICAgIC8vIEhvdyBjbG9zZSB0byBkcmFnIGhhbmRsZSBwb2ludGVyIG5lZWRzIHRvIGJlXG4gICAgcHJpdmF0ZSByZWFkb25seSBNSU5fRFJBR19ESVNUQU5DRSA9IDUwO1xuXG4gICAgcHJpdmF0ZSBkcmFnZ2FibGVzOiBEcmFnZ2FibGVbXSA9IFtdO1xuICAgIHByaXZhdGUgY3VycmVudGx5RHJhZ2dpbmc6IERyYWdnYWJsZSA9IG51bGw7ICAvLyBUZW5zb3IgZmllbGRcbiAgICBwcml2YXRlIF9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3VpOiBkYXQuR1VJKSB7XG4gICAgICAgIGludGVyYWN0KGAjJHtVdGlsLkNBTlZBU19JRH1gKS5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgb25zdGFydDogdGhpcy5kcmFnU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9ubW92ZTogdGhpcy5kcmFnTW92ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb25lbmQ6IHRoaXMuZHJhZ0VuZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY3Vyc29yQ2hlY2tlcjogdGhpcy5nZXRDdXJzb3IuYmluZCh0aGlzKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0RHJhZ0Rpc2FibGVkKGRpc2FibGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGU7XG4gICAgfVxuXG4gICAgZ2V0Q3Vyc29yKGFjdGlvbjogYW55LCBpbnRlcmFjdGFibGU6IGFueSwgZWxlbWVudDogYW55LCBpbnRlcmFjdGluZzogYm9vbGVhbikge1xuICAgICAgICBpZiAoaW50ZXJhY3RpbmcpIHJldHVybiAnZ3JhYmJpbmcnO1xuICAgICAgICByZXR1cm4gJ2dyYWInO1xuICAgIH1cblxuICAgIGRyYWdTdGFydChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAvLyBUcmFuc2Zvcm0gc2NyZWVuIHNwYWNlIHRvIHdvcmxkIHNwYWNlXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZG9tYWluQ29udHJvbGxlci5zY3JlZW5Ub1dvcmxkKG5ldyBWZWN0b3IoZXZlbnQueDAsIGV2ZW50LnkwKSk7XG4gICAgICAgIFxuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlcy5mb3JFYWNoKGRyYWdnYWJsZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkID0gZHJhZ2dhYmxlLmdldENlbnRyZSgpLmRpc3RhbmNlVG8ob3JpZ2luKTtcbiAgICAgICAgICAgIGlmIChkIDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZDtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRseURyYWdnaW5nID0gZHJhZ2dhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBab29tIHNjcmVlbiBzaXplIHRvIHdvcmxkIHNpemUgZm9yIGNvbnNpc3RlbnQgZHJhZyBkaXN0YW5jZSB3aGlsZSB6b29tZWQgaW5cbiAgICAgICAgY29uc3Qgc2NhbGVkRHJhZ0Rpc3RhbmNlID0gdGhpcy5NSU5fRFJBR19ESVNUQU5DRSAvIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tO1xuXG4gICAgICAgIGlmIChjbG9zZXN0RGlzdGFuY2UgPiBzY2FsZWREcmFnRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHJhZ01vdmUoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCBkZWx0YSA9IG5ldyBWZWN0b3IoZXZlbnQuZGVsdGEueCwgZXZlbnQuZGVsdGEueSk7XG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tVG9Xb3JsZChkZWx0YSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERyYWcgZmllbGRcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcuY2FsbGJhY2tGbihkZWx0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNb3ZlIG1hcFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnBhbihkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmFnRW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci5wYW4oVmVjdG9yLnplcm9WZWN0b3IoKSk7ICAvLyBUcmlnZ2VycyBjYW52YXMgdXBkYXRlXG4gICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcgPSBudWxsO1xuICAgICAgICBVdGlsLnVwZGF0ZUd1aSh0aGlzLmd1aSk7XG4gICAgfVxuXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7KCgpID0+IFZlY3Rvcil9IEdldHMgY2VudHJlIHBvaW50XG4gICAgICogQHBhcmFtIHsoKHY6IFZlY3RvcikgPT4gdm9pZCl9IENhbGxlZCBvbiBtb3ZlIHdpdGggZGVsdGEgdmVjdG9yXG4gICAgICogQHJldHVybnMgeygoKSA9PiB2b2lkKX0gRnVuY3Rpb24gdG8gZGVyZWdpc3RlciBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlZ2lzdGVyKGdldENlbnRyZTogKCgpID0+IFZlY3RvciksXG4gICAgICAgICAgICAgb25Nb3ZlOiAoKHY6IFZlY3RvcikgPT4gdm9pZCkpOiAoKCkgPT4gdm9pZCkge1xuICAgICAgICBjb25zdCBkcmFnZ2FibGU6IERyYWdnYWJsZSA9IHtcbiAgICAgICAgICAgIGdldENlbnRyZTogZ2V0Q2VudHJlLFxuICAgICAgICAgICAgY2FsbGJhY2tGbjogb25Nb3ZlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlcy5wdXNoKGRyYWdnYWJsZSk7XG4gICAgICAgIHJldHVybiAoKCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRyYWdnYWJsZXMuaW5kZXhPZihkcmFnZ2FibGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5pbXBvcnQgVGVuc29yRmllbGQgZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xuaW1wb3J0IHtSSzRJbnRlZ3JhdG9yfSBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCB7V2F0ZXJQYXJhbXN9IGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBHcmFwaCBmcm9tICcuLi9pbXBsL2dyYXBoJztcbmltcG9ydCBSb2FkR1VJIGZyb20gJy4vcm9hZF9ndWknO1xuaW1wb3J0IFdhdGVyR1VJIGZyb20gJy4vd2F0ZXJfZ3VpJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBQb2x5Z29uRmluZGVyIGZyb20gJy4uL2ltcGwvcG9seWdvbl9maW5kZXInO1xuaW1wb3J0IHtQb2x5Z29uUGFyYW1zfSBmcm9tICcuLi9pbXBsL3BvbHlnb25fZmluZGVyJztcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IFdhdGVyR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBTdHlsZSBmcm9tICcuL3N0eWxlJztcbmltcG9ydCB7RGVmYXVsdFN0eWxlLCBSb3VnaFN0eWxlfSBmcm9tICcuL3N0eWxlJztcbmltcG9ydCBDYW52YXNXcmFwcGVyIGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xuaW1wb3J0IEJ1aWxkaW5ncyBmcm9tICcuL2J1aWxkaW5ncyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5HVUkge1xuICAgIHByaXZhdGUgbnVtQmlnUGFya3M6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBudW1TbWFsbFBhcmtzOiBudW1iZXIgPSA1O1xuXG4gICAgcHJpdmF0ZSBkb21haW5Db250cm9sbGVyID0gRG9tYWluQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xuICAgIHByaXZhdGUgaW50ZXJzZWN0aW9uczogVmVjdG9yW10gPSBbXTtcbiAgICBwcml2YXRlIGJpZ1BhcmtzOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHJpdmF0ZSBzbWFsbFBhcmtzOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHJpdmF0ZSBhbmltYXRlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBwcml2YXRlIGFuaW1hdGlvblNwZWVkOiBudW1iZXIgPSAzMDtcblxuICAgIHByaXZhdGUgY29hc3RsaW5lOiBXYXRlckdVSTtcbiAgICBwcml2YXRlIG1haW5Sb2FkczogUm9hZEdVSTtcbiAgICBwcml2YXRlIG1ham9yUm9hZHM6IFJvYWRHVUk7XG4gICAgcHJpdmF0ZSBtaW5vclJvYWRzOiBSb2FkR1VJO1xuICAgIHByaXZhdGUgYnVpbGRpbmdzOiBCdWlsZGluZ3M7XG5cbiAgICAvLyBQYXJhbXNcbiAgICBwcml2YXRlIGNvYXN0bGluZVBhcmFtczogV2F0ZXJQYXJhbXM7XG4gICAgcHJpdmF0ZSBtYWluUGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zO1xuICAgIHByaXZhdGUgbWFqb3JQYXJhbXM6IFN0cmVhbWxpbmVQYXJhbXM7XG4gICAgcHJpdmF0ZSBtaW5vclBhcmFtczogU3RyZWFtbGluZVBhcmFtcyA9IHtcbiAgICAgICAgZHNlcDogMjAsXG4gICAgICAgIGR0ZXN0OiAxNSxcbiAgICAgICAgZHN0ZXA6IDEsXG4gICAgICAgIGRsb29rYWhlYWQ6IDQwLFxuICAgICAgICBkY2lyY2xlam9pbjogNSxcbiAgICAgICAgam9pbmFuZ2xlOiAwLjEsICAvLyBhcHByb3ggMzBkZWdcbiAgICAgICAgcGF0aEl0ZXJhdGlvbnM6IDEwMDAsXG4gICAgICAgIHNlZWRUcmllczogMzAwLFxuICAgICAgICBzaW1wbGlmeVRvbGVyYW5jZTogMC41LFxuICAgICAgICBjb2xsaWRlRWFybHk6IDAuNyxcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSByZWRyYXc6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBndWlGb2xkZXI6IGRhdC5HVUksIHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIGNsb3NlVGVuc29yRm9sZGVyOiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIGd1aUZvbGRlci5hZGQodGhpcywgJ2dlbmVyYXRlRXZlcnl0aGluZycpO1xuICAgICAgICAvLyBndWlGb2xkZXIuYWRkKHRoaXMsICdzaW1wbGVCZW5jaE1hcmsnKTtcbiAgICAgICAgY29uc3QgYW5pbWF0ZUNvbnRyb2xsZXIgPSBndWlGb2xkZXIuYWRkKHRoaXMsICdhbmltYXRlJyk7XG4gICAgICAgIGd1aUZvbGRlci5hZGQodGhpcywgJ2FuaW1hdGlvblNwZWVkJyk7XG5cbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNvYXN0Tm9pc2U6IHtcbiAgICAgICAgICAgICAgICBub2lzZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbm9pc2VTaXplOiAzMCxcbiAgICAgICAgICAgICAgICBub2lzZUFuZ2xlOiAyMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaXZlck5vaXNlOiB7XG4gICAgICAgICAgICAgICAgbm9pc2VFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5vaXNlU2l6ZTogMzAsXG4gICAgICAgICAgICAgICAgbm9pc2VBbmdsZTogMjAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcml2ZXJCYW5rU2l6ZTogMTAsXG4gICAgICAgICAgICByaXZlclNpemU6IDMwLFxuICAgICAgICB9LCB0aGlzLm1pbm9yUGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMucGF0aEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2UgPSAxMDtcblxuICAgICAgICB0aGlzLm1ham9yUGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5taW5vclBhcmFtcyk7XG4gICAgICAgIHRoaXMubWFqb3JQYXJhbXMuZHNlcCA9IDEwMDtcbiAgICAgICAgdGhpcy5tYWpvclBhcmFtcy5kdGVzdCA9IDMwO1xuICAgICAgICB0aGlzLm1ham9yUGFyYW1zLmRsb29rYWhlYWQgPSAyMDA7XG4gICAgICAgIHRoaXMubWFqb3JQYXJhbXMuY29sbGlkZUVhcmx5ID0gMDtcblxuICAgICAgICB0aGlzLm1haW5QYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1pbm9yUGFyYW1zKTtcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zLmRzZXAgPSA0MDA7XG4gICAgICAgIHRoaXMubWFpblBhcmFtcy5kdGVzdCA9IDIwMDtcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zLmRsb29rYWhlYWQgPSA1MDA7XG4gICAgICAgIHRoaXMubWFpblBhcmFtcy5jb2xsaWRlRWFybHkgPSAwO1xuXG4gICAgICAgIGNvbnN0IGludGVncmF0b3IgPSBuZXcgUks0SW50ZWdyYXRvcih0ZW5zb3JGaWVsZCwgdGhpcy5taW5vclBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlZHJhdyA9ICgpID0+IHRoaXMucmVkcmF3ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNvYXN0bGluZSA9IG5ldyBXYXRlckdVSSh0ZW5zb3JGaWVsZCwgdGhpcy5jb2FzdGxpbmVQYXJhbXMsIGludGVncmF0b3IsXG4gICAgICAgICAgICB0aGlzLmd1aUZvbGRlciwgY2xvc2VUZW5zb3JGb2xkZXIsICdXYXRlcicsIHJlZHJhdykuaW5pdEZvbGRlcigpO1xuICAgICAgICB0aGlzLm1haW5Sb2FkcyA9IG5ldyBSb2FkR1VJKHRoaXMubWFpblBhcmFtcywgaW50ZWdyYXRvciwgdGhpcy5ndWlGb2xkZXIsIGNsb3NlVGVuc29yRm9sZGVyLCAnTWFpbicsIHJlZHJhdykuaW5pdEZvbGRlcigpO1xuICAgICAgICB0aGlzLm1ham9yUm9hZHMgPSBuZXcgUm9hZEdVSSh0aGlzLm1ham9yUGFyYW1zLCBpbnRlZ3JhdG9yLCB0aGlzLmd1aUZvbGRlciwgY2xvc2VUZW5zb3JGb2xkZXIsICdNYWpvcicsIHJlZHJhdywgdGhpcy5hbmltYXRlKS5pbml0Rm9sZGVyKCk7XG4gICAgICAgIHRoaXMubWlub3JSb2FkcyA9IG5ldyBSb2FkR1VJKHRoaXMubWlub3JQYXJhbXMsIGludGVncmF0b3IsIHRoaXMuZ3VpRm9sZGVyLCBjbG9zZVRlbnNvckZvbGRlciwgJ01pbm9yJywgcmVkcmF3LCB0aGlzLmFuaW1hdGUpLmluaXRGb2xkZXIoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmtzID0gZ3VpRm9sZGVyLmFkZEZvbGRlcignUGFya3MnKTtcbiAgICAgICAgcGFya3MuYWRkKHtHZW5lcmF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUGFya3MoKTtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfX0sICdHZW5lcmF0ZScpO1xuICAgICAgICBwYXJrcy5hZGQodGhpcywgJ251bUJpZ1BhcmtzJyk7XG4gICAgICAgIHBhcmtzLmFkZCh0aGlzLCAnbnVtU21hbGxQYXJrcycpO1xuXG4gICAgICAgIGNvbnN0IGJ1aWxkaW5nc0ZvbGRlciA9IGd1aUZvbGRlci5hZGRGb2xkZXIoJ0J1aWxkaW5ncycpO1xuICAgICAgICB0aGlzLmJ1aWxkaW5ncyA9IG5ldyBCdWlsZGluZ3ModGVuc29yRmllbGQsIGJ1aWxkaW5nc0ZvbGRlciwgcmVkcmF3LCB0aGlzLm1pbm9yUGFyYW1zLmRzdGVwLCB0aGlzLmFuaW1hdGUpO1xuICAgICAgICB0aGlzLmJ1aWxkaW5ncy5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFsbFN0cmVhbWxpbmVzID0gW107XG4gICAgICAgICAgICBhbGxTdHJlYW1saW5lcy5wdXNoKC4uLnRoaXMubWFpblJvYWRzLmFsbFN0cmVhbWxpbmVzKTtcbiAgICAgICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5tYWpvclJvYWRzLmFsbFN0cmVhbWxpbmVzKTtcbiAgICAgICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5taW5vclJvYWRzLmFsbFN0cmVhbWxpbmVzKTtcbiAgICAgICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5jb2FzdGxpbmUuc3RyZWFtbGluZXNXaXRoU2Vjb25kYXJ5Um9hZCk7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5ncy5zZXRBbGxTdHJlYW1saW5lcyhhbGxTdHJlYW1saW5lcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFuaW1hdGVDb250cm9sbGVyLm9uQ2hhbmdlKChiOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuYW5pbWF0ZSA9IGI7XG4gICAgICAgICAgICB0aGlzLm1pbm9yUm9hZHMuYW5pbWF0ZSA9IGI7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5ncy5hbmltYXRlID0gYjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5taW5vclJvYWRzLnNldEV4aXN0aW5nU3RyZWFtbGluZXMoW3RoaXMuY29hc3RsaW5lLCB0aGlzLm1haW5Sb2FkcywgdGhpcy5tYWpvclJvYWRzXSk7XG4gICAgICAgIHRoaXMubWFqb3JSb2Fkcy5zZXRFeGlzdGluZ1N0cmVhbWxpbmVzKFt0aGlzLmNvYXN0bGluZSwgdGhpcy5tYWluUm9hZHNdKTtcbiAgICAgICAgdGhpcy5tYWluUm9hZHMuc2V0RXhpc3RpbmdTdHJlYW1saW5lcyhbdGhpcy5jb2FzdGxpbmVdKTtcblxuICAgICAgICB0aGlzLmNvYXN0bGluZS5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFpblJvYWRzLmNsZWFyU3RyZWFtbGluZXMoKTtcbiAgICAgICAgICAgIHRoaXMubWFqb3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICB0aGlzLm1pbm9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgdGhpcy5iaWdQYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zbWFsbFBhcmtzID0gW107XG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5ncy5yZXNldCgpO1xuICAgICAgICAgICAgdGVuc29yRmllbGQucGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnNlYSA9IFtdO1xuICAgICAgICAgICAgdGVuc29yRmllbGQucml2ZXIgPSBbXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYWluUm9hZHMuc2V0UHJlR2VuZXJhdGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xuICAgICAgICAgICAgdGhpcy5taW5vclJvYWRzLmNsZWFyU3RyZWFtbGluZXMoKTtcbiAgICAgICAgICAgIHRoaXMuYmlnUGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc21hbGxQYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MucmVzZXQoKTtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnBhcmtzID0gW107XG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5pZ25vcmVSaXZlciA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWFpblJvYWRzLnNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLmlnbm9yZVJpdmVyID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWFqb3JSb2Fkcy5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWlub3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZ1BhcmtzID0gW107XG4gICAgICAgICAgICB0aGlzLnNtYWxsUGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmdzLnJlc2V0KCk7XG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5wYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGVuc29yRmllbGQuaWdub3JlUml2ZXIgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1ham9yUm9hZHMuc2V0UG9zdEdlbmVyYXRlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgdGVuc29yRmllbGQuaWdub3JlUml2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYWRkUGFya3MoKTtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5taW5vclJvYWRzLnNldFByZUdlbmVyYXRlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc21hbGxQYXJrcyA9IFtdO1xuICAgICAgICAgICAgdGVuc29yRmllbGQucGFya3MgPSB0aGlzLmJpZ1BhcmtzO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1pbm9yUm9hZHMuc2V0UG9zdEdlbmVyYXRlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRQYXJrcygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRQYXJrcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZyA9IG5ldyBHcmFwaCh0aGlzLm1ham9yUm9hZHMuYWxsU3RyZWFtbGluZXNcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5tYWluUm9hZHMuYWxsU3RyZWFtbGluZXMpXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMubWlub3JSb2Fkcy5hbGxTdHJlYW1saW5lcyksIHRoaXMubWlub3JQYXJhbXMuZHN0ZXApO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbnMgPSBnLmludGVyc2VjdGlvbnM7XG5cbiAgICAgICAgY29uc3QgcCA9IG5ldyBQb2x5Z29uRmluZGVyKGcubm9kZXMsIHtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGg6IDIwLFxuICAgICAgICAgICAgICAgIG1pbkFyZWE6IDgwLFxuICAgICAgICAgICAgICAgIHNocmlua1NwYWNpbmc6IDQsXG4gICAgICAgICAgICAgICAgY2hhbmNlTm9EaXZpZGU6IDEsXG4gICAgICAgICAgICB9LCB0aGlzLnRlbnNvckZpZWxkKTtcbiAgICAgICAgcC5maW5kUG9seWdvbnMoKTtcbiAgICAgICAgY29uc3QgcG9seWdvbnMgPSBwLnBvbHlnb25zO1xuXG4gICAgICAgIGlmICh0aGlzLm1pbm9yUm9hZHMuYWxsU3RyZWFtbGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBCaWcgcGFya3MgLSBhZGQgY29uc2VjdXRpdmUgcG9seWdvbnNcbiAgICAgICAgICAgIHRoaXMuYmlnUGFya3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc21hbGxQYXJrcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zLmxlbmd0aCA+IHRoaXMubnVtQmlnUGFya3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJrSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAocG9seWdvbnMubGVuZ3RoIC0gdGhpcy5udW1CaWdQYXJrcykpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJrSW5kZXg7IGkgPCBwYXJrSW5kZXggKyB0aGlzLm51bUJpZ1BhcmtzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaWdQYXJrcy5wdXNoKHBvbHlnb25zW2ldKTsgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpZ1BhcmtzLnB1c2goLi4ucG9seWdvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU21hbGwgcGFya3NcbiAgICAgICAgICAgIHRoaXMuc21hbGxQYXJrcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bVNtYWxsUGFya3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmtJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvbHlnb25zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zbWFsbFBhcmtzLnB1c2gocG9seWdvbnNbcGFya0luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRlbnNvckZpZWxkLnBhcmtzID0gW107XG4gICAgICAgIHRoaXMudGVuc29yRmllbGQucGFya3MucHVzaCguLi50aGlzLmJpZ1BhcmtzKTtcbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5wYXJrcy5wdXNoKC4uLnRoaXMuc21hbGxQYXJrcyk7XG4gICAgfVxuXG4gICAgLy8gYXN5bmMgc2ltcGxlQmVuY2hNYXJrKCkge1xuICAgIC8vICAgICBsb2cuaW5mbyhgU3RhcnRpbmcgQmVuY2htYXJrLi4uYCk7XG4gICAgLy8gICAgIGNvbnN0IHRyaWVzID0gMTA7XG4gICAgLy8gICAgIGxldCBzdW0gPSAwO1xuICAgIC8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWVzOyBpKyspIHtcbiAgICAvLyAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gICAgICAgICBhd2FpdCB0aGlzLm1haW5Sb2Fkcy5nZW5lcmF0ZVJvYWRzKCk7XG4gICAgLy8gICAgICAgICBhd2FpdCB0aGlzLm1ham9yUm9hZHMuZ2VuZXJhdGVSb2FkcygpO1xuICAgIC8vICAgICAgICAgYXdhaXQgdGhpcy5taW5vclJvYWRzLmdlbmVyYXRlUm9hZHMoKTtcbiAgICAvLyAgICAgICAgIGF3YWl0IHRoaXMuYWRkQnVpbGRpbmdzKCk7XG4gICAgLy8gICAgICAgICBzdW0gKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIGxvZy5pbmZvKGBHZW5lcmF0ZWQgJHt0cmllc30gY2l0aWVzIHdpdGggYXZlcmFnZSAke3N1bS90cmllc31tc2ApO1xuICAgIC8vIH1cblxuICAgIGFzeW5jIGdlbmVyYXRlRXZlcnl0aGluZygpIHtcbiAgICAgICAgdGhpcy5jb2FzdGxpbmUuZ2VuZXJhdGVSb2FkcygpO1xuICAgICAgICBhd2FpdCB0aGlzLm1haW5Sb2Fkcy5nZW5lcmF0ZVJvYWRzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMubWFqb3JSb2Fkcy5nZW5lcmF0ZVJvYWRzKHRoaXMuYW5pbWF0ZSk7XG4gICAgICAgIGF3YWl0IHRoaXMubWlub3JSb2Fkcy5nZW5lcmF0ZVJvYWRzKHRoaXMuYW5pbWF0ZSk7XG4gICAgICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgdGhpcy5idWlsZGluZ3MuZ2VuZXJhdGUodGhpcy5hbmltYXRlKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCBjb250aW51ZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHdoaWxlIChjb250aW51ZVVwZGF0ZSAmJiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0IDwgdGhpcy5hbmltYXRpb25TcGVlZCkge1xuICAgICAgICAgICAgY29uc3QgbWlub3JDaGFuZ2VkID0gdGhpcy5taW5vclJvYWRzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgbWFqb3JDaGFuZ2VkID0gdGhpcy5tYWpvclJvYWRzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgbWFpbkNoYW5nZWQgPSB0aGlzLm1haW5Sb2Fkcy51cGRhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1aWxkaW5nc0NoYW5nZWQgPSB0aGlzLmJ1aWxkaW5ncy51cGRhdGUoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlVXBkYXRlID0gbWlub3JDaGFuZ2VkIHx8IG1ham9yQ2hhbmdlZCB8fCBtYWluQ2hhbmdlZCB8fCBidWlsZGluZ3NDaGFuZ2VkO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnJlZHJhdyA9IHRoaXMucmVkcmF3IHx8IGNvbnRpbnVlVXBkYXRlO1xuICAgIH1cblxuICAgIGRyYXcoc3R5bGU6IFN0eWxlLCBmb3JjZURyYXc9ZmFsc2UsIGN1c3RvbUNhbnZhcz86IENhbnZhc1dyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFzdHlsZS5uZWVkc1VwZGF0ZSAmJiAhZm9yY2VEcmF3ICYmICF0aGlzLnJlZHJhdyAmJiAhdGhpcy5kb21haW5Db250cm9sbGVyLm1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIubW92ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWRyYXcgPSBmYWxzZTtcblxuICAgICAgICBzdHlsZS5zZWFQb2x5Z29uID0gdGhpcy5jb2FzdGxpbmUuc2VhUG9seWdvbjtcbiAgICAgICAgc3R5bGUuY29hc3RsaW5lID0gdGhpcy5jb2FzdGxpbmUuY29hc3RsaW5lO1xuICAgICAgICBzdHlsZS5yaXZlciA9IHRoaXMuY29hc3RsaW5lLnJpdmVyO1xuICAgICAgICBzdHlsZS5sb3RzID0gdGhpcy5idWlsZGluZ3MubG90cztcblxuICAgICAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBEZWZhdWx0U3R5bGUgJiYgc3R5bGUuc2hvd0J1aWxkaW5nTW9kZWxzIHx8IHN0eWxlIGluc3RhbmNlb2YgUm91Z2hTdHlsZSkge1xuICAgICAgICAgICAgc3R5bGUuYnVpbGRpbmdNb2RlbHMgPSB0aGlzLmJ1aWxkaW5ncy5tb2RlbHM7ICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUucGFya3MgPSBbXTtcbiAgICAgICAgc3R5bGUucGFya3MucHVzaCguLi50aGlzLmJpZ1BhcmtzLm1hcChwID0+IHAubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSkpKTtcbiAgICAgICAgc3R5bGUucGFya3MucHVzaCguLi50aGlzLnNtYWxsUGFya3MubWFwKHAgPT4gcC5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKSkpO1xuICAgICAgICBzdHlsZS5taW5vclJvYWRzID0gdGhpcy5taW5vclJvYWRzLnJvYWRzO1xuICAgICAgICBzdHlsZS5tYWpvclJvYWRzID0gdGhpcy5tYWpvclJvYWRzLnJvYWRzO1xuICAgICAgICBzdHlsZS5tYWluUm9hZHMgPSB0aGlzLm1haW5Sb2Fkcy5yb2FkcztcbiAgICAgICAgc3R5bGUuY29hc3RsaW5lUm9hZHMgPSB0aGlzLmNvYXN0bGluZS5yb2FkcztcbiAgICAgICAgc3R5bGUuc2Vjb25kYXJ5Uml2ZXIgPSB0aGlzLmNvYXN0bGluZS5zZWNvbmRhcnlSaXZlcjtcbiAgICAgICAgc3R5bGUuZHJhdyhjdXN0b21DYW52YXMpO1xuICAgIH1cblxuICAgIHJvYWRzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ham9yUm9hZHMucm9hZHNFbXB0eSgpXG4gICAgICAgICAgICAmJiB0aGlzLm1pbm9yUm9hZHMucm9hZHNFbXB0eSgpXG4gICAgICAgICAgICAmJiB0aGlzLm1haW5Sb2Fkcy5yb2Fkc0VtcHR5KClcbiAgICAgICAgICAgICYmIHRoaXMuY29hc3RsaW5lLnJvYWRzRW1wdHkoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb2FkR1VJIHtcbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZXM6IFN0cmVhbWxpbmVHZW5lcmF0b3I7XG4gICAgcHJpdmF0ZSBleGlzdGluZ1N0cmVhbWxpbmVzOiBSb2FkR1VJW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBwcm90ZWN0ZWQgcHJlR2VuZXJhdGVDYWxsYmFjazogKCkgPT4gYW55ID0gKCkgPT4ge307XG4gICAgcHJvdGVjdGVkIHBvc3RHZW5lcmF0ZUNhbGxiYWNrOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcblxuICAgIHByaXZhdGUgc3RyZWFtbGluZXNJblByb2dyZXNzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBpbnRlZ3JhdG9yOiBGaWVsZEludGVncmF0b3IsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIGd1aUZvbGRlcjogZGF0LkdVSSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgY2xvc2VUZW5zb3JGb2xkZXI6ICgpID0+IHZvaWQsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIGZvbGRlck5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcmVkcmF3OiAoKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBfYW5pbWF0ZT1mYWxzZSkge1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzID0gbmV3IFN0cmVhbWxpbmVHZW5lcmF0b3IoXG4gICAgICAgICAgICB0aGlzLmludGVncmF0b3IsIHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4sXG4gICAgICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLCB0aGlzLnBhcmFtcyk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHBhdGggaXRlcmF0aW9ucyBiYXNlZCBvbiB3aW5kb3cgc2l6ZVxuICAgICAgICB0aGlzLnNldFBhdGhJdGVyYXRpb25zKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKTogdm9pZCA9PiB0aGlzLnNldFBhdGhJdGVyYXRpb25zKCkpO1xuICAgIH1cblxuICAgIGluaXRGb2xkZXIoKTogUm9hZEdVSSB7XG4gICAgICAgIGNvbnN0IHJvYWRHVUkgPSB7XG4gICAgICAgICAgICBHZW5lcmF0ZTogKCkgPT4gdGhpcy5nZW5lcmF0ZVJvYWRzKHRoaXMuX2FuaW1hdGUpLnRoZW4oKCkgPT4gdGhpcy5yZWRyYXcoKSksXG4gICAgICAgICAgICBKb2luRGFuZ2xpbmc6ICgpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmpvaW5EYW5nbGluZ1N0cmVhbWxpbmVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5ndWlGb2xkZXIuYWRkRm9sZGVyKHRoaXMuZm9sZGVyTmFtZSk7XG4gICAgICAgIGZvbGRlci5hZGQocm9hZEdVSSwgJ0dlbmVyYXRlJyk7XG4gICAgICAgIC8vIGZvbGRlci5hZGQocm9hZEdVSSwgJ0pvaW5EYW5nbGluZycpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFyYW1zRm9sZGVyID0gZm9sZGVyLmFkZEZvbGRlcignUGFyYW1zJyk7XG4gICAgICAgIHBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMsICdkc2VwJyk7XG4gICAgICAgIHBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMsICdkdGVzdCcpO1xuXG4gICAgICAgIGNvbnN0IGRldlBhcmFtc0ZvbGRlciA9IHBhcmFtc0ZvbGRlci5hZGRGb2xkZXIoJ0RldicpO1xuICAgICAgICB0aGlzLmFkZERldlBhcmFtc1RvRm9sZGVyKHRoaXMucGFyYW1zLCBkZXZQYXJhbXNGb2xkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQgYW5pbWF0ZShiOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGUgPSBiO1xuICAgIH1cblxuICAgIGdldCBhbGxTdHJlYW1saW5lcygpOiBWZWN0b3JbXVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMuYWxsU3RyZWFtbGluZXNTaW1wbGU7XG4gICAgfVxuXG4gICAgZ2V0IHJvYWRzKCk6IFZlY3RvcltdW10ge1xuICAgICAgICAvLyBGb3IgZHJhd2luZyBub3QgZ2VuZXJhdGlvbiwgcHJvYmFibHkgZmluZSB0byBsZWF2ZSBtYXBcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMuYWxsU3RyZWFtbGluZXNTaW1wbGUubWFwKHMgPT5cbiAgICAgICAgICAgIHMubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByb2Fkc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgc2V0RXhpc3RpbmdTdHJlYW1saW5lcyhleGlzdGluZ1N0cmVhbWxpbmVzOiBSb2FkR1VJW10pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5leGlzdGluZ1N0cmVhbWxpbmVzID0gZXhpc3RpbmdTdHJlYW1saW5lcztcbiAgICB9XG5cbiAgICBzZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKGNhbGxiYWNrOiAoKSA9PiBhbnkpIHtcbiAgICAgICAgdGhpcy5wcmVHZW5lcmF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgc2V0UG9zdEdlbmVyYXRlQ2FsbGJhY2soY2FsbGJhY2s6ICgpID0+IGFueSkge1xuICAgICAgICB0aGlzLnBvc3RHZW5lcmF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgY2xlYXJTdHJlYW1saW5lcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcy5jbGVhclN0cmVhbWxpbmVzKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2VuZXJhdGVSb2FkcyhhbmltYXRlPWZhbHNlKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgICAgIHRoaXMucHJlR2VuZXJhdGVDYWxsYmFjaygpO1xuXG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID0gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gLyBVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQ7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMgPSBuZXcgU3RyZWFtbGluZUdlbmVyYXRvcihcbiAgICAgICAgICAgIHRoaXMuaW50ZWdyYXRvciwgdGhpcy5kb21haW5Db250cm9sbGVyLm9yaWdpbixcbiAgICAgICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMsIE9iamVjdC5hc3NpZ24oe30sdGhpcy5wYXJhbXMpKTtcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSAqIFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVDtcblxuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5leGlzdGluZ1N0cmVhbWxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmFkZEV4aXN0aW5nU3RyZWFtbGluZXMocy5zdHJlYW1saW5lcykgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xvc2VUZW5zb3JGb2xkZXIoKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLmNyZWF0ZUFsbFN0cmVhbWxpbmVzKGFuaW1hdGUpLnRoZW4oKCkgPT4gdGhpcy5wb3N0R2VuZXJhdGVDYWxsYmFjaygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3RyZWFtbGluZXMgY2hhbmdlc1xuICAgICAqL1xuICAgIHVwZGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFkZERldlBhcmFtc1RvRm9sZGVyKHBhcmFtczogU3RyZWFtbGluZVBhcmFtcywgZm9sZGVyOiBkYXQuR1VJKTogdm9pZCB7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAncGF0aEl0ZXJhdGlvbnMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdzZWVkVHJpZXMnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkc3RlcCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2Rsb29rYWhlYWQnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkY2lyY2xlam9pbicpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2pvaW5hbmdsZScpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ3NpbXBsaWZ5VG9sZXJhbmNlJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnY29sbGlkZUVhcmx5Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwYXRoIGl0ZXJhdGlvbnMgc28gdGhhdCBhIHJvYWQgY2FuIGNvdmVyIHRoZSBzY3JlZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFBhdGhJdGVyYXRpb25zKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXggPSAxLjUgKiBNYXRoLm1heCh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy5wYXJhbXMucGF0aEl0ZXJhdGlvbnMgPSBtYXgvdGhpcy5wYXJhbXMuZHN0ZXA7XG4gICAgICAgIFV0aWwudXBkYXRlR3VpKHRoaXMuZ3VpRm9sZGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0ICogYXMgZGF0IGZyb20gJ2RhdC5ndWknO1xuaW1wb3J0IFRlbnNvckZpZWxkR1VJIGZyb20gJy4vdGVuc29yX2ZpZWxkX2d1aSc7XG5pbXBvcnQge05vaXNlUGFyYW1zfSBmcm9tICcuLi9pbXBsL3RlbnNvcl9maWVsZCc7XG5pbXBvcnQgQ2FudmFzV3JhcHBlciBmcm9tICcuL2NhbnZhc193cmFwcGVyJztcbmltcG9ydCB7RGVmYXVsdENhbnZhc1dyYXBwZXIsIFJvdWdoQ2FudmFzV3JhcHBlcn0gZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBQb2x5Z29uVXRpbCBmcm9tICcuLi9pbXBsL3BvbHlnb25fdXRpbCc7XG5pbXBvcnQgRHJhZ0NvbnRyb2xsZXIgZnJvbSAnLi9kcmFnX2NvbnRyb2xsZXInO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQge0J1aWxkaW5nTW9kZWx9IGZyb20gJy4vYnVpbGRpbmdzJztcblxuZXhwb3J0IGludGVyZmFjZSBDb2xvdXJTY2hlbWUge1xuICAgIGJnQ29sb3VyOiBzdHJpbmc7XG4gICAgYmdDb2xvdXJJbj86IHN0cmluZztcbiAgICBidWlsZGluZ0NvbG91cj86IHN0cmluZztcbiAgICBidWlsZGluZ1NpZGVDb2xvdXI/OiBzdHJpbmc7XG4gICAgYnVpbGRpbmdTdHJva2U/OiBzdHJpbmc7XG4gICAgc2VhQ29sb3VyOiBzdHJpbmc7XG4gICAgZ3Jhc3NDb2xvdXI/OiBzdHJpbmc7XG4gICAgbWlub3JSb2FkQ29sb3VyOiBzdHJpbmc7XG4gICAgbWlub3JSb2FkT3V0bGluZT86IHN0cmluZztcbiAgICBtYWpvclJvYWRDb2xvdXI/OiBzdHJpbmc7XG4gICAgbWFqb3JSb2FkT3V0bGluZT86IHN0cmluZztcbiAgICBtYWluUm9hZENvbG91cj86IHN0cmluZztcbiAgICBtYWluUm9hZE91dGxpbmU/OiBzdHJpbmc7XG4gICAgb3V0bGluZVNpemU/OiBudW1iZXI7XG4gICAgbWlub3JXaWR0aD86IG51bWJlcjtcbiAgICBtYWpvcldpZHRoPzogbnVtYmVyO1xuICAgIG1haW5XaWR0aD86IG51bWJlcjtcbiAgICB6b29tQnVpbGRpbmdzPzogYm9vbGVhbjtcbiAgICBidWlsZGluZ01vZGVscz86IGJvb2xlYW47XG4gICAgZnJhbWVDb2xvdXI/OiBzdHJpbmc7XG4gICAgZnJhbWVUZXh0Q29sb3VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTdHlsZSB7XG4gICAgcHJvdGVjdGVkIGNhbnZhczogQ2FudmFzV3JhcHBlcjtcbiAgICBwcm90ZWN0ZWQgZG9tYWluQ29udHJvbGxlcjogRG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBwdWJsaWMgYWJzdHJhY3QgY3JlYXRlQ2FudmFzV3JhcHBlcihjOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGU6IG51bWJlciwgcmVzaXplVG9XaW5kb3c6IGJvb2xlYW4pOiBDYW52YXNXcmFwcGVyO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBkcmF3KGNhbnZhcz86IENhbnZhc1dyYXBwZXIpOiB2b2lkO1xuXG4gICAgcHVibGljIHVwZGF0ZSgpOiB2b2lkIHt9XG5cbiAgICAvLyBQb2x5Z29uc1xuICAgIHB1YmxpYyBzZWFQb2x5Z29uOiBWZWN0b3JbXSA9IFtdO1xuICAgIHB1YmxpYyBsb3RzOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHVibGljIGJ1aWxkaW5nTW9kZWxzOiBCdWlsZGluZ01vZGVsW10gPSBbXTtcbiAgICBwdWJsaWMgcGFya3M6IFZlY3RvcltdW10gPSBbXTtcblxuICAgIC8vIFBvbHlsaW5lc1xuICAgIHB1YmxpYyBjb2FzdGxpbmU6IFZlY3RvcltdID0gW107XG4gICAgcHVibGljIHJpdmVyOiBWZWN0b3JbXSA9IFtdO1xuICAgIHB1YmxpYyBzZWNvbmRhcnlSaXZlcjogVmVjdG9yW10gPSBbXTtcbiAgICBwdWJsaWMgbWlub3JSb2FkczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHB1YmxpYyBtYWpvclJvYWRzOiBWZWN0b3JbXVtdID0gW107XG4gICAgcHVibGljIG1haW5Sb2FkczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHB1YmxpYyBjb2FzdGxpbmVSb2FkczogVmVjdG9yW11bXSA9IFtdO1xuICAgIHB1YmxpYyBzaG93RnJhbWU6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZHJhZ0NvbnRyb2xsZXI6IERyYWdDb250cm9sbGVyLCBwcm90ZWN0ZWQgY29sb3VyU2NoZW1lOiBDb2xvdXJTY2hlbWUpIHtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuYmdDb2xvdXIpIGxvZy5lcnJvcihcIkNvbG91clNjaGVtZSBFcnJvciAtIGJnQ29sb3VyIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5zZWFDb2xvdXIpIGxvZy5lcnJvcihcIkNvbG91clNjaGVtZSBFcnJvciAtIHNlYUNvbG91ciBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWlub3JSb2FkQ29sb3VyKSBsb2cuZXJyb3IoXCJDb2xvdXJTY2hlbWUgRXJyb3IgLSBtaW5vclJvYWRDb2xvdXIgbm90IGRlZmluZWRcIik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBjb2xvdXJzY2hlbWUgY2FzY2FkZVxuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5iZ0NvbG91ckluKSBjb2xvdXJTY2hlbWUuYmdDb2xvdXJJbiA9IGNvbG91clNjaGVtZS5iZ0NvbG91cjtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXIpIGNvbG91clNjaGVtZS5idWlsZGluZ0NvbG91ciA9IGNvbG91clNjaGVtZS5iZ0NvbG91cjtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuYnVpbGRpbmdTdHJva2UpIGNvbG91clNjaGVtZS5idWlsZGluZ1N0cm9rZSA9IGNvbG91clNjaGVtZS5iZ0NvbG91cjtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuZ3Jhc3NDb2xvdXIpIGNvbG91clNjaGVtZS5ncmFzc0NvbG91ciA9IGNvbG91clNjaGVtZS5iZ0NvbG91cjtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWlub3JSb2FkT3V0bGluZSkgY29sb3VyU2NoZW1lLm1pbm9yUm9hZE91dGxpbmUgPSBjb2xvdXJTY2hlbWUubWlub3JSb2FkQ29sb3VyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWpvclJvYWRDb2xvdXIpIGNvbG91clNjaGVtZS5tYWpvclJvYWRDb2xvdXIgPSBjb2xvdXJTY2hlbWUubWlub3JSb2FkQ29sb3VyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWpvclJvYWRPdXRsaW5lKSBjb2xvdXJTY2hlbWUubWFqb3JSb2FkT3V0bGluZSA9IGNvbG91clNjaGVtZS5taW5vclJvYWRPdXRsaW5lO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWluUm9hZENvbG91cikgY29sb3VyU2NoZW1lLm1haW5Sb2FkQ29sb3VyID0gY29sb3VyU2NoZW1lLm1ham9yUm9hZENvbG91cjtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWFpblJvYWRPdXRsaW5lKSBjb2xvdXJTY2hlbWUubWFpblJvYWRPdXRsaW5lID0gY29sb3VyU2NoZW1lLm1ham9yUm9hZE91dGxpbmU7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm91dGxpbmVTaXplKSBjb2xvdXJTY2hlbWUub3V0bGluZVNpemUgPSAxO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzKSBjb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5idWlsZGluZ01vZGVscykgY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzID0gZmFsc2U7XG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1pbm9yV2lkdGgpIGNvbG91clNjaGVtZS5taW5vcldpZHRoID0gMjtcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWFqb3JXaWR0aCkgY29sb3VyU2NoZW1lLm1ham9yV2lkdGggPSA0O1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWluV2lkdGgpIGNvbG91clNjaGVtZS5tYWluV2lkdGggPSA1O1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWluV2lkdGgpIGNvbG91clNjaGVtZS5tYWluV2lkdGggPSA1O1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5mcmFtZUNvbG91cikgY29sb3VyU2NoZW1lLmZyYW1lQ29sb3VyID0gY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5mcmFtZVRleHRDb2xvdXIpIGNvbG91clNjaGVtZS5mcmFtZVRleHRDb2xvdXIgPSBjb2xvdXJTY2hlbWUubWlub3JSb2FkT3V0bGluZTtcblxuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5idWlsZGluZ1NpZGVDb2xvdXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJnYiA9IFV0aWwucGFyc2VDU1NDb2xvcihjb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXIpLm1hcCh2ID0+IE1hdGgubWF4KDAsIHYgLSA0MCkpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZFJnYikge1xuICAgICAgICAgICAgICAgIGNvbG91clNjaGVtZS5idWlsZGluZ1NpZGVDb2xvdXIgPSBgcmdiKCR7cGFyc2VkUmdiWzBdfSwke3BhcnNlZFJnYlsxXX0sJHtwYXJzZWRSZ2JbMl19KWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG91clNjaGVtZS5idWlsZGluZ1NpZGVDb2xvdXIgPSBjb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHpvb21CdWlsZGluZ3MoYjogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzID0gYjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHNob3dCdWlsZGluZ01vZGVscyhiOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzID0gYjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHNob3dCdWlsZGluZ01vZGVscygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgY2FudmFzU2NhbGUoc2NhbGU6IG51bWJlcikge1xuICAgICAgICB0aGlzLmNhbnZhcy5jYW52YXNTY2FsZSA9IHNjYWxlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgbmVlZHNVcGRhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5uZWVkc1VwZGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IG5lZWRzVXBkYXRlKG46IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5jYW52YXMubmVlZHNVcGRhdGUgPSBuO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIERlZmF1bHRTdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjOiBIVE1MQ2FudmFzRWxlbWVudCwgZHJhZ0NvbnRyb2xsZXI6IERyYWdDb250cm9sbGVyLCBjb2xvdXJTY2hlbWU6IENvbG91clNjaGVtZSkge1xuICAgICAgICBzdXBlcihkcmFnQ29udHJvbGxlciwgY29sb3VyU2NoZW1lKTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhc1dyYXBwZXIoYywgMSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUNhbnZhc1dyYXBwZXIoYzogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpOiBDYW52YXNXcmFwcGVyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0Q2FudmFzV3JhcHBlcihjLCBzY2FsZSwgcmVzaXplVG9XaW5kb3cpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KGNhbnZhcz10aGlzLmNhbnZhcyBhcyBEZWZhdWx0Q2FudmFzV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBsZXQgYmdDb2xvdXI7XG4gICAgICAgIGlmICh0aGlzLmNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzKSB7XG4gICAgICAgICAgICBiZ0NvbG91ciA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID49IDIgPyB0aGlzLmNvbG91clNjaGVtZS5iZ0NvbG91ckluIDogdGhpcy5jb2xvdXJTY2hlbWUuYmdDb2xvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZ0NvbG91ciA9IHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUoYmdDb2xvdXIpO1xuICAgICAgICBjYW52YXMuY2xlYXJDYW52YXMoKTtcblxuICAgICAgICAvLyBTZWFcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5zZWFDb2xvdXIpO1xuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgwLjEpO1xuICAgICAgICBjYW52YXMuZHJhd1BvbHlnb24odGhpcy5zZWFQb2x5Z29uKTtcblxuICAgICAgICAvLyBDb2FzdGxpbmVcbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKGJnQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgzMCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5bGluZSh0aGlzLmNvYXN0bGluZSk7XG5cbiAgICAgICAgLy8gUGFya3NcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgxKTtcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5ncmFzc0NvbG91cik7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBhcmtzKSBjYW52YXMuZHJhd1BvbHlnb24ocCk7XG5cbiAgICAgICAgLy8gUml2ZXJcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5zZWFDb2xvdXIpO1xuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgwLjEpO1xuICAgICAgICBjYW52YXMuZHJhd1BvbHlnb24odGhpcy5yaXZlcik7XG5cbiAgICAgICAgLy8gUm9hZCBvdXRsaW5lXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5taW5vclJvYWRPdXRsaW5lKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5vdXRsaW5lU2l6ZSArIHRoaXMuY29sb3VyU2NoZW1lLm1pbm9yV2lkdGggKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLm1pbm9yUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XG5cbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLm1ham9yUm9hZE91dGxpbmUpO1xuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKHRoaXMuY29sb3VyU2NoZW1lLm91dGxpbmVTaXplICsgdGhpcy5jb2xvdXJTY2hlbWUubWFqb3JXaWR0aCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMubWFqb3JSb2FkcykgY2FudmFzLmRyYXdQb2x5bGluZShzKTtcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5bGluZSh0aGlzLnNlY29uZGFyeVJpdmVyKTtcblxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUubWFpblJvYWRPdXRsaW5lKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5vdXRsaW5lU2l6ZSArIHRoaXMuY29sb3VyU2NoZW1lLm1haW5XaWR0aCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMubWFpblJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5jb2FzdGxpbmVSb2FkcykgY2FudmFzLmRyYXdQb2x5bGluZShzKTtcblxuICAgICAgICAvLyBSb2FkIGlubGluZVxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUubWlub3JSb2FkQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5taW5vcldpZHRoICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5taW5vclJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5tYWpvclJvYWRDb2xvdXIpO1xuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKHRoaXMuY29sb3VyU2NoZW1lLm1ham9yV2lkdGggKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLm1ham9yUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5zZWNvbmRhcnlSaXZlcik7XG5cbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLm1haW5Sb2FkQ29sb3VyKTtcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5tYWluV2lkdGggKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLm1haW5Sb2FkcykgY2FudmFzLmRyYXdQb2x5bGluZShzKTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuY29hc3RsaW5lUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XG5cbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgxKTtcbiAgICAgICAgLy8gQnVpbGRpbmdzXG4gICAgICAgIGlmICghdGhpcy5jb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyB8fCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA+PSAyKSB7XG4gICAgICAgICAgICBjYW52YXMuc2V0RmlsbFN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nQ29sb3VyKTtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ1N0cm9rZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5sb3RzKSBjYW52YXMuZHJhd1BvbHlnb24oYik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQc2V1ZG8tM0RcbiAgICAgICAgaWYgKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzICYmICghdGhpcy5jb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncyB8fCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA+PSAyLjUpKSB7XG4gICAgICAgICAgICBjYW52YXMuc2V0RmlsbFN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU2lkZUNvbG91cik7XG4gICAgICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdTaWRlQ29sb3VyKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLmJ1aWxkaW5nTW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIGIuc2lkZXMpIGNhbnZhcy5kcmF3UG9seWdvbihzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXIpO1xuICAgICAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLmJ1aWxkaW5nTW9kZWxzKSBjYW52YXMuZHJhd1BvbHlnb24oYi5yb29mKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNob3dGcmFtZSkge1xuICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5mcmFtZUNvbG91cik7XG4gICAgICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZnJhbWVDb2xvdXIpO1xuICAgICAgICAgICAgY2FudmFzLmRyYXdGcmFtZSgzMCwgMzAsIDMwLCAzMCk7XG5cbiAgICAgICAgICAgIC8vIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZnJhbWVUZXh0Q29sb3VyKTtcbiAgICAgICAgICAgIC8vIGNhbnZhcy5kcmF3Q2l0eU5hbWUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJvdWdoU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgcHJpdmF0ZSBkcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoYzogSFRNTENhbnZhc0VsZW1lbnQsIGRyYWdDb250cm9sbGVyOiBEcmFnQ29udHJvbGxlciwgY29sb3VyU2NoZW1lOiBDb2xvdXJTY2hlbWUpIHtcbiAgICAgICAgc3VwZXIoZHJhZ0NvbnRyb2xsZXIsIGNvbG91clNjaGVtZSk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXNXcmFwcGVyKGMsIDEsIHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVDYW52YXNXcmFwcGVyKGM6IEhUTUxDYW52YXNFbGVtZW50LCBzY2FsZT0xLCByZXNpemVUb1dpbmRvdz10cnVlKTogQ2FudmFzV3JhcHBlciB7XG4gICAgICAgIHJldHVybiBuZXcgUm91Z2hDYW52YXNXcmFwcGVyKGMsIHNjYWxlLCByZXNpemVUb1dpbmRvdyk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmRyYWdDb250cm9sbGVyLmlzRHJhZ2dpbmcgfHwgdGhpcy5kb21haW5Db250cm9sbGVyLmlzU2Nyb2xsaW5nO1xuICAgICAgICBpZiAoIWRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcpIHRoaXMuY2FudmFzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KGNhbnZhcz10aGlzLmNhbnZhcyBhcyBSb3VnaENhbnZhc1dyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgZmlsbDogdGhpcy5jb2xvdXJTY2hlbWUuYmdDb2xvdXIsXG4gICAgICAgICAgICByb3VnaG5lc3M6IDEsXG4gICAgICAgICAgICBib3dpbmc6IDEsXG4gICAgICAgICAgICBmaWxsU3R5bGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICB9KTtcblxuICAgICAgICBjYW52YXMuY2xlYXJDYW52YXMoKTtcblxuICAgICAgICAvLyBTZWFcbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcm91Z2huZXNzOiAwLFxuICAgICAgICAgICAgZmlsbFdlaWdodDogMSxcbiAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3VyU2NoZW1lLnNlYUNvbG91cixcbiAgICAgICAgICAgIGZpbGxTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHRoaXMuc2VhUG9seWdvbik7XG5cbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG91clNjaGVtZS5iZ0NvbG91cixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAzMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5jb2FzdGxpbmUpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHJvdWdobmVzczogMCxcbiAgICAgICAgICAgIGZpbGxXZWlnaHQ6IDEsXG4gICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG91clNjaGVtZS5zZWFDb2xvdXIsXG4gICAgICAgICAgICBmaWxsU3R5bGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWdvbih0aGlzLnJpdmVyKTtcblxuICAgICAgICAvLyBQYXJrc1xuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG91clNjaGVtZS5ncmFzc0NvbG91cixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFya3MuZm9yRWFjaChwID0+IGNhbnZhcy5kcmF3UG9seWdvbihwKSk7XG5cbiAgICAgICAgLy8gUm9hZHNcbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG91clNjaGVtZS5taW5vclJvYWRDb2xvdXIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5taW5vclJvYWRzLmZvckVhY2gocyA9PiBjYW52YXMuZHJhd1BvbHlsaW5lKHMpKTtcblxuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICAgIHN0cm9rZTogdGhpcy5jb2xvdXJTY2hlbWUubWFqb3JSb2FkQ29sb3VyLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1ham9yUm9hZHMuZm9yRWFjaChzID0+IGNhbnZhcy5kcmF3UG9seWxpbmUocykpO1xuICAgICAgICBjYW52YXMuZHJhd1BvbHlsaW5lKHRoaXMuc2Vjb25kYXJ5Uml2ZXIpO1xuXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAzLFxuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG91clNjaGVtZS5tYWluUm9hZENvbG91cixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYWluUm9hZHMuZm9yRWFjaChzID0+IGNhbnZhcy5kcmF3UG9seWxpbmUocykpO1xuICAgICAgICB0aGlzLmNvYXN0bGluZVJvYWRzLmZvckVhY2gocyA9PiBjYW52YXMuZHJhd1BvbHlsaW5lKHMpKTtcblxuICAgICAgICAvLyBCdWlsZGluZ3NcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAvLyBMb3RzXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29sb3VyU2NoZW1lLnpvb21CdWlsZGluZ3MgfHwgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPj0gMikge1xuICAgICAgICAgICAgICAgIC8vIExvdHNcbiAgICAgICAgICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIHJvdWdobmVzczogMS4yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIHRoaXMubG90cykgY2FudmFzLmRyYXdQb2x5Z29uKGIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQc2V1ZG8tM0RcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ01vZGVscyAmJiAoIXRoaXMuY29sb3VyU2NoZW1lLnpvb21CdWlsZGluZ3MgfHwgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPj0gMi41KSkge1xuICAgICAgICAgICAgICAgIC8vIFBzZXVkby0zRFxuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgcm91Z2huZXNzOiAxLjIsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdTdHJva2UsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ1NpZGVDb2xvdXIsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgY2FuIGJlIGh1Z2VseSBpbXByb3ZlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFNpZGVzRGlzdGFuY2VzOiBhbnlbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci5nZXRDYW1lcmFQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLmJ1aWxkaW5nTW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBiLnNpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdmVyYWdlUG9pbnQgPSBzWzBdLmNsb25lKCkuYWRkKHNbMV0pLmRpdmlkZVNjYWxhcigyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFNpZGVzRGlzdGFuY2VzLnB1c2goW2F2ZXJhZ2VQb2ludC5kaXN0YW5jZVRvU3F1YXJlZChjYW1lcmEpLCBzXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxsU2lkZXNEaXN0YW5jZXMuc29ydCgoYSwgYikgPT4gYlswXSAtIGFbMF0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBhbGxTaWRlc0Rpc3RhbmNlcykgY2FudmFzLmRyYXdQb2x5Z29uKHBbMV0pO1xuXG4gICAgICAgICAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICByb3VnaG5lc3M6IDEuMixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ1N0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nQ29sb3VyLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIHRoaXMuYnVpbGRpbmdNb2RlbHMpIGNhbnZhcy5kcmF3UG9seWdvbihiLnJvb2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7RGVmYXVsdENhbnZhc1dyYXBwZXJ9IGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XG5pbXBvcnQgRHJhZ0NvbnRyb2xsZXIgZnJvbSAnLi9kcmFnX2NvbnRyb2xsZXInO1xuaW1wb3J0IFRlbnNvckZpZWxkIGZyb20gJy4uL2ltcGwvdGVuc29yX2ZpZWxkJztcbmltcG9ydCB7Tm9pc2VQYXJhbXN9IGZyb20gJy4uL2ltcGwvdGVuc29yX2ZpZWxkJztcbmltcG9ydCB7QmFzaXNGaWVsZH0gZnJvbSAnLi4vaW1wbC9iYXNpc19maWVsZCc7XG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVuc29yRmllbGRHVUkgZXh0ZW5kcyBUZW5zb3JGaWVsZCB7XG4gICAgcHJpdmF0ZSBURU5TT1JfTElORV9ESUFNRVRFUiA9IDIwO1xuICAgIHByaXZhdGUgVEVOU09SX1NQQVdOX1NDQUxFID0gMC43OyAgLy8gSG93IG11Y2ggdG8gc2hyaW5rIHdvcmxkRGltZW5zaW9ucyB0byBmaW5kIHNwYXduIHBvaW50XG4gICAgcHJpdmF0ZSBkb21haW5Db250cm9sbGVyID0gRG9tYWluQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBndWlGb2xkZXI6IGRhdC5HVUksIHByaXZhdGUgZHJhZ0NvbnRyb2xsZXI6IERyYWdDb250cm9sbGVyLFxuICAgICAgICBwdWJsaWMgZHJhd0NlbnRyZTogYm9vbGVhbiwgbm9pc2VQYXJhbXM6IE5vaXNlUGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKG5vaXNlUGFyYW1zKTtcbiAgICAgICAgLy8gRm9yIGN1c3RvbSBuYW1pbmcgb2YgZ3VpIGJ1dHRvbnNcbiAgICAgICAgY29uc3QgdGVuc29yRmllbGRHdWlPYmogPSB7XG4gICAgICAgICAgICByZXNldDogKCk6IHZvaWQgPT4gdGhpcy5yZXNldCgpLFxuICAgICAgICAgICAgc2V0UmVjb21tZW5kZWQ6ICgpOiB2b2lkID0+IHRoaXMuc2V0UmVjb21tZW5kZWQoKSxcbiAgICAgICAgICAgIGFkZFJhZGlhbDogKCk6IHZvaWQgPT4gdGhpcy5hZGRSYWRpYWxSYW5kb20oKSxcbiAgICAgICAgICAgIGFkZEdyaWQ6ICgpOiB2b2lkID0+IHRoaXMuYWRkR3JpZFJhbmRvbSgpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ3VpRm9sZGVyLmFkZCh0ZW5zb3JGaWVsZEd1aU9iaiwgJ3Jlc2V0Jyk7XG4gICAgICAgIHRoaXMuZ3VpRm9sZGVyLmFkZCh0ZW5zb3JGaWVsZEd1aU9iaiwgJ3NldFJlY29tbWVuZGVkJyk7XG4gICAgICAgIHRoaXMuZ3VpRm9sZGVyLmFkZCh0ZW5zb3JGaWVsZEd1aU9iaiwgJ2FkZFJhZGlhbCcpO1xuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdhZGRHcmlkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogNCBHcmlkcywgb25lIHJhZGlhbFxuICAgICAqL1xuICAgIHNldFJlY29tbWVuZGVkKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLm11bHRpcGx5U2NhbGFyKHRoaXMuVEVOU09SX1NQQVdOX1NDQUxFKTtcbiAgICAgICAgY29uc3QgbmV3T3JpZ2luID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9uc1xuICAgICAgICAgICAgLm11bHRpcGx5U2NhbGFyKCgxIC0gdGhpcy5URU5TT1JfU1BBV05fU0NBTEUpIC8gMilcbiAgICAgICAgICAgIC5hZGQodGhpcy5kb21haW5Db250cm9sbGVyLm9yaWdpbik7XG4gICAgICAgIHRoaXMuYWRkR3JpZEF0TG9jYXRpb24obmV3T3JpZ2luKTtcbiAgICAgICAgdGhpcy5hZGRHcmlkQXRMb2NhdGlvbihuZXdPcmlnaW4uY2xvbmUoKS5hZGQoc2l6ZSkpO1xuICAgICAgICB0aGlzLmFkZEdyaWRBdExvY2F0aW9uKG5ld09yaWdpbi5jbG9uZSgpLmFkZChuZXcgVmVjdG9yKHNpemUueCwgMCkpKTtcbiAgICAgICAgdGhpcy5hZGRHcmlkQXRMb2NhdGlvbihuZXdPcmlnaW4uY2xvbmUoKS5hZGQobmV3IFZlY3RvcigwLCBzaXplLnkpKSk7XG4gICAgICAgIHRoaXMuYWRkUmFkaWFsUmFuZG9tKCk7XG4gICAgfVxuXG4gICAgYWRkUmFkaWFsUmFuZG9tKCk6IHZvaWQge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMueDtcbiAgICAgICAgdGhpcy5hZGRSYWRpYWwodGhpcy5yYW5kb21Mb2NhdGlvbigpLFxuICAgICAgICAgICAgVXRpbC5yYW5kb21SYW5nZSh3aWR0aC8xMCwgd2lkdGgvNSksICAvLyBTaXplXG4gICAgICAgICAgICBVdGlsLnJhbmRvbVJhbmdlKDUwKSk7ICAvLyBEZWNheVxuICAgIH1cblxuICAgIGFkZEdyaWRSYW5kb20oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWRkR3JpZEF0TG9jYXRpb24odGhpcy5yYW5kb21Mb2NhdGlvbigpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZEdyaWRBdExvY2F0aW9uKGxvY2F0aW9uOiBWZWN0b3IpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLng7XG4gICAgICAgIHRoaXMuYWRkR3JpZChsb2NhdGlvbixcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2Uod2lkdGgvNCwgd2lkdGgpLCAgLy8gU2l6ZVxuICAgICAgICAgICAgVXRpbC5yYW5kb21SYW5nZSg1MCksICAvLyBEZWNheVxuICAgICAgICAgICAgVXRpbC5yYW5kb21SYW5nZShNYXRoLlBJLzIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1zcGFjZSByYW5kb20gbG9jYXRpb24gZm9yIHRlbnNvciBmaWVsZCBzcGF3blxuICAgICAqIFNhbXBsZWQgZnJvbSBtaWRkbGUgb2Ygc2NyZWVuIChzaHJ1bmsgcmVjdGFuZ2xlKVxuICAgICAqL1xuICAgIHByaXZhdGUgcmFuZG9tTG9jYXRpb24oKTogVmVjdG9yIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMubXVsdGlwbHlTY2FsYXIodGhpcy5URU5TT1JfU1BBV05fU0NBTEUpO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBWZWN0b3IoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSkubXVsdGlwbHkoc2l6ZSk7XG4gICAgICAgIGNvbnN0IG5ld09yaWdpbiA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMubXVsdGlwbHlTY2FsYXIoKDEgLSB0aGlzLlRFTlNPUl9TUEFXTl9TQ0FMRSkgLyAyKTtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmFkZCh0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luKS5hZGQobmV3T3JpZ2luKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENyb3NzTG9jYXRpb25zKCk6IFZlY3RvcltdIHtcbiAgICAgICAgLy8gR2V0cyBncmlkIG9mIHBvaW50cyBmb3IgdmVjdG9yIGZpZWxkIHZpcyBpbiB3b3JsZCBzcGFjZVxuICAgICAgICBjb25zdCBkaWFtZXRlciA9IHRoaXMuVEVOU09SX0xJTkVfRElBTUVURVIgLyB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbTtcbiAgICAgICAgY29uc3Qgd29ybGREaW1lbnNpb25zID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucztcbiAgICAgICAgY29uc3QgbkhvciA9IE1hdGguY2VpbCh3b3JsZERpbWVuc2lvbnMueCAvIGRpYW1ldGVyKSArIDE7IC8vIFByZXZlbnQgcG9wLWluXG4gICAgICAgIGNvbnN0IG5WZXIgPSBNYXRoLmNlaWwod29ybGREaW1lbnNpb25zLnkgLyBkaWFtZXRlcikgKyAxO1xuICAgICAgICBjb25zdCBvcmlnaW5YID0gZGlhbWV0ZXIgKiBNYXRoLmZsb29yKHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4ueCAvIGRpYW1ldGVyKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luWSA9IGRpYW1ldGVyICogTWF0aC5mbG9vcih0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLnkgLyBkaWFtZXRlcik7XG5cbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDw9IG5Ib3I7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPD0gblZlcjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobmV3IFZlY3RvcihvcmlnaW5YICsgKHggKiBkaWFtZXRlciksIG9yaWdpblkgKyAoeSAqIGRpYW1ldGVyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRlbnNvckxpbmUocG9pbnQ6IFZlY3RvciwgdGVuc29yVjogVmVjdG9yKTogVmVjdG9yW10ge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4ocG9pbnQuY2xvbmUoKSk7XG5cbiAgICAgICAgY29uc3QgZGlmZiA9IHRlbnNvclYubXVsdGlwbHlTY2FsYXIodGhpcy5URU5TT1JfTElORV9ESUFNRVRFUiAvIDIpOyAgLy8gQXNzdW1lcyBub3JtYWxpc2VkXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdHJhbnNmb3JtZWRQb2ludC5jbG9uZSgpLnN1YihkaWZmKTtcbiAgICAgICAgY29uc3QgZW5kID0gdHJhbnNmb3JtZWRQb2ludC5jbG9uZSgpLmFkZChkaWZmKTtcbiAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgICB9XG5cbiAgICBkcmF3KGNhbnZhczogRGVmYXVsdENhbnZhc1dyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gRHJhdyB0ZW5zb3IgZmllbGRcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSgnYmxhY2snKTtcbiAgICAgICAgY2FudmFzLmNsZWFyQ2FudmFzKCk7XG5cbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKCd3aGl0ZScpO1xuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKDEpO1xuICAgICAgICBjb25zdCB0ZW5zb3JQb2ludHMgPSB0aGlzLmdldENyb3NzTG9jYXRpb25zKCk7XG4gICAgICAgIHRlbnNvclBvaW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuc2FtcGxlUG9pbnQocCk7XG4gICAgICAgICAgICBjYW52YXMuZHJhd1BvbHlsaW5lKHRoaXMuZ2V0VGVuc29yTGluZShwLCB0LmdldE1ham9yKCkpKTtcbiAgICAgICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5nZXRUZW5zb3JMaW5lKHAsIHQuZ2V0TWlub3IoKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEcmF3IGNlbnRyZSBwb2ludHMgb2YgZmllbGRzXG4gICAgICAgIGlmICh0aGlzLmRyYXdDZW50cmUpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUoJ3JlZCcpO1xuICAgICAgICAgICAgdGhpcy5nZXRDZW50cmVQb2ludHMoKS5mb3JFYWNoKHYgPT5cbiAgICAgICAgICAgICAgICBjYW52YXMuZHJhd1NxdWFyZSh0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2KSwgNykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFkZEZpZWxkKGZpZWxkOiBCYXNpc0ZpZWxkKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLmFkZEZpZWxkKGZpZWxkKTtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5ndWlGb2xkZXIuYWRkRm9sZGVyKGAke2ZpZWxkLkZPTERFUl9OQU1FfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gZGVyZWdpc3RlciBmcm9tIGRyYWcgY29udHJvbGxlclxuICAgICAgICBjb25zdCBkZXJlZ2lzdGVyRHJhZyA9IHRoaXMuZHJhZ0NvbnRyb2xsZXIucmVnaXN0ZXIoXG4gICAgICAgICAgICAoKSA9PiBmaWVsZC5jZW50cmUsIGZpZWxkLmRyYWdNb3ZlTGlzdGVuZXIuYmluZChmaWVsZCkpO1xuICAgICAgICBjb25zdCByZW1vdmVGaWVsZE9iaiA9IHtyZW1vdmU6ICgpOiB2b2lkID0+IHRoaXMucmVtb3ZlRmllbGRHVUkuYmluZCh0aGlzKShmaWVsZCwgZm9sZGVyLCBkZXJlZ2lzdGVyRHJhZyl9O1xuICAgICAgICBcbiAgICAgICAgLy8gR2l2ZSBkYXQgZ3VpIHJlbW92ZUZpZWxkIGJ1dHRvblxuICAgICAgICBmb2xkZXIuYWRkKHJlbW92ZUZpZWxkT2JqLCAncmVtb3ZlJyk7XG4gICAgICAgIGZpZWxkLnNldEd1aShmb2xkZXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVtb3ZlRmllbGRHVUkoZmllbGQ6IEJhc2lzRmllbGQsIGZvbGRlcjogZGF0LkdVSSwgZGVyZWdpc3RlckRyYWc6ICgoKSA9PiB2b2lkKSk6IHZvaWQge1xuICAgICAgICBzdXBlci5yZW1vdmVGaWVsZChmaWVsZCk7XG4gICAgICAgIHRoaXMuZ3VpRm9sZGVyLnJlbW92ZUZvbGRlcihmb2xkZXIpO1xuICAgICAgICAvLyBEZXJlZ2lzdGVyIGZyb20gZHJhZyBjb250cm9sbGVyXG4gICAgICAgIGRlcmVnaXN0ZXJEcmFnKCk7XG4gICAgfVxuXG4gICAgcmVzZXQoKTogdm9pZCB7XG4gICAgICAgIC8vIFRPRE8ga2luZCBvZiBoYWNreSAtIGNhbGxpbmcgcmVtb3ZlIGNhbGxiYWNrcyBmcm9tIGd1aSBvYmplY3QsIHNob3VsZCBzdG9yZSBjYWxsYmFja3NcbiAgICAgICAgLy8gaW4gYWRkZmllbGQgYW5kIGNhbGwgdGhlbSAocmVxdWlyZXMgbWFraW5nIHN1cmUgdGhleSdyZSBpZGVtcG90ZW50KVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkRm9sZGVyTmFtZSBpbiB0aGlzLmd1aUZvbGRlci5fX2ZvbGRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkRm9sZGVyID0gdGhpcy5ndWlGb2xkZXIuX19mb2xkZXJzW2ZpZWxkRm9sZGVyTmFtZV07XG4gICAgICAgICAgICAoZmllbGRGb2xkZXIuX19jb250cm9sbGVyc1swXSBhcyBhbnkpLmluaXRpYWxWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIucmVzZXQoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcbmltcG9ydCB7V2F0ZXJQYXJhbXN9IGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcbmltcG9ydCBXYXRlckdlbmVyYXRvciBmcm9tICcuLi9pbXBsL3dhdGVyX2dlbmVyYXRvcic7XG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgUG9seWdvbkZpbmRlciBmcm9tICcuLi9pbXBsL3BvbHlnb25fZmluZGVyJztcbmltcG9ydCBQb2x5Z29uVXRpbCBmcm9tICcuLi9pbXBsL3BvbHlnb25fdXRpbCc7XG5pbXBvcnQgUm9hZEdVSSBmcm9tICcuL3JvYWRfZ3VpJztcbmltcG9ydCB7Tm9pc2VQYXJhbXN9IGZyb20gJy4uL2ltcGwvdGVuc29yX2ZpZWxkJztcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuLi9pbXBsL3RlbnNvcl9maWVsZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhdGVyR1VJIGV4dGVuZHMgUm9hZEdVSSB7XG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVzOiBXYXRlckdlbmVyYXRvcjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJhbXM6IFdhdGVyUGFyYW1zLFxuICAgICAgICAgICAgICAgIGludGVncmF0b3I6IEZpZWxkSW50ZWdyYXRvcixcbiAgICAgICAgICAgICAgICBndWlGb2xkZXI6IGRhdC5HVUksXG4gICAgICAgICAgICAgICAgY2xvc2VUZW5zb3JGb2xkZXI6ICgpID0+IHZvaWQsXG4gICAgICAgICAgICAgICAgZm9sZGVyTmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlZHJhdzogKCkgPT4gdm9pZCkge1xuICAgICAgICBzdXBlcihwYXJhbXMsIGludGVncmF0b3IsIGd1aUZvbGRlciwgY2xvc2VUZW5zb3JGb2xkZXIsIGZvbGRlck5hbWUsIHJlZHJhdyk7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMgPSBuZXcgV2F0ZXJHZW5lcmF0b3IoXG4gICAgICAgICAgICB0aGlzLmludGVncmF0b3IsIHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4sXG4gICAgICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSx0aGlzLnBhcmFtcyksIHRoaXMudGVuc29yRmllbGQpO1xuICAgIH1cblxuICAgIGluaXRGb2xkZXIoKTogV2F0ZXJHVUkge1xuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmd1aUZvbGRlci5hZGRGb2xkZXIodGhpcy5mb2xkZXJOYW1lKTtcbiAgICAgICAgZm9sZGVyLmFkZCh7R2VuZXJhdGU6ICgpID0+IHRoaXMuZ2VuZXJhdGVSb2FkcygpfSwgJ0dlbmVyYXRlJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjb2FzdFBhcmFtc0ZvbGRlciA9IGZvbGRlci5hZGRGb2xkZXIoJ0NvYXN0UGFyYW1zJyk7XG4gICAgICAgIGNvYXN0UGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VFbmFibGVkJyk7XG4gICAgICAgIGNvYXN0UGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VTaXplJyk7XG4gICAgICAgIGNvYXN0UGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VBbmdsZScpO1xuICAgICAgICBjb25zdCByaXZlclBhcmFtc0ZvbGRlciA9IGZvbGRlci5hZGRGb2xkZXIoJ1JpdmVyUGFyYW1zJyk7XG4gICAgICAgIHJpdmVyUGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5yaXZlck5vaXNlLCAnbm9pc2VFbmFibGVkJyk7XG4gICAgICAgIHJpdmVyUGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5yaXZlck5vaXNlLCAnbm9pc2VTaXplJyk7XG4gICAgICAgIHJpdmVyUGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5yaXZlck5vaXNlLCAnbm9pc2VBbmdsZScpO1xuICAgICAgICBcbiAgICAgICAgZm9sZGVyLmFkZCh0aGlzLnBhcmFtcywgJ3NpbXBsaWZ5VG9sZXJhbmNlJyk7XG4gICAgICAgIGNvbnN0IGRldlBhcmFtc0ZvbGRlciA9IGZvbGRlci5hZGRGb2xkZXIoJ0RldicpO1xuICAgICAgICB0aGlzLmFkZERldlBhcmFtc1RvRm9sZGVyKHRoaXMucGFyYW1zLCBkZXZQYXJhbXNGb2xkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZW5lcmF0ZVJvYWRzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLnByZUdlbmVyYXRlQ2FsbGJhY2soKTtcblxuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tIC8gVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UO1xuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzID0gbmV3IFdhdGVyR2VuZXJhdG9yKFxuICAgICAgICAgICAgdGhpcy5pbnRlZ3JhdG9yLCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLFxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucyxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sdGhpcy5wYXJhbXMpLCB0aGlzLnRlbnNvckZpZWxkKTtcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSAqIFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVDtcblxuICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmNyZWF0ZUNvYXN0KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMuY3JlYXRlUml2ZXIoKTtcbiAgICAgICBcbiAgICAgICAgdGhpcy5jbG9zZVRlbnNvckZvbGRlcigpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB0aGlzLnBvc3RHZW5lcmF0ZUNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHJlc29sdmUoKSk7XG4gICAgfVxuXG4gICAgZ2V0IHN0cmVhbWxpbmVzV2l0aFNlY29uZGFyeVJvYWQoKTogVmVjdG9yW11bXSB7XG4gICAgICAgIGNvbnN0IHdpdGhTZWNvbmRhcnkgPSB0aGlzLnN0cmVhbWxpbmVzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnNsaWNlKCk7XG4gICAgICAgIHdpdGhTZWNvbmRhcnkucHVzaCh0aGlzLnN0cmVhbWxpbmVzLnJpdmVyU2Vjb25kYXJ5Um9hZCk7XG4gICAgICAgIHJldHVybiB3aXRoU2Vjb25kYXJ5O1xuICAgIH1cblxuICAgIGdldCByaXZlcigpOiBWZWN0b3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLnJpdmVyUG9seWdvbi5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKTtcbiAgICB9XG5cbiAgICBnZXQgc2Vjb25kYXJ5Uml2ZXIoKTogVmVjdG9yW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5yaXZlclNlY29uZGFyeVJvYWQubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSk7XG4gICAgfVxuXG4gICAgZ2V0IGNvYXN0bGluZSgpOiBWZWN0b3JbXSB7XG4gICAgICAgIC8vIFVzZSB1bnNpbXBsaWZpZWQgbm9pc3kgc3RyZWFtbGluZSBhcyBjb2FzdGxpbmVcbiAgICAgICAgLy8gVmlzdWFsIG9ubHksIG5vIHJvYWQgbG9naWMgcGVyZm9ybWVkIHVzaW5nIHRoaXNcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMuY29hc3RsaW5lLm1hcCh2ID0+IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSkpO1xuICAgIH1cblxuICAgIGdldCBzZWFQb2x5Z29uKCk6IFZlY3RvcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtbGluZXMuc2VhUG9seWdvbi5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYWRkRGV2UGFyYW1zVG9Gb2xkZXIocGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zLCBmb2xkZXI6IGRhdC5HVUkpOiB2b2lkIHtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkc2VwJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnZHRlc3QnKTtcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdwYXRoSXRlcmF0aW9ucycpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ3NlZWRUcmllcycpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2RzdGVwJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnZGxvb2thaGVhZCcpO1xuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2RjaXJjbGVqb2luJyk7XG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnam9pbmFuZ2xlJyk7XG4gICAgfVxuICAgIFxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBSYW5kb21SYW5nZSB7XG4gICAgbWluPzogbnVtYmVyLFxuICAgIG1heDogbnVtYmVyLFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVdGlsIHtcbiAgICAvLyBNdXN0IG1hdGNoIHN0eWxlLmNzc1xuICAgIHN0YXRpYyByZWFkb25seSBDQU5WQVNfSUQgPSAnbWFwLWNhbnZhcyc7XG4gICAgc3RhdGljIHJlYWRvbmx5IElNR19DQU5WQVNfSUQgPSAnaW1nLWNhbnZhcyc7XG4gICAgc3RhdGljIHJlYWRvbmx5IFNWR19JRCA9ICdtYXAtc3ZnJztcblxuICAgIC8vIEhvdyBmYXIgdG8gaW50ZWdyYXRlIHN0cmVhbWxpbmVzIGJleW9uZCBzY3JlZW4gLSBmb3IgbWFraW5nIGJ1aWxkaW5ncyByZWFjaCB0aGUgZWRnZVxuICAgIHN0YXRpYyByZWFkb25seSBEUkFXX0lORkxBVEVfQU1PVU5UID0gMS4yO1xuXG4gICAgc3RhdGljIHVwZGF0ZUd1aShndWk6IGRhdC5HVUkpOiB2b2lkIHtcbiAgICAgICAgaWYgKGd1aS5fX2NvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICBndWkuX19jb250cm9sbGVycy5mb3JFYWNoKGMgPT4gYy51cGRhdGVEaXNwbGF5KCkpOyAgICBcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3VpLl9fZm9sZGVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgZm9sZGVyTmFtZSBpbiBndWkuX19mb2xkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVHdWkoZ3VpLl9fZm9sZGVyc1tmb2xkZXJOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlQWxsRm9sZGVycyhndWk6IGRhdC5HVUkpIHtcbiAgICAgICAgaWYgKGd1aS5fX2ZvbGRlcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGZvbGRlck5hbWUgaW4gZ3VpLl9fZm9sZGVycykge1xuICAgICAgICAgICAgICAgIGd1aS5yZW1vdmVGb2xkZXIoZ3VpLl9fZm9sZGVyc1tmb2xkZXJOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmFuZG9tUmFuZ2UobWF4OiBudW1iZXIsIG1pbj0wKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcbiAgICB9XG5cbiAgICAvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXG4gICAgLy9cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vY3NzLWNvbG9yLXBhcnNlci1qc1xuICAgIC8vXG4gICAgLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgIC8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gICAgLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbiAgICAvLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiAgICAvLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgIC8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgLy9cbiAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICAgIC8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgIC8vXG4gICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgIC8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgIC8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgIC8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAvLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgIC8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiAgICAvLyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yL1xuICAgIHByaXZhdGUgc3RhdGljIGtDU1NDb2xvclRhYmxlOiBhbnkgPSB7XG4gICAgICAgIFwidHJhbnNwYXJlbnRcIjogWzAsMCwwLDBdLCBcImFsaWNlYmx1ZVwiOiBbMjQwLDI0OCwyNTUsMV0sXG4gICAgICAgIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNSwxXSwgXCJhcXVhXCI6IFswLDI1NSwyNTUsMV0sXG4gICAgICAgIFwiYXF1YW1hcmluZVwiOiBbMTI3LDI1NSwyMTIsMV0sIFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1LDFdLFxuICAgICAgICBcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMCwxXSwgXCJiaXNxdWVcIjogWzI1NSwyMjgsMTk2LDFdLFxuICAgICAgICBcImJsYWNrXCI6IFswLDAsMCwxXSwgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LDIzNSwyMDUsMV0sXG4gICAgICAgIFwiYmx1ZVwiOiBbMCwwLDI1NSwxXSwgXCJibHVldmlvbGV0XCI6IFsxMzgsNDMsMjI2LDFdLFxuICAgICAgICBcImJyb3duXCI6IFsxNjUsNDIsNDIsMV0sIFwiYnVybHl3b29kXCI6IFsyMjIsMTg0LDEzNSwxXSxcbiAgICAgICAgXCJjYWRldGJsdWVcIjogWzk1LDE1OCwxNjAsMV0sIFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwLDFdLFxuICAgICAgICBcImNob2NvbGF0ZVwiOiBbMjEwLDEwNSwzMCwxXSwgXCJjb3JhbFwiOiBbMjU1LDEyNyw4MCwxXSxcbiAgICAgICAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLDE0OSwyMzcsMV0sIFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwLDFdLFxuICAgICAgICBcImNyaW1zb25cIjogWzIyMCwyMCw2MCwxXSwgXCJjeWFuXCI6IFswLDI1NSwyNTUsMV0sXG4gICAgICAgIFwiZGFya2JsdWVcIjogWzAsMCwxMzksMV0sIFwiZGFya2N5YW5cIjogWzAsMTM5LDEzOSwxXSxcbiAgICAgICAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsMTM0LDExLDFdLCBcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgXCJkYXJrZ3JlZW5cIjogWzAsMTAwLDAsMV0sIFwiZGFya2dyZXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICAgICAgICBcImRhcmtraGFraVwiOiBbMTg5LDE4MywxMDcsMV0sIFwiZGFya21hZ2VudGFcIjogWzEzOSwwLDEzOSwxXSxcbiAgICAgICAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsMTA3LDQ3LDFdLCBcImRhcmtvcmFuZ2VcIjogWzI1NSwxNDAsMCwxXSxcbiAgICAgICAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsNTAsMjA0LDFdLCBcImRhcmtyZWRcIjogWzEzOSwwLDAsMV0sXG4gICAgICAgIFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjIsMV0sIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsMTg4LDE0MywxXSxcbiAgICAgICAgXCJkYXJrc2xhdGVibHVlXCI6IFs3Miw2MSwxMzksMV0sIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzksMV0sXG4gICAgICAgIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzksMV0sIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5LDFdLFxuICAgICAgICBcImRhcmt2aW9sZXRcIjogWzE0OCwwLDIxMSwxXSwgXCJkZWVwcGlua1wiOiBbMjU1LDIwLDE0NywxXSxcbiAgICAgICAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwxOTEsMjU1LDFdLCBcImRpbWdyYXlcIjogWzEwNSwxMDUsMTA1LDFdLFxuICAgICAgICBcImRpbWdyZXlcIjogWzEwNSwxMDUsMTA1LDFdLCBcImRvZGdlcmJsdWVcIjogWzMwLDE0NCwyNTUsMV0sXG4gICAgICAgIFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzQsMV0sIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwLDFdLFxuICAgICAgICBcImZvcmVzdGdyZWVuXCI6IFszNCwxMzksMzQsMV0sIFwiZnVjaHNpYVwiOiBbMjU1LDAsMjU1LDFdLFxuICAgICAgICBcImdhaW5zYm9yb1wiOiBbMjIwLDIyMCwyMjAsMV0sIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LDI0OCwyNTUsMV0sXG4gICAgICAgIFwiZ29sZFwiOiBbMjU1LDIxNSwwLDFdLCBcImdvbGRlbnJvZFwiOiBbMjE4LDE2NSwzMiwxXSxcbiAgICAgICAgXCJncmF5XCI6IFsxMjgsMTI4LDEyOCwxXSwgXCJncmVlblwiOiBbMCwxMjgsMCwxXSxcbiAgICAgICAgXCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0NywxXSwgXCJncmV5XCI6IFsxMjgsMTI4LDEyOCwxXSxcbiAgICAgICAgXCJob25leWRld1wiOiBbMjQwLDI1NSwyNDAsMV0sIFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODAsMV0sXG4gICAgICAgIFwiaW5kaWFucmVkXCI6IFsyMDUsOTIsOTIsMV0sIFwiaW5kaWdvXCI6IFs3NSwwLDEzMCwxXSxcbiAgICAgICAgXCJpdm9yeVwiOiBbMjU1LDI1NSwyNDAsMV0sIFwia2hha2lcIjogWzI0MCwyMzAsMTQwLDFdLFxuICAgICAgICBcImxhdmVuZGVyXCI6IFsyMzAsMjMwLDI1MCwxXSwgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NSwxXSxcbiAgICAgICAgXCJsYXduZ3JlZW5cIjogWzEyNCwyNTIsMCwxXSwgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwyNTAsMjA1LDFdLFxuICAgICAgICBcImxpZ2h0Ymx1ZVwiOiBbMTczLDIxNiwyMzAsMV0sIFwibGlnaHRjb3JhbFwiOiBbMjQwLDEyOCwxMjgsMV0sXG4gICAgICAgIFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NSwxXSwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLDI1MCwyMTAsMV0sXG4gICAgICAgIFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodGdyZWVuXCI6IFsxNDQsMjM4LDE0NCwxXSxcbiAgICAgICAgXCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0cGlua1wiOiBbMjU1LDE4MiwxOTMsMV0sXG4gICAgICAgIFwibGlnaHRzYWxtb25cIjogWzI1NSwxNjAsMTIyLDFdLCBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLDE3OCwxNzAsMV0sXG4gICAgICAgIFwibGlnaHRza3libHVlXCI6IFsxMzUsMjA2LDI1MCwxXSwgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTMsMV0sXG4gICAgICAgIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzLDFdLCBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsMTk2LDIyMiwxXSxcbiAgICAgICAgXCJsaWdodHllbGxvd1wiOiBbMjU1LDI1NSwyMjQsMV0sIFwibGltZVwiOiBbMCwyNTUsMCwxXSxcbiAgICAgICAgXCJsaW1lZ3JlZW5cIjogWzUwLDIwNSw1MCwxXSwgXCJsaW5lblwiOiBbMjUwLDI0MCwyMzAsMV0sXG4gICAgICAgIFwibWFnZW50YVwiOiBbMjU1LDAsMjU1LDFdLCBcIm1hcm9vblwiOiBbMTI4LDAsMCwxXSxcbiAgICAgICAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MCwxXSwgXCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1LDFdLFxuICAgICAgICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LDg1LDIxMSwxXSwgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywxMTIsMjE5LDFdLFxuICAgICAgICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwxNzksMTEzLDFdLCBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzgsMV0sXG4gICAgICAgIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsMjUwLDE1NCwxXSwgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLDIwOSwyMDQsMV0sXG4gICAgICAgIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzLDFdLCBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsMjUsMTEyLDFdLFxuICAgICAgICBcIm1pbnRjcmVhbVwiOiBbMjQ1LDI1NSwyNTAsMV0sIFwibWlzdHlyb3NlXCI6IFsyNTUsMjI4LDIyNSwxXSxcbiAgICAgICAgXCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODEsMV0sIFwibmF2YWpvd2hpdGVcIjogWzI1NSwyMjIsMTczLDFdLFxuICAgICAgICBcIm5hdnlcIjogWzAsMCwxMjgsMV0sIFwib2xkbGFjZVwiOiBbMjUzLDI0NSwyMzAsMV0sXG4gICAgICAgIFwib2xpdmVcIjogWzEyOCwxMjgsMCwxXSwgXCJvbGl2ZWRyYWJcIjogWzEwNywxNDIsMzUsMV0sXG4gICAgICAgIFwib3JhbmdlXCI6IFsyNTUsMTY1LDAsMV0sIFwib3JhbmdlcmVkXCI6IFsyNTUsNjksMCwxXSxcbiAgICAgICAgXCJvcmNoaWRcIjogWzIxOCwxMTIsMjE0LDFdLCBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwyMzIsMTcwLDFdLFxuICAgICAgICBcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTIsMV0sIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LDIzOCwyMzgsMV0sXG4gICAgICAgIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LDExMiwxNDcsMV0sIFwicGFwYXlhd2hpcFwiOiBbMjU1LDIzOSwyMTMsMV0sXG4gICAgICAgIFwicGVhY2hwdWZmXCI6IFsyNTUsMjE4LDE4NSwxXSwgXCJwZXJ1XCI6IFsyMDUsMTMzLDYzLDFdLFxuICAgICAgICBcInBpbmtcIjogWzI1NSwxOTIsMjAzLDFdLCBcInBsdW1cIjogWzIyMSwxNjAsMjIxLDFdLFxuICAgICAgICBcInBvd2RlcmJsdWVcIjogWzE3NiwyMjQsMjMwLDFdLCBcInB1cnBsZVwiOiBbMTI4LDAsMTI4LDFdLFxuICAgICAgICBcInJlYmVjY2FwdXJwbGVcIjogWzEwMiw1MSwxNTMsMV0sXG4gICAgICAgIFwicmVkXCI6IFsyNTUsMCwwLDFdLCBcInJvc3licm93blwiOiBbMTg4LDE0MywxNDMsMV0sXG4gICAgICAgIFwicm95YWxibHVlXCI6IFs2NSwxMDUsMjI1LDFdLCBcInNhZGRsZWJyb3duXCI6IFsxMzksNjksMTksMV0sXG4gICAgICAgIFwic2FsbW9uXCI6IFsyNTAsMTI4LDExNCwxXSwgXCJzYW5keWJyb3duXCI6IFsyNDQsMTY0LDk2LDFdLFxuICAgICAgICBcInNlYWdyZWVuXCI6IFs0NiwxMzksODcsMV0sIFwic2Vhc2hlbGxcIjogWzI1NSwyNDUsMjM4LDFdLFxuICAgICAgICBcInNpZW5uYVwiOiBbMTYwLDgyLDQ1LDFdLCBcInNpbHZlclwiOiBbMTkyLDE5MiwxOTIsMV0sXG4gICAgICAgIFwic2t5Ymx1ZVwiOiBbMTM1LDIwNiwyMzUsMV0sIFwic2xhdGVibHVlXCI6IFsxMDYsOTAsMjA1LDFdLFxuICAgICAgICBcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDQsMV0sIFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NCwxXSxcbiAgICAgICAgXCJzbm93XCI6IFsyNTUsMjUwLDI1MCwxXSwgXCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3LDFdLFxuICAgICAgICBcInN0ZWVsYmx1ZVwiOiBbNzAsMTMwLDE4MCwxXSwgXCJ0YW5cIjogWzIxMCwxODAsMTQwLDFdLFxuICAgICAgICBcInRlYWxcIjogWzAsMTI4LDEyOCwxXSwgXCJ0aGlzdGxlXCI6IFsyMTYsMTkxLDIxNiwxXSxcbiAgICAgICAgXCJ0b21hdG9cIjogWzI1NSw5OSw3MSwxXSwgXCJ0dXJxdW9pc2VcIjogWzY0LDIyNCwyMDgsMV0sXG4gICAgICAgIFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOCwxXSwgXCJ3aGVhdFwiOiBbMjQ1LDIyMiwxNzksMV0sXG4gICAgICAgIFwid2hpdGVcIjogWzI1NSwyNTUsMjU1LDFdLCBcIndoaXRlc21va2VcIjogWzI0NSwyNDUsMjQ1LDFdLFxuICAgICAgICBcInllbGxvd1wiOiBbMjU1LDI1NSwwLDFdLCBcInllbGxvd2dyZWVuXCI6IFsxNTQsMjA1LDUwLDFdfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY2xhbXBfY3NzX2J5dGUoaTogbnVtYmVyKTogbnVtYmVyIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjbGFtcF9jc3NfZmxvYXQoZjogbnVtYmVyKTogbnVtYmVyIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gICAgICAgIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHBhcnNlX2Nzc19pbnQoc3RyOiBzdHJpbmcpOiBudW1iZXIgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgICAgIHJldHVybiBVdGlsLmNsYW1wX2Nzc19ieXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gICAgICAgIHJldHVybiBVdGlsLmNsYW1wX2Nzc19ieXRlKHBhcnNlSW50KHN0cikpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHBhcnNlX2Nzc19mbG9hdChzdHI6IHN0cmluZyk6IG51bWJlciB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgICAgICByZXR1cm4gVXRpbC5jbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgICAgICAgcmV0dXJuIFV0aWwuY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3NzX2h1ZV90b19yZ2IobTE6IG51bWJlciwgbTI6IG51bWJlciwgaDogbnVtYmVyKSB7XG4gICAgICAgIGlmIChoIDwgMCkgaCArPSAxO1xuICAgICAgICBlbHNlIGlmIChoID4gMSkgaCAtPSAxO1xuXG4gICAgICAgIGlmIChoICogNiA8IDEpIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICAgICAgICBpZiAoaCAqIDIgPCAxKSByZXR1cm4gbTI7XG4gICAgICAgIGlmIChoICogMyA8IDIpIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gICAgICAgIHJldHVybiBtMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VDU1NDb2xvcihjc3Nfc3RyOiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICAgICAgICB2YXIgc3RyID0gY3NzX3N0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cbiAgICAgICAgaWYgKHN0ciBpbiBVdGlsLmtDU1NDb2xvclRhYmxlKSByZXR1cm4gVXRpbC5rQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG5cbiAgICAgICAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIHJldHVybiBbKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAgICAgICAgIDFdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgICAgICAgICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAgICAgICAgIDFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgICAgICAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgICAgICAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBVdGlsLnBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1V0aWwucGFyc2VfY3NzX2ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwucGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwucGFyc2VfY3NzX2ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBVdGlsLnBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IFV0aWwucGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gVXRpbC5wYXJzZV9jc3NfZmxvYXQocGFyYW1zWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtMSA9IGwgKiAyIC0gbTI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbVXRpbC5jbGFtcF9jc3NfYnl0ZShVdGlsLmNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCsxLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLmNsYW1wX2Nzc19ieXRlKFV0aWwuY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5jbGFtcF9jc3NfYnl0ZShVdGlsLmNzc19odWVfdG9fcmdiKG0xLCBtMiwgaC0xLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB4OiBudW1iZXIsIHB1YmxpYyB5OiBudW1iZXIpIHt9XG5cbiAgICBzdGF0aWMgemVyb1ZlY3RvcigpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihzLCBzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAtcGkgdG8gcGlcbiAgICAgKi9cbiAgICBzdGF0aWMgYW5nbGVCZXR3ZWVuKHYxOiBWZWN0b3IsIHYyOiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICAvLyAtMnBpIHRvIDJwaVxuICAgICAgICBsZXQgYW5nbGVCZXR3ZWVuID0gdjEuYW5nbGUoKSAtIHYyLmFuZ2xlKCk7XG4gICAgICAgIGlmIChhbmdsZUJldHdlZW4gPiBNYXRoLlBJKSB7XG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gLT0gMiAqIE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5nbGVCZXR3ZWVuIDw9IC1NYXRoLlBJKSB7XG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuZ2xlQmV0d2VlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIGEgcG9pbnQgbGllcyB0byB0aGUgbGVmdCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IGxpbmVQb2ludCAgICAgUG9pbnQgb24gdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IGxpbmVEaXJlY3Rpb24gXG4gICAgICogQHBhcmFtICB7VmVjdG9yfSBwb2ludFxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gICAgICAgICAgICAgICB0cnVlIGlmIGxlZnQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0xlZnQobGluZVBvaW50OiBWZWN0b3IsIGxpbmVEaXJlY3Rpb246IFZlY3RvciwgcG9pbnQ6IFZlY3Rvcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBwZXJwZW5kaWN1bGFyVmVjdG9yID0gbmV3IFZlY3RvcihsaW5lRGlyZWN0aW9uLnksIC1saW5lRGlyZWN0aW9uLngpO1xuICAgICAgICByZXR1cm4gcG9pbnQuY2xvbmUoKS5zdWIobGluZVBvaW50KS5kb3QocGVycGVuZGljdWxhclZlY3RvcikgPCAwO1xuICAgIH1cblxuICAgIGFkZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggKz0gdi54O1xuICAgICAgICB0aGlzLnkgKz0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBpbiByYWRpYW5zIHRvIHBvc2l0aXZlIHgtYXhpcyBiZXR3ZWVuIC1waSBhbmQgcGlcbiAgICAgKi9cbiAgICBhbmdsZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cblxuICAgIGNvcHkodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgICB0aGlzLnkgPSB2Lnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNyb3NzKHY6IFZlY3Rvcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG4gICAgfVxuXG4gICAgZGlzdGFuY2VUbyh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xuICAgIH1cblxuICAgIGRpc3RhbmNlVG9TcXVhcmVkICh2OiBWZWN0b3IpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkeCA9IHRoaXMueCAtIHYueFxuICAgICAgICBjb25zdCBkeSA9IHRoaXMueSAtIHYueTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH1cblxuICAgIGRpdmlkZSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICBpZiAodi54ID09PSAwIHx8IHYueSA9PT0gMCkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggLz0gdi54O1xuICAgICAgICB0aGlzLnkgLz0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkaXZpZGVTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiRGl2aXNpb24gYnkgemVyb1wiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzKTtcbiAgICB9XG5cbiAgICBkb3QodjogVmVjdG9yKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcbiAgICB9XG5cbiAgICBlcXVhbHModjogVmVjdG9yKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoKHYueCA9PT0gdGhpcy54KSAmJiAodi55ID09PSB0aGlzLnkpKTtcbiAgICB9XG5cbiAgICBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkpO1xuICAgIH1cblxuICAgIGxlbmd0aFNxKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG4gICAgfVxuXG4gICAgbXVsdGlwbHkodjogVmVjdG9yKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ICo9IHYueDtcbiAgICAgICAgdGhpcy55ICo9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbXVsdGlwbHlTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcbiAgICAgICAgdGhpcy54ICo9IHM7XG4gICAgICAgIHRoaXMueSAqPSBzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBuZWdhdGUoKTogVmVjdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoLTEpO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZSgpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiWmVybyBWZWN0b3JcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICByb3RhdGVBcm91bmQoY2VudGVyOiBWZWN0b3IsIGFuZ2xlOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSlcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnggLSBjZW50ZXIueDtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIGNlbnRlci55O1xuXG4gICAgICAgIHRoaXMueCA9IHggKiBjb3MgLSB5ICogc2luICsgY2VudGVyLng7XG4gICAgICAgIHRoaXMueSA9IHggKiBzaW4gKyB5ICogY29zICsgY2VudGVyLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB2Lng7XG4gICAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0WCh4OiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRZKHk6IG51bWJlcik6IFZlY3RvciB7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldExlbmd0aCAobGVuZ3RoOiBudW1iZXIpOiBWZWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgIH1cblxuICAgIHN1Yih2OiBWZWN0b3IpOiBWZWN0b3Ige1xuICAgICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgICB0aGlzLnkgLT0gdi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iXX0=
